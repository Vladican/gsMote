
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000776e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00802000  0000776e  00007802  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fad  00802138  00802138  0000793a  2**0
                  ALLOC
  3 .stab         000029b8  00000000  00000000  0000793c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2d  00000000  00000000  0000a2f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003e0  00000000  00000000  0000ad28  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c9d0  00000000  00000000  0000b108  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000263a  00000000  00000000  00017ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000054a8  00000000  00000000  0001a112  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bf0  00000000  00000000  0001f5bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000466c  00000000  00000000  000211ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000080b3  00000000  00000000  00025818  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b166  00000000  00000000  0002d8cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000190  00000000  00000000  00188a31  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 86 08 	jmp	0x110c	; 0x110c <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 57 0b 	jmp	0x16ae	; 0x16ae <__vector_16>
      44:	0c 94 2f 0b 	jmp	0x165e	; 0x165e <__vector_17>
      48:	0c 94 07 0b 	jmp	0x160e	; 0x160e <__vector_18>
      4c:	0c 94 c1 0a 	jmp	0x1582	; 0x1582 <__vector_19>
      50:	0c 94 db 06 	jmp	0xdb6	; 0xdb6 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 47 1e 	jmp	0x3c8e	; 0x3c8e <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 2f 18 	jmp	0x305e	; 0x305e <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 34 09 	jmp	0x1268	; 0x1268 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__vector_79>
     140:	0c 94 71 0a 	jmp	0x14e2	; 0x14e2 <__vector_80>
     144:	0c 94 49 0a 	jmp	0x1492	; 0x1492 <__vector_81>
     148:	0c 94 1f 0a 	jmp	0x143e	; 0x143e <__vector_82>
     14c:	0c 94 f9 02 	jmp	0x5f2	; 0x5f2 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 5b 07 	jmp	0xeb6	; 0xeb6 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ee e6       	ldi	r30, 0x6E	; 110
     244:	f7 e7       	ldi	r31, 0x77	; 119
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 33       	cpi	r26, 0x38	; 56
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e3       	ldi	r26, 0x38	; 56
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a5 3e       	cpi	r26, 0xE5	; 229
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 01 02 	call	0x402	; 0x402 <main>
     26a:	0c 94 b5 3b 	jmp	0x776a	; 0x776a <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	6b 01       	movw	r12, r22
     284:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     286:	dc 01       	movw	r26, r24
     288:	cb 01       	movw	r24, r22
     28a:	88 55       	subi	r24, 0x58	; 88
     28c:	92 40       	sbci	r25, 0x02	; 2
     28e:	a0 40       	sbci	r26, 0x00	; 0
     290:	b0 40       	sbci	r27, 0x00	; 0
     292:	89 3e       	cpi	r24, 0xE9	; 233
     294:	2f e3       	ldi	r18, 0x3F	; 63
     296:	92 07       	cpc	r25, r18
     298:	2f e0       	ldi	r18, 0x0F	; 15
     29a:	a2 07       	cpc	r26, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	b2 07       	cpc	r27, r18
     2a0:	08 f0       	brcs	.+2      	; 0x2a4 <StartSerial+0x32>
     2a2:	5c c0       	rjmp	.+184    	; 0x35c <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2a4:	0e 94 c1 1a 	call	0x3582	; 0x3582 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2a8:	e0 e4       	ldi	r30, 0x40	; 64
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2b0:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2b2:	84 e0       	ldi	r24, 0x04	; 4
     2b4:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2b6:	cc 0c       	add	r12, r12
     2b8:	dd 1c       	adc	r13, r13
     2ba:	ee 1c       	adc	r14, r14
     2bc:	ff 1c       	adc	r15, r15
     2be:	cc 0c       	add	r12, r12
     2c0:	dd 1c       	adc	r13, r13
     2c2:	ee 1c       	adc	r14, r14
     2c4:	ff 1c       	adc	r15, r15
     2c6:	c7 01       	movw	r24, r14
     2c8:	b6 01       	movw	r22, r12
     2ca:	66 0f       	add	r22, r22
     2cc:	77 1f       	adc	r23, r23
     2ce:	88 1f       	adc	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	66 0f       	add	r22, r22
     2d4:	77 1f       	adc	r23, r23
     2d6:	88 1f       	adc	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__floatunsisf>
     2de:	9b 01       	movw	r18, r22
     2e0:	ac 01       	movw	r20, r24
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	74 e2       	ldi	r23, 0x24	; 36
     2e6:	84 ef       	ldi	r24, 0xF4	; 244
     2e8:	9b e4       	ldi	r25, 0x4B	; 75
     2ea:	0e 94 6f 36 	call	0x6cde	; 0x6cde <__divsf3>
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	40 e8       	ldi	r20, 0x80	; 128
     2f4:	5f e3       	ldi	r21, 0x3F	; 63
     2f6:	0e 94 0a 36 	call	0x6c14	; 0x6c14 <__subsf3>
     2fa:	c6 2f       	mov	r28, r22
     2fc:	d7 2f       	mov	r29, r23
     2fe:	18 2f       	mov	r17, r24
     300:	09 2f       	mov	r16, r25
     302:	86 2f       	mov	r24, r22
     304:	9d 2f       	mov	r25, r29
     306:	a1 2f       	mov	r26, r17
     308:	b0 2f       	mov	r27, r16
     30a:	bc 01       	movw	r22, r24
     30c:	cd 01       	movw	r24, r26
     30e:	0e 94 d7 36 	call	0x6dae	; 0x6dae <__fixunssfsi>
     312:	6b 01       	movw	r12, r22
     314:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__floatunsisf>
     31e:	9b 01       	movw	r18, r22
     320:	ac 01       	movw	r20, r24
     322:	8c 2f       	mov	r24, r28
     324:	9d 2f       	mov	r25, r29
     326:	a1 2f       	mov	r26, r17
     328:	b0 2f       	mov	r27, r16
     32a:	bc 01       	movw	r22, r24
     32c:	cd 01       	movw	r24, r26
     32e:	0e 94 0a 36 	call	0x6c14	; 0x6c14 <__subsf3>
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	40 e0       	ldi	r20, 0x00	; 0
     338:	5f e3       	ldi	r21, 0x3F	; 63
     33a:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__gesf2>
     33e:	88 23       	and	r24, r24
     340:	1c f0       	brlt	.+6      	; 0x348 <StartSerial+0xd6>
     342:	08 94       	sec
     344:	c1 1c       	adc	r12, r1
     346:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     348:	e0 ea       	ldi	r30, 0xA0	; 160
     34a:	f8 e0       	ldi	r31, 0x08	; 8
     34c:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     34e:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     354:	88 e1       	ldi	r24, 0x18	; 24
     356:	84 83       	std	Z+4, r24	; 0x04
	return true;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	01 c0       	rjmp	.+2      	; 0x35e <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     35c:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	1f 91       	pop	r17
     364:	0f 91       	pop	r16
     366:	ff 90       	pop	r15
     368:	ef 90       	pop	r14
     36a:	df 90       	pop	r13
     36c:	cf 90       	pop	r12
     36e:	08 95       	ret

00000370 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     370:	e0 ea       	ldi	r30, 0xA0	; 160
     372:	f8 e0       	ldi	r31, 0x08	; 8
     374:	91 81       	ldd	r25, Z+1	; 0x01
     376:	95 ff       	sbrs	r25, 5
     378:	fd cf       	rjmp	.-6      	; 0x374 <SerialWriteByte+0x4>
		//wait
	}
	//incremented byte
	USARTC0.DATA = byte;
     37a:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     37e:	08 95       	ret

00000380 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     380:	e0 ea       	ldi	r30, 0xA0	; 160
     382:	f8 e0       	ldi	r31, 0x08	; 8
     384:	81 81       	ldd	r24, Z+1	; 0x01
     386:	88 23       	and	r24, r24
     388:	ec f7       	brge	.-6      	; 0x384 <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     38a:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     38e:	08 95       	ret

00000390 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     390:	8f 92       	push	r8
     392:	9f 92       	push	r9
     394:	af 92       	push	r10
     396:	bf 92       	push	r11
     398:	cf 92       	push	r12
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	6a 01       	movw	r12, r20
     3a6:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     3a8:	41 15       	cp	r20, r1
     3aa:	51 05       	cpc	r21, r1
     3ac:	61 05       	cpc	r22, r1
     3ae:	71 05       	cpc	r23, r1
     3b0:	91 f0       	breq	.+36     	; 0x3d6 <SerialWriteBuffer+0x46>
     3b2:	c8 2f       	mov	r28, r24
     3b4:	d9 2f       	mov	r29, r25
     3b6:	88 24       	eor	r8, r8
     3b8:	99 24       	eor	r9, r9
     3ba:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     3bc:	89 91       	ld	r24, Y+
     3be:	0e 94 b8 01 	call	0x370	; 0x370 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     3c2:	08 94       	sec
     3c4:	81 1c       	adc	r8, r1
     3c6:	91 1c       	adc	r9, r1
     3c8:	a1 1c       	adc	r10, r1
     3ca:	b1 1c       	adc	r11, r1
     3cc:	8c 14       	cp	r8, r12
     3ce:	9d 04       	cpc	r9, r13
     3d0:	ae 04       	cpc	r10, r14
     3d2:	bf 04       	cpc	r11, r15
     3d4:	99 f7       	brne	.-26     	; 0x3bc <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	ff 90       	pop	r15
     3dc:	ef 90       	pop	r14
     3de:	df 90       	pop	r13
     3e0:	cf 90       	pop	r12
     3e2:	bf 90       	pop	r11
     3e4:	af 90       	pop	r10
     3e6:	9f 90       	pop	r9
     3e8:	8f 90       	pop	r8
     3ea:	08 95       	ret

000003ec <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     3ec:	e0 ea       	ldi	r30, 0xA0	; 160
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	84 81       	ldd	r24, Z+4	; 0x04
     3f2:	87 7e       	andi	r24, 0xE7	; 231
     3f4:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     3f6:	e0 e4       	ldi	r30, 0x40	; 64
     3f8:	f6 e0       	ldi	r31, 0x06	; 6
     3fa:	88 e0       	ldi	r24, 0x08	; 8
     3fc:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     3fe:	82 83       	std	Z+2, r24	; 0x02
     400:	08 95       	ret

00000402 <main>:
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
	uint32_t samples = 0;
	DataAvailable = 0;
     402:	10 92 d5 21 	sts	0x21D5, r1
	ADC_Sampling_Finished = 1;
     406:	81 e0       	ldi	r24, 0x01	; 1
     408:	80 93 d5 50 	sts	0x50D5, r24
	chb_init();
     40c:	0e 94 e6 13 	call	0x27cc	; 0x27cc <chb_init>
	chb_set_channel(1);
     410:	81 e0       	ldi	r24, 0x01	; 1
     412:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <chb_set_channel>
	chb_set_short_addr(0x0002);
     416:	82 e0       	ldi	r24, 0x02	; 2
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     41e:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <chb_get_pcb>
     422:	ec 01       	movw	r28, r24

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
     424:	0f 2e       	mov	r0, r31
     426:	f8 ee       	ldi	r31, 0xE8	; 232
     428:	cf 2e       	mov	r12, r31
     42a:	f3 e0       	ldi	r31, 0x03	; 3
     42c:	df 2e       	mov	r13, r31
     42e:	f0 2d       	mov	r31, r0
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     430:	99 24       	eor	r9, r9
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
			//read the data
			length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
     432:	0f 2e       	mov	r0, r31
     434:	ff ed       	ldi	r31, 0xDF	; 223
     436:	ef 2e       	mov	r14, r31
     438:	f3 e2       	ldi	r31, 0x23	; 35
     43a:	ff 2e       	mov	r15, r31
     43c:	f0 2d       	mov	r31, r0
						CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
					}						
					break;
				case 'g':
					//set gain to what is specified
					switch(FRAMReadBuffer[1]){
     43e:	0f 2e       	mov	r0, r31
     440:	f0 ee       	ldi	r31, 0xE0	; 224
     442:	af 2e       	mov	r10, r31
     444:	f3 e2       	ldi	r31, 0x23	; 35
     446:	bf 2e       	mov	r11, r31
     448:	f0 2d       	mov	r31, r0
	chb_init();
	chb_set_channel(1);
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
     44a:	8b 81       	ldd	r24, Y+3	; 0x03
     44c:	88 23       	and	r24, r24
     44e:	09 f4       	brne	.+2      	; 0x452 <main+0x50>
     450:	74 c0       	rjmp	.+232    	; 0x53a <main+0x138>
			//read the data
			length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
     452:	c7 01       	movw	r24, r14
     454:	0e 94 be 14 	call	0x297c	; 0x297c <chb_read>
			
			if(length == 1){
     458:	81 30       	cpi	r24, 0x01	; 1
     45a:	09 f0       	breq	.+2      	; 0x45e <main+0x5c>
     45c:	6e c0       	rjmp	.+220    	; 0x53a <main+0x138>
				switch ( FRAMReadBuffer[0])
     45e:	f7 01       	movw	r30, r14
     460:	80 81       	ld	r24, Z
     462:	87 36       	cpi	r24, 0x67	; 103
     464:	d1 f0       	breq	.+52     	; 0x49a <main+0x98>
     466:	88 36       	cpi	r24, 0x68	; 104
     468:	20 f4       	brcc	.+8      	; 0x472 <main+0x70>
     46a:	86 36       	cpi	r24, 0x66	; 102
     46c:	09 f0       	breq	.+2      	; 0x470 <main+0x6e>
     46e:	65 c0       	rjmp	.+202    	; 0x53a <main+0x138>
     470:	57 c0       	rjmp	.+174    	; 0x520 <main+0x11e>
     472:	83 37       	cpi	r24, 0x73	; 115
     474:	21 f0       	breq	.+8      	; 0x47e <main+0x7c>
     476:	84 37       	cpi	r24, 0x74	; 116
     478:	09 f0       	breq	.+2      	; 0x47c <main+0x7a>
     47a:	5f c0       	rjmp	.+190    	; 0x53a <main+0x138>
     47c:	55 c0       	rjmp	.+170    	; 0x528 <main+0x126>
				{
				case 's':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     47e:	80 91 d5 50 	lds	r24, 0x50D5
     482:	88 23       	and	r24, r24
     484:	09 f4       	brne	.+2      	; 0x488 <main+0x86>
     486:	59 c0       	rjmp	.+178    	; 0x53a <main+0x138>
						CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     488:	80 e0       	ldi	r24, 0x00	; 0
     48a:	69 2d       	mov	r22, r9
     48c:	a6 01       	movw	r20, r12
     48e:	2c e1       	ldi	r18, 0x1C	; 28
     490:	37 e0       	ldi	r19, 0x07	; 7
     492:	87 01       	movw	r16, r14
     494:	0e 94 fe 12 	call	0x25fc	; 0x25fc <CO_collectADC>
     498:	50 c0       	rjmp	.+160    	; 0x53a <main+0x138>
					}						
					break;
				case 'g':
					//set gain to what is specified
					switch(FRAMReadBuffer[1]){
     49a:	f5 01       	movw	r30, r10
     49c:	80 81       	ld	r24, Z
     49e:	88 30       	cpi	r24, 0x08	; 8
     4a0:	e1 f0       	breq	.+56     	; 0x4da <main+0xd8>
     4a2:	89 30       	cpi	r24, 0x09	; 9
     4a4:	40 f4       	brcc	.+16     	; 0x4b6 <main+0xb4>
     4a6:	82 30       	cpi	r24, 0x02	; 2
     4a8:	09 f4       	brne	.+2      	; 0x4ac <main+0xaa>
     4aa:	45 c0       	rjmp	.+138    	; 0x536 <main+0x134>
     4ac:	84 30       	cpi	r24, 0x04	; 4
     4ae:	89 f0       	breq	.+34     	; 0x4d2 <main+0xd0>
     4b0:	81 30       	cpi	r24, 0x01	; 1
     4b2:	59 f5       	brne	.+86     	; 0x50a <main+0x108>
     4b4:	0c c0       	rjmp	.+24     	; 0x4ce <main+0xcc>
     4b6:	80 32       	cpi	r24, 0x20	; 32
     4b8:	c9 f0       	breq	.+50     	; 0x4ec <main+0xea>
     4ba:	81 32       	cpi	r24, 0x21	; 33
     4bc:	18 f4       	brcc	.+6      	; 0x4c4 <main+0xc2>
     4be:	80 31       	cpi	r24, 0x10	; 16
     4c0:	21 f5       	brne	.+72     	; 0x50a <main+0x108>
     4c2:	10 c0       	rjmp	.+32     	; 0x4e4 <main+0xe2>
     4c4:	80 34       	cpi	r24, 0x40	; 64
     4c6:	b9 f0       	breq	.+46     	; 0x4f6 <main+0xf4>
     4c8:	80 38       	cpi	r24, 0x80	; 128
     4ca:	f9 f4       	brne	.+62     	; 0x50a <main+0x108>
     4cc:	19 c0       	rjmp	.+50     	; 0x500 <main+0xfe>
						case 1:
							gain = GAIN_1_gc;
     4ce:	99 24       	eor	r9, r9
     4d0:	34 c0       	rjmp	.+104    	; 0x53a <main+0x138>
							break;
						case 2:
							gain = GAIN_2_gc;
							break;
						case 4:
							gain = GAIN_4_gc;
     4d2:	99 24       	eor	r9, r9
     4d4:	68 94       	set
     4d6:	91 f8       	bld	r9, 1
							break;
     4d8:	30 c0       	rjmp	.+96     	; 0x53a <main+0x138>
						case 8:
							gain = GAIN_8_gc;
     4da:	0f 2e       	mov	r0, r31
     4dc:	f3 e0       	ldi	r31, 0x03	; 3
     4de:	9f 2e       	mov	r9, r31
     4e0:	f0 2d       	mov	r31, r0
							break;
     4e2:	2b c0       	rjmp	.+86     	; 0x53a <main+0x138>
						case 16:
							gain = GAIN_16_gc;
     4e4:	99 24       	eor	r9, r9
     4e6:	68 94       	set
     4e8:	92 f8       	bld	r9, 2
							break;
     4ea:	27 c0       	rjmp	.+78     	; 0x53a <main+0x138>
						case 32:
							gain = GAIN_32_gc;
     4ec:	0f 2e       	mov	r0, r31
     4ee:	f5 e0       	ldi	r31, 0x05	; 5
     4f0:	9f 2e       	mov	r9, r31
     4f2:	f0 2d       	mov	r31, r0
							break;
     4f4:	22 c0       	rjmp	.+68     	; 0x53a <main+0x138>
						case 64:
							gain = GAIN_64_gc;
     4f6:	0f 2e       	mov	r0, r31
     4f8:	f6 e0       	ldi	r31, 0x06	; 6
     4fa:	9f 2e       	mov	r9, r31
     4fc:	f0 2d       	mov	r31, r0
							break;
     4fe:	1d c0       	rjmp	.+58     	; 0x53a <main+0x138>
						case 128:
							gain = GAIN_128_gc;
     500:	0f 2e       	mov	r0, r31
     502:	f7 e0       	ldi	r31, 0x07	; 7
     504:	9f 2e       	mov	r9, r31
     506:	f0 2d       	mov	r31, r0
							break;
     508:	18 c0       	rjmp	.+48     	; 0x53a <main+0x138>
						default:
							chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
     50a:	80 e0       	ldi	r24, 0x00	; 0
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	60 e0       	ldi	r22, 0x00	; 0
     510:	70 e2       	ldi	r23, 0x20	; 32
     512:	2c e0       	ldi	r18, 0x0C	; 12
     514:	30 e0       	ldi	r19, 0x00	; 0
     516:	40 e0       	ldi	r20, 0x00	; 0
     518:	50 e0       	ldi	r21, 0x00	; 0
     51a:	0e 94 fb 13 	call	0x27f6	; 0x27f6 <chb_write>
							break;
     51e:	0d c0       	rjmp	.+26     	; 0x53a <main+0x138>
					}					
					break;
				case 'f':
					//set sampling frequency to what is specified
					freq = *(uint16_t*)(FRAMReadBuffer+1);
     520:	f7 01       	movw	r30, r14
     522:	c1 80       	ldd	r12, Z+1	; 0x01
     524:	d2 80       	ldd	r13, Z+2	; 0x02
					break;
     526:	09 c0       	rjmp	.+18     	; 0x53a <main+0x138>
				case 't':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     528:	80 91 d5 50 	lds	r24, 0x50D5
     52c:	88 23       	and	r24, r24
     52e:	29 f4       	brne	.+10     	; 0x53a <main+0x138>
						ADC_Stop_Sampling();
     530:	0e 94 21 07 	call	0xe42	; 0xe42 <ADC_Stop_Sampling>
     534:	02 c0       	rjmp	.+4      	; 0x53a <main+0x138>
					switch(FRAMReadBuffer[1]){
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     536:	99 24       	eor	r9, r9
     538:	93 94       	inc	r9
				}	
			}			
		}		
		//if all data collected or ADC was stopped while sampling, send collected data to base station
		//samples = ADC_Get_Num_Samples();
		if(ADC_Sampling_Finished && DataAvailable){
     53a:	80 91 d5 50 	lds	r24, 0x50D5
     53e:	88 23       	and	r24, r24
     540:	09 f4       	brne	.+2      	; 0x544 <main+0x142>
     542:	83 cf       	rjmp	.-250    	; 0x44a <main+0x48>
     544:	80 91 d5 21 	lds	r24, 0x21D5
     548:	88 23       	and	r24, r24
     54a:	09 f4       	brne	.+2      	; 0x54e <main+0x14c>
     54c:	7e cf       	rjmp	.-260    	; 0x44a <main+0x48>
			//get number of data points collected
			samples = ADC_Get_Num_Samples();
     54e:	0e 94 42 07 	call	0xe84	; 0xe84 <ADC_Get_Num_Samples>
     552:	a0 e0       	ldi	r26, 0x00	; 0
     554:	b0 e0       	ldi	r27, 0x00	; 0
			if(samples > 0) chb_write(0x0000,FRAMReadBuffer,samples*4);
     556:	00 97       	sbiw	r24, 0x00	; 0
     558:	a1 05       	cpc	r26, r1
     55a:	b1 05       	cpc	r27, r1
     55c:	79 f0       	breq	.+30     	; 0x57c <main+0x17a>
     55e:	9c 01       	movw	r18, r24
     560:	ad 01       	movw	r20, r26
     562:	22 0f       	add	r18, r18
     564:	33 1f       	adc	r19, r19
     566:	44 1f       	adc	r20, r20
     568:	55 1f       	adc	r21, r21
     56a:	22 0f       	add	r18, r18
     56c:	33 1f       	adc	r19, r19
     56e:	44 1f       	adc	r20, r20
     570:	55 1f       	adc	r21, r21
     572:	80 e0       	ldi	r24, 0x00	; 0
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	b7 01       	movw	r22, r14
     578:	0e 94 fb 13 	call	0x27f6	; 0x27f6 <chb_write>
			DataAvailable = 0;
     57c:	10 92 d5 21 	sts	0x21D5, r1
     580:	64 cf       	rjmp	.-312    	; 0x44a <main+0x48>

00000582 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     582:	0f 93       	push	r16
     584:	1f 93       	push	r17
     586:	cf 93       	push	r28
     588:	8c 01       	movw	r16, r24
	moteID = 1;
     58a:	c1 e0       	ldi	r28, 0x01	; 1
     58c:	c0 93 d0 50 	sts	0x50D0, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     590:	83 e0       	ldi	r24, 0x03	; 3
     592:	80 93 5e 40 	sts	0x405E, r24
	chb_init();
     596:	0e 94 e6 13 	call	0x27cc	; 0x27cc <chb_init>
	chb_set_short_addr(moteID);
     59a:	80 91 d0 50 	lds	r24, 0x50D0
     59e:	90 e0       	ldi	r25, 0x00	; 0
     5a0:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     5a4:	88 ec       	ldi	r24, 0xC8	; 200
     5a6:	e0 e8       	ldi	r30, 0x80	; 128
     5a8:	f1 e0       	ldi	r31, 0x01	; 1
     5aa:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     5ac:	e0 e4       	ldi	r30, 0x40	; 64
     5ae:	f9 e0       	ldi	r31, 0x09	; 9
     5b0:	89 e0       	ldi	r24, 0x09	; 9
     5b2:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     5b4:	82 e0       	ldi	r24, 0x02	; 2
     5b6:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     5b8:	24 ef       	ldi	r18, 0xF4	; 244
     5ba:	31 e0       	ldi	r19, 0x01	; 1
     5bc:	02 9f       	mul	r16, r18
     5be:	c0 01       	movw	r24, r0
     5c0:	03 9f       	mul	r16, r19
     5c2:	90 0d       	add	r25, r0
     5c4:	12 9f       	mul	r17, r18
     5c6:	90 0d       	add	r25, r0
     5c8:	11 24       	eor	r1, r1
     5ca:	86 a3       	lds	r24, 0x56
     5cc:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     5ce:	e0 e4       	ldi	r30, 0x40	; 64
     5d0:	f8 e0       	ldi	r31, 0x08	; 8
     5d2:	80 e0       	ldi	r24, 0x00	; 0
     5d4:	9a ef       	ldi	r25, 0xFA	; 250
     5d6:	86 a3       	lds	r24, 0x56
     5d8:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     5da:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     5dc:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     5de:	e0 ea       	ldi	r30, 0xA0	; 160
     5e0:	f0 e0       	ldi	r31, 0x00	; 0
     5e2:	82 81       	ldd	r24, Z+2	; 0x02
     5e4:	87 60       	ori	r24, 0x07	; 7
     5e6:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     5e8:	78 94       	sei
}
     5ea:	cf 91       	pop	r28
     5ec:	1f 91       	pop	r17
     5ee:	0f 91       	pop	r16
     5f0:	08 95       	ret

000005f2 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     5f2:	78 94       	sei
     5f4:	1f 92       	push	r1
     5f6:	0f 92       	push	r0
     5f8:	0f b6       	in	r0, 0x3f	; 63
     5fa:	0f 92       	push	r0
     5fc:	0b b6       	in	r0, 0x3b	; 59
     5fe:	0f 92       	push	r0
     600:	11 24       	eor	r1, r1
     602:	ef 92       	push	r14
     604:	ff 92       	push	r15
     606:	0f 93       	push	r16
     608:	1f 93       	push	r17
     60a:	2f 93       	push	r18
     60c:	3f 93       	push	r19
     60e:	4f 93       	push	r20
     610:	5f 93       	push	r21
     612:	6f 93       	push	r22
     614:	7f 93       	push	r23
     616:	8f 93       	push	r24
     618:	9f 93       	push	r25
     61a:	af 93       	push	r26
     61c:	bf 93       	push	r27
     61e:	ef 93       	push	r30
     620:	ff 93       	push	r31
     622:	cf 93       	push	r28
     624:	df 93       	push	r29
     626:	cd b7       	in	r28, 0x3d	; 61
     628:	de b7       	in	r29, 0x3e	; 62
     62a:	28 97       	sbiw	r28, 0x08	; 8
     62c:	cd bf       	out	0x3d, r28	; 61
     62e:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     630:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
     634:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     638:	82 e0       	ldi	r24, 0x02	; 2
     63a:	80 93 5e 40 	sts	0x405E, r24
	char message[8];
	strcpy(message,"reset");
     63e:	de 01       	movw	r26, r28
     640:	11 96       	adiw	r26, 0x01	; 1
     642:	ed e0       	ldi	r30, 0x0D	; 13
     644:	f0 e2       	ldi	r31, 0x20	; 32
     646:	86 e0       	ldi	r24, 0x06	; 6
     648:	01 90       	ld	r0, Z+
     64a:	0d 92       	st	X+, r0
     64c:	81 50       	subi	r24, 0x01	; 1
     64e:	e1 f7       	brne	.-8      	; 0x648 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
     650:	07 ed       	ldi	r16, 0xD7	; 215
     652:	10 e5       	ldi	r17, 0x50	; 80
     654:	80 91 d0 50 	lds	r24, 0x50D0
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	b8 01       	movw	r22, r16
     65c:	4a e0       	ldi	r20, 0x0A	; 10
     65e:	50 e0       	ldi	r21, 0x00	; 0
     660:	0e 94 9f 38 	call	0x713e	; 0x713e <itoa>
	strcat(message,buff);
     664:	7e 01       	movw	r14, r28
     666:	08 94       	sec
     668:	e1 1c       	adc	r14, r1
     66a:	f1 1c       	adc	r15, r1
     66c:	c7 01       	movw	r24, r14
     66e:	b8 01       	movw	r22, r16
     670:	0e 94 86 38 	call	0x710c	; 0x710c <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     674:	0e 94 52 07 	call	0xea4	; 0xea4 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     678:	f7 01       	movw	r30, r14
     67a:	01 90       	ld	r0, Z+
     67c:	00 20       	and	r0, r0
     67e:	e9 f7       	brne	.-6      	; 0x67a <__vector_83+0x88>
     680:	31 97       	sbiw	r30, 0x01	; 1
     682:	ee 19       	sub	r30, r14
     684:	ff 09       	sbc	r31, r15
     686:	9f 01       	movw	r18, r30
     688:	40 e0       	ldi	r20, 0x00	; 0
     68a:	50 e0       	ldi	r21, 0x00	; 0
     68c:	80 e0       	ldi	r24, 0x00	; 0
     68e:	90 e0       	ldi	r25, 0x00	; 0
     690:	b7 01       	movw	r22, r14
     692:	0e 94 fb 13 	call	0x27f6	; 0x27f6 <chb_write>
}	
     696:	28 96       	adiw	r28, 0x08	; 8
     698:	cd bf       	out	0x3d, r28	; 61
     69a:	de bf       	out	0x3e, r29	; 62
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	ff 91       	pop	r31
     6a2:	ef 91       	pop	r30
     6a4:	bf 91       	pop	r27
     6a6:	af 91       	pop	r26
     6a8:	9f 91       	pop	r25
     6aa:	8f 91       	pop	r24
     6ac:	7f 91       	pop	r23
     6ae:	6f 91       	pop	r22
     6b0:	5f 91       	pop	r21
     6b2:	4f 91       	pop	r20
     6b4:	3f 91       	pop	r19
     6b6:	2f 91       	pop	r18
     6b8:	1f 91       	pop	r17
     6ba:	0f 91       	pop	r16
     6bc:	ff 90       	pop	r15
     6be:	ef 90       	pop	r14
     6c0:	0f 90       	pop	r0
     6c2:	0b be       	out	0x3b, r0	; 59
     6c4:	0f 90       	pop	r0
     6c6:	0f be       	out	0x3f, r0	; 63
     6c8:	0f 90       	pop	r0
     6ca:	1f 90       	pop	r1
     6cc:	18 95       	reti

000006ce <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     6ce:	cf 93       	push	r28
     6d0:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     6d2:	21 e0       	ldi	r18, 0x01	; 1
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	a9 01       	movw	r20, r18
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <set_ampGain+0x10>
     6da:	44 0f       	add	r20, r20
     6dc:	55 1f       	adc	r21, r21
     6de:	8a 95       	dec	r24
     6e0:	e2 f7       	brpl	.-8      	; 0x6da <set_ampGain+0xc>
     6e2:	ca 01       	movw	r24, r20
     6e4:	61 e0       	ldi	r22, 0x01	; 1
     6e6:	0e 94 82 1b 	call	0x3704	; 0x3704 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     6ea:	c0 ff       	sbrs	r28, 0
     6ec:	05 c0       	rjmp	.+10     	; 0x6f8 <set_ampGain+0x2a>
     6ee:	80 e4       	ldi	r24, 0x40	; 64
     6f0:	e0 e0       	ldi	r30, 0x00	; 0
     6f2:	f6 e0       	ldi	r31, 0x06	; 6
     6f4:	85 83       	std	Z+5, r24	; 0x05
     6f6:	04 c0       	rjmp	.+8      	; 0x700 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
     6f8:	80 e4       	ldi	r24, 0x40	; 64
     6fa:	e0 e0       	ldi	r30, 0x00	; 0
     6fc:	f6 e0       	ldi	r31, 0x06	; 6
     6fe:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     700:	c1 ff       	sbrs	r28, 1
     702:	05 c0       	rjmp	.+10     	; 0x70e <set_ampGain+0x40>
     704:	82 e0       	ldi	r24, 0x02	; 2
     706:	e0 e2       	ldi	r30, 0x20	; 32
     708:	f6 e0       	ldi	r31, 0x06	; 6
     70a:	85 83       	std	Z+5, r24	; 0x05
     70c:	04 c0       	rjmp	.+8      	; 0x716 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
     70e:	82 e0       	ldi	r24, 0x02	; 2
     710:	e0 e2       	ldi	r30, 0x20	; 32
     712:	f6 e0       	ldi	r31, 0x06	; 6
     714:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     716:	c2 ff       	sbrs	r28, 2
     718:	05 c0       	rjmp	.+10     	; 0x724 <set_ampGain+0x56>
     71a:	84 e0       	ldi	r24, 0x04	; 4
     71c:	e0 e2       	ldi	r30, 0x20	; 32
     71e:	f6 e0       	ldi	r31, 0x06	; 6
     720:	85 83       	std	Z+5, r24	; 0x05
     722:	04 c0       	rjmp	.+8      	; 0x72c <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
     724:	84 e0       	ldi	r24, 0x04	; 4
     726:	e0 e2       	ldi	r30, 0x20	; 32
     728:	f6 e0       	ldi	r31, 0x06	; 6
     72a:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     72c:	5a e0       	ldi	r21, 0x0A	; 10
     72e:	5a 95       	dec	r21
     730:	f1 f7       	brne	.-4      	; 0x72e <set_ampGain+0x60>
     732:	00 c0       	rjmp	.+0      	; 0x734 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     734:	8f ef       	ldi	r24, 0xFF	; 255
     736:	61 e0       	ldi	r22, 0x01	; 1
     738:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     73c:	cf 91       	pop	r28
     73e:	08 95       	ret

00000740 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     740:	cf 93       	push	r28
     742:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     744:	c8 2f       	mov	r28, r24
     746:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     748:	d8 2f       	mov	r29, r24
     74a:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     74c:	28 2f       	mov	r18, r24
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	a9 01       	movw	r20, r18
     752:	45 70       	andi	r20, 0x05	; 5
     754:	50 70       	andi	r21, 0x00	; 0
     756:	41 15       	cp	r20, r1
     758:	51 05       	cpc	r21, r1
     75a:	49 f0       	breq	.+18     	; 0x76e <set_filter+0x2e>
     75c:	90 91 81 50 	lds	r25, 0x5081
     760:	48 2f       	mov	r20, r24
     762:	42 95       	swap	r20
     764:	4f 70       	andi	r20, 0x0F	; 15
     766:	90 7f       	andi	r25, 0xF0	; 240
     768:	94 2b       	or	r25, r20
     76a:	90 93 81 50 	sts	0x5081, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     76e:	2a 70       	andi	r18, 0x0A	; 10
     770:	30 70       	andi	r19, 0x00	; 0
     772:	21 15       	cp	r18, r1
     774:	31 05       	cpc	r19, r1
     776:	39 f0       	breq	.+14     	; 0x786 <set_filter+0x46>
     778:	90 91 81 50 	lds	r25, 0x5081
     77c:	80 7f       	andi	r24, 0xF0	; 240
     77e:	9f 70       	andi	r25, 0x0F	; 15
     780:	89 2b       	or	r24, r25
     782:	80 93 81 50 	sts	0x5081, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     786:	84 e0       	ldi	r24, 0x04	; 4
     788:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     78c:	80 91 81 50 	lds	r24, 0x5081
     790:	80 93 65 50 	sts	0x5065, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     794:	cc 23       	and	r28, r28
     796:	19 f0       	breq	.+6      	; 0x79e <set_filter+0x5e>
     798:	81 e0       	ldi	r24, 0x01	; 1
     79a:	0e 94 31 1b 	call	0x3662	; 0x3662 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     79e:	dd 23       	and	r29, r29
     7a0:	19 f0       	breq	.+6      	; 0x7a8 <set_filter+0x68>
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	0e 94 3d 1b 	call	0x367a	; 0x367a <upperMuxCS>

	SPICS(TRUE);
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     7ae:	8f ef       	ldi	r24, 0xFF	; 255
     7b0:	e0 ec       	ldi	r30, 0xC0	; 192
     7b2:	f8 e0       	ldi	r31, 0x08	; 8
     7b4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     7b6:	82 81       	ldd	r24, Z+2	; 0x02
     7b8:	88 23       	and	r24, r24
     7ba:	ec f7       	brge	.-6      	; 0x7b6 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     7bc:	e0 ec       	ldi	r30, 0xC0	; 192
     7be:	f8 e0       	ldi	r31, 0x08	; 8
     7c0:	83 81       	ldd	r24, Z+3	; 0x03
     7c2:	80 93 71 50 	sts	0x5071, r24

	nop();
     7c6:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     7c8:	a1 e7       	ldi	r26, 0x71	; 113
     7ca:	b0 e5       	ldi	r27, 0x50	; 80
     7cc:	1c 97       	sbiw	r26, 0x0c	; 12
     7ce:	8c 91       	ld	r24, X
     7d0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     7d2:	82 81       	ldd	r24, Z+2	; 0x02
     7d4:	88 23       	and	r24, r24
     7d6:	ec f7       	brge	.-6      	; 0x7d2 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     7d8:	e0 ec       	ldi	r30, 0xC0	; 192
     7da:	f8 e0       	ldi	r31, 0x08	; 8
     7dc:	83 81       	ldd	r24, Z+3	; 0x03
     7de:	80 93 71 50 	sts	0x5071, r24
	SPICS(FALSE);
     7e2:	80 e0       	ldi	r24, 0x00	; 0
     7e4:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     7e8:	cc 23       	and	r28, r28
     7ea:	19 f0       	breq	.+6      	; 0x7f2 <set_filter+0xb2>
     7ec:	80 e0       	ldi	r24, 0x00	; 0
     7ee:	0e 94 31 1b 	call	0x3662	; 0x3662 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     7f2:	dd 23       	and	r29, r29
     7f4:	19 f0       	breq	.+6      	; 0x7fc <set_filter+0xbc>
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	0e 94 3d 1b 	call	0x367a	; 0x367a <upperMuxCS>
	SPIDisable();
     7fc:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
}
     800:	df 91       	pop	r29
     802:	cf 91       	pop	r28
     804:	08 95       	ret

00000806 <ADCPower>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void ADCPower(uint8_t on) {
     806:	0f 93       	push	r16
     808:	1f 93       	push	r17
     80a:	cf 93       	push	r28
     80c:	df 93       	push	r29
	
	if (on) {
     80e:	88 23       	and	r24, r24
     810:	09 f4       	brne	.+2      	; 0x814 <ADCPower+0xe>
     812:	46 c0       	rjmp	.+140    	; 0x8a0 <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     814:	00 e0       	ldi	r16, 0x00	; 0
     816:	16 e0       	ldi	r17, 0x06	; 6
     818:	8e ed       	ldi	r24, 0xDE	; 222
     81a:	d8 01       	movw	r26, r16
     81c:	11 96       	adiw	r26, 0x01	; 1
     81e:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     820:	c0 e2       	ldi	r28, 0x20	; 32
     822:	d6 e0       	ldi	r29, 0x06	; 6
     824:	4e e0       	ldi	r20, 0x0E	; 14
     826:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     828:	e0 e4       	ldi	r30, 0x40	; 64
     82a:	f6 e0       	ldi	r31, 0x06	; 6
     82c:	63 e0       	ldi	r22, 0x03	; 3
     82e:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     830:	80 e8       	ldi	r24, 0x80	; 128
     832:	96 e0       	ldi	r25, 0x06	; 6
     834:	50 e1       	ldi	r21, 0x10	; 16
     836:	dc 01       	movw	r26, r24
     838:	11 96       	adiw	r26, 0x01	; 1
     83a:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     83c:	20 ea       	ldi	r18, 0xA0	; 160
     83e:	36 e0       	ldi	r19, 0x06	; 6
     840:	d9 01       	movw	r26, r18
     842:	11 96       	adiw	r26, 0x01	; 1
     844:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     846:	7e e9       	ldi	r23, 0x9E	; 158
     848:	d8 01       	movw	r26, r16
     84a:	15 96       	adiw	r26, 0x05	; 5
     84c:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     84e:	78 e0       	ldi	r23, 0x08	; 8
     850:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     852:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     854:	ec 01       	movw	r28, r24
     856:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     858:	d9 01       	movw	r26, r18
     85a:	15 96       	adiw	r26, 0x05	; 5
     85c:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     85e:	10 92 81 50 	sts	0x5081, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     862:	8f ef       	ldi	r24, 0xFF	; 255
     864:	93 ec       	ldi	r25, 0xC3	; 195
     866:	a9 e0       	ldi	r26, 0x09	; 9
     868:	81 50       	subi	r24, 0x01	; 1
     86a:	90 40       	sbci	r25, 0x00	; 0
     86c:	a0 40       	sbci	r26, 0x00	; 0
     86e:	e1 f7       	brne	.-8      	; 0x868 <ADCPower+0x62>
     870:	00 c0       	rjmp	.+0      	; 0x872 <ADCPower+0x6c>
     872:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     874:	80 e4       	ldi	r24, 0x40	; 64
     876:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     878:	10 92 82 50 	sts	0x5082, r1
     87c:	10 92 d6 50 	sts	0x50D6, r1
     880:	10 92 d6 23 	sts	0x23D6, r1
     884:	10 92 7a 50 	sts	0x507A, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     888:	8f ef       	ldi	r24, 0xFF	; 255
     88a:	61 e0       	ldi	r22, 0x01	; 1
     88c:	0e 94 86 1c 	call	0x390c	; 0x390c <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     890:	8f ef       	ldi	r24, 0xFF	; 255
     892:	61 e0       	ldi	r22, 0x01	; 1
     894:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     898:	8f ef       	ldi	r24, 0xFF	; 255
     89a:	0e 94 a0 03 	call	0x740	; 0x740 <set_filter>
     89e:	32 c0       	rjmp	.+100    	; 0x904 <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     8a0:	00 e0       	ldi	r16, 0x00	; 0
     8a2:	16 e0       	ldi	r17, 0x06	; 6
     8a4:	7e ed       	ldi	r23, 0xDE	; 222
     8a6:	d8 01       	movw	r26, r16
     8a8:	16 96       	adiw	r26, 0x06	; 6
     8aa:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     8ac:	a0 e2       	ldi	r26, 0x20	; 32
     8ae:	b6 e0       	ldi	r27, 0x06	; 6
     8b0:	4e e0       	ldi	r20, 0x0E	; 14
     8b2:	16 96       	adiw	r26, 0x06	; 6
     8b4:	4c 93       	st	X, r20
     8b6:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     8b8:	20 e4       	ldi	r18, 0x40	; 64
     8ba:	36 e0       	ldi	r19, 0x06	; 6
     8bc:	63 e0       	ldi	r22, 0x03	; 3
     8be:	e9 01       	movw	r28, r18
     8c0:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     8c2:	c0 e8       	ldi	r28, 0x80	; 128
     8c4:	d6 e0       	ldi	r29, 0x06	; 6
     8c6:	50 e1       	ldi	r21, 0x10	; 16
     8c8:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     8ca:	80 ea       	ldi	r24, 0xA0	; 160
     8cc:	96 e0       	ldi	r25, 0x06	; 6
     8ce:	fc 01       	movw	r30, r24
     8d0:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     8d2:	f8 01       	movw	r30, r16
     8d4:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     8d6:	12 96       	adiw	r26, 0x02	; 2
     8d8:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     8da:	d9 01       	movw	r26, r18
     8dc:	12 96       	adiw	r26, 0x02	; 2
     8de:	6c 93       	st	X, r22
     8e0:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     8e2:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     8e4:	ec 01       	movw	r28, r24
     8e6:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     8e8:	80 e4       	ldi	r24, 0x40	; 64
     8ea:	12 96       	adiw	r26, 0x02	; 2
     8ec:	8c 93       	st	X, r24
     8ee:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     8f0:	10 92 82 50 	sts	0x5082, r1
     8f4:	10 92 d6 50 	sts	0x50D6, r1
     8f8:	10 92 d6 23 	sts	0x23D6, r1
     8fc:	10 92 7a 50 	sts	0x507A, r1
		channelStatus = 0x00;
     900:	10 92 81 50 	sts	0x5081, r1
		
	}
}
     904:	df 91       	pop	r29
     906:	cf 91       	pop	r28
     908:	1f 91       	pop	r17
     90a:	0f 91       	pop	r16
     90c:	08 95       	ret

0000090e <CO_collectBatt>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     90e:	4f 92       	push	r4
     910:	5f 92       	push	r5
     912:	6f 92       	push	r6
     914:	7f 92       	push	r7
     916:	8f 92       	push	r8
     918:	9f 92       	push	r9
     91a:	af 92       	push	r10
     91c:	bf 92       	push	r11
     91e:	ef 92       	push	r14
     920:	ff 92       	push	r15
     922:	0f 93       	push	r16
     924:	1f 93       	push	r17
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	cd b7       	in	r28, 0x3d	; 61
     92c:	de b7       	in	r29, 0x3e	; 62
     92e:	2b 97       	sbiw	r28, 0x0b	; 11
     930:	cd bf       	out	0x3d, r28	; 61
     932:	de bf       	out	0x3e, r29	; 62
     934:	8e 83       	std	Y+6, r24	; 0x06
     936:	9f 83       	std	Y+7, r25	; 0x07
     938:	68 87       	std	Y+8, r22	; 0x08
     93a:	79 87       	std	Y+9, r23	; 0x09
     93c:	4a 87       	std	Y+10, r20	; 0x0a
     93e:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     940:	81 e0       	ldi	r24, 0x01	; 1
     942:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     946:	84 e0       	ldi	r24, 0x04	; 4
     948:	60 e0       	ldi	r22, 0x00	; 0
     94a:	0e 94 86 1c 	call	0x390c	; 0x390c <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     94e:	84 e0       	ldi	r24, 0x04	; 4
     950:	60 e0       	ldi	r22, 0x00	; 0
     952:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
     956:	2f ef       	ldi	r18, 0xFF	; 255
     958:	33 ec       	ldi	r19, 0xC3	; 195
     95a:	49 e0       	ldi	r20, 0x09	; 9
     95c:	21 50       	subi	r18, 0x01	; 1
     95e:	30 40       	sbci	r19, 0x00	; 0
     960:	40 40       	sbci	r20, 0x00	; 0
     962:	e1 f7       	brne	.-8      	; 0x95c <CO_collectBatt+0x4e>
     964:	00 c0       	rjmp	.+0      	; 0x966 <CO_collectBatt+0x58>
     966:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     968:	80 e4       	ldi	r24, 0x40	; 64
     96a:	92 e0       	ldi	r25, 0x02	; 2
     96c:	0e 94 b8 13 	call	0x2770	; 0x2770 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     970:	00 e4       	ldi	r16, 0x40	; 64
     972:	12 e0       	ldi	r17, 0x02	; 2
     974:	d8 01       	movw	r26, r16
     976:	11 96       	adiw	r26, 0x01	; 1
     978:	8c 91       	ld	r24, X
     97a:	11 97       	sbiw	r26, 0x01	; 1
     97c:	89 7e       	andi	r24, 0xE9	; 233
     97e:	11 96       	adiw	r26, 0x01	; 1
     980:	8c 93       	st	X, r24
     982:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     984:	14 96       	adiw	r26, 0x04	; 4
     986:	8c 91       	ld	r24, X
     988:	14 97       	sbiw	r26, 0x04	; 4
     98a:	88 7f       	andi	r24, 0xF8	; 248
     98c:	83 60       	ori	r24, 0x03	; 3
     98e:	14 96       	adiw	r26, 0x04	; 4
     990:	8c 93       	st	X, r24
     992:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     994:	12 96       	adiw	r26, 0x02	; 2
     996:	8c 91       	ld	r24, X
     998:	12 97       	sbiw	r26, 0x02	; 2
     99a:	8f 7c       	andi	r24, 0xCF	; 207
     99c:	12 96       	adiw	r26, 0x02	; 2
     99e:	8c 93       	st	X, r24
     9a0:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     9a2:	0f 2e       	mov	r0, r31
     9a4:	f0 e6       	ldi	r31, 0x60	; 96
     9a6:	ef 2e       	mov	r14, r31
     9a8:	f2 e0       	ldi	r31, 0x02	; 2
     9aa:	ff 2e       	mov	r15, r31
     9ac:	f0 2d       	mov	r31, r0
     9ae:	f7 01       	movw	r30, r14
     9b0:	80 81       	ld	r24, Z
     9b2:	80 7e       	andi	r24, 0xE0	; 224
     9b4:	81 60       	ori	r24, 0x01	; 1
     9b6:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     9b8:	89 e0       	ldi	r24, 0x09	; 9
     9ba:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
     9bc:	8c 91       	ld	r24, X
     9be:	81 60       	ori	r24, 0x01	; 1
     9c0:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     9c2:	80 e4       	ldi	r24, 0x40	; 64
     9c4:	92 e0       	ldi	r25, 0x02	; 2
     9c6:	0e 94 3d 13 	call	0x267a	; 0x267a <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     9ca:	80 e4       	ldi	r24, 0x40	; 64
     9cc:	92 e0       	ldi	r25, 0x02	; 2
     9ce:	60 e6       	ldi	r22, 0x60	; 96
     9d0:	72 e0       	ldi	r23, 0x02	; 2
     9d2:	40 e0       	ldi	r20, 0x00	; 0
     9d4:	0e 94 47 13 	call	0x268e	; 0x268e <ADC_Offset_Get_Unsigned>
     9d8:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
     9da:	d8 01       	movw	r26, r16
     9dc:	8c 91       	ld	r24, X
     9de:	8e 7f       	andi	r24, 0xFE	; 254
     9e0:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     9e2:	f7 01       	movw	r30, r14
     9e4:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     9e6:	13 96       	adiw	r26, 0x03	; 3
     9e8:	8c 91       	ld	r24, X
     9ea:	13 97       	sbiw	r26, 0x03	; 3
     9ec:	8f 73       	andi	r24, 0x3F	; 63
     9ee:	13 96       	adiw	r26, 0x03	; 3
     9f0:	8c 93       	st	X, r24
     9f2:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     9f4:	8c 91       	ld	r24, X
     9f6:	81 60       	ori	r24, 0x01	; 1
     9f8:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     9fa:	80 e4       	ldi	r24, 0x40	; 64
     9fc:	92 e0       	ldi	r25, 0x02	; 2
     9fe:	0e 94 3d 13 	call	0x267a	; 0x267a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     a02:	d8 01       	movw	r26, r16
     a04:	11 96       	adiw	r26, 0x01	; 1
     a06:	8c 91       	ld	r24, X
     a08:	11 97       	sbiw	r26, 0x01	; 1
     a0a:	88 60       	ori	r24, 0x08	; 8
     a0c:	11 96       	adiw	r26, 0x01	; 1
     a0e:	8c 93       	st	X, r24
     a10:	ee 24       	eor	r14, r14
     a12:	ff 24       	eor	r15, r15
     a14:	68 94       	set
     a16:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     a18:	44 24       	eor	r4, r4
     a1a:	55 24       	eor	r5, r5
     a1c:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     a1e:	20 e0       	ldi	r18, 0x00	; 0
     a20:	30 e1       	ldi	r19, 0x10	; 16
     a22:	40 e0       	ldi	r20, 0x00	; 0
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	2a 83       	std	Y+2, r18	; 0x02
     a28:	3b 83       	std	Y+3, r19	; 0x03
     a2a:	4c 83       	std	Y+4, r20	; 0x04
     a2c:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     a2e:	88 24       	eor	r8, r8
     a30:	99 24       	eor	r9, r9
     a32:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     a34:	00 e6       	ldi	r16, 0x60	; 96
     a36:	12 e0       	ldi	r17, 0x02	; 2
     a38:	d8 01       	movw	r26, r16
     a3a:	13 96       	adiw	r26, 0x03	; 3
     a3c:	8c 91       	ld	r24, X
     a3e:	13 97       	sbiw	r26, 0x03	; 3
     a40:	80 ff       	sbrs	r24, 0
     a42:	fa cf       	rjmp	.-12     	; 0xa38 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a44:	69 81       	ldd	r22, Y+1	; 0x01
     a46:	c8 01       	movw	r24, r16
     a48:	0e 94 19 13 	call	0x2632	; 0x2632 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
     a4c:	a0 e0       	ldi	r26, 0x00	; 0
     a4e:	b0 e0       	ldi	r27, 0x00	; 0
     a50:	88 0e       	add	r8, r24
     a52:	99 1e       	adc	r9, r25
     a54:	aa 1e       	adc	r10, r26
     a56:	bb 1e       	adc	r11, r27
     a58:	48 16       	cp	r4, r24
     a5a:	59 06       	cpc	r5, r25
     a5c:	6a 06       	cpc	r6, r26
     a5e:	7b 06       	cpc	r7, r27
     a60:	10 f4       	brcc	.+4      	; 0xa66 <CO_collectBatt+0x158>
     a62:	2c 01       	movw	r4, r24
     a64:	3d 01       	movw	r6, r26
     a66:	2a 81       	ldd	r18, Y+2	; 0x02
     a68:	3b 81       	ldd	r19, Y+3	; 0x03
     a6a:	4c 81       	ldd	r20, Y+4	; 0x04
     a6c:	5d 81       	ldd	r21, Y+5	; 0x05
     a6e:	82 17       	cp	r24, r18
     a70:	93 07       	cpc	r25, r19
     a72:	a4 07       	cpc	r26, r20
     a74:	b5 07       	cpc	r27, r21
     a76:	20 f4       	brcc	.+8      	; 0xa80 <CO_collectBatt+0x172>
     a78:	8a 83       	std	Y+2, r24	; 0x02
     a7a:	9b 83       	std	Y+3, r25	; 0x03
     a7c:	ac 83       	std	Y+4, r26	; 0x04
     a7e:	bd 83       	std	Y+5, r27	; 0x05
     a80:	08 94       	sec
     a82:	e1 08       	sbc	r14, r1
     a84:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a86:	e1 14       	cp	r14, r1
     a88:	f1 04       	cpc	r15, r1
     a8a:	b1 f6       	brne	.-84     	; 0xa38 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     a8c:	e0 e4       	ldi	r30, 0x40	; 64
     a8e:	f2 e0       	ldi	r31, 0x02	; 2
     a90:	81 81       	ldd	r24, Z+1	; 0x01
     a92:	87 7f       	andi	r24, 0xF7	; 247
     a94:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
     a96:	80 81       	ld	r24, Z
     a98:	8e 7f       	andi	r24, 0xFE	; 254
     a9a:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     a9c:	84 e0       	ldi	r24, 0x04	; 4
     a9e:	60 e0       	ldi	r22, 0x00	; 0
     aa0:	0e 94 2e 1c 	call	0x385c	; 0x385c <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
     aaa:	c5 01       	movw	r24, r10
     aac:	b4 01       	movw	r22, r8
     aae:	05 2e       	mov	r0, r21
     ab0:	5a e0       	ldi	r21, 0x0A	; 10
     ab2:	96 95       	lsr	r25
     ab4:	87 95       	ror	r24
     ab6:	77 95       	ror	r23
     ab8:	67 95       	ror	r22
     aba:	5a 95       	dec	r21
     abc:	d1 f7       	brne	.-12     	; 0xab2 <CO_collectBatt+0x1a4>
     abe:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     ac0:	28 ee       	ldi	r18, 0xE8	; 232
     ac2:	33 e0       	ldi	r19, 0x03	; 3
     ac4:	40 e0       	ldi	r20, 0x00	; 0
     ac6:	50 e0       	ldi	r21, 0x00	; 0
     ac8:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
     acc:	0f 2e       	mov	r0, r31
     ace:	ff ef       	ldi	r31, 0xFF	; 255
     ad0:	8f 2e       	mov	r8, r31
     ad2:	ff e0       	ldi	r31, 0x0F	; 15
     ad4:	9f 2e       	mov	r9, r31
     ad6:	f0 e0       	ldi	r31, 0x00	; 0
     ad8:	af 2e       	mov	r10, r31
     ada:	f0 e0       	ldi	r31, 0x00	; 0
     adc:	bf 2e       	mov	r11, r31
     ade:	f0 2d       	mov	r31, r0
     ae0:	a5 01       	movw	r20, r10
     ae2:	94 01       	movw	r18, r8
     ae4:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
     ae8:	c9 01       	movw	r24, r18
     aea:	c2 97       	sbiw	r24, 0x32	; 50
     aec:	ae 81       	ldd	r26, Y+6	; 0x06
     aee:	bf 81       	ldd	r27, Y+7	; 0x07
     af0:	8d 93       	st	X+, r24
     af2:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     af4:	c3 01       	movw	r24, r6
     af6:	b2 01       	movw	r22, r4
     af8:	28 ee       	ldi	r18, 0xE8	; 232
     afa:	33 e0       	ldi	r19, 0x03	; 3
     afc:	40 e0       	ldi	r20, 0x00	; 0
     afe:	50 e0       	ldi	r21, 0x00	; 0
     b00:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
     b04:	a5 01       	movw	r20, r10
     b06:	94 01       	movw	r18, r8
     b08:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
     b0c:	c9 01       	movw	r24, r18
     b0e:	c2 97       	sbiw	r24, 0x32	; 50
     b10:	ea 85       	ldd	r30, Y+10	; 0x0a
     b12:	fb 85       	ldd	r31, Y+11	; 0x0b
     b14:	80 83       	st	Z, r24
     b16:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     b18:	6a 81       	ldd	r22, Y+2	; 0x02
     b1a:	7b 81       	ldd	r23, Y+3	; 0x03
     b1c:	8c 81       	ldd	r24, Y+4	; 0x04
     b1e:	9d 81       	ldd	r25, Y+5	; 0x05
     b20:	28 ee       	ldi	r18, 0xE8	; 232
     b22:	33 e0       	ldi	r19, 0x03	; 3
     b24:	40 e0       	ldi	r20, 0x00	; 0
     b26:	50 e0       	ldi	r21, 0x00	; 0
     b28:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
     b2c:	a5 01       	movw	r20, r10
     b2e:	94 01       	movw	r18, r8
     b30:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
     b34:	22 53       	subi	r18, 0x32	; 50
     b36:	30 40       	sbci	r19, 0x00	; 0
     b38:	a8 85       	ldd	r26, Y+8	; 0x08
     b3a:	b9 85       	ldd	r27, Y+9	; 0x09
     b3c:	2d 93       	st	X+, r18
     b3e:	3c 93       	st	X, r19
     b40:	11 97       	sbiw	r26, 0x01	; 1
}
     b42:	2b 96       	adiw	r28, 0x0b	; 11
     b44:	cd bf       	out	0x3d, r28	; 61
     b46:	de bf       	out	0x3e, r29	; 62
     b48:	df 91       	pop	r29
     b4a:	cf 91       	pop	r28
     b4c:	1f 91       	pop	r17
     b4e:	0f 91       	pop	r16
     b50:	ff 90       	pop	r15
     b52:	ef 90       	pop	r14
     b54:	bf 90       	pop	r11
     b56:	af 90       	pop	r10
     b58:	9f 90       	pop	r9
     b5a:	8f 90       	pop	r8
     b5c:	7f 90       	pop	r7
     b5e:	6f 90       	pop	r6
     b60:	5f 90       	pop	r5
     b62:	4f 90       	pop	r4
     b64:	08 95       	ret

00000b66 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     b66:	4f 92       	push	r4
     b68:	5f 92       	push	r5
     b6a:	6f 92       	push	r6
     b6c:	7f 92       	push	r7
     b6e:	8f 92       	push	r8
     b70:	9f 92       	push	r9
     b72:	af 92       	push	r10
     b74:	bf 92       	push	r11
     b76:	ef 92       	push	r14
     b78:	ff 92       	push	r15
     b7a:	0f 93       	push	r16
     b7c:	1f 93       	push	r17
     b7e:	cf 93       	push	r28
     b80:	df 93       	push	r29
     b82:	cd b7       	in	r28, 0x3d	; 61
     b84:	de b7       	in	r29, 0x3e	; 62
     b86:	2b 97       	sbiw	r28, 0x0b	; 11
     b88:	cd bf       	out	0x3d, r28	; 61
     b8a:	de bf       	out	0x3e, r29	; 62
     b8c:	8e 83       	std	Y+6, r24	; 0x06
     b8e:	9f 83       	std	Y+7, r25	; 0x07
     b90:	68 87       	std	Y+8, r22	; 0x08
     b92:	79 87       	std	Y+9, r23	; 0x09
     b94:	4a 87       	std	Y+10, r20	; 0x0a
     b96:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     b9e:	80 e0       	ldi	r24, 0x00	; 0
     ba0:	92 e0       	ldi	r25, 0x02	; 2
     ba2:	0e 94 b8 13 	call	0x2770	; 0x2770 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     ba6:	00 e0       	ldi	r16, 0x00	; 0
     ba8:	12 e0       	ldi	r17, 0x02	; 2
     baa:	d8 01       	movw	r26, r16
     bac:	11 96       	adiw	r26, 0x01	; 1
     bae:	8c 91       	ld	r24, X
     bb0:	11 97       	sbiw	r26, 0x01	; 1
     bb2:	89 7e       	andi	r24, 0xE9	; 233
     bb4:	11 96       	adiw	r26, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     bba:	14 96       	adiw	r26, 0x04	; 4
     bbc:	8c 91       	ld	r24, X
     bbe:	14 97       	sbiw	r26, 0x04	; 4
     bc0:	88 7f       	andi	r24, 0xF8	; 248
     bc2:	83 60       	ori	r24, 0x03	; 3
     bc4:	14 96       	adiw	r26, 0x04	; 4
     bc6:	8c 93       	st	X, r24
     bc8:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     bca:	12 96       	adiw	r26, 0x02	; 2
     bcc:	8c 91       	ld	r24, X
     bce:	12 97       	sbiw	r26, 0x02	; 2
     bd0:	8f 7c       	andi	r24, 0xCF	; 207
     bd2:	12 96       	adiw	r26, 0x02	; 2
     bd4:	8c 93       	st	X, r24
     bd6:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     bd8:	0f 2e       	mov	r0, r31
     bda:	f0 e2       	ldi	r31, 0x20	; 32
     bdc:	ef 2e       	mov	r14, r31
     bde:	f2 e0       	ldi	r31, 0x02	; 2
     be0:	ff 2e       	mov	r15, r31
     be2:	f0 2d       	mov	r31, r0
     be4:	f7 01       	movw	r30, r14
     be6:	80 81       	ld	r24, Z
     be8:	80 7e       	andi	r24, 0xE0	; 224
     bea:	81 60       	ori	r24, 0x01	; 1
     bec:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     bee:	89 e0       	ldi	r24, 0x09	; 9
     bf0:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     bf2:	8c 91       	ld	r24, X
     bf4:	81 60       	ori	r24, 0x01	; 1
     bf6:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	92 e0       	ldi	r25, 0x02	; 2
     bfc:	0e 94 3d 13 	call	0x267a	; 0x267a <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     c00:	80 e0       	ldi	r24, 0x00	; 0
     c02:	92 e0       	ldi	r25, 0x02	; 2
     c04:	60 e2       	ldi	r22, 0x20	; 32
     c06:	72 e0       	ldi	r23, 0x02	; 2
     c08:	40 e0       	ldi	r20, 0x00	; 0
     c0a:	0e 94 47 13 	call	0x268e	; 0x268e <ADC_Offset_Get_Unsigned>
     c0e:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     c10:	d8 01       	movw	r26, r16
     c12:	8c 91       	ld	r24, X
     c14:	8e 7f       	andi	r24, 0xFE	; 254
     c16:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     c18:	f7 01       	movw	r30, r14
     c1a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     c1c:	13 96       	adiw	r26, 0x03	; 3
     c1e:	8c 91       	ld	r24, X
     c20:	13 97       	sbiw	r26, 0x03	; 3
     c22:	8f 73       	andi	r24, 0x3F	; 63
     c24:	13 96       	adiw	r26, 0x03	; 3
     c26:	8c 93       	st	X, r24
     c28:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     c2a:	8c 91       	ld	r24, X
     c2c:	81 60       	ori	r24, 0x01	; 1
     c2e:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     c30:	80 e0       	ldi	r24, 0x00	; 0
     c32:	92 e0       	ldi	r25, 0x02	; 2
     c34:	0e 94 3d 13 	call	0x267a	; 0x267a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     c38:	d8 01       	movw	r26, r16
     c3a:	11 96       	adiw	r26, 0x01	; 1
     c3c:	8c 91       	ld	r24, X
     c3e:	11 97       	sbiw	r26, 0x01	; 1
     c40:	88 60       	ori	r24, 0x08	; 8
     c42:	11 96       	adiw	r26, 0x01	; 1
     c44:	8c 93       	st	X, r24
     c46:	ee 24       	eor	r14, r14
     c48:	ff 24       	eor	r15, r15
     c4a:	68 94       	set
     c4c:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     c4e:	44 24       	eor	r4, r4
     c50:	55 24       	eor	r5, r5
     c52:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     c54:	20 e0       	ldi	r18, 0x00	; 0
     c56:	30 e1       	ldi	r19, 0x10	; 16
     c58:	40 e0       	ldi	r20, 0x00	; 0
     c5a:	50 e0       	ldi	r21, 0x00	; 0
     c5c:	2a 83       	std	Y+2, r18	; 0x02
     c5e:	3b 83       	std	Y+3, r19	; 0x03
     c60:	4c 83       	std	Y+4, r20	; 0x04
     c62:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     c64:	88 24       	eor	r8, r8
     c66:	99 24       	eor	r9, r9
     c68:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     c6a:	00 e2       	ldi	r16, 0x20	; 32
     c6c:	12 e0       	ldi	r17, 0x02	; 2
     c6e:	d8 01       	movw	r26, r16
     c70:	13 96       	adiw	r26, 0x03	; 3
     c72:	8c 91       	ld	r24, X
     c74:	13 97       	sbiw	r26, 0x03	; 3
     c76:	80 ff       	sbrs	r24, 0
     c78:	fa cf       	rjmp	.-12     	; 0xc6e <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     c7a:	69 81       	ldd	r22, Y+1	; 0x01
     c7c:	c8 01       	movw	r24, r16
     c7e:	0e 94 19 13 	call	0x2632	; 0x2632 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
     c82:	a0 e0       	ldi	r26, 0x00	; 0
     c84:	b0 e0       	ldi	r27, 0x00	; 0
     c86:	88 0e       	add	r8, r24
     c88:	99 1e       	adc	r9, r25
     c8a:	aa 1e       	adc	r10, r26
     c8c:	bb 1e       	adc	r11, r27
     c8e:	48 16       	cp	r4, r24
     c90:	59 06       	cpc	r5, r25
     c92:	6a 06       	cpc	r6, r26
     c94:	7b 06       	cpc	r7, r27
     c96:	10 f4       	brcc	.+4      	; 0xc9c <CO_collectTemp+0x136>
     c98:	2c 01       	movw	r4, r24
     c9a:	3d 01       	movw	r6, r26
     c9c:	2a 81       	ldd	r18, Y+2	; 0x02
     c9e:	3b 81       	ldd	r19, Y+3	; 0x03
     ca0:	4c 81       	ldd	r20, Y+4	; 0x04
     ca2:	5d 81       	ldd	r21, Y+5	; 0x05
     ca4:	82 17       	cp	r24, r18
     ca6:	93 07       	cpc	r25, r19
     ca8:	a4 07       	cpc	r26, r20
     caa:	b5 07       	cpc	r27, r21
     cac:	20 f4       	brcc	.+8      	; 0xcb6 <CO_collectTemp+0x150>
     cae:	8a 83       	std	Y+2, r24	; 0x02
     cb0:	9b 83       	std	Y+3, r25	; 0x03
     cb2:	ac 83       	std	Y+4, r26	; 0x04
     cb4:	bd 83       	std	Y+5, r27	; 0x05
     cb6:	08 94       	sec
     cb8:	e1 08       	sbc	r14, r1
     cba:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     cbc:	e1 14       	cp	r14, r1
     cbe:	f1 04       	cpc	r15, r1
     cc0:	b1 f6       	brne	.-84     	; 0xc6e <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     cc2:	e0 e0       	ldi	r30, 0x00	; 0
     cc4:	f2 e0       	ldi	r31, 0x02	; 2
     cc6:	81 81       	ldd	r24, Z+1	; 0x01
     cc8:	87 7f       	andi	r24, 0xF7	; 247
     cca:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     ccc:	80 81       	ld	r24, Z
     cce:	82 60       	ori	r24, 0x02	; 2
     cd0:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
     cd2:	80 81       	ld	r24, Z
     cd4:	8e 7f       	andi	r24, 0xFE	; 254
     cd6:	80 83       	st	Z, r24

	ADCPower(FALSE);
     cd8:	80 e0       	ldi	r24, 0x00	; 0
     cda:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>

	average = sum / NUM_SAMPLES;
     cde:	c5 01       	movw	r24, r10
     ce0:	b4 01       	movw	r22, r8
     ce2:	05 2e       	mov	r0, r21
     ce4:	5a e0       	ldi	r21, 0x0A	; 10
     ce6:	96 95       	lsr	r25
     ce8:	87 95       	ror	r24
     cea:	77 95       	ror	r23
     cec:	67 95       	ror	r22
     cee:	5a 95       	dec	r21
     cf0:	d1 f7       	brne	.-12     	; 0xce6 <CO_collectTemp+0x180>
     cf2:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     cf4:	28 ee       	ldi	r18, 0xE8	; 232
     cf6:	33 e0       	ldi	r19, 0x03	; 3
     cf8:	40 e0       	ldi	r20, 0x00	; 0
     cfa:	50 e0       	ldi	r21, 0x00	; 0
     cfc:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
     d00:	0f 2e       	mov	r0, r31
     d02:	ff ef       	ldi	r31, 0xFF	; 255
     d04:	8f 2e       	mov	r8, r31
     d06:	ff e0       	ldi	r31, 0x0F	; 15
     d08:	9f 2e       	mov	r9, r31
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
     d0c:	af 2e       	mov	r10, r31
     d0e:	f0 e0       	ldi	r31, 0x00	; 0
     d10:	bf 2e       	mov	r11, r31
     d12:	f0 2d       	mov	r31, r0
     d14:	a5 01       	movw	r20, r10
     d16:	94 01       	movw	r18, r8
     d18:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
     d1c:	c9 01       	movw	r24, r18
     d1e:	c2 97       	sbiw	r24, 0x32	; 50
     d20:	ae 81       	ldd	r26, Y+6	; 0x06
     d22:	bf 81       	ldd	r27, Y+7	; 0x07
     d24:	8d 93       	st	X+, r24
     d26:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     d28:	c3 01       	movw	r24, r6
     d2a:	b2 01       	movw	r22, r4
     d2c:	28 ee       	ldi	r18, 0xE8	; 232
     d2e:	33 e0       	ldi	r19, 0x03	; 3
     d30:	40 e0       	ldi	r20, 0x00	; 0
     d32:	50 e0       	ldi	r21, 0x00	; 0
     d34:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
     d38:	a5 01       	movw	r20, r10
     d3a:	94 01       	movw	r18, r8
     d3c:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
     d40:	c9 01       	movw	r24, r18
     d42:	c2 97       	sbiw	r24, 0x32	; 50
     d44:	ea 85       	ldd	r30, Y+10	; 0x0a
     d46:	fb 85       	ldd	r31, Y+11	; 0x0b
     d48:	80 83       	st	Z, r24
     d4a:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     d4c:	6a 81       	ldd	r22, Y+2	; 0x02
     d4e:	7b 81       	ldd	r23, Y+3	; 0x03
     d50:	8c 81       	ldd	r24, Y+4	; 0x04
     d52:	9d 81       	ldd	r25, Y+5	; 0x05
     d54:	28 ee       	ldi	r18, 0xE8	; 232
     d56:	33 e0       	ldi	r19, 0x03	; 3
     d58:	40 e0       	ldi	r20, 0x00	; 0
     d5a:	50 e0       	ldi	r21, 0x00	; 0
     d5c:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
     d60:	a5 01       	movw	r20, r10
     d62:	94 01       	movw	r18, r8
     d64:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
     d68:	22 53       	subi	r18, 0x32	; 50
     d6a:	30 40       	sbci	r19, 0x00	; 0
     d6c:	a8 85       	ldd	r26, Y+8	; 0x08
     d6e:	b9 85       	ldd	r27, Y+9	; 0x09
     d70:	2d 93       	st	X+, r18
     d72:	3c 93       	st	X, r19
     d74:	11 97       	sbiw	r26, 0x01	; 1
}
     d76:	2b 96       	adiw	r28, 0x0b	; 11
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ff 90       	pop	r15
     d86:	ef 90       	pop	r14
     d88:	bf 90       	pop	r11
     d8a:	af 90       	pop	r10
     d8c:	9f 90       	pop	r9
     d8e:	8f 90       	pop	r8
     d90:	7f 90       	pop	r7
     d92:	6f 90       	pop	r6
     d94:	5f 90       	pop	r5
     d96:	4f 90       	pop	r4
     d98:	08 95       	ret

00000d9a <enableADCMUX>:
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	
	if(on) {
     d9a:	88 23       	and	r24, r24
     d9c:	31 f0       	breq	.+12     	; 0xdaa <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
     d9e:	e0 e0       	ldi	r30, 0x00	; 0
     da0:	f6 e0       	ldi	r31, 0x06	; 6
     da2:	80 e2       	ldi	r24, 0x20	; 32
     da4:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
     da6:	85 83       	std	Z+5, r24	; 0x05
     da8:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
     daa:	e0 e0       	ldi	r30, 0x00	; 0
     dac:	f6 e0       	ldi	r31, 0x06	; 6
     dae:	80 e2       	ldi	r24, 0x20	; 32
     db0:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     db2:	82 83       	std	Z+2, r24	; 0x02
     db4:	08 95       	ret

00000db6 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
     db6:	1f 92       	push	r1
     db8:	0f 92       	push	r0
     dba:	0f b6       	in	r0, 0x3f	; 63
     dbc:	0f 92       	push	r0
     dbe:	0b b6       	in	r0, 0x3b	; 59
     dc0:	0f 92       	push	r0
     dc2:	11 24       	eor	r1, r1
     dc4:	2f 93       	push	r18
     dc6:	3f 93       	push	r19
     dc8:	4f 93       	push	r20
     dca:	5f 93       	push	r21
     dcc:	6f 93       	push	r22
     dce:	7f 93       	push	r23
     dd0:	8f 93       	push	r24
     dd2:	9f 93       	push	r25
     dd4:	af 93       	push	r26
     dd6:	bf 93       	push	r27
     dd8:	ef 93       	push	r30
     dda:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     ddc:	e0 e4       	ldi	r30, 0x40	; 64
     dde:	fa e0       	ldi	r31, 0x0A	; 10
     de0:	80 81       	ld	r24, Z
     de2:	80 7f       	andi	r24, 0xF0	; 240
     de4:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     de6:	a0 e0       	ldi	r26, 0x00	; 0
     de8:	b8 e0       	ldi	r27, 0x08	; 8
     dea:	8c 91       	ld	r24, X
     dec:	80 7f       	andi	r24, 0xF0	; 240
     dee:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     df0:	a0 e0       	ldi	r26, 0x00	; 0
     df2:	b9 e0       	ldi	r27, 0x09	; 9
     df4:	8c 91       	ld	r24, X
     df6:	80 7f       	andi	r24, 0xF0	; 240
     df8:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     dfa:	80 81       	ld	r24, Z
     dfc:	80 7f       	andi	r24, 0xF0	; 240
     dfe:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
     e08:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	enableADCMUX(FALSE);
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
     e12:	81 e0       	ldi	r24, 0x01	; 1
     e14:	80 93 d5 50 	sts	0x50D5, r24
	DataAvailable = 1;
     e18:	80 93 d5 21 	sts	0x21D5, r24
}
     e1c:	ff 91       	pop	r31
     e1e:	ef 91       	pop	r30
     e20:	bf 91       	pop	r27
     e22:	af 91       	pop	r26
     e24:	9f 91       	pop	r25
     e26:	8f 91       	pop	r24
     e28:	7f 91       	pop	r23
     e2a:	6f 91       	pop	r22
     e2c:	5f 91       	pop	r21
     e2e:	4f 91       	pop	r20
     e30:	3f 91       	pop	r19
     e32:	2f 91       	pop	r18
     e34:	0f 90       	pop	r0
     e36:	0b be       	out	0x3b, r0	; 59
     e38:	0f 90       	pop	r0
     e3a:	0f be       	out	0x3f, r0	; 63
     e3c:	0f 90       	pop	r0
     e3e:	1f 90       	pop	r1
     e40:	18 95       	reti

00000e42 <ADC_Stop_Sampling>:
//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e42:	e0 e4       	ldi	r30, 0x40	; 64
     e44:	fa e0       	ldi	r31, 0x0A	; 10
     e46:	80 81       	ld	r24, Z
     e48:	80 7f       	andi	r24, 0xF0	; 240
     e4a:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e4c:	a0 e0       	ldi	r26, 0x00	; 0
     e4e:	b8 e0       	ldi	r27, 0x08	; 8
     e50:	8c 91       	ld	r24, X
     e52:	80 7f       	andi	r24, 0xF0	; 240
     e54:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e56:	a0 e0       	ldi	r26, 0x00	; 0
     e58:	b9 e0       	ldi	r27, 0x09	; 9
     e5a:	8c 91       	ld	r24, X
     e5c:	80 7f       	andi	r24, 0xF0	; 240
     e5e:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e60:	80 81       	ld	r24, Z
     e62:	80 7f       	andi	r24, 0xF0	; 240
     e64:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     e68:	80 e0       	ldi	r24, 0x00	; 0
     e6a:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
     e6e:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	enableADCMUX(FALSE);
     e72:	80 e0       	ldi	r24, 0x00	; 0
     e74:	0e 94 cd 06 	call	0xd9a	; 0xd9a <enableADCMUX>
	ADC_Sampling_Finished = 1;
     e78:	81 e0       	ldi	r24, 0x01	; 1
     e7a:	80 93 d5 50 	sts	0x50D5, r24
	DataAvailable = 1;
     e7e:	80 93 d5 21 	sts	0x21D5, r24
}
     e82:	08 95       	ret

00000e84 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
	
	if(ADC_Sampling_Finished){
     e84:	80 91 d5 50 	lds	r24, 0x50D5
     e88:	88 23       	and	r24, r24
     e8a:	49 f0       	breq	.+18     	; 0xe9e <ADC_Get_Num_Samples+0x1a>
		uint16_t count;
		count = TCC1.CNT;
     e8c:	e0 e4       	ldi	r30, 0x40	; 64
     e8e:	f8 e0       	ldi	r31, 0x08	; 8
     e90:	80 a1       	lds	r24, 0x40
     e92:	91 a1       	lds	r25, 0x41
		if(count == 0) count = TCC1.PER;
     e94:	00 97       	sbiw	r24, 0x00	; 0
     e96:	29 f4       	brne	.+10     	; 0xea2 <ADC_Get_Num_Samples+0x1e>
     e98:	86 a1       	lds	r24, 0x46
     e9a:	97 a1       	lds	r25, 0x47
     e9c:	08 95       	ret
		return count;
	}
	else return 0;		
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	90 e0       	ldi	r25, 0x00	; 0
}
     ea2:	08 95       	ret

00000ea4 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
     ea4:	e0 ea       	ldi	r30, 0xA0	; 160
     ea6:	f6 e0       	ldi	r31, 0x06	; 6
     ea8:	13 86       	std	Z+11, r1	; 0x0b
}
     eaa:	08 95       	ret

00000eac <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	e0 ea       	ldi	r30, 0xA0	; 160
     eb0:	f6 e0       	ldi	r31, 0x06	; 6
     eb2:	83 87       	std	Z+11, r24	; 0x0b
}	
     eb4:	08 95       	ret

00000eb6 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
     eb6:	1f 92       	push	r1
     eb8:	0f 92       	push	r0
     eba:	0f b6       	in	r0, 0x3f	; 63
     ebc:	0f 92       	push	r0
     ebe:	0b b6       	in	r0, 0x3b	; 59
     ec0:	0f 92       	push	r0
     ec2:	11 24       	eor	r1, r1
     ec4:	6f 92       	push	r6
     ec6:	7f 92       	push	r7
     ec8:	8f 92       	push	r8
     eca:	9f 92       	push	r9
     ecc:	af 92       	push	r10
     ece:	bf 92       	push	r11
     ed0:	cf 92       	push	r12
     ed2:	df 92       	push	r13
     ed4:	ef 92       	push	r14
     ed6:	ff 92       	push	r15
     ed8:	0f 93       	push	r16
     eda:	1f 93       	push	r17
     edc:	2f 93       	push	r18
     ede:	3f 93       	push	r19
     ee0:	4f 93       	push	r20
     ee2:	5f 93       	push	r21
     ee4:	6f 93       	push	r22
     ee6:	7f 93       	push	r23
     ee8:	8f 93       	push	r24
     eea:	9f 93       	push	r25
     eec:	af 93       	push	r26
     eee:	bf 93       	push	r27
     ef0:	ef 93       	push	r30
     ef2:	ff 93       	push	r31
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	00 d0       	rcall	.+0      	; 0xefa <__vector_104+0x44>
     efa:	0f 92       	push	r0
     efc:	cd b7       	in	r28, 0x3d	; 61
     efe:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	if (discardCount < ADC_DISCARD) {
     f00:	80 91 5d 40 	lds	r24, 0x405D
     f04:	88 23       	and	r24, r24
     f06:	8c f0       	brlt	.+34     	; 0xf2a <__vector_104+0x74>
		discardCount++;
     f08:	80 91 5d 40 	lds	r24, 0x405D
     f0c:	8f 5f       	subi	r24, 0xFF	; 255
     f0e:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
     f12:	80 91 5d 40 	lds	r24, 0x405D
     f16:	80 38       	cpi	r24, 0x80	; 128
     f18:	09 f0       	breq	.+2      	; 0xf1c <__vector_104+0x66>
     f1a:	c4 c0       	rjmp	.+392    	; 0x10a4 <__vector_104+0x1ee>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
     f1c:	e0 e4       	ldi	r30, 0x40	; 64
     f1e:	f8 e0       	ldi	r31, 0x08	; 8
     f20:	80 81       	ld	r24, Z
     f22:	80 7f       	andi	r24, 0xF0	; 240
     f24:	89 60       	ori	r24, 0x09	; 9
     f26:	80 83       	st	Z, r24
     f28:	bd c0       	rjmp	.+378    	; 0x10a4 <__vector_104+0x1ee>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
     f2a:	81 e0       	ldi	r24, 0x01	; 1
     f2c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
     f30:	82 e0       	ldi	r24, 0x02	; 2
     f32:	e0 ea       	ldi	r30, 0xA0	; 160
     f34:	f6 e0       	ldi	r31, 0x06	; 6
     f36:	86 83       	std	Z+6, r24	; 0x06
     f38:	80 e0       	ldi	r24, 0x00	; 0
     f3a:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     f3c:	e0 ec       	ldi	r30, 0xC0	; 192
     f3e:	f8 e0       	ldi	r31, 0x08	; 8
     f40:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
     f42:	25 e6       	ldi	r18, 0x65	; 101
     f44:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     f46:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
     f48:	42 81       	ldd	r20, Z+2	; 0x02
     f4a:	44 23       	and	r20, r20
     f4c:	ec f7       	brge	.-6      	; 0xf48 <__vector_104+0x92>
			SPIBuffer[bufIndex] = SPIC.DATA;
     f4e:	43 81       	ldd	r20, Z+3	; 0x03
     f50:	d9 01       	movw	r26, r18
     f52:	a8 0f       	add	r26, r24
     f54:	b9 1f       	adc	r27, r25
     f56:	4c 93       	st	X, r20
     f58:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     f5a:	83 30       	cpi	r24, 0x03	; 3
     f5c:	91 05       	cpc	r25, r1
     f5e:	99 f7       	brne	.-26     	; 0xf46 <__vector_104+0x90>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
     f60:	82 e0       	ldi	r24, 0x02	; 2
     f62:	e0 ea       	ldi	r30, 0xA0	; 160
     f64:	f6 e0       	ldi	r31, 0x06	; 6
     f66:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
     f6e:	80 91 65 50 	lds	r24, 0x5065
     f72:	88 23       	and	r24, r24
     f74:	1c f4       	brge	.+6      	; 0xf7c <__vector_104+0xc6>
     f76:	8f ef       	ldi	r24, 0xFF	; 255
     f78:	8c 83       	std	Y+4, r24	; 0x04
     f7a:	01 c0       	rjmp	.+2      	; 0xf7e <__vector_104+0xc8>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
     f7c:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
     f7e:	80 91 65 50 	lds	r24, 0x5065
     f82:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
     f84:	80 91 66 50 	lds	r24, 0x5066
     f88:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
     f8a:	80 91 67 50 	lds	r24, 0x5067
     f8e:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	9a 81       	ldd	r25, Y+2	; 0x02
     f94:	ab 81       	ldd	r26, Y+3	; 0x03
     f96:	bc 81       	ldd	r27, Y+4	; 0x04
     f98:	ac 01       	movw	r20, r24
     f9a:	bd 01       	movw	r22, r26
     f9c:	77 0f       	add	r23, r23
     f9e:	44 0b       	sbc	r20, r20
     fa0:	54 2f       	mov	r21, r20
     fa2:	ba 01       	movw	r22, r20
     fa4:	80 93 a6 50 	sts	0x50A6, r24
     fa8:	90 93 a7 50 	sts	0x50A7, r25
     fac:	a0 93 a8 50 	sts	0x50A8, r26
     fb0:	b0 93 a9 50 	sts	0x50A9, r27
     fb4:	40 93 aa 50 	sts	0x50AA, r20
     fb8:	40 93 ab 50 	sts	0x50AB, r20
     fbc:	40 93 ac 50 	sts	0x50AC, r20
     fc0:	40 93 ad 50 	sts	0x50AD, r20
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
     fc4:	80 90 74 50 	lds	r8, 0x5074
     fc8:	90 90 75 50 	lds	r9, 0x5075
     fcc:	a0 90 76 50 	lds	r10, 0x5076
     fd0:	b0 90 77 50 	lds	r11, 0x5077
     fd4:	20 91 a6 50 	lds	r18, 0x50A6
     fd8:	30 91 a7 50 	lds	r19, 0x50A7
     fdc:	40 91 a8 50 	lds	r20, 0x50A8
     fe0:	50 91 a9 50 	lds	r21, 0x50A9
     fe4:	60 91 aa 50 	lds	r22, 0x50AA
     fe8:	70 91 ab 50 	lds	r23, 0x50AB
     fec:	80 91 ac 50 	lds	r24, 0x50AC
     ff0:	90 91 ad 50 	lds	r25, 0x50AD
     ff4:	f4 01       	movw	r30, r8
     ff6:	ee 0f       	add	r30, r30
     ff8:	ff 1f       	adc	r31, r31
     ffa:	ee 0f       	add	r30, r30
     ffc:	ff 1f       	adc	r31, r31
     ffe:	60 90 72 50 	lds	r6, 0x5072
    1002:	70 90 73 50 	lds	r7, 0x5073
    1006:	6e 0e       	add	r6, r30
    1008:	7f 1e       	adc	r7, r31
    100a:	0f 2e       	mov	r0, r31
    100c:	f0 ea       	ldi	r31, 0xA0	; 160
    100e:	af 2e       	mov	r10, r31
    1010:	f0 2d       	mov	r31, r0
    1012:	0f 2e       	mov	r0, r31
    1014:	f5 e2       	ldi	r31, 0x25	; 37
    1016:	bf 2e       	mov	r11, r31
    1018:	f0 2d       	mov	r31, r0
    101a:	0f 2e       	mov	r0, r31
    101c:	f6 e2       	ldi	r31, 0x26	; 38
    101e:	cf 2e       	mov	r12, r31
    1020:	f0 2d       	mov	r31, r0
    1022:	dd 24       	eor	r13, r13
    1024:	ee 24       	eor	r14, r14
    1026:	ff 24       	eor	r15, r15
    1028:	00 e0       	ldi	r16, 0x00	; 0
    102a:	10 e0       	ldi	r17, 0x00	; 0
    102c:	0e 94 07 2d 	call	0x5a0e	; 0x5a0e <__muldi3>
    1030:	aa 24       	eor	r10, r10
    1032:	aa 94       	dec	r10
    1034:	bb 24       	eor	r11, r11
    1036:	ba 94       	dec	r11
    1038:	0f 2e       	mov	r0, r31
    103a:	ff e7       	ldi	r31, 0x7F	; 127
    103c:	cf 2e       	mov	r12, r31
    103e:	f0 2d       	mov	r31, r0
    1040:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <__divdi3>
    1044:	01 e0       	ldi	r16, 0x01	; 1
    1046:	0e 94 da 2d 	call	0x5bb4	; 0x5bb4 <__ashldi3>
    104a:	0f 2e       	mov	r0, r31
    104c:	f3 e0       	ldi	r31, 0x03	; 3
    104e:	af 2e       	mov	r10, r31
    1050:	f0 2d       	mov	r31, r0
    1052:	bb 24       	eor	r11, r11
    1054:	cc 24       	eor	r12, r12
    1056:	00 e0       	ldi	r16, 0x00	; 0
    1058:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <__divdi3>
    105c:	82 2e       	mov	r8, r18
    105e:	93 2e       	mov	r9, r19
    1060:	a4 2e       	mov	r10, r20
    1062:	b5 2e       	mov	r11, r21
    1064:	b0 94       	com	r11
    1066:	a0 94       	com	r10
    1068:	90 94       	com	r9
    106a:	80 94       	com	r8
    106c:	81 1c       	adc	r8, r1
    106e:	91 1c       	adc	r9, r1
    1070:	a1 1c       	adc	r10, r1
    1072:	b1 1c       	adc	r11, r1
    1074:	f3 01       	movw	r30, r6
    1076:	80 82       	st	Z, r8
    1078:	91 82       	std	Z+1, r9	; 0x01
    107a:	a2 82       	std	Z+2, r10	; 0x02
    107c:	b3 82       	std	Z+3, r11	; 0x03
		sampleCount++;
    107e:	80 91 74 50 	lds	r24, 0x5074
    1082:	90 91 75 50 	lds	r25, 0x5075
    1086:	a0 91 76 50 	lds	r26, 0x5076
    108a:	b0 91 77 50 	lds	r27, 0x5077
    108e:	01 96       	adiw	r24, 0x01	; 1
    1090:	a1 1d       	adc	r26, r1
    1092:	b1 1d       	adc	r27, r1
    1094:	80 93 74 50 	sts	0x5074, r24
    1098:	90 93 75 50 	sts	0x5075, r25
    109c:	a0 93 76 50 	sts	0x5076, r26
    10a0:	b0 93 77 50 	sts	0x5077, r27
	}
}
    10a4:	24 96       	adiw	r28, 0x04	; 4
    10a6:	cd bf       	out	0x3d, r28	; 61
    10a8:	de bf       	out	0x3e, r29	; 62
    10aa:	df 91       	pop	r29
    10ac:	cf 91       	pop	r28
    10ae:	ff 91       	pop	r31
    10b0:	ef 91       	pop	r30
    10b2:	bf 91       	pop	r27
    10b4:	af 91       	pop	r26
    10b6:	9f 91       	pop	r25
    10b8:	8f 91       	pop	r24
    10ba:	7f 91       	pop	r23
    10bc:	6f 91       	pop	r22
    10be:	5f 91       	pop	r21
    10c0:	4f 91       	pop	r20
    10c2:	3f 91       	pop	r19
    10c4:	2f 91       	pop	r18
    10c6:	1f 91       	pop	r17
    10c8:	0f 91       	pop	r16
    10ca:	ff 90       	pop	r15
    10cc:	ef 90       	pop	r14
    10ce:	df 90       	pop	r13
    10d0:	cf 90       	pop	r12
    10d2:	bf 90       	pop	r11
    10d4:	af 90       	pop	r10
    10d6:	9f 90       	pop	r9
    10d8:	8f 90       	pop	r8
    10da:	7f 90       	pop	r7
    10dc:	6f 90       	pop	r6
    10de:	0f 90       	pop	r0
    10e0:	0b be       	out	0x3b, r0	; 59
    10e2:	0f 90       	pop	r0
    10e4:	0f be       	out	0x3f, r0	; 63
    10e6:	0f 90       	pop	r0
    10e8:	1f 90       	pop	r1
    10ea:	18 95       	reti

000010ec <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    10ec:	88 23       	and	r24, r24
    10ee:	49 f0       	breq	.+18     	; 0x1102 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    10f0:	80 e2       	ldi	r24, 0x20	; 32
    10f2:	60 e0       	ldi	r22, 0x00	; 0
    10f4:	0e 94 86 1c 	call	0x390c	; 0x390c <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    10f8:	80 e2       	ldi	r24, 0x20	; 32
    10fa:	60 e0       	ldi	r22, 0x00	; 0
    10fc:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
    1100:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1102:	80 e2       	ldi	r24, 0x20	; 32
    1104:	60 e0       	ldi	r22, 0x00	; 0
    1106:	0e 94 2e 1c 	call	0x385c	; 0x385c <PortEx_DIRCLR>
    110a:	08 95       	ret

0000110c <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    110c:	1f 92       	push	r1
    110e:	0f 92       	push	r0
    1110:	0f b6       	in	r0, 0x3f	; 63
    1112:	0f 92       	push	r0
    1114:	0b b6       	in	r0, 0x3b	; 59
    1116:	0f 92       	push	r0
    1118:	11 24       	eor	r1, r1
    111a:	ff 92       	push	r15
    111c:	0f 93       	push	r16
    111e:	1f 93       	push	r17
    1120:	2f 93       	push	r18
    1122:	3f 93       	push	r19
    1124:	4f 93       	push	r20
    1126:	5f 93       	push	r21
    1128:	6f 93       	push	r22
    112a:	7f 93       	push	r23
    112c:	8f 93       	push	r24
    112e:	9f 93       	push	r25
    1130:	af 93       	push	r26
    1132:	bf 93       	push	r27
    1134:	ef 93       	push	r30
    1136:	ff 93       	push	r31
    1138:	cf 93       	push	r28
    113a:	df 93       	push	r29
    113c:	cd b7       	in	r28, 0x3d	; 61
    113e:	de b7       	in	r29, 0x3e	; 62
    1140:	28 97       	sbiw	r28, 0x08	; 8
    1142:	cd bf       	out	0x3d, r28	; 61
    1144:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1146:	19 82       	std	Y+1, r1	; 0x01
    1148:	1a 82       	std	Y+2, r1	; 0x02
    114a:	1b 82       	std	Y+3, r1	; 0x03
    114c:	1c 82       	std	Y+4, r1	; 0x04
    114e:	20 e0       	ldi	r18, 0x00	; 0
    1150:	30 e0       	ldi	r19, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1152:	05 e6       	ldi	r16, 0x65	; 101
    1154:	10 e5       	ldi	r17, 0x50	; 80
    1156:	ff 24       	eor	r15, r15
    1158:	fa 94       	dec	r15
    115a:	c9 01       	movw	r24, r18
    115c:	f8 01       	movw	r30, r16
    115e:	e2 0f       	add	r30, r18
    1160:	f3 1f       	adc	r31, r19
    1162:	40 81       	ld	r20, Z
    1164:	44 23       	and	r20, r20
    1166:	14 f4       	brge	.+4      	; 0x116c <__vector_14+0x60>
    1168:	f8 86       	std	Y+8, r15	; 0x08
    116a:	01 c0       	rjmp	.+2      	; 0x116e <__vector_14+0x62>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    116c:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    116e:	80 0f       	add	r24, r16
    1170:	91 1f       	adc	r25, r17
    1172:	fc 01       	movw	r30, r24
    1174:	80 81       	ld	r24, Z
    1176:	8f 83       	std	Y+7, r24	; 0x07
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1178:	f9 01       	movw	r30, r18
    117a:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    117c:	e0 0f       	add	r30, r16
    117e:	f1 1f       	adc	r31, r17
    1180:	80 81       	ld	r24, Z
    1182:	8e 83       	std	Y+6, r24	; 0x06
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1184:	f9 01       	movw	r30, r18
    1186:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1188:	e0 0f       	add	r30, r16
    118a:	f1 1f       	adc	r31, r17
    118c:	80 81       	ld	r24, Z
    118e:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    1190:	49 81       	ldd	r20, Y+1	; 0x01
    1192:	5a 81       	ldd	r21, Y+2	; 0x02
    1194:	6b 81       	ldd	r22, Y+3	; 0x03
    1196:	7c 81       	ldd	r23, Y+4	; 0x04
    1198:	8d 81       	ldd	r24, Y+5	; 0x05
    119a:	9e 81       	ldd	r25, Y+6	; 0x06
    119c:	af 81       	ldd	r26, Y+7	; 0x07
    119e:	b8 85       	ldd	r27, Y+8	; 0x08
    11a0:	84 0f       	add	r24, r20
    11a2:	95 1f       	adc	r25, r21
    11a4:	a6 1f       	adc	r26, r22
    11a6:	b7 1f       	adc	r27, r23
    11a8:	89 83       	std	Y+1, r24	; 0x01
    11aa:	9a 83       	std	Y+2, r25	; 0x02
    11ac:	ab 83       	std	Y+3, r26	; 0x03
    11ae:	bc 83       	std	Y+4, r27	; 0x04
    11b0:	2d 5f       	subi	r18, 0xFD	; 253
    11b2:	3f 4f       	sbci	r19, 0xFF	; 255
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    11b4:	2c 30       	cpi	r18, 0x0C	; 12
    11b6:	31 05       	cpc	r19, r1
    11b8:	81 f6       	brne	.-96     	; 0x115a <__vector_14+0x4e>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    11ba:	69 81       	ldd	r22, Y+1	; 0x01
    11bc:	7a 81       	ldd	r23, Y+2	; 0x02
    11be:	8b 81       	ldd	r24, Y+3	; 0x03
    11c0:	9c 81       	ldd	r25, Y+4	; 0x04
    11c2:	24 e0       	ldi	r18, 0x04	; 4
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	40 e0       	ldi	r20, 0x00	; 0
    11c8:	50 e0       	ldi	r21, 0x00	; 0
    11ca:	0e 94 21 38 	call	0x7042	; 0x7042 <__divmodsi4>
    11ce:	29 83       	std	Y+1, r18	; 0x01
    11d0:	3a 83       	std	Y+2, r19	; 0x02
    11d2:	4b 83       	std	Y+3, r20	; 0x03
    11d4:	5c 83       	std	Y+4, r21	; 0x04
	ADC_BUFFER[sampleCount] = currentSample;
    11d6:	80 91 74 50 	lds	r24, 0x5074
    11da:	90 91 75 50 	lds	r25, 0x5075
    11de:	a0 91 76 50 	lds	r26, 0x5076
    11e2:	b0 91 77 50 	lds	r27, 0x5077
    11e6:	4d 81       	ldd	r20, Y+5	; 0x05
    11e8:	5e 81       	ldd	r21, Y+6	; 0x06
    11ea:	6f 81       	ldd	r22, Y+7	; 0x07
    11ec:	78 85       	ldd	r23, Y+8	; 0x08
    11ee:	88 0f       	add	r24, r24
    11f0:	99 1f       	adc	r25, r25
    11f2:	88 0f       	add	r24, r24
    11f4:	99 1f       	adc	r25, r25
    11f6:	20 91 72 50 	lds	r18, 0x5072
    11fa:	30 91 73 50 	lds	r19, 0x5073
    11fe:	82 0f       	add	r24, r18
    1200:	93 1f       	adc	r25, r19
    1202:	fc 01       	movw	r30, r24
    1204:	40 83       	st	Z, r20
    1206:	51 83       	std	Z+1, r21	; 0x01
    1208:	62 83       	std	Z+2, r22	; 0x02
    120a:	73 83       	std	Z+3, r23	; 0x03
	sampleCount++;
    120c:	80 91 74 50 	lds	r24, 0x5074
    1210:	90 91 75 50 	lds	r25, 0x5075
    1214:	a0 91 76 50 	lds	r26, 0x5076
    1218:	b0 91 77 50 	lds	r27, 0x5077
    121c:	01 96       	adiw	r24, 0x01	; 1
    121e:	a1 1d       	adc	r26, r1
    1220:	b1 1d       	adc	r27, r1
    1222:	80 93 74 50 	sts	0x5074, r24
    1226:	90 93 75 50 	sts	0x5075, r25
    122a:	a0 93 76 50 	sts	0x5076, r26
    122e:	b0 93 77 50 	sts	0x5077, r27

}
    1232:	28 96       	adiw	r28, 0x08	; 8
    1234:	cd bf       	out	0x3d, r28	; 61
    1236:	de bf       	out	0x3e, r29	; 62
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	ff 91       	pop	r31
    123e:	ef 91       	pop	r30
    1240:	bf 91       	pop	r27
    1242:	af 91       	pop	r26
    1244:	9f 91       	pop	r25
    1246:	8f 91       	pop	r24
    1248:	7f 91       	pop	r23
    124a:	6f 91       	pop	r22
    124c:	5f 91       	pop	r21
    124e:	4f 91       	pop	r20
    1250:	3f 91       	pop	r19
    1252:	2f 91       	pop	r18
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	ff 90       	pop	r15
    125a:	0f 90       	pop	r0
    125c:	0b be       	out	0x3b, r0	; 59
    125e:	0f 90       	pop	r0
    1260:	0f be       	out	0x3f, r0	; 63
    1262:	0f 90       	pop	r0
    1264:	1f 90       	pop	r1
    1266:	18 95       	reti

00001268 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1268:	1f 92       	push	r1
    126a:	0f 92       	push	r0
    126c:	0f b6       	in	r0, 0x3f	; 63
    126e:	0f 92       	push	r0
    1270:	0b b6       	in	r0, 0x3b	; 59
    1272:	0f 92       	push	r0
    1274:	11 24       	eor	r1, r1
    1276:	ff 92       	push	r15
    1278:	0f 93       	push	r16
    127a:	1f 93       	push	r17
    127c:	2f 93       	push	r18
    127e:	3f 93       	push	r19
    1280:	4f 93       	push	r20
    1282:	5f 93       	push	r21
    1284:	6f 93       	push	r22
    1286:	7f 93       	push	r23
    1288:	8f 93       	push	r24
    128a:	9f 93       	push	r25
    128c:	af 93       	push	r26
    128e:	bf 93       	push	r27
    1290:	ef 93       	push	r30
    1292:	ff 93       	push	r31
    1294:	cf 93       	push	r28
    1296:	df 93       	push	r29
    1298:	cd b7       	in	r28, 0x3d	; 61
    129a:	de b7       	in	r29, 0x3e	; 62
    129c:	28 97       	sbiw	r28, 0x08	; 8
    129e:	cd bf       	out	0x3d, r28	; 61
    12a0:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    12a2:	19 82       	std	Y+1, r1	; 0x01
    12a4:	1a 82       	std	Y+2, r1	; 0x02
    12a6:	1b 82       	std	Y+3, r1	; 0x03
    12a8:	1c 82       	std	Y+4, r1	; 0x04
    12aa:	20 e0       	ldi	r18, 0x00	; 0
    12ac:	30 e0       	ldi	r19, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    12ae:	05 e6       	ldi	r16, 0x65	; 101
    12b0:	10 e5       	ldi	r17, 0x50	; 80
    12b2:	ff 24       	eor	r15, r15
    12b4:	fa 94       	dec	r15
    12b6:	c9 01       	movw	r24, r18
    12b8:	f8 01       	movw	r30, r16
    12ba:	e2 0f       	add	r30, r18
    12bc:	f3 1f       	adc	r31, r19
    12be:	40 81       	ld	r20, Z
    12c0:	44 23       	and	r20, r20
    12c2:	14 f4       	brge	.+4      	; 0x12c8 <__vector_77+0x60>
    12c4:	f8 86       	std	Y+8, r15	; 0x08
    12c6:	01 c0       	rjmp	.+2      	; 0x12ca <__vector_77+0x62>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    12c8:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    12ca:	80 0f       	add	r24, r16
    12cc:	91 1f       	adc	r25, r17
    12ce:	fc 01       	movw	r30, r24
    12d0:	80 81       	ld	r24, Z
    12d2:	8f 83       	std	Y+7, r24	; 0x07
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    12d4:	f9 01       	movw	r30, r18
    12d6:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    12d8:	e0 0f       	add	r30, r16
    12da:	f1 1f       	adc	r31, r17
    12dc:	80 81       	ld	r24, Z
    12de:	8e 83       	std	Y+6, r24	; 0x06
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    12e0:	f9 01       	movw	r30, r18
    12e2:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    12e4:	e0 0f       	add	r30, r16
    12e6:	f1 1f       	adc	r31, r17
    12e8:	80 81       	ld	r24, Z
    12ea:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    12ec:	49 81       	ldd	r20, Y+1	; 0x01
    12ee:	5a 81       	ldd	r21, Y+2	; 0x02
    12f0:	6b 81       	ldd	r22, Y+3	; 0x03
    12f2:	7c 81       	ldd	r23, Y+4	; 0x04
    12f4:	8d 81       	ldd	r24, Y+5	; 0x05
    12f6:	9e 81       	ldd	r25, Y+6	; 0x06
    12f8:	af 81       	ldd	r26, Y+7	; 0x07
    12fa:	b8 85       	ldd	r27, Y+8	; 0x08
    12fc:	84 0f       	add	r24, r20
    12fe:	95 1f       	adc	r25, r21
    1300:	a6 1f       	adc	r26, r22
    1302:	b7 1f       	adc	r27, r23
    1304:	89 83       	std	Y+1, r24	; 0x01
    1306:	9a 83       	std	Y+2, r25	; 0x02
    1308:	ab 83       	std	Y+3, r26	; 0x03
    130a:	bc 83       	std	Y+4, r27	; 0x04
    130c:	2d 5f       	subi	r18, 0xFD	; 253
    130e:	3f 4f       	sbci	r19, 0xFF	; 255
ISR(TCD0_OVF_vect) {

	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1310:	2c 30       	cpi	r18, 0x0C	; 12
    1312:	31 05       	cpc	r19, r1
    1314:	81 f6       	brne	.-96     	; 0x12b6 <__vector_77+0x4e>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1316:	69 81       	ldd	r22, Y+1	; 0x01
    1318:	7a 81       	ldd	r23, Y+2	; 0x02
    131a:	8b 81       	ldd	r24, Y+3	; 0x03
    131c:	9c 81       	ldd	r25, Y+4	; 0x04
    131e:	24 e0       	ldi	r18, 0x04	; 4
    1320:	30 e0       	ldi	r19, 0x00	; 0
    1322:	40 e0       	ldi	r20, 0x00	; 0
    1324:	50 e0       	ldi	r21, 0x00	; 0
    1326:	0e 94 21 38 	call	0x7042	; 0x7042 <__divmodsi4>
    132a:	29 83       	std	Y+1, r18	; 0x01
    132c:	3a 83       	std	Y+2, r19	; 0x02
    132e:	4b 83       	std	Y+3, r20	; 0x03
    1330:	5c 83       	std	Y+4, r21	; 0x04
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    1332:	80 91 74 50 	lds	r24, 0x5074
    1336:	90 91 75 50 	lds	r25, 0x5075
    133a:	a0 91 76 50 	lds	r26, 0x5076
    133e:	b0 91 77 50 	lds	r27, 0x5077
    1342:	49 81       	ldd	r20, Y+1	; 0x01
    1344:	5a 81       	ldd	r21, Y+2	; 0x02
    1346:	6b 81       	ldd	r22, Y+3	; 0x03
    1348:	7c 81       	ldd	r23, Y+4	; 0x04
    134a:	88 0f       	add	r24, r24
    134c:	99 1f       	adc	r25, r25
    134e:	88 0f       	add	r24, r24
    1350:	99 1f       	adc	r25, r25
    1352:	20 91 72 50 	lds	r18, 0x5072
    1356:	30 91 73 50 	lds	r19, 0x5073
    135a:	82 0f       	add	r24, r18
    135c:	93 1f       	adc	r25, r19
    135e:	fc 01       	movw	r30, r24
    1360:	40 83       	st	Z, r20
    1362:	51 83       	std	Z+1, r21	; 0x01
    1364:	62 83       	std	Z+2, r22	; 0x02
    1366:	73 83       	std	Z+3, r23	; 0x03
	sampleCount++;
    1368:	80 91 74 50 	lds	r24, 0x5074
    136c:	90 91 75 50 	lds	r25, 0x5075
    1370:	a0 91 76 50 	lds	r26, 0x5076
    1374:	b0 91 77 50 	lds	r27, 0x5077
    1378:	01 96       	adiw	r24, 0x01	; 1
    137a:	a1 1d       	adc	r26, r1
    137c:	b1 1d       	adc	r27, r1
    137e:	80 93 74 50 	sts	0x5074, r24
    1382:	90 93 75 50 	sts	0x5075, r25
    1386:	a0 93 76 50 	sts	0x5076, r26
    138a:	b0 93 77 50 	sts	0x5077, r27
}
    138e:	28 96       	adiw	r28, 0x08	; 8
    1390:	cd bf       	out	0x3d, r28	; 61
    1392:	de bf       	out	0x3e, r29	; 62
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	ff 91       	pop	r31
    139a:	ef 91       	pop	r30
    139c:	bf 91       	pop	r27
    139e:	af 91       	pop	r26
    13a0:	9f 91       	pop	r25
    13a2:	8f 91       	pop	r24
    13a4:	7f 91       	pop	r23
    13a6:	6f 91       	pop	r22
    13a8:	5f 91       	pop	r21
    13aa:	4f 91       	pop	r20
    13ac:	3f 91       	pop	r19
    13ae:	2f 91       	pop	r18
    13b0:	1f 91       	pop	r17
    13b2:	0f 91       	pop	r16
    13b4:	ff 90       	pop	r15
    13b6:	0f 90       	pop	r0
    13b8:	0b be       	out	0x3b, r0	; 59
    13ba:	0f 90       	pop	r0
    13bc:	0f be       	out	0x3f, r0	; 63
    13be:	0f 90       	pop	r0
    13c0:	1f 90       	pop	r1
    13c2:	18 95       	reti

000013c4 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    13c4:	82 e0       	ldi	r24, 0x02	; 2
    13c6:	e0 ea       	ldi	r30, 0xA0	; 160
    13c8:	f6 e0       	ldi	r31, 0x06	; 6
    13ca:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    13cc:	8a ea       	ldi	r24, 0xAA	; 170
    13ce:	e0 ec       	ldi	r30, 0xC0	; 192
    13d0:	f8 e0       	ldi	r31, 0x08	; 8
    13d2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    13d4:	82 81       	ldd	r24, Z+2	; 0x02
    13d6:	88 23       	and	r24, r24
    13d8:	ec f7       	brge	.-6      	; 0x13d4 <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    13da:	90 91 ce 50 	lds	r25, 0x50CE
    13de:	e0 ec       	ldi	r30, 0xC0	; 192
    13e0:	f8 e0       	ldi	r31, 0x08	; 8
    13e2:	83 81       	ldd	r24, Z+3	; 0x03
    13e4:	a5 e6       	ldi	r26, 0x65	; 101
    13e6:	b0 e5       	ldi	r27, 0x50	; 80
    13e8:	a9 0f       	add	r26, r25
    13ea:	b1 1d       	adc	r27, r1
    13ec:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    13ee:	8a ea       	ldi	r24, 0xAA	; 170
    13f0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    13f2:	82 81       	ldd	r24, Z+2	; 0x02
    13f4:	88 23       	and	r24, r24
    13f6:	ec f7       	brge	.-6      	; 0x13f2 <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    13f8:	a0 91 ce 50 	lds	r26, 0x50CE
    13fc:	b0 e0       	ldi	r27, 0x00	; 0
    13fe:	e0 ec       	ldi	r30, 0xC0	; 192
    1400:	f8 e0       	ldi	r31, 0x08	; 8
    1402:	83 81       	ldd	r24, Z+3	; 0x03
    1404:	aa 59       	subi	r26, 0x9A	; 154
    1406:	bf 4a       	sbci	r27, 0xAF	; 175
    1408:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    140a:	8a ea       	ldi	r24, 0xAA	; 170
    140c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    140e:	82 81       	ldd	r24, Z+2	; 0x02
    1410:	88 23       	and	r24, r24
    1412:	ec f7       	brge	.-6      	; 0x140e <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    1414:	e0 91 ce 50 	lds	r30, 0x50CE
    1418:	f0 e0       	ldi	r31, 0x00	; 0
    141a:	a0 ec       	ldi	r26, 0xC0	; 192
    141c:	b8 e0       	ldi	r27, 0x08	; 8
    141e:	13 96       	adiw	r26, 0x03	; 3
    1420:	8c 91       	ld	r24, X
    1422:	13 97       	sbiw	r26, 0x03	; 3
    1424:	e9 59       	subi	r30, 0x99	; 153
    1426:	ff 4a       	sbci	r31, 0xAF	; 175
    1428:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    142a:	82 e0       	ldi	r24, 0x02	; 2
    142c:	e0 ea       	ldi	r30, 0xA0	; 160
    142e:	f6 e0       	ldi	r31, 0x06	; 6
    1430:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    1432:	80 91 ce 50 	lds	r24, 0x50CE
    1436:	8d 5f       	subi	r24, 0xFD	; 253
    1438:	80 93 ce 50 	sts	0x50CE, r24
}
    143c:	08 95       	ret

0000143e <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    143e:	1f 92       	push	r1
    1440:	0f 92       	push	r0
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	0f 92       	push	r0
    1446:	0b b6       	in	r0, 0x3b	; 59
    1448:	0f 92       	push	r0
    144a:	11 24       	eor	r1, r1
    144c:	2f 93       	push	r18
    144e:	3f 93       	push	r19
    1450:	4f 93       	push	r20
    1452:	5f 93       	push	r21
    1454:	6f 93       	push	r22
    1456:	7f 93       	push	r23
    1458:	8f 93       	push	r24
    145a:	9f 93       	push	r25
    145c:	af 93       	push	r26
    145e:	bf 93       	push	r27
    1460:	ef 93       	push	r30
    1462:	ff 93       	push	r31
	sampleCurrentChannel();
    1464:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
	SPICount = 0;
    1468:	10 92 ce 50 	sts	0x50CE, r1
}
    146c:	ff 91       	pop	r31
    146e:	ef 91       	pop	r30
    1470:	bf 91       	pop	r27
    1472:	af 91       	pop	r26
    1474:	9f 91       	pop	r25
    1476:	8f 91       	pop	r24
    1478:	7f 91       	pop	r23
    147a:	6f 91       	pop	r22
    147c:	5f 91       	pop	r21
    147e:	4f 91       	pop	r20
    1480:	3f 91       	pop	r19
    1482:	2f 91       	pop	r18
    1484:	0f 90       	pop	r0
    1486:	0b be       	out	0x3b, r0	; 59
    1488:	0f 90       	pop	r0
    148a:	0f be       	out	0x3f, r0	; 63
    148c:	0f 90       	pop	r0
    148e:	1f 90       	pop	r1
    1490:	18 95       	reti

00001492 <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    1492:	1f 92       	push	r1
    1494:	0f 92       	push	r0
    1496:	0f b6       	in	r0, 0x3f	; 63
    1498:	0f 92       	push	r0
    149a:	0b b6       	in	r0, 0x3b	; 59
    149c:	0f 92       	push	r0
    149e:	11 24       	eor	r1, r1
    14a0:	2f 93       	push	r18
    14a2:	3f 93       	push	r19
    14a4:	4f 93       	push	r20
    14a6:	5f 93       	push	r21
    14a8:	6f 93       	push	r22
    14aa:	7f 93       	push	r23
    14ac:	8f 93       	push	r24
    14ae:	9f 93       	push	r25
    14b0:	af 93       	push	r26
    14b2:	bf 93       	push	r27
    14b4:	ef 93       	push	r30
    14b6:	ff 93       	push	r31
	sampleCurrentChannel();
    14b8:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
}
    14bc:	ff 91       	pop	r31
    14be:	ef 91       	pop	r30
    14c0:	bf 91       	pop	r27
    14c2:	af 91       	pop	r26
    14c4:	9f 91       	pop	r25
    14c6:	8f 91       	pop	r24
    14c8:	7f 91       	pop	r23
    14ca:	6f 91       	pop	r22
    14cc:	5f 91       	pop	r21
    14ce:	4f 91       	pop	r20
    14d0:	3f 91       	pop	r19
    14d2:	2f 91       	pop	r18
    14d4:	0f 90       	pop	r0
    14d6:	0b be       	out	0x3b, r0	; 59
    14d8:	0f 90       	pop	r0
    14da:	0f be       	out	0x3f, r0	; 63
    14dc:	0f 90       	pop	r0
    14de:	1f 90       	pop	r1
    14e0:	18 95       	reti

000014e2 <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    14e2:	1f 92       	push	r1
    14e4:	0f 92       	push	r0
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	0f 92       	push	r0
    14ea:	0b b6       	in	r0, 0x3b	; 59
    14ec:	0f 92       	push	r0
    14ee:	11 24       	eor	r1, r1
    14f0:	2f 93       	push	r18
    14f2:	3f 93       	push	r19
    14f4:	4f 93       	push	r20
    14f6:	5f 93       	push	r21
    14f8:	6f 93       	push	r22
    14fa:	7f 93       	push	r23
    14fc:	8f 93       	push	r24
    14fe:	9f 93       	push	r25
    1500:	af 93       	push	r26
    1502:	bf 93       	push	r27
    1504:	ef 93       	push	r30
    1506:	ff 93       	push	r31
	sampleCurrentChannel();
    1508:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
}
    150c:	ff 91       	pop	r31
    150e:	ef 91       	pop	r30
    1510:	bf 91       	pop	r27
    1512:	af 91       	pop	r26
    1514:	9f 91       	pop	r25
    1516:	8f 91       	pop	r24
    1518:	7f 91       	pop	r23
    151a:	6f 91       	pop	r22
    151c:	5f 91       	pop	r21
    151e:	4f 91       	pop	r20
    1520:	3f 91       	pop	r19
    1522:	2f 91       	pop	r18
    1524:	0f 90       	pop	r0
    1526:	0b be       	out	0x3b, r0	; 59
    1528:	0f 90       	pop	r0
    152a:	0f be       	out	0x3f, r0	; 63
    152c:	0f 90       	pop	r0
    152e:	1f 90       	pop	r1
    1530:	18 95       	reti

00001532 <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    1532:	1f 92       	push	r1
    1534:	0f 92       	push	r0
    1536:	0f b6       	in	r0, 0x3f	; 63
    1538:	0f 92       	push	r0
    153a:	0b b6       	in	r0, 0x3b	; 59
    153c:	0f 92       	push	r0
    153e:	11 24       	eor	r1, r1
    1540:	2f 93       	push	r18
    1542:	3f 93       	push	r19
    1544:	4f 93       	push	r20
    1546:	5f 93       	push	r21
    1548:	6f 93       	push	r22
    154a:	7f 93       	push	r23
    154c:	8f 93       	push	r24
    154e:	9f 93       	push	r25
    1550:	af 93       	push	r26
    1552:	bf 93       	push	r27
    1554:	ef 93       	push	r30
    1556:	ff 93       	push	r31
	sampleCurrentChannel();
    1558:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
}
    155c:	ff 91       	pop	r31
    155e:	ef 91       	pop	r30
    1560:	bf 91       	pop	r27
    1562:	af 91       	pop	r26
    1564:	9f 91       	pop	r25
    1566:	8f 91       	pop	r24
    1568:	7f 91       	pop	r23
    156a:	6f 91       	pop	r22
    156c:	5f 91       	pop	r21
    156e:	4f 91       	pop	r20
    1570:	3f 91       	pop	r19
    1572:	2f 91       	pop	r18
    1574:	0f 90       	pop	r0
    1576:	0b be       	out	0x3b, r0	; 59
    1578:	0f 90       	pop	r0
    157a:	0f be       	out	0x3f, r0	; 63
    157c:	0f 90       	pop	r0
    157e:	1f 90       	pop	r1
    1580:	18 95       	reti

00001582 <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    1582:	1f 92       	push	r1
    1584:	0f 92       	push	r0
    1586:	0f b6       	in	r0, 0x3f	; 63
    1588:	0f 92       	push	r0
    158a:	0b b6       	in	r0, 0x3b	; 59
    158c:	0f 92       	push	r0
    158e:	11 24       	eor	r1, r1
    1590:	2f 93       	push	r18
    1592:	3f 93       	push	r19
    1594:	4f 93       	push	r20
    1596:	5f 93       	push	r21
    1598:	6f 93       	push	r22
    159a:	7f 93       	push	r23
    159c:	8f 93       	push	r24
    159e:	9f 93       	push	r25
    15a0:	af 93       	push	r26
    15a2:	bf 93       	push	r27
    15a4:	ef 93       	push	r30
    15a6:	ff 93       	push	r31
	sampleCurrentChannel();
    15a8:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
	SPICount = 0;
    15ac:	10 92 ce 50 	sts	0x50CE, r1
	if(PORTB.OUT & PIN1_bm) {
    15b0:	e0 e2       	ldi	r30, 0x20	; 32
    15b2:	f6 e0       	ldi	r31, 0x06	; 6
    15b4:	84 81       	ldd	r24, Z+4	; 0x04
    15b6:	81 ff       	sbrs	r24, 1
    15b8:	0f c0       	rjmp	.+30     	; 0x15d8 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    15ba:	e0 e0       	ldi	r30, 0x00	; 0
    15bc:	f6 e0       	ldi	r31, 0x06	; 6
    15be:	84 81       	ldd	r24, Z+4	; 0x04
    15c0:	86 ff       	sbrs	r24, 6
    15c2:	05 c0       	rjmp	.+10     	; 0x15ce <__vector_19+0x4c>
    15c4:	82 e0       	ldi	r24, 0x02	; 2
    15c6:	e0 e2       	ldi	r30, 0x20	; 32
    15c8:	f6 e0       	ldi	r31, 0x06	; 6
    15ca:	87 83       	std	Z+7, r24	; 0x07
    15cc:	0d c0       	rjmp	.+26     	; 0x15e8 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    15ce:	80 e4       	ldi	r24, 0x40	; 64
    15d0:	e0 e0       	ldi	r30, 0x00	; 0
    15d2:	f6 e0       	ldi	r31, 0x06	; 6
    15d4:	87 83       	std	Z+7, r24	; 0x07
    15d6:	08 c0       	rjmp	.+16     	; 0x15e8 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    15d8:	80 e4       	ldi	r24, 0x40	; 64
    15da:	e0 e0       	ldi	r30, 0x00	; 0
    15dc:	f6 e0       	ldi	r31, 0x06	; 6
    15de:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    15e0:	82 e0       	ldi	r24, 0x02	; 2
    15e2:	e0 e2       	ldi	r30, 0x20	; 32
    15e4:	f6 e0       	ldi	r31, 0x06	; 6
    15e6:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    15e8:	ff 91       	pop	r31
    15ea:	ef 91       	pop	r30
    15ec:	bf 91       	pop	r27
    15ee:	af 91       	pop	r26
    15f0:	9f 91       	pop	r25
    15f2:	8f 91       	pop	r24
    15f4:	7f 91       	pop	r23
    15f6:	6f 91       	pop	r22
    15f8:	5f 91       	pop	r21
    15fa:	4f 91       	pop	r20
    15fc:	3f 91       	pop	r19
    15fe:	2f 91       	pop	r18
    1600:	0f 90       	pop	r0
    1602:	0b be       	out	0x3b, r0	; 59
    1604:	0f 90       	pop	r0
    1606:	0f be       	out	0x3f, r0	; 63
    1608:	0f 90       	pop	r0
    160a:	1f 90       	pop	r1
    160c:	18 95       	reti

0000160e <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    160e:	1f 92       	push	r1
    1610:	0f 92       	push	r0
    1612:	0f b6       	in	r0, 0x3f	; 63
    1614:	0f 92       	push	r0
    1616:	0b b6       	in	r0, 0x3b	; 59
    1618:	0f 92       	push	r0
    161a:	11 24       	eor	r1, r1
    161c:	2f 93       	push	r18
    161e:	3f 93       	push	r19
    1620:	4f 93       	push	r20
    1622:	5f 93       	push	r21
    1624:	6f 93       	push	r22
    1626:	7f 93       	push	r23
    1628:	8f 93       	push	r24
    162a:	9f 93       	push	r25
    162c:	af 93       	push	r26
    162e:	bf 93       	push	r27
    1630:	ef 93       	push	r30
    1632:	ff 93       	push	r31
	sampleCurrentChannel();
    1634:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
}
    1638:	ff 91       	pop	r31
    163a:	ef 91       	pop	r30
    163c:	bf 91       	pop	r27
    163e:	af 91       	pop	r26
    1640:	9f 91       	pop	r25
    1642:	8f 91       	pop	r24
    1644:	7f 91       	pop	r23
    1646:	6f 91       	pop	r22
    1648:	5f 91       	pop	r21
    164a:	4f 91       	pop	r20
    164c:	3f 91       	pop	r19
    164e:	2f 91       	pop	r18
    1650:	0f 90       	pop	r0
    1652:	0b be       	out	0x3b, r0	; 59
    1654:	0f 90       	pop	r0
    1656:	0f be       	out	0x3f, r0	; 63
    1658:	0f 90       	pop	r0
    165a:	1f 90       	pop	r1
    165c:	18 95       	reti

0000165e <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    165e:	1f 92       	push	r1
    1660:	0f 92       	push	r0
    1662:	0f b6       	in	r0, 0x3f	; 63
    1664:	0f 92       	push	r0
    1666:	0b b6       	in	r0, 0x3b	; 59
    1668:	0f 92       	push	r0
    166a:	11 24       	eor	r1, r1
    166c:	2f 93       	push	r18
    166e:	3f 93       	push	r19
    1670:	4f 93       	push	r20
    1672:	5f 93       	push	r21
    1674:	6f 93       	push	r22
    1676:	7f 93       	push	r23
    1678:	8f 93       	push	r24
    167a:	9f 93       	push	r25
    167c:	af 93       	push	r26
    167e:	bf 93       	push	r27
    1680:	ef 93       	push	r30
    1682:	ff 93       	push	r31
	sampleCurrentChannel();
    1684:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
}
    1688:	ff 91       	pop	r31
    168a:	ef 91       	pop	r30
    168c:	bf 91       	pop	r27
    168e:	af 91       	pop	r26
    1690:	9f 91       	pop	r25
    1692:	8f 91       	pop	r24
    1694:	7f 91       	pop	r23
    1696:	6f 91       	pop	r22
    1698:	5f 91       	pop	r21
    169a:	4f 91       	pop	r20
    169c:	3f 91       	pop	r19
    169e:	2f 91       	pop	r18
    16a0:	0f 90       	pop	r0
    16a2:	0b be       	out	0x3b, r0	; 59
    16a4:	0f 90       	pop	r0
    16a6:	0f be       	out	0x3f, r0	; 63
    16a8:	0f 90       	pop	r0
    16aa:	1f 90       	pop	r1
    16ac:	18 95       	reti

000016ae <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    16ae:	1f 92       	push	r1
    16b0:	0f 92       	push	r0
    16b2:	0f b6       	in	r0, 0x3f	; 63
    16b4:	0f 92       	push	r0
    16b6:	0b b6       	in	r0, 0x3b	; 59
    16b8:	0f 92       	push	r0
    16ba:	11 24       	eor	r1, r1
    16bc:	2f 93       	push	r18
    16be:	3f 93       	push	r19
    16c0:	4f 93       	push	r20
    16c2:	5f 93       	push	r21
    16c4:	6f 93       	push	r22
    16c6:	7f 93       	push	r23
    16c8:	8f 93       	push	r24
    16ca:	9f 93       	push	r25
    16cc:	af 93       	push	r26
    16ce:	bf 93       	push	r27
    16d0:	ef 93       	push	r30
    16d2:	ff 93       	push	r31
	sampleCurrentChannel();
    16d4:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <sampleCurrentChannel>
}
    16d8:	ff 91       	pop	r31
    16da:	ef 91       	pop	r30
    16dc:	bf 91       	pop	r27
    16de:	af 91       	pop	r26
    16e0:	9f 91       	pop	r25
    16e2:	8f 91       	pop	r24
    16e4:	7f 91       	pop	r23
    16e6:	6f 91       	pop	r22
    16e8:	5f 91       	pop	r21
    16ea:	4f 91       	pop	r20
    16ec:	3f 91       	pop	r19
    16ee:	2f 91       	pop	r18
    16f0:	0f 90       	pop	r0
    16f2:	0b be       	out	0x3b, r0	; 59
    16f4:	0f 90       	pop	r0
    16f6:	0f be       	out	0x3f, r0	; 63
    16f8:	0f 90       	pop	r0
    16fa:	1f 90       	pop	r1
    16fc:	18 95       	reti

000016fe <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    16fe:	ff 92       	push	r15
    1700:	0f 93       	push	r16
    1702:	1f 93       	push	r17
    1704:	cf 93       	push	r28
    1706:	df 93       	push	r29
    1708:	cd b7       	in	r28, 0x3d	; 61
    170a:	de b7       	in	r29, 0x3e	; 62
    170c:	28 97       	sbiw	r28, 0x08	; 8
    170e:	cd bf       	out	0x3d, r28	; 61
    1710:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1712:	19 82       	std	Y+1, r1	; 0x01
    1714:	1a 82       	std	Y+2, r1	; 0x02
    1716:	1b 82       	std	Y+3, r1	; 0x03
    1718:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    171a:	80 91 74 50 	lds	r24, 0x5074
    171e:	90 91 75 50 	lds	r25, 0x5075
    1722:	a0 91 76 50 	lds	r26, 0x5076
    1726:	b0 91 77 50 	lds	r27, 0x5077
    172a:	01 96       	adiw	r24, 0x01	; 1
    172c:	a1 1d       	adc	r26, r1
    172e:	b1 1d       	adc	r27, r1
    1730:	80 93 74 50 	sts	0x5074, r24
    1734:	90 93 75 50 	sts	0x5075, r25
    1738:	a0 93 76 50 	sts	0x5076, r26
    173c:	b0 93 77 50 	sts	0x5077, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1740:	80 ed       	ldi	r24, 0xD0	; 208
    1742:	80 93 c0 08 	sts	0x08C0, r24
    1746:	20 e0       	ldi	r18, 0x00	; 0
    1748:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    174a:	05 e6       	ldi	r16, 0x65	; 101
    174c:	10 e5       	ldi	r17, 0x50	; 80
    174e:	ff 24       	eor	r15, r15
    1750:	fa 94       	dec	r15
    1752:	c9 01       	movw	r24, r18
    1754:	f8 01       	movw	r30, r16
    1756:	e2 0f       	add	r30, r18
    1758:	f3 1f       	adc	r31, r19
    175a:	40 81       	ld	r20, Z
    175c:	44 23       	and	r20, r20
    175e:	14 f4       	brge	.+4      	; 0x1764 <writeSE2FRAM+0x66>
    1760:	f8 86       	std	Y+8, r15	; 0x08
    1762:	01 c0       	rjmp	.+2      	; 0x1766 <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1764:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1766:	80 0f       	add	r24, r16
    1768:	91 1f       	adc	r25, r17
    176a:	fc 01       	movw	r30, r24
    176c:	80 81       	ld	r24, Z
    176e:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1770:	f9 01       	movw	r30, r18
    1772:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1774:	e0 0f       	add	r30, r16
    1776:	f1 1f       	adc	r31, r17
    1778:	80 81       	ld	r24, Z
    177a:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    177c:	f9 01       	movw	r30, r18
    177e:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1780:	e0 0f       	add	r30, r16
    1782:	f1 1f       	adc	r31, r17
    1784:	80 81       	ld	r24, Z
    1786:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    1788:	49 81       	ldd	r20, Y+1	; 0x01
    178a:	5a 81       	ldd	r21, Y+2	; 0x02
    178c:	6b 81       	ldd	r22, Y+3	; 0x03
    178e:	7c 81       	ldd	r23, Y+4	; 0x04
    1790:	8d 81       	ldd	r24, Y+5	; 0x05
    1792:	9e 81       	ldd	r25, Y+6	; 0x06
    1794:	af 81       	ldd	r26, Y+7	; 0x07
    1796:	b8 85       	ldd	r27, Y+8	; 0x08
    1798:	84 0f       	add	r24, r20
    179a:	95 1f       	adc	r25, r21
    179c:	a6 1f       	adc	r26, r22
    179e:	b7 1f       	adc	r27, r23
    17a0:	89 83       	std	Y+1, r24	; 0x01
    17a2:	9a 83       	std	Y+2, r25	; 0x02
    17a4:	ab 83       	std	Y+3, r26	; 0x03
    17a6:	bc 83       	std	Y+4, r27	; 0x04
    17a8:	2d 5f       	subi	r18, 0xFD	; 253
    17aa:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    17ac:	2c 30       	cpi	r18, 0x0C	; 12
    17ae:	31 05       	cpc	r19, r1
    17b0:	81 f6       	brne	.-96     	; 0x1752 <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    17b2:	69 81       	ldd	r22, Y+1	; 0x01
    17b4:	7a 81       	ldd	r23, Y+2	; 0x02
    17b6:	8b 81       	ldd	r24, Y+3	; 0x03
    17b8:	9c 81       	ldd	r25, Y+4	; 0x04
    17ba:	24 e0       	ldi	r18, 0x04	; 4
    17bc:	30 e0       	ldi	r19, 0x00	; 0
    17be:	40 e0       	ldi	r20, 0x00	; 0
    17c0:	50 e0       	ldi	r21, 0x00	; 0
    17c2:	0e 94 21 38 	call	0x7042	; 0x7042 <__divmodsi4>
    17c6:	29 83       	std	Y+1, r18	; 0x01
    17c8:	3a 83       	std	Y+2, r19	; 0x02
    17ca:	4b 83       	std	Y+3, r20	; 0x03
    17cc:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    17ce:	29 81       	ldd	r18, Y+1	; 0x01
    17d0:	87 e6       	ldi	r24, 0x67	; 103
    17d2:	90 e5       	ldi	r25, 0x50	; 80
    17d4:	20 93 67 50 	sts	0x5067, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    17d8:	2a 81       	ldd	r18, Y+2	; 0x02
    17da:	fc 01       	movw	r30, r24
    17dc:	31 97       	sbiw	r30, 0x01	; 1
    17de:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    17e0:	2b 81       	ldd	r18, Y+3	; 0x03
    17e2:	02 97       	sbiw	r24, 0x02	; 2
    17e4:	fc 01       	movw	r30, r24
    17e6:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    17e8:	80 e1       	ldi	r24, 0x10	; 16
    17ea:	e0 e4       	ldi	r30, 0x40	; 64
    17ec:	f6 e0       	ldi	r31, 0x06	; 6
    17ee:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    17f0:	88 e0       	ldi	r24, 0x08	; 8
    17f2:	e0 e2       	ldi	r30, 0x20	; 32
    17f4:	f6 e0       	ldi	r31, 0x06	; 6
    17f6:	86 83       	std	Z+6, r24	; 0x06
	nop();
    17f8:	00 00       	nop
	SPIC.DATA = FR_WREN;
    17fa:	86 e0       	ldi	r24, 0x06	; 6
    17fc:	e0 ec       	ldi	r30, 0xC0	; 192
    17fe:	f8 e0       	ldi	r31, 0x08	; 8
    1800:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1802:	82 81       	ldd	r24, Z+2	; 0x02
    1804:	88 23       	and	r24, r24
    1806:	ec f7       	brge	.-6      	; 0x1802 <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    1808:	e0 ec       	ldi	r30, 0xC0	; 192
    180a:	f8 e0       	ldi	r31, 0x08	; 8
    180c:	83 81       	ldd	r24, Z+3	; 0x03
    180e:	80 93 71 50 	sts	0x5071, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    1812:	a0 e2       	ldi	r26, 0x20	; 32
    1814:	b6 e0       	ldi	r27, 0x06	; 6
    1816:	88 e0       	ldi	r24, 0x08	; 8
    1818:	15 96       	adiw	r26, 0x05	; 5
    181a:	8c 93       	st	X, r24
    181c:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    181e:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1820:	16 96       	adiw	r26, 0x06	; 6
    1822:	8c 93       	st	X, r24
    1824:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    1826:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    1828:	82 e0       	ldi	r24, 0x02	; 2
    182a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    182c:	82 81       	ldd	r24, Z+2	; 0x02
    182e:	88 23       	and	r24, r24
    1830:	ec f7       	brge	.-6      	; 0x182c <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    1832:	e0 ec       	ldi	r30, 0xC0	; 192
    1834:	f8 e0       	ldi	r31, 0x08	; 8
    1836:	83 81       	ldd	r24, Z+3	; 0x03
    1838:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    183c:	80 91 58 40 	lds	r24, 0x4058
    1840:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1842:	82 81       	ldd	r24, Z+2	; 0x02
    1844:	88 23       	and	r24, r24
    1846:	ec f7       	brge	.-6      	; 0x1842 <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    1848:	e0 ec       	ldi	r30, 0xC0	; 192
    184a:	f8 e0       	ldi	r31, 0x08	; 8
    184c:	83 81       	ldd	r24, Z+3	; 0x03
    184e:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1852:	80 91 57 40 	lds	r24, 0x4057
    1856:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1858:	82 81       	ldd	r24, Z+2	; 0x02
    185a:	88 23       	and	r24, r24
    185c:	ec f7       	brge	.-6      	; 0x1858 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    185e:	e0 ec       	ldi	r30, 0xC0	; 192
    1860:	f8 e0       	ldi	r31, 0x08	; 8
    1862:	83 81       	ldd	r24, Z+3	; 0x03
    1864:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[0];
    1868:	80 91 65 50 	lds	r24, 0x5065
    186c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    186e:	82 81       	ldd	r24, Z+2	; 0x02
    1870:	88 23       	and	r24, r24
    1872:	ec f7       	brge	.-6      	; 0x186e <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    1874:	e0 ec       	ldi	r30, 0xC0	; 192
    1876:	f8 e0       	ldi	r31, 0x08	; 8
    1878:	83 81       	ldd	r24, Z+3	; 0x03
    187a:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[1];
    187e:	80 91 66 50 	lds	r24, 0x5066
    1882:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1884:	82 81       	ldd	r24, Z+2	; 0x02
    1886:	88 23       	and	r24, r24
    1888:	ec f7       	brge	.-6      	; 0x1884 <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    188a:	e0 ec       	ldi	r30, 0xC0	; 192
    188c:	f8 e0       	ldi	r31, 0x08	; 8
    188e:	83 81       	ldd	r24, Z+3	; 0x03
    1890:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[2];
    1894:	80 91 67 50 	lds	r24, 0x5067
    1898:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    189a:	82 81       	ldd	r24, Z+2	; 0x02
    189c:	88 23       	and	r24, r24
    189e:	ec f7       	brge	.-6      	; 0x189a <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    18a0:	a0 ec       	ldi	r26, 0xC0	; 192
    18a2:	b8 e0       	ldi	r27, 0x08	; 8
    18a4:	13 96       	adiw	r26, 0x03	; 3
    18a6:	8c 91       	ld	r24, X
    18a8:	13 97       	sbiw	r26, 0x03	; 3
    18aa:	80 93 71 50 	sts	0x5071, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    18ae:	88 e0       	ldi	r24, 0x08	; 8
    18b0:	e0 e2       	ldi	r30, 0x20	; 32
    18b2:	f6 e0       	ldi	r31, 0x06	; 6
    18b4:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    18b6:	e0 e4       	ldi	r30, 0x40	; 64
    18b8:	f6 e0       	ldi	r31, 0x06	; 6
    18ba:	80 e1       	ldi	r24, 0x10	; 16
    18bc:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    18be:	94 e5       	ldi	r25, 0x54	; 84
    18c0:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    18c2:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    18c4:	80 91 57 40 	lds	r24, 0x4057
    18c8:	90 91 58 40 	lds	r25, 0x4058
    18cc:	03 96       	adiw	r24, 0x03	; 3
    18ce:	80 93 57 40 	sts	0x4057, r24
    18d2:	90 93 58 40 	sts	0x4058, r25
	checksumADC[0] += SPIBuffer[0];
    18d6:	80 91 3b 21 	lds	r24, 0x213B
    18da:	e5 e6       	ldi	r30, 0x65	; 101
    18dc:	f0 e5       	ldi	r31, 0x50	; 80
    18de:	90 81       	ld	r25, Z
    18e0:	89 0f       	add	r24, r25
    18e2:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[1] += SPIBuffer[1];
    18e6:	80 91 3c 21 	lds	r24, 0x213C
    18ea:	91 81       	ldd	r25, Z+1	; 0x01
    18ec:	89 0f       	add	r24, r25
    18ee:	80 93 3c 21 	sts	0x213C, r24
	checksumADC[2] += SPIBuffer[2];
    18f2:	80 91 3d 21 	lds	r24, 0x213D
    18f6:	92 81       	ldd	r25, Z+2	; 0x02
    18f8:	89 0f       	add	r24, r25
    18fa:	80 93 3d 21 	sts	0x213D, r24
}
    18fe:	28 96       	adiw	r28, 0x08	; 8
    1900:	cd bf       	out	0x3d, r28	; 61
    1902:	de bf       	out	0x3e, r29	; 62
    1904:	df 91       	pop	r29
    1906:	cf 91       	pop	r28
    1908:	1f 91       	pop	r17
    190a:	0f 91       	pop	r16
    190c:	ff 90       	pop	r15
    190e:	08 95       	ret

00001910 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1910:	2f 92       	push	r2
    1912:	3f 92       	push	r3
    1914:	4f 92       	push	r4
    1916:	5f 92       	push	r5
    1918:	6f 92       	push	r6
    191a:	7f 92       	push	r7
    191c:	8f 92       	push	r8
    191e:	9f 92       	push	r9
    1920:	af 92       	push	r10
    1922:	bf 92       	push	r11
    1924:	cf 92       	push	r12
    1926:	df 92       	push	r13
    1928:	ef 92       	push	r14
    192a:	ff 92       	push	r15
    192c:	0f 93       	push	r16
    192e:	1f 93       	push	r17
    1930:	cf 93       	push	r28
    1932:	df 93       	push	r29
    1934:	00 d0       	rcall	.+0      	; 0x1936 <calcChecksumFRAM+0x26>
    1936:	0f 92       	push	r0
    1938:	cd b7       	in	r28, 0x3d	; 61
    193a:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    193c:	eb e9       	ldi	r30, 0x9B	; 155
    193e:	f0 e5       	ldi	r31, 0x50	; 80
    1940:	10 92 9b 50 	sts	0x509B, r1
    1944:	10 92 9c 50 	sts	0x509C, r1
    1948:	10 92 9d 50 	sts	0x509D, r1
    194c:	10 92 9e 50 	sts	0x509E, r1
    1950:	10 92 9f 50 	sts	0x509F, r1
    1954:	10 92 a0 50 	sts	0x50A0, r1
    1958:	10 92 a1 50 	sts	0x50A1, r1
    195c:	10 92 a2 50 	sts	0x50A2, r1
    1960:	df 01       	movw	r26, r30
    1962:	18 97       	sbiw	r26, 0x08	; 8
    1964:	1c 92       	st	X, r1
    1966:	11 96       	adiw	r26, 0x01	; 1
    1968:	1c 92       	st	X, r1
    196a:	11 97       	sbiw	r26, 0x01	; 1
    196c:	12 96       	adiw	r26, 0x02	; 2
    196e:	1c 92       	st	X, r1
    1970:	12 97       	sbiw	r26, 0x02	; 2
    1972:	13 96       	adiw	r26, 0x03	; 3
    1974:	1c 92       	st	X, r1
    1976:	13 97       	sbiw	r26, 0x03	; 3
    1978:	14 96       	adiw	r26, 0x04	; 4
    197a:	1c 92       	st	X, r1
    197c:	14 97       	sbiw	r26, 0x04	; 4
    197e:	15 96       	adiw	r26, 0x05	; 5
    1980:	1c 92       	st	X, r1
    1982:	15 97       	sbiw	r26, 0x05	; 5
    1984:	16 96       	adiw	r26, 0x06	; 6
    1986:	1c 92       	st	X, r1
    1988:	16 97       	sbiw	r26, 0x06	; 6
    198a:	17 96       	adiw	r26, 0x07	; 7
    198c:	1c 92       	st	X, r1
    198e:	70 97       	sbiw	r30, 0x10	; 16
    1990:	10 82       	st	Z, r1
    1992:	11 82       	std	Z+1, r1	; 0x01
    1994:	12 82       	std	Z+2, r1	; 0x02
    1996:	13 82       	std	Z+3, r1	; 0x03
    1998:	14 82       	std	Z+4, r1	; 0x04
    199a:	15 82       	std	Z+5, r1	; 0x05
    199c:	16 82       	std	Z+6, r1	; 0x06
    199e:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    19a0:	8a e3       	ldi	r24, 0x3A	; 58
    19a2:	91 e2       	ldi	r25, 0x21	; 33
    19a4:	10 92 3a 21 	sts	0x213A, r1
    19a8:	fc 01       	movw	r30, r24
    19aa:	31 97       	sbiw	r30, 0x01	; 1
    19ac:	10 82       	st	Z, r1
    19ae:	02 97       	sbiw	r24, 0x02	; 2
    19b0:	dc 01       	movw	r26, r24
    19b2:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    19b4:	10 92 57 40 	sts	0x4057, r1
    19b8:	10 92 58 40 	sts	0x4058, r1
    19bc:	e9 e0       	ldi	r30, 0x09	; 9
    19be:	f0 e0       	ldi	r31, 0x00	; 0
    19c0:	e9 83       	std	Y+1, r30	; 0x01
    19c2:	fa 83       	std	Y+2, r31	; 0x02
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    19c4:	99 24       	eor	r9, r9
    19c6:	9a 94       	dec	r9
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    19c8:	0f 2e       	mov	r0, r31
    19ca:	fb e9       	ldi	r31, 0x9B	; 155
    19cc:	ef 2e       	mov	r14, r31
    19ce:	f0 e5       	ldi	r31, 0x50	; 80
    19d0:	ff 2e       	mov	r15, r31
    19d2:	f0 2d       	mov	r31, r0
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    19d4:	0f 2e       	mov	r0, r31
    19d6:	f3 e9       	ldi	r31, 0x93	; 147
    19d8:	cf 2e       	mov	r12, r31
    19da:	f0 e5       	ldi	r31, 0x50	; 80
    19dc:	df 2e       	mov	r13, r31
    19de:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    19e0:	0f 2e       	mov	r0, r31
    19e2:	fb e8       	ldi	r31, 0x8B	; 139
    19e4:	af 2e       	mov	r10, r31
    19e6:	f0 e5       	ldi	r31, 0x50	; 80
    19e8:	bf 2e       	mov	r11, r31
    19ea:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    19ec:	81 e7       	ldi	r24, 0x71	; 113
    19ee:	9c e1       	ldi	r25, 0x1C	; 28
    19f0:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    19f4:	80 91 57 40 	lds	r24, 0x4057
    19f8:	90 91 58 40 	lds	r25, 0x4058
    19fc:	8f 58       	subi	r24, 0x8F	; 143
    19fe:	93 4e       	sbci	r25, 0xE3	; 227
    1a00:	80 93 57 40 	sts	0x4057, r24
    1a04:	90 93 58 40 	sts	0x4058, r25
    1a08:	0f ed       	ldi	r16, 0xDF	; 223
    1a0a:	13 e2       	ldi	r17, 0x23	; 35
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1a0c:	80 e0       	ldi	r24, 0x00	; 0
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1a10:	0f 2e       	mov	r0, r31
    1a12:	f9 e0       	ldi	r31, 0x09	; 9
    1a14:	2f 2e       	mov	r2, r31
    1a16:	33 24       	eor	r3, r3
    1a18:	f0 2d       	mov	r31, r0
    1a1a:	8b 83       	std	Y+3, r24	; 0x03
    1a1c:	9c 83       	std	Y+4, r25	; 0x04
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a20:	9c 81       	ldd	r25, Y+4	; 0x04
    1a22:	63 e0       	ldi	r22, 0x03	; 3
    1a24:	70 e0       	ldi	r23, 0x00	; 0
    1a26:	0e 94 d8 37 	call	0x6fb0	; 0x6fb0 <__udivmodhi4>
    1a2a:	9c 01       	movw	r18, r24
    1a2c:	e8 e3       	ldi	r30, 0x38	; 56
    1a2e:	f1 e2       	ldi	r31, 0x21	; 33
    1a30:	e8 0f       	add	r30, r24
    1a32:	f9 1f       	adc	r31, r25
    1a34:	90 81       	ld	r25, Z
	checksumADC[1] += SPIBuffer[1];
	checksumADC[2] += SPIBuffer[2];
}

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1a36:	a8 01       	movw	r20, r16
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1a38:	d8 01       	movw	r26, r16
    1a3a:	8c 91       	ld	r24, X
    1a3c:	98 0f       	add	r25, r24
    1a3e:	90 83       	st	Z, r25
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    1a40:	21 15       	cp	r18, r1
    1a42:	31 05       	cpc	r19, r1
    1a44:	19 f5       	brne	.+70     	; 0x1a8c <calcChecksumFRAM+0x17c>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1a46:	88 23       	and	r24, r24
    1a48:	6c f4       	brge	.+26     	; 0x1a64 <calcChecksumFRAM+0x154>
    1a4a:	e0 91 63 50 	lds	r30, 0x5063
    1a4e:	f0 91 64 50 	lds	r31, 0x5064
    1a52:	10 82       	st	Z, r1
    1a54:	11 82       	std	Z+1, r1	; 0x01
    1a56:	12 82       	std	Z+2, r1	; 0x02
    1a58:	93 82       	std	Z+3, r9	; 0x03
    1a5a:	94 82       	std	Z+4, r9	; 0x04
    1a5c:	95 82       	std	Z+5, r9	; 0x05
    1a5e:	96 82       	std	Z+6, r9	; 0x06
    1a60:	97 82       	std	Z+7, r9	; 0x07
    1a62:	0c c0       	rjmp	.+24     	; 0x1a7c <calcChecksumFRAM+0x16c>
				else *temp64 = 0x0000000000000000;
    1a64:	e0 91 63 50 	lds	r30, 0x5063
    1a68:	f0 91 64 50 	lds	r31, 0x5064
    1a6c:	10 82       	st	Z, r1
    1a6e:	11 82       	std	Z+1, r1	; 0x01
    1a70:	12 82       	std	Z+2, r1	; 0x02
    1a72:	13 82       	std	Z+3, r1	; 0x03
    1a74:	14 82       	std	Z+4, r1	; 0x04
    1a76:	15 82       	std	Z+5, r1	; 0x05
    1a78:	16 82       	std	Z+6, r1	; 0x06
    1a7a:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    1a7c:	fa 01       	movw	r30, r20
    1a7e:	80 81       	ld	r24, Z
    1a80:	e0 91 63 50 	lds	r30, 0x5063
    1a84:	f0 91 64 50 	lds	r31, 0x5064
    1a88:	82 83       	std	Z+2, r24	; 0x02
    1a8a:	10 c0       	rjmp	.+32     	; 0x1aac <calcChecksumFRAM+0x19c>
			} else if(k%3 == 1) {
    1a8c:	21 30       	cpi	r18, 0x01	; 1
    1a8e:	31 05       	cpc	r19, r1
    1a90:	31 f4       	brne	.+12     	; 0x1a9e <calcChecksumFRAM+0x18e>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    1a92:	e0 91 63 50 	lds	r30, 0x5063
    1a96:	f0 91 64 50 	lds	r31, 0x5064
    1a9a:	81 83       	std	Z+1, r24	; 0x01
    1a9c:	07 c0       	rjmp	.+14     	; 0x1aac <calcChecksumFRAM+0x19c>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    1a9e:	e0 91 63 50 	lds	r30, 0x5063
    1aa2:	f0 91 64 50 	lds	r31, 0x5064
    1aa6:	d8 01       	movw	r26, r16
    1aa8:	8c 91       	ld	r24, X
    1aaa:	80 83       	st	Z, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1aac:	8b 81       	ldd	r24, Y+3	; 0x03
    1aae:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab0:	b1 01       	movw	r22, r2
    1ab2:	0e 94 d8 37 	call	0x6fb0	; 0x6fb0 <__udivmodhi4>
    1ab6:	82 30       	cpi	r24, 0x02	; 2
    1ab8:	91 05       	cpc	r25, r1
    1aba:	09 f0       	breq	.+2      	; 0x1abe <calcChecksumFRAM+0x1ae>
    1abc:	76 c0       	rjmp	.+236    	; 0x1baa <calcChecksumFRAM+0x29a>
    1abe:	f5 01       	movw	r30, r10
    1ac0:	60 81       	ld	r22, Z
    1ac2:	51 81       	ldd	r21, Z+1	; 0x01
    1ac4:	42 81       	ldd	r20, Z+2	; 0x02
    1ac6:	33 81       	ldd	r19, Z+3	; 0x03
    1ac8:	24 81       	ldd	r18, Z+4	; 0x04
    1aca:	95 81       	ldd	r25, Z+5	; 0x05
    1acc:	86 81       	ldd	r24, Z+6	; 0x06
    1ace:	47 80       	ldd	r4, Z+7	; 0x07
    1ad0:	e0 91 63 50 	lds	r30, 0x5063
    1ad4:	f0 91 64 50 	lds	r31, 0x5064
    1ad8:	70 81       	ld	r23, Z
    1ada:	a1 81       	ldd	r26, Z+1	; 0x01
    1adc:	b2 81       	ldd	r27, Z+2	; 0x02
    1ade:	83 80       	ldd	r8, Z+3	; 0x03
    1ae0:	74 80       	ldd	r7, Z+4	; 0x04
    1ae2:	65 80       	ldd	r6, Z+5	; 0x05
    1ae4:	56 80       	ldd	r5, Z+6	; 0x06
    1ae6:	e7 81       	ldd	r30, Z+7	; 0x07
    1ae8:	76 0f       	add	r23, r22
    1aea:	f1 e0       	ldi	r31, 0x01	; 1
    1aec:	76 17       	cp	r23, r22
    1aee:	08 f0       	brcs	.+2      	; 0x1af2 <calcChecksumFRAM+0x1e2>
    1af0:	f0 e0       	ldi	r31, 0x00	; 0
    1af2:	a5 0f       	add	r26, r21
    1af4:	61 e0       	ldi	r22, 0x01	; 1
    1af6:	a5 17       	cp	r26, r21
    1af8:	08 f0       	brcs	.+2      	; 0x1afc <calcChecksumFRAM+0x1ec>
    1afa:	60 e0       	ldi	r22, 0x00	; 0
    1afc:	fa 0f       	add	r31, r26
    1afe:	51 e0       	ldi	r21, 0x01	; 1
    1b00:	fa 17       	cp	r31, r26
    1b02:	08 f0       	brcs	.+2      	; 0x1b06 <calcChecksumFRAM+0x1f6>
    1b04:	50 e0       	ldi	r21, 0x00	; 0
    1b06:	65 2b       	or	r22, r21
    1b08:	b4 0f       	add	r27, r20
    1b0a:	51 e0       	ldi	r21, 0x01	; 1
    1b0c:	b4 17       	cp	r27, r20
    1b0e:	08 f0       	brcs	.+2      	; 0x1b12 <calcChecksumFRAM+0x202>
    1b10:	50 e0       	ldi	r21, 0x00	; 0
    1b12:	6b 0f       	add	r22, r27
    1b14:	41 e0       	ldi	r20, 0x01	; 1
    1b16:	6b 17       	cp	r22, r27
    1b18:	08 f0       	brcs	.+2      	; 0x1b1c <calcChecksumFRAM+0x20c>
    1b1a:	40 e0       	ldi	r20, 0x00	; 0
    1b1c:	54 2b       	or	r21, r20
    1b1e:	83 0e       	add	r8, r19
    1b20:	41 e0       	ldi	r20, 0x01	; 1
    1b22:	83 16       	cp	r8, r19
    1b24:	08 f0       	brcs	.+2      	; 0x1b28 <calcChecksumFRAM+0x218>
    1b26:	40 e0       	ldi	r20, 0x00	; 0
    1b28:	58 0d       	add	r21, r8
    1b2a:	31 e0       	ldi	r19, 0x01	; 1
    1b2c:	58 15       	cp	r21, r8
    1b2e:	08 f0       	brcs	.+2      	; 0x1b32 <calcChecksumFRAM+0x222>
    1b30:	30 e0       	ldi	r19, 0x00	; 0
    1b32:	43 2b       	or	r20, r19
    1b34:	72 0e       	add	r7, r18
    1b36:	31 e0       	ldi	r19, 0x01	; 1
    1b38:	72 16       	cp	r7, r18
    1b3a:	08 f0       	brcs	.+2      	; 0x1b3e <calcChecksumFRAM+0x22e>
    1b3c:	30 e0       	ldi	r19, 0x00	; 0
    1b3e:	47 0d       	add	r20, r7
    1b40:	21 e0       	ldi	r18, 0x01	; 1
    1b42:	47 15       	cp	r20, r7
    1b44:	08 f0       	brcs	.+2      	; 0x1b48 <calcChecksumFRAM+0x238>
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	32 2b       	or	r19, r18
    1b4a:	69 0e       	add	r6, r25
    1b4c:	21 e0       	ldi	r18, 0x01	; 1
    1b4e:	69 16       	cp	r6, r25
    1b50:	08 f0       	brcs	.+2      	; 0x1b54 <calcChecksumFRAM+0x244>
    1b52:	20 e0       	ldi	r18, 0x00	; 0
    1b54:	36 0d       	add	r19, r6
    1b56:	91 e0       	ldi	r25, 0x01	; 1
    1b58:	36 15       	cp	r19, r6
    1b5a:	08 f0       	brcs	.+2      	; 0x1b5e <calcChecksumFRAM+0x24e>
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	29 2b       	or	r18, r25
    1b60:	58 0e       	add	r5, r24
    1b62:	91 e0       	ldi	r25, 0x01	; 1
    1b64:	58 16       	cp	r5, r24
    1b66:	08 f0       	brcs	.+2      	; 0x1b6a <calcChecksumFRAM+0x25a>
    1b68:	90 e0       	ldi	r25, 0x00	; 0
    1b6a:	25 0d       	add	r18, r5
    1b6c:	81 e0       	ldi	r24, 0x01	; 1
    1b6e:	25 15       	cp	r18, r5
    1b70:	08 f0       	brcs	.+2      	; 0x1b74 <calcChecksumFRAM+0x264>
    1b72:	80 e0       	ldi	r24, 0x00	; 0
    1b74:	98 2b       	or	r25, r24
    1b76:	e4 0d       	add	r30, r4
    1b78:	9e 0f       	add	r25, r30
    1b7a:	d5 01       	movw	r26, r10
    1b7c:	7c 93       	st	X, r23
    1b7e:	11 96       	adiw	r26, 0x01	; 1
    1b80:	fc 93       	st	X, r31
    1b82:	11 97       	sbiw	r26, 0x01	; 1
    1b84:	12 96       	adiw	r26, 0x02	; 2
    1b86:	6c 93       	st	X, r22
    1b88:	12 97       	sbiw	r26, 0x02	; 2
    1b8a:	13 96       	adiw	r26, 0x03	; 3
    1b8c:	5c 93       	st	X, r21
    1b8e:	13 97       	sbiw	r26, 0x03	; 3
    1b90:	14 96       	adiw	r26, 0x04	; 4
    1b92:	4c 93       	st	X, r20
    1b94:	14 97       	sbiw	r26, 0x04	; 4
    1b96:	15 96       	adiw	r26, 0x05	; 5
    1b98:	3c 93       	st	X, r19
    1b9a:	15 97       	sbiw	r26, 0x05	; 5
    1b9c:	16 96       	adiw	r26, 0x06	; 6
    1b9e:	2c 93       	st	X, r18
    1ba0:	16 97       	sbiw	r26, 0x06	; 6
    1ba2:	17 96       	adiw	r26, 0x07	; 7
    1ba4:	9c 93       	st	X, r25
    1ba6:	17 97       	sbiw	r26, 0x07	; 7
    1ba8:	f3 c0       	rjmp	.+486    	; 0x1d90 <calcChecksumFRAM+0x480>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    1baa:	85 30       	cpi	r24, 0x05	; 5
    1bac:	91 05       	cpc	r25, r1
    1bae:	09 f0       	breq	.+2      	; 0x1bb2 <calcChecksumFRAM+0x2a2>
    1bb0:	76 c0       	rjmp	.+236    	; 0x1c9e <calcChecksumFRAM+0x38e>
    1bb2:	f6 01       	movw	r30, r12
    1bb4:	60 81       	ld	r22, Z
    1bb6:	51 81       	ldd	r21, Z+1	; 0x01
    1bb8:	42 81       	ldd	r20, Z+2	; 0x02
    1bba:	33 81       	ldd	r19, Z+3	; 0x03
    1bbc:	24 81       	ldd	r18, Z+4	; 0x04
    1bbe:	95 81       	ldd	r25, Z+5	; 0x05
    1bc0:	86 81       	ldd	r24, Z+6	; 0x06
    1bc2:	47 80       	ldd	r4, Z+7	; 0x07
    1bc4:	e0 91 63 50 	lds	r30, 0x5063
    1bc8:	f0 91 64 50 	lds	r31, 0x5064
    1bcc:	70 81       	ld	r23, Z
    1bce:	a1 81       	ldd	r26, Z+1	; 0x01
    1bd0:	b2 81       	ldd	r27, Z+2	; 0x02
    1bd2:	83 80       	ldd	r8, Z+3	; 0x03
    1bd4:	74 80       	ldd	r7, Z+4	; 0x04
    1bd6:	65 80       	ldd	r6, Z+5	; 0x05
    1bd8:	56 80       	ldd	r5, Z+6	; 0x06
    1bda:	e7 81       	ldd	r30, Z+7	; 0x07
    1bdc:	76 0f       	add	r23, r22
    1bde:	f1 e0       	ldi	r31, 0x01	; 1
    1be0:	76 17       	cp	r23, r22
    1be2:	08 f0       	brcs	.+2      	; 0x1be6 <calcChecksumFRAM+0x2d6>
    1be4:	f0 e0       	ldi	r31, 0x00	; 0
    1be6:	a5 0f       	add	r26, r21
    1be8:	61 e0       	ldi	r22, 0x01	; 1
    1bea:	a5 17       	cp	r26, r21
    1bec:	08 f0       	brcs	.+2      	; 0x1bf0 <calcChecksumFRAM+0x2e0>
    1bee:	60 e0       	ldi	r22, 0x00	; 0
    1bf0:	fa 0f       	add	r31, r26
    1bf2:	51 e0       	ldi	r21, 0x01	; 1
    1bf4:	fa 17       	cp	r31, r26
    1bf6:	08 f0       	brcs	.+2      	; 0x1bfa <calcChecksumFRAM+0x2ea>
    1bf8:	50 e0       	ldi	r21, 0x00	; 0
    1bfa:	65 2b       	or	r22, r21
    1bfc:	b4 0f       	add	r27, r20
    1bfe:	51 e0       	ldi	r21, 0x01	; 1
    1c00:	b4 17       	cp	r27, r20
    1c02:	08 f0       	brcs	.+2      	; 0x1c06 <calcChecksumFRAM+0x2f6>
    1c04:	50 e0       	ldi	r21, 0x00	; 0
    1c06:	6b 0f       	add	r22, r27
    1c08:	41 e0       	ldi	r20, 0x01	; 1
    1c0a:	6b 17       	cp	r22, r27
    1c0c:	08 f0       	brcs	.+2      	; 0x1c10 <calcChecksumFRAM+0x300>
    1c0e:	40 e0       	ldi	r20, 0x00	; 0
    1c10:	54 2b       	or	r21, r20
    1c12:	83 0e       	add	r8, r19
    1c14:	41 e0       	ldi	r20, 0x01	; 1
    1c16:	83 16       	cp	r8, r19
    1c18:	08 f0       	brcs	.+2      	; 0x1c1c <calcChecksumFRAM+0x30c>
    1c1a:	40 e0       	ldi	r20, 0x00	; 0
    1c1c:	58 0d       	add	r21, r8
    1c1e:	31 e0       	ldi	r19, 0x01	; 1
    1c20:	58 15       	cp	r21, r8
    1c22:	08 f0       	brcs	.+2      	; 0x1c26 <calcChecksumFRAM+0x316>
    1c24:	30 e0       	ldi	r19, 0x00	; 0
    1c26:	43 2b       	or	r20, r19
    1c28:	72 0e       	add	r7, r18
    1c2a:	31 e0       	ldi	r19, 0x01	; 1
    1c2c:	72 16       	cp	r7, r18
    1c2e:	08 f0       	brcs	.+2      	; 0x1c32 <calcChecksumFRAM+0x322>
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	47 0d       	add	r20, r7
    1c34:	21 e0       	ldi	r18, 0x01	; 1
    1c36:	47 15       	cp	r20, r7
    1c38:	08 f0       	brcs	.+2      	; 0x1c3c <calcChecksumFRAM+0x32c>
    1c3a:	20 e0       	ldi	r18, 0x00	; 0
    1c3c:	32 2b       	or	r19, r18
    1c3e:	69 0e       	add	r6, r25
    1c40:	21 e0       	ldi	r18, 0x01	; 1
    1c42:	69 16       	cp	r6, r25
    1c44:	08 f0       	brcs	.+2      	; 0x1c48 <calcChecksumFRAM+0x338>
    1c46:	20 e0       	ldi	r18, 0x00	; 0
    1c48:	36 0d       	add	r19, r6
    1c4a:	91 e0       	ldi	r25, 0x01	; 1
    1c4c:	36 15       	cp	r19, r6
    1c4e:	08 f0       	brcs	.+2      	; 0x1c52 <calcChecksumFRAM+0x342>
    1c50:	90 e0       	ldi	r25, 0x00	; 0
    1c52:	29 2b       	or	r18, r25
    1c54:	58 0e       	add	r5, r24
    1c56:	91 e0       	ldi	r25, 0x01	; 1
    1c58:	58 16       	cp	r5, r24
    1c5a:	08 f0       	brcs	.+2      	; 0x1c5e <calcChecksumFRAM+0x34e>
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
    1c5e:	25 0d       	add	r18, r5
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	25 15       	cp	r18, r5
    1c64:	08 f0       	brcs	.+2      	; 0x1c68 <calcChecksumFRAM+0x358>
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	98 2b       	or	r25, r24
    1c6a:	e4 0d       	add	r30, r4
    1c6c:	9e 0f       	add	r25, r30
    1c6e:	d6 01       	movw	r26, r12
    1c70:	7c 93       	st	X, r23
    1c72:	11 96       	adiw	r26, 0x01	; 1
    1c74:	fc 93       	st	X, r31
    1c76:	11 97       	sbiw	r26, 0x01	; 1
    1c78:	12 96       	adiw	r26, 0x02	; 2
    1c7a:	6c 93       	st	X, r22
    1c7c:	12 97       	sbiw	r26, 0x02	; 2
    1c7e:	13 96       	adiw	r26, 0x03	; 3
    1c80:	5c 93       	st	X, r21
    1c82:	13 97       	sbiw	r26, 0x03	; 3
    1c84:	14 96       	adiw	r26, 0x04	; 4
    1c86:	4c 93       	st	X, r20
    1c88:	14 97       	sbiw	r26, 0x04	; 4
    1c8a:	15 96       	adiw	r26, 0x05	; 5
    1c8c:	3c 93       	st	X, r19
    1c8e:	15 97       	sbiw	r26, 0x05	; 5
    1c90:	16 96       	adiw	r26, 0x06	; 6
    1c92:	2c 93       	st	X, r18
    1c94:	16 97       	sbiw	r26, 0x06	; 6
    1c96:	17 96       	adiw	r26, 0x07	; 7
    1c98:	9c 93       	st	X, r25
    1c9a:	17 97       	sbiw	r26, 0x07	; 7
    1c9c:	79 c0       	rjmp	.+242    	; 0x1d90 <calcChecksumFRAM+0x480>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    1c9e:	88 30       	cpi	r24, 0x08	; 8
    1ca0:	91 05       	cpc	r25, r1
    1ca2:	09 f0       	breq	.+2      	; 0x1ca6 <calcChecksumFRAM+0x396>
    1ca4:	75 c0       	rjmp	.+234    	; 0x1d90 <calcChecksumFRAM+0x480>
    1ca6:	f7 01       	movw	r30, r14
    1ca8:	60 81       	ld	r22, Z
    1caa:	51 81       	ldd	r21, Z+1	; 0x01
    1cac:	42 81       	ldd	r20, Z+2	; 0x02
    1cae:	33 81       	ldd	r19, Z+3	; 0x03
    1cb0:	24 81       	ldd	r18, Z+4	; 0x04
    1cb2:	95 81       	ldd	r25, Z+5	; 0x05
    1cb4:	86 81       	ldd	r24, Z+6	; 0x06
    1cb6:	47 80       	ldd	r4, Z+7	; 0x07
    1cb8:	e0 91 63 50 	lds	r30, 0x5063
    1cbc:	f0 91 64 50 	lds	r31, 0x5064
    1cc0:	70 81       	ld	r23, Z
    1cc2:	a1 81       	ldd	r26, Z+1	; 0x01
    1cc4:	b2 81       	ldd	r27, Z+2	; 0x02
    1cc6:	83 80       	ldd	r8, Z+3	; 0x03
    1cc8:	74 80       	ldd	r7, Z+4	; 0x04
    1cca:	65 80       	ldd	r6, Z+5	; 0x05
    1ccc:	56 80       	ldd	r5, Z+6	; 0x06
    1cce:	e7 81       	ldd	r30, Z+7	; 0x07
    1cd0:	76 0f       	add	r23, r22
    1cd2:	f1 e0       	ldi	r31, 0x01	; 1
    1cd4:	76 17       	cp	r23, r22
    1cd6:	08 f0       	brcs	.+2      	; 0x1cda <calcChecksumFRAM+0x3ca>
    1cd8:	f0 e0       	ldi	r31, 0x00	; 0
    1cda:	a5 0f       	add	r26, r21
    1cdc:	61 e0       	ldi	r22, 0x01	; 1
    1cde:	a5 17       	cp	r26, r21
    1ce0:	08 f0       	brcs	.+2      	; 0x1ce4 <calcChecksumFRAM+0x3d4>
    1ce2:	60 e0       	ldi	r22, 0x00	; 0
    1ce4:	fa 0f       	add	r31, r26
    1ce6:	51 e0       	ldi	r21, 0x01	; 1
    1ce8:	fa 17       	cp	r31, r26
    1cea:	08 f0       	brcs	.+2      	; 0x1cee <calcChecksumFRAM+0x3de>
    1cec:	50 e0       	ldi	r21, 0x00	; 0
    1cee:	65 2b       	or	r22, r21
    1cf0:	b4 0f       	add	r27, r20
    1cf2:	51 e0       	ldi	r21, 0x01	; 1
    1cf4:	b4 17       	cp	r27, r20
    1cf6:	08 f0       	brcs	.+2      	; 0x1cfa <calcChecksumFRAM+0x3ea>
    1cf8:	50 e0       	ldi	r21, 0x00	; 0
    1cfa:	6b 0f       	add	r22, r27
    1cfc:	41 e0       	ldi	r20, 0x01	; 1
    1cfe:	6b 17       	cp	r22, r27
    1d00:	08 f0       	brcs	.+2      	; 0x1d04 <calcChecksumFRAM+0x3f4>
    1d02:	40 e0       	ldi	r20, 0x00	; 0
    1d04:	54 2b       	or	r21, r20
    1d06:	83 0e       	add	r8, r19
    1d08:	41 e0       	ldi	r20, 0x01	; 1
    1d0a:	83 16       	cp	r8, r19
    1d0c:	08 f0       	brcs	.+2      	; 0x1d10 <calcChecksumFRAM+0x400>
    1d0e:	40 e0       	ldi	r20, 0x00	; 0
    1d10:	58 0d       	add	r21, r8
    1d12:	31 e0       	ldi	r19, 0x01	; 1
    1d14:	58 15       	cp	r21, r8
    1d16:	08 f0       	brcs	.+2      	; 0x1d1a <calcChecksumFRAM+0x40a>
    1d18:	30 e0       	ldi	r19, 0x00	; 0
    1d1a:	43 2b       	or	r20, r19
    1d1c:	72 0e       	add	r7, r18
    1d1e:	31 e0       	ldi	r19, 0x01	; 1
    1d20:	72 16       	cp	r7, r18
    1d22:	08 f0       	brcs	.+2      	; 0x1d26 <calcChecksumFRAM+0x416>
    1d24:	30 e0       	ldi	r19, 0x00	; 0
    1d26:	47 0d       	add	r20, r7
    1d28:	21 e0       	ldi	r18, 0x01	; 1
    1d2a:	47 15       	cp	r20, r7
    1d2c:	08 f0       	brcs	.+2      	; 0x1d30 <calcChecksumFRAM+0x420>
    1d2e:	20 e0       	ldi	r18, 0x00	; 0
    1d30:	32 2b       	or	r19, r18
    1d32:	69 0e       	add	r6, r25
    1d34:	21 e0       	ldi	r18, 0x01	; 1
    1d36:	69 16       	cp	r6, r25
    1d38:	08 f0       	brcs	.+2      	; 0x1d3c <calcChecksumFRAM+0x42c>
    1d3a:	20 e0       	ldi	r18, 0x00	; 0
    1d3c:	36 0d       	add	r19, r6
    1d3e:	91 e0       	ldi	r25, 0x01	; 1
    1d40:	36 15       	cp	r19, r6
    1d42:	08 f0       	brcs	.+2      	; 0x1d46 <calcChecksumFRAM+0x436>
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	29 2b       	or	r18, r25
    1d48:	58 0e       	add	r5, r24
    1d4a:	91 e0       	ldi	r25, 0x01	; 1
    1d4c:	58 16       	cp	r5, r24
    1d4e:	08 f0       	brcs	.+2      	; 0x1d52 <calcChecksumFRAM+0x442>
    1d50:	90 e0       	ldi	r25, 0x00	; 0
    1d52:	25 0d       	add	r18, r5
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	25 15       	cp	r18, r5
    1d58:	08 f0       	brcs	.+2      	; 0x1d5c <calcChecksumFRAM+0x44c>
    1d5a:	80 e0       	ldi	r24, 0x00	; 0
    1d5c:	98 2b       	or	r25, r24
    1d5e:	e4 0d       	add	r30, r4
    1d60:	9e 0f       	add	r25, r30
    1d62:	d7 01       	movw	r26, r14
    1d64:	7c 93       	st	X, r23
    1d66:	11 96       	adiw	r26, 0x01	; 1
    1d68:	fc 93       	st	X, r31
    1d6a:	11 97       	sbiw	r26, 0x01	; 1
    1d6c:	12 96       	adiw	r26, 0x02	; 2
    1d6e:	6c 93       	st	X, r22
    1d70:	12 97       	sbiw	r26, 0x02	; 2
    1d72:	13 96       	adiw	r26, 0x03	; 3
    1d74:	5c 93       	st	X, r21
    1d76:	13 97       	sbiw	r26, 0x03	; 3
    1d78:	14 96       	adiw	r26, 0x04	; 4
    1d7a:	4c 93       	st	X, r20
    1d7c:	14 97       	sbiw	r26, 0x04	; 4
    1d7e:	15 96       	adiw	r26, 0x05	; 5
    1d80:	3c 93       	st	X, r19
    1d82:	15 97       	sbiw	r26, 0x05	; 5
    1d84:	16 96       	adiw	r26, 0x06	; 6
    1d86:	2c 93       	st	X, r18
    1d88:	16 97       	sbiw	r26, 0x06	; 6
    1d8a:	17 96       	adiw	r26, 0x07	; 7
    1d8c:	9c 93       	st	X, r25
    1d8e:	17 97       	sbiw	r26, 0x07	; 7
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1d90:	eb 81       	ldd	r30, Y+3	; 0x03
    1d92:	fc 81       	ldd	r31, Y+4	; 0x04
    1d94:	31 96       	adiw	r30, 0x01	; 1
    1d96:	eb 83       	std	Y+3, r30	; 0x03
    1d98:	fc 83       	std	Y+4, r31	; 0x04
    1d9a:	0f 5f       	subi	r16, 0xFF	; 255
    1d9c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d9e:	2c e1       	ldi	r18, 0x1C	; 28
    1da0:	e1 37       	cpi	r30, 0x71	; 113
    1da2:	f2 07       	cpc	r31, r18
    1da4:	09 f0       	breq	.+2      	; 0x1da8 <calcChecksumFRAM+0x498>
    1da6:	3b ce       	rjmp	.-906    	; 0x1a1e <calcChecksumFRAM+0x10e>
    1da8:	89 81       	ldd	r24, Y+1	; 0x01
    1daa:	9a 81       	ldd	r25, Y+2	; 0x02
    1dac:	01 97       	sbiw	r24, 0x01	; 1
    1dae:	89 83       	std	Y+1, r24	; 0x01
    1db0:	9a 83       	std	Y+2, r25	; 0x02
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    1db2:	00 97       	sbiw	r24, 0x00	; 0
    1db4:	09 f0       	breq	.+2      	; 0x1db8 <calcChecksumFRAM+0x4a8>
    1db6:	1a ce       	rjmp	.-972    	; 0x19ec <calcChecksumFRAM+0xdc>
			
		}
		
	}
	
}
    1db8:	24 96       	adiw	r28, 0x04	; 4
    1dba:	cd bf       	out	0x3d, r28	; 61
    1dbc:	de bf       	out	0x3e, r29	; 62
    1dbe:	df 91       	pop	r29
    1dc0:	cf 91       	pop	r28
    1dc2:	1f 91       	pop	r17
    1dc4:	0f 91       	pop	r16
    1dc6:	ff 90       	pop	r15
    1dc8:	ef 90       	pop	r14
    1dca:	df 90       	pop	r13
    1dcc:	cf 90       	pop	r12
    1dce:	bf 90       	pop	r11
    1dd0:	af 90       	pop	r10
    1dd2:	9f 90       	pop	r9
    1dd4:	8f 90       	pop	r8
    1dd6:	7f 90       	pop	r7
    1dd8:	6f 90       	pop	r6
    1dda:	5f 90       	pop	r5
    1ddc:	4f 90       	pop	r4
    1dde:	3f 90       	pop	r3
    1de0:	2f 90       	pop	r2
    1de2:	08 95       	ret

00001de4 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    1de4:	2f 92       	push	r2
    1de6:	3f 92       	push	r3
    1de8:	4f 92       	push	r4
    1dea:	5f 92       	push	r5
    1dec:	6f 92       	push	r6
    1dee:	7f 92       	push	r7
    1df0:	8f 92       	push	r8
    1df2:	9f 92       	push	r9
    1df4:	af 92       	push	r10
    1df6:	bf 92       	push	r11
    1df8:	cf 92       	push	r12
    1dfa:	df 92       	push	r13
    1dfc:	ef 92       	push	r14
    1dfe:	ff 92       	push	r15
    1e00:	0f 93       	push	r16
    1e02:	1f 93       	push	r17
    1e04:	cf 93       	push	r28
    1e06:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    1e08:	10 92 57 40 	sts	0x4057, r1
    1e0c:	10 92 58 40 	sts	0x4058, r1
	sampleCount = 0;
    1e10:	10 92 74 50 	sts	0x5074, r1
    1e14:	10 92 75 50 	sts	0x5075, r1
    1e18:	10 92 76 50 	sts	0x5076, r1
    1e1c:	10 92 77 50 	sts	0x5077, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1e20:	8d e3       	ldi	r24, 0x3D	; 61
    1e22:	91 e2       	ldi	r25, 0x21	; 33
    1e24:	10 92 3d 21 	sts	0x213D, r1
    1e28:	fc 01       	movw	r30, r24
    1e2a:	31 97       	sbiw	r30, 0x01	; 1
    1e2c:	10 82       	st	Z, r1
    1e2e:	02 97       	sbiw	r24, 0x02	; 2
    1e30:	dc 01       	movw	r26, r24
    1e32:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    1e3a:	84 e0       	ldi	r24, 0x04	; 4
    1e3c:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1e40:	80 ed       	ldi	r24, 0xD0	; 208
    1e42:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    1e46:	8d e0       	ldi	r24, 0x0D	; 13
    1e48:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[1] = 0xF3;
    1e4c:	83 ef       	ldi	r24, 0xF3	; 243
    1e4e:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[2] = 0x57;
    1e52:	87 e5       	ldi	r24, 0x57	; 87
    1e54:	80 93 67 50 	sts	0x5067, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    1e58:	80 91 74 50 	lds	r24, 0x5074
    1e5c:	90 91 75 50 	lds	r25, 0x5075
    1e60:	a0 91 76 50 	lds	r26, 0x5076
    1e64:	b0 91 77 50 	lds	r27, 0x5077
    1e68:	83 35       	cpi	r24, 0x53	; 83
    1e6a:	e5 e5       	ldi	r30, 0x55	; 85
    1e6c:	9e 07       	cpc	r25, r30
    1e6e:	e0 e0       	ldi	r30, 0x00	; 0
    1e70:	ae 07       	cpc	r26, r30
    1e72:	e0 e0       	ldi	r30, 0x00	; 0
    1e74:	be 07       	cpc	r27, r30
    1e76:	08 f0       	brcs	.+2      	; 0x1e7a <FRAMWriteKnowns+0x96>
    1e78:	cc c0       	rjmp	.+408    	; 0x2012 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1e7a:	0f 2e       	mov	r0, r31
    1e7c:	f0 e4       	ldi	r31, 0x40	; 64
    1e7e:	ef 2e       	mov	r14, r31
    1e80:	f6 e0       	ldi	r31, 0x06	; 6
    1e82:	ff 2e       	mov	r15, r31
    1e84:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1e86:	40 e2       	ldi	r20, 0x20	; 32
    1e88:	56 e0       	ldi	r21, 0x06	; 6
    1e8a:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    1e8c:	e0 ec       	ldi	r30, 0xC0	; 192
    1e8e:	f8 e0       	ldi	r31, 0x08	; 8
    1e90:	0f 2e       	mov	r0, r31
    1e92:	f6 e0       	ldi	r31, 0x06	; 6
    1e94:	7f 2e       	mov	r7, r31
    1e96:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    1e98:	c1 e7       	ldi	r28, 0x71	; 113
    1e9a:	d0 e5       	ldi	r29, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    1e9c:	66 24       	eor	r6, r6
    1e9e:	68 94       	set
    1ea0:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1ea2:	0f 2e       	mov	r0, r31
    1ea4:	f7 e5       	ldi	r31, 0x57	; 87
    1ea6:	cf 2e       	mov	r12, r31
    1ea8:	f0 e4       	ldi	r31, 0x40	; 64
    1eaa:	df 2e       	mov	r13, r31
    1eac:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    1eae:	8e 01       	movw	r16, r28
    1eb0:	0c 50       	subi	r16, 0x0C	; 12
    1eb2:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    1eb4:	0f 2e       	mov	r0, r31
    1eb6:	f5 ef       	ldi	r31, 0xF5	; 245
    1eb8:	4f 2e       	mov	r4, r31
    1eba:	ff ef       	ldi	r31, 0xFF	; 255
    1ebc:	5f 2e       	mov	r5, r31
    1ebe:	f0 2d       	mov	r31, r0
    1ec0:	4c 0e       	add	r4, r28
    1ec2:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    1ec4:	0f 2e       	mov	r0, r31
    1ec6:	f6 ef       	ldi	r31, 0xF6	; 246
    1ec8:	2f 2e       	mov	r2, r31
    1eca:	ff ef       	ldi	r31, 0xFF	; 255
    1ecc:	3f 2e       	mov	r3, r31
    1ece:	f0 2d       	mov	r31, r0
    1ed0:	2c 0e       	add	r2, r28
    1ed2:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    1ed4:	6b e3       	ldi	r22, 0x3B	; 59
    1ed6:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    1ed8:	5b 01       	movw	r10, r22
    1eda:	08 94       	sec
    1edc:	a1 1c       	adc	r10, r1
    1ede:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    1ee0:	88 24       	eor	r8, r8
    1ee2:	99 24       	eor	r9, r9
    1ee4:	68 94       	set
    1ee6:	81 f8       	bld	r8, 1
    1ee8:	86 0e       	add	r8, r22
    1eea:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1eec:	30 e1       	ldi	r19, 0x10	; 16
    1eee:	d7 01       	movw	r26, r14
    1ef0:	16 96       	adiw	r26, 0x06	; 6
    1ef2:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1ef4:	da 01       	movw	r26, r20
    1ef6:	16 96       	adiw	r26, 0x06	; 6
    1ef8:	2c 93       	st	X, r18
    1efa:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    1efc:	00 00       	nop
		SPIC.DATA = FR_WREN;
    1efe:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f00:	82 81       	ldd	r24, Z+2	; 0x02
    1f02:	88 23       	and	r24, r24
    1f04:	ec f7       	brge	.-6      	; 0x1f00 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    1f06:	83 81       	ldd	r24, Z+3	; 0x03
    1f08:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    1f0a:	da 01       	movw	r26, r20
    1f0c:	15 96       	adiw	r26, 0x05	; 5
    1f0e:	2c 93       	st	X, r18
    1f10:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    1f12:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1f14:	16 96       	adiw	r26, 0x06	; 6
    1f16:	2c 93       	st	X, r18
    1f18:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    1f1a:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    1f1c:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f1e:	82 81       	ldd	r24, Z+2	; 0x02
    1f20:	88 23       	and	r24, r24
    1f22:	ec f7       	brge	.-6      	; 0x1f1e <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    1f24:	83 81       	ldd	r24, Z+3	; 0x03
    1f26:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1f28:	d6 01       	movw	r26, r12
    1f2a:	11 96       	adiw	r26, 0x01	; 1
    1f2c:	8c 91       	ld	r24, X
    1f2e:	11 97       	sbiw	r26, 0x01	; 1
    1f30:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f32:	82 81       	ldd	r24, Z+2	; 0x02
    1f34:	88 23       	and	r24, r24
    1f36:	ec f7       	brge	.-6      	; 0x1f32 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    1f38:	83 81       	ldd	r24, Z+3	; 0x03
    1f3a:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1f3c:	d6 01       	movw	r26, r12
    1f3e:	8c 91       	ld	r24, X
    1f40:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f42:	82 81       	ldd	r24, Z+2	; 0x02
    1f44:	88 23       	and	r24, r24
    1f46:	ec f7       	brge	.-6      	; 0x1f42 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    1f48:	83 81       	ldd	r24, Z+3	; 0x03
    1f4a:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    1f4c:	d8 01       	movw	r26, r16
    1f4e:	8c 91       	ld	r24, X
    1f50:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f52:	82 81       	ldd	r24, Z+2	; 0x02
    1f54:	88 23       	and	r24, r24
    1f56:	ec f7       	brge	.-6      	; 0x1f52 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    1f58:	83 81       	ldd	r24, Z+3	; 0x03
    1f5a:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    1f5c:	d2 01       	movw	r26, r4
    1f5e:	8c 91       	ld	r24, X
    1f60:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f62:	82 81       	ldd	r24, Z+2	; 0x02
    1f64:	88 23       	and	r24, r24
    1f66:	ec f7       	brge	.-6      	; 0x1f62 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    1f68:	83 81       	ldd	r24, Z+3	; 0x03
    1f6a:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    1f6c:	d1 01       	movw	r26, r2
    1f6e:	8c 91       	ld	r24, X
    1f70:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f72:	82 81       	ldd	r24, Z+2	; 0x02
    1f74:	88 23       	and	r24, r24
    1f76:	ec f7       	brge	.-6      	; 0x1f72 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    1f78:	83 81       	ldd	r24, Z+3	; 0x03
    1f7a:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    1f7c:	da 01       	movw	r26, r20
    1f7e:	15 96       	adiw	r26, 0x05	; 5
    1f80:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1f82:	30 e1       	ldi	r19, 0x10	; 16
    1f84:	d7 01       	movw	r26, r14
    1f86:	15 96       	adiw	r26, 0x05	; 5
    1f88:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    1f8a:	80 91 57 40 	lds	r24, 0x4057
    1f8e:	90 91 58 40 	lds	r25, 0x4058
    1f92:	03 96       	adiw	r24, 0x03	; 3
    1f94:	80 93 57 40 	sts	0x4057, r24
    1f98:	90 93 58 40 	sts	0x4058, r25
		checksumADC[0] += SPIBuffer[0];
    1f9c:	db 01       	movw	r26, r22
    1f9e:	8c 91       	ld	r24, X
    1fa0:	d8 01       	movw	r26, r16
    1fa2:	9c 91       	ld	r25, X
    1fa4:	89 0f       	add	r24, r25
    1fa6:	db 01       	movw	r26, r22
    1fa8:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    1faa:	d5 01       	movw	r26, r10
    1fac:	8c 91       	ld	r24, X
    1fae:	a6 e6       	ldi	r26, 0x66	; 102
    1fb0:	b0 e5       	ldi	r27, 0x50	; 80
    1fb2:	9c 91       	ld	r25, X
    1fb4:	89 0f       	add	r24, r25
    1fb6:	d5 01       	movw	r26, r10
    1fb8:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    1fba:	d4 01       	movw	r26, r8
    1fbc:	8c 91       	ld	r24, X
    1fbe:	a7 e6       	ldi	r26, 0x67	; 103
    1fc0:	b0 e5       	ldi	r27, 0x50	; 80
    1fc2:	9c 91       	ld	r25, X
    1fc4:	89 0f       	add	r24, r25
    1fc6:	d4 01       	movw	r26, r8
    1fc8:	8c 93       	st	X, r24
		
		sampleCount++;
    1fca:	80 91 74 50 	lds	r24, 0x5074
    1fce:	90 91 75 50 	lds	r25, 0x5075
    1fd2:	a0 91 76 50 	lds	r26, 0x5076
    1fd6:	b0 91 77 50 	lds	r27, 0x5077
    1fda:	01 96       	adiw	r24, 0x01	; 1
    1fdc:	a1 1d       	adc	r26, r1
    1fde:	b1 1d       	adc	r27, r1
    1fe0:	80 93 74 50 	sts	0x5074, r24
    1fe4:	90 93 75 50 	sts	0x5075, r25
    1fe8:	a0 93 76 50 	sts	0x5076, r26
    1fec:	b0 93 77 50 	sts	0x5077, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    1ff0:	80 91 74 50 	lds	r24, 0x5074
    1ff4:	90 91 75 50 	lds	r25, 0x5075
    1ff8:	a0 91 76 50 	lds	r26, 0x5076
    1ffc:	b0 91 77 50 	lds	r27, 0x5077
    2000:	83 35       	cpi	r24, 0x53	; 83
    2002:	35 e5       	ldi	r19, 0x55	; 85
    2004:	93 07       	cpc	r25, r19
    2006:	30 e0       	ldi	r19, 0x00	; 0
    2008:	a3 07       	cpc	r26, r19
    200a:	30 e0       	ldi	r19, 0x00	; 0
    200c:	b3 07       	cpc	r27, r19
    200e:	08 f4       	brcc	.+2      	; 0x2012 <FRAMWriteKnowns+0x22e>
    2010:	6d cf       	rjmp	.-294    	; 0x1eec <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2012:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	ADCPower(FALSE);
    2016:	80 e0       	ldi	r24, 0x00	; 0
    2018:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
}
    201c:	df 91       	pop	r29
    201e:	cf 91       	pop	r28
    2020:	1f 91       	pop	r17
    2022:	0f 91       	pop	r16
    2024:	ff 90       	pop	r15
    2026:	ef 90       	pop	r14
    2028:	df 90       	pop	r13
    202a:	cf 90       	pop	r12
    202c:	bf 90       	pop	r11
    202e:	af 90       	pop	r10
    2030:	9f 90       	pop	r9
    2032:	8f 90       	pop	r8
    2034:	7f 90       	pop	r7
    2036:	6f 90       	pop	r6
    2038:	5f 90       	pop	r5
    203a:	4f 90       	pop	r4
    203c:	3f 90       	pop	r3
    203e:	2f 90       	pop	r2
    2040:	08 95       	ret

00002042 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2042:	80 ff       	sbrs	r24, 0
    2044:	05 c0       	rjmp	.+10     	; 0x2050 <setADCInput+0xe>
    2046:	20 e4       	ldi	r18, 0x40	; 64
    2048:	e0 e0       	ldi	r30, 0x00	; 0
    204a:	f6 e0       	ldi	r31, 0x06	; 6
    204c:	25 83       	std	Z+5, r18	; 0x05
    204e:	04 c0       	rjmp	.+8      	; 0x2058 <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2050:	20 e4       	ldi	r18, 0x40	; 64
    2052:	e0 e0       	ldi	r30, 0x00	; 0
    2054:	f6 e0       	ldi	r31, 0x06	; 6
    2056:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2058:	81 ff       	sbrs	r24, 1
    205a:	05 c0       	rjmp	.+10     	; 0x2066 <setADCInput+0x24>
    205c:	22 e0       	ldi	r18, 0x02	; 2
    205e:	e0 e2       	ldi	r30, 0x20	; 32
    2060:	f6 e0       	ldi	r31, 0x06	; 6
    2062:	25 83       	std	Z+5, r18	; 0x05
    2064:	04 c0       	rjmp	.+8      	; 0x206e <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2066:	22 e0       	ldi	r18, 0x02	; 2
    2068:	e0 e2       	ldi	r30, 0x20	; 32
    206a:	f6 e0       	ldi	r31, 0x06	; 6
    206c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    206e:	82 ff       	sbrs	r24, 2
    2070:	05 c0       	rjmp	.+10     	; 0x207c <setADCInput+0x3a>
    2072:	84 e0       	ldi	r24, 0x04	; 4
    2074:	e0 e2       	ldi	r30, 0x20	; 32
    2076:	f6 e0       	ldi	r31, 0x06	; 6
    2078:	85 83       	std	Z+5, r24	; 0x05
    207a:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    207c:	84 e0       	ldi	r24, 0x04	; 4
    207e:	e0 e2       	ldi	r30, 0x20	; 32
    2080:	f6 e0       	ldi	r31, 0x06	; 6
    2082:	86 83       	std	Z+6, r24	; 0x06
    2084:	08 95       	ret

00002086 <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2086:	2f 92       	push	r2
    2088:	3f 92       	push	r3
    208a:	4f 92       	push	r4
    208c:	5f 92       	push	r5
    208e:	7f 92       	push	r7
    2090:	8f 92       	push	r8
    2092:	9f 92       	push	r9
    2094:	af 92       	push	r10
    2096:	bf 92       	push	r11
    2098:	cf 92       	push	r12
    209a:	df 92       	push	r13
    209c:	ef 92       	push	r14
    209e:	ff 92       	push	r15
    20a0:	0f 93       	push	r16
    20a2:	1f 93       	push	r17
    20a4:	cf 93       	push	r28
    20a6:	df 93       	push	r29
    20a8:	cd b7       	in	r28, 0x3d	; 61
    20aa:	de b7       	in	r29, 0x3e	; 62
    20ac:	18 2f       	mov	r17, r24
    20ae:	76 2e       	mov	r7, r22
    20b0:	f4 2e       	mov	r15, r20
    20b2:	19 01       	movw	r2, r18
	
	ADC_BUFFER=DataArray;
    20b4:	89 8d       	ldd	r24, Y+25	; 0x19
    20b6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    20b8:	80 93 72 50 	sts	0x5072, r24
    20bc:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    20c0:	10 92 d5 50 	sts	0x50D5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    20c4:	81 e0       	ldi	r24, 0x01	; 1
    20c6:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    20ca:	81 2f       	mov	r24, r17
    20cc:	6f 2d       	mov	r22, r15
    20ce:	0e 94 67 03 	call	0x6ce	; 0x6ce <set_ampGain>
	set_filter(filterConfig);
    20d2:	87 2d       	mov	r24, r7
    20d4:	0e 94 a0 03 	call	0x740	; 0x740 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    20d8:	8e 2d       	mov	r24, r14
    20da:	0e 94 76 08 	call	0x10ec	; 0x10ec <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    20de:	84 e0       	ldi	r24, 0x04	; 4
    20e0:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    20e4:	84 e5       	ldi	r24, 0x54	; 84
    20e6:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    20ea:	81 e0       	ldi	r24, 0x01	; 1
    20ec:	0e 94 cd 06 	call	0xd9a	; 0xd9a <enableADCMUX>
	setADCInput(channel);
    20f0:	81 2f       	mov	r24, r17
    20f2:	0e 94 21 10 	call	0x2042	; 0x2042 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    20f6:	e0 ea       	ldi	r30, 0xA0	; 160
    20f8:	f6 e0       	ldi	r31, 0x06	; 6
    20fa:	22 e0       	ldi	r18, 0x02	; 2
    20fc:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    20fe:	77 24       	eor	r7, r7
    2100:	73 94       	inc	r7
    2102:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2104:	0f 2e       	mov	r0, r31
    2106:	f0 e8       	ldi	r31, 0x80	; 128
    2108:	4f 2e       	mov	r4, r31
    210a:	f1 e0       	ldi	r31, 0x01	; 1
    210c:	5f 2e       	mov	r5, r31
    210e:	f0 2d       	mov	r31, r0
    2110:	88 e7       	ldi	r24, 0x78	; 120
    2112:	d2 01       	movw	r26, r4
    2114:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2116:	e0 e0       	ldi	r30, 0x00	; 0
    2118:	f9 e0       	ldi	r31, 0x09	; 9
    211a:	80 ef       	ldi	r24, 0xF0	; 240
    211c:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    211e:	c0 a6       	lds	r28, 0xb0
    2120:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2122:	a2 a6       	lds	r26, 0xb2
    2124:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2126:	84 a6       	lds	r24, 0xb4
    2128:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    212a:	8d 89       	ldd	r24, Y+21	; 0x15
    212c:	9e 89       	ldd	r25, Y+22	; 0x16
    212e:	86 a7       	lds	r24, 0x76
    2130:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2132:	80 2f       	mov	r24, r16
    2134:	90 e0       	ldi	r25, 0x00	; 0
    2136:	01 97       	sbiw	r24, 0x01	; 1
    2138:	86 a3       	lds	r24, 0x56
    213a:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    213c:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    213e:	8f ef       	ldi	r24, 0xFF	; 255
    2140:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2142:	80 81       	ld	r24, Z
    2144:	80 7f       	andi	r24, 0xF0	; 240
    2146:	88 60       	ori	r24, 0x08	; 8
    2148:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    214a:	10 92 74 50 	sts	0x5074, r1
    214e:	10 92 75 50 	sts	0x5075, r1
    2152:	10 92 76 50 	sts	0x5076, r1
    2156:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    215a:	10 92 ce 50 	sts	0x50CE, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    215e:	e0 ea       	ldi	r30, 0xA0	; 160
    2160:	f0 e0       	ldi	r31, 0x00	; 0
    2162:	82 81       	ldd	r24, Z+2	; 0x02
    2164:	86 60       	ori	r24, 0x06	; 6
    2166:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2168:	78 94       	sei

	SPICS(TRUE);
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2170:	80 e2       	ldi	r24, 0x20	; 32
    2172:	e0 e8       	ldi	r30, 0x80	; 128
    2174:	f6 e0       	ldi	r31, 0x06	; 6
    2176:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2178:	00 e4       	ldi	r16, 0x40	; 64
    217a:	1a e0       	ldi	r17, 0x0A	; 10
    217c:	83 e2       	ldi	r24, 0x23	; 35
    217e:	f8 01       	movw	r30, r16
    2180:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2182:	61 01       	movw	r12, r2
    2184:	ee 24       	eor	r14, r14
    2186:	ff 24       	eor	r15, r15
    2188:	60 e8       	ldi	r22, 0x80	; 128
    218a:	74 e8       	ldi	r23, 0x84	; 132
    218c:	8e e1       	ldi	r24, 0x1E	; 30
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	a7 01       	movw	r20, r14
    2192:	96 01       	movw	r18, r12
    2194:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    2198:	d8 01       	movw	r26, r16
    219a:	96 96       	adiw	r26, 0x26	; 38
    219c:	2d 93       	st	X+, r18
    219e:	3c 93       	st	X, r19
    21a0:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    21a2:	60 e4       	ldi	r22, 0x40	; 64
    21a4:	72 e4       	ldi	r23, 0x42	; 66
    21a6:	8f e0       	ldi	r24, 0x0F	; 15
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	a7 01       	movw	r20, r14
    21ac:	96 01       	movw	r18, r12
    21ae:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    21b2:	f8 01       	movw	r30, r16
    21b4:	22 af       	sts	0x72, r18
    21b6:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    21b8:	e0 e4       	ldi	r30, 0x40	; 64
    21ba:	f8 e0       	ldi	r31, 0x08	; 8
    21bc:	8f 89       	ldd	r24, Y+23	; 0x17
    21be:	98 8d       	ldd	r25, Y+24	; 0x18
    21c0:	86 a3       	lds	r24, 0x56
    21c2:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    21c4:	80 ed       	ldi	r24, 0xD0	; 208
    21c6:	d2 01       	movw	r26, r4
    21c8:	11 96       	adiw	r26, 0x01	; 1
    21ca:	8c 93       	st	X, r24
    21cc:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to med lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    21ce:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    21d0:	80 81       	ld	r24, Z
    21d2:	80 7f       	andi	r24, 0xF0	; 240
    21d4:	89 60       	ori	r24, 0x09	; 9
    21d6:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    21d8:	f8 01       	movw	r30, r16
    21da:	80 81       	ld	r24, Z
    21dc:	80 7f       	andi	r24, 0xF0	; 240
    21de:	81 60       	ori	r24, 0x01	; 1
    21e0:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    21e2:	df 91       	pop	r29
    21e4:	cf 91       	pop	r28
    21e6:	1f 91       	pop	r17
    21e8:	0f 91       	pop	r16
    21ea:	ff 90       	pop	r15
    21ec:	ef 90       	pop	r14
    21ee:	df 90       	pop	r13
    21f0:	cf 90       	pop	r12
    21f2:	bf 90       	pop	r11
    21f4:	af 90       	pop	r10
    21f6:	9f 90       	pop	r9
    21f8:	8f 90       	pop	r8
    21fa:	7f 90       	pop	r7
    21fc:	5f 90       	pop	r5
    21fe:	4f 90       	pop	r4
    2200:	3f 90       	pop	r3
    2202:	2f 90       	pop	r2
    2204:	08 95       	ret

00002206 <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2206:	2f 92       	push	r2
    2208:	3f 92       	push	r3
    220a:	4f 92       	push	r4
    220c:	5f 92       	push	r5
    220e:	6f 92       	push	r6
    2210:	7f 92       	push	r7
    2212:	8f 92       	push	r8
    2214:	9f 92       	push	r9
    2216:	af 92       	push	r10
    2218:	bf 92       	push	r11
    221a:	cf 92       	push	r12
    221c:	df 92       	push	r13
    221e:	ef 92       	push	r14
    2220:	ff 92       	push	r15
    2222:	0f 93       	push	r16
    2224:	cf 93       	push	r28
    2226:	df 93       	push	r29
    2228:	cd b7       	in	r28, 0x3d	; 61
    222a:	de b7       	in	r29, 0x3e	; 62
    222c:	96 2f       	mov	r25, r22
    222e:	1a 01       	movw	r2, r20
    2230:	52 2f       	mov	r21, r18
    2232:	70 2f       	mov	r23, r16
    2234:	d7 01       	movw	r26, r14
    2236:	36 01       	movw	r6, r12
    2238:	25 01       	movw	r4, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    223a:	00 d0       	rcall	.+0      	; 0x223c <CO_collectSeismic1Channel+0x36>
    223c:	00 d0       	rcall	.+0      	; 0x223e <CO_collectSeismic1Channel+0x38>
    223e:	2d b7       	in	r18, 0x3d	; 61
    2240:	3e b7       	in	r19, 0x3e	; 62
    2242:	2f 5f       	subi	r18, 0xFF	; 255
    2244:	3f 4f       	sbci	r19, 0xFF	; 255
    2246:	ed b7       	in	r30, 0x3d	; 61
    2248:	fe b7       	in	r31, 0x3e	; 62
    224a:	81 82       	std	Z+1, r8	; 0x01
    224c:	92 82       	std	Z+2, r9	; 0x02
    224e:	8d 88       	ldd	r8, Y+21	; 0x15
    2250:	9e 88       	ldd	r9, Y+22	; 0x16
    2252:	f9 01       	movw	r30, r18
    2254:	82 82       	std	Z+2, r8	; 0x02
    2256:	93 82       	std	Z+3, r9	; 0x03
    2258:	8f 88       	ldd	r8, Y+23	; 0x17
    225a:	98 8c       	ldd	r9, Y+24	; 0x18
    225c:	84 82       	std	Z+4, r8	; 0x04
    225e:	95 82       	std	Z+5, r9	; 0x05
    2260:	64 ec       	ldi	r22, 0xC4	; 196
    2262:	49 2f       	mov	r20, r25
    2264:	91 01       	movw	r18, r2
    2266:	05 2f       	mov	r16, r21
    2268:	e7 2e       	mov	r14, r23
    226a:	6d 01       	movw	r12, r26
    226c:	53 01       	movw	r10, r6
    226e:	42 01       	movw	r8, r4
    2270:	0e 94 43 10 	call	0x2086	; 0x2086 <CO_collectSeismic1Channel_ext>
    2274:	8d b7       	in	r24, 0x3d	; 61
    2276:	9e b7       	in	r25, 0x3e	; 62
    2278:	06 96       	adiw	r24, 0x06	; 6
    227a:	8d bf       	out	0x3d, r24	; 61
    227c:	9e bf       	out	0x3e, r25	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    227e:	df 91       	pop	r29
    2280:	cf 91       	pop	r28
    2282:	0f 91       	pop	r16
    2284:	ff 90       	pop	r15
    2286:	ef 90       	pop	r14
    2288:	df 90       	pop	r13
    228a:	cf 90       	pop	r12
    228c:	bf 90       	pop	r11
    228e:	af 90       	pop	r10
    2290:	9f 90       	pop	r9
    2292:	8f 90       	pop	r8
    2294:	7f 90       	pop	r7
    2296:	6f 90       	pop	r6
    2298:	5f 90       	pop	r5
    229a:	4f 90       	pop	r4
    229c:	3f 90       	pop	r3
    229e:	2f 90       	pop	r2
    22a0:	08 95       	ret

000022a2 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    22a2:	2f 92       	push	r2
    22a4:	3f 92       	push	r3
    22a6:	5f 92       	push	r5
    22a8:	6f 92       	push	r6
    22aa:	7f 92       	push	r7
    22ac:	8f 92       	push	r8
    22ae:	9f 92       	push	r9
    22b0:	af 92       	push	r10
    22b2:	bf 92       	push	r11
    22b4:	cf 92       	push	r12
    22b6:	df 92       	push	r13
    22b8:	ef 92       	push	r14
    22ba:	ff 92       	push	r15
    22bc:	0f 93       	push	r16
    22be:	1f 93       	push	r17
    22c0:	cf 93       	push	r28
    22c2:	df 93       	push	r29
    22c4:	0f 92       	push	r0
    22c6:	0f 92       	push	r0
    22c8:	cd b7       	in	r28, 0x3d	; 61
    22ca:	de b7       	in	r29, 0x3e	; 62
    22cc:	18 2f       	mov	r17, r24
    22ce:	3b 01       	movw	r6, r22
    22d0:	49 83       	std	Y+1, r20	; 0x01
    22d2:	5a 83       	std	Y+2, r21	; 0x02
    22d4:	52 2e       	mov	r5, r18
	
	ADC_BUFFER = DataArray;
    22d6:	89 8d       	ldd	r24, Y+25	; 0x19
    22d8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    22da:	80 93 72 50 	sts	0x5072, r24
    22de:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    22e2:	10 92 d5 50 	sts	0x50D5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    22ec:	85 e0       	ldi	r24, 0x05	; 5
    22ee:	d3 01       	movw	r26, r6
    22f0:	6c 91       	ld	r22, X
    22f2:	0e 94 67 03 	call	0x6ce	; 0x6ce <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    22f6:	86 e0       	ldi	r24, 0x06	; 6
    22f8:	f3 01       	movw	r30, r6
    22fa:	61 81       	ldd	r22, Z+1	; 0x01
    22fc:	0e 94 67 03 	call	0x6ce	; 0x6ce <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2300:	87 e0       	ldi	r24, 0x07	; 7
    2302:	d3 01       	movw	r26, r6
    2304:	12 96       	adiw	r26, 0x02	; 2
    2306:	6c 91       	ld	r22, X
    2308:	0e 94 67 03 	call	0x6ce	; 0x6ce <set_ampGain>
	set_filter(filterConfig);
    230c:	81 2f       	mov	r24, r17
    230e:	0e 94 a0 03 	call	0x740	; 0x740 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2312:	80 2f       	mov	r24, r16
    2314:	0e 94 76 08 	call	0x10ec	; 0x10ec <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2318:	84 e0       	ldi	r24, 0x04	; 4
    231a:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    231e:	84 e5       	ldi	r24, 0x54	; 84
    2320:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2324:	81 e0       	ldi	r24, 0x01	; 1
    2326:	0e 94 cd 06 	call	0xd9a	; 0xd9a <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    232a:	85 e0       	ldi	r24, 0x05	; 5
    232c:	0e 94 21 10 	call	0x2042	; 0x2042 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2330:	e0 ea       	ldi	r30, 0xA0	; 160
    2332:	f6 e0       	ldi	r31, 0x06	; 6
    2334:	22 e0       	ldi	r18, 0x02	; 2
    2336:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2338:	66 24       	eor	r6, r6
    233a:	63 94       	inc	r6
    233c:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    233e:	0f 2e       	mov	r0, r31
    2340:	f0 e8       	ldi	r31, 0x80	; 128
    2342:	2f 2e       	mov	r2, r31
    2344:	f1 e0       	ldi	r31, 0x01	; 1
    2346:	3f 2e       	mov	r3, r31
    2348:	f0 2d       	mov	r31, r0
    234a:	88 e7       	ldi	r24, 0x78	; 120
    234c:	f1 01       	movw	r30, r2
    234e:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2350:	e0 e0       	ldi	r30, 0x00	; 0
    2352:	f8 e0       	ldi	r31, 0x08	; 8
    2354:	80 ef       	ldi	r24, 0xF0	; 240
    2356:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2358:	e0 a6       	lds	r30, 0xb0
    235a:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    235c:	c2 a6       	lds	r28, 0xb2
    235e:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2360:	a4 a6       	lds	r26, 0xb4
    2362:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2364:	86 a6       	lds	r24, 0xb6
    2366:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2368:	85 2d       	mov	r24, r5
    236a:	90 e0       	ldi	r25, 0x00	; 0
    236c:	01 97       	sbiw	r24, 0x01	; 1
    236e:	86 a3       	lds	r24, 0x56
    2370:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2372:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2374:	8f ef       	ldi	r24, 0xFF	; 255
    2376:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2378:	80 81       	ld	r24, Z
    237a:	80 7f       	andi	r24, 0xF0	; 240
    237c:	88 60       	ori	r24, 0x08	; 8
    237e:	80 83       	st	Z, r24

	sampleCount = 0;
    2380:	10 92 74 50 	sts	0x5074, r1
    2384:	10 92 75 50 	sts	0x5075, r1
    2388:	10 92 76 50 	sts	0x5076, r1
    238c:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    2390:	10 92 ce 50 	sts	0x50CE, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2394:	8d e3       	ldi	r24, 0x3D	; 61
    2396:	91 e2       	ldi	r25, 0x21	; 33
    2398:	10 92 3d 21 	sts	0x213D, r1
    239c:	fc 01       	movw	r30, r24
    239e:	31 97       	sbiw	r30, 0x01	; 1
    23a0:	10 82       	st	Z, r1
    23a2:	02 97       	sbiw	r24, 0x02	; 2
    23a4:	dc 01       	movw	r26, r24
    23a6:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    23a8:	e0 ea       	ldi	r30, 0xA0	; 160
    23aa:	f0 e0       	ldi	r31, 0x00	; 0
    23ac:	82 81       	ldd	r24, Z+2	; 0x02
    23ae:	86 60       	ori	r24, 0x06	; 6
    23b0:	82 83       	std	Z+2, r24	; 0x02
	sei();
    23b2:	78 94       	sei

	SPICS(TRUE);
    23b4:	81 e0       	ldi	r24, 0x01	; 1
    23b6:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    23ba:	80 e2       	ldi	r24, 0x20	; 32
    23bc:	e0 e8       	ldi	r30, 0x80	; 128
    23be:	f6 e0       	ldi	r31, 0x06	; 6
    23c0:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    23c2:	00 e4       	ldi	r16, 0x40	; 64
    23c4:	1a e0       	ldi	r17, 0x0A	; 10
    23c6:	83 e2       	ldi	r24, 0x23	; 35
    23c8:	f8 01       	movw	r30, r16
    23ca:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    23cc:	89 81       	ldd	r24, Y+1	; 0x01
    23ce:	9a 81       	ldd	r25, Y+2	; 0x02
    23d0:	6c 01       	movw	r12, r24
    23d2:	ee 24       	eor	r14, r14
    23d4:	ff 24       	eor	r15, r15
    23d6:	60 e8       	ldi	r22, 0x80	; 128
    23d8:	74 e8       	ldi	r23, 0x84	; 132
    23da:	8e e1       	ldi	r24, 0x1E	; 30
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	a7 01       	movw	r20, r14
    23e0:	96 01       	movw	r18, r12
    23e2:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    23e6:	d8 01       	movw	r26, r16
    23e8:	96 96       	adiw	r26, 0x26	; 38
    23ea:	2d 93       	st	X+, r18
    23ec:	3c 93       	st	X, r19
    23ee:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    23f0:	60 e4       	ldi	r22, 0x40	; 64
    23f2:	72 e4       	ldi	r23, 0x42	; 66
    23f4:	8f e0       	ldi	r24, 0x0F	; 15
    23f6:	90 e0       	ldi	r25, 0x00	; 0
    23f8:	a7 01       	movw	r20, r14
    23fa:	96 01       	movw	r18, r12
    23fc:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    2400:	f8 01       	movw	r30, r16
    2402:	22 af       	sts	0x72, r18
    2404:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2406:	e0 e4       	ldi	r30, 0x40	; 64
    2408:	f8 e0       	ldi	r31, 0x08	; 8
    240a:	8f 89       	ldd	r24, Y+23	; 0x17
    240c:	98 8d       	ldd	r25, Y+24	; 0x18
    240e:	86 a3       	lds	r24, 0x56
    2410:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2412:	80 ec       	ldi	r24, 0xC0	; 192
    2414:	d1 01       	movw	r26, r2
    2416:	11 96       	adiw	r26, 0x01	; 1
    2418:	8c 93       	st	X, r24
    241a:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to med lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    241c:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    241e:	80 81       	ld	r24, Z
    2420:	80 7f       	andi	r24, 0xF0	; 240
    2422:	89 60       	ori	r24, 0x09	; 9
    2424:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2426:	f8 01       	movw	r30, r16
    2428:	80 81       	ld	r24, Z
    242a:	80 7f       	andi	r24, 0xF0	; 240
    242c:	81 60       	ori	r24, 0x01	; 1
    242e:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2430:	0f 90       	pop	r0
    2432:	0f 90       	pop	r0
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	1f 91       	pop	r17
    243a:	0f 91       	pop	r16
    243c:	ff 90       	pop	r15
    243e:	ef 90       	pop	r14
    2440:	df 90       	pop	r13
    2442:	cf 90       	pop	r12
    2444:	bf 90       	pop	r11
    2446:	af 90       	pop	r10
    2448:	9f 90       	pop	r9
    244a:	8f 90       	pop	r8
    244c:	7f 90       	pop	r7
    244e:	6f 90       	pop	r6
    2450:	5f 90       	pop	r5
    2452:	3f 90       	pop	r3
    2454:	2f 90       	pop	r2
    2456:	08 95       	ret

00002458 <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2458:	2f 92       	push	r2
    245a:	3f 92       	push	r3
    245c:	4f 92       	push	r4
    245e:	5f 92       	push	r5
    2460:	6f 92       	push	r6
    2462:	7f 92       	push	r7
    2464:	8f 92       	push	r8
    2466:	9f 92       	push	r9
    2468:	af 92       	push	r10
    246a:	bf 92       	push	r11
    246c:	cf 92       	push	r12
    246e:	df 92       	push	r13
    2470:	ef 92       	push	r14
    2472:	ff 92       	push	r15
    2474:	0f 93       	push	r16
    2476:	1f 93       	push	r17
    2478:	cf 93       	push	r28
    247a:	df 93       	push	r29
    247c:	00 d0       	rcall	.+0      	; 0x247e <CO_collectSeismic3Axises+0x26>
    247e:	0f 92       	push	r0
    2480:	cd b7       	in	r28, 0x3d	; 61
    2482:	de b7       	in	r29, 0x3e	; 62
    2484:	8b 83       	std	Y+3, r24	; 0x03
    2486:	9c 83       	std	Y+4, r25	; 0x04
    2488:	db 01       	movw	r26, r22
    248a:	94 2f       	mov	r25, r20
    248c:	32 2f       	mov	r19, r18
    248e:	38 01       	movw	r6, r16
    2490:	27 01       	movw	r4, r14
    2492:	16 01       	movw	r2, r12
    2494:	a9 82       	std	Y+1, r10	; 0x01
    2496:	ba 82       	std	Y+2, r11	; 0x02
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    2498:	00 d0       	rcall	.+0      	; 0x249a <CO_collectSeismic3Axises+0x42>
    249a:	0f 92       	push	r0
    249c:	ed b7       	in	r30, 0x3d	; 61
    249e:	fe b7       	in	r31, 0x3e	; 62
    24a0:	81 82       	std	Z+1, r8	; 0x01
    24a2:	92 82       	std	Z+2, r9	; 0x02
    24a4:	4a 8d       	ldd	r20, Y+26	; 0x1a
    24a6:	5b 8d       	ldd	r21, Y+27	; 0x1b
    24a8:	43 83       	std	Z+3, r20	; 0x03
    24aa:	54 83       	std	Z+4, r21	; 0x04
    24ac:	84 ec       	ldi	r24, 0xC4	; 196
    24ae:	6b 81       	ldd	r22, Y+3	; 0x03
    24b0:	7c 81       	ldd	r23, Y+4	; 0x04
    24b2:	ad 01       	movw	r20, r26
    24b4:	29 2f       	mov	r18, r25
    24b6:	03 2f       	mov	r16, r19
    24b8:	73 01       	movw	r14, r6
    24ba:	62 01       	movw	r12, r4
    24bc:	51 01       	movw	r10, r2
    24be:	89 80       	ldd	r8, Y+1	; 0x01
    24c0:	9a 80       	ldd	r9, Y+2	; 0x02
    24c2:	0e 94 51 11 	call	0x22a2	; 0x22a2 <CO_collectSeismic3Axises_ext>
    24c6:	0f 90       	pop	r0
    24c8:	0f 90       	pop	r0
    24ca:	0f 90       	pop	r0
    24cc:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    24ce:	24 96       	adiw	r28, 0x04	; 4
    24d0:	cd bf       	out	0x3d, r28	; 61
    24d2:	de bf       	out	0x3e, r29	; 62
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	1f 91       	pop	r17
    24da:	0f 91       	pop	r16
    24dc:	ff 90       	pop	r15
    24de:	ef 90       	pop	r14
    24e0:	df 90       	pop	r13
    24e2:	cf 90       	pop	r12
    24e4:	bf 90       	pop	r11
    24e6:	af 90       	pop	r10
    24e8:	9f 90       	pop	r9
    24ea:	8f 90       	pop	r8
    24ec:	7f 90       	pop	r7
    24ee:	6f 90       	pop	r6
    24f0:	5f 90       	pop	r5
    24f2:	4f 90       	pop	r4
    24f4:	3f 90       	pop	r3
    24f6:	2f 90       	pop	r2
    24f8:	08 95       	ret

000024fa <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    24fa:	8f 92       	push	r8
    24fc:	9f 92       	push	r9
    24fe:	af 92       	push	r10
    2500:	bf 92       	push	r11
    2502:	df 92       	push	r13
    2504:	ef 92       	push	r14
    2506:	ff 92       	push	r15
    2508:	0f 93       	push	r16
    250a:	1f 93       	push	r17
    250c:	cf 93       	push	r28
    250e:	df 93       	push	r29
    2510:	c8 2f       	mov	r28, r24
    2512:	d6 2e       	mov	r13, r22
    2514:	d4 2f       	mov	r29, r20
    2516:	59 01       	movw	r10, r18
    2518:	48 01       	movw	r8, r16


	uint16_t period;
	ADC_BUFFER = DataArray;
    251a:	e0 92 72 50 	sts	0x5072, r14
    251e:	f0 92 73 50 	sts	0x5073, r15
	ADC_Sampling_Finished = 0;
    2522:	10 92 d5 50 	sts	0x50D5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2526:	81 e0       	ldi	r24, 0x01	; 1
    2528:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    252c:	8c 2f       	mov	r24, r28
    252e:	6d 2f       	mov	r22, r29
    2530:	0e 94 67 03 	call	0x6ce	; 0x6ce <set_ampGain>
	set_filter(filterConfig);
    2534:	8d 2d       	mov	r24, r13
    2536:	0e 94 a0 03 	call	0x740	; 0x740 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    253a:	8c 2f       	mov	r24, r28
    253c:	85 50       	subi	r24, 0x05	; 5
    253e:	83 30       	cpi	r24, 0x03	; 3
    2540:	18 f4       	brcc	.+6      	; 0x2548 <CO_collectADC_ext+0x4e>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	0e 94 76 08 	call	0x10ec	; 0x10ec <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2548:	81 e0       	ldi	r24, 0x01	; 1
    254a:	0e 94 cd 06 	call	0xd9a	; 0xd9a <enableADCMUX>
	setADCInput(channel);
    254e:	8c 2f       	mov	r24, r28
    2550:	0e 94 21 10 	call	0x2042	; 0x2042 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2554:	84 e0       	ldi	r24, 0x04	; 4
    2556:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    255a:	84 e5       	ldi	r24, 0x54	; 84
    255c:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2560:	e0 ea       	ldi	r30, 0xA0	; 160
    2562:	f6 e0       	ldi	r31, 0x06	; 6
    2564:	dd 24       	eor	r13, r13
    2566:	d3 94       	inc	r13
    2568:	d2 82       	std	Z+2, r13	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    256a:	82 e0       	ldi	r24, 0x02	; 2
    256c:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    256e:	d2 86       	std	Z+10, r13	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2570:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2572:	80 e2       	ldi	r24, 0x20	; 32
    2574:	e0 e8       	ldi	r30, 0x80	; 128
    2576:	f6 e0       	ldi	r31, 0x06	; 6
    2578:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    257a:	c0 e4       	ldi	r28, 0x40	; 64
    257c:	da e0       	ldi	r29, 0x0A	; 10
    257e:	83 e2       	ldi	r24, 0x23	; 35
    2580:	89 83       	std	Y+1, r24	; 0x01
	// set period
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2582:	95 01       	movw	r18, r10
    2584:	40 e0       	ldi	r20, 0x00	; 0
    2586:	50 e0       	ldi	r21, 0x00	; 0
    2588:	60 e8       	ldi	r22, 0x80	; 128
    258a:	74 e8       	ldi	r23, 0x84	; 132
    258c:	8e e1       	ldi	r24, 0x1E	; 30
    258e:	90 e0       	ldi	r25, 0x00	; 0
    2590:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    2594:	89 01       	movw	r16, r18
    2596:	9a 01       	movw	r18, r20
    2598:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    259a:	0e a3       	lds	r16, 0x5e
    259c:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    259e:	96 95       	lsr	r25
    25a0:	87 95       	ror	r24
    25a2:	8a af       	sts	0x7a, r24
    25a4:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    25a6:	e0 e4       	ldi	r30, 0x40	; 64
    25a8:	f8 e0       	ldi	r31, 0x08	; 8
    25aa:	86 a2       	lds	r24, 0x96
    25ac:	97 a2       	lds	r25, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    25ae:	88 e7       	ldi	r24, 0x78	; 120
    25b0:	a0 e8       	ldi	r26, 0x80	; 128
    25b2:	b1 e0       	ldi	r27, 0x01	; 1
    25b4:	11 96       	adiw	r26, 0x01	; 1
    25b6:	8c 93       	st	X, r24
    25b8:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    25ba:	d6 82       	std	Z+6, r13	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    25bc:	88 81       	ld	r24, Y
    25be:	80 7f       	andi	r24, 0xF0	; 240
    25c0:	81 60       	ori	r24, 0x01	; 1
    25c2:	88 83       	st	Y, r24
	
	sampleCount = 0;
    25c4:	10 92 74 50 	sts	0x5074, r1
    25c8:	10 92 75 50 	sts	0x5075, r1
    25cc:	10 92 76 50 	sts	0x5076, r1
    25d0:	10 92 77 50 	sts	0x5077, r1
	discardCount = 0;
    25d4:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    25d8:	e0 ea       	ldi	r30, 0xA0	; 160
    25da:	f0 e0       	ldi	r31, 0x00	; 0
    25dc:	82 81       	ldd	r24, Z+2	; 0x02
    25de:	81 60       	ori	r24, 0x01	; 1
    25e0:	82 83       	std	Z+2, r24	; 0x02
	sei();
    25e2:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    25e4:	df 91       	pop	r29
    25e6:	cf 91       	pop	r28
    25e8:	1f 91       	pop	r17
    25ea:	0f 91       	pop	r16
    25ec:	ff 90       	pop	r15
    25ee:	ef 90       	pop	r14
    25f0:	df 90       	pop	r13
    25f2:	bf 90       	pop	r11
    25f4:	af 90       	pop	r10
    25f6:	9f 90       	pop	r9
    25f8:	8f 90       	pop	r8
    25fa:	08 95       	ret

000025fc <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    25fc:	ef 92       	push	r14
    25fe:	ff 92       	push	r15
    2600:	0f 93       	push	r16
    2602:	1f 93       	push	r17
    2604:	96 2f       	mov	r25, r22
    2606:	fa 01       	movw	r30, r20
    2608:	d9 01       	movw	r26, r18
    260a:	78 01       	movw	r14, r16
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    260c:	64 ec       	ldi	r22, 0xC4	; 196
    260e:	49 2f       	mov	r20, r25
    2610:	9f 01       	movw	r18, r30
    2612:	8d 01       	movw	r16, r26
    2614:	0e 94 7d 12 	call	0x24fa	; 0x24fa <CO_collectADC_ext>
}
    2618:	1f 91       	pop	r17
    261a:	0f 91       	pop	r16
    261c:	ff 90       	pop	r15
    261e:	ef 90       	pop	r14
    2620:	08 95       	ret

00002622 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2622:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2624:	81 e0       	ldi	r24, 0x01	; 1
    2626:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2628:	84 81       	ldd	r24, Z+4	; 0x04
    262a:	95 81       	ldd	r25, Z+5	; 0x05
    262c:	86 1b       	sub	r24, r22
    262e:	91 09       	sbc	r25, r1

	return answer;
}
    2630:	08 95       	ret

00002632 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2632:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2638:	84 81       	ldd	r24, Z+4	; 0x04
    263a:	95 81       	ldd	r25, Z+5	; 0x05
    263c:	77 27       	eor	r23, r23
    263e:	67 fd       	sbrc	r22, 7
    2640:	70 95       	com	r23
    2642:	86 1b       	sub	r24, r22
    2644:	97 0b       	sbc	r25, r23

	return answer;
}
    2646:	08 95       	ret

00002648 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2648:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    264a:	81 e0       	ldi	r24, 0x01	; 1
    264c:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    264e:	84 81       	ldd	r24, Z+4	; 0x04
    2650:	95 81       	ldd	r25, Z+5	; 0x05
}
    2652:	08 95       	ret

00002654 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2654:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2656:	81 e0       	ldi	r24, 0x01	; 1
    2658:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    265a:	84 81       	ldd	r24, Z+4	; 0x04
}
    265c:	08 95       	ret

0000265e <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    265e:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2660:	81 e0       	ldi	r24, 0x01	; 1
    2662:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2664:	85 81       	ldd	r24, Z+5	; 0x05
}
    2666:	08 95       	ret

00002668 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2668:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    266a:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    266c:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    266e:	9a e2       	ldi	r25, 0x2A	; 42
    2670:	9a 95       	dec	r25
    2672:	f1 f7       	brne	.-4      	; 0x2670 <ADC_Wait_8MHz+0x8>
    2674:	00 c0       	rjmp	.+0      	; 0x2676 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2676:	84 83       	std	Z+4, r24	; 0x04
}
    2678:	08 95       	ret

0000267a <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    267a:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    267c:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    267e:	91 e0       	ldi	r25, 0x01	; 1
    2680:	94 83       	std	Z+4, r25	; 0x04
    2682:	95 e5       	ldi	r25, 0x55	; 85
    2684:	9a 95       	dec	r25
    2686:	f1 f7       	brne	.-4      	; 0x2684 <ADC_Wait_32MHz+0xa>
    2688:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    268a:	84 83       	std	Z+4, r24	; 0x04
}
    268c:	08 95       	ret

0000268e <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    268e:	ef 92       	push	r14
    2690:	ff 92       	push	r15
    2692:	0f 93       	push	r16
    2694:	1f 93       	push	r17
    2696:	cf 93       	push	r28
    2698:	df 93       	push	r29
    269a:	eb 01       	movw	r28, r22
    if (oversampling)
    269c:	44 23       	and	r20, r20
    269e:	c9 f0       	breq	.+50     	; 0x26d2 <ADC_Offset_Get_Unsigned+0x44>
    26a0:	04 e0       	ldi	r16, 0x04	; 4
    26a2:	10 e0       	ldi	r17, 0x00	; 0
    26a4:	ee 24       	eor	r14, r14
    26a6:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    26a8:	88 81       	ld	r24, Y
    26aa:	80 68       	ori	r24, 0x80	; 128
    26ac:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    26ae:	8b 81       	ldd	r24, Y+3	; 0x03
    26b0:	80 ff       	sbrs	r24, 0
    26b2:	fd cf       	rjmp	.-6      	; 0x26ae <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    26b4:	ce 01       	movw	r24, r28
    26b6:	60 e0       	ldi	r22, 0x00	; 0
    26b8:	0e 94 11 13 	call	0x2622	; 0x2622 <ADC_ResultCh_GetWord_Unsigned>
    26bc:	e8 0e       	add	r14, r24
    26be:	f9 1e       	adc	r15, r25
    26c0:	01 50       	subi	r16, 0x01	; 1
    26c2:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    26c4:	89 f7       	brne	.-30     	; 0x26a8 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    26c6:	c7 01       	movw	r24, r14
    26c8:	96 95       	lsr	r25
    26ca:	87 95       	ror	r24
    26cc:	96 95       	lsr	r25
    26ce:	87 95       	ror	r24
    26d0:	09 c0       	rjmp	.+18     	; 0x26e4 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    26d2:	88 81       	ld	r24, Y
    26d4:	80 68       	ori	r24, 0x80	; 128
    26d6:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    26d8:	8b 81       	ldd	r24, Y+3	; 0x03
    26da:	80 ff       	sbrs	r24, 0
    26dc:	fd cf       	rjmp	.-6      	; 0x26d8 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    26de:	ce 01       	movw	r24, r28
    26e0:	0e 94 24 13 	call	0x2648	; 0x2648 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    26e4:	df 91       	pop	r29
    26e6:	cf 91       	pop	r28
    26e8:	1f 91       	pop	r17
    26ea:	0f 91       	pop	r16
    26ec:	ff 90       	pop	r15
    26ee:	ef 90       	pop	r14
    26f0:	08 95       	ret

000026f2 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    26f2:	ef 92       	push	r14
    26f4:	ff 92       	push	r15
    26f6:	0f 93       	push	r16
    26f8:	1f 93       	push	r17
    26fa:	cf 93       	push	r28
    26fc:	df 93       	push	r29
    26fe:	eb 01       	movw	r28, r22
    if (oversampling)
    2700:	44 23       	and	r20, r20
    2702:	e1 f0       	breq	.+56     	; 0x273c <ADC_Offset_Get_Signed+0x4a>
    2704:	04 e0       	ldi	r16, 0x04	; 4
    2706:	10 e0       	ldi	r17, 0x00	; 0
    2708:	ee 24       	eor	r14, r14
    270a:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    270c:	88 81       	ld	r24, Y
    270e:	80 68       	ori	r24, 0x80	; 128
    2710:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2712:	8b 81       	ldd	r24, Y+3	; 0x03
    2714:	80 ff       	sbrs	r24, 0
    2716:	fd cf       	rjmp	.-6      	; 0x2712 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2718:	ce 01       	movw	r24, r28
    271a:	60 e0       	ldi	r22, 0x00	; 0
    271c:	0e 94 19 13 	call	0x2632	; 0x2632 <ADC_ResultCh_GetWord_Signed>
    2720:	e8 0e       	add	r14, r24
    2722:	f9 1e       	adc	r15, r25
    2724:	01 50       	subi	r16, 0x01	; 1
    2726:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2728:	89 f7       	brne	.-30     	; 0x270c <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    272a:	c7 01       	movw	r24, r14
    272c:	99 23       	and	r25, r25
    272e:	0c f4       	brge	.+2      	; 0x2732 <ADC_Offset_Get_Signed+0x40>
    2730:	03 96       	adiw	r24, 0x03	; 3
    2732:	95 95       	asr	r25
    2734:	87 95       	ror	r24
    2736:	95 95       	asr	r25
    2738:	87 95       	ror	r24
    273a:	0a c0       	rjmp	.+20     	; 0x2750 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    273c:	88 81       	ld	r24, Y
    273e:	80 68       	ori	r24, 0x80	; 128
    2740:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2742:	8b 81       	ldd	r24, Y+3	; 0x03
    2744:	80 ff       	sbrs	r24, 0
    2746:	fd cf       	rjmp	.-6      	; 0x2742 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2748:	ce 01       	movw	r24, r28
    274a:	60 e0       	ldi	r22, 0x00	; 0
    274c:	0e 94 19 13 	call	0x2632	; 0x2632 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    2750:	df 91       	pop	r29
    2752:	cf 91       	pop	r28
    2754:	1f 91       	pop	r17
    2756:	0f 91       	pop	r16
    2758:	ff 90       	pop	r15
    275a:	ef 90       	pop	r14
    275c:	08 95       	ret

0000275e <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    275e:	aa ec       	ldi	r26, 0xCA	; 202
    2760:	b1 e0       	ldi	r27, 0x01	; 1
    2762:	92 e0       	ldi	r25, 0x02	; 2
    2764:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    2766:	e8 2f       	mov	r30, r24
    2768:	f0 e0       	ldi	r31, 0x00	; 0
    276a:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    276c:	1c 92       	st	X, r1

	return result;
}
    276e:	08 95       	ret

00002770 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    2770:	cf 93       	push	r28
    2772:	df 93       	push	r29
    2774:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    2776:	82 e0       	ldi	r24, 0x02	; 2
    2778:	c0 30       	cpi	r28, 0x00	; 0
    277a:	d8 07       	cpc	r29, r24
    277c:	59 f4       	brne	.+22     	; 0x2794 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    277e:	80 e2       	ldi	r24, 0x20	; 32
    2780:	0e 94 af 13 	call	0x275e	; 0x275e <SP_ReadCalibrationByte>
    2784:	c0 e0       	ldi	r28, 0x00	; 0
    2786:	d2 e0       	ldi	r29, 0x02	; 2
    2788:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    278a:	81 e2       	ldi	r24, 0x21	; 33
    278c:	0e 94 af 13 	call	0x275e	; 0x275e <SP_ReadCalibrationByte>
    2790:	8d 87       	std	Y+13, r24	; 0x0d
    2792:	08 c0       	rjmp	.+16     	; 0x27a4 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    2794:	84 e2       	ldi	r24, 0x24	; 36
    2796:	0e 94 af 13 	call	0x275e	; 0x275e <SP_ReadCalibrationByte>
    279a:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    279c:	85 e2       	ldi	r24, 0x25	; 37
    279e:	0e 94 af 13 	call	0x275e	; 0x275e <SP_ReadCalibrationByte>
    27a2:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	08 95       	ret

000027aa <radio_msg_received_int_enable>:
	radio_msg_received_int_enable();
}

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    27aa:	e0 e8       	ldi	r30, 0x80	; 128
    27ac:	f6 e0       	ldi	r31, 0x06	; 6
    27ae:	84 e0       	ldi	r24, 0x04	; 4
    27b0:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    27b2:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    27b4:	92 e0       	ldi	r25, 0x02	; 2
    27b6:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    27b8:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    27ba:	83 e0       	ldi	r24, 0x03	; 3
    27bc:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    27be:	e0 ea       	ldi	r30, 0xA0	; 160
    27c0:	f0 e0       	ldi	r31, 0x00	; 0
    27c2:	82 81       	ldd	r24, Z+2	; 0x02
    27c4:	84 60       	ori	r24, 0x04	; 4
    27c6:	82 83       	std	Z+2, r24	; 0x02
	sei();
    27c8:	78 94       	sei
}
    27ca:	08 95       	ret

000027cc <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    27cc:	84 e1       	ldi	r24, 0x14	; 20
    27ce:	ee e3       	ldi	r30, 0x3E	; 62
    27d0:	f1 e2       	ldi	r31, 0x21	; 33
    27d2:	df 01       	movw	r26, r30
    27d4:	1d 92       	st	X+, r1
    27d6:	8a 95       	dec	r24
    27d8:	e9 f7       	brne	.-6      	; 0x27d4 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    27da:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <chb_get_short_addr>
    27de:	80 93 3e 21 	sts	0x213E, r24
    27e2:	90 93 3f 21 	sts	0x213F, r25
    chb_drvr_init();
    27e6:	0e 94 ad 17 	call	0x2f5a	; 0x2f5a <chb_drvr_init>
	radio_msg_received_int_enable();
    27ea:	0e 94 d5 13 	call	0x27aa	; 0x27aa <radio_msg_received_int_enable>
}
    27ee:	08 95       	ret

000027f0 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    27f0:	8e e3       	ldi	r24, 0x3E	; 62
    27f2:	91 e2       	ldi	r25, 0x21	; 33
    27f4:	08 95       	ret

000027f6 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    27f6:	2f 92       	push	r2
    27f8:	3f 92       	push	r3
    27fa:	4f 92       	push	r4
    27fc:	5f 92       	push	r5
    27fe:	6f 92       	push	r6
    2800:	7f 92       	push	r7
    2802:	8f 92       	push	r8
    2804:	9f 92       	push	r9
    2806:	af 92       	push	r10
    2808:	bf 92       	push	r11
    280a:	cf 92       	push	r12
    280c:	df 92       	push	r13
    280e:	ef 92       	push	r14
    2810:	ff 92       	push	r15
    2812:	0f 93       	push	r16
    2814:	1f 93       	push	r17
    2816:	cf 93       	push	r28
    2818:	df 93       	push	r29
    281a:	cd b7       	in	r28, 0x3d	; 61
    281c:	de b7       	in	r29, 0x3e	; 62
    281e:	2e 97       	sbiw	r28, 0x0e	; 14
    2820:	cd bf       	out	0x3d, r28	; 61
    2822:	de bf       	out	0x3e, r29	; 62
    2824:	8b 87       	std	Y+11, r24	; 0x0b
    2826:	9c 87       	std	Y+12, r25	; 0x0c
    2828:	6d 87       	std	Y+13, r22	; 0x0d
    282a:	7e 87       	std	Y+14, r23	; 0x0e
    282c:	49 01       	movw	r8, r18
    282e:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2830:	21 15       	cp	r18, r1
    2832:	31 05       	cpc	r19, r1
    2834:	41 05       	cpc	r20, r1
    2836:	51 05       	cpc	r21, r1
    2838:	09 f4       	brne	.+2      	; 0x283c <chb_write+0x46>
    283a:	88 c0       	rjmp	.+272    	; 0x294c <chb_write+0x156>
{
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    283c:	ee 24       	eor	r14, r14
                 pcb.txd_noack++;
				 rtry++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    283e:	0f 2e       	mov	r0, r31
    2840:	f9 e4       	ldi	r31, 0x49	; 73
    2842:	6f 2e       	mov	r6, r31
    2844:	f1 e2       	ldi	r31, 0x21	; 33
    2846:	7f 2e       	mov	r7, r31
    2848:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    284a:	0f 2e       	mov	r0, r31
    284c:	f5 e4       	ldi	r31, 0x45	; 69
    284e:	4f 2e       	mov	r4, r31
    2850:	f1 e2       	ldi	r31, 0x21	; 33
    2852:	5f 2e       	mov	r5, r31
    2854:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2856:	0f 2e       	mov	r0, r31
    2858:	f7 e4       	ldi	r31, 0x47	; 71
    285a:	2f 2e       	mov	r2, r31
    285c:	f1 e2       	ldi	r31, 0x21	; 33
    285e:	3f 2e       	mov	r3, r31
    2860:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    2862:	f8 2c       	mov	r15, r8
    2864:	25 e6       	ldi	r18, 0x65	; 101
    2866:	82 16       	cp	r8, r18
    2868:	91 04       	cpc	r9, r1
    286a:	a1 04       	cpc	r10, r1
    286c:	b1 04       	cpc	r11, r1
    286e:	20 f0       	brcs	.+8      	; 0x2878 <chb_write+0x82>
    2870:	0f 2e       	mov	r0, r31
    2872:	f4 e6       	ldi	r31, 0x64	; 100
    2874:	ff 2e       	mov	r15, r31
    2876:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    2878:	8f 2d       	mov	r24, r15
    287a:	85 5f       	subi	r24, 0xF5	; 245
    287c:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    287e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2880:	9c 85       	ldd	r25, Y+12	; 0x0c
    2882:	ef ef       	ldi	r30, 0xFF	; 255
    2884:	8f 3f       	cpi	r24, 0xFF	; 255
    2886:	9e 07       	cpc	r25, r30
    2888:	11 f0       	breq	.+4      	; 0x288e <chb_write+0x98>
    288a:	81 e6       	ldi	r24, 0x61	; 97
    288c:	01 c0       	rjmp	.+2      	; 0x2890 <chb_write+0x9a>
    288e:	81 e4       	ldi	r24, 0x41	; 65
    2890:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    2892:	88 e9       	ldi	r24, 0x98	; 152
    2894:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
    2896:	e0 e4       	ldi	r30, 0x40	; 64
    2898:	f1 e2       	ldi	r31, 0x21	; 33
    289a:	80 81       	ld	r24, Z
    289c:	8c 83       	std	Y+4, r24	; 0x04
    289e:	8f 5f       	subi	r24, 0xFF	; 255
    28a0:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    28a2:	84 e3       	ldi	r24, 0x34	; 52
    28a4:	92 e1       	ldi	r25, 0x12	; 18
    28a6:	8d 83       	std	Y+5, r24	; 0x05
    28a8:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    28aa:	8b 85       	ldd	r24, Y+11	; 0x0b
    28ac:	9c 85       	ldd	r25, Y+12	; 0x0c
    28ae:	8f 83       	std	Y+7, r24	; 0x07
    28b0:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    28b2:	32 97       	sbiw	r30, 0x02	; 2
    28b4:	80 81       	ld	r24, Z
    28b6:	91 81       	ldd	r25, Z+1	; 0x01
    28b8:	89 87       	std	Y+9, r24	; 0x09
    28ba:	9a 87       	std	Y+10, r25	; 0x0a
        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
    28bc:	00 e0       	ldi	r16, 0x00	; 0
    28be:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    28c0:	cd 84       	ldd	r12, Y+13	; 0x0d
    28c2:	de 84       	ldd	r13, Y+14	; 0x0e
    28c4:	ce 0c       	add	r12, r14
    28c6:	d1 1c       	adc	r13, r1
    28c8:	ce 01       	movw	r24, r28
    28ca:	01 96       	adiw	r24, 0x01	; 1
    28cc:	b6 01       	movw	r22, r12
    28ce:	4f 2d       	mov	r20, r15
    28d0:	0e 94 e9 16 	call	0x2dd2	; 0x2dd2 <chb_tx>
    28d4:	28 2f       	mov	r18, r24

             switch (status)
    28d6:	83 30       	cpi	r24, 0x03	; 3
    28d8:	c9 f0       	breq	.+50     	; 0x290c <chb_write+0x116>
    28da:	84 30       	cpi	r24, 0x04	; 4
    28dc:	18 f4       	brcc	.+6      	; 0x28e4 <chb_write+0xee>
    28de:	81 30       	cpi	r24, 0x01	; 1
    28e0:	e9 f4       	brne	.+58     	; 0x291c <chb_write+0x126>
    28e2:	04 c0       	rjmp	.+8      	; 0x28ec <chb_write+0xf6>
    28e4:	85 30       	cpi	r24, 0x05	; 5
    28e6:	49 f0       	breq	.+18     	; 0x28fa <chb_write+0x104>
    28e8:	80 34       	cpi	r24, 0x40	; 64
    28ea:	c1 f4       	brne	.+48     	; 0x291c <chb_write+0x126>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    28ec:	f2 01       	movw	r30, r4
    28ee:	80 81       	ld	r24, Z
    28f0:	91 81       	ldd	r25, Z+1	; 0x01
    28f2:	01 96       	adiw	r24, 0x01	; 1
    28f4:	80 83       	st	Z, r24
    28f6:	91 83       	std	Z+1, r25	; 0x01
                 break;
    28f8:	11 c0       	rjmp	.+34     	; 0x291c <chb_write+0x126>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    28fa:	f1 01       	movw	r30, r2
    28fc:	80 81       	ld	r24, Z
    28fe:	91 81       	ldd	r25, Z+1	; 0x01
    2900:	01 96       	adiw	r24, 0x01	; 1
    2902:	80 83       	st	Z, r24
    2904:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2906:	0f 5f       	subi	r16, 0xFF	; 255
    2908:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
    290a:	08 c0       	rjmp	.+16     	; 0x291c <chb_write+0x126>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    290c:	f3 01       	movw	r30, r6
    290e:	80 81       	ld	r24, Z
    2910:	91 81       	ldd	r25, Z+1	; 0x01
    2912:	01 96       	adiw	r24, 0x01	; 1
    2914:	80 83       	st	Z, r24
    2916:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2918:	0f 5f       	subi	r16, 0xFF	; 255
    291a:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
 
             default:
                 break;
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    291c:	10 16       	cp	r1, r16
    291e:	11 06       	cpc	r1, r17
    2920:	24 f4       	brge	.+8      	; 0x292a <chb_write+0x134>
    2922:	fa e6       	ldi	r31, 0x6A	; 106
    2924:	fa 95       	dec	r31
    2926:	f1 f7       	brne	.-4      	; 0x2924 <chb_write+0x12e>
    2928:	00 c0       	rjmp	.+0      	; 0x292a <chb_write+0x134>
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    292a:	04 31       	cpi	r16, 0x14	; 20
    292c:	11 05       	cpc	r17, r1
    292e:	79 f0       	breq	.+30     	; 0x294e <chb_write+0x158>
		} while(status != CHB_SUCCESS);			
    2930:	22 23       	and	r18, r18
    2932:	51 f6       	brne	.-108    	; 0x28c8 <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
    2934:	ef 0c       	add	r14, r15
        len = len - frm_len;
    2936:	8f 18       	sub	r8, r15
    2938:	91 08       	sbc	r9, r1
    293a:	a1 08       	sbc	r10, r1
    293c:	b1 08       	sbc	r11, r1
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    293e:	81 14       	cp	r8, r1
    2940:	91 04       	cpc	r9, r1
    2942:	a1 04       	cpc	r10, r1
    2944:	b1 04       	cpc	r11, r1
    2946:	09 f0       	breq	.+2      	; 0x294a <chb_write+0x154>
    2948:	8c cf       	rjmp	.-232    	; 0x2862 <chb_write+0x6c>
    294a:	01 c0       	rjmp	.+2      	; 0x294e <chb_write+0x158>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    294c:	20 e0       	ldi	r18, 0x00	; 0
}
    294e:	82 2f       	mov	r24, r18
    2950:	2e 96       	adiw	r28, 0x0e	; 14
    2952:	cd bf       	out	0x3d, r28	; 61
    2954:	de bf       	out	0x3e, r29	; 62
    2956:	df 91       	pop	r29
    2958:	cf 91       	pop	r28
    295a:	1f 91       	pop	r17
    295c:	0f 91       	pop	r16
    295e:	ff 90       	pop	r15
    2960:	ef 90       	pop	r14
    2962:	df 90       	pop	r13
    2964:	cf 90       	pop	r12
    2966:	bf 90       	pop	r11
    2968:	af 90       	pop	r10
    296a:	9f 90       	pop	r9
    296c:	8f 90       	pop	r8
    296e:	7f 90       	pop	r7
    2970:	6f 90       	pop	r6
    2972:	5f 90       	pop	r5
    2974:	4f 90       	pop	r4
    2976:	3f 90       	pop	r3
    2978:	2f 90       	pop	r2
    297a:	08 95       	ret

0000297c <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    297c:	df 92       	push	r13
    297e:	ef 92       	push	r14
    2980:	ff 92       	push	r15
    2982:	0f 93       	push	r16
    2984:	1f 93       	push	r17
    2986:	cf 93       	push	r28
    2988:	df 93       	push	r29
    298a:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    298c:	0e 94 39 15 	call	0x2a72	; 0x2a72 <chb_buf_read>
    2990:	d8 2e       	mov	r13, r24
    2992:	88 23       	and	r24, r24
    2994:	0c f4       	brge	.+2      	; 0x2998 <chb_read+0x1c>
    2996:	46 c0       	rjmp	.+140    	; 0x2a24 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    2998:	f7 01       	movw	r30, r14
    299a:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    299c:	88 23       	and	r24, r24
    299e:	71 f0       	breq	.+28     	; 0x29bc <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    29a0:	e7 01       	movw	r28, r14
    29a2:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    29a4:	87 01       	movw	r16, r14
    29a6:	09 5f       	subi	r16, 0xF9	; 249
    29a8:	1f 4f       	sbci	r17, 0xFF	; 255
    29aa:	81 50       	subi	r24, 0x01	; 1
    29ac:	08 0f       	add	r16, r24
    29ae:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    29b0:	0e 94 39 15 	call	0x2a72	; 0x2a72 <chb_buf_read>
    29b4:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    29b6:	c0 17       	cp	r28, r16
    29b8:	d1 07       	cpc	r29, r17
    29ba:	d1 f7       	brne	.-12     	; 0x29b0 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    29bc:	f7 01       	movw	r30, r14
    29be:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    29c0:	83 85       	ldd	r24, Z+11	; 0x0b
    29c2:	94 85       	ldd	r25, Z+12	; 0x0c
    29c4:	83 83       	std	Z+3, r24	; 0x03
    29c6:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    29c8:	85 85       	ldd	r24, Z+13	; 0x0d
    29ca:	96 85       	ldd	r25, Z+14	; 0x0e
    29cc:	81 83       	std	Z+1, r24	; 0x01
    29ce:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    29d0:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <chb_buf_get_len>
    29d4:	88 23       	and	r24, r24
    29d6:	11 f4       	brne	.+4      	; 0x29dc <chb_read+0x60>
    {
        pcb.data_rcv = false;
    29d8:	10 92 41 21 	sts	0x2141, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    29dc:	80 91 13 20 	lds	r24, 0x2013
    29e0:	c8 17       	cp	r28, r24
    29e2:	51 f4       	brne	.+20     	; 0x29f8 <chb_read+0x7c>
    29e4:	f7 01       	movw	r30, r14
    29e6:	21 81       	ldd	r18, Z+1	; 0x01
    29e8:	32 81       	ldd	r19, Z+2	; 0x02
    29ea:	80 91 14 20 	lds	r24, 0x2014
    29ee:	90 91 15 20 	lds	r25, 0x2015
    29f2:	28 17       	cp	r18, r24
    29f4:	39 07       	cpc	r19, r25
    29f6:	c1 f0       	breq	.+48     	; 0x2a28 <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    29f8:	c0 93 13 20 	sts	0x2013, r28
        prev_src_addr = rx->src_addr;
    29fc:	f7 01       	movw	r30, r14
    29fe:	81 81       	ldd	r24, Z+1	; 0x01
    2a00:	92 81       	ldd	r25, Z+2	; 0x02
    2a02:	80 93 14 20 	sts	0x2014, r24
    2a06:	90 93 15 20 	sts	0x2015, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    2a0a:	b7 01       	movw	r22, r14
    2a0c:	61 5f       	subi	r22, 0xF1	; 241
    2a0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a10:	4d 2d       	mov	r20, r13
    2a12:	50 e0       	ldi	r21, 0x00	; 0
    2a14:	49 50       	subi	r20, 0x09	; 9
    2a16:	50 40       	sbci	r21, 0x00	; 0
    2a18:	c7 01       	movw	r24, r14
    2a1a:	0e 94 74 38 	call	0x70e8	; 0x70e8 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2a1e:	8d 2d       	mov	r24, r13
    2a20:	8b 50       	subi	r24, 0x0B	; 11
    2a22:	03 c0       	rjmp	.+6      	; 0x2a2a <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2a24:	80 e0       	ldi	r24, 0x00	; 0
    2a26:	01 c0       	rjmp	.+2      	; 0x2a2a <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    2a28:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    2a2a:	df 91       	pop	r29
    2a2c:	cf 91       	pop	r28
    2a2e:	1f 91       	pop	r17
    2a30:	0f 91       	pop	r16
    2a32:	ff 90       	pop	r15
    2a34:	ef 90       	pop	r14
    2a36:	df 90       	pop	r13
    2a38:	08 95       	ret

00002a3a <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    2a3a:	10 92 52 21 	sts	0x2152, r1
    wr_ptr = 0;
    2a3e:	10 92 53 21 	sts	0x2153, r1
    len = 0;
    2a42:	10 92 54 21 	sts	0x2154, r1
}
    2a46:	08 95       	ret

00002a48 <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    2a48:	20 91 53 21 	lds	r18, 0x2153
    2a4c:	30 e0       	ldi	r19, 0x00	; 0
    2a4e:	f9 01       	movw	r30, r18
    2a50:	eb 5a       	subi	r30, 0xAB	; 171
    2a52:	fe 4d       	sbci	r31, 0xDE	; 222
    2a54:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2a56:	c9 01       	movw	r24, r18
    2a58:	01 96       	adiw	r24, 0x01	; 1
    2a5a:	60 e8       	ldi	r22, 0x80	; 128
    2a5c:	70 e0       	ldi	r23, 0x00	; 0
    2a5e:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    2a62:	80 93 53 21 	sts	0x2153, r24
    len++;
    2a66:	80 91 54 21 	lds	r24, 0x2154
    2a6a:	8f 5f       	subi	r24, 0xFF	; 255
    2a6c:	80 93 54 21 	sts	0x2154, r24
}
    2a70:	08 95       	ret

00002a72 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    2a72:	20 91 52 21 	lds	r18, 0x2152
    2a76:	30 e0       	ldi	r19, 0x00	; 0
    2a78:	f9 01       	movw	r30, r18
    2a7a:	eb 5a       	subi	r30, 0xAB	; 171
    2a7c:	fe 4d       	sbci	r31, 0xDE	; 222
    2a7e:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    2a80:	2f 5f       	subi	r18, 0xFF	; 255
    2a82:	3f 4f       	sbci	r19, 0xFF	; 255
    2a84:	c9 01       	movw	r24, r18
    2a86:	60 e8       	ldi	r22, 0x80	; 128
    2a88:	70 e0       	ldi	r23, 0x00	; 0
    2a8a:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    2a8e:	80 93 52 21 	sts	0x2152, r24
    len--;
    2a92:	80 91 54 21 	lds	r24, 0x2154
    2a96:	81 50       	subi	r24, 0x01	; 1
    2a98:	80 93 54 21 	sts	0x2154, r24
    return data;
}
    2a9c:	84 2f       	mov	r24, r20
    2a9e:	08 95       	ret

00002aa0 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    2aa0:	80 91 54 21 	lds	r24, 0x2154
    2aa4:	08 95       	ret

00002aa6 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    2aa6:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
    2aac:	48 e0       	ldi	r20, 0x08	; 8
    2aae:	50 e0       	ldi	r21, 0x00	; 0
    2ab0:	0e 94 bc 19 	call	0x3378	; 0x3378 <chb_eeprom_read>
}
    2ab4:	08 95       	ret

00002ab6 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    2ab6:	cf 93       	push	r28
    2ab8:	df 93       	push	r29
    2aba:	0f 92       	push	r0
    2abc:	0f 92       	push	r0
    2abe:	cd b7       	in	r28, 0x3d	; 61
    2ac0:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    2ac2:	89 e0       	ldi	r24, 0x09	; 9
    2ac4:	90 e0       	ldi	r25, 0x00	; 0
    2ac6:	be 01       	movw	r22, r28
    2ac8:	6f 5f       	subi	r22, 0xFF	; 255
    2aca:	7f 4f       	sbci	r23, 0xFF	; 255
    2acc:	42 e0       	ldi	r20, 0x02	; 2
    2ace:	50 e0       	ldi	r21, 0x00	; 0
    2ad0:	0e 94 bc 19 	call	0x3378	; 0x3378 <chb_eeprom_read>
    return *(U16 *)addr;
}
    2ad4:	89 81       	ldd	r24, Y+1	; 0x01
    2ad6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad8:	0f 90       	pop	r0
    2ada:	0f 90       	pop	r0
    2adc:	df 91       	pop	r29
    2ade:	cf 91       	pop	r28
    2ae0:	08 95       	ret

00002ae2 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    2ae2:	88 23       	and	r24, r24
    2ae4:	29 f0       	breq	.+10     	; 0x2af0 <RadioCS+0xe>
    2ae6:	80 e1       	ldi	r24, 0x10	; 16
    2ae8:	e0 e6       	ldi	r30, 0x60	; 96
    2aea:	f6 e0       	ldi	r31, 0x06	; 6
    2aec:	86 83       	std	Z+6, r24	; 0x06
    2aee:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    2af0:	80 e1       	ldi	r24, 0x10	; 16
    2af2:	e0 e6       	ldi	r30, 0x60	; 96
    2af4:	f6 e0       	ldi	r31, 0x06	; 6
    2af6:	85 83       	std	Z+5, r24	; 0x05
    2af8:	08 95       	ret

00002afa <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    2afa:	df 92       	push	r13
    2afc:	ef 92       	push	r14
    2afe:	ff 92       	push	r15
    2b00:	0f 93       	push	r16
    2b02:	1f 93       	push	r17
    2b04:	cf 93       	push	r28
    2b06:	df 93       	push	r29
    2b08:	8c 01       	movw	r16, r24
    2b0a:	c6 2f       	mov	r28, r22
    2b0c:	7a 01       	movw	r14, r20
    2b0e:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    2b10:	82 2f       	mov	r24, r18
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	86 0f       	add	r24, r22
    2b16:	91 1d       	adc	r25, r1
    2b18:	80 38       	cpi	r24, 0x80	; 128
    2b1a:	91 05       	cpc	r25, r1
    2b1c:	8c f5       	brge	.+98     	; 0x2b80 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    2b1e:	8f b7       	in	r24, 0x3f	; 63
    2b20:	80 93 56 40 	sts	0x4056, r24
    2b24:	f8 94       	cli
    RadioCS(TRUE); 
    2b26:	81 e0       	ldi	r24, 0x01	; 1
    2b28:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    2b2c:	80 e6       	ldi	r24, 0x60	; 96
    2b2e:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2b32:	cc 23       	and	r28, r28
    2b34:	79 f0       	breq	.+30     	; 0x2b54 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2b36:	c8 01       	movw	r24, r16
    2b38:	01 96       	adiw	r24, 0x01	; 1
    2b3a:	c1 50       	subi	r28, 0x01	; 1
    2b3c:	9c 01       	movw	r18, r24
    2b3e:	2c 0f       	add	r18, r28
    2b40:	31 1d       	adc	r19, r1
    2b42:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    2b44:	f8 01       	movw	r30, r16
    2b46:	81 91       	ld	r24, Z+
    2b48:	8f 01       	movw	r16, r30
    2b4a:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2b4e:	0c 17       	cp	r16, r28
    2b50:	1d 07       	cpc	r17, r29
    2b52:	c1 f7       	brne	.-16     	; 0x2b44 <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2b54:	dd 20       	and	r13, r13
    2b56:	69 f0       	breq	.+26     	; 0x2b72 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2b58:	e7 01       	movw	r28, r14
    2b5a:	21 96       	adiw	r28, 0x01	; 1
    2b5c:	da 94       	dec	r13
    2b5e:	cd 0d       	add	r28, r13
    2b60:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    2b62:	f7 01       	movw	r30, r14
    2b64:	81 91       	ld	r24, Z+
    2b66:	7f 01       	movw	r14, r30
    2b68:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2b6c:	ec 16       	cp	r14, r28
    2b6e:	fd 06       	cpc	r15, r29
    2b70:	c1 f7       	brne	.-16     	; 0x2b62 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    2b72:	80 e0       	ldi	r24, 0x00	; 0
    2b74:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>
    CHB_LEAVE_CRIT();
    2b78:	80 91 56 40 	lds	r24, 0x4056
    2b7c:	8f bf       	out	0x3f, r24	; 63
    2b7e:	78 94       	sei
}
    2b80:	df 91       	pop	r29
    2b82:	cf 91       	pop	r28
    2b84:	1f 91       	pop	r17
    2b86:	0f 91       	pop	r16
    2b88:	ff 90       	pop	r15
    2b8a:	ef 90       	pop	r14
    2b8c:	df 90       	pop	r13
    2b8e:	08 95       	ret

00002b90 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    2b90:	cf 93       	push	r28
    2b92:	df 93       	push	r29
    2b94:	d8 2f       	mov	r29, r24
    2b96:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    2b98:	8f b7       	in	r24, 0x3f	; 63
    2b9a:	80 93 56 40 	sts	0x4056, r24
    2b9e:	f8 94       	cli
    RadioCS(TRUE);
    2ba0:	81 e0       	ldi	r24, 0x01	; 1
    2ba2:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    2ba6:	8d 2f       	mov	r24, r29
    2ba8:	80 6c       	ori	r24, 0xC0	; 192
    2baa:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    2bae:	8c 2f       	mov	r24, r28
    2bb0:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>

    RadioCS(FALSE);
    2bb4:	80 e0       	ldi	r24, 0x00	; 0
    2bb6:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>
    CHB_LEAVE_CRIT();
    2bba:	80 91 56 40 	lds	r24, 0x4056
    2bbe:	8f bf       	out	0x3f, r24	; 63
    2bc0:	78 94       	sei
}
    2bc2:	df 91       	pop	r29
    2bc4:	cf 91       	pop	r28
    2bc6:	08 95       	ret

00002bc8 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    2bc8:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    2bca:	85 e0       	ldi	r24, 0x05	; 5
    2bcc:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <chb_reg_write>
}
    2bd0:	08 95       	ret

00002bd2 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    2bd2:	0f 93       	push	r16
    2bd4:	1f 93       	push	r17
    2bd6:	cf 93       	push	r28
    2bd8:	df 93       	push	r29
    2bda:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    2bdc:	c6 2f       	mov	r28, r22
    2bde:	d7 2f       	mov	r29, r23
    2be0:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    2be2:	69 91       	ld	r22, Y+
    2be4:	81 2f       	mov	r24, r17
    2be6:	80 0f       	add	r24, r16
    2be8:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    2bec:	1f 5f       	subi	r17, 0xFF	; 255
    2bee:	18 30       	cpi	r17, 0x08	; 8
    2bf0:	c1 f7       	brne	.-16     	; 0x2be2 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    2bf2:	df 91       	pop	r29
    2bf4:	cf 91       	pop	r28
    2bf6:	1f 91       	pop	r17
    2bf8:	0f 91       	pop	r16
    2bfa:	08 95       	ret

00002bfc <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    2bfc:	cf 93       	push	r28
    2bfe:	df 93       	push	r29
    2c00:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    2c02:	80 e0       	ldi	r24, 0x00	; 0
    2c04:	90 e0       	ldi	r25, 0x00	; 0
    2c06:	be 01       	movw	r22, r28
    2c08:	48 e0       	ldi	r20, 0x08	; 8
    2c0a:	50 e0       	ldi	r21, 0x00	; 0
    2c0c:	0e 94 59 19 	call	0x32b2	; 0x32b2 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    2c10:	84 e2       	ldi	r24, 0x24	; 36
    2c12:	be 01       	movw	r22, r28
    2c14:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <chb_reg_write64>
}
    2c18:	df 91       	pop	r29
    2c1a:	cf 91       	pop	r28
    2c1c:	08 95       	ret

00002c1e <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    2c1e:	cf 93       	push	r28
    2c20:	df 93       	push	r29
    2c22:	c8 2f       	mov	r28, r24
    2c24:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    2c26:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <chb_reg_write>
    2c2a:	8c 2f       	mov	r24, r28
    2c2c:	8f 5f       	subi	r24, 0xFF	; 255
    2c2e:	6d 2f       	mov	r22, r29
    2c30:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <chb_reg_write>
    }
}
    2c34:	df 91       	pop	r29
    2c36:	cf 91       	pop	r28
    2c38:	08 95       	ret

00002c3a <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    2c3a:	0f 93       	push	r16
    2c3c:	1f 93       	push	r17
    2c3e:	cf 93       	push	r28
    2c40:	df 93       	push	r29
    2c42:	0f 92       	push	r0
    2c44:	0f 92       	push	r0
    2c46:	cd b7       	in	r28, 0x3d	; 61
    2c48:	de b7       	in	r29, 0x3e	; 62
    2c4a:	89 83       	std	Y+1, r24	; 0x01
    2c4c:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    2c4e:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <chb_get_pcb>
    2c52:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    2c54:	89 e0       	ldi	r24, 0x09	; 9
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	be 01       	movw	r22, r28
    2c5a:	6f 5f       	subi	r22, 0xFF	; 255
    2c5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c5e:	42 e0       	ldi	r20, 0x02	; 2
    2c60:	50 e0       	ldi	r21, 0x00	; 0
    2c62:	0e 94 59 19 	call	0x32b2	; 0x32b2 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    2c66:	69 81       	ldd	r22, Y+1	; 0x01
    2c68:	7a 81       	ldd	r23, Y+2	; 0x02
    2c6a:	80 e2       	ldi	r24, 0x20	; 32
    2c6c:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <chb_reg_write16>
    pcb->src_addr = addr;
    2c70:	89 81       	ldd	r24, Y+1	; 0x01
    2c72:	9a 81       	ldd	r25, Y+2	; 0x02
    2c74:	f8 01       	movw	r30, r16
    2c76:	80 83       	st	Z, r24
    2c78:	91 83       	std	Z+1, r25	; 0x01
}
    2c7a:	0f 90       	pop	r0
    2c7c:	0f 90       	pop	r0
    2c7e:	df 91       	pop	r29
    2c80:	cf 91       	pop	r28
    2c82:	1f 91       	pop	r17
    2c84:	0f 91       	pop	r16
    2c86:	08 95       	ret

00002c88 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    2c88:	cf 93       	push	r28
    2c8a:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    2c8c:	8f b7       	in	r24, 0x3f	; 63
    2c8e:	80 93 56 40 	sts	0x4056, r24
    2c92:	f8 94       	cli
    RadioCS(TRUE);
    2c94:	81 e0       	ldi	r24, 0x01	; 1
    2c96:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    2c9a:	8c 2f       	mov	r24, r28
    2c9c:	80 68       	ori	r24, 0x80	; 128
    2c9e:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    val = SPID_write(val);
    2ca2:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    2ca6:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    2ca8:	80 e0       	ldi	r24, 0x00	; 0
    2caa:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>
    CHB_LEAVE_CRIT();
    2cae:	80 91 56 40 	lds	r24, 0x4056
    2cb2:	8f bf       	out	0x3f, r24	; 63
    2cb4:	78 94       	sei

    return val;
}
    2cb6:	8c 2f       	mov	r24, r28
    2cb8:	cf 91       	pop	r28
    2cba:	08 95       	ret

00002cbc <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    2cbc:	81 e0       	ldi	r24, 0x01	; 1
    2cbe:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
}
    2cc2:	8f 71       	andi	r24, 0x1F	; 31
    2cc4:	08 95       	ret

00002cc6 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    2cc6:	1f 93       	push	r17
    2cc8:	cf 93       	push	r28
    2cca:	df 93       	push	r29
    2ccc:	c8 2f       	mov	r28, r24
    2cce:	16 2f       	mov	r17, r22
    2cd0:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    2cd2:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    2cd6:	6d 2f       	mov	r22, r29
    2cd8:	60 95       	com	r22
    2cda:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    2cdc:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    2cde:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    2ce0:	8c 2f       	mov	r24, r28
    2ce2:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <chb_reg_write>
}
    2ce6:	df 91       	pop	r29
    2ce8:	cf 91       	pop	r28
    2cea:	1f 91       	pop	r17
    2cec:	08 95       	ret

00002cee <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    2cee:	cf 93       	push	r28
    2cf0:	df 93       	push	r29
    2cf2:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    2cf4:	80 91 64 06 	lds	r24, 0x0664
    2cf8:	81 fd       	sbrc	r24, 1
    2cfa:	4b c0       	rjmp	.+150    	; 0x2d92 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    2cfc:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_get_state>
    2d00:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    2d02:	81 51       	subi	r24, 0x11	; 17
    2d04:	82 30       	cpi	r24, 0x02	; 2
    2d06:	20 f0       	brcs	.+8      	; 0x2d10 <chb_set_state+0x22>
    2d08:	c1 30       	cpi	r28, 0x01	; 1
    2d0a:	11 f0       	breq	.+4      	; 0x2d10 <chb_set_state+0x22>
    2d0c:	c2 30       	cpi	r28, 0x02	; 2
    2d0e:	21 f4       	brne	.+8      	; 0x2d18 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    2d10:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_get_state>
    2d14:	8c 17       	cp	r24, r28
    2d16:	e1 f3       	breq	.-8      	; 0x2d10 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    2d18:	d6 31       	cpi	r29, 0x16	; 22
    2d1a:	f9 f0       	breq	.+62     	; 0x2d5a <chb_set_state+0x6c>
    2d1c:	d9 31       	cpi	r29, 0x19	; 25
    2d1e:	89 f0       	breq	.+34     	; 0x2d42 <chb_set_state+0x54>
    2d20:	d8 30       	cpi	r29, 0x08	; 8
    2d22:	31 f5       	brne	.+76     	; 0x2d70 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    2d24:	e4 e6       	ldi	r30, 0x64	; 100
    2d26:	f6 e0       	ldi	r31, 0x06	; 6
    2d28:	80 81       	ld	r24, Z
    2d2a:	8d 7f       	andi	r24, 0xFD	; 253
    2d2c:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    2d2e:	82 e0       	ldi	r24, 0x02	; 2
    2d30:	63 e0       	ldi	r22, 0x03	; 3
    2d32:	4f e1       	ldi	r20, 0x1F	; 31
    2d34:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
    2d38:	8a e0       	ldi	r24, 0x0A	; 10
    2d3a:	8a 95       	dec	r24
    2d3c:	f1 f7       	brne	.-4      	; 0x2d3a <chb_set_state+0x4c>
    2d3e:	00 c0       	rjmp	.+0      	; 0x2d40 <chb_set_state+0x52>
    2d40:	17 c0       	rjmp	.+46     	; 0x2d70 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    2d42:	c6 31       	cpi	r28, 0x16	; 22
    2d44:	a9 f4       	brne	.+42     	; 0x2d70 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    2d46:	82 e0       	ldi	r24, 0x02	; 2
    2d48:	69 e0       	ldi	r22, 0x09	; 9
    2d4a:	4f e1       	ldi	r20, 0x1F	; 31
    2d4c:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
    2d50:	9a e0       	ldi	r25, 0x0A	; 10
    2d52:	9a 95       	dec	r25
    2d54:	f1 f7       	brne	.-4      	; 0x2d52 <chb_set_state+0x64>
    2d56:	00 c0       	rjmp	.+0      	; 0x2d58 <chb_set_state+0x6a>
    2d58:	0b c0       	rjmp	.+22     	; 0x2d70 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    2d5a:	c9 31       	cpi	r28, 0x19	; 25
    2d5c:	49 f4       	brne	.+18     	; 0x2d70 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    2d5e:	82 e0       	ldi	r24, 0x02	; 2
    2d60:	69 e0       	ldi	r22, 0x09	; 9
    2d62:	4f e1       	ldi	r20, 0x1F	; 31
    2d64:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
    2d68:	8a e0       	ldi	r24, 0x0A	; 10
    2d6a:	8a 95       	dec	r24
    2d6c:	f1 f7       	brne	.-4      	; 0x2d6a <chb_set_state+0x7c>
    2d6e:	00 c0       	rjmp	.+0      	; 0x2d70 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    2d70:	82 e0       	ldi	r24, 0x02	; 2
    2d72:	6d 2f       	mov	r22, r29
    2d74:	4f e1       	ldi	r20, 0x1F	; 31
    2d76:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
    2d7a:	8f e6       	ldi	r24, 0x6F	; 111
    2d7c:	93 e0       	ldi	r25, 0x03	; 3
    2d7e:	01 97       	sbiw	r24, 0x01	; 1
    2d80:	f1 f7       	brne	.-4      	; 0x2d7e <chb_set_state+0x90>
    2d82:	00 c0       	rjmp	.+0      	; 0x2d84 <chb_set_state+0x96>
    2d84:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    2d86:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_get_state>
    2d8a:	8d 17       	cp	r24, r29
    2d8c:	21 f4       	brne	.+8      	; 0x2d96 <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    2d8e:	80 e4       	ldi	r24, 0x40	; 64
    2d90:	03 c0       	rjmp	.+6      	; 0x2d98 <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    2d92:	84 e4       	ldi	r24, 0x44	; 68
    2d94:	01 c0       	rjmp	.+2      	; 0x2d98 <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    2d96:	83 e4       	ldi	r24, 0x43	; 67
}
    2d98:	df 91       	pop	r29
    2d9a:	cf 91       	pop	r28
    2d9c:	08 95       	ret

00002d9e <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    2d9e:	88 23       	and	r24, r24
    2da0:	49 f0       	breq	.+18     	; 0x2db4 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    2da2:	88 e0       	ldi	r24, 0x08	; 8
    2da4:	0e 94 77 16 	call	0x2cee	; 0x2cee <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    2da8:	e4 e6       	ldi	r30, 0x64	; 100
    2daa:	f6 e0       	ldi	r31, 0x06	; 6
    2dac:	80 81       	ld	r24, Z
    2dae:	82 60       	ori	r24, 0x02	; 2
    2db0:	80 83       	st	Z, r24
    2db2:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    2db4:	e4 e6       	ldi	r30, 0x64	; 100
    2db6:	f6 e0       	ldi	r31, 0x06	; 6
    2db8:	80 81       	ld	r24, Z
    2dba:	8d 7f       	andi	r24, 0xFD	; 253
    2dbc:	80 83       	st	Z, r24
    2dbe:	8f e7       	ldi	r24, 0x7F	; 127
    2dc0:	97 e0       	ldi	r25, 0x07	; 7
    2dc2:	01 97       	sbiw	r24, 0x01	; 1
    2dc4:	f1 f7       	brne	.-4      	; 0x2dc2 <chb_sleep+0x24>
    2dc6:	00 c0       	rjmp	.+0      	; 0x2dc8 <chb_sleep+0x2a>
    2dc8:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    2dca:	86 e1       	ldi	r24, 0x16	; 22
    2dcc:	0e 94 77 16 	call	0x2cee	; 0x2cee <chb_set_state>
    2dd0:	08 95       	ret

00002dd2 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    2dd2:	cf 92       	push	r12
    2dd4:	df 92       	push	r13
    2dd6:	ef 92       	push	r14
    2dd8:	ff 92       	push	r15
    2dda:	0f 93       	push	r16
    2ddc:	1f 93       	push	r17
    2dde:	cf 93       	push	r28
    2de0:	df 93       	push	r29
    2de2:	7c 01       	movw	r14, r24
    2de4:	6b 01       	movw	r12, r22
    2de6:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    2de8:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_get_state>
    2dec:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    2dee:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <chb_get_pcb>
    2df2:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    2df4:	12 30       	cpi	r17, 0x02	; 2
    2df6:	f1 f0       	breq	.+60     	; 0x2e34 <chb_tx+0x62>
    2df8:	12 31       	cpi	r17, 0x12	; 18
    2dfa:	f1 f0       	breq	.+60     	; 0x2e38 <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    2dfc:	88 e0       	ldi	r24, 0x08	; 8
    2dfe:	0e 94 77 16 	call	0x2cee	; 0x2cee <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    2e02:	89 e1       	ldi	r24, 0x19	; 25
    2e04:	0e 94 77 16 	call	0x2cee	; 0x2cee <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    2e08:	c7 01       	movw	r24, r14
    2e0a:	6a e0       	ldi	r22, 0x0A	; 10
    2e0c:	a6 01       	movw	r20, r12
    2e0e:	20 2f       	mov	r18, r16
    2e10:	0e 94 7d 15 	call	0x2afa	; 0x2afa <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    2e14:	82 e0       	ldi	r24, 0x02	; 2
    2e16:	62 e0       	ldi	r22, 0x02	; 2
    2e18:	4f e1       	ldi	r20, 0x1F	; 31
    2e1a:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    2e1e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e20:	88 23       	and	r24, r24
    2e22:	e9 f3       	breq	.-6      	; 0x2e1e <chb_tx+0x4c>
    pcb->tx_end = false;
    2e24:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    2e26:	82 e0       	ldi	r24, 0x02	; 2
    2e28:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    2e2c:	82 95       	swap	r24
    2e2e:	86 95       	lsr	r24
    2e30:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    2e32:	03 c0       	rjmp	.+6      	; 0x2e3a <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    2e34:	84 e4       	ldi	r24, 0x44	; 68
    2e36:	01 c0       	rjmp	.+2      	; 0x2e3a <chb_tx+0x68>
    2e38:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    2e3a:	df 91       	pop	r29
    2e3c:	cf 91       	pop	r28
    2e3e:	1f 91       	pop	r17
    2e40:	0f 91       	pop	r16
    2e42:	ff 90       	pop	r15
    2e44:	ef 90       	pop	r14
    2e46:	df 90       	pop	r13
    2e48:	cf 90       	pop	r12
    2e4a:	08 95       	ret

00002e4c <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    2e4c:	81 30       	cpi	r24, 0x01	; 1
    2e4e:	91 f0       	breq	.+36     	; 0x2e74 <chb_set_mode+0x28>
    2e50:	81 30       	cpi	r24, 0x01	; 1
    2e52:	28 f0       	brcs	.+10     	; 0x2e5e <chb_set_mode+0x12>
    2e54:	82 30       	cpi	r24, 0x02	; 2
    2e56:	c9 f0       	breq	.+50     	; 0x2e8a <chb_set_mode+0x3e>
    2e58:	83 30       	cpi	r24, 0x03	; 3
    2e5a:	61 f5       	brne	.+88     	; 0x2eb4 <chb_set_mode+0x68>
    2e5c:	21 c0       	rjmp	.+66     	; 0x2ea0 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    2e5e:	8c e0       	ldi	r24, 0x0C	; 12
    2e60:	68 e0       	ldi	r22, 0x08	; 8
    2e62:	4f e3       	ldi	r20, 0x3F	; 63
    2e64:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2e68:	86 e1       	ldi	r24, 0x16	; 22
    2e6a:	62 e0       	ldi	r22, 0x02	; 2
    2e6c:	43 e0       	ldi	r20, 0x03	; 3
    2e6e:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
        break;
    2e72:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    2e74:	8c e0       	ldi	r24, 0x0C	; 12
    2e76:	6c e0       	ldi	r22, 0x0C	; 12
    2e78:	4f e3       	ldi	r20, 0x3F	; 63
    2e7a:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2e7e:	86 e1       	ldi	r24, 0x16	; 22
    2e80:	62 e0       	ldi	r22, 0x02	; 2
    2e82:	43 e0       	ldi	r20, 0x03	; 3
    2e84:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
        break;
    2e88:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    2e8a:	8c e0       	ldi	r24, 0x0C	; 12
    2e8c:	6c e1       	ldi	r22, 0x1C	; 28
    2e8e:	4f e3       	ldi	r20, 0x3F	; 63
    2e90:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2e94:	86 e1       	ldi	r24, 0x16	; 22
    2e96:	62 e0       	ldi	r22, 0x02	; 2
    2e98:	43 e0       	ldi	r20, 0x03	; 3
    2e9a:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
        break;
    2e9e:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    2ea0:	8c e0       	ldi	r24, 0x0C	; 12
    2ea2:	60 e0       	ldi	r22, 0x00	; 0
    2ea4:	4f e3       	ldi	r20, 0x3F	; 63
    2ea6:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    2eaa:	86 e1       	ldi	r24, 0x16	; 22
    2eac:	63 e0       	ldi	r22, 0x03	; 3
    2eae:	43 e0       	ldi	r20, 0x03	; 3
    2eb0:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
    2eb4:	08 95       	ret

00002eb6 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    2eb6:	cf 93       	push	r28
    2eb8:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    2eba:	88 e0       	ldi	r24, 0x08	; 8
    2ebc:	6c 2f       	mov	r22, r28
    2ebe:	4f e1       	ldi	r20, 0x1F	; 31
    2ec0:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    2ec4:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    2ec8:	86 30       	cpi	r24, 0x06	; 6
    2eca:	11 f0       	breq	.+4      	; 0x2ed0 <chb_set_channel+0x1a>
    2ecc:	89 30       	cpi	r24, 0x09	; 9
    2ece:	31 f4       	brne	.+12     	; 0x2edc <chb_set_channel+0x26>
    2ed0:	8f e6       	ldi	r24, 0x6F	; 111
    2ed2:	93 e0       	ldi	r25, 0x03	; 3
    2ed4:	01 97       	sbiw	r24, 0x01	; 1
    2ed6:	f1 f7       	brne	.-4      	; 0x2ed4 <chb_set_channel+0x1e>
    2ed8:	00 c0       	rjmp	.+0      	; 0x2eda <chb_set_channel+0x24>
    2eda:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    2edc:	88 e0       	ldi	r24, 0x08	; 8
    2ede:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	8f 71       	andi	r24, 0x1F	; 31
    2ee6:	90 70       	andi	r25, 0x00	; 0
    2ee8:	6c 2f       	mov	r22, r28
    2eea:	70 e0       	ldi	r23, 0x00	; 0
    2eec:	86 17       	cp	r24, r22
    2eee:	97 07       	cpc	r25, r23
    2ef0:	11 f4       	brne	.+4      	; 0x2ef6 <chb_set_channel+0x40>
    2ef2:	80 e4       	ldi	r24, 0x40	; 64
    2ef4:	01 c0       	rjmp	.+2      	; 0x2ef8 <chb_set_channel+0x42>
    2ef6:	83 e4       	ldi	r24, 0x43	; 67
}
    2ef8:	cf 91       	pop	r28
    2efa:	08 95       	ret

00002efc <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    2efc:	cf 93       	push	r28
    2efe:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    2f00:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    2f04:	8c 2b       	or	r24, r28
    2f06:	8f 5f       	subi	r24, 0xFF	; 255
    2f08:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    }
    return val;
}
    2f0c:	80 e0       	ldi	r24, 0x00	; 0
    2f0e:	90 e0       	ldi	r25, 0x00	; 0
    2f10:	cf 91       	pop	r28
    2f12:	08 95       	ret

00002f14 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    2f14:	e4 e6       	ldi	r30, 0x64	; 100
    2f16:	f6 e0       	ldi	r31, 0x06	; 6
    2f18:	80 81       	ld	r24, Z
    2f1a:	81 60       	ori	r24, 0x01	; 1
    2f1c:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    2f1e:	80 81       	ld	r24, Z
    2f20:	8d 7f       	andi	r24, 0xFD	; 253
    2f22:	80 83       	st	Z, r24
    2f24:	8f ed       	ldi	r24, 0xDF	; 223
    2f26:	9b e0       	ldi	r25, 0x0B	; 11
    2f28:	01 97       	sbiw	r24, 0x01	; 1
    2f2a:	f1 f7       	brne	.-4      	; 0x2f28 <chb_reset+0x14>
    2f2c:	00 c0       	rjmp	.+0      	; 0x2f2e <chb_reset+0x1a>
    2f2e:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    2f30:	80 81       	ld	r24, Z
    2f32:	8e 7f       	andi	r24, 0xFE	; 254
    2f34:	80 83       	st	Z, r24
    2f36:	9a e0       	ldi	r25, 0x0A	; 10
    2f38:	9a 95       	dec	r25
    2f3a:	f1 f7       	brne	.-4      	; 0x2f38 <chb_reset+0x24>
    2f3c:	00 c0       	rjmp	.+0      	; 0x2f3e <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    2f3e:	80 81       	ld	r24, Z
    2f40:	81 60       	ori	r24, 0x01	; 1
    2f42:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    2f44:	8d e1       	ldi	r24, 0x1D	; 29
    2f46:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    2f4a:	81 30       	cpi	r24, 0x01	; 1
    2f4c:	d9 f7       	brne	.-10     	; 0x2f44 <chb_reset+0x30>
    2f4e:	8c e1       	ldi	r24, 0x1C	; 28
    2f50:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    2f54:	87 30       	cpi	r24, 0x07	; 7
    2f56:	b1 f7       	brne	.-20     	; 0x2f44 <chb_reset+0x30>
            break;
        }
    }
	

}
    2f58:	08 95       	ret

00002f5a <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    2f5a:	0f 93       	push	r16
    2f5c:	1f 93       	push	r17
    2f5e:	cf 93       	push	r28
    2f60:	df 93       	push	r29
    2f62:	cd b7       	in	r28, 0x3d	; 61
    2f64:	de b7       	in	r29, 0x3e	; 62
    2f66:	ea 97       	sbiw	r28, 0x3a	; 58
    2f68:	cd bf       	out	0x3d, r28	; 61
    2f6a:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    2f6c:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    2f70:	e0 e6       	ldi	r30, 0x60	; 96
    2f72:	f6 e0       	ldi	r31, 0x06	; 6
    2f74:	80 81       	ld	r24, Z
    2f76:	82 60       	ori	r24, 0x02	; 2
    2f78:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    2f7a:	80 81       	ld	r24, Z
    2f7c:	81 60       	ori	r24, 0x01	; 1
    2f7e:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    2f80:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    2f84:	8e e0       	ldi	r24, 0x0E	; 14
    2f86:	60 e0       	ldi	r22, 0x00	; 0
    2f88:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    2f8c:	82 e0       	ldi	r24, 0x02	; 2
    2f8e:	63 e0       	ldi	r22, 0x03	; 3
    2f90:	4f e1       	ldi	r20, 0x1F	; 31
    2f92:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    2f96:	81 e0       	ldi	r24, 0x01	; 1
    2f98:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    2f9c:	8f 71       	andi	r24, 0x1F	; 31
    2f9e:	88 30       	cpi	r24, 0x08	; 8
    2fa0:	d1 f7       	brne	.-12     	; 0x2f96 <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    2fa2:	8e e2       	ldi	r24, 0x2E	; 46
    2fa4:	60 e4       	ldi	r22, 0x40	; 64
    2fa6:	40 ec       	ldi	r20, 0xC0	; 192
    2fa8:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    2fac:	8e e0       	ldi	r24, 0x0E	; 14
    2fae:	6c e0       	ldi	r22, 0x0C	; 12
    2fb0:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    2fb4:	84 e0       	ldi	r24, 0x04	; 4
    2fb6:	60 e2       	ldi	r22, 0x20	; 32
    2fb8:	40 e2       	ldi	r20, 0x20	; 32
    2fba:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    2fbe:	81 e0       	ldi	r24, 0x01	; 1
    2fc0:	0e 94 26 17 	call	0x2e4c	; 0x2e4c <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    2fc4:	81 e0       	ldi	r24, 0x01	; 1
    2fc6:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    2fca:	86 e1       	ldi	r24, 0x16	; 22
    2fcc:	0e 94 77 16 	call	0x2cee	; 0x2cee <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    2fd0:	82 e2       	ldi	r24, 0x22	; 34
    2fd2:	64 e3       	ldi	r22, 0x34	; 52
    2fd4:	72 e1       	ldi	r23, 0x12	; 18
    2fd6:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    2fda:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <chb_get_short_addr>
    2fde:	bc 01       	movw	r22, r24
    2fe0:	80 e2       	ldi	r24, 0x20	; 32
    2fe2:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    2fe6:	ce 01       	movw	r24, r28
    2fe8:	01 96       	adiw	r24, 0x01	; 1
    2fea:	0e 94 53 15 	call	0x2aa6	; 0x2aa6 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    2fee:	84 e2       	ldi	r24, 0x24	; 36
    2ff0:	be 01       	movw	r22, r28
    2ff2:	6f 5f       	subi	r22, 0xFF	; 255
    2ff4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ff6:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    2ffa:	e2 e7       	ldi	r30, 0x72	; 114
    2ffc:	f6 e0       	ldi	r31, 0x06	; 6
    2ffe:	80 81       	ld	r24, Z
    3000:	81 60       	ori	r24, 0x01	; 1
    3002:	80 83       	st	Z, r24
    3004:	e9 e6       	ldi	r30, 0x69	; 105
    3006:	f6 e0       	ldi	r31, 0x06	; 6
    3008:	80 81       	ld	r24, Z
    300a:	83 60       	ori	r24, 0x03	; 3
    300c:	80 83       	st	Z, r24
    300e:	ea e6       	ldi	r30, 0x6A	; 106
    3010:	f6 e0       	ldi	r31, 0x06	; 6
    3012:	80 81       	ld	r24, Z
    3014:	84 60       	ori	r24, 0x04	; 4
    3016:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3018:	e0 ea       	ldi	r30, 0xA0	; 160
    301a:	f0 e0       	ldi	r31, 0x00	; 0
    301c:	82 81       	ldd	r24, Z+2	; 0x02
    301e:	87 60       	ori	r24, 0x07	; 7
    3020:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3022:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_get_state>
    3026:	86 31       	cpi	r24, 0x16	; 22
    3028:	91 f0       	breq	.+36     	; 0x304e <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    302a:	8e 01       	movw	r16, r28
    302c:	07 5f       	subi	r16, 0xF7	; 247
    302e:	1f 4f       	sbci	r17, 0xFF	; 255
    3030:	c8 01       	movw	r24, r16
    3032:	68 ee       	ldi	r22, 0xE8	; 232
    3034:	71 e0       	ldi	r23, 0x01	; 1
    3036:	0e 94 6d 38 	call	0x70da	; 0x70da <strcpy_P>
        printf(buf);
    303a:	0f 92       	push	r0
    303c:	0f 92       	push	r0
    303e:	ed b7       	in	r30, 0x3d	; 61
    3040:	fe b7       	in	r31, 0x3e	; 62
    3042:	01 83       	std	Z+1, r16	; 0x01
    3044:	12 83       	std	Z+2, r17	; 0x02
    3046:	0e 94 c0 38 	call	0x7180	; 0x7180 <printf>
    304a:	0f 90       	pop	r0
    304c:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    304e:	ea 96       	adiw	r28, 0x3a	; 58
    3050:	cd bf       	out	0x3d, r28	; 61
    3052:	de bf       	out	0x3e, r29	; 62
    3054:	df 91       	pop	r29
    3056:	cf 91       	pop	r28
    3058:	1f 91       	pop	r17
    305a:	0f 91       	pop	r16
    305c:	08 95       	ret

0000305e <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    305e:	1f 92       	push	r1
    3060:	0f 92       	push	r0
    3062:	0f b6       	in	r0, 0x3f	; 63
    3064:	0f 92       	push	r0
    3066:	0b b6       	in	r0, 0x3b	; 59
    3068:	0f 92       	push	r0
    306a:	11 24       	eor	r1, r1
    306c:	4f 92       	push	r4
    306e:	5f 92       	push	r5
    3070:	6f 92       	push	r6
    3072:	7f 92       	push	r7
    3074:	8f 92       	push	r8
    3076:	9f 92       	push	r9
    3078:	af 92       	push	r10
    307a:	bf 92       	push	r11
    307c:	cf 92       	push	r12
    307e:	df 92       	push	r13
    3080:	ef 92       	push	r14
    3082:	ff 92       	push	r15
    3084:	0f 93       	push	r16
    3086:	1f 93       	push	r17
    3088:	2f 93       	push	r18
    308a:	3f 93       	push	r19
    308c:	4f 93       	push	r20
    308e:	5f 93       	push	r21
    3090:	6f 93       	push	r22
    3092:	7f 93       	push	r23
    3094:	8f 93       	push	r24
    3096:	9f 93       	push	r25
    3098:	af 93       	push	r26
    309a:	bf 93       	push	r27
    309c:	ef 93       	push	r30
    309e:	ff 93       	push	r31
    30a0:	cf 93       	push	r28
    30a2:	df 93       	push	r29
    30a4:	cd b7       	in	r28, 0x3d	; 61
    30a6:	de b7       	in	r29, 0x3e	; 62
    30a8:	e2 97       	sbiw	r28, 0x32	; 50
    30aa:	cd bf       	out	0x3d, r28	; 61
    30ac:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    30ae:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <chb_get_pcb>
    30b2:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    30b4:	8f b7       	in	r24, 0x3f	; 63
    30b6:	80 93 56 40 	sts	0x4056, r24
    30ba:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    30bc:	81 e0       	ldi	r24, 0x01	; 1
    30be:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    30c2:	8f e8       	ldi	r24, 0x8F	; 143
    30c4:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    intp_src = SPID_write(0);
    30c8:	80 e0       	ldi	r24, 0x00	; 0
    30ca:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    30ce:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    30d0:	80 e0       	ldi	r24, 0x00	; 0
    30d2:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>

    while (intp_src)
    30d6:	11 23       	and	r17, r17
    30d8:	09 f4       	brne	.+2      	; 0x30dc <__vector_64+0x7e>
    30da:	be c0       	rjmp	.+380    	; 0x3258 <__vector_64+0x1fa>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    30dc:	aa 24       	eor	r10, r10
    30de:	bb 24       	eor	r11, r11
    30e0:	68 94       	set
    30e2:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    30e4:	0f 2e       	mov	r0, r31
    30e6:	f8 e0       	ldi	r31, 0x08	; 8
    30e8:	6f 2e       	mov	r6, r31
    30ea:	f2 e0       	ldi	r31, 0x02	; 2
    30ec:	7f 2e       	mov	r7, r31
    30ee:	f0 2d       	mov	r31, r0
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    30f0:	0f 2e       	mov	r0, r31
    30f2:	f0 e8       	ldi	r31, 0x80	; 128
    30f4:	8f 2e       	mov	r8, r31
    30f6:	f6 e0       	ldi	r31, 0x06	; 6
    30f8:	9f 2e       	mov	r9, r31
    30fa:	f0 2d       	mov	r31, r0
    30fc:	cc 24       	eor	r12, r12
    30fe:	68 94       	set
    3100:	c2 f8       	bld	r12, 2
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3102:	12 ff       	sbrs	r17, 2
    3104:	02 c0       	rjmp	.+4      	; 0x310a <__vector_64+0xac>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3106:	1b 7f       	andi	r17, 0xFB	; 251
    3108:	a4 c0       	rjmp	.+328    	; 0x3252 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    310a:	13 ff       	sbrs	r17, 3
    310c:	89 c0       	rjmp	.+274    	; 0x3220 <__vector_64+0x1c2>
        {
            state = chb_get_state();
    310e:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3112:	86 30       	cpi	r24, 0x06	; 6
    3114:	29 f0       	breq	.+10     	; 0x3120 <__vector_64+0xc2>
    3116:	86 31       	cpi	r24, 0x16	; 22
    3118:	19 f0       	breq	.+6      	; 0x3120 <__vector_64+0xc2>
    311a:	81 31       	cpi	r24, 0x11	; 17
    311c:	09 f0       	breq	.+2      	; 0x3120 <__vector_64+0xc2>
    311e:	76 c0       	rjmp	.+236    	; 0x320c <__vector_64+0x1ae>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    3120:	88 e0       	ldi	r24, 0x08	; 8
    3122:	0e 94 77 16 	call	0x2cee	; 0x2cee <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3126:	87 e0       	ldi	r24, 0x07	; 7
    3128:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    312c:	f7 01       	movw	r30, r14
    312e:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3130:	86 e0       	ldi	r24, 0x06	; 6
    3132:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
    3136:	88 1f       	adc	r24, r24
    3138:	88 27       	eor	r24, r24
    313a:	88 1f       	adc	r24, r24
    313c:	f7 01       	movw	r30, r14
    313e:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3140:	88 23       	and	r24, r24
    3142:	09 f4       	brne	.+2      	; 0x3146 <__vector_64+0xe8>
    3144:	66 c0       	rjmp	.+204    	; 0x3212 <__vector_64+0x1b4>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3146:	8f b7       	in	r24, 0x3f	; 63
    3148:	80 93 56 40 	sts	0x4056, r24
    314c:	f8 94       	cli
    RadioCS(TRUE);
    314e:	81 e0       	ldi	r24, 0x01	; 1
    3150:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3154:	80 e2       	ldi	r24, 0x20	; 32
    3156:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    len = SPID_write(0);
    315a:	80 e0       	ldi	r24, 0x00	; 0
    315c:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
    3160:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3162:	83 50       	subi	r24, 0x03	; 3
    3164:	8d 37       	cpi	r24, 0x7D	; 125
    3166:	08 f0       	brcs	.+2      	; 0x316a <__vector_64+0x10c>
    3168:	41 c0       	rjmp	.+130    	; 0x31ec <__vector_64+0x18e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    316a:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <chb_buf_get_len>
    316e:	2d 2d       	mov	r18, r13
    3170:	30 e0       	ldi	r19, 0x00	; 0
    3172:	a5 01       	movw	r20, r10
    3174:	48 1b       	sub	r20, r24
    3176:	51 09       	sbc	r21, r1
    3178:	24 17       	cp	r18, r20
    317a:	35 07       	cpc	r19, r21
    317c:	94 f4       	brge	.+36     	; 0x31a2 <__vector_64+0x144>
        {
            chb_buf_write(len);
    317e:	8d 2d       	mov	r24, r13
    3180:	0e 94 24 15 	call	0x2a48	; 0x2a48 <chb_buf_write>
            
            for (i=0; i<len; i++)
    3184:	dd 20       	and	r13, r13
    3186:	49 f0       	breq	.+18     	; 0x319a <__vector_64+0x13c>
    3188:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    318a:	80 e0       	ldi	r24, 0x00	; 0
    318c:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
                chb_buf_write(data);
    3190:	0e 94 24 15 	call	0x2a48	; 0x2a48 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3194:	0f 5f       	subi	r16, 0xFF	; 255
    3196:	0d 15       	cp	r16, r13
    3198:	c1 f7       	brne	.-16     	; 0x318a <__vector_64+0x12c>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    319a:	f4 01       	movw	r30, r8
    319c:	c5 82       	std	Z+5, r12	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    319e:	c6 82       	std	Z+6, r12	; 0x06
    31a0:	25 c0       	rjmp	.+74     	; 0x31ec <__vector_64+0x18e>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    31a2:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <chb_get_pcb>
    31a6:	2c 01       	movw	r4, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    31a8:	dd 20       	and	r13, r13
    31aa:	39 f0       	breq	.+14     	; 0x31ba <__vector_64+0x15c>
    31ac:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    31ae:	80 e0       	ldi	r24, 0x00	; 0
    31b0:	0e 94 07 1a 	call	0x340e	; 0x340e <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    31b4:	0f 5f       	subi	r16, 0xFF	; 255
    31b6:	0d 15       	cp	r16, r13
    31b8:	d1 f7       	brne	.-12     	; 0x31ae <__vector_64+0x150>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    31ba:	f2 01       	movw	r30, r4
    31bc:	85 85       	ldd	r24, Z+13	; 0x0d
    31be:	96 85       	ldd	r25, Z+14	; 0x0e
    31c0:	01 96       	adiw	r24, 0x01	; 1
    31c2:	85 87       	std	Z+13, r24	; 0x0d
    31c4:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    31c6:	ce 01       	movw	r24, r28
    31c8:	01 96       	adiw	r24, 0x01	; 1
    31ca:	b3 01       	movw	r22, r6
    31cc:	0e 94 6d 38 	call	0x70da	; 0x70da <strcpy_P>
            printf(buf);
    31d0:	0f 92       	push	r0
    31d2:	0f 92       	push	r0
    31d4:	41 e0       	ldi	r20, 0x01	; 1
    31d6:	50 e0       	ldi	r21, 0x00	; 0
    31d8:	4c 0f       	add	r20, r28
    31da:	5d 1f       	adc	r21, r29
    31dc:	ed b7       	in	r30, 0x3d	; 61
    31de:	fe b7       	in	r31, 0x3e	; 62
    31e0:	41 83       	std	Z+1, r20	; 0x01
    31e2:	52 83       	std	Z+2, r21	; 0x02
    31e4:	0e 94 c0 38 	call	0x7180	; 0x7180 <printf>
    31e8:	0f 90       	pop	r0
    31ea:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    31ec:	80 e0       	ldi	r24, 0x00	; 0
    31ee:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RadioCS>
    CHB_LEAVE_CRIT();
    31f2:	80 91 56 40 	lds	r24, 0x4056
    31f6:	8f bf       	out	0x3f, r24	; 63
    31f8:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    31fa:	f7 01       	movw	r30, r14
    31fc:	85 81       	ldd	r24, Z+5	; 0x05
    31fe:	96 81       	ldd	r25, Z+6	; 0x06
    3200:	01 96       	adiw	r24, 0x01	; 1
    3202:	85 83       	std	Z+5, r24	; 0x05
    3204:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3206:	81 e0       	ldi	r24, 0x01	; 1
    3208:	83 83       	std	Z+3, r24	; 0x03
    320a:	03 c0       	rjmp	.+6      	; 0x3212 <__vector_64+0x1b4>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    320c:	81 e0       	ldi	r24, 0x01	; 1
    320e:	f7 01       	movw	r30, r14
    3210:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3212:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3214:	86 e1       	ldi	r24, 0x16	; 22
    3216:	0e 94 77 16 	call	0x2cee	; 0x2cee <chb_set_state>
    321a:	80 34       	cpi	r24, 0x40	; 64
    321c:	d9 f7       	brne	.-10     	; 0x3214 <__vector_64+0x1b6>
    321e:	19 c0       	rjmp	.+50     	; 0x3252 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3220:	16 ff       	sbrs	r17, 6
    3222:	08 c0       	rjmp	.+16     	; 0x3234 <__vector_64+0x1d6>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3224:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3226:	f7 01       	movw	r30, r14
    3228:	87 85       	ldd	r24, Z+15	; 0x0f
    322a:	90 89       	ldd	r25, Z+16	; 0x10
    322c:	01 96       	adiw	r24, 0x01	; 1
    322e:	87 87       	std	Z+15, r24	; 0x0f
    3230:	90 8b       	std	Z+16, r25	; 0x10
    3232:	0f c0       	rjmp	.+30     	; 0x3252 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3234:	11 ff       	sbrs	r17, 1
    3236:	02 c0       	rjmp	.+4      	; 0x323c <__vector_64+0x1de>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3238:	1d 7f       	andi	r17, 0xFD	; 253
    323a:	0b c0       	rjmp	.+22     	; 0x3252 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    323c:	10 ff       	sbrs	r17, 0
    323e:	02 c0       	rjmp	.+4      	; 0x3244 <__vector_64+0x1e6>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3240:	1e 7f       	andi	r17, 0xFE	; 254
    3242:	07 c0       	rjmp	.+14     	; 0x3252 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3244:	11 23       	and	r17, r17
    3246:	2c f4       	brge	.+10     	; 0x3252 <__vector_64+0x1f4>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3248:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    324a:	f7 01       	movw	r30, r14
    324c:	81 89       	ldd	r24, Z+17	; 0x11
    324e:	8f 5f       	subi	r24, 0xFF	; 255
    3250:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3252:	11 23       	and	r17, r17
    3254:	09 f0       	breq	.+2      	; 0x3258 <__vector_64+0x1fa>
    3256:	55 cf       	rjmp	.-342    	; 0x3102 <__vector_64+0xa4>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3258:	80 91 56 40 	lds	r24, 0x4056
    325c:	8f bf       	out	0x3f, r24	; 63
    325e:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3260:	8f e0       	ldi	r24, 0x0F	; 15
    3262:	0e 94 44 16 	call	0x2c88	; 0x2c88 <chb_reg_read>
}
    3266:	e2 96       	adiw	r28, 0x32	; 50
    3268:	cd bf       	out	0x3d, r28	; 61
    326a:	de bf       	out	0x3e, r29	; 62
    326c:	df 91       	pop	r29
    326e:	cf 91       	pop	r28
    3270:	ff 91       	pop	r31
    3272:	ef 91       	pop	r30
    3274:	bf 91       	pop	r27
    3276:	af 91       	pop	r26
    3278:	9f 91       	pop	r25
    327a:	8f 91       	pop	r24
    327c:	7f 91       	pop	r23
    327e:	6f 91       	pop	r22
    3280:	5f 91       	pop	r21
    3282:	4f 91       	pop	r20
    3284:	3f 91       	pop	r19
    3286:	2f 91       	pop	r18
    3288:	1f 91       	pop	r17
    328a:	0f 91       	pop	r16
    328c:	ff 90       	pop	r15
    328e:	ef 90       	pop	r14
    3290:	df 90       	pop	r13
    3292:	cf 90       	pop	r12
    3294:	bf 90       	pop	r11
    3296:	af 90       	pop	r10
    3298:	9f 90       	pop	r9
    329a:	8f 90       	pop	r8
    329c:	7f 90       	pop	r7
    329e:	6f 90       	pop	r6
    32a0:	5f 90       	pop	r5
    32a2:	4f 90       	pop	r4
    32a4:	0f 90       	pop	r0
    32a6:	0b be       	out	0x3b, r0	; 59
    32a8:	0f 90       	pop	r0
    32aa:	0f be       	out	0x3f, r0	; 63
    32ac:	0f 90       	pop	r0
    32ae:	1f 90       	pop	r1
    32b0:	18 95       	reti

000032b2 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    32b2:	0f 93       	push	r16
    32b4:	1f 93       	push	r17
    32b6:	cf 93       	push	r28
    32b8:	df 93       	push	r29
    32ba:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    32bc:	e0 ec       	ldi	r30, 0xC0	; 192
    32be:	f1 e0       	ldi	r31, 0x01	; 1
    32c0:	84 85       	ldd	r24, Z+12	; 0x0c
    32c2:	87 7f       	andi	r24, 0xF7	; 247
    32c4:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    32c6:	41 15       	cp	r20, r1
    32c8:	51 05       	cpc	r21, r1
    32ca:	09 f4       	brne	.+2      	; 0x32ce <chb_eeprom_write+0x1c>
    32cc:	50 c0       	rjmp	.+160    	; 0x336e <chb_eeprom_write+0xbc>
    32ce:	e0 e0       	ldi	r30, 0x00	; 0
    32d0:	f0 e0       	ldi	r31, 0x00	; 0
    32d2:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    32d4:	a0 ec       	ldi	r26, 0xC0	; 192
    32d6:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    32d8:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    32da:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    32dc:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    32de:	cf 01       	movw	r24, r30
    32e0:	80 0f       	add	r24, r16
    32e2:	91 1f       	adc	r25, r17
    32e4:	e6 0f       	add	r30, r22
    32e6:	f7 1f       	adc	r31, r23
    32e8:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    32ea:	1f 96       	adiw	r26, 0x0f	; 15
    32ec:	ec 91       	ld	r30, X
    32ee:	1f 97       	sbiw	r26, 0x0f	; 15
    32f0:	ee 23       	and	r30, r30
    32f2:	dc f3       	brlt	.-10     	; 0x32ea <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    32f4:	1f 96       	adiw	r26, 0x0f	; 15
    32f6:	ec 91       	ld	r30, X
    32f8:	1f 97       	sbiw	r26, 0x0f	; 15
    32fa:	e1 ff       	sbrs	r30, 1
    32fc:	11 c0       	rjmp	.+34     	; 0x3320 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    32fe:	1a 96       	adiw	r26, 0x0a	; 10
    3300:	dc 93       	st	X, r29
    3302:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3304:	ef 93       	push	r30
    3306:	ff 93       	push	r31
    3308:	0f 93       	push	r16
    330a:	2f 93       	push	r18
    330c:	eb ec       	ldi	r30, 0xCB	; 203
    330e:	f1 e0       	ldi	r31, 0x01	; 1
    3310:	08 ed       	ldi	r16, 0xD8	; 216
    3312:	21 e0       	ldi	r18, 0x01	; 1
    3314:	04 bf       	out	0x34, r16	; 52
    3316:	20 83       	st	Z, r18
    3318:	2f 91       	pop	r18
    331a:	0f 91       	pop	r16
    331c:	ff 91       	pop	r31
    331e:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3320:	1a 96       	adiw	r26, 0x0a	; 10
    3322:	cc 93       	st	X, r28
    3324:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3326:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3328:	89 2f       	mov	r24, r25
    332a:	8f 71       	andi	r24, 0x1F	; 31
    332c:	11 96       	adiw	r26, 0x01	; 1
    332e:	8c 93       	st	X, r24
    3330:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3332:	12 96       	adiw	r26, 0x02	; 2
    3334:	1c 92       	st	X, r1
    3336:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3338:	14 96       	adiw	r26, 0x04	; 4
    333a:	fc 93       	st	X, r31
    333c:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    333e:	1a 96       	adiw	r26, 0x0a	; 10
    3340:	3c 93       	st	X, r19
    3342:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3344:	ef 93       	push	r30
    3346:	ff 93       	push	r31
    3348:	0f 93       	push	r16
    334a:	2f 93       	push	r18
    334c:	eb ec       	ldi	r30, 0xCB	; 203
    334e:	f1 e0       	ldi	r31, 0x01	; 1
    3350:	08 ed       	ldi	r16, 0xD8	; 216
    3352:	21 e0       	ldi	r18, 0x01	; 1
    3354:	04 bf       	out	0x34, r16	; 52
    3356:	20 83       	st	Z, r18
    3358:	2f 91       	pop	r18
    335a:	0f 91       	pop	r16
    335c:	ff 91       	pop	r31
    335e:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3360:	2f 5f       	subi	r18, 0xFF	; 255
    3362:	e2 2f       	mov	r30, r18
    3364:	f0 e0       	ldi	r31, 0x00	; 0
    3366:	e4 17       	cp	r30, r20
    3368:	f5 07       	cpc	r31, r21
    336a:	08 f4       	brcc	.+2      	; 0x336e <chb_eeprom_write+0xbc>
    336c:	b8 cf       	rjmp	.-144    	; 0x32de <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    336e:	df 91       	pop	r29
    3370:	cf 91       	pop	r28
    3372:	1f 91       	pop	r17
    3374:	0f 91       	pop	r16
    3376:	08 95       	ret

00003378 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3378:	1f 93       	push	r17
    337a:	cf 93       	push	r28
    337c:	df 93       	push	r29
    337e:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3380:	e0 ec       	ldi	r30, 0xC0	; 192
    3382:	f1 e0       	ldi	r31, 0x01	; 1
    3384:	84 85       	ldd	r24, Z+12	; 0x0c
    3386:	87 7f       	andi	r24, 0xF7	; 247
    3388:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    338a:	41 15       	cp	r20, r1
    338c:	51 05       	cpc	r21, r1
    338e:	41 f1       	breq	.+80     	; 0x33e0 <chb_eeprom_read+0x68>
    3390:	80 e0       	ldi	r24, 0x00	; 0
    3392:	90 e0       	ldi	r25, 0x00	; 0
    3394:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3396:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3398:	db 01       	movw	r26, r22
    339a:	a8 0f       	add	r26, r24
    339c:	b9 1f       	adc	r27, r25
    339e:	82 0f       	add	r24, r18
    33a0:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    33a2:	17 85       	ldd	r17, Z+15	; 0x0f
    33a4:	11 23       	and	r17, r17
    33a6:	ec f3       	brlt	.-6      	; 0x33a2 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    33a8:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    33aa:	89 2f       	mov	r24, r25
    33ac:	8f 71       	andi	r24, 0x1F	; 31
    33ae:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    33b0:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    33b2:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    33b4:	ef 93       	push	r30
    33b6:	ff 93       	push	r31
    33b8:	0f 93       	push	r16
    33ba:	2f 93       	push	r18
    33bc:	eb ec       	ldi	r30, 0xCB	; 203
    33be:	f1 e0       	ldi	r31, 0x01	; 1
    33c0:	08 ed       	ldi	r16, 0xD8	; 216
    33c2:	21 e0       	ldi	r18, 0x01	; 1
    33c4:	04 bf       	out	0x34, r16	; 52
    33c6:	20 83       	st	Z, r18
    33c8:	2f 91       	pop	r18
    33ca:	0f 91       	pop	r16
    33cc:	ff 91       	pop	r31
    33ce:	ef 91       	pop	r30

    return NVM.DATA0;
    33d0:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    33d2:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    33d4:	cf 5f       	subi	r28, 0xFF	; 255
    33d6:	8c 2f       	mov	r24, r28
    33d8:	90 e0       	ldi	r25, 0x00	; 0
    33da:	84 17       	cp	r24, r20
    33dc:	95 07       	cpc	r25, r21
    33de:	e0 f2       	brcs	.-72     	; 0x3398 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    33e0:	df 91       	pop	r29
    33e2:	cf 91       	pop	r28
    33e4:	1f 91       	pop	r17
    33e6:	08 95       	ret

000033e8 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    33e8:	e0 e6       	ldi	r30, 0x60	; 96
    33ea:	f6 e0       	ldi	r31, 0x06	; 6
    33ec:	80 81       	ld	r24, Z
    33ee:	80 6b       	ori	r24, 0xB0	; 176
    33f0:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    33f2:	e4 e6       	ldi	r30, 0x64	; 100
    33f4:	f6 e0       	ldi	r31, 0x06	; 6
    33f6:	80 81       	ld	r24, Z
    33f8:	80 61       	ori	r24, 0x10	; 16
    33fa:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    33fc:	a0 ec       	ldi	r26, 0xC0	; 192
    33fe:	b9 e0       	ldi	r27, 0x09	; 9
    3400:	8c 91       	ld	r24, X
    3402:	81 65       	ori	r24, 0x51	; 81
    3404:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3406:	80 81       	ld	r24, Z
    3408:	80 61       	ori	r24, 0x10	; 16
    340a:	80 83       	st	Z, r24
}
    340c:	08 95       	ret

0000340e <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    340e:	e0 ec       	ldi	r30, 0xC0	; 192
    3410:	f9 e0       	ldi	r31, 0x09	; 9
    3412:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3414:	82 81       	ldd	r24, Z+2	; 0x02
    3416:	88 23       	and	r24, r24
    3418:	ec f7       	brge	.-6      	; 0x3414 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    341a:	e0 ec       	ldi	r30, 0xC0	; 192
    341c:	f9 e0       	ldi	r31, 0x09	; 9
    341e:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3420:	08 95       	ret

00003422 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3422:	0f 93       	push	r16
    3424:	cf 93       	push	r28
    3426:	df 93       	push	r29
    3428:	0f 92       	push	r0
    342a:	cd b7       	in	r28, 0x3d	; 61
    342c:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    342e:	2f b7       	in	r18, 0x3f	; 63
    3430:	29 83       	std	Y+1, r18	; 0x01
    3432:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3434:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3436:	fc 01       	movw	r30, r24
    3438:	08 ed       	ldi	r16, 0xD8	; 216
    343a:	04 bf       	out	0x34, r16	; 52
    343c:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    343e:	89 81       	ldd	r24, Y+1	; 0x01
    3440:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3442:	0f 90       	pop	r0
    3444:	df 91       	pop	r29
    3446:	cf 91       	pop	r28
    3448:	0f 91       	pop	r16
    344a:	08 95       	ret

0000344c <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    344c:	66 23       	and	r22, r22
    344e:	11 f0       	breq	.+4      	; 0x3454 <CLKSYS_XOSC_Config+0x8>
    3450:	90 e2       	ldi	r25, 0x20	; 32
    3452:	01 c0       	rjmp	.+2      	; 0x3456 <CLKSYS_XOSC_Config+0xa>
    3454:	90 e0       	ldi	r25, 0x00	; 0
    3456:	84 2b       	or	r24, r20
    3458:	89 2b       	or	r24, r25
    345a:	e0 e5       	ldi	r30, 0x50	; 80
    345c:	f0 e0       	ldi	r31, 0x00	; 0
    345e:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3460:	08 95       	ret

00003462 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3462:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3464:	86 2b       	or	r24, r22
    3466:	e0 e5       	ldi	r30, 0x50	; 80
    3468:	f0 e0       	ldi	r31, 0x00	; 0
    346a:	85 83       	std	Z+5, r24	; 0x05
}
    346c:	08 95       	ret

0000346e <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    346e:	e0 e5       	ldi	r30, 0x50	; 80
    3470:	f0 e0       	ldi	r31, 0x00	; 0
    3472:	90 81       	ld	r25, Z
    3474:	28 2f       	mov	r18, r24
    3476:	20 95       	com	r18
    3478:	92 23       	and	r25, r18
    347a:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    347c:	90 81       	ld	r25, Z
	return clkEnabled;
}
    347e:	89 23       	and	r24, r25
    3480:	08 95       	ret

00003482 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    3482:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    3484:	81 e4       	ldi	r24, 0x41	; 65
    3486:	90 e0       	ldi	r25, 0x00	; 0
    3488:	0e 94 11 1a 	call	0x3422	; 0x3422 <CCPWrite>
}
    348c:	08 95       	ret

0000348e <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    348e:	1f 93       	push	r17
    3490:	cf 93       	push	r28
    3492:	df 93       	push	r29
    3494:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    3496:	c0 e4       	ldi	r28, 0x40	; 64
    3498:	d0 e0       	ldi	r29, 0x00	; 0
    349a:	68 81       	ld	r22, Y
    349c:	68 7f       	andi	r22, 0xF8	; 248
    349e:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    34a0:	80 e4       	ldi	r24, 0x40	; 64
    34a2:	90 e0       	ldi	r25, 0x00	; 0
    34a4:	0e 94 11 1a 	call	0x3422	; 0x3422 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    34a8:	88 81       	ld	r24, Y
	return clkCtrl;
}
    34aa:	81 23       	and	r24, r17
    34ac:	df 91       	pop	r29
    34ae:	cf 91       	pop	r28
    34b0:	1f 91       	pop	r17
    34b2:	08 95       	ret

000034b4 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    34b4:	e0 e4       	ldi	r30, 0x40	; 64
    34b6:	f0 e0       	ldi	r31, 0x00	; 0
    34b8:	93 81       	ldd	r25, Z+3	; 0x03
    34ba:	91 7f       	andi	r25, 0xF1	; 241
    34bc:	91 60       	ori	r25, 0x01	; 1
    34be:	89 2b       	or	r24, r25
    34c0:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    34c2:	08 95       	ret

000034c4 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    34c4:	e0 e5       	ldi	r30, 0x50	; 80
    34c6:	f0 e0       	ldi	r31, 0x00	; 0
    34c8:	26 81       	ldd	r18, Z+6	; 0x06
    34ca:	98 2f       	mov	r25, r24
    34cc:	38 2f       	mov	r19, r24
    34ce:	30 95       	com	r19
    34d0:	23 23       	and	r18, r19
    34d2:	66 23       	and	r22, r22
    34d4:	09 f4       	brne	.+2      	; 0x34d8 <CLKSYS_AutoCalibration_Enable+0x14>
    34d6:	90 e0       	ldi	r25, 0x00	; 0
    34d8:	92 2b       	or	r25, r18
    34da:	e0 e5       	ldi	r30, 0x50	; 80
    34dc:	f0 e0       	ldi	r31, 0x00	; 0
    34de:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    34e0:	81 30       	cpi	r24, 0x01	; 1
    34e2:	31 f4       	brne	.+12     	; 0x34f0 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    34e4:	e8 e6       	ldi	r30, 0x68	; 104
    34e6:	f0 e0       	ldi	r31, 0x00	; 0
    34e8:	80 81       	ld	r24, Z
    34ea:	81 60       	ori	r24, 0x01	; 1
    34ec:	80 83       	st	Z, r24
    34ee:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    34f0:	82 30       	cpi	r24, 0x02	; 2
    34f2:	29 f4       	brne	.+10     	; 0x34fe <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    34f4:	e0 e6       	ldi	r30, 0x60	; 96
    34f6:	f0 e0       	ldi	r31, 0x00	; 0
    34f8:	80 81       	ld	r24, Z
    34fa:	81 60       	ori	r24, 0x01	; 1
    34fc:	80 83       	st	Z, r24
    34fe:	08 95       	ret

00003500 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3500:	83 e5       	ldi	r24, 0x53	; 83
    3502:	90 e0       	ldi	r25, 0x00	; 0
    3504:	63 e0       	ldi	r22, 0x03	; 3
    3506:	0e 94 11 1a 	call	0x3422	; 0x3422 <CCPWrite>
}
    350a:	08 95       	ret

0000350c <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    350c:	82 e4       	ldi	r24, 0x42	; 66
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	61 e0       	ldi	r22, 0x01	; 1
    3512:	0e 94 11 1a 	call	0x3422	; 0x3422 <CCPWrite>
}
    3516:	08 95       	ret

00003518 <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    3518:	80 ec       	ldi	r24, 0xC0	; 192
    351a:	60 e0       	ldi	r22, 0x00	; 0
    351c:	4b e0       	ldi	r20, 0x0B	; 11
    351e:	0e 94 26 1a 	call	0x344c	; 0x344c <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    3522:	e0 e5       	ldi	r30, 0x50	; 80
    3524:	f0 e0       	ldi	r31, 0x00	; 0
    3526:	80 81       	ld	r24, Z
    3528:	88 60       	ori	r24, 0x08	; 8
    352a:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    352c:	81 81       	ldd	r24, Z+1	; 0x01
    352e:	83 ff       	sbrs	r24, 3
    3530:	fd cf       	rjmp	.-6      	; 0x352c <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    3532:	80 ec       	ldi	r24, 0xC0	; 192
    3534:	62 e0       	ldi	r22, 0x02	; 2
    3536:	0e 94 31 1a 	call	0x3462	; 0x3462 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    353a:	e0 e5       	ldi	r30, 0x50	; 80
    353c:	f0 e0       	ldi	r31, 0x00	; 0
    353e:	80 81       	ld	r24, Z
    3540:	80 61       	ori	r24, 0x10	; 16
    3542:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    3544:	81 81       	ldd	r24, Z+1	; 0x01
    3546:	84 ff       	sbrs	r24, 4
    3548:	fd cf       	rjmp	.-6      	; 0x3544 <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    354a:	84 e0       	ldi	r24, 0x04	; 4
    354c:	0e 94 47 1a 	call	0x348e	; 0x348e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3550:	81 e0       	ldi	r24, 0x01	; 1
    3552:	0e 94 37 1a 	call	0x346e	; 0x346e <CLKSYS_Disable>
}
    3556:	08 95       	ret

00003558 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3558:	e0 e5       	ldi	r30, 0x50	; 80
    355a:	f0 e0       	ldi	r31, 0x00	; 0
    355c:	80 81       	ld	r24, Z
    355e:	82 60       	ori	r24, 0x02	; 2
    3560:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    3562:	80 e0       	ldi	r24, 0x00	; 0
    3564:	61 e0       	ldi	r22, 0x01	; 1
    3566:	0e 94 41 1a 	call	0x3482	; 0x3482 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    356a:	e0 e5       	ldi	r30, 0x50	; 80
    356c:	f0 e0       	ldi	r31, 0x00	; 0
    356e:	81 81       	ldd	r24, Z+1	; 0x01
    3570:	81 ff       	sbrs	r24, 1
    3572:	fd cf       	rjmp	.-6      	; 0x356e <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3574:	81 e0       	ldi	r24, 0x01	; 1
    3576:	0e 94 47 1a 	call	0x348e	; 0x348e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	0e 94 37 1a 	call	0x346e	; 0x346e <CLKSYS_Disable>
	
}
    3580:	08 95       	ret

00003582 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3582:	e0 e5       	ldi	r30, 0x50	; 80
    3584:	f0 e0       	ldi	r31, 0x00	; 0
    3586:	80 81       	ld	r24, Z
    3588:	82 60       	ori	r24, 0x02	; 2
    358a:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    358c:	80 e0       	ldi	r24, 0x00	; 0
    358e:	60 e0       	ldi	r22, 0x00	; 0
    3590:	0e 94 41 1a 	call	0x3482	; 0x3482 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3594:	e0 e5       	ldi	r30, 0x50	; 80
    3596:	f0 e0       	ldi	r31, 0x00	; 0
    3598:	81 81       	ldd	r24, Z+1	; 0x01
    359a:	81 ff       	sbrs	r24, 1
    359c:	fd cf       	rjmp	.-6      	; 0x3598 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    359e:	81 e0       	ldi	r24, 0x01	; 1
    35a0:	0e 94 47 1a 	call	0x348e	; 0x348e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    35a4:	81 e0       	ldi	r24, 0x01	; 1
    35a6:	0e 94 37 1a 	call	0x346e	; 0x346e <CLKSYS_Disable>
	
}
    35aa:	08 95       	ret

000035ac <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    35ac:	88 23       	and	r24, r24
    35ae:	29 f0       	breq	.+10     	; 0x35ba <portExCS+0xe>
    35b0:	88 e0       	ldi	r24, 0x08	; 8
    35b2:	e0 e0       	ldi	r30, 0x00	; 0
    35b4:	f6 e0       	ldi	r31, 0x06	; 6
    35b6:	86 83       	std	Z+6, r24	; 0x06
    35b8:	04 c0       	rjmp	.+8      	; 0x35c2 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    35ba:	88 e0       	ldi	r24, 0x08	; 8
    35bc:	e0 e0       	ldi	r30, 0x00	; 0
    35be:	f6 e0       	ldi	r31, 0x06	; 6
    35c0:	85 83       	std	Z+5, r24	; 0x05
    35c2:	8a e6       	ldi	r24, 0x6A	; 106
    35c4:	8a 95       	dec	r24
    35c6:	f1 f7       	brne	.-4      	; 0x35c4 <portExCS+0x18>
    35c8:	00 c0       	rjmp	.+0      	; 0x35ca <portExCS+0x1e>
	}
	_delay_us(10);
}
    35ca:	08 95       	ret

000035cc <Ext1Power>:
*/


void Ext1Power(uint8_t on) {
	
	if (on) {
    35cc:	88 23       	and	r24, r24
    35ce:	79 f0       	breq	.+30     	; 0x35ee <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    35d0:	e0 ea       	ldi	r30, 0xA0	; 160
    35d2:	f6 e0       	ldi	r31, 0x06	; 6
    35d4:	80 e2       	ldi	r24, 0x20	; 32
    35d6:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    35d8:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    35da:	8f ef       	ldi	r24, 0xFF	; 255
    35dc:	93 ec       	ldi	r25, 0xC3	; 195
    35de:	a9 e0       	ldi	r26, 0x09	; 9
    35e0:	81 50       	subi	r24, 0x01	; 1
    35e2:	90 40       	sbci	r25, 0x00	; 0
    35e4:	a0 40       	sbci	r26, 0x00	; 0
    35e6:	e1 f7       	brne	.-8      	; 0x35e0 <Ext1Power+0x14>
    35e8:	00 c0       	rjmp	.+0      	; 0x35ea <Ext1Power+0x1e>
    35ea:	00 00       	nop
    35ec:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    35ee:	e0 ea       	ldi	r30, 0xA0	; 160
    35f0:	f6 e0       	ldi	r31, 0x06	; 6
    35f2:	80 e2       	ldi	r24, 0x20	; 32
    35f4:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    35f6:	82 83       	std	Z+2, r24	; 0x02
    35f8:	08 95       	ret

000035fa <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
    35fa:	88 23       	and	r24, r24
    35fc:	79 f0       	breq	.+30     	; 0x361c <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    35fe:	e0 ea       	ldi	r30, 0xA0	; 160
    3600:	f6 e0       	ldi	r31, 0x06	; 6
    3602:	80 e4       	ldi	r24, 0x40	; 64
    3604:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    3606:	85 83       	std	Z+5, r24	; 0x05
    3608:	8f ef       	ldi	r24, 0xFF	; 255
    360a:	93 ec       	ldi	r25, 0xC3	; 195
    360c:	a9 e0       	ldi	r26, 0x09	; 9
    360e:	81 50       	subi	r24, 0x01	; 1
    3610:	90 40       	sbci	r25, 0x00	; 0
    3612:	a0 40       	sbci	r26, 0x00	; 0
    3614:	e1 f7       	brne	.-8      	; 0x360e <Ext2Power+0x14>
    3616:	00 c0       	rjmp	.+0      	; 0x3618 <Ext2Power+0x1e>
    3618:	00 00       	nop
    361a:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    361c:	e0 ea       	ldi	r30, 0xA0	; 160
    361e:	f6 e0       	ldi	r31, 0x06	; 6
    3620:	80 e4       	ldi	r24, 0x40	; 64
    3622:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    3624:	82 83       	std	Z+2, r24	; 0x02
    3626:	08 95       	ret

00003628 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
    3628:	88 23       	and	r24, r24
    362a:	79 f0       	breq	.+30     	; 0x364a <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    362c:	e0 ea       	ldi	r30, 0xA0	; 160
    362e:	f6 e0       	ldi	r31, 0x06	; 6
    3630:	80 e8       	ldi	r24, 0x80	; 128
    3632:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    3634:	85 83       	std	Z+5, r24	; 0x05
    3636:	8f ef       	ldi	r24, 0xFF	; 255
    3638:	93 ec       	ldi	r25, 0xC3	; 195
    363a:	a9 e0       	ldi	r26, 0x09	; 9
    363c:	81 50       	subi	r24, 0x01	; 1
    363e:	90 40       	sbci	r25, 0x00	; 0
    3640:	a0 40       	sbci	r26, 0x00	; 0
    3642:	e1 f7       	brne	.-8      	; 0x363c <HVPower+0x14>
    3644:	00 c0       	rjmp	.+0      	; 0x3646 <HVPower+0x1e>
    3646:	00 00       	nop
    3648:	05 c0       	rjmp	.+10     	; 0x3654 <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    364a:	e0 ea       	ldi	r30, 0xA0	; 160
    364c:	f6 e0       	ldi	r31, 0x06	; 6
    364e:	80 e8       	ldi	r24, 0x80	; 128
    3650:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    3652:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3654:	af e3       	ldi	r26, 0x3F	; 63
    3656:	bf e1       	ldi	r27, 0x1F	; 31
    3658:	11 97       	sbiw	r26, 0x01	; 1
    365a:	f1 f7       	brne	.-4      	; 0x3658 <HVPower+0x30>
    365c:	00 c0       	rjmp	.+0      	; 0x365e <HVPower+0x36>
    365e:	00 00       	nop
	}
	_delay_us(1000);
}
    3660:	08 95       	ret

00003662 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    3662:	88 23       	and	r24, r24
    3664:	29 f0       	breq	.+10     	; 0x3670 <lowerMuxCS+0xe>
    3666:	80 e1       	ldi	r24, 0x10	; 16
    3668:	e0 e8       	ldi	r30, 0x80	; 128
    366a:	f6 e0       	ldi	r31, 0x06	; 6
    366c:	86 83       	std	Z+6, r24	; 0x06
    366e:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    3670:	80 e1       	ldi	r24, 0x10	; 16
    3672:	e0 e8       	ldi	r30, 0x80	; 128
    3674:	f6 e0       	ldi	r31, 0x06	; 6
    3676:	85 83       	std	Z+5, r24	; 0x05
    3678:	08 95       	ret

0000367a <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    367a:	88 23       	and	r24, r24
    367c:	29 f0       	breq	.+10     	; 0x3688 <upperMuxCS+0xe>
    367e:	82 e0       	ldi	r24, 0x02	; 2
    3680:	e0 e4       	ldi	r30, 0x40	; 64
    3682:	f6 e0       	ldi	r31, 0x06	; 6
    3684:	86 83       	std	Z+6, r24	; 0x06
    3686:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    3688:	82 e0       	ldi	r24, 0x02	; 2
    368a:	e0 e4       	ldi	r30, 0x40	; 64
    368c:	f6 e0       	ldi	r31, 0x06	; 6
    368e:	85 83       	std	Z+5, r24	; 0x05
    3690:	08 95       	ret

00003692 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3692:	e0 e4       	ldi	r30, 0x40	; 64
    3694:	f6 e0       	ldi	r31, 0x06	; 6
    3696:	90 e1       	ldi	r25, 0x10	; 16
    3698:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    369a:	28 e3       	ldi	r18, 0x38	; 56
    369c:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    369e:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    36a0:	81 65       	ori	r24, 0x51	; 81
    36a2:	a0 ec       	ldi	r26, 0xC0	; 192
    36a4:	b8 e0       	ldi	r27, 0x08	; 8
    36a6:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    36a8:	11 96       	adiw	r26, 0x01	; 1
    36aa:	1c 92       	st	X, r1
    36ac:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    36ae:	80 ea       	ldi	r24, 0xA0	; 160
    36b0:	81 83       	std	Z+1, r24	; 0x01

	
}
    36b2:	08 95       	ret

000036b4 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    36b4:	e0 e4       	ldi	r30, 0x40	; 64
    36b6:	f6 e0       	ldi	r31, 0x06	; 6
    36b8:	90 e1       	ldi	r25, 0x10	; 16
    36ba:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    36bc:	28 e3       	ldi	r18, 0x38	; 56
    36be:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    36c0:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    36c2:	80 65       	ori	r24, 0x50	; 80
    36c4:	68 2b       	or	r22, r24
    36c6:	a0 ec       	ldi	r26, 0xC0	; 192
    36c8:	b8 e0       	ldi	r27, 0x08	; 8
    36ca:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    36cc:	11 96       	adiw	r26, 0x01	; 1
    36ce:	1c 92       	st	X, r1
    36d0:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    36d2:	80 ea       	ldi	r24, 0xA0	; 160
    36d4:	81 83       	std	Z+1, r24	; 0x01
}
    36d6:	08 95       	ret

000036d8 <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    36d8:	88 23       	and	r24, r24
    36da:	29 f0       	breq	.+10     	; 0x36e6 <SPICS+0xe>
    36dc:	80 e1       	ldi	r24, 0x10	; 16
    36de:	e0 e4       	ldi	r30, 0x40	; 64
    36e0:	f6 e0       	ldi	r31, 0x06	; 6
    36e2:	86 83       	std	Z+6, r24	; 0x06
    36e4:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    36e6:	80 e1       	ldi	r24, 0x10	; 16
    36e8:	e0 e4       	ldi	r30, 0x40	; 64
    36ea:	f6 e0       	ldi	r31, 0x06	; 6
    36ec:	85 83       	std	Z+5, r24	; 0x05
    36ee:	08 95       	ret

000036f0 <SPIDisable>:
	}	
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
    36f0:	e0 e4       	ldi	r30, 0x40	; 64
    36f2:	f6 e0       	ldi	r31, 0x06	; 6
    36f4:	80 e1       	ldi	r24, 0x10	; 16
    36f6:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    36f8:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    36fc:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    36fe:	80 eb       	ldi	r24, 0xB0	; 176
    3700:	82 83       	std	Z+2, r24	; 0x02

}
    3702:	08 95       	ret

00003704 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3704:	cf 93       	push	r28
    3706:	df 93       	push	r29
    3708:	c8 2f       	mov	r28, r24
    370a:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    370c:	80 e0       	ldi	r24, 0x00	; 0
    370e:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    3712:	81 e0       	ldi	r24, 0x01	; 1
    3714:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	portExCS(TRUE);
    3718:	81 e0       	ldi	r24, 0x01	; 1
    371a:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    371e:	dd 23       	and	r29, r29
    3720:	89 f0       	breq	.+34     	; 0x3744 <PortEx_OUTCLR+0x40>
    3722:	80 91 d6 23 	lds	r24, 0x23D6
    3726:	c0 95       	com	r28
    3728:	c8 23       	and	r28, r24
    372a:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    372e:	80 e4       	ldi	r24, 0x40	; 64
    3730:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3734:	84 e1       	ldi	r24, 0x14	; 20
    3736:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    373a:	80 91 d6 23 	lds	r24, 0x23D6
    373e:	80 93 67 50 	sts	0x5067, r24
    3742:	10 c0       	rjmp	.+32     	; 0x3764 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    3744:	80 91 82 50 	lds	r24, 0x5082
    3748:	c0 95       	com	r28
    374a:	c8 23       	and	r28, r24
    374c:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3750:	80 e4       	ldi	r24, 0x40	; 64
    3752:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3756:	85 e1       	ldi	r24, 0x15	; 21
    3758:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    375c:	80 91 82 50 	lds	r24, 0x5082
    3760:	80 93 67 50 	sts	0x5067, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3764:	80 e0       	ldi	r24, 0x00	; 0
    3766:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3768:	25 e6       	ldi	r18, 0x65	; 101
    376a:	30 e5       	ldi	r19, 0x50	; 80
    376c:	a0 ec       	ldi	r26, 0xC0	; 192
    376e:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3770:	c1 e7       	ldi	r28, 0x71	; 113
    3772:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3774:	f9 01       	movw	r30, r18
    3776:	e8 0f       	add	r30, r24
    3778:	f9 1f       	adc	r31, r25
    377a:	40 81       	ld	r20, Z
    377c:	13 96       	adiw	r26, 0x03	; 3
    377e:	4c 93       	st	X, r20
    3780:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3782:	12 96       	adiw	r26, 0x02	; 2
    3784:	4c 91       	ld	r20, X
    3786:	12 97       	sbiw	r26, 0x02	; 2
    3788:	44 23       	and	r20, r20
    378a:	dc f7       	brge	.-10     	; 0x3782 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    378c:	13 96       	adiw	r26, 0x03	; 3
    378e:	4c 91       	ld	r20, X
    3790:	13 97       	sbiw	r26, 0x03	; 3
    3792:	48 83       	st	Y, r20
    3794:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3796:	83 30       	cpi	r24, 0x03	; 3
    3798:	91 05       	cpc	r25, r1
    379a:	61 f7       	brne	.-40     	; 0x3774 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    379c:	80 e0       	ldi	r24, 0x00	; 0
    379e:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	portExCS(FALSE);
    37a2:	80 e0       	ldi	r24, 0x00	; 0
    37a4:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>
	SPIDisable();
    37a8:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
}
    37ac:	df 91       	pop	r29
    37ae:	cf 91       	pop	r28
    37b0:	08 95       	ret

000037b2 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    37b2:	cf 93       	push	r28
    37b4:	df 93       	push	r29
    37b6:	c8 2f       	mov	r28, r24
    37b8:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    37ba:	80 e0       	ldi	r24, 0x00	; 0
    37bc:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    37c0:	81 e0       	ldi	r24, 0x01	; 1
    37c2:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	portExCS(TRUE);
    37c6:	81 e0       	ldi	r24, 0x01	; 1
    37c8:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    37cc:	dd 23       	and	r29, r29
    37ce:	81 f0       	breq	.+32     	; 0x37f0 <PortEx_OUTSET+0x3e>
    37d0:	80 91 d6 23 	lds	r24, 0x23D6
    37d4:	c8 2b       	or	r28, r24
    37d6:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    37da:	80 e4       	ldi	r24, 0x40	; 64
    37dc:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    37e0:	84 e1       	ldi	r24, 0x14	; 20
    37e2:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    37e6:	80 91 d6 23 	lds	r24, 0x23D6
    37ea:	80 93 67 50 	sts	0x5067, r24
    37ee:	0f c0       	rjmp	.+30     	; 0x380e <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    37f0:	80 91 82 50 	lds	r24, 0x5082
    37f4:	c8 2b       	or	r28, r24
    37f6:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    37fa:	80 e4       	ldi	r24, 0x40	; 64
    37fc:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3800:	85 e1       	ldi	r24, 0x15	; 21
    3802:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3806:	80 91 82 50 	lds	r24, 0x5082
    380a:	80 93 67 50 	sts	0x5067, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    380e:	80 e0       	ldi	r24, 0x00	; 0
    3810:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3812:	25 e6       	ldi	r18, 0x65	; 101
    3814:	30 e5       	ldi	r19, 0x50	; 80
    3816:	a0 ec       	ldi	r26, 0xC0	; 192
    3818:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    381a:	c1 e7       	ldi	r28, 0x71	; 113
    381c:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    381e:	f9 01       	movw	r30, r18
    3820:	e8 0f       	add	r30, r24
    3822:	f9 1f       	adc	r31, r25
    3824:	40 81       	ld	r20, Z
    3826:	13 96       	adiw	r26, 0x03	; 3
    3828:	4c 93       	st	X, r20
    382a:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    382c:	12 96       	adiw	r26, 0x02	; 2
    382e:	4c 91       	ld	r20, X
    3830:	12 97       	sbiw	r26, 0x02	; 2
    3832:	44 23       	and	r20, r20
    3834:	dc f7       	brge	.-10     	; 0x382c <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3836:	13 96       	adiw	r26, 0x03	; 3
    3838:	4c 91       	ld	r20, X
    383a:	13 97       	sbiw	r26, 0x03	; 3
    383c:	48 83       	st	Y, r20
    383e:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3840:	83 30       	cpi	r24, 0x03	; 3
    3842:	91 05       	cpc	r25, r1
    3844:	61 f7       	brne	.-40     	; 0x381e <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3846:	80 e0       	ldi	r24, 0x00	; 0
    3848:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	portExCS(FALSE);
    384c:	80 e0       	ldi	r24, 0x00	; 0
    384e:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>
	SPIDisable();
    3852:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
}
    3856:	df 91       	pop	r29
    3858:	cf 91       	pop	r28
    385a:	08 95       	ret

0000385c <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    385c:	cf 93       	push	r28
    385e:	df 93       	push	r29
    3860:	c8 2f       	mov	r28, r24
    3862:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3864:	80 e0       	ldi	r24, 0x00	; 0
    3866:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    386a:	81 e0       	ldi	r24, 0x01	; 1
    386c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	portExCS(TRUE);
    3870:	81 e0       	ldi	r24, 0x01	; 1
    3872:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    3876:	dd 23       	and	r29, r29
    3878:	89 f0       	breq	.+34     	; 0x389c <PortEx_DIRCLR+0x40>
    387a:	80 91 7a 50 	lds	r24, 0x507A
    387e:	80 95       	com	r24
    3880:	c8 23       	and	r28, r24
    3882:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3886:	80 e4       	ldi	r24, 0x40	; 64
    3888:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    388c:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3890:	80 91 7a 50 	lds	r24, 0x507A
    3894:	80 95       	com	r24
    3896:	80 93 67 50 	sts	0x5067, r24
    389a:	11 c0       	rjmp	.+34     	; 0x38be <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    389c:	80 91 d6 50 	lds	r24, 0x50D6
    38a0:	80 95       	com	r24
    38a2:	c8 23       	and	r28, r24
    38a4:	c0 93 d6 50 	sts	0x50D6, r28
	
	SPIBuffer[0] = PS_WRITE;
    38a8:	80 e4       	ldi	r24, 0x40	; 64
    38aa:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    38ae:	81 e0       	ldi	r24, 0x01	; 1
    38b0:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    38b4:	80 91 d6 50 	lds	r24, 0x50D6
    38b8:	80 95       	com	r24
    38ba:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    38be:	80 e0       	ldi	r24, 0x00	; 0
    38c0:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    38c2:	25 e6       	ldi	r18, 0x65	; 101
    38c4:	30 e5       	ldi	r19, 0x50	; 80
    38c6:	a0 ec       	ldi	r26, 0xC0	; 192
    38c8:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    38ca:	c1 e7       	ldi	r28, 0x71	; 113
    38cc:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    38ce:	f9 01       	movw	r30, r18
    38d0:	e8 0f       	add	r30, r24
    38d2:	f9 1f       	adc	r31, r25
    38d4:	40 81       	ld	r20, Z
    38d6:	13 96       	adiw	r26, 0x03	; 3
    38d8:	4c 93       	st	X, r20
    38da:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    38dc:	12 96       	adiw	r26, 0x02	; 2
    38de:	4c 91       	ld	r20, X
    38e0:	12 97       	sbiw	r26, 0x02	; 2
    38e2:	44 23       	and	r20, r20
    38e4:	dc f7       	brge	.-10     	; 0x38dc <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    38e6:	13 96       	adiw	r26, 0x03	; 3
    38e8:	4c 91       	ld	r20, X
    38ea:	13 97       	sbiw	r26, 0x03	; 3
    38ec:	48 83       	st	Y, r20
    38ee:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    38f0:	83 30       	cpi	r24, 0x03	; 3
    38f2:	91 05       	cpc	r25, r1
    38f4:	61 f7       	brne	.-40     	; 0x38ce <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    38f6:	80 e0       	ldi	r24, 0x00	; 0
    38f8:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	portExCS(FALSE);
    38fc:	80 e0       	ldi	r24, 0x00	; 0
    38fe:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>
	SPIDisable();
    3902:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
}
    3906:	df 91       	pop	r29
    3908:	cf 91       	pop	r28
    390a:	08 95       	ret

0000390c <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    390c:	cf 93       	push	r28
    390e:	df 93       	push	r29
    3910:	c8 2f       	mov	r28, r24
    3912:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3914:	80 e0       	ldi	r24, 0x00	; 0
    3916:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    391a:	81 e0       	ldi	r24, 0x01	; 1
    391c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	portExCS(TRUE);
    3920:	81 e0       	ldi	r24, 0x01	; 1
    3922:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    3926:	dd 23       	and	r29, r29
    3928:	81 f0       	breq	.+32     	; 0x394a <PortEx_DIRSET+0x3e>
    392a:	80 91 7a 50 	lds	r24, 0x507A
    392e:	c8 2b       	or	r28, r24
    3930:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3934:	80 e4       	ldi	r24, 0x40	; 64
    3936:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    393a:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    393e:	80 91 7a 50 	lds	r24, 0x507A
    3942:	80 95       	com	r24
    3944:	80 93 67 50 	sts	0x5067, r24
    3948:	10 c0       	rjmp	.+32     	; 0x396a <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    394a:	80 91 d6 50 	lds	r24, 0x50D6
    394e:	c8 2b       	or	r28, r24
    3950:	c0 93 d6 50 	sts	0x50D6, r28
	
	SPIBuffer[0] = PS_WRITE;
    3954:	80 e4       	ldi	r24, 0x40	; 64
    3956:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    395a:	81 e0       	ldi	r24, 0x01	; 1
    395c:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3960:	80 91 d6 50 	lds	r24, 0x50D6
    3964:	80 95       	com	r24
    3966:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    396a:	80 e0       	ldi	r24, 0x00	; 0
    396c:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    396e:	25 e6       	ldi	r18, 0x65	; 101
    3970:	30 e5       	ldi	r19, 0x50	; 80
    3972:	a0 ec       	ldi	r26, 0xC0	; 192
    3974:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3976:	c1 e7       	ldi	r28, 0x71	; 113
    3978:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    397a:	f9 01       	movw	r30, r18
    397c:	e8 0f       	add	r30, r24
    397e:	f9 1f       	adc	r31, r25
    3980:	40 81       	ld	r20, Z
    3982:	13 96       	adiw	r26, 0x03	; 3
    3984:	4c 93       	st	X, r20
    3986:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    3988:	12 96       	adiw	r26, 0x02	; 2
    398a:	4c 91       	ld	r20, X
    398c:	12 97       	sbiw	r26, 0x02	; 2
    398e:	44 23       	and	r20, r20
    3990:	dc f7       	brge	.-10     	; 0x3988 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3992:	13 96       	adiw	r26, 0x03	; 3
    3994:	4c 91       	ld	r20, X
    3996:	13 97       	sbiw	r26, 0x03	; 3
    3998:	48 83       	st	Y, r20
    399a:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    399c:	83 30       	cpi	r24, 0x03	; 3
    399e:	91 05       	cpc	r25, r1
    39a0:	61 f7       	brne	.-40     	; 0x397a <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    39a2:	80 e0       	ldi	r24, 0x00	; 0
    39a4:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <portExCS>
	SPICS(FALSE);
    39a8:	80 e0       	ldi	r24, 0x00	; 0
    39aa:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    39ae:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>


}
    39b2:	df 91       	pop	r29
    39b4:	cf 91       	pop	r28
    39b6:	08 95       	ret

000039b8 <readFRAM>:

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    39b8:	0f 93       	push	r16
    39ba:	1f 93       	push	r17
    39bc:	cf 93       	push	r28
    39be:	df 93       	push	r29
    39c0:	8c 01       	movw	r16, r24
	
	SPIInit(SPI_MODE_0_gc);
    39c2:	80 e0       	ldi	r24, 0x00	; 0
    39c4:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    39c8:	c0 ec       	ldi	r28, 0xC0	; 192
    39ca:	d8 e0       	ldi	r29, 0x08	; 8
    39cc:	80 ed       	ldi	r24, 0xD0	; 208
    39ce:	88 83       	st	Y, r24
	SPICS(TRUE);
    39d0:	81 e0       	ldi	r24, 0x01	; 1
    39d2:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    39d6:	88 e0       	ldi	r24, 0x08	; 8
    39d8:	e0 e2       	ldi	r30, 0x20	; 32
    39da:	f6 e0       	ldi	r31, 0x06	; 6
    39dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
    39de:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    39e0:	83 e0       	ldi	r24, 0x03	; 3
    39e2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    39e4:	e0 ec       	ldi	r30, 0xC0	; 192
    39e6:	f8 e0       	ldi	r31, 0x08	; 8
    39e8:	82 81       	ldd	r24, Z+2	; 0x02
    39ea:	88 23       	and	r24, r24
    39ec:	ec f7       	brge	.-6      	; 0x39e8 <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    39ee:	e0 ec       	ldi	r30, 0xC0	; 192
    39f0:	f8 e0       	ldi	r31, 0x08	; 8
    39f2:	83 81       	ldd	r24, Z+3	; 0x03
    39f4:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    39f8:	80 91 58 40 	lds	r24, 0x4058
    39fc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    39fe:	82 81       	ldd	r24, Z+2	; 0x02
    3a00:	88 23       	and	r24, r24
    3a02:	ec f7       	brge	.-6      	; 0x39fe <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    3a04:	e0 ec       	ldi	r30, 0xC0	; 192
    3a06:	f8 e0       	ldi	r31, 0x08	; 8
    3a08:	83 81       	ldd	r24, Z+3	; 0x03
    3a0a:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    3a0e:	80 91 57 40 	lds	r24, 0x4057
    3a12:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3a14:	82 81       	ldd	r24, Z+2	; 0x02
    3a16:	88 23       	and	r24, r24
    3a18:	ec f7       	brge	.-6      	; 0x3a14 <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3a1a:	e0 ec       	ldi	r30, 0xC0	; 192
    3a1c:	f8 e0       	ldi	r31, 0x08	; 8
    3a1e:	83 81       	ldd	r24, Z+3	; 0x03
    3a20:	80 93 71 50 	sts	0x5071, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3a24:	01 15       	cp	r16, r1
    3a26:	11 05       	cpc	r17, r1
    3a28:	b1 f0       	breq	.+44     	; 0x3a56 <readFRAM+0x9e>
    3a2a:	ef ed       	ldi	r30, 0xDF	; 223
    3a2c:	f3 e2       	ldi	r31, 0x23	; 35

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3a2e:	0e 0f       	add	r16, r30
    3a30:	1f 1f       	adc	r17, r31
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    3a32:	a0 ec       	ldi	r26, 0xC0	; 192
    3a34:	b8 e0       	ldi	r27, 0x08	; 8
    3a36:	9a ea       	ldi	r25, 0xAA	; 170
    3a38:	13 96       	adiw	r26, 0x03	; 3
    3a3a:	9c 93       	st	X, r25
    3a3c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3a3e:	12 96       	adiw	r26, 0x02	; 2
    3a40:	8c 91       	ld	r24, X
    3a42:	12 97       	sbiw	r26, 0x02	; 2
    3a44:	88 23       	and	r24, r24
    3a46:	dc f7       	brge	.-10     	; 0x3a3e <readFRAM+0x86>
		FRAMReadBuffer[i] = SPIC.DATA;
    3a48:	13 96       	adiw	r26, 0x03	; 3
    3a4a:	8c 91       	ld	r24, X
    3a4c:	13 97       	sbiw	r26, 0x03	; 3
    3a4e:	81 93       	st	Z+, r24
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3a50:	e0 17       	cp	r30, r16
    3a52:	f1 07       	cpc	r31, r17
    3a54:	89 f7       	brne	.-30     	; 0x3a38 <readFRAM+0x80>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    3a56:	88 e0       	ldi	r24, 0x08	; 8
    3a58:	e0 e2       	ldi	r30, 0x20	; 32
    3a5a:	f6 e0       	ldi	r31, 0x06	; 6
    3a5c:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    3a5e:	80 e0       	ldi	r24, 0x00	; 0
    3a60:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    3a64:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>

}
    3a68:	df 91       	pop	r29
    3a6a:	cf 91       	pop	r28
    3a6c:	1f 91       	pop	r17
    3a6e:	0f 91       	pop	r16
    3a70:	08 95       	ret

00003a72 <FRAMTest3Channel>:
//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3a72:	81 e0       	ldi	r24, 0x01	; 1
    3a74:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
    3a78:	8f ec       	ldi	r24, 0xCF	; 207
    3a7a:	97 e0       	ldi	r25, 0x07	; 7
    3a7c:	01 97       	sbiw	r24, 0x01	; 1
    3a7e:	f1 f7       	brne	.-4      	; 0x3a7c <FRAMTest3Channel+0xa>
    3a80:	00 c0       	rjmp	.+0      	; 0x3a82 <FRAMTest3Channel+0x10>
    3a82:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3a84:	0e 94 88 0c 	call	0x1910	; 0x1910 <calcChecksumFRAM>

	ADCPower(FALSE);
    3a88:	80 e0       	ldi	r24, 0x00	; 0
    3a8a:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	
}
    3a8e:	08 95       	ret

00003a90 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3a90:	81 e0       	ldi	r24, 0x01	; 1
    3a92:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
    3a96:	8f ec       	ldi	r24, 0xCF	; 207
    3a98:	97 e0       	ldi	r25, 0x07	; 7
    3a9a:	01 97       	sbiw	r24, 0x01	; 1
    3a9c:	f1 f7       	brne	.-4      	; 0x3a9a <FRAMTest1Channel+0xa>
    3a9e:	00 c0       	rjmp	.+0      	; 0x3aa0 <FRAMTest1Channel+0x10>
    3aa0:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3aa2:	0e 94 88 0c 	call	0x1910	; 0x1910 <calcChecksumFRAM>

	ADCPower(FALSE);
    3aa6:	80 e0       	ldi	r24, 0x00	; 0
    3aa8:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>

}
    3aac:	08 95       	ret

00003aae <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
	
	FRAMWriteKnowns();
    3aae:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <FRAMWriteKnowns>
	ADCPower(TRUE);
    3ab2:	81 e0       	ldi	r24, 0x01	; 1
    3ab4:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
    3ab8:	8f ec       	ldi	r24, 0xCF	; 207
    3aba:	97 e0       	ldi	r25, 0x07	; 7
    3abc:	01 97       	sbiw	r24, 0x01	; 1
    3abe:	f1 f7       	brne	.-4      	; 0x3abc <FRAMWriteKnownsCheck+0xe>
    3ac0:	00 c0       	rjmp	.+0      	; 0x3ac2 <FRAMWriteKnownsCheck+0x14>
    3ac2:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    3ac4:	0e 94 88 0c 	call	0x1910	; 0x1910 <calcChecksumFRAM>

	ADCPower(FALSE);
    3ac8:	80 e0       	ldi	r24, 0x00	; 0
    3aca:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>

}
    3ace:	08 95       	ret

00003ad0 <checkMote>:

//random function for testing stuff	
void checkMote(){
	
	ADCPower(TRUE);
    3ad0:	81 e0       	ldi	r24, 0x01	; 1
    3ad2:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	Ext1Power(TRUE);
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3adc:	8f ef       	ldi	r24, 0xFF	; 255
    3ade:	93 ec       	ldi	r25, 0xC3	; 195
    3ae0:	a9 e0       	ldi	r26, 0x09	; 9
    3ae2:	81 50       	subi	r24, 0x01	; 1
    3ae4:	90 40       	sbci	r25, 0x00	; 0
    3ae6:	a0 40       	sbci	r26, 0x00	; 0
    3ae8:	e1 f7       	brne	.-8      	; 0x3ae2 <checkMote+0x12>
    3aea:	00 c0       	rjmp	.+0      	; 0x3aec <checkMote+0x1c>
    3aec:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3aee:	88 e0       	ldi	r24, 0x08	; 8
    3af0:	60 e0       	ldi	r22, 0x00	; 0
    3af2:	0e 94 86 1c 	call	0x390c	; 0x390c <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3af6:	88 e0       	ldi	r24, 0x08	; 8
    3af8:	60 e0       	ldi	r22, 0x00	; 0
    3afa:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
    3afe:	8a ea       	ldi	r24, 0xAA	; 170
    3b00:	96 ee       	ldi	r25, 0xE6	; 230
    3b02:	a6 e9       	ldi	r26, 0x96	; 150
    3b04:	b1 e0       	ldi	r27, 0x01	; 1
    3b06:	81 50       	subi	r24, 0x01	; 1
    3b08:	90 40       	sbci	r25, 0x00	; 0
    3b0a:	a0 40       	sbci	r26, 0x00	; 0
    3b0c:	b0 40       	sbci	r27, 0x00	; 0
    3b0e:	d9 f7       	brne	.-10     	; 0x3b06 <checkMote+0x36>
    3b10:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3b12:	88 e0       	ldi	r24, 0x08	; 8
    3b14:	60 e0       	ldi	r22, 0x00	; 0
    3b16:	0e 94 82 1b 	call	0x3704	; 0x3704 <PortEx_OUTCLR>
    3b1a:	8a ea       	ldi	r24, 0xAA	; 170
    3b1c:	96 ee       	ldi	r25, 0xE6	; 230
    3b1e:	a6 e9       	ldi	r26, 0x96	; 150
    3b20:	b1 e0       	ldi	r27, 0x01	; 1
    3b22:	81 50       	subi	r24, 0x01	; 1
    3b24:	90 40       	sbci	r25, 0x00	; 0
    3b26:	a0 40       	sbci	r26, 0x00	; 0
    3b28:	b0 40       	sbci	r27, 0x00	; 0
    3b2a:	d9 f7       	brne	.-10     	; 0x3b22 <checkMote+0x52>
    3b2c:	00 00       	nop
    3b2e:	e3 cf       	rjmp	.-58     	; 0x3af6 <checkMote+0x26>

00003b30 <SD_write_and_read_knowns>:
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3b30:	0f 93       	push	r16
    3b32:	1f 93       	push	r17
    3b34:	cf 93       	push	r28
    3b36:	df 93       	push	r29
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3b38:	0f ed       	ldi	r16, 0xDF	; 223
    3b3a:	13 e2       	ldi	r17, 0x23	; 35
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3b3c:	f8 01       	movw	r30, r16
    3b3e:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3b40:	81 93       	st	Z+, r24
    3b42:	8f 5f       	subi	r24, 0xFF	; 255
    3b44:	88 31       	cpi	r24, 0x18	; 24
    3b46:	e1 f7       	brne	.-8      	; 0x3b40 <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    3b48:	cf ed       	ldi	r28, 0xDF	; 223
    3b4a:	d3 e2       	ldi	r29, 0x23	; 35
    3b4c:	64 e1       	ldi	r22, 0x14	; 20
    3b4e:	70 e0       	ldi	r23, 0x00	; 0
    3b50:	80 e0       	ldi	r24, 0x00	; 0
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	ae 01       	movw	r20, r28
    3b56:	28 e1       	ldi	r18, 0x18	; 24
    3b58:	30 e0       	ldi	r19, 0x00	; 0
    3b5a:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_write_block>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3b5e:	68 96       	adiw	r28, 0x18	; 24
    3b60:	f8 01       	movw	r30, r16
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    3b62:	11 92       	st	Z+, r1
    3b64:	ec 17       	cp	r30, r28
    3b66:	fd 07       	cpc	r31, r29
    3b68:	e1 f7       	brne	.-8      	; 0x3b62 <SD_write_and_read_knowns+0x32>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    3b6a:	64 e1       	ldi	r22, 0x14	; 20
    3b6c:	70 e0       	ldi	r23, 0x00	; 0
    3b6e:	80 e0       	ldi	r24, 0x00	; 0
    3b70:	90 e0       	ldi	r25, 0x00	; 0
    3b72:	4f ed       	ldi	r20, 0xDF	; 223
    3b74:	53 e2       	ldi	r21, 0x23	; 35
    3b76:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
    3b7a:	f8 01       	movw	r30, r16
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3b7c:	20 e0       	ldi	r18, 0x00	; 0
    3b7e:	30 e0       	ldi	r19, 0x00	; 0
    3b80:	c4 e6       	ldi	r28, 0x64	; 100
    3b82:	d0 e0       	ldi	r29, 0x00	; 0
    3b84:	c9 01       	movw	r24, r18
    3b86:	be 01       	movw	r22, r28
    3b88:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    3b8c:	81 93       	st	Z+, r24
    3b8e:	2f 5f       	subi	r18, 0xFF	; 255
    3b90:	3f 4f       	sbci	r19, 0xFF	; 255
    3b92:	84 e0       	ldi	r24, 0x04	; 4
    3b94:	22 3e       	cpi	r18, 0xE2	; 226
    3b96:	38 07       	cpc	r19, r24
    3b98:	a9 f7       	brne	.-22     	; 0x3b84 <SD_write_and_read_knowns+0x54>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    3b9a:	60 e5       	ldi	r22, 0x50	; 80
    3b9c:	70 e0       	ldi	r23, 0x00	; 0
    3b9e:	80 e0       	ldi	r24, 0x00	; 0
    3ba0:	90 e0       	ldi	r25, 0x00	; 0
    3ba2:	4f ed       	ldi	r20, 0xDF	; 223
    3ba4:	53 e2       	ldi	r21, 0x23	; 35
    3ba6:	22 ee       	ldi	r18, 0xE2	; 226
    3ba8:	34 e0       	ldi	r19, 0x04	; 4
    3baa:	0e 94 e2 2a 	call	0x55c4	; 0x55c4 <SD_write_multiple_blocks>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3bae:	81 ec       	ldi	r24, 0xC1	; 193
    3bb0:	98 e2       	ldi	r25, 0x28	; 40
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    3bb2:	f8 01       	movw	r30, r16
    3bb4:	11 92       	st	Z+, r1
    3bb6:	8f 01       	movw	r16, r30
    3bb8:	e8 17       	cp	r30, r24
    3bba:	f9 07       	cpc	r31, r25
    3bbc:	d1 f7       	brne	.-12     	; 0x3bb2 <SD_write_and_read_knowns+0x82>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    3bbe:	60 e5       	ldi	r22, 0x50	; 80
    3bc0:	70 e0       	ldi	r23, 0x00	; 0
    3bc2:	80 e0       	ldi	r24, 0x00	; 0
    3bc4:	90 e0       	ldi	r25, 0x00	; 0
    3bc6:	4f ed       	ldi	r20, 0xDF	; 223
    3bc8:	53 e2       	ldi	r21, 0x23	; 35
    3bca:	23 e0       	ldi	r18, 0x03	; 3
    3bcc:	30 e0       	ldi	r19, 0x00	; 0
    3bce:	0e 94 3c 2c 	call	0x5878	; 0x5878 <SD_read_multiple_blocks>
}
    3bd2:	df 91       	pop	r29
    3bd4:	cf 91       	pop	r28
    3bd6:	1f 91       	pop	r17
    3bd8:	0f 91       	pop	r16
    3bda:	08 95       	ret

00003bdc <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    3bdc:	0f 93       	push	r16
    3bde:	1f 93       	push	r17
    3be0:	cf 93       	push	r28
    3be2:	df 93       	push	r29
    3be4:	0f ed       	ldi	r16, 0xDF	; 223
    3be6:	13 e2       	ldi	r17, 0x23	; 35
    3be8:	f8 01       	movw	r30, r16
    3bea:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3bec:	81 93       	st	Z+, r24
    3bee:	8f 5f       	subi	r24, 0xFF	; 255
    3bf0:	88 31       	cpi	r24, 0x18	; 24
    3bf2:	e1 f7       	brne	.-8      	; 0x3bec <SD_write_and_read_knowns_FAT+0x10>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    3bf4:	cf ed       	ldi	r28, 0xDF	; 223
    3bf6:	d3 e2       	ldi	r29, 0x23	; 35
    3bf8:	86 e1       	ldi	r24, 0x16	; 22
    3bfa:	90 e2       	ldi	r25, 0x20	; 32
    3bfc:	be 01       	movw	r22, r28
    3bfe:	20 e0       	ldi	r18, 0x00	; 0
    3c00:	32 e0       	ldi	r19, 0x02	; 2
    3c02:	40 e0       	ldi	r20, 0x00	; 0
    3c04:	50 e0       	ldi	r21, 0x00	; 0
    3c06:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <writeFile>
    3c0a:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
}

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    3c0e:	68 96       	adiw	r28, 0x18	; 24
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    3c10:	f8 01       	movw	r30, r16
    3c12:	11 92       	st	Z+, r1
    3c14:	8f 01       	movw	r16, r30
    3c16:	ec 17       	cp	r30, r28
    3c18:	fd 07       	cpc	r31, r29
    3c1a:	d1 f7       	brne	.-12     	; 0x3c10 <SD_write_and_read_knowns_FAT+0x34>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    3c1c:	80 e0       	ldi	r24, 0x00	; 0
    3c1e:	66 e1       	ldi	r22, 0x16	; 22
    3c20:	70 e2       	ldi	r23, 0x20	; 32
    3c22:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <readFile>
    3c26:	80 93 a3 50 	sts	0x50A3, r24
}
    3c2a:	df 91       	pop	r29
    3c2c:	cf 91       	pop	r28
    3c2e:	1f 91       	pop	r17
    3c30:	0f 91       	pop	r16
    3c32:	08 95       	ret

00003c34 <chibi_test_radio>:


//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    3c34:	0e 94 e6 13 	call	0x27cc	; 0x27cc <chb_init>
	chb_set_short_addr(0x0002);
    3c38:	82 e0       	ldi	r24, 0x02	; 2
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    3c40:	00 00       	nop
    3c42:	fe cf       	rjmp	.-4      	; 0x3c40 <chibi_test_radio+0xc>

00003c44 <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    3c44:	cf 93       	push	r28
    3c46:	df 93       	push	r29
	
	SD_init();
    3c48:	0e 94 ec 28 	call	0x51d8	; 0x51d8 <SD_init>
	getBootSectorData();
    3c4c:	0e 94 cc 20 	call	0x4198	; 0x4198 <getBootSectorData>
    3c50:	ef ed       	ldi	r30, 0xDF	; 223
    3c52:	f3 e2       	ldi	r31, 0x23	; 35
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    3c54:	20 e0       	ldi	r18, 0x00	; 0
    3c56:	30 e0       	ldi	r19, 0x00	; 0
    3c58:	c9 e7       	ldi	r28, 0x79	; 121
    3c5a:	d0 e0       	ldi	r29, 0x00	; 0
    3c5c:	c9 01       	movw	r24, r18
    3c5e:	be 01       	movw	r22, r28
    3c60:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    3c64:	81 93       	st	Z+, r24
    3c66:	2f 5f       	subi	r18, 0xFF	; 255
    3c68:	3f 4f       	sbci	r19, 0xFF	; 255
    3c6a:	82 e0       	ldi	r24, 0x02	; 2
    3c6c:	20 30       	cpi	r18, 0x00	; 0
    3c6e:	38 07       	cpc	r19, r24
    3c70:	a9 f7       	brne	.-22     	; 0x3c5c <TestCard+0x18>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    3c72:	86 e1       	ldi	r24, 0x16	; 22
    3c74:	90 e2       	ldi	r25, 0x20	; 32
    3c76:	6f ed       	ldi	r22, 0xDF	; 223
    3c78:	73 e2       	ldi	r23, 0x23	; 35
    3c7a:	20 e0       	ldi	r18, 0x00	; 0
    3c7c:	32 e0       	ldi	r19, 0x02	; 2
    3c7e:	40 e0       	ldi	r20, 0x00	; 0
    3c80:	50 e0       	ldi	r21, 0x00	; 0
    3c82:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <writeFile>
	nop();
    3c86:	00 00       	nop
}
    3c88:	df 91       	pop	r29
    3c8a:	cf 91       	pop	r28
    3c8c:	08 95       	ret

00003c8e <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    3c8e:	1f 92       	push	r1
    3c90:	0f 92       	push	r0
    3c92:	0f b6       	in	r0, 0x3f	; 63
    3c94:	0f 92       	push	r0
    3c96:	0b b6       	in	r0, 0x3b	; 59
    3c98:	0f 92       	push	r0
    3c9a:	11 24       	eor	r1, r1
    3c9c:	2f 93       	push	r18
    3c9e:	3f 93       	push	r19
    3ca0:	4f 93       	push	r20
    3ca2:	5f 93       	push	r21
    3ca4:	6f 93       	push	r22
    3ca6:	7f 93       	push	r23
    3ca8:	8f 93       	push	r24
    3caa:	9f 93       	push	r25
    3cac:	af 93       	push	r26
    3cae:	bf 93       	push	r27
    3cb0:	ef 93       	push	r30
    3cb2:	ff 93       	push	r31
	
	chb_rx_data_t* msg = NULL;
	switch (RadioMonitorMode) {
    3cb4:	80 91 5e 40 	lds	r24, 0x405E
    3cb8:	81 30       	cpi	r24, 0x01	; 1
    3cba:	21 f0       	breq	.+8      	; 0x3cc4 <__vector_43+0x36>
    3cbc:	82 30       	cpi	r24, 0x02	; 2
    3cbe:	09 f0       	breq	.+2      	; 0x3cc2 <__vector_43+0x34>
    3cc0:	72 c0       	rjmp	.+228    	; 0x3da6 <__vector_43+0x118>
    3cc2:	55 c0       	rjmp	.+170    	; 0x3d6e <__vector_43+0xe0>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    3cc4:	80 e0       	ldi	r24, 0x00	; 0
    3cc6:	90 e0       	ldi	r25, 0x00	; 0
    3cc8:	0e 94 be 14 	call	0x297c	; 0x297c <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    3ccc:	85 e0       	ldi	r24, 0x05	; 5
    3cce:	90 e0       	ldi	r25, 0x00	; 0
    3cd0:	6e e1       	ldi	r22, 0x1E	; 30
    3cd2:	70 e2       	ldi	r23, 0x20	; 32
    3cd4:	45 e0       	ldi	r20, 0x05	; 5
    3cd6:	50 e0       	ldi	r21, 0x00	; 0
    3cd8:	0e 94 91 38 	call	0x7122	; 0x7122 <strncmp>
    3cdc:	28 2f       	mov	r18, r24
    3cde:	39 2f       	mov	r19, r25
    3ce0:	21 15       	cp	r18, r1
    3ce2:	31 05       	cpc	r19, r1
    3ce4:	51 f4       	brne	.+20     	; 0x3cfa <__vector_43+0x6c>
				MotesReadyToSynch++;
    3ce6:	80 91 78 50 	lds	r24, 0x5078
    3cea:	90 91 79 50 	lds	r25, 0x5079
    3cee:	01 96       	adiw	r24, 0x01	; 1
    3cf0:	80 93 78 50 	sts	0x5078, r24
    3cf4:	90 93 79 50 	sts	0x5079, r25
    3cf8:	56 c0       	rjmp	.+172    	; 0x3da6 <__vector_43+0x118>
    3cfa:	e5 e0       	ldi	r30, 0x05	; 5
    3cfc:	f0 e0       	ldi	r31, 0x00	; 0
    3cfe:	af ed       	ldi	r26, 0xDF	; 223
    3d00:	b3 e2       	ldi	r27, 0x23	; 35
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    3d02:	81 91       	ld	r24, Z+
    3d04:	8d 93       	st	X+, r24
    3d06:	e5 38       	cpi	r30, 0x85	; 133
    3d08:	f1 05       	cpc	r31, r1
    3d0a:	d9 f7       	brne	.-10     	; 0x3d02 <__vector_43+0x74>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    3d0c:	80 91 ca 50 	lds	r24, 0x50CA
    3d10:	90 91 cb 50 	lds	r25, 0x50CB
    3d14:	a0 91 cc 50 	lds	r26, 0x50CC
    3d18:	b0 91 cd 50 	lds	r27, 0x50CD
    3d1c:	80 58       	subi	r24, 0x80	; 128
    3d1e:	9f 4f       	sbci	r25, 0xFF	; 255
    3d20:	af 4f       	sbci	r26, 0xFF	; 255
    3d22:	bf 4f       	sbci	r27, 0xFF	; 255
    3d24:	80 93 ca 50 	sts	0x50CA, r24
    3d28:	90 93 cb 50 	sts	0x50CB, r25
    3d2c:	a0 93 cc 50 	sts	0x50CC, r26
    3d30:	b0 93 cd 50 	sts	0x50CD, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    3d34:	80 91 ca 50 	lds	r24, 0x50CA
    3d38:	90 91 cb 50 	lds	r25, 0x50CB
    3d3c:	a0 91 cc 50 	lds	r26, 0x50CC
    3d40:	b0 91 cd 50 	lds	r27, 0x50CD
    3d44:	80 58       	subi	r24, 0x80	; 128
    3d46:	9f 4f       	sbci	r25, 0xFF	; 255
    3d48:	af 4f       	sbci	r26, 0xFF	; 255
    3d4a:	bf 4f       	sbci	r27, 0xFF	; 255
    3d4c:	81 37       	cpi	r24, 0x71	; 113
    3d4e:	2c e1       	ldi	r18, 0x1C	; 28
    3d50:	92 07       	cpc	r25, r18
    3d52:	20 e0       	ldi	r18, 0x00	; 0
    3d54:	a2 07       	cpc	r26, r18
    3d56:	20 e0       	ldi	r18, 0x00	; 0
    3d58:	b2 07       	cpc	r27, r18
    3d5a:	28 f1       	brcs	.+74     	; 0x3da6 <__vector_43+0x118>
    3d5c:	10 92 ca 50 	sts	0x50CA, r1
    3d60:	10 92 cb 50 	sts	0x50CB, r1
    3d64:	10 92 cc 50 	sts	0x50CC, r1
    3d68:	10 92 cd 50 	sts	0x50CD, r1
    3d6c:	1c c0       	rjmp	.+56     	; 0x3da6 <__vector_43+0x118>
			}			
			break;
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    3d6e:	80 e0       	ldi	r24, 0x00	; 0
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	0e 94 be 14 	call	0x297c	; 0x297c <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    3d76:	85 e0       	ldi	r24, 0x05	; 5
    3d78:	90 e0       	ldi	r25, 0x00	; 0
    3d7a:	64 e2       	ldi	r22, 0x24	; 36
    3d7c:	70 e2       	ldi	r23, 0x20	; 32
    3d7e:	4e e0       	ldi	r20, 0x0E	; 14
    3d80:	50 e0       	ldi	r21, 0x00	; 0
    3d82:	0e 94 91 38 	call	0x7122	; 0x7122 <strncmp>
    3d86:	28 2f       	mov	r18, r24
    3d88:	39 2f       	mov	r19, r25
    3d8a:	21 15       	cp	r18, r1
    3d8c:	31 05       	cpc	r19, r1
    3d8e:	59 f4       	brne	.+22     	; 0x3da6 <__vector_43+0x118>
				RadioMonitorMode = SYNCHED;
    3d90:	83 e0       	ldi	r24, 0x03	; 3
    3d92:	80 93 5e 40 	sts	0x405E, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    3d96:	89 e0       	ldi	r24, 0x09	; 9
    3d98:	80 93 40 09 	sts	0x0940, r24
				TCC1.CTRLA = 0x01;  
    3d9c:	81 e0       	ldi	r24, 0x01	; 1
    3d9e:	80 93 40 08 	sts	0x0840, r24
				ADC_Resume_Sampling();	//resume sampling with the adc
    3da2:	0e 94 56 07 	call	0xeac	; 0xeac <ADC_Resume_Sampling>
			}
			break;
		default:
			break;
	}
}
    3da6:	ff 91       	pop	r31
    3da8:	ef 91       	pop	r30
    3daa:	bf 91       	pop	r27
    3dac:	af 91       	pop	r26
    3dae:	9f 91       	pop	r25
    3db0:	8f 91       	pop	r24
    3db2:	7f 91       	pop	r23
    3db4:	6f 91       	pop	r22
    3db6:	5f 91       	pop	r21
    3db8:	4f 91       	pop	r20
    3dba:	3f 91       	pop	r19
    3dbc:	2f 91       	pop	r18
    3dbe:	0f 90       	pop	r0
    3dc0:	0b be       	out	0x3b, r0	; 59
    3dc2:	0f 90       	pop	r0
    3dc4:	0f be       	out	0x3f, r0	; 63
    3dc6:	0f 90       	pop	r0
    3dc8:	1f 90       	pop	r1
    3dca:	18 95       	reti

00003dcc <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    3dcc:	2f 92       	push	r2
    3dce:	3f 92       	push	r3
    3dd0:	4f 92       	push	r4
    3dd2:	5f 92       	push	r5
    3dd4:	6f 92       	push	r6
    3dd6:	7f 92       	push	r7
    3dd8:	8f 92       	push	r8
    3dda:	9f 92       	push	r9
    3ddc:	af 92       	push	r10
    3dde:	bf 92       	push	r11
    3de0:	cf 92       	push	r12
    3de2:	df 92       	push	r13
    3de4:	ef 92       	push	r14
    3de6:	ff 92       	push	r15
    3de8:	0f 93       	push	r16
    3dea:	1f 93       	push	r17
    3dec:	cf 93       	push	r28
    3dee:	df 93       	push	r29
    3df0:	cd b7       	in	r28, 0x3d	; 61
    3df2:	de b7       	in	r29, 0x3e	; 62
    3df4:	64 97       	sbiw	r28, 0x14	; 20
    3df6:	cd bf       	out	0x3d, r28	; 61
    3df8:	de bf       	out	0x3e, r29	; 62
    3dfa:	2a 01       	movw	r4, r20
    3dfc:	3b 01       	movw	r6, r22
    3dfe:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    3e00:	f9 01       	movw	r30, r18
    3e02:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    3e04:	41 15       	cp	r20, r1
    3e06:	51 05       	cpc	r21, r1
    3e08:	61 05       	cpc	r22, r1
    3e0a:	71 05       	cpc	r23, r1
    3e0c:	09 f4       	brne	.+2      	; 0x3e10 <DeciToString+0x44>
    3e0e:	4d c0       	rjmp	.+154    	; 0x3eaa <DeciToString+0xde>
    3e10:	88 2e       	mov	r8, r24
    3e12:	99 2e       	mov	r9, r25
    3e14:	cc 24       	eor	r12, r12
    3e16:	dd 24       	eor	r13, r13
    3e18:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    3e1a:	5e 01       	movw	r10, r28
    3e1c:	08 94       	sec
    3e1e:	a1 1c       	adc	r10, r1
    3e20:	b1 1c       	adc	r11, r1
    3e22:	0f 2e       	mov	r0, r31
    3e24:	f3 e3       	ldi	r31, 0x33	; 51
    3e26:	2f 2e       	mov	r2, r31
    3e28:	f0 e2       	ldi	r31, 0x20	; 32
    3e2a:	3f 2e       	mov	r3, r31
    3e2c:	f0 2d       	mov	r31, r0
    3e2e:	f4 01       	movw	r30, r8
    3e30:	81 91       	ld	r24, Z+
    3e32:	91 91       	ld	r25, Z+
    3e34:	a1 91       	ld	r26, Z+
    3e36:	b1 91       	ld	r27, Z+
    3e38:	4f 01       	movw	r8, r30
    3e3a:	2d b7       	in	r18, 0x3d	; 61
    3e3c:	3e b7       	in	r19, 0x3e	; 62
    3e3e:	28 50       	subi	r18, 0x08	; 8
    3e40:	30 40       	sbci	r19, 0x00	; 0
    3e42:	2d bf       	out	0x3d, r18	; 61
    3e44:	3e bf       	out	0x3e, r19	; 62
    3e46:	2f 5f       	subi	r18, 0xFF	; 255
    3e48:	3f 4f       	sbci	r19, 0xFF	; 255
    3e4a:	ed b7       	in	r30, 0x3d	; 61
    3e4c:	fe b7       	in	r31, 0x3e	; 62
    3e4e:	a1 82       	std	Z+1, r10	; 0x01
    3e50:	b2 82       	std	Z+2, r11	; 0x02
    3e52:	f9 01       	movw	r30, r18
    3e54:	22 82       	std	Z+2, r2	; 0x02
    3e56:	33 82       	std	Z+3, r3	; 0x03
    3e58:	84 83       	std	Z+4, r24	; 0x04
    3e5a:	95 83       	std	Z+5, r25	; 0x05
    3e5c:	a6 83       	std	Z+6, r26	; 0x06
    3e5e:	b7 83       	std	Z+7, r27	; 0x07
    3e60:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <sprintf>
		strcat(ReturnString,b);
    3e64:	2d b7       	in	r18, 0x3d	; 61
    3e66:	3e b7       	in	r19, 0x3e	; 62
    3e68:	28 5f       	subi	r18, 0xF8	; 248
    3e6a:	3f 4f       	sbci	r19, 0xFF	; 255
    3e6c:	2d bf       	out	0x3d, r18	; 61
    3e6e:	3e bf       	out	0x3e, r19	; 62
    3e70:	c8 01       	movw	r24, r16
    3e72:	b5 01       	movw	r22, r10
    3e74:	0e 94 86 38 	call	0x710c	; 0x710c <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    3e78:	a0 2f       	mov	r26, r16
    3e7a:	b1 2f       	mov	r27, r17
    3e7c:	fd 01       	movw	r30, r26
    3e7e:	01 90       	ld	r0, Z+
    3e80:	00 20       	and	r0, r0
    3e82:	e9 f7       	brne	.-6      	; 0x3e7e <DeciToString+0xb2>
    3e84:	31 97       	sbiw	r30, 0x01	; 1
    3e86:	ea 1b       	sub	r30, r26
    3e88:	fb 0b       	sbc	r31, r27
    3e8a:	e0 0f       	add	r30, r16
    3e8c:	f1 1f       	adc	r31, r17
    3e8e:	8a e0       	ldi	r24, 0x0A	; 10
    3e90:	90 e0       	ldi	r25, 0x00	; 0
    3e92:	80 83       	st	Z, r24
    3e94:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    3e96:	08 94       	sec
    3e98:	c1 1c       	adc	r12, r1
    3e9a:	d1 1c       	adc	r13, r1
    3e9c:	e1 1c       	adc	r14, r1
    3e9e:	f1 1c       	adc	r15, r1
    3ea0:	c4 14       	cp	r12, r4
    3ea2:	d5 04       	cpc	r13, r5
    3ea4:	e6 04       	cpc	r14, r6
    3ea6:	f7 04       	cpc	r15, r7
    3ea8:	11 f6       	brne	.-124    	; 0x3e2e <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    3eaa:	64 96       	adiw	r28, 0x14	; 20
    3eac:	cd bf       	out	0x3d, r28	; 61
    3eae:	de bf       	out	0x3e, r29	; 62
    3eb0:	df 91       	pop	r29
    3eb2:	cf 91       	pop	r28
    3eb4:	1f 91       	pop	r17
    3eb6:	0f 91       	pop	r16
    3eb8:	ff 90       	pop	r15
    3eba:	ef 90       	pop	r14
    3ebc:	df 90       	pop	r13
    3ebe:	cf 90       	pop	r12
    3ec0:	bf 90       	pop	r11
    3ec2:	af 90       	pop	r10
    3ec4:	9f 90       	pop	r9
    3ec6:	8f 90       	pop	r8
    3ec8:	7f 90       	pop	r7
    3eca:	6f 90       	pop	r6
    3ecc:	5f 90       	pop	r5
    3ece:	4f 90       	pop	r4
    3ed0:	3f 90       	pop	r3
    3ed2:	2f 90       	pop	r2
    3ed4:	08 95       	ret

00003ed6 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    3ed6:	cf 92       	push	r12
    3ed8:	df 92       	push	r13
    3eda:	ef 92       	push	r14
    3edc:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3ede:	20 91 7b 50 	lds	r18, 0x507B
    3ee2:	30 91 7c 50 	lds	r19, 0x507C
    3ee6:	c0 90 db 23 	lds	r12, 0x23DB
    3eea:	d0 90 dc 23 	lds	r13, 0x23DC
    3eee:	e0 90 dd 23 	lds	r14, 0x23DD
    3ef2:	f0 90 de 23 	lds	r15, 0x23DE
    3ef6:	62 50       	subi	r22, 0x02	; 2
    3ef8:	70 40       	sbci	r23, 0x00	; 0
    3efa:	80 40       	sbci	r24, 0x00	; 0
    3efc:	90 40       	sbci	r25, 0x00	; 0
    3efe:	40 e0       	ldi	r20, 0x00	; 0
    3f00:	50 e0       	ldi	r21, 0x00	; 0
    3f02:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    3f06:	dc 01       	movw	r26, r24
    3f08:	cb 01       	movw	r24, r22
    3f0a:	c8 0e       	add	r12, r24
    3f0c:	d9 1e       	adc	r13, r25
    3f0e:	ea 1e       	adc	r14, r26
    3f10:	fb 1e       	adc	r15, r27
}
    3f12:	6c 2d       	mov	r22, r12
    3f14:	7d 2d       	mov	r23, r13
    3f16:	8e 2d       	mov	r24, r14
    3f18:	9f 2d       	mov	r25, r15
    3f1a:	ff 90       	pop	r15
    3f1c:	ef 90       	pop	r14
    3f1e:	df 90       	pop	r13
    3f20:	cf 90       	pop	r12
    3f22:	08 95       	ret

00003f24 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    3f24:	3f 92       	push	r3
    3f26:	4f 92       	push	r4
    3f28:	5f 92       	push	r5
    3f2a:	6f 92       	push	r6
    3f2c:	7f 92       	push	r7
    3f2e:	8f 92       	push	r8
    3f30:	9f 92       	push	r9
    3f32:	af 92       	push	r10
    3f34:	bf 92       	push	r11
    3f36:	cf 92       	push	r12
    3f38:	df 92       	push	r13
    3f3a:	ef 92       	push	r14
    3f3c:	ff 92       	push	r15
    3f3e:	0f 93       	push	r16
    3f40:	1f 93       	push	r17
    3f42:	cf 93       	push	r28
    3f44:	df 93       	push	r29
    3f46:	00 d0       	rcall	.+0      	; 0x3f48 <getSetNextCluster+0x24>
    3f48:	0f 92       	push	r0
    3f4a:	cd b7       	in	r28, 0x3d	; 61
    3f4c:	de b7       	in	r29, 0x3e	; 62
    3f4e:	dc 01       	movw	r26, r24
    3f50:	cb 01       	movw	r24, r22
    3f52:	34 2e       	mov	r3, r20
    3f54:	09 83       	std	Y+1, r16	; 0x01
    3f56:	1a 83       	std	Y+2, r17	; 0x02
    3f58:	2b 83       	std	Y+3, r18	; 0x03
    3f5a:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    3f5c:	80 90 83 50 	lds	r8, 0x5083
    3f60:	90 90 84 50 	lds	r9, 0x5084
    3f64:	2c 01       	movw	r4, r24
    3f66:	3d 01       	movw	r6, r26
    3f68:	44 0c       	add	r4, r4
    3f6a:	55 1c       	adc	r5, r5
    3f6c:	66 1c       	adc	r6, r6
    3f6e:	77 1c       	adc	r7, r7
    3f70:	44 0c       	add	r4, r4
    3f72:	55 1c       	adc	r5, r5
    3f74:	66 1c       	adc	r6, r6
    3f76:	77 1c       	adc	r7, r7
    3f78:	20 91 54 40 	lds	r18, 0x4054
    3f7c:	30 91 55 40 	lds	r19, 0x4055
    3f80:	aa 24       	eor	r10, r10
    3f82:	bb 24       	eor	r11, r11
    3f84:	80 91 7d 50 	lds	r24, 0x507D
    3f88:	90 91 7e 50 	lds	r25, 0x507E
    3f8c:	a0 91 7f 50 	lds	r26, 0x507F
    3f90:	b0 91 80 50 	lds	r27, 0x5080
    3f94:	88 0e       	add	r8, r24
    3f96:	99 1e       	adc	r9, r25
    3f98:	aa 1e       	adc	r10, r26
    3f9a:	bb 1e       	adc	r11, r27
    3f9c:	40 e0       	ldi	r20, 0x00	; 0
    3f9e:	50 e0       	ldi	r21, 0x00	; 0
    3fa0:	c3 01       	movw	r24, r6
    3fa2:	b2 01       	movw	r22, r4
    3fa4:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    3fa8:	69 01       	movw	r12, r18
    3faa:	7a 01       	movw	r14, r20
    3fac:	c8 0c       	add	r12, r8
    3fae:	d9 1c       	adc	r13, r9
    3fb0:	ea 1c       	adc	r14, r10
    3fb2:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3fb4:	00 91 54 40 	lds	r16, 0x4054
    3fb8:	10 91 55 40 	lds	r17, 0x4055

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    3fbc:	c7 01       	movw	r24, r14
    3fbe:	b6 01       	movw	r22, r12
    3fc0:	46 ed       	ldi	r20, 0xD6	; 214
    3fc2:	51 e2       	ldi	r21, 0x21	; 33
    3fc4:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3fc8:	98 01       	movw	r18, r16
    3fca:	40 e0       	ldi	r20, 0x00	; 0
    3fcc:	50 e0       	ldi	r21, 0x00	; 0
    3fce:	c3 01       	movw	r24, r6
    3fd0:	b2 01       	movw	r22, r4
    3fd2:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    3fd6:	6a 52       	subi	r22, 0x2A	; 42
    3fd8:	7e 4d       	sbci	r23, 0xDE	; 222

if(get_set == GET)
    3fda:	33 20       	and	r3, r3
    3fdc:	41 f4       	brne	.+16     	; 0x3fee <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    3fde:	db 01       	movw	r26, r22
    3fe0:	0d 91       	ld	r16, X+
    3fe2:	1d 91       	ld	r17, X+
    3fe4:	2d 91       	ld	r18, X+
    3fe6:	3c 91       	ld	r19, X
    3fe8:	13 97       	sbiw	r26, 0x03	; 3
    3fea:	3f 70       	andi	r19, 0x0F	; 15
    3fec:	14 c0       	rjmp	.+40     	; 0x4016 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    3fee:	89 81       	ldd	r24, Y+1	; 0x01
    3ff0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff2:	ab 81       	ldd	r26, Y+3	; 0x03
    3ff4:	bc 81       	ldd	r27, Y+4	; 0x04
    3ff6:	fb 01       	movw	r30, r22
    3ff8:	80 83       	st	Z, r24
    3ffa:	91 83       	std	Z+1, r25	; 0x01
    3ffc:	a2 83       	std	Z+2, r26	; 0x02
    3ffe:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    4000:	c7 01       	movw	r24, r14
    4002:	b6 01       	movw	r22, r12
    4004:	46 ed       	ldi	r20, 0xD6	; 214
    4006:	51 e2       	ldi	r21, 0x21	; 33
    4008:	20 e0       	ldi	r18, 0x00	; 0
    400a:	32 e0       	ldi	r19, 0x02	; 2
    400c:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_write_block>

return (0);
    4010:	00 e0       	ldi	r16, 0x00	; 0
    4012:	10 e0       	ldi	r17, 0x00	; 0
    4014:	98 01       	movw	r18, r16
}
    4016:	60 2f       	mov	r22, r16
    4018:	71 2f       	mov	r23, r17
    401a:	82 2f       	mov	r24, r18
    401c:	93 2f       	mov	r25, r19
    401e:	24 96       	adiw	r28, 0x04	; 4
    4020:	cd bf       	out	0x3d, r28	; 61
    4022:	de bf       	out	0x3e, r29	; 62
    4024:	df 91       	pop	r29
    4026:	cf 91       	pop	r28
    4028:	1f 91       	pop	r17
    402a:	0f 91       	pop	r16
    402c:	ff 90       	pop	r15
    402e:	ef 90       	pop	r14
    4030:	df 90       	pop	r13
    4032:	cf 90       	pop	r12
    4034:	bf 90       	pop	r11
    4036:	af 90       	pop	r10
    4038:	9f 90       	pop	r9
    403a:	8f 90       	pop	r8
    403c:	7f 90       	pop	r7
    403e:	6f 90       	pop	r6
    4040:	5f 90       	pop	r5
    4042:	4f 90       	pop	r4
    4044:	3f 90       	pop	r3
    4046:	08 95       	ret

00004048 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    4048:	cf 92       	push	r12
    404a:	df 92       	push	r13
    404c:	ef 92       	push	r14
    404e:	ff 92       	push	r15
    4050:	0f 93       	push	r16
    4052:	1f 93       	push	r17
    4054:	cf 93       	push	r28
    4056:	c8 2f       	mov	r28, r24
    4058:	06 2f       	mov	r16, r22
    405a:	69 01       	movw	r12, r18
    405c:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    405e:	80 91 7d 50 	lds	r24, 0x507D
    4062:	90 91 7e 50 	lds	r25, 0x507E
    4066:	a0 91 7f 50 	lds	r26, 0x507F
    406a:	b0 91 80 50 	lds	r27, 0x5080
    406e:	bc 01       	movw	r22, r24
    4070:	cd 01       	movw	r24, r26
    4072:	6f 5f       	subi	r22, 0xFF	; 255
    4074:	7f 4f       	sbci	r23, 0xFF	; 255
    4076:	8f 4f       	sbci	r24, 0xFF	; 255
    4078:	9f 4f       	sbci	r25, 0xFF	; 255
    407a:	46 ed       	ldi	r20, 0xD6	; 214
    407c:	51 e2       	ldi	r21, 0x21	; 33
    407e:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    4082:	80 91 d6 21 	lds	r24, 0x21D6
    4086:	90 91 d7 21 	lds	r25, 0x21D7
    408a:	a0 91 d8 21 	lds	r26, 0x21D8
    408e:	b0 91 d9 21 	lds	r27, 0x21D9
    4092:	82 35       	cpi	r24, 0x52	; 82
    4094:	22 e5       	ldi	r18, 0x52	; 82
    4096:	92 07       	cpc	r25, r18
    4098:	21 e6       	ldi	r18, 0x61	; 97
    409a:	a2 07       	cpc	r26, r18
    409c:	21 e4       	ldi	r18, 0x41	; 65
    409e:	b2 07       	cpc	r27, r18
    40a0:	09 f0       	breq	.+2      	; 0x40a4 <getSetFreeCluster+0x5c>
    40a2:	63 c0       	rjmp	.+198    	; 0x416a <getSetFreeCluster+0x122>
    40a4:	80 91 ba 23 	lds	r24, 0x23BA
    40a8:	90 91 bb 23 	lds	r25, 0x23BB
    40ac:	a0 91 bc 23 	lds	r26, 0x23BC
    40b0:	b0 91 bd 23 	lds	r27, 0x23BD
    40b4:	82 37       	cpi	r24, 0x72	; 114
    40b6:	22 e7       	ldi	r18, 0x72	; 114
    40b8:	92 07       	cpc	r25, r18
    40ba:	21 e4       	ldi	r18, 0x41	; 65
    40bc:	a2 07       	cpc	r26, r18
    40be:	21 e6       	ldi	r18, 0x61	; 97
    40c0:	b2 07       	cpc	r27, r18
    40c2:	09 f0       	breq	.+2      	; 0x40c6 <getSetFreeCluster+0x7e>
    40c4:	56 c0       	rjmp	.+172    	; 0x4172 <getSetFreeCluster+0x12a>
    40c6:	80 91 d2 23 	lds	r24, 0x23D2
    40ca:	90 91 d3 23 	lds	r25, 0x23D3
    40ce:	a0 91 d4 23 	lds	r26, 0x23D4
    40d2:	b0 91 d5 23 	lds	r27, 0x23D5
    40d6:	80 30       	cpi	r24, 0x00	; 0
    40d8:	20 e0       	ldi	r18, 0x00	; 0
    40da:	92 07       	cpc	r25, r18
    40dc:	25 e5       	ldi	r18, 0x55	; 85
    40de:	a2 07       	cpc	r26, r18
    40e0:	2a ea       	ldi	r18, 0xAA	; 170
    40e2:	b2 07       	cpc	r27, r18
    40e4:	09 f0       	breq	.+2      	; 0x40e8 <getSetFreeCluster+0xa0>
    40e6:	49 c0       	rjmp	.+146    	; 0x417a <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    40e8:	00 23       	and	r16, r16
    40ea:	a1 f4       	brne	.+40     	; 0x4114 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    40ec:	c1 30       	cpi	r28, 0x01	; 1
    40ee:	49 f4       	brne	.+18     	; 0x4102 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    40f0:	00 91 be 23 	lds	r16, 0x23BE
    40f4:	10 91 bf 23 	lds	r17, 0x23BF
    40f8:	20 91 c0 23 	lds	r18, 0x23C0
    40fc:	30 91 c1 23 	lds	r19, 0x23C1
    4100:	3f c0       	rjmp	.+126    	; 0x4180 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    4102:	00 91 c2 23 	lds	r16, 0x23C2
    4106:	10 91 c3 23 	lds	r17, 0x23C3
    410a:	20 91 c4 23 	lds	r18, 0x23C4
    410e:	30 91 c5 23 	lds	r19, 0x23C5
    4112:	36 c0       	rjmp	.+108    	; 0x4180 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4114:	c1 30       	cpi	r28, 0x01	; 1
    4116:	49 f4       	brne	.+18     	; 0x412a <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    4118:	c0 92 be 23 	sts	0x23BE, r12
    411c:	d0 92 bf 23 	sts	0x23BF, r13
    4120:	e0 92 c0 23 	sts	0x23C0, r14
    4124:	f0 92 c1 23 	sts	0x23C1, r15
    4128:	08 c0       	rjmp	.+16     	; 0x413a <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    412a:	c0 92 c2 23 	sts	0x23C2, r12
    412e:	d0 92 c3 23 	sts	0x23C3, r13
    4132:	e0 92 c4 23 	sts	0x23C4, r14
    4136:	f0 92 c5 23 	sts	0x23C5, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    413a:	80 91 7d 50 	lds	r24, 0x507D
    413e:	90 91 7e 50 	lds	r25, 0x507E
    4142:	a0 91 7f 50 	lds	r26, 0x507F
    4146:	b0 91 80 50 	lds	r27, 0x5080
    414a:	bc 01       	movw	r22, r24
    414c:	cd 01       	movw	r24, r26
    414e:	6f 5f       	subi	r22, 0xFF	; 255
    4150:	7f 4f       	sbci	r23, 0xFF	; 255
    4152:	8f 4f       	sbci	r24, 0xFF	; 255
    4154:	9f 4f       	sbci	r25, 0xFF	; 255
    4156:	46 ed       	ldi	r20, 0xD6	; 214
    4158:	51 e2       	ldi	r21, 0x21	; 33
    415a:	20 e0       	ldi	r18, 0x00	; 0
    415c:	32 e0       	ldi	r19, 0x02	; 2
    415e:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_write_block>
 }
 return 0xffffffff;
    4162:	0f ef       	ldi	r16, 0xFF	; 255
    4164:	1f ef       	ldi	r17, 0xFF	; 255
    4166:	98 01       	movw	r18, r16
    4168:	0b c0       	rjmp	.+22     	; 0x4180 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    416a:	0f ef       	ldi	r16, 0xFF	; 255
    416c:	1f ef       	ldi	r17, 0xFF	; 255
    416e:	98 01       	movw	r18, r16
    4170:	07 c0       	rjmp	.+14     	; 0x4180 <getSetFreeCluster+0x138>
    4172:	0f ef       	ldi	r16, 0xFF	; 255
    4174:	1f ef       	ldi	r17, 0xFF	; 255
    4176:	98 01       	movw	r18, r16
    4178:	03 c0       	rjmp	.+6      	; 0x4180 <getSetFreeCluster+0x138>
    417a:	0f ef       	ldi	r16, 0xFF	; 255
    417c:	1f ef       	ldi	r17, 0xFF	; 255
    417e:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    4180:	60 2f       	mov	r22, r16
    4182:	71 2f       	mov	r23, r17
    4184:	82 2f       	mov	r24, r18
    4186:	93 2f       	mov	r25, r19
    4188:	cf 91       	pop	r28
    418a:	1f 91       	pop	r17
    418c:	0f 91       	pop	r16
    418e:	ff 90       	pop	r15
    4190:	ef 90       	pop	r14
    4192:	df 90       	pop	r13
    4194:	cf 90       	pop	r12
    4196:	08 95       	ret

00004198 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    4198:	ef 92       	push	r14
    419a:	ff 92       	push	r15
    419c:	0f 93       	push	r16
    419e:	1f 93       	push	r17
    41a0:	cf 93       	push	r28
    41a2:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    41a4:	10 92 7d 50 	sts	0x507D, r1
    41a8:	10 92 7e 50 	sts	0x507E, r1
    41ac:	10 92 7f 50 	sts	0x507F, r1
    41b0:	10 92 80 50 	sts	0x5080, r1

SD_read_block(0,SDBuffer);
    41b4:	60 e0       	ldi	r22, 0x00	; 0
    41b6:	70 e0       	ldi	r23, 0x00	; 0
    41b8:	cb 01       	movw	r24, r22
    41ba:	46 ed       	ldi	r20, 0xD6	; 214
    41bc:	51 e2       	ldi	r21, 0x21	; 33
    41be:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    41c2:	80 91 d6 21 	lds	r24, 0x21D6
    41c6:	89 3e       	cpi	r24, 0xE9	; 233
    41c8:	31 f1       	breq	.+76     	; 0x4216 <getBootSectorData+0x7e>
    41ca:	8b 3e       	cpi	r24, 0xEB	; 235
    41cc:	21 f1       	breq	.+72     	; 0x4216 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    41ce:	80 91 d4 23 	lds	r24, 0x23D4
    41d2:	90 91 d5 23 	lds	r25, 0x23D5
    41d6:	2a ea       	ldi	r18, 0xAA	; 170
    41d8:	85 35       	cpi	r24, 0x55	; 85
    41da:	92 07       	cpc	r25, r18
    41dc:	09 f0       	breq	.+2      	; 0x41e0 <getBootSectorData+0x48>
    41de:	b7 c0       	rjmp	.+366    	; 0x434e <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    41e0:	60 91 9c 23 	lds	r22, 0x239C
    41e4:	70 91 9d 23 	lds	r23, 0x239D
    41e8:	80 91 9e 23 	lds	r24, 0x239E
    41ec:	90 91 9f 23 	lds	r25, 0x239F
    41f0:	60 93 7d 50 	sts	0x507D, r22
    41f4:	70 93 7e 50 	sts	0x507E, r23
    41f8:	80 93 7f 50 	sts	0x507F, r24
    41fc:	90 93 80 50 	sts	0x5080, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    4200:	46 ed       	ldi	r20, 0xD6	; 214
    4202:	51 e2       	ldi	r21, 0x21	; 33
    4204:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4208:	80 91 d6 21 	lds	r24, 0x21D6
    420c:	89 3e       	cpi	r24, 0xE9	; 233
    420e:	19 f0       	breq	.+6      	; 0x4216 <getBootSectorData+0x7e>
    4210:	8b 3e       	cpi	r24, 0xEB	; 235
    4212:	09 f0       	breq	.+2      	; 0x4216 <getBootSectorData+0x7e>
    4214:	9e c0       	rjmp	.+316    	; 0x4352 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4216:	80 91 e1 21 	lds	r24, 0x21E1
    421a:	90 91 e2 21 	lds	r25, 0x21E2
    421e:	80 93 54 40 	sts	0x4054, r24
    4222:	90 93 55 40 	sts	0x4055, r25
sectorPerCluster = bpb->sectorPerCluster;
    4226:	80 91 e3 21 	lds	r24, 0x21E3
    422a:	90 e0       	ldi	r25, 0x00	; 0
    422c:	80 93 7b 50 	sts	0x507B, r24
    4230:	90 93 7c 50 	sts	0x507C, r25
reservedSectorCount = bpb->reservedSectorCount;
    4234:	e0 90 e4 21 	lds	r14, 0x21E4
    4238:	f0 90 e5 21 	lds	r15, 0x21E5
    423c:	e0 92 83 50 	sts	0x5083, r14
    4240:	f0 92 84 50 	sts	0x5084, r15
rootCluster = bpb->rootCluster;
    4244:	80 91 02 22 	lds	r24, 0x2202
    4248:	90 91 03 22 	lds	r25, 0x2203
    424c:	a0 91 04 22 	lds	r26, 0x2204
    4250:	b0 91 05 22 	lds	r27, 0x2205
    4254:	80 93 5f 40 	sts	0x405F, r24
    4258:	90 93 60 40 	sts	0x4060, r25
    425c:	a0 93 61 40 	sts	0x4061, r26
    4260:	b0 93 62 40 	sts	0x4062, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    4264:	c0 91 83 50 	lds	r28, 0x5083
    4268:	d0 91 84 50 	lds	r29, 0x5084
    426c:	60 91 e6 21 	lds	r22, 0x21E6
    4270:	70 e0       	ldi	r23, 0x00	; 0
    4272:	80 e0       	ldi	r24, 0x00	; 0
    4274:	90 e0       	ldi	r25, 0x00	; 0
    4276:	20 91 fa 21 	lds	r18, 0x21FA
    427a:	30 91 fb 21 	lds	r19, 0x21FB
    427e:	40 91 fc 21 	lds	r20, 0x21FC
    4282:	50 91 fd 21 	lds	r21, 0x21FD
    4286:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    428a:	8b 01       	movw	r16, r22
    428c:	9c 01       	movw	r18, r24
    428e:	ae 01       	movw	r20, r28
    4290:	60 e0       	ldi	r22, 0x00	; 0
    4292:	70 e0       	ldi	r23, 0x00	; 0
    4294:	80 91 f2 21 	lds	r24, 0x21F2
    4298:	90 91 f3 21 	lds	r25, 0x21F3
    429c:	a0 91 f4 21 	lds	r26, 0x21F4
    42a0:	b0 91 f5 21 	lds	r27, 0x21F5
    42a4:	84 0f       	add	r24, r20
    42a6:	95 1f       	adc	r25, r21
    42a8:	a6 1f       	adc	r26, r22
    42aa:	b7 1f       	adc	r27, r23
    42ac:	80 0f       	add	r24, r16
    42ae:	91 1f       	adc	r25, r17
    42b0:	a2 1f       	adc	r26, r18
    42b2:	b3 1f       	adc	r27, r19
    42b4:	80 93 db 23 	sts	0x23DB, r24
    42b8:	90 93 dc 23 	sts	0x23DC, r25
    42bc:	a0 93 dd 23 	sts	0x23DD, r26
    42c0:	b0 93 de 23 	sts	0x23DE, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    42c4:	e0 91 7b 50 	lds	r30, 0x507B
    42c8:	f0 91 7c 50 	lds	r31, 0x507C
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    42cc:	c7 01       	movw	r24, r14
    42ce:	a0 e0       	ldi	r26, 0x00	; 0
    42d0:	b0 e0       	ldi	r27, 0x00	; 0
    42d2:	40 91 f6 21 	lds	r20, 0x21F6
    42d6:	50 91 f7 21 	lds	r21, 0x21F7
    42da:	60 91 f8 21 	lds	r22, 0x21F8
    42de:	70 91 f9 21 	lds	r23, 0x21F9
    42e2:	48 1b       	sub	r20, r24
    42e4:	59 0b       	sbc	r21, r25
    42e6:	6a 0b       	sbc	r22, r26
    42e8:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    42ea:	cb 01       	movw	r24, r22
    42ec:	ba 01       	movw	r22, r20
    42ee:	60 1b       	sub	r22, r16
    42f0:	71 0b       	sbc	r23, r17
    42f2:	82 0b       	sbc	r24, r18
    42f4:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    42f6:	9f 01       	movw	r18, r30
    42f8:	40 e0       	ldi	r20, 0x00	; 0
    42fa:	50 e0       	ldi	r21, 0x00	; 0
    42fc:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    4300:	20 93 59 40 	sts	0x4059, r18
    4304:	30 93 5a 40 	sts	0x405A, r19
    4308:	40 93 5b 40 	sts	0x405B, r20
    430c:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    4310:	81 e0       	ldi	r24, 0x01	; 1
    4312:	60 e0       	ldi	r22, 0x00	; 0
    4314:	20 e0       	ldi	r18, 0x00	; 0
    4316:	30 e0       	ldi	r19, 0x00	; 0
    4318:	a9 01       	movw	r20, r18
    431a:	0e 94 24 20 	call	0x4048	; 0x4048 <getSetFreeCluster>
    431e:	ab 01       	movw	r20, r22
    4320:	bc 01       	movw	r22, r24
    4322:	80 91 59 40 	lds	r24, 0x4059
    4326:	90 91 5a 40 	lds	r25, 0x405A
    432a:	a0 91 5b 40 	lds	r26, 0x405B
    432e:	b0 91 5c 40 	lds	r27, 0x405C
    4332:	84 17       	cp	r24, r20
    4334:	95 07       	cpc	r25, r21
    4336:	a6 07       	cpc	r26, r22
    4338:	b7 07       	cpc	r27, r23
    433a:	20 f4       	brcc	.+8      	; 0x4344 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    433c:	10 92 cf 50 	sts	0x50CF, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4340:	80 e0       	ldi	r24, 0x00	; 0
    4342:	08 c0       	rjmp	.+16     	; 0x4354 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4344:	81 e0       	ldi	r24, 0x01	; 1
    4346:	80 93 cf 50 	sts	0x50CF, r24
return 0;
    434a:	80 e0       	ldi	r24, 0x00	; 0
    434c:	03 c0       	rjmp	.+6      	; 0x4354 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    434e:	81 e0       	ldi	r24, 0x01	; 1
    4350:	01 c0       	rjmp	.+2      	; 0x4354 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4352:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4354:	df 91       	pop	r29
    4356:	cf 91       	pop	r28
    4358:	1f 91       	pop	r17
    435a:	0f 91       	pop	r16
    435c:	ff 90       	pop	r15
    435e:	ef 90       	pop	r14
    4360:	08 95       	ret

00004362 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4362:	0f 93       	push	r16
    4364:	1f 93       	push	r17
    4366:	cf 93       	push	r28
    4368:	df 93       	push	r29
    436a:	cd b7       	in	r28, 0x3d	; 61
    436c:	de b7       	in	r29, 0x3e	; 62
    436e:	2b 97       	sbiw	r28, 0x0b	; 11
    4370:	cd bf       	out	0x3d, r28	; 61
    4372:	de bf       	out	0x3e, r29	; 62
    4374:	78 2f       	mov	r23, r24
    4376:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4378:	e8 2f       	mov	r30, r24
    437a:	f9 2f       	mov	r31, r25
    437c:	df 01       	movw	r26, r30
    437e:	0d 90       	ld	r0, X+
    4380:	00 20       	and	r0, r0
    4382:	e9 f7       	brne	.-6      	; 0x437e <convertFileName+0x1c>
    4384:	11 97       	sbiw	r26, 0x01	; 1
    4386:	ae 1b       	sub	r26, r30
    4388:	bf 0b       	sbc	r27, r31
    438a:	a0 31       	cpi	r26, 0x10	; 16
    438c:	b1 05       	cpc	r27, r1
    438e:	08 f0       	brcs	.+2      	; 0x4392 <convertFileName+0x30>
    4390:	9c c0       	rjmp	.+312    	; 0x44ca <convertFileName+0x168>
    4392:	28 2f       	mov	r18, r24
    4394:	39 2f       	mov	r19, r25
    4396:	0b eb       	ldi	r16, 0xBB	; 187
    4398:	10 e5       	ldi	r17, 0x50	; 80
    439a:	a8 01       	movw	r20, r16
    439c:	80 e0       	ldi	r24, 0x00	; 0
    439e:	90 e0       	ldi	r25, 0x00	; 0
    43a0:	07 c0       	rjmp	.+14     	; 0x43b0 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    43a2:	d9 01       	movw	r26, r18
    43a4:	ed 91       	ld	r30, X+
    43a6:	9d 01       	movw	r18, r26
    43a8:	da 01       	movw	r26, r20
    43aa:	ed 93       	st	X+, r30
    43ac:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    43ae:	01 96       	adiw	r24, 0x01	; 1
    43b0:	a7 2f       	mov	r26, r23
    43b2:	b6 2f       	mov	r27, r22
    43b4:	fd 01       	movw	r30, r26
    43b6:	01 90       	ld	r0, Z+
    43b8:	00 20       	and	r0, r0
    43ba:	e9 f7       	brne	.-6      	; 0x43b6 <convertFileName+0x54>
    43bc:	31 97       	sbiw	r30, 0x01	; 1
    43be:	ea 1b       	sub	r30, r26
    43c0:	fb 0b       	sbc	r31, r27
    43c2:	8e 17       	cp	r24, r30
    43c4:	9f 07       	cpc	r25, r31
    43c6:	68 f3       	brcs	.-38     	; 0x43a2 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    43c8:	8f 30       	cpi	r24, 0x0F	; 15
    43ca:	91 05       	cpc	r25, r1
    43cc:	54 f4       	brge	.+20     	; 0x43e2 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    43ce:	fc 01       	movw	r30, r24
    43d0:	e5 54       	subi	r30, 0x45	; 69
    43d2:	ff 4a       	sbci	r31, 0xAF	; 175
    43d4:	8a ec       	ldi	r24, 0xCA	; 202
    43d6:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    43d8:	20 e2       	ldi	r18, 0x20	; 32
    43da:	21 93       	st	Z+, r18
    43dc:	e8 17       	cp	r30, r24
    43de:	f9 07       	cpc	r31, r25
    43e0:	e1 f7       	brne	.-8      	; 0x43da <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    43e2:	80 91 bb 50 	lds	r24, 0x50BB
    43e6:	8e 32       	cpi	r24, 0x2E	; 46
    43e8:	91 f0       	breq	.+36     	; 0x440e <convertFileName+0xac>
    43ea:	ec eb       	ldi	r30, 0xBC	; 188
    43ec:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    43ee:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    43f0:	81 91       	ld	r24, Z+
    43f2:	8e 32       	cpi	r24, 0x2E	; 46
    43f4:	21 f0       	breq	.+8      	; 0x43fe <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    43f6:	2f 5f       	subi	r18, 0xFF	; 255
    43f8:	2c 30       	cpi	r18, 0x0C	; 12
    43fa:	d1 f7       	brne	.-12     	; 0x43f0 <convertFileName+0x8e>
    43fc:	05 c0       	rjmp	.+10     	; 0x4408 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    43fe:	82 2f       	mov	r24, r18
    4400:	89 50       	subi	r24, 0x09	; 9
    4402:	83 30       	cpi	r24, 0x03	; 3
    4404:	08 f4       	brcc	.+2      	; 0x4408 <convertFileName+0xa6>
    4406:	63 c0       	rjmp	.+198    	; 0x44ce <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4408:	22 23       	and	r18, r18
    440a:	29 f4       	brne	.+10     	; 0x4416 <convertFileName+0xb4>
    440c:	01 c0       	rjmp	.+2      	; 0x4410 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    440e:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4410:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    4412:	90 e2       	ldi	r25, 0x20	; 32
    4414:	10 c0       	rjmp	.+32     	; 0x4436 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4416:	de 01       	movw	r26, r28
    4418:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    441a:	82 2f       	mov	r24, r18
    441c:	81 50       	subi	r24, 0x01	; 1
    441e:	90 e0       	ldi	r25, 0x00	; 0
    4420:	84 54       	subi	r24, 0x44	; 68
    4422:	9f 4a       	sbci	r25, 0xAF	; 175
    4424:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    4426:	31 91       	ld	r19, Z+
    4428:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    442a:	e8 17       	cp	r30, r24
    442c:	f9 07       	cpc	r31, r25
    442e:	d9 f7       	brne	.-10     	; 0x4426 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4430:	28 30       	cpi	r18, 0x08	; 8
    4432:	70 f3       	brcs	.-36     	; 0x4410 <convertFileName+0xae>
    4434:	0a c0       	rjmp	.+20     	; 0x444a <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    4436:	e1 e0       	ldi	r30, 0x01	; 1
    4438:	f0 e0       	ldi	r31, 0x00	; 0
    443a:	ec 0f       	add	r30, r28
    443c:	fd 1f       	adc	r31, r29
    443e:	e8 0f       	add	r30, r24
    4440:	f1 1d       	adc	r31, r1
    4442:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4444:	8f 5f       	subi	r24, 0xFF	; 255
    4446:	88 30       	cpi	r24, 0x08	; 8
    4448:	b0 f3       	brcs	.-20     	; 0x4436 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    444a:	2c 30       	cpi	r18, 0x0C	; 12
    444c:	09 f0       	breq	.+2      	; 0x4450 <convertFileName+0xee>
    444e:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4450:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4452:	8b eb       	ldi	r24, 0xBB	; 187
    4454:	90 e5       	ldi	r25, 0x50	; 80
    4456:	fc 01       	movw	r30, r24
    4458:	e2 0f       	add	r30, r18
    445a:	f1 1d       	adc	r31, r1
    445c:	40 81       	ld	r20, Z
    445e:	44 23       	and	r20, r20
    4460:	19 f4       	brne	.+6      	; 0x4468 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4462:	3b 30       	cpi	r19, 0x0B	; 11
    4464:	50 f0       	brcs	.+20     	; 0x447a <convertFileName+0x118>
    4466:	15 c0       	rjmp	.+42     	; 0x4492 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    4468:	e1 e0       	ldi	r30, 0x01	; 1
    446a:	f0 e0       	ldi	r31, 0x00	; 0
    446c:	ec 0f       	add	r30, r28
    446e:	fd 1f       	adc	r31, r29
    4470:	e3 0f       	add	r30, r19
    4472:	f1 1d       	adc	r31, r1
    4474:	40 83       	st	Z, r20
    4476:	2f 5f       	subi	r18, 0xFF	; 255
    4478:	0c c0       	rjmp	.+24     	; 0x4492 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    447a:	80 e2       	ldi	r24, 0x20	; 32
    447c:	e1 e0       	ldi	r30, 0x01	; 1
    447e:	f0 e0       	ldi	r31, 0x00	; 0
    4480:	ec 0f       	add	r30, r28
    4482:	fd 1f       	adc	r31, r29
    4484:	e3 0f       	add	r30, r19
    4486:	f1 1d       	adc	r31, r1
    4488:	80 83       	st	Z, r24
    448a:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    448c:	3b 30       	cpi	r19, 0x0B	; 11
    448e:	b1 f7       	brne	.-20     	; 0x447c <convertFileName+0x11a>
    4490:	03 c0       	rjmp	.+6      	; 0x4498 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    4492:	3f 5f       	subi	r19, 0xFF	; 255
    4494:	3b 30       	cpi	r19, 0x0B	; 11
    4496:	f8 f2       	brcs	.-66     	; 0x4456 <convertFileName+0xf4>
    4498:	de 01       	movw	r26, r28
    449a:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    449c:	ce 01       	movw	r24, r28
    449e:	0c 96       	adiw	r24, 0x0c	; 12
    44a0:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    44a2:	20 81       	ld	r18, Z
    44a4:	32 2f       	mov	r19, r18
    44a6:	31 56       	subi	r19, 0x61	; 97
    44a8:	3a 31       	cpi	r19, 0x1A	; 26
    44aa:	10 f4       	brcc	.+4      	; 0x44b0 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    44ac:	20 52       	subi	r18, 0x20	; 32
    44ae:	20 83       	st	Z, r18
    44b0:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    44b2:	e8 17       	cp	r30, r24
    44b4:	f9 07       	cpc	r31, r25
    44b6:	a9 f7       	brne	.-22     	; 0x44a2 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    44b8:	2d 91       	ld	r18, X+
    44ba:	f8 01       	movw	r30, r16
    44bc:	21 93       	st	Z+, r18
    44be:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    44c0:	a8 17       	cp	r26, r24
    44c2:	b9 07       	cpc	r27, r25
    44c4:	c9 f7       	brne	.-14     	; 0x44b8 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    44c6:	80 e0       	ldi	r24, 0x00	; 0
    44c8:	03 c0       	rjmp	.+6      	; 0x44d0 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    44ca:	81 e0       	ldi	r24, 0x01	; 1
    44cc:	01 c0       	rjmp	.+2      	; 0x44d0 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    44ce:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    44d0:	2b 96       	adiw	r28, 0x0b	; 11
    44d2:	cd bf       	out	0x3d, r28	; 61
    44d4:	de bf       	out	0x3e, r29	; 62
    44d6:	df 91       	pop	r29
    44d8:	cf 91       	pop	r28
    44da:	1f 91       	pop	r17
    44dc:	0f 91       	pop	r16
    44de:	08 95       	ret

000044e0 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    44e0:	4f 92       	push	r4
    44e2:	5f 92       	push	r5
    44e4:	6f 92       	push	r6
    44e6:	7f 92       	push	r7
    44e8:	8f 92       	push	r8
    44ea:	9f 92       	push	r9
    44ec:	af 92       	push	r10
    44ee:	bf 92       	push	r11
    44f0:	cf 92       	push	r12
    44f2:	df 92       	push	r13
    44f4:	ef 92       	push	r14
    44f6:	ff 92       	push	r15
    44f8:	cf 93       	push	r28
    44fa:	df 93       	push	r29
    44fc:	2b 01       	movw	r4, r22
    44fe:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4500:	20 e8       	ldi	r18, 0x80	; 128
    4502:	3f ef       	ldi	r19, 0xFF	; 255
    4504:	4f ef       	ldi	r20, 0xFF	; 255
    4506:	5f ef       	ldi	r21, 0xFF	; 255
    4508:	42 22       	and	r4, r18
    450a:	53 22       	and	r5, r19
    450c:	64 22       	and	r6, r20
    450e:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4510:	80 91 59 40 	lds	r24, 0x4059
    4514:	90 91 5a 40 	lds	r25, 0x405A
    4518:	a0 91 5b 40 	lds	r26, 0x405B
    451c:	b0 91 5c 40 	lds	r27, 0x405C
    4520:	48 16       	cp	r4, r24
    4522:	59 06       	cpc	r5, r25
    4524:	6a 06       	cpc	r6, r26
    4526:	7b 06       	cpc	r7, r27
    4528:	08 f0       	brcs	.+2      	; 0x452c <searchNextFreeCluster+0x4c>
    452a:	77 c0       	rjmp	.+238    	; 0x461a <searchNextFreeCluster+0x13a>
    452c:	53 01       	movw	r10, r6
    452e:	42 01       	movw	r8, r4
    4530:	88 0c       	add	r8, r8
    4532:	99 1c       	adc	r9, r9
    4534:	aa 1c       	adc	r10, r10
    4536:	bb 1c       	adc	r11, r11
    4538:	88 0c       	add	r8, r8
    453a:	99 1c       	adc	r9, r9
    453c:	aa 1c       	adc	r10, r10
    453e:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4540:	c6 ed       	ldi	r28, 0xD6	; 214
    4542:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4544:	c0 90 83 50 	lds	r12, 0x5083
    4548:	d0 90 84 50 	lds	r13, 0x5084
    454c:	20 91 54 40 	lds	r18, 0x4054
    4550:	30 91 55 40 	lds	r19, 0x4055
    4554:	ee 24       	eor	r14, r14
    4556:	ff 24       	eor	r15, r15
    4558:	80 91 7d 50 	lds	r24, 0x507D
    455c:	90 91 7e 50 	lds	r25, 0x507E
    4560:	a0 91 7f 50 	lds	r26, 0x507F
    4564:	b0 91 80 50 	lds	r27, 0x5080
    4568:	c8 0e       	add	r12, r24
    456a:	d9 1e       	adc	r13, r25
    456c:	ea 1e       	adc	r14, r26
    456e:	fb 1e       	adc	r15, r27
    4570:	40 e0       	ldi	r20, 0x00	; 0
    4572:	50 e0       	ldi	r21, 0x00	; 0
    4574:	c5 01       	movw	r24, r10
    4576:	b4 01       	movw	r22, r8
    4578:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    457c:	c7 01       	movw	r24, r14
    457e:	b6 01       	movw	r22, r12
    4580:	62 0f       	add	r22, r18
    4582:	73 1f       	adc	r23, r19
    4584:	84 1f       	adc	r24, r20
    4586:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    4588:	ae 01       	movw	r20, r28
    458a:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    458e:	88 81       	ld	r24, Y
    4590:	99 81       	ldd	r25, Y+1	; 0x01
    4592:	aa 81       	ldd	r26, Y+2	; 0x02
    4594:	bb 81       	ldd	r27, Y+3	; 0x03
    4596:	bf 70       	andi	r27, 0x0F	; 15
    4598:	00 97       	sbiw	r24, 0x00	; 0
    459a:	a1 05       	cpc	r26, r1
    459c:	b1 05       	cpc	r27, r1
    459e:	99 f0       	breq	.+38     	; 0x45c6 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45a0:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    45a2:	e2 2f       	mov	r30, r18
    45a4:	f0 e0       	ldi	r31, 0x00	; 0
    45a6:	ee 0f       	add	r30, r30
    45a8:	ff 1f       	adc	r31, r31
    45aa:	ee 0f       	add	r30, r30
    45ac:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    45ae:	ea 52       	subi	r30, 0x2A	; 42
    45b0:	fe 4d       	sbci	r31, 0xDE	; 222
    45b2:	80 81       	ld	r24, Z
    45b4:	91 81       	ldd	r25, Z+1	; 0x01
    45b6:	a2 81       	ldd	r26, Z+2	; 0x02
    45b8:	b3 81       	ldd	r27, Z+3	; 0x03
    45ba:	bf 70       	andi	r27, 0x0F	; 15
    45bc:	00 97       	sbiw	r24, 0x00	; 0
    45be:	a1 05       	cpc	r26, r1
    45c0:	b1 05       	cpc	r27, r1
    45c2:	39 f4       	brne	.+14     	; 0x45d2 <searchNextFreeCluster+0xf2>
    45c4:	01 c0       	rjmp	.+2      	; 0x45c8 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45c6:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    45c8:	42 0e       	add	r4, r18
    45ca:	51 1c       	adc	r5, r1
    45cc:	61 1c       	adc	r6, r1
    45ce:	71 1c       	adc	r7, r1
    45d0:	27 c0       	rjmp	.+78     	; 0x4620 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45d2:	2f 5f       	subi	r18, 0xFF	; 255
    45d4:	32 f7       	brpl	.-52     	; 0x45a2 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    45d6:	80 e8       	ldi	r24, 0x80	; 128
    45d8:	90 e0       	ldi	r25, 0x00	; 0
    45da:	a0 e0       	ldi	r26, 0x00	; 0
    45dc:	b0 e0       	ldi	r27, 0x00	; 0
    45de:	48 0e       	add	r4, r24
    45e0:	59 1e       	adc	r5, r25
    45e2:	6a 1e       	adc	r6, r26
    45e4:	7b 1e       	adc	r7, r27
    45e6:	80 91 59 40 	lds	r24, 0x4059
    45ea:	90 91 5a 40 	lds	r25, 0x405A
    45ee:	a0 91 5b 40 	lds	r26, 0x405B
    45f2:	b0 91 5c 40 	lds	r27, 0x405C
    45f6:	20 e0       	ldi	r18, 0x00	; 0
    45f8:	32 e0       	ldi	r19, 0x02	; 2
    45fa:	40 e0       	ldi	r20, 0x00	; 0
    45fc:	50 e0       	ldi	r21, 0x00	; 0
    45fe:	82 0e       	add	r8, r18
    4600:	93 1e       	adc	r9, r19
    4602:	a4 1e       	adc	r10, r20
    4604:	b5 1e       	adc	r11, r21
    4606:	48 16       	cp	r4, r24
    4608:	59 06       	cpc	r5, r25
    460a:	6a 06       	cpc	r6, r26
    460c:	7b 06       	cpc	r7, r27
    460e:	08 f4       	brcc	.+2      	; 0x4612 <searchNextFreeCluster+0x132>
    4610:	99 cf       	rjmp	.-206    	; 0x4544 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4612:	44 24       	eor	r4, r4
    4614:	55 24       	eor	r5, r5
    4616:	32 01       	movw	r6, r4
    4618:	03 c0       	rjmp	.+6      	; 0x4620 <searchNextFreeCluster+0x140>
    461a:	44 24       	eor	r4, r4
    461c:	55 24       	eor	r5, r5
    461e:	32 01       	movw	r6, r4
}
    4620:	64 2d       	mov	r22, r4
    4622:	75 2d       	mov	r23, r5
    4624:	86 2d       	mov	r24, r6
    4626:	97 2d       	mov	r25, r7
    4628:	df 91       	pop	r29
    462a:	cf 91       	pop	r28
    462c:	ff 90       	pop	r15
    462e:	ef 90       	pop	r14
    4630:	df 90       	pop	r13
    4632:	cf 90       	pop	r12
    4634:	bf 90       	pop	r11
    4636:	af 90       	pop	r10
    4638:	9f 90       	pop	r9
    463a:	8f 90       	pop	r8
    463c:	7f 90       	pop	r7
    463e:	6f 90       	pop	r6
    4640:	5f 90       	pop	r5
    4642:	4f 90       	pop	r4
    4644:	08 95       	ret

00004646 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4646:	cf 92       	push	r12
    4648:	df 92       	push	r13
    464a:	ef 92       	push	r14
    464c:	ff 92       	push	r15
    464e:	cf 93       	push	r28
    4650:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4652:	db 01       	movw	r26, r22
    4654:	ca 01       	movw	r24, r20
    4656:	91 70       	andi	r25, 0x01	; 1
    4658:	a0 70       	andi	r26, 0x00	; 0
    465a:	b0 70       	andi	r27, 0x00	; 0
    465c:	00 97       	sbiw	r24, 0x00	; 0
    465e:	a1 05       	cpc	r26, r1
    4660:	b1 05       	cpc	r27, r1
    4662:	51 f4       	brne	.+20     	; 0x4678 <freeMemoryUpdate+0x32>
    4664:	03 2e       	mov	r0, r19
    4666:	39 e0       	ldi	r19, 0x09	; 9
    4668:	76 95       	lsr	r23
    466a:	67 95       	ror	r22
    466c:	57 95       	ror	r21
    466e:	47 95       	ror	r20
    4670:	3a 95       	dec	r19
    4672:	d1 f7       	brne	.-12     	; 0x4668 <freeMemoryUpdate+0x22>
    4674:	30 2d       	mov	r19, r0
    4676:	0d c0       	rjmp	.+26     	; 0x4692 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4678:	03 2e       	mov	r0, r19
    467a:	39 e0       	ldi	r19, 0x09	; 9
    467c:	76 95       	lsr	r23
    467e:	67 95       	ror	r22
    4680:	57 95       	ror	r21
    4682:	47 95       	ror	r20
    4684:	3a 95       	dec	r19
    4686:	d1 f7       	brne	.-12     	; 0x467c <freeMemoryUpdate+0x36>
    4688:	30 2d       	mov	r19, r0
    468a:	4f 5f       	subi	r20, 0xFF	; 255
    468c:	5f 4f       	sbci	r21, 0xFF	; 255
    468e:	6f 4f       	sbci	r22, 0xFF	; 255
    4690:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4692:	db 01       	movw	r26, r22
    4694:	ca 01       	movw	r24, r20
    4696:	87 70       	andi	r24, 0x07	; 7
    4698:	90 70       	andi	r25, 0x00	; 0
    469a:	a0 70       	andi	r26, 0x00	; 0
    469c:	b0 70       	andi	r27, 0x00	; 0
    469e:	00 97       	sbiw	r24, 0x00	; 0
    46a0:	a1 05       	cpc	r26, r1
    46a2:	b1 05       	cpc	r27, r1
    46a4:	59 f4       	brne	.+22     	; 0x46bc <freeMemoryUpdate+0x76>
    46a6:	6a 01       	movw	r12, r20
    46a8:	7b 01       	movw	r14, r22
    46aa:	68 94       	set
    46ac:	12 f8       	bld	r1, 2
    46ae:	f6 94       	lsr	r15
    46b0:	e7 94       	ror	r14
    46b2:	d7 94       	ror	r13
    46b4:	c7 94       	ror	r12
    46b6:	16 94       	lsr	r1
    46b8:	d1 f7       	brne	.-12     	; 0x46ae <freeMemoryUpdate+0x68>
    46ba:	0f c0       	rjmp	.+30     	; 0x46da <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    46bc:	6a 01       	movw	r12, r20
    46be:	7b 01       	movw	r14, r22
    46c0:	68 94       	set
    46c2:	12 f8       	bld	r1, 2
    46c4:	f6 94       	lsr	r15
    46c6:	e7 94       	ror	r14
    46c8:	d7 94       	ror	r13
    46ca:	c7 94       	ror	r12
    46cc:	16 94       	lsr	r1
    46ce:	d1 f7       	brne	.-12     	; 0x46c4 <freeMemoryUpdate+0x7e>
    46d0:	08 94       	sec
    46d2:	c1 1c       	adc	r12, r1
    46d4:	d1 1c       	adc	r13, r1
    46d6:	e1 1c       	adc	r14, r1
    46d8:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    46da:	80 91 cf 50 	lds	r24, 0x50CF
    46de:	88 23       	and	r24, r24
    46e0:	d1 f0       	breq	.+52     	; 0x4716 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    46e2:	81 e0       	ldi	r24, 0x01	; 1
    46e4:	60 e0       	ldi	r22, 0x00	; 0
    46e6:	20 e0       	ldi	r18, 0x00	; 0
    46e8:	30 e0       	ldi	r19, 0x00	; 0
    46ea:	a9 01       	movw	r20, r18
    46ec:	0e 94 24 20 	call	0x4048	; 0x4048 <getSetFreeCluster>
	if(flag == ADD)
    46f0:	cc 23       	and	r28, r28
    46f2:	39 f4       	brne	.+14     	; 0x4702 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    46f4:	9b 01       	movw	r18, r22
    46f6:	ac 01       	movw	r20, r24
    46f8:	2c 0d       	add	r18, r12
    46fa:	3d 1d       	adc	r19, r13
    46fc:	4e 1d       	adc	r20, r14
    46fe:	5f 1d       	adc	r21, r15
    4700:	06 c0       	rjmp	.+12     	; 0x470e <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4702:	9b 01       	movw	r18, r22
    4704:	ac 01       	movw	r20, r24
    4706:	2c 19       	sub	r18, r12
    4708:	3d 09       	sbc	r19, r13
    470a:	4e 09       	sbc	r20, r14
    470c:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    470e:	81 e0       	ldi	r24, 0x01	; 1
    4710:	61 e0       	ldi	r22, 0x01	; 1
    4712:	0e 94 24 20 	call	0x4048	; 0x4048 <getSetFreeCluster>
  }
}
    4716:	cf 91       	pop	r28
    4718:	ff 90       	pop	r15
    471a:	ef 90       	pop	r14
    471c:	df 90       	pop	r13
    471e:	cf 90       	pop	r12
    4720:	08 95       	ret

00004722 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4722:	2f 92       	push	r2
    4724:	3f 92       	push	r3
    4726:	4f 92       	push	r4
    4728:	5f 92       	push	r5
    472a:	6f 92       	push	r6
    472c:	7f 92       	push	r7
    472e:	8f 92       	push	r8
    4730:	9f 92       	push	r9
    4732:	af 92       	push	r10
    4734:	bf 92       	push	r11
    4736:	cf 92       	push	r12
    4738:	df 92       	push	r13
    473a:	ef 92       	push	r14
    473c:	ff 92       	push	r15
    473e:	0f 93       	push	r16
    4740:	1f 93       	push	r17
    4742:	cf 93       	push	r28
    4744:	df 93       	push	r29
    4746:	cd b7       	in	r28, 0x3d	; 61
    4748:	de b7       	in	r29, 0x3e	; 62
    474a:	2c 97       	sbiw	r28, 0x0c	; 12
    474c:	cd bf       	out	0x3d, r28	; 61
    474e:	de bf       	out	0x3e, r29	; 62
    4750:	88 2e       	mov	r8, r24
    4752:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4754:	80 91 5f 40 	lds	r24, 0x405F
    4758:	90 91 60 40 	lds	r25, 0x4060
    475c:	a0 91 61 40 	lds	r26, 0x4061
    4760:	b0 91 62 40 	lds	r27, 0x4062
    4764:	89 87       	std	Y+9, r24	; 0x09
    4766:	9a 87       	std	Y+10, r25	; 0x0a
    4768:	ab 87       	std	Y+11, r26	; 0x0b
    476a:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    476c:	0f 2e       	mov	r0, r31
    476e:	f6 ed       	ldi	r31, 0xD6	; 214
    4770:	2f 2e       	mov	r2, r31
    4772:	f1 e2       	ldi	r31, 0x21	; 33
    4774:	3f 2e       	mov	r3, r31
    4776:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4778:	c8 2c       	mov	r12, r8
    477a:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    477c:	d2 2c       	mov	r13, r2
    477e:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4780:	5b 01       	movw	r10, r22
    4782:	08 94       	sec
    4784:	a1 1c       	adc	r10, r1
    4786:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4788:	69 85       	ldd	r22, Y+9	; 0x09
    478a:	7a 85       	ldd	r23, Y+10	; 0x0a
    478c:	8b 85       	ldd	r24, Y+11	; 0x0b
    478e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4790:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <getFirstSector>
    4794:	6d 83       	std	Y+5, r22	; 0x05
    4796:	7e 83       	std	Y+6, r23	; 0x06
    4798:	8f 83       	std	Y+7, r24	; 0x07
    479a:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    479c:	80 91 7b 50 	lds	r24, 0x507B
    47a0:	90 91 7c 50 	lds	r25, 0x507C
    47a4:	00 97       	sbiw	r24, 0x00	; 0
    47a6:	09 f4       	brne	.+2      	; 0x47aa <findFiles+0x88>
    47a8:	13 c1       	rjmp	.+550    	; 0x49d0 <findFiles+0x2ae>
    47aa:	44 24       	eor	r4, r4
    47ac:	55 24       	eor	r5, r5
    47ae:	32 01       	movw	r6, r4
    47b0:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    47b2:	8d 81       	ldd	r24, Y+5	; 0x05
    47b4:	9e 81       	ldd	r25, Y+6	; 0x06
    47b6:	af 81       	ldd	r26, Y+7	; 0x07
    47b8:	b8 85       	ldd	r27, Y+8	; 0x08
    47ba:	84 0d       	add	r24, r4
    47bc:	95 1d       	adc	r25, r5
    47be:	a6 1d       	adc	r26, r6
    47c0:	b7 1d       	adc	r27, r7
    47c2:	89 83       	std	Y+1, r24	; 0x01
    47c4:	9a 83       	std	Y+2, r25	; 0x02
    47c6:	ab 83       	std	Y+3, r26	; 0x03
    47c8:	bc 83       	std	Y+4, r27	; 0x04
    47ca:	bc 01       	movw	r22, r24
    47cc:	cd 01       	movw	r24, r26
    47ce:	4d 2d       	mov	r20, r13
    47d0:	59 2d       	mov	r21, r9
    47d2:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    47d6:	80 91 54 40 	lds	r24, 0x4054
    47da:	90 91 55 40 	lds	r25, 0x4055
    47de:	00 97       	sbiw	r24, 0x00	; 0
    47e0:	09 f4       	brne	.+2      	; 0x47e4 <findFiles+0xc2>
    47e2:	e4 c0       	rjmp	.+456    	; 0x49ac <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    47e4:	d1 01       	movw	r26, r2
    47e6:	8c 91       	ld	r24, X
    47e8:	88 23       	and	r24, r24
    47ea:	09 f4       	brne	.+2      	; 0x47ee <findFiles+0xcc>
    47ec:	10 c1       	rjmp	.+544    	; 0x4a0e <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    47ee:	4d 2d       	mov	r20, r13
    47f0:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    47f2:	20 e0       	ldi	r18, 0x00	; 0
    47f4:	30 e0       	ldi	r19, 0x00	; 0
    47f6:	08 c0       	rjmp	.+16     	; 0x4808 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    47f8:	a9 01       	movw	r20, r18
    47fa:	4a 52       	subi	r20, 0x2A	; 42
    47fc:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    47fe:	fa 01       	movw	r30, r20
    4800:	80 81       	ld	r24, Z
    4802:	88 23       	and	r24, r24
    4804:	09 f4       	brne	.+2      	; 0x4808 <findFiles+0xe6>
    4806:	06 c1       	rjmp	.+524    	; 0x4a14 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4808:	85 3e       	cpi	r24, 0xE5	; 229
    480a:	09 f4       	brne	.+2      	; 0x480e <findFiles+0xec>
    480c:	c5 c0       	rjmp	.+394    	; 0x4998 <findFiles+0x276>
    480e:	da 01       	movw	r26, r20
    4810:	1b 96       	adiw	r26, 0x0b	; 11
    4812:	8c 91       	ld	r24, X
    4814:	1b 97       	sbiw	r26, 0x0b	; 11
    4816:	8f 30       	cpi	r24, 0x0F	; 15
    4818:	09 f4       	brne	.+2      	; 0x481c <findFiles+0xfa>
    481a:	be c0       	rjmp	.+380    	; 0x4998 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    481c:	12 30       	cpi	r17, 0x02	; 2
    481e:	08 f0       	brcs	.+2      	; 0x4822 <findFiles+0x100>
    4820:	fc c0       	rjmp	.+504    	; 0x4a1a <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4822:	9c 91       	ld	r25, X
    4824:	f7 01       	movw	r30, r14
    4826:	80 81       	ld	r24, Z
    4828:	98 17       	cp	r25, r24
    482a:	09 f0       	breq	.+2      	; 0x482e <findFiles+0x10c>
    482c:	b5 c0       	rjmp	.+362    	; 0x4998 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    482e:	fa 01       	movw	r30, r20
    4830:	31 96       	adiw	r30, 0x01	; 1
    4832:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4834:	81 e0       	ldi	r24, 0x01	; 1
    4836:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4838:	41 91       	ld	r20, Z+
    483a:	9d 91       	ld	r25, X+
    483c:	49 17       	cp	r20, r25
    483e:	31 f4       	brne	.+12     	; 0x484c <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4840:	8f 5f       	subi	r24, 0xFF	; 255
    4842:	8b 30       	cpi	r24, 0x0B	; 11
    4844:	c9 f7       	brne	.-14     	; 0x4838 <findFiles+0x116>
    4846:	8b 01       	movw	r16, r22
    4848:	6b 01       	movw	r12, r22
    484a:	05 c0       	rjmp	.+10     	; 0x4856 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    484c:	8b 30       	cpi	r24, 0x0B	; 11
    484e:	09 f0       	breq	.+2      	; 0x4852 <findFiles+0x130>
    4850:	a3 c0       	rjmp	.+326    	; 0x4998 <findFiles+0x276>
    4852:	8b 01       	movw	r16, r22
    4854:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4856:	f1 e0       	ldi	r31, 0x01	; 1
    4858:	8f 16       	cp	r8, r31
    485a:	09 f0       	breq	.+2      	; 0x485e <findFiles+0x13c>
    485c:	41 c0       	rjmp	.+130    	; 0x48e0 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    485e:	89 81       	ldd	r24, Y+1	; 0x01
    4860:	9a 81       	ldd	r25, Y+2	; 0x02
    4862:	ab 81       	ldd	r26, Y+3	; 0x03
    4864:	bc 81       	ldd	r27, Y+4	; 0x04
    4866:	80 93 d1 50 	sts	0x50D1, r24
    486a:	90 93 d2 50 	sts	0x50D2, r25
    486e:	a0 93 d3 50 	sts	0x50D3, r26
    4872:	b0 93 d4 50 	sts	0x50D4, r27
				appendFileLocation = i;
    4876:	c9 01       	movw	r24, r18
    4878:	a0 e0       	ldi	r26, 0x00	; 0
    487a:	b0 e0       	ldi	r27, 0x00	; 0
    487c:	80 93 d7 23 	sts	0x23D7, r24
    4880:	90 93 d8 23 	sts	0x23D8, r25
    4884:	a0 93 d9 23 	sts	0x23D9, r26
    4888:	b0 93 da 23 	sts	0x23DA, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    488c:	d6 01       	movw	r26, r12
    488e:	54 96       	adiw	r26, 0x14	; 20
    4890:	4d 91       	ld	r20, X+
    4892:	5c 91       	ld	r21, X
    4894:	55 97       	sbiw	r26, 0x15	; 21
    4896:	60 e0       	ldi	r22, 0x00	; 0
    4898:	70 e0       	ldi	r23, 0x00	; 0
    489a:	ba 01       	movw	r22, r20
    489c:	55 27       	eor	r21, r21
    489e:	44 27       	eor	r20, r20
    48a0:	5a 96       	adiw	r26, 0x1a	; 26
    48a2:	8d 91       	ld	r24, X+
    48a4:	9c 91       	ld	r25, X
    48a6:	5b 97       	sbiw	r26, 0x1b	; 27
    48a8:	a0 e0       	ldi	r26, 0x00	; 0
    48aa:	b0 e0       	ldi	r27, 0x00	; 0
    48ac:	84 2b       	or	r24, r20
    48ae:	95 2b       	or	r25, r21
    48b0:	a6 2b       	or	r26, r22
    48b2:	b7 2b       	or	r27, r23
    48b4:	80 93 87 50 	sts	0x5087, r24
    48b8:	90 93 88 50 	sts	0x5088, r25
    48bc:	a0 93 89 50 	sts	0x5089, r26
    48c0:	b0 93 8a 50 	sts	0x508A, r27
				fileSize = dir->fileSize;
    48c4:	f6 01       	movw	r30, r12
    48c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    48c8:	95 8d       	ldd	r25, Z+29	; 0x1d
    48ca:	a6 8d       	ldd	r26, Z+30	; 0x1e
    48cc:	b7 8d       	ldd	r27, Z+31	; 0x1f
    48ce:	80 93 50 40 	sts	0x4050, r24
    48d2:	90 93 51 40 	sts	0x4051, r25
    48d6:	a0 93 52 40 	sts	0x4052, r26
    48da:	b0 93 53 40 	sts	0x4053, r27
			    return (dir);
    48de:	a5 c0       	rjmp	.+330    	; 0x4a2a <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    48e0:	d6 01       	movw	r26, r12
    48e2:	54 96       	adiw	r26, 0x14	; 20
    48e4:	8d 91       	ld	r24, X+
    48e6:	9c 91       	ld	r25, X
    48e8:	55 97       	sbiw	r26, 0x15	; 21
    48ea:	a0 e0       	ldi	r26, 0x00	; 0
    48ec:	b0 e0       	ldi	r27, 0x00	; 0
    48ee:	3c 01       	movw	r6, r24
    48f0:	55 24       	eor	r5, r5
    48f2:	44 24       	eor	r4, r4
    48f4:	f6 01       	movw	r30, r12
    48f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    48f8:	93 8d       	ldd	r25, Z+27	; 0x1b
    48fa:	a0 e0       	ldi	r26, 0x00	; 0
    48fc:	b0 e0       	ldi	r27, 0x00	; 0
    48fe:	48 2a       	or	r4, r24
    4900:	59 2a       	or	r5, r25
    4902:	6a 2a       	or	r6, r26
    4904:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4906:	85 ee       	ldi	r24, 0xE5	; 229
    4908:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    490a:	69 81       	ldd	r22, Y+1	; 0x01
    490c:	7a 81       	ldd	r23, Y+2	; 0x02
    490e:	8b 81       	ldd	r24, Y+3	; 0x03
    4910:	9c 81       	ldd	r25, Y+4	; 0x04
    4912:	46 ed       	ldi	r20, 0xD6	; 214
    4914:	51 e2       	ldi	r21, 0x21	; 33
    4916:	20 e0       	ldi	r18, 0x00	; 0
    4918:	32 e0       	ldi	r19, 0x02	; 2
    491a:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    491e:	d6 01       	movw	r26, r12
    4920:	5c 96       	adiw	r26, 0x1c	; 28
    4922:	4d 91       	ld	r20, X+
    4924:	5d 91       	ld	r21, X+
    4926:	6d 91       	ld	r22, X+
    4928:	7c 91       	ld	r23, X
    492a:	5f 97       	sbiw	r26, 0x1f	; 31
    492c:	80 e0       	ldi	r24, 0x00	; 0
    492e:	0e 94 23 23 	call	0x4646	; 0x4646 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4932:	82 e0       	ldi	r24, 0x02	; 2
    4934:	60 e0       	ldi	r22, 0x00	; 0
    4936:	20 e0       	ldi	r18, 0x00	; 0
    4938:	30 e0       	ldi	r19, 0x00	; 0
    493a:	a9 01       	movw	r20, r18
    493c:	0e 94 24 20 	call	0x4048	; 0x4048 <getSetFreeCluster>
    4940:	dc 01       	movw	r26, r24
    4942:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4944:	48 16       	cp	r4, r24
    4946:	59 06       	cpc	r5, r25
    4948:	6a 06       	cpc	r6, r26
    494a:	7b 06       	cpc	r7, r27
    494c:	30 f4       	brcc	.+12     	; 0x495a <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    494e:	82 e0       	ldi	r24, 0x02	; 2
    4950:	61 e0       	ldi	r22, 0x01	; 1
    4952:	a3 01       	movw	r20, r6
    4954:	92 01       	movw	r18, r4
    4956:	0e 94 24 20 	call	0x4048	; 0x4048 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    495a:	c3 01       	movw	r24, r6
    495c:	b2 01       	movw	r22, r4
    495e:	40 e0       	ldi	r20, 0x00	; 0
    4960:	00 e0       	ldi	r16, 0x00	; 0
    4962:	10 e0       	ldi	r17, 0x00	; 0
    4964:	98 01       	movw	r18, r16
    4966:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
    496a:	6b 01       	movw	r12, r22
    496c:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    496e:	c3 01       	movw	r24, r6
    4970:	b2 01       	movw	r22, r4
    4972:	41 e0       	ldi	r20, 0x01	; 1
    4974:	00 e0       	ldi	r16, 0x00	; 0
    4976:	10 e0       	ldi	r17, 0x00	; 0
    4978:	98 01       	movw	r18, r16
    497a:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    497e:	b7 ef       	ldi	r27, 0xF7	; 247
    4980:	cb 16       	cp	r12, r27
    4982:	bf ef       	ldi	r27, 0xFF	; 255
    4984:	db 06       	cpc	r13, r27
    4986:	bf ef       	ldi	r27, 0xFF	; 255
    4988:	eb 06       	cpc	r14, r27
    498a:	bf e0       	ldi	r27, 0x0F	; 15
    498c:	fb 06       	cpc	r15, r27
    498e:	08 f0       	brcs	.+2      	; 0x4992 <findFiles+0x270>
    4990:	47 c0       	rjmp	.+142    	; 0x4a20 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4992:	26 01       	movw	r4, r12
    4994:	37 01       	movw	r6, r14
    4996:	e1 cf       	rjmp	.-62     	; 0x495a <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4998:	20 5e       	subi	r18, 0xE0	; 224
    499a:	3f 4f       	sbci	r19, 0xFF	; 255
    499c:	80 91 54 40 	lds	r24, 0x4054
    49a0:	90 91 55 40 	lds	r25, 0x4055
    49a4:	28 17       	cp	r18, r24
    49a6:	39 07       	cpc	r19, r25
    49a8:	08 f4       	brcc	.+2      	; 0x49ac <findFiles+0x28a>
    49aa:	26 cf       	rjmp	.-436    	; 0x47f8 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    49ac:	08 94       	sec
    49ae:	41 1c       	adc	r4, r1
    49b0:	51 1c       	adc	r5, r1
    49b2:	61 1c       	adc	r6, r1
    49b4:	71 1c       	adc	r7, r1
    49b6:	80 91 7b 50 	lds	r24, 0x507B
    49ba:	90 91 7c 50 	lds	r25, 0x507C
    49be:	a0 e0       	ldi	r26, 0x00	; 0
    49c0:	b0 e0       	ldi	r27, 0x00	; 0
    49c2:	48 16       	cp	r4, r24
    49c4:	59 06       	cpc	r5, r25
    49c6:	6a 06       	cpc	r6, r26
    49c8:	7b 06       	cpc	r7, r27
    49ca:	08 f4       	brcc	.+2      	; 0x49ce <findFiles+0x2ac>
    49cc:	f2 ce       	rjmp	.-540    	; 0x47b2 <findFiles+0x90>
    49ce:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    49d0:	69 85       	ldd	r22, Y+9	; 0x09
    49d2:	7a 85       	ldd	r23, Y+10	; 0x0a
    49d4:	8b 85       	ldd	r24, Y+11	; 0x0b
    49d6:	9c 85       	ldd	r25, Y+12	; 0x0c
    49d8:	40 e0       	ldi	r20, 0x00	; 0
    49da:	00 e0       	ldi	r16, 0x00	; 0
    49dc:	10 e0       	ldi	r17, 0x00	; 0
    49de:	98 01       	movw	r18, r16
    49e0:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
    49e4:	69 87       	std	Y+9, r22	; 0x09
    49e6:	7a 87       	std	Y+10, r23	; 0x0a
    49e8:	8b 87       	std	Y+11, r24	; 0x0b
    49ea:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    49ec:	67 3f       	cpi	r22, 0xF7	; 247
    49ee:	ef ef       	ldi	r30, 0xFF	; 255
    49f0:	7e 07       	cpc	r23, r30
    49f2:	ef ef       	ldi	r30, 0xFF	; 255
    49f4:	8e 07       	cpc	r24, r30
    49f6:	ef e0       	ldi	r30, 0x0F	; 15
    49f8:	9e 07       	cpc	r25, r30
    49fa:	a8 f4       	brcc	.+42     	; 0x4a26 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    49fc:	61 15       	cp	r22, r1
    49fe:	71 05       	cpc	r23, r1
    4a00:	81 05       	cpc	r24, r1
    4a02:	91 05       	cpc	r25, r1
    4a04:	09 f0       	breq	.+2      	; 0x4a08 <findFiles+0x2e6>
    4a06:	c0 ce       	rjmp	.-640    	; 0x4788 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4a08:	00 e0       	ldi	r16, 0x00	; 0
    4a0a:	10 e0       	ldi	r17, 0x00	; 0
    4a0c:	0e c0       	rjmp	.+28     	; 0x4a2a <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4a0e:	00 e0       	ldi	r16, 0x00	; 0
    4a10:	10 e0       	ldi	r17, 0x00	; 0
    4a12:	0b c0       	rjmp	.+22     	; 0x4a2a <findFiles+0x308>
    4a14:	00 e0       	ldi	r16, 0x00	; 0
    4a16:	10 e0       	ldi	r17, 0x00	; 0
    4a18:	08 c0       	rjmp	.+16     	; 0x4a2a <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4a1a:	00 e0       	ldi	r16, 0x00	; 0
    4a1c:	10 e0       	ldi	r17, 0x00	; 0
    4a1e:	05 c0       	rjmp	.+10     	; 0x4a2a <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4a20:	00 e0       	ldi	r16, 0x00	; 0
    4a22:	10 e0       	ldi	r17, 0x00	; 0
    4a24:	02 c0       	rjmp	.+4      	; 0x4a2a <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4a26:	00 e0       	ldi	r16, 0x00	; 0
    4a28:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4a2a:	80 2f       	mov	r24, r16
    4a2c:	91 2f       	mov	r25, r17
    4a2e:	2c 96       	adiw	r28, 0x0c	; 12
    4a30:	cd bf       	out	0x3d, r28	; 61
    4a32:	de bf       	out	0x3e, r29	; 62
    4a34:	df 91       	pop	r29
    4a36:	cf 91       	pop	r28
    4a38:	1f 91       	pop	r17
    4a3a:	0f 91       	pop	r16
    4a3c:	ff 90       	pop	r15
    4a3e:	ef 90       	pop	r14
    4a40:	df 90       	pop	r13
    4a42:	cf 90       	pop	r12
    4a44:	bf 90       	pop	r11
    4a46:	af 90       	pop	r10
    4a48:	9f 90       	pop	r9
    4a4a:	8f 90       	pop	r8
    4a4c:	7f 90       	pop	r7
    4a4e:	6f 90       	pop	r6
    4a50:	5f 90       	pop	r5
    4a52:	4f 90       	pop	r4
    4a54:	3f 90       	pop	r3
    4a56:	2f 90       	pop	r2
    4a58:	08 95       	ret

00004a5a <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4a5a:	0e 94 b1 21 	call	0x4362	; 0x4362 <convertFileName>
  if(error) return;
    4a5e:	88 23       	and	r24, r24
    4a60:	29 f4       	brne	.+10     	; 0x4a6c <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4a62:	82 e0       	ldi	r24, 0x02	; 2
    4a64:	6b eb       	ldi	r22, 0xBB	; 187
    4a66:	70 e5       	ldi	r23, 0x50	; 80
    4a68:	0e 94 91 23 	call	0x4722	; 0x4722 <findFiles>
    4a6c:	08 95       	ret

00004a6e <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4a6e:	4f 92       	push	r4
    4a70:	5f 92       	push	r5
    4a72:	6f 92       	push	r6
    4a74:	7f 92       	push	r7
    4a76:	af 92       	push	r10
    4a78:	bf 92       	push	r11
    4a7a:	cf 92       	push	r12
    4a7c:	df 92       	push	r13
    4a7e:	ef 92       	push	r14
    4a80:	ff 92       	push	r15
    4a82:	0f 93       	push	r16
    4a84:	1f 93       	push	r17
    4a86:	cf 93       	push	r28
    4a88:	c8 2f       	mov	r28, r24
    4a8a:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4a8c:	0e 94 b1 21 	call	0x4362	; 0x4362 <convertFileName>
if(error) return 2;
    4a90:	88 23       	and	r24, r24
    4a92:	09 f0       	breq	.+2      	; 0x4a96 <readFile+0x28>
    4a94:	57 c0       	rjmp	.+174    	; 0x4b44 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4a96:	81 e0       	ldi	r24, 0x01	; 1
    4a98:	6b eb       	ldi	r22, 0xBB	; 187
    4a9a:	70 e5       	ldi	r23, 0x50	; 80
    4a9c:	0e 94 91 23 	call	0x4722	; 0x4722 <findFiles>
    4aa0:	fc 01       	movw	r30, r24
if(dir == 0) 
    4aa2:	00 97       	sbiw	r24, 0x00	; 0
    4aa4:	31 f4       	brne	.+12     	; 0x4ab2 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4aa6:	81 e0       	ldi	r24, 0x01	; 1
    4aa8:	cc 23       	and	r28, r28
    4aaa:	09 f4       	brne	.+2      	; 0x4aae <readFile+0x40>
    4aac:	4e c0       	rjmp	.+156    	; 0x4b4a <readFile+0xdc>
    4aae:	80 e0       	ldi	r24, 0x00	; 0
    4ab0:	4c c0       	rjmp	.+152    	; 0x4b4a <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4ab2:	c1 30       	cpi	r28, 0x01	; 1
    4ab4:	09 f4       	brne	.+2      	; 0x4ab8 <readFile+0x4a>
    4ab6:	48 c0       	rjmp	.+144    	; 0x4b48 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4ab8:	44 88       	ldd	r4, Z+20	; 0x14
    4aba:	55 88       	ldd	r5, Z+21	; 0x15
    4abc:	66 24       	eor	r6, r6
    4abe:	77 24       	eor	r7, r7
    4ac0:	32 01       	movw	r6, r4
    4ac2:	55 24       	eor	r5, r5
    4ac4:	44 24       	eor	r4, r4
    4ac6:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ac8:	93 8d       	ldd	r25, Z+27	; 0x1b
    4aca:	a0 e0       	ldi	r26, 0x00	; 0
    4acc:	b0 e0       	ldi	r27, 0x00	; 0
    4ace:	48 2a       	or	r4, r24
    4ad0:	59 2a       	or	r5, r25
    4ad2:	6a 2a       	or	r6, r26
    4ad4:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4ad6:	0f 2e       	mov	r0, r31
    4ad8:	ff ed       	ldi	r31, 0xDF	; 223
    4ada:	af 2e       	mov	r10, r31
    4adc:	f3 e2       	ldi	r31, 0x23	; 35
    4ade:	bf 2e       	mov	r11, r31
    4ae0:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4ae2:	c3 01       	movw	r24, r6
    4ae4:	b2 01       	movw	r22, r4
    4ae6:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <getFirstSector>
    4aea:	6b 01       	movw	r12, r22
    4aec:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4aee:	80 91 7b 50 	lds	r24, 0x507B
    4af2:	90 91 7c 50 	lds	r25, 0x507C
    4af6:	00 97       	sbiw	r24, 0x00	; 0
    4af8:	a1 f0       	breq	.+40     	; 0x4b22 <readFile+0xb4>
    4afa:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4afc:	c7 01       	movw	r24, r14
    4afe:	b6 01       	movw	r22, r12
    4b00:	6c 0f       	add	r22, r28
    4b02:	71 1d       	adc	r23, r1
    4b04:	81 1d       	adc	r24, r1
    4b06:	91 1d       	adc	r25, r1
    4b08:	a5 01       	movw	r20, r10
    4b0a:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4b0e:	cf 5f       	subi	r28, 0xFF	; 255
    4b10:	80 91 7b 50 	lds	r24, 0x507B
    4b14:	90 91 7c 50 	lds	r25, 0x507C
    4b18:	2c 2f       	mov	r18, r28
    4b1a:	30 e0       	ldi	r19, 0x00	; 0
    4b1c:	28 17       	cp	r18, r24
    4b1e:	39 07       	cpc	r19, r25
    4b20:	68 f3       	brcs	.-38     	; 0x4afc <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4b22:	c3 01       	movw	r24, r6
    4b24:	b2 01       	movw	r22, r4
    4b26:	40 e0       	ldi	r20, 0x00	; 0
    4b28:	00 e0       	ldi	r16, 0x00	; 0
    4b2a:	10 e0       	ldi	r17, 0x00	; 0
    4b2c:	98 01       	movw	r18, r16
    4b2e:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
    4b32:	2b 01       	movw	r4, r22
    4b34:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4b36:	61 15       	cp	r22, r1
    4b38:	71 05       	cpc	r23, r1
    4b3a:	81 05       	cpc	r24, r1
    4b3c:	91 05       	cpc	r25, r1
    4b3e:	89 f6       	brne	.-94     	; 0x4ae2 <readFile+0x74>
	  return 0;}
    4b40:	80 e0       	ldi	r24, 0x00	; 0
    4b42:	03 c0       	rjmp	.+6      	; 0x4b4a <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4b44:	82 e0       	ldi	r24, 0x02	; 2
    4b46:	01 c0       	rjmp	.+2      	; 0x4b4a <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4b48:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4b4a:	cf 91       	pop	r28
    4b4c:	1f 91       	pop	r17
    4b4e:	0f 91       	pop	r16
    4b50:	ff 90       	pop	r15
    4b52:	ef 90       	pop	r14
    4b54:	df 90       	pop	r13
    4b56:	cf 90       	pop	r12
    4b58:	bf 90       	pop	r11
    4b5a:	af 90       	pop	r10
    4b5c:	7f 90       	pop	r7
    4b5e:	6f 90       	pop	r6
    4b60:	5f 90       	pop	r5
    4b62:	4f 90       	pop	r4
    4b64:	08 95       	ret

00004b66 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4b66:	2f 92       	push	r2
    4b68:	3f 92       	push	r3
    4b6a:	4f 92       	push	r4
    4b6c:	5f 92       	push	r5
    4b6e:	6f 92       	push	r6
    4b70:	7f 92       	push	r7
    4b72:	8f 92       	push	r8
    4b74:	9f 92       	push	r9
    4b76:	af 92       	push	r10
    4b78:	bf 92       	push	r11
    4b7a:	cf 92       	push	r12
    4b7c:	df 92       	push	r13
    4b7e:	ef 92       	push	r14
    4b80:	ff 92       	push	r15
    4b82:	0f 93       	push	r16
    4b84:	1f 93       	push	r17
    4b86:	cf 93       	push	r28
    4b88:	df 93       	push	r29
    4b8a:	cd b7       	in	r28, 0x3d	; 61
    4b8c:	de b7       	in	r29, 0x3e	; 62
    4b8e:	60 97       	sbiw	r28, 0x10	; 16
    4b90:	cd bf       	out	0x3d, r28	; 61
    4b92:	de bf       	out	0x3e, r29	; 62
    4b94:	fc 01       	movw	r30, r24
    4b96:	6d 83       	std	Y+5, r22	; 0x05
    4b98:	7e 83       	std	Y+6, r23	; 0x06
    4b9a:	49 01       	movw	r8, r18
    4b9c:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	bf 01       	movw	r22, r30
    4ba2:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <readFile>

if(j == 1) 
    4ba6:	81 30       	cpi	r24, 0x01	; 1
    4ba8:	09 f0       	breq	.+2      	; 0x4bac <writeFile+0x46>
    4baa:	7b c0       	rjmp	.+246    	; 0x4ca2 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4bac:	00 91 87 50 	lds	r16, 0x5087
    4bb0:	10 91 88 50 	lds	r17, 0x5088
    4bb4:	20 91 89 50 	lds	r18, 0x5089
    4bb8:	30 91 8a 50 	lds	r19, 0x508A
    4bbc:	09 83       	std	Y+1, r16	; 0x01
    4bbe:	1a 83       	std	Y+2, r17	; 0x02
    4bc0:	2b 83       	std	Y+3, r18	; 0x03
    4bc2:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4bc4:	cc 24       	eor	r12, r12
    4bc6:	dd 24       	eor	r13, r13
    4bc8:	76 01       	movw	r14, r12
    4bca:	24 01       	movw	r4, r8
    4bcc:	35 01       	movw	r6, r10
    4bce:	48 01       	movw	r8, r16
    4bd0:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4bd2:	c5 01       	movw	r24, r10
    4bd4:	b4 01       	movw	r22, r8
    4bd6:	40 e0       	ldi	r20, 0x00	; 0
    4bd8:	00 e0       	ldi	r16, 0x00	; 0
    4bda:	10 e0       	ldi	r17, 0x00	; 0
    4bdc:	98 01       	movw	r18, r16
    4bde:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
    4be2:	dc 01       	movw	r26, r24
    4be4:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4be6:	8f 3f       	cpi	r24, 0xFF	; 255
    4be8:	1f ef       	ldi	r17, 0xFF	; 255
    4bea:	91 07       	cpc	r25, r17
    4bec:	1f ef       	ldi	r17, 0xFF	; 255
    4bee:	a1 07       	cpc	r26, r17
    4bf0:	1f ef       	ldi	r17, 0xFF	; 255
    4bf2:	b1 07       	cpc	r27, r17
    4bf4:	41 f0       	breq	.+16     	; 0x4c06 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4bf6:	08 94       	sec
    4bf8:	c1 1c       	adc	r12, r1
    4bfa:	d1 1c       	adc	r13, r1
    4bfc:	e1 1c       	adc	r14, r1
    4bfe:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4c00:	4c 01       	movw	r8, r24
    4c02:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4c04:	e6 cf       	rjmp	.-52     	; 0x4bd2 <writeFile+0x6c>
    4c06:	89 82       	std	Y+1, r8	; 0x01
    4c08:	9a 82       	std	Y+2, r9	; 0x02
    4c0a:	ab 82       	std	Y+3, r10	; 0x03
    4c0c:	bc 82       	std	Y+4, r11	; 0x04
    4c0e:	53 01       	movw	r10, r6
    4c10:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4c12:	20 91 7b 50 	lds	r18, 0x507B
    4c16:	30 91 7c 50 	lds	r19, 0x507C
    4c1a:	80 91 54 40 	lds	r24, 0x4054
    4c1e:	90 91 55 40 	lds	r25, 0x4055
    4c22:	60 90 54 40 	lds	r6, 0x4054
    4c26:	70 90 55 40 	lds	r7, 0x4055
    4c2a:	bc 01       	movw	r22, r24
    4c2c:	80 e0       	ldi	r24, 0x00	; 0
    4c2e:	90 e0       	ldi	r25, 0x00	; 0
    4c30:	40 e0       	ldi	r20, 0x00	; 0
    4c32:	50 e0       	ldi	r21, 0x00	; 0
    4c34:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    4c38:	a7 01       	movw	r20, r14
    4c3a:	96 01       	movw	r18, r12
    4c3c:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    4c40:	dc 01       	movw	r26, r24
    4c42:	cb 01       	movw	r24, r22
    4c44:	40 91 50 40 	lds	r20, 0x4050
    4c48:	50 91 51 40 	lds	r21, 0x4051
    4c4c:	60 91 52 40 	lds	r22, 0x4052
    4c50:	70 91 53 40 	lds	r23, 0x4053
    4c54:	8a 01       	movw	r16, r20
    4c56:	9b 01       	movw	r18, r22
    4c58:	08 1b       	sub	r16, r24
    4c5a:	19 0b       	sbc	r17, r25
    4c5c:	2a 0b       	sbc	r18, r26
    4c5e:	3b 0b       	sbc	r19, r27
    4c60:	c9 01       	movw	r24, r18
    4c62:	b8 01       	movw	r22, r16
    4c64:	93 01       	movw	r18, r6
    4c66:	40 e0       	ldi	r20, 0x00	; 0
    4c68:	50 e0       	ldi	r21, 0x00	; 0
    4c6a:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    4c6e:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4c70:	69 81       	ldd	r22, Y+1	; 0x01
    4c72:	7a 81       	ldd	r23, Y+2	; 0x02
    4c74:	8b 81       	ldd	r24, Y+3	; 0x03
    4c76:	9c 81       	ldd	r25, Y+4	; 0x04
    4c78:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <getFirstSector>
    4c7c:	dc 01       	movw	r26, r24
    4c7e:	cb 01       	movw	r24, r22
    4c80:	20 2e       	mov	r2, r16
    4c82:	33 24       	eor	r3, r3
    4c84:	28 0e       	add	r2, r24
    4c86:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4c88:	b1 01       	movw	r22, r2
    4c8a:	80 e0       	ldi	r24, 0x00	; 0
    4c8c:	90 e0       	ldi	r25, 0x00	; 0
    4c8e:	46 ed       	ldi	r20, 0xD6	; 214
    4c90:	51 e2       	ldi	r21, 0x21	; 33
    4c92:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4c96:	1f 86       	std	Y+15, r1	; 0x0f
    4c98:	18 8a       	std	Y+16, r1	; 0x10
    4c9a:	19 86       	std	Y+9, r1	; 0x09
    4c9c:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4c9e:	11 e0       	ldi	r17, 0x01	; 1
    4ca0:	4c c0       	rjmp	.+152    	; 0x4d3a <writeFile+0x1d4>
}
else if(j == 2) 
    4ca2:	82 30       	cpi	r24, 0x02	; 2
    4ca4:	09 f4       	brne	.+2      	; 0x4ca8 <writeFile+0x142>
    4ca6:	0c c2       	rjmp	.+1048   	; 0x50c0 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4ca8:	82 e0       	ldi	r24, 0x02	; 2
    4caa:	60 e0       	ldi	r22, 0x00	; 0
    4cac:	20 e0       	ldi	r18, 0x00	; 0
    4cae:	30 e0       	ldi	r19, 0x00	; 0
    4cb0:	a9 01       	movw	r20, r18
    4cb2:	0e 94 24 20 	call	0x4048	; 0x4048 <getSetFreeCluster>
  if(cluster > totalClusters)
    4cb6:	00 91 59 40 	lds	r16, 0x4059
    4cba:	10 91 5a 40 	lds	r17, 0x405A
    4cbe:	20 91 5b 40 	lds	r18, 0x405B
    4cc2:	30 91 5c 40 	lds	r19, 0x405C
    4cc6:	06 17       	cp	r16, r22
    4cc8:	17 07       	cpc	r17, r23
    4cca:	28 07       	cpc	r18, r24
    4ccc:	39 07       	cpc	r19, r25
    4cce:	40 f4       	brcc	.+16     	; 0x4ce0 <writeFile+0x17a>
     cluster = rootCluster;
    4cd0:	60 91 5f 40 	lds	r22, 0x405F
    4cd4:	70 91 60 40 	lds	r23, 0x4060
    4cd8:	80 91 61 40 	lds	r24, 0x4061
    4cdc:	90 91 62 40 	lds	r25, 0x4062

  cluster = searchNextFreeCluster(cluster);
    4ce0:	0e 94 70 22 	call	0x44e0	; 0x44e0 <searchNextFreeCluster>
    4ce4:	69 83       	std	Y+1, r22	; 0x01
    4ce6:	7a 83       	std	Y+2, r23	; 0x02
    4ce8:	8b 83       	std	Y+3, r24	; 0x03
    4cea:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4cec:	61 15       	cp	r22, r1
    4cee:	71 05       	cpc	r23, r1
    4cf0:	81 05       	cpc	r24, r1
    4cf2:	91 05       	cpc	r25, r1
    4cf4:	09 f4       	brne	.+2      	; 0x4cf8 <writeFile+0x192>
    4cf6:	e6 c1       	rjmp	.+972    	; 0x50c4 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4cf8:	41 e0       	ldi	r20, 0x01	; 1
    4cfa:	0f ef       	ldi	r16, 0xFF	; 255
    4cfc:	1f ef       	ldi	r17, 0xFF	; 255
    4cfe:	98 01       	movw	r18, r16
    4d00:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4d04:	2b 81       	ldd	r18, Y+3	; 0x03
    4d06:	3c 81       	ldd	r19, Y+4	; 0x04
    4d08:	29 87       	std	Y+9, r18	; 0x09
    4d0a:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4d0c:	89 81       	ldd	r24, Y+1	; 0x01
    4d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d10:	8f 87       	std	Y+15, r24	; 0x0f
    4d12:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4d14:	10 92 50 40 	sts	0x4050, r1
    4d18:	10 92 51 40 	sts	0x4051, r1
    4d1c:	10 92 52 40 	sts	0x4052, r1
    4d20:	10 92 53 40 	sts	0x4053, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4d24:	69 81       	ldd	r22, Y+1	; 0x01
    4d26:	7a 81       	ldd	r23, Y+2	; 0x02
    4d28:	8b 81       	ldd	r24, Y+3	; 0x03
    4d2a:	9c 81       	ldd	r25, Y+4	; 0x04
    4d2c:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <getFirstSector>
    4d30:	dc 01       	movw	r26, r24
    4d32:	cb 01       	movw	r24, r22
    4d34:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4d36:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4d38:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4d3a:	81 14       	cp	r8, r1
    4d3c:	91 04       	cpc	r9, r1
    4d3e:	a1 04       	cpc	r10, r1
    4d40:	b1 04       	cpc	r11, r1
    4d42:	09 f4       	brne	.+2      	; 0x4d46 <writeFile+0x1e0>
    4d44:	8d c0       	rjmp	.+282    	; 0x4e60 <writeFile+0x2fa>
    4d46:	44 24       	eor	r4, r4
    4d48:	55 24       	eor	r5, r5
    4d4a:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4d4c:	c0 2e       	mov	r12, r16
    4d4e:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4d50:	90 e0       	ldi	r25, 0x00	; 0
    4d52:	89 16       	cp	r8, r25
    4d54:	92 e0       	ldi	r25, 0x02	; 2
    4d56:	99 06       	cpc	r9, r25
    4d58:	90 e0       	ldi	r25, 0x00	; 0
    4d5a:	a9 06       	cpc	r10, r25
    4d5c:	90 e0       	ldi	r25, 0x00	; 0
    4d5e:	b9 06       	cpc	r11, r25
    4d60:	88 f0       	brcs	.+34     	; 0x4d84 <writeFile+0x21e>
		 writtenData += 512;
    4d62:	00 e0       	ldi	r16, 0x00	; 0
    4d64:	12 e0       	ldi	r17, 0x02	; 2
    4d66:	20 e0       	ldi	r18, 0x00	; 0
    4d68:	30 e0       	ldi	r19, 0x00	; 0
    4d6a:	40 0e       	add	r4, r16
    4d6c:	51 1e       	adc	r5, r17
    4d6e:	62 1e       	adc	r6, r18
    4d70:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4d72:	80 e0       	ldi	r24, 0x00	; 0
    4d74:	9e ef       	ldi	r25, 0xFE	; 254
    4d76:	af ef       	ldi	r26, 0xFF	; 255
    4d78:	bf ef       	ldi	r27, 0xFF	; 255
    4d7a:	88 0e       	add	r8, r24
    4d7c:	99 1e       	adc	r9, r25
    4d7e:	aa 1e       	adc	r10, r26
    4d80:	bb 1e       	adc	r11, r27
    4d82:	0c c0       	rjmp	.+24     	; 0x4d9c <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4d84:	48 0c       	add	r4, r8
    4d86:	59 1c       	adc	r5, r9
    4d88:	6a 1c       	adc	r6, r10
    4d8a:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4d8c:	95 01       	movw	r18, r10
    4d8e:	84 01       	movw	r16, r8
    4d90:	11 70       	andi	r17, 0x01	; 1
    4d92:	20 70       	andi	r18, 0x00	; 0
    4d94:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4d96:	88 24       	eor	r8, r8
    4d98:	99 24       	eor	r9, r9
    4d9a:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4d9c:	80 91 50 40 	lds	r24, 0x4050
    4da0:	90 91 51 40 	lds	r25, 0x4051
    4da4:	a0 91 52 40 	lds	r26, 0x4052
    4da8:	b0 91 53 40 	lds	r27, 0x4053
    4dac:	80 50       	subi	r24, 0x00	; 0
    4dae:	9e 4f       	sbci	r25, 0xFE	; 254
    4db0:	af 4f       	sbci	r26, 0xFF	; 255
    4db2:	bf 4f       	sbci	r27, 0xFF	; 255
    4db4:	80 93 50 40 	sts	0x4050, r24
    4db8:	90 93 51 40 	sts	0x4051, r25
    4dbc:	a0 93 52 40 	sts	0x4052, r26
    4dc0:	b0 93 53 40 	sts	0x4053, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4dc4:	b1 01       	movw	r22, r2
    4dc6:	80 e0       	ldi	r24, 0x00	; 0
    4dc8:	90 e0       	ldi	r25, 0x00	; 0
    4dca:	a2 01       	movw	r20, r4
    4dcc:	40 1b       	sub	r20, r16
    4dce:	51 0b       	sbc	r21, r17
    4dd0:	ad 81       	ldd	r26, Y+5	; 0x05
    4dd2:	be 81       	ldd	r27, Y+6	; 0x06
    4dd4:	4a 0f       	add	r20, r26
    4dd6:	5b 1f       	adc	r21, r27
    4dd8:	98 01       	movw	r18, r16
    4dda:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_write_block>
	j++;
    4dde:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4de0:	20 91 7b 50 	lds	r18, 0x507B
    4de4:	30 91 7c 50 	lds	r19, 0x507C
    4de8:	8c 2d       	mov	r24, r12
    4dea:	90 e0       	ldi	r25, 0x00	; 0
    4dec:	82 17       	cp	r24, r18
    4dee:	93 07       	cpc	r25, r19
    4df0:	29 f5       	brne	.+74     	; 0x4e3c <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4df2:	69 81       	ldd	r22, Y+1	; 0x01
    4df4:	7a 81       	ldd	r23, Y+2	; 0x02
    4df6:	8b 81       	ldd	r24, Y+3	; 0x03
    4df8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dfa:	0e 94 70 22 	call	0x44e0	; 0x44e0 <searchNextFreeCluster>
    4dfe:	6b 01       	movw	r12, r22
    4e00:	7c 01       	movw	r14, r24
		if(cluster == 0){
    4e02:	61 15       	cp	r22, r1
    4e04:	71 05       	cpc	r23, r1
    4e06:	81 05       	cpc	r24, r1
    4e08:	91 05       	cpc	r25, r1
    4e0a:	09 f4       	brne	.+2      	; 0x4e0e <writeFile+0x2a8>
    4e0c:	5d c1       	rjmp	.+698    	; 0x50c8 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    4e0e:	69 81       	ldd	r22, Y+1	; 0x01
    4e10:	7a 81       	ldd	r23, Y+2	; 0x02
    4e12:	8b 81       	ldd	r24, Y+3	; 0x03
    4e14:	9c 81       	ldd	r25, Y+4	; 0x04
    4e16:	41 e0       	ldi	r20, 0x01	; 1
    4e18:	97 01       	movw	r18, r14
    4e1a:	86 01       	movw	r16, r12
    4e1c:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    4e20:	c7 01       	movw	r24, r14
    4e22:	b6 01       	movw	r22, r12
    4e24:	41 e0       	ldi	r20, 0x01	; 1
    4e26:	0f ef       	ldi	r16, 0xFF	; 255
    4e28:	1f ef       	ldi	r17, 0xFF	; 255
    4e2a:	98 01       	movw	r18, r16
    4e2c:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4e30:	c9 82       	std	Y+1, r12	; 0x01
    4e32:	da 82       	std	Y+2, r13	; 0x02
    4e34:	eb 82       	std	Y+3, r14	; 0x03
    4e36:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    4e38:	cc 24       	eor	r12, r12
    4e3a:	03 c0       	rjmp	.+6      	; 0x4e42 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    4e3c:	08 94       	sec
    4e3e:	21 1c       	adc	r2, r1
    4e40:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    4e42:	82 e0       	ldi	r24, 0x02	; 2
    4e44:	61 e0       	ldi	r22, 0x01	; 1
    4e46:	29 81       	ldd	r18, Y+1	; 0x01
    4e48:	3a 81       	ldd	r19, Y+2	; 0x02
    4e4a:	4b 81       	ldd	r20, Y+3	; 0x03
    4e4c:	5c 81       	ldd	r21, Y+4	; 0x04
    4e4e:	0e 94 24 20 	call	0x4048	; 0x4048 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4e52:	81 14       	cp	r8, r1
    4e54:	91 04       	cpc	r9, r1
    4e56:	a1 04       	cpc	r10, r1
    4e58:	b1 04       	cpc	r11, r1
    4e5a:	09 f0       	breq	.+2      	; 0x4e5e <writeFile+0x2f8>
    4e5c:	79 cf       	rjmp	.-270    	; 0x4d50 <writeFile+0x1ea>
    4e5e:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    4e60:	11 23       	and	r17, r17
    4e62:	09 f4       	brne	.+2      	; 0x4e66 <writeFile+0x300>
    4e64:	3f c0       	rjmp	.+126    	; 0x4ee4 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    4e66:	60 91 d1 50 	lds	r22, 0x50D1
    4e6a:	70 91 d2 50 	lds	r23, 0x50D2
    4e6e:	80 91 d3 50 	lds	r24, 0x50D3
    4e72:	90 91 d4 50 	lds	r25, 0x50D4
    4e76:	06 ed       	ldi	r16, 0xD6	; 214
    4e78:	11 e2       	ldi	r17, 0x21	; 33
    4e7a:	a8 01       	movw	r20, r16
    4e7c:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4e80:	e0 91 d7 23 	lds	r30, 0x23D7
    4e84:	f0 91 d8 23 	lds	r31, 0x23D8
    4e88:	e0 0f       	add	r30, r16
    4e8a:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4e8c:	12 8a       	std	Z+18, r1	; 0x12
    4e8e:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4e90:	80 91 50 40 	lds	r24, 0x4050
    4e94:	90 91 51 40 	lds	r25, 0x4051
    4e98:	a0 91 52 40 	lds	r26, 0x4052
    4e9c:	b0 91 53 40 	lds	r27, 0x4053
    4ea0:	44 8d       	ldd	r20, Z+28	; 0x1c
    4ea2:	55 8d       	ldd	r21, Z+29	; 0x1d
    4ea4:	66 8d       	ldd	r22, Z+30	; 0x1e
    4ea6:	77 8d       	ldd	r23, Z+31	; 0x1f
    4ea8:	6c 01       	movw	r12, r24
    4eaa:	7d 01       	movw	r14, r26
    4eac:	c4 1a       	sub	r12, r20
    4eae:	d5 0a       	sbc	r13, r21
    4eb0:	e6 0a       	sbc	r14, r22
    4eb2:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4eb4:	84 8f       	std	Z+28, r24	; 0x1c
    4eb6:	95 8f       	std	Z+29, r25	; 0x1d
    4eb8:	a6 8f       	std	Z+30, r26	; 0x1e
    4eba:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4ebc:	60 91 d1 50 	lds	r22, 0x50D1
    4ec0:	70 91 d2 50 	lds	r23, 0x50D2
    4ec4:	80 91 d3 50 	lds	r24, 0x50D3
    4ec8:	90 91 d4 50 	lds	r25, 0x50D4
    4ecc:	a8 01       	movw	r20, r16
    4ece:	20 e0       	ldi	r18, 0x00	; 0
    4ed0:	32 e0       	ldi	r19, 0x02	; 2
    4ed2:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    4ed6:	81 e0       	ldi	r24, 0x01	; 1
    4ed8:	b7 01       	movw	r22, r14
    4eda:	a6 01       	movw	r20, r12
    4edc:	0e 94 23 23 	call	0x4646	; 0x4646 <freeMemoryUpdate>

 //File appended!
  return 0;
    4ee0:	80 e0       	ldi	r24, 0x00	; 0
    4ee2:	f9 c0       	rjmp	.+498    	; 0x50d6 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    4ee4:	00 91 5f 40 	lds	r16, 0x405F
    4ee8:	10 91 60 40 	lds	r17, 0x4060
    4eec:	20 91 61 40 	lds	r18, 0x4061
    4ef0:	30 91 62 40 	lds	r19, 0x4062
    4ef4:	0b 87       	std	Y+11, r16	; 0x0b
    4ef6:	1c 87       	std	Y+12, r17	; 0x0c
    4ef8:	2d 87       	std	Y+13, r18	; 0x0d
    4efa:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4efc:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4efe:	8b eb       	ldi	r24, 0xBB	; 187
    4f00:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4f02:	0f 2e       	mov	r0, r31
    4f04:	fb e0       	ldi	r31, 0x0B	; 11
    4f06:	af 2e       	mov	r10, r31
    4f08:	bb 24       	eor	r11, r11
    4f0a:	f0 2d       	mov	r31, r0
    4f0c:	a8 0e       	add	r10, r24
    4f0e:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4f10:	88 24       	eor	r8, r8
    4f12:	68 94       	set
    4f14:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4f16:	0f 2e       	mov	r0, r31
    4f18:	f6 ed       	ldi	r31, 0xD6	; 214
    4f1a:	4f 2e       	mov	r4, r31
    4f1c:	f1 e2       	ldi	r31, 0x21	; 33
    4f1e:	5f 2e       	mov	r5, r31
    4f20:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4f22:	28 2e       	mov	r2, r24
    4f24:	99 2e       	mov	r9, r25
    4f26:	37 2c       	mov	r3, r7
    4f28:	6f 84       	ldd	r6, Y+15	; 0x0f
    4f2a:	78 88       	ldd	r7, Y+16	; 0x10
    4f2c:	04 c0       	rjmp	.+8      	; 0x4f36 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    4f2e:	cb 86       	std	Y+11, r12	; 0x0b
    4f30:	dc 86       	std	Y+12, r13	; 0x0c
    4f32:	ed 86       	std	Y+13, r14	; 0x0d
    4f34:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    4f36:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f38:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f3a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f3c:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f3e:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <getFirstSector>
    4f42:	6d 83       	std	Y+5, r22	; 0x05
    4f44:	7e 83       	std	Y+6, r23	; 0x06
    4f46:	8f 83       	std	Y+7, r24	; 0x07
    4f48:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4f4a:	80 91 7b 50 	lds	r24, 0x507B
    4f4e:	90 91 7c 50 	lds	r25, 0x507C
    4f52:	00 97       	sbiw	r24, 0x00	; 0
    4f54:	09 f4       	brne	.+2      	; 0x4f58 <writeFile+0x3f2>
    4f56:	77 c0       	rjmp	.+238    	; 0x5046 <writeFile+0x4e0>
    4f58:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4f5a:	cd 80       	ldd	r12, Y+5	; 0x05
    4f5c:	de 80       	ldd	r13, Y+6	; 0x06
    4f5e:	ef 80       	ldd	r14, Y+7	; 0x07
    4f60:	f8 84       	ldd	r15, Y+8	; 0x08
    4f62:	19 81       	ldd	r17, Y+1	; 0x01
    4f64:	c1 0e       	add	r12, r17
    4f66:	d1 1c       	adc	r13, r1
    4f68:	e1 1c       	adc	r14, r1
    4f6a:	f1 1c       	adc	r15, r1
    4f6c:	c7 01       	movw	r24, r14
    4f6e:	b6 01       	movw	r22, r12
    4f70:	a2 01       	movw	r20, r4
    4f72:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    4f76:	80 91 54 40 	lds	r24, 0x4054
    4f7a:	90 91 55 40 	lds	r25, 0x4055
    4f7e:	00 97       	sbiw	r24, 0x00	; 0
    4f80:	09 f4       	brne	.+2      	; 0x4f84 <writeFile+0x41e>
    4f82:	54 c0       	rjmp	.+168    	; 0x502c <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4f84:	33 20       	and	r3, r3
    4f86:	09 f0       	breq	.+2      	; 0x4f8a <writeFile+0x424>
    4f88:	a1 c0       	rjmp	.+322    	; 0x50cc <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4f8a:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4f8c:	00 e0       	ldi	r16, 0x00	; 0
    4f8e:	10 e0       	ldi	r17, 0x00	; 0
    4f90:	06 c0       	rjmp	.+12     	; 0x4f9e <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4f92:	a8 01       	movw	r20, r16
    4f94:	4a 52       	subi	r20, 0x2A	; 42
    4f96:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4f98:	22 23       	and	r18, r18
    4f9a:	09 f0       	breq	.+2      	; 0x4f9e <writeFile+0x438>
    4f9c:	99 c0       	rjmp	.+306    	; 0x50d0 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4f9e:	da 01       	movw	r26, r20
    4fa0:	8c 91       	ld	r24, X
    4fa2:	88 23       	and	r24, r24
    4fa4:	21 f4       	brne	.+8      	; 0x4fae <writeFile+0x448>
    4fa6:	e2 2d       	mov	r30, r2
    4fa8:	f9 2d       	mov	r31, r9
    4faa:	da 01       	movw	r26, r20
    4fac:	04 c0       	rjmp	.+8      	; 0x4fb6 <writeFile+0x450>
    4fae:	85 3e       	cpi	r24, 0xE5	; 229
    4fb0:	d1 f3       	breq	.-12     	; 0x4fa6 <writeFile+0x440>
    4fb2:	23 2d       	mov	r18, r3
    4fb4:	30 c0       	rjmp	.+96     	; 0x5016 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    4fb6:	81 91       	ld	r24, Z+
    4fb8:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    4fba:	ea 15       	cp	r30, r10
    4fbc:	fb 05       	cpc	r31, r11
    4fbe:	d9 f7       	brne	.-10     	; 0x4fb6 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4fc0:	fa 01       	movw	r30, r20
    4fc2:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    4fc4:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    4fc6:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    4fc8:	12 8a       	std	Z+18, r1	; 0x12
    4fca:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    4fcc:	29 85       	ldd	r18, Y+9	; 0x09
    4fce:	3a 85       	ldd	r19, Y+10	; 0x0a
    4fd0:	24 8b       	std	Z+20, r18	; 0x14
    4fd2:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    4fd4:	62 8e       	std	Z+26, r6	; 0x1a
    4fd6:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    4fd8:	80 91 50 40 	lds	r24, 0x4050
    4fdc:	90 91 51 40 	lds	r25, 0x4051
    4fe0:	a0 91 52 40 	lds	r26, 0x4052
    4fe4:	b0 91 53 40 	lds	r27, 0x4053
    4fe8:	84 8f       	std	Z+28, r24	; 0x1c
    4fea:	95 8f       	std	Z+29, r25	; 0x1d
    4fec:	a6 8f       	std	Z+30, r26	; 0x1e
    4fee:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    4ff0:	c7 01       	movw	r24, r14
    4ff2:	b6 01       	movw	r22, r12
    4ff4:	a2 01       	movw	r20, r4
    4ff6:	20 e0       	ldi	r18, 0x00	; 0
    4ff8:	32 e0       	ldi	r19, 0x02	; 2
    4ffa:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    4ffe:	40 91 50 40 	lds	r20, 0x4050
    5002:	50 91 51 40 	lds	r21, 0x4051
    5006:	60 91 52 40 	lds	r22, 0x4052
    500a:	70 91 53 40 	lds	r23, 0x4053
    500e:	81 e0       	ldi	r24, 0x01	; 1
    5010:	0e 94 23 23 	call	0x4646	; 0x4646 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    5014:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5016:	00 5e       	subi	r16, 0xE0	; 224
    5018:	1f 4f       	sbci	r17, 0xFF	; 255
    501a:	80 91 54 40 	lds	r24, 0x4054
    501e:	90 91 55 40 	lds	r25, 0x4055
    5022:	08 17       	cp	r16, r24
    5024:	19 07       	cpc	r17, r25
    5026:	08 f4       	brcc	.+2      	; 0x502a <writeFile+0x4c4>
    5028:	b4 cf       	rjmp	.-152    	; 0x4f92 <writeFile+0x42c>
    502a:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    502c:	09 81       	ldd	r16, Y+1	; 0x01
    502e:	0f 5f       	subi	r16, 0xFF	; 255
    5030:	09 83       	std	Y+1, r16	; 0x01
    5032:	20 91 7b 50 	lds	r18, 0x507B
    5036:	30 91 7c 50 	lds	r19, 0x507C
    503a:	80 2f       	mov	r24, r16
    503c:	90 e0       	ldi	r25, 0x00	; 0
    503e:	82 17       	cp	r24, r18
    5040:	93 07       	cpc	r25, r19
    5042:	08 f4       	brcc	.+2      	; 0x5046 <writeFile+0x4e0>
    5044:	8a cf       	rjmp	.-236    	; 0x4f5a <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    5046:	6b 85       	ldd	r22, Y+11	; 0x0b
    5048:	7c 85       	ldd	r23, Y+12	; 0x0c
    504a:	8d 85       	ldd	r24, Y+13	; 0x0d
    504c:	9e 85       	ldd	r25, Y+14	; 0x0e
    504e:	40 e0       	ldi	r20, 0x00	; 0
    5050:	00 e0       	ldi	r16, 0x00	; 0
    5052:	10 e0       	ldi	r17, 0x00	; 0
    5054:	98 01       	movw	r18, r16
    5056:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
    505a:	6b 01       	movw	r12, r22
    505c:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    505e:	67 3f       	cpi	r22, 0xF7	; 247
    5060:	1f ef       	ldi	r17, 0xFF	; 255
    5062:	71 07       	cpc	r23, r17
    5064:	1f ef       	ldi	r17, 0xFF	; 255
    5066:	81 07       	cpc	r24, r17
    5068:	1f e0       	ldi	r17, 0x0F	; 15
    506a:	91 07       	cpc	r25, r17
    506c:	08 f1       	brcs	.+66     	; 0x50b0 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    506e:	6f 3f       	cpi	r22, 0xFF	; 255
    5070:	2f ef       	ldi	r18, 0xFF	; 255
    5072:	72 07       	cpc	r23, r18
    5074:	2f ef       	ldi	r18, 0xFF	; 255
    5076:	82 07       	cpc	r24, r18
    5078:	2f ef       	ldi	r18, 0xFF	; 255
    507a:	92 07       	cpc	r25, r18
    507c:	59 f5       	brne	.+86     	; 0x50d4 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    507e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5080:	7c 85       	ldd	r23, Y+12	; 0x0c
    5082:	8d 85       	ldd	r24, Y+13	; 0x0d
    5084:	9e 85       	ldd	r25, Y+14	; 0x0e
    5086:	0e 94 70 22 	call	0x44e0	; 0x44e0 <searchNextFreeCluster>
    508a:	6b 01       	movw	r12, r22
    508c:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    508e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5090:	7c 85       	ldd	r23, Y+12	; 0x0c
    5092:	8d 85       	ldd	r24, Y+13	; 0x0d
    5094:	9e 85       	ldd	r25, Y+14	; 0x0e
    5096:	41 e0       	ldi	r20, 0x01	; 1
    5098:	97 01       	movw	r18, r14
    509a:	86 01       	movw	r16, r12
    509c:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    50a0:	c7 01       	movw	r24, r14
    50a2:	b6 01       	movw	r22, r12
    50a4:	41 e0       	ldi	r20, 0x01	; 1
    50a6:	0f ef       	ldi	r16, 0xFF	; 255
    50a8:	1f ef       	ldi	r17, 0xFF	; 255
    50aa:	98 01       	movw	r18, r16
    50ac:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    50b0:	c1 14       	cp	r12, r1
    50b2:	d1 04       	cpc	r13, r1
    50b4:	e1 04       	cpc	r14, r1
    50b6:	f1 04       	cpc	r15, r1
    50b8:	09 f0       	breq	.+2      	; 0x50bc <writeFile+0x556>
    50ba:	39 cf       	rjmp	.-398    	; 0x4f2e <writeFile+0x3c8>
	   return 4;
    50bc:	84 e0       	ldi	r24, 0x04	; 4
    50be:	0b c0       	rjmp	.+22     	; 0x50d6 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    50c0:	81 e0       	ldi	r24, 0x01	; 1
    50c2:	09 c0       	rjmp	.+18     	; 0x50d6 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    50c4:	82 e0       	ldi	r24, 0x02	; 2
    50c6:	07 c0       	rjmp	.+14     	; 0x50d6 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    50c8:	82 e0       	ldi	r24, 0x02	; 2
    50ca:	05 c0       	rjmp	.+10     	; 0x50d6 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    50cc:	80 e0       	ldi	r24, 0x00	; 0
    50ce:	03 c0       	rjmp	.+6      	; 0x50d6 <writeFile+0x570>
    50d0:	80 e0       	ldi	r24, 0x00	; 0
    50d2:	01 c0       	rjmp	.+2      	; 0x50d6 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    50d4:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    50d6:	60 96       	adiw	r28, 0x10	; 16
    50d8:	cd bf       	out	0x3d, r28	; 61
    50da:	de bf       	out	0x3e, r29	; 62
    50dc:	df 91       	pop	r29
    50de:	cf 91       	pop	r28
    50e0:	1f 91       	pop	r17
    50e2:	0f 91       	pop	r16
    50e4:	ff 90       	pop	r15
    50e6:	ef 90       	pop	r14
    50e8:	df 90       	pop	r13
    50ea:	cf 90       	pop	r12
    50ec:	bf 90       	pop	r11
    50ee:	af 90       	pop	r10
    50f0:	9f 90       	pop	r9
    50f2:	8f 90       	pop	r8
    50f4:	7f 90       	pop	r7
    50f6:	6f 90       	pop	r6
    50f8:	5f 90       	pop	r5
    50fa:	4f 90       	pop	r4
    50fc:	3f 90       	pop	r3
    50fe:	2f 90       	pop	r2
    5100:	08 95       	ret

00005102 <SPI_write>:
}	

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    5102:	e0 ec       	ldi	r30, 0xC0	; 192
    5104:	f8 e0       	ldi	r31, 0x08	; 8
    5106:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5108:	82 81       	ldd	r24, Z+2	; 0x02
    510a:	88 23       	and	r24, r24
    510c:	ec f7       	brge	.-6      	; 0x5108 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    510e:	e0 ec       	ldi	r30, 0xC0	; 192
    5110:	f8 e0       	ldi	r31, 0x08	; 8
    5112:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    5114:	08 95       	ret

00005116 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    5116:	8f 92       	push	r8
    5118:	9f 92       	push	r9
    511a:	af 92       	push	r10
    511c:	bf 92       	push	r11
    511e:	cf 92       	push	r12
    5120:	df 92       	push	r13
    5122:	ef 92       	push	r14
    5124:	ff 92       	push	r15
    5126:	0f 93       	push	r16
    5128:	1f 93       	push	r17
    512a:	cf 93       	push	r28
    512c:	df 93       	push	r29
    512e:	84 2e       	mov	r8, r20
    5130:	a5 2e       	mov	r10, r21
    5132:	c6 2e       	mov	r12, r22
    5134:	c7 2f       	mov	r28, r23
    5136:	d2 2f       	mov	r29, r18
    5138:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    513a:	80 64       	ori	r24, 0x40	; 64
    513c:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5140:	8c 2f       	mov	r24, r28
    5142:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    5146:	8c 2d       	mov	r24, r12
    5148:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    514c:	8a 2d       	mov	r24, r10
    514e:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5152:	88 2d       	mov	r24, r8
    5154:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
	SPI_write(crc);
    5158:	8d 2f       	mov	r24, r29
    515a:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
	
	for(int i=0; i<read; i++){
    515e:	10 16       	cp	r1, r16
    5160:	11 06       	cpc	r1, r17
    5162:	64 f5       	brge	.+88     	; 0x51bc <SD_command+0xa6>
    5164:	00 e0       	ldi	r16, 0x00	; 0
    5166:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    5168:	0f 2e       	mov	r0, r31
    516a:	fd e0       	ldi	r31, 0x0D	; 13
    516c:	cf 2e       	mov	r12, r31
    516e:	dd 24       	eor	r13, r13
    5170:	f0 2d       	mov	r31, r0
    5172:	0f 2e       	mov	r0, r31
    5174:	fe ea       	ldi	r31, 0xAE	; 174
    5176:	af 2e       	mov	r10, r31
    5178:	f0 e5       	ldi	r31, 0x50	; 80
    517a:	bf 2e       	mov	r11, r31
    517c:	f0 2d       	mov	r31, r0
    517e:	c8 01       	movw	r24, r16
    5180:	b6 01       	movw	r22, r12
    5182:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    5186:	ec 01       	movw	r28, r24
    5188:	8f ef       	ldi	r24, 0xFF	; 255
    518a:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    518e:	f5 01       	movw	r30, r10
    5190:	ec 0f       	add	r30, r28
    5192:	fd 1f       	adc	r31, r29
    5194:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    5196:	80 81       	ld	r24, Z
    5198:	8f 3f       	cpi	r24, 0xFF	; 255
    519a:	49 f0       	breq	.+18     	; 0x51ae <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    519c:	fe 01       	movw	r30, r28
    519e:	e2 55       	subi	r30, 0x52	; 82
    51a0:	ff 4a       	sbci	r31, 0xAF	; 175
    51a2:	80 81       	ld	r24, Z
    51a4:	80 93 af 50 	sts	0x50AF, r24
			return Buffer[1];
    51a8:	80 91 af 50 	lds	r24, 0x50AF
    51ac:	08 c0       	rjmp	.+16     	; 0x51be <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    51ae:	0f 5f       	subi	r16, 0xFF	; 255
    51b0:	1f 4f       	sbci	r17, 0xFF	; 255
    51b2:	0e 15       	cp	r16, r14
    51b4:	1f 05       	cpc	r17, r15
    51b6:	19 f7       	brne	.-58     	; 0x517e <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    51b8:	8f ef       	ldi	r24, 0xFF	; 255
    51ba:	01 c0       	rjmp	.+2      	; 0x51be <SD_command+0xa8>
    51bc:	8f ef       	ldi	r24, 0xFF	; 255
}
    51be:	df 91       	pop	r29
    51c0:	cf 91       	pop	r28
    51c2:	1f 91       	pop	r17
    51c4:	0f 91       	pop	r16
    51c6:	ff 90       	pop	r15
    51c8:	ef 90       	pop	r14
    51ca:	df 90       	pop	r13
    51cc:	cf 90       	pop	r12
    51ce:	bf 90       	pop	r11
    51d0:	af 90       	pop	r10
    51d2:	9f 90       	pop	r9
    51d4:	8f 90       	pop	r8
    51d6:	08 95       	ret

000051d8 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    51d8:	ff 92       	push	r15
    51da:	0f 93       	push	r16
    51dc:	1f 93       	push	r17
    51de:	cf 93       	push	r28
    51e0:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    51e2:	81 e0       	ldi	r24, 0x01	; 1
    51e4:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    51e8:	81 e0       	ldi	r24, 0x01	; 1
    51ea:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <Ext1Power>
    51ee:	8f ef       	ldi	r24, 0xFF	; 255
    51f0:	93 ec       	ldi	r25, 0xC3	; 195
    51f2:	a9 e0       	ldi	r26, 0x09	; 9
    51f4:	81 50       	subi	r24, 0x01	; 1
    51f6:	90 40       	sbci	r25, 0x00	; 0
    51f8:	a0 40       	sbci	r26, 0x00	; 0
    51fa:	e1 f7       	brne	.-8      	; 0x51f4 <SD_init+0x1c>
    51fc:	00 c0       	rjmp	.+0      	; 0x51fe <SD_init+0x26>
    51fe:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    5200:	88 e0       	ldi	r24, 0x08	; 8
    5202:	60 e0       	ldi	r22, 0x00	; 0
    5204:	0e 94 86 1c 	call	0x390c	; 0x390c <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5208:	88 e0       	ldi	r24, 0x08	; 8
    520a:	60 e0       	ldi	r22, 0x00	; 0
    520c:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5210:	80 e0       	ldi	r24, 0x00	; 0
    5212:	63 e0       	ldi	r22, 0x03	; 3
    5214:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <SPIInit2>
	SPICS(TRUE);
    5218:	81 e0       	ldi	r24, 0x01	; 1
    521a:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
    521e:	8a e0       	ldi	r24, 0x0A	; 10
    5220:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    5222:	e0 ec       	ldi	r30, 0xC0	; 192
    5224:	f8 e0       	ldi	r31, 0x08	; 8
    5226:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    5228:	aa eb       	ldi	r26, 0xBA	; 186
    522a:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    522c:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    522e:	22 81       	ldd	r18, Z+2	; 0x02
    5230:	22 23       	and	r18, r18
    5232:	ec f7       	brge	.-6      	; 0x522e <SD_init+0x56>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    5234:	23 81       	ldd	r18, Z+3	; 0x03
    5236:	2c 93       	st	X, r18
    5238:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    523a:	c1 f7       	brne	.-16     	; 0x522c <SD_init+0x54>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    523c:	80 e0       	ldi	r24, 0x00	; 0
    523e:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    5242:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5246:	88 e0       	ldi	r24, 0x08	; 8
    5248:	60 e0       	ldi	r22, 0x00	; 0
    524a:	0e 94 82 1b 	call	0x3704	; 0x3704 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    524e:	80 e0       	ldi	r24, 0x00	; 0
    5250:	63 e0       	ldi	r22, 0x03	; 3
    5252:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <SPIInit2>
	SPICS(TRUE);
    5256:	81 e0       	ldi	r24, 0x01	; 1
    5258:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    525c:	cb e0       	ldi	r28, 0x0B	; 11
    525e:	d0 e0       	ldi	r29, 0x00	; 0
    5260:	02 c0       	rjmp	.+4      	; 0x5266 <SD_init+0x8e>
    5262:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    5264:	69 f0       	breq	.+26     	; 0x5280 <SD_init+0xa8>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    5266:	80 e0       	ldi	r24, 0x00	; 0
    5268:	40 e0       	ldi	r20, 0x00	; 0
    526a:	50 e0       	ldi	r21, 0x00	; 0
    526c:	ba 01       	movw	r22, r20
    526e:	25 e9       	ldi	r18, 0x95	; 149
    5270:	08 e0       	ldi	r16, 0x08	; 8
    5272:	10 e0       	ldi	r17, 0x00	; 0
    5274:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
    5278:	81 30       	cpi	r24, 0x01	; 1
    527a:	99 f7       	brne	.-26     	; 0x5262 <SD_init+0x8a>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    527c:	ff 24       	eor	r15, r15
    527e:	02 c0       	rjmp	.+4      	; 0x5284 <SD_init+0xac>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    5280:	ff 24       	eor	r15, r15
    5282:	f3 94       	inc	r15
    5284:	8f ef       	ldi	r24, 0xFF	; 255
    5286:	93 ec       	ldi	r25, 0xC3	; 195
    5288:	a9 e0       	ldi	r26, 0x09	; 9
    528a:	81 50       	subi	r24, 0x01	; 1
    528c:	90 40       	sbci	r25, 0x00	; 0
    528e:	a0 40       	sbci	r26, 0x00	; 0
    5290:	e1 f7       	brne	.-8      	; 0x528a <SD_init+0xb2>
    5292:	00 c0       	rjmp	.+0      	; 0x5294 <SD_init+0xbc>
    5294:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    5296:	cb e0       	ldi	r28, 0x0B	; 11
    5298:	d0 e0       	ldi	r29, 0x00	; 0
    529a:	02 c0       	rjmp	.+4      	; 0x52a0 <SD_init+0xc8>
    529c:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    529e:	69 f0       	breq	.+26     	; 0x52ba <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    52a0:	88 e0       	ldi	r24, 0x08	; 8
    52a2:	4a ea       	ldi	r20, 0xAA	; 170
    52a4:	51 e0       	ldi	r21, 0x01	; 1
    52a6:	60 e0       	ldi	r22, 0x00	; 0
    52a8:	70 e0       	ldi	r23, 0x00	; 0
    52aa:	27 e8       	ldi	r18, 0x87	; 135
    52ac:	08 e0       	ldi	r16, 0x08	; 8
    52ae:	10 e0       	ldi	r17, 0x00	; 0
    52b0:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
    52b4:	81 30       	cpi	r24, 0x01	; 1
    52b6:	91 f7       	brne	.-28     	; 0x529c <SD_init+0xc4>
    52b8:	02 c0       	rjmp	.+4      	; 0x52be <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    52ba:	ff 24       	eor	r15, r15
    52bc:	f3 94       	inc	r15
    52be:	c2 e0       	ldi	r28, 0x02	; 2
    52c0:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    52c2:	0e ea       	ldi	r16, 0xAE	; 174
    52c4:	10 e5       	ldi	r17, 0x50	; 80
    52c6:	8f ef       	ldi	r24, 0xFF	; 255
    52c8:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    52cc:	f8 01       	movw	r30, r16
    52ce:	ec 0f       	add	r30, r28
    52d0:	fd 1f       	adc	r31, r29
    52d2:	80 83       	st	Z, r24
    52d4:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    52d6:	c6 30       	cpi	r28, 0x06	; 6
    52d8:	d1 05       	cpc	r29, r1
    52da:	a9 f7       	brne	.-22     	; 0x52c6 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    52dc:	80 91 b2 50 	lds	r24, 0x50B2
    52e0:	81 30       	cpi	r24, 0x01	; 1
    52e2:	29 f4       	brne	.+10     	; 0x52ee <SD_init+0x116>
    52e4:	80 91 b3 50 	lds	r24, 0x50B3
    52e8:	8a 3a       	cpi	r24, 0xAA	; 170
    52ea:	21 f4       	brne	.+8      	; 0x52f4 <SD_init+0x11c>
    52ec:	05 c0       	rjmp	.+10     	; 0x52f8 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    52ee:	ff 24       	eor	r15, r15
    52f0:	f3 94       	inc	r15
    52f2:	02 c0       	rjmp	.+4      	; 0x52f8 <SD_init+0x120>
    52f4:	ff 24       	eor	r15, r15
    52f6:	f3 94       	inc	r15
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    52f8:	cf ea       	ldi	r28, 0xAF	; 175
    52fa:	d0 e5       	ldi	r29, 0x50	; 80
		//broken card or voltage out of operating range bounds
		errorCode = 1;
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    52fc:	87 e3       	ldi	r24, 0x37	; 55
    52fe:	40 e0       	ldi	r20, 0x00	; 0
    5300:	50 e0       	ldi	r21, 0x00	; 0
    5302:	ba 01       	movw	r22, r20
    5304:	2f ef       	ldi	r18, 0xFF	; 255
    5306:	08 e0       	ldi	r16, 0x08	; 8
    5308:	10 e0       	ldi	r17, 0x00	; 0
    530a:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    530e:	81 e0       	ldi	r24, 0x01	; 1
    5310:	40 e0       	ldi	r20, 0x00	; 0
    5312:	50 e0       	ldi	r21, 0x00	; 0
    5314:	60 e0       	ldi	r22, 0x00	; 0
    5316:	70 e4       	ldi	r23, 0x40	; 64
    5318:	2f ef       	ldi	r18, 0xFF	; 255
    531a:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
	} while(Buffer[1]!= 0x00);
    531e:	88 81       	ld	r24, Y
    5320:	88 23       	and	r24, r24
    5322:	61 f7       	brne	.-40     	; 0x52fc <SD_init+0x124>
    5324:	cb e0       	ldi	r28, 0x0B	; 11
    5326:	d0 e0       	ldi	r29, 0x00	; 0
    5328:	02 c0       	rjmp	.+4      	; 0x532e <SD_init+0x156>
    532a:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    532c:	61 f0       	breq	.+24     	; 0x5346 <SD_init+0x16e>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    532e:	8a e3       	ldi	r24, 0x3A	; 58
    5330:	40 e0       	ldi	r20, 0x00	; 0
    5332:	50 e0       	ldi	r21, 0x00	; 0
    5334:	ba 01       	movw	r22, r20
    5336:	2f ef       	ldi	r18, 0xFF	; 255
    5338:	08 e0       	ldi	r16, 0x08	; 8
    533a:	10 e0       	ldi	r17, 0x00	; 0
    533c:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
    5340:	88 23       	and	r24, r24
    5342:	99 f7       	brne	.-26     	; 0x532a <SD_init+0x152>
    5344:	02 c0       	rjmp	.+4      	; 0x534a <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5346:	ff 24       	eor	r15, r15
    5348:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    534a:	c0 e0       	ldi	r28, 0x00	; 0
    534c:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    534e:	0e ea       	ldi	r16, 0xAE	; 174
    5350:	10 e5       	ldi	r17, 0x50	; 80
    5352:	8f ef       	ldi	r24, 0xFF	; 255
    5354:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5358:	f8 01       	movw	r30, r16
    535a:	ec 0f       	add	r30, r28
    535c:	fd 1f       	adc	r31, r29
    535e:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5360:	21 96       	adiw	r28, 0x01	; 1
    5362:	c4 30       	cpi	r28, 0x04	; 4
    5364:	d1 05       	cpc	r29, r1
    5366:	a9 f7       	brne	.-22     	; 0x5352 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5368:	80 91 ae 50 	lds	r24, 0x50AE
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    536c:	80 e0       	ldi	r24, 0x00	; 0
    536e:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    5372:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5376:	88 e0       	ldi	r24, 0x08	; 8
    5378:	60 e0       	ldi	r22, 0x00	; 0
    537a:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
	return errorCode;	
}	
    537e:	8f 2d       	mov	r24, r15
    5380:	df 91       	pop	r29
    5382:	cf 91       	pop	r28
    5384:	1f 91       	pop	r17
    5386:	0f 91       	pop	r16
    5388:	ff 90       	pop	r15
    538a:	08 95       	ret

0000538c <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    538c:	6f 92       	push	r6
    538e:	7f 92       	push	r7
    5390:	8f 92       	push	r8
    5392:	9f 92       	push	r9
    5394:	af 92       	push	r10
    5396:	bf 92       	push	r11
    5398:	cf 92       	push	r12
    539a:	df 92       	push	r13
    539c:	ef 92       	push	r14
    539e:	ff 92       	push	r15
    53a0:	0f 93       	push	r16
    53a2:	1f 93       	push	r17
    53a4:	cf 93       	push	r28
    53a6:	df 93       	push	r29
    53a8:	4b 01       	movw	r8, r22
    53aa:	5c 01       	movw	r10, r24
    53ac:	74 2e       	mov	r7, r20
    53ae:	65 2e       	mov	r6, r21
    53b0:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    53b2:	88 e0       	ldi	r24, 0x08	; 8
    53b4:	60 e0       	ldi	r22, 0x00	; 0
    53b6:	0e 94 82 1b 	call	0x3704	; 0x3704 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    53ba:	80 e0       	ldi	r24, 0x00	; 0
    53bc:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    53c0:	81 e0       	ldi	r24, 0x01	; 1
    53c2:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    53c6:	80 e0       	ldi	r24, 0x00	; 0
    53c8:	92 e0       	ldi	r25, 0x02	; 2
    53ca:	7c 01       	movw	r14, r24
    53cc:	ec 18       	sub	r14, r12
    53ce:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    53d0:	80 e0       	ldi	r24, 0x00	; 0
    53d2:	e8 16       	cp	r14, r24
    53d4:	82 e0       	ldi	r24, 0x02	; 2
    53d6:	f8 06       	cpc	r15, r24
    53d8:	11 f4       	brne	.+4      	; 0x53de <SD_write_block+0x52>
    53da:	ee 24       	eor	r14, r14
    53dc:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    53de:	cb e0       	ldi	r28, 0x0B	; 11
    53e0:	d0 e0       	ldi	r29, 0x00	; 0
    53e2:	03 c0       	rjmp	.+6      	; 0x53ea <SD_write_block+0x5e>
    53e4:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    53e6:	09 f4       	brne	.+2      	; 0x53ea <SD_write_block+0x5e>
    53e8:	ff cf       	rjmp	.-2      	; 0x53e8 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    53ea:	88 e1       	ldi	r24, 0x18	; 24
    53ec:	b5 01       	movw	r22, r10
    53ee:	a4 01       	movw	r20, r8
    53f0:	2f ef       	ldi	r18, 0xFF	; 255
    53f2:	08 e0       	ldi	r16, 0x08	; 8
    53f4:	10 e0       	ldi	r17, 0x00	; 0
    53f6:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
    53fa:	88 23       	and	r24, r24
    53fc:	99 f7       	brne	.-26     	; 0x53e4 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    53fe:	8f ef       	ldi	r24, 0xFF	; 255
    5400:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5404:	80 93 ae 50 	sts	0x50AE, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    5408:	8e ef       	ldi	r24, 0xFE	; 254
    540a:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    540e:	1c 14       	cp	r1, r12
    5410:	1d 04       	cpc	r1, r13
    5412:	bc f4       	brge	.+46     	; 0x5442 <SD_write_block+0xb6>
    5414:	87 2c       	mov	r8, r7
    5416:	96 2c       	mov	r9, r6
    5418:	00 e0       	ldi	r16, 0x00	; 0
    541a:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    541c:	c8 01       	movw	r24, r16
    541e:	6d e0       	ldi	r22, 0x0D	; 13
    5420:	70 e0       	ldi	r23, 0x00	; 0
    5422:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    5426:	ec 01       	movw	r28, r24
    5428:	f4 01       	movw	r30, r8
    542a:	81 91       	ld	r24, Z+
    542c:	4f 01       	movw	r8, r30
    542e:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5432:	c2 55       	subi	r28, 0x52	; 82
    5434:	df 4a       	sbci	r29, 0xAF	; 175
    5436:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5438:	0f 5f       	subi	r16, 0xFF	; 255
    543a:	1f 4f       	sbci	r17, 0xFF	; 255
    543c:	0c 15       	cp	r16, r12
    543e:	1d 05       	cpc	r17, r13
    5440:	69 f7       	brne	.-38     	; 0x541c <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5442:	1e 14       	cp	r1, r14
    5444:	1f 04       	cpc	r1, r15
    5446:	ec f4       	brge	.+58     	; 0x5482 <SD_write_block+0xf6>
    5448:	00 e0       	ldi	r16, 0x00	; 0
    544a:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    544c:	0f 2e       	mov	r0, r31
    544e:	fd e0       	ldi	r31, 0x0D	; 13
    5450:	cf 2e       	mov	r12, r31
    5452:	dd 24       	eor	r13, r13
    5454:	f0 2d       	mov	r31, r0
    5456:	0f 2e       	mov	r0, r31
    5458:	fe ea       	ldi	r31, 0xAE	; 174
    545a:	8f 2e       	mov	r8, r31
    545c:	f0 e5       	ldi	r31, 0x50	; 80
    545e:	9f 2e       	mov	r9, r31
    5460:	f0 2d       	mov	r31, r0
    5462:	c8 01       	movw	r24, r16
    5464:	b6 01       	movw	r22, r12
    5466:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    546a:	ec 01       	movw	r28, r24
    546c:	80 e0       	ldi	r24, 0x00	; 0
    546e:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5472:	c8 0d       	add	r28, r8
    5474:	d9 1d       	adc	r29, r9
    5476:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5478:	0f 5f       	subi	r16, 0xFF	; 255
    547a:	1f 4f       	sbci	r17, 0xFF	; 255
    547c:	0e 15       	cp	r16, r14
    547e:	1f 05       	cpc	r17, r15
    5480:	81 f7       	brne	.-32     	; 0x5462 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    5482:	8f ef       	ldi	r24, 0xFF	; 255
    5484:	80 93 ae 50 	sts	0x50AE, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5488:	c0 e0       	ldi	r28, 0x00	; 0
    548a:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    548c:	0e ea       	ldi	r16, 0xAE	; 174
    548e:	10 e5       	ldi	r17, 0x50	; 80
    5490:	8f ef       	ldi	r24, 0xFF	; 255
    5492:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5496:	f8 01       	movw	r30, r16
    5498:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    549a:	21 96       	adiw	r28, 0x01	; 1
    549c:	c2 30       	cpi	r28, 0x02	; 2
    549e:	d1 05       	cpc	r29, r1
    54a0:	bc f3       	brlt	.-18     	; 0x5490 <SD_write_block+0x104>
    54a2:	80 81       	ld	r24, Z
    54a4:	8f 3f       	cpi	r24, 0xFF	; 255
    54a6:	a1 f3       	breq	.-24     	; 0x5490 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    54a8:	80 91 ae 50 	lds	r24, 0x50AE
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    54ac:	80 91 ae 50 	lds	r24, 0x50AE
    54b0:	8f 3f       	cpi	r24, 0xFF	; 255
    54b2:	49 f0       	breq	.+18     	; 0x54c6 <SD_write_block+0x13a>
    54b4:	ce ea       	ldi	r28, 0xAE	; 174
    54b6:	d0 e5       	ldi	r29, 0x50	; 80
    54b8:	8f ef       	ldi	r24, 0xFF	; 255
    54ba:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    54be:	88 83       	st	Y, r24
    54c0:	88 81       	ld	r24, Y
    54c2:	8f 3f       	cpi	r24, 0xFF	; 255
    54c4:	c9 f7       	brne	.-14     	; 0x54b8 <SD_write_block+0x12c>
	SPICS(FALSE);
    54c6:	80 e0       	ldi	r24, 0x00	; 0
    54c8:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    54cc:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    54d0:	88 e0       	ldi	r24, 0x08	; 8
    54d2:	60 e0       	ldi	r22, 0x00	; 0
    54d4:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
}
    54d8:	df 91       	pop	r29
    54da:	cf 91       	pop	r28
    54dc:	1f 91       	pop	r17
    54de:	0f 91       	pop	r16
    54e0:	ff 90       	pop	r15
    54e2:	ef 90       	pop	r14
    54e4:	df 90       	pop	r13
    54e6:	cf 90       	pop	r12
    54e8:	bf 90       	pop	r11
    54ea:	af 90       	pop	r10
    54ec:	9f 90       	pop	r9
    54ee:	8f 90       	pop	r8
    54f0:	7f 90       	pop	r7
    54f2:	6f 90       	pop	r6
    54f4:	08 95       	ret

000054f6 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    54f6:	af 92       	push	r10
    54f8:	bf 92       	push	r11
    54fa:	cf 92       	push	r12
    54fc:	df 92       	push	r13
    54fe:	ef 92       	push	r14
    5500:	ff 92       	push	r15
    5502:	0f 93       	push	r16
    5504:	1f 93       	push	r17
    5506:	cf 93       	push	r28
    5508:	df 93       	push	r29
    550a:	6b 01       	movw	r12, r22
    550c:	7c 01       	movw	r14, r24
    550e:	b4 2e       	mov	r11, r20
    5510:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5512:	88 e0       	ldi	r24, 0x08	; 8
    5514:	60 e0       	ldi	r22, 0x00	; 0
    5516:	0e 94 82 1b 	call	0x3704	; 0x3704 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    551a:	80 e0       	ldi	r24, 0x00	; 0
    551c:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    5520:	81 e0       	ldi	r24, 0x01	; 1
    5522:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5526:	cb e0       	ldi	r28, 0x0B	; 11
    5528:	d0 e0       	ldi	r29, 0x00	; 0
    552a:	03 c0       	rjmp	.+6      	; 0x5532 <SD_read_block+0x3c>
    552c:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    552e:	09 f4       	brne	.+2      	; 0x5532 <SD_read_block+0x3c>
    5530:	ff cf       	rjmp	.-2      	; 0x5530 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5532:	81 e1       	ldi	r24, 0x11	; 17
    5534:	b7 01       	movw	r22, r14
    5536:	a6 01       	movw	r20, r12
    5538:	2f ef       	ldi	r18, 0xFF	; 255
    553a:	08 e0       	ldi	r16, 0x08	; 8
    553c:	10 e0       	ldi	r17, 0x00	; 0
    553e:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
    5542:	88 23       	and	r24, r24
    5544:	99 f7       	brne	.-26     	; 0x552c <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5546:	80 91 ae 50 	lds	r24, 0x50AE
    554a:	8e 3f       	cpi	r24, 0xFE	; 254
    554c:	49 f0       	breq	.+18     	; 0x5560 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    554e:	ce ea       	ldi	r28, 0xAE	; 174
    5550:	d0 e5       	ldi	r29, 0x50	; 80
    5552:	8f ef       	ldi	r24, 0xFF	; 255
    5554:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5558:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    555a:	88 81       	ld	r24, Y
    555c:	8e 3f       	cpi	r24, 0xFE	; 254
    555e:	c9 f7       	brne	.-14     	; 0x5552 <SD_read_block+0x5c>
    5560:	0b 2d       	mov	r16, r11
    5562:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5564:	c0 e0       	ldi	r28, 0x00	; 0
    5566:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5568:	8f ef       	ldi	r24, 0xFF	; 255
    556a:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    556e:	f8 01       	movw	r30, r16
    5570:	81 93       	st	Z+, r24
    5572:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5574:	21 96       	adiw	r28, 0x01	; 1
    5576:	f2 e0       	ldi	r31, 0x02	; 2
    5578:	c0 30       	cpi	r28, 0x00	; 0
    557a:	df 07       	cpc	r29, r31
    557c:	a9 f7       	brne	.-22     	; 0x5568 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    557e:	10 92 ba 50 	sts	0x50BA, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5582:	80 91 ba 50 	lds	r24, 0x50BA
    5586:	8f 3f       	cpi	r24, 0xFF	; 255
    5588:	49 f0       	breq	.+18     	; 0x559c <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    558a:	ca eb       	ldi	r28, 0xBA	; 186
    558c:	d0 e5       	ldi	r29, 0x50	; 80
    558e:	8f ef       	ldi	r24, 0xFF	; 255
    5590:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5594:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5596:	88 81       	ld	r24, Y
    5598:	8f 3f       	cpi	r24, 0xFF	; 255
    559a:	c9 f7       	brne	.-14     	; 0x558e <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    559c:	80 e0       	ldi	r24, 0x00	; 0
    559e:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    55a2:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    55a6:	88 e0       	ldi	r24, 0x08	; 8
    55a8:	60 e0       	ldi	r22, 0x00	; 0
    55aa:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
}
    55ae:	df 91       	pop	r29
    55b0:	cf 91       	pop	r28
    55b2:	1f 91       	pop	r17
    55b4:	0f 91       	pop	r16
    55b6:	ff 90       	pop	r15
    55b8:	ef 90       	pop	r14
    55ba:	df 90       	pop	r13
    55bc:	cf 90       	pop	r12
    55be:	bf 90       	pop	r11
    55c0:	af 90       	pop	r10
    55c2:	08 95       	ret

000055c4 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    55c4:	2f 92       	push	r2
    55c6:	3f 92       	push	r3
    55c8:	4f 92       	push	r4
    55ca:	5f 92       	push	r5
    55cc:	6f 92       	push	r6
    55ce:	7f 92       	push	r7
    55d0:	8f 92       	push	r8
    55d2:	9f 92       	push	r9
    55d4:	af 92       	push	r10
    55d6:	bf 92       	push	r11
    55d8:	cf 92       	push	r12
    55da:	df 92       	push	r13
    55dc:	ef 92       	push	r14
    55de:	ff 92       	push	r15
    55e0:	0f 93       	push	r16
    55e2:	1f 93       	push	r17
    55e4:	cf 93       	push	r28
    55e6:	df 93       	push	r29
    55e8:	cd b7       	in	r28, 0x3d	; 61
    55ea:	de b7       	in	r29, 0x3e	; 62
    55ec:	2a 97       	sbiw	r28, 0x0a	; 10
    55ee:	cd bf       	out	0x3d, r28	; 61
    55f0:	de bf       	out	0x3e, r29	; 62
    55f2:	6b 01       	movw	r12, r22
    55f4:	7c 01       	movw	r14, r24
    55f6:	4f 83       	std	Y+7, r20	; 0x07
    55f8:	58 87       	std	Y+8, r21	; 0x08
    55fa:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    55fc:	88 e0       	ldi	r24, 0x08	; 8
    55fe:	60 e0       	ldi	r22, 0x00	; 0
    5600:	0e 94 82 1b 	call	0x3704	; 0x3704 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5604:	80 e0       	ldi	r24, 0x00	; 0
    5606:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    560a:	81 e0       	ldi	r24, 0x01	; 1
    560c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5610:	c8 01       	movw	r24, r16
    5612:	11 23       	and	r17, r17
    5614:	14 f4       	brge	.+4      	; 0x561a <SD_write_multiple_blocks+0x56>
    5616:	81 50       	subi	r24, 0x01	; 1
    5618:	9e 4f       	sbci	r25, 0xFE	; 254
    561a:	9c 01       	movw	r18, r24
    561c:	23 2f       	mov	r18, r19
    561e:	33 0f       	add	r19, r19
    5620:	33 0b       	sbc	r19, r19
    5622:	25 95       	asr	r18
    5624:	2b 83       	std	Y+3, r18	; 0x03
    5626:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5628:	20 e0       	ldi	r18, 0x00	; 0
    562a:	32 e0       	ldi	r19, 0x02	; 2
    562c:	c8 01       	movw	r24, r16
    562e:	b9 01       	movw	r22, r18
    5630:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    5634:	29 01       	movw	r4, r18
    5636:	48 1a       	sub	r4, r24
    5638:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    563a:	30 e0       	ldi	r19, 0x00	; 0
    563c:	43 16       	cp	r4, r19
    563e:	32 e0       	ldi	r19, 0x02	; 2
    5640:	53 06       	cpc	r5, r19
    5642:	31 f0       	breq	.+12     	; 0x5650 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5644:	8b 81       	ldd	r24, Y+3	; 0x03
    5646:	9c 81       	ldd	r25, Y+4	; 0x04
    5648:	01 96       	adiw	r24, 0x01	; 1
    564a:	8b 83       	std	Y+3, r24	; 0x03
    564c:	9c 83       	std	Y+4, r25	; 0x04
    564e:	02 c0       	rjmp	.+4      	; 0x5654 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5650:	44 24       	eor	r4, r4
    5652:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5654:	89 e1       	ldi	r24, 0x19	; 25
    5656:	b7 01       	movw	r22, r14
    5658:	a6 01       	movw	r20, r12
    565a:	2f ef       	ldi	r18, 0xFF	; 255
    565c:	08 e0       	ldi	r16, 0x08	; 8
    565e:	10 e0       	ldi	r17, 0x00	; 0
    5660:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
    5664:	88 23       	and	r24, r24
    5666:	b1 f7       	brne	.-20     	; 0x5654 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5668:	eb 81       	ldd	r30, Y+3	; 0x03
    566a:	fc 81       	ldd	r31, Y+4	; 0x04
    566c:	1e 16       	cp	r1, r30
    566e:	1f 06       	cpc	r1, r31
    5670:	0c f0       	brlt	.+2      	; 0x5674 <SD_write_multiple_blocks+0xb0>
    5672:	ac c0       	rjmp	.+344    	; 0x57cc <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5674:	31 97       	sbiw	r30, 0x01	; 1
    5676:	ed 83       	std	Y+5, r30	; 0x05
    5678:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    567a:	9f 01       	movw	r18, r30
    567c:	32 2f       	mov	r19, r18
    567e:	22 27       	eor	r18, r18
    5680:	33 0f       	add	r19, r19
    5682:	8f 81       	ldd	r24, Y+7	; 0x07
    5684:	98 85       	ldd	r25, Y+8	; 0x08
    5686:	89 83       	std	Y+1, r24	; 0x01
    5688:	9a 83       	std	Y+2, r25	; 0x02
    568a:	66 24       	eor	r6, r6
    568c:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    568e:	0f 2e       	mov	r0, r31
    5690:	ff ea       	ldi	r31, 0xAF	; 175
    5692:	8f 2e       	mov	r8, r31
    5694:	f0 e5       	ldi	r31, 0x50	; 80
    5696:	9f 2e       	mov	r9, r31
    5698:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    569a:	0f 2e       	mov	r0, r31
    569c:	fc e0       	ldi	r31, 0x0C	; 12
    569e:	cf 2e       	mov	r12, r31
    56a0:	dd 24       	eor	r13, r13
    56a2:	f0 2d       	mov	r31, r0
    56a4:	0f 2e       	mov	r0, r31
    56a6:	fe ea       	ldi	r31, 0xAE	; 174
    56a8:	af 2e       	mov	r10, r31
    56aa:	f0 e5       	ldi	r31, 0x50	; 80
    56ac:	bf 2e       	mov	r11, r31
    56ae:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    56b0:	80 e0       	ldi	r24, 0x00	; 0
    56b2:	92 e0       	ldi	r25, 0x02	; 2
    56b4:	1c 01       	movw	r2, r24
    56b6:	24 18       	sub	r2, r4
    56b8:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    56ba:	ef 81       	ldd	r30, Y+7	; 0x07
    56bc:	f8 85       	ldd	r31, Y+8	; 0x08
    56be:	e2 0f       	add	r30, r18
    56c0:	f3 1f       	adc	r31, r19
    56c2:	ef 83       	std	Y+7, r30	; 0x07
    56c4:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    56c6:	8f ef       	ldi	r24, 0xFF	; 255
    56c8:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    56cc:	f4 01       	movw	r30, r8
    56ce:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    56d0:	8c ef       	ldi	r24, 0xFC	; 252
    56d2:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    56d6:	f4 01       	movw	r30, r8
    56d8:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    56da:	2d 81       	ldd	r18, Y+5	; 0x05
    56dc:	3e 81       	ldd	r19, Y+6	; 0x06
    56de:	26 15       	cp	r18, r6
    56e0:	37 05       	cpc	r19, r7
    56e2:	09 f0       	breq	.+2      	; 0x56e6 <SD_write_multiple_blocks+0x122>
    56e4:	41 c0       	rjmp	.+130    	; 0x5768 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    56e6:	12 14       	cp	r1, r2
    56e8:	13 04       	cpc	r1, r3
    56ea:	cc f4       	brge	.+50     	; 0x571e <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    56ec:	ef 80       	ldd	r14, Y+7	; 0x07
    56ee:	f8 84       	ldd	r15, Y+8	; 0x08
    56f0:	00 e0       	ldi	r16, 0x00	; 0
    56f2:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    56f4:	c8 01       	movw	r24, r16
    56f6:	b6 01       	movw	r22, r12
    56f8:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    56fc:	89 87       	std	Y+9, r24	; 0x09
    56fe:	9a 87       	std	Y+10, r25	; 0x0a
    5700:	f7 01       	movw	r30, r14
    5702:	81 91       	ld	r24, Z+
    5704:	7f 01       	movw	r14, r30
    5706:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    570a:	e9 85       	ldd	r30, Y+9	; 0x09
    570c:	fa 85       	ldd	r31, Y+10	; 0x0a
    570e:	ea 0d       	add	r30, r10
    5710:	fb 1d       	adc	r31, r11
    5712:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5714:	0f 5f       	subi	r16, 0xFF	; 255
    5716:	1f 4f       	sbci	r17, 0xFF	; 255
    5718:	02 15       	cp	r16, r2
    571a:	13 05       	cpc	r17, r3
    571c:	59 f7       	brne	.-42     	; 0x56f4 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    571e:	14 14       	cp	r1, r4
    5720:	15 04       	cpc	r1, r5
    5722:	9c f4       	brge	.+38     	; 0x574a <SD_write_multiple_blocks+0x186>
    5724:	00 e0       	ldi	r16, 0x00	; 0
    5726:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5728:	c8 01       	movw	r24, r16
    572a:	b6 01       	movw	r22, r12
    572c:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    5730:	7c 01       	movw	r14, r24
    5732:	80 e0       	ldi	r24, 0x00	; 0
    5734:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5738:	f5 01       	movw	r30, r10
    573a:	ee 0d       	add	r30, r14
    573c:	ff 1d       	adc	r31, r15
    573e:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5740:	0f 5f       	subi	r16, 0xFF	; 255
    5742:	1f 4f       	sbci	r17, 0xFF	; 255
    5744:	04 15       	cp	r16, r4
    5746:	15 05       	cpc	r17, r5
    5748:	79 f7       	brne	.-34     	; 0x5728 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    574a:	8f ef       	ldi	r24, 0xFF	; 255
    574c:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5750:	f4 01       	movw	r30, r8
    5752:	80 83       	st	Z, r24
    5754:	8f ef       	ldi	r24, 0xFF	; 255
    5756:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    575a:	f4 01       	movw	r30, r8
    575c:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    575e:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5760:	80 81       	ld	r24, Z
    5762:	8f 3f       	cpi	r24, 0xFF	; 255
    5764:	e1 f4       	brne	.+56     	; 0x579e <SD_write_multiple_blocks+0x1da>
    5766:	23 c0       	rjmp	.+70     	; 0x57ae <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5768:	e9 80       	ldd	r14, Y+1	; 0x01
    576a:	fa 80       	ldd	r15, Y+2	; 0x02
    576c:	00 e0       	ldi	r16, 0x00	; 0
    576e:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5770:	c8 01       	movw	r24, r16
    5772:	b6 01       	movw	r22, r12
    5774:	0e 94 ec 37 	call	0x6fd8	; 0x6fd8 <__divmodhi4>
    5778:	89 87       	std	Y+9, r24	; 0x09
    577a:	9a 87       	std	Y+10, r25	; 0x0a
    577c:	f7 01       	movw	r30, r14
    577e:	81 91       	ld	r24, Z+
    5780:	7f 01       	movw	r14, r30
    5782:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5786:	e9 85       	ldd	r30, Y+9	; 0x09
    5788:	fa 85       	ldd	r31, Y+10	; 0x0a
    578a:	ea 0d       	add	r30, r10
    578c:	fb 1d       	adc	r31, r11
    578e:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5790:	0f 5f       	subi	r16, 0xFF	; 255
    5792:	1f 4f       	sbci	r17, 0xFF	; 255
    5794:	f2 e0       	ldi	r31, 0x02	; 2
    5796:	00 30       	cpi	r16, 0x00	; 0
    5798:	1f 07       	cpc	r17, r31
    579a:	51 f7       	brne	.-44     	; 0x5770 <SD_write_multiple_blocks+0x1ac>
    579c:	d6 cf       	rjmp	.-84     	; 0x574a <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    579e:	8f ef       	ldi	r24, 0xFF	; 255
    57a0:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    57a4:	f4 01       	movw	r30, r8
    57a6:	80 83       	st	Z, r24
    57a8:	80 81       	ld	r24, Z
    57aa:	8f 3f       	cpi	r24, 0xFF	; 255
    57ac:	c1 f7       	brne	.-16     	; 0x579e <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    57ae:	08 94       	sec
    57b0:	61 1c       	adc	r6, r1
    57b2:	71 1c       	adc	r7, r1
    57b4:	29 81       	ldd	r18, Y+1	; 0x01
    57b6:	3a 81       	ldd	r19, Y+2	; 0x02
    57b8:	20 50       	subi	r18, 0x00	; 0
    57ba:	3e 4f       	sbci	r19, 0xFE	; 254
    57bc:	29 83       	std	Y+1, r18	; 0x01
    57be:	3a 83       	std	Y+2, r19	; 0x02
    57c0:	8b 81       	ldd	r24, Y+3	; 0x03
    57c2:	9c 81       	ldd	r25, Y+4	; 0x04
    57c4:	68 16       	cp	r6, r24
    57c6:	79 06       	cpc	r7, r25
    57c8:	09 f0       	breq	.+2      	; 0x57cc <SD_write_multiple_blocks+0x208>
    57ca:	7d cf       	rjmp	.-262    	; 0x56c6 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    57cc:	ee 24       	eor	r14, r14
    57ce:	ff 24       	eor	r15, r15
    57d0:	68 94       	set
    57d2:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    57d4:	0f ea       	ldi	r16, 0xAF	; 175
    57d6:	10 e5       	ldi	r17, 0x50	; 80
    57d8:	8f ef       	ldi	r24, 0xFF	; 255
    57da:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    57de:	f8 01       	movw	r30, r16
    57e0:	80 83       	st	Z, r24
    57e2:	08 94       	sec
    57e4:	e1 08       	sbc	r14, r1
    57e6:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    57e8:	e1 14       	cp	r14, r1
    57ea:	f1 04       	cpc	r15, r1
    57ec:	a9 f7       	brne	.-22     	; 0x57d8 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    57ee:	8d ef       	ldi	r24, 0xFD	; 253
    57f0:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    57f4:	80 93 af 50 	sts	0x50AF, r24
    57f8:	ee 24       	eor	r14, r14
    57fa:	ff 24       	eor	r15, r15
    57fc:	68 94       	set
    57fe:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5800:	0f ea       	ldi	r16, 0xAF	; 175
    5802:	10 e5       	ldi	r17, 0x50	; 80
    5804:	8f ef       	ldi	r24, 0xFF	; 255
    5806:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    580a:	f8 01       	movw	r30, r16
    580c:	80 83       	st	Z, r24
    580e:	08 94       	sec
    5810:	e1 08       	sbc	r14, r1
    5812:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5814:	e1 14       	cp	r14, r1
    5816:	f1 04       	cpc	r15, r1
    5818:	a9 f7       	brne	.-22     	; 0x5804 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    581a:	10 92 af 50 	sts	0x50AF, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    581e:	80 91 af 50 	lds	r24, 0x50AF
    5822:	8f 3f       	cpi	r24, 0xFF	; 255
    5824:	51 f0       	breq	.+20     	; 0x583a <SD_write_multiple_blocks+0x276>
    5826:	0f ea       	ldi	r16, 0xAF	; 175
    5828:	10 e5       	ldi	r17, 0x50	; 80
    582a:	8f ef       	ldi	r24, 0xFF	; 255
    582c:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5830:	f8 01       	movw	r30, r16
    5832:	80 83       	st	Z, r24
    5834:	80 81       	ld	r24, Z
    5836:	8f 3f       	cpi	r24, 0xFF	; 255
    5838:	c1 f7       	brne	.-16     	; 0x582a <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    583a:	80 e0       	ldi	r24, 0x00	; 0
    583c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    5840:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5844:	88 e0       	ldi	r24, 0x08	; 8
    5846:	60 e0       	ldi	r22, 0x00	; 0
    5848:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
}
    584c:	2a 96       	adiw	r28, 0x0a	; 10
    584e:	cd bf       	out	0x3d, r28	; 61
    5850:	de bf       	out	0x3e, r29	; 62
    5852:	df 91       	pop	r29
    5854:	cf 91       	pop	r28
    5856:	1f 91       	pop	r17
    5858:	0f 91       	pop	r16
    585a:	ff 90       	pop	r15
    585c:	ef 90       	pop	r14
    585e:	df 90       	pop	r13
    5860:	cf 90       	pop	r12
    5862:	bf 90       	pop	r11
    5864:	af 90       	pop	r10
    5866:	9f 90       	pop	r9
    5868:	8f 90       	pop	r8
    586a:	7f 90       	pop	r7
    586c:	6f 90       	pop	r6
    586e:	5f 90       	pop	r5
    5870:	4f 90       	pop	r4
    5872:	3f 90       	pop	r3
    5874:	2f 90       	pop	r2
    5876:	08 95       	ret

00005878 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5878:	2f 92       	push	r2
    587a:	3f 92       	push	r3
    587c:	4f 92       	push	r4
    587e:	5f 92       	push	r5
    5880:	6f 92       	push	r6
    5882:	7f 92       	push	r7
    5884:	8f 92       	push	r8
    5886:	9f 92       	push	r9
    5888:	af 92       	push	r10
    588a:	bf 92       	push	r11
    588c:	cf 92       	push	r12
    588e:	df 92       	push	r13
    5890:	ef 92       	push	r14
    5892:	ff 92       	push	r15
    5894:	0f 93       	push	r16
    5896:	1f 93       	push	r17
    5898:	cf 93       	push	r28
    589a:	df 93       	push	r29
    589c:	6b 01       	movw	r12, r22
    589e:	7c 01       	movw	r14, r24
    58a0:	c4 2f       	mov	r28, r20
    58a2:	85 2e       	mov	r8, r21
    58a4:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    58a6:	88 e0       	ldi	r24, 0x08	; 8
    58a8:	60 e0       	ldi	r22, 0x00	; 0
    58aa:	0e 94 82 1b 	call	0x3704	; 0x3704 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    58ae:	80 e0       	ldi	r24, 0x00	; 0
    58b0:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    58b4:	81 e0       	ldi	r24, 0x01	; 1
    58b6:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    58ba:	82 e1       	ldi	r24, 0x12	; 18
    58bc:	b7 01       	movw	r22, r14
    58be:	a6 01       	movw	r20, r12
    58c0:	2f ef       	ldi	r18, 0xFF	; 255
    58c2:	08 e0       	ldi	r16, 0x08	; 8
    58c4:	10 e0       	ldi	r17, 0x00	; 0
    58c6:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
    58ca:	88 23       	and	r24, r24
    58cc:	b1 f7       	brne	.-20     	; 0x58ba <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    58ce:	16 14       	cp	r1, r6
    58d0:	17 04       	cpc	r1, r7
    58d2:	0c f0       	brlt	.+2      	; 0x58d6 <SD_read_multiple_blocks+0x5e>
    58d4:	46 c0       	rjmp	.+140    	; 0x5962 <SD_read_multiple_blocks+0xea>
    58d6:	ac 2e       	mov	r10, r28
    58d8:	b8 2c       	mov	r11, r8
    58da:	88 24       	eor	r8, r8
    58dc:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    58de:	0f 2e       	mov	r0, r31
    58e0:	ff ea       	ldi	r31, 0xAF	; 175
    58e2:	cf 2e       	mov	r12, r31
    58e4:	f0 e5       	ldi	r31, 0x50	; 80
    58e6:	df 2e       	mov	r13, r31
    58e8:	f0 2d       	mov	r31, r0
    58ea:	ff 24       	eor	r15, r15
    58ec:	fa 94       	dec	r15
    58ee:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    58f0:	0f 2e       	mov	r0, r31
    58f2:	fe ea       	ldi	r31, 0xAE	; 174
    58f4:	4f 2e       	mov	r4, r31
    58f6:	f0 e5       	ldi	r31, 0x50	; 80
    58f8:	5f 2e       	mov	r5, r31
    58fa:	f0 2d       	mov	r31, r0
    58fc:	12 01       	movw	r2, r4
    58fe:	08 94       	sec
    5900:	21 1c       	adc	r2, r1
    5902:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5904:	f6 01       	movw	r30, r12
    5906:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5908:	80 81       	ld	r24, Z
    590a:	8e 3f       	cpi	r24, 0xFE	; 254
    590c:	41 f0       	breq	.+16     	; 0x591e <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    590e:	8f 2d       	mov	r24, r15
    5910:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5914:	f6 01       	movw	r30, r12
    5916:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5918:	80 81       	ld	r24, Z
    591a:	8e 3f       	cpi	r24, 0xFE	; 254
    591c:	c1 f7       	brne	.-16     	; 0x590e <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    591e:	85 01       	movw	r16, r10
    5920:	c0 e0       	ldi	r28, 0x00	; 0
    5922:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5924:	8f 2d       	mov	r24, r15
    5926:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    592a:	f8 01       	movw	r30, r16
    592c:	81 93       	st	Z+, r24
    592e:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5930:	21 96       	adiw	r28, 0x01	; 1
    5932:	f2 e0       	ldi	r31, 0x02	; 2
    5934:	c0 30       	cpi	r28, 0x00	; 0
    5936:	df 07       	cpc	r29, r31
    5938:	a9 f7       	brne	.-22     	; 0x5924 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    593a:	8f 2d       	mov	r24, r15
    593c:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5940:	f2 01       	movw	r30, r4
    5942:	80 83       	st	Z, r24
    5944:	8f 2d       	mov	r24, r15
    5946:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    594a:	f1 01       	movw	r30, r2
    594c:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    594e:	08 94       	sec
    5950:	81 1c       	adc	r8, r1
    5952:	91 1c       	adc	r9, r1
    5954:	80 e0       	ldi	r24, 0x00	; 0
    5956:	92 e0       	ldi	r25, 0x02	; 2
    5958:	a8 0e       	add	r10, r24
    595a:	b9 1e       	adc	r11, r25
    595c:	86 14       	cp	r8, r6
    595e:	97 04       	cpc	r9, r7
    5960:	89 f6       	brne	.-94     	; 0x5904 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5962:	8c e0       	ldi	r24, 0x0C	; 12
    5964:	40 e0       	ldi	r20, 0x00	; 0
    5966:	50 e0       	ldi	r21, 0x00	; 0
    5968:	ba 01       	movw	r22, r20
    596a:	2f ef       	ldi	r18, 0xFF	; 255
    596c:	08 e0       	ldi	r16, 0x08	; 8
    596e:	10 e0       	ldi	r17, 0x00	; 0
    5970:	0e 94 8b 28 	call	0x5116	; 0x5116 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5974:	8f ef       	ldi	r24, 0xFF	; 255
    5976:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    597a:	80 93 ae 50 	sts	0x50AE, r24
	Buffer[1] = FILLER_BYTE;
    597e:	10 92 af 50 	sts	0x50AF, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5982:	80 91 af 50 	lds	r24, 0x50AF
    5986:	8f 3f       	cpi	r24, 0xFF	; 255
    5988:	49 f0       	breq	.+18     	; 0x599c <SD_read_multiple_blocks+0x124>
    598a:	cf ea       	ldi	r28, 0xAF	; 175
    598c:	d0 e5       	ldi	r29, 0x50	; 80
    598e:	8f ef       	ldi	r24, 0xFF	; 255
    5990:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
    5994:	88 83       	st	Y, r24
    5996:	88 81       	ld	r24, Y
    5998:	8f 3f       	cpi	r24, 0xFF	; 255
    599a:	c9 f7       	brne	.-14     	; 0x598e <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    599c:	80 e0       	ldi	r24, 0x00	; 0
    599e:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    59a2:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    59a6:	88 e0       	ldi	r24, 0x08	; 8
    59a8:	60 e0       	ldi	r22, 0x00	; 0
    59aa:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
}
    59ae:	df 91       	pop	r29
    59b0:	cf 91       	pop	r28
    59b2:	1f 91       	pop	r17
    59b4:	0f 91       	pop	r16
    59b6:	ff 90       	pop	r15
    59b8:	ef 90       	pop	r14
    59ba:	df 90       	pop	r13
    59bc:	cf 90       	pop	r12
    59be:	bf 90       	pop	r11
    59c0:	af 90       	pop	r10
    59c2:	9f 90       	pop	r9
    59c4:	8f 90       	pop	r8
    59c6:	7f 90       	pop	r7
    59c8:	6f 90       	pop	r6
    59ca:	5f 90       	pop	r5
    59cc:	4f 90       	pop	r4
    59ce:	3f 90       	pop	r3
    59d0:	2f 90       	pop	r2
    59d2:	08 95       	ret

000059d4 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    59d4:	88 e0       	ldi	r24, 0x08	; 8
    59d6:	60 e0       	ldi	r22, 0x00	; 0
    59d8:	0e 94 86 1c 	call	0x390c	; 0x390c <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    59dc:	88 e0       	ldi	r24, 0x08	; 8
    59de:	60 e0       	ldi	r22, 0x00	; 0
    59e0:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    59e4:	80 e0       	ldi	r24, 0x00	; 0
    59e6:	0e 94 49 1b 	call	0x3692	; 0x3692 <SPIInit>
	SPICS(TRUE);
    59ea:	81 e0       	ldi	r24, 0x01	; 1
    59ec:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    59f0:	8f ef       	ldi	r24, 0xFF	; 255
    59f2:	0e 94 81 28 	call	0x5102	; 0x5102 <SPI_write>
	SPICS(FALSE);	//stop spi
    59f6:	80 e0       	ldi	r24, 0x00	; 0
    59f8:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <SPICS>
	SPIDisable();
    59fc:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5a00:	80 e0       	ldi	r24, 0x00	; 0
    5a02:	0e 94 03 04 	call	0x806	; 0x806 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5a06:	80 e0       	ldi	r24, 0x00	; 0
    5a08:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <Ext1Power>
}
    5a0c:	08 95       	ret

00005a0e <__muldi3>:
    5a0e:	a0 e3       	ldi	r26, 0x30	; 48
    5a10:	b0 e0       	ldi	r27, 0x00	; 0
    5a12:	ed e0       	ldi	r30, 0x0D	; 13
    5a14:	fd e2       	ldi	r31, 0x2D	; 45
    5a16:	0c 94 3e 38 	jmp	0x707c	; 0x707c <__prologue_saves__+0x4>
    5a1a:	29 8f       	std	Y+25, r18	; 0x19
    5a1c:	3a 8f       	std	Y+26, r19	; 0x1a
    5a1e:	4b 8f       	std	Y+27, r20	; 0x1b
    5a20:	5c 8f       	std	Y+28, r21	; 0x1c
    5a22:	6d 8f       	std	Y+29, r22	; 0x1d
    5a24:	7e 8f       	std	Y+30, r23	; 0x1e
    5a26:	8f 8f       	std	Y+31, r24	; 0x1f
    5a28:	98 a3       	lds	r25, 0x58
    5a2a:	a9 8a       	std	Y+17, r10	; 0x11
    5a2c:	ba 8a       	std	Y+18, r11	; 0x12
    5a2e:	cb 8a       	std	Y+19, r12	; 0x13
    5a30:	dc 8a       	std	Y+20, r13	; 0x14
    5a32:	ed 8a       	std	Y+21, r14	; 0x15
    5a34:	fe 8a       	std	Y+22, r15	; 0x16
    5a36:	0f 8b       	std	Y+23, r16	; 0x17
    5a38:	18 8f       	std	Y+24, r17	; 0x18
    5a3a:	09 8d       	ldd	r16, Y+25	; 0x19
    5a3c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5a3e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5a40:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5a42:	09 a3       	lds	r16, 0x59
    5a44:	1a a3       	lds	r17, 0x5a
    5a46:	2b a3       	lds	r18, 0x5b
    5a48:	3c a3       	lds	r19, 0x5c
    5a4a:	68 01       	movw	r12, r16
    5a4c:	79 01       	movw	r14, r18
    5a4e:	8f ef       	ldi	r24, 0xFF	; 255
    5a50:	9f ef       	ldi	r25, 0xFF	; 255
    5a52:	a0 e0       	ldi	r26, 0x00	; 0
    5a54:	b0 e0       	ldi	r27, 0x00	; 0
    5a56:	c8 22       	and	r12, r24
    5a58:	d9 22       	and	r13, r25
    5a5a:	ea 22       	and	r14, r26
    5a5c:	fb 22       	and	r15, r27
    5a5e:	89 01       	movw	r16, r18
    5a60:	22 27       	eor	r18, r18
    5a62:	33 27       	eor	r19, r19
    5a64:	09 a7       	lds	r16, 0x79
    5a66:	1a a7       	lds	r17, 0x7a
    5a68:	2b a7       	lds	r18, 0x7b
    5a6a:	3c a7       	lds	r19, 0x7c
    5a6c:	09 89       	ldd	r16, Y+17	; 0x11
    5a6e:	1a 89       	ldd	r17, Y+18	; 0x12
    5a70:	2b 89       	ldd	r18, Y+19	; 0x13
    5a72:	3c 89       	ldd	r19, Y+20	; 0x14
    5a74:	0d a3       	lds	r16, 0x5d
    5a76:	1e a3       	lds	r17, 0x5e
    5a78:	2f a3       	lds	r18, 0x5f
    5a7a:	38 a7       	lds	r19, 0x78
    5a7c:	48 01       	movw	r8, r16
    5a7e:	59 01       	movw	r10, r18
    5a80:	88 22       	and	r8, r24
    5a82:	99 22       	and	r9, r25
    5a84:	aa 22       	and	r10, r26
    5a86:	bb 22       	and	r11, r27
    5a88:	29 01       	movw	r4, r18
    5a8a:	66 24       	eor	r6, r6
    5a8c:	77 24       	eor	r7, r7
    5a8e:	c5 01       	movw	r24, r10
    5a90:	b4 01       	movw	r22, r8
    5a92:	a7 01       	movw	r20, r14
    5a94:	96 01       	movw	r18, r12
    5a96:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    5a9a:	6d a7       	lds	r22, 0x7d
    5a9c:	7e a7       	lds	r23, 0x7e
    5a9e:	8f a7       	lds	r24, 0x7f
    5aa0:	98 ab       	sts	0x58, r25
    5aa2:	c3 01       	movw	r24, r6
    5aa4:	b2 01       	movw	r22, r4
    5aa6:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    5aaa:	6b 01       	movw	r12, r22
    5aac:	7c 01       	movw	r14, r24
    5aae:	c5 01       	movw	r24, r10
    5ab0:	b4 01       	movw	r22, r8
    5ab2:	29 a5       	lds	r18, 0x69
    5ab4:	3a a5       	lds	r19, 0x6a
    5ab6:	4b a5       	lds	r20, 0x6b
    5ab8:	5c a5       	lds	r21, 0x6c
    5aba:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    5abe:	4b 01       	movw	r8, r22
    5ac0:	5c 01       	movw	r10, r24
    5ac2:	c3 01       	movw	r24, r6
    5ac4:	b2 01       	movw	r22, r4
    5ac6:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    5aca:	ab 01       	movw	r20, r22
    5acc:	bc 01       	movw	r22, r24
    5ace:	c8 0c       	add	r12, r8
    5ad0:	d9 1c       	adc	r13, r9
    5ad2:	ea 1c       	adc	r14, r10
    5ad4:	fb 1c       	adc	r15, r11
    5ad6:	0d a5       	lds	r16, 0x6d
    5ad8:	1e a5       	lds	r17, 0x6e
    5ada:	2f a5       	lds	r18, 0x6f
    5adc:	38 a9       	sts	0x48, r19
    5ade:	c9 01       	movw	r24, r18
    5ae0:	aa 27       	eor	r26, r26
    5ae2:	bb 27       	eor	r27, r27
    5ae4:	c8 0e       	add	r12, r24
    5ae6:	d9 1e       	adc	r13, r25
    5ae8:	ea 1e       	adc	r14, r26
    5aea:	fb 1e       	adc	r15, r27
    5aec:	c8 14       	cp	r12, r8
    5aee:	d9 04       	cpc	r13, r9
    5af0:	ea 04       	cpc	r14, r10
    5af2:	fb 04       	cpc	r15, r11
    5af4:	20 f4       	brcc	.+8      	; 0x5afe <__muldi3+0xf0>
    5af6:	40 50       	subi	r20, 0x00	; 0
    5af8:	50 40       	sbci	r21, 0x00	; 0
    5afa:	6f 4f       	sbci	r22, 0xFF	; 255
    5afc:	7f 4f       	sbci	r23, 0xFF	; 255
    5afe:	c7 01       	movw	r24, r14
    5b00:	aa 27       	eor	r26, r26
    5b02:	bb 27       	eor	r27, r27
    5b04:	84 0f       	add	r24, r20
    5b06:	95 1f       	adc	r25, r21
    5b08:	a6 1f       	adc	r26, r22
    5b0a:	b7 1f       	adc	r27, r23
    5b0c:	8d 83       	std	Y+5, r24	; 0x05
    5b0e:	9e 83       	std	Y+6, r25	; 0x06
    5b10:	af 83       	std	Y+7, r26	; 0x07
    5b12:	b8 87       	std	Y+8, r27	; 0x08
    5b14:	76 01       	movw	r14, r12
    5b16:	dd 24       	eor	r13, r13
    5b18:	cc 24       	eor	r12, r12
    5b1a:	4d a5       	lds	r20, 0x6d
    5b1c:	5e a5       	lds	r21, 0x6e
    5b1e:	6f a5       	lds	r22, 0x6f
    5b20:	78 a9       	sts	0x48, r23
    5b22:	60 70       	andi	r22, 0x00	; 0
    5b24:	70 70       	andi	r23, 0x00	; 0
    5b26:	c4 0e       	add	r12, r20
    5b28:	d5 1e       	adc	r13, r21
    5b2a:	e6 1e       	adc	r14, r22
    5b2c:	f7 1e       	adc	r15, r23
    5b2e:	c9 82       	std	Y+1, r12	; 0x01
    5b30:	da 82       	std	Y+2, r13	; 0x02
    5b32:	eb 82       	std	Y+3, r14	; 0x03
    5b34:	fc 82       	std	Y+4, r15	; 0x04
    5b36:	1c 2d       	mov	r17, r12
    5b38:	0a 81       	ldd	r16, Y+2	; 0x02
    5b3a:	8b 80       	ldd	r8, Y+3	; 0x03
    5b3c:	4c 80       	ldd	r4, Y+4	; 0x04
    5b3e:	8d 87       	std	Y+13, r24	; 0x0d
    5b40:	8e 81       	ldd	r24, Y+6	; 0x06
    5b42:	8e 87       	std	Y+14, r24	; 0x0e
    5b44:	8f 81       	ldd	r24, Y+7	; 0x07
    5b46:	8f 87       	std	Y+15, r24	; 0x0f
    5b48:	88 85       	ldd	r24, Y+8	; 0x08
    5b4a:	88 8b       	std	Y+16, r24	; 0x10
    5b4c:	2d 89       	ldd	r18, Y+21	; 0x15
    5b4e:	3e 89       	ldd	r19, Y+22	; 0x16
    5b50:	4f 89       	ldd	r20, Y+23	; 0x17
    5b52:	58 8d       	ldd	r21, Y+24	; 0x18
    5b54:	69 a1       	lds	r22, 0x49
    5b56:	7a a1       	lds	r23, 0x4a
    5b58:	8b a1       	lds	r24, 0x4b
    5b5a:	9c a1       	lds	r25, 0x4c
    5b5c:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    5b60:	6b 01       	movw	r12, r22
    5b62:	7c 01       	movw	r14, r24
    5b64:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5b66:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5b68:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5b6a:	58 a1       	lds	r21, 0x48
    5b6c:	6d a1       	lds	r22, 0x4d
    5b6e:	7e a1       	lds	r23, 0x4e
    5b70:	8f a1       	lds	r24, 0x4f
    5b72:	98 a5       	lds	r25, 0x68
    5b74:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    5b78:	dc 01       	movw	r26, r24
    5b7a:	cb 01       	movw	r24, r22
    5b7c:	c8 0e       	add	r12, r24
    5b7e:	d9 1e       	adc	r13, r25
    5b80:	ea 1e       	adc	r14, r26
    5b82:	fb 1e       	adc	r15, r27
    5b84:	8d 85       	ldd	r24, Y+13	; 0x0d
    5b86:	9e 85       	ldd	r25, Y+14	; 0x0e
    5b88:	af 85       	ldd	r26, Y+15	; 0x0f
    5b8a:	b8 89       	ldd	r27, Y+16	; 0x10
    5b8c:	8c 0d       	add	r24, r12
    5b8e:	9d 1d       	adc	r25, r13
    5b90:	ae 1d       	adc	r26, r14
    5b92:	bf 1d       	adc	r27, r15
    5b94:	8d 87       	std	Y+13, r24	; 0x0d
    5b96:	9e 87       	std	Y+14, r25	; 0x0e
    5b98:	af 87       	std	Y+15, r26	; 0x0f
    5b9a:	b8 8b       	std	Y+16, r27	; 0x10
    5b9c:	68 2f       	mov	r22, r24
    5b9e:	7e 85       	ldd	r23, Y+14	; 0x0e
    5ba0:	21 2f       	mov	r18, r17
    5ba2:	30 2f       	mov	r19, r16
    5ba4:	48 2d       	mov	r20, r8
    5ba6:	54 2d       	mov	r21, r4
    5ba8:	8f 85       	ldd	r24, Y+15	; 0x0f
    5baa:	98 89       	ldd	r25, Y+16	; 0x10
    5bac:	e0 96       	adiw	r28, 0x30	; 48
    5bae:	e0 e1       	ldi	r30, 0x10	; 16
    5bb0:	0c 94 57 38 	jmp	0x70ae	; 0x70ae <__epilogue_restores__+0x4>

00005bb4 <__ashldi3>:
    5bb4:	cf 92       	push	r12
    5bb6:	df 92       	push	r13
    5bb8:	ef 92       	push	r14
    5bba:	ff 92       	push	r15
    5bbc:	0f 93       	push	r16
    5bbe:	cf 93       	push	r28
    5bc0:	df 93       	push	r29
    5bc2:	cd b7       	in	r28, 0x3d	; 61
    5bc4:	de b7       	in	r29, 0x3e	; 62
    5bc6:	60 97       	sbiw	r28, 0x10	; 16
    5bc8:	cd bf       	out	0x3d, r28	; 61
    5bca:	de bf       	out	0x3e, r29	; 62
    5bcc:	00 23       	and	r16, r16
    5bce:	09 f4       	brne	.+2      	; 0x5bd2 <__ashldi3+0x1e>
    5bd0:	5a c0       	rjmp	.+180    	; 0x5c86 <__ashldi3+0xd2>
    5bd2:	29 87       	std	Y+9, r18	; 0x09
    5bd4:	3a 87       	std	Y+10, r19	; 0x0a
    5bd6:	4b 87       	std	Y+11, r20	; 0x0b
    5bd8:	5c 87       	std	Y+12, r21	; 0x0c
    5bda:	6d 87       	std	Y+13, r22	; 0x0d
    5bdc:	7e 87       	std	Y+14, r23	; 0x0e
    5bde:	8f 87       	std	Y+15, r24	; 0x0f
    5be0:	98 8b       	std	Y+16, r25	; 0x10
    5be2:	80 e2       	ldi	r24, 0x20	; 32
    5be4:	80 1b       	sub	r24, r16
    5be6:	49 85       	ldd	r20, Y+9	; 0x09
    5be8:	5a 85       	ldd	r21, Y+10	; 0x0a
    5bea:	6b 85       	ldd	r22, Y+11	; 0x0b
    5bec:	7c 85       	ldd	r23, Y+12	; 0x0c
    5bee:	18 16       	cp	r1, r24
    5bf0:	b4 f0       	brlt	.+44     	; 0x5c1e <__ashldi3+0x6a>
    5bf2:	19 82       	std	Y+1, r1	; 0x01
    5bf4:	1a 82       	std	Y+2, r1	; 0x02
    5bf6:	1b 82       	std	Y+3, r1	; 0x03
    5bf8:	1c 82       	std	Y+4, r1	; 0x04
    5bfa:	99 27       	eor	r25, r25
    5bfc:	87 fd       	sbrc	r24, 7
    5bfe:	90 95       	com	r25
    5c00:	90 95       	com	r25
    5c02:	81 95       	neg	r24
    5c04:	9f 4f       	sbci	r25, 0xFF	; 255
    5c06:	04 c0       	rjmp	.+8      	; 0x5c10 <__ashldi3+0x5c>
    5c08:	44 0f       	add	r20, r20
    5c0a:	55 1f       	adc	r21, r21
    5c0c:	66 1f       	adc	r22, r22
    5c0e:	77 1f       	adc	r23, r23
    5c10:	8a 95       	dec	r24
    5c12:	d2 f7       	brpl	.-12     	; 0x5c08 <__ashldi3+0x54>
    5c14:	4d 83       	std	Y+5, r20	; 0x05
    5c16:	5e 83       	std	Y+6, r21	; 0x06
    5c18:	6f 83       	std	Y+7, r22	; 0x07
    5c1a:	78 87       	std	Y+8, r23	; 0x08
    5c1c:	2c c0       	rjmp	.+88     	; 0x5c76 <__ashldi3+0xc2>
    5c1e:	6a 01       	movw	r12, r20
    5c20:	7b 01       	movw	r14, r22
    5c22:	00 2e       	mov	r0, r16
    5c24:	04 c0       	rjmp	.+8      	; 0x5c2e <__ashldi3+0x7a>
    5c26:	cc 0c       	add	r12, r12
    5c28:	dd 1c       	adc	r13, r13
    5c2a:	ee 1c       	adc	r14, r14
    5c2c:	ff 1c       	adc	r15, r15
    5c2e:	0a 94       	dec	r0
    5c30:	d2 f7       	brpl	.-12     	; 0x5c26 <__ashldi3+0x72>
    5c32:	c9 82       	std	Y+1, r12	; 0x01
    5c34:	da 82       	std	Y+2, r13	; 0x02
    5c36:	eb 82       	std	Y+3, r14	; 0x03
    5c38:	fc 82       	std	Y+4, r15	; 0x04
    5c3a:	6a 01       	movw	r12, r20
    5c3c:	7b 01       	movw	r14, r22
    5c3e:	04 c0       	rjmp	.+8      	; 0x5c48 <__ashldi3+0x94>
    5c40:	f6 94       	lsr	r15
    5c42:	e7 94       	ror	r14
    5c44:	d7 94       	ror	r13
    5c46:	c7 94       	ror	r12
    5c48:	8a 95       	dec	r24
    5c4a:	d2 f7       	brpl	.-12     	; 0x5c40 <__ashldi3+0x8c>
    5c4c:	d7 01       	movw	r26, r14
    5c4e:	c6 01       	movw	r24, r12
    5c50:	4d 85       	ldd	r20, Y+13	; 0x0d
    5c52:	5e 85       	ldd	r21, Y+14	; 0x0e
    5c54:	6f 85       	ldd	r22, Y+15	; 0x0f
    5c56:	78 89       	ldd	r23, Y+16	; 0x10
    5c58:	04 c0       	rjmp	.+8      	; 0x5c62 <__ashldi3+0xae>
    5c5a:	44 0f       	add	r20, r20
    5c5c:	55 1f       	adc	r21, r21
    5c5e:	66 1f       	adc	r22, r22
    5c60:	77 1f       	adc	r23, r23
    5c62:	0a 95       	dec	r16
    5c64:	d2 f7       	brpl	.-12     	; 0x5c5a <__ashldi3+0xa6>
    5c66:	84 2b       	or	r24, r20
    5c68:	95 2b       	or	r25, r21
    5c6a:	a6 2b       	or	r26, r22
    5c6c:	b7 2b       	or	r27, r23
    5c6e:	8d 83       	std	Y+5, r24	; 0x05
    5c70:	9e 83       	std	Y+6, r25	; 0x06
    5c72:	af 83       	std	Y+7, r26	; 0x07
    5c74:	b8 87       	std	Y+8, r27	; 0x08
    5c76:	29 81       	ldd	r18, Y+1	; 0x01
    5c78:	3a 81       	ldd	r19, Y+2	; 0x02
    5c7a:	4b 81       	ldd	r20, Y+3	; 0x03
    5c7c:	5c 81       	ldd	r21, Y+4	; 0x04
    5c7e:	6d 81       	ldd	r22, Y+5	; 0x05
    5c80:	7e 81       	ldd	r23, Y+6	; 0x06
    5c82:	8f 81       	ldd	r24, Y+7	; 0x07
    5c84:	98 85       	ldd	r25, Y+8	; 0x08
    5c86:	60 96       	adiw	r28, 0x10	; 16
    5c88:	cd bf       	out	0x3d, r28	; 61
    5c8a:	de bf       	out	0x3e, r29	; 62
    5c8c:	df 91       	pop	r29
    5c8e:	cf 91       	pop	r28
    5c90:	0f 91       	pop	r16
    5c92:	ff 90       	pop	r15
    5c94:	ef 90       	pop	r14
    5c96:	df 90       	pop	r13
    5c98:	cf 90       	pop	r12
    5c9a:	08 95       	ret

00005c9c <__divdi3>:
    5c9c:	a8 e4       	ldi	r26, 0x48	; 72
    5c9e:	b0 e0       	ldi	r27, 0x00	; 0
    5ca0:	e4 e5       	ldi	r30, 0x54	; 84
    5ca2:	fe e2       	ldi	r31, 0x2E	; 46
    5ca4:	0c 94 3d 38 	jmp	0x707a	; 0x707a <__prologue_saves__+0x2>
    5ca8:	f5 01       	movw	r30, r10
    5caa:	29 a3       	lds	r18, 0x59
    5cac:	3a a3       	lds	r19, 0x5a
    5cae:	4b a3       	lds	r20, 0x5b
    5cb0:	5c a3       	lds	r21, 0x5c
    5cb2:	6d a3       	lds	r22, 0x5d
    5cb4:	7e a3       	lds	r23, 0x5e
    5cb6:	8f a3       	lds	r24, 0x5f
    5cb8:	98 a7       	lds	r25, 0x78
    5cba:	a9 8e       	std	Y+25, r10	; 0x19
    5cbc:	fa 8f       	std	Y+26, r31	; 0x1a
    5cbe:	cb 8e       	std	Y+27, r12	; 0x1b
    5cc0:	dc 8e       	std	Y+28, r13	; 0x1c
    5cc2:	ed 8e       	std	Y+29, r14	; 0x1d
    5cc4:	fe 8e       	std	Y+30, r15	; 0x1e
    5cc6:	0f 8f       	std	Y+31, r16	; 0x1f
    5cc8:	18 a3       	lds	r17, 0x58
    5cca:	8d a0       	lds	r24, 0x8d
    5ccc:	9e a0       	lds	r25, 0x8e
    5cce:	af a0       	lds	r26, 0x8f
    5cd0:	b8 a4       	lds	r27, 0xa8
    5cd2:	b7 fe       	sbrs	r11, 7
    5cd4:	67 c0       	rjmp	.+206    	; 0x5da4 <__divdi3+0x108>
    5cd6:	21 95       	neg	r18
    5cd8:	b1 e0       	ldi	r27, 0x01	; 1
    5cda:	12 16       	cp	r1, r18
    5cdc:	08 f0       	brcs	.+2      	; 0x5ce0 <__divdi3+0x44>
    5cde:	b0 e0       	ldi	r27, 0x00	; 0
    5ce0:	31 95       	neg	r19
    5ce2:	a1 e0       	ldi	r26, 0x01	; 1
    5ce4:	13 16       	cp	r1, r19
    5ce6:	08 f0       	brcs	.+2      	; 0x5cea <__divdi3+0x4e>
    5ce8:	a0 e0       	ldi	r26, 0x00	; 0
    5cea:	b3 2e       	mov	r11, r19
    5cec:	bb 1a       	sub	r11, r27
    5cee:	bb 2d       	mov	r27, r11
    5cf0:	88 24       	eor	r8, r8
    5cf2:	83 94       	inc	r8
    5cf4:	3b 15       	cp	r19, r11
    5cf6:	08 f0       	brcs	.+2      	; 0x5cfa <__divdi3+0x5e>
    5cf8:	88 24       	eor	r8, r8
    5cfa:	a8 29       	or	r26, r8
    5cfc:	41 95       	neg	r20
    5cfe:	31 e0       	ldi	r19, 0x01	; 1
    5d00:	14 16       	cp	r1, r20
    5d02:	08 f0       	brcs	.+2      	; 0x5d06 <__divdi3+0x6a>
    5d04:	30 e0       	ldi	r19, 0x00	; 0
    5d06:	b4 2e       	mov	r11, r20
    5d08:	ba 1a       	sub	r11, r26
    5d0a:	ab 2d       	mov	r26, r11
    5d0c:	88 24       	eor	r8, r8
    5d0e:	83 94       	inc	r8
    5d10:	4b 15       	cp	r20, r11
    5d12:	08 f0       	brcs	.+2      	; 0x5d16 <__divdi3+0x7a>
    5d14:	88 24       	eor	r8, r8
    5d16:	38 29       	or	r19, r8
    5d18:	51 95       	neg	r21
    5d1a:	41 e0       	ldi	r20, 0x01	; 1
    5d1c:	15 16       	cp	r1, r21
    5d1e:	08 f0       	brcs	.+2      	; 0x5d22 <__divdi3+0x86>
    5d20:	40 e0       	ldi	r20, 0x00	; 0
    5d22:	45 2e       	mov	r4, r21
    5d24:	43 1a       	sub	r4, r19
    5d26:	31 e0       	ldi	r19, 0x01	; 1
    5d28:	54 15       	cp	r21, r4
    5d2a:	08 f0       	brcs	.+2      	; 0x5d2e <__divdi3+0x92>
    5d2c:	30 e0       	ldi	r19, 0x00	; 0
    5d2e:	43 2b       	or	r20, r19
    5d30:	61 95       	neg	r22
    5d32:	31 e0       	ldi	r19, 0x01	; 1
    5d34:	16 16       	cp	r1, r22
    5d36:	08 f0       	brcs	.+2      	; 0x5d3a <__divdi3+0x9e>
    5d38:	30 e0       	ldi	r19, 0x00	; 0
    5d3a:	86 2e       	mov	r8, r22
    5d3c:	84 1a       	sub	r8, r20
    5d3e:	41 e0       	ldi	r20, 0x01	; 1
    5d40:	68 15       	cp	r22, r8
    5d42:	08 f0       	brcs	.+2      	; 0x5d46 <__divdi3+0xaa>
    5d44:	40 e0       	ldi	r20, 0x00	; 0
    5d46:	34 2b       	or	r19, r20
    5d48:	71 95       	neg	r23
    5d4a:	41 e0       	ldi	r20, 0x01	; 1
    5d4c:	17 16       	cp	r1, r23
    5d4e:	08 f0       	brcs	.+2      	; 0x5d52 <__divdi3+0xb6>
    5d50:	40 e0       	ldi	r20, 0x00	; 0
    5d52:	57 2f       	mov	r21, r23
    5d54:	53 1b       	sub	r21, r19
    5d56:	31 e0       	ldi	r19, 0x01	; 1
    5d58:	75 17       	cp	r23, r21
    5d5a:	08 f0       	brcs	.+2      	; 0x5d5e <__divdi3+0xc2>
    5d5c:	30 e0       	ldi	r19, 0x00	; 0
    5d5e:	43 2b       	or	r20, r19
    5d60:	81 95       	neg	r24
    5d62:	31 e0       	ldi	r19, 0x01	; 1
    5d64:	18 16       	cp	r1, r24
    5d66:	08 f0       	brcs	.+2      	; 0x5d6a <__divdi3+0xce>
    5d68:	30 e0       	ldi	r19, 0x00	; 0
    5d6a:	68 2f       	mov	r22, r24
    5d6c:	64 1b       	sub	r22, r20
    5d6e:	46 2f       	mov	r20, r22
    5d70:	61 e0       	ldi	r22, 0x01	; 1
    5d72:	84 17       	cp	r24, r20
    5d74:	08 f0       	brcs	.+2      	; 0x5d78 <__divdi3+0xdc>
    5d76:	60 e0       	ldi	r22, 0x00	; 0
    5d78:	36 2b       	or	r19, r22
    5d7a:	91 95       	neg	r25
    5d7c:	93 1b       	sub	r25, r19
    5d7e:	29 a3       	lds	r18, 0x59
    5d80:	ba a3       	lds	r27, 0x5a
    5d82:	ab a3       	lds	r26, 0x5b
    5d84:	4c a2       	lds	r20, 0x9c
    5d86:	8d a2       	lds	r24, 0x9d
    5d88:	5e a3       	lds	r21, 0x5e
    5d8a:	4f a3       	lds	r20, 0x5f
    5d8c:	98 a7       	lds	r25, 0x78
    5d8e:	8f ef       	ldi	r24, 0xFF	; 255
    5d90:	9f ef       	ldi	r25, 0xFF	; 255
    5d92:	af ef       	ldi	r26, 0xFF	; 255
    5d94:	bf ef       	ldi	r27, 0xFF	; 255
    5d96:	25 96       	adiw	r28, 0x05	; 5
    5d98:	8c af       	sts	0x7c, r24
    5d9a:	9d af       	sts	0x7d, r25
    5d9c:	ae af       	sts	0x7e, r26
    5d9e:	bf af       	sts	0x7f, r27
    5da0:	25 97       	sbiw	r28, 0x05	; 5
    5da2:	06 c0       	rjmp	.+12     	; 0x5db0 <__divdi3+0x114>
    5da4:	25 96       	adiw	r28, 0x05	; 5
    5da6:	1c ae       	sts	0xbc, r17
    5da8:	1d ae       	sts	0xbd, r17
    5daa:	1e ae       	sts	0xbe, r17
    5dac:	1f ae       	sts	0xbf, r17
    5dae:	25 97       	sbiw	r28, 0x05	; 5
    5db0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5db2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5db4:	af 8d       	ldd	r26, Y+31	; 0x1f
    5db6:	b8 a1       	lds	r27, 0x48
    5db8:	b7 ff       	sbrs	r27, 7
    5dba:	68 c0       	rjmp	.+208    	; 0x5e8c <__divdi3+0x1f0>
    5dbc:	25 96       	adiw	r28, 0x05	; 5
    5dbe:	2c ad       	sts	0x6c, r18
    5dc0:	3d ad       	sts	0x6d, r19
    5dc2:	4e ad       	sts	0x6e, r20
    5dc4:	5f ad       	sts	0x6f, r21
    5dc6:	25 97       	sbiw	r28, 0x05	; 5
    5dc8:	20 95       	com	r18
    5dca:	30 95       	com	r19
    5dcc:	40 95       	com	r20
    5dce:	50 95       	com	r21
    5dd0:	25 96       	adiw	r28, 0x05	; 5
    5dd2:	2c af       	sts	0x7c, r18
    5dd4:	3d af       	sts	0x7d, r19
    5dd6:	4e af       	sts	0x7e, r20
    5dd8:	5f af       	sts	0x7f, r21
    5dda:	25 97       	sbiw	r28, 0x05	; 5
    5ddc:	e1 95       	neg	r30
    5dde:	81 e0       	ldi	r24, 0x01	; 1
    5de0:	1e 16       	cp	r1, r30
    5de2:	08 f0       	brcs	.+2      	; 0x5de6 <__divdi3+0x14a>
    5de4:	80 e0       	ldi	r24, 0x00	; 0
    5de6:	f1 95       	neg	r31
    5de8:	91 e0       	ldi	r25, 0x01	; 1
    5dea:	1f 16       	cp	r1, r31
    5dec:	08 f0       	brcs	.+2      	; 0x5df0 <__divdi3+0x154>
    5dee:	90 e0       	ldi	r25, 0x00	; 0
    5df0:	4f 2f       	mov	r20, r31
    5df2:	48 1b       	sub	r20, r24
    5df4:	81 e0       	ldi	r24, 0x01	; 1
    5df6:	f4 17       	cp	r31, r20
    5df8:	08 f0       	brcs	.+2      	; 0x5dfc <__divdi3+0x160>
    5dfa:	80 e0       	ldi	r24, 0x00	; 0
    5dfc:	98 2b       	or	r25, r24
    5dfe:	c1 94       	neg	r12
    5e00:	81 e0       	ldi	r24, 0x01	; 1
    5e02:	1c 14       	cp	r1, r12
    5e04:	08 f0       	brcs	.+2      	; 0x5e08 <__divdi3+0x16c>
    5e06:	80 e0       	ldi	r24, 0x00	; 0
    5e08:	6c 2d       	mov	r22, r12
    5e0a:	69 1b       	sub	r22, r25
    5e0c:	91 e0       	ldi	r25, 0x01	; 1
    5e0e:	c6 16       	cp	r12, r22
    5e10:	08 f0       	brcs	.+2      	; 0x5e14 <__divdi3+0x178>
    5e12:	90 e0       	ldi	r25, 0x00	; 0
    5e14:	89 2b       	or	r24, r25
    5e16:	d1 94       	neg	r13
    5e18:	91 e0       	ldi	r25, 0x01	; 1
    5e1a:	1d 14       	cp	r1, r13
    5e1c:	08 f0       	brcs	.+2      	; 0x5e20 <__divdi3+0x184>
    5e1e:	90 e0       	ldi	r25, 0x00	; 0
    5e20:	5d 2d       	mov	r21, r13
    5e22:	58 1b       	sub	r21, r24
    5e24:	81 e0       	ldi	r24, 0x01	; 1
    5e26:	d5 16       	cp	r13, r21
    5e28:	08 f0       	brcs	.+2      	; 0x5e2c <__divdi3+0x190>
    5e2a:	80 e0       	ldi	r24, 0x00	; 0
    5e2c:	98 2b       	or	r25, r24
    5e2e:	e1 94       	neg	r14
    5e30:	81 e0       	ldi	r24, 0x01	; 1
    5e32:	1e 14       	cp	r1, r14
    5e34:	08 f0       	brcs	.+2      	; 0x5e38 <__divdi3+0x19c>
    5e36:	80 e0       	ldi	r24, 0x00	; 0
    5e38:	3e 2d       	mov	r19, r14
    5e3a:	39 1b       	sub	r19, r25
    5e3c:	91 e0       	ldi	r25, 0x01	; 1
    5e3e:	e3 16       	cp	r14, r19
    5e40:	08 f0       	brcs	.+2      	; 0x5e44 <__divdi3+0x1a8>
    5e42:	90 e0       	ldi	r25, 0x00	; 0
    5e44:	89 2b       	or	r24, r25
    5e46:	f1 94       	neg	r15
    5e48:	91 e0       	ldi	r25, 0x01	; 1
    5e4a:	1f 14       	cp	r1, r15
    5e4c:	08 f0       	brcs	.+2      	; 0x5e50 <__divdi3+0x1b4>
    5e4e:	90 e0       	ldi	r25, 0x00	; 0
    5e50:	2f 2d       	mov	r18, r15
    5e52:	28 1b       	sub	r18, r24
    5e54:	81 e0       	ldi	r24, 0x01	; 1
    5e56:	f2 16       	cp	r15, r18
    5e58:	08 f0       	brcs	.+2      	; 0x5e5c <__divdi3+0x1c0>
    5e5a:	80 e0       	ldi	r24, 0x00	; 0
    5e5c:	98 2b       	or	r25, r24
    5e5e:	01 95       	neg	r16
    5e60:	81 e0       	ldi	r24, 0x01	; 1
    5e62:	10 16       	cp	r1, r16
    5e64:	08 f0       	brcs	.+2      	; 0x5e68 <__divdi3+0x1cc>
    5e66:	80 e0       	ldi	r24, 0x00	; 0
    5e68:	70 2f       	mov	r23, r16
    5e6a:	79 1b       	sub	r23, r25
    5e6c:	97 2f       	mov	r25, r23
    5e6e:	71 e0       	ldi	r23, 0x01	; 1
    5e70:	09 17       	cp	r16, r25
    5e72:	08 f0       	brcs	.+2      	; 0x5e76 <__divdi3+0x1da>
    5e74:	70 e0       	ldi	r23, 0x00	; 0
    5e76:	87 2b       	or	r24, r23
    5e78:	11 95       	neg	r17
    5e7a:	18 1b       	sub	r17, r24
    5e7c:	e9 8f       	std	Y+25, r30	; 0x19
    5e7e:	4a 8f       	std	Y+26, r20	; 0x1a
    5e80:	6b 8f       	std	Y+27, r22	; 0x1b
    5e82:	5c 8f       	std	Y+28, r21	; 0x1c
    5e84:	3d 8f       	std	Y+29, r19	; 0x1d
    5e86:	2e 8f       	std	Y+30, r18	; 0x1e
    5e88:	9f 8f       	std	Y+31, r25	; 0x1f
    5e8a:	18 a3       	lds	r17, 0x58
    5e8c:	79 8d       	ldd	r23, Y+25	; 0x19
    5e8e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5e90:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5e92:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5e94:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5e96:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5e98:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5e9a:	88 a1       	lds	r24, 0x48
    5e9c:	e9 a1       	lds	r30, 0x49
    5e9e:	e9 8b       	std	Y+17, r30	; 0x11
    5ea0:	ea a1       	lds	r30, 0x4a
    5ea2:	ea 8b       	std	Y+18, r30	; 0x12
    5ea4:	eb a1       	lds	r30, 0x4b
    5ea6:	eb 8b       	std	Y+19, r30	; 0x13
    5ea8:	ec a1       	lds	r30, 0x4c
    5eaa:	ec 8b       	std	Y+20, r30	; 0x14
    5eac:	ed a1       	lds	r30, 0x4d
    5eae:	ed 8b       	std	Y+21, r30	; 0x15
    5eb0:	ee a1       	lds	r30, 0x4e
    5eb2:	ee 8b       	std	Y+22, r30	; 0x16
    5eb4:	ef a1       	lds	r30, 0x4f
    5eb6:	ef 8b       	std	Y+23, r30	; 0x17
    5eb8:	e8 a5       	lds	r30, 0x68
    5eba:	e8 8f       	std	Y+24, r30	; 0x18
    5ebc:	79 87       	std	Y+9, r23	; 0x09
    5ebe:	6a 87       	std	Y+10, r22	; 0x0a
    5ec0:	5b 87       	std	Y+11, r21	; 0x0b
    5ec2:	4c 87       	std	Y+12, r20	; 0x0c
    5ec4:	3d 87       	std	Y+13, r19	; 0x0d
    5ec6:	2e 87       	std	Y+14, r18	; 0x0e
    5ec8:	9f 87       	std	Y+15, r25	; 0x0f
    5eca:	88 8b       	std	Y+16, r24	; 0x10
    5ecc:	89 84       	ldd	r8, Y+9	; 0x09
    5ece:	9a 84       	ldd	r9, Y+10	; 0x0a
    5ed0:	ab 84       	ldd	r10, Y+11	; 0x0b
    5ed2:	bc 84       	ldd	r11, Y+12	; 0x0c
    5ed4:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ed6:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ed8:	af 85       	ldd	r26, Y+15	; 0x0f
    5eda:	b8 89       	ldd	r27, Y+16	; 0x10
    5edc:	e9 88       	ldd	r14, Y+17	; 0x11
    5ede:	fa 88       	ldd	r15, Y+18	; 0x12
    5ee0:	0b 89       	ldd	r16, Y+19	; 0x13
    5ee2:	1c 89       	ldd	r17, Y+20	; 0x14
    5ee4:	ed aa       	sts	0x9d, r30
    5ee6:	fe aa       	sts	0x9e, r31
    5ee8:	0f ab       	sts	0x5f, r16
    5eea:	18 af       	sts	0x78, r17
    5eec:	cd 88       	ldd	r12, Y+21	; 0x15
    5eee:	de 88       	ldd	r13, Y+22	; 0x16
    5ef0:	ef 88       	ldd	r14, Y+23	; 0x17
    5ef2:	f8 8c       	ldd	r15, Y+24	; 0x18
    5ef4:	00 97       	sbiw	r24, 0x00	; 0
    5ef6:	a1 05       	cpc	r26, r1
    5ef8:	b1 05       	cpc	r27, r1
    5efa:	09 f0       	breq	.+2      	; 0x5efe <__divdi3+0x262>
    5efc:	bd c3       	rjmp	.+1914   	; 0x6678 <__stack+0x679>
    5efe:	c8 14       	cp	r12, r8
    5f00:	d9 04       	cpc	r13, r9
    5f02:	ea 04       	cpc	r14, r10
    5f04:	fb 04       	cpc	r15, r11
    5f06:	08 f0       	brcs	.+2      	; 0x5f0a <__divdi3+0x26e>
    5f08:	4d c1       	rjmp	.+666    	; 0x61a4 <__stack+0x1a5>
    5f0a:	00 e0       	ldi	r16, 0x00	; 0
    5f0c:	80 16       	cp	r8, r16
    5f0e:	00 e0       	ldi	r16, 0x00	; 0
    5f10:	90 06       	cpc	r9, r16
    5f12:	01 e0       	ldi	r16, 0x01	; 1
    5f14:	a0 06       	cpc	r10, r16
    5f16:	00 e0       	ldi	r16, 0x00	; 0
    5f18:	b0 06       	cpc	r11, r16
    5f1a:	58 f4       	brcc	.+22     	; 0x5f32 <__divdi3+0x296>
    5f1c:	1f ef       	ldi	r17, 0xFF	; 255
    5f1e:	81 16       	cp	r8, r17
    5f20:	91 04       	cpc	r9, r1
    5f22:	a1 04       	cpc	r10, r1
    5f24:	b1 04       	cpc	r11, r1
    5f26:	09 f0       	breq	.+2      	; 0x5f2a <__divdi3+0x28e>
    5f28:	90 f4       	brcc	.+36     	; 0x5f4e <__divdi3+0x2b2>
    5f2a:	80 e0       	ldi	r24, 0x00	; 0
    5f2c:	90 e0       	ldi	r25, 0x00	; 0
    5f2e:	dc 01       	movw	r26, r24
    5f30:	17 c0       	rjmp	.+46     	; 0x5f60 <__divdi3+0x2c4>
    5f32:	20 e0       	ldi	r18, 0x00	; 0
    5f34:	82 16       	cp	r8, r18
    5f36:	20 e0       	ldi	r18, 0x00	; 0
    5f38:	92 06       	cpc	r9, r18
    5f3a:	20 e0       	ldi	r18, 0x00	; 0
    5f3c:	a2 06       	cpc	r10, r18
    5f3e:	21 e0       	ldi	r18, 0x01	; 1
    5f40:	b2 06       	cpc	r11, r18
    5f42:	50 f4       	brcc	.+20     	; 0x5f58 <__divdi3+0x2bc>
    5f44:	80 e1       	ldi	r24, 0x10	; 16
    5f46:	90 e0       	ldi	r25, 0x00	; 0
    5f48:	a0 e0       	ldi	r26, 0x00	; 0
    5f4a:	b0 e0       	ldi	r27, 0x00	; 0
    5f4c:	09 c0       	rjmp	.+18     	; 0x5f60 <__divdi3+0x2c4>
    5f4e:	88 e0       	ldi	r24, 0x08	; 8
    5f50:	90 e0       	ldi	r25, 0x00	; 0
    5f52:	a0 e0       	ldi	r26, 0x00	; 0
    5f54:	b0 e0       	ldi	r27, 0x00	; 0
    5f56:	04 c0       	rjmp	.+8      	; 0x5f60 <__divdi3+0x2c4>
    5f58:	88 e1       	ldi	r24, 0x18	; 24
    5f5a:	90 e0       	ldi	r25, 0x00	; 0
    5f5c:	a0 e0       	ldi	r26, 0x00	; 0
    5f5e:	b0 e0       	ldi	r27, 0x00	; 0
    5f60:	b5 01       	movw	r22, r10
    5f62:	a4 01       	movw	r20, r8
    5f64:	08 2e       	mov	r0, r24
    5f66:	04 c0       	rjmp	.+8      	; 0x5f70 <__divdi3+0x2d4>
    5f68:	76 95       	lsr	r23
    5f6a:	67 95       	ror	r22
    5f6c:	57 95       	ror	r21
    5f6e:	47 95       	ror	r20
    5f70:	0a 94       	dec	r0
    5f72:	d2 f7       	brpl	.-12     	; 0x5f68 <__divdi3+0x2cc>
    5f74:	fa 01       	movw	r30, r20
    5f76:	e9 5c       	subi	r30, 0xC9	; 201
    5f78:	ff 4d       	sbci	r31, 0xDF	; 223
    5f7a:	20 81       	ld	r18, Z
    5f7c:	40 e2       	ldi	r20, 0x20	; 32
    5f7e:	50 e0       	ldi	r21, 0x00	; 0
    5f80:	60 e0       	ldi	r22, 0x00	; 0
    5f82:	70 e0       	ldi	r23, 0x00	; 0
    5f84:	48 1b       	sub	r20, r24
    5f86:	59 0b       	sbc	r21, r25
    5f88:	6a 0b       	sbc	r22, r26
    5f8a:	7b 0b       	sbc	r23, r27
    5f8c:	42 1b       	sub	r20, r18
    5f8e:	51 09       	sbc	r21, r1
    5f90:	61 09       	sbc	r22, r1
    5f92:	71 09       	sbc	r23, r1
    5f94:	41 15       	cp	r20, r1
    5f96:	51 05       	cpc	r21, r1
    5f98:	61 05       	cpc	r22, r1
    5f9a:	71 05       	cpc	r23, r1
    5f9c:	a1 f1       	breq	.+104    	; 0x6006 <__stack+0x7>
    5f9e:	04 2e       	mov	r0, r20
    5fa0:	04 c0       	rjmp	.+8      	; 0x5faa <__divdi3+0x30e>
    5fa2:	88 0c       	add	r8, r8
    5fa4:	99 1c       	adc	r9, r9
    5fa6:	aa 1c       	adc	r10, r10
    5fa8:	bb 1c       	adc	r11, r11
    5faa:	0a 94       	dec	r0
    5fac:	d2 f7       	brpl	.-12     	; 0x5fa2 <__divdi3+0x306>
    5fae:	97 01       	movw	r18, r14
    5fb0:	86 01       	movw	r16, r12
    5fb2:	04 2e       	mov	r0, r20
    5fb4:	04 c0       	rjmp	.+8      	; 0x5fbe <__divdi3+0x322>
    5fb6:	00 0f       	add	r16, r16
    5fb8:	11 1f       	adc	r17, r17
    5fba:	22 1f       	adc	r18, r18
    5fbc:	33 1f       	adc	r19, r19
    5fbe:	0a 94       	dec	r0
    5fc0:	d2 f7       	brpl	.-12     	; 0x5fb6 <__divdi3+0x31a>
    5fc2:	80 e2       	ldi	r24, 0x20	; 32
    5fc4:	90 e0       	ldi	r25, 0x00	; 0
    5fc6:	84 1b       	sub	r24, r20
    5fc8:	95 0b       	sbc	r25, r21
    5fca:	cd a8       	sts	0x8d, r28
    5fcc:	de a8       	sts	0x8e, r29
    5fce:	ef a8       	sts	0x8f, r30
    5fd0:	f8 ac       	sts	0xa8, r31
    5fd2:	04 c0       	rjmp	.+8      	; 0x5fdc <__divdi3+0x340>
    5fd4:	f6 94       	lsr	r15
    5fd6:	e7 94       	ror	r14
    5fd8:	d7 94       	ror	r13
    5fda:	c7 94       	ror	r12
    5fdc:	8a 95       	dec	r24
    5fde:	d2 f7       	brpl	.-12     	; 0x5fd4 <__divdi3+0x338>
    5fe0:	c0 2a       	or	r12, r16
    5fe2:	d1 2a       	or	r13, r17
    5fe4:	e2 2a       	or	r14, r18
    5fe6:	f3 2a       	or	r15, r19
    5fe8:	0d a9       	sts	0x4d, r16
    5fea:	1e a9       	sts	0x4e, r17
    5fec:	2f a9       	sts	0x4f, r18
    5fee:	38 ad       	sts	0x68, r19
    5ff0:	04 c0       	rjmp	.+8      	; 0x5ffa <__divdi3+0x35e>
    5ff2:	00 0f       	add	r16, r16
    5ff4:	11 1f       	adc	r17, r17
    5ff6:	22 1f       	adc	r18, r18
    5ff8:	33 1f       	adc	r19, r19
    5ffa:	4a 95       	dec	r20
    5ffc:	d2 f7       	brpl	.-12     	; 0x5ff2 <__divdi3+0x356>
    5ffe:	0d ab       	sts	0x5d, r16
    6000:	1e ab       	sts	0x5e, r17
    6002:	2f ab       	sts	0x5f, r18
    6004:	38 af       	sts	0x78, r19
    6006:	25 01       	movw	r4, r10
    6008:	66 24       	eor	r6, r6
    600a:	77 24       	eor	r7, r7
    600c:	95 01       	movw	r18, r10
    600e:	84 01       	movw	r16, r8
    6010:	20 70       	andi	r18, 0x00	; 0
    6012:	30 70       	andi	r19, 0x00	; 0
    6014:	09 ab       	sts	0x59, r16
    6016:	1a ab       	sts	0x5a, r17
    6018:	2b ab       	sts	0x5b, r18
    601a:	3c ab       	sts	0x5c, r19
    601c:	c7 01       	movw	r24, r14
    601e:	b6 01       	movw	r22, r12
    6020:	a3 01       	movw	r20, r6
    6022:	92 01       	movw	r18, r4
    6024:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    6028:	2d a7       	lds	r18, 0x7d
    602a:	3e a7       	lds	r19, 0x7e
    602c:	4f a7       	lds	r20, 0x7f
    602e:	58 ab       	sts	0x58, r21
    6030:	69 a7       	lds	r22, 0x79
    6032:	7a a7       	lds	r23, 0x7a
    6034:	8b a7       	lds	r24, 0x7b
    6036:	9c a7       	lds	r25, 0x7c
    6038:	c7 01       	movw	r24, r14
    603a:	b6 01       	movw	r22, r12
    603c:	a3 01       	movw	r20, r6
    603e:	92 01       	movw	r18, r4
    6040:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    6044:	ca 01       	movw	r24, r20
    6046:	b9 01       	movw	r22, r18
    6048:	29 a9       	sts	0x49, r18
    604a:	3a a9       	sts	0x4a, r19
    604c:	4b a9       	sts	0x4b, r20
    604e:	5c a9       	sts	0x4c, r21
    6050:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6054:	ab 01       	movw	r20, r22
    6056:	bc 01       	movw	r22, r24
    6058:	09 a5       	lds	r16, 0x69
    605a:	1a a5       	lds	r17, 0x6a
    605c:	2b a5       	lds	r18, 0x6b
    605e:	3c a5       	lds	r19, 0x6c
    6060:	78 01       	movw	r14, r16
    6062:	dd 24       	eor	r13, r13
    6064:	cc 24       	eor	r12, r12
    6066:	0d a9       	sts	0x4d, r16
    6068:	1e a9       	sts	0x4e, r17
    606a:	2f a9       	sts	0x4f, r18
    606c:	38 ad       	sts	0x68, r19
    606e:	c9 01       	movw	r24, r18
    6070:	aa 27       	eor	r26, r26
    6072:	bb 27       	eor	r27, r27
    6074:	c8 2a       	or	r12, r24
    6076:	d9 2a       	or	r13, r25
    6078:	ea 2a       	or	r14, r26
    607a:	fb 2a       	or	r15, r27
    607c:	0d a5       	lds	r16, 0x6d
    607e:	1e a5       	lds	r17, 0x6e
    6080:	2f a5       	lds	r18, 0x6f
    6082:	38 a9       	sts	0x48, r19
    6084:	c4 16       	cp	r12, r20
    6086:	d5 06       	cpc	r13, r21
    6088:	e6 06       	cpc	r14, r22
    608a:	f7 06       	cpc	r15, r23
    608c:	38 f5       	brcc	.+78     	; 0x60dc <__stack+0xdd>
    608e:	01 50       	subi	r16, 0x01	; 1
    6090:	10 40       	sbci	r17, 0x00	; 0
    6092:	20 40       	sbci	r18, 0x00	; 0
    6094:	30 40       	sbci	r19, 0x00	; 0
    6096:	09 a7       	lds	r16, 0x79
    6098:	1a a7       	lds	r17, 0x7a
    609a:	2b a7       	lds	r18, 0x7b
    609c:	3c a7       	lds	r19, 0x7c
    609e:	c8 0c       	add	r12, r8
    60a0:	d9 1c       	adc	r13, r9
    60a2:	ea 1c       	adc	r14, r10
    60a4:	fb 1c       	adc	r15, r11
    60a6:	c8 14       	cp	r12, r8
    60a8:	d9 04       	cpc	r13, r9
    60aa:	ea 04       	cpc	r14, r10
    60ac:	fb 04       	cpc	r15, r11
    60ae:	d0 f0       	brcs	.+52     	; 0x60e4 <__stack+0xe5>
    60b0:	c4 16       	cp	r12, r20
    60b2:	d5 06       	cpc	r13, r21
    60b4:	e6 06       	cpc	r14, r22
    60b6:	f7 06       	cpc	r15, r23
    60b8:	a8 f4       	brcc	.+42     	; 0x60e4 <__stack+0xe5>
    60ba:	0d a5       	lds	r16, 0x6d
    60bc:	1e a5       	lds	r17, 0x6e
    60be:	2f a5       	lds	r18, 0x6f
    60c0:	38 a9       	sts	0x48, r19
    60c2:	02 50       	subi	r16, 0x02	; 2
    60c4:	10 40       	sbci	r17, 0x00	; 0
    60c6:	20 40       	sbci	r18, 0x00	; 0
    60c8:	30 40       	sbci	r19, 0x00	; 0
    60ca:	09 a7       	lds	r16, 0x79
    60cc:	1a a7       	lds	r17, 0x7a
    60ce:	2b a7       	lds	r18, 0x7b
    60d0:	3c a7       	lds	r19, 0x7c
    60d2:	c8 0c       	add	r12, r8
    60d4:	d9 1c       	adc	r13, r9
    60d6:	ea 1c       	adc	r14, r10
    60d8:	fb 1c       	adc	r15, r11
    60da:	04 c0       	rjmp	.+8      	; 0x60e4 <__stack+0xe5>
    60dc:	09 a7       	lds	r16, 0x79
    60de:	1a a7       	lds	r17, 0x7a
    60e0:	2b a7       	lds	r18, 0x7b
    60e2:	3c a7       	lds	r19, 0x7c
    60e4:	c4 1a       	sub	r12, r20
    60e6:	d5 0a       	sbc	r13, r21
    60e8:	e6 0a       	sbc	r14, r22
    60ea:	f7 0a       	sbc	r15, r23
    60ec:	c7 01       	movw	r24, r14
    60ee:	b6 01       	movw	r22, r12
    60f0:	a3 01       	movw	r20, r6
    60f2:	92 01       	movw	r18, r4
    60f4:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    60f8:	2d a7       	lds	r18, 0x7d
    60fa:	3e a7       	lds	r19, 0x7e
    60fc:	4f a7       	lds	r20, 0x7f
    60fe:	58 ab       	sts	0x58, r21
    6100:	69 af       	sts	0x79, r22
    6102:	7a af       	sts	0x7a, r23
    6104:	8b af       	sts	0x7b, r24
    6106:	9c af       	sts	0x7c, r25
    6108:	c7 01       	movw	r24, r14
    610a:	b6 01       	movw	r22, r12
    610c:	a3 01       	movw	r20, r6
    610e:	92 01       	movw	r18, r4
    6110:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    6114:	ca 01       	movw	r24, r20
    6116:	b9 01       	movw	r22, r18
    6118:	29 a9       	sts	0x49, r18
    611a:	3a a9       	sts	0x4a, r19
    611c:	4b a9       	sts	0x4b, r20
    611e:	5c a9       	sts	0x4c, r21
    6120:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6124:	6b 01       	movw	r12, r22
    6126:	7c 01       	movw	r14, r24
    6128:	49 ad       	sts	0x69, r20
    612a:	5a ad       	sts	0x6a, r21
    612c:	6b ad       	sts	0x6b, r22
    612e:	7c ad       	sts	0x6c, r23
    6130:	9a 01       	movw	r18, r20
    6132:	11 27       	eor	r17, r17
    6134:	00 27       	eor	r16, r16
    6136:	4d a9       	sts	0x4d, r20
    6138:	5e a9       	sts	0x4e, r21
    613a:	6f a9       	sts	0x4f, r22
    613c:	78 ad       	sts	0x68, r23
    613e:	60 70       	andi	r22, 0x00	; 0
    6140:	70 70       	andi	r23, 0x00	; 0
    6142:	04 2b       	or	r16, r20
    6144:	15 2b       	or	r17, r21
    6146:	26 2b       	or	r18, r22
    6148:	37 2b       	or	r19, r23
    614a:	8d a5       	lds	r24, 0x6d
    614c:	9e a5       	lds	r25, 0x6e
    614e:	af a5       	lds	r26, 0x6f
    6150:	b8 a9       	sts	0x48, r27
    6152:	0c 15       	cp	r16, r12
    6154:	1d 05       	cpc	r17, r13
    6156:	2e 05       	cpc	r18, r14
    6158:	3f 05       	cpc	r19, r15
    615a:	c0 f4       	brcc	.+48     	; 0x618c <__stack+0x18d>
    615c:	01 97       	sbiw	r24, 0x01	; 1
    615e:	a1 09       	sbc	r26, r1
    6160:	b1 09       	sbc	r27, r1
    6162:	08 0d       	add	r16, r8
    6164:	19 1d       	adc	r17, r9
    6166:	2a 1d       	adc	r18, r10
    6168:	3b 1d       	adc	r19, r11
    616a:	08 15       	cp	r16, r8
    616c:	19 05       	cpc	r17, r9
    616e:	2a 05       	cpc	r18, r10
    6170:	3b 05       	cpc	r19, r11
    6172:	60 f0       	brcs	.+24     	; 0x618c <__stack+0x18d>
    6174:	0c 15       	cp	r16, r12
    6176:	1d 05       	cpc	r17, r13
    6178:	2e 05       	cpc	r18, r14
    617a:	3f 05       	cpc	r19, r15
    617c:	38 f4       	brcc	.+14     	; 0x618c <__stack+0x18d>
    617e:	8d a5       	lds	r24, 0x6d
    6180:	9e a5       	lds	r25, 0x6e
    6182:	af a5       	lds	r26, 0x6f
    6184:	b8 a9       	sts	0x48, r27
    6186:	02 97       	sbiw	r24, 0x02	; 2
    6188:	a1 09       	sbc	r26, r1
    618a:	b1 09       	sbc	r27, r1
    618c:	09 a5       	lds	r16, 0x69
    618e:	1a a5       	lds	r17, 0x6a
    6190:	2b a5       	lds	r18, 0x6b
    6192:	3c a5       	lds	r19, 0x6c
    6194:	78 01       	movw	r14, r16
    6196:	dd 24       	eor	r13, r13
    6198:	cc 24       	eor	r12, r12
    619a:	c8 2a       	or	r12, r24
    619c:	d9 2a       	or	r13, r25
    619e:	ea 2a       	or	r14, r26
    61a0:	fb 2a       	or	r15, r27
    61a2:	b7 c4       	rjmp	.+2414   	; 0x6b12 <__stack+0xb13>
    61a4:	81 14       	cp	r8, r1
    61a6:	91 04       	cpc	r9, r1
    61a8:	a1 04       	cpc	r10, r1
    61aa:	b1 04       	cpc	r11, r1
    61ac:	51 f4       	brne	.+20     	; 0x61c2 <__stack+0x1c3>
    61ae:	61 e0       	ldi	r22, 0x01	; 1
    61b0:	70 e0       	ldi	r23, 0x00	; 0
    61b2:	80 e0       	ldi	r24, 0x00	; 0
    61b4:	90 e0       	ldi	r25, 0x00	; 0
    61b6:	a5 01       	movw	r20, r10
    61b8:	94 01       	movw	r18, r8
    61ba:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    61be:	49 01       	movw	r8, r18
    61c0:	5a 01       	movw	r10, r20
    61c2:	10 e0       	ldi	r17, 0x00	; 0
    61c4:	81 16       	cp	r8, r17
    61c6:	10 e0       	ldi	r17, 0x00	; 0
    61c8:	91 06       	cpc	r9, r17
    61ca:	11 e0       	ldi	r17, 0x01	; 1
    61cc:	a1 06       	cpc	r10, r17
    61ce:	10 e0       	ldi	r17, 0x00	; 0
    61d0:	b1 06       	cpc	r11, r17
    61d2:	58 f4       	brcc	.+22     	; 0x61ea <__stack+0x1eb>
    61d4:	2f ef       	ldi	r18, 0xFF	; 255
    61d6:	82 16       	cp	r8, r18
    61d8:	91 04       	cpc	r9, r1
    61da:	a1 04       	cpc	r10, r1
    61dc:	b1 04       	cpc	r11, r1
    61de:	09 f0       	breq	.+2      	; 0x61e2 <__stack+0x1e3>
    61e0:	90 f4       	brcc	.+36     	; 0x6206 <__stack+0x207>
    61e2:	80 e0       	ldi	r24, 0x00	; 0
    61e4:	90 e0       	ldi	r25, 0x00	; 0
    61e6:	dc 01       	movw	r26, r24
    61e8:	17 c0       	rjmp	.+46     	; 0x6218 <__stack+0x219>
    61ea:	30 e0       	ldi	r19, 0x00	; 0
    61ec:	83 16       	cp	r8, r19
    61ee:	30 e0       	ldi	r19, 0x00	; 0
    61f0:	93 06       	cpc	r9, r19
    61f2:	30 e0       	ldi	r19, 0x00	; 0
    61f4:	a3 06       	cpc	r10, r19
    61f6:	31 e0       	ldi	r19, 0x01	; 1
    61f8:	b3 06       	cpc	r11, r19
    61fa:	50 f4       	brcc	.+20     	; 0x6210 <__stack+0x211>
    61fc:	80 e1       	ldi	r24, 0x10	; 16
    61fe:	90 e0       	ldi	r25, 0x00	; 0
    6200:	a0 e0       	ldi	r26, 0x00	; 0
    6202:	b0 e0       	ldi	r27, 0x00	; 0
    6204:	09 c0       	rjmp	.+18     	; 0x6218 <__stack+0x219>
    6206:	88 e0       	ldi	r24, 0x08	; 8
    6208:	90 e0       	ldi	r25, 0x00	; 0
    620a:	a0 e0       	ldi	r26, 0x00	; 0
    620c:	b0 e0       	ldi	r27, 0x00	; 0
    620e:	04 c0       	rjmp	.+8      	; 0x6218 <__stack+0x219>
    6210:	88 e1       	ldi	r24, 0x18	; 24
    6212:	90 e0       	ldi	r25, 0x00	; 0
    6214:	a0 e0       	ldi	r26, 0x00	; 0
    6216:	b0 e0       	ldi	r27, 0x00	; 0
    6218:	b5 01       	movw	r22, r10
    621a:	a4 01       	movw	r20, r8
    621c:	08 2e       	mov	r0, r24
    621e:	04 c0       	rjmp	.+8      	; 0x6228 <__stack+0x229>
    6220:	76 95       	lsr	r23
    6222:	67 95       	ror	r22
    6224:	57 95       	ror	r21
    6226:	47 95       	ror	r20
    6228:	0a 94       	dec	r0
    622a:	d2 f7       	brpl	.-12     	; 0x6220 <__stack+0x221>
    622c:	fa 01       	movw	r30, r20
    622e:	e9 5c       	subi	r30, 0xC9	; 201
    6230:	ff 4d       	sbci	r31, 0xDF	; 223
    6232:	20 81       	ld	r18, Z
    6234:	ac 01       	movw	r20, r24
    6236:	bd 01       	movw	r22, r26
    6238:	42 0f       	add	r20, r18
    623a:	51 1d       	adc	r21, r1
    623c:	61 1d       	adc	r22, r1
    623e:	71 1d       	adc	r23, r1
    6240:	80 e2       	ldi	r24, 0x20	; 32
    6242:	90 e0       	ldi	r25, 0x00	; 0
    6244:	a0 e0       	ldi	r26, 0x00	; 0
    6246:	b0 e0       	ldi	r27, 0x00	; 0
    6248:	84 1b       	sub	r24, r20
    624a:	95 0b       	sbc	r25, r21
    624c:	a6 0b       	sbc	r26, r22
    624e:	b7 0b       	sbc	r27, r23
    6250:	51 f4       	brne	.+20     	; 0x6266 <__stack+0x267>
    6252:	c8 18       	sub	r12, r8
    6254:	d9 08       	sbc	r13, r9
    6256:	ea 08       	sbc	r14, r10
    6258:	fb 08       	sbc	r15, r11
    625a:	f1 e0       	ldi	r31, 0x01	; 1
    625c:	4f 2e       	mov	r4, r31
    625e:	51 2c       	mov	r5, r1
    6260:	61 2c       	mov	r6, r1
    6262:	71 2c       	mov	r7, r1
    6264:	28 c1       	rjmp	.+592    	; 0x64b6 <__stack+0x4b7>
    6266:	08 2e       	mov	r0, r24
    6268:	04 c0       	rjmp	.+8      	; 0x6272 <__stack+0x273>
    626a:	88 0c       	add	r8, r8
    626c:	99 1c       	adc	r9, r9
    626e:	aa 1c       	adc	r10, r10
    6270:	bb 1c       	adc	r11, r11
    6272:	0a 94       	dec	r0
    6274:	d2 f7       	brpl	.-12     	; 0x626a <__stack+0x26b>
    6276:	97 01       	movw	r18, r14
    6278:	86 01       	movw	r16, r12
    627a:	04 2e       	mov	r0, r20
    627c:	04 c0       	rjmp	.+8      	; 0x6286 <__stack+0x287>
    627e:	36 95       	lsr	r19
    6280:	27 95       	ror	r18
    6282:	17 95       	ror	r17
    6284:	07 95       	ror	r16
    6286:	0a 94       	dec	r0
    6288:	d2 f7       	brpl	.-12     	; 0x627e <__stack+0x27f>
    628a:	09 ab       	sts	0x59, r16
    628c:	1a ab       	sts	0x5a, r17
    628e:	2b ab       	sts	0x5b, r18
    6290:	3c ab       	sts	0x5c, r19
    6292:	97 01       	movw	r18, r14
    6294:	86 01       	movw	r16, r12
    6296:	08 2e       	mov	r0, r24
    6298:	04 c0       	rjmp	.+8      	; 0x62a2 <__stack+0x2a3>
    629a:	00 0f       	add	r16, r16
    629c:	11 1f       	adc	r17, r17
    629e:	22 1f       	adc	r18, r18
    62a0:	33 1f       	adc	r19, r19
    62a2:	0a 94       	dec	r0
    62a4:	d2 f7       	brpl	.-12     	; 0x629a <__stack+0x29b>
    62a6:	0d a7       	lds	r16, 0x7d
    62a8:	1e a7       	lds	r17, 0x7e
    62aa:	2f a7       	lds	r18, 0x7f
    62ac:	38 ab       	sts	0x58, r19
    62ae:	ed a8       	sts	0x8d, r30
    62b0:	fe a8       	sts	0x8e, r31
    62b2:	0f a9       	sts	0x4f, r16
    62b4:	18 ad       	sts	0x68, r17
    62b6:	04 c0       	rjmp	.+8      	; 0x62c0 <__stack+0x2c1>
    62b8:	16 95       	lsr	r17
    62ba:	07 95       	ror	r16
    62bc:	f7 94       	ror	r15
    62be:	e7 94       	ror	r14
    62c0:	4a 95       	dec	r20
    62c2:	d2 f7       	brpl	.-12     	; 0x62b8 <__stack+0x2b9>
    62c4:	b8 01       	movw	r22, r16
    62c6:	a7 01       	movw	r20, r14
    62c8:	0d a5       	lds	r16, 0x6d
    62ca:	1e a5       	lds	r17, 0x6e
    62cc:	2f a5       	lds	r18, 0x6f
    62ce:	38 a9       	sts	0x48, r19
    62d0:	04 2b       	or	r16, r20
    62d2:	15 2b       	or	r17, r21
    62d4:	26 2b       	or	r18, r22
    62d6:	37 2b       	or	r19, r23
    62d8:	0d a7       	lds	r16, 0x7d
    62da:	1e a7       	lds	r17, 0x7e
    62dc:	2f a7       	lds	r18, 0x7f
    62de:	38 ab       	sts	0x58, r19
    62e0:	ed a8       	sts	0x8d, r30
    62e2:	fe a8       	sts	0x8e, r31
    62e4:	0f a9       	sts	0x4f, r16
    62e6:	18 ad       	sts	0x68, r17
    62e8:	04 c0       	rjmp	.+8      	; 0x62f2 <__stack+0x2f3>
    62ea:	ee 0c       	add	r14, r14
    62ec:	ff 1c       	adc	r15, r15
    62ee:	00 1f       	adc	r16, r16
    62f0:	11 1f       	adc	r17, r17
    62f2:	8a 95       	dec	r24
    62f4:	d2 f7       	brpl	.-12     	; 0x62ea <__stack+0x2eb>
    62f6:	ed aa       	sts	0x9d, r30
    62f8:	fe aa       	sts	0x9e, r31
    62fa:	0f ab       	sts	0x5f, r16
    62fc:	18 af       	sts	0x78, r17
    62fe:	25 01       	movw	r4, r10
    6300:	66 24       	eor	r6, r6
    6302:	77 24       	eor	r7, r7
    6304:	95 01       	movw	r18, r10
    6306:	84 01       	movw	r16, r8
    6308:	20 70       	andi	r18, 0x00	; 0
    630a:	30 70       	andi	r19, 0x00	; 0
    630c:	09 af       	sts	0x79, r16
    630e:	1a af       	sts	0x7a, r17
    6310:	2b af       	sts	0x7b, r18
    6312:	3c af       	sts	0x7c, r19
    6314:	69 a9       	sts	0x49, r22
    6316:	7a a9       	sts	0x4a, r23
    6318:	8b a9       	sts	0x4b, r24
    631a:	9c a9       	sts	0x4c, r25
    631c:	a3 01       	movw	r20, r6
    631e:	92 01       	movw	r18, r4
    6320:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    6324:	29 a7       	lds	r18, 0x79
    6326:	3a a7       	lds	r19, 0x7a
    6328:	4b a7       	lds	r20, 0x7b
    632a:	5c a7       	lds	r21, 0x7c
    632c:	6b 01       	movw	r12, r22
    632e:	7c 01       	movw	r14, r24
    6330:	69 a9       	sts	0x49, r22
    6332:	7a a9       	sts	0x4a, r23
    6334:	8b a9       	sts	0x4b, r24
    6336:	9c a9       	sts	0x4c, r25
    6338:	a3 01       	movw	r20, r6
    633a:	92 01       	movw	r18, r4
    633c:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    6340:	ca 01       	movw	r24, r20
    6342:	b9 01       	movw	r22, r18
    6344:	29 ad       	sts	0x69, r18
    6346:	3a ad       	sts	0x6a, r19
    6348:	4b ad       	sts	0x6b, r20
    634a:	5c ad       	sts	0x6c, r21
    634c:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6350:	ab 01       	movw	r20, r22
    6352:	bc 01       	movw	r22, r24
    6354:	76 01       	movw	r14, r12
    6356:	dd 24       	eor	r13, r13
    6358:	cc 24       	eor	r12, r12
    635a:	0d a5       	lds	r16, 0x6d
    635c:	1e a5       	lds	r17, 0x6e
    635e:	2f a5       	lds	r18, 0x6f
    6360:	38 a9       	sts	0x48, r19
    6362:	c9 01       	movw	r24, r18
    6364:	aa 27       	eor	r26, r26
    6366:	bb 27       	eor	r27, r27
    6368:	c8 2a       	or	r12, r24
    636a:	d9 2a       	or	r13, r25
    636c:	ea 2a       	or	r14, r26
    636e:	fb 2a       	or	r15, r27
    6370:	09 a5       	lds	r16, 0x69
    6372:	1a a5       	lds	r17, 0x6a
    6374:	2b a5       	lds	r18, 0x6b
    6376:	3c a5       	lds	r19, 0x6c
    6378:	c4 16       	cp	r12, r20
    637a:	d5 06       	cpc	r13, r21
    637c:	e6 06       	cpc	r14, r22
    637e:	f7 06       	cpc	r15, r23
    6380:	38 f5       	brcc	.+78     	; 0x63d0 <__stack+0x3d1>
    6382:	01 50       	subi	r16, 0x01	; 1
    6384:	10 40       	sbci	r17, 0x00	; 0
    6386:	20 40       	sbci	r18, 0x00	; 0
    6388:	30 40       	sbci	r19, 0x00	; 0
    638a:	09 ab       	sts	0x59, r16
    638c:	1a ab       	sts	0x5a, r17
    638e:	2b ab       	sts	0x5b, r18
    6390:	3c ab       	sts	0x5c, r19
    6392:	c8 0c       	add	r12, r8
    6394:	d9 1c       	adc	r13, r9
    6396:	ea 1c       	adc	r14, r10
    6398:	fb 1c       	adc	r15, r11
    639a:	c8 14       	cp	r12, r8
    639c:	d9 04       	cpc	r13, r9
    639e:	ea 04       	cpc	r14, r10
    63a0:	fb 04       	cpc	r15, r11
    63a2:	d0 f0       	brcs	.+52     	; 0x63d8 <__stack+0x3d9>
    63a4:	c4 16       	cp	r12, r20
    63a6:	d5 06       	cpc	r13, r21
    63a8:	e6 06       	cpc	r14, r22
    63aa:	f7 06       	cpc	r15, r23
    63ac:	a8 f4       	brcc	.+42     	; 0x63d8 <__stack+0x3d9>
    63ae:	09 a5       	lds	r16, 0x69
    63b0:	1a a5       	lds	r17, 0x6a
    63b2:	2b a5       	lds	r18, 0x6b
    63b4:	3c a5       	lds	r19, 0x6c
    63b6:	02 50       	subi	r16, 0x02	; 2
    63b8:	10 40       	sbci	r17, 0x00	; 0
    63ba:	20 40       	sbci	r18, 0x00	; 0
    63bc:	30 40       	sbci	r19, 0x00	; 0
    63be:	09 ab       	sts	0x59, r16
    63c0:	1a ab       	sts	0x5a, r17
    63c2:	2b ab       	sts	0x5b, r18
    63c4:	3c ab       	sts	0x5c, r19
    63c6:	c8 0c       	add	r12, r8
    63c8:	d9 1c       	adc	r13, r9
    63ca:	ea 1c       	adc	r14, r10
    63cc:	fb 1c       	adc	r15, r11
    63ce:	04 c0       	rjmp	.+8      	; 0x63d8 <__stack+0x3d9>
    63d0:	09 ab       	sts	0x59, r16
    63d2:	1a ab       	sts	0x5a, r17
    63d4:	2b ab       	sts	0x5b, r18
    63d6:	3c ab       	sts	0x5c, r19
    63d8:	c4 1a       	sub	r12, r20
    63da:	d5 0a       	sbc	r13, r21
    63dc:	e6 0a       	sbc	r14, r22
    63de:	f7 0a       	sbc	r15, r23
    63e0:	c7 01       	movw	r24, r14
    63e2:	b6 01       	movw	r22, r12
    63e4:	a3 01       	movw	r20, r6
    63e6:	92 01       	movw	r18, r4
    63e8:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    63ec:	29 a7       	lds	r18, 0x79
    63ee:	3a a7       	lds	r19, 0x7a
    63f0:	4b a7       	lds	r20, 0x7b
    63f2:	5c a7       	lds	r21, 0x7c
    63f4:	21 96       	adiw	r28, 0x01	; 1
    63f6:	6c af       	sts	0x7c, r22
    63f8:	7d af       	sts	0x7d, r23
    63fa:	8e af       	sts	0x7e, r24
    63fc:	9f af       	sts	0x7f, r25
    63fe:	21 97       	sbiw	r28, 0x01	; 1
    6400:	c7 01       	movw	r24, r14
    6402:	b6 01       	movw	r22, r12
    6404:	a3 01       	movw	r20, r6
    6406:	92 01       	movw	r18, r4
    6408:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    640c:	ca 01       	movw	r24, r20
    640e:	b9 01       	movw	r22, r18
    6410:	29 ad       	sts	0x69, r18
    6412:	3a ad       	sts	0x6a, r19
    6414:	4b ad       	sts	0x6b, r20
    6416:	5c ad       	sts	0x6c, r21
    6418:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    641c:	8b 01       	movw	r16, r22
    641e:	9c 01       	movw	r18, r24
    6420:	21 96       	adiw	r28, 0x01	; 1
    6422:	4c ad       	sts	0x6c, r20
    6424:	5d ad       	sts	0x6d, r21
    6426:	6e ad       	sts	0x6e, r22
    6428:	7f ad       	sts	0x6f, r23
    642a:	21 97       	sbiw	r28, 0x01	; 1
    642c:	da 01       	movw	r26, r20
    642e:	99 27       	eor	r25, r25
    6430:	88 27       	eor	r24, r24
    6432:	4d a5       	lds	r20, 0x6d
    6434:	5e a5       	lds	r21, 0x6e
    6436:	6f a5       	lds	r22, 0x6f
    6438:	78 a9       	sts	0x48, r23
    643a:	60 70       	andi	r22, 0x00	; 0
    643c:	70 70       	andi	r23, 0x00	; 0
    643e:	84 2b       	or	r24, r20
    6440:	95 2b       	or	r25, r21
    6442:	a6 2b       	or	r26, r22
    6444:	b7 2b       	or	r27, r23
    6446:	49 a5       	lds	r20, 0x69
    6448:	5a a5       	lds	r21, 0x6a
    644a:	6b a5       	lds	r22, 0x6b
    644c:	7c a5       	lds	r23, 0x6c
    644e:	80 17       	cp	r24, r16
    6450:	91 07       	cpc	r25, r17
    6452:	a2 07       	cpc	r26, r18
    6454:	b3 07       	cpc	r27, r19
    6456:	f0 f4       	brcc	.+60     	; 0x6494 <__stack+0x495>
    6458:	41 50       	subi	r20, 0x01	; 1
    645a:	50 40       	sbci	r21, 0x00	; 0
    645c:	60 40       	sbci	r22, 0x00	; 0
    645e:	70 40       	sbci	r23, 0x00	; 0
    6460:	88 0d       	add	r24, r8
    6462:	99 1d       	adc	r25, r9
    6464:	aa 1d       	adc	r26, r10
    6466:	bb 1d       	adc	r27, r11
    6468:	88 15       	cp	r24, r8
    646a:	99 05       	cpc	r25, r9
    646c:	aa 05       	cpc	r26, r10
    646e:	bb 05       	cpc	r27, r11
    6470:	88 f0       	brcs	.+34     	; 0x6494 <__stack+0x495>
    6472:	80 17       	cp	r24, r16
    6474:	91 07       	cpc	r25, r17
    6476:	a2 07       	cpc	r26, r18
    6478:	b3 07       	cpc	r27, r19
    647a:	60 f4       	brcc	.+24     	; 0x6494 <__stack+0x495>
    647c:	49 a5       	lds	r20, 0x69
    647e:	5a a5       	lds	r21, 0x6a
    6480:	6b a5       	lds	r22, 0x6b
    6482:	7c a5       	lds	r23, 0x6c
    6484:	42 50       	subi	r20, 0x02	; 2
    6486:	50 40       	sbci	r21, 0x00	; 0
    6488:	60 40       	sbci	r22, 0x00	; 0
    648a:	70 40       	sbci	r23, 0x00	; 0
    648c:	88 0d       	add	r24, r8
    648e:	99 1d       	adc	r25, r9
    6490:	aa 1d       	adc	r26, r10
    6492:	bb 1d       	adc	r27, r11
    6494:	6c 01       	movw	r12, r24
    6496:	7d 01       	movw	r14, r26
    6498:	c0 1a       	sub	r12, r16
    649a:	d1 0a       	sbc	r13, r17
    649c:	e2 0a       	sbc	r14, r18
    649e:	f3 0a       	sbc	r15, r19
    64a0:	09 a9       	sts	0x49, r16
    64a2:	1a a9       	sts	0x4a, r17
    64a4:	2b a9       	sts	0x4b, r18
    64a6:	3c a9       	sts	0x4c, r19
    64a8:	38 01       	movw	r6, r16
    64aa:	55 24       	eor	r5, r5
    64ac:	44 24       	eor	r4, r4
    64ae:	44 2a       	or	r4, r20
    64b0:	55 2a       	or	r5, r21
    64b2:	66 2a       	or	r6, r22
    64b4:	77 2a       	or	r7, r23
    64b6:	85 01       	movw	r16, r10
    64b8:	22 27       	eor	r18, r18
    64ba:	33 27       	eor	r19, r19
    64bc:	0d a7       	lds	r16, 0x7d
    64be:	1e a7       	lds	r17, 0x7e
    64c0:	2f a7       	lds	r18, 0x7f
    64c2:	38 ab       	sts	0x58, r19
    64c4:	95 01       	movw	r18, r10
    64c6:	84 01       	movw	r16, r8
    64c8:	20 70       	andi	r18, 0x00	; 0
    64ca:	30 70       	andi	r19, 0x00	; 0
    64cc:	09 af       	sts	0x79, r16
    64ce:	1a af       	sts	0x7a, r17
    64d0:	2b af       	sts	0x7b, r18
    64d2:	3c af       	sts	0x7c, r19
    64d4:	c7 01       	movw	r24, r14
    64d6:	b6 01       	movw	r22, r12
    64d8:	2d a5       	lds	r18, 0x6d
    64da:	3e a5       	lds	r19, 0x6e
    64dc:	4f a5       	lds	r20, 0x6f
    64de:	58 a9       	sts	0x48, r21
    64e0:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    64e4:	29 a7       	lds	r18, 0x79
    64e6:	3a a7       	lds	r19, 0x7a
    64e8:	4b a7       	lds	r20, 0x7b
    64ea:	5c a7       	lds	r21, 0x7c
    64ec:	69 ab       	sts	0x59, r22
    64ee:	7a ab       	sts	0x5a, r23
    64f0:	8b ab       	sts	0x5b, r24
    64f2:	9c ab       	sts	0x5c, r25
    64f4:	c7 01       	movw	r24, r14
    64f6:	b6 01       	movw	r22, r12
    64f8:	2d a5       	lds	r18, 0x6d
    64fa:	3e a5       	lds	r19, 0x6e
    64fc:	4f a5       	lds	r20, 0x6f
    64fe:	58 a9       	sts	0x48, r21
    6500:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    6504:	ca 01       	movw	r24, r20
    6506:	b9 01       	movw	r22, r18
    6508:	29 ad       	sts	0x69, r18
    650a:	3a ad       	sts	0x6a, r19
    650c:	4b ad       	sts	0x6b, r20
    650e:	5c ad       	sts	0x6c, r21
    6510:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6514:	ab 01       	movw	r20, r22
    6516:	bc 01       	movw	r22, r24
    6518:	09 a9       	sts	0x49, r16
    651a:	1a a9       	sts	0x4a, r17
    651c:	2b a9       	sts	0x4b, r18
    651e:	3c a9       	sts	0x4c, r19
    6520:	78 01       	movw	r14, r16
    6522:	dd 24       	eor	r13, r13
    6524:	cc 24       	eor	r12, r12
    6526:	0d a9       	sts	0x4d, r16
    6528:	1e a9       	sts	0x4e, r17
    652a:	2f a9       	sts	0x4f, r18
    652c:	38 ad       	sts	0x68, r19
    652e:	c9 01       	movw	r24, r18
    6530:	aa 27       	eor	r26, r26
    6532:	bb 27       	eor	r27, r27
    6534:	c8 2a       	or	r12, r24
    6536:	d9 2a       	or	r13, r25
    6538:	ea 2a       	or	r14, r26
    653a:	fb 2a       	or	r15, r27
    653c:	09 a5       	lds	r16, 0x69
    653e:	1a a5       	lds	r17, 0x6a
    6540:	2b a5       	lds	r18, 0x6b
    6542:	3c a5       	lds	r19, 0x6c
    6544:	c4 16       	cp	r12, r20
    6546:	d5 06       	cpc	r13, r21
    6548:	e6 06       	cpc	r14, r22
    654a:	f7 06       	cpc	r15, r23
    654c:	38 f5       	brcc	.+78     	; 0x659c <__stack+0x59d>
    654e:	01 50       	subi	r16, 0x01	; 1
    6550:	10 40       	sbci	r17, 0x00	; 0
    6552:	20 40       	sbci	r18, 0x00	; 0
    6554:	30 40       	sbci	r19, 0x00	; 0
    6556:	09 ab       	sts	0x59, r16
    6558:	1a ab       	sts	0x5a, r17
    655a:	2b ab       	sts	0x5b, r18
    655c:	3c ab       	sts	0x5c, r19
    655e:	c8 0c       	add	r12, r8
    6560:	d9 1c       	adc	r13, r9
    6562:	ea 1c       	adc	r14, r10
    6564:	fb 1c       	adc	r15, r11
    6566:	c8 14       	cp	r12, r8
    6568:	d9 04       	cpc	r13, r9
    656a:	ea 04       	cpc	r14, r10
    656c:	fb 04       	cpc	r15, r11
    656e:	d0 f0       	brcs	.+52     	; 0x65a4 <__stack+0x5a5>
    6570:	c4 16       	cp	r12, r20
    6572:	d5 06       	cpc	r13, r21
    6574:	e6 06       	cpc	r14, r22
    6576:	f7 06       	cpc	r15, r23
    6578:	a8 f4       	brcc	.+42     	; 0x65a4 <__stack+0x5a5>
    657a:	09 a5       	lds	r16, 0x69
    657c:	1a a5       	lds	r17, 0x6a
    657e:	2b a5       	lds	r18, 0x6b
    6580:	3c a5       	lds	r19, 0x6c
    6582:	02 50       	subi	r16, 0x02	; 2
    6584:	10 40       	sbci	r17, 0x00	; 0
    6586:	20 40       	sbci	r18, 0x00	; 0
    6588:	30 40       	sbci	r19, 0x00	; 0
    658a:	09 ab       	sts	0x59, r16
    658c:	1a ab       	sts	0x5a, r17
    658e:	2b ab       	sts	0x5b, r18
    6590:	3c ab       	sts	0x5c, r19
    6592:	c8 0c       	add	r12, r8
    6594:	d9 1c       	adc	r13, r9
    6596:	ea 1c       	adc	r14, r10
    6598:	fb 1c       	adc	r15, r11
    659a:	04 c0       	rjmp	.+8      	; 0x65a4 <__stack+0x5a5>
    659c:	09 ab       	sts	0x59, r16
    659e:	1a ab       	sts	0x5a, r17
    65a0:	2b ab       	sts	0x5b, r18
    65a2:	3c ab       	sts	0x5c, r19
    65a4:	c4 1a       	sub	r12, r20
    65a6:	d5 0a       	sbc	r13, r21
    65a8:	e6 0a       	sbc	r14, r22
    65aa:	f7 0a       	sbc	r15, r23
    65ac:	c7 01       	movw	r24, r14
    65ae:	b6 01       	movw	r22, r12
    65b0:	2d a5       	lds	r18, 0x6d
    65b2:	3e a5       	lds	r19, 0x6e
    65b4:	4f a5       	lds	r20, 0x6f
    65b6:	58 a9       	sts	0x48, r21
    65b8:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    65bc:	29 a7       	lds	r18, 0x79
    65be:	3a a7       	lds	r19, 0x7a
    65c0:	4b a7       	lds	r20, 0x7b
    65c2:	5c a7       	lds	r21, 0x7c
    65c4:	21 96       	adiw	r28, 0x01	; 1
    65c6:	6c af       	sts	0x7c, r22
    65c8:	7d af       	sts	0x7d, r23
    65ca:	8e af       	sts	0x7e, r24
    65cc:	9f af       	sts	0x7f, r25
    65ce:	21 97       	sbiw	r28, 0x01	; 1
    65d0:	c7 01       	movw	r24, r14
    65d2:	b6 01       	movw	r22, r12
    65d4:	2d a5       	lds	r18, 0x6d
    65d6:	3e a5       	lds	r19, 0x6e
    65d8:	4f a5       	lds	r20, 0x6f
    65da:	58 a9       	sts	0x48, r21
    65dc:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    65e0:	ca 01       	movw	r24, r20
    65e2:	b9 01       	movw	r22, r18
    65e4:	29 ad       	sts	0x69, r18
    65e6:	3a ad       	sts	0x6a, r19
    65e8:	4b ad       	sts	0x6b, r20
    65ea:	5c ad       	sts	0x6c, r21
    65ec:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    65f0:	8b 01       	movw	r16, r22
    65f2:	9c 01       	movw	r18, r24
    65f4:	21 96       	adiw	r28, 0x01	; 1
    65f6:	4c ad       	sts	0x6c, r20
    65f8:	5d ad       	sts	0x6d, r21
    65fa:	6e ad       	sts	0x6e, r22
    65fc:	7f ad       	sts	0x6f, r23
    65fe:	21 97       	sbiw	r28, 0x01	; 1
    6600:	da 01       	movw	r26, r20
    6602:	99 27       	eor	r25, r25
    6604:	88 27       	eor	r24, r24
    6606:	4d a9       	sts	0x4d, r20
    6608:	5e a9       	sts	0x4e, r21
    660a:	6f a9       	sts	0x4f, r22
    660c:	78 ad       	sts	0x68, r23
    660e:	60 70       	andi	r22, 0x00	; 0
    6610:	70 70       	andi	r23, 0x00	; 0
    6612:	84 2b       	or	r24, r20
    6614:	95 2b       	or	r25, r21
    6616:	a6 2b       	or	r26, r22
    6618:	b7 2b       	or	r27, r23
    661a:	49 a5       	lds	r20, 0x69
    661c:	5a a5       	lds	r21, 0x6a
    661e:	6b a5       	lds	r22, 0x6b
    6620:	7c a5       	lds	r23, 0x6c
    6622:	80 17       	cp	r24, r16
    6624:	91 07       	cpc	r25, r17
    6626:	a2 07       	cpc	r26, r18
    6628:	b3 07       	cpc	r27, r19
    662a:	d0 f4       	brcc	.+52     	; 0x6660 <__stack+0x661>
    662c:	41 50       	subi	r20, 0x01	; 1
    662e:	50 40       	sbci	r21, 0x00	; 0
    6630:	60 40       	sbci	r22, 0x00	; 0
    6632:	70 40       	sbci	r23, 0x00	; 0
    6634:	88 0d       	add	r24, r8
    6636:	99 1d       	adc	r25, r9
    6638:	aa 1d       	adc	r26, r10
    663a:	bb 1d       	adc	r27, r11
    663c:	88 15       	cp	r24, r8
    663e:	99 05       	cpc	r25, r9
    6640:	aa 05       	cpc	r26, r10
    6642:	bb 05       	cpc	r27, r11
    6644:	68 f0       	brcs	.+26     	; 0x6660 <__stack+0x661>
    6646:	80 17       	cp	r24, r16
    6648:	91 07       	cpc	r25, r17
    664a:	a2 07       	cpc	r26, r18
    664c:	b3 07       	cpc	r27, r19
    664e:	40 f4       	brcc	.+16     	; 0x6660 <__stack+0x661>
    6650:	49 a5       	lds	r20, 0x69
    6652:	5a a5       	lds	r21, 0x6a
    6654:	6b a5       	lds	r22, 0x6b
    6656:	7c a5       	lds	r23, 0x6c
    6658:	42 50       	subi	r20, 0x02	; 2
    665a:	50 40       	sbci	r21, 0x00	; 0
    665c:	60 40       	sbci	r22, 0x00	; 0
    665e:	70 40       	sbci	r23, 0x00	; 0
    6660:	09 a9       	sts	0x49, r16
    6662:	1a a9       	sts	0x4a, r17
    6664:	2b a9       	sts	0x4b, r18
    6666:	3c a9       	sts	0x4c, r19
    6668:	78 01       	movw	r14, r16
    666a:	dd 24       	eor	r13, r13
    666c:	cc 24       	eor	r12, r12
    666e:	c4 2a       	or	r12, r20
    6670:	d5 2a       	or	r13, r21
    6672:	e6 2a       	or	r14, r22
    6674:	f7 2a       	or	r15, r23
    6676:	50 c2       	rjmp	.+1184   	; 0x6b18 <__stack+0xb19>
    6678:	c8 16       	cp	r12, r24
    667a:	d9 06       	cpc	r13, r25
    667c:	ea 06       	cpc	r14, r26
    667e:	fb 06       	cpc	r15, r27
    6680:	08 f4       	brcc	.+2      	; 0x6684 <__stack+0x685>
    6682:	37 c2       	rjmp	.+1134   	; 0x6af2 <__stack+0xaf3>
    6684:	80 30       	cpi	r24, 0x00	; 0
    6686:	10 e0       	ldi	r17, 0x00	; 0
    6688:	91 07       	cpc	r25, r17
    668a:	11 e0       	ldi	r17, 0x01	; 1
    668c:	a1 07       	cpc	r26, r17
    668e:	10 e0       	ldi	r17, 0x00	; 0
    6690:	b1 07       	cpc	r27, r17
    6692:	50 f4       	brcc	.+20     	; 0x66a8 <__stack+0x6a9>
    6694:	8f 3f       	cpi	r24, 0xFF	; 255
    6696:	91 05       	cpc	r25, r1
    6698:	a1 05       	cpc	r26, r1
    669a:	b1 05       	cpc	r27, r1
    669c:	09 f0       	breq	.+2      	; 0x66a0 <__stack+0x6a1>
    669e:	88 f4       	brcc	.+34     	; 0x66c2 <__stack+0x6c3>
    66a0:	00 e0       	ldi	r16, 0x00	; 0
    66a2:	10 e0       	ldi	r17, 0x00	; 0
    66a4:	98 01       	movw	r18, r16
    66a6:	16 c0       	rjmp	.+44     	; 0x66d4 <__stack+0x6d5>
    66a8:	80 30       	cpi	r24, 0x00	; 0
    66aa:	20 e0       	ldi	r18, 0x00	; 0
    66ac:	92 07       	cpc	r25, r18
    66ae:	20 e0       	ldi	r18, 0x00	; 0
    66b0:	a2 07       	cpc	r26, r18
    66b2:	21 e0       	ldi	r18, 0x01	; 1
    66b4:	b2 07       	cpc	r27, r18
    66b6:	50 f4       	brcc	.+20     	; 0x66cc <__stack+0x6cd>
    66b8:	00 e1       	ldi	r16, 0x10	; 16
    66ba:	10 e0       	ldi	r17, 0x00	; 0
    66bc:	20 e0       	ldi	r18, 0x00	; 0
    66be:	30 e0       	ldi	r19, 0x00	; 0
    66c0:	09 c0       	rjmp	.+18     	; 0x66d4 <__stack+0x6d5>
    66c2:	08 e0       	ldi	r16, 0x08	; 8
    66c4:	10 e0       	ldi	r17, 0x00	; 0
    66c6:	20 e0       	ldi	r18, 0x00	; 0
    66c8:	30 e0       	ldi	r19, 0x00	; 0
    66ca:	04 c0       	rjmp	.+8      	; 0x66d4 <__stack+0x6d5>
    66cc:	08 e1       	ldi	r16, 0x18	; 24
    66ce:	10 e0       	ldi	r17, 0x00	; 0
    66d0:	20 e0       	ldi	r18, 0x00	; 0
    66d2:	30 e0       	ldi	r19, 0x00	; 0
    66d4:	ac 01       	movw	r20, r24
    66d6:	bd 01       	movw	r22, r26
    66d8:	00 2e       	mov	r0, r16
    66da:	04 c0       	rjmp	.+8      	; 0x66e4 <__stack+0x6e5>
    66dc:	76 95       	lsr	r23
    66de:	67 95       	ror	r22
    66e0:	57 95       	ror	r21
    66e2:	47 95       	ror	r20
    66e4:	0a 94       	dec	r0
    66e6:	d2 f7       	brpl	.-12     	; 0x66dc <__stack+0x6dd>
    66e8:	fa 01       	movw	r30, r20
    66ea:	e9 5c       	subi	r30, 0xC9	; 201
    66ec:	ff 4d       	sbci	r31, 0xDF	; 223
    66ee:	40 81       	ld	r20, Z
    66f0:	04 0f       	add	r16, r20
    66f2:	11 1d       	adc	r17, r1
    66f4:	21 1d       	adc	r18, r1
    66f6:	31 1d       	adc	r19, r1
    66f8:	40 e2       	ldi	r20, 0x20	; 32
    66fa:	50 e0       	ldi	r21, 0x00	; 0
    66fc:	60 e0       	ldi	r22, 0x00	; 0
    66fe:	70 e0       	ldi	r23, 0x00	; 0
    6700:	40 1b       	sub	r20, r16
    6702:	51 0b       	sbc	r21, r17
    6704:	62 0b       	sbc	r22, r18
    6706:	73 0b       	sbc	r23, r19
    6708:	a1 f4       	brne	.+40     	; 0x6732 <__stack+0x733>
    670a:	8c 15       	cp	r24, r12
    670c:	9d 05       	cpc	r25, r13
    670e:	ae 05       	cpc	r26, r14
    6710:	bf 05       	cpc	r27, r15
    6712:	08 f4       	brcc	.+2      	; 0x6716 <__stack+0x717>
    6714:	f5 c1       	rjmp	.+1002   	; 0x6b00 <__stack+0xb01>
    6716:	ed a8       	sts	0x8d, r30
    6718:	fe a8       	sts	0x8e, r31
    671a:	0f a9       	sts	0x4f, r16
    671c:	18 ad       	sts	0x68, r17
    671e:	44 24       	eor	r4, r4
    6720:	55 24       	eor	r5, r5
    6722:	32 01       	movw	r6, r4
    6724:	e8 14       	cp	r14, r8
    6726:	f9 04       	cpc	r15, r9
    6728:	0a 05       	cpc	r16, r10
    672a:	1b 05       	cpc	r17, r11
    672c:	08 f0       	brcs	.+2      	; 0x6730 <__stack+0x731>
    672e:	eb c1       	rjmp	.+982    	; 0x6b06 <__stack+0xb07>
    6730:	e3 c1       	rjmp	.+966    	; 0x6af8 <__stack+0xaf9>
    6732:	34 2e       	mov	r3, r20
    6734:	2c 01       	movw	r4, r24
    6736:	3d 01       	movw	r6, r26
    6738:	04 c0       	rjmp	.+8      	; 0x6742 <__stack+0x743>
    673a:	44 0c       	add	r4, r4
    673c:	55 1c       	adc	r5, r5
    673e:	66 1c       	adc	r6, r6
    6740:	77 1c       	adc	r7, r7
    6742:	4a 95       	dec	r20
    6744:	d2 f7       	brpl	.-12     	; 0x673a <__stack+0x73b>
    6746:	d5 01       	movw	r26, r10
    6748:	c4 01       	movw	r24, r8
    674a:	00 2e       	mov	r0, r16
    674c:	04 c0       	rjmp	.+8      	; 0x6756 <__stack+0x757>
    674e:	b6 95       	lsr	r27
    6750:	a7 95       	ror	r26
    6752:	97 95       	ror	r25
    6754:	87 95       	ror	r24
    6756:	0a 94       	dec	r0
    6758:	d2 f7       	brpl	.-12     	; 0x674e <__stack+0x74f>
    675a:	48 2a       	or	r4, r24
    675c:	59 2a       	or	r5, r25
    675e:	6a 2a       	or	r6, r26
    6760:	7b 2a       	or	r7, r27
    6762:	a5 01       	movw	r20, r10
    6764:	94 01       	movw	r18, r8
    6766:	03 2c       	mov	r0, r3
    6768:	04 c0       	rjmp	.+8      	; 0x6772 <__stack+0x773>
    676a:	22 0f       	add	r18, r18
    676c:	33 1f       	adc	r19, r19
    676e:	44 1f       	adc	r20, r20
    6770:	55 1f       	adc	r21, r21
    6772:	0a 94       	dec	r0
    6774:	d2 f7       	brpl	.-12     	; 0x676a <__stack+0x76b>
    6776:	29 af       	sts	0x79, r18
    6778:	3a af       	sts	0x7a, r19
    677a:	4b af       	sts	0x7b, r20
    677c:	5c af       	sts	0x7c, r21
    677e:	b7 01       	movw	r22, r14
    6780:	a6 01       	movw	r20, r12
    6782:	00 2e       	mov	r0, r16
    6784:	04 c0       	rjmp	.+8      	; 0x678e <__stack+0x78f>
    6786:	76 95       	lsr	r23
    6788:	67 95       	ror	r22
    678a:	57 95       	ror	r21
    678c:	47 95       	ror	r20
    678e:	0a 94       	dec	r0
    6790:	d2 f7       	brpl	.-12     	; 0x6786 <__stack+0x787>
    6792:	49 ab       	sts	0x59, r20
    6794:	5a ab       	sts	0x5a, r21
    6796:	6b ab       	sts	0x5b, r22
    6798:	7c ab       	sts	0x5c, r23
    679a:	c7 01       	movw	r24, r14
    679c:	b6 01       	movw	r22, r12
    679e:	03 2c       	mov	r0, r3
    67a0:	04 c0       	rjmp	.+8      	; 0x67aa <__stack+0x7ab>
    67a2:	66 0f       	add	r22, r22
    67a4:	77 1f       	adc	r23, r23
    67a6:	88 1f       	adc	r24, r24
    67a8:	99 1f       	adc	r25, r25
    67aa:	0a 94       	dec	r0
    67ac:	d2 f7       	brpl	.-12     	; 0x67a2 <__stack+0x7a3>
    67ae:	6d a7       	lds	r22, 0x7d
    67b0:	7e a7       	lds	r23, 0x7e
    67b2:	8f a7       	lds	r24, 0x7f
    67b4:	98 ab       	sts	0x58, r25
    67b6:	8d a9       	sts	0x4d, r24
    67b8:	9e a9       	sts	0x4e, r25
    67ba:	af a9       	sts	0x4f, r26
    67bc:	b8 ad       	sts	0x68, r27
    67be:	04 c0       	rjmp	.+8      	; 0x67c8 <__stack+0x7c9>
    67c0:	b6 95       	lsr	r27
    67c2:	a7 95       	ror	r26
    67c4:	97 95       	ror	r25
    67c6:	87 95       	ror	r24
    67c8:	0a 95       	dec	r16
    67ca:	d2 f7       	brpl	.-12     	; 0x67c0 <__stack+0x7c1>
    67cc:	4d a5       	lds	r20, 0x6d
    67ce:	5e a5       	lds	r21, 0x6e
    67d0:	6f a5       	lds	r22, 0x6f
    67d2:	78 a9       	sts	0x48, r23
    67d4:	48 2b       	or	r20, r24
    67d6:	59 2b       	or	r21, r25
    67d8:	6a 2b       	or	r22, r26
    67da:	7b 2b       	or	r23, r27
    67dc:	4d a7       	lds	r20, 0x7d
    67de:	5e a7       	lds	r21, 0x7e
    67e0:	6f a7       	lds	r22, 0x7f
    67e2:	78 ab       	sts	0x58, r23
    67e4:	43 01       	movw	r8, r6
    67e6:	aa 24       	eor	r10, r10
    67e8:	bb 24       	eor	r11, r11
    67ea:	93 01       	movw	r18, r6
    67ec:	82 01       	movw	r16, r4
    67ee:	20 70       	andi	r18, 0x00	; 0
    67f0:	30 70       	andi	r19, 0x00	; 0
    67f2:	21 96       	adiw	r28, 0x01	; 1
    67f4:	0c af       	sts	0x7c, r16
    67f6:	1d af       	sts	0x7d, r17
    67f8:	2e af       	sts	0x7e, r18
    67fa:	3f af       	sts	0x7f, r19
    67fc:	21 97       	sbiw	r28, 0x01	; 1
    67fe:	69 a9       	sts	0x49, r22
    6800:	7a a9       	sts	0x4a, r23
    6802:	8b a9       	sts	0x4b, r24
    6804:	9c a9       	sts	0x4c, r25
    6806:	a5 01       	movw	r20, r10
    6808:	94 01       	movw	r18, r8
    680a:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    680e:	29 a7       	lds	r18, 0x79
    6810:	3a a7       	lds	r19, 0x7a
    6812:	4b a7       	lds	r20, 0x7b
    6814:	5c a7       	lds	r21, 0x7c
    6816:	6b 01       	movw	r12, r22
    6818:	7c 01       	movw	r14, r24
    681a:	69 a9       	sts	0x49, r22
    681c:	7a a9       	sts	0x4a, r23
    681e:	8b a9       	sts	0x4b, r24
    6820:	9c a9       	sts	0x4c, r25
    6822:	a5 01       	movw	r20, r10
    6824:	94 01       	movw	r18, r8
    6826:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    682a:	ca 01       	movw	r24, r20
    682c:	b9 01       	movw	r22, r18
    682e:	21 96       	adiw	r28, 0x01	; 1
    6830:	2c ad       	sts	0x6c, r18
    6832:	3d ad       	sts	0x6d, r19
    6834:	4e ad       	sts	0x6e, r20
    6836:	5f ad       	sts	0x6f, r21
    6838:	21 97       	sbiw	r28, 0x01	; 1
    683a:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    683e:	dc 01       	movw	r26, r24
    6840:	cb 01       	movw	r24, r22
    6842:	76 01       	movw	r14, r12
    6844:	dd 24       	eor	r13, r13
    6846:	cc 24       	eor	r12, r12
    6848:	0d a5       	lds	r16, 0x6d
    684a:	1e a5       	lds	r17, 0x6e
    684c:	2f a5       	lds	r18, 0x6f
    684e:	38 a9       	sts	0x48, r19
    6850:	a9 01       	movw	r20, r18
    6852:	66 27       	eor	r22, r22
    6854:	77 27       	eor	r23, r23
    6856:	c4 2a       	or	r12, r20
    6858:	d5 2a       	or	r13, r21
    685a:	e6 2a       	or	r14, r22
    685c:	f7 2a       	or	r15, r23
    685e:	09 a5       	lds	r16, 0x69
    6860:	1a a5       	lds	r17, 0x6a
    6862:	2b a5       	lds	r18, 0x6b
    6864:	3c a5       	lds	r19, 0x6c
    6866:	c8 16       	cp	r12, r24
    6868:	d9 06       	cpc	r13, r25
    686a:	ea 06       	cpc	r14, r26
    686c:	fb 06       	cpc	r15, r27
    686e:	38 f5       	brcc	.+78     	; 0x68be <__stack+0x8bf>
    6870:	01 50       	subi	r16, 0x01	; 1
    6872:	10 40       	sbci	r17, 0x00	; 0
    6874:	20 40       	sbci	r18, 0x00	; 0
    6876:	30 40       	sbci	r19, 0x00	; 0
    6878:	09 ab       	sts	0x59, r16
    687a:	1a ab       	sts	0x5a, r17
    687c:	2b ab       	sts	0x5b, r18
    687e:	3c ab       	sts	0x5c, r19
    6880:	c4 0c       	add	r12, r4
    6882:	d5 1c       	adc	r13, r5
    6884:	e6 1c       	adc	r14, r6
    6886:	f7 1c       	adc	r15, r7
    6888:	c4 14       	cp	r12, r4
    688a:	d5 04       	cpc	r13, r5
    688c:	e6 04       	cpc	r14, r6
    688e:	f7 04       	cpc	r15, r7
    6890:	d0 f0       	brcs	.+52     	; 0x68c6 <__stack+0x8c7>
    6892:	c8 16       	cp	r12, r24
    6894:	d9 06       	cpc	r13, r25
    6896:	ea 06       	cpc	r14, r26
    6898:	fb 06       	cpc	r15, r27
    689a:	a8 f4       	brcc	.+42     	; 0x68c6 <__stack+0x8c7>
    689c:	09 a5       	lds	r16, 0x69
    689e:	1a a5       	lds	r17, 0x6a
    68a0:	2b a5       	lds	r18, 0x6b
    68a2:	3c a5       	lds	r19, 0x6c
    68a4:	02 50       	subi	r16, 0x02	; 2
    68a6:	10 40       	sbci	r17, 0x00	; 0
    68a8:	20 40       	sbci	r18, 0x00	; 0
    68aa:	30 40       	sbci	r19, 0x00	; 0
    68ac:	09 ab       	sts	0x59, r16
    68ae:	1a ab       	sts	0x5a, r17
    68b0:	2b ab       	sts	0x5b, r18
    68b2:	3c ab       	sts	0x5c, r19
    68b4:	c4 0c       	add	r12, r4
    68b6:	d5 1c       	adc	r13, r5
    68b8:	e6 1c       	adc	r14, r6
    68ba:	f7 1c       	adc	r15, r7
    68bc:	04 c0       	rjmp	.+8      	; 0x68c6 <__stack+0x8c7>
    68be:	09 ab       	sts	0x59, r16
    68c0:	1a ab       	sts	0x5a, r17
    68c2:	2b ab       	sts	0x5b, r18
    68c4:	3c ab       	sts	0x5c, r19
    68c6:	c8 1a       	sub	r12, r24
    68c8:	d9 0a       	sbc	r13, r25
    68ca:	ea 0a       	sbc	r14, r26
    68cc:	fb 0a       	sbc	r15, r27
    68ce:	c7 01       	movw	r24, r14
    68d0:	b6 01       	movw	r22, r12
    68d2:	a5 01       	movw	r20, r10
    68d4:	94 01       	movw	r18, r8
    68d6:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    68da:	29 a7       	lds	r18, 0x79
    68dc:	3a a7       	lds	r19, 0x7a
    68de:	4b a7       	lds	r20, 0x7b
    68e0:	5c a7       	lds	r21, 0x7c
    68e2:	29 96       	adiw	r28, 0x09	; 9
    68e4:	6c af       	sts	0x7c, r22
    68e6:	7d af       	sts	0x7d, r23
    68e8:	8e af       	sts	0x7e, r24
    68ea:	9f af       	sts	0x7f, r25
    68ec:	29 97       	sbiw	r28, 0x09	; 9
    68ee:	c7 01       	movw	r24, r14
    68f0:	b6 01       	movw	r22, r12
    68f2:	a5 01       	movw	r20, r10
    68f4:	94 01       	movw	r18, r8
    68f6:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__udivmodsi4>
    68fa:	ca 01       	movw	r24, r20
    68fc:	b9 01       	movw	r22, r18
    68fe:	21 96       	adiw	r28, 0x01	; 1
    6900:	2c ad       	sts	0x6c, r18
    6902:	3d ad       	sts	0x6d, r19
    6904:	4e ad       	sts	0x6e, r20
    6906:	5f ad       	sts	0x6f, r21
    6908:	21 97       	sbiw	r28, 0x01	; 1
    690a:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    690e:	4b 01       	movw	r8, r22
    6910:	5c 01       	movw	r10, r24
    6912:	29 96       	adiw	r28, 0x09	; 9
    6914:	4c ad       	sts	0x6c, r20
    6916:	5d ad       	sts	0x6d, r21
    6918:	6e ad       	sts	0x6e, r22
    691a:	7f ad       	sts	0x6f, r23
    691c:	29 97       	sbiw	r28, 0x09	; 9
    691e:	9a 01       	movw	r18, r20
    6920:	11 27       	eor	r17, r17
    6922:	00 27       	eor	r16, r16
    6924:	8d a5       	lds	r24, 0x6d
    6926:	9e a5       	lds	r25, 0x6e
    6928:	af a5       	lds	r26, 0x6f
    692a:	b8 a9       	sts	0x48, r27
    692c:	a0 70       	andi	r26, 0x00	; 0
    692e:	b0 70       	andi	r27, 0x00	; 0
    6930:	08 2b       	or	r16, r24
    6932:	19 2b       	or	r17, r25
    6934:	2a 2b       	or	r18, r26
    6936:	3b 2b       	or	r19, r27
    6938:	89 a5       	lds	r24, 0x69
    693a:	9a a5       	lds	r25, 0x6a
    693c:	ab a5       	lds	r26, 0x6b
    693e:	bc a5       	lds	r27, 0x6c
    6940:	08 15       	cp	r16, r8
    6942:	19 05       	cpc	r17, r9
    6944:	2a 05       	cpc	r18, r10
    6946:	3b 05       	cpc	r19, r11
    6948:	e0 f4       	brcc	.+56     	; 0x6982 <__stack+0x983>
    694a:	01 97       	sbiw	r24, 0x01	; 1
    694c:	a1 09       	sbc	r26, r1
    694e:	b1 09       	sbc	r27, r1
    6950:	04 0d       	add	r16, r4
    6952:	15 1d       	adc	r17, r5
    6954:	26 1d       	adc	r18, r6
    6956:	37 1d       	adc	r19, r7
    6958:	04 15       	cp	r16, r4
    695a:	15 05       	cpc	r17, r5
    695c:	26 05       	cpc	r18, r6
    695e:	37 05       	cpc	r19, r7
    6960:	80 f0       	brcs	.+32     	; 0x6982 <__stack+0x983>
    6962:	08 15       	cp	r16, r8
    6964:	19 05       	cpc	r17, r9
    6966:	2a 05       	cpc	r18, r10
    6968:	3b 05       	cpc	r19, r11
    696a:	58 f4       	brcc	.+22     	; 0x6982 <__stack+0x983>
    696c:	89 a5       	lds	r24, 0x69
    696e:	9a a5       	lds	r25, 0x6a
    6970:	ab a5       	lds	r26, 0x6b
    6972:	bc a5       	lds	r27, 0x6c
    6974:	02 97       	sbiw	r24, 0x02	; 2
    6976:	a1 09       	sbc	r26, r1
    6978:	b1 09       	sbc	r27, r1
    697a:	04 0d       	add	r16, r4
    697c:	15 1d       	adc	r17, r5
    697e:	26 1d       	adc	r18, r6
    6980:	37 1d       	adc	r19, r7
    6982:	b9 01       	movw	r22, r18
    6984:	a8 01       	movw	r20, r16
    6986:	48 19       	sub	r20, r8
    6988:	59 09       	sbc	r21, r9
    698a:	6a 09       	sbc	r22, r10
    698c:	7b 09       	sbc	r23, r11
    698e:	4d a7       	lds	r20, 0x7d
    6990:	5e a7       	lds	r21, 0x7e
    6992:	6f a7       	lds	r22, 0x7f
    6994:	78 ab       	sts	0x58, r23
    6996:	09 a9       	sts	0x49, r16
    6998:	1a a9       	sts	0x4a, r17
    699a:	2b a9       	sts	0x4b, r18
    699c:	3c a9       	sts	0x4c, r19
    699e:	78 01       	movw	r14, r16
    69a0:	dd 24       	eor	r13, r13
    69a2:	cc 24       	eor	r12, r12
    69a4:	c8 2a       	or	r12, r24
    69a6:	d9 2a       	or	r13, r25
    69a8:	ea 2a       	or	r14, r26
    69aa:	fb 2a       	or	r15, r27
    69ac:	ff ef       	ldi	r31, 0xFF	; 255
    69ae:	8f 2e       	mov	r8, r31
    69b0:	ff ef       	ldi	r31, 0xFF	; 255
    69b2:	9f 2e       	mov	r9, r31
    69b4:	a1 2c       	mov	r10, r1
    69b6:	b1 2c       	mov	r11, r1
    69b8:	8c 20       	and	r8, r12
    69ba:	9d 20       	and	r9, r13
    69bc:	ae 20       	and	r10, r14
    69be:	bf 20       	and	r11, r15
    69c0:	87 01       	movw	r16, r14
    69c2:	22 27       	eor	r18, r18
    69c4:	33 27       	eor	r19, r19
    69c6:	09 a7       	lds	r16, 0x79
    69c8:	1a a7       	lds	r17, 0x7a
    69ca:	2b a7       	lds	r18, 0x7b
    69cc:	3c a7       	lds	r19, 0x7c
    69ce:	49 ac       	sts	0xa9, r20
    69d0:	5a ac       	sts	0xaa, r21
    69d2:	6b ac       	sts	0xab, r22
    69d4:	7c ac       	sts	0xac, r23
    69d6:	2f ef       	ldi	r18, 0xFF	; 255
    69d8:	3f ef       	ldi	r19, 0xFF	; 255
    69da:	40 e0       	ldi	r20, 0x00	; 0
    69dc:	50 e0       	ldi	r21, 0x00	; 0
    69de:	42 22       	and	r4, r18
    69e0:	53 22       	and	r5, r19
    69e2:	64 22       	and	r6, r20
    69e4:	75 22       	and	r7, r21
    69e6:	29 ad       	sts	0x69, r18
    69e8:	3a ad       	sts	0x6a, r19
    69ea:	4b ad       	sts	0x6b, r20
    69ec:	5c ad       	sts	0x6c, r21
    69ee:	8a 01       	movw	r16, r20
    69f0:	22 27       	eor	r18, r18
    69f2:	33 27       	eor	r19, r19
    69f4:	09 ab       	sts	0x59, r16
    69f6:	1a ab       	sts	0x5a, r17
    69f8:	2b ab       	sts	0x5b, r18
    69fa:	3c ab       	sts	0x5c, r19
    69fc:	c5 01       	movw	r24, r10
    69fe:	b4 01       	movw	r22, r8
    6a00:	a3 01       	movw	r20, r6
    6a02:	92 01       	movw	r18, r4
    6a04:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6a08:	69 af       	sts	0x79, r22
    6a0a:	7a af       	sts	0x7a, r23
    6a0c:	8b af       	sts	0x7b, r24
    6a0e:	9c af       	sts	0x7c, r25
    6a10:	c5 01       	movw	r24, r10
    6a12:	b4 01       	movw	r22, r8
    6a14:	29 a9       	sts	0x49, r18
    6a16:	3a a9       	sts	0x4a, r19
    6a18:	4b a9       	sts	0x4b, r20
    6a1a:	5c a9       	sts	0x4c, r21
    6a1c:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6a20:	4b 01       	movw	r8, r22
    6a22:	5c 01       	movw	r10, r24
    6a24:	69 a5       	lds	r22, 0x69
    6a26:	7a a5       	lds	r23, 0x6a
    6a28:	8b a5       	lds	r24, 0x6b
    6a2a:	9c a5       	lds	r25, 0x6c
    6a2c:	a3 01       	movw	r20, r6
    6a2e:	92 01       	movw	r18, r4
    6a30:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6a34:	2b 01       	movw	r4, r22
    6a36:	3c 01       	movw	r6, r24
    6a38:	69 a5       	lds	r22, 0x69
    6a3a:	7a a5       	lds	r23, 0x6a
    6a3c:	8b a5       	lds	r24, 0x6b
    6a3e:	9c a5       	lds	r25, 0x6c
    6a40:	29 a9       	sts	0x49, r18
    6a42:	3a a9       	sts	0x4a, r19
    6a44:	4b a9       	sts	0x4b, r20
    6a46:	5c a9       	sts	0x4c, r21
    6a48:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <__mulsi3>
    6a4c:	ab 01       	movw	r20, r22
    6a4e:	bc 01       	movw	r22, r24
    6a50:	84 0c       	add	r8, r4
    6a52:	95 1c       	adc	r9, r5
    6a54:	a6 1c       	adc	r10, r6
    6a56:	b7 1c       	adc	r11, r7
    6a58:	09 ad       	sts	0x69, r16
    6a5a:	1a ad       	sts	0x6a, r17
    6a5c:	2b ad       	sts	0x6b, r18
    6a5e:	3c ad       	sts	0x6c, r19
    6a60:	c9 01       	movw	r24, r18
    6a62:	aa 27       	eor	r26, r26
    6a64:	bb 27       	eor	r27, r27
    6a66:	88 0e       	add	r8, r24
    6a68:	99 1e       	adc	r9, r25
    6a6a:	aa 1e       	adc	r10, r26
    6a6c:	bb 1e       	adc	r11, r27
    6a6e:	84 14       	cp	r8, r4
    6a70:	95 04       	cpc	r9, r5
    6a72:	a6 04       	cpc	r10, r6
    6a74:	b7 04       	cpc	r11, r7
    6a76:	20 f4       	brcc	.+8      	; 0x6a80 <__stack+0xa81>
    6a78:	40 50       	subi	r20, 0x00	; 0
    6a7a:	50 40       	sbci	r21, 0x00	; 0
    6a7c:	6f 4f       	sbci	r22, 0xFF	; 255
    6a7e:	7f 4f       	sbci	r23, 0xFF	; 255
    6a80:	c5 01       	movw	r24, r10
    6a82:	aa 27       	eor	r26, r26
    6a84:	bb 27       	eor	r27, r27
    6a86:	84 0f       	add	r24, r20
    6a88:	95 1f       	adc	r25, r21
    6a8a:	a6 1f       	adc	r26, r22
    6a8c:	b7 1f       	adc	r27, r23
    6a8e:	0d a5       	lds	r16, 0x6d
    6a90:	1e a5       	lds	r17, 0x6e
    6a92:	2f a5       	lds	r18, 0x6f
    6a94:	38 a9       	sts	0x48, r19
    6a96:	08 17       	cp	r16, r24
    6a98:	19 07       	cpc	r17, r25
    6a9a:	2a 07       	cpc	r18, r26
    6a9c:	3b 07       	cpc	r19, r27
    6a9e:	18 f1       	brcs	.+70     	; 0x6ae6 <__stack+0xae7>
    6aa0:	80 17       	cp	r24, r16
    6aa2:	91 07       	cpc	r25, r17
    6aa4:	a2 07       	cpc	r26, r18
    6aa6:	b3 07       	cpc	r27, r19
    6aa8:	a1 f5       	brne	.+104    	; 0x6b12 <__stack+0xb13>
    6aaa:	54 01       	movw	r10, r8
    6aac:	99 24       	eor	r9, r9
    6aae:	88 24       	eor	r8, r8
    6ab0:	89 ad       	sts	0x69, r24
    6ab2:	9a ad       	sts	0x6a, r25
    6ab4:	ab ad       	sts	0x6b, r26
    6ab6:	bc ad       	sts	0x6c, r27
    6ab8:	a0 70       	andi	r26, 0x00	; 0
    6aba:	b0 70       	andi	r27, 0x00	; 0
    6abc:	88 0e       	add	r8, r24
    6abe:	99 1e       	adc	r9, r25
    6ac0:	aa 1e       	adc	r10, r26
    6ac2:	bb 1e       	adc	r11, r27
    6ac4:	4d a9       	sts	0x4d, r20
    6ac6:	5e a9       	sts	0x4e, r21
    6ac8:	6f a9       	sts	0x4f, r22
    6aca:	78 ad       	sts	0x68, r23
    6acc:	03 2c       	mov	r0, r3
    6ace:	04 c0       	rjmp	.+8      	; 0x6ad8 <__stack+0xad9>
    6ad0:	44 0f       	add	r20, r20
    6ad2:	55 1f       	adc	r21, r21
    6ad4:	66 1f       	adc	r22, r22
    6ad6:	77 1f       	adc	r23, r23
    6ad8:	0a 94       	dec	r0
    6ada:	d2 f7       	brpl	.-12     	; 0x6ad0 <__stack+0xad1>
    6adc:	48 15       	cp	r20, r8
    6ade:	59 05       	cpc	r21, r9
    6ae0:	6a 05       	cpc	r22, r10
    6ae2:	7b 05       	cpc	r23, r11
    6ae4:	b0 f4       	brcc	.+44     	; 0x6b12 <__stack+0xb13>
    6ae6:	08 94       	sec
    6ae8:	c1 08       	sbc	r12, r1
    6aea:	d1 08       	sbc	r13, r1
    6aec:	e1 08       	sbc	r14, r1
    6aee:	f1 08       	sbc	r15, r1
    6af0:	10 c0       	rjmp	.+32     	; 0x6b12 <__stack+0xb13>
    6af2:	44 24       	eor	r4, r4
    6af4:	55 24       	eor	r5, r5
    6af6:	32 01       	movw	r6, r4
    6af8:	cc 24       	eor	r12, r12
    6afa:	dd 24       	eor	r13, r13
    6afc:	76 01       	movw	r14, r12
    6afe:	0c c0       	rjmp	.+24     	; 0x6b18 <__stack+0xb19>
    6b00:	44 24       	eor	r4, r4
    6b02:	55 24       	eor	r5, r5
    6b04:	32 01       	movw	r6, r4
    6b06:	81 e0       	ldi	r24, 0x01	; 1
    6b08:	c8 2e       	mov	r12, r24
    6b0a:	d1 2c       	mov	r13, r1
    6b0c:	e1 2c       	mov	r14, r1
    6b0e:	f1 2c       	mov	r15, r1
    6b10:	03 c0       	rjmp	.+6      	; 0x6b18 <__stack+0xb19>
    6b12:	44 24       	eor	r4, r4
    6b14:	55 24       	eor	r5, r5
    6b16:	32 01       	movw	r6, r4
    6b18:	fe 01       	movw	r30, r28
    6b1a:	31 96       	adiw	r30, 0x01	; 1
    6b1c:	88 e0       	ldi	r24, 0x08	; 8
    6b1e:	df 01       	movw	r26, r30
    6b20:	1d 92       	st	X+, r1
    6b22:	8a 95       	dec	r24
    6b24:	e9 f7       	brne	.-6      	; 0x6b20 <__stack+0xb21>
    6b26:	c9 82       	std	Y+1, r12	; 0x01
    6b28:	da 82       	std	Y+2, r13	; 0x02
    6b2a:	eb 82       	std	Y+3, r14	; 0x03
    6b2c:	fc 82       	std	Y+4, r15	; 0x04
    6b2e:	4d 82       	std	Y+5, r4	; 0x05
    6b30:	5e 82       	std	Y+6, r5	; 0x06
    6b32:	6f 82       	std	Y+7, r6	; 0x07
    6b34:	78 86       	std	Y+8, r7	; 0x08
    6b36:	2c 2d       	mov	r18, r12
    6b38:	3a 81       	ldd	r19, Y+2	; 0x02
    6b3a:	4b 81       	ldd	r20, Y+3	; 0x03
    6b3c:	5c 81       	ldd	r21, Y+4	; 0x04
    6b3e:	64 2d       	mov	r22, r4
    6b40:	7e 81       	ldd	r23, Y+6	; 0x06
    6b42:	8f 81       	ldd	r24, Y+7	; 0x07
    6b44:	98 85       	ldd	r25, Y+8	; 0x08
    6b46:	25 96       	adiw	r28, 0x05	; 5
    6b48:	ec ac       	sts	0xac, r30
    6b4a:	fd ac       	sts	0xad, r31
    6b4c:	0e ad       	sts	0x6e, r16
    6b4e:	1f ad       	sts	0x6f, r17
    6b50:	25 97       	sbiw	r28, 0x05	; 5
    6b52:	e1 14       	cp	r14, r1
    6b54:	f1 04       	cpc	r15, r1
    6b56:	01 05       	cpc	r16, r1
    6b58:	11 05       	cpc	r17, r1
    6b5a:	09 f4       	brne	.+2      	; 0x6b5e <__stack+0xb5f>
    6b5c:	56 c0       	rjmp	.+172    	; 0x6c0a <__stack+0xc0b>
    6b5e:	21 95       	neg	r18
    6b60:	e1 e0       	ldi	r30, 0x01	; 1
    6b62:	12 16       	cp	r1, r18
    6b64:	08 f0       	brcs	.+2      	; 0x6b68 <__stack+0xb69>
    6b66:	e0 e0       	ldi	r30, 0x00	; 0
    6b68:	31 95       	neg	r19
    6b6a:	f1 e0       	ldi	r31, 0x01	; 1
    6b6c:	13 16       	cp	r1, r19
    6b6e:	08 f0       	brcs	.+2      	; 0x6b72 <__stack+0xb73>
    6b70:	f0 e0       	ldi	r31, 0x00	; 0
    6b72:	03 2f       	mov	r16, r19
    6b74:	0e 1b       	sub	r16, r30
    6b76:	e1 e0       	ldi	r30, 0x01	; 1
    6b78:	30 17       	cp	r19, r16
    6b7a:	08 f0       	brcs	.+2      	; 0x6b7e <__stack+0xb7f>
    6b7c:	e0 e0       	ldi	r30, 0x00	; 0
    6b7e:	fe 2b       	or	r31, r30
    6b80:	41 95       	neg	r20
    6b82:	e1 e0       	ldi	r30, 0x01	; 1
    6b84:	14 16       	cp	r1, r20
    6b86:	08 f0       	brcs	.+2      	; 0x6b8a <__stack+0xb8b>
    6b88:	e0 e0       	ldi	r30, 0x00	; 0
    6b8a:	14 2f       	mov	r17, r20
    6b8c:	1f 1b       	sub	r17, r31
    6b8e:	31 e0       	ldi	r19, 0x01	; 1
    6b90:	41 17       	cp	r20, r17
    6b92:	08 f0       	brcs	.+2      	; 0x6b96 <__stack+0xb97>
    6b94:	30 e0       	ldi	r19, 0x00	; 0
    6b96:	e3 2b       	or	r30, r19
    6b98:	51 95       	neg	r21
    6b9a:	f1 e0       	ldi	r31, 0x01	; 1
    6b9c:	15 16       	cp	r1, r21
    6b9e:	08 f0       	brcs	.+2      	; 0x6ba2 <__stack+0xba3>
    6ba0:	f0 e0       	ldi	r31, 0x00	; 0
    6ba2:	b5 2f       	mov	r27, r21
    6ba4:	be 1b       	sub	r27, r30
    6ba6:	31 e0       	ldi	r19, 0x01	; 1
    6ba8:	5b 17       	cp	r21, r27
    6baa:	08 f0       	brcs	.+2      	; 0x6bae <__stack+0xbaf>
    6bac:	30 e0       	ldi	r19, 0x00	; 0
    6bae:	f3 2b       	or	r31, r19
    6bb0:	61 95       	neg	r22
    6bb2:	e1 e0       	ldi	r30, 0x01	; 1
    6bb4:	16 16       	cp	r1, r22
    6bb6:	08 f0       	brcs	.+2      	; 0x6bba <__stack+0xbbb>
    6bb8:	e0 e0       	ldi	r30, 0x00	; 0
    6bba:	46 2e       	mov	r4, r22
    6bbc:	4f 1a       	sub	r4, r31
    6bbe:	31 e0       	ldi	r19, 0x01	; 1
    6bc0:	64 15       	cp	r22, r4
    6bc2:	08 f0       	brcs	.+2      	; 0x6bc6 <__stack+0xbc7>
    6bc4:	30 e0       	ldi	r19, 0x00	; 0
    6bc6:	e3 2b       	or	r30, r19
    6bc8:	71 95       	neg	r23
    6bca:	f1 e0       	ldi	r31, 0x01	; 1
    6bcc:	17 16       	cp	r1, r23
    6bce:	08 f0       	brcs	.+2      	; 0x6bd2 <__stack+0xbd3>
    6bd0:	f0 e0       	ldi	r31, 0x00	; 0
    6bd2:	a7 2f       	mov	r26, r23
    6bd4:	ae 1b       	sub	r26, r30
    6bd6:	31 e0       	ldi	r19, 0x01	; 1
    6bd8:	7a 17       	cp	r23, r26
    6bda:	08 f0       	brcs	.+2      	; 0x6bde <__stack+0xbdf>
    6bdc:	30 e0       	ldi	r19, 0x00	; 0
    6bde:	f3 2b       	or	r31, r19
    6be0:	81 95       	neg	r24
    6be2:	e1 e0       	ldi	r30, 0x01	; 1
    6be4:	18 16       	cp	r1, r24
    6be6:	08 f0       	brcs	.+2      	; 0x6bea <__stack+0xbeb>
    6be8:	e0 e0       	ldi	r30, 0x00	; 0
    6bea:	f8 2e       	mov	r15, r24
    6bec:	ff 1a       	sub	r15, r31
    6bee:	ff 2d       	mov	r31, r15
    6bf0:	31 e0       	ldi	r19, 0x01	; 1
    6bf2:	8f 15       	cp	r24, r15
    6bf4:	08 f0       	brcs	.+2      	; 0x6bf8 <__stack+0xbf9>
    6bf6:	30 e0       	ldi	r19, 0x00	; 0
    6bf8:	e3 2b       	or	r30, r19
    6bfa:	91 95       	neg	r25
    6bfc:	30 2f       	mov	r19, r16
    6bfe:	41 2f       	mov	r20, r17
    6c00:	5b 2f       	mov	r21, r27
    6c02:	64 2d       	mov	r22, r4
    6c04:	7a 2f       	mov	r23, r26
    6c06:	8f 2f       	mov	r24, r31
    6c08:	9e 1b       	sub	r25, r30
    6c0a:	c8 5b       	subi	r28, 0xB8	; 184
    6c0c:	df 4f       	sbci	r29, 0xFF	; 255
    6c0e:	e1 e1       	ldi	r30, 0x11	; 17
    6c10:	0c 94 56 38 	jmp	0x70ac	; 0x70ac <__epilogue_restores__+0x2>

00006c14 <__subsf3>:
    6c14:	50 58       	subi	r21, 0x80	; 128

00006c16 <__addsf3>:
    6c16:	bb 27       	eor	r27, r27
    6c18:	aa 27       	eor	r26, r26
    6c1a:	0e d0       	rcall	.+28     	; 0x6c38 <__addsf3x>
    6c1c:	48 c1       	rjmp	.+656    	; 0x6eae <__fp_round>
    6c1e:	39 d1       	rcall	.+626    	; 0x6e92 <__fp_pscA>
    6c20:	30 f0       	brcs	.+12     	; 0x6c2e <__addsf3+0x18>
    6c22:	3e d1       	rcall	.+636    	; 0x6ea0 <__fp_pscB>
    6c24:	20 f0       	brcs	.+8      	; 0x6c2e <__addsf3+0x18>
    6c26:	31 f4       	brne	.+12     	; 0x6c34 <__addsf3+0x1e>
    6c28:	9f 3f       	cpi	r25, 0xFF	; 255
    6c2a:	11 f4       	brne	.+4      	; 0x6c30 <__addsf3+0x1a>
    6c2c:	1e f4       	brtc	.+6      	; 0x6c34 <__addsf3+0x1e>
    6c2e:	2e c1       	rjmp	.+604    	; 0x6e8c <__fp_nan>
    6c30:	0e f4       	brtc	.+2      	; 0x6c34 <__addsf3+0x1e>
    6c32:	e0 95       	com	r30
    6c34:	e7 fb       	bst	r30, 7
    6c36:	24 c1       	rjmp	.+584    	; 0x6e80 <__fp_inf>

00006c38 <__addsf3x>:
    6c38:	e9 2f       	mov	r30, r25
    6c3a:	4a d1       	rcall	.+660    	; 0x6ed0 <__fp_split3>
    6c3c:	80 f3       	brcs	.-32     	; 0x6c1e <__addsf3+0x8>
    6c3e:	ba 17       	cp	r27, r26
    6c40:	62 07       	cpc	r22, r18
    6c42:	73 07       	cpc	r23, r19
    6c44:	84 07       	cpc	r24, r20
    6c46:	95 07       	cpc	r25, r21
    6c48:	18 f0       	brcs	.+6      	; 0x6c50 <__addsf3x+0x18>
    6c4a:	71 f4       	brne	.+28     	; 0x6c68 <__addsf3x+0x30>
    6c4c:	9e f5       	brtc	.+102    	; 0x6cb4 <__addsf3x+0x7c>
    6c4e:	62 c1       	rjmp	.+708    	; 0x6f14 <__fp_zero>
    6c50:	0e f4       	brtc	.+2      	; 0x6c54 <__addsf3x+0x1c>
    6c52:	e0 95       	com	r30
    6c54:	0b 2e       	mov	r0, r27
    6c56:	ba 2f       	mov	r27, r26
    6c58:	a0 2d       	mov	r26, r0
    6c5a:	0b 01       	movw	r0, r22
    6c5c:	b9 01       	movw	r22, r18
    6c5e:	90 01       	movw	r18, r0
    6c60:	0c 01       	movw	r0, r24
    6c62:	ca 01       	movw	r24, r20
    6c64:	a0 01       	movw	r20, r0
    6c66:	11 24       	eor	r1, r1
    6c68:	ff 27       	eor	r31, r31
    6c6a:	59 1b       	sub	r21, r25
    6c6c:	99 f0       	breq	.+38     	; 0x6c94 <__addsf3x+0x5c>
    6c6e:	59 3f       	cpi	r21, 0xF9	; 249
    6c70:	50 f4       	brcc	.+20     	; 0x6c86 <__addsf3x+0x4e>
    6c72:	50 3e       	cpi	r21, 0xE0	; 224
    6c74:	68 f1       	brcs	.+90     	; 0x6cd0 <__addsf3x+0x98>
    6c76:	1a 16       	cp	r1, r26
    6c78:	f0 40       	sbci	r31, 0x00	; 0
    6c7a:	a2 2f       	mov	r26, r18
    6c7c:	23 2f       	mov	r18, r19
    6c7e:	34 2f       	mov	r19, r20
    6c80:	44 27       	eor	r20, r20
    6c82:	58 5f       	subi	r21, 0xF8	; 248
    6c84:	f3 cf       	rjmp	.-26     	; 0x6c6c <__addsf3x+0x34>
    6c86:	46 95       	lsr	r20
    6c88:	37 95       	ror	r19
    6c8a:	27 95       	ror	r18
    6c8c:	a7 95       	ror	r26
    6c8e:	f0 40       	sbci	r31, 0x00	; 0
    6c90:	53 95       	inc	r21
    6c92:	c9 f7       	brne	.-14     	; 0x6c86 <__addsf3x+0x4e>
    6c94:	7e f4       	brtc	.+30     	; 0x6cb4 <__addsf3x+0x7c>
    6c96:	1f 16       	cp	r1, r31
    6c98:	ba 0b       	sbc	r27, r26
    6c9a:	62 0b       	sbc	r22, r18
    6c9c:	73 0b       	sbc	r23, r19
    6c9e:	84 0b       	sbc	r24, r20
    6ca0:	ba f0       	brmi	.+46     	; 0x6cd0 <__addsf3x+0x98>
    6ca2:	91 50       	subi	r25, 0x01	; 1
    6ca4:	a1 f0       	breq	.+40     	; 0x6cce <__addsf3x+0x96>
    6ca6:	ff 0f       	add	r31, r31
    6ca8:	bb 1f       	adc	r27, r27
    6caa:	66 1f       	adc	r22, r22
    6cac:	77 1f       	adc	r23, r23
    6cae:	88 1f       	adc	r24, r24
    6cb0:	c2 f7       	brpl	.-16     	; 0x6ca2 <__addsf3x+0x6a>
    6cb2:	0e c0       	rjmp	.+28     	; 0x6cd0 <__addsf3x+0x98>
    6cb4:	ba 0f       	add	r27, r26
    6cb6:	62 1f       	adc	r22, r18
    6cb8:	73 1f       	adc	r23, r19
    6cba:	84 1f       	adc	r24, r20
    6cbc:	48 f4       	brcc	.+18     	; 0x6cd0 <__addsf3x+0x98>
    6cbe:	87 95       	ror	r24
    6cc0:	77 95       	ror	r23
    6cc2:	67 95       	ror	r22
    6cc4:	b7 95       	ror	r27
    6cc6:	f7 95       	ror	r31
    6cc8:	9e 3f       	cpi	r25, 0xFE	; 254
    6cca:	08 f0       	brcs	.+2      	; 0x6cce <__addsf3x+0x96>
    6ccc:	b3 cf       	rjmp	.-154    	; 0x6c34 <__addsf3+0x1e>
    6cce:	93 95       	inc	r25
    6cd0:	88 0f       	add	r24, r24
    6cd2:	08 f0       	brcs	.+2      	; 0x6cd6 <__addsf3x+0x9e>
    6cd4:	99 27       	eor	r25, r25
    6cd6:	ee 0f       	add	r30, r30
    6cd8:	97 95       	ror	r25
    6cda:	87 95       	ror	r24
    6cdc:	08 95       	ret

00006cde <__divsf3>:
    6cde:	0c d0       	rcall	.+24     	; 0x6cf8 <__divsf3x>
    6ce0:	e6 c0       	rjmp	.+460    	; 0x6eae <__fp_round>
    6ce2:	de d0       	rcall	.+444    	; 0x6ea0 <__fp_pscB>
    6ce4:	40 f0       	brcs	.+16     	; 0x6cf6 <__divsf3+0x18>
    6ce6:	d5 d0       	rcall	.+426    	; 0x6e92 <__fp_pscA>
    6ce8:	30 f0       	brcs	.+12     	; 0x6cf6 <__divsf3+0x18>
    6cea:	21 f4       	brne	.+8      	; 0x6cf4 <__divsf3+0x16>
    6cec:	5f 3f       	cpi	r21, 0xFF	; 255
    6cee:	19 f0       	breq	.+6      	; 0x6cf6 <__divsf3+0x18>
    6cf0:	c7 c0       	rjmp	.+398    	; 0x6e80 <__fp_inf>
    6cf2:	51 11       	cpse	r21, r1
    6cf4:	10 c1       	rjmp	.+544    	; 0x6f16 <__fp_szero>
    6cf6:	ca c0       	rjmp	.+404    	; 0x6e8c <__fp_nan>

00006cf8 <__divsf3x>:
    6cf8:	eb d0       	rcall	.+470    	; 0x6ed0 <__fp_split3>
    6cfa:	98 f3       	brcs	.-26     	; 0x6ce2 <__divsf3+0x4>

00006cfc <__divsf3_pse>:
    6cfc:	99 23       	and	r25, r25
    6cfe:	c9 f3       	breq	.-14     	; 0x6cf2 <__divsf3+0x14>
    6d00:	55 23       	and	r21, r21
    6d02:	b1 f3       	breq	.-20     	; 0x6cf0 <__divsf3+0x12>
    6d04:	95 1b       	sub	r25, r21
    6d06:	55 0b       	sbc	r21, r21
    6d08:	bb 27       	eor	r27, r27
    6d0a:	aa 27       	eor	r26, r26
    6d0c:	62 17       	cp	r22, r18
    6d0e:	73 07       	cpc	r23, r19
    6d10:	84 07       	cpc	r24, r20
    6d12:	38 f0       	brcs	.+14     	; 0x6d22 <__divsf3_pse+0x26>
    6d14:	9f 5f       	subi	r25, 0xFF	; 255
    6d16:	5f 4f       	sbci	r21, 0xFF	; 255
    6d18:	22 0f       	add	r18, r18
    6d1a:	33 1f       	adc	r19, r19
    6d1c:	44 1f       	adc	r20, r20
    6d1e:	aa 1f       	adc	r26, r26
    6d20:	a9 f3       	breq	.-22     	; 0x6d0c <__divsf3_pse+0x10>
    6d22:	33 d0       	rcall	.+102    	; 0x6d8a <__divsf3_pse+0x8e>
    6d24:	0e 2e       	mov	r0, r30
    6d26:	3a f0       	brmi	.+14     	; 0x6d36 <__divsf3_pse+0x3a>
    6d28:	e0 e8       	ldi	r30, 0x80	; 128
    6d2a:	30 d0       	rcall	.+96     	; 0x6d8c <__divsf3_pse+0x90>
    6d2c:	91 50       	subi	r25, 0x01	; 1
    6d2e:	50 40       	sbci	r21, 0x00	; 0
    6d30:	e6 95       	lsr	r30
    6d32:	00 1c       	adc	r0, r0
    6d34:	ca f7       	brpl	.-14     	; 0x6d28 <__divsf3_pse+0x2c>
    6d36:	29 d0       	rcall	.+82     	; 0x6d8a <__divsf3_pse+0x8e>
    6d38:	fe 2f       	mov	r31, r30
    6d3a:	27 d0       	rcall	.+78     	; 0x6d8a <__divsf3_pse+0x8e>
    6d3c:	66 0f       	add	r22, r22
    6d3e:	77 1f       	adc	r23, r23
    6d40:	88 1f       	adc	r24, r24
    6d42:	bb 1f       	adc	r27, r27
    6d44:	26 17       	cp	r18, r22
    6d46:	37 07       	cpc	r19, r23
    6d48:	48 07       	cpc	r20, r24
    6d4a:	ab 07       	cpc	r26, r27
    6d4c:	b0 e8       	ldi	r27, 0x80	; 128
    6d4e:	09 f0       	breq	.+2      	; 0x6d52 <__divsf3_pse+0x56>
    6d50:	bb 0b       	sbc	r27, r27
    6d52:	80 2d       	mov	r24, r0
    6d54:	bf 01       	movw	r22, r30
    6d56:	ff 27       	eor	r31, r31
    6d58:	93 58       	subi	r25, 0x83	; 131
    6d5a:	5f 4f       	sbci	r21, 0xFF	; 255
    6d5c:	2a f0       	brmi	.+10     	; 0x6d68 <__divsf3_pse+0x6c>
    6d5e:	9e 3f       	cpi	r25, 0xFE	; 254
    6d60:	51 05       	cpc	r21, r1
    6d62:	68 f0       	brcs	.+26     	; 0x6d7e <__divsf3_pse+0x82>
    6d64:	8d c0       	rjmp	.+282    	; 0x6e80 <__fp_inf>
    6d66:	d7 c0       	rjmp	.+430    	; 0x6f16 <__fp_szero>
    6d68:	5f 3f       	cpi	r21, 0xFF	; 255
    6d6a:	ec f3       	brlt	.-6      	; 0x6d66 <__divsf3_pse+0x6a>
    6d6c:	98 3e       	cpi	r25, 0xE8	; 232
    6d6e:	dc f3       	brlt	.-10     	; 0x6d66 <__divsf3_pse+0x6a>
    6d70:	86 95       	lsr	r24
    6d72:	77 95       	ror	r23
    6d74:	67 95       	ror	r22
    6d76:	b7 95       	ror	r27
    6d78:	f7 95       	ror	r31
    6d7a:	9f 5f       	subi	r25, 0xFF	; 255
    6d7c:	c9 f7       	brne	.-14     	; 0x6d70 <__divsf3_pse+0x74>
    6d7e:	88 0f       	add	r24, r24
    6d80:	91 1d       	adc	r25, r1
    6d82:	96 95       	lsr	r25
    6d84:	87 95       	ror	r24
    6d86:	97 f9       	bld	r25, 7
    6d88:	08 95       	ret
    6d8a:	e1 e0       	ldi	r30, 0x01	; 1
    6d8c:	66 0f       	add	r22, r22
    6d8e:	77 1f       	adc	r23, r23
    6d90:	88 1f       	adc	r24, r24
    6d92:	bb 1f       	adc	r27, r27
    6d94:	62 17       	cp	r22, r18
    6d96:	73 07       	cpc	r23, r19
    6d98:	84 07       	cpc	r24, r20
    6d9a:	ba 07       	cpc	r27, r26
    6d9c:	20 f0       	brcs	.+8      	; 0x6da6 <__divsf3_pse+0xaa>
    6d9e:	62 1b       	sub	r22, r18
    6da0:	73 0b       	sbc	r23, r19
    6da2:	84 0b       	sbc	r24, r20
    6da4:	ba 0b       	sbc	r27, r26
    6da6:	ee 1f       	adc	r30, r30
    6da8:	88 f7       	brcc	.-30     	; 0x6d8c <__divsf3_pse+0x90>
    6daa:	e0 95       	com	r30
    6dac:	08 95       	ret

00006dae <__fixunssfsi>:
    6dae:	98 d0       	rcall	.+304    	; 0x6ee0 <__fp_splitA>
    6db0:	88 f0       	brcs	.+34     	; 0x6dd4 <__fixunssfsi+0x26>
    6db2:	9f 57       	subi	r25, 0x7F	; 127
    6db4:	90 f0       	brcs	.+36     	; 0x6dda <__fixunssfsi+0x2c>
    6db6:	b9 2f       	mov	r27, r25
    6db8:	99 27       	eor	r25, r25
    6dba:	b7 51       	subi	r27, 0x17	; 23
    6dbc:	a0 f0       	brcs	.+40     	; 0x6de6 <__fixunssfsi+0x38>
    6dbe:	d1 f0       	breq	.+52     	; 0x6df4 <__fixunssfsi+0x46>
    6dc0:	66 0f       	add	r22, r22
    6dc2:	77 1f       	adc	r23, r23
    6dc4:	88 1f       	adc	r24, r24
    6dc6:	99 1f       	adc	r25, r25
    6dc8:	1a f0       	brmi	.+6      	; 0x6dd0 <__fixunssfsi+0x22>
    6dca:	ba 95       	dec	r27
    6dcc:	c9 f7       	brne	.-14     	; 0x6dc0 <__fixunssfsi+0x12>
    6dce:	12 c0       	rjmp	.+36     	; 0x6df4 <__fixunssfsi+0x46>
    6dd0:	b1 30       	cpi	r27, 0x01	; 1
    6dd2:	81 f0       	breq	.+32     	; 0x6df4 <__fixunssfsi+0x46>
    6dd4:	9f d0       	rcall	.+318    	; 0x6f14 <__fp_zero>
    6dd6:	b1 e0       	ldi	r27, 0x01	; 1
    6dd8:	08 95       	ret
    6dda:	9c c0       	rjmp	.+312    	; 0x6f14 <__fp_zero>
    6ddc:	67 2f       	mov	r22, r23
    6dde:	78 2f       	mov	r23, r24
    6de0:	88 27       	eor	r24, r24
    6de2:	b8 5f       	subi	r27, 0xF8	; 248
    6de4:	39 f0       	breq	.+14     	; 0x6df4 <__fixunssfsi+0x46>
    6de6:	b9 3f       	cpi	r27, 0xF9	; 249
    6de8:	cc f3       	brlt	.-14     	; 0x6ddc <__fixunssfsi+0x2e>
    6dea:	86 95       	lsr	r24
    6dec:	77 95       	ror	r23
    6dee:	67 95       	ror	r22
    6df0:	b3 95       	inc	r27
    6df2:	d9 f7       	brne	.-10     	; 0x6dea <__fixunssfsi+0x3c>
    6df4:	3e f4       	brtc	.+14     	; 0x6e04 <__fixunssfsi+0x56>
    6df6:	90 95       	com	r25
    6df8:	80 95       	com	r24
    6dfa:	70 95       	com	r23
    6dfc:	61 95       	neg	r22
    6dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    6e00:	8f 4f       	sbci	r24, 0xFF	; 255
    6e02:	9f 4f       	sbci	r25, 0xFF	; 255
    6e04:	08 95       	ret

00006e06 <__floatunsisf>:
    6e06:	e8 94       	clt
    6e08:	09 c0       	rjmp	.+18     	; 0x6e1c <__floatsisf+0x12>

00006e0a <__floatsisf>:
    6e0a:	97 fb       	bst	r25, 7
    6e0c:	3e f4       	brtc	.+14     	; 0x6e1c <__floatsisf+0x12>
    6e0e:	90 95       	com	r25
    6e10:	80 95       	com	r24
    6e12:	70 95       	com	r23
    6e14:	61 95       	neg	r22
    6e16:	7f 4f       	sbci	r23, 0xFF	; 255
    6e18:	8f 4f       	sbci	r24, 0xFF	; 255
    6e1a:	9f 4f       	sbci	r25, 0xFF	; 255
    6e1c:	99 23       	and	r25, r25
    6e1e:	a9 f0       	breq	.+42     	; 0x6e4a <__floatsisf+0x40>
    6e20:	f9 2f       	mov	r31, r25
    6e22:	96 e9       	ldi	r25, 0x96	; 150
    6e24:	bb 27       	eor	r27, r27
    6e26:	93 95       	inc	r25
    6e28:	f6 95       	lsr	r31
    6e2a:	87 95       	ror	r24
    6e2c:	77 95       	ror	r23
    6e2e:	67 95       	ror	r22
    6e30:	b7 95       	ror	r27
    6e32:	f1 11       	cpse	r31, r1
    6e34:	f8 cf       	rjmp	.-16     	; 0x6e26 <__floatsisf+0x1c>
    6e36:	fa f4       	brpl	.+62     	; 0x6e76 <__floatsisf+0x6c>
    6e38:	bb 0f       	add	r27, r27
    6e3a:	11 f4       	brne	.+4      	; 0x6e40 <__floatsisf+0x36>
    6e3c:	60 ff       	sbrs	r22, 0
    6e3e:	1b c0       	rjmp	.+54     	; 0x6e76 <__floatsisf+0x6c>
    6e40:	6f 5f       	subi	r22, 0xFF	; 255
    6e42:	7f 4f       	sbci	r23, 0xFF	; 255
    6e44:	8f 4f       	sbci	r24, 0xFF	; 255
    6e46:	9f 4f       	sbci	r25, 0xFF	; 255
    6e48:	16 c0       	rjmp	.+44     	; 0x6e76 <__floatsisf+0x6c>
    6e4a:	88 23       	and	r24, r24
    6e4c:	11 f0       	breq	.+4      	; 0x6e52 <__floatsisf+0x48>
    6e4e:	96 e9       	ldi	r25, 0x96	; 150
    6e50:	11 c0       	rjmp	.+34     	; 0x6e74 <__floatsisf+0x6a>
    6e52:	77 23       	and	r23, r23
    6e54:	21 f0       	breq	.+8      	; 0x6e5e <__floatsisf+0x54>
    6e56:	9e e8       	ldi	r25, 0x8E	; 142
    6e58:	87 2f       	mov	r24, r23
    6e5a:	76 2f       	mov	r23, r22
    6e5c:	05 c0       	rjmp	.+10     	; 0x6e68 <__floatsisf+0x5e>
    6e5e:	66 23       	and	r22, r22
    6e60:	71 f0       	breq	.+28     	; 0x6e7e <__floatsisf+0x74>
    6e62:	96 e8       	ldi	r25, 0x86	; 134
    6e64:	86 2f       	mov	r24, r22
    6e66:	70 e0       	ldi	r23, 0x00	; 0
    6e68:	60 e0       	ldi	r22, 0x00	; 0
    6e6a:	2a f0       	brmi	.+10     	; 0x6e76 <__floatsisf+0x6c>
    6e6c:	9a 95       	dec	r25
    6e6e:	66 0f       	add	r22, r22
    6e70:	77 1f       	adc	r23, r23
    6e72:	88 1f       	adc	r24, r24
    6e74:	da f7       	brpl	.-10     	; 0x6e6c <__floatsisf+0x62>
    6e76:	88 0f       	add	r24, r24
    6e78:	96 95       	lsr	r25
    6e7a:	87 95       	ror	r24
    6e7c:	97 f9       	bld	r25, 7
    6e7e:	08 95       	ret

00006e80 <__fp_inf>:
    6e80:	97 f9       	bld	r25, 7
    6e82:	9f 67       	ori	r25, 0x7F	; 127
    6e84:	80 e8       	ldi	r24, 0x80	; 128
    6e86:	70 e0       	ldi	r23, 0x00	; 0
    6e88:	60 e0       	ldi	r22, 0x00	; 0
    6e8a:	08 95       	ret

00006e8c <__fp_nan>:
    6e8c:	9f ef       	ldi	r25, 0xFF	; 255
    6e8e:	80 ec       	ldi	r24, 0xC0	; 192
    6e90:	08 95       	ret

00006e92 <__fp_pscA>:
    6e92:	00 24       	eor	r0, r0
    6e94:	0a 94       	dec	r0
    6e96:	16 16       	cp	r1, r22
    6e98:	17 06       	cpc	r1, r23
    6e9a:	18 06       	cpc	r1, r24
    6e9c:	09 06       	cpc	r0, r25
    6e9e:	08 95       	ret

00006ea0 <__fp_pscB>:
    6ea0:	00 24       	eor	r0, r0
    6ea2:	0a 94       	dec	r0
    6ea4:	12 16       	cp	r1, r18
    6ea6:	13 06       	cpc	r1, r19
    6ea8:	14 06       	cpc	r1, r20
    6eaa:	05 06       	cpc	r0, r21
    6eac:	08 95       	ret

00006eae <__fp_round>:
    6eae:	09 2e       	mov	r0, r25
    6eb0:	03 94       	inc	r0
    6eb2:	00 0c       	add	r0, r0
    6eb4:	11 f4       	brne	.+4      	; 0x6eba <__fp_round+0xc>
    6eb6:	88 23       	and	r24, r24
    6eb8:	52 f0       	brmi	.+20     	; 0x6ece <__fp_round+0x20>
    6eba:	bb 0f       	add	r27, r27
    6ebc:	40 f4       	brcc	.+16     	; 0x6ece <__fp_round+0x20>
    6ebe:	bf 2b       	or	r27, r31
    6ec0:	11 f4       	brne	.+4      	; 0x6ec6 <__fp_round+0x18>
    6ec2:	60 ff       	sbrs	r22, 0
    6ec4:	04 c0       	rjmp	.+8      	; 0x6ece <__fp_round+0x20>
    6ec6:	6f 5f       	subi	r22, 0xFF	; 255
    6ec8:	7f 4f       	sbci	r23, 0xFF	; 255
    6eca:	8f 4f       	sbci	r24, 0xFF	; 255
    6ecc:	9f 4f       	sbci	r25, 0xFF	; 255
    6ece:	08 95       	ret

00006ed0 <__fp_split3>:
    6ed0:	57 fd       	sbrc	r21, 7
    6ed2:	90 58       	subi	r25, 0x80	; 128
    6ed4:	44 0f       	add	r20, r20
    6ed6:	55 1f       	adc	r21, r21
    6ed8:	59 f0       	breq	.+22     	; 0x6ef0 <__fp_splitA+0x10>
    6eda:	5f 3f       	cpi	r21, 0xFF	; 255
    6edc:	71 f0       	breq	.+28     	; 0x6efa <__fp_splitA+0x1a>
    6ede:	47 95       	ror	r20

00006ee0 <__fp_splitA>:
    6ee0:	88 0f       	add	r24, r24
    6ee2:	97 fb       	bst	r25, 7
    6ee4:	99 1f       	adc	r25, r25
    6ee6:	61 f0       	breq	.+24     	; 0x6f00 <__fp_splitA+0x20>
    6ee8:	9f 3f       	cpi	r25, 0xFF	; 255
    6eea:	79 f0       	breq	.+30     	; 0x6f0a <__fp_splitA+0x2a>
    6eec:	87 95       	ror	r24
    6eee:	08 95       	ret
    6ef0:	12 16       	cp	r1, r18
    6ef2:	13 06       	cpc	r1, r19
    6ef4:	14 06       	cpc	r1, r20
    6ef6:	55 1f       	adc	r21, r21
    6ef8:	f2 cf       	rjmp	.-28     	; 0x6ede <__fp_split3+0xe>
    6efa:	46 95       	lsr	r20
    6efc:	f1 df       	rcall	.-30     	; 0x6ee0 <__fp_splitA>
    6efe:	08 c0       	rjmp	.+16     	; 0x6f10 <__fp_splitA+0x30>
    6f00:	16 16       	cp	r1, r22
    6f02:	17 06       	cpc	r1, r23
    6f04:	18 06       	cpc	r1, r24
    6f06:	99 1f       	adc	r25, r25
    6f08:	f1 cf       	rjmp	.-30     	; 0x6eec <__fp_splitA+0xc>
    6f0a:	86 95       	lsr	r24
    6f0c:	71 05       	cpc	r23, r1
    6f0e:	61 05       	cpc	r22, r1
    6f10:	08 94       	sec
    6f12:	08 95       	ret

00006f14 <__fp_zero>:
    6f14:	e8 94       	clt

00006f16 <__fp_szero>:
    6f16:	bb 27       	eor	r27, r27
    6f18:	66 27       	eor	r22, r22
    6f1a:	77 27       	eor	r23, r23
    6f1c:	cb 01       	movw	r24, r22
    6f1e:	97 f9       	bld	r25, 7
    6f20:	08 95       	ret

00006f22 <__gesf2>:
    6f22:	03 d0       	rcall	.+6      	; 0x6f2a <__fp_cmp>
    6f24:	08 f4       	brcc	.+2      	; 0x6f28 <__gesf2+0x6>
    6f26:	8f ef       	ldi	r24, 0xFF	; 255
    6f28:	08 95       	ret

00006f2a <__fp_cmp>:
    6f2a:	99 0f       	add	r25, r25
    6f2c:	00 08       	sbc	r0, r0
    6f2e:	55 0f       	add	r21, r21
    6f30:	aa 0b       	sbc	r26, r26
    6f32:	e0 e8       	ldi	r30, 0x80	; 128
    6f34:	fe ef       	ldi	r31, 0xFE	; 254
    6f36:	16 16       	cp	r1, r22
    6f38:	17 06       	cpc	r1, r23
    6f3a:	e8 07       	cpc	r30, r24
    6f3c:	f9 07       	cpc	r31, r25
    6f3e:	c0 f0       	brcs	.+48     	; 0x6f70 <__fp_cmp+0x46>
    6f40:	12 16       	cp	r1, r18
    6f42:	13 06       	cpc	r1, r19
    6f44:	e4 07       	cpc	r30, r20
    6f46:	f5 07       	cpc	r31, r21
    6f48:	98 f0       	brcs	.+38     	; 0x6f70 <__fp_cmp+0x46>
    6f4a:	62 1b       	sub	r22, r18
    6f4c:	73 0b       	sbc	r23, r19
    6f4e:	84 0b       	sbc	r24, r20
    6f50:	95 0b       	sbc	r25, r21
    6f52:	39 f4       	brne	.+14     	; 0x6f62 <__fp_cmp+0x38>
    6f54:	0a 26       	eor	r0, r26
    6f56:	61 f0       	breq	.+24     	; 0x6f70 <__fp_cmp+0x46>
    6f58:	23 2b       	or	r18, r19
    6f5a:	24 2b       	or	r18, r20
    6f5c:	25 2b       	or	r18, r21
    6f5e:	21 f4       	brne	.+8      	; 0x6f68 <__fp_cmp+0x3e>
    6f60:	08 95       	ret
    6f62:	0a 26       	eor	r0, r26
    6f64:	09 f4       	brne	.+2      	; 0x6f68 <__fp_cmp+0x3e>
    6f66:	a1 40       	sbci	r26, 0x01	; 1
    6f68:	a6 95       	lsr	r26
    6f6a:	8f ef       	ldi	r24, 0xFF	; 255
    6f6c:	81 1d       	adc	r24, r1
    6f6e:	81 1d       	adc	r24, r1
    6f70:	08 95       	ret

00006f72 <__mulsi3>:
    6f72:	62 9f       	mul	r22, r18
    6f74:	d0 01       	movw	r26, r0
    6f76:	73 9f       	mul	r23, r19
    6f78:	f0 01       	movw	r30, r0
    6f7a:	82 9f       	mul	r24, r18
    6f7c:	e0 0d       	add	r30, r0
    6f7e:	f1 1d       	adc	r31, r1
    6f80:	64 9f       	mul	r22, r20
    6f82:	e0 0d       	add	r30, r0
    6f84:	f1 1d       	adc	r31, r1
    6f86:	92 9f       	mul	r25, r18
    6f88:	f0 0d       	add	r31, r0
    6f8a:	83 9f       	mul	r24, r19
    6f8c:	f0 0d       	add	r31, r0
    6f8e:	74 9f       	mul	r23, r20
    6f90:	f0 0d       	add	r31, r0
    6f92:	65 9f       	mul	r22, r21
    6f94:	f0 0d       	add	r31, r0
    6f96:	99 27       	eor	r25, r25
    6f98:	72 9f       	mul	r23, r18
    6f9a:	b0 0d       	add	r27, r0
    6f9c:	e1 1d       	adc	r30, r1
    6f9e:	f9 1f       	adc	r31, r25
    6fa0:	63 9f       	mul	r22, r19
    6fa2:	b0 0d       	add	r27, r0
    6fa4:	e1 1d       	adc	r30, r1
    6fa6:	f9 1f       	adc	r31, r25
    6fa8:	bd 01       	movw	r22, r26
    6faa:	cf 01       	movw	r24, r30
    6fac:	11 24       	eor	r1, r1
    6fae:	08 95       	ret

00006fb0 <__udivmodhi4>:
    6fb0:	aa 1b       	sub	r26, r26
    6fb2:	bb 1b       	sub	r27, r27
    6fb4:	51 e1       	ldi	r21, 0x11	; 17
    6fb6:	07 c0       	rjmp	.+14     	; 0x6fc6 <__udivmodhi4_ep>

00006fb8 <__udivmodhi4_loop>:
    6fb8:	aa 1f       	adc	r26, r26
    6fba:	bb 1f       	adc	r27, r27
    6fbc:	a6 17       	cp	r26, r22
    6fbe:	b7 07       	cpc	r27, r23
    6fc0:	10 f0       	brcs	.+4      	; 0x6fc6 <__udivmodhi4_ep>
    6fc2:	a6 1b       	sub	r26, r22
    6fc4:	b7 0b       	sbc	r27, r23

00006fc6 <__udivmodhi4_ep>:
    6fc6:	88 1f       	adc	r24, r24
    6fc8:	99 1f       	adc	r25, r25
    6fca:	5a 95       	dec	r21
    6fcc:	a9 f7       	brne	.-22     	; 0x6fb8 <__udivmodhi4_loop>
    6fce:	80 95       	com	r24
    6fd0:	90 95       	com	r25
    6fd2:	bc 01       	movw	r22, r24
    6fd4:	cd 01       	movw	r24, r26
    6fd6:	08 95       	ret

00006fd8 <__divmodhi4>:
    6fd8:	97 fb       	bst	r25, 7
    6fda:	09 2e       	mov	r0, r25
    6fdc:	07 26       	eor	r0, r23
    6fde:	0a d0       	rcall	.+20     	; 0x6ff4 <__divmodhi4_neg1>
    6fe0:	77 fd       	sbrc	r23, 7
    6fe2:	04 d0       	rcall	.+8      	; 0x6fec <__divmodhi4_neg2>
    6fe4:	e5 df       	rcall	.-54     	; 0x6fb0 <__udivmodhi4>
    6fe6:	06 d0       	rcall	.+12     	; 0x6ff4 <__divmodhi4_neg1>
    6fe8:	00 20       	and	r0, r0
    6fea:	1a f4       	brpl	.+6      	; 0x6ff2 <__divmodhi4_exit>

00006fec <__divmodhi4_neg2>:
    6fec:	70 95       	com	r23
    6fee:	61 95       	neg	r22
    6ff0:	7f 4f       	sbci	r23, 0xFF	; 255

00006ff2 <__divmodhi4_exit>:
    6ff2:	08 95       	ret

00006ff4 <__divmodhi4_neg1>:
    6ff4:	f6 f7       	brtc	.-4      	; 0x6ff2 <__divmodhi4_exit>
    6ff6:	90 95       	com	r25
    6ff8:	81 95       	neg	r24
    6ffa:	9f 4f       	sbci	r25, 0xFF	; 255
    6ffc:	08 95       	ret

00006ffe <__udivmodsi4>:
    6ffe:	a1 e2       	ldi	r26, 0x21	; 33
    7000:	1a 2e       	mov	r1, r26
    7002:	aa 1b       	sub	r26, r26
    7004:	bb 1b       	sub	r27, r27
    7006:	fd 01       	movw	r30, r26
    7008:	0d c0       	rjmp	.+26     	; 0x7024 <__udivmodsi4_ep>

0000700a <__udivmodsi4_loop>:
    700a:	aa 1f       	adc	r26, r26
    700c:	bb 1f       	adc	r27, r27
    700e:	ee 1f       	adc	r30, r30
    7010:	ff 1f       	adc	r31, r31
    7012:	a2 17       	cp	r26, r18
    7014:	b3 07       	cpc	r27, r19
    7016:	e4 07       	cpc	r30, r20
    7018:	f5 07       	cpc	r31, r21
    701a:	20 f0       	brcs	.+8      	; 0x7024 <__udivmodsi4_ep>
    701c:	a2 1b       	sub	r26, r18
    701e:	b3 0b       	sbc	r27, r19
    7020:	e4 0b       	sbc	r30, r20
    7022:	f5 0b       	sbc	r31, r21

00007024 <__udivmodsi4_ep>:
    7024:	66 1f       	adc	r22, r22
    7026:	77 1f       	adc	r23, r23
    7028:	88 1f       	adc	r24, r24
    702a:	99 1f       	adc	r25, r25
    702c:	1a 94       	dec	r1
    702e:	69 f7       	brne	.-38     	; 0x700a <__udivmodsi4_loop>
    7030:	60 95       	com	r22
    7032:	70 95       	com	r23
    7034:	80 95       	com	r24
    7036:	90 95       	com	r25
    7038:	9b 01       	movw	r18, r22
    703a:	ac 01       	movw	r20, r24
    703c:	bd 01       	movw	r22, r26
    703e:	cf 01       	movw	r24, r30
    7040:	08 95       	ret

00007042 <__divmodsi4>:
    7042:	97 fb       	bst	r25, 7
    7044:	09 2e       	mov	r0, r25
    7046:	05 26       	eor	r0, r21
    7048:	0e d0       	rcall	.+28     	; 0x7066 <__divmodsi4_neg1>
    704a:	57 fd       	sbrc	r21, 7
    704c:	04 d0       	rcall	.+8      	; 0x7056 <__divmodsi4_neg2>
    704e:	d7 df       	rcall	.-82     	; 0x6ffe <__udivmodsi4>
    7050:	0a d0       	rcall	.+20     	; 0x7066 <__divmodsi4_neg1>
    7052:	00 1c       	adc	r0, r0
    7054:	38 f4       	brcc	.+14     	; 0x7064 <__divmodsi4_exit>

00007056 <__divmodsi4_neg2>:
    7056:	50 95       	com	r21
    7058:	40 95       	com	r20
    705a:	30 95       	com	r19
    705c:	21 95       	neg	r18
    705e:	3f 4f       	sbci	r19, 0xFF	; 255
    7060:	4f 4f       	sbci	r20, 0xFF	; 255
    7062:	5f 4f       	sbci	r21, 0xFF	; 255

00007064 <__divmodsi4_exit>:
    7064:	08 95       	ret

00007066 <__divmodsi4_neg1>:
    7066:	f6 f7       	brtc	.-4      	; 0x7064 <__divmodsi4_exit>
    7068:	90 95       	com	r25
    706a:	80 95       	com	r24
    706c:	70 95       	com	r23
    706e:	61 95       	neg	r22
    7070:	7f 4f       	sbci	r23, 0xFF	; 255
    7072:	8f 4f       	sbci	r24, 0xFF	; 255
    7074:	9f 4f       	sbci	r25, 0xFF	; 255
    7076:	08 95       	ret

00007078 <__prologue_saves__>:
    7078:	2f 92       	push	r2
    707a:	3f 92       	push	r3
    707c:	4f 92       	push	r4
    707e:	5f 92       	push	r5
    7080:	6f 92       	push	r6
    7082:	7f 92       	push	r7
    7084:	8f 92       	push	r8
    7086:	9f 92       	push	r9
    7088:	af 92       	push	r10
    708a:	bf 92       	push	r11
    708c:	cf 92       	push	r12
    708e:	df 92       	push	r13
    7090:	ef 92       	push	r14
    7092:	ff 92       	push	r15
    7094:	0f 93       	push	r16
    7096:	1f 93       	push	r17
    7098:	cf 93       	push	r28
    709a:	df 93       	push	r29
    709c:	cd b7       	in	r28, 0x3d	; 61
    709e:	de b7       	in	r29, 0x3e	; 62
    70a0:	ca 1b       	sub	r28, r26
    70a2:	db 0b       	sbc	r29, r27
    70a4:	cd bf       	out	0x3d, r28	; 61
    70a6:	de bf       	out	0x3e, r29	; 62
    70a8:	19 94       	eijmp

000070aa <__epilogue_restores__>:
    70aa:	2a 88       	ldd	r2, Y+18	; 0x12
    70ac:	39 88       	ldd	r3, Y+17	; 0x11
    70ae:	48 88       	ldd	r4, Y+16	; 0x10
    70b0:	5f 84       	ldd	r5, Y+15	; 0x0f
    70b2:	6e 84       	ldd	r6, Y+14	; 0x0e
    70b4:	7d 84       	ldd	r7, Y+13	; 0x0d
    70b6:	8c 84       	ldd	r8, Y+12	; 0x0c
    70b8:	9b 84       	ldd	r9, Y+11	; 0x0b
    70ba:	aa 84       	ldd	r10, Y+10	; 0x0a
    70bc:	b9 84       	ldd	r11, Y+9	; 0x09
    70be:	c8 84       	ldd	r12, Y+8	; 0x08
    70c0:	df 80       	ldd	r13, Y+7	; 0x07
    70c2:	ee 80       	ldd	r14, Y+6	; 0x06
    70c4:	fd 80       	ldd	r15, Y+5	; 0x05
    70c6:	0c 81       	ldd	r16, Y+4	; 0x04
    70c8:	1b 81       	ldd	r17, Y+3	; 0x03
    70ca:	aa 81       	ldd	r26, Y+2	; 0x02
    70cc:	b9 81       	ldd	r27, Y+1	; 0x01
    70ce:	ce 0f       	add	r28, r30
    70d0:	d1 1d       	adc	r29, r1
    70d2:	cd bf       	out	0x3d, r28	; 61
    70d4:	de bf       	out	0x3e, r29	; 62
    70d6:	ed 01       	movw	r28, r26
    70d8:	08 95       	ret

000070da <strcpy_P>:
    70da:	fb 01       	movw	r30, r22
    70dc:	dc 01       	movw	r26, r24
    70de:	05 90       	lpm	r0, Z+
    70e0:	0d 92       	st	X+, r0
    70e2:	00 20       	and	r0, r0
    70e4:	e1 f7       	brne	.-8      	; 0x70de <strcpy_P+0x4>
    70e6:	08 95       	ret

000070e8 <memmove>:
    70e8:	68 17       	cp	r22, r24
    70ea:	79 07       	cpc	r23, r25
    70ec:	68 f4       	brcc	.+26     	; 0x7108 <memmove+0x20>
    70ee:	fb 01       	movw	r30, r22
    70f0:	dc 01       	movw	r26, r24
    70f2:	e4 0f       	add	r30, r20
    70f4:	f5 1f       	adc	r31, r21
    70f6:	a4 0f       	add	r26, r20
    70f8:	b5 1f       	adc	r27, r21
    70fa:	02 c0       	rjmp	.+4      	; 0x7100 <memmove+0x18>
    70fc:	02 90       	ld	r0, -Z
    70fe:	0e 92       	st	-X, r0
    7100:	41 50       	subi	r20, 0x01	; 1
    7102:	50 40       	sbci	r21, 0x00	; 0
    7104:	d8 f7       	brcc	.-10     	; 0x70fc <memmove+0x14>
    7106:	08 95       	ret
    7108:	0c 94 07 3b 	jmp	0x760e	; 0x760e <memcpy>

0000710c <strcat>:
    710c:	fb 01       	movw	r30, r22
    710e:	dc 01       	movw	r26, r24
    7110:	0d 90       	ld	r0, X+
    7112:	00 20       	and	r0, r0
    7114:	e9 f7       	brne	.-6      	; 0x7110 <strcat+0x4>
    7116:	11 97       	sbiw	r26, 0x01	; 1
    7118:	01 90       	ld	r0, Z+
    711a:	0d 92       	st	X+, r0
    711c:	00 20       	and	r0, r0
    711e:	e1 f7       	brne	.-8      	; 0x7118 <strcat+0xc>
    7120:	08 95       	ret

00007122 <strncmp>:
    7122:	fb 01       	movw	r30, r22
    7124:	dc 01       	movw	r26, r24
    7126:	41 50       	subi	r20, 0x01	; 1
    7128:	50 40       	sbci	r21, 0x00	; 0
    712a:	30 f0       	brcs	.+12     	; 0x7138 <strncmp+0x16>
    712c:	8d 91       	ld	r24, X+
    712e:	01 90       	ld	r0, Z+
    7130:	80 19       	sub	r24, r0
    7132:	19 f4       	brne	.+6      	; 0x713a <strncmp+0x18>
    7134:	00 20       	and	r0, r0
    7136:	b9 f7       	brne	.-18     	; 0x7126 <strncmp+0x4>
    7138:	88 1b       	sub	r24, r24
    713a:	99 0b       	sbc	r25, r25
    713c:	08 95       	ret

0000713e <itoa>:
    713e:	fb 01       	movw	r30, r22
    7140:	9f 01       	movw	r18, r30
    7142:	e8 94       	clt
    7144:	42 30       	cpi	r20, 0x02	; 2
    7146:	c4 f0       	brlt	.+48     	; 0x7178 <itoa+0x3a>
    7148:	45 32       	cpi	r20, 0x25	; 37
    714a:	b4 f4       	brge	.+44     	; 0x7178 <itoa+0x3a>
    714c:	4a 30       	cpi	r20, 0x0A	; 10
    714e:	29 f4       	brne	.+10     	; 0x715a <itoa+0x1c>
    7150:	97 fb       	bst	r25, 7
    7152:	1e f4       	brtc	.+6      	; 0x715a <itoa+0x1c>
    7154:	90 95       	com	r25
    7156:	81 95       	neg	r24
    7158:	9f 4f       	sbci	r25, 0xFF	; 255
    715a:	64 2f       	mov	r22, r20
    715c:	77 27       	eor	r23, r23
    715e:	0e 94 d8 37 	call	0x6fb0	; 0x6fb0 <__udivmodhi4>
    7162:	80 5d       	subi	r24, 0xD0	; 208
    7164:	8a 33       	cpi	r24, 0x3A	; 58
    7166:	0c f0       	brlt	.+2      	; 0x716a <itoa+0x2c>
    7168:	89 5d       	subi	r24, 0xD9	; 217
    716a:	81 93       	st	Z+, r24
    716c:	cb 01       	movw	r24, r22
    716e:	00 97       	sbiw	r24, 0x00	; 0
    7170:	a1 f7       	brne	.-24     	; 0x715a <itoa+0x1c>
    7172:	16 f4       	brtc	.+4      	; 0x7178 <itoa+0x3a>
    7174:	5d e2       	ldi	r21, 0x2D	; 45
    7176:	51 93       	st	Z+, r21
    7178:	10 82       	st	Z, r1
    717a:	c9 01       	movw	r24, r18
    717c:	0c 94 1b 3b 	jmp	0x7636	; 0x7636 <strrev>

00007180 <printf>:
    7180:	cf 93       	push	r28
    7182:	df 93       	push	r29
    7184:	cd b7       	in	r28, 0x3d	; 61
    7186:	de b7       	in	r29, 0x3e	; 62
    7188:	fe 01       	movw	r30, r28
    718a:	36 96       	adiw	r30, 0x06	; 6
    718c:	61 91       	ld	r22, Z+
    718e:	71 91       	ld	r23, Z+
    7190:	80 91 e1 50 	lds	r24, 0x50E1
    7194:	90 91 e2 50 	lds	r25, 0x50E2
    7198:	af 01       	movw	r20, r30
    719a:	0e 94 fb 38 	call	0x71f6	; 0x71f6 <vfprintf>
    719e:	df 91       	pop	r29
    71a0:	cf 91       	pop	r28
    71a2:	08 95       	ret

000071a4 <sprintf>:
    71a4:	0f 93       	push	r16
    71a6:	1f 93       	push	r17
    71a8:	cf 93       	push	r28
    71aa:	df 93       	push	r29
    71ac:	cd b7       	in	r28, 0x3d	; 61
    71ae:	de b7       	in	r29, 0x3e	; 62
    71b0:	2e 97       	sbiw	r28, 0x0e	; 14
    71b2:	cd bf       	out	0x3d, r28	; 61
    71b4:	de bf       	out	0x3e, r29	; 62
    71b6:	0e 89       	ldd	r16, Y+22	; 0x16
    71b8:	1f 89       	ldd	r17, Y+23	; 0x17
    71ba:	86 e0       	ldi	r24, 0x06	; 6
    71bc:	8c 83       	std	Y+4, r24	; 0x04
    71be:	09 83       	std	Y+1, r16	; 0x01
    71c0:	1a 83       	std	Y+2, r17	; 0x02
    71c2:	8f ef       	ldi	r24, 0xFF	; 255
    71c4:	9f e7       	ldi	r25, 0x7F	; 127
    71c6:	8d 83       	std	Y+5, r24	; 0x05
    71c8:	9e 83       	std	Y+6, r25	; 0x06
    71ca:	ae 01       	movw	r20, r28
    71cc:	46 5e       	subi	r20, 0xE6	; 230
    71ce:	5f 4f       	sbci	r21, 0xFF	; 255
    71d0:	ce 01       	movw	r24, r28
    71d2:	01 96       	adiw	r24, 0x01	; 1
    71d4:	68 8d       	ldd	r22, Y+24	; 0x18
    71d6:	79 8d       	ldd	r23, Y+25	; 0x19
    71d8:	0e 94 fb 38 	call	0x71f6	; 0x71f6 <vfprintf>
    71dc:	ef 81       	ldd	r30, Y+7	; 0x07
    71de:	f8 85       	ldd	r31, Y+8	; 0x08
    71e0:	e0 0f       	add	r30, r16
    71e2:	f1 1f       	adc	r31, r17
    71e4:	10 82       	st	Z, r1
    71e6:	2e 96       	adiw	r28, 0x0e	; 14
    71e8:	cd bf       	out	0x3d, r28	; 61
    71ea:	de bf       	out	0x3e, r29	; 62
    71ec:	df 91       	pop	r29
    71ee:	cf 91       	pop	r28
    71f0:	1f 91       	pop	r17
    71f2:	0f 91       	pop	r16
    71f4:	08 95       	ret

000071f6 <vfprintf>:
    71f6:	2f 92       	push	r2
    71f8:	3f 92       	push	r3
    71fa:	4f 92       	push	r4
    71fc:	5f 92       	push	r5
    71fe:	6f 92       	push	r6
    7200:	7f 92       	push	r7
    7202:	8f 92       	push	r8
    7204:	9f 92       	push	r9
    7206:	af 92       	push	r10
    7208:	bf 92       	push	r11
    720a:	cf 92       	push	r12
    720c:	df 92       	push	r13
    720e:	ef 92       	push	r14
    7210:	ff 92       	push	r15
    7212:	0f 93       	push	r16
    7214:	1f 93       	push	r17
    7216:	cf 93       	push	r28
    7218:	df 93       	push	r29
    721a:	cd b7       	in	r28, 0x3d	; 61
    721c:	de b7       	in	r29, 0x3e	; 62
    721e:	2d 97       	sbiw	r28, 0x0d	; 13
    7220:	cd bf       	out	0x3d, r28	; 61
    7222:	de bf       	out	0x3e, r29	; 62
    7224:	3c 01       	movw	r6, r24
    7226:	6c 87       	std	Y+12, r22	; 0x0c
    7228:	7d 87       	std	Y+13, r23	; 0x0d
    722a:	5a 01       	movw	r10, r20
    722c:	fc 01       	movw	r30, r24
    722e:	16 82       	std	Z+6, r1	; 0x06
    7230:	17 82       	std	Z+7, r1	; 0x07
    7232:	83 81       	ldd	r24, Z+3	; 0x03
    7234:	81 ff       	sbrs	r24, 1
    7236:	c8 c1       	rjmp	.+912    	; 0x75c8 <vfprintf+0x3d2>
    7238:	2e 01       	movw	r4, r28
    723a:	08 94       	sec
    723c:	41 1c       	adc	r4, r1
    723e:	51 1c       	adc	r5, r1
    7240:	f3 01       	movw	r30, r6
    7242:	93 81       	ldd	r25, Z+3	; 0x03
    7244:	ec 85       	ldd	r30, Y+12	; 0x0c
    7246:	fd 85       	ldd	r31, Y+13	; 0x0d
    7248:	93 fd       	sbrc	r25, 3
    724a:	85 91       	lpm	r24, Z+
    724c:	93 ff       	sbrs	r25, 3
    724e:	81 91       	ld	r24, Z+
    7250:	ec 87       	std	Y+12, r30	; 0x0c
    7252:	fd 87       	std	Y+13, r31	; 0x0d
    7254:	88 23       	and	r24, r24
    7256:	09 f4       	brne	.+2      	; 0x725a <vfprintf+0x64>
    7258:	b3 c1       	rjmp	.+870    	; 0x75c0 <vfprintf+0x3ca>
    725a:	85 32       	cpi	r24, 0x25	; 37
    725c:	41 f4       	brne	.+16     	; 0x726e <vfprintf+0x78>
    725e:	93 fd       	sbrc	r25, 3
    7260:	85 91       	lpm	r24, Z+
    7262:	93 ff       	sbrs	r25, 3
    7264:	81 91       	ld	r24, Z+
    7266:	ec 87       	std	Y+12, r30	; 0x0c
    7268:	fd 87       	std	Y+13, r31	; 0x0d
    726a:	85 32       	cpi	r24, 0x25	; 37
    726c:	29 f4       	brne	.+10     	; 0x7278 <vfprintf+0x82>
    726e:	90 e0       	ldi	r25, 0x00	; 0
    7270:	b3 01       	movw	r22, r6
    7272:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    7276:	e4 cf       	rjmp	.-56     	; 0x7240 <vfprintf+0x4a>
    7278:	ff 24       	eor	r15, r15
    727a:	ee 24       	eor	r14, r14
    727c:	10 e0       	ldi	r17, 0x00	; 0
    727e:	10 32       	cpi	r17, 0x20	; 32
    7280:	b0 f4       	brcc	.+44     	; 0x72ae <vfprintf+0xb8>
    7282:	8b 32       	cpi	r24, 0x2B	; 43
    7284:	69 f0       	breq	.+26     	; 0x72a0 <vfprintf+0xaa>
    7286:	8c 32       	cpi	r24, 0x2C	; 44
    7288:	28 f4       	brcc	.+10     	; 0x7294 <vfprintf+0x9e>
    728a:	80 32       	cpi	r24, 0x20	; 32
    728c:	51 f0       	breq	.+20     	; 0x72a2 <vfprintf+0xac>
    728e:	83 32       	cpi	r24, 0x23	; 35
    7290:	71 f4       	brne	.+28     	; 0x72ae <vfprintf+0xb8>
    7292:	0b c0       	rjmp	.+22     	; 0x72aa <vfprintf+0xb4>
    7294:	8d 32       	cpi	r24, 0x2D	; 45
    7296:	39 f0       	breq	.+14     	; 0x72a6 <vfprintf+0xb0>
    7298:	80 33       	cpi	r24, 0x30	; 48
    729a:	49 f4       	brne	.+18     	; 0x72ae <vfprintf+0xb8>
    729c:	11 60       	ori	r17, 0x01	; 1
    729e:	2c c0       	rjmp	.+88     	; 0x72f8 <vfprintf+0x102>
    72a0:	12 60       	ori	r17, 0x02	; 2
    72a2:	14 60       	ori	r17, 0x04	; 4
    72a4:	29 c0       	rjmp	.+82     	; 0x72f8 <vfprintf+0x102>
    72a6:	18 60       	ori	r17, 0x08	; 8
    72a8:	27 c0       	rjmp	.+78     	; 0x72f8 <vfprintf+0x102>
    72aa:	10 61       	ori	r17, 0x10	; 16
    72ac:	25 c0       	rjmp	.+74     	; 0x72f8 <vfprintf+0x102>
    72ae:	17 fd       	sbrc	r17, 7
    72b0:	2e c0       	rjmp	.+92     	; 0x730e <vfprintf+0x118>
    72b2:	28 2f       	mov	r18, r24
    72b4:	20 53       	subi	r18, 0x30	; 48
    72b6:	2a 30       	cpi	r18, 0x0A	; 10
    72b8:	98 f4       	brcc	.+38     	; 0x72e0 <vfprintf+0xea>
    72ba:	16 ff       	sbrs	r17, 6
    72bc:	08 c0       	rjmp	.+16     	; 0x72ce <vfprintf+0xd8>
    72be:	8f 2d       	mov	r24, r15
    72c0:	88 0f       	add	r24, r24
    72c2:	f8 2e       	mov	r15, r24
    72c4:	ff 0c       	add	r15, r15
    72c6:	ff 0c       	add	r15, r15
    72c8:	f8 0e       	add	r15, r24
    72ca:	f2 0e       	add	r15, r18
    72cc:	15 c0       	rjmp	.+42     	; 0x72f8 <vfprintf+0x102>
    72ce:	8e 2d       	mov	r24, r14
    72d0:	88 0f       	add	r24, r24
    72d2:	e8 2e       	mov	r14, r24
    72d4:	ee 0c       	add	r14, r14
    72d6:	ee 0c       	add	r14, r14
    72d8:	e8 0e       	add	r14, r24
    72da:	e2 0e       	add	r14, r18
    72dc:	10 62       	ori	r17, 0x20	; 32
    72de:	0c c0       	rjmp	.+24     	; 0x72f8 <vfprintf+0x102>
    72e0:	8e 32       	cpi	r24, 0x2E	; 46
    72e2:	21 f4       	brne	.+8      	; 0x72ec <vfprintf+0xf6>
    72e4:	16 fd       	sbrc	r17, 6
    72e6:	6c c1       	rjmp	.+728    	; 0x75c0 <vfprintf+0x3ca>
    72e8:	10 64       	ori	r17, 0x40	; 64
    72ea:	06 c0       	rjmp	.+12     	; 0x72f8 <vfprintf+0x102>
    72ec:	8c 36       	cpi	r24, 0x6C	; 108
    72ee:	11 f4       	brne	.+4      	; 0x72f4 <vfprintf+0xfe>
    72f0:	10 68       	ori	r17, 0x80	; 128
    72f2:	02 c0       	rjmp	.+4      	; 0x72f8 <vfprintf+0x102>
    72f4:	88 36       	cpi	r24, 0x68	; 104
    72f6:	59 f4       	brne	.+22     	; 0x730e <vfprintf+0x118>
    72f8:	ec 85       	ldd	r30, Y+12	; 0x0c
    72fa:	fd 85       	ldd	r31, Y+13	; 0x0d
    72fc:	93 fd       	sbrc	r25, 3
    72fe:	85 91       	lpm	r24, Z+
    7300:	93 ff       	sbrs	r25, 3
    7302:	81 91       	ld	r24, Z+
    7304:	ec 87       	std	Y+12, r30	; 0x0c
    7306:	fd 87       	std	Y+13, r31	; 0x0d
    7308:	88 23       	and	r24, r24
    730a:	09 f0       	breq	.+2      	; 0x730e <vfprintf+0x118>
    730c:	b8 cf       	rjmp	.-144    	; 0x727e <vfprintf+0x88>
    730e:	98 2f       	mov	r25, r24
    7310:	95 54       	subi	r25, 0x45	; 69
    7312:	93 30       	cpi	r25, 0x03	; 3
    7314:	18 f0       	brcs	.+6      	; 0x731c <vfprintf+0x126>
    7316:	90 52       	subi	r25, 0x20	; 32
    7318:	93 30       	cpi	r25, 0x03	; 3
    731a:	38 f4       	brcc	.+14     	; 0x732a <vfprintf+0x134>
    731c:	24 e0       	ldi	r18, 0x04	; 4
    731e:	30 e0       	ldi	r19, 0x00	; 0
    7320:	a2 0e       	add	r10, r18
    7322:	b3 1e       	adc	r11, r19
    7324:	3f e3       	ldi	r19, 0x3F	; 63
    7326:	39 83       	std	Y+1, r19	; 0x01
    7328:	0f c0       	rjmp	.+30     	; 0x7348 <vfprintf+0x152>
    732a:	83 36       	cpi	r24, 0x63	; 99
    732c:	31 f0       	breq	.+12     	; 0x733a <vfprintf+0x144>
    732e:	83 37       	cpi	r24, 0x73	; 115
    7330:	81 f0       	breq	.+32     	; 0x7352 <vfprintf+0x15c>
    7332:	83 35       	cpi	r24, 0x53	; 83
    7334:	09 f0       	breq	.+2      	; 0x7338 <vfprintf+0x142>
    7336:	5a c0       	rjmp	.+180    	; 0x73ec <vfprintf+0x1f6>
    7338:	22 c0       	rjmp	.+68     	; 0x737e <vfprintf+0x188>
    733a:	f5 01       	movw	r30, r10
    733c:	80 81       	ld	r24, Z
    733e:	89 83       	std	Y+1, r24	; 0x01
    7340:	22 e0       	ldi	r18, 0x02	; 2
    7342:	30 e0       	ldi	r19, 0x00	; 0
    7344:	a2 0e       	add	r10, r18
    7346:	b3 1e       	adc	r11, r19
    7348:	21 e0       	ldi	r18, 0x01	; 1
    734a:	c2 2e       	mov	r12, r18
    734c:	d1 2c       	mov	r13, r1
    734e:	42 01       	movw	r8, r4
    7350:	14 c0       	rjmp	.+40     	; 0x737a <vfprintf+0x184>
    7352:	92 e0       	ldi	r25, 0x02	; 2
    7354:	29 2e       	mov	r2, r25
    7356:	31 2c       	mov	r3, r1
    7358:	2a 0c       	add	r2, r10
    735a:	3b 1c       	adc	r3, r11
    735c:	f5 01       	movw	r30, r10
    735e:	80 80       	ld	r8, Z
    7360:	91 80       	ldd	r9, Z+1	; 0x01
    7362:	16 ff       	sbrs	r17, 6
    7364:	03 c0       	rjmp	.+6      	; 0x736c <vfprintf+0x176>
    7366:	6f 2d       	mov	r22, r15
    7368:	70 e0       	ldi	r23, 0x00	; 0
    736a:	02 c0       	rjmp	.+4      	; 0x7370 <vfprintf+0x17a>
    736c:	6f ef       	ldi	r22, 0xFF	; 255
    736e:	7f ef       	ldi	r23, 0xFF	; 255
    7370:	c4 01       	movw	r24, r8
    7372:	0e 94 10 3b 	call	0x7620	; 0x7620 <strnlen>
    7376:	6c 01       	movw	r12, r24
    7378:	51 01       	movw	r10, r2
    737a:	1f 77       	andi	r17, 0x7F	; 127
    737c:	15 c0       	rjmp	.+42     	; 0x73a8 <vfprintf+0x1b2>
    737e:	82 e0       	ldi	r24, 0x02	; 2
    7380:	28 2e       	mov	r2, r24
    7382:	31 2c       	mov	r3, r1
    7384:	2a 0c       	add	r2, r10
    7386:	3b 1c       	adc	r3, r11
    7388:	f5 01       	movw	r30, r10
    738a:	80 80       	ld	r8, Z
    738c:	91 80       	ldd	r9, Z+1	; 0x01
    738e:	16 ff       	sbrs	r17, 6
    7390:	03 c0       	rjmp	.+6      	; 0x7398 <vfprintf+0x1a2>
    7392:	6f 2d       	mov	r22, r15
    7394:	70 e0       	ldi	r23, 0x00	; 0
    7396:	02 c0       	rjmp	.+4      	; 0x739c <vfprintf+0x1a6>
    7398:	6f ef       	ldi	r22, 0xFF	; 255
    739a:	7f ef       	ldi	r23, 0xFF	; 255
    739c:	c4 01       	movw	r24, r8
    739e:	0e 94 fc 3a 	call	0x75f8	; 0x75f8 <strnlen_P>
    73a2:	6c 01       	movw	r12, r24
    73a4:	10 68       	ori	r17, 0x80	; 128
    73a6:	51 01       	movw	r10, r2
    73a8:	13 fd       	sbrc	r17, 3
    73aa:	1c c0       	rjmp	.+56     	; 0x73e4 <vfprintf+0x1ee>
    73ac:	06 c0       	rjmp	.+12     	; 0x73ba <vfprintf+0x1c4>
    73ae:	80 e2       	ldi	r24, 0x20	; 32
    73b0:	90 e0       	ldi	r25, 0x00	; 0
    73b2:	b3 01       	movw	r22, r6
    73b4:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    73b8:	ea 94       	dec	r14
    73ba:	8e 2d       	mov	r24, r14
    73bc:	90 e0       	ldi	r25, 0x00	; 0
    73be:	c8 16       	cp	r12, r24
    73c0:	d9 06       	cpc	r13, r25
    73c2:	a8 f3       	brcs	.-22     	; 0x73ae <vfprintf+0x1b8>
    73c4:	0f c0       	rjmp	.+30     	; 0x73e4 <vfprintf+0x1ee>
    73c6:	f4 01       	movw	r30, r8
    73c8:	17 fd       	sbrc	r17, 7
    73ca:	85 91       	lpm	r24, Z+
    73cc:	17 ff       	sbrs	r17, 7
    73ce:	81 91       	ld	r24, Z+
    73d0:	4f 01       	movw	r8, r30
    73d2:	90 e0       	ldi	r25, 0x00	; 0
    73d4:	b3 01       	movw	r22, r6
    73d6:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    73da:	e1 10       	cpse	r14, r1
    73dc:	ea 94       	dec	r14
    73de:	08 94       	sec
    73e0:	c1 08       	sbc	r12, r1
    73e2:	d1 08       	sbc	r13, r1
    73e4:	c1 14       	cp	r12, r1
    73e6:	d1 04       	cpc	r13, r1
    73e8:	71 f7       	brne	.-36     	; 0x73c6 <vfprintf+0x1d0>
    73ea:	e7 c0       	rjmp	.+462    	; 0x75ba <vfprintf+0x3c4>
    73ec:	84 36       	cpi	r24, 0x64	; 100
    73ee:	11 f0       	breq	.+4      	; 0x73f4 <vfprintf+0x1fe>
    73f0:	89 36       	cpi	r24, 0x69	; 105
    73f2:	51 f5       	brne	.+84     	; 0x7448 <vfprintf+0x252>
    73f4:	f5 01       	movw	r30, r10
    73f6:	17 ff       	sbrs	r17, 7
    73f8:	07 c0       	rjmp	.+14     	; 0x7408 <vfprintf+0x212>
    73fa:	80 81       	ld	r24, Z
    73fc:	91 81       	ldd	r25, Z+1	; 0x01
    73fe:	a2 81       	ldd	r26, Z+2	; 0x02
    7400:	b3 81       	ldd	r27, Z+3	; 0x03
    7402:	24 e0       	ldi	r18, 0x04	; 4
    7404:	30 e0       	ldi	r19, 0x00	; 0
    7406:	08 c0       	rjmp	.+16     	; 0x7418 <vfprintf+0x222>
    7408:	80 81       	ld	r24, Z
    740a:	91 81       	ldd	r25, Z+1	; 0x01
    740c:	aa 27       	eor	r26, r26
    740e:	97 fd       	sbrc	r25, 7
    7410:	a0 95       	com	r26
    7412:	ba 2f       	mov	r27, r26
    7414:	22 e0       	ldi	r18, 0x02	; 2
    7416:	30 e0       	ldi	r19, 0x00	; 0
    7418:	a2 0e       	add	r10, r18
    741a:	b3 1e       	adc	r11, r19
    741c:	01 2f       	mov	r16, r17
    741e:	0f 76       	andi	r16, 0x6F	; 111
    7420:	b7 ff       	sbrs	r27, 7
    7422:	08 c0       	rjmp	.+16     	; 0x7434 <vfprintf+0x23e>
    7424:	b0 95       	com	r27
    7426:	a0 95       	com	r26
    7428:	90 95       	com	r25
    742a:	81 95       	neg	r24
    742c:	9f 4f       	sbci	r25, 0xFF	; 255
    742e:	af 4f       	sbci	r26, 0xFF	; 255
    7430:	bf 4f       	sbci	r27, 0xFF	; 255
    7432:	00 68       	ori	r16, 0x80	; 128
    7434:	bc 01       	movw	r22, r24
    7436:	cd 01       	movw	r24, r26
    7438:	a2 01       	movw	r20, r4
    743a:	2a e0       	ldi	r18, 0x0A	; 10
    743c:	30 e0       	ldi	r19, 0x00	; 0
    743e:	0e 94 57 3b 	call	0x76ae	; 0x76ae <__ultoa_invert>
    7442:	d8 2e       	mov	r13, r24
    7444:	d4 18       	sub	r13, r4
    7446:	3f c0       	rjmp	.+126    	; 0x74c6 <vfprintf+0x2d0>
    7448:	85 37       	cpi	r24, 0x75	; 117
    744a:	21 f4       	brne	.+8      	; 0x7454 <vfprintf+0x25e>
    744c:	1f 7e       	andi	r17, 0xEF	; 239
    744e:	2a e0       	ldi	r18, 0x0A	; 10
    7450:	30 e0       	ldi	r19, 0x00	; 0
    7452:	20 c0       	rjmp	.+64     	; 0x7494 <vfprintf+0x29e>
    7454:	19 7f       	andi	r17, 0xF9	; 249
    7456:	8f 36       	cpi	r24, 0x6F	; 111
    7458:	a9 f0       	breq	.+42     	; 0x7484 <vfprintf+0x28e>
    745a:	80 37       	cpi	r24, 0x70	; 112
    745c:	20 f4       	brcc	.+8      	; 0x7466 <vfprintf+0x270>
    745e:	88 35       	cpi	r24, 0x58	; 88
    7460:	09 f0       	breq	.+2      	; 0x7464 <vfprintf+0x26e>
    7462:	ae c0       	rjmp	.+348    	; 0x75c0 <vfprintf+0x3ca>
    7464:	0b c0       	rjmp	.+22     	; 0x747c <vfprintf+0x286>
    7466:	80 37       	cpi	r24, 0x70	; 112
    7468:	21 f0       	breq	.+8      	; 0x7472 <vfprintf+0x27c>
    746a:	88 37       	cpi	r24, 0x78	; 120
    746c:	09 f0       	breq	.+2      	; 0x7470 <vfprintf+0x27a>
    746e:	a8 c0       	rjmp	.+336    	; 0x75c0 <vfprintf+0x3ca>
    7470:	01 c0       	rjmp	.+2      	; 0x7474 <vfprintf+0x27e>
    7472:	10 61       	ori	r17, 0x10	; 16
    7474:	14 ff       	sbrs	r17, 4
    7476:	09 c0       	rjmp	.+18     	; 0x748a <vfprintf+0x294>
    7478:	14 60       	ori	r17, 0x04	; 4
    747a:	07 c0       	rjmp	.+14     	; 0x748a <vfprintf+0x294>
    747c:	14 ff       	sbrs	r17, 4
    747e:	08 c0       	rjmp	.+16     	; 0x7490 <vfprintf+0x29a>
    7480:	16 60       	ori	r17, 0x06	; 6
    7482:	06 c0       	rjmp	.+12     	; 0x7490 <vfprintf+0x29a>
    7484:	28 e0       	ldi	r18, 0x08	; 8
    7486:	30 e0       	ldi	r19, 0x00	; 0
    7488:	05 c0       	rjmp	.+10     	; 0x7494 <vfprintf+0x29e>
    748a:	20 e1       	ldi	r18, 0x10	; 16
    748c:	30 e0       	ldi	r19, 0x00	; 0
    748e:	02 c0       	rjmp	.+4      	; 0x7494 <vfprintf+0x29e>
    7490:	20 e1       	ldi	r18, 0x10	; 16
    7492:	32 e0       	ldi	r19, 0x02	; 2
    7494:	f5 01       	movw	r30, r10
    7496:	17 ff       	sbrs	r17, 7
    7498:	07 c0       	rjmp	.+14     	; 0x74a8 <vfprintf+0x2b2>
    749a:	60 81       	ld	r22, Z
    749c:	71 81       	ldd	r23, Z+1	; 0x01
    749e:	82 81       	ldd	r24, Z+2	; 0x02
    74a0:	93 81       	ldd	r25, Z+3	; 0x03
    74a2:	44 e0       	ldi	r20, 0x04	; 4
    74a4:	50 e0       	ldi	r21, 0x00	; 0
    74a6:	06 c0       	rjmp	.+12     	; 0x74b4 <vfprintf+0x2be>
    74a8:	60 81       	ld	r22, Z
    74aa:	71 81       	ldd	r23, Z+1	; 0x01
    74ac:	80 e0       	ldi	r24, 0x00	; 0
    74ae:	90 e0       	ldi	r25, 0x00	; 0
    74b0:	42 e0       	ldi	r20, 0x02	; 2
    74b2:	50 e0       	ldi	r21, 0x00	; 0
    74b4:	a4 0e       	add	r10, r20
    74b6:	b5 1e       	adc	r11, r21
    74b8:	a2 01       	movw	r20, r4
    74ba:	0e 94 57 3b 	call	0x76ae	; 0x76ae <__ultoa_invert>
    74be:	d8 2e       	mov	r13, r24
    74c0:	d4 18       	sub	r13, r4
    74c2:	01 2f       	mov	r16, r17
    74c4:	0f 77       	andi	r16, 0x7F	; 127
    74c6:	06 ff       	sbrs	r16, 6
    74c8:	09 c0       	rjmp	.+18     	; 0x74dc <vfprintf+0x2e6>
    74ca:	0e 7f       	andi	r16, 0xFE	; 254
    74cc:	df 14       	cp	r13, r15
    74ce:	30 f4       	brcc	.+12     	; 0x74dc <vfprintf+0x2e6>
    74d0:	04 ff       	sbrs	r16, 4
    74d2:	06 c0       	rjmp	.+12     	; 0x74e0 <vfprintf+0x2ea>
    74d4:	02 fd       	sbrc	r16, 2
    74d6:	04 c0       	rjmp	.+8      	; 0x74e0 <vfprintf+0x2ea>
    74d8:	0f 7e       	andi	r16, 0xEF	; 239
    74da:	02 c0       	rjmp	.+4      	; 0x74e0 <vfprintf+0x2ea>
    74dc:	1d 2d       	mov	r17, r13
    74de:	01 c0       	rjmp	.+2      	; 0x74e2 <vfprintf+0x2ec>
    74e0:	1f 2d       	mov	r17, r15
    74e2:	80 2f       	mov	r24, r16
    74e4:	90 e0       	ldi	r25, 0x00	; 0
    74e6:	04 ff       	sbrs	r16, 4
    74e8:	0c c0       	rjmp	.+24     	; 0x7502 <vfprintf+0x30c>
    74ea:	fe 01       	movw	r30, r28
    74ec:	ed 0d       	add	r30, r13
    74ee:	f1 1d       	adc	r31, r1
    74f0:	20 81       	ld	r18, Z
    74f2:	20 33       	cpi	r18, 0x30	; 48
    74f4:	11 f4       	brne	.+4      	; 0x74fa <vfprintf+0x304>
    74f6:	09 7e       	andi	r16, 0xE9	; 233
    74f8:	09 c0       	rjmp	.+18     	; 0x750c <vfprintf+0x316>
    74fa:	02 ff       	sbrs	r16, 2
    74fc:	06 c0       	rjmp	.+12     	; 0x750a <vfprintf+0x314>
    74fe:	1e 5f       	subi	r17, 0xFE	; 254
    7500:	05 c0       	rjmp	.+10     	; 0x750c <vfprintf+0x316>
    7502:	86 78       	andi	r24, 0x86	; 134
    7504:	90 70       	andi	r25, 0x00	; 0
    7506:	00 97       	sbiw	r24, 0x00	; 0
    7508:	09 f0       	breq	.+2      	; 0x750c <vfprintf+0x316>
    750a:	1f 5f       	subi	r17, 0xFF	; 255
    750c:	80 2e       	mov	r8, r16
    750e:	99 24       	eor	r9, r9
    7510:	03 fd       	sbrc	r16, 3
    7512:	12 c0       	rjmp	.+36     	; 0x7538 <vfprintf+0x342>
    7514:	00 ff       	sbrs	r16, 0
    7516:	0d c0       	rjmp	.+26     	; 0x7532 <vfprintf+0x33c>
    7518:	fd 2c       	mov	r15, r13
    751a:	1e 15       	cp	r17, r14
    751c:	50 f4       	brcc	.+20     	; 0x7532 <vfprintf+0x33c>
    751e:	fe 0c       	add	r15, r14
    7520:	f1 1a       	sub	r15, r17
    7522:	1e 2d       	mov	r17, r14
    7524:	06 c0       	rjmp	.+12     	; 0x7532 <vfprintf+0x33c>
    7526:	80 e2       	ldi	r24, 0x20	; 32
    7528:	90 e0       	ldi	r25, 0x00	; 0
    752a:	b3 01       	movw	r22, r6
    752c:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    7530:	1f 5f       	subi	r17, 0xFF	; 255
    7532:	1e 15       	cp	r17, r14
    7534:	c0 f3       	brcs	.-16     	; 0x7526 <vfprintf+0x330>
    7536:	04 c0       	rjmp	.+8      	; 0x7540 <vfprintf+0x34a>
    7538:	1e 15       	cp	r17, r14
    753a:	10 f4       	brcc	.+4      	; 0x7540 <vfprintf+0x34a>
    753c:	e1 1a       	sub	r14, r17
    753e:	01 c0       	rjmp	.+2      	; 0x7542 <vfprintf+0x34c>
    7540:	ee 24       	eor	r14, r14
    7542:	84 fe       	sbrs	r8, 4
    7544:	0f c0       	rjmp	.+30     	; 0x7564 <vfprintf+0x36e>
    7546:	80 e3       	ldi	r24, 0x30	; 48
    7548:	90 e0       	ldi	r25, 0x00	; 0
    754a:	b3 01       	movw	r22, r6
    754c:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    7550:	82 fe       	sbrs	r8, 2
    7552:	1f c0       	rjmp	.+62     	; 0x7592 <vfprintf+0x39c>
    7554:	81 fe       	sbrs	r8, 1
    7556:	03 c0       	rjmp	.+6      	; 0x755e <vfprintf+0x368>
    7558:	88 e5       	ldi	r24, 0x58	; 88
    755a:	90 e0       	ldi	r25, 0x00	; 0
    755c:	10 c0       	rjmp	.+32     	; 0x757e <vfprintf+0x388>
    755e:	88 e7       	ldi	r24, 0x78	; 120
    7560:	90 e0       	ldi	r25, 0x00	; 0
    7562:	0d c0       	rjmp	.+26     	; 0x757e <vfprintf+0x388>
    7564:	c4 01       	movw	r24, r8
    7566:	86 78       	andi	r24, 0x86	; 134
    7568:	90 70       	andi	r25, 0x00	; 0
    756a:	00 97       	sbiw	r24, 0x00	; 0
    756c:	91 f0       	breq	.+36     	; 0x7592 <vfprintf+0x39c>
    756e:	81 fc       	sbrc	r8, 1
    7570:	02 c0       	rjmp	.+4      	; 0x7576 <vfprintf+0x380>
    7572:	80 e2       	ldi	r24, 0x20	; 32
    7574:	01 c0       	rjmp	.+2      	; 0x7578 <vfprintf+0x382>
    7576:	8b e2       	ldi	r24, 0x2B	; 43
    7578:	07 fd       	sbrc	r16, 7
    757a:	8d e2       	ldi	r24, 0x2D	; 45
    757c:	90 e0       	ldi	r25, 0x00	; 0
    757e:	b3 01       	movw	r22, r6
    7580:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    7584:	06 c0       	rjmp	.+12     	; 0x7592 <vfprintf+0x39c>
    7586:	80 e3       	ldi	r24, 0x30	; 48
    7588:	90 e0       	ldi	r25, 0x00	; 0
    758a:	b3 01       	movw	r22, r6
    758c:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    7590:	fa 94       	dec	r15
    7592:	df 14       	cp	r13, r15
    7594:	c0 f3       	brcs	.-16     	; 0x7586 <vfprintf+0x390>
    7596:	da 94       	dec	r13
    7598:	f2 01       	movw	r30, r4
    759a:	ed 0d       	add	r30, r13
    759c:	f1 1d       	adc	r31, r1
    759e:	80 81       	ld	r24, Z
    75a0:	90 e0       	ldi	r25, 0x00	; 0
    75a2:	b3 01       	movw	r22, r6
    75a4:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    75a8:	dd 20       	and	r13, r13
    75aa:	a9 f7       	brne	.-22     	; 0x7596 <vfprintf+0x3a0>
    75ac:	06 c0       	rjmp	.+12     	; 0x75ba <vfprintf+0x3c4>
    75ae:	80 e2       	ldi	r24, 0x20	; 32
    75b0:	90 e0       	ldi	r25, 0x00	; 0
    75b2:	b3 01       	movw	r22, r6
    75b4:	0e 94 2b 3b 	call	0x7656	; 0x7656 <fputc>
    75b8:	ea 94       	dec	r14
    75ba:	ee 20       	and	r14, r14
    75bc:	c1 f7       	brne	.-16     	; 0x75ae <vfprintf+0x3b8>
    75be:	40 ce       	rjmp	.-896    	; 0x7240 <vfprintf+0x4a>
    75c0:	f3 01       	movw	r30, r6
    75c2:	86 81       	ldd	r24, Z+6	; 0x06
    75c4:	97 81       	ldd	r25, Z+7	; 0x07
    75c6:	02 c0       	rjmp	.+4      	; 0x75cc <vfprintf+0x3d6>
    75c8:	8f ef       	ldi	r24, 0xFF	; 255
    75ca:	9f ef       	ldi	r25, 0xFF	; 255
    75cc:	2d 96       	adiw	r28, 0x0d	; 13
    75ce:	cd bf       	out	0x3d, r28	; 61
    75d0:	de bf       	out	0x3e, r29	; 62
    75d2:	df 91       	pop	r29
    75d4:	cf 91       	pop	r28
    75d6:	1f 91       	pop	r17
    75d8:	0f 91       	pop	r16
    75da:	ff 90       	pop	r15
    75dc:	ef 90       	pop	r14
    75de:	df 90       	pop	r13
    75e0:	cf 90       	pop	r12
    75e2:	bf 90       	pop	r11
    75e4:	af 90       	pop	r10
    75e6:	9f 90       	pop	r9
    75e8:	8f 90       	pop	r8
    75ea:	7f 90       	pop	r7
    75ec:	6f 90       	pop	r6
    75ee:	5f 90       	pop	r5
    75f0:	4f 90       	pop	r4
    75f2:	3f 90       	pop	r3
    75f4:	2f 90       	pop	r2
    75f6:	08 95       	ret

000075f8 <strnlen_P>:
    75f8:	fc 01       	movw	r30, r24
    75fa:	05 90       	lpm	r0, Z+
    75fc:	61 50       	subi	r22, 0x01	; 1
    75fe:	70 40       	sbci	r23, 0x00	; 0
    7600:	01 10       	cpse	r0, r1
    7602:	d8 f7       	brcc	.-10     	; 0x75fa <strnlen_P+0x2>
    7604:	80 95       	com	r24
    7606:	90 95       	com	r25
    7608:	8e 0f       	add	r24, r30
    760a:	9f 1f       	adc	r25, r31
    760c:	08 95       	ret

0000760e <memcpy>:
    760e:	fb 01       	movw	r30, r22
    7610:	dc 01       	movw	r26, r24
    7612:	02 c0       	rjmp	.+4      	; 0x7618 <memcpy+0xa>
    7614:	01 90       	ld	r0, Z+
    7616:	0d 92       	st	X+, r0
    7618:	41 50       	subi	r20, 0x01	; 1
    761a:	50 40       	sbci	r21, 0x00	; 0
    761c:	d8 f7       	brcc	.-10     	; 0x7614 <memcpy+0x6>
    761e:	08 95       	ret

00007620 <strnlen>:
    7620:	fc 01       	movw	r30, r24
    7622:	61 50       	subi	r22, 0x01	; 1
    7624:	70 40       	sbci	r23, 0x00	; 0
    7626:	01 90       	ld	r0, Z+
    7628:	01 10       	cpse	r0, r1
    762a:	d8 f7       	brcc	.-10     	; 0x7622 <strnlen+0x2>
    762c:	80 95       	com	r24
    762e:	90 95       	com	r25
    7630:	8e 0f       	add	r24, r30
    7632:	9f 1f       	adc	r25, r31
    7634:	08 95       	ret

00007636 <strrev>:
    7636:	dc 01       	movw	r26, r24
    7638:	fc 01       	movw	r30, r24
    763a:	67 2f       	mov	r22, r23
    763c:	71 91       	ld	r23, Z+
    763e:	77 23       	and	r23, r23
    7640:	e1 f7       	brne	.-8      	; 0x763a <strrev+0x4>
    7642:	32 97       	sbiw	r30, 0x02	; 2
    7644:	04 c0       	rjmp	.+8      	; 0x764e <strrev+0x18>
    7646:	7c 91       	ld	r23, X
    7648:	6d 93       	st	X+, r22
    764a:	70 83       	st	Z, r23
    764c:	62 91       	ld	r22, -Z
    764e:	ae 17       	cp	r26, r30
    7650:	bf 07       	cpc	r27, r31
    7652:	c8 f3       	brcs	.-14     	; 0x7646 <strrev+0x10>
    7654:	08 95       	ret

00007656 <fputc>:
    7656:	0f 93       	push	r16
    7658:	1f 93       	push	r17
    765a:	cf 93       	push	r28
    765c:	df 93       	push	r29
    765e:	8c 01       	movw	r16, r24
    7660:	eb 01       	movw	r28, r22
    7662:	8b 81       	ldd	r24, Y+3	; 0x03
    7664:	81 ff       	sbrs	r24, 1
    7666:	1b c0       	rjmp	.+54     	; 0x769e <fputc+0x48>
    7668:	82 ff       	sbrs	r24, 2
    766a:	0d c0       	rjmp	.+26     	; 0x7686 <fputc+0x30>
    766c:	2e 81       	ldd	r18, Y+6	; 0x06
    766e:	3f 81       	ldd	r19, Y+7	; 0x07
    7670:	8c 81       	ldd	r24, Y+4	; 0x04
    7672:	9d 81       	ldd	r25, Y+5	; 0x05
    7674:	28 17       	cp	r18, r24
    7676:	39 07       	cpc	r19, r25
    7678:	64 f4       	brge	.+24     	; 0x7692 <fputc+0x3c>
    767a:	e8 81       	ld	r30, Y
    767c:	f9 81       	ldd	r31, Y+1	; 0x01
    767e:	01 93       	st	Z+, r16
    7680:	e8 83       	st	Y, r30
    7682:	f9 83       	std	Y+1, r31	; 0x01
    7684:	06 c0       	rjmp	.+12     	; 0x7692 <fputc+0x3c>
    7686:	e8 85       	ldd	r30, Y+8	; 0x08
    7688:	f9 85       	ldd	r31, Y+9	; 0x09
    768a:	80 2f       	mov	r24, r16
    768c:	19 95       	eicall
    768e:	00 97       	sbiw	r24, 0x00	; 0
    7690:	31 f4       	brne	.+12     	; 0x769e <fputc+0x48>
    7692:	8e 81       	ldd	r24, Y+6	; 0x06
    7694:	9f 81       	ldd	r25, Y+7	; 0x07
    7696:	01 96       	adiw	r24, 0x01	; 1
    7698:	8e 83       	std	Y+6, r24	; 0x06
    769a:	9f 83       	std	Y+7, r25	; 0x07
    769c:	02 c0       	rjmp	.+4      	; 0x76a2 <fputc+0x4c>
    769e:	0f ef       	ldi	r16, 0xFF	; 255
    76a0:	1f ef       	ldi	r17, 0xFF	; 255
    76a2:	c8 01       	movw	r24, r16
    76a4:	df 91       	pop	r29
    76a6:	cf 91       	pop	r28
    76a8:	1f 91       	pop	r17
    76aa:	0f 91       	pop	r16
    76ac:	08 95       	ret

000076ae <__ultoa_invert>:
    76ae:	fa 01       	movw	r30, r20
    76b0:	aa 27       	eor	r26, r26
    76b2:	28 30       	cpi	r18, 0x08	; 8
    76b4:	51 f1       	breq	.+84     	; 0x770a <__ultoa_invert+0x5c>
    76b6:	20 31       	cpi	r18, 0x10	; 16
    76b8:	81 f1       	breq	.+96     	; 0x771a <__ultoa_invert+0x6c>
    76ba:	e8 94       	clt
    76bc:	6f 93       	push	r22
    76be:	6e 7f       	andi	r22, 0xFE	; 254
    76c0:	6e 5f       	subi	r22, 0xFE	; 254
    76c2:	7f 4f       	sbci	r23, 0xFF	; 255
    76c4:	8f 4f       	sbci	r24, 0xFF	; 255
    76c6:	9f 4f       	sbci	r25, 0xFF	; 255
    76c8:	af 4f       	sbci	r26, 0xFF	; 255
    76ca:	b1 e0       	ldi	r27, 0x01	; 1
    76cc:	3e d0       	rcall	.+124    	; 0x774a <__ultoa_invert+0x9c>
    76ce:	b4 e0       	ldi	r27, 0x04	; 4
    76d0:	3c d0       	rcall	.+120    	; 0x774a <__ultoa_invert+0x9c>
    76d2:	67 0f       	add	r22, r23
    76d4:	78 1f       	adc	r23, r24
    76d6:	89 1f       	adc	r24, r25
    76d8:	9a 1f       	adc	r25, r26
    76da:	a1 1d       	adc	r26, r1
    76dc:	68 0f       	add	r22, r24
    76de:	79 1f       	adc	r23, r25
    76e0:	8a 1f       	adc	r24, r26
    76e2:	91 1d       	adc	r25, r1
    76e4:	a1 1d       	adc	r26, r1
    76e6:	6a 0f       	add	r22, r26
    76e8:	71 1d       	adc	r23, r1
    76ea:	81 1d       	adc	r24, r1
    76ec:	91 1d       	adc	r25, r1
    76ee:	a1 1d       	adc	r26, r1
    76f0:	20 d0       	rcall	.+64     	; 0x7732 <__ultoa_invert+0x84>
    76f2:	09 f4       	brne	.+2      	; 0x76f6 <__ultoa_invert+0x48>
    76f4:	68 94       	set
    76f6:	3f 91       	pop	r19
    76f8:	2a e0       	ldi	r18, 0x0A	; 10
    76fa:	26 9f       	mul	r18, r22
    76fc:	11 24       	eor	r1, r1
    76fe:	30 19       	sub	r19, r0
    7700:	30 5d       	subi	r19, 0xD0	; 208
    7702:	31 93       	st	Z+, r19
    7704:	de f6       	brtc	.-74     	; 0x76bc <__ultoa_invert+0xe>
    7706:	cf 01       	movw	r24, r30
    7708:	08 95       	ret
    770a:	46 2f       	mov	r20, r22
    770c:	47 70       	andi	r20, 0x07	; 7
    770e:	40 5d       	subi	r20, 0xD0	; 208
    7710:	41 93       	st	Z+, r20
    7712:	b3 e0       	ldi	r27, 0x03	; 3
    7714:	0f d0       	rcall	.+30     	; 0x7734 <__ultoa_invert+0x86>
    7716:	c9 f7       	brne	.-14     	; 0x770a <__ultoa_invert+0x5c>
    7718:	f6 cf       	rjmp	.-20     	; 0x7706 <__ultoa_invert+0x58>
    771a:	46 2f       	mov	r20, r22
    771c:	4f 70       	andi	r20, 0x0F	; 15
    771e:	40 5d       	subi	r20, 0xD0	; 208
    7720:	4a 33       	cpi	r20, 0x3A	; 58
    7722:	18 f0       	brcs	.+6      	; 0x772a <__ultoa_invert+0x7c>
    7724:	49 5d       	subi	r20, 0xD9	; 217
    7726:	31 fd       	sbrc	r19, 1
    7728:	40 52       	subi	r20, 0x20	; 32
    772a:	41 93       	st	Z+, r20
    772c:	02 d0       	rcall	.+4      	; 0x7732 <__ultoa_invert+0x84>
    772e:	a9 f7       	brne	.-22     	; 0x771a <__ultoa_invert+0x6c>
    7730:	ea cf       	rjmp	.-44     	; 0x7706 <__ultoa_invert+0x58>
    7732:	b4 e0       	ldi	r27, 0x04	; 4
    7734:	a6 95       	lsr	r26
    7736:	97 95       	ror	r25
    7738:	87 95       	ror	r24
    773a:	77 95       	ror	r23
    773c:	67 95       	ror	r22
    773e:	ba 95       	dec	r27
    7740:	c9 f7       	brne	.-14     	; 0x7734 <__ultoa_invert+0x86>
    7742:	00 97       	sbiw	r24, 0x00	; 0
    7744:	61 05       	cpc	r22, r1
    7746:	71 05       	cpc	r23, r1
    7748:	08 95       	ret
    774a:	9b 01       	movw	r18, r22
    774c:	ac 01       	movw	r20, r24
    774e:	0a 2e       	mov	r0, r26
    7750:	06 94       	lsr	r0
    7752:	57 95       	ror	r21
    7754:	47 95       	ror	r20
    7756:	37 95       	ror	r19
    7758:	27 95       	ror	r18
    775a:	ba 95       	dec	r27
    775c:	c9 f7       	brne	.-14     	; 0x7750 <__ultoa_invert+0xa2>
    775e:	62 0f       	add	r22, r18
    7760:	73 1f       	adc	r23, r19
    7762:	84 1f       	adc	r24, r20
    7764:	95 1f       	adc	r25, r21
    7766:	a0 1d       	adc	r26, r0
    7768:	08 95       	ret

0000776a <_exit>:
    776a:	f8 94       	cli

0000776c <__stop_program>:
    776c:	ff cf       	rjmp	.-2      	; 0x776c <__stop_program>
