
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000bfb4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011a  00802000  0000bfb4  0000c048  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fac  0080211a  0080211a  0000c162  2**0
                  ALLOC
  3 .stab         00002334  00000000  00000000  0000c164  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000089d  00000000  00000000  0000e498  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003a0  00000000  00000000  0000ed38  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000abf6  00000000  00000000  0000f0d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ec0  00000000  00000000  00019cce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003aee  00000000  00000000  0001bb8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ae0  00000000  00000000  0001f67c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004486  00000000  00000000  0002115c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004ecd  00000000  00000000  000255e2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f0  00000000  00000000  0002a4af  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 f4 12 	jmp	0x25e8	; 0x25e8 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 08 12 	jmp	0x2410	; 0x2410 <__vector_16>
      44:	0c 94 38 12 	jmp	0x2470	; 0x2470 <__vector_17>
      48:	0c 94 68 12 	jmp	0x24d0	; 0x24d0 <__vector_18>
      4c:	0c 94 98 12 	jmp	0x2530	; 0x2530 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 7b 2e 	jmp	0x5cf6	; 0x5cf6 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 f9 14 	jmp	0x29f2	; 0x29f2 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 37 14 	jmp	0x286e	; 0x286e <__vector_79>
     140:	0c 94 67 14 	jmp	0x28ce	; 0x28ce <__vector_80>
     144:	0c 94 97 14 	jmp	0x292e	; 0x292e <__vector_81>
     148:	0c 94 c7 14 	jmp	0x298e	; 0x298e <__vector_82>
     14c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 13 0f 	jmp	0x1e26	; 0x1e26 <__vector_104>
     1a4:	0c 94 54 0d 	jmp	0x1aa8	; 0x1aa8 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e4 eb       	ldi	r30, 0xB4	; 180
     244:	ff eb       	ldi	r31, 0xBF	; 191
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	aa 31       	cpi	r26, 0x1A	; 26
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	aa e1       	ldi	r26, 0x1A	; 26
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a6 3c       	cpi	r26, 0xC6	; 198
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 43 51 	call	0xa286	; 0xa286 <main>
     26a:	0c 94 d8 5f 	jmp	0xbfb0	; 0xbfb0 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <CO_collectTemp>:
volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test
//volatile uint8_t newFile[15] = {'n','e','w','F','I','L','E','.',' ',' ',' ',' ',' ',' ',' '}; //must be no more than 8 letters before the extension "." 
//volatile uint8_t Filename[15];

void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	6b 97       	sbiw	r28, 0x1b	; 27
     27c:	cd bf       	out	0x3d, r28	; 61
     27e:	de bf       	out	0x3e, r29	; 62
     280:	8e 8b       	std	Y+22, r24	; 0x16
     282:	9f 8b       	std	Y+23, r25	; 0x17
     284:	68 8f       	std	Y+24, r22	; 0x18
     286:	79 8f       	std	Y+25, r23	; 0x19
     288:	4a 8f       	std	Y+26, r20	; 0x1a
     28a:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     28c:	19 82       	std	Y+1, r1	; 0x01
     28e:	1a 82       	std	Y+2, r1	; 0x02
     290:	1b 82       	std	Y+3, r1	; 0x03
     292:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     294:	80 e0       	ldi	r24, 0x00	; 0
     296:	90 e1       	ldi	r25, 0x10	; 16
     298:	a0 e0       	ldi	r26, 0x00	; 0
     29a:	b0 e0       	ldi	r27, 0x00	; 0
     29c:	8d 83       	std	Y+5, r24	; 0x05
     29e:	9e 83       	std	Y+6, r25	; 0x06
     2a0:	af 83       	std	Y+7, r26	; 0x07
     2a2:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     2a4:	19 86       	std	Y+9, r1	; 0x09
     2a6:	1a 86       	std	Y+10, r1	; 0x0a
     2a8:	1b 86       	std	Y+11, r1	; 0x0b
     2aa:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     2ac:	81 e0       	ldi	r24, 0x01	; 1
     2ae:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	92 e0       	ldi	r25, 0x02	; 2
     2b6:	0e 94 3d 1b 	call	0x367a	; 0x367a <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     2ba:	80 e0       	ldi	r24, 0x00	; 0
     2bc:	92 e0       	ldi	r25, 0x02	; 2
     2be:	20 e0       	ldi	r18, 0x00	; 0
     2c0:	32 e0       	ldi	r19, 0x02	; 2
     2c2:	f9 01       	movw	r30, r18
     2c4:	21 81       	ldd	r18, Z+1	; 0x01
     2c6:	29 7e       	andi	r18, 0xE9	; 233
     2c8:	fc 01       	movw	r30, r24
     2ca:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     2cc:	80 e0       	ldi	r24, 0x00	; 0
     2ce:	92 e0       	ldi	r25, 0x02	; 2
     2d0:	20 e0       	ldi	r18, 0x00	; 0
     2d2:	32 e0       	ldi	r19, 0x02	; 2
     2d4:	f9 01       	movw	r30, r18
     2d6:	24 81       	ldd	r18, Z+4	; 0x04
     2d8:	28 7f       	andi	r18, 0xF8	; 248
     2da:	23 60       	ori	r18, 0x03	; 3
     2dc:	fc 01       	movw	r30, r24
     2de:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     2e0:	80 e0       	ldi	r24, 0x00	; 0
     2e2:	92 e0       	ldi	r25, 0x02	; 2
     2e4:	20 e0       	ldi	r18, 0x00	; 0
     2e6:	32 e0       	ldi	r19, 0x02	; 2
     2e8:	f9 01       	movw	r30, r18
     2ea:	22 81       	ldd	r18, Z+2	; 0x02
     2ec:	2f 7c       	andi	r18, 0xCF	; 207
     2ee:	fc 01       	movw	r30, r24
     2f0:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     2f2:	80 e2       	ldi	r24, 0x20	; 32
     2f4:	92 e0       	ldi	r25, 0x02	; 2
     2f6:	20 e2       	ldi	r18, 0x20	; 32
     2f8:	32 e0       	ldi	r19, 0x02	; 2
     2fa:	f9 01       	movw	r30, r18
     2fc:	20 81       	ld	r18, Z
     2fe:	20 7e       	andi	r18, 0xE0	; 224
     300:	21 60       	ori	r18, 0x01	; 1
     302:	fc 01       	movw	r30, r24
     304:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     306:	80 e2       	ldi	r24, 0x20	; 32
     308:	92 e0       	ldi	r25, 0x02	; 2
     30a:	29 e0       	ldi	r18, 0x09	; 9
     30c:	fc 01       	movw	r30, r24
     30e:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     310:	80 e0       	ldi	r24, 0x00	; 0
     312:	92 e0       	ldi	r25, 0x02	; 2
     314:	20 e0       	ldi	r18, 0x00	; 0
     316:	32 e0       	ldi	r19, 0x02	; 2
     318:	f9 01       	movw	r30, r18
     31a:	20 81       	ld	r18, Z
     31c:	21 60       	ori	r18, 0x01	; 1
     31e:	fc 01       	movw	r30, r24
     320:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     322:	80 e0       	ldi	r24, 0x00	; 0
     324:	92 e0       	ldi	r25, 0x02	; 2
     326:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     32a:	80 e0       	ldi	r24, 0x00	; 0
     32c:	92 e0       	ldi	r25, 0x02	; 2
     32e:	60 e2       	ldi	r22, 0x20	; 32
     330:	72 e0       	ldi	r23, 0x02	; 2
     332:	40 e0       	ldi	r20, 0x00	; 0
     334:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ADC_Offset_Get_Unsigned>
     338:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     33a:	80 e0       	ldi	r24, 0x00	; 0
     33c:	92 e0       	ldi	r25, 0x02	; 2
     33e:	20 e0       	ldi	r18, 0x00	; 0
     340:	32 e0       	ldi	r19, 0x02	; 2
     342:	f9 01       	movw	r30, r18
     344:	20 81       	ld	r18, Z
     346:	2e 7f       	andi	r18, 0xFE	; 254
     348:	fc 01       	movw	r30, r24
     34a:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     34c:	80 e2       	ldi	r24, 0x20	; 32
     34e:	92 e0       	ldi	r25, 0x02	; 2
     350:	fc 01       	movw	r30, r24
     352:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     354:	80 e0       	ldi	r24, 0x00	; 0
     356:	92 e0       	ldi	r25, 0x02	; 2
     358:	20 e0       	ldi	r18, 0x00	; 0
     35a:	32 e0       	ldi	r19, 0x02	; 2
     35c:	f9 01       	movw	r30, r18
     35e:	23 81       	ldd	r18, Z+3	; 0x03
     360:	2f 73       	andi	r18, 0x3F	; 63
     362:	fc 01       	movw	r30, r24
     364:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     366:	80 e0       	ldi	r24, 0x00	; 0
     368:	92 e0       	ldi	r25, 0x02	; 2
     36a:	20 e0       	ldi	r18, 0x00	; 0
     36c:	32 e0       	ldi	r19, 0x02	; 2
     36e:	f9 01       	movw	r30, r18
     370:	20 81       	ld	r18, Z
     372:	21 60       	ori	r18, 0x01	; 1
     374:	fc 01       	movw	r30, r24
     376:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     378:	80 e0       	ldi	r24, 0x00	; 0
     37a:	92 e0       	ldi	r25, 0x02	; 2
     37c:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	92 e0       	ldi	r25, 0x02	; 2
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	32 e0       	ldi	r19, 0x02	; 2
     388:	f9 01       	movw	r30, r18
     38a:	21 81       	ldd	r18, Z+1	; 0x01
     38c:	28 60       	ori	r18, 0x08	; 8
     38e:	fc 01       	movw	r30, r24
     390:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     392:	1d 86       	std	Y+13, r1	; 0x0d
     394:	1e 86       	std	Y+14, r1	; 0x0e
     396:	56 c0       	rjmp	.+172    	; 0x444 <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     398:	80 e2       	ldi	r24, 0x20	; 32
     39a:	92 e0       	ldi	r25, 0x02	; 2
     39c:	fc 01       	movw	r30, r24
     39e:	83 81       	ldd	r24, Z+3	; 0x03
     3a0:	88 2f       	mov	r24, r24
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	81 70       	andi	r24, 0x01	; 1
     3a6:	90 70       	andi	r25, 0x00	; 0
     3a8:	00 97       	sbiw	r24, 0x00	; 0
     3aa:	b1 f3       	breq	.-20     	; 0x398 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     3ac:	2d 89       	ldd	r18, Y+21	; 0x15
     3ae:	80 e2       	ldi	r24, 0x20	; 32
     3b0:	92 e0       	ldi	r25, 0x02	; 2
     3b2:	62 2f       	mov	r22, r18
     3b4:	0e 94 96 1b 	call	0x372c	; 0x372c <ADC_ResultCh_GetWord_Signed>
     3b8:	8f 87       	std	Y+15, r24	; 0x0f
     3ba:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     3bc:	8f 85       	ldd	r24, Y+15	; 0x0f
     3be:	98 89       	ldd	r25, Y+16	; 0x10
     3c0:	cc 01       	movw	r24, r24
     3c2:	a0 e0       	ldi	r26, 0x00	; 0
     3c4:	b0 e0       	ldi	r27, 0x00	; 0
     3c6:	29 81       	ldd	r18, Y+1	; 0x01
     3c8:	3a 81       	ldd	r19, Y+2	; 0x02
     3ca:	4b 81       	ldd	r20, Y+3	; 0x03
     3cc:	5c 81       	ldd	r21, Y+4	; 0x04
     3ce:	82 0f       	add	r24, r18
     3d0:	93 1f       	adc	r25, r19
     3d2:	a4 1f       	adc	r26, r20
     3d4:	b5 1f       	adc	r27, r21
     3d6:	89 83       	std	Y+1, r24	; 0x01
     3d8:	9a 83       	std	Y+2, r25	; 0x02
     3da:	ab 83       	std	Y+3, r26	; 0x03
     3dc:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     3de:	8f 85       	ldd	r24, Y+15	; 0x0f
     3e0:	98 89       	ldd	r25, Y+16	; 0x10
     3e2:	9c 01       	movw	r18, r24
     3e4:	40 e0       	ldi	r20, 0x00	; 0
     3e6:	50 e0       	ldi	r21, 0x00	; 0
     3e8:	89 85       	ldd	r24, Y+9	; 0x09
     3ea:	9a 85       	ldd	r25, Y+10	; 0x0a
     3ec:	ab 85       	ldd	r26, Y+11	; 0x0b
     3ee:	bc 85       	ldd	r27, Y+12	; 0x0c
     3f0:	82 17       	cp	r24, r18
     3f2:	93 07       	cpc	r25, r19
     3f4:	a4 07       	cpc	r26, r20
     3f6:	b5 07       	cpc	r27, r21
     3f8:	48 f4       	brcc	.+18     	; 0x40c <CO_collectTemp+0x19a>
     3fa:	8f 85       	ldd	r24, Y+15	; 0x0f
     3fc:	98 89       	ldd	r25, Y+16	; 0x10
     3fe:	cc 01       	movw	r24, r24
     400:	a0 e0       	ldi	r26, 0x00	; 0
     402:	b0 e0       	ldi	r27, 0x00	; 0
     404:	89 87       	std	Y+9, r24	; 0x09
     406:	9a 87       	std	Y+10, r25	; 0x0a
     408:	ab 87       	std	Y+11, r26	; 0x0b
     40a:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     40c:	8f 85       	ldd	r24, Y+15	; 0x0f
     40e:	98 89       	ldd	r25, Y+16	; 0x10
     410:	9c 01       	movw	r18, r24
     412:	40 e0       	ldi	r20, 0x00	; 0
     414:	50 e0       	ldi	r21, 0x00	; 0
     416:	8d 81       	ldd	r24, Y+5	; 0x05
     418:	9e 81       	ldd	r25, Y+6	; 0x06
     41a:	af 81       	ldd	r26, Y+7	; 0x07
     41c:	b8 85       	ldd	r27, Y+8	; 0x08
     41e:	28 17       	cp	r18, r24
     420:	39 07       	cpc	r19, r25
     422:	4a 07       	cpc	r20, r26
     424:	5b 07       	cpc	r21, r27
     426:	48 f4       	brcc	.+18     	; 0x43a <CO_collectTemp+0x1c8>
     428:	8f 85       	ldd	r24, Y+15	; 0x0f
     42a:	98 89       	ldd	r25, Y+16	; 0x10
     42c:	cc 01       	movw	r24, r24
     42e:	a0 e0       	ldi	r26, 0x00	; 0
     430:	b0 e0       	ldi	r27, 0x00	; 0
     432:	8d 83       	std	Y+5, r24	; 0x05
     434:	9e 83       	std	Y+6, r25	; 0x06
     436:	af 83       	std	Y+7, r26	; 0x07
     438:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     43a:	8d 85       	ldd	r24, Y+13	; 0x0d
     43c:	9e 85       	ldd	r25, Y+14	; 0x0e
     43e:	01 96       	adiw	r24, 0x01	; 1
     440:	8d 87       	std	Y+13, r24	; 0x0d
     442:	9e 87       	std	Y+14, r25	; 0x0e
     444:	8d 85       	ldd	r24, Y+13	; 0x0d
     446:	9e 85       	ldd	r25, Y+14	; 0x0e
     448:	f4 e0       	ldi	r31, 0x04	; 4
     44a:	80 30       	cpi	r24, 0x00	; 0
     44c:	9f 07       	cpc	r25, r31
     44e:	08 f4       	brcc	.+2      	; 0x452 <CO_collectTemp+0x1e0>
     450:	a3 cf       	rjmp	.-186    	; 0x398 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	92 e0       	ldi	r25, 0x02	; 2
     456:	20 e0       	ldi	r18, 0x00	; 0
     458:	32 e0       	ldi	r19, 0x02	; 2
     45a:	f9 01       	movw	r30, r18
     45c:	21 81       	ldd	r18, Z+1	; 0x01
     45e:	27 7f       	andi	r18, 0xF7	; 247
     460:	fc 01       	movw	r30, r24
     462:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     464:	80 e0       	ldi	r24, 0x00	; 0
     466:	92 e0       	ldi	r25, 0x02	; 2
     468:	20 e0       	ldi	r18, 0x00	; 0
     46a:	32 e0       	ldi	r19, 0x02	; 2
     46c:	f9 01       	movw	r30, r18
     46e:	20 81       	ld	r18, Z
     470:	22 60       	ori	r18, 0x02	; 2
     472:	fc 01       	movw	r30, r24
     474:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     476:	80 e0       	ldi	r24, 0x00	; 0
     478:	92 e0       	ldi	r25, 0x02	; 2
     47a:	20 e0       	ldi	r18, 0x00	; 0
     47c:	32 e0       	ldi	r19, 0x02	; 2
     47e:	f9 01       	movw	r30, r18
     480:	20 81       	ld	r18, Z
     482:	2e 7f       	andi	r18, 0xFE	; 254
     484:	fc 01       	movw	r30, r24
     486:	20 83       	st	Z, r18

	ADCPower(FALSE);
     488:	80 e0       	ldi	r24, 0x00	; 0
     48a:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>

	average = sum / NUM_SAMPLES;
     48e:	89 81       	ldd	r24, Y+1	; 0x01
     490:	9a 81       	ldd	r25, Y+2	; 0x02
     492:	ab 81       	ldd	r26, Y+3	; 0x03
     494:	bc 81       	ldd	r27, Y+4	; 0x04
     496:	07 2e       	mov	r0, r23
     498:	7a e0       	ldi	r23, 0x0A	; 10
     49a:	b6 95       	lsr	r27
     49c:	a7 95       	ror	r26
     49e:	97 95       	ror	r25
     4a0:	87 95       	ror	r24
     4a2:	7a 95       	dec	r23
     4a4:	d1 f7       	brne	.-12     	; 0x49a <CO_collectTemp+0x228>
     4a6:	70 2d       	mov	r23, r0
     4a8:	89 8b       	std	Y+17, r24	; 0x11
     4aa:	9a 8b       	std	Y+18, r25	; 0x12
     4ac:	ab 8b       	std	Y+19, r26	; 0x13
     4ae:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     4b0:	89 89       	ldd	r24, Y+17	; 0x11
     4b2:	9a 89       	ldd	r25, Y+18	; 0x12
     4b4:	ab 89       	ldd	r26, Y+19	; 0x13
     4b6:	bc 89       	ldd	r27, Y+20	; 0x14
     4b8:	28 ee       	ldi	r18, 0xE8	; 232
     4ba:	33 e0       	ldi	r19, 0x03	; 3
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	50 e0       	ldi	r21, 0x00	; 0
     4c0:	bc 01       	movw	r22, r24
     4c2:	cd 01       	movw	r24, r26
     4c4:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
     4c8:	dc 01       	movw	r26, r24
     4ca:	cb 01       	movw	r24, r22
     4cc:	2f ef       	ldi	r18, 0xFF	; 255
     4ce:	3f e0       	ldi	r19, 0x0F	; 15
     4d0:	40 e0       	ldi	r20, 0x00	; 0
     4d2:	50 e0       	ldi	r21, 0x00	; 0
     4d4:	bc 01       	movw	r22, r24
     4d6:	cd 01       	movw	r24, r26
     4d8:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
     4dc:	da 01       	movw	r26, r20
     4de:	c9 01       	movw	r24, r18
     4e0:	9c 01       	movw	r18, r24
     4e2:	22 53       	subi	r18, 0x32	; 50
     4e4:	30 40       	sbci	r19, 0x00	; 0
     4e6:	8e 89       	ldd	r24, Y+22	; 0x16
     4e8:	9f 89       	ldd	r25, Y+23	; 0x17
     4ea:	fc 01       	movw	r30, r24
     4ec:	20 83       	st	Z, r18
     4ee:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     4f0:	89 85       	ldd	r24, Y+9	; 0x09
     4f2:	9a 85       	ldd	r25, Y+10	; 0x0a
     4f4:	ab 85       	ldd	r26, Y+11	; 0x0b
     4f6:	bc 85       	ldd	r27, Y+12	; 0x0c
     4f8:	28 ee       	ldi	r18, 0xE8	; 232
     4fa:	33 e0       	ldi	r19, 0x03	; 3
     4fc:	40 e0       	ldi	r20, 0x00	; 0
     4fe:	50 e0       	ldi	r21, 0x00	; 0
     500:	bc 01       	movw	r22, r24
     502:	cd 01       	movw	r24, r26
     504:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
     508:	dc 01       	movw	r26, r24
     50a:	cb 01       	movw	r24, r22
     50c:	2f ef       	ldi	r18, 0xFF	; 255
     50e:	3f e0       	ldi	r19, 0x0F	; 15
     510:	40 e0       	ldi	r20, 0x00	; 0
     512:	50 e0       	ldi	r21, 0x00	; 0
     514:	bc 01       	movw	r22, r24
     516:	cd 01       	movw	r24, r26
     518:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
     51c:	da 01       	movw	r26, r20
     51e:	c9 01       	movw	r24, r18
     520:	9c 01       	movw	r18, r24
     522:	22 53       	subi	r18, 0x32	; 50
     524:	30 40       	sbci	r19, 0x00	; 0
     526:	8a 8d       	ldd	r24, Y+26	; 0x1a
     528:	9b 8d       	ldd	r25, Y+27	; 0x1b
     52a:	fc 01       	movw	r30, r24
     52c:	20 83       	st	Z, r18
     52e:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     530:	8d 81       	ldd	r24, Y+5	; 0x05
     532:	9e 81       	ldd	r25, Y+6	; 0x06
     534:	af 81       	ldd	r26, Y+7	; 0x07
     536:	b8 85       	ldd	r27, Y+8	; 0x08
     538:	28 ee       	ldi	r18, 0xE8	; 232
     53a:	33 e0       	ldi	r19, 0x03	; 3
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	50 e0       	ldi	r21, 0x00	; 0
     540:	bc 01       	movw	r22, r24
     542:	cd 01       	movw	r24, r26
     544:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
     548:	dc 01       	movw	r26, r24
     54a:	cb 01       	movw	r24, r22
     54c:	2f ef       	ldi	r18, 0xFF	; 255
     54e:	3f e0       	ldi	r19, 0x0F	; 15
     550:	40 e0       	ldi	r20, 0x00	; 0
     552:	50 e0       	ldi	r21, 0x00	; 0
     554:	bc 01       	movw	r22, r24
     556:	cd 01       	movw	r24, r26
     558:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
     55c:	da 01       	movw	r26, r20
     55e:	c9 01       	movw	r24, r18
     560:	9c 01       	movw	r18, r24
     562:	22 53       	subi	r18, 0x32	; 50
     564:	30 40       	sbci	r19, 0x00	; 0
     566:	88 8d       	ldd	r24, Y+24	; 0x18
     568:	99 8d       	ldd	r25, Y+25	; 0x19
     56a:	fc 01       	movw	r30, r24
     56c:	20 83       	st	Z, r18
     56e:	31 83       	std	Z+1, r19	; 0x01
}
     570:	6b 96       	adiw	r28, 0x1b	; 27
     572:	cd bf       	out	0x3d, r28	; 61
     574:	de bf       	out	0x3e, r29	; 62
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	08 95       	ret

0000057c <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     57c:	0f 93       	push	r16
     57e:	1f 93       	push	r17
     580:	cf 93       	push	r28
     582:	df 93       	push	r29
     584:	cd b7       	in	r28, 0x3d	; 61
     586:	de b7       	in	r29, 0x3e	; 62
     588:	a9 97       	sbiw	r28, 0x29	; 41
     58a:	cd bf       	out	0x3d, r28	; 61
     58c:	de bf       	out	0x3e, r29	; 62
     58e:	8c a3       	lds	r24, 0x5c
     590:	9d a3       	lds	r25, 0x5d
     592:	6e a3       	lds	r22, 0x5e
     594:	7f a3       	lds	r23, 0x5f
     596:	48 a7       	lds	r20, 0x78
     598:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     59a:	19 82       	std	Y+1, r1	; 0x01
     59c:	1a 82       	std	Y+2, r1	; 0x02
     59e:	1b 82       	std	Y+3, r1	; 0x03
     5a0:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     5a2:	80 e0       	ldi	r24, 0x00	; 0
     5a4:	90 e1       	ldi	r25, 0x10	; 16
     5a6:	a0 e0       	ldi	r26, 0x00	; 0
     5a8:	b0 e0       	ldi	r27, 0x00	; 0
     5aa:	8d 83       	std	Y+5, r24	; 0x05
     5ac:	9e 83       	std	Y+6, r25	; 0x06
     5ae:	af 83       	std	Y+7, r26	; 0x07
     5b0:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     5b2:	19 86       	std	Y+9, r1	; 0x09
     5b4:	1a 86       	std	Y+10, r1	; 0x0a
     5b6:	1b 86       	std	Y+11, r1	; 0x0b
     5b8:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     5ba:	81 e0       	ldi	r24, 0x01	; 1
     5bc:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     5c0:	84 e0       	ldi	r24, 0x04	; 4
     5c2:	60 e0       	ldi	r22, 0x00	; 0
     5c4:	0e 94 cb 33 	call	0x6796	; 0x6796 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     5c8:	84 e0       	ldi	r24, 0x04	; 4
     5ca:	60 e0       	ldi	r22, 0x00	; 0
     5cc:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	a8 ec       	ldi	r26, 0xC8	; 200
     5d6:	b2 e4       	ldi	r27, 0x42	; 66
     5d8:	8d 8b       	std	Y+21, r24	; 0x15
     5da:	9e 8b       	std	Y+22, r25	; 0x16
     5dc:	af 8b       	std	Y+23, r26	; 0x17
     5de:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     5e0:	6d 89       	ldd	r22, Y+21	; 0x15
     5e2:	7e 89       	ldd	r23, Y+22	; 0x16
     5e4:	8f 89       	ldd	r24, Y+23	; 0x17
     5e6:	98 8d       	ldd	r25, Y+24	; 0x18
     5e8:	20 e0       	ldi	r18, 0x00	; 0
     5ea:	30 e0       	ldi	r19, 0x00	; 0
     5ec:	4a ef       	ldi	r20, 0xFA	; 250
     5ee:	55 e4       	ldi	r21, 0x45	; 69
     5f0:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
     5f4:	dc 01       	movw	r26, r24
     5f6:	cb 01       	movw	r24, r22
     5f8:	89 8f       	std	Y+25, r24	; 0x19
     5fa:	9a 8f       	std	Y+26, r25	; 0x1a
     5fc:	ab 8f       	std	Y+27, r26	; 0x1b
     5fe:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     600:	11 e0       	ldi	r17, 0x01	; 1
     602:	69 8d       	ldd	r22, Y+25	; 0x19
     604:	7a 8d       	ldd	r23, Y+26	; 0x1a
     606:	8b 8d       	ldd	r24, Y+27	; 0x1b
     608:	9c 8d       	ldd	r25, Y+28	; 0x1c
     60a:	20 e0       	ldi	r18, 0x00	; 0
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	40 e8       	ldi	r20, 0x80	; 128
     610:	5f e3       	ldi	r21, 0x3F	; 63
     612:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
     616:	88 23       	and	r24, r24
     618:	0c f0       	brlt	.+2      	; 0x61c <CO_collectBatt+0xa0>
     61a:	10 e0       	ldi	r17, 0x00	; 0
     61c:	11 23       	and	r17, r17
     61e:	29 f0       	breq	.+10     	; 0x62a <CO_collectBatt+0xae>
		__ticks = 1;
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	8d 8f       	std	Y+29, r24	; 0x1d
     626:	9e 8f       	std	Y+30, r25	; 0x1e
     628:	46 c0       	rjmp	.+140    	; 0x6b6 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     62a:	11 e0       	ldi	r17, 0x01	; 1
     62c:	69 8d       	ldd	r22, Y+25	; 0x19
     62e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     630:	8b 8d       	ldd	r24, Y+27	; 0x1b
     632:	9c 8d       	ldd	r25, Y+28	; 0x1c
     634:	20 e0       	ldi	r18, 0x00	; 0
     636:	3f ef       	ldi	r19, 0xFF	; 255
     638:	4f e7       	ldi	r20, 0x7F	; 127
     63a:	57 e4       	ldi	r21, 0x47	; 71
     63c:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
     640:	18 16       	cp	r1, r24
     642:	0c f0       	brlt	.+2      	; 0x646 <CO_collectBatt+0xca>
     644:	10 e0       	ldi	r17, 0x00	; 0
     646:	11 23       	and	r17, r17
     648:	61 f1       	breq	.+88     	; 0x6a2 <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     64a:	6d 89       	ldd	r22, Y+21	; 0x15
     64c:	7e 89       	ldd	r23, Y+22	; 0x16
     64e:	8f 89       	ldd	r24, Y+23	; 0x17
     650:	98 8d       	ldd	r25, Y+24	; 0x18
     652:	20 e0       	ldi	r18, 0x00	; 0
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	40 e2       	ldi	r20, 0x20	; 32
     658:	51 e4       	ldi	r21, 0x41	; 65
     65a:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
     65e:	dc 01       	movw	r26, r24
     660:	cb 01       	movw	r24, r22
     662:	bc 01       	movw	r22, r24
     664:	cd 01       	movw	r24, r26
     666:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
     66a:	dc 01       	movw	r26, r24
     66c:	cb 01       	movw	r24, r22
     66e:	8d 8f       	std	Y+29, r24	; 0x1d
     670:	9e 8f       	std	Y+30, r25	; 0x1e
     672:	12 c0       	rjmp	.+36     	; 0x698 <CO_collectBatt+0x11c>
     674:	80 e2       	ldi	r24, 0x20	; 32
     676:	93 e0       	ldi	r25, 0x03	; 3
     678:	8f 8f       	std	Y+31, r24	; 0x1f
     67a:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     67c:	8f 8d       	ldd	r24, Y+31	; 0x1f
     67e:	98 a1       	lds	r25, 0x48
     680:	8c 01       	movw	r16, r24
     682:	c8 01       	movw	r24, r16
     684:	01 97       	sbiw	r24, 0x01	; 1
     686:	f1 f7       	brne	.-4      	; 0x684 <CO_collectBatt+0x108>
     688:	8c 01       	movw	r16, r24
     68a:	0f 8f       	std	Y+31, r16	; 0x1f
     68c:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     68e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     690:	9e 8d       	ldd	r25, Y+30	; 0x1e
     692:	01 97       	sbiw	r24, 0x01	; 1
     694:	8d 8f       	std	Y+29, r24	; 0x1d
     696:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     698:	8d 8d       	ldd	r24, Y+29	; 0x1d
     69a:	9e 8d       	ldd	r25, Y+30	; 0x1e
     69c:	00 97       	sbiw	r24, 0x00	; 0
     69e:	51 f7       	brne	.-44     	; 0x674 <CO_collectBatt+0xf8>
     6a0:	17 c0       	rjmp	.+46     	; 0x6d0 <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     6a2:	69 8d       	ldd	r22, Y+25	; 0x19
     6a4:	7a 8d       	ldd	r23, Y+26	; 0x1a
     6a6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     6a8:	9c 8d       	ldd	r25, Y+28	; 0x1c
     6aa:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
     6ae:	dc 01       	movw	r26, r24
     6b0:	cb 01       	movw	r24, r22
     6b2:	8d 8f       	std	Y+29, r24	; 0x1d
     6b4:	9e 8f       	std	Y+30, r25	; 0x1e
     6b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     6b8:	9e 8d       	ldd	r25, Y+30	; 0x1e
     6ba:	89 a3       	lds	r24, 0x59
     6bc:	9a a3       	lds	r25, 0x5a
     6be:	89 a1       	lds	r24, 0x49
     6c0:	9a a1       	lds	r25, 0x4a
     6c2:	8c 01       	movw	r16, r24
     6c4:	f8 01       	movw	r30, r16
     6c6:	31 97       	sbiw	r30, 0x01	; 1
     6c8:	f1 f7       	brne	.-4      	; 0x6c6 <CO_collectBatt+0x14a>
     6ca:	8f 01       	movw	r16, r30
     6cc:	09 a3       	lds	r16, 0x59
     6ce:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     6d0:	80 e4       	ldi	r24, 0x40	; 64
     6d2:	92 e0       	ldi	r25, 0x02	; 2
     6d4:	0e 94 3d 1b 	call	0x367a	; 0x367a <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     6d8:	80 e4       	ldi	r24, 0x40	; 64
     6da:	92 e0       	ldi	r25, 0x02	; 2
     6dc:	20 e4       	ldi	r18, 0x40	; 64
     6de:	32 e0       	ldi	r19, 0x02	; 2
     6e0:	f9 01       	movw	r30, r18
     6e2:	21 81       	ldd	r18, Z+1	; 0x01
     6e4:	29 7e       	andi	r18, 0xE9	; 233
     6e6:	fc 01       	movw	r30, r24
     6e8:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     6ea:	80 e4       	ldi	r24, 0x40	; 64
     6ec:	92 e0       	ldi	r25, 0x02	; 2
     6ee:	20 e4       	ldi	r18, 0x40	; 64
     6f0:	32 e0       	ldi	r19, 0x02	; 2
     6f2:	f9 01       	movw	r30, r18
     6f4:	24 81       	ldd	r18, Z+4	; 0x04
     6f6:	28 7f       	andi	r18, 0xF8	; 248
     6f8:	23 60       	ori	r18, 0x03	; 3
     6fa:	fc 01       	movw	r30, r24
     6fc:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     6fe:	80 e4       	ldi	r24, 0x40	; 64
     700:	92 e0       	ldi	r25, 0x02	; 2
     702:	20 e4       	ldi	r18, 0x40	; 64
     704:	32 e0       	ldi	r19, 0x02	; 2
     706:	f9 01       	movw	r30, r18
     708:	22 81       	ldd	r18, Z+2	; 0x02
     70a:	2f 7c       	andi	r18, 0xCF	; 207
     70c:	fc 01       	movw	r30, r24
     70e:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     710:	80 e6       	ldi	r24, 0x60	; 96
     712:	92 e0       	ldi	r25, 0x02	; 2
     714:	20 e6       	ldi	r18, 0x60	; 96
     716:	32 e0       	ldi	r19, 0x02	; 2
     718:	f9 01       	movw	r30, r18
     71a:	20 81       	ld	r18, Z
     71c:	20 7e       	andi	r18, 0xE0	; 224
     71e:	21 60       	ori	r18, 0x01	; 1
     720:	fc 01       	movw	r30, r24
     722:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     724:	80 e6       	ldi	r24, 0x60	; 96
     726:	92 e0       	ldi	r25, 0x02	; 2
     728:	29 e0       	ldi	r18, 0x09	; 9
     72a:	fc 01       	movw	r30, r24
     72c:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     72e:	80 e4       	ldi	r24, 0x40	; 64
     730:	92 e0       	ldi	r25, 0x02	; 2
     732:	20 e4       	ldi	r18, 0x40	; 64
     734:	32 e0       	ldi	r19, 0x02	; 2
     736:	f9 01       	movw	r30, r18
     738:	20 81       	ld	r18, Z
     73a:	21 60       	ori	r18, 0x01	; 1
     73c:	fc 01       	movw	r30, r24
     73e:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     740:	80 e4       	ldi	r24, 0x40	; 64
     742:	92 e0       	ldi	r25, 0x02	; 2
     744:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     748:	80 e4       	ldi	r24, 0x40	; 64
     74a:	92 e0       	ldi	r25, 0x02	; 2
     74c:	60 e6       	ldi	r22, 0x60	; 96
     74e:	72 e0       	ldi	r23, 0x02	; 2
     750:	40 e0       	ldi	r20, 0x00	; 0
     752:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ADC_Offset_Get_Unsigned>
     756:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     758:	80 e4       	ldi	r24, 0x40	; 64
     75a:	92 e0       	ldi	r25, 0x02	; 2
     75c:	20 e4       	ldi	r18, 0x40	; 64
     75e:	32 e0       	ldi	r19, 0x02	; 2
     760:	f9 01       	movw	r30, r18
     762:	20 81       	ld	r18, Z
     764:	2e 7f       	andi	r18, 0xFE	; 254
     766:	fc 01       	movw	r30, r24
     768:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     76a:	80 e6       	ldi	r24, 0x60	; 96
     76c:	92 e0       	ldi	r25, 0x02	; 2
     76e:	fc 01       	movw	r30, r24
     770:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     772:	80 e4       	ldi	r24, 0x40	; 64
     774:	92 e0       	ldi	r25, 0x02	; 2
     776:	20 e4       	ldi	r18, 0x40	; 64
     778:	32 e0       	ldi	r19, 0x02	; 2
     77a:	f9 01       	movw	r30, r18
     77c:	23 81       	ldd	r18, Z+3	; 0x03
     77e:	2f 73       	andi	r18, 0x3F	; 63
     780:	fc 01       	movw	r30, r24
     782:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     784:	80 e4       	ldi	r24, 0x40	; 64
     786:	92 e0       	ldi	r25, 0x02	; 2
     788:	20 e4       	ldi	r18, 0x40	; 64
     78a:	32 e0       	ldi	r19, 0x02	; 2
     78c:	f9 01       	movw	r30, r18
     78e:	20 81       	ld	r18, Z
     790:	21 60       	ori	r18, 0x01	; 1
     792:	fc 01       	movw	r30, r24
     794:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     796:	80 e4       	ldi	r24, 0x40	; 64
     798:	92 e0       	ldi	r25, 0x02	; 2
     79a:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     79e:	80 e4       	ldi	r24, 0x40	; 64
     7a0:	92 e0       	ldi	r25, 0x02	; 2
     7a2:	20 e4       	ldi	r18, 0x40	; 64
     7a4:	32 e0       	ldi	r19, 0x02	; 2
     7a6:	f9 01       	movw	r30, r18
     7a8:	21 81       	ldd	r18, Z+1	; 0x01
     7aa:	28 60       	ori	r18, 0x08	; 8
     7ac:	fc 01       	movw	r30, r24
     7ae:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     7b0:	1d 86       	std	Y+13, r1	; 0x0d
     7b2:	1e 86       	std	Y+14, r1	; 0x0e
     7b4:	56 c0       	rjmp	.+172    	; 0x862 <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     7b6:	80 e6       	ldi	r24, 0x60	; 96
     7b8:	92 e0       	ldi	r25, 0x02	; 2
     7ba:	fc 01       	movw	r30, r24
     7bc:	83 81       	ldd	r24, Z+3	; 0x03
     7be:	88 2f       	mov	r24, r24
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	81 70       	andi	r24, 0x01	; 1
     7c4:	90 70       	andi	r25, 0x00	; 0
     7c6:	00 97       	sbiw	r24, 0x00	; 0
     7c8:	b1 f3       	breq	.-20     	; 0x7b6 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     7ca:	2b a1       	lds	r18, 0x4b
     7cc:	80 e6       	ldi	r24, 0x60	; 96
     7ce:	92 e0       	ldi	r25, 0x02	; 2
     7d0:	62 2f       	mov	r22, r18
     7d2:	0e 94 96 1b 	call	0x372c	; 0x372c <ADC_ResultCh_GetWord_Signed>
     7d6:	8f 87       	std	Y+15, r24	; 0x0f
     7d8:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     7da:	8f 85       	ldd	r24, Y+15	; 0x0f
     7dc:	98 89       	ldd	r25, Y+16	; 0x10
     7de:	cc 01       	movw	r24, r24
     7e0:	a0 e0       	ldi	r26, 0x00	; 0
     7e2:	b0 e0       	ldi	r27, 0x00	; 0
     7e4:	29 81       	ldd	r18, Y+1	; 0x01
     7e6:	3a 81       	ldd	r19, Y+2	; 0x02
     7e8:	4b 81       	ldd	r20, Y+3	; 0x03
     7ea:	5c 81       	ldd	r21, Y+4	; 0x04
     7ec:	82 0f       	add	r24, r18
     7ee:	93 1f       	adc	r25, r19
     7f0:	a4 1f       	adc	r26, r20
     7f2:	b5 1f       	adc	r27, r21
     7f4:	89 83       	std	Y+1, r24	; 0x01
     7f6:	9a 83       	std	Y+2, r25	; 0x02
     7f8:	ab 83       	std	Y+3, r26	; 0x03
     7fa:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     7fc:	8f 85       	ldd	r24, Y+15	; 0x0f
     7fe:	98 89       	ldd	r25, Y+16	; 0x10
     800:	9c 01       	movw	r18, r24
     802:	40 e0       	ldi	r20, 0x00	; 0
     804:	50 e0       	ldi	r21, 0x00	; 0
     806:	89 85       	ldd	r24, Y+9	; 0x09
     808:	9a 85       	ldd	r25, Y+10	; 0x0a
     80a:	ab 85       	ldd	r26, Y+11	; 0x0b
     80c:	bc 85       	ldd	r27, Y+12	; 0x0c
     80e:	82 17       	cp	r24, r18
     810:	93 07       	cpc	r25, r19
     812:	a4 07       	cpc	r26, r20
     814:	b5 07       	cpc	r27, r21
     816:	48 f4       	brcc	.+18     	; 0x82a <CO_collectBatt+0x2ae>
     818:	8f 85       	ldd	r24, Y+15	; 0x0f
     81a:	98 89       	ldd	r25, Y+16	; 0x10
     81c:	cc 01       	movw	r24, r24
     81e:	a0 e0       	ldi	r26, 0x00	; 0
     820:	b0 e0       	ldi	r27, 0x00	; 0
     822:	89 87       	std	Y+9, r24	; 0x09
     824:	9a 87       	std	Y+10, r25	; 0x0a
     826:	ab 87       	std	Y+11, r26	; 0x0b
     828:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     82a:	8f 85       	ldd	r24, Y+15	; 0x0f
     82c:	98 89       	ldd	r25, Y+16	; 0x10
     82e:	9c 01       	movw	r18, r24
     830:	40 e0       	ldi	r20, 0x00	; 0
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	8d 81       	ldd	r24, Y+5	; 0x05
     836:	9e 81       	ldd	r25, Y+6	; 0x06
     838:	af 81       	ldd	r26, Y+7	; 0x07
     83a:	b8 85       	ldd	r27, Y+8	; 0x08
     83c:	28 17       	cp	r18, r24
     83e:	39 07       	cpc	r19, r25
     840:	4a 07       	cpc	r20, r26
     842:	5b 07       	cpc	r21, r27
     844:	48 f4       	brcc	.+18     	; 0x858 <CO_collectBatt+0x2dc>
     846:	8f 85       	ldd	r24, Y+15	; 0x0f
     848:	98 89       	ldd	r25, Y+16	; 0x10
     84a:	cc 01       	movw	r24, r24
     84c:	a0 e0       	ldi	r26, 0x00	; 0
     84e:	b0 e0       	ldi	r27, 0x00	; 0
     850:	8d 83       	std	Y+5, r24	; 0x05
     852:	9e 83       	std	Y+6, r25	; 0x06
     854:	af 83       	std	Y+7, r26	; 0x07
     856:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     858:	8d 85       	ldd	r24, Y+13	; 0x0d
     85a:	9e 85       	ldd	r25, Y+14	; 0x0e
     85c:	01 96       	adiw	r24, 0x01	; 1
     85e:	8d 87       	std	Y+13, r24	; 0x0d
     860:	9e 87       	std	Y+14, r25	; 0x0e
     862:	8d 85       	ldd	r24, Y+13	; 0x0d
     864:	9e 85       	ldd	r25, Y+14	; 0x0e
     866:	f4 e0       	ldi	r31, 0x04	; 4
     868:	80 30       	cpi	r24, 0x00	; 0
     86a:	9f 07       	cpc	r25, r31
     86c:	08 f4       	brcc	.+2      	; 0x870 <CO_collectBatt+0x2f4>
     86e:	a3 cf       	rjmp	.-186    	; 0x7b6 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     870:	80 e4       	ldi	r24, 0x40	; 64
     872:	92 e0       	ldi	r25, 0x02	; 2
     874:	20 e4       	ldi	r18, 0x40	; 64
     876:	32 e0       	ldi	r19, 0x02	; 2
     878:	f9 01       	movw	r30, r18
     87a:	21 81       	ldd	r18, Z+1	; 0x01
     87c:	27 7f       	andi	r18, 0xF7	; 247
     87e:	fc 01       	movw	r30, r24
     880:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     882:	80 e4       	ldi	r24, 0x40	; 64
     884:	92 e0       	ldi	r25, 0x02	; 2
     886:	20 e4       	ldi	r18, 0x40	; 64
     888:	32 e0       	ldi	r19, 0x02	; 2
     88a:	f9 01       	movw	r30, r18
     88c:	20 81       	ld	r18, Z
     88e:	2e 7f       	andi	r18, 0xFE	; 254
     890:	fc 01       	movw	r30, r24
     892:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     894:	89 81       	ldd	r24, Y+1	; 0x01
     896:	9a 81       	ldd	r25, Y+2	; 0x02
     898:	ab 81       	ldd	r26, Y+3	; 0x03
     89a:	bc 81       	ldd	r27, Y+4	; 0x04
     89c:	07 2e       	mov	r0, r23
     89e:	7a e0       	ldi	r23, 0x0A	; 10
     8a0:	b6 95       	lsr	r27
     8a2:	a7 95       	ror	r26
     8a4:	97 95       	ror	r25
     8a6:	87 95       	ror	r24
     8a8:	7a 95       	dec	r23
     8aa:	d1 f7       	brne	.-12     	; 0x8a0 <CO_collectBatt+0x324>
     8ac:	70 2d       	mov	r23, r0
     8ae:	89 8b       	std	Y+17, r24	; 0x11
     8b0:	9a 8b       	std	Y+18, r25	; 0x12
     8b2:	ab 8b       	std	Y+19, r26	; 0x13
     8b4:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     8b6:	84 e0       	ldi	r24, 0x04	; 4
     8b8:	60 e0       	ldi	r22, 0x00	; 0
     8ba:	0e 94 2f 34 	call	0x685e	; 0x685e <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     8c4:	89 89       	ldd	r24, Y+17	; 0x11
     8c6:	9a 89       	ldd	r25, Y+18	; 0x12
     8c8:	ab 89       	ldd	r26, Y+19	; 0x13
     8ca:	bc 89       	ldd	r27, Y+20	; 0x14
     8cc:	28 ee       	ldi	r18, 0xE8	; 232
     8ce:	33 e0       	ldi	r19, 0x03	; 3
     8d0:	40 e0       	ldi	r20, 0x00	; 0
     8d2:	50 e0       	ldi	r21, 0x00	; 0
     8d4:	bc 01       	movw	r22, r24
     8d6:	cd 01       	movw	r24, r26
     8d8:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
     8dc:	dc 01       	movw	r26, r24
     8de:	cb 01       	movw	r24, r22
     8e0:	2f ef       	ldi	r18, 0xFF	; 255
     8e2:	3f e0       	ldi	r19, 0x0F	; 15
     8e4:	40 e0       	ldi	r20, 0x00	; 0
     8e6:	50 e0       	ldi	r21, 0x00	; 0
     8e8:	bc 01       	movw	r22, r24
     8ea:	cd 01       	movw	r24, r26
     8ec:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
     8f0:	da 01       	movw	r26, r20
     8f2:	c9 01       	movw	r24, r18
     8f4:	9c 01       	movw	r18, r24
     8f6:	22 53       	subi	r18, 0x32	; 50
     8f8:	30 40       	sbci	r19, 0x00	; 0
     8fa:	8c a1       	lds	r24, 0x4c
     8fc:	9d a1       	lds	r25, 0x4d
     8fe:	fc 01       	movw	r30, r24
     900:	20 83       	st	Z, r18
     902:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     904:	89 85       	ldd	r24, Y+9	; 0x09
     906:	9a 85       	ldd	r25, Y+10	; 0x0a
     908:	ab 85       	ldd	r26, Y+11	; 0x0b
     90a:	bc 85       	ldd	r27, Y+12	; 0x0c
     90c:	28 ee       	ldi	r18, 0xE8	; 232
     90e:	33 e0       	ldi	r19, 0x03	; 3
     910:	40 e0       	ldi	r20, 0x00	; 0
     912:	50 e0       	ldi	r21, 0x00	; 0
     914:	bc 01       	movw	r22, r24
     916:	cd 01       	movw	r24, r26
     918:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
     91c:	dc 01       	movw	r26, r24
     91e:	cb 01       	movw	r24, r22
     920:	2f ef       	ldi	r18, 0xFF	; 255
     922:	3f e0       	ldi	r19, 0x0F	; 15
     924:	40 e0       	ldi	r20, 0x00	; 0
     926:	50 e0       	ldi	r21, 0x00	; 0
     928:	bc 01       	movw	r22, r24
     92a:	cd 01       	movw	r24, r26
     92c:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
     930:	da 01       	movw	r26, r20
     932:	c9 01       	movw	r24, r18
     934:	9c 01       	movw	r18, r24
     936:	22 53       	subi	r18, 0x32	; 50
     938:	30 40       	sbci	r19, 0x00	; 0
     93a:	88 a5       	lds	r24, 0x68
     93c:	99 a5       	lds	r25, 0x69
     93e:	fc 01       	movw	r30, r24
     940:	20 83       	st	Z, r18
     942:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     944:	8d 81       	ldd	r24, Y+5	; 0x05
     946:	9e 81       	ldd	r25, Y+6	; 0x06
     948:	af 81       	ldd	r26, Y+7	; 0x07
     94a:	b8 85       	ldd	r27, Y+8	; 0x08
     94c:	28 ee       	ldi	r18, 0xE8	; 232
     94e:	33 e0       	ldi	r19, 0x03	; 3
     950:	40 e0       	ldi	r20, 0x00	; 0
     952:	50 e0       	ldi	r21, 0x00	; 0
     954:	bc 01       	movw	r22, r24
     956:	cd 01       	movw	r24, r26
     958:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
     95c:	dc 01       	movw	r26, r24
     95e:	cb 01       	movw	r24, r22
     960:	2f ef       	ldi	r18, 0xFF	; 255
     962:	3f e0       	ldi	r19, 0x0F	; 15
     964:	40 e0       	ldi	r20, 0x00	; 0
     966:	50 e0       	ldi	r21, 0x00	; 0
     968:	bc 01       	movw	r22, r24
     96a:	cd 01       	movw	r24, r26
     96c:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
     970:	da 01       	movw	r26, r20
     972:	c9 01       	movw	r24, r18
     974:	9c 01       	movw	r18, r24
     976:	22 53       	subi	r18, 0x32	; 50
     978:	30 40       	sbci	r19, 0x00	; 0
     97a:	8e a1       	lds	r24, 0x4e
     97c:	9f a1       	lds	r25, 0x4f
     97e:	fc 01       	movw	r30, r24
     980:	20 83       	st	Z, r18
     982:	31 83       	std	Z+1, r19	; 0x01
}
     984:	a9 96       	adiw	r28, 0x29	; 41
     986:	cd bf       	out	0x3d, r28	; 61
     988:	de bf       	out	0x3e, r29	; 62
     98a:	df 91       	pop	r29
     98c:	cf 91       	pop	r28
     98e:	1f 91       	pop	r17
     990:	0f 91       	pop	r16
     992:	08 95       	ret

00000994 <ADCPower>:

void ADCPower(uint8_t on) {
     994:	0f 93       	push	r16
     996:	1f 93       	push	r17
     998:	cf 93       	push	r28
     99a:	df 93       	push	r29
     99c:	cd b7       	in	r28, 0x3d	; 61
     99e:	de b7       	in	r29, 0x3e	; 62
     9a0:	2f 97       	sbiw	r28, 0x0f	; 15
     9a2:	cd bf       	out	0x3d, r28	; 61
     9a4:	de bf       	out	0x3e, r29	; 62
     9a6:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     9a8:	8f 85       	ldd	r24, Y+15	; 0x0f
     9aa:	88 23       	and	r24, r24
     9ac:	09 f4       	brne	.+2      	; 0x9b0 <ADCPower+0x1c>
     9ae:	ce c0       	rjmp	.+412    	; 0xb4c <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     9b0:	80 e0       	ldi	r24, 0x00	; 0
     9b2:	96 e0       	ldi	r25, 0x06	; 6
     9b4:	2e ed       	ldi	r18, 0xDE	; 222
     9b6:	fc 01       	movw	r30, r24
     9b8:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     9ba:	80 e2       	ldi	r24, 0x20	; 32
     9bc:	96 e0       	ldi	r25, 0x06	; 6
     9be:	2e e0       	ldi	r18, 0x0E	; 14
     9c0:	fc 01       	movw	r30, r24
     9c2:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     9c4:	80 e4       	ldi	r24, 0x40	; 64
     9c6:	96 e0       	ldi	r25, 0x06	; 6
     9c8:	23 e0       	ldi	r18, 0x03	; 3
     9ca:	fc 01       	movw	r30, r24
     9cc:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     9ce:	80 e8       	ldi	r24, 0x80	; 128
     9d0:	96 e0       	ldi	r25, 0x06	; 6
     9d2:	20 e1       	ldi	r18, 0x10	; 16
     9d4:	fc 01       	movw	r30, r24
     9d6:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     9d8:	80 ea       	ldi	r24, 0xA0	; 160
     9da:	96 e0       	ldi	r25, 0x06	; 6
     9dc:	2e e0       	ldi	r18, 0x0E	; 14
     9de:	fc 01       	movw	r30, r24
     9e0:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     9e2:	80 e0       	ldi	r24, 0x00	; 0
     9e4:	96 e0       	ldi	r25, 0x06	; 6
     9e6:	2e e9       	ldi	r18, 0x9E	; 158
     9e8:	fc 01       	movw	r30, r24
     9ea:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     9ec:	80 e2       	ldi	r24, 0x20	; 32
     9ee:	96 e0       	ldi	r25, 0x06	; 6
     9f0:	28 e0       	ldi	r18, 0x08	; 8
     9f2:	fc 01       	movw	r30, r24
     9f4:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     9f6:	80 e4       	ldi	r24, 0x40	; 64
     9f8:	96 e0       	ldi	r25, 0x06	; 6
     9fa:	23 e0       	ldi	r18, 0x03	; 3
     9fc:	fc 01       	movw	r30, r24
     9fe:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     a00:	80 e8       	ldi	r24, 0x80	; 128
     a02:	96 e0       	ldi	r25, 0x06	; 6
     a04:	20 e1       	ldi	r18, 0x10	; 16
     a06:	fc 01       	movw	r30, r24
     a08:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     a0a:	80 ea       	ldi	r24, 0xA0	; 160
     a0c:	96 e0       	ldi	r25, 0x06	; 6
     a0e:	2e e0       	ldi	r18, 0x0E	; 14
     a10:	fc 01       	movw	r30, r24
     a12:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     a14:	10 92 5b 50 	sts	0x505B, r1
     a18:	80 e0       	ldi	r24, 0x00	; 0
     a1a:	90 e0       	ldi	r25, 0x00	; 0
     a1c:	a8 ec       	ldi	r26, 0xC8	; 200
     a1e:	b2 e4       	ldi	r27, 0x42	; 66
     a20:	89 83       	std	Y+1, r24	; 0x01
     a22:	9a 83       	std	Y+2, r25	; 0x02
     a24:	ab 83       	std	Y+3, r26	; 0x03
     a26:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     a28:	69 81       	ldd	r22, Y+1	; 0x01
     a2a:	7a 81       	ldd	r23, Y+2	; 0x02
     a2c:	8b 81       	ldd	r24, Y+3	; 0x03
     a2e:	9c 81       	ldd	r25, Y+4	; 0x04
     a30:	20 e0       	ldi	r18, 0x00	; 0
     a32:	30 e0       	ldi	r19, 0x00	; 0
     a34:	4a ef       	ldi	r20, 0xFA	; 250
     a36:	55 e4       	ldi	r21, 0x45	; 69
     a38:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
     a3c:	dc 01       	movw	r26, r24
     a3e:	cb 01       	movw	r24, r22
     a40:	8d 83       	std	Y+5, r24	; 0x05
     a42:	9e 83       	std	Y+6, r25	; 0x06
     a44:	af 83       	std	Y+7, r26	; 0x07
     a46:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     a48:	11 e0       	ldi	r17, 0x01	; 1
     a4a:	6d 81       	ldd	r22, Y+5	; 0x05
     a4c:	7e 81       	ldd	r23, Y+6	; 0x06
     a4e:	8f 81       	ldd	r24, Y+7	; 0x07
     a50:	98 85       	ldd	r25, Y+8	; 0x08
     a52:	20 e0       	ldi	r18, 0x00	; 0
     a54:	30 e0       	ldi	r19, 0x00	; 0
     a56:	40 e8       	ldi	r20, 0x80	; 128
     a58:	5f e3       	ldi	r21, 0x3F	; 63
     a5a:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
     a5e:	88 23       	and	r24, r24
     a60:	0c f0       	brlt	.+2      	; 0xa64 <ADCPower+0xd0>
     a62:	10 e0       	ldi	r17, 0x00	; 0
     a64:	11 23       	and	r17, r17
     a66:	29 f0       	breq	.+10     	; 0xa72 <ADCPower+0xde>
		__ticks = 1;
     a68:	81 e0       	ldi	r24, 0x01	; 1
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	89 87       	std	Y+9, r24	; 0x09
     a6e:	9a 87       	std	Y+10, r25	; 0x0a
     a70:	46 c0       	rjmp	.+140    	; 0xafe <ADCPower+0x16a>
	else if (__tmp > 65535)
     a72:	11 e0       	ldi	r17, 0x01	; 1
     a74:	6d 81       	ldd	r22, Y+5	; 0x05
     a76:	7e 81       	ldd	r23, Y+6	; 0x06
     a78:	8f 81       	ldd	r24, Y+7	; 0x07
     a7a:	98 85       	ldd	r25, Y+8	; 0x08
     a7c:	20 e0       	ldi	r18, 0x00	; 0
     a7e:	3f ef       	ldi	r19, 0xFF	; 255
     a80:	4f e7       	ldi	r20, 0x7F	; 127
     a82:	57 e4       	ldi	r21, 0x47	; 71
     a84:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
     a88:	18 16       	cp	r1, r24
     a8a:	0c f0       	brlt	.+2      	; 0xa8e <ADCPower+0xfa>
     a8c:	10 e0       	ldi	r17, 0x00	; 0
     a8e:	11 23       	and	r17, r17
     a90:	61 f1       	breq	.+88     	; 0xaea <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     a92:	69 81       	ldd	r22, Y+1	; 0x01
     a94:	7a 81       	ldd	r23, Y+2	; 0x02
     a96:	8b 81       	ldd	r24, Y+3	; 0x03
     a98:	9c 81       	ldd	r25, Y+4	; 0x04
     a9a:	20 e0       	ldi	r18, 0x00	; 0
     a9c:	30 e0       	ldi	r19, 0x00	; 0
     a9e:	40 e2       	ldi	r20, 0x20	; 32
     aa0:	51 e4       	ldi	r21, 0x41	; 65
     aa2:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
     aa6:	dc 01       	movw	r26, r24
     aa8:	cb 01       	movw	r24, r22
     aaa:	bc 01       	movw	r22, r24
     aac:	cd 01       	movw	r24, r26
     aae:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
     ab2:	dc 01       	movw	r26, r24
     ab4:	cb 01       	movw	r24, r22
     ab6:	89 87       	std	Y+9, r24	; 0x09
     ab8:	9a 87       	std	Y+10, r25	; 0x0a
     aba:	12 c0       	rjmp	.+36     	; 0xae0 <ADCPower+0x14c>
     abc:	80 e2       	ldi	r24, 0x20	; 32
     abe:	93 e0       	ldi	r25, 0x03	; 3
     ac0:	8b 87       	std	Y+11, r24	; 0x0b
     ac2:	9c 87       	std	Y+12, r25	; 0x0c
     ac4:	8b 85       	ldd	r24, Y+11	; 0x0b
     ac6:	9c 85       	ldd	r25, Y+12	; 0x0c
     ac8:	8c 01       	movw	r16, r24
     aca:	c8 01       	movw	r24, r16
     acc:	01 97       	sbiw	r24, 0x01	; 1
     ace:	f1 f7       	brne	.-4      	; 0xacc <ADCPower+0x138>
     ad0:	8c 01       	movw	r16, r24
     ad2:	0b 87       	std	Y+11, r16	; 0x0b
     ad4:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ad6:	89 85       	ldd	r24, Y+9	; 0x09
     ad8:	9a 85       	ldd	r25, Y+10	; 0x0a
     ada:	01 97       	sbiw	r24, 0x01	; 1
     adc:	89 87       	std	Y+9, r24	; 0x09
     ade:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ae0:	89 85       	ldd	r24, Y+9	; 0x09
     ae2:	9a 85       	ldd	r25, Y+10	; 0x0a
     ae4:	00 97       	sbiw	r24, 0x00	; 0
     ae6:	51 f7       	brne	.-44     	; 0xabc <ADCPower+0x128>
     ae8:	17 c0       	rjmp	.+46     	; 0xb18 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     aea:	6d 81       	ldd	r22, Y+5	; 0x05
     aec:	7e 81       	ldd	r23, Y+6	; 0x06
     aee:	8f 81       	ldd	r24, Y+7	; 0x07
     af0:	98 85       	ldd	r25, Y+8	; 0x08
     af2:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
     af6:	dc 01       	movw	r26, r24
     af8:	cb 01       	movw	r24, r22
     afa:	89 87       	std	Y+9, r24	; 0x09
     afc:	9a 87       	std	Y+10, r25	; 0x0a
     afe:	89 85       	ldd	r24, Y+9	; 0x09
     b00:	9a 85       	ldd	r25, Y+10	; 0x0a
     b02:	8d 87       	std	Y+13, r24	; 0x0d
     b04:	9e 87       	std	Y+14, r25	; 0x0e
     b06:	8d 85       	ldd	r24, Y+13	; 0x0d
     b08:	9e 85       	ldd	r25, Y+14	; 0x0e
     b0a:	8c 01       	movw	r16, r24
     b0c:	f8 01       	movw	r30, r16
     b0e:	31 97       	sbiw	r30, 0x01	; 1
     b10:	f1 f7       	brne	.-4      	; 0xb0e <ADCPower+0x17a>
     b12:	8f 01       	movw	r16, r30
     b14:	0d 87       	std	Y+13, r16	; 0x0d
     b16:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     b18:	80 e4       	ldi	r24, 0x40	; 64
     b1a:	96 e0       	ldi	r25, 0x06	; 6
     b1c:	20 e4       	ldi	r18, 0x40	; 64
     b1e:	fc 01       	movw	r30, r24
     b20:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	80 93 5c 50 	sts	0x505C, r24
     b28:	80 93 bd 50 	sts	0x50BD, r24
     b2c:	80 93 b7 23 	sts	0x23B7, r24
     b30:	80 93 54 50 	sts	0x5054, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     b34:	8f ef       	ldi	r24, 0xFF	; 255
     b36:	61 e0       	ldi	r22, 0x01	; 1
     b38:	0e 94 cb 33 	call	0x6796	; 0x6796 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     b3c:	8f ef       	ldi	r24, 0xFF	; 255
     b3e:	61 e0       	ldi	r22, 0x01	; 1
     b40:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     b44:	8f ef       	ldi	r24, 0xFF	; 255
     b46:	0e 94 1f 07 	call	0xe3e	; 0xe3e <set_filter>
     b4a:	42 c0       	rjmp	.+132    	; 0xbd0 <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     b4c:	80 e0       	ldi	r24, 0x00	; 0
     b4e:	96 e0       	ldi	r25, 0x06	; 6
     b50:	2e ed       	ldi	r18, 0xDE	; 222
     b52:	fc 01       	movw	r30, r24
     b54:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b56:	80 e2       	ldi	r24, 0x20	; 32
     b58:	96 e0       	ldi	r25, 0x06	; 6
     b5a:	2e e0       	ldi	r18, 0x0E	; 14
     b5c:	fc 01       	movw	r30, r24
     b5e:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     b60:	80 e4       	ldi	r24, 0x40	; 64
     b62:	96 e0       	ldi	r25, 0x06	; 6
     b64:	23 e0       	ldi	r18, 0x03	; 3
     b66:	fc 01       	movw	r30, r24
     b68:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     b6a:	80 e8       	ldi	r24, 0x80	; 128
     b6c:	96 e0       	ldi	r25, 0x06	; 6
     b6e:	20 e1       	ldi	r18, 0x10	; 16
     b70:	fc 01       	movw	r30, r24
     b72:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     b74:	80 ea       	ldi	r24, 0xA0	; 160
     b76:	96 e0       	ldi	r25, 0x06	; 6
     b78:	2e e0       	ldi	r18, 0x0E	; 14
     b7a:	fc 01       	movw	r30, r24
     b7c:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	96 e0       	ldi	r25, 0x06	; 6
     b82:	2e ed       	ldi	r18, 0xDE	; 222
     b84:	fc 01       	movw	r30, r24
     b86:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     b88:	80 e2       	ldi	r24, 0x20	; 32
     b8a:	96 e0       	ldi	r25, 0x06	; 6
     b8c:	2e e0       	ldi	r18, 0x0E	; 14
     b8e:	fc 01       	movw	r30, r24
     b90:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     b92:	80 e4       	ldi	r24, 0x40	; 64
     b94:	96 e0       	ldi	r25, 0x06	; 6
     b96:	23 e0       	ldi	r18, 0x03	; 3
     b98:	fc 01       	movw	r30, r24
     b9a:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     b9c:	80 e8       	ldi	r24, 0x80	; 128
     b9e:	96 e0       	ldi	r25, 0x06	; 6
     ba0:	20 e1       	ldi	r18, 0x10	; 16
     ba2:	fc 01       	movw	r30, r24
     ba4:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     ba6:	80 ea       	ldi	r24, 0xA0	; 160
     ba8:	96 e0       	ldi	r25, 0x06	; 6
     baa:	2e e0       	ldi	r18, 0x0E	; 14
     bac:	fc 01       	movw	r30, r24
     bae:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     bb0:	80 e4       	ldi	r24, 0x40	; 64
     bb2:	96 e0       	ldi	r25, 0x06	; 6
     bb4:	20 e4       	ldi	r18, 0x40	; 64
     bb6:	fc 01       	movw	r30, r24
     bb8:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	80 93 5c 50 	sts	0x505C, r24
     bc0:	80 93 bd 50 	sts	0x50BD, r24
     bc4:	80 93 b7 23 	sts	0x23B7, r24
     bc8:	80 93 54 50 	sts	0x5054, r24
		channelStatus = 0x00;
     bcc:	10 92 5b 50 	sts	0x505B, r1
		
	}
}
     bd0:	2f 96       	adiw	r28, 0x0f	; 15
     bd2:	cd bf       	out	0x3d, r28	; 61
     bd4:	de bf       	out	0x3e, r29	; 62
     bd6:	df 91       	pop	r29
     bd8:	cf 91       	pop	r28
     bda:	1f 91       	pop	r17
     bdc:	0f 91       	pop	r16
     bde:	08 95       	ret

00000be0 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     be0:	0f 93       	push	r16
     be2:	1f 93       	push	r17
     be4:	cf 93       	push	r28
     be6:	df 93       	push	r29
     be8:	cd b7       	in	r28, 0x3d	; 61
     bea:	de b7       	in	r29, 0x3e	; 62
     bec:	6a 97       	sbiw	r28, 0x1a	; 26
     bee:	cd bf       	out	0x3d, r28	; 61
     bf0:	de bf       	out	0x3e, r29	; 62
     bf2:	89 8f       	std	Y+25, r24	; 0x19
     bf4:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     bf6:	89 8d       	ldd	r24, Y+25	; 0x19
     bf8:	28 2f       	mov	r18, r24
     bfa:	30 e0       	ldi	r19, 0x00	; 0
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	90 e0       	ldi	r25, 0x00	; 0
     c00:	02 c0       	rjmp	.+4      	; 0xc06 <set_ampGain+0x26>
     c02:	88 0f       	add	r24, r24
     c04:	99 1f       	adc	r25, r25
     c06:	2a 95       	dec	r18
     c08:	e2 f7       	brpl	.-8      	; 0xc02 <set_ampGain+0x22>
     c0a:	61 e0       	ldi	r22, 0x01	; 1
     c0c:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     c10:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c12:	88 2f       	mov	r24, r24
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	81 70       	andi	r24, 0x01	; 1
     c18:	90 70       	andi	r25, 0x00	; 0
     c1a:	88 23       	and	r24, r24
     c1c:	31 f0       	breq	.+12     	; 0xc2a <set_ampGain+0x4a>
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	96 e0       	ldi	r25, 0x06	; 6
     c22:	20 e4       	ldi	r18, 0x40	; 64
     c24:	fc 01       	movw	r30, r24
     c26:	25 83       	std	Z+5, r18	; 0x05
     c28:	05 c0       	rjmp	.+10     	; 0xc34 <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	96 e0       	ldi	r25, 0x06	; 6
     c2e:	20 e4       	ldi	r18, 0x40	; 64
     c30:	fc 01       	movw	r30, r24
     c32:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     c34:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c36:	88 2f       	mov	r24, r24
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	82 70       	andi	r24, 0x02	; 2
     c3c:	90 70       	andi	r25, 0x00	; 0
     c3e:	00 97       	sbiw	r24, 0x00	; 0
     c40:	31 f0       	breq	.+12     	; 0xc4e <set_ampGain+0x6e>
     c42:	80 e2       	ldi	r24, 0x20	; 32
     c44:	96 e0       	ldi	r25, 0x06	; 6
     c46:	22 e0       	ldi	r18, 0x02	; 2
     c48:	fc 01       	movw	r30, r24
     c4a:	25 83       	std	Z+5, r18	; 0x05
     c4c:	05 c0       	rjmp	.+10     	; 0xc58 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     c4e:	80 e2       	ldi	r24, 0x20	; 32
     c50:	96 e0       	ldi	r25, 0x06	; 6
     c52:	22 e0       	ldi	r18, 0x02	; 2
     c54:	fc 01       	movw	r30, r24
     c56:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     c58:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c5a:	88 2f       	mov	r24, r24
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	84 70       	andi	r24, 0x04	; 4
     c60:	90 70       	andi	r25, 0x00	; 0
     c62:	00 97       	sbiw	r24, 0x00	; 0
     c64:	31 f0       	breq	.+12     	; 0xc72 <set_ampGain+0x92>
     c66:	80 e2       	ldi	r24, 0x20	; 32
     c68:	96 e0       	ldi	r25, 0x06	; 6
     c6a:	24 e0       	ldi	r18, 0x04	; 4
     c6c:	fc 01       	movw	r30, r24
     c6e:	25 83       	std	Z+5, r18	; 0x05
     c70:	05 c0       	rjmp	.+10     	; 0xc7c <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     c72:	80 e2       	ldi	r24, 0x20	; 32
     c74:	96 e0       	ldi	r25, 0x06	; 6
     c76:	24 e0       	ldi	r18, 0x04	; 4
     c78:	fc 01       	movw	r30, r24
     c7a:	26 83       	std	Z+6, r18	; 0x06
     c7c:	80 e0       	ldi	r24, 0x00	; 0
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	a0 e8       	ldi	r26, 0x80	; 128
     c82:	bf e3       	ldi	r27, 0x3F	; 63
     c84:	89 83       	std	Y+1, r24	; 0x01
     c86:	9a 83       	std	Y+2, r25	; 0x02
     c88:	ab 83       	std	Y+3, r26	; 0x03
     c8a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     c8c:	69 81       	ldd	r22, Y+1	; 0x01
     c8e:	7a 81       	ldd	r23, Y+2	; 0x02
     c90:	8b 81       	ldd	r24, Y+3	; 0x03
     c92:	9c 81       	ldd	r25, Y+4	; 0x04
     c94:	2b ea       	ldi	r18, 0xAB	; 171
     c96:	3a ea       	ldi	r19, 0xAA	; 170
     c98:	4a e2       	ldi	r20, 0x2A	; 42
     c9a:	51 e4       	ldi	r21, 0x41	; 65
     c9c:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
     ca0:	dc 01       	movw	r26, r24
     ca2:	cb 01       	movw	r24, r22
     ca4:	8d 83       	std	Y+5, r24	; 0x05
     ca6:	9e 83       	std	Y+6, r25	; 0x06
     ca8:	af 83       	std	Y+7, r26	; 0x07
     caa:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     cac:	11 e0       	ldi	r17, 0x01	; 1
     cae:	6d 81       	ldd	r22, Y+5	; 0x05
     cb0:	7e 81       	ldd	r23, Y+6	; 0x06
     cb2:	8f 81       	ldd	r24, Y+7	; 0x07
     cb4:	98 85       	ldd	r25, Y+8	; 0x08
     cb6:	20 e0       	ldi	r18, 0x00	; 0
     cb8:	30 e0       	ldi	r19, 0x00	; 0
     cba:	40 e8       	ldi	r20, 0x80	; 128
     cbc:	5f e3       	ldi	r21, 0x3F	; 63
     cbe:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
     cc2:	88 23       	and	r24, r24
     cc4:	0c f0       	brlt	.+2      	; 0xcc8 <set_ampGain+0xe8>
     cc6:	10 e0       	ldi	r17, 0x00	; 0
     cc8:	11 23       	and	r17, r17
     cca:	19 f0       	breq	.+6      	; 0xcd2 <set_ampGain+0xf2>
		__ticks = 1;
     ccc:	81 e0       	ldi	r24, 0x01	; 1
     cce:	89 87       	std	Y+9, r24	; 0x09
     cd0:	a3 c0       	rjmp	.+326    	; 0xe18 <set_ampGain+0x238>
	else if (__tmp > 255)
     cd2:	11 e0       	ldi	r17, 0x01	; 1
     cd4:	6d 81       	ldd	r22, Y+5	; 0x05
     cd6:	7e 81       	ldd	r23, Y+6	; 0x06
     cd8:	8f 81       	ldd	r24, Y+7	; 0x07
     cda:	98 85       	ldd	r25, Y+8	; 0x08
     cdc:	20 e0       	ldi	r18, 0x00	; 0
     cde:	30 e0       	ldi	r19, 0x00	; 0
     ce0:	4f e7       	ldi	r20, 0x7F	; 127
     ce2:	53 e4       	ldi	r21, 0x43	; 67
     ce4:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
     ce8:	18 16       	cp	r1, r24
     cea:	0c f0       	brlt	.+2      	; 0xcee <set_ampGain+0x10e>
     cec:	10 e0       	ldi	r17, 0x00	; 0
     cee:	11 23       	and	r17, r17
     cf0:	09 f4       	brne	.+2      	; 0xcf4 <set_ampGain+0x114>
     cf2:	89 c0       	rjmp	.+274    	; 0xe06 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     cf4:	69 81       	ldd	r22, Y+1	; 0x01
     cf6:	7a 81       	ldd	r23, Y+2	; 0x02
     cf8:	8b 81       	ldd	r24, Y+3	; 0x03
     cfa:	9c 81       	ldd	r25, Y+4	; 0x04
     cfc:	20 e0       	ldi	r18, 0x00	; 0
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	4a e7       	ldi	r20, 0x7A	; 122
     d02:	54 e4       	ldi	r21, 0x44	; 68
     d04:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
     d08:	dc 01       	movw	r26, r24
     d0a:	cb 01       	movw	r24, r22
     d0c:	8a 87       	std	Y+10, r24	; 0x0a
     d0e:	9b 87       	std	Y+11, r25	; 0x0b
     d10:	ac 87       	std	Y+12, r26	; 0x0c
     d12:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     d14:	6a 85       	ldd	r22, Y+10	; 0x0a
     d16:	7b 85       	ldd	r23, Y+11	; 0x0b
     d18:	8c 85       	ldd	r24, Y+12	; 0x0c
     d1a:	9d 85       	ldd	r25, Y+13	; 0x0d
     d1c:	20 e0       	ldi	r18, 0x00	; 0
     d1e:	30 e0       	ldi	r19, 0x00	; 0
     d20:	4a ef       	ldi	r20, 0xFA	; 250
     d22:	55 e4       	ldi	r21, 0x45	; 69
     d24:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
     d28:	dc 01       	movw	r26, r24
     d2a:	cb 01       	movw	r24, r22
     d2c:	8e 87       	std	Y+14, r24	; 0x0e
     d2e:	9f 87       	std	Y+15, r25	; 0x0f
     d30:	a8 8b       	std	Y+16, r26	; 0x10
     d32:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     d34:	11 e0       	ldi	r17, 0x01	; 1
     d36:	6e 85       	ldd	r22, Y+14	; 0x0e
     d38:	7f 85       	ldd	r23, Y+15	; 0x0f
     d3a:	88 89       	ldd	r24, Y+16	; 0x10
     d3c:	99 89       	ldd	r25, Y+17	; 0x11
     d3e:	20 e0       	ldi	r18, 0x00	; 0
     d40:	30 e0       	ldi	r19, 0x00	; 0
     d42:	40 e8       	ldi	r20, 0x80	; 128
     d44:	5f e3       	ldi	r21, 0x3F	; 63
     d46:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
     d4a:	88 23       	and	r24, r24
     d4c:	0c f0       	brlt	.+2      	; 0xd50 <set_ampGain+0x170>
     d4e:	10 e0       	ldi	r17, 0x00	; 0
     d50:	11 23       	and	r17, r17
     d52:	29 f0       	breq	.+10     	; 0xd5e <set_ampGain+0x17e>
		__ticks = 1;
     d54:	81 e0       	ldi	r24, 0x01	; 1
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	8a 8b       	std	Y+18, r24	; 0x12
     d5a:	9b 8b       	std	Y+19, r25	; 0x13
     d5c:	46 c0       	rjmp	.+140    	; 0xdea <set_ampGain+0x20a>
	else if (__tmp > 65535)
     d5e:	11 e0       	ldi	r17, 0x01	; 1
     d60:	6e 85       	ldd	r22, Y+14	; 0x0e
     d62:	7f 85       	ldd	r23, Y+15	; 0x0f
     d64:	88 89       	ldd	r24, Y+16	; 0x10
     d66:	99 89       	ldd	r25, Y+17	; 0x11
     d68:	20 e0       	ldi	r18, 0x00	; 0
     d6a:	3f ef       	ldi	r19, 0xFF	; 255
     d6c:	4f e7       	ldi	r20, 0x7F	; 127
     d6e:	57 e4       	ldi	r21, 0x47	; 71
     d70:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
     d74:	18 16       	cp	r1, r24
     d76:	0c f0       	brlt	.+2      	; 0xd7a <set_ampGain+0x19a>
     d78:	10 e0       	ldi	r17, 0x00	; 0
     d7a:	11 23       	and	r17, r17
     d7c:	61 f1       	breq	.+88     	; 0xdd6 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d7e:	6a 85       	ldd	r22, Y+10	; 0x0a
     d80:	7b 85       	ldd	r23, Y+11	; 0x0b
     d82:	8c 85       	ldd	r24, Y+12	; 0x0c
     d84:	9d 85       	ldd	r25, Y+13	; 0x0d
     d86:	20 e0       	ldi	r18, 0x00	; 0
     d88:	30 e0       	ldi	r19, 0x00	; 0
     d8a:	40 e2       	ldi	r20, 0x20	; 32
     d8c:	51 e4       	ldi	r21, 0x41	; 65
     d8e:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
     d92:	dc 01       	movw	r26, r24
     d94:	cb 01       	movw	r24, r22
     d96:	bc 01       	movw	r22, r24
     d98:	cd 01       	movw	r24, r26
     d9a:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
     d9e:	dc 01       	movw	r26, r24
     da0:	cb 01       	movw	r24, r22
     da2:	8a 8b       	std	Y+18, r24	; 0x12
     da4:	9b 8b       	std	Y+19, r25	; 0x13
     da6:	12 c0       	rjmp	.+36     	; 0xdcc <set_ampGain+0x1ec>
     da8:	80 e2       	ldi	r24, 0x20	; 32
     daa:	93 e0       	ldi	r25, 0x03	; 3
     dac:	8c 8b       	std	Y+20, r24	; 0x14
     dae:	9d 8b       	std	Y+21, r25	; 0x15
     db0:	8c 89       	ldd	r24, Y+20	; 0x14
     db2:	9d 89       	ldd	r25, Y+21	; 0x15
     db4:	8c 01       	movw	r16, r24
     db6:	c8 01       	movw	r24, r16
     db8:	01 97       	sbiw	r24, 0x01	; 1
     dba:	f1 f7       	brne	.-4      	; 0xdb8 <set_ampGain+0x1d8>
     dbc:	8c 01       	movw	r16, r24
     dbe:	0c 8b       	std	Y+20, r16	; 0x14
     dc0:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     dc2:	8a 89       	ldd	r24, Y+18	; 0x12
     dc4:	9b 89       	ldd	r25, Y+19	; 0x13
     dc6:	01 97       	sbiw	r24, 0x01	; 1
     dc8:	8a 8b       	std	Y+18, r24	; 0x12
     dca:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     dcc:	8a 89       	ldd	r24, Y+18	; 0x12
     dce:	9b 89       	ldd	r25, Y+19	; 0x13
     dd0:	00 97       	sbiw	r24, 0x00	; 0
     dd2:	51 f7       	brne	.-44     	; 0xda8 <set_ampGain+0x1c8>
     dd4:	28 c0       	rjmp	.+80     	; 0xe26 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     dd6:	6e 85       	ldd	r22, Y+14	; 0x0e
     dd8:	7f 85       	ldd	r23, Y+15	; 0x0f
     dda:	88 89       	ldd	r24, Y+16	; 0x10
     ddc:	99 89       	ldd	r25, Y+17	; 0x11
     dde:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
     de2:	dc 01       	movw	r26, r24
     de4:	cb 01       	movw	r24, r22
     de6:	8a 8b       	std	Y+18, r24	; 0x12
     de8:	9b 8b       	std	Y+19, r25	; 0x13
     dea:	8a 89       	ldd	r24, Y+18	; 0x12
     dec:	9b 89       	ldd	r25, Y+19	; 0x13
     dee:	8e 8b       	std	Y+22, r24	; 0x16
     df0:	9f 8b       	std	Y+23, r25	; 0x17
     df2:	8e 89       	ldd	r24, Y+22	; 0x16
     df4:	9f 89       	ldd	r25, Y+23	; 0x17
     df6:	8c 01       	movw	r16, r24
     df8:	f8 01       	movw	r30, r16
     dfa:	31 97       	sbiw	r30, 0x01	; 1
     dfc:	f1 f7       	brne	.-4      	; 0xdfa <set_ampGain+0x21a>
     dfe:	8f 01       	movw	r16, r30
     e00:	0e 8b       	std	Y+22, r16	; 0x16
     e02:	1f 8b       	std	Y+23, r17	; 0x17
     e04:	10 c0       	rjmp	.+32     	; 0xe26 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     e06:	6d 81       	ldd	r22, Y+5	; 0x05
     e08:	7e 81       	ldd	r23, Y+6	; 0x06
     e0a:	8f 81       	ldd	r24, Y+7	; 0x07
     e0c:	98 85       	ldd	r25, Y+8	; 0x08
     e0e:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
     e12:	dc 01       	movw	r26, r24
     e14:	cb 01       	movw	r24, r22
     e16:	89 87       	std	Y+9, r24	; 0x09
     e18:	89 85       	ldd	r24, Y+9	; 0x09
     e1a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     e1c:	88 8d       	ldd	r24, Y+24	; 0x18
     e1e:	18 2f       	mov	r17, r24
     e20:	1a 95       	dec	r17
     e22:	f1 f7       	brne	.-4      	; 0xe20 <set_ampGain+0x240>
     e24:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     e26:	8f ef       	ldi	r24, 0xFF	; 255
     e28:	61 e0       	ldi	r22, 0x01	; 1
     e2a:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     e2e:	6a 96       	adiw	r28, 0x1a	; 26
     e30:	cd bf       	out	0x3d, r28	; 61
     e32:	de bf       	out	0x3e, r29	; 62
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	1f 91       	pop	r17
     e3a:	0f 91       	pop	r16
     e3c:	08 95       	ret

00000e3e <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     e3e:	cf 93       	push	r28
     e40:	df 93       	push	r29
     e42:	00 d0       	rcall	.+0      	; 0xe44 <set_filter+0x6>
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62
     e48:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     e4a:	8b 81       	ldd	r24, Y+3	; 0x03
     e4c:	83 70       	andi	r24, 0x03	; 3
     e4e:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
     e50:	8b 81       	ldd	r24, Y+3	; 0x03
     e52:	8c 70       	andi	r24, 0x0C	; 12
     e54:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     e56:	8b 81       	ldd	r24, Y+3	; 0x03
     e58:	88 2f       	mov	r24, r24
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	85 70       	andi	r24, 0x05	; 5
     e5e:	90 70       	andi	r25, 0x00	; 0
     e60:	00 97       	sbiw	r24, 0x00	; 0
     e62:	51 f0       	breq	.+20     	; 0xe78 <set_filter+0x3a>
     e64:	80 91 5b 50 	lds	r24, 0x505B
     e68:	98 2f       	mov	r25, r24
     e6a:	90 7f       	andi	r25, 0xF0	; 240
     e6c:	8b 81       	ldd	r24, Y+3	; 0x03
     e6e:	82 95       	swap	r24
     e70:	8f 70       	andi	r24, 0x0F	; 15
     e72:	89 2b       	or	r24, r25
     e74:	80 93 5b 50 	sts	0x505B, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     e78:	8b 81       	ldd	r24, Y+3	; 0x03
     e7a:	88 2f       	mov	r24, r24
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	8a 70       	andi	r24, 0x0A	; 10
     e80:	90 70       	andi	r25, 0x00	; 0
     e82:	00 97       	sbiw	r24, 0x00	; 0
     e84:	49 f0       	breq	.+18     	; 0xe98 <set_filter+0x5a>
     e86:	8b 81       	ldd	r24, Y+3	; 0x03
     e88:	98 2f       	mov	r25, r24
     e8a:	90 7f       	andi	r25, 0xF0	; 240
     e8c:	80 91 5b 50 	lds	r24, 0x505B
     e90:	8f 70       	andi	r24, 0x0F	; 15
     e92:	89 2b       	or	r24, r25
     e94:	80 93 5b 50 	sts	0x505B, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     e98:	84 e0       	ldi	r24, 0x04	; 4
     e9a:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     e9e:	80 91 5b 50 	lds	r24, 0x505B
     ea2:	80 93 45 50 	sts	0x5045, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     ea6:	89 81       	ldd	r24, Y+1	; 0x01
     ea8:	88 23       	and	r24, r24
     eaa:	19 f0       	breq	.+6      	; 0xeb2 <set_filter+0x74>
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	0e 94 37 38 	call	0x706e	; 0x706e <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     eb2:	8a 81       	ldd	r24, Y+2	; 0x02
     eb4:	88 23       	and	r24, r24
     eb6:	19 f0       	breq	.+6      	; 0xebe <set_filter+0x80>
     eb8:	81 e0       	ldi	r24, 0x01	; 1
     eba:	0e 94 4f 38 	call	0x709e	; 0x709e <upperMuxCS>

	SPICS(TRUE);
     ebe:	81 e0       	ldi	r24, 0x01	; 1
     ec0:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     ec4:	80 ec       	ldi	r24, 0xC0	; 192
     ec6:	98 e0       	ldi	r25, 0x08	; 8
     ec8:	2f ef       	ldi	r18, 0xFF	; 255
     eca:	fc 01       	movw	r30, r24
     ecc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     ece:	00 00       	nop
     ed0:	80 ec       	ldi	r24, 0xC0	; 192
     ed2:	98 e0       	ldi	r25, 0x08	; 8
     ed4:	fc 01       	movw	r30, r24
     ed6:	82 81       	ldd	r24, Z+2	; 0x02
     ed8:	88 23       	and	r24, r24
     eda:	d4 f7       	brge	.-12     	; 0xed0 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     edc:	80 ec       	ldi	r24, 0xC0	; 192
     ede:	98 e0       	ldi	r25, 0x08	; 8
     ee0:	fc 01       	movw	r30, r24
     ee2:	83 81       	ldd	r24, Z+3	; 0x03
     ee4:	80 93 51 50 	sts	0x5051, r24

	nop();
     ee8:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     eea:	80 ec       	ldi	r24, 0xC0	; 192
     eec:	98 e0       	ldi	r25, 0x08	; 8
     eee:	20 91 45 50 	lds	r18, 0x5045
     ef2:	fc 01       	movw	r30, r24
     ef4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     ef6:	00 00       	nop
     ef8:	80 ec       	ldi	r24, 0xC0	; 192
     efa:	98 e0       	ldi	r25, 0x08	; 8
     efc:	fc 01       	movw	r30, r24
     efe:	82 81       	ldd	r24, Z+2	; 0x02
     f00:	88 23       	and	r24, r24
     f02:	d4 f7       	brge	.-12     	; 0xef8 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
     f04:	80 ec       	ldi	r24, 0xC0	; 192
     f06:	98 e0       	ldi	r25, 0x08	; 8
     f08:	fc 01       	movw	r30, r24
     f0a:	83 81       	ldd	r24, Z+3	; 0x03
     f0c:	80 93 51 50 	sts	0x5051, r24
	SPICS(FALSE);
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     f16:	89 81       	ldd	r24, Y+1	; 0x01
     f18:	88 23       	and	r24, r24
     f1a:	19 f0       	breq	.+6      	; 0xf22 <set_filter+0xe4>
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	0e 94 37 38 	call	0x706e	; 0x706e <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     f22:	8a 81       	ldd	r24, Y+2	; 0x02
     f24:	88 23       	and	r24, r24
     f26:	19 f0       	breq	.+6      	; 0xf2e <set_filter+0xf0>
     f28:	80 e0       	ldi	r24, 0x00	; 0
     f2a:	0e 94 4f 38 	call	0x709e	; 0x709e <upperMuxCS>
	SPIDisable();
     f2e:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
}
     f32:	23 96       	adiw	r28, 0x03	; 3
     f34:	cd bf       	out	0x3d, r28	; 61
     f36:	de bf       	out	0x3e, r29	; 62
     f38:	df 91       	pop	r29
     f3a:	cf 91       	pop	r28
     f3c:	08 95       	ret

00000f3e <enableADCMUX>:

void enableADCMUX(uint8_t on) {
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
     f42:	0f 92       	push	r0
     f44:	cd b7       	in	r28, 0x3d	; 61
     f46:	de b7       	in	r29, 0x3e	; 62
     f48:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
     f4a:	89 81       	ldd	r24, Y+1	; 0x01
     f4c:	88 23       	and	r24, r24
     f4e:	59 f0       	breq	.+22     	; 0xf66 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
     f50:	80 e0       	ldi	r24, 0x00	; 0
     f52:	96 e0       	ldi	r25, 0x06	; 6
     f54:	20 e2       	ldi	r18, 0x20	; 32
     f56:	fc 01       	movw	r30, r24
     f58:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	96 e0       	ldi	r25, 0x06	; 6
     f5e:	20 e2       	ldi	r18, 0x20	; 32
     f60:	fc 01       	movw	r30, r24
     f62:	25 83       	std	Z+5, r18	; 0x05
     f64:	0a c0       	rjmp	.+20     	; 0xf7a <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
     f66:	80 e0       	ldi	r24, 0x00	; 0
     f68:	96 e0       	ldi	r25, 0x06	; 6
     f6a:	20 e2       	ldi	r18, 0x20	; 32
     f6c:	fc 01       	movw	r30, r24
     f6e:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     f70:	80 e0       	ldi	r24, 0x00	; 0
     f72:	96 e0       	ldi	r25, 0x06	; 6
     f74:	20 e2       	ldi	r18, 0x20	; 32
     f76:	fc 01       	movw	r30, r24
     f78:	22 83       	std	Z+2, r18	; 0x02
	}
}
     f7a:	0f 90       	pop	r0
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	08 95       	ret

00000f82 <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {
     f82:	2f 92       	push	r2
     f84:	3f 92       	push	r3
     f86:	4f 92       	push	r4
     f88:	5f 92       	push	r5
     f8a:	6f 92       	push	r6
     f8c:	7f 92       	push	r7
     f8e:	8f 92       	push	r8
     f90:	9f 92       	push	r9
     f92:	af 92       	push	r10
     f94:	bf 92       	push	r11
     f96:	cf 92       	push	r12
     f98:	df 92       	push	r13
     f9a:	ef 92       	push	r14
     f9c:	ff 92       	push	r15
     f9e:	0f 93       	push	r16
     fa0:	1f 93       	push	r17
     fa2:	cf 93       	push	r28
     fa4:	df 93       	push	r29
     fa6:	cd b7       	in	r28, 0x3d	; 61
     fa8:	de b7       	in	r29, 0x3e	; 62
     faa:	ec 97       	sbiw	r28, 0x3c	; 60
     fac:	cd bf       	out	0x3d, r28	; 61
     fae:	de bf       	out	0x3e, r29	; 62
     fb0:	8b a3       	lds	r24, 0x5b
     fb2:	6c a3       	lds	r22, 0x5c
     fb4:	4d a3       	lds	r20, 0x5d
     fb6:	5e a3       	lds	r21, 0x5e
     fb8:	2f a3       	lds	r18, 0x5f
     fba:	38 a7       	lds	r19, 0x78
     fbc:	09 a7       	lds	r16, 0x79
     fbe:	1a a7       	lds	r17, 0x7a
     fc0:	eb a6       	lds	r30, 0xbb
     fc2:	cc a6       	lds	r28, 0xbc

	int64_t sum = 0;
     fc4:	19 82       	std	Y+1, r1	; 0x01
     fc6:	1a 82       	std	Y+2, r1	; 0x02
     fc8:	1b 82       	std	Y+3, r1	; 0x03
     fca:	1c 82       	std	Y+4, r1	; 0x04
     fcc:	1d 82       	std	Y+5, r1	; 0x05
     fce:	1e 82       	std	Y+6, r1	; 0x06
     fd0:	1f 82       	std	Y+7, r1	; 0x07
     fd2:	18 86       	std	Y+8, r1	; 0x08
	int64_t average;
	int64_t min = ADC_MAX;
     fd4:	8f ef       	ldi	r24, 0xFF	; 255
     fd6:	89 87       	std	Y+9, r24	; 0x09
     fd8:	8f ef       	ldi	r24, 0xFF	; 255
     fda:	8a 87       	std	Y+10, r24	; 0x0a
     fdc:	8f e7       	ldi	r24, 0x7F	; 127
     fde:	8b 87       	std	Y+11, r24	; 0x0b
     fe0:	1c 86       	std	Y+12, r1	; 0x0c
     fe2:	1d 86       	std	Y+13, r1	; 0x0d
     fe4:	1e 86       	std	Y+14, r1	; 0x0e
     fe6:	1f 86       	std	Y+15, r1	; 0x0f
     fe8:	18 8a       	std	Y+16, r1	; 0x10
	int64_t max = -ADC_MAX;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	89 8b       	std	Y+17, r24	; 0x11
     fee:	1a 8a       	std	Y+18, r1	; 0x12
     ff0:	80 e8       	ldi	r24, 0x80	; 128
     ff2:	8b 8b       	std	Y+19, r24	; 0x13
     ff4:	8f ef       	ldi	r24, 0xFF	; 255
     ff6:	8c 8b       	std	Y+20, r24	; 0x14
     ff8:	8f ef       	ldi	r24, 0xFF	; 255
     ffa:	8d 8b       	std	Y+21, r24	; 0x15
     ffc:	8f ef       	ldi	r24, 0xFF	; 255
     ffe:	8e 8b       	std	Y+22, r24	; 0x16
    1000:	8f ef       	ldi	r24, 0xFF	; 255
    1002:	8f 8b       	std	Y+23, r24	; 0x17
    1004:	8f ef       	ldi	r24, 0xFF	; 255
    1006:	88 8f       	std	Y+24, r24	; 0x18
	uint16_t period;
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    100e:	8b a1       	lds	r24, 0x4b
    1010:	6b a5       	lds	r22, 0x6b
    1012:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_filter(filterConfig);
    1016:	8c a1       	lds	r24, 0x4c
    1018:	0e 94 1f 07 	call	0xe3e	; 0xe3e <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    101c:	8b a1       	lds	r24, 0x4b
    101e:	85 30       	cpi	r24, 0x05	; 5
    1020:	31 f0       	breq	.+12     	; 0x102e <CO_collectADC+0xac>
    1022:	8b a1       	lds	r24, 0x4b
    1024:	86 30       	cpi	r24, 0x06	; 6
    1026:	19 f0       	breq	.+6      	; 0x102e <CO_collectADC+0xac>
    1028:	8b a1       	lds	r24, 0x4b
    102a:	87 30       	cpi	r24, 0x07	; 7
    102c:	19 f4       	brne	.+6      	; 0x1034 <CO_collectADC+0xb2>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    102e:	81 e0       	ldi	r24, 0x01	; 1
    1030:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1034:	81 e0       	ldi	r24, 0x01	; 1
    1036:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
	setADCInput(channel);
    103a:	8b a1       	lds	r24, 0x4b
    103c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    1040:	84 e0       	ldi	r24, 0x04	; 4
    1042:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1046:	80 ec       	ldi	r24, 0xC0	; 192
    1048:	98 e0       	ldi	r25, 0x08	; 8
    104a:	24 e5       	ldi	r18, 0x54	; 84
    104c:	fc 01       	movw	r30, r24
    104e:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    1050:	80 ea       	ldi	r24, 0xA0	; 160
    1052:	96 e0       	ldi	r25, 0x06	; 6
    1054:	21 e0       	ldi	r18, 0x01	; 1
    1056:	fc 01       	movw	r30, r24
    1058:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    105a:	80 ea       	ldi	r24, 0xA0	; 160
    105c:	96 e0       	ldi	r25, 0x06	; 6
    105e:	22 e0       	ldi	r18, 0x02	; 2
    1060:	fc 01       	movw	r30, r24
    1062:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    1064:	80 ea       	ldi	r24, 0xA0	; 160
    1066:	96 e0       	ldi	r25, 0x06	; 6
    1068:	21 e0       	ldi	r18, 0x01	; 1
    106a:	fc 01       	movw	r30, r24
    106c:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    106e:	80 ea       	ldi	r24, 0xA0	; 160
    1070:	96 e0       	ldi	r25, 0x06	; 6
    1072:	21 e0       	ldi	r18, 0x01	; 1
    1074:	fc 01       	movw	r30, r24
    1076:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    1078:	80 e8       	ldi	r24, 0x80	; 128
    107a:	96 e0       	ldi	r25, 0x06	; 6
    107c:	20 e2       	ldi	r18, 0x20	; 32
    107e:	fc 01       	movw	r30, r24
    1080:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1082:	80 e4       	ldi	r24, 0x40	; 64
    1084:	9a e0       	ldi	r25, 0x0A	; 10
    1086:	23 e2       	ldi	r18, 0x23	; 35
    1088:	fc 01       	movw	r30, r24
    108a:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    108c:	8c a5       	lds	r24, 0x6c
    108e:	88 2f       	mov	r24, r24
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	25 e1       	ldi	r18, 0x15	; 21
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	28 1b       	sub	r18, r24
    1098:	39 0b       	sbc	r19, r25
    109a:	81 e0       	ldi	r24, 0x01	; 1
    109c:	90 e0       	ldi	r25, 0x00	; 0
    109e:	02 c0       	rjmp	.+4      	; 0x10a4 <CO_collectADC+0x122>
    10a0:	88 0f       	add	r24, r24
    10a2:	99 1f       	adc	r25, r25
    10a4:	2a 95       	dec	r18
    10a6:	e2 f7       	brpl	.-8      	; 0x10a0 <CO_collectADC+0x11e>
    10a8:	01 97       	sbiw	r24, 0x01	; 1
    10aa:	89 8f       	std	Y+25, r24	; 0x19
    10ac:	9a 8f       	std	Y+26, r25	; 0x1a
	TCE1.PER = period;
    10ae:	80 e4       	ldi	r24, 0x40	; 64
    10b0:	9a e0       	ldi	r25, 0x0A	; 10
    10b2:	29 8d       	ldd	r18, Y+25	; 0x19
    10b4:	3a 8d       	ldd	r19, Y+26	; 0x1a
    10b6:	fc 01       	movw	r30, r24
    10b8:	26 a3       	lds	r18, 0x56
    10ba:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    10bc:	80 e4       	ldi	r24, 0x40	; 64
    10be:	9a e0       	ldi	r25, 0x0A	; 10
    10c0:	29 8d       	ldd	r18, Y+25	; 0x19
    10c2:	3a 8d       	ldd	r19, Y+26	; 0x1a
    10c4:	36 95       	lsr	r19
    10c6:	27 95       	ror	r18
    10c8:	fc 01       	movw	r30, r24
    10ca:	22 af       	sts	0x72, r18
    10cc:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    10ce:	80 e4       	ldi	r24, 0x40	; 64
    10d0:	9a e0       	ldi	r25, 0x0A	; 10
    10d2:	20 e4       	ldi	r18, 0x40	; 64
    10d4:	3a e0       	ldi	r19, 0x0A	; 10
    10d6:	f9 01       	movw	r30, r18
    10d8:	20 81       	ld	r18, Z
    10da:	20 7f       	andi	r18, 0xF0	; 240
    10dc:	21 60       	ori	r18, 0x01	; 1
    10de:	fc 01       	movw	r30, r24
    10e0:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    10e2:	80 ea       	ldi	r24, 0xA0	; 160
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	20 ea       	ldi	r18, 0xA0	; 160
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	f9 01       	movw	r30, r18
    10ec:	22 81       	ldd	r18, Z+2	; 0x02
    10ee:	21 60       	ori	r18, 0x01	; 1
    10f0:	fc 01       	movw	r30, r24
    10f2:	22 83       	std	Z+2, r18	; 0x02
	sei();
    10f4:	78 94       	sei

	sampleCount = 0;
    10f6:	10 92 52 50 	sts	0x5052, r1
    10fa:	10 92 53 50 	sts	0x5053, r1
	discardCount = 0;
    10fe:	10 92 3e 40 	sts	0x403E, r1
	
	// wait for ADC to collect samples
	while(sampleCount < NUM_SAMPLES);
    1102:	00 00       	nop
    1104:	80 91 52 50 	lds	r24, 0x5052
    1108:	90 91 53 50 	lds	r25, 0x5053
    110c:	f4 e0       	ldi	r31, 0x04	; 4
    110e:	80 30       	cpi	r24, 0x00	; 0
    1110:	9f 07       	cpc	r25, r31
    1112:	c0 f3       	brcs	.-16     	; 0x1104 <CO_collectADC+0x182>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1114:	80 e4       	ldi	r24, 0x40	; 64
    1116:	9a e0       	ldi	r25, 0x0A	; 10
    1118:	20 e4       	ldi	r18, 0x40	; 64
    111a:	3a e0       	ldi	r19, 0x0A	; 10
    111c:	f9 01       	movw	r30, r18
    111e:	20 81       	ld	r18, Z
    1120:	20 7f       	andi	r18, 0xF0	; 240
    1122:	fc 01       	movw	r30, r24
    1124:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    1126:	80 ea       	ldi	r24, 0xA0	; 160
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	20 ea       	ldi	r18, 0xA0	; 160
    112c:	30 e0       	ldi	r19, 0x00	; 0
    112e:	f9 01       	movw	r30, r18
    1130:	22 81       	ldd	r18, Z+2	; 0x02
    1132:	2e 7f       	andi	r18, 0xFE	; 254
    1134:	fc 01       	movw	r30, r24
    1136:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1138:	f8 94       	cli

	SPIDisable();	
    113a:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	enableADCMUX(FALSE);
    113e:	80 e0       	ldi	r24, 0x00	; 0
    1140:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
	ADCPower(FALSE);
    1144:	80 e0       	ldi	r24, 0x00	; 0
    1146:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    114a:	10 92 52 50 	sts	0x5052, r1
    114e:	10 92 53 50 	sts	0x5053, r1
    1152:	69 c1       	rjmp	.+722    	; 0x1426 <CO_collectADC+0x4a4>
		sum += data24Bit[sampleCount];
    1154:	80 91 52 50 	lds	r24, 0x5052
    1158:	90 91 53 50 	lds	r25, 0x5053
    115c:	88 0f       	add	r24, r24
    115e:	99 1f       	adc	r25, r25
    1160:	88 0f       	add	r24, r24
    1162:	99 1f       	adc	r25, r25
    1164:	8d 5b       	subi	r24, 0xBD	; 189
    1166:	9f 4b       	sbci	r25, 0xBF	; 191
    1168:	fc 01       	movw	r30, r24
    116a:	80 81       	ld	r24, Z
    116c:	91 81       	ldd	r25, Z+1	; 0x01
    116e:	a2 81       	ldd	r26, Z+2	; 0x02
    1170:	b3 81       	ldd	r27, Z+3	; 0x03
    1172:	8d a7       	lds	r24, 0x7d
    1174:	9e a7       	lds	r25, 0x7e
    1176:	af a7       	lds	r26, 0x7f
    1178:	b8 ab       	sts	0x58, r27
    117a:	bb 0f       	add	r27, r27
    117c:	88 0b       	sbc	r24, r24
    117e:	98 2f       	mov	r25, r24
    1180:	dc 01       	movw	r26, r24
    1182:	89 ab       	sts	0x59, r24
    1184:	8a ab       	sts	0x5a, r24
    1186:	8b ab       	sts	0x5b, r24
    1188:	8c ab       	sts	0x5c, r24
    118a:	a9 80       	ldd	r10, Y+1	; 0x01
    118c:	ba 80       	ldd	r11, Y+2	; 0x02
    118e:	cb 80       	ldd	r12, Y+3	; 0x03
    1190:	dc 80       	ldd	r13, Y+4	; 0x04
    1192:	ed 80       	ldd	r14, Y+5	; 0x05
    1194:	fe 80       	ldd	r15, Y+6	; 0x06
    1196:	0f 81       	ldd	r16, Y+7	; 0x07
    1198:	18 85       	ldd	r17, Y+8	; 0x08
    119a:	2d a5       	lds	r18, 0x6d
    119c:	2a 0d       	add	r18, r10
    119e:	e1 e0       	ldi	r30, 0x01	; 1
    11a0:	2a 15       	cp	r18, r10
    11a2:	08 f0       	brcs	.+2      	; 0x11a6 <CO_collectADC+0x224>
    11a4:	e0 e0       	ldi	r30, 0x00	; 0
    11a6:	3e a5       	lds	r19, 0x6e
    11a8:	3b 0d       	add	r19, r11
    11aa:	a1 e0       	ldi	r26, 0x01	; 1
    11ac:	3b 15       	cp	r19, r11
    11ae:	08 f0       	brcs	.+2      	; 0x11b2 <CO_collectADC+0x230>
    11b0:	a0 e0       	ldi	r26, 0x00	; 0
    11b2:	fe 2f       	mov	r31, r30
    11b4:	f3 0f       	add	r31, r19
    11b6:	e1 e0       	ldi	r30, 0x01	; 1
    11b8:	f3 17       	cp	r31, r19
    11ba:	08 f0       	brcs	.+2      	; 0x11be <CO_collectADC+0x23c>
    11bc:	e0 e0       	ldi	r30, 0x00	; 0
    11be:	ae 2b       	or	r26, r30
    11c0:	3f 2f       	mov	r19, r31
    11c2:	4f a5       	lds	r20, 0x6f
    11c4:	4c 0d       	add	r20, r12
    11c6:	b1 e0       	ldi	r27, 0x01	; 1
    11c8:	4c 15       	cp	r20, r12
    11ca:	08 f0       	brcs	.+2      	; 0x11ce <CO_collectADC+0x24c>
    11cc:	b0 e0       	ldi	r27, 0x00	; 0
    11ce:	fa 2f       	mov	r31, r26
    11d0:	f4 0f       	add	r31, r20
    11d2:	e1 e0       	ldi	r30, 0x01	; 1
    11d4:	f4 17       	cp	r31, r20
    11d6:	08 f0       	brcs	.+2      	; 0x11da <CO_collectADC+0x258>
    11d8:	e0 e0       	ldi	r30, 0x00	; 0
    11da:	be 2b       	or	r27, r30
    11dc:	4f 2f       	mov	r20, r31
    11de:	58 a9       	sts	0x48, r21
    11e0:	5d 0d       	add	r21, r13
    11e2:	a1 e0       	ldi	r26, 0x01	; 1
    11e4:	5d 15       	cp	r21, r13
    11e6:	08 f0       	brcs	.+2      	; 0x11ea <CO_collectADC+0x268>
    11e8:	a0 e0       	ldi	r26, 0x00	; 0
    11ea:	fb 2f       	mov	r31, r27
    11ec:	f5 0f       	add	r31, r21
    11ee:	e1 e0       	ldi	r30, 0x01	; 1
    11f0:	f5 17       	cp	r31, r21
    11f2:	08 f0       	brcs	.+2      	; 0x11f6 <CO_collectADC+0x274>
    11f4:	e0 e0       	ldi	r30, 0x00	; 0
    11f6:	ae 2b       	or	r26, r30
    11f8:	5f 2f       	mov	r21, r31
    11fa:	69 a9       	sts	0x49, r22
    11fc:	6e 0d       	add	r22, r14
    11fe:	b1 e0       	ldi	r27, 0x01	; 1
    1200:	6e 15       	cp	r22, r14
    1202:	08 f0       	brcs	.+2      	; 0x1206 <CO_collectADC+0x284>
    1204:	b0 e0       	ldi	r27, 0x00	; 0
    1206:	fa 2f       	mov	r31, r26
    1208:	f6 0f       	add	r31, r22
    120a:	e1 e0       	ldi	r30, 0x01	; 1
    120c:	f6 17       	cp	r31, r22
    120e:	08 f0       	brcs	.+2      	; 0x1212 <CO_collectADC+0x290>
    1210:	e0 e0       	ldi	r30, 0x00	; 0
    1212:	be 2b       	or	r27, r30
    1214:	6f 2f       	mov	r22, r31
    1216:	7a a9       	sts	0x4a, r23
    1218:	7f 0d       	add	r23, r15
    121a:	a1 e0       	ldi	r26, 0x01	; 1
    121c:	7f 15       	cp	r23, r15
    121e:	08 f0       	brcs	.+2      	; 0x1222 <CO_collectADC+0x2a0>
    1220:	a0 e0       	ldi	r26, 0x00	; 0
    1222:	fb 2f       	mov	r31, r27
    1224:	f7 0f       	add	r31, r23
    1226:	e1 e0       	ldi	r30, 0x01	; 1
    1228:	f7 17       	cp	r31, r23
    122a:	08 f0       	brcs	.+2      	; 0x122e <CO_collectADC+0x2ac>
    122c:	e0 e0       	ldi	r30, 0x00	; 0
    122e:	ae 2b       	or	r26, r30
    1230:	7f 2f       	mov	r23, r31
    1232:	8b a9       	sts	0x4b, r24
    1234:	80 0f       	add	r24, r16
    1236:	f1 e0       	ldi	r31, 0x01	; 1
    1238:	80 17       	cp	r24, r16
    123a:	08 f0       	brcs	.+2      	; 0x123e <CO_collectADC+0x2bc>
    123c:	f0 e0       	ldi	r31, 0x00	; 0
    123e:	a8 0f       	add	r26, r24
    1240:	e1 e0       	ldi	r30, 0x01	; 1
    1242:	a8 17       	cp	r26, r24
    1244:	08 f0       	brcs	.+2      	; 0x1248 <CO_collectADC+0x2c6>
    1246:	e0 e0       	ldi	r30, 0x00	; 0
    1248:	fe 2b       	or	r31, r30
    124a:	8a 2f       	mov	r24, r26
    124c:	9c a9       	sts	0x4c, r25
    124e:	91 0f       	add	r25, r17
    1250:	ef 2f       	mov	r30, r31
    1252:	e9 0f       	add	r30, r25
    1254:	9e 2f       	mov	r25, r30
    1256:	29 83       	std	Y+1, r18	; 0x01
    1258:	3a 83       	std	Y+2, r19	; 0x02
    125a:	4b 83       	std	Y+3, r20	; 0x03
    125c:	5c 83       	std	Y+4, r21	; 0x04
    125e:	6d 83       	std	Y+5, r22	; 0x05
    1260:	7e 83       	std	Y+6, r23	; 0x06
    1262:	8f 83       	std	Y+7, r24	; 0x07
    1264:	98 87       	std	Y+8, r25	; 0x08
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
    1266:	80 91 52 50 	lds	r24, 0x5052
    126a:	90 91 53 50 	lds	r25, 0x5053
    126e:	88 0f       	add	r24, r24
    1270:	99 1f       	adc	r25, r25
    1272:	88 0f       	add	r24, r24
    1274:	99 1f       	adc	r25, r25
    1276:	8d 5b       	subi	r24, 0xBD	; 189
    1278:	9f 4b       	sbci	r25, 0xBF	; 191
    127a:	fc 01       	movw	r30, r24
    127c:	80 81       	ld	r24, Z
    127e:	91 81       	ldd	r25, Z+1	; 0x01
    1280:	a2 81       	ldd	r26, Z+2	; 0x02
    1282:	b3 81       	ldd	r27, Z+3	; 0x03
    1284:	1c 01       	movw	r2, r24
    1286:	2d 01       	movw	r4, r26
    1288:	bb 0f       	add	r27, r27
    128a:	88 0b       	sbc	r24, r24
    128c:	98 2f       	mov	r25, r24
    128e:	dc 01       	movw	r26, r24
    1290:	68 2e       	mov	r6, r24
    1292:	78 2e       	mov	r7, r24
    1294:	88 2e       	mov	r8, r24
    1296:	98 2e       	mov	r9, r24
    1298:	88 8d       	ldd	r24, Y+24	; 0x18
    129a:	89 15       	cp	r24, r9
    129c:	5c f1       	brlt	.+86     	; 0x12f4 <CO_collectADC+0x372>
    129e:	88 8d       	ldd	r24, Y+24	; 0x18
    12a0:	89 15       	cp	r24, r9
    12a2:	09 f0       	breq	.+2      	; 0x12a6 <CO_collectADC+0x324>
    12a4:	42 c0       	rjmp	.+132    	; 0x132a <CO_collectADC+0x3a8>
    12a6:	8f 89       	ldd	r24, Y+23	; 0x17
    12a8:	88 15       	cp	r24, r8
    12aa:	20 f1       	brcs	.+72     	; 0x12f4 <CO_collectADC+0x372>
    12ac:	8f 89       	ldd	r24, Y+23	; 0x17
    12ae:	88 15       	cp	r24, r8
    12b0:	e1 f5       	brne	.+120    	; 0x132a <CO_collectADC+0x3a8>
    12b2:	8e 89       	ldd	r24, Y+22	; 0x16
    12b4:	87 15       	cp	r24, r7
    12b6:	f0 f0       	brcs	.+60     	; 0x12f4 <CO_collectADC+0x372>
    12b8:	8e 89       	ldd	r24, Y+22	; 0x16
    12ba:	87 15       	cp	r24, r7
    12bc:	b1 f5       	brne	.+108    	; 0x132a <CO_collectADC+0x3a8>
    12be:	8d 89       	ldd	r24, Y+21	; 0x15
    12c0:	86 15       	cp	r24, r6
    12c2:	c0 f0       	brcs	.+48     	; 0x12f4 <CO_collectADC+0x372>
    12c4:	8d 89       	ldd	r24, Y+21	; 0x15
    12c6:	86 15       	cp	r24, r6
    12c8:	81 f5       	brne	.+96     	; 0x132a <CO_collectADC+0x3a8>
    12ca:	8c 89       	ldd	r24, Y+20	; 0x14
    12cc:	85 15       	cp	r24, r5
    12ce:	90 f0       	brcs	.+36     	; 0x12f4 <CO_collectADC+0x372>
    12d0:	8c 89       	ldd	r24, Y+20	; 0x14
    12d2:	85 15       	cp	r24, r5
    12d4:	51 f5       	brne	.+84     	; 0x132a <CO_collectADC+0x3a8>
    12d6:	8b 89       	ldd	r24, Y+19	; 0x13
    12d8:	84 15       	cp	r24, r4
    12da:	60 f0       	brcs	.+24     	; 0x12f4 <CO_collectADC+0x372>
    12dc:	8b 89       	ldd	r24, Y+19	; 0x13
    12de:	84 15       	cp	r24, r4
    12e0:	21 f5       	brne	.+72     	; 0x132a <CO_collectADC+0x3a8>
    12e2:	8a 89       	ldd	r24, Y+18	; 0x12
    12e4:	83 15       	cp	r24, r3
    12e6:	30 f0       	brcs	.+12     	; 0x12f4 <CO_collectADC+0x372>
    12e8:	8a 89       	ldd	r24, Y+18	; 0x12
    12ea:	83 15       	cp	r24, r3
    12ec:	f1 f4       	brne	.+60     	; 0x132a <CO_collectADC+0x3a8>
    12ee:	89 89       	ldd	r24, Y+17	; 0x11
    12f0:	82 15       	cp	r24, r2
    12f2:	d8 f4       	brcc	.+54     	; 0x132a <CO_collectADC+0x3a8>
    12f4:	80 91 52 50 	lds	r24, 0x5052
    12f8:	90 91 53 50 	lds	r25, 0x5053
    12fc:	88 0f       	add	r24, r24
    12fe:	99 1f       	adc	r25, r25
    1300:	88 0f       	add	r24, r24
    1302:	99 1f       	adc	r25, r25
    1304:	8d 5b       	subi	r24, 0xBD	; 189
    1306:	9f 4b       	sbci	r25, 0xBF	; 191
    1308:	fc 01       	movw	r30, r24
    130a:	80 81       	ld	r24, Z
    130c:	91 81       	ldd	r25, Z+1	; 0x01
    130e:	a2 81       	ldd	r26, Z+2	; 0x02
    1310:	b3 81       	ldd	r27, Z+3	; 0x03
    1312:	89 8b       	std	Y+17, r24	; 0x11
    1314:	9a 8b       	std	Y+18, r25	; 0x12
    1316:	ab 8b       	std	Y+19, r26	; 0x13
    1318:	bc 8b       	std	Y+20, r27	; 0x14
    131a:	bb 0f       	add	r27, r27
    131c:	88 0b       	sbc	r24, r24
    131e:	98 2f       	mov	r25, r24
    1320:	dc 01       	movw	r26, r24
    1322:	8d 8b       	std	Y+21, r24	; 0x15
    1324:	8e 8b       	std	Y+22, r24	; 0x16
    1326:	8f 8b       	std	Y+23, r24	; 0x17
    1328:	88 8f       	std	Y+24, r24	; 0x18
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
    132a:	80 91 52 50 	lds	r24, 0x5052
    132e:	90 91 53 50 	lds	r25, 0x5053
    1332:	88 0f       	add	r24, r24
    1334:	99 1f       	adc	r25, r25
    1336:	88 0f       	add	r24, r24
    1338:	99 1f       	adc	r25, r25
    133a:	8d 5b       	subi	r24, 0xBD	; 189
    133c:	9f 4b       	sbci	r25, 0xBF	; 191
    133e:	fc 01       	movw	r30, r24
    1340:	80 81       	ld	r24, Z
    1342:	91 81       	ldd	r25, Z+1	; 0x01
    1344:	a2 81       	ldd	r26, Z+2	; 0x02
    1346:	b3 81       	ldd	r27, Z+3	; 0x03
    1348:	8d ab       	sts	0x5d, r24
    134a:	9e ab       	sts	0x5e, r25
    134c:	af ab       	sts	0x5f, r26
    134e:	b8 af       	sts	0x78, r27
    1350:	bb 0f       	add	r27, r27
    1352:	88 0b       	sbc	r24, r24
    1354:	98 2f       	mov	r25, r24
    1356:	dc 01       	movw	r26, r24
    1358:	89 af       	sts	0x79, r24
    135a:	8a af       	sts	0x7a, r24
    135c:	8b af       	sts	0x7b, r24
    135e:	8c af       	sts	0x7c, r24
    1360:	88 89       	ldd	r24, Y+16	; 0x10
    1362:	fc ad       	sts	0x6c, r31
    1364:	f8 17       	cp	r31, r24
    1366:	dc f1       	brlt	.+118    	; 0x13de <CO_collectADC+0x45c>
    1368:	88 89       	ldd	r24, Y+16	; 0x10
    136a:	2c ad       	sts	0x6c, r18
    136c:	82 17       	cp	r24, r18
    136e:	09 f0       	breq	.+2      	; 0x1372 <CO_collectADC+0x3f0>
    1370:	51 c0       	rjmp	.+162    	; 0x1414 <CO_collectADC+0x492>
    1372:	8f 85       	ldd	r24, Y+15	; 0x0f
    1374:	9b ad       	sts	0x6b, r25
    1376:	98 17       	cp	r25, r24
    1378:	90 f1       	brcs	.+100    	; 0x13de <CO_collectADC+0x45c>
    137a:	8f 85       	ldd	r24, Y+15	; 0x0f
    137c:	eb ad       	sts	0x6b, r30
    137e:	8e 17       	cp	r24, r30
    1380:	09 f0       	breq	.+2      	; 0x1384 <CO_collectADC+0x402>
    1382:	48 c0       	rjmp	.+144    	; 0x1414 <CO_collectADC+0x492>
    1384:	8e 85       	ldd	r24, Y+14	; 0x0e
    1386:	fa ad       	sts	0x6a, r31
    1388:	f8 17       	cp	r31, r24
    138a:	48 f1       	brcs	.+82     	; 0x13de <CO_collectADC+0x45c>
    138c:	8e 85       	ldd	r24, Y+14	; 0x0e
    138e:	2a ad       	sts	0x6a, r18
    1390:	82 17       	cp	r24, r18
    1392:	09 f0       	breq	.+2      	; 0x1396 <CO_collectADC+0x414>
    1394:	3f c0       	rjmp	.+126    	; 0x1414 <CO_collectADC+0x492>
    1396:	8d 85       	ldd	r24, Y+13	; 0x0d
    1398:	99 ad       	sts	0x69, r25
    139a:	98 17       	cp	r25, r24
    139c:	00 f1       	brcs	.+64     	; 0x13de <CO_collectADC+0x45c>
    139e:	8d 85       	ldd	r24, Y+13	; 0x0d
    13a0:	e9 ad       	sts	0x69, r30
    13a2:	8e 17       	cp	r24, r30
    13a4:	b9 f5       	brne	.+110    	; 0x1414 <CO_collectADC+0x492>
    13a6:	8c 85       	ldd	r24, Y+12	; 0x0c
    13a8:	f8 ad       	sts	0x68, r31
    13aa:	f8 17       	cp	r31, r24
    13ac:	c0 f0       	brcs	.+48     	; 0x13de <CO_collectADC+0x45c>
    13ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    13b0:	28 ad       	sts	0x68, r18
    13b2:	82 17       	cp	r24, r18
    13b4:	79 f5       	brne	.+94     	; 0x1414 <CO_collectADC+0x492>
    13b6:	8b 85       	ldd	r24, Y+11	; 0x0b
    13b8:	9f a9       	sts	0x4f, r25
    13ba:	98 17       	cp	r25, r24
    13bc:	80 f0       	brcs	.+32     	; 0x13de <CO_collectADC+0x45c>
    13be:	8b 85       	ldd	r24, Y+11	; 0x0b
    13c0:	ef a9       	sts	0x4f, r30
    13c2:	8e 17       	cp	r24, r30
    13c4:	39 f5       	brne	.+78     	; 0x1414 <CO_collectADC+0x492>
    13c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    13c8:	fe a9       	sts	0x4e, r31
    13ca:	f8 17       	cp	r31, r24
    13cc:	40 f0       	brcs	.+16     	; 0x13de <CO_collectADC+0x45c>
    13ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    13d0:	2e a9       	sts	0x4e, r18
    13d2:	82 17       	cp	r24, r18
    13d4:	f9 f4       	brne	.+62     	; 0x1414 <CO_collectADC+0x492>
    13d6:	89 85       	ldd	r24, Y+9	; 0x09
    13d8:	9d a9       	sts	0x4d, r25
    13da:	98 17       	cp	r25, r24
    13dc:	d8 f4       	brcc	.+54     	; 0x1414 <CO_collectADC+0x492>
    13de:	80 91 52 50 	lds	r24, 0x5052
    13e2:	90 91 53 50 	lds	r25, 0x5053
    13e6:	88 0f       	add	r24, r24
    13e8:	99 1f       	adc	r25, r25
    13ea:	88 0f       	add	r24, r24
    13ec:	99 1f       	adc	r25, r25
    13ee:	8d 5b       	subi	r24, 0xBD	; 189
    13f0:	9f 4b       	sbci	r25, 0xBF	; 191
    13f2:	fc 01       	movw	r30, r24
    13f4:	80 81       	ld	r24, Z
    13f6:	91 81       	ldd	r25, Z+1	; 0x01
    13f8:	a2 81       	ldd	r26, Z+2	; 0x02
    13fa:	b3 81       	ldd	r27, Z+3	; 0x03
    13fc:	89 87       	std	Y+9, r24	; 0x09
    13fe:	9a 87       	std	Y+10, r25	; 0x0a
    1400:	ab 87       	std	Y+11, r26	; 0x0b
    1402:	bc 87       	std	Y+12, r27	; 0x0c
    1404:	bb 0f       	add	r27, r27
    1406:	88 0b       	sbc	r24, r24
    1408:	98 2f       	mov	r25, r24
    140a:	dc 01       	movw	r26, r24
    140c:	8d 87       	std	Y+13, r24	; 0x0d
    140e:	8e 87       	std	Y+14, r24	; 0x0e
    1410:	8f 87       	std	Y+15, r24	; 0x0f
    1412:	88 8b       	std	Y+16, r24	; 0x10
	SPIDisable();	
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    1414:	80 91 52 50 	lds	r24, 0x5052
    1418:	90 91 53 50 	lds	r25, 0x5053
    141c:	01 96       	adiw	r24, 0x01	; 1
    141e:	80 93 52 50 	sts	0x5052, r24
    1422:	90 93 53 50 	sts	0x5053, r25
    1426:	80 91 52 50 	lds	r24, 0x5052
    142a:	90 91 53 50 	lds	r25, 0x5053
    142e:	f4 e0       	ldi	r31, 0x04	; 4
    1430:	80 30       	cpi	r24, 0x00	; 0
    1432:	9f 07       	cpc	r25, r31
    1434:	08 f4       	brcc	.+2      	; 0x1438 <CO_collectADC+0x4b6>
    1436:	8e ce       	rjmp	.-740    	; 0x1154 <CO_collectADC+0x1d2>
		sum += data24Bit[sampleCount];
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
	}
	average = sum / NUM_SAMPLES;
    1438:	29 81       	ldd	r18, Y+1	; 0x01
    143a:	3a 81       	ldd	r19, Y+2	; 0x02
    143c:	4b 81       	ldd	r20, Y+3	; 0x03
    143e:	5c 81       	ldd	r21, Y+4	; 0x04
    1440:	6d 81       	ldd	r22, Y+5	; 0x05
    1442:	7e 81       	ldd	r23, Y+6	; 0x06
    1444:	8f 81       	ldd	r24, Y+7	; 0x07
    1446:	98 85       	ldd	r25, Y+8	; 0x08
    1448:	a2 2e       	mov	r10, r18
    144a:	b3 2e       	mov	r11, r19
    144c:	c4 2e       	mov	r12, r20
    144e:	d5 2e       	mov	r13, r21
    1450:	e6 2e       	mov	r14, r22
    1452:	f7 2e       	mov	r15, r23
    1454:	08 2f       	mov	r16, r24
    1456:	19 2f       	mov	r17, r25
    1458:	11 23       	and	r17, r17
    145a:	0c f0       	brlt	.+2      	; 0x145e <CO_collectADC+0x4dc>
    145c:	6c c0       	rjmp	.+216    	; 0x1536 <CO_collectADC+0x5b4>
    145e:	22 24       	eor	r2, r2
    1460:	2a 94       	dec	r2
    1462:	0f 2e       	mov	r0, r31
    1464:	f3 e0       	ldi	r31, 0x03	; 3
    1466:	3f 2e       	mov	r3, r31
    1468:	f0 2d       	mov	r31, r0
    146a:	44 24       	eor	r4, r4
    146c:	55 24       	eor	r5, r5
    146e:	66 24       	eor	r6, r6
    1470:	77 24       	eor	r7, r7
    1472:	88 24       	eor	r8, r8
    1474:	99 24       	eor	r9, r9
    1476:	2a 2d       	mov	r18, r10
    1478:	22 0d       	add	r18, r2
    147a:	e1 e0       	ldi	r30, 0x01	; 1
    147c:	2a 15       	cp	r18, r10
    147e:	08 f0       	brcs	.+2      	; 0x1482 <CO_collectADC+0x500>
    1480:	e0 e0       	ldi	r30, 0x00	; 0
    1482:	3b 2d       	mov	r19, r11
    1484:	33 0d       	add	r19, r3
    1486:	f1 e0       	ldi	r31, 0x01	; 1
    1488:	3b 15       	cp	r19, r11
    148a:	08 f0       	brcs	.+2      	; 0x148e <CO_collectADC+0x50c>
    148c:	f0 e0       	ldi	r31, 0x00	; 0
    148e:	e3 0f       	add	r30, r19
    1490:	a1 e0       	ldi	r26, 0x01	; 1
    1492:	e3 17       	cp	r30, r19
    1494:	08 f0       	brcs	.+2      	; 0x1498 <CO_collectADC+0x516>
    1496:	a0 e0       	ldi	r26, 0x00	; 0
    1498:	fa 2b       	or	r31, r26
    149a:	3e 2f       	mov	r19, r30
    149c:	4c 2d       	mov	r20, r12
    149e:	44 0d       	add	r20, r4
    14a0:	e1 e0       	ldi	r30, 0x01	; 1
    14a2:	4c 15       	cp	r20, r12
    14a4:	08 f0       	brcs	.+2      	; 0x14a8 <CO_collectADC+0x526>
    14a6:	e0 e0       	ldi	r30, 0x00	; 0
    14a8:	f4 0f       	add	r31, r20
    14aa:	a1 e0       	ldi	r26, 0x01	; 1
    14ac:	f4 17       	cp	r31, r20
    14ae:	08 f0       	brcs	.+2      	; 0x14b2 <CO_collectADC+0x530>
    14b0:	a0 e0       	ldi	r26, 0x00	; 0
    14b2:	ea 2b       	or	r30, r26
    14b4:	4f 2f       	mov	r20, r31
    14b6:	5d 2d       	mov	r21, r13
    14b8:	55 0d       	add	r21, r5
    14ba:	f1 e0       	ldi	r31, 0x01	; 1
    14bc:	5d 15       	cp	r21, r13
    14be:	08 f0       	brcs	.+2      	; 0x14c2 <CO_collectADC+0x540>
    14c0:	f0 e0       	ldi	r31, 0x00	; 0
    14c2:	e5 0f       	add	r30, r21
    14c4:	a1 e0       	ldi	r26, 0x01	; 1
    14c6:	e5 17       	cp	r30, r21
    14c8:	08 f0       	brcs	.+2      	; 0x14cc <CO_collectADC+0x54a>
    14ca:	a0 e0       	ldi	r26, 0x00	; 0
    14cc:	fa 2b       	or	r31, r26
    14ce:	5e 2f       	mov	r21, r30
    14d0:	6e 2d       	mov	r22, r14
    14d2:	66 0d       	add	r22, r6
    14d4:	e1 e0       	ldi	r30, 0x01	; 1
    14d6:	6e 15       	cp	r22, r14
    14d8:	08 f0       	brcs	.+2      	; 0x14dc <CO_collectADC+0x55a>
    14da:	e0 e0       	ldi	r30, 0x00	; 0
    14dc:	f6 0f       	add	r31, r22
    14de:	a1 e0       	ldi	r26, 0x01	; 1
    14e0:	f6 17       	cp	r31, r22
    14e2:	08 f0       	brcs	.+2      	; 0x14e6 <CO_collectADC+0x564>
    14e4:	a0 e0       	ldi	r26, 0x00	; 0
    14e6:	ea 2b       	or	r30, r26
    14e8:	6f 2f       	mov	r22, r31
    14ea:	7f 2d       	mov	r23, r15
    14ec:	77 0d       	add	r23, r7
    14ee:	f1 e0       	ldi	r31, 0x01	; 1
    14f0:	7f 15       	cp	r23, r15
    14f2:	08 f0       	brcs	.+2      	; 0x14f6 <CO_collectADC+0x574>
    14f4:	f0 e0       	ldi	r31, 0x00	; 0
    14f6:	e7 0f       	add	r30, r23
    14f8:	a1 e0       	ldi	r26, 0x01	; 1
    14fa:	e7 17       	cp	r30, r23
    14fc:	08 f0       	brcs	.+2      	; 0x1500 <CO_collectADC+0x57e>
    14fe:	a0 e0       	ldi	r26, 0x00	; 0
    1500:	fa 2b       	or	r31, r26
    1502:	7e 2f       	mov	r23, r30
    1504:	80 2f       	mov	r24, r16
    1506:	88 0d       	add	r24, r8
    1508:	e1 e0       	ldi	r30, 0x01	; 1
    150a:	80 17       	cp	r24, r16
    150c:	08 f0       	brcs	.+2      	; 0x1510 <CO_collectADC+0x58e>
    150e:	e0 e0       	ldi	r30, 0x00	; 0
    1510:	f8 0f       	add	r31, r24
    1512:	a1 e0       	ldi	r26, 0x01	; 1
    1514:	f8 17       	cp	r31, r24
    1516:	08 f0       	brcs	.+2      	; 0x151a <CO_collectADC+0x598>
    1518:	a0 e0       	ldi	r26, 0x00	; 0
    151a:	ea 2b       	or	r30, r26
    151c:	8f 2f       	mov	r24, r31
    151e:	91 2f       	mov	r25, r17
    1520:	99 0d       	add	r25, r9
    1522:	e9 0f       	add	r30, r25
    1524:	9e 2f       	mov	r25, r30
    1526:	a2 2e       	mov	r10, r18
    1528:	b3 2e       	mov	r11, r19
    152a:	c4 2e       	mov	r12, r20
    152c:	d5 2e       	mov	r13, r21
    152e:	e6 2e       	mov	r14, r22
    1530:	f7 2e       	mov	r15, r23
    1532:	08 2f       	mov	r16, r24
    1534:	19 2f       	mov	r17, r25
    1536:	2a 2d       	mov	r18, r10
    1538:	3b 2d       	mov	r19, r11
    153a:	4c 2d       	mov	r20, r12
    153c:	5d 2d       	mov	r21, r13
    153e:	6e 2d       	mov	r22, r14
    1540:	7f 2d       	mov	r23, r15
    1542:	80 2f       	mov	r24, r16
    1544:	91 2f       	mov	r25, r17
    1546:	0a e0       	ldi	r16, 0x0A	; 10
    1548:	0e 94 b7 52 	call	0xa56e	; 0xa56e <__ashrdi3>
    154c:	a2 2e       	mov	r10, r18
    154e:	b3 2e       	mov	r11, r19
    1550:	c4 2e       	mov	r12, r20
    1552:	d5 2e       	mov	r13, r21
    1554:	e6 2e       	mov	r14, r22
    1556:	f7 2e       	mov	r15, r23
    1558:	08 2f       	mov	r16, r24
    155a:	19 2f       	mov	r17, r25
    155c:	ab 8e       	std	Y+27, r10	; 0x1b
    155e:	bc 8e       	std	Y+28, r11	; 0x1c
    1560:	cd 8e       	std	Y+29, r12	; 0x1d
    1562:	de 8e       	std	Y+30, r13	; 0x1e
    1564:	ef 8e       	std	Y+31, r14	; 0x1f
    1566:	f8 a2       	lds	r31, 0x98
    1568:	09 a3       	lds	r16, 0x59
    156a:	1a a3       	lds	r17, 0x5a

	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    156c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    156e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    1570:	4d 8d       	ldd	r20, Y+29	; 0x1d
    1572:	5e 8d       	ldd	r21, Y+30	; 0x1e
    1574:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1576:	78 a1       	lds	r23, 0x48
    1578:	89 a1       	lds	r24, 0x49
    157a:	9a a1       	lds	r25, 0x4a
    157c:	0f 2e       	mov	r0, r31
    157e:	f0 ea       	ldi	r31, 0xA0	; 160
    1580:	af 2e       	mov	r10, r31
    1582:	f0 2d       	mov	r31, r0
    1584:	0f 2e       	mov	r0, r31
    1586:	f5 e2       	ldi	r31, 0x25	; 37
    1588:	bf 2e       	mov	r11, r31
    158a:	f0 2d       	mov	r31, r0
    158c:	0f 2e       	mov	r0, r31
    158e:	f6 e2       	ldi	r31, 0x26	; 38
    1590:	cf 2e       	mov	r12, r31
    1592:	f0 2d       	mov	r31, r0
    1594:	dd 24       	eor	r13, r13
    1596:	ee 24       	eor	r14, r14
    1598:	ff 24       	eor	r15, r15
    159a:	00 e0       	ldi	r16, 0x00	; 0
    159c:	10 e0       	ldi	r17, 0x00	; 0
    159e:	0e 94 70 51 	call	0xa2e0	; 0xa2e0 <__muldi3>
    15a2:	22 2e       	mov	r2, r18
    15a4:	33 2e       	mov	r3, r19
    15a6:	44 2e       	mov	r4, r20
    15a8:	55 2e       	mov	r5, r21
    15aa:	66 2e       	mov	r6, r22
    15ac:	77 2e       	mov	r7, r23
    15ae:	88 2e       	mov	r8, r24
    15b0:	99 2e       	mov	r9, r25
    15b2:	a2 2c       	mov	r10, r2
    15b4:	b3 2c       	mov	r11, r3
    15b6:	c4 2c       	mov	r12, r4
    15b8:	d5 2c       	mov	r13, r5
    15ba:	e6 2c       	mov	r14, r6
    15bc:	f7 2c       	mov	r15, r7
    15be:	08 2d       	mov	r16, r8
    15c0:	19 2d       	mov	r17, r9
    15c2:	2a 2d       	mov	r18, r10
    15c4:	3b 2d       	mov	r19, r11
    15c6:	4c 2d       	mov	r20, r12
    15c8:	5d 2d       	mov	r21, r13
    15ca:	6e 2d       	mov	r22, r14
    15cc:	7f 2d       	mov	r23, r15
    15ce:	80 2f       	mov	r24, r16
    15d0:	91 2f       	mov	r25, r17
    15d2:	aa 24       	eor	r10, r10
    15d4:	aa 94       	dec	r10
    15d6:	bb 24       	eor	r11, r11
    15d8:	ba 94       	dec	r11
    15da:	0f 2e       	mov	r0, r31
    15dc:	ff e7       	ldi	r31, 0x7F	; 127
    15de:	cf 2e       	mov	r12, r31
    15e0:	f0 2d       	mov	r31, r0
    15e2:	dd 24       	eor	r13, r13
    15e4:	ee 24       	eor	r14, r14
    15e6:	ff 24       	eor	r15, r15
    15e8:	00 e0       	ldi	r16, 0x00	; 0
    15ea:	10 e0       	ldi	r17, 0x00	; 0
    15ec:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    15f0:	22 2e       	mov	r2, r18
    15f2:	33 2e       	mov	r3, r19
    15f4:	44 2e       	mov	r4, r20
    15f6:	55 2e       	mov	r5, r21
    15f8:	66 2e       	mov	r6, r22
    15fa:	77 2e       	mov	r7, r23
    15fc:	88 2e       	mov	r8, r24
    15fe:	99 2e       	mov	r9, r25
    1600:	a2 2c       	mov	r10, r2
    1602:	b3 2c       	mov	r11, r3
    1604:	c4 2c       	mov	r12, r4
    1606:	d5 2c       	mov	r13, r5
    1608:	e6 2c       	mov	r14, r6
    160a:	f7 2c       	mov	r15, r7
    160c:	08 2d       	mov	r16, r8
    160e:	19 2d       	mov	r17, r9
    1610:	2a 2d       	mov	r18, r10
    1612:	3b 2d       	mov	r19, r11
    1614:	4c 2d       	mov	r20, r12
    1616:	5d 2d       	mov	r21, r13
    1618:	6e 2d       	mov	r22, r14
    161a:	7f 2d       	mov	r23, r15
    161c:	80 2f       	mov	r24, r16
    161e:	91 2f       	mov	r25, r17
    1620:	01 e0       	ldi	r16, 0x01	; 1
    1622:	0e 94 43 52 	call	0xa486	; 0xa486 <__ashldi3>
    1626:	22 2e       	mov	r2, r18
    1628:	33 2e       	mov	r3, r19
    162a:	44 2e       	mov	r4, r20
    162c:	55 2e       	mov	r5, r21
    162e:	66 2e       	mov	r6, r22
    1630:	77 2e       	mov	r7, r23
    1632:	88 2e       	mov	r8, r24
    1634:	99 2e       	mov	r9, r25
    1636:	a2 2c       	mov	r10, r2
    1638:	b3 2c       	mov	r11, r3
    163a:	c4 2c       	mov	r12, r4
    163c:	d5 2c       	mov	r13, r5
    163e:	e6 2c       	mov	r14, r6
    1640:	f7 2c       	mov	r15, r7
    1642:	08 2d       	mov	r16, r8
    1644:	19 2d       	mov	r17, r9
    1646:	2a 2d       	mov	r18, r10
    1648:	3b 2d       	mov	r19, r11
    164a:	4c 2d       	mov	r20, r12
    164c:	5d 2d       	mov	r21, r13
    164e:	6e 2d       	mov	r22, r14
    1650:	7f 2d       	mov	r23, r15
    1652:	80 2f       	mov	r24, r16
    1654:	91 2f       	mov	r25, r17
    1656:	0f 2e       	mov	r0, r31
    1658:	f3 e0       	ldi	r31, 0x03	; 3
    165a:	af 2e       	mov	r10, r31
    165c:	f0 2d       	mov	r31, r0
    165e:	bb 24       	eor	r11, r11
    1660:	cc 24       	eor	r12, r12
    1662:	dd 24       	eor	r13, r13
    1664:	ee 24       	eor	r14, r14
    1666:	ff 24       	eor	r15, r15
    1668:	00 e0       	ldi	r16, 0x00	; 0
    166a:	10 e0       	ldi	r17, 0x00	; 0
    166c:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    1670:	a2 2e       	mov	r10, r18
    1672:	b3 2e       	mov	r11, r19
    1674:	c4 2e       	mov	r12, r20
    1676:	d5 2e       	mov	r13, r21
    1678:	e6 2e       	mov	r14, r22
    167a:	f7 2e       	mov	r15, r23
    167c:	08 2f       	mov	r16, r24
    167e:	19 2f       	mov	r17, r25
    1680:	2a 2d       	mov	r18, r10
    1682:	3b 2d       	mov	r19, r11
    1684:	4c 2d       	mov	r20, r12
    1686:	5d 2d       	mov	r21, r13
    1688:	6e 2d       	mov	r22, r14
    168a:	7f 2d       	mov	r23, r15
    168c:	80 2f       	mov	r24, r16
    168e:	91 2f       	mov	r25, r17
    1690:	da 01       	movw	r26, r20
    1692:	c9 01       	movw	r24, r18
    1694:	b0 95       	com	r27
    1696:	a0 95       	com	r26
    1698:	90 95       	com	r25
    169a:	81 95       	neg	r24
    169c:	9f 4f       	sbci	r25, 0xFF	; 255
    169e:	af 4f       	sbci	r26, 0xFF	; 255
    16a0:	bf 4f       	sbci	r27, 0xFF	; 255
    16a2:	2d a1       	lds	r18, 0x4d
    16a4:	3e a1       	lds	r19, 0x4e
    16a6:	f9 01       	movw	r30, r18
    16a8:	80 83       	st	Z, r24
    16aa:	91 83       	std	Z+1, r25	; 0x01
    16ac:	a2 83       	std	Z+2, r26	; 0x02
    16ae:	b3 83       	std	Z+3, r27	; 0x03
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    16b0:	29 89       	ldd	r18, Y+17	; 0x11
    16b2:	3a 89       	ldd	r19, Y+18	; 0x12
    16b4:	4b 89       	ldd	r20, Y+19	; 0x13
    16b6:	5c 89       	ldd	r21, Y+20	; 0x14
    16b8:	6d 89       	ldd	r22, Y+21	; 0x15
    16ba:	7e 89       	ldd	r23, Y+22	; 0x16
    16bc:	8f 89       	ldd	r24, Y+23	; 0x17
    16be:	98 8d       	ldd	r25, Y+24	; 0x18
    16c0:	0f 2e       	mov	r0, r31
    16c2:	f0 ea       	ldi	r31, 0xA0	; 160
    16c4:	af 2e       	mov	r10, r31
    16c6:	f0 2d       	mov	r31, r0
    16c8:	0f 2e       	mov	r0, r31
    16ca:	f5 e2       	ldi	r31, 0x25	; 37
    16cc:	bf 2e       	mov	r11, r31
    16ce:	f0 2d       	mov	r31, r0
    16d0:	0f 2e       	mov	r0, r31
    16d2:	f6 e2       	ldi	r31, 0x26	; 38
    16d4:	cf 2e       	mov	r12, r31
    16d6:	f0 2d       	mov	r31, r0
    16d8:	dd 24       	eor	r13, r13
    16da:	ee 24       	eor	r14, r14
    16dc:	ff 24       	eor	r15, r15
    16de:	00 e0       	ldi	r16, 0x00	; 0
    16e0:	10 e0       	ldi	r17, 0x00	; 0
    16e2:	0e 94 70 51 	call	0xa2e0	; 0xa2e0 <__muldi3>
    16e6:	22 2e       	mov	r2, r18
    16e8:	33 2e       	mov	r3, r19
    16ea:	44 2e       	mov	r4, r20
    16ec:	55 2e       	mov	r5, r21
    16ee:	66 2e       	mov	r6, r22
    16f0:	77 2e       	mov	r7, r23
    16f2:	88 2e       	mov	r8, r24
    16f4:	99 2e       	mov	r9, r25
    16f6:	a2 2c       	mov	r10, r2
    16f8:	b3 2c       	mov	r11, r3
    16fa:	c4 2c       	mov	r12, r4
    16fc:	d5 2c       	mov	r13, r5
    16fe:	e6 2c       	mov	r14, r6
    1700:	f7 2c       	mov	r15, r7
    1702:	08 2d       	mov	r16, r8
    1704:	19 2d       	mov	r17, r9
    1706:	2a 2d       	mov	r18, r10
    1708:	3b 2d       	mov	r19, r11
    170a:	4c 2d       	mov	r20, r12
    170c:	5d 2d       	mov	r21, r13
    170e:	6e 2d       	mov	r22, r14
    1710:	7f 2d       	mov	r23, r15
    1712:	80 2f       	mov	r24, r16
    1714:	91 2f       	mov	r25, r17
    1716:	aa 24       	eor	r10, r10
    1718:	aa 94       	dec	r10
    171a:	bb 24       	eor	r11, r11
    171c:	ba 94       	dec	r11
    171e:	0f 2e       	mov	r0, r31
    1720:	ff e7       	ldi	r31, 0x7F	; 127
    1722:	cf 2e       	mov	r12, r31
    1724:	f0 2d       	mov	r31, r0
    1726:	dd 24       	eor	r13, r13
    1728:	ee 24       	eor	r14, r14
    172a:	ff 24       	eor	r15, r15
    172c:	00 e0       	ldi	r16, 0x00	; 0
    172e:	10 e0       	ldi	r17, 0x00	; 0
    1730:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    1734:	22 2e       	mov	r2, r18
    1736:	33 2e       	mov	r3, r19
    1738:	44 2e       	mov	r4, r20
    173a:	55 2e       	mov	r5, r21
    173c:	66 2e       	mov	r6, r22
    173e:	77 2e       	mov	r7, r23
    1740:	88 2e       	mov	r8, r24
    1742:	99 2e       	mov	r9, r25
    1744:	a2 2c       	mov	r10, r2
    1746:	b3 2c       	mov	r11, r3
    1748:	c4 2c       	mov	r12, r4
    174a:	d5 2c       	mov	r13, r5
    174c:	e6 2c       	mov	r14, r6
    174e:	f7 2c       	mov	r15, r7
    1750:	08 2d       	mov	r16, r8
    1752:	19 2d       	mov	r17, r9
    1754:	2a 2d       	mov	r18, r10
    1756:	3b 2d       	mov	r19, r11
    1758:	4c 2d       	mov	r20, r12
    175a:	5d 2d       	mov	r21, r13
    175c:	6e 2d       	mov	r22, r14
    175e:	7f 2d       	mov	r23, r15
    1760:	80 2f       	mov	r24, r16
    1762:	91 2f       	mov	r25, r17
    1764:	01 e0       	ldi	r16, 0x01	; 1
    1766:	0e 94 43 52 	call	0xa486	; 0xa486 <__ashldi3>
    176a:	22 2e       	mov	r2, r18
    176c:	33 2e       	mov	r3, r19
    176e:	44 2e       	mov	r4, r20
    1770:	55 2e       	mov	r5, r21
    1772:	66 2e       	mov	r6, r22
    1774:	77 2e       	mov	r7, r23
    1776:	88 2e       	mov	r8, r24
    1778:	99 2e       	mov	r9, r25
    177a:	a2 2c       	mov	r10, r2
    177c:	b3 2c       	mov	r11, r3
    177e:	c4 2c       	mov	r12, r4
    1780:	d5 2c       	mov	r13, r5
    1782:	e6 2c       	mov	r14, r6
    1784:	f7 2c       	mov	r15, r7
    1786:	08 2d       	mov	r16, r8
    1788:	19 2d       	mov	r17, r9
    178a:	2a 2d       	mov	r18, r10
    178c:	3b 2d       	mov	r19, r11
    178e:	4c 2d       	mov	r20, r12
    1790:	5d 2d       	mov	r21, r13
    1792:	6e 2d       	mov	r22, r14
    1794:	7f 2d       	mov	r23, r15
    1796:	80 2f       	mov	r24, r16
    1798:	91 2f       	mov	r25, r17
    179a:	0f 2e       	mov	r0, r31
    179c:	f3 e0       	ldi	r31, 0x03	; 3
    179e:	af 2e       	mov	r10, r31
    17a0:	f0 2d       	mov	r31, r0
    17a2:	bb 24       	eor	r11, r11
    17a4:	cc 24       	eor	r12, r12
    17a6:	dd 24       	eor	r13, r13
    17a8:	ee 24       	eor	r14, r14
    17aa:	ff 24       	eor	r15, r15
    17ac:	00 e0       	ldi	r16, 0x00	; 0
    17ae:	10 e0       	ldi	r17, 0x00	; 0
    17b0:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    17b4:	a2 2e       	mov	r10, r18
    17b6:	b3 2e       	mov	r11, r19
    17b8:	c4 2e       	mov	r12, r20
    17ba:	d5 2e       	mov	r13, r21
    17bc:	e6 2e       	mov	r14, r22
    17be:	f7 2e       	mov	r15, r23
    17c0:	08 2f       	mov	r16, r24
    17c2:	19 2f       	mov	r17, r25
    17c4:	2a 2d       	mov	r18, r10
    17c6:	3b 2d       	mov	r19, r11
    17c8:	4c 2d       	mov	r20, r12
    17ca:	5d 2d       	mov	r21, r13
    17cc:	6e 2d       	mov	r22, r14
    17ce:	7f 2d       	mov	r23, r15
    17d0:	80 2f       	mov	r24, r16
    17d2:	91 2f       	mov	r25, r17
    17d4:	da 01       	movw	r26, r20
    17d6:	c9 01       	movw	r24, r18
    17d8:	b0 95       	com	r27
    17da:	a0 95       	com	r26
    17dc:	90 95       	com	r25
    17de:	81 95       	neg	r24
    17e0:	9f 4f       	sbci	r25, 0xFF	; 255
    17e2:	af 4f       	sbci	r26, 0xFF	; 255
    17e4:	bf 4f       	sbci	r27, 0xFF	; 255
    17e6:	29 a5       	lds	r18, 0x69
    17e8:	3a a5       	lds	r19, 0x6a
    17ea:	f9 01       	movw	r30, r18
    17ec:	80 83       	st	Z, r24
    17ee:	91 83       	std	Z+1, r25	; 0x01
    17f0:	a2 83       	std	Z+2, r26	; 0x02
    17f2:	b3 83       	std	Z+3, r27	; 0x03
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    17f4:	29 85       	ldd	r18, Y+9	; 0x09
    17f6:	3a 85       	ldd	r19, Y+10	; 0x0a
    17f8:	4b 85       	ldd	r20, Y+11	; 0x0b
    17fa:	5c 85       	ldd	r21, Y+12	; 0x0c
    17fc:	6d 85       	ldd	r22, Y+13	; 0x0d
    17fe:	7e 85       	ldd	r23, Y+14	; 0x0e
    1800:	8f 85       	ldd	r24, Y+15	; 0x0f
    1802:	98 89       	ldd	r25, Y+16	; 0x10
    1804:	0f 2e       	mov	r0, r31
    1806:	f0 ea       	ldi	r31, 0xA0	; 160
    1808:	af 2e       	mov	r10, r31
    180a:	f0 2d       	mov	r31, r0
    180c:	0f 2e       	mov	r0, r31
    180e:	f5 e2       	ldi	r31, 0x25	; 37
    1810:	bf 2e       	mov	r11, r31
    1812:	f0 2d       	mov	r31, r0
    1814:	0f 2e       	mov	r0, r31
    1816:	f6 e2       	ldi	r31, 0x26	; 38
    1818:	cf 2e       	mov	r12, r31
    181a:	f0 2d       	mov	r31, r0
    181c:	dd 24       	eor	r13, r13
    181e:	ee 24       	eor	r14, r14
    1820:	ff 24       	eor	r15, r15
    1822:	00 e0       	ldi	r16, 0x00	; 0
    1824:	10 e0       	ldi	r17, 0x00	; 0
    1826:	0e 94 70 51 	call	0xa2e0	; 0xa2e0 <__muldi3>
    182a:	22 2e       	mov	r2, r18
    182c:	33 2e       	mov	r3, r19
    182e:	44 2e       	mov	r4, r20
    1830:	55 2e       	mov	r5, r21
    1832:	66 2e       	mov	r6, r22
    1834:	77 2e       	mov	r7, r23
    1836:	88 2e       	mov	r8, r24
    1838:	99 2e       	mov	r9, r25
    183a:	a2 2c       	mov	r10, r2
    183c:	b3 2c       	mov	r11, r3
    183e:	c4 2c       	mov	r12, r4
    1840:	d5 2c       	mov	r13, r5
    1842:	e6 2c       	mov	r14, r6
    1844:	f7 2c       	mov	r15, r7
    1846:	08 2d       	mov	r16, r8
    1848:	19 2d       	mov	r17, r9
    184a:	2a 2d       	mov	r18, r10
    184c:	3b 2d       	mov	r19, r11
    184e:	4c 2d       	mov	r20, r12
    1850:	5d 2d       	mov	r21, r13
    1852:	6e 2d       	mov	r22, r14
    1854:	7f 2d       	mov	r23, r15
    1856:	80 2f       	mov	r24, r16
    1858:	91 2f       	mov	r25, r17
    185a:	aa 24       	eor	r10, r10
    185c:	aa 94       	dec	r10
    185e:	bb 24       	eor	r11, r11
    1860:	ba 94       	dec	r11
    1862:	0f 2e       	mov	r0, r31
    1864:	ff e7       	ldi	r31, 0x7F	; 127
    1866:	cf 2e       	mov	r12, r31
    1868:	f0 2d       	mov	r31, r0
    186a:	dd 24       	eor	r13, r13
    186c:	ee 24       	eor	r14, r14
    186e:	ff 24       	eor	r15, r15
    1870:	00 e0       	ldi	r16, 0x00	; 0
    1872:	10 e0       	ldi	r17, 0x00	; 0
    1874:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    1878:	22 2e       	mov	r2, r18
    187a:	33 2e       	mov	r3, r19
    187c:	44 2e       	mov	r4, r20
    187e:	55 2e       	mov	r5, r21
    1880:	66 2e       	mov	r6, r22
    1882:	77 2e       	mov	r7, r23
    1884:	88 2e       	mov	r8, r24
    1886:	99 2e       	mov	r9, r25
    1888:	a2 2c       	mov	r10, r2
    188a:	b3 2c       	mov	r11, r3
    188c:	c4 2c       	mov	r12, r4
    188e:	d5 2c       	mov	r13, r5
    1890:	e6 2c       	mov	r14, r6
    1892:	f7 2c       	mov	r15, r7
    1894:	08 2d       	mov	r16, r8
    1896:	19 2d       	mov	r17, r9
    1898:	2a 2d       	mov	r18, r10
    189a:	3b 2d       	mov	r19, r11
    189c:	4c 2d       	mov	r20, r12
    189e:	5d 2d       	mov	r21, r13
    18a0:	6e 2d       	mov	r22, r14
    18a2:	7f 2d       	mov	r23, r15
    18a4:	80 2f       	mov	r24, r16
    18a6:	91 2f       	mov	r25, r17
    18a8:	01 e0       	ldi	r16, 0x01	; 1
    18aa:	0e 94 43 52 	call	0xa486	; 0xa486 <__ashldi3>
    18ae:	22 2e       	mov	r2, r18
    18b0:	33 2e       	mov	r3, r19
    18b2:	44 2e       	mov	r4, r20
    18b4:	55 2e       	mov	r5, r21
    18b6:	66 2e       	mov	r6, r22
    18b8:	77 2e       	mov	r7, r23
    18ba:	88 2e       	mov	r8, r24
    18bc:	99 2e       	mov	r9, r25
    18be:	a2 2c       	mov	r10, r2
    18c0:	b3 2c       	mov	r11, r3
    18c2:	c4 2c       	mov	r12, r4
    18c4:	d5 2c       	mov	r13, r5
    18c6:	e6 2c       	mov	r14, r6
    18c8:	f7 2c       	mov	r15, r7
    18ca:	08 2d       	mov	r16, r8
    18cc:	19 2d       	mov	r17, r9
    18ce:	2a 2d       	mov	r18, r10
    18d0:	3b 2d       	mov	r19, r11
    18d2:	4c 2d       	mov	r20, r12
    18d4:	5d 2d       	mov	r21, r13
    18d6:	6e 2d       	mov	r22, r14
    18d8:	7f 2d       	mov	r23, r15
    18da:	80 2f       	mov	r24, r16
    18dc:	91 2f       	mov	r25, r17
    18de:	0f 2e       	mov	r0, r31
    18e0:	f3 e0       	ldi	r31, 0x03	; 3
    18e2:	af 2e       	mov	r10, r31
    18e4:	f0 2d       	mov	r31, r0
    18e6:	bb 24       	eor	r11, r11
    18e8:	cc 24       	eor	r12, r12
    18ea:	dd 24       	eor	r13, r13
    18ec:	ee 24       	eor	r14, r14
    18ee:	ff 24       	eor	r15, r15
    18f0:	00 e0       	ldi	r16, 0x00	; 0
    18f2:	10 e0       	ldi	r17, 0x00	; 0
    18f4:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    18f8:	a2 2e       	mov	r10, r18
    18fa:	b3 2e       	mov	r11, r19
    18fc:	c4 2e       	mov	r12, r20
    18fe:	d5 2e       	mov	r13, r21
    1900:	e6 2e       	mov	r14, r22
    1902:	f7 2e       	mov	r15, r23
    1904:	08 2f       	mov	r16, r24
    1906:	19 2f       	mov	r17, r25
    1908:	2a 2d       	mov	r18, r10
    190a:	3b 2d       	mov	r19, r11
    190c:	4c 2d       	mov	r20, r12
    190e:	5d 2d       	mov	r21, r13
    1910:	6e 2d       	mov	r22, r14
    1912:	7f 2d       	mov	r23, r15
    1914:	80 2f       	mov	r24, r16
    1916:	91 2f       	mov	r25, r17
    1918:	da 01       	movw	r26, r20
    191a:	c9 01       	movw	r24, r18
    191c:	b0 95       	com	r27
    191e:	a0 95       	com	r26
    1920:	90 95       	com	r25
    1922:	81 95       	neg	r24
    1924:	9f 4f       	sbci	r25, 0xFF	; 255
    1926:	af 4f       	sbci	r26, 0xFF	; 255
    1928:	bf 4f       	sbci	r27, 0xFF	; 255
    192a:	2f a1       	lds	r18, 0x4f
    192c:	38 a5       	lds	r19, 0x68
    192e:	f9 01       	movw	r30, r18
    1930:	80 83       	st	Z, r24
    1932:	91 83       	std	Z+1, r25	; 0x01
    1934:	a2 83       	std	Z+2, r26	; 0x02
    1936:	b3 83       	std	Z+3, r27	; 0x03

}
    1938:	ec 96       	adiw	r28, 0x3c	; 60
    193a:	cd bf       	out	0x3d, r28	; 61
    193c:	de bf       	out	0x3e, r29	; 62
    193e:	df 91       	pop	r29
    1940:	cf 91       	pop	r28
    1942:	1f 91       	pop	r17
    1944:	0f 91       	pop	r16
    1946:	ff 90       	pop	r15
    1948:	ef 90       	pop	r14
    194a:	df 90       	pop	r13
    194c:	cf 90       	pop	r12
    194e:	bf 90       	pop	r11
    1950:	af 90       	pop	r10
    1952:	9f 90       	pop	r9
    1954:	8f 90       	pop	r8
    1956:	7f 90       	pop	r7
    1958:	6f 90       	pop	r6
    195a:	5f 90       	pop	r5
    195c:	4f 90       	pop	r4
    195e:	3f 90       	pop	r3
    1960:	2f 90       	pop	r2
    1962:	08 95       	ret

00001964 <CO_collectADC_cont>:

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1964:	cf 93       	push	r28
    1966:	df 93       	push	r29
    1968:	00 d0       	rcall	.+0      	; 0x196a <CO_collectADC_cont+0x6>
    196a:	00 d0       	rcall	.+0      	; 0x196c <CO_collectADC_cont+0x8>
    196c:	cd b7       	in	r28, 0x3d	; 61
    196e:	de b7       	in	r29, 0x3e	; 62
    1970:	8b 83       	std	Y+3, r24	; 0x03
    1972:	6c 83       	std	Y+4, r22	; 0x04
    1974:	4d 83       	std	Y+5, r20	; 0x05
    1976:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
//get data to write files to SD card
getBootSectorData();
    197e:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <getBootSectorData>
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	6d 81       	ldd	r22, Y+5	; 0x05
    1986:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
set_filter(filterConfig);
    198a:	8c 81       	ldd	r24, Y+4	; 0x04
    198c:	0e 94 1f 07 	call	0xe3e	; 0xe3e <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1990:	8b 81       	ldd	r24, Y+3	; 0x03
    1992:	85 30       	cpi	r24, 0x05	; 5
    1994:	31 f0       	breq	.+12     	; 0x19a2 <CO_collectADC_cont+0x3e>
    1996:	8b 81       	ldd	r24, Y+3	; 0x03
    1998:	86 30       	cpi	r24, 0x06	; 6
    199a:	19 f0       	breq	.+6      	; 0x19a2 <CO_collectADC_cont+0x3e>
    199c:	8b 81       	ldd	r24, Y+3	; 0x03
    199e:	87 30       	cpi	r24, 0x07	; 7
    19a0:	19 f4       	brne	.+6      	; 0x19a8 <CO_collectADC_cont+0x44>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    19a2:	81 e0       	ldi	r24, 0x01	; 1
    19a4:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
setADCInput(channel);
    19ae:	8b 81       	ldd	r24, Y+3	; 0x03
    19b0:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <setADCInput>
SPIInit(SPI_MODE_1_gc);
    19b4:	84 e0       	ldi	r24, 0x04	; 4
    19b6:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    19ba:	80 ec       	ldi	r24, 0xC0	; 192
    19bc:	98 e0       	ldi	r25, 0x08	; 8
    19be:	24 e5       	ldi	r18, 0x54	; 84
    19c0:	fc 01       	movw	r30, r24
    19c2:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    19c4:	80 ea       	ldi	r24, 0xA0	; 160
    19c6:	96 e0       	ldi	r25, 0x06	; 6
    19c8:	21 e0       	ldi	r18, 0x01	; 1
    19ca:	fc 01       	movw	r30, r24
    19cc:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    19ce:	80 ea       	ldi	r24, 0xA0	; 160
    19d0:	96 e0       	ldi	r25, 0x06	; 6
    19d2:	22 e0       	ldi	r18, 0x02	; 2
    19d4:	fc 01       	movw	r30, r24
    19d6:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    19d8:	80 ea       	ldi	r24, 0xA0	; 160
    19da:	96 e0       	ldi	r25, 0x06	; 6
    19dc:	21 e0       	ldi	r18, 0x01	; 1
    19de:	fc 01       	movw	r30, r24
    19e0:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_LO_gc;
    19e2:	80 ea       	ldi	r24, 0xA0	; 160
    19e4:	96 e0       	ldi	r25, 0x06	; 6
    19e6:	24 e0       	ldi	r18, 0x04	; 4
    19e8:	fc 01       	movw	r30, r24
    19ea:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    19ec:	80 e8       	ldi	r24, 0x80	; 128
    19ee:	96 e0       	ldi	r25, 0x06	; 6
    19f0:	20 e2       	ldi	r18, 0x20	; 32
    19f2:	fc 01       	movw	r30, r24
    19f4:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    19f6:	80 e4       	ldi	r24, 0x40	; 64
    19f8:	9a e0       	ldi	r25, 0x0A	; 10
    19fa:	23 e2       	ldi	r18, 0x23	; 35
    19fc:	fc 01       	movw	r30, r24
    19fe:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1a00:	8e 81       	ldd	r24, Y+6	; 0x06
    1a02:	88 2f       	mov	r24, r24
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	25 e1       	ldi	r18, 0x15	; 21
    1a08:	30 e0       	ldi	r19, 0x00	; 0
    1a0a:	28 1b       	sub	r18, r24
    1a0c:	39 0b       	sbc	r19, r25
    1a0e:	81 e0       	ldi	r24, 0x01	; 1
    1a10:	90 e0       	ldi	r25, 0x00	; 0
    1a12:	02 c0       	rjmp	.+4      	; 0x1a18 <CO_collectADC_cont+0xb4>
    1a14:	88 0f       	add	r24, r24
    1a16:	99 1f       	adc	r25, r25
    1a18:	2a 95       	dec	r18
    1a1a:	e2 f7       	brpl	.-8      	; 0x1a14 <CO_collectADC_cont+0xb0>
    1a1c:	01 97       	sbiw	r24, 0x01	; 1
    1a1e:	89 83       	std	Y+1, r24	; 0x01
    1a20:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1a22:	80 e4       	ldi	r24, 0x40	; 64
    1a24:	9a e0       	ldi	r25, 0x0A	; 10
    1a26:	29 81       	ldd	r18, Y+1	; 0x01
    1a28:	3a 81       	ldd	r19, Y+2	; 0x02
    1a2a:	fc 01       	movw	r30, r24
    1a2c:	26 a3       	lds	r18, 0x56
    1a2e:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1a30:	80 e4       	ldi	r24, 0x40	; 64
    1a32:	9a e0       	ldi	r25, 0x0A	; 10
    1a34:	29 81       	ldd	r18, Y+1	; 0x01
    1a36:	3a 81       	ldd	r19, Y+2	; 0x02
    1a38:	36 95       	lsr	r19
    1a3a:	27 95       	ror	r18
    1a3c:	fc 01       	movw	r30, r24
    1a3e:	22 af       	sts	0x72, r18
    1a40:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1a42:	80 e4       	ldi	r24, 0x40	; 64
    1a44:	9a e0       	ldi	r25, 0x0A	; 10
    1a46:	20 e4       	ldi	r18, 0x40	; 64
    1a48:	3a e0       	ldi	r19, 0x0A	; 10
    1a4a:	f9 01       	movw	r30, r18
    1a4c:	20 81       	ld	r18, Z
    1a4e:	20 7f       	andi	r18, 0xF0	; 240
    1a50:	21 60       	ori	r18, 0x01	; 1
    1a52:	fc 01       	movw	r30, r24
    1a54:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1a56:	80 ea       	ldi	r24, 0xA0	; 160
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	20 ea       	ldi	r18, 0xA0	; 160
    1a5c:	30 e0       	ldi	r19, 0x00	; 0
    1a5e:	f9 01       	movw	r30, r18
    1a60:	22 81       	ldd	r18, Z+2	; 0x02
    1a62:	21 60       	ori	r18, 0x01	; 1
    1a64:	fc 01       	movw	r30, r24
    1a66:	22 83       	std	Z+2, r18	; 0x02
sei();
    1a68:	78 94       	sei

sampleCount = 0;
    1a6a:	10 92 52 50 	sts	0x5052, r1
    1a6e:	10 92 53 50 	sts	0x5053, r1
TotalSampleCount = 0;
    1a72:	10 92 7e 50 	sts	0x507E, r1
    1a76:	10 92 7f 50 	sts	0x507F, r1
discardCount = 0;
    1a7a:	10 92 3e 40 	sts	0x403E, r1
}
    1a7e:	26 96       	adiw	r28, 0x06	; 6
    1a80:	cd bf       	out	0x3d, r28	; 61
    1a82:	de bf       	out	0x3e, r29	; 62
    1a84:	df 91       	pop	r29
    1a86:	cf 91       	pop	r28
    1a88:	08 95       	ret

00001a8a <ADC_Stop_Sampling>:


void ADC_Stop_Sampling(){
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
    1a8e:	cd b7       	in	r28, 0x3d	; 61
    1a90:	de b7       	in	r29, 0x3e	; 62
		PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS high
    1a92:	88 e0       	ldi	r24, 0x08	; 8
    1a94:	60 e0       	ldi	r22, 0x00	; 0
    1a96:	0e 94 2f 34 	call	0x685e	; 0x685e <PortEx_DIRCLR>
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);
    1a9a:	88 e0       	ldi	r24, 0x08	; 8
    1a9c:	60 e0       	ldi	r22, 0x00	; 0
    1a9e:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
	
}
    1aa2:	df 91       	pop	r29
    1aa4:	cf 91       	pop	r28
    1aa6:	08 95       	ret

00001aa8 <__vector_105>:
ISR(PORTF_INT1_vect) {
    1aa8:	1f 92       	push	r1
    1aaa:	0f 92       	push	r0
    1aac:	0f b6       	in	r0, 0x3f	; 63
    1aae:	0f 92       	push	r0
    1ab0:	00 90 3b 00 	lds	r0, 0x003B
    1ab4:	0f 92       	push	r0
    1ab6:	11 24       	eor	r1, r1
    1ab8:	2f 92       	push	r2
    1aba:	3f 92       	push	r3
    1abc:	4f 92       	push	r4
    1abe:	5f 92       	push	r5
    1ac0:	6f 92       	push	r6
    1ac2:	7f 92       	push	r7
    1ac4:	8f 92       	push	r8
    1ac6:	9f 92       	push	r9
    1ac8:	af 92       	push	r10
    1aca:	bf 92       	push	r11
    1acc:	cf 92       	push	r12
    1ace:	df 92       	push	r13
    1ad0:	ef 92       	push	r14
    1ad2:	ff 92       	push	r15
    1ad4:	0f 93       	push	r16
    1ad6:	1f 93       	push	r17
    1ad8:	2f 93       	push	r18
    1ada:	3f 93       	push	r19
    1adc:	4f 93       	push	r20
    1ade:	5f 93       	push	r21
    1ae0:	6f 93       	push	r22
    1ae2:	7f 93       	push	r23
    1ae4:	8f 93       	push	r24
    1ae6:	9f 93       	push	r25
    1ae8:	af 93       	push	r26
    1aea:	bf 93       	push	r27
    1aec:	ef 93       	push	r30
    1aee:	ff 93       	push	r31
    1af0:	cf 93       	push	r28
    1af2:	df 93       	push	r29
    1af4:	00 d0       	rcall	.+0      	; 0x1af6 <__vector_105+0x4e>
    1af6:	cd b7       	in	r28, 0x3d	; 61
    1af8:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if(TotalSampleCount>=10){
    1afa:	80 91 7e 50 	lds	r24, 0x507E
    1afe:	90 91 7f 50 	lds	r25, 0x507F
    1b02:	8a 30       	cpi	r24, 0x0A	; 10
    1b04:	91 05       	cpc	r25, r1
    1b06:	20 f0       	brcs	.+8      	; 0x1b10 <__vector_105+0x68>
		SD_disable();
    1b08:	0e 94 d3 50 	call	0xa1a6	; 0xa1a6 <SD_disable>
		while(1){
			nop();
    1b0c:	00 00       	nop
		}		
    1b0e:	fe cf       	rjmp	.-4      	; 0x1b0c <__vector_105+0x64>
	}		
	if (discardCount < ADC_DISCARD) {
    1b10:	80 91 3e 40 	lds	r24, 0x403E
    1b14:	88 23       	and	r24, r24
    1b16:	34 f0       	brlt	.+12     	; 0x1b24 <__vector_105+0x7c>
		discardCount++;
    1b18:	80 91 3e 40 	lds	r24, 0x403E
    1b1c:	8f 5f       	subi	r24, 0xFF	; 255
    1b1e:	80 93 3e 40 	sts	0x403E, r24
    1b22:	58 c1       	rjmp	.+688    	; 0x1dd4 <__vector_105+0x32c>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1b24:	84 e0       	ldi	r24, 0x04	; 4
    1b26:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1b2a:	80 ec       	ldi	r24, 0xC0	; 192
    1b2c:	98 e0       	ldi	r25, 0x08	; 8
    1b2e:	24 e5       	ldi	r18, 0x54	; 84
    1b30:	fc 01       	movw	r30, r24
    1b32:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1b3a:	80 ea       	ldi	r24, 0xA0	; 160
    1b3c:	96 e0       	ldi	r25, 0x06	; 6
    1b3e:	22 e0       	ldi	r18, 0x02	; 2
    1b40:	fc 01       	movw	r30, r24
    1b42:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1b44:	19 82       	std	Y+1, r1	; 0x01
    1b46:	1a c0       	rjmp	.+52     	; 0x1b7c <__vector_105+0xd4>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1b48:	80 ec       	ldi	r24, 0xC0	; 192
    1b4a:	98 e0       	ldi	r25, 0x08	; 8
    1b4c:	2a ea       	ldi	r18, 0xAA	; 170
    1b4e:	fc 01       	movw	r30, r24
    1b50:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1b52:	00 00       	nop
    1b54:	80 ec       	ldi	r24, 0xC0	; 192
    1b56:	98 e0       	ldi	r25, 0x08	; 8
    1b58:	fc 01       	movw	r30, r24
    1b5a:	82 81       	ldd	r24, Z+2	; 0x02
    1b5c:	88 23       	and	r24, r24
    1b5e:	d4 f7       	brge	.-12     	; 0x1b54 <__vector_105+0xac>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1b60:	89 81       	ldd	r24, Y+1	; 0x01
    1b62:	88 2f       	mov	r24, r24
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	20 ec       	ldi	r18, 0xC0	; 192
    1b68:	38 e0       	ldi	r19, 0x08	; 8
    1b6a:	f9 01       	movw	r30, r18
    1b6c:	23 81       	ldd	r18, Z+3	; 0x03
    1b6e:	8b 5b       	subi	r24, 0xBB	; 187
    1b70:	9f 4a       	sbci	r25, 0xAF	; 175
    1b72:	fc 01       	movw	r30, r24
    1b74:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1b76:	89 81       	ldd	r24, Y+1	; 0x01
    1b78:	8f 5f       	subi	r24, 0xFF	; 255
    1b7a:	89 83       	std	Y+1, r24	; 0x01
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	83 30       	cpi	r24, 0x03	; 3
    1b80:	18 f3       	brcs	.-58     	; 0x1b48 <__vector_105+0xa0>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1b82:	80 ea       	ldi	r24, 0xA0	; 160
    1b84:	96 e0       	ldi	r25, 0x06	; 6
    1b86:	22 e0       	ldi	r18, 0x02	; 2
    1b88:	fc 01       	movw	r30, r24
    1b8a:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
    1b8e:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1b92:	80 91 45 50 	lds	r24, 0x5045
    1b96:	88 23       	and	r24, r24
    1b98:	34 f4       	brge	.+12     	; 0x1ba6 <__vector_105+0xfe>
    1b9a:	86 e4       	ldi	r24, 0x46	; 70
    1b9c:	90 e4       	ldi	r25, 0x40	; 64
    1b9e:	2f ef       	ldi	r18, 0xFF	; 255
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	20 83       	st	Z, r18
    1ba4:	04 c0       	rjmp	.+8      	; 0x1bae <__vector_105+0x106>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    1ba6:	86 e4       	ldi	r24, 0x46	; 70
    1ba8:	90 e4       	ldi	r25, 0x40	; 64
    1baa:	fc 01       	movw	r30, r24
    1bac:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1bae:	85 e4       	ldi	r24, 0x45	; 69
    1bb0:	90 e4       	ldi	r25, 0x40	; 64
    1bb2:	20 91 45 50 	lds	r18, 0x5045
    1bb6:	fc 01       	movw	r30, r24
    1bb8:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1bba:	84 e4       	ldi	r24, 0x44	; 68
    1bbc:	90 e4       	ldi	r25, 0x40	; 64
    1bbe:	20 91 46 50 	lds	r18, 0x5046
    1bc2:	fc 01       	movw	r30, r24
    1bc4:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    1bc6:	83 e4       	ldi	r24, 0x43	; 67
    1bc8:	90 e4       	ldi	r25, 0x40	; 64
    1bca:	20 91 47 50 	lds	r18, 0x5047
    1bce:	fc 01       	movw	r30, r24
    1bd0:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    1bd2:	80 91 43 40 	lds	r24, 0x4043
    1bd6:	90 91 44 40 	lds	r25, 0x4044
    1bda:	a0 91 45 40 	lds	r26, 0x4045
    1bde:	b0 91 46 40 	lds	r27, 0x4046
    1be2:	5c 01       	movw	r10, r24
    1be4:	6d 01       	movw	r12, r26
    1be6:	bb 0f       	add	r27, r27
    1be8:	88 0b       	sbc	r24, r24
    1bea:	98 2f       	mov	r25, r24
    1bec:	dc 01       	movw	r26, r24
    1bee:	e8 2e       	mov	r14, r24
    1bf0:	f8 2e       	mov	r15, r24
    1bf2:	08 2f       	mov	r16, r24
    1bf4:	18 2f       	mov	r17, r24
    1bf6:	a0 92 80 50 	sts	0x5080, r10
    1bfa:	b0 92 81 50 	sts	0x5081, r11
    1bfe:	c0 92 82 50 	sts	0x5082, r12
    1c02:	d0 92 83 50 	sts	0x5083, r13
    1c06:	e0 92 84 50 	sts	0x5084, r14
    1c0a:	f0 92 85 50 	sts	0x5085, r15
    1c0e:	00 93 86 50 	sts	0x5086, r16
    1c12:	10 93 87 50 	sts	0x5087, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1c16:	80 91 52 50 	lds	r24, 0x5052
    1c1a:	90 91 53 50 	lds	r25, 0x5053
    1c1e:	88 0f       	add	r24, r24
    1c20:	99 1f       	adc	r25, r25
    1c22:	88 0f       	add	r24, r24
    1c24:	99 1f       	adc	r25, r25
    1c26:	9c 01       	movw	r18, r24
    1c28:	20 54       	subi	r18, 0x40	; 64
    1c2a:	3c 4d       	sbci	r19, 0xDC	; 220
    1c2c:	2a 83       	std	Y+2, r18	; 0x02
    1c2e:	3b 83       	std	Y+3, r19	; 0x03
    1c30:	a0 90 80 50 	lds	r10, 0x5080
    1c34:	b0 90 81 50 	lds	r11, 0x5081
    1c38:	c0 90 82 50 	lds	r12, 0x5082
    1c3c:	d0 90 83 50 	lds	r13, 0x5083
    1c40:	e0 90 84 50 	lds	r14, 0x5084
    1c44:	f0 90 85 50 	lds	r15, 0x5085
    1c48:	00 91 86 50 	lds	r16, 0x5086
    1c4c:	10 91 87 50 	lds	r17, 0x5087
    1c50:	2a 2d       	mov	r18, r10
    1c52:	3b 2d       	mov	r19, r11
    1c54:	4c 2d       	mov	r20, r12
    1c56:	5d 2d       	mov	r21, r13
    1c58:	6e 2d       	mov	r22, r14
    1c5a:	7f 2d       	mov	r23, r15
    1c5c:	80 2f       	mov	r24, r16
    1c5e:	91 2f       	mov	r25, r17
    1c60:	0f 2e       	mov	r0, r31
    1c62:	f0 ea       	ldi	r31, 0xA0	; 160
    1c64:	af 2e       	mov	r10, r31
    1c66:	f0 2d       	mov	r31, r0
    1c68:	0f 2e       	mov	r0, r31
    1c6a:	f5 e2       	ldi	r31, 0x25	; 37
    1c6c:	bf 2e       	mov	r11, r31
    1c6e:	f0 2d       	mov	r31, r0
    1c70:	0f 2e       	mov	r0, r31
    1c72:	f6 e2       	ldi	r31, 0x26	; 38
    1c74:	cf 2e       	mov	r12, r31
    1c76:	f0 2d       	mov	r31, r0
    1c78:	dd 24       	eor	r13, r13
    1c7a:	ee 24       	eor	r14, r14
    1c7c:	ff 24       	eor	r15, r15
    1c7e:	00 e0       	ldi	r16, 0x00	; 0
    1c80:	10 e0       	ldi	r17, 0x00	; 0
    1c82:	0e 94 70 51 	call	0xa2e0	; 0xa2e0 <__muldi3>
    1c86:	22 2e       	mov	r2, r18
    1c88:	33 2e       	mov	r3, r19
    1c8a:	44 2e       	mov	r4, r20
    1c8c:	55 2e       	mov	r5, r21
    1c8e:	66 2e       	mov	r6, r22
    1c90:	77 2e       	mov	r7, r23
    1c92:	88 2e       	mov	r8, r24
    1c94:	99 2e       	mov	r9, r25
    1c96:	a2 2c       	mov	r10, r2
    1c98:	b3 2c       	mov	r11, r3
    1c9a:	c4 2c       	mov	r12, r4
    1c9c:	d5 2c       	mov	r13, r5
    1c9e:	e6 2c       	mov	r14, r6
    1ca0:	f7 2c       	mov	r15, r7
    1ca2:	08 2d       	mov	r16, r8
    1ca4:	19 2d       	mov	r17, r9
    1ca6:	2a 2d       	mov	r18, r10
    1ca8:	3b 2d       	mov	r19, r11
    1caa:	4c 2d       	mov	r20, r12
    1cac:	5d 2d       	mov	r21, r13
    1cae:	6e 2d       	mov	r22, r14
    1cb0:	7f 2d       	mov	r23, r15
    1cb2:	80 2f       	mov	r24, r16
    1cb4:	91 2f       	mov	r25, r17
    1cb6:	aa 24       	eor	r10, r10
    1cb8:	aa 94       	dec	r10
    1cba:	bb 24       	eor	r11, r11
    1cbc:	ba 94       	dec	r11
    1cbe:	0f 2e       	mov	r0, r31
    1cc0:	ff e7       	ldi	r31, 0x7F	; 127
    1cc2:	cf 2e       	mov	r12, r31
    1cc4:	f0 2d       	mov	r31, r0
    1cc6:	dd 24       	eor	r13, r13
    1cc8:	ee 24       	eor	r14, r14
    1cca:	ff 24       	eor	r15, r15
    1ccc:	00 e0       	ldi	r16, 0x00	; 0
    1cce:	10 e0       	ldi	r17, 0x00	; 0
    1cd0:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    1cd4:	22 2e       	mov	r2, r18
    1cd6:	33 2e       	mov	r3, r19
    1cd8:	44 2e       	mov	r4, r20
    1cda:	55 2e       	mov	r5, r21
    1cdc:	66 2e       	mov	r6, r22
    1cde:	77 2e       	mov	r7, r23
    1ce0:	88 2e       	mov	r8, r24
    1ce2:	99 2e       	mov	r9, r25
    1ce4:	a2 2c       	mov	r10, r2
    1ce6:	b3 2c       	mov	r11, r3
    1ce8:	c4 2c       	mov	r12, r4
    1cea:	d5 2c       	mov	r13, r5
    1cec:	e6 2c       	mov	r14, r6
    1cee:	f7 2c       	mov	r15, r7
    1cf0:	08 2d       	mov	r16, r8
    1cf2:	19 2d       	mov	r17, r9
    1cf4:	2a 2d       	mov	r18, r10
    1cf6:	3b 2d       	mov	r19, r11
    1cf8:	4c 2d       	mov	r20, r12
    1cfa:	5d 2d       	mov	r21, r13
    1cfc:	6e 2d       	mov	r22, r14
    1cfe:	7f 2d       	mov	r23, r15
    1d00:	80 2f       	mov	r24, r16
    1d02:	91 2f       	mov	r25, r17
    1d04:	01 e0       	ldi	r16, 0x01	; 1
    1d06:	0e 94 43 52 	call	0xa486	; 0xa486 <__ashldi3>
    1d0a:	22 2e       	mov	r2, r18
    1d0c:	33 2e       	mov	r3, r19
    1d0e:	44 2e       	mov	r4, r20
    1d10:	55 2e       	mov	r5, r21
    1d12:	66 2e       	mov	r6, r22
    1d14:	77 2e       	mov	r7, r23
    1d16:	88 2e       	mov	r8, r24
    1d18:	99 2e       	mov	r9, r25
    1d1a:	a2 2c       	mov	r10, r2
    1d1c:	b3 2c       	mov	r11, r3
    1d1e:	c4 2c       	mov	r12, r4
    1d20:	d5 2c       	mov	r13, r5
    1d22:	e6 2c       	mov	r14, r6
    1d24:	f7 2c       	mov	r15, r7
    1d26:	08 2d       	mov	r16, r8
    1d28:	19 2d       	mov	r17, r9
    1d2a:	2a 2d       	mov	r18, r10
    1d2c:	3b 2d       	mov	r19, r11
    1d2e:	4c 2d       	mov	r20, r12
    1d30:	5d 2d       	mov	r21, r13
    1d32:	6e 2d       	mov	r22, r14
    1d34:	7f 2d       	mov	r23, r15
    1d36:	80 2f       	mov	r24, r16
    1d38:	91 2f       	mov	r25, r17
    1d3a:	0f 2e       	mov	r0, r31
    1d3c:	f3 e0       	ldi	r31, 0x03	; 3
    1d3e:	af 2e       	mov	r10, r31
    1d40:	f0 2d       	mov	r31, r0
    1d42:	bb 24       	eor	r11, r11
    1d44:	cc 24       	eor	r12, r12
    1d46:	dd 24       	eor	r13, r13
    1d48:	ee 24       	eor	r14, r14
    1d4a:	ff 24       	eor	r15, r15
    1d4c:	00 e0       	ldi	r16, 0x00	; 0
    1d4e:	10 e0       	ldi	r17, 0x00	; 0
    1d50:	0e 94 1f 53 	call	0xa63e	; 0xa63e <__divdi3>
    1d54:	a2 2e       	mov	r10, r18
    1d56:	b3 2e       	mov	r11, r19
    1d58:	c4 2e       	mov	r12, r20
    1d5a:	d5 2e       	mov	r13, r21
    1d5c:	e6 2e       	mov	r14, r22
    1d5e:	f7 2e       	mov	r15, r23
    1d60:	08 2f       	mov	r16, r24
    1d62:	19 2f       	mov	r17, r25
    1d64:	2a 2d       	mov	r18, r10
    1d66:	3b 2d       	mov	r19, r11
    1d68:	4c 2d       	mov	r20, r12
    1d6a:	5d 2d       	mov	r21, r13
    1d6c:	6e 2d       	mov	r22, r14
    1d6e:	7f 2d       	mov	r23, r15
    1d70:	80 2f       	mov	r24, r16
    1d72:	91 2f       	mov	r25, r17
    1d74:	da 01       	movw	r26, r20
    1d76:	c9 01       	movw	r24, r18
    1d78:	b0 95       	com	r27
    1d7a:	a0 95       	com	r26
    1d7c:	90 95       	com	r25
    1d7e:	81 95       	neg	r24
    1d80:	9f 4f       	sbci	r25, 0xFF	; 255
    1d82:	af 4f       	sbci	r26, 0xFF	; 255
    1d84:	bf 4f       	sbci	r27, 0xFF	; 255
    1d86:	ea 81       	ldd	r30, Y+2	; 0x02
    1d88:	fb 81       	ldd	r31, Y+3	; 0x03
    1d8a:	80 83       	st	Z, r24
    1d8c:	91 83       	std	Z+1, r25	; 0x01
    1d8e:	a2 83       	std	Z+2, r26	; 0x02
    1d90:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    1d92:	80 91 52 50 	lds	r24, 0x5052
    1d96:	90 91 53 50 	lds	r25, 0x5053
    1d9a:	01 96       	adiw	r24, 0x01	; 1
    1d9c:	80 93 52 50 	sts	0x5052, r24
    1da0:	90 93 53 50 	sts	0x5053, r25
	//after 128 samples, store the data into sd card and reset sample buffer
	if (sampleCount >= 128) { 
    1da4:	80 91 52 50 	lds	r24, 0x5052
    1da8:	90 91 53 50 	lds	r25, 0x5053
    1dac:	80 38       	cpi	r24, 0x80	; 128
    1dae:	91 05       	cpc	r25, r1
    1db0:	88 f0       	brcs	.+34     	; 0x1dd4 <__vector_105+0x32c>
		//SPIInit(SPI_MODE_0_gc);
		//SPICS(TRUE);
		//PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS low
		//PortEx_OUTCLR(BIT3_bm, PS_BANKB);
		//writeFile("samples");
		writeFile("data"); 
    1db2:	80 e0       	ldi	r24, 0x00	; 0
    1db4:	90 e2       	ldi	r25, 0x20	; 32
    1db6:	0e 94 e1 45 	call	0x8bc2	; 0x8bc2 <writeFile>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    1dba:	10 92 52 50 	sts	0x5052, r1
    1dbe:	10 92 53 50 	sts	0x5053, r1
		TotalSampleCount++;
    1dc2:	80 91 7e 50 	lds	r24, 0x507E
    1dc6:	90 91 7f 50 	lds	r25, 0x507F
    1dca:	01 96       	adiw	r24, 0x01	; 1
    1dcc:	80 93 7e 50 	sts	0x507E, r24
    1dd0:	90 93 7f 50 	sts	0x507F, r25
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
	}	
	}	
}
    1dd4:	23 96       	adiw	r28, 0x03	; 3
    1dd6:	cd bf       	out	0x3d, r28	; 61
    1dd8:	de bf       	out	0x3e, r29	; 62
    1dda:	df 91       	pop	r29
    1ddc:	cf 91       	pop	r28
    1dde:	ff 91       	pop	r31
    1de0:	ef 91       	pop	r30
    1de2:	bf 91       	pop	r27
    1de4:	af 91       	pop	r26
    1de6:	9f 91       	pop	r25
    1de8:	8f 91       	pop	r24
    1dea:	7f 91       	pop	r23
    1dec:	6f 91       	pop	r22
    1dee:	5f 91       	pop	r21
    1df0:	4f 91       	pop	r20
    1df2:	3f 91       	pop	r19
    1df4:	2f 91       	pop	r18
    1df6:	1f 91       	pop	r17
    1df8:	0f 91       	pop	r16
    1dfa:	ff 90       	pop	r15
    1dfc:	ef 90       	pop	r14
    1dfe:	df 90       	pop	r13
    1e00:	cf 90       	pop	r12
    1e02:	bf 90       	pop	r11
    1e04:	af 90       	pop	r10
    1e06:	9f 90       	pop	r9
    1e08:	8f 90       	pop	r8
    1e0a:	7f 90       	pop	r7
    1e0c:	6f 90       	pop	r6
    1e0e:	5f 90       	pop	r5
    1e10:	4f 90       	pop	r4
    1e12:	3f 90       	pop	r3
    1e14:	2f 90       	pop	r2
    1e16:	0f 90       	pop	r0
    1e18:	00 92 3b 00 	sts	0x003B, r0
    1e1c:	0f 90       	pop	r0
    1e1e:	0f be       	out	0x3f, r0	; 63
    1e20:	0f 90       	pop	r0
    1e22:	1f 90       	pop	r1
    1e24:	18 95       	reti

00001e26 <__vector_104>:

ISR(PORTF_INT0_vect) {
    1e26:	1f 92       	push	r1
    1e28:	0f 92       	push	r0
    1e2a:	0f b6       	in	r0, 0x3f	; 63
    1e2c:	0f 92       	push	r0
    1e2e:	00 90 3b 00 	lds	r0, 0x003B
    1e32:	0f 92       	push	r0
    1e34:	11 24       	eor	r1, r1
    1e36:	2f 93       	push	r18
    1e38:	3f 93       	push	r19
    1e3a:	4f 93       	push	r20
    1e3c:	5f 93       	push	r21
    1e3e:	6f 93       	push	r22
    1e40:	7f 93       	push	r23
    1e42:	8f 93       	push	r24
    1e44:	9f 93       	push	r25
    1e46:	af 93       	push	r26
    1e48:	bf 93       	push	r27
    1e4a:	ef 93       	push	r30
    1e4c:	ff 93       	push	r31
    1e4e:	cf 93       	push	r28
    1e50:	df 93       	push	r29
    1e52:	0f 92       	push	r0
    1e54:	cd b7       	in	r28, 0x3d	; 61
    1e56:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1e58:	80 91 3e 40 	lds	r24, 0x403E
    1e5c:	88 23       	and	r24, r24
    1e5e:	34 f0       	brlt	.+12     	; 0x1e6c <__vector_104+0x46>
		discardCount++;
    1e60:	80 91 3e 40 	lds	r24, 0x403E
    1e64:	8f 5f       	subi	r24, 0xFF	; 255
    1e66:	80 93 3e 40 	sts	0x403E, r24
    1e6a:	84 c0       	rjmp	.+264    	; 0x1f74 <__vector_104+0x14e>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1e72:	80 ea       	ldi	r24, 0xA0	; 160
    1e74:	96 e0       	ldi	r25, 0x06	; 6
    1e76:	22 e0       	ldi	r18, 0x02	; 2
    1e78:	fc 01       	movw	r30, r24
    1e7a:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1e7c:	19 82       	std	Y+1, r1	; 0x01
    1e7e:	1a c0       	rjmp	.+52     	; 0x1eb4 <__vector_104+0x8e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1e80:	80 ec       	ldi	r24, 0xC0	; 192
    1e82:	98 e0       	ldi	r25, 0x08	; 8
    1e84:	2a ea       	ldi	r18, 0xAA	; 170
    1e86:	fc 01       	movw	r30, r24
    1e88:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1e8a:	00 00       	nop
    1e8c:	80 ec       	ldi	r24, 0xC0	; 192
    1e8e:	98 e0       	ldi	r25, 0x08	; 8
    1e90:	fc 01       	movw	r30, r24
    1e92:	82 81       	ldd	r24, Z+2	; 0x02
    1e94:	88 23       	and	r24, r24
    1e96:	d4 f7       	brge	.-12     	; 0x1e8c <__vector_104+0x66>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	88 2f       	mov	r24, r24
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	20 ec       	ldi	r18, 0xC0	; 192
    1ea0:	38 e0       	ldi	r19, 0x08	; 8
    1ea2:	f9 01       	movw	r30, r18
    1ea4:	23 81       	ldd	r18, Z+3	; 0x03
    1ea6:	8b 5b       	subi	r24, 0xBB	; 187
    1ea8:	9f 4a       	sbci	r25, 0xAF	; 175
    1eaa:	fc 01       	movw	r30, r24
    1eac:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1eae:	89 81       	ldd	r24, Y+1	; 0x01
    1eb0:	8f 5f       	subi	r24, 0xFF	; 255
    1eb2:	89 83       	std	Y+1, r24	; 0x01
    1eb4:	89 81       	ldd	r24, Y+1	; 0x01
    1eb6:	83 30       	cpi	r24, 0x03	; 3
    1eb8:	18 f3       	brcs	.-58     	; 0x1e80 <__vector_104+0x5a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1eba:	80 ea       	ldi	r24, 0xA0	; 160
    1ebc:	96 e0       	ldi	r25, 0x06	; 6
    1ebe:	22 e0       	ldi	r18, 0x02	; 2
    1ec0:	fc 01       	movw	r30, r24
    1ec2:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1ec4:	80 e0       	ldi	r24, 0x00	; 0
    1ec6:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    1eca:	80 91 45 50 	lds	r24, 0x5045
    1ece:	88 23       	and	r24, r24
    1ed0:	7c f4       	brge	.+30     	; 0x1ef0 <__vector_104+0xca>
    1ed2:	80 91 52 50 	lds	r24, 0x5052
    1ed6:	90 91 53 50 	lds	r25, 0x5053
    1eda:	88 0f       	add	r24, r24
    1edc:	99 1f       	adc	r25, r25
    1ede:	88 0f       	add	r24, r24
    1ee0:	99 1f       	adc	r25, r25
    1ee2:	03 96       	adiw	r24, 0x03	; 3
    1ee4:	8d 5b       	subi	r24, 0xBD	; 189
    1ee6:	9f 4b       	sbci	r25, 0xBF	; 191
    1ee8:	2f ef       	ldi	r18, 0xFF	; 255
    1eea:	fc 01       	movw	r30, r24
    1eec:	20 83       	st	Z, r18
    1eee:	0d c0       	rjmp	.+26     	; 0x1f0a <__vector_104+0xe4>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    1ef0:	80 91 52 50 	lds	r24, 0x5052
    1ef4:	90 91 53 50 	lds	r25, 0x5053
    1ef8:	88 0f       	add	r24, r24
    1efa:	99 1f       	adc	r25, r25
    1efc:	88 0f       	add	r24, r24
    1efe:	99 1f       	adc	r25, r25
    1f00:	03 96       	adiw	r24, 0x03	; 3
    1f02:	8d 5b       	subi	r24, 0xBD	; 189
    1f04:	9f 4b       	sbci	r25, 0xBF	; 191
    1f06:	fc 01       	movw	r30, r24
    1f08:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    1f0a:	80 91 52 50 	lds	r24, 0x5052
    1f0e:	90 91 53 50 	lds	r25, 0x5053
    1f12:	88 0f       	add	r24, r24
    1f14:	99 1f       	adc	r25, r25
    1f16:	88 0f       	add	r24, r24
    1f18:	99 1f       	adc	r25, r25
    1f1a:	02 96       	adiw	r24, 0x02	; 2
    1f1c:	8d 5b       	subi	r24, 0xBD	; 189
    1f1e:	9f 4b       	sbci	r25, 0xBF	; 191
    1f20:	20 91 45 50 	lds	r18, 0x5045
    1f24:	fc 01       	movw	r30, r24
    1f26:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    1f28:	80 91 52 50 	lds	r24, 0x5052
    1f2c:	90 91 53 50 	lds	r25, 0x5053
    1f30:	88 0f       	add	r24, r24
    1f32:	99 1f       	adc	r25, r25
    1f34:	88 0f       	add	r24, r24
    1f36:	99 1f       	adc	r25, r25
    1f38:	01 96       	adiw	r24, 0x01	; 1
    1f3a:	8d 5b       	subi	r24, 0xBD	; 189
    1f3c:	9f 4b       	sbci	r25, 0xBF	; 191
    1f3e:	20 91 46 50 	lds	r18, 0x5046
    1f42:	fc 01       	movw	r30, r24
    1f44:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    1f46:	80 91 52 50 	lds	r24, 0x5052
    1f4a:	90 91 53 50 	lds	r25, 0x5053
    1f4e:	88 0f       	add	r24, r24
    1f50:	99 1f       	adc	r25, r25
    1f52:	88 0f       	add	r24, r24
    1f54:	99 1f       	adc	r25, r25
    1f56:	8d 5b       	subi	r24, 0xBD	; 189
    1f58:	9f 4b       	sbci	r25, 0xBF	; 191
    1f5a:	20 91 47 50 	lds	r18, 0x5047
    1f5e:	fc 01       	movw	r30, r24
    1f60:	20 83       	st	Z, r18

		sampleCount++;
    1f62:	80 91 52 50 	lds	r24, 0x5052
    1f66:	90 91 53 50 	lds	r25, 0x5053
    1f6a:	01 96       	adiw	r24, 0x01	; 1
    1f6c:	80 93 52 50 	sts	0x5052, r24
    1f70:	90 93 53 50 	sts	0x5053, r25
	}
}
    1f74:	0f 90       	pop	r0
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	ff 91       	pop	r31
    1f7c:	ef 91       	pop	r30
    1f7e:	bf 91       	pop	r27
    1f80:	af 91       	pop	r26
    1f82:	9f 91       	pop	r25
    1f84:	8f 91       	pop	r24
    1f86:	7f 91       	pop	r23
    1f88:	6f 91       	pop	r22
    1f8a:	5f 91       	pop	r21
    1f8c:	4f 91       	pop	r20
    1f8e:	3f 91       	pop	r19
    1f90:	2f 91       	pop	r18
    1f92:	0f 90       	pop	r0
    1f94:	00 92 3b 00 	sts	0x003B, r0
    1f98:	0f 90       	pop	r0
    1f9a:	0f be       	out	0x3f, r0	; 63
    1f9c:	0f 90       	pop	r0
    1f9e:	1f 90       	pop	r1
    1fa0:	18 95       	reti

00001fa2 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1fa2:	cf 93       	push	r28
    1fa4:	df 93       	push	r29
    1fa6:	0f 92       	push	r0
    1fa8:	cd b7       	in	r28, 0x3d	; 61
    1faa:	de b7       	in	r29, 0x3e	; 62
    1fac:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1fae:	89 81       	ldd	r24, Y+1	; 0x01
    1fb0:	88 23       	and	r24, r24
    1fb2:	49 f0       	breq	.+18     	; 0x1fc6 <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1fb4:	80 e2       	ldi	r24, 0x20	; 32
    1fb6:	60 e0       	ldi	r22, 0x00	; 0
    1fb8:	0e 94 cb 33 	call	0x6796	; 0x6796 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1fbc:	80 e2       	ldi	r24, 0x20	; 32
    1fbe:	60 e0       	ldi	r22, 0x00	; 0
    1fc0:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
    1fc4:	04 c0       	rjmp	.+8      	; 0x1fce <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1fc6:	80 e2       	ldi	r24, 0x20	; 32
    1fc8:	60 e0       	ldi	r22, 0x00	; 0
    1fca:	0e 94 2f 34 	call	0x685e	; 0x685e <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1fce:	0f 90       	pop	r0
    1fd0:	df 91       	pop	r29
    1fd2:	cf 91       	pop	r28
    1fd4:	08 95       	ret

00001fd6 <CO_collectSeismic3Channel>:

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    1fd6:	8f 92       	push	r8
    1fd8:	9f 92       	push	r9
    1fda:	af 92       	push	r10
    1fdc:	bf 92       	push	r11
    1fde:	cf 92       	push	r12
    1fe0:	df 92       	push	r13
    1fe2:	ef 92       	push	r14
    1fe4:	ff 92       	push	r15
    1fe6:	0f 93       	push	r16
    1fe8:	cf 93       	push	r28
    1fea:	df 93       	push	r29
    1fec:	cd b7       	in	r28, 0x3d	; 61
    1fee:	de b7       	in	r29, 0x3e	; 62
    1ff0:	2e 97       	sbiw	r28, 0x0e	; 14
    1ff2:	cd bf       	out	0x3d, r28	; 61
    1ff4:	de bf       	out	0x3e, r29	; 62
    1ff6:	89 83       	std	Y+1, r24	; 0x01
    1ff8:	6a 83       	std	Y+2, r22	; 0x02
    1ffa:	7b 83       	std	Y+3, r23	; 0x03
    1ffc:	4c 83       	std	Y+4, r20	; 0x04
    1ffe:	2d 83       	std	Y+5, r18	; 0x05
    2000:	0e 83       	std	Y+6, r16	; 0x06
    2002:	ef 82       	std	Y+7, r14	; 0x07
    2004:	f8 86       	std	Y+8, r15	; 0x08
    2006:	c9 86       	std	Y+9, r12	; 0x09
    2008:	da 86       	std	Y+10, r13	; 0x0a
    200a:	ab 86       	std	Y+11, r10	; 0x0b
    200c:	bc 86       	std	Y+12, r11	; 0x0c
    200e:	8d 86       	std	Y+13, r8	; 0x0d
    2010:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2018:	8a 81       	ldd	r24, Y+2	; 0x02
    201a:	9b 81       	ldd	r25, Y+3	; 0x03
    201c:	fc 01       	movw	r30, r24
    201e:	90 81       	ld	r25, Z
    2020:	85 e0       	ldi	r24, 0x05	; 5
    2022:	69 2f       	mov	r22, r25
    2024:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2028:	8a 81       	ldd	r24, Y+2	; 0x02
    202a:	9b 81       	ldd	r25, Y+3	; 0x03
    202c:	01 96       	adiw	r24, 0x01	; 1
    202e:	fc 01       	movw	r30, r24
    2030:	90 81       	ld	r25, Z
    2032:	86 e0       	ldi	r24, 0x06	; 6
    2034:	69 2f       	mov	r22, r25
    2036:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    203a:	8a 81       	ldd	r24, Y+2	; 0x02
    203c:	9b 81       	ldd	r25, Y+3	; 0x03
    203e:	02 96       	adiw	r24, 0x02	; 2
    2040:	fc 01       	movw	r30, r24
    2042:	90 81       	ld	r25, Z
    2044:	87 e0       	ldi	r24, 0x07	; 7
    2046:	69 2f       	mov	r22, r25
    2048:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_filter(filterConfig);
    204c:	89 81       	ldd	r24, Y+1	; 0x01
    204e:	0e 94 1f 07 	call	0xe3e	; 0xe3e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2052:	8e 81       	ldd	r24, Y+6	; 0x06
    2054:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2058:	84 e0       	ldi	r24, 0x04	; 4
    205a:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    205e:	80 ec       	ldi	r24, 0xC0	; 192
    2060:	98 e0       	ldi	r25, 0x08	; 8
    2062:	24 e5       	ldi	r18, 0x54	; 84
    2064:	fc 01       	movw	r30, r24
    2066:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2068:	81 e0       	ldi	r24, 0x01	; 1
    206a:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    206e:	85 e0       	ldi	r24, 0x05	; 5
    2070:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2074:	80 ea       	ldi	r24, 0xA0	; 160
    2076:	96 e0       	ldi	r25, 0x06	; 6
    2078:	22 e0       	ldi	r18, 0x02	; 2
    207a:	fc 01       	movw	r30, r24
    207c:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    207e:	80 ea       	ldi	r24, 0xA0	; 160
    2080:	96 e0       	ldi	r25, 0x06	; 6
    2082:	21 e0       	ldi	r18, 0x01	; 1
    2084:	fc 01       	movw	r30, r24
    2086:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2088:	80 e8       	ldi	r24, 0x80	; 128
    208a:	91 e0       	ldi	r25, 0x01	; 1
    208c:	28 e7       	ldi	r18, 0x78	; 120
    208e:	fc 01       	movw	r30, r24
    2090:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2092:	80 e0       	ldi	r24, 0x00	; 0
    2094:	98 e0       	ldi	r25, 0x08	; 8
    2096:	20 ef       	ldi	r18, 0xF0	; 240
    2098:	fc 01       	movw	r30, r24
    209a:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	98 e0       	ldi	r25, 0x08	; 8
    20a0:	2f 81       	ldd	r18, Y+7	; 0x07
    20a2:	38 85       	ldd	r19, Y+8	; 0x08
    20a4:	fc 01       	movw	r30, r24
    20a6:	20 a7       	lds	r18, 0x70
    20a8:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    20aa:	80 e0       	ldi	r24, 0x00	; 0
    20ac:	98 e0       	ldi	r25, 0x08	; 8
    20ae:	29 85       	ldd	r18, Y+9	; 0x09
    20b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    20b2:	fc 01       	movw	r30, r24
    20b4:	22 a7       	lds	r18, 0x72
    20b6:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    20b8:	80 e0       	ldi	r24, 0x00	; 0
    20ba:	98 e0       	ldi	r25, 0x08	; 8
    20bc:	2b 85       	ldd	r18, Y+11	; 0x0b
    20be:	3c 85       	ldd	r19, Y+12	; 0x0c
    20c0:	fc 01       	movw	r30, r24
    20c2:	24 a7       	lds	r18, 0x74
    20c4:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    20c6:	80 e0       	ldi	r24, 0x00	; 0
    20c8:	98 e0       	ldi	r25, 0x08	; 8
    20ca:	2d 85       	ldd	r18, Y+13	; 0x0d
    20cc:	3e 85       	ldd	r19, Y+14	; 0x0e
    20ce:	fc 01       	movw	r30, r24
    20d0:	26 a7       	lds	r18, 0x76
    20d2:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    20d4:	80 e0       	ldi	r24, 0x00	; 0
    20d6:	98 e0       	ldi	r25, 0x08	; 8
    20d8:	2d 81       	ldd	r18, Y+5	; 0x05
    20da:	22 2f       	mov	r18, r18
    20dc:	30 e0       	ldi	r19, 0x00	; 0
    20de:	21 50       	subi	r18, 0x01	; 1
    20e0:	30 40       	sbci	r19, 0x00	; 0
    20e2:	fc 01       	movw	r30, r24
    20e4:	26 a3       	lds	r18, 0x56
    20e6:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    20e8:	80 e0       	ldi	r24, 0x00	; 0
    20ea:	98 e0       	ldi	r25, 0x08	; 8
    20ec:	22 e0       	ldi	r18, 0x02	; 2
    20ee:	fc 01       	movw	r30, r24
    20f0:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    20f2:	80 e0       	ldi	r24, 0x00	; 0
    20f4:	98 e0       	ldi	r25, 0x08	; 8
    20f6:	2f ef       	ldi	r18, 0xFF	; 255
    20f8:	fc 01       	movw	r30, r24
    20fa:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    20fc:	80 e0       	ldi	r24, 0x00	; 0
    20fe:	98 e0       	ldi	r25, 0x08	; 8
    2100:	20 e0       	ldi	r18, 0x00	; 0
    2102:	38 e0       	ldi	r19, 0x08	; 8
    2104:	f9 01       	movw	r30, r18
    2106:	20 81       	ld	r18, Z
    2108:	20 7f       	andi	r18, 0xF0	; 240
    210a:	28 60       	ori	r18, 0x08	; 8
    210c:	fc 01       	movw	r30, r24
    210e:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    2110:	10 92 38 40 	sts	0x4038, r1
    2114:	10 92 39 40 	sts	0x4039, r1
	sampleCount = 0;
    2118:	10 92 52 50 	sts	0x5052, r1
    211c:	10 92 53 50 	sts	0x5053, r1
	SPICount = 0;
    2120:	10 92 b7 50 	sts	0x50B7, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2124:	80 e0       	ldi	r24, 0x00	; 0
    2126:	80 93 1c 21 	sts	0x211C, r24
    212a:	80 93 1b 21 	sts	0x211B, r24
    212e:	80 93 1a 21 	sts	0x211A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2132:	80 ea       	ldi	r24, 0xA0	; 160
    2134:	90 e0       	ldi	r25, 0x00	; 0
    2136:	20 ea       	ldi	r18, 0xA0	; 160
    2138:	30 e0       	ldi	r19, 0x00	; 0
    213a:	f9 01       	movw	r30, r18
    213c:	22 81       	ldd	r18, Z+2	; 0x02
    213e:	26 60       	ori	r18, 0x06	; 6
    2140:	fc 01       	movw	r30, r24
    2142:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2144:	78 94       	sei

	SPICS(TRUE);
    2146:	81 e0       	ldi	r24, 0x01	; 1
    2148:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    214c:	80 e8       	ldi	r24, 0x80	; 128
    214e:	96 e0       	ldi	r25, 0x06	; 6
    2150:	20 e2       	ldi	r18, 0x20	; 32
    2152:	fc 01       	movw	r30, r24
    2154:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2156:	80 e4       	ldi	r24, 0x40	; 64
    2158:	9a e0       	ldi	r25, 0x0A	; 10
    215a:	23 e2       	ldi	r18, 0x23	; 35
    215c:	fc 01       	movw	r30, r24
    215e:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2160:	80 e4       	ldi	r24, 0x40	; 64
    2162:	9a e0       	ldi	r25, 0x0A	; 10
    2164:	2c 81       	ldd	r18, Y+4	; 0x04
    2166:	42 2f       	mov	r20, r18
    2168:	50 e0       	ldi	r21, 0x00	; 0
    216a:	20 e2       	ldi	r18, 0x20	; 32
    216c:	30 e0       	ldi	r19, 0x00	; 0
    216e:	02 c0       	rjmp	.+4      	; 0x2174 <CO_collectSeismic3Channel+0x19e>
    2170:	22 0f       	add	r18, r18
    2172:	33 1f       	adc	r19, r19
    2174:	4a 95       	dec	r20
    2176:	e2 f7       	brpl	.-8      	; 0x2170 <CO_collectSeismic3Channel+0x19a>
    2178:	fc 01       	movw	r30, r24
    217a:	26 a3       	lds	r18, 0x56
    217c:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    217e:	80 e4       	ldi	r24, 0x40	; 64
    2180:	9a e0       	ldi	r25, 0x0A	; 10
    2182:	2c 81       	ldd	r18, Y+4	; 0x04
    2184:	42 2f       	mov	r20, r18
    2186:	50 e0       	ldi	r21, 0x00	; 0
    2188:	20 e1       	ldi	r18, 0x10	; 16
    218a:	30 e0       	ldi	r19, 0x00	; 0
    218c:	04 2e       	mov	r0, r20
    218e:	02 c0       	rjmp	.+4      	; 0x2194 <CO_collectSeismic3Channel+0x1be>
    2190:	22 0f       	add	r18, r18
    2192:	33 1f       	adc	r19, r19
    2194:	0a 94       	dec	r0
    2196:	e2 f7       	brpl	.-8      	; 0x2190 <CO_collectSeismic3Channel+0x1ba>
    2198:	fc 01       	movw	r30, r24
    219a:	22 af       	sts	0x72, r18
    219c:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    219e:	80 e4       	ldi	r24, 0x40	; 64
    21a0:	9a e0       	ldi	r25, 0x0A	; 10
    21a2:	20 e4       	ldi	r18, 0x40	; 64
    21a4:	3a e0       	ldi	r19, 0x0A	; 10
    21a6:	f9 01       	movw	r30, r18
    21a8:	20 81       	ld	r18, Z
    21aa:	20 7f       	andi	r18, 0xF0	; 240
    21ac:	21 60       	ori	r18, 0x01	; 1
    21ae:	fc 01       	movw	r30, r24
    21b0:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    21b2:	00 00       	nop
    21b4:	80 91 52 50 	lds	r24, 0x5052
    21b8:	90 91 53 50 	lds	r25, 0x5053
    21bc:	f5 e5       	ldi	r31, 0x55	; 85
    21be:	83 35       	cpi	r24, 0x53	; 83
    21c0:	9f 07       	cpc	r25, r31
    21c2:	c0 f3       	brcs	.-16     	; 0x21b4 <CO_collectSeismic3Channel+0x1de>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    21c4:	80 e0       	ldi	r24, 0x00	; 0
    21c6:	98 e0       	ldi	r25, 0x08	; 8
    21c8:	20 e0       	ldi	r18, 0x00	; 0
    21ca:	38 e0       	ldi	r19, 0x08	; 8
    21cc:	f9 01       	movw	r30, r18
    21ce:	20 81       	ld	r18, Z
    21d0:	20 7f       	andi	r18, 0xF0	; 240
    21d2:	fc 01       	movw	r30, r24
    21d4:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    21d6:	80 e4       	ldi	r24, 0x40	; 64
    21d8:	9a e0       	ldi	r25, 0x0A	; 10
    21da:	20 e4       	ldi	r18, 0x40	; 64
    21dc:	3a e0       	ldi	r19, 0x0A	; 10
    21de:	f9 01       	movw	r30, r18
    21e0:	20 81       	ld	r18, Z
    21e2:	20 7f       	andi	r18, 0xF0	; 240
    21e4:	fc 01       	movw	r30, r24
    21e6:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    21e8:	80 ea       	ldi	r24, 0xA0	; 160
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	20 ea       	ldi	r18, 0xA0	; 160
    21ee:	30 e0       	ldi	r19, 0x00	; 0
    21f0:	f9 01       	movw	r30, r18
    21f2:	22 81       	ldd	r18, Z+2	; 0x02
    21f4:	29 7f       	andi	r18, 0xF9	; 249
    21f6:	fc 01       	movw	r30, r24
    21f8:	22 83       	std	Z+2, r18	; 0x02
	cli();
    21fa:	f8 94       	cli

	SPICS(FALSE);
    21fc:	80 e0       	ldi	r24, 0x00	; 0
    21fe:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    2202:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	enableADCMUX(FALSE);
    2206:	80 e0       	ldi	r24, 0x00	; 0
    2208:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
	ADCPower(FALSE);
    220c:	80 e0       	ldi	r24, 0x00	; 0
    220e:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	
}
    2212:	2e 96       	adiw	r28, 0x0e	; 14
    2214:	cd bf       	out	0x3d, r28	; 61
    2216:	de bf       	out	0x3e, r29	; 62
    2218:	df 91       	pop	r29
    221a:	cf 91       	pop	r28
    221c:	0f 91       	pop	r16
    221e:	ff 90       	pop	r15
    2220:	ef 90       	pop	r14
    2222:	df 90       	pop	r13
    2224:	cf 90       	pop	r12
    2226:	bf 90       	pop	r11
    2228:	af 90       	pop	r10
    222a:	9f 90       	pop	r9
    222c:	8f 90       	pop	r8
    222e:	08 95       	ret

00002230 <CO_collectSeismic3Channel_continuous>:

void CO_collectSeismic3Channel_continuous(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    2230:	8f 92       	push	r8
    2232:	9f 92       	push	r9
    2234:	af 92       	push	r10
    2236:	bf 92       	push	r11
    2238:	cf 92       	push	r12
    223a:	df 92       	push	r13
    223c:	ef 92       	push	r14
    223e:	ff 92       	push	r15
    2240:	0f 93       	push	r16
    2242:	cf 93       	push	r28
    2244:	df 93       	push	r29
    2246:	cd b7       	in	r28, 0x3d	; 61
    2248:	de b7       	in	r29, 0x3e	; 62
    224a:	2e 97       	sbiw	r28, 0x0e	; 14
    224c:	cd bf       	out	0x3d, r28	; 61
    224e:	de bf       	out	0x3e, r29	; 62
    2250:	89 83       	std	Y+1, r24	; 0x01
    2252:	6a 83       	std	Y+2, r22	; 0x02
    2254:	7b 83       	std	Y+3, r23	; 0x03
    2256:	4c 83       	std	Y+4, r20	; 0x04
    2258:	2d 83       	std	Y+5, r18	; 0x05
    225a:	0e 83       	std	Y+6, r16	; 0x06
    225c:	ef 82       	std	Y+7, r14	; 0x07
    225e:	f8 86       	std	Y+8, r15	; 0x08
    2260:	c9 86       	std	Y+9, r12	; 0x09
    2262:	da 86       	std	Y+10, r13	; 0x0a
    2264:	ab 86       	std	Y+11, r10	; 0x0b
    2266:	bc 86       	std	Y+12, r11	; 0x0c
    2268:	8d 86       	std	Y+13, r8	; 0x0d
    226a:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    226c:	81 e0       	ldi	r24, 0x01	; 1
    226e:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2272:	8a 81       	ldd	r24, Y+2	; 0x02
    2274:	9b 81       	ldd	r25, Y+3	; 0x03
    2276:	fc 01       	movw	r30, r24
    2278:	90 81       	ld	r25, Z
    227a:	85 e0       	ldi	r24, 0x05	; 5
    227c:	69 2f       	mov	r22, r25
    227e:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2282:	8a 81       	ldd	r24, Y+2	; 0x02
    2284:	9b 81       	ldd	r25, Y+3	; 0x03
    2286:	01 96       	adiw	r24, 0x01	; 1
    2288:	fc 01       	movw	r30, r24
    228a:	90 81       	ld	r25, Z
    228c:	86 e0       	ldi	r24, 0x06	; 6
    228e:	69 2f       	mov	r22, r25
    2290:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2294:	8a 81       	ldd	r24, Y+2	; 0x02
    2296:	9b 81       	ldd	r25, Y+3	; 0x03
    2298:	02 96       	adiw	r24, 0x02	; 2
    229a:	fc 01       	movw	r30, r24
    229c:	90 81       	ld	r25, Z
    229e:	87 e0       	ldi	r24, 0x07	; 7
    22a0:	69 2f       	mov	r22, r25
    22a2:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_filter(filterConfig);
    22a6:	89 81       	ldd	r24, Y+1	; 0x01
    22a8:	0e 94 1f 07 	call	0xe3e	; 0xe3e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    22ac:	8e 81       	ldd	r24, Y+6	; 0x06
    22ae:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    22b2:	84 e0       	ldi	r24, 0x04	; 4
    22b4:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    22b8:	80 ec       	ldi	r24, 0xC0	; 192
    22ba:	98 e0       	ldi	r25, 0x08	; 8
    22bc:	24 e5       	ldi	r18, 0x54	; 84
    22be:	fc 01       	movw	r30, r24
    22c0:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    22c8:	85 e0       	ldi	r24, 0x05	; 5
    22ca:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    22ce:	80 ea       	ldi	r24, 0xA0	; 160
    22d0:	96 e0       	ldi	r25, 0x06	; 6
    22d2:	22 e0       	ldi	r18, 0x02	; 2
    22d4:	fc 01       	movw	r30, r24
    22d6:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    22d8:	80 ea       	ldi	r24, 0xA0	; 160
    22da:	96 e0       	ldi	r25, 0x06	; 6
    22dc:	21 e0       	ldi	r18, 0x01	; 1
    22de:	fc 01       	movw	r30, r24
    22e0:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    22e2:	80 e8       	ldi	r24, 0x80	; 128
    22e4:	91 e0       	ldi	r25, 0x01	; 1
    22e6:	28 e7       	ldi	r18, 0x78	; 120
    22e8:	fc 01       	movw	r30, r24
    22ea:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    22ec:	80 e0       	ldi	r24, 0x00	; 0
    22ee:	98 e0       	ldi	r25, 0x08	; 8
    22f0:	20 ef       	ldi	r18, 0xF0	; 240
    22f2:	fc 01       	movw	r30, r24
    22f4:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    22f6:	80 e0       	ldi	r24, 0x00	; 0
    22f8:	98 e0       	ldi	r25, 0x08	; 8
    22fa:	2f 81       	ldd	r18, Y+7	; 0x07
    22fc:	38 85       	ldd	r19, Y+8	; 0x08
    22fe:	fc 01       	movw	r30, r24
    2300:	20 a7       	lds	r18, 0x70
    2302:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    2304:	80 e0       	ldi	r24, 0x00	; 0
    2306:	98 e0       	ldi	r25, 0x08	; 8
    2308:	29 85       	ldd	r18, Y+9	; 0x09
    230a:	3a 85       	ldd	r19, Y+10	; 0x0a
    230c:	fc 01       	movw	r30, r24
    230e:	22 a7       	lds	r18, 0x72
    2310:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    2312:	80 e0       	ldi	r24, 0x00	; 0
    2314:	98 e0       	ldi	r25, 0x08	; 8
    2316:	2b 85       	ldd	r18, Y+11	; 0x0b
    2318:	3c 85       	ldd	r19, Y+12	; 0x0c
    231a:	fc 01       	movw	r30, r24
    231c:	24 a7       	lds	r18, 0x74
    231e:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    2320:	80 e0       	ldi	r24, 0x00	; 0
    2322:	98 e0       	ldi	r25, 0x08	; 8
    2324:	2d 85       	ldd	r18, Y+13	; 0x0d
    2326:	3e 85       	ldd	r19, Y+14	; 0x0e
    2328:	fc 01       	movw	r30, r24
    232a:	26 a7       	lds	r18, 0x76
    232c:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    232e:	80 e0       	ldi	r24, 0x00	; 0
    2330:	98 e0       	ldi	r25, 0x08	; 8
    2332:	2d 81       	ldd	r18, Y+5	; 0x05
    2334:	22 2f       	mov	r18, r18
    2336:	30 e0       	ldi	r19, 0x00	; 0
    2338:	21 50       	subi	r18, 0x01	; 1
    233a:	30 40       	sbci	r19, 0x00	; 0
    233c:	fc 01       	movw	r30, r24
    233e:	26 a3       	lds	r18, 0x56
    2340:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2342:	80 e0       	ldi	r24, 0x00	; 0
    2344:	98 e0       	ldi	r25, 0x08	; 8
    2346:	22 e0       	ldi	r18, 0x02	; 2
    2348:	fc 01       	movw	r30, r24
    234a:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    234c:	80 e0       	ldi	r24, 0x00	; 0
    234e:	98 e0       	ldi	r25, 0x08	; 8
    2350:	2f ef       	ldi	r18, 0xFF	; 255
    2352:	fc 01       	movw	r30, r24
    2354:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2356:	80 e0       	ldi	r24, 0x00	; 0
    2358:	98 e0       	ldi	r25, 0x08	; 8
    235a:	20 e0       	ldi	r18, 0x00	; 0
    235c:	38 e0       	ldi	r19, 0x08	; 8
    235e:	f9 01       	movw	r30, r18
    2360:	20 81       	ld	r18, Z
    2362:	20 7f       	andi	r18, 0xF0	; 240
    2364:	28 60       	ori	r18, 0x08	; 8
    2366:	fc 01       	movw	r30, r24
    2368:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    236a:	10 92 38 40 	sts	0x4038, r1
    236e:	10 92 39 40 	sts	0x4039, r1
	sampleCount = 0;
    2372:	10 92 52 50 	sts	0x5052, r1
    2376:	10 92 53 50 	sts	0x5053, r1
	SPICount = 0;
    237a:	10 92 b7 50 	sts	0x50B7, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    237e:	80 e0       	ldi	r24, 0x00	; 0
    2380:	80 93 1c 21 	sts	0x211C, r24
    2384:	80 93 1b 21 	sts	0x211B, r24
    2388:	80 93 1a 21 	sts	0x211A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    238c:	80 ea       	ldi	r24, 0xA0	; 160
    238e:	90 e0       	ldi	r25, 0x00	; 0
    2390:	20 ea       	ldi	r18, 0xA0	; 160
    2392:	30 e0       	ldi	r19, 0x00	; 0
    2394:	f9 01       	movw	r30, r18
    2396:	22 81       	ldd	r18, Z+2	; 0x02
    2398:	26 60       	ori	r18, 0x06	; 6
    239a:	fc 01       	movw	r30, r24
    239c:	22 83       	std	Z+2, r18	; 0x02
	sei();
    239e:	78 94       	sei

	SPICS(TRUE);
    23a0:	81 e0       	ldi	r24, 0x01	; 1
    23a2:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    23a6:	80 e8       	ldi	r24, 0x80	; 128
    23a8:	96 e0       	ldi	r25, 0x06	; 6
    23aa:	20 e2       	ldi	r18, 0x20	; 32
    23ac:	fc 01       	movw	r30, r24
    23ae:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    23b0:	80 e4       	ldi	r24, 0x40	; 64
    23b2:	9a e0       	ldi	r25, 0x0A	; 10
    23b4:	23 e2       	ldi	r18, 0x23	; 35
    23b6:	fc 01       	movw	r30, r24
    23b8:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    23ba:	80 e4       	ldi	r24, 0x40	; 64
    23bc:	9a e0       	ldi	r25, 0x0A	; 10
    23be:	2c 81       	ldd	r18, Y+4	; 0x04
    23c0:	42 2f       	mov	r20, r18
    23c2:	50 e0       	ldi	r21, 0x00	; 0
    23c4:	20 e2       	ldi	r18, 0x20	; 32
    23c6:	30 e0       	ldi	r19, 0x00	; 0
    23c8:	02 c0       	rjmp	.+4      	; 0x23ce <CO_collectSeismic3Channel_continuous+0x19e>
    23ca:	22 0f       	add	r18, r18
    23cc:	33 1f       	adc	r19, r19
    23ce:	4a 95       	dec	r20
    23d0:	e2 f7       	brpl	.-8      	; 0x23ca <CO_collectSeismic3Channel_continuous+0x19a>
    23d2:	fc 01       	movw	r30, r24
    23d4:	26 a3       	lds	r18, 0x56
    23d6:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    23d8:	80 e4       	ldi	r24, 0x40	; 64
    23da:	9a e0       	ldi	r25, 0x0A	; 10
    23dc:	2c 81       	ldd	r18, Y+4	; 0x04
    23de:	42 2f       	mov	r20, r18
    23e0:	50 e0       	ldi	r21, 0x00	; 0
    23e2:	20 e1       	ldi	r18, 0x10	; 16
    23e4:	30 e0       	ldi	r19, 0x00	; 0
    23e6:	04 2e       	mov	r0, r20
    23e8:	02 c0       	rjmp	.+4      	; 0x23ee <CO_collectSeismic3Channel_continuous+0x1be>
    23ea:	22 0f       	add	r18, r18
    23ec:	33 1f       	adc	r19, r19
    23ee:	0a 94       	dec	r0
    23f0:	e2 f7       	brpl	.-8      	; 0x23ea <CO_collectSeismic3Channel_continuous+0x1ba>
    23f2:	fc 01       	movw	r30, r24
    23f4:	22 af       	sts	0x72, r18
    23f6:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    23f8:	80 e4       	ldi	r24, 0x40	; 64
    23fa:	9a e0       	ldi	r25, 0x0A	; 10
    23fc:	20 e4       	ldi	r18, 0x40	; 64
    23fe:	3a e0       	ldi	r19, 0x0A	; 10
    2400:	f9 01       	movw	r30, r18
    2402:	20 81       	ld	r18, Z
    2404:	20 7f       	andi	r18, 0xF0	; 240
    2406:	21 60       	ori	r18, 0x01	; 1
    2408:	fc 01       	movw	r30, r24
    240a:	20 83       	st	Z, r18
	
	// collect samples from ADC continuously
	while(1){
		nop();
    240c:	00 00       	nop
	}
    240e:	fe cf       	rjmp	.-4      	; 0x240c <CO_collectSeismic3Channel_continuous+0x1dc>

00002410 <__vector_16>:
}


ISR(TCC0_CCA_vect) {
    2410:	1f 92       	push	r1
    2412:	0f 92       	push	r0
    2414:	0f b6       	in	r0, 0x3f	; 63
    2416:	0f 92       	push	r0
    2418:	00 90 3b 00 	lds	r0, 0x003B
    241c:	0f 92       	push	r0
    241e:	11 24       	eor	r1, r1
    2420:	2f 93       	push	r18
    2422:	3f 93       	push	r19
    2424:	4f 93       	push	r20
    2426:	5f 93       	push	r21
    2428:	6f 93       	push	r22
    242a:	7f 93       	push	r23
    242c:	8f 93       	push	r24
    242e:	9f 93       	push	r25
    2430:	af 93       	push	r26
    2432:	bf 93       	push	r27
    2434:	ef 93       	push	r30
    2436:	ff 93       	push	r31
    2438:	cf 93       	push	r28
    243a:	df 93       	push	r29
    243c:	cd b7       	in	r28, 0x3d	; 61
    243e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2440:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    2444:	df 91       	pop	r29
    2446:	cf 91       	pop	r28
    2448:	ff 91       	pop	r31
    244a:	ef 91       	pop	r30
    244c:	bf 91       	pop	r27
    244e:	af 91       	pop	r26
    2450:	9f 91       	pop	r25
    2452:	8f 91       	pop	r24
    2454:	7f 91       	pop	r23
    2456:	6f 91       	pop	r22
    2458:	5f 91       	pop	r21
    245a:	4f 91       	pop	r20
    245c:	3f 91       	pop	r19
    245e:	2f 91       	pop	r18
    2460:	0f 90       	pop	r0
    2462:	00 92 3b 00 	sts	0x003B, r0
    2466:	0f 90       	pop	r0
    2468:	0f be       	out	0x3f, r0	; 63
    246a:	0f 90       	pop	r0
    246c:	1f 90       	pop	r1
    246e:	18 95       	reti

00002470 <__vector_17>:

ISR(TCC0_CCB_vect) {
    2470:	1f 92       	push	r1
    2472:	0f 92       	push	r0
    2474:	0f b6       	in	r0, 0x3f	; 63
    2476:	0f 92       	push	r0
    2478:	00 90 3b 00 	lds	r0, 0x003B
    247c:	0f 92       	push	r0
    247e:	11 24       	eor	r1, r1
    2480:	2f 93       	push	r18
    2482:	3f 93       	push	r19
    2484:	4f 93       	push	r20
    2486:	5f 93       	push	r21
    2488:	6f 93       	push	r22
    248a:	7f 93       	push	r23
    248c:	8f 93       	push	r24
    248e:	9f 93       	push	r25
    2490:	af 93       	push	r26
    2492:	bf 93       	push	r27
    2494:	ef 93       	push	r30
    2496:	ff 93       	push	r31
    2498:	cf 93       	push	r28
    249a:	df 93       	push	r29
    249c:	cd b7       	in	r28, 0x3d	; 61
    249e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    24a0:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    24a4:	df 91       	pop	r29
    24a6:	cf 91       	pop	r28
    24a8:	ff 91       	pop	r31
    24aa:	ef 91       	pop	r30
    24ac:	bf 91       	pop	r27
    24ae:	af 91       	pop	r26
    24b0:	9f 91       	pop	r25
    24b2:	8f 91       	pop	r24
    24b4:	7f 91       	pop	r23
    24b6:	6f 91       	pop	r22
    24b8:	5f 91       	pop	r21
    24ba:	4f 91       	pop	r20
    24bc:	3f 91       	pop	r19
    24be:	2f 91       	pop	r18
    24c0:	0f 90       	pop	r0
    24c2:	00 92 3b 00 	sts	0x003B, r0
    24c6:	0f 90       	pop	r0
    24c8:	0f be       	out	0x3f, r0	; 63
    24ca:	0f 90       	pop	r0
    24cc:	1f 90       	pop	r1
    24ce:	18 95       	reti

000024d0 <__vector_18>:

ISR(TCC0_CCC_vect) {
    24d0:	1f 92       	push	r1
    24d2:	0f 92       	push	r0
    24d4:	0f b6       	in	r0, 0x3f	; 63
    24d6:	0f 92       	push	r0
    24d8:	00 90 3b 00 	lds	r0, 0x003B
    24dc:	0f 92       	push	r0
    24de:	11 24       	eor	r1, r1
    24e0:	2f 93       	push	r18
    24e2:	3f 93       	push	r19
    24e4:	4f 93       	push	r20
    24e6:	5f 93       	push	r21
    24e8:	6f 93       	push	r22
    24ea:	7f 93       	push	r23
    24ec:	8f 93       	push	r24
    24ee:	9f 93       	push	r25
    24f0:	af 93       	push	r26
    24f2:	bf 93       	push	r27
    24f4:	ef 93       	push	r30
    24f6:	ff 93       	push	r31
    24f8:	cf 93       	push	r28
    24fa:	df 93       	push	r29
    24fc:	cd b7       	in	r28, 0x3d	; 61
    24fe:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2500:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    2504:	df 91       	pop	r29
    2506:	cf 91       	pop	r28
    2508:	ff 91       	pop	r31
    250a:	ef 91       	pop	r30
    250c:	bf 91       	pop	r27
    250e:	af 91       	pop	r26
    2510:	9f 91       	pop	r25
    2512:	8f 91       	pop	r24
    2514:	7f 91       	pop	r23
    2516:	6f 91       	pop	r22
    2518:	5f 91       	pop	r21
    251a:	4f 91       	pop	r20
    251c:	3f 91       	pop	r19
    251e:	2f 91       	pop	r18
    2520:	0f 90       	pop	r0
    2522:	00 92 3b 00 	sts	0x003B, r0
    2526:	0f 90       	pop	r0
    2528:	0f be       	out	0x3f, r0	; 63
    252a:	0f 90       	pop	r0
    252c:	1f 90       	pop	r1
    252e:	18 95       	reti

00002530 <__vector_19>:

ISR(TCC0_CCD_vect) {
    2530:	1f 92       	push	r1
    2532:	0f 92       	push	r0
    2534:	0f b6       	in	r0, 0x3f	; 63
    2536:	0f 92       	push	r0
    2538:	00 90 3b 00 	lds	r0, 0x003B
    253c:	0f 92       	push	r0
    253e:	11 24       	eor	r1, r1
    2540:	2f 93       	push	r18
    2542:	3f 93       	push	r19
    2544:	4f 93       	push	r20
    2546:	5f 93       	push	r21
    2548:	6f 93       	push	r22
    254a:	7f 93       	push	r23
    254c:	8f 93       	push	r24
    254e:	9f 93       	push	r25
    2550:	af 93       	push	r26
    2552:	bf 93       	push	r27
    2554:	ef 93       	push	r30
    2556:	ff 93       	push	r31
    2558:	cf 93       	push	r28
    255a:	df 93       	push	r29
    255c:	cd b7       	in	r28, 0x3d	; 61
    255e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2560:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
	SPICount = 0;
    2564:	10 92 b7 50 	sts	0x50B7, r1
	if(PORTB.OUT & PIN1_bm) {
    2568:	80 e2       	ldi	r24, 0x20	; 32
    256a:	96 e0       	ldi	r25, 0x06	; 6
    256c:	fc 01       	movw	r30, r24
    256e:	84 81       	ldd	r24, Z+4	; 0x04
    2570:	88 2f       	mov	r24, r24
    2572:	90 e0       	ldi	r25, 0x00	; 0
    2574:	82 70       	andi	r24, 0x02	; 2
    2576:	90 70       	andi	r25, 0x00	; 0
    2578:	00 97       	sbiw	r24, 0x00	; 0
    257a:	b1 f0       	breq	.+44     	; 0x25a8 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    257c:	80 e0       	ldi	r24, 0x00	; 0
    257e:	96 e0       	ldi	r25, 0x06	; 6
    2580:	fc 01       	movw	r30, r24
    2582:	84 81       	ldd	r24, Z+4	; 0x04
    2584:	88 2f       	mov	r24, r24
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	80 74       	andi	r24, 0x40	; 64
    258a:	90 70       	andi	r25, 0x00	; 0
    258c:	00 97       	sbiw	r24, 0x00	; 0
    258e:	31 f0       	breq	.+12     	; 0x259c <__vector_19+0x6c>
    2590:	80 e2       	ldi	r24, 0x20	; 32
    2592:	96 e0       	ldi	r25, 0x06	; 6
    2594:	22 e0       	ldi	r18, 0x02	; 2
    2596:	fc 01       	movw	r30, r24
    2598:	27 83       	std	Z+7, r18	; 0x07
    259a:	10 c0       	rjmp	.+32     	; 0x25bc <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    259c:	80 e0       	ldi	r24, 0x00	; 0
    259e:	96 e0       	ldi	r25, 0x06	; 6
    25a0:	20 e4       	ldi	r18, 0x40	; 64
    25a2:	fc 01       	movw	r30, r24
    25a4:	27 83       	std	Z+7, r18	; 0x07
    25a6:	0a c0       	rjmp	.+20     	; 0x25bc <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    25a8:	80 e0       	ldi	r24, 0x00	; 0
    25aa:	96 e0       	ldi	r25, 0x06	; 6
    25ac:	20 e4       	ldi	r18, 0x40	; 64
    25ae:	fc 01       	movw	r30, r24
    25b0:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    25b2:	80 e2       	ldi	r24, 0x20	; 32
    25b4:	96 e0       	ldi	r25, 0x06	; 6
    25b6:	22 e0       	ldi	r18, 0x02	; 2
    25b8:	fc 01       	movw	r30, r24
    25ba:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	ff 91       	pop	r31
    25c2:	ef 91       	pop	r30
    25c4:	bf 91       	pop	r27
    25c6:	af 91       	pop	r26
    25c8:	9f 91       	pop	r25
    25ca:	8f 91       	pop	r24
    25cc:	7f 91       	pop	r23
    25ce:	6f 91       	pop	r22
    25d0:	5f 91       	pop	r21
    25d2:	4f 91       	pop	r20
    25d4:	3f 91       	pop	r19
    25d6:	2f 91       	pop	r18
    25d8:	0f 90       	pop	r0
    25da:	00 92 3b 00 	sts	0x003B, r0
    25de:	0f 90       	pop	r0
    25e0:	0f be       	out	0x3f, r0	; 63
    25e2:	0f 90       	pop	r0
    25e4:	1f 90       	pop	r1
    25e6:	18 95       	reti

000025e8 <__vector_14>:

ISR(TCC0_OVF_vect) {
    25e8:	1f 92       	push	r1
    25ea:	0f 92       	push	r0
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	0f 92       	push	r0
    25f0:	00 90 3b 00 	lds	r0, 0x003B
    25f4:	0f 92       	push	r0
    25f6:	11 24       	eor	r1, r1
    25f8:	2f 93       	push	r18
    25fa:	3f 93       	push	r19
    25fc:	4f 93       	push	r20
    25fe:	5f 93       	push	r21
    2600:	6f 93       	push	r22
    2602:	7f 93       	push	r23
    2604:	8f 93       	push	r24
    2606:	9f 93       	push	r25
    2608:	af 93       	push	r26
    260a:	bf 93       	push	r27
    260c:	ef 93       	push	r30
    260e:	ff 93       	push	r31
    2610:	cf 93       	push	r28
    2612:	df 93       	push	r29
    2614:	cd b7       	in	r28, 0x3d	; 61
    2616:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    2618:	0e 94 89 15 	call	0x2b12	; 0x2b12 <writeSE2FRAM>
}
    261c:	df 91       	pop	r29
    261e:	cf 91       	pop	r28
    2620:	ff 91       	pop	r31
    2622:	ef 91       	pop	r30
    2624:	bf 91       	pop	r27
    2626:	af 91       	pop	r26
    2628:	9f 91       	pop	r25
    262a:	8f 91       	pop	r24
    262c:	7f 91       	pop	r23
    262e:	6f 91       	pop	r22
    2630:	5f 91       	pop	r21
    2632:	4f 91       	pop	r20
    2634:	3f 91       	pop	r19
    2636:	2f 91       	pop	r18
    2638:	0f 90       	pop	r0
    263a:	00 92 3b 00 	sts	0x003B, r0
    263e:	0f 90       	pop	r0
    2640:	0f be       	out	0x3f, r0	; 63
    2642:	0f 90       	pop	r0
    2644:	1f 90       	pop	r1
    2646:	18 95       	reti

00002648 <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD) {
    2648:	8f 92       	push	r8
    264a:	9f 92       	push	r9
    264c:	af 92       	push	r10
    264e:	bf 92       	push	r11
    2650:	cf 92       	push	r12
    2652:	df 92       	push	r13
    2654:	ef 92       	push	r14
    2656:	0f 93       	push	r16
    2658:	cf 93       	push	r28
    265a:	df 93       	push	r29
    265c:	cd b7       	in	r28, 0x3d	; 61
    265e:	de b7       	in	r29, 0x3e	; 62
    2660:	2c 97       	sbiw	r28, 0x0c	; 12
    2662:	cd bf       	out	0x3d, r28	; 61
    2664:	de bf       	out	0x3e, r29	; 62
    2666:	89 83       	std	Y+1, r24	; 0x01
    2668:	6a 83       	std	Y+2, r22	; 0x02
    266a:	4b 83       	std	Y+3, r20	; 0x03
    266c:	2c 83       	std	Y+4, r18	; 0x04
    266e:	0d 83       	std	Y+5, r16	; 0x05
    2670:	ee 82       	std	Y+6, r14	; 0x06
    2672:	cf 82       	std	Y+7, r12	; 0x07
    2674:	d8 86       	std	Y+8, r13	; 0x08
    2676:	a9 86       	std	Y+9, r10	; 0x09
    2678:	ba 86       	std	Y+10, r11	; 0x0a
    267a:	8b 86       	std	Y+11, r8	; 0x0b
    267c:	9c 86       	std	Y+12, r9	; 0x0c
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2684:	89 81       	ldd	r24, Y+1	; 0x01
    2686:	6b 81       	ldd	r22, Y+3	; 0x03
    2688:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <set_ampGain>
	set_filter(filterConfig);
    268c:	8a 81       	ldd	r24, Y+2	; 0x02
    268e:	0e 94 1f 07 	call	0xe3e	; 0xe3e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2692:	8e 81       	ldd	r24, Y+6	; 0x06
    2694:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2698:	84 e0       	ldi	r24, 0x04	; 4
    269a:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    269e:	80 ec       	ldi	r24, 0xC0	; 192
    26a0:	98 e0       	ldi	r25, 0x08	; 8
    26a2:	24 e5       	ldi	r18, 0x54	; 84
    26a4:	fc 01       	movw	r30, r24
    26a6:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    26a8:	81 e0       	ldi	r24, 0x01	; 1
    26aa:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
	setADCInput(channel);
    26ae:	89 81       	ldd	r24, Y+1	; 0x01
    26b0:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    26b4:	80 ea       	ldi	r24, 0xA0	; 160
    26b6:	96 e0       	ldi	r25, 0x06	; 6
    26b8:	22 e0       	ldi	r18, 0x02	; 2
    26ba:	fc 01       	movw	r30, r24
    26bc:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    26be:	80 ea       	ldi	r24, 0xA0	; 160
    26c0:	96 e0       	ldi	r25, 0x06	; 6
    26c2:	21 e0       	ldi	r18, 0x01	; 1
    26c4:	fc 01       	movw	r30, r24
    26c6:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    26c8:	80 e8       	ldi	r24, 0x80	; 128
    26ca:	91 e0       	ldi	r25, 0x01	; 1
    26cc:	28 e7       	ldi	r18, 0x78	; 120
    26ce:	fc 01       	movw	r30, r24
    26d0:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    26d2:	80 e0       	ldi	r24, 0x00	; 0
    26d4:	99 e0       	ldi	r25, 0x09	; 9
    26d6:	20 ef       	ldi	r18, 0xF0	; 240
    26d8:	fc 01       	movw	r30, r24
    26da:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    26dc:	80 e0       	ldi	r24, 0x00	; 0
    26de:	99 e0       	ldi	r25, 0x09	; 9
    26e0:	2f 81       	ldd	r18, Y+7	; 0x07
    26e2:	38 85       	ldd	r19, Y+8	; 0x08
    26e4:	fc 01       	movw	r30, r24
    26e6:	20 a7       	lds	r18, 0x70
    26e8:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    26ea:	80 e0       	ldi	r24, 0x00	; 0
    26ec:	99 e0       	ldi	r25, 0x09	; 9
    26ee:	29 85       	ldd	r18, Y+9	; 0x09
    26f0:	3a 85       	ldd	r19, Y+10	; 0x0a
    26f2:	fc 01       	movw	r30, r24
    26f4:	22 a7       	lds	r18, 0x72
    26f6:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    26f8:	80 e0       	ldi	r24, 0x00	; 0
    26fa:	99 e0       	ldi	r25, 0x09	; 9
    26fc:	2b 85       	ldd	r18, Y+11	; 0x0b
    26fe:	3c 85       	ldd	r19, Y+12	; 0x0c
    2700:	fc 01       	movw	r30, r24
    2702:	24 a7       	lds	r18, 0x74
    2704:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    2706:	80 e0       	ldi	r24, 0x00	; 0
    2708:	99 e0       	ldi	r25, 0x09	; 9
    270a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    270c:	3b 8d       	ldd	r19, Y+27	; 0x1b
    270e:	fc 01       	movw	r30, r24
    2710:	26 a7       	lds	r18, 0x76
    2712:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2714:	80 e0       	ldi	r24, 0x00	; 0
    2716:	99 e0       	ldi	r25, 0x09	; 9
    2718:	2d 81       	ldd	r18, Y+5	; 0x05
    271a:	22 2f       	mov	r18, r18
    271c:	30 e0       	ldi	r19, 0x00	; 0
    271e:	21 50       	subi	r18, 0x01	; 1
    2720:	30 40       	sbci	r19, 0x00	; 0
    2722:	fc 01       	movw	r30, r24
    2724:	26 a3       	lds	r18, 0x56
    2726:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2728:	80 e0       	ldi	r24, 0x00	; 0
    272a:	99 e0       	ldi	r25, 0x09	; 9
    272c:	22 e0       	ldi	r18, 0x02	; 2
    272e:	fc 01       	movw	r30, r24
    2730:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2732:	80 e0       	ldi	r24, 0x00	; 0
    2734:	99 e0       	ldi	r25, 0x09	; 9
    2736:	2f ef       	ldi	r18, 0xFF	; 255
    2738:	fc 01       	movw	r30, r24
    273a:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    273c:	80 e0       	ldi	r24, 0x00	; 0
    273e:	99 e0       	ldi	r25, 0x09	; 9
    2740:	20 e0       	ldi	r18, 0x00	; 0
    2742:	39 e0       	ldi	r19, 0x09	; 9
    2744:	f9 01       	movw	r30, r18
    2746:	20 81       	ld	r18, Z
    2748:	20 7f       	andi	r18, 0xF0	; 240
    274a:	28 60       	ori	r18, 0x08	; 8
    274c:	fc 01       	movw	r30, r24
    274e:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    2750:	10 92 38 40 	sts	0x4038, r1
    2754:	10 92 39 40 	sts	0x4039, r1
	sampleCount = 0;
    2758:	10 92 52 50 	sts	0x5052, r1
    275c:	10 92 53 50 	sts	0x5053, r1
	SPICount = 0;
    2760:	10 92 b7 50 	sts	0x50B7, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2764:	80 e0       	ldi	r24, 0x00	; 0
    2766:	80 93 1c 21 	sts	0x211C, r24
    276a:	80 93 1b 21 	sts	0x211B, r24
    276e:	80 93 1a 21 	sts	0x211A, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2772:	80 ea       	ldi	r24, 0xA0	; 160
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	20 ea       	ldi	r18, 0xA0	; 160
    2778:	30 e0       	ldi	r19, 0x00	; 0
    277a:	f9 01       	movw	r30, r18
    277c:	22 81       	ldd	r18, Z+2	; 0x02
    277e:	26 60       	ori	r18, 0x06	; 6
    2780:	fc 01       	movw	r30, r24
    2782:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2784:	78 94       	sei

	SPICS(TRUE);
    2786:	81 e0       	ldi	r24, 0x01	; 1
    2788:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    278c:	80 e8       	ldi	r24, 0x80	; 128
    278e:	96 e0       	ldi	r25, 0x06	; 6
    2790:	20 e2       	ldi	r18, 0x20	; 32
    2792:	fc 01       	movw	r30, r24
    2794:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2796:	80 e4       	ldi	r24, 0x40	; 64
    2798:	9a e0       	ldi	r25, 0x0A	; 10
    279a:	23 e2       	ldi	r18, 0x23	; 35
    279c:	fc 01       	movw	r30, r24
    279e:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    27a0:	80 e4       	ldi	r24, 0x40	; 64
    27a2:	9a e0       	ldi	r25, 0x0A	; 10
    27a4:	2c 81       	ldd	r18, Y+4	; 0x04
    27a6:	42 2f       	mov	r20, r18
    27a8:	50 e0       	ldi	r21, 0x00	; 0
    27aa:	20 e2       	ldi	r18, 0x20	; 32
    27ac:	30 e0       	ldi	r19, 0x00	; 0
    27ae:	02 c0       	rjmp	.+4      	; 0x27b4 <CO_collectSeismic1Channel+0x16c>
    27b0:	22 0f       	add	r18, r18
    27b2:	33 1f       	adc	r19, r19
    27b4:	4a 95       	dec	r20
    27b6:	e2 f7       	brpl	.-8      	; 0x27b0 <CO_collectSeismic1Channel+0x168>
    27b8:	fc 01       	movw	r30, r24
    27ba:	26 a3       	lds	r18, 0x56
    27bc:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    27be:	80 e4       	ldi	r24, 0x40	; 64
    27c0:	9a e0       	ldi	r25, 0x0A	; 10
    27c2:	2c 81       	ldd	r18, Y+4	; 0x04
    27c4:	42 2f       	mov	r20, r18
    27c6:	50 e0       	ldi	r21, 0x00	; 0
    27c8:	20 e1       	ldi	r18, 0x10	; 16
    27ca:	30 e0       	ldi	r19, 0x00	; 0
    27cc:	04 2e       	mov	r0, r20
    27ce:	02 c0       	rjmp	.+4      	; 0x27d4 <CO_collectSeismic1Channel+0x18c>
    27d0:	22 0f       	add	r18, r18
    27d2:	33 1f       	adc	r19, r19
    27d4:	0a 94       	dec	r0
    27d6:	e2 f7       	brpl	.-8      	; 0x27d0 <CO_collectSeismic1Channel+0x188>
    27d8:	fc 01       	movw	r30, r24
    27da:	22 af       	sts	0x72, r18
    27dc:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    27de:	80 e4       	ldi	r24, 0x40	; 64
    27e0:	9a e0       	ldi	r25, 0x0A	; 10
    27e2:	20 e4       	ldi	r18, 0x40	; 64
    27e4:	3a e0       	ldi	r19, 0x0A	; 10
    27e6:	f9 01       	movw	r30, r18
    27e8:	20 81       	ld	r18, Z
    27ea:	20 7f       	andi	r18, 0xF0	; 240
    27ec:	21 60       	ori	r18, 0x01	; 1
    27ee:	fc 01       	movw	r30, r24
    27f0:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    27f2:	00 00       	nop
    27f4:	80 91 52 50 	lds	r24, 0x5052
    27f8:	90 91 53 50 	lds	r25, 0x5053
    27fc:	f5 e5       	ldi	r31, 0x55	; 85
    27fe:	83 35       	cpi	r24, 0x53	; 83
    2800:	9f 07       	cpc	r25, r31
    2802:	c0 f3       	brcs	.-16     	; 0x27f4 <CO_collectSeismic1Channel+0x1ac>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2804:	80 e0       	ldi	r24, 0x00	; 0
    2806:	99 e0       	ldi	r25, 0x09	; 9
    2808:	20 e0       	ldi	r18, 0x00	; 0
    280a:	39 e0       	ldi	r19, 0x09	; 9
    280c:	f9 01       	movw	r30, r18
    280e:	20 81       	ld	r18, Z
    2810:	20 7f       	andi	r18, 0xF0	; 240
    2812:	fc 01       	movw	r30, r24
    2814:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2816:	80 e4       	ldi	r24, 0x40	; 64
    2818:	9a e0       	ldi	r25, 0x0A	; 10
    281a:	20 e4       	ldi	r18, 0x40	; 64
    281c:	3a e0       	ldi	r19, 0x0A	; 10
    281e:	f9 01       	movw	r30, r18
    2820:	20 81       	ld	r18, Z
    2822:	20 7f       	andi	r18, 0xF0	; 240
    2824:	fc 01       	movw	r30, r24
    2826:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2828:	80 ea       	ldi	r24, 0xA0	; 160
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	20 ea       	ldi	r18, 0xA0	; 160
    282e:	30 e0       	ldi	r19, 0x00	; 0
    2830:	f9 01       	movw	r30, r18
    2832:	22 81       	ldd	r18, Z+2	; 0x02
    2834:	29 7f       	andi	r18, 0xF9	; 249
    2836:	fc 01       	movw	r30, r24
    2838:	22 83       	std	Z+2, r18	; 0x02
	cli();
    283a:	f8 94       	cli

	SPICS(FALSE);
    283c:	80 e0       	ldi	r24, 0x00	; 0
    283e:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    2842:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	enableADCMUX(FALSE);
    2846:	80 e0       	ldi	r24, 0x00	; 0
    2848:	0e 94 9f 07 	call	0xf3e	; 0xf3e <enableADCMUX>
	ADCPower(FALSE);
    284c:	80 e0       	ldi	r24, 0x00	; 0
    284e:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	
}
    2852:	2c 96       	adiw	r28, 0x0c	; 12
    2854:	cd bf       	out	0x3d, r28	; 61
    2856:	de bf       	out	0x3e, r29	; 62
    2858:	df 91       	pop	r29
    285a:	cf 91       	pop	r28
    285c:	0f 91       	pop	r16
    285e:	ef 90       	pop	r14
    2860:	df 90       	pop	r13
    2862:	cf 90       	pop	r12
    2864:	bf 90       	pop	r11
    2866:	af 90       	pop	r10
    2868:	9f 90       	pop	r9
    286a:	8f 90       	pop	r8
    286c:	08 95       	ret

0000286e <__vector_79>:

ISR(TCD0_CCA_vect) {
    286e:	1f 92       	push	r1
    2870:	0f 92       	push	r0
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	0f 92       	push	r0
    2876:	00 90 3b 00 	lds	r0, 0x003B
    287a:	0f 92       	push	r0
    287c:	11 24       	eor	r1, r1
    287e:	2f 93       	push	r18
    2880:	3f 93       	push	r19
    2882:	4f 93       	push	r20
    2884:	5f 93       	push	r21
    2886:	6f 93       	push	r22
    2888:	7f 93       	push	r23
    288a:	8f 93       	push	r24
    288c:	9f 93       	push	r25
    288e:	af 93       	push	r26
    2890:	bf 93       	push	r27
    2892:	ef 93       	push	r30
    2894:	ff 93       	push	r31
    2896:	cf 93       	push	r28
    2898:	df 93       	push	r29
    289a:	cd b7       	in	r28, 0x3d	; 61
    289c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    289e:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    28a2:	df 91       	pop	r29
    28a4:	cf 91       	pop	r28
    28a6:	ff 91       	pop	r31
    28a8:	ef 91       	pop	r30
    28aa:	bf 91       	pop	r27
    28ac:	af 91       	pop	r26
    28ae:	9f 91       	pop	r25
    28b0:	8f 91       	pop	r24
    28b2:	7f 91       	pop	r23
    28b4:	6f 91       	pop	r22
    28b6:	5f 91       	pop	r21
    28b8:	4f 91       	pop	r20
    28ba:	3f 91       	pop	r19
    28bc:	2f 91       	pop	r18
    28be:	0f 90       	pop	r0
    28c0:	00 92 3b 00 	sts	0x003B, r0
    28c4:	0f 90       	pop	r0
    28c6:	0f be       	out	0x3f, r0	; 63
    28c8:	0f 90       	pop	r0
    28ca:	1f 90       	pop	r1
    28cc:	18 95       	reti

000028ce <__vector_80>:

ISR(TCD0_CCB_vect) {
    28ce:	1f 92       	push	r1
    28d0:	0f 92       	push	r0
    28d2:	0f b6       	in	r0, 0x3f	; 63
    28d4:	0f 92       	push	r0
    28d6:	00 90 3b 00 	lds	r0, 0x003B
    28da:	0f 92       	push	r0
    28dc:	11 24       	eor	r1, r1
    28de:	2f 93       	push	r18
    28e0:	3f 93       	push	r19
    28e2:	4f 93       	push	r20
    28e4:	5f 93       	push	r21
    28e6:	6f 93       	push	r22
    28e8:	7f 93       	push	r23
    28ea:	8f 93       	push	r24
    28ec:	9f 93       	push	r25
    28ee:	af 93       	push	r26
    28f0:	bf 93       	push	r27
    28f2:	ef 93       	push	r30
    28f4:	ff 93       	push	r31
    28f6:	cf 93       	push	r28
    28f8:	df 93       	push	r29
    28fa:	cd b7       	in	r28, 0x3d	; 61
    28fc:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    28fe:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    2902:	df 91       	pop	r29
    2904:	cf 91       	pop	r28
    2906:	ff 91       	pop	r31
    2908:	ef 91       	pop	r30
    290a:	bf 91       	pop	r27
    290c:	af 91       	pop	r26
    290e:	9f 91       	pop	r25
    2910:	8f 91       	pop	r24
    2912:	7f 91       	pop	r23
    2914:	6f 91       	pop	r22
    2916:	5f 91       	pop	r21
    2918:	4f 91       	pop	r20
    291a:	3f 91       	pop	r19
    291c:	2f 91       	pop	r18
    291e:	0f 90       	pop	r0
    2920:	00 92 3b 00 	sts	0x003B, r0
    2924:	0f 90       	pop	r0
    2926:	0f be       	out	0x3f, r0	; 63
    2928:	0f 90       	pop	r0
    292a:	1f 90       	pop	r1
    292c:	18 95       	reti

0000292e <__vector_81>:

ISR(TCD0_CCC_vect) {
    292e:	1f 92       	push	r1
    2930:	0f 92       	push	r0
    2932:	0f b6       	in	r0, 0x3f	; 63
    2934:	0f 92       	push	r0
    2936:	00 90 3b 00 	lds	r0, 0x003B
    293a:	0f 92       	push	r0
    293c:	11 24       	eor	r1, r1
    293e:	2f 93       	push	r18
    2940:	3f 93       	push	r19
    2942:	4f 93       	push	r20
    2944:	5f 93       	push	r21
    2946:	6f 93       	push	r22
    2948:	7f 93       	push	r23
    294a:	8f 93       	push	r24
    294c:	9f 93       	push	r25
    294e:	af 93       	push	r26
    2950:	bf 93       	push	r27
    2952:	ef 93       	push	r30
    2954:	ff 93       	push	r31
    2956:	cf 93       	push	r28
    2958:	df 93       	push	r29
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    295e:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    2962:	df 91       	pop	r29
    2964:	cf 91       	pop	r28
    2966:	ff 91       	pop	r31
    2968:	ef 91       	pop	r30
    296a:	bf 91       	pop	r27
    296c:	af 91       	pop	r26
    296e:	9f 91       	pop	r25
    2970:	8f 91       	pop	r24
    2972:	7f 91       	pop	r23
    2974:	6f 91       	pop	r22
    2976:	5f 91       	pop	r21
    2978:	4f 91       	pop	r20
    297a:	3f 91       	pop	r19
    297c:	2f 91       	pop	r18
    297e:	0f 90       	pop	r0
    2980:	00 92 3b 00 	sts	0x003B, r0
    2984:	0f 90       	pop	r0
    2986:	0f be       	out	0x3f, r0	; 63
    2988:	0f 90       	pop	r0
    298a:	1f 90       	pop	r1
    298c:	18 95       	reti

0000298e <__vector_82>:

ISR(TCD0_CCD_vect) {
    298e:	1f 92       	push	r1
    2990:	0f 92       	push	r0
    2992:	0f b6       	in	r0, 0x3f	; 63
    2994:	0f 92       	push	r0
    2996:	00 90 3b 00 	lds	r0, 0x003B
    299a:	0f 92       	push	r0
    299c:	11 24       	eor	r1, r1
    299e:	2f 93       	push	r18
    29a0:	3f 93       	push	r19
    29a2:	4f 93       	push	r20
    29a4:	5f 93       	push	r21
    29a6:	6f 93       	push	r22
    29a8:	7f 93       	push	r23
    29aa:	8f 93       	push	r24
    29ac:	9f 93       	push	r25
    29ae:	af 93       	push	r26
    29b0:	bf 93       	push	r27
    29b2:	ef 93       	push	r30
    29b4:	ff 93       	push	r31
    29b6:	cf 93       	push	r28
    29b8:	df 93       	push	r29
    29ba:	cd b7       	in	r28, 0x3d	; 61
    29bc:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    29be:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
	SPICount = 0;
    29c2:	10 92 b7 50 	sts	0x50B7, r1
}
    29c6:	df 91       	pop	r29
    29c8:	cf 91       	pop	r28
    29ca:	ff 91       	pop	r31
    29cc:	ef 91       	pop	r30
    29ce:	bf 91       	pop	r27
    29d0:	af 91       	pop	r26
    29d2:	9f 91       	pop	r25
    29d4:	8f 91       	pop	r24
    29d6:	7f 91       	pop	r23
    29d8:	6f 91       	pop	r22
    29da:	5f 91       	pop	r21
    29dc:	4f 91       	pop	r20
    29de:	3f 91       	pop	r19
    29e0:	2f 91       	pop	r18
    29e2:	0f 90       	pop	r0
    29e4:	00 92 3b 00 	sts	0x003B, r0
    29e8:	0f 90       	pop	r0
    29ea:	0f be       	out	0x3f, r0	; 63
    29ec:	0f 90       	pop	r0
    29ee:	1f 90       	pop	r1
    29f0:	18 95       	reti

000029f2 <__vector_77>:

ISR(TCD0_OVF_vect) {
    29f2:	1f 92       	push	r1
    29f4:	0f 92       	push	r0
    29f6:	0f b6       	in	r0, 0x3f	; 63
    29f8:	0f 92       	push	r0
    29fa:	00 90 3b 00 	lds	r0, 0x003B
    29fe:	0f 92       	push	r0
    2a00:	11 24       	eor	r1, r1
    2a02:	2f 93       	push	r18
    2a04:	3f 93       	push	r19
    2a06:	4f 93       	push	r20
    2a08:	5f 93       	push	r21
    2a0a:	6f 93       	push	r22
    2a0c:	7f 93       	push	r23
    2a0e:	8f 93       	push	r24
    2a10:	9f 93       	push	r25
    2a12:	af 93       	push	r26
    2a14:	bf 93       	push	r27
    2a16:	ef 93       	push	r30
    2a18:	ff 93       	push	r31
    2a1a:	cf 93       	push	r28
    2a1c:	df 93       	push	r29
    2a1e:	cd b7       	in	r28, 0x3d	; 61
    2a20:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    2a22:	0e 94 89 15 	call	0x2b12	; 0x2b12 <writeSE2FRAM>
}
    2a26:	df 91       	pop	r29
    2a28:	cf 91       	pop	r28
    2a2a:	ff 91       	pop	r31
    2a2c:	ef 91       	pop	r30
    2a2e:	bf 91       	pop	r27
    2a30:	af 91       	pop	r26
    2a32:	9f 91       	pop	r25
    2a34:	8f 91       	pop	r24
    2a36:	7f 91       	pop	r23
    2a38:	6f 91       	pop	r22
    2a3a:	5f 91       	pop	r21
    2a3c:	4f 91       	pop	r20
    2a3e:	3f 91       	pop	r19
    2a40:	2f 91       	pop	r18
    2a42:	0f 90       	pop	r0
    2a44:	00 92 3b 00 	sts	0x003B, r0
    2a48:	0f 90       	pop	r0
    2a4a:	0f be       	out	0x3f, r0	; 63
    2a4c:	0f 90       	pop	r0
    2a4e:	1f 90       	pop	r1
    2a50:	18 95       	reti

00002a52 <sampleCurrentChannel>:

void sampleCurrentChannel() {
    2a52:	cf 93       	push	r28
    2a54:	df 93       	push	r29
    2a56:	cd b7       	in	r28, 0x3d	; 61
    2a58:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2a5a:	80 ea       	ldi	r24, 0xA0	; 160
    2a5c:	96 e0       	ldi	r25, 0x06	; 6
    2a5e:	22 e0       	ldi	r18, 0x02	; 2
    2a60:	fc 01       	movw	r30, r24
    2a62:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2a64:	80 ec       	ldi	r24, 0xC0	; 192
    2a66:	98 e0       	ldi	r25, 0x08	; 8
    2a68:	2a ea       	ldi	r18, 0xAA	; 170
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a6e:	00 00       	nop
    2a70:	80 ec       	ldi	r24, 0xC0	; 192
    2a72:	98 e0       	ldi	r25, 0x08	; 8
    2a74:	fc 01       	movw	r30, r24
    2a76:	82 81       	ldd	r24, Z+2	; 0x02
    2a78:	88 23       	and	r24, r24
    2a7a:	d4 f7       	brge	.-12     	; 0x2a70 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    2a7c:	80 91 b7 50 	lds	r24, 0x50B7
    2a80:	88 2f       	mov	r24, r24
    2a82:	90 e0       	ldi	r25, 0x00	; 0
    2a84:	20 ec       	ldi	r18, 0xC0	; 192
    2a86:	38 e0       	ldi	r19, 0x08	; 8
    2a88:	f9 01       	movw	r30, r18
    2a8a:	23 81       	ldd	r18, Z+3	; 0x03
    2a8c:	8b 5b       	subi	r24, 0xBB	; 187
    2a8e:	9f 4a       	sbci	r25, 0xAF	; 175
    2a90:	fc 01       	movw	r30, r24
    2a92:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2a94:	80 ec       	ldi	r24, 0xC0	; 192
    2a96:	98 e0       	ldi	r25, 0x08	; 8
    2a98:	2a ea       	ldi	r18, 0xAA	; 170
    2a9a:	fc 01       	movw	r30, r24
    2a9c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a9e:	00 00       	nop
    2aa0:	80 ec       	ldi	r24, 0xC0	; 192
    2aa2:	98 e0       	ldi	r25, 0x08	; 8
    2aa4:	fc 01       	movw	r30, r24
    2aa6:	82 81       	ldd	r24, Z+2	; 0x02
    2aa8:	88 23       	and	r24, r24
    2aaa:	d4 f7       	brge	.-12     	; 0x2aa0 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2aac:	80 91 b7 50 	lds	r24, 0x50B7
    2ab0:	88 2f       	mov	r24, r24
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	01 96       	adiw	r24, 0x01	; 1
    2ab6:	20 ec       	ldi	r18, 0xC0	; 192
    2ab8:	38 e0       	ldi	r19, 0x08	; 8
    2aba:	f9 01       	movw	r30, r18
    2abc:	23 81       	ldd	r18, Z+3	; 0x03
    2abe:	8b 5b       	subi	r24, 0xBB	; 187
    2ac0:	9f 4a       	sbci	r25, 0xAF	; 175
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2ac6:	80 ec       	ldi	r24, 0xC0	; 192
    2ac8:	98 e0       	ldi	r25, 0x08	; 8
    2aca:	2a ea       	ldi	r18, 0xAA	; 170
    2acc:	fc 01       	movw	r30, r24
    2ace:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ad0:	00 00       	nop
    2ad2:	80 ec       	ldi	r24, 0xC0	; 192
    2ad4:	98 e0       	ldi	r25, 0x08	; 8
    2ad6:	fc 01       	movw	r30, r24
    2ad8:	82 81       	ldd	r24, Z+2	; 0x02
    2ada:	88 23       	and	r24, r24
    2adc:	d4 f7       	brge	.-12     	; 0x2ad2 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2ade:	80 91 b7 50 	lds	r24, 0x50B7
    2ae2:	88 2f       	mov	r24, r24
    2ae4:	90 e0       	ldi	r25, 0x00	; 0
    2ae6:	02 96       	adiw	r24, 0x02	; 2
    2ae8:	20 ec       	ldi	r18, 0xC0	; 192
    2aea:	38 e0       	ldi	r19, 0x08	; 8
    2aec:	f9 01       	movw	r30, r18
    2aee:	23 81       	ldd	r18, Z+3	; 0x03
    2af0:	8b 5b       	subi	r24, 0xBB	; 187
    2af2:	9f 4a       	sbci	r25, 0xAF	; 175
    2af4:	fc 01       	movw	r30, r24
    2af6:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2af8:	80 ea       	ldi	r24, 0xA0	; 160
    2afa:	96 e0       	ldi	r25, 0x06	; 6
    2afc:	22 e0       	ldi	r18, 0x02	; 2
    2afe:	fc 01       	movw	r30, r24
    2b00:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2b02:	80 91 b7 50 	lds	r24, 0x50B7
    2b06:	8d 5f       	subi	r24, 0xFD	; 253
    2b08:	80 93 b7 50 	sts	0x50B7, r24
}
    2b0c:	df 91       	pop	r29
    2b0e:	cf 91       	pop	r28
    2b10:	08 95       	ret

00002b12 <writeSE2FRAM>:

void writeSE2FRAM() {
    2b12:	cf 93       	push	r28
    2b14:	df 93       	push	r29
    2b16:	cd b7       	in	r28, 0x3d	; 61
    2b18:	de b7       	in	r29, 0x3e	; 62
    2b1a:	29 97       	sbiw	r28, 0x09	; 9
    2b1c:	cd bf       	out	0x3d, r28	; 61
    2b1e:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2b20:	1a 82       	std	Y+2, r1	; 0x02
    2b22:	1b 82       	std	Y+3, r1	; 0x03
    2b24:	1c 82       	std	Y+4, r1	; 0x04
    2b26:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2b28:	80 91 52 50 	lds	r24, 0x5052
    2b2c:	90 91 53 50 	lds	r25, 0x5053
    2b30:	01 96       	adiw	r24, 0x01	; 1
    2b32:	80 93 52 50 	sts	0x5052, r24
    2b36:	90 93 53 50 	sts	0x5053, r25
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2b3a:	80 ec       	ldi	r24, 0xC0	; 192
    2b3c:	98 e0       	ldi	r25, 0x08	; 8
    2b3e:	20 ed       	ldi	r18, 0xD0	; 208
    2b40:	fc 01       	movw	r30, r24
    2b42:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2b44:	19 82       	std	Y+1, r1	; 0x01
    2b46:	4f c0       	rjmp	.+158    	; 0x2be6 <writeSE2FRAM+0xd4>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2b48:	89 81       	ldd	r24, Y+1	; 0x01
    2b4a:	88 2f       	mov	r24, r24
    2b4c:	90 e0       	ldi	r25, 0x00	; 0
    2b4e:	8b 5b       	subi	r24, 0xBB	; 187
    2b50:	9f 4a       	sbci	r25, 0xAF	; 175
    2b52:	fc 01       	movw	r30, r24
    2b54:	80 81       	ld	r24, Z
    2b56:	88 23       	and	r24, r24
    2b58:	3c f4       	brge	.+14     	; 0x2b68 <writeSE2FRAM+0x56>
    2b5a:	ce 01       	movw	r24, r28
    2b5c:	06 96       	adiw	r24, 0x06	; 6
    2b5e:	03 96       	adiw	r24, 0x03	; 3
    2b60:	2f ef       	ldi	r18, 0xFF	; 255
    2b62:	fc 01       	movw	r30, r24
    2b64:	20 83       	st	Z, r18
    2b66:	05 c0       	rjmp	.+10     	; 0x2b72 <writeSE2FRAM+0x60>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2b68:	ce 01       	movw	r24, r28
    2b6a:	06 96       	adiw	r24, 0x06	; 6
    2b6c:	03 96       	adiw	r24, 0x03	; 3
    2b6e:	fc 01       	movw	r30, r24
    2b70:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2b72:	ce 01       	movw	r24, r28
    2b74:	06 96       	adiw	r24, 0x06	; 6
    2b76:	02 96       	adiw	r24, 0x02	; 2
    2b78:	29 81       	ldd	r18, Y+1	; 0x01
    2b7a:	22 2f       	mov	r18, r18
    2b7c:	30 e0       	ldi	r19, 0x00	; 0
    2b7e:	2b 5b       	subi	r18, 0xBB	; 187
    2b80:	3f 4a       	sbci	r19, 0xAF	; 175
    2b82:	f9 01       	movw	r30, r18
    2b84:	20 81       	ld	r18, Z
    2b86:	fc 01       	movw	r30, r24
    2b88:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2b8a:	ce 01       	movw	r24, r28
    2b8c:	06 96       	adiw	r24, 0x06	; 6
    2b8e:	01 96       	adiw	r24, 0x01	; 1
    2b90:	29 81       	ldd	r18, Y+1	; 0x01
    2b92:	22 2f       	mov	r18, r18
    2b94:	30 e0       	ldi	r19, 0x00	; 0
    2b96:	2f 5f       	subi	r18, 0xFF	; 255
    2b98:	3f 4f       	sbci	r19, 0xFF	; 255
    2b9a:	2b 5b       	subi	r18, 0xBB	; 187
    2b9c:	3f 4a       	sbci	r19, 0xAF	; 175
    2b9e:	f9 01       	movw	r30, r18
    2ba0:	20 81       	ld	r18, Z
    2ba2:	fc 01       	movw	r30, r24
    2ba4:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2ba6:	ce 01       	movw	r24, r28
    2ba8:	06 96       	adiw	r24, 0x06	; 6
    2baa:	29 81       	ldd	r18, Y+1	; 0x01
    2bac:	22 2f       	mov	r18, r18
    2bae:	30 e0       	ldi	r19, 0x00	; 0
    2bb0:	2e 5f       	subi	r18, 0xFE	; 254
    2bb2:	3f 4f       	sbci	r19, 0xFF	; 255
    2bb4:	2b 5b       	subi	r18, 0xBB	; 187
    2bb6:	3f 4a       	sbci	r19, 0xAF	; 175
    2bb8:	f9 01       	movw	r30, r18
    2bba:	20 81       	ld	r18, Z
    2bbc:	fc 01       	movw	r30, r24
    2bbe:	20 83       	st	Z, r18
		sum += currentSample;
    2bc0:	2a 81       	ldd	r18, Y+2	; 0x02
    2bc2:	3b 81       	ldd	r19, Y+3	; 0x03
    2bc4:	4c 81       	ldd	r20, Y+4	; 0x04
    2bc6:	5d 81       	ldd	r21, Y+5	; 0x05
    2bc8:	8e 81       	ldd	r24, Y+6	; 0x06
    2bca:	9f 81       	ldd	r25, Y+7	; 0x07
    2bcc:	a8 85       	ldd	r26, Y+8	; 0x08
    2bce:	b9 85       	ldd	r27, Y+9	; 0x09
    2bd0:	82 0f       	add	r24, r18
    2bd2:	93 1f       	adc	r25, r19
    2bd4:	a4 1f       	adc	r26, r20
    2bd6:	b5 1f       	adc	r27, r21
    2bd8:	8a 83       	std	Y+2, r24	; 0x02
    2bda:	9b 83       	std	Y+3, r25	; 0x03
    2bdc:	ac 83       	std	Y+4, r26	; 0x04
    2bde:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2be0:	89 81       	ldd	r24, Y+1	; 0x01
    2be2:	8d 5f       	subi	r24, 0xFD	; 253
    2be4:	89 83       	std	Y+1, r24	; 0x01
    2be6:	89 81       	ldd	r24, Y+1	; 0x01
    2be8:	8c 30       	cpi	r24, 0x0C	; 12
    2bea:	08 f4       	brcc	.+2      	; 0x2bee <writeSE2FRAM+0xdc>
    2bec:	ad cf       	rjmp	.-166    	; 0x2b48 <writeSE2FRAM+0x36>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2bee:	8a 81       	ldd	r24, Y+2	; 0x02
    2bf0:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf2:	ac 81       	ldd	r26, Y+4	; 0x04
    2bf4:	bd 81       	ldd	r27, Y+5	; 0x05
    2bf6:	24 e0       	ldi	r18, 0x04	; 4
    2bf8:	30 e0       	ldi	r19, 0x00	; 0
    2bfa:	40 e0       	ldi	r20, 0x00	; 0
    2bfc:	50 e0       	ldi	r21, 0x00	; 0
    2bfe:	bc 01       	movw	r22, r24
    2c00:	cd 01       	movw	r24, r26
    2c02:	0e 94 b7 5c 	call	0xb96e	; 0xb96e <__divmodsi4>
    2c06:	da 01       	movw	r26, r20
    2c08:	c9 01       	movw	r24, r18
    2c0a:	8a 83       	std	Y+2, r24	; 0x02
    2c0c:	9b 83       	std	Y+3, r25	; 0x03
    2c0e:	ac 83       	std	Y+4, r26	; 0x04
    2c10:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2c12:	ce 01       	movw	r24, r28
    2c14:	02 96       	adiw	r24, 0x02	; 2
    2c16:	fc 01       	movw	r30, r24
    2c18:	80 81       	ld	r24, Z
    2c1a:	80 93 47 50 	sts	0x5047, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2c1e:	ce 01       	movw	r24, r28
    2c20:	02 96       	adiw	r24, 0x02	; 2
    2c22:	fc 01       	movw	r30, r24
    2c24:	81 81       	ldd	r24, Z+1	; 0x01
    2c26:	80 93 46 50 	sts	0x5046, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2c2a:	ce 01       	movw	r24, r28
    2c2c:	02 96       	adiw	r24, 0x02	; 2
    2c2e:	fc 01       	movw	r30, r24
    2c30:	82 81       	ldd	r24, Z+2	; 0x02
    2c32:	80 93 45 50 	sts	0x5045, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2c36:	80 e4       	ldi	r24, 0x40	; 64
    2c38:	96 e0       	ldi	r25, 0x06	; 6
    2c3a:	20 e1       	ldi	r18, 0x10	; 16
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2c40:	80 e2       	ldi	r24, 0x20	; 32
    2c42:	96 e0       	ldi	r25, 0x06	; 6
    2c44:	28 e0       	ldi	r18, 0x08	; 8
    2c46:	fc 01       	movw	r30, r24
    2c48:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2c4a:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2c4c:	80 ec       	ldi	r24, 0xC0	; 192
    2c4e:	98 e0       	ldi	r25, 0x08	; 8
    2c50:	26 e0       	ldi	r18, 0x06	; 6
    2c52:	fc 01       	movw	r30, r24
    2c54:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2c56:	00 00       	nop
    2c58:	80 ec       	ldi	r24, 0xC0	; 192
    2c5a:	98 e0       	ldi	r25, 0x08	; 8
    2c5c:	fc 01       	movw	r30, r24
    2c5e:	82 81       	ldd	r24, Z+2	; 0x02
    2c60:	88 23       	and	r24, r24
    2c62:	d4 f7       	brge	.-12     	; 0x2c58 <writeSE2FRAM+0x146>
	SPIBuffer[12] = SPIC.DATA;
    2c64:	80 ec       	ldi	r24, 0xC0	; 192
    2c66:	98 e0       	ldi	r25, 0x08	; 8
    2c68:	fc 01       	movw	r30, r24
    2c6a:	83 81       	ldd	r24, Z+3	; 0x03
    2c6c:	80 93 51 50 	sts	0x5051, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2c70:	80 e2       	ldi	r24, 0x20	; 32
    2c72:	96 e0       	ldi	r25, 0x06	; 6
    2c74:	28 e0       	ldi	r18, 0x08	; 8
    2c76:	fc 01       	movw	r30, r24
    2c78:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2c7a:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2c7c:	80 e2       	ldi	r24, 0x20	; 32
    2c7e:	96 e0       	ldi	r25, 0x06	; 6
    2c80:	28 e0       	ldi	r18, 0x08	; 8
    2c82:	fc 01       	movw	r30, r24
    2c84:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2c86:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2c88:	80 ec       	ldi	r24, 0xC0	; 192
    2c8a:	98 e0       	ldi	r25, 0x08	; 8
    2c8c:	22 e0       	ldi	r18, 0x02	; 2
    2c8e:	fc 01       	movw	r30, r24
    2c90:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2c92:	00 00       	nop
    2c94:	80 ec       	ldi	r24, 0xC0	; 192
    2c96:	98 e0       	ldi	r25, 0x08	; 8
    2c98:	fc 01       	movw	r30, r24
    2c9a:	82 81       	ldd	r24, Z+2	; 0x02
    2c9c:	88 23       	and	r24, r24
    2c9e:	d4 f7       	brge	.-12     	; 0x2c94 <writeSE2FRAM+0x182>
	SPIBuffer[12] = SPIC.DATA;
    2ca0:	80 ec       	ldi	r24, 0xC0	; 192
    2ca2:	98 e0       	ldi	r25, 0x08	; 8
    2ca4:	fc 01       	movw	r30, r24
    2ca6:	83 81       	ldd	r24, Z+3	; 0x03
    2ca8:	80 93 51 50 	sts	0x5051, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2cac:	80 ec       	ldi	r24, 0xC0	; 192
    2cae:	98 e0       	ldi	r25, 0x08	; 8
    2cb0:	20 91 39 40 	lds	r18, 0x4039
    2cb4:	fc 01       	movw	r30, r24
    2cb6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2cb8:	00 00       	nop
    2cba:	80 ec       	ldi	r24, 0xC0	; 192
    2cbc:	98 e0       	ldi	r25, 0x08	; 8
    2cbe:	fc 01       	movw	r30, r24
    2cc0:	82 81       	ldd	r24, Z+2	; 0x02
    2cc2:	88 23       	and	r24, r24
    2cc4:	d4 f7       	brge	.-12     	; 0x2cba <writeSE2FRAM+0x1a8>
	SPIBuffer[12] = SPIC.DATA;
    2cc6:	80 ec       	ldi	r24, 0xC0	; 192
    2cc8:	98 e0       	ldi	r25, 0x08	; 8
    2cca:	fc 01       	movw	r30, r24
    2ccc:	83 81       	ldd	r24, Z+3	; 0x03
    2cce:	80 93 51 50 	sts	0x5051, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2cd2:	80 ec       	ldi	r24, 0xC0	; 192
    2cd4:	98 e0       	ldi	r25, 0x08	; 8
    2cd6:	28 e3       	ldi	r18, 0x38	; 56
    2cd8:	30 e4       	ldi	r19, 0x40	; 64
    2cda:	f9 01       	movw	r30, r18
    2cdc:	20 81       	ld	r18, Z
    2cde:	fc 01       	movw	r30, r24
    2ce0:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ce2:	00 00       	nop
    2ce4:	80 ec       	ldi	r24, 0xC0	; 192
    2ce6:	98 e0       	ldi	r25, 0x08	; 8
    2ce8:	fc 01       	movw	r30, r24
    2cea:	82 81       	ldd	r24, Z+2	; 0x02
    2cec:	88 23       	and	r24, r24
    2cee:	d4 f7       	brge	.-12     	; 0x2ce4 <writeSE2FRAM+0x1d2>
	SPIBuffer[12] = SPIC.DATA;
    2cf0:	80 ec       	ldi	r24, 0xC0	; 192
    2cf2:	98 e0       	ldi	r25, 0x08	; 8
    2cf4:	fc 01       	movw	r30, r24
    2cf6:	83 81       	ldd	r24, Z+3	; 0x03
    2cf8:	80 93 51 50 	sts	0x5051, r24
	SPIC.DATA = SPIBuffer[0];
    2cfc:	80 ec       	ldi	r24, 0xC0	; 192
    2cfe:	98 e0       	ldi	r25, 0x08	; 8
    2d00:	20 91 45 50 	lds	r18, 0x5045
    2d04:	fc 01       	movw	r30, r24
    2d06:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d08:	00 00       	nop
    2d0a:	80 ec       	ldi	r24, 0xC0	; 192
    2d0c:	98 e0       	ldi	r25, 0x08	; 8
    2d0e:	fc 01       	movw	r30, r24
    2d10:	82 81       	ldd	r24, Z+2	; 0x02
    2d12:	88 23       	and	r24, r24
    2d14:	d4 f7       	brge	.-12     	; 0x2d0a <writeSE2FRAM+0x1f8>
	SPIBuffer[12] = SPIC.DATA;
    2d16:	80 ec       	ldi	r24, 0xC0	; 192
    2d18:	98 e0       	ldi	r25, 0x08	; 8
    2d1a:	fc 01       	movw	r30, r24
    2d1c:	83 81       	ldd	r24, Z+3	; 0x03
    2d1e:	80 93 51 50 	sts	0x5051, r24
	SPIC.DATA = SPIBuffer[1];
    2d22:	80 ec       	ldi	r24, 0xC0	; 192
    2d24:	98 e0       	ldi	r25, 0x08	; 8
    2d26:	20 91 46 50 	lds	r18, 0x5046
    2d2a:	fc 01       	movw	r30, r24
    2d2c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d2e:	00 00       	nop
    2d30:	80 ec       	ldi	r24, 0xC0	; 192
    2d32:	98 e0       	ldi	r25, 0x08	; 8
    2d34:	fc 01       	movw	r30, r24
    2d36:	82 81       	ldd	r24, Z+2	; 0x02
    2d38:	88 23       	and	r24, r24
    2d3a:	d4 f7       	brge	.-12     	; 0x2d30 <writeSE2FRAM+0x21e>
	SPIBuffer[12] = SPIC.DATA;
    2d3c:	80 ec       	ldi	r24, 0xC0	; 192
    2d3e:	98 e0       	ldi	r25, 0x08	; 8
    2d40:	fc 01       	movw	r30, r24
    2d42:	83 81       	ldd	r24, Z+3	; 0x03
    2d44:	80 93 51 50 	sts	0x5051, r24
	SPIC.DATA = SPIBuffer[2];
    2d48:	80 ec       	ldi	r24, 0xC0	; 192
    2d4a:	98 e0       	ldi	r25, 0x08	; 8
    2d4c:	20 91 47 50 	lds	r18, 0x5047
    2d50:	fc 01       	movw	r30, r24
    2d52:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d54:	00 00       	nop
    2d56:	80 ec       	ldi	r24, 0xC0	; 192
    2d58:	98 e0       	ldi	r25, 0x08	; 8
    2d5a:	fc 01       	movw	r30, r24
    2d5c:	82 81       	ldd	r24, Z+2	; 0x02
    2d5e:	88 23       	and	r24, r24
    2d60:	d4 f7       	brge	.-12     	; 0x2d56 <writeSE2FRAM+0x244>
	SPIBuffer[12] = SPIC.DATA;
    2d62:	80 ec       	ldi	r24, 0xC0	; 192
    2d64:	98 e0       	ldi	r25, 0x08	; 8
    2d66:	fc 01       	movw	r30, r24
    2d68:	83 81       	ldd	r24, Z+3	; 0x03
    2d6a:	80 93 51 50 	sts	0x5051, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2d6e:	80 e2       	ldi	r24, 0x20	; 32
    2d70:	96 e0       	ldi	r25, 0x06	; 6
    2d72:	28 e0       	ldi	r18, 0x08	; 8
    2d74:	fc 01       	movw	r30, r24
    2d76:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2d78:	80 e4       	ldi	r24, 0x40	; 64
    2d7a:	96 e0       	ldi	r25, 0x06	; 6
    2d7c:	20 e1       	ldi	r18, 0x10	; 16
    2d7e:	fc 01       	movw	r30, r24
    2d80:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2d82:	80 ec       	ldi	r24, 0xC0	; 192
    2d84:	98 e0       	ldi	r25, 0x08	; 8
    2d86:	24 e5       	ldi	r18, 0x54	; 84
    2d88:	fc 01       	movw	r30, r24
    2d8a:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2d8c:	80 e4       	ldi	r24, 0x40	; 64
    2d8e:	96 e0       	ldi	r25, 0x06	; 6
    2d90:	20 e1       	ldi	r18, 0x10	; 16
    2d92:	fc 01       	movw	r30, r24
    2d94:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2d96:	80 91 38 40 	lds	r24, 0x4038
    2d9a:	90 91 39 40 	lds	r25, 0x4039
    2d9e:	03 96       	adiw	r24, 0x03	; 3
    2da0:	80 93 38 40 	sts	0x4038, r24
    2da4:	90 93 39 40 	sts	0x4039, r25
	checksumADC[0] += SPIBuffer[0];
    2da8:	90 91 1a 21 	lds	r25, 0x211A
    2dac:	80 91 45 50 	lds	r24, 0x5045
    2db0:	89 0f       	add	r24, r25
    2db2:	80 93 1a 21 	sts	0x211A, r24
	checksumADC[1] += SPIBuffer[1];
    2db6:	90 91 1b 21 	lds	r25, 0x211B
    2dba:	80 91 46 50 	lds	r24, 0x5046
    2dbe:	89 0f       	add	r24, r25
    2dc0:	80 93 1b 21 	sts	0x211B, r24
	checksumADC[2] += SPIBuffer[2];
    2dc4:	90 91 1c 21 	lds	r25, 0x211C
    2dc8:	80 91 47 50 	lds	r24, 0x5047
    2dcc:	89 0f       	add	r24, r25
    2dce:	80 93 1c 21 	sts	0x211C, r24
}
    2dd2:	29 96       	adiw	r28, 0x09	; 9
    2dd4:	cd bf       	out	0x3d, r28	; 61
    2dd6:	de bf       	out	0x3e, r29	; 62
    2dd8:	df 91       	pop	r29
    2dda:	cf 91       	pop	r28
    2ddc:	08 95       	ret

00002dde <calcChecksumFRAM>:


void calcChecksumFRAM() {
    2dde:	2f 92       	push	r2
    2de0:	3f 92       	push	r3
    2de2:	4f 92       	push	r4
    2de4:	5f 92       	push	r5
    2de6:	6f 92       	push	r6
    2de8:	7f 92       	push	r7
    2dea:	8f 92       	push	r8
    2dec:	9f 92       	push	r9
    2dee:	af 92       	push	r10
    2df0:	bf 92       	push	r11
    2df2:	cf 92       	push	r12
    2df4:	df 92       	push	r13
    2df6:	ef 92       	push	r14
    2df8:	ff 92       	push	r15
    2dfa:	0f 93       	push	r16
    2dfc:	1f 93       	push	r17
    2dfe:	cf 93       	push	r28
    2e00:	df 93       	push	r29
    2e02:	00 d0       	rcall	.+0      	; 0x2e04 <calcChecksumFRAM+0x26>
    2e04:	0f 92       	push	r0
    2e06:	cd b7       	in	r28, 0x3d	; 61
    2e08:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2e0a:	aa 24       	eor	r10, r10
    2e0c:	bb 24       	eor	r11, r11
    2e0e:	cc 24       	eor	r12, r12
    2e10:	dd 24       	eor	r13, r13
    2e12:	ee 24       	eor	r14, r14
    2e14:	ff 24       	eor	r15, r15
    2e16:	00 e0       	ldi	r16, 0x00	; 0
    2e18:	10 e0       	ldi	r17, 0x00	; 0
    2e1a:	a0 92 75 50 	sts	0x5075, r10
    2e1e:	b0 92 76 50 	sts	0x5076, r11
    2e22:	c0 92 77 50 	sts	0x5077, r12
    2e26:	d0 92 78 50 	sts	0x5078, r13
    2e2a:	e0 92 79 50 	sts	0x5079, r14
    2e2e:	f0 92 7a 50 	sts	0x507A, r15
    2e32:	00 93 7b 50 	sts	0x507B, r16
    2e36:	10 93 7c 50 	sts	0x507C, r17
    2e3a:	2a 2d       	mov	r18, r10
    2e3c:	3b 2d       	mov	r19, r11
    2e3e:	4c 2d       	mov	r20, r12
    2e40:	5d 2d       	mov	r21, r13
    2e42:	6e 2d       	mov	r22, r14
    2e44:	7f 2d       	mov	r23, r15
    2e46:	80 2f       	mov	r24, r16
    2e48:	91 2f       	mov	r25, r17
    2e4a:	20 93 6d 50 	sts	0x506D, r18
    2e4e:	30 93 6e 50 	sts	0x506E, r19
    2e52:	40 93 6f 50 	sts	0x506F, r20
    2e56:	50 93 70 50 	sts	0x5070, r21
    2e5a:	60 93 71 50 	sts	0x5071, r22
    2e5e:	70 93 72 50 	sts	0x5072, r23
    2e62:	80 93 73 50 	sts	0x5073, r24
    2e66:	90 93 74 50 	sts	0x5074, r25
    2e6a:	20 93 65 50 	sts	0x5065, r18
    2e6e:	30 93 66 50 	sts	0x5066, r19
    2e72:	40 93 67 50 	sts	0x5067, r20
    2e76:	50 93 68 50 	sts	0x5068, r21
    2e7a:	60 93 69 50 	sts	0x5069, r22
    2e7e:	70 93 6a 50 	sts	0x506A, r23
    2e82:	80 93 6b 50 	sts	0x506B, r24
    2e86:	90 93 6c 50 	sts	0x506C, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2e8a:	80 e0       	ldi	r24, 0x00	; 0
    2e8c:	80 93 1f 21 	sts	0x211F, r24
    2e90:	80 93 1e 21 	sts	0x211E, r24
    2e94:	80 93 1d 21 	sts	0x211D, r24
	FRAMAddress = FR_BASEADD;
    2e98:	10 92 38 40 	sts	0x4038, r1
    2e9c:	10 92 39 40 	sts	0x4039, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2ea0:	19 82       	std	Y+1, r1	; 0x01
    2ea2:	1a 82       	std	Y+2, r1	; 0x02
    2ea4:	88 c2       	rjmp	.+1296   	; 0x33b6 <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2ea6:	81 e7       	ldi	r24, 0x71	; 113
    2ea8:	9c e1       	ldi	r25, 0x1C	; 28
    2eaa:	0e 94 ee 38 	call	0x71dc	; 0x71dc <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2eae:	80 91 38 40 	lds	r24, 0x4038
    2eb2:	90 91 39 40 	lds	r25, 0x4039
    2eb6:	8f 58       	subi	r24, 0x8F	; 143
    2eb8:	93 4e       	sbci	r25, 0xE3	; 227
    2eba:	80 93 38 40 	sts	0x4038, r24
    2ebe:	90 93 39 40 	sts	0x4039, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2ec2:	1b 82       	std	Y+3, r1	; 0x03
    2ec4:	1c 82       	std	Y+4, r1	; 0x04
    2ec6:	6b c2       	rjmp	.+1238   	; 0x339e <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2ec8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eca:	9c 81       	ldd	r25, Y+4	; 0x04
    2ecc:	23 e0       	ldi	r18, 0x03	; 3
    2ece:	30 e0       	ldi	r19, 0x00	; 0
    2ed0:	b9 01       	movw	r22, r18
    2ed2:	0e 94 6e 5c 	call	0xb8dc	; 0xb8dc <__udivmodhi4>
    2ed6:	9c 01       	movw	r18, r24
    2ed8:	23 5e       	subi	r18, 0xE3	; 227
    2eda:	3e 4d       	sbci	r19, 0xDE	; 222
    2edc:	f9 01       	movw	r30, r18
    2ede:	40 81       	ld	r20, Z
    2ee0:	2b 81       	ldd	r18, Y+3	; 0x03
    2ee2:	3c 81       	ldd	r19, Y+4	; 0x04
    2ee4:	20 54       	subi	r18, 0x40	; 64
    2ee6:	3c 4d       	sbci	r19, 0xDC	; 220
    2ee8:	f9 01       	movw	r30, r18
    2eea:	20 81       	ld	r18, Z
    2eec:	24 0f       	add	r18, r20
    2eee:	83 5e       	subi	r24, 0xE3	; 227
    2ef0:	9e 4d       	sbci	r25, 0xDE	; 222
    2ef2:	fc 01       	movw	r30, r24
    2ef4:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    2efa:	23 e0       	ldi	r18, 0x03	; 3
    2efc:	30 e0       	ldi	r19, 0x00	; 0
    2efe:	b9 01       	movw	r22, r18
    2f00:	0e 94 6e 5c 	call	0xb8dc	; 0xb8dc <__udivmodhi4>
    2f04:	00 97       	sbiw	r24, 0x00	; 0
    2f06:	09 f0       	breq	.+2      	; 0x2f0a <calcChecksumFRAM+0x12c>
    2f08:	44 c0       	rjmp	.+136    	; 0x2f92 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f0e:	80 54       	subi	r24, 0x40	; 64
    2f10:	9c 4d       	sbci	r25, 0xDC	; 220
    2f12:	fc 01       	movw	r30, r24
    2f14:	80 81       	ld	r24, Z
    2f16:	88 23       	and	r24, r24
    2f18:	d4 f4       	brge	.+52     	; 0x2f4e <calcChecksumFRAM+0x170>
    2f1a:	80 91 43 50 	lds	r24, 0x5043
    2f1e:	90 91 44 50 	lds	r25, 0x5044
    2f22:	fc 01       	movw	r30, r24
    2f24:	10 82       	st	Z, r1
    2f26:	fc 01       	movw	r30, r24
    2f28:	11 82       	std	Z+1, r1	; 0x01
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	12 82       	std	Z+2, r1	; 0x02
    2f2e:	2f ef       	ldi	r18, 0xFF	; 255
    2f30:	fc 01       	movw	r30, r24
    2f32:	23 83       	std	Z+3, r18	; 0x03
    2f34:	2f ef       	ldi	r18, 0xFF	; 255
    2f36:	fc 01       	movw	r30, r24
    2f38:	24 83       	std	Z+4, r18	; 0x04
    2f3a:	2f ef       	ldi	r18, 0xFF	; 255
    2f3c:	fc 01       	movw	r30, r24
    2f3e:	25 83       	std	Z+5, r18	; 0x05
    2f40:	2f ef       	ldi	r18, 0xFF	; 255
    2f42:	fc 01       	movw	r30, r24
    2f44:	26 83       	std	Z+6, r18	; 0x06
    2f46:	2f ef       	ldi	r18, 0xFF	; 255
    2f48:	fc 01       	movw	r30, r24
    2f4a:	27 83       	std	Z+7, r18	; 0x07
    2f4c:	14 c0       	rjmp	.+40     	; 0x2f76 <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2f4e:	80 91 43 50 	lds	r24, 0x5043
    2f52:	90 91 44 50 	lds	r25, 0x5044
    2f56:	fc 01       	movw	r30, r24
    2f58:	10 82       	st	Z, r1
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	11 82       	std	Z+1, r1	; 0x01
    2f5e:	fc 01       	movw	r30, r24
    2f60:	12 82       	std	Z+2, r1	; 0x02
    2f62:	fc 01       	movw	r30, r24
    2f64:	13 82       	std	Z+3, r1	; 0x03
    2f66:	fc 01       	movw	r30, r24
    2f68:	14 82       	std	Z+4, r1	; 0x04
    2f6a:	fc 01       	movw	r30, r24
    2f6c:	15 82       	std	Z+5, r1	; 0x05
    2f6e:	fc 01       	movw	r30, r24
    2f70:	16 82       	std	Z+6, r1	; 0x06
    2f72:	fc 01       	movw	r30, r24
    2f74:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2f76:	80 91 43 50 	lds	r24, 0x5043
    2f7a:	90 91 44 50 	lds	r25, 0x5044
    2f7e:	02 96       	adiw	r24, 0x02	; 2
    2f80:	2b 81       	ldd	r18, Y+3	; 0x03
    2f82:	3c 81       	ldd	r19, Y+4	; 0x04
    2f84:	20 54       	subi	r18, 0x40	; 64
    2f86:	3c 4d       	sbci	r19, 0xDC	; 220
    2f88:	f9 01       	movw	r30, r18
    2f8a:	20 81       	ld	r18, Z
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	20 83       	st	Z, r18
    2f90:	24 c0       	rjmp	.+72     	; 0x2fda <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2f92:	8b 81       	ldd	r24, Y+3	; 0x03
    2f94:	9c 81       	ldd	r25, Y+4	; 0x04
    2f96:	23 e0       	ldi	r18, 0x03	; 3
    2f98:	30 e0       	ldi	r19, 0x00	; 0
    2f9a:	b9 01       	movw	r22, r18
    2f9c:	0e 94 6e 5c 	call	0xb8dc	; 0xb8dc <__udivmodhi4>
    2fa0:	81 30       	cpi	r24, 0x01	; 1
    2fa2:	91 05       	cpc	r25, r1
    2fa4:	71 f4       	brne	.+28     	; 0x2fc2 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2fa6:	80 91 43 50 	lds	r24, 0x5043
    2faa:	90 91 44 50 	lds	r25, 0x5044
    2fae:	01 96       	adiw	r24, 0x01	; 1
    2fb0:	2b 81       	ldd	r18, Y+3	; 0x03
    2fb2:	3c 81       	ldd	r19, Y+4	; 0x04
    2fb4:	20 54       	subi	r18, 0x40	; 64
    2fb6:	3c 4d       	sbci	r19, 0xDC	; 220
    2fb8:	f9 01       	movw	r30, r18
    2fba:	20 81       	ld	r18, Z
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	20 83       	st	Z, r18
    2fc0:	0c c0       	rjmp	.+24     	; 0x2fda <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2fc2:	80 91 43 50 	lds	r24, 0x5043
    2fc6:	90 91 44 50 	lds	r25, 0x5044
    2fca:	2b 81       	ldd	r18, Y+3	; 0x03
    2fcc:	3c 81       	ldd	r19, Y+4	; 0x04
    2fce:	20 54       	subi	r18, 0x40	; 64
    2fd0:	3c 4d       	sbci	r19, 0xDC	; 220
    2fd2:	f9 01       	movw	r30, r18
    2fd4:	20 81       	ld	r18, Z
    2fd6:	fc 01       	movw	r30, r24
    2fd8:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2fda:	8b 81       	ldd	r24, Y+3	; 0x03
    2fdc:	9c 81       	ldd	r25, Y+4	; 0x04
    2fde:	29 e0       	ldi	r18, 0x09	; 9
    2fe0:	30 e0       	ldi	r19, 0x00	; 0
    2fe2:	b9 01       	movw	r22, r18
    2fe4:	0e 94 6e 5c 	call	0xb8dc	; 0xb8dc <__udivmodhi4>
    2fe8:	82 30       	cpi	r24, 0x02	; 2
    2fea:	91 05       	cpc	r25, r1
    2fec:	09 f0       	breq	.+2      	; 0x2ff0 <calcChecksumFRAM+0x212>
    2fee:	94 c0       	rjmp	.+296    	; 0x3118 <calcChecksumFRAM+0x33a>
    2ff0:	a0 90 65 50 	lds	r10, 0x5065
    2ff4:	b0 90 66 50 	lds	r11, 0x5066
    2ff8:	c0 90 67 50 	lds	r12, 0x5067
    2ffc:	d0 90 68 50 	lds	r13, 0x5068
    3000:	e0 90 69 50 	lds	r14, 0x5069
    3004:	f0 90 6a 50 	lds	r15, 0x506A
    3008:	00 91 6b 50 	lds	r16, 0x506B
    300c:	10 91 6c 50 	lds	r17, 0x506C
    3010:	80 91 43 50 	lds	r24, 0x5043
    3014:	90 91 44 50 	lds	r25, 0x5044
    3018:	fc 01       	movw	r30, r24
    301a:	20 80       	ld	r2, Z
    301c:	fc 01       	movw	r30, r24
    301e:	31 80       	ldd	r3, Z+1	; 0x01
    3020:	fc 01       	movw	r30, r24
    3022:	42 80       	ldd	r4, Z+2	; 0x02
    3024:	fc 01       	movw	r30, r24
    3026:	53 80       	ldd	r5, Z+3	; 0x03
    3028:	fc 01       	movw	r30, r24
    302a:	64 80       	ldd	r6, Z+4	; 0x04
    302c:	fc 01       	movw	r30, r24
    302e:	75 80       	ldd	r7, Z+5	; 0x05
    3030:	fc 01       	movw	r30, r24
    3032:	86 80       	ldd	r8, Z+6	; 0x06
    3034:	fc 01       	movw	r30, r24
    3036:	97 80       	ldd	r9, Z+7	; 0x07
    3038:	2a 2d       	mov	r18, r10
    303a:	22 0d       	add	r18, r2
    303c:	e1 e0       	ldi	r30, 0x01	; 1
    303e:	2a 15       	cp	r18, r10
    3040:	08 f0       	brcs	.+2      	; 0x3044 <calcChecksumFRAM+0x266>
    3042:	e0 e0       	ldi	r30, 0x00	; 0
    3044:	3b 2d       	mov	r19, r11
    3046:	33 0d       	add	r19, r3
    3048:	f1 e0       	ldi	r31, 0x01	; 1
    304a:	3b 15       	cp	r19, r11
    304c:	08 f0       	brcs	.+2      	; 0x3050 <calcChecksumFRAM+0x272>
    304e:	f0 e0       	ldi	r31, 0x00	; 0
    3050:	e3 0f       	add	r30, r19
    3052:	a1 e0       	ldi	r26, 0x01	; 1
    3054:	e3 17       	cp	r30, r19
    3056:	08 f0       	brcs	.+2      	; 0x305a <calcChecksumFRAM+0x27c>
    3058:	a0 e0       	ldi	r26, 0x00	; 0
    305a:	fa 2b       	or	r31, r26
    305c:	3e 2f       	mov	r19, r30
    305e:	4c 2d       	mov	r20, r12
    3060:	44 0d       	add	r20, r4
    3062:	e1 e0       	ldi	r30, 0x01	; 1
    3064:	4c 15       	cp	r20, r12
    3066:	08 f0       	brcs	.+2      	; 0x306a <calcChecksumFRAM+0x28c>
    3068:	e0 e0       	ldi	r30, 0x00	; 0
    306a:	f4 0f       	add	r31, r20
    306c:	a1 e0       	ldi	r26, 0x01	; 1
    306e:	f4 17       	cp	r31, r20
    3070:	08 f0       	brcs	.+2      	; 0x3074 <calcChecksumFRAM+0x296>
    3072:	a0 e0       	ldi	r26, 0x00	; 0
    3074:	ea 2b       	or	r30, r26
    3076:	4f 2f       	mov	r20, r31
    3078:	5d 2d       	mov	r21, r13
    307a:	55 0d       	add	r21, r5
    307c:	f1 e0       	ldi	r31, 0x01	; 1
    307e:	5d 15       	cp	r21, r13
    3080:	08 f0       	brcs	.+2      	; 0x3084 <calcChecksumFRAM+0x2a6>
    3082:	f0 e0       	ldi	r31, 0x00	; 0
    3084:	e5 0f       	add	r30, r21
    3086:	a1 e0       	ldi	r26, 0x01	; 1
    3088:	e5 17       	cp	r30, r21
    308a:	08 f0       	brcs	.+2      	; 0x308e <calcChecksumFRAM+0x2b0>
    308c:	a0 e0       	ldi	r26, 0x00	; 0
    308e:	fa 2b       	or	r31, r26
    3090:	5e 2f       	mov	r21, r30
    3092:	6e 2d       	mov	r22, r14
    3094:	66 0d       	add	r22, r6
    3096:	e1 e0       	ldi	r30, 0x01	; 1
    3098:	6e 15       	cp	r22, r14
    309a:	08 f0       	brcs	.+2      	; 0x309e <calcChecksumFRAM+0x2c0>
    309c:	e0 e0       	ldi	r30, 0x00	; 0
    309e:	f6 0f       	add	r31, r22
    30a0:	a1 e0       	ldi	r26, 0x01	; 1
    30a2:	f6 17       	cp	r31, r22
    30a4:	08 f0       	brcs	.+2      	; 0x30a8 <calcChecksumFRAM+0x2ca>
    30a6:	a0 e0       	ldi	r26, 0x00	; 0
    30a8:	ea 2b       	or	r30, r26
    30aa:	6f 2f       	mov	r22, r31
    30ac:	7f 2d       	mov	r23, r15
    30ae:	77 0d       	add	r23, r7
    30b0:	f1 e0       	ldi	r31, 0x01	; 1
    30b2:	7f 15       	cp	r23, r15
    30b4:	08 f0       	brcs	.+2      	; 0x30b8 <calcChecksumFRAM+0x2da>
    30b6:	f0 e0       	ldi	r31, 0x00	; 0
    30b8:	e7 0f       	add	r30, r23
    30ba:	a1 e0       	ldi	r26, 0x01	; 1
    30bc:	e7 17       	cp	r30, r23
    30be:	08 f0       	brcs	.+2      	; 0x30c2 <calcChecksumFRAM+0x2e4>
    30c0:	a0 e0       	ldi	r26, 0x00	; 0
    30c2:	fa 2b       	or	r31, r26
    30c4:	7e 2f       	mov	r23, r30
    30c6:	80 2f       	mov	r24, r16
    30c8:	88 0d       	add	r24, r8
    30ca:	e1 e0       	ldi	r30, 0x01	; 1
    30cc:	80 17       	cp	r24, r16
    30ce:	08 f0       	brcs	.+2      	; 0x30d2 <calcChecksumFRAM+0x2f4>
    30d0:	e0 e0       	ldi	r30, 0x00	; 0
    30d2:	f8 0f       	add	r31, r24
    30d4:	a1 e0       	ldi	r26, 0x01	; 1
    30d6:	f8 17       	cp	r31, r24
    30d8:	08 f0       	brcs	.+2      	; 0x30dc <calcChecksumFRAM+0x2fe>
    30da:	a0 e0       	ldi	r26, 0x00	; 0
    30dc:	ea 2b       	or	r30, r26
    30de:	8f 2f       	mov	r24, r31
    30e0:	91 2f       	mov	r25, r17
    30e2:	99 0d       	add	r25, r9
    30e4:	e9 0f       	add	r30, r25
    30e6:	9e 2f       	mov	r25, r30
    30e8:	a2 2e       	mov	r10, r18
    30ea:	b3 2e       	mov	r11, r19
    30ec:	c4 2e       	mov	r12, r20
    30ee:	d5 2e       	mov	r13, r21
    30f0:	e6 2e       	mov	r14, r22
    30f2:	f7 2e       	mov	r15, r23
    30f4:	08 2f       	mov	r16, r24
    30f6:	19 2f       	mov	r17, r25
    30f8:	a0 92 65 50 	sts	0x5065, r10
    30fc:	b0 92 66 50 	sts	0x5066, r11
    3100:	c0 92 67 50 	sts	0x5067, r12
    3104:	d0 92 68 50 	sts	0x5068, r13
    3108:	e0 92 69 50 	sts	0x5069, r14
    310c:	f0 92 6a 50 	sts	0x506A, r15
    3110:	00 93 6b 50 	sts	0x506B, r16
    3114:	10 93 6c 50 	sts	0x506C, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    3118:	8b 81       	ldd	r24, Y+3	; 0x03
    311a:	9c 81       	ldd	r25, Y+4	; 0x04
    311c:	29 e0       	ldi	r18, 0x09	; 9
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	b9 01       	movw	r22, r18
    3122:	0e 94 6e 5c 	call	0xb8dc	; 0xb8dc <__udivmodhi4>
    3126:	85 30       	cpi	r24, 0x05	; 5
    3128:	91 05       	cpc	r25, r1
    312a:	09 f0       	breq	.+2      	; 0x312e <calcChecksumFRAM+0x350>
    312c:	94 c0       	rjmp	.+296    	; 0x3256 <calcChecksumFRAM+0x478>
    312e:	a0 90 6d 50 	lds	r10, 0x506D
    3132:	b0 90 6e 50 	lds	r11, 0x506E
    3136:	c0 90 6f 50 	lds	r12, 0x506F
    313a:	d0 90 70 50 	lds	r13, 0x5070
    313e:	e0 90 71 50 	lds	r14, 0x5071
    3142:	f0 90 72 50 	lds	r15, 0x5072
    3146:	00 91 73 50 	lds	r16, 0x5073
    314a:	10 91 74 50 	lds	r17, 0x5074
    314e:	80 91 43 50 	lds	r24, 0x5043
    3152:	90 91 44 50 	lds	r25, 0x5044
    3156:	fc 01       	movw	r30, r24
    3158:	20 80       	ld	r2, Z
    315a:	fc 01       	movw	r30, r24
    315c:	31 80       	ldd	r3, Z+1	; 0x01
    315e:	fc 01       	movw	r30, r24
    3160:	42 80       	ldd	r4, Z+2	; 0x02
    3162:	fc 01       	movw	r30, r24
    3164:	53 80       	ldd	r5, Z+3	; 0x03
    3166:	fc 01       	movw	r30, r24
    3168:	64 80       	ldd	r6, Z+4	; 0x04
    316a:	fc 01       	movw	r30, r24
    316c:	75 80       	ldd	r7, Z+5	; 0x05
    316e:	fc 01       	movw	r30, r24
    3170:	86 80       	ldd	r8, Z+6	; 0x06
    3172:	fc 01       	movw	r30, r24
    3174:	97 80       	ldd	r9, Z+7	; 0x07
    3176:	2a 2d       	mov	r18, r10
    3178:	22 0d       	add	r18, r2
    317a:	e1 e0       	ldi	r30, 0x01	; 1
    317c:	2a 15       	cp	r18, r10
    317e:	08 f0       	brcs	.+2      	; 0x3182 <calcChecksumFRAM+0x3a4>
    3180:	e0 e0       	ldi	r30, 0x00	; 0
    3182:	3b 2d       	mov	r19, r11
    3184:	33 0d       	add	r19, r3
    3186:	f1 e0       	ldi	r31, 0x01	; 1
    3188:	3b 15       	cp	r19, r11
    318a:	08 f0       	brcs	.+2      	; 0x318e <calcChecksumFRAM+0x3b0>
    318c:	f0 e0       	ldi	r31, 0x00	; 0
    318e:	e3 0f       	add	r30, r19
    3190:	a1 e0       	ldi	r26, 0x01	; 1
    3192:	e3 17       	cp	r30, r19
    3194:	08 f0       	brcs	.+2      	; 0x3198 <calcChecksumFRAM+0x3ba>
    3196:	a0 e0       	ldi	r26, 0x00	; 0
    3198:	fa 2b       	or	r31, r26
    319a:	3e 2f       	mov	r19, r30
    319c:	4c 2d       	mov	r20, r12
    319e:	44 0d       	add	r20, r4
    31a0:	e1 e0       	ldi	r30, 0x01	; 1
    31a2:	4c 15       	cp	r20, r12
    31a4:	08 f0       	brcs	.+2      	; 0x31a8 <calcChecksumFRAM+0x3ca>
    31a6:	e0 e0       	ldi	r30, 0x00	; 0
    31a8:	f4 0f       	add	r31, r20
    31aa:	a1 e0       	ldi	r26, 0x01	; 1
    31ac:	f4 17       	cp	r31, r20
    31ae:	08 f0       	brcs	.+2      	; 0x31b2 <calcChecksumFRAM+0x3d4>
    31b0:	a0 e0       	ldi	r26, 0x00	; 0
    31b2:	ea 2b       	or	r30, r26
    31b4:	4f 2f       	mov	r20, r31
    31b6:	5d 2d       	mov	r21, r13
    31b8:	55 0d       	add	r21, r5
    31ba:	f1 e0       	ldi	r31, 0x01	; 1
    31bc:	5d 15       	cp	r21, r13
    31be:	08 f0       	brcs	.+2      	; 0x31c2 <calcChecksumFRAM+0x3e4>
    31c0:	f0 e0       	ldi	r31, 0x00	; 0
    31c2:	e5 0f       	add	r30, r21
    31c4:	a1 e0       	ldi	r26, 0x01	; 1
    31c6:	e5 17       	cp	r30, r21
    31c8:	08 f0       	brcs	.+2      	; 0x31cc <calcChecksumFRAM+0x3ee>
    31ca:	a0 e0       	ldi	r26, 0x00	; 0
    31cc:	fa 2b       	or	r31, r26
    31ce:	5e 2f       	mov	r21, r30
    31d0:	6e 2d       	mov	r22, r14
    31d2:	66 0d       	add	r22, r6
    31d4:	e1 e0       	ldi	r30, 0x01	; 1
    31d6:	6e 15       	cp	r22, r14
    31d8:	08 f0       	brcs	.+2      	; 0x31dc <calcChecksumFRAM+0x3fe>
    31da:	e0 e0       	ldi	r30, 0x00	; 0
    31dc:	f6 0f       	add	r31, r22
    31de:	a1 e0       	ldi	r26, 0x01	; 1
    31e0:	f6 17       	cp	r31, r22
    31e2:	08 f0       	brcs	.+2      	; 0x31e6 <calcChecksumFRAM+0x408>
    31e4:	a0 e0       	ldi	r26, 0x00	; 0
    31e6:	ea 2b       	or	r30, r26
    31e8:	6f 2f       	mov	r22, r31
    31ea:	7f 2d       	mov	r23, r15
    31ec:	77 0d       	add	r23, r7
    31ee:	f1 e0       	ldi	r31, 0x01	; 1
    31f0:	7f 15       	cp	r23, r15
    31f2:	08 f0       	brcs	.+2      	; 0x31f6 <calcChecksumFRAM+0x418>
    31f4:	f0 e0       	ldi	r31, 0x00	; 0
    31f6:	e7 0f       	add	r30, r23
    31f8:	a1 e0       	ldi	r26, 0x01	; 1
    31fa:	e7 17       	cp	r30, r23
    31fc:	08 f0       	brcs	.+2      	; 0x3200 <calcChecksumFRAM+0x422>
    31fe:	a0 e0       	ldi	r26, 0x00	; 0
    3200:	fa 2b       	or	r31, r26
    3202:	7e 2f       	mov	r23, r30
    3204:	80 2f       	mov	r24, r16
    3206:	88 0d       	add	r24, r8
    3208:	e1 e0       	ldi	r30, 0x01	; 1
    320a:	80 17       	cp	r24, r16
    320c:	08 f0       	brcs	.+2      	; 0x3210 <calcChecksumFRAM+0x432>
    320e:	e0 e0       	ldi	r30, 0x00	; 0
    3210:	f8 0f       	add	r31, r24
    3212:	a1 e0       	ldi	r26, 0x01	; 1
    3214:	f8 17       	cp	r31, r24
    3216:	08 f0       	brcs	.+2      	; 0x321a <calcChecksumFRAM+0x43c>
    3218:	a0 e0       	ldi	r26, 0x00	; 0
    321a:	ea 2b       	or	r30, r26
    321c:	8f 2f       	mov	r24, r31
    321e:	91 2f       	mov	r25, r17
    3220:	99 0d       	add	r25, r9
    3222:	e9 0f       	add	r30, r25
    3224:	9e 2f       	mov	r25, r30
    3226:	a2 2e       	mov	r10, r18
    3228:	b3 2e       	mov	r11, r19
    322a:	c4 2e       	mov	r12, r20
    322c:	d5 2e       	mov	r13, r21
    322e:	e6 2e       	mov	r14, r22
    3230:	f7 2e       	mov	r15, r23
    3232:	08 2f       	mov	r16, r24
    3234:	19 2f       	mov	r17, r25
    3236:	a0 92 6d 50 	sts	0x506D, r10
    323a:	b0 92 6e 50 	sts	0x506E, r11
    323e:	c0 92 6f 50 	sts	0x506F, r12
    3242:	d0 92 70 50 	sts	0x5070, r13
    3246:	e0 92 71 50 	sts	0x5071, r14
    324a:	f0 92 72 50 	sts	0x5072, r15
    324e:	00 93 73 50 	sts	0x5073, r16
    3252:	10 93 74 50 	sts	0x5074, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    3256:	8b 81       	ldd	r24, Y+3	; 0x03
    3258:	9c 81       	ldd	r25, Y+4	; 0x04
    325a:	29 e0       	ldi	r18, 0x09	; 9
    325c:	30 e0       	ldi	r19, 0x00	; 0
    325e:	b9 01       	movw	r22, r18
    3260:	0e 94 6e 5c 	call	0xb8dc	; 0xb8dc <__udivmodhi4>
    3264:	88 30       	cpi	r24, 0x08	; 8
    3266:	91 05       	cpc	r25, r1
    3268:	09 f0       	breq	.+2      	; 0x326c <calcChecksumFRAM+0x48e>
    326a:	94 c0       	rjmp	.+296    	; 0x3394 <calcChecksumFRAM+0x5b6>
    326c:	a0 90 75 50 	lds	r10, 0x5075
    3270:	b0 90 76 50 	lds	r11, 0x5076
    3274:	c0 90 77 50 	lds	r12, 0x5077
    3278:	d0 90 78 50 	lds	r13, 0x5078
    327c:	e0 90 79 50 	lds	r14, 0x5079
    3280:	f0 90 7a 50 	lds	r15, 0x507A
    3284:	00 91 7b 50 	lds	r16, 0x507B
    3288:	10 91 7c 50 	lds	r17, 0x507C
    328c:	80 91 43 50 	lds	r24, 0x5043
    3290:	90 91 44 50 	lds	r25, 0x5044
    3294:	fc 01       	movw	r30, r24
    3296:	20 80       	ld	r2, Z
    3298:	fc 01       	movw	r30, r24
    329a:	31 80       	ldd	r3, Z+1	; 0x01
    329c:	fc 01       	movw	r30, r24
    329e:	42 80       	ldd	r4, Z+2	; 0x02
    32a0:	fc 01       	movw	r30, r24
    32a2:	53 80       	ldd	r5, Z+3	; 0x03
    32a4:	fc 01       	movw	r30, r24
    32a6:	64 80       	ldd	r6, Z+4	; 0x04
    32a8:	fc 01       	movw	r30, r24
    32aa:	75 80       	ldd	r7, Z+5	; 0x05
    32ac:	fc 01       	movw	r30, r24
    32ae:	86 80       	ldd	r8, Z+6	; 0x06
    32b0:	fc 01       	movw	r30, r24
    32b2:	97 80       	ldd	r9, Z+7	; 0x07
    32b4:	2a 2d       	mov	r18, r10
    32b6:	22 0d       	add	r18, r2
    32b8:	e1 e0       	ldi	r30, 0x01	; 1
    32ba:	2a 15       	cp	r18, r10
    32bc:	08 f0       	brcs	.+2      	; 0x32c0 <calcChecksumFRAM+0x4e2>
    32be:	e0 e0       	ldi	r30, 0x00	; 0
    32c0:	3b 2d       	mov	r19, r11
    32c2:	33 0d       	add	r19, r3
    32c4:	f1 e0       	ldi	r31, 0x01	; 1
    32c6:	3b 15       	cp	r19, r11
    32c8:	08 f0       	brcs	.+2      	; 0x32cc <calcChecksumFRAM+0x4ee>
    32ca:	f0 e0       	ldi	r31, 0x00	; 0
    32cc:	e3 0f       	add	r30, r19
    32ce:	a1 e0       	ldi	r26, 0x01	; 1
    32d0:	e3 17       	cp	r30, r19
    32d2:	08 f0       	brcs	.+2      	; 0x32d6 <calcChecksumFRAM+0x4f8>
    32d4:	a0 e0       	ldi	r26, 0x00	; 0
    32d6:	fa 2b       	or	r31, r26
    32d8:	3e 2f       	mov	r19, r30
    32da:	4c 2d       	mov	r20, r12
    32dc:	44 0d       	add	r20, r4
    32de:	e1 e0       	ldi	r30, 0x01	; 1
    32e0:	4c 15       	cp	r20, r12
    32e2:	08 f0       	brcs	.+2      	; 0x32e6 <calcChecksumFRAM+0x508>
    32e4:	e0 e0       	ldi	r30, 0x00	; 0
    32e6:	f4 0f       	add	r31, r20
    32e8:	a1 e0       	ldi	r26, 0x01	; 1
    32ea:	f4 17       	cp	r31, r20
    32ec:	08 f0       	brcs	.+2      	; 0x32f0 <calcChecksumFRAM+0x512>
    32ee:	a0 e0       	ldi	r26, 0x00	; 0
    32f0:	ea 2b       	or	r30, r26
    32f2:	4f 2f       	mov	r20, r31
    32f4:	5d 2d       	mov	r21, r13
    32f6:	55 0d       	add	r21, r5
    32f8:	f1 e0       	ldi	r31, 0x01	; 1
    32fa:	5d 15       	cp	r21, r13
    32fc:	08 f0       	brcs	.+2      	; 0x3300 <calcChecksumFRAM+0x522>
    32fe:	f0 e0       	ldi	r31, 0x00	; 0
    3300:	e5 0f       	add	r30, r21
    3302:	a1 e0       	ldi	r26, 0x01	; 1
    3304:	e5 17       	cp	r30, r21
    3306:	08 f0       	brcs	.+2      	; 0x330a <calcChecksumFRAM+0x52c>
    3308:	a0 e0       	ldi	r26, 0x00	; 0
    330a:	fa 2b       	or	r31, r26
    330c:	5e 2f       	mov	r21, r30
    330e:	6e 2d       	mov	r22, r14
    3310:	66 0d       	add	r22, r6
    3312:	e1 e0       	ldi	r30, 0x01	; 1
    3314:	6e 15       	cp	r22, r14
    3316:	08 f0       	brcs	.+2      	; 0x331a <calcChecksumFRAM+0x53c>
    3318:	e0 e0       	ldi	r30, 0x00	; 0
    331a:	f6 0f       	add	r31, r22
    331c:	a1 e0       	ldi	r26, 0x01	; 1
    331e:	f6 17       	cp	r31, r22
    3320:	08 f0       	brcs	.+2      	; 0x3324 <calcChecksumFRAM+0x546>
    3322:	a0 e0       	ldi	r26, 0x00	; 0
    3324:	ea 2b       	or	r30, r26
    3326:	6f 2f       	mov	r22, r31
    3328:	7f 2d       	mov	r23, r15
    332a:	77 0d       	add	r23, r7
    332c:	f1 e0       	ldi	r31, 0x01	; 1
    332e:	7f 15       	cp	r23, r15
    3330:	08 f0       	brcs	.+2      	; 0x3334 <calcChecksumFRAM+0x556>
    3332:	f0 e0       	ldi	r31, 0x00	; 0
    3334:	e7 0f       	add	r30, r23
    3336:	a1 e0       	ldi	r26, 0x01	; 1
    3338:	e7 17       	cp	r30, r23
    333a:	08 f0       	brcs	.+2      	; 0x333e <calcChecksumFRAM+0x560>
    333c:	a0 e0       	ldi	r26, 0x00	; 0
    333e:	fa 2b       	or	r31, r26
    3340:	7e 2f       	mov	r23, r30
    3342:	80 2f       	mov	r24, r16
    3344:	88 0d       	add	r24, r8
    3346:	e1 e0       	ldi	r30, 0x01	; 1
    3348:	80 17       	cp	r24, r16
    334a:	08 f0       	brcs	.+2      	; 0x334e <calcChecksumFRAM+0x570>
    334c:	e0 e0       	ldi	r30, 0x00	; 0
    334e:	f8 0f       	add	r31, r24
    3350:	a1 e0       	ldi	r26, 0x01	; 1
    3352:	f8 17       	cp	r31, r24
    3354:	08 f0       	brcs	.+2      	; 0x3358 <calcChecksumFRAM+0x57a>
    3356:	a0 e0       	ldi	r26, 0x00	; 0
    3358:	ea 2b       	or	r30, r26
    335a:	8f 2f       	mov	r24, r31
    335c:	91 2f       	mov	r25, r17
    335e:	99 0d       	add	r25, r9
    3360:	e9 0f       	add	r30, r25
    3362:	9e 2f       	mov	r25, r30
    3364:	a2 2e       	mov	r10, r18
    3366:	b3 2e       	mov	r11, r19
    3368:	c4 2e       	mov	r12, r20
    336a:	d5 2e       	mov	r13, r21
    336c:	e6 2e       	mov	r14, r22
    336e:	f7 2e       	mov	r15, r23
    3370:	08 2f       	mov	r16, r24
    3372:	19 2f       	mov	r17, r25
    3374:	a0 92 75 50 	sts	0x5075, r10
    3378:	b0 92 76 50 	sts	0x5076, r11
    337c:	c0 92 77 50 	sts	0x5077, r12
    3380:	d0 92 78 50 	sts	0x5078, r13
    3384:	e0 92 79 50 	sts	0x5079, r14
    3388:	f0 92 7a 50 	sts	0x507A, r15
    338c:	00 93 7b 50 	sts	0x507B, r16
    3390:	10 93 7c 50 	sts	0x507C, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3394:	8b 81       	ldd	r24, Y+3	; 0x03
    3396:	9c 81       	ldd	r25, Y+4	; 0x04
    3398:	01 96       	adiw	r24, 0x01	; 1
    339a:	8b 83       	std	Y+3, r24	; 0x03
    339c:	9c 83       	std	Y+4, r25	; 0x04
    339e:	8b 81       	ldd	r24, Y+3	; 0x03
    33a0:	9c 81       	ldd	r25, Y+4	; 0x04
    33a2:	fc e1       	ldi	r31, 0x1C	; 28
    33a4:	81 37       	cpi	r24, 0x71	; 113
    33a6:	9f 07       	cpc	r25, r31
    33a8:	08 f4       	brcc	.+2      	; 0x33ac <calcChecksumFRAM+0x5ce>
    33aa:	8e cd       	rjmp	.-1252   	; 0x2ec8 <calcChecksumFRAM+0xea>

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    33ac:	89 81       	ldd	r24, Y+1	; 0x01
    33ae:	9a 81       	ldd	r25, Y+2	; 0x02
    33b0:	01 96       	adiw	r24, 0x01	; 1
    33b2:	89 83       	std	Y+1, r24	; 0x01
    33b4:	9a 83       	std	Y+2, r25	; 0x02
    33b6:	89 81       	ldd	r24, Y+1	; 0x01
    33b8:	9a 81       	ldd	r25, Y+2	; 0x02
    33ba:	89 30       	cpi	r24, 0x09	; 9
    33bc:	91 05       	cpc	r25, r1
    33be:	08 f4       	brcc	.+2      	; 0x33c2 <calcChecksumFRAM+0x5e4>
    33c0:	72 cd       	rjmp	.-1308   	; 0x2ea6 <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    33c2:	24 96       	adiw	r28, 0x04	; 4
    33c4:	cd bf       	out	0x3d, r28	; 61
    33c6:	de bf       	out	0x3e, r29	; 62
    33c8:	df 91       	pop	r29
    33ca:	cf 91       	pop	r28
    33cc:	1f 91       	pop	r17
    33ce:	0f 91       	pop	r16
    33d0:	ff 90       	pop	r15
    33d2:	ef 90       	pop	r14
    33d4:	df 90       	pop	r13
    33d6:	cf 90       	pop	r12
    33d8:	bf 90       	pop	r11
    33da:	af 90       	pop	r10
    33dc:	9f 90       	pop	r9
    33de:	8f 90       	pop	r8
    33e0:	7f 90       	pop	r7
    33e2:	6f 90       	pop	r6
    33e4:	5f 90       	pop	r5
    33e6:	4f 90       	pop	r4
    33e8:	3f 90       	pop	r3
    33ea:	2f 90       	pop	r2
    33ec:	08 95       	ret

000033ee <FRAMWriteKnowns>:


void FRAMWriteKnowns() {
    33ee:	cf 93       	push	r28
    33f0:	df 93       	push	r29
    33f2:	cd b7       	in	r28, 0x3d	; 61
    33f4:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    33f6:	10 92 38 40 	sts	0x4038, r1
    33fa:	10 92 39 40 	sts	0x4039, r1
	sampleCount = 0;
    33fe:	10 92 52 50 	sts	0x5052, r1
    3402:	10 92 53 50 	sts	0x5053, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3406:	80 e0       	ldi	r24, 0x00	; 0
    3408:	80 93 1c 21 	sts	0x211C, r24
    340c:	80 93 1b 21 	sts	0x211B, r24
    3410:	80 93 1a 21 	sts	0x211A, r24
	
	ADCPower(TRUE);
    3414:	81 e0       	ldi	r24, 0x01	; 1
    3416:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    341a:	84 e0       	ldi	r24, 0x04	; 4
    341c:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3420:	80 ec       	ldi	r24, 0xC0	; 192
    3422:	98 e0       	ldi	r25, 0x08	; 8
    3424:	20 ed       	ldi	r18, 0xD0	; 208
    3426:	fc 01       	movw	r30, r24
    3428:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    342a:	8d e0       	ldi	r24, 0x0D	; 13
    342c:	80 93 45 50 	sts	0x5045, r24
	SPIBuffer[1] = 0xF3;
    3430:	83 ef       	ldi	r24, 0xF3	; 243
    3432:	80 93 46 50 	sts	0x5046, r24
	SPIBuffer[2] = 0x57;
    3436:	87 e5       	ldi	r24, 0x57	; 87
    3438:	80 93 47 50 	sts	0x5047, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    343c:	cd c0       	rjmp	.+410    	; 0x35d8 <FRAMWriteKnowns+0x1ea>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    343e:	80 e4       	ldi	r24, 0x40	; 64
    3440:	96 e0       	ldi	r25, 0x06	; 6
    3442:	20 e1       	ldi	r18, 0x10	; 16
    3444:	fc 01       	movw	r30, r24
    3446:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3448:	80 e2       	ldi	r24, 0x20	; 32
    344a:	96 e0       	ldi	r25, 0x06	; 6
    344c:	28 e0       	ldi	r18, 0x08	; 8
    344e:	fc 01       	movw	r30, r24
    3450:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3452:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3454:	80 ec       	ldi	r24, 0xC0	; 192
    3456:	98 e0       	ldi	r25, 0x08	; 8
    3458:	26 e0       	ldi	r18, 0x06	; 6
    345a:	fc 01       	movw	r30, r24
    345c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    345e:	00 00       	nop
    3460:	80 ec       	ldi	r24, 0xC0	; 192
    3462:	98 e0       	ldi	r25, 0x08	; 8
    3464:	fc 01       	movw	r30, r24
    3466:	82 81       	ldd	r24, Z+2	; 0x02
    3468:	88 23       	and	r24, r24
    346a:	d4 f7       	brge	.-12     	; 0x3460 <FRAMWriteKnowns+0x72>
		SPIBuffer[12] = SPIC.DATA;
    346c:	80 ec       	ldi	r24, 0xC0	; 192
    346e:	98 e0       	ldi	r25, 0x08	; 8
    3470:	fc 01       	movw	r30, r24
    3472:	83 81       	ldd	r24, Z+3	; 0x03
    3474:	80 93 51 50 	sts	0x5051, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3478:	80 e2       	ldi	r24, 0x20	; 32
    347a:	96 e0       	ldi	r25, 0x06	; 6
    347c:	28 e0       	ldi	r18, 0x08	; 8
    347e:	fc 01       	movw	r30, r24
    3480:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    3482:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3484:	80 e2       	ldi	r24, 0x20	; 32
    3486:	96 e0       	ldi	r25, 0x06	; 6
    3488:	28 e0       	ldi	r18, 0x08	; 8
    348a:	fc 01       	movw	r30, r24
    348c:	26 83       	std	Z+6, r18	; 0x06
		nop();
    348e:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    3490:	80 ec       	ldi	r24, 0xC0	; 192
    3492:	98 e0       	ldi	r25, 0x08	; 8
    3494:	22 e0       	ldi	r18, 0x02	; 2
    3496:	fc 01       	movw	r30, r24
    3498:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    349a:	00 00       	nop
    349c:	80 ec       	ldi	r24, 0xC0	; 192
    349e:	98 e0       	ldi	r25, 0x08	; 8
    34a0:	fc 01       	movw	r30, r24
    34a2:	82 81       	ldd	r24, Z+2	; 0x02
    34a4:	88 23       	and	r24, r24
    34a6:	d4 f7       	brge	.-12     	; 0x349c <FRAMWriteKnowns+0xae>
		SPIBuffer[12] = SPIC.DATA;
    34a8:	80 ec       	ldi	r24, 0xC0	; 192
    34aa:	98 e0       	ldi	r25, 0x08	; 8
    34ac:	fc 01       	movw	r30, r24
    34ae:	83 81       	ldd	r24, Z+3	; 0x03
    34b0:	80 93 51 50 	sts	0x5051, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    34b4:	80 ec       	ldi	r24, 0xC0	; 192
    34b6:	98 e0       	ldi	r25, 0x08	; 8
    34b8:	20 91 39 40 	lds	r18, 0x4039
    34bc:	fc 01       	movw	r30, r24
    34be:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    34c0:	00 00       	nop
    34c2:	80 ec       	ldi	r24, 0xC0	; 192
    34c4:	98 e0       	ldi	r25, 0x08	; 8
    34c6:	fc 01       	movw	r30, r24
    34c8:	82 81       	ldd	r24, Z+2	; 0x02
    34ca:	88 23       	and	r24, r24
    34cc:	d4 f7       	brge	.-12     	; 0x34c2 <FRAMWriteKnowns+0xd4>
		SPIBuffer[12] = SPIC.DATA;
    34ce:	80 ec       	ldi	r24, 0xC0	; 192
    34d0:	98 e0       	ldi	r25, 0x08	; 8
    34d2:	fc 01       	movw	r30, r24
    34d4:	83 81       	ldd	r24, Z+3	; 0x03
    34d6:	80 93 51 50 	sts	0x5051, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    34da:	80 ec       	ldi	r24, 0xC0	; 192
    34dc:	98 e0       	ldi	r25, 0x08	; 8
    34de:	28 e3       	ldi	r18, 0x38	; 56
    34e0:	30 e4       	ldi	r19, 0x40	; 64
    34e2:	f9 01       	movw	r30, r18
    34e4:	20 81       	ld	r18, Z
    34e6:	fc 01       	movw	r30, r24
    34e8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    34ea:	00 00       	nop
    34ec:	80 ec       	ldi	r24, 0xC0	; 192
    34ee:	98 e0       	ldi	r25, 0x08	; 8
    34f0:	fc 01       	movw	r30, r24
    34f2:	82 81       	ldd	r24, Z+2	; 0x02
    34f4:	88 23       	and	r24, r24
    34f6:	d4 f7       	brge	.-12     	; 0x34ec <FRAMWriteKnowns+0xfe>
		SPIBuffer[12] = SPIC.DATA;
    34f8:	80 ec       	ldi	r24, 0xC0	; 192
    34fa:	98 e0       	ldi	r25, 0x08	; 8
    34fc:	fc 01       	movw	r30, r24
    34fe:	83 81       	ldd	r24, Z+3	; 0x03
    3500:	80 93 51 50 	sts	0x5051, r24
		SPIC.DATA = SPIBuffer[0];
    3504:	80 ec       	ldi	r24, 0xC0	; 192
    3506:	98 e0       	ldi	r25, 0x08	; 8
    3508:	20 91 45 50 	lds	r18, 0x5045
    350c:	fc 01       	movw	r30, r24
    350e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3510:	00 00       	nop
    3512:	80 ec       	ldi	r24, 0xC0	; 192
    3514:	98 e0       	ldi	r25, 0x08	; 8
    3516:	fc 01       	movw	r30, r24
    3518:	82 81       	ldd	r24, Z+2	; 0x02
    351a:	88 23       	and	r24, r24
    351c:	d4 f7       	brge	.-12     	; 0x3512 <FRAMWriteKnowns+0x124>
		SPIBuffer[12] = SPIC.DATA;
    351e:	80 ec       	ldi	r24, 0xC0	; 192
    3520:	98 e0       	ldi	r25, 0x08	; 8
    3522:	fc 01       	movw	r30, r24
    3524:	83 81       	ldd	r24, Z+3	; 0x03
    3526:	80 93 51 50 	sts	0x5051, r24
		SPIC.DATA = SPIBuffer[1];
    352a:	80 ec       	ldi	r24, 0xC0	; 192
    352c:	98 e0       	ldi	r25, 0x08	; 8
    352e:	20 91 46 50 	lds	r18, 0x5046
    3532:	fc 01       	movw	r30, r24
    3534:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3536:	00 00       	nop
    3538:	80 ec       	ldi	r24, 0xC0	; 192
    353a:	98 e0       	ldi	r25, 0x08	; 8
    353c:	fc 01       	movw	r30, r24
    353e:	82 81       	ldd	r24, Z+2	; 0x02
    3540:	88 23       	and	r24, r24
    3542:	d4 f7       	brge	.-12     	; 0x3538 <FRAMWriteKnowns+0x14a>
		SPIBuffer[12] = SPIC.DATA;
    3544:	80 ec       	ldi	r24, 0xC0	; 192
    3546:	98 e0       	ldi	r25, 0x08	; 8
    3548:	fc 01       	movw	r30, r24
    354a:	83 81       	ldd	r24, Z+3	; 0x03
    354c:	80 93 51 50 	sts	0x5051, r24
		SPIC.DATA = SPIBuffer[2];
    3550:	80 ec       	ldi	r24, 0xC0	; 192
    3552:	98 e0       	ldi	r25, 0x08	; 8
    3554:	20 91 47 50 	lds	r18, 0x5047
    3558:	fc 01       	movw	r30, r24
    355a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    355c:	00 00       	nop
    355e:	80 ec       	ldi	r24, 0xC0	; 192
    3560:	98 e0       	ldi	r25, 0x08	; 8
    3562:	fc 01       	movw	r30, r24
    3564:	82 81       	ldd	r24, Z+2	; 0x02
    3566:	88 23       	and	r24, r24
    3568:	d4 f7       	brge	.-12     	; 0x355e <FRAMWriteKnowns+0x170>
		SPIBuffer[12] = SPIC.DATA;
    356a:	80 ec       	ldi	r24, 0xC0	; 192
    356c:	98 e0       	ldi	r25, 0x08	; 8
    356e:	fc 01       	movw	r30, r24
    3570:	83 81       	ldd	r24, Z+3	; 0x03
    3572:	80 93 51 50 	sts	0x5051, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3576:	80 e2       	ldi	r24, 0x20	; 32
    3578:	96 e0       	ldi	r25, 0x06	; 6
    357a:	28 e0       	ldi	r18, 0x08	; 8
    357c:	fc 01       	movw	r30, r24
    357e:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3580:	80 e4       	ldi	r24, 0x40	; 64
    3582:	96 e0       	ldi	r25, 0x06	; 6
    3584:	20 e1       	ldi	r18, 0x10	; 16
    3586:	fc 01       	movw	r30, r24
    3588:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    358a:	80 91 38 40 	lds	r24, 0x4038
    358e:	90 91 39 40 	lds	r25, 0x4039
    3592:	03 96       	adiw	r24, 0x03	; 3
    3594:	80 93 38 40 	sts	0x4038, r24
    3598:	90 93 39 40 	sts	0x4039, r25
		checksumADC[0] += SPIBuffer[0];
    359c:	90 91 1a 21 	lds	r25, 0x211A
    35a0:	80 91 45 50 	lds	r24, 0x5045
    35a4:	89 0f       	add	r24, r25
    35a6:	80 93 1a 21 	sts	0x211A, r24
		checksumADC[1] += SPIBuffer[1];
    35aa:	90 91 1b 21 	lds	r25, 0x211B
    35ae:	80 91 46 50 	lds	r24, 0x5046
    35b2:	89 0f       	add	r24, r25
    35b4:	80 93 1b 21 	sts	0x211B, r24
		checksumADC[2] += SPIBuffer[2];
    35b8:	90 91 1c 21 	lds	r25, 0x211C
    35bc:	80 91 47 50 	lds	r24, 0x5047
    35c0:	89 0f       	add	r24, r25
    35c2:	80 93 1c 21 	sts	0x211C, r24
		
		sampleCount++;
    35c6:	80 91 52 50 	lds	r24, 0x5052
    35ca:	90 91 53 50 	lds	r25, 0x5053
    35ce:	01 96       	adiw	r24, 0x01	; 1
    35d0:	80 93 52 50 	sts	0x5052, r24
    35d4:	90 93 53 50 	sts	0x5053, r25
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    35d8:	80 91 52 50 	lds	r24, 0x5052
    35dc:	90 91 53 50 	lds	r25, 0x5053
    35e0:	f5 e5       	ldi	r31, 0x55	; 85
    35e2:	83 35       	cpi	r24, 0x53	; 83
    35e4:	9f 07       	cpc	r25, r31
    35e6:	08 f4       	brcc	.+2      	; 0x35ea <FRAMWriteKnowns+0x1fc>
    35e8:	2a cf       	rjmp	.-428    	; 0x343e <FRAMWriteKnowns+0x50>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    35ea:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	ADCPower(FALSE);
    35ee:	80 e0       	ldi	r24, 0x00	; 0
    35f0:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
}
    35f4:	df 91       	pop	r29
    35f6:	cf 91       	pop	r28
    35f8:	08 95       	ret

000035fa <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    35fa:	cf 93       	push	r28
    35fc:	df 93       	push	r29
    35fe:	0f 92       	push	r0
    3600:	cd b7       	in	r28, 0x3d	; 61
    3602:	de b7       	in	r29, 0x3e	; 62
    3604:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    3606:	89 81       	ldd	r24, Y+1	; 0x01
    3608:	88 2f       	mov	r24, r24
    360a:	90 e0       	ldi	r25, 0x00	; 0
    360c:	81 70       	andi	r24, 0x01	; 1
    360e:	90 70       	andi	r25, 0x00	; 0
    3610:	88 23       	and	r24, r24
    3612:	31 f0       	breq	.+12     	; 0x3620 <setADCInput+0x26>
    3614:	80 e0       	ldi	r24, 0x00	; 0
    3616:	96 e0       	ldi	r25, 0x06	; 6
    3618:	20 e4       	ldi	r18, 0x40	; 64
    361a:	fc 01       	movw	r30, r24
    361c:	25 83       	std	Z+5, r18	; 0x05
    361e:	05 c0       	rjmp	.+10     	; 0x362a <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    3620:	80 e0       	ldi	r24, 0x00	; 0
    3622:	96 e0       	ldi	r25, 0x06	; 6
    3624:	20 e4       	ldi	r18, 0x40	; 64
    3626:	fc 01       	movw	r30, r24
    3628:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    362a:	89 81       	ldd	r24, Y+1	; 0x01
    362c:	88 2f       	mov	r24, r24
    362e:	90 e0       	ldi	r25, 0x00	; 0
    3630:	82 70       	andi	r24, 0x02	; 2
    3632:	90 70       	andi	r25, 0x00	; 0
    3634:	00 97       	sbiw	r24, 0x00	; 0
    3636:	31 f0       	breq	.+12     	; 0x3644 <setADCInput+0x4a>
    3638:	80 e2       	ldi	r24, 0x20	; 32
    363a:	96 e0       	ldi	r25, 0x06	; 6
    363c:	22 e0       	ldi	r18, 0x02	; 2
    363e:	fc 01       	movw	r30, r24
    3640:	25 83       	std	Z+5, r18	; 0x05
    3642:	05 c0       	rjmp	.+10     	; 0x364e <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3644:	80 e2       	ldi	r24, 0x20	; 32
    3646:	96 e0       	ldi	r25, 0x06	; 6
    3648:	22 e0       	ldi	r18, 0x02	; 2
    364a:	fc 01       	movw	r30, r24
    364c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    364e:	89 81       	ldd	r24, Y+1	; 0x01
    3650:	88 2f       	mov	r24, r24
    3652:	90 e0       	ldi	r25, 0x00	; 0
    3654:	84 70       	andi	r24, 0x04	; 4
    3656:	90 70       	andi	r25, 0x00	; 0
    3658:	00 97       	sbiw	r24, 0x00	; 0
    365a:	31 f0       	breq	.+12     	; 0x3668 <setADCInput+0x6e>
    365c:	80 e2       	ldi	r24, 0x20	; 32
    365e:	96 e0       	ldi	r25, 0x06	; 6
    3660:	24 e0       	ldi	r18, 0x04	; 4
    3662:	fc 01       	movw	r30, r24
    3664:	25 83       	std	Z+5, r18	; 0x05
    3666:	05 c0       	rjmp	.+10     	; 0x3672 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    3668:	80 e2       	ldi	r24, 0x20	; 32
    366a:	96 e0       	ldi	r25, 0x06	; 6
    366c:	24 e0       	ldi	r18, 0x04	; 4
    366e:	fc 01       	movw	r30, r24
    3670:	26 83       	std	Z+6, r18	; 0x06

}
    3672:	0f 90       	pop	r0
    3674:	df 91       	pop	r29
    3676:	cf 91       	pop	r28
    3678:	08 95       	ret

0000367a <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    367a:	cf 93       	push	r28
    367c:	df 93       	push	r29
    367e:	0f 92       	push	r0
    3680:	0f 92       	push	r0
    3682:	cd b7       	in	r28, 0x3d	; 61
    3684:	de b7       	in	r29, 0x3e	; 62
    3686:	89 83       	std	Y+1, r24	; 0x01
    3688:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    368a:	89 81       	ldd	r24, Y+1	; 0x01
    368c:	9a 81       	ldd	r25, Y+2	; 0x02
    368e:	22 e0       	ldi	r18, 0x02	; 2
    3690:	80 30       	cpi	r24, 0x00	; 0
    3692:	92 07       	cpc	r25, r18
    3694:	89 f4       	brne	.+34     	; 0x36b8 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3696:	80 e2       	ldi	r24, 0x20	; 32
    3698:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <SP_ReadCalibrationByte>
    369c:	28 2f       	mov	r18, r24
    369e:	89 81       	ldd	r24, Y+1	; 0x01
    36a0:	9a 81       	ldd	r25, Y+2	; 0x02
    36a2:	fc 01       	movw	r30, r24
    36a4:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    36a6:	81 e2       	ldi	r24, 0x21	; 33
    36a8:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <SP_ReadCalibrationByte>
    36ac:	28 2f       	mov	r18, r24
    36ae:	89 81       	ldd	r24, Y+1	; 0x01
    36b0:	9a 81       	ldd	r25, Y+2	; 0x02
    36b2:	fc 01       	movw	r30, r24
    36b4:	25 87       	std	Z+13, r18	; 0x0d
    36b6:	10 c0       	rjmp	.+32     	; 0x36d8 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    36b8:	84 e2       	ldi	r24, 0x24	; 36
    36ba:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <SP_ReadCalibrationByte>
    36be:	28 2f       	mov	r18, r24
    36c0:	89 81       	ldd	r24, Y+1	; 0x01
    36c2:	9a 81       	ldd	r25, Y+2	; 0x02
    36c4:	fc 01       	movw	r30, r24
    36c6:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    36c8:	85 e2       	ldi	r24, 0x25	; 37
    36ca:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <SP_ReadCalibrationByte>
    36ce:	28 2f       	mov	r18, r24
    36d0:	89 81       	ldd	r24, Y+1	; 0x01
    36d2:	9a 81       	ldd	r25, Y+2	; 0x02
    36d4:	fc 01       	movw	r30, r24
    36d6:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    36d8:	0f 90       	pop	r0
    36da:	0f 90       	pop	r0
    36dc:	df 91       	pop	r29
    36de:	cf 91       	pop	r28
    36e0:	08 95       	ret

000036e2 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    36e2:	cf 93       	push	r28
    36e4:	df 93       	push	r29
    36e6:	cd b7       	in	r28, 0x3d	; 61
    36e8:	de b7       	in	r29, 0x3e	; 62
    36ea:	25 97       	sbiw	r28, 0x05	; 5
    36ec:	cd bf       	out	0x3d, r28	; 61
    36ee:	de bf       	out	0x3e, r29	; 62
    36f0:	8b 83       	std	Y+3, r24	; 0x03
    36f2:	9c 83       	std	Y+4, r25	; 0x04
    36f4:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    36f6:	8b 81       	ldd	r24, Y+3	; 0x03
    36f8:	9c 81       	ldd	r25, Y+4	; 0x04
    36fa:	21 e0       	ldi	r18, 0x01	; 1
    36fc:	fc 01       	movw	r30, r24
    36fe:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    3700:	8b 81       	ldd	r24, Y+3	; 0x03
    3702:	9c 81       	ldd	r25, Y+4	; 0x04
    3704:	fc 01       	movw	r30, r24
    3706:	24 81       	ldd	r18, Z+4	; 0x04
    3708:	35 81       	ldd	r19, Z+5	; 0x05
    370a:	8d 81       	ldd	r24, Y+5	; 0x05
    370c:	88 2f       	mov	r24, r24
    370e:	90 e0       	ldi	r25, 0x00	; 0
    3710:	a9 01       	movw	r20, r18
    3712:	48 1b       	sub	r20, r24
    3714:	59 0b       	sbc	r21, r25
    3716:	ca 01       	movw	r24, r20
    3718:	89 83       	std	Y+1, r24	; 0x01
    371a:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    371c:	89 81       	ldd	r24, Y+1	; 0x01
    371e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3720:	25 96       	adiw	r28, 0x05	; 5
    3722:	cd bf       	out	0x3d, r28	; 61
    3724:	de bf       	out	0x3e, r29	; 62
    3726:	df 91       	pop	r29
    3728:	cf 91       	pop	r28
    372a:	08 95       	ret

0000372c <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29
    3730:	cd b7       	in	r28, 0x3d	; 61
    3732:	de b7       	in	r29, 0x3e	; 62
    3734:	25 97       	sbiw	r28, 0x05	; 5
    3736:	cd bf       	out	0x3d, r28	; 61
    3738:	de bf       	out	0x3e, r29	; 62
    373a:	8b 83       	std	Y+3, r24	; 0x03
    373c:	9c 83       	std	Y+4, r25	; 0x04
    373e:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3740:	8b 81       	ldd	r24, Y+3	; 0x03
    3742:	9c 81       	ldd	r25, Y+4	; 0x04
    3744:	21 e0       	ldi	r18, 0x01	; 1
    3746:	fc 01       	movw	r30, r24
    3748:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    374a:	8b 81       	ldd	r24, Y+3	; 0x03
    374c:	9c 81       	ldd	r25, Y+4	; 0x04
    374e:	fc 01       	movw	r30, r24
    3750:	24 81       	ldd	r18, Z+4	; 0x04
    3752:	35 81       	ldd	r19, Z+5	; 0x05
    3754:	8d 81       	ldd	r24, Y+5	; 0x05
    3756:	99 27       	eor	r25, r25
    3758:	87 fd       	sbrc	r24, 7
    375a:	90 95       	com	r25
    375c:	a9 01       	movw	r20, r18
    375e:	48 1b       	sub	r20, r24
    3760:	59 0b       	sbc	r21, r25
    3762:	ca 01       	movw	r24, r20
    3764:	89 83       	std	Y+1, r24	; 0x01
    3766:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3768:	89 81       	ldd	r24, Y+1	; 0x01
    376a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    376c:	25 96       	adiw	r28, 0x05	; 5
    376e:	cd bf       	out	0x3d, r28	; 61
    3770:	de bf       	out	0x3e, r29	; 62
    3772:	df 91       	pop	r29
    3774:	cf 91       	pop	r28
    3776:	08 95       	ret

00003778 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3778:	cf 93       	push	r28
    377a:	df 93       	push	r29
    377c:	0f 92       	push	r0
    377e:	0f 92       	push	r0
    3780:	cd b7       	in	r28, 0x3d	; 61
    3782:	de b7       	in	r29, 0x3e	; 62
    3784:	89 83       	std	Y+1, r24	; 0x01
    3786:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3788:	89 81       	ldd	r24, Y+1	; 0x01
    378a:	9a 81       	ldd	r25, Y+2	; 0x02
    378c:	21 e0       	ldi	r18, 0x01	; 1
    378e:	fc 01       	movw	r30, r24
    3790:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3792:	89 81       	ldd	r24, Y+1	; 0x01
    3794:	9a 81       	ldd	r25, Y+2	; 0x02
    3796:	fc 01       	movw	r30, r24
    3798:	84 81       	ldd	r24, Z+4	; 0x04
    379a:	95 81       	ldd	r25, Z+5	; 0x05
}
    379c:	0f 90       	pop	r0
    379e:	0f 90       	pop	r0
    37a0:	df 91       	pop	r29
    37a2:	cf 91       	pop	r28
    37a4:	08 95       	ret

000037a6 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    37a6:	cf 93       	push	r28
    37a8:	df 93       	push	r29
    37aa:	0f 92       	push	r0
    37ac:	0f 92       	push	r0
    37ae:	cd b7       	in	r28, 0x3d	; 61
    37b0:	de b7       	in	r29, 0x3e	; 62
    37b2:	89 83       	std	Y+1, r24	; 0x01
    37b4:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    37b6:	89 81       	ldd	r24, Y+1	; 0x01
    37b8:	9a 81       	ldd	r25, Y+2	; 0x02
    37ba:	21 e0       	ldi	r18, 0x01	; 1
    37bc:	fc 01       	movw	r30, r24
    37be:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    37c0:	89 81       	ldd	r24, Y+1	; 0x01
    37c2:	9a 81       	ldd	r25, Y+2	; 0x02
    37c4:	fc 01       	movw	r30, r24
    37c6:	84 81       	ldd	r24, Z+4	; 0x04
}
    37c8:	0f 90       	pop	r0
    37ca:	0f 90       	pop	r0
    37cc:	df 91       	pop	r29
    37ce:	cf 91       	pop	r28
    37d0:	08 95       	ret

000037d2 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    37d2:	cf 93       	push	r28
    37d4:	df 93       	push	r29
    37d6:	0f 92       	push	r0
    37d8:	0f 92       	push	r0
    37da:	cd b7       	in	r28, 0x3d	; 61
    37dc:	de b7       	in	r29, 0x3e	; 62
    37de:	89 83       	std	Y+1, r24	; 0x01
    37e0:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    37e2:	89 81       	ldd	r24, Y+1	; 0x01
    37e4:	9a 81       	ldd	r25, Y+2	; 0x02
    37e6:	21 e0       	ldi	r18, 0x01	; 1
    37e8:	fc 01       	movw	r30, r24
    37ea:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    37ec:	89 81       	ldd	r24, Y+1	; 0x01
    37ee:	9a 81       	ldd	r25, Y+2	; 0x02
    37f0:	fc 01       	movw	r30, r24
    37f2:	85 81       	ldd	r24, Z+5	; 0x05
}
    37f4:	0f 90       	pop	r0
    37f6:	0f 90       	pop	r0
    37f8:	df 91       	pop	r29
    37fa:	cf 91       	pop	r28
    37fc:	08 95       	ret

000037fe <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    37fe:	0f 93       	push	r16
    3800:	1f 93       	push	r17
    3802:	cf 93       	push	r28
    3804:	df 93       	push	r29
    3806:	cd b7       	in	r28, 0x3d	; 61
    3808:	de b7       	in	r29, 0x3e	; 62
    380a:	6b 97       	sbiw	r28, 0x1b	; 27
    380c:	cd bf       	out	0x3d, r28	; 61
    380e:	de bf       	out	0x3e, r29	; 62
    3810:	8a 8f       	std	Y+26, r24	; 0x1a
    3812:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3814:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3816:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3818:	fc 01       	movw	r30, r24
    381a:	84 81       	ldd	r24, Z+4	; 0x04
    381c:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    381e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3820:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3822:	fc 01       	movw	r30, r24
    3824:	14 82       	std	Z+4, r1	; 0x04
    3826:	80 e0       	ldi	r24, 0x00	; 0
    3828:	90 e0       	ldi	r25, 0x00	; 0
    382a:	a0 e8       	ldi	r26, 0x80	; 128
    382c:	b2 e4       	ldi	r27, 0x42	; 66
    382e:	8a 83       	std	Y+2, r24	; 0x02
    3830:	9b 83       	std	Y+3, r25	; 0x03
    3832:	ac 83       	std	Y+4, r26	; 0x04
    3834:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3836:	6a 81       	ldd	r22, Y+2	; 0x02
    3838:	7b 81       	ldd	r23, Y+3	; 0x03
    383a:	8c 81       	ldd	r24, Y+4	; 0x04
    383c:	9d 81       	ldd	r25, Y+5	; 0x05
    383e:	2b ea       	ldi	r18, 0xAB	; 171
    3840:	3a ea       	ldi	r19, 0xAA	; 170
    3842:	4a e2       	ldi	r20, 0x2A	; 42
    3844:	5f e3       	ldi	r21, 0x3F	; 63
    3846:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    384a:	dc 01       	movw	r26, r24
    384c:	cb 01       	movw	r24, r22
    384e:	8e 83       	std	Y+6, r24	; 0x06
    3850:	9f 83       	std	Y+7, r25	; 0x07
    3852:	a8 87       	std	Y+8, r26	; 0x08
    3854:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3856:	11 e0       	ldi	r17, 0x01	; 1
    3858:	6e 81       	ldd	r22, Y+6	; 0x06
    385a:	7f 81       	ldd	r23, Y+7	; 0x07
    385c:	88 85       	ldd	r24, Y+8	; 0x08
    385e:	99 85       	ldd	r25, Y+9	; 0x09
    3860:	20 e0       	ldi	r18, 0x00	; 0
    3862:	30 e0       	ldi	r19, 0x00	; 0
    3864:	40 e8       	ldi	r20, 0x80	; 128
    3866:	5f e3       	ldi	r21, 0x3F	; 63
    3868:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    386c:	88 23       	and	r24, r24
    386e:	0c f0       	brlt	.+2      	; 0x3872 <ADC_Wait_8MHz+0x74>
    3870:	10 e0       	ldi	r17, 0x00	; 0
    3872:	11 23       	and	r17, r17
    3874:	19 f0       	breq	.+6      	; 0x387c <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3876:	81 e0       	ldi	r24, 0x01	; 1
    3878:	8a 87       	std	Y+10, r24	; 0x0a
    387a:	a3 c0       	rjmp	.+326    	; 0x39c2 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    387c:	11 e0       	ldi	r17, 0x01	; 1
    387e:	6e 81       	ldd	r22, Y+6	; 0x06
    3880:	7f 81       	ldd	r23, Y+7	; 0x07
    3882:	88 85       	ldd	r24, Y+8	; 0x08
    3884:	99 85       	ldd	r25, Y+9	; 0x09
    3886:	20 e0       	ldi	r18, 0x00	; 0
    3888:	30 e0       	ldi	r19, 0x00	; 0
    388a:	4f e7       	ldi	r20, 0x7F	; 127
    388c:	53 e4       	ldi	r21, 0x43	; 67
    388e:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    3892:	18 16       	cp	r1, r24
    3894:	0c f0       	brlt	.+2      	; 0x3898 <ADC_Wait_8MHz+0x9a>
    3896:	10 e0       	ldi	r17, 0x00	; 0
    3898:	11 23       	and	r17, r17
    389a:	09 f4       	brne	.+2      	; 0x389e <ADC_Wait_8MHz+0xa0>
    389c:	89 c0       	rjmp	.+274    	; 0x39b0 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    389e:	6a 81       	ldd	r22, Y+2	; 0x02
    38a0:	7b 81       	ldd	r23, Y+3	; 0x03
    38a2:	8c 81       	ldd	r24, Y+4	; 0x04
    38a4:	9d 81       	ldd	r25, Y+5	; 0x05
    38a6:	20 e0       	ldi	r18, 0x00	; 0
    38a8:	30 e0       	ldi	r19, 0x00	; 0
    38aa:	4a e7       	ldi	r20, 0x7A	; 122
    38ac:	54 e4       	ldi	r21, 0x44	; 68
    38ae:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    38b2:	dc 01       	movw	r26, r24
    38b4:	cb 01       	movw	r24, r22
    38b6:	8b 87       	std	Y+11, r24	; 0x0b
    38b8:	9c 87       	std	Y+12, r25	; 0x0c
    38ba:	ad 87       	std	Y+13, r26	; 0x0d
    38bc:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    38be:	6b 85       	ldd	r22, Y+11	; 0x0b
    38c0:	7c 85       	ldd	r23, Y+12	; 0x0c
    38c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    38c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    38c6:	20 e0       	ldi	r18, 0x00	; 0
    38c8:	30 e0       	ldi	r19, 0x00	; 0
    38ca:	4a ef       	ldi	r20, 0xFA	; 250
    38cc:	53 e4       	ldi	r21, 0x43	; 67
    38ce:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    38d2:	dc 01       	movw	r26, r24
    38d4:	cb 01       	movw	r24, r22
    38d6:	8f 87       	std	Y+15, r24	; 0x0f
    38d8:	98 8b       	std	Y+16, r25	; 0x10
    38da:	a9 8b       	std	Y+17, r26	; 0x11
    38dc:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    38de:	11 e0       	ldi	r17, 0x01	; 1
    38e0:	6f 85       	ldd	r22, Y+15	; 0x0f
    38e2:	78 89       	ldd	r23, Y+16	; 0x10
    38e4:	89 89       	ldd	r24, Y+17	; 0x11
    38e6:	9a 89       	ldd	r25, Y+18	; 0x12
    38e8:	20 e0       	ldi	r18, 0x00	; 0
    38ea:	30 e0       	ldi	r19, 0x00	; 0
    38ec:	40 e8       	ldi	r20, 0x80	; 128
    38ee:	5f e3       	ldi	r21, 0x3F	; 63
    38f0:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    38f4:	88 23       	and	r24, r24
    38f6:	0c f0       	brlt	.+2      	; 0x38fa <ADC_Wait_8MHz+0xfc>
    38f8:	10 e0       	ldi	r17, 0x00	; 0
    38fa:	11 23       	and	r17, r17
    38fc:	29 f0       	breq	.+10     	; 0x3908 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    38fe:	81 e0       	ldi	r24, 0x01	; 1
    3900:	90 e0       	ldi	r25, 0x00	; 0
    3902:	8b 8b       	std	Y+19, r24	; 0x13
    3904:	9c 8b       	std	Y+20, r25	; 0x14
    3906:	46 c0       	rjmp	.+140    	; 0x3994 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3908:	11 e0       	ldi	r17, 0x01	; 1
    390a:	6f 85       	ldd	r22, Y+15	; 0x0f
    390c:	78 89       	ldd	r23, Y+16	; 0x10
    390e:	89 89       	ldd	r24, Y+17	; 0x11
    3910:	9a 89       	ldd	r25, Y+18	; 0x12
    3912:	20 e0       	ldi	r18, 0x00	; 0
    3914:	3f ef       	ldi	r19, 0xFF	; 255
    3916:	4f e7       	ldi	r20, 0x7F	; 127
    3918:	57 e4       	ldi	r21, 0x47	; 71
    391a:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    391e:	18 16       	cp	r1, r24
    3920:	0c f0       	brlt	.+2      	; 0x3924 <ADC_Wait_8MHz+0x126>
    3922:	10 e0       	ldi	r17, 0x00	; 0
    3924:	11 23       	and	r17, r17
    3926:	61 f1       	breq	.+88     	; 0x3980 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3928:	6b 85       	ldd	r22, Y+11	; 0x0b
    392a:	7c 85       	ldd	r23, Y+12	; 0x0c
    392c:	8d 85       	ldd	r24, Y+13	; 0x0d
    392e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3930:	20 e0       	ldi	r18, 0x00	; 0
    3932:	30 e0       	ldi	r19, 0x00	; 0
    3934:	40 e2       	ldi	r20, 0x20	; 32
    3936:	51 e4       	ldi	r21, 0x41	; 65
    3938:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    393c:	dc 01       	movw	r26, r24
    393e:	cb 01       	movw	r24, r22
    3940:	bc 01       	movw	r22, r24
    3942:	cd 01       	movw	r24, r26
    3944:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    3948:	dc 01       	movw	r26, r24
    394a:	cb 01       	movw	r24, r22
    394c:	8b 8b       	std	Y+19, r24	; 0x13
    394e:	9c 8b       	std	Y+20, r25	; 0x14
    3950:	12 c0       	rjmp	.+36     	; 0x3976 <ADC_Wait_8MHz+0x178>
    3952:	82 e3       	ldi	r24, 0x32	; 50
    3954:	90 e0       	ldi	r25, 0x00	; 0
    3956:	8d 8b       	std	Y+21, r24	; 0x15
    3958:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    395a:	8d 89       	ldd	r24, Y+21	; 0x15
    395c:	9e 89       	ldd	r25, Y+22	; 0x16
    395e:	8c 01       	movw	r16, r24
    3960:	c8 01       	movw	r24, r16
    3962:	01 97       	sbiw	r24, 0x01	; 1
    3964:	f1 f7       	brne	.-4      	; 0x3962 <ADC_Wait_8MHz+0x164>
    3966:	8c 01       	movw	r16, r24
    3968:	0d 8b       	std	Y+21, r16	; 0x15
    396a:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    396c:	8b 89       	ldd	r24, Y+19	; 0x13
    396e:	9c 89       	ldd	r25, Y+20	; 0x14
    3970:	01 97       	sbiw	r24, 0x01	; 1
    3972:	8b 8b       	std	Y+19, r24	; 0x13
    3974:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3976:	8b 89       	ldd	r24, Y+19	; 0x13
    3978:	9c 89       	ldd	r25, Y+20	; 0x14
    397a:	00 97       	sbiw	r24, 0x00	; 0
    397c:	51 f7       	brne	.-44     	; 0x3952 <ADC_Wait_8MHz+0x154>
    397e:	28 c0       	rjmp	.+80     	; 0x39d0 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3980:	6f 85       	ldd	r22, Y+15	; 0x0f
    3982:	78 89       	ldd	r23, Y+16	; 0x10
    3984:	89 89       	ldd	r24, Y+17	; 0x11
    3986:	9a 89       	ldd	r25, Y+18	; 0x12
    3988:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    398c:	dc 01       	movw	r26, r24
    398e:	cb 01       	movw	r24, r22
    3990:	8b 8b       	std	Y+19, r24	; 0x13
    3992:	9c 8b       	std	Y+20, r25	; 0x14
    3994:	8b 89       	ldd	r24, Y+19	; 0x13
    3996:	9c 89       	ldd	r25, Y+20	; 0x14
    3998:	8f 8b       	std	Y+23, r24	; 0x17
    399a:	98 8f       	std	Y+24, r25	; 0x18
    399c:	8f 89       	ldd	r24, Y+23	; 0x17
    399e:	98 8d       	ldd	r25, Y+24	; 0x18
    39a0:	8c 01       	movw	r16, r24
    39a2:	f8 01       	movw	r30, r16
    39a4:	31 97       	sbiw	r30, 0x01	; 1
    39a6:	f1 f7       	brne	.-4      	; 0x39a4 <ADC_Wait_8MHz+0x1a6>
    39a8:	8f 01       	movw	r16, r30
    39aa:	0f 8b       	std	Y+23, r16	; 0x17
    39ac:	18 8f       	std	Y+24, r17	; 0x18
    39ae:	10 c0       	rjmp	.+32     	; 0x39d0 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    39b0:	6e 81       	ldd	r22, Y+6	; 0x06
    39b2:	7f 81       	ldd	r23, Y+7	; 0x07
    39b4:	88 85       	ldd	r24, Y+8	; 0x08
    39b6:	99 85       	ldd	r25, Y+9	; 0x09
    39b8:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    39bc:	dc 01       	movw	r26, r24
    39be:	cb 01       	movw	r24, r22
    39c0:	8a 87       	std	Y+10, r24	; 0x0a
    39c2:	8a 85       	ldd	r24, Y+10	; 0x0a
    39c4:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    39c6:	89 8d       	ldd	r24, Y+25	; 0x19
    39c8:	18 2f       	mov	r17, r24
    39ca:	1a 95       	dec	r17
    39cc:	f1 f7       	brne	.-4      	; 0x39ca <ADC_Wait_8MHz+0x1cc>
    39ce:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    39d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    39d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    39d4:	29 81       	ldd	r18, Y+1	; 0x01
    39d6:	fc 01       	movw	r30, r24
    39d8:	24 83       	std	Z+4, r18	; 0x04
}
    39da:	6b 96       	adiw	r28, 0x1b	; 27
    39dc:	cd bf       	out	0x3d, r28	; 61
    39de:	de bf       	out	0x3e, r29	; 62
    39e0:	df 91       	pop	r29
    39e2:	cf 91       	pop	r28
    39e4:	1f 91       	pop	r17
    39e6:	0f 91       	pop	r16
    39e8:	08 95       	ret

000039ea <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    39ea:	0f 93       	push	r16
    39ec:	1f 93       	push	r17
    39ee:	cf 93       	push	r28
    39f0:	df 93       	push	r29
    39f2:	cd b7       	in	r28, 0x3d	; 61
    39f4:	de b7       	in	r29, 0x3e	; 62
    39f6:	6b 97       	sbiw	r28, 0x1b	; 27
    39f8:	cd bf       	out	0x3d, r28	; 61
    39fa:	de bf       	out	0x3e, r29	; 62
    39fc:	8a 8f       	std	Y+26, r24	; 0x1a
    39fe:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3a00:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a02:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a04:	fc 01       	movw	r30, r24
    3a06:	84 81       	ldd	r24, Z+4	; 0x04
    3a08:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3a0a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a0c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a0e:	21 e0       	ldi	r18, 0x01	; 1
    3a10:	fc 01       	movw	r30, r24
    3a12:	24 83       	std	Z+4, r18	; 0x04
    3a14:	80 e0       	ldi	r24, 0x00	; 0
    3a16:	90 e0       	ldi	r25, 0x00	; 0
    3a18:	a0 e0       	ldi	r26, 0x00	; 0
    3a1a:	b3 e4       	ldi	r27, 0x43	; 67
    3a1c:	8a 83       	std	Y+2, r24	; 0x02
    3a1e:	9b 83       	std	Y+3, r25	; 0x03
    3a20:	ac 83       	std	Y+4, r26	; 0x04
    3a22:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3a24:	6a 81       	ldd	r22, Y+2	; 0x02
    3a26:	7b 81       	ldd	r23, Y+3	; 0x03
    3a28:	8c 81       	ldd	r24, Y+4	; 0x04
    3a2a:	9d 81       	ldd	r25, Y+5	; 0x05
    3a2c:	2b ea       	ldi	r18, 0xAB	; 171
    3a2e:	3a ea       	ldi	r19, 0xAA	; 170
    3a30:	4a e2       	ldi	r20, 0x2A	; 42
    3a32:	5f e3       	ldi	r21, 0x3F	; 63
    3a34:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    3a38:	dc 01       	movw	r26, r24
    3a3a:	cb 01       	movw	r24, r22
    3a3c:	8e 83       	std	Y+6, r24	; 0x06
    3a3e:	9f 83       	std	Y+7, r25	; 0x07
    3a40:	a8 87       	std	Y+8, r26	; 0x08
    3a42:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3a44:	11 e0       	ldi	r17, 0x01	; 1
    3a46:	6e 81       	ldd	r22, Y+6	; 0x06
    3a48:	7f 81       	ldd	r23, Y+7	; 0x07
    3a4a:	88 85       	ldd	r24, Y+8	; 0x08
    3a4c:	99 85       	ldd	r25, Y+9	; 0x09
    3a4e:	20 e0       	ldi	r18, 0x00	; 0
    3a50:	30 e0       	ldi	r19, 0x00	; 0
    3a52:	40 e8       	ldi	r20, 0x80	; 128
    3a54:	5f e3       	ldi	r21, 0x3F	; 63
    3a56:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    3a5a:	88 23       	and	r24, r24
    3a5c:	0c f0       	brlt	.+2      	; 0x3a60 <ADC_Wait_32MHz+0x76>
    3a5e:	10 e0       	ldi	r17, 0x00	; 0
    3a60:	11 23       	and	r17, r17
    3a62:	19 f0       	breq	.+6      	; 0x3a6a <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3a64:	81 e0       	ldi	r24, 0x01	; 1
    3a66:	8a 87       	std	Y+10, r24	; 0x0a
    3a68:	a3 c0       	rjmp	.+326    	; 0x3bb0 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3a6a:	11 e0       	ldi	r17, 0x01	; 1
    3a6c:	6e 81       	ldd	r22, Y+6	; 0x06
    3a6e:	7f 81       	ldd	r23, Y+7	; 0x07
    3a70:	88 85       	ldd	r24, Y+8	; 0x08
    3a72:	99 85       	ldd	r25, Y+9	; 0x09
    3a74:	20 e0       	ldi	r18, 0x00	; 0
    3a76:	30 e0       	ldi	r19, 0x00	; 0
    3a78:	4f e7       	ldi	r20, 0x7F	; 127
    3a7a:	53 e4       	ldi	r21, 0x43	; 67
    3a7c:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    3a80:	18 16       	cp	r1, r24
    3a82:	0c f0       	brlt	.+2      	; 0x3a86 <ADC_Wait_32MHz+0x9c>
    3a84:	10 e0       	ldi	r17, 0x00	; 0
    3a86:	11 23       	and	r17, r17
    3a88:	09 f4       	brne	.+2      	; 0x3a8c <ADC_Wait_32MHz+0xa2>
    3a8a:	89 c0       	rjmp	.+274    	; 0x3b9e <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3a8c:	6a 81       	ldd	r22, Y+2	; 0x02
    3a8e:	7b 81       	ldd	r23, Y+3	; 0x03
    3a90:	8c 81       	ldd	r24, Y+4	; 0x04
    3a92:	9d 81       	ldd	r25, Y+5	; 0x05
    3a94:	20 e0       	ldi	r18, 0x00	; 0
    3a96:	30 e0       	ldi	r19, 0x00	; 0
    3a98:	4a e7       	ldi	r20, 0x7A	; 122
    3a9a:	54 e4       	ldi	r21, 0x44	; 68
    3a9c:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    3aa0:	dc 01       	movw	r26, r24
    3aa2:	cb 01       	movw	r24, r22
    3aa4:	8b 87       	std	Y+11, r24	; 0x0b
    3aa6:	9c 87       	std	Y+12, r25	; 0x0c
    3aa8:	ad 87       	std	Y+13, r26	; 0x0d
    3aaa:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3aac:	6b 85       	ldd	r22, Y+11	; 0x0b
    3aae:	7c 85       	ldd	r23, Y+12	; 0x0c
    3ab0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ab2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ab4:	20 e0       	ldi	r18, 0x00	; 0
    3ab6:	30 e0       	ldi	r19, 0x00	; 0
    3ab8:	4a ef       	ldi	r20, 0xFA	; 250
    3aba:	53 e4       	ldi	r21, 0x43	; 67
    3abc:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    3ac0:	dc 01       	movw	r26, r24
    3ac2:	cb 01       	movw	r24, r22
    3ac4:	8f 87       	std	Y+15, r24	; 0x0f
    3ac6:	98 8b       	std	Y+16, r25	; 0x10
    3ac8:	a9 8b       	std	Y+17, r26	; 0x11
    3aca:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3acc:	11 e0       	ldi	r17, 0x01	; 1
    3ace:	6f 85       	ldd	r22, Y+15	; 0x0f
    3ad0:	78 89       	ldd	r23, Y+16	; 0x10
    3ad2:	89 89       	ldd	r24, Y+17	; 0x11
    3ad4:	9a 89       	ldd	r25, Y+18	; 0x12
    3ad6:	20 e0       	ldi	r18, 0x00	; 0
    3ad8:	30 e0       	ldi	r19, 0x00	; 0
    3ada:	40 e8       	ldi	r20, 0x80	; 128
    3adc:	5f e3       	ldi	r21, 0x3F	; 63
    3ade:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    3ae2:	88 23       	and	r24, r24
    3ae4:	0c f0       	brlt	.+2      	; 0x3ae8 <ADC_Wait_32MHz+0xfe>
    3ae6:	10 e0       	ldi	r17, 0x00	; 0
    3ae8:	11 23       	and	r17, r17
    3aea:	29 f0       	breq	.+10     	; 0x3af6 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    3aec:	81 e0       	ldi	r24, 0x01	; 1
    3aee:	90 e0       	ldi	r25, 0x00	; 0
    3af0:	8b 8b       	std	Y+19, r24	; 0x13
    3af2:	9c 8b       	std	Y+20, r25	; 0x14
    3af4:	46 c0       	rjmp	.+140    	; 0x3b82 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3af6:	11 e0       	ldi	r17, 0x01	; 1
    3af8:	6f 85       	ldd	r22, Y+15	; 0x0f
    3afa:	78 89       	ldd	r23, Y+16	; 0x10
    3afc:	89 89       	ldd	r24, Y+17	; 0x11
    3afe:	9a 89       	ldd	r25, Y+18	; 0x12
    3b00:	20 e0       	ldi	r18, 0x00	; 0
    3b02:	3f ef       	ldi	r19, 0xFF	; 255
    3b04:	4f e7       	ldi	r20, 0x7F	; 127
    3b06:	57 e4       	ldi	r21, 0x47	; 71
    3b08:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    3b0c:	18 16       	cp	r1, r24
    3b0e:	0c f0       	brlt	.+2      	; 0x3b12 <ADC_Wait_32MHz+0x128>
    3b10:	10 e0       	ldi	r17, 0x00	; 0
    3b12:	11 23       	and	r17, r17
    3b14:	61 f1       	breq	.+88     	; 0x3b6e <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b16:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b18:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b1e:	20 e0       	ldi	r18, 0x00	; 0
    3b20:	30 e0       	ldi	r19, 0x00	; 0
    3b22:	40 e2       	ldi	r20, 0x20	; 32
    3b24:	51 e4       	ldi	r21, 0x41	; 65
    3b26:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    3b2a:	dc 01       	movw	r26, r24
    3b2c:	cb 01       	movw	r24, r22
    3b2e:	bc 01       	movw	r22, r24
    3b30:	cd 01       	movw	r24, r26
    3b32:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    3b36:	dc 01       	movw	r26, r24
    3b38:	cb 01       	movw	r24, r22
    3b3a:	8b 8b       	std	Y+19, r24	; 0x13
    3b3c:	9c 8b       	std	Y+20, r25	; 0x14
    3b3e:	12 c0       	rjmp	.+36     	; 0x3b64 <ADC_Wait_32MHz+0x17a>
    3b40:	82 e3       	ldi	r24, 0x32	; 50
    3b42:	90 e0       	ldi	r25, 0x00	; 0
    3b44:	8d 8b       	std	Y+21, r24	; 0x15
    3b46:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b48:	8d 89       	ldd	r24, Y+21	; 0x15
    3b4a:	9e 89       	ldd	r25, Y+22	; 0x16
    3b4c:	8c 01       	movw	r16, r24
    3b4e:	c8 01       	movw	r24, r16
    3b50:	01 97       	sbiw	r24, 0x01	; 1
    3b52:	f1 f7       	brne	.-4      	; 0x3b50 <ADC_Wait_32MHz+0x166>
    3b54:	8c 01       	movw	r16, r24
    3b56:	0d 8b       	std	Y+21, r16	; 0x15
    3b58:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b5a:	8b 89       	ldd	r24, Y+19	; 0x13
    3b5c:	9c 89       	ldd	r25, Y+20	; 0x14
    3b5e:	01 97       	sbiw	r24, 0x01	; 1
    3b60:	8b 8b       	std	Y+19, r24	; 0x13
    3b62:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b64:	8b 89       	ldd	r24, Y+19	; 0x13
    3b66:	9c 89       	ldd	r25, Y+20	; 0x14
    3b68:	00 97       	sbiw	r24, 0x00	; 0
    3b6a:	51 f7       	brne	.-44     	; 0x3b40 <ADC_Wait_32MHz+0x156>
    3b6c:	28 c0       	rjmp	.+80     	; 0x3bbe <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b6e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3b70:	78 89       	ldd	r23, Y+16	; 0x10
    3b72:	89 89       	ldd	r24, Y+17	; 0x11
    3b74:	9a 89       	ldd	r25, Y+18	; 0x12
    3b76:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    3b7a:	dc 01       	movw	r26, r24
    3b7c:	cb 01       	movw	r24, r22
    3b7e:	8b 8b       	std	Y+19, r24	; 0x13
    3b80:	9c 8b       	std	Y+20, r25	; 0x14
    3b82:	8b 89       	ldd	r24, Y+19	; 0x13
    3b84:	9c 89       	ldd	r25, Y+20	; 0x14
    3b86:	8f 8b       	std	Y+23, r24	; 0x17
    3b88:	98 8f       	std	Y+24, r25	; 0x18
    3b8a:	8f 89       	ldd	r24, Y+23	; 0x17
    3b8c:	98 8d       	ldd	r25, Y+24	; 0x18
    3b8e:	8c 01       	movw	r16, r24
    3b90:	f8 01       	movw	r30, r16
    3b92:	31 97       	sbiw	r30, 0x01	; 1
    3b94:	f1 f7       	brne	.-4      	; 0x3b92 <ADC_Wait_32MHz+0x1a8>
    3b96:	8f 01       	movw	r16, r30
    3b98:	0f 8b       	std	Y+23, r16	; 0x17
    3b9a:	18 8f       	std	Y+24, r17	; 0x18
    3b9c:	10 c0       	rjmp	.+32     	; 0x3bbe <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3b9e:	6e 81       	ldd	r22, Y+6	; 0x06
    3ba0:	7f 81       	ldd	r23, Y+7	; 0x07
    3ba2:	88 85       	ldd	r24, Y+8	; 0x08
    3ba4:	99 85       	ldd	r25, Y+9	; 0x09
    3ba6:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    3baa:	dc 01       	movw	r26, r24
    3bac:	cb 01       	movw	r24, r22
    3bae:	8a 87       	std	Y+10, r24	; 0x0a
    3bb0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bb2:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3bb4:	89 8d       	ldd	r24, Y+25	; 0x19
    3bb6:	18 2f       	mov	r17, r24
    3bb8:	1a 95       	dec	r17
    3bba:	f1 f7       	brne	.-4      	; 0x3bb8 <ADC_Wait_32MHz+0x1ce>
    3bbc:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3bbe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3bc0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3bc2:	29 81       	ldd	r18, Y+1	; 0x01
    3bc4:	fc 01       	movw	r30, r24
    3bc6:	24 83       	std	Z+4, r18	; 0x04
}
    3bc8:	6b 96       	adiw	r28, 0x1b	; 27
    3bca:	cd bf       	out	0x3d, r28	; 61
    3bcc:	de bf       	out	0x3e, r29	; 62
    3bce:	df 91       	pop	r29
    3bd0:	cf 91       	pop	r28
    3bd2:	1f 91       	pop	r17
    3bd4:	0f 91       	pop	r16
    3bd6:	08 95       	ret

00003bd8 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3bd8:	cf 93       	push	r28
    3bda:	df 93       	push	r29
    3bdc:	cd b7       	in	r28, 0x3d	; 61
    3bde:	de b7       	in	r29, 0x3e	; 62
    3be0:	2a 97       	sbiw	r28, 0x0a	; 10
    3be2:	cd bf       	out	0x3d, r28	; 61
    3be4:	de bf       	out	0x3e, r29	; 62
    3be6:	8e 83       	std	Y+6, r24	; 0x06
    3be8:	9f 83       	std	Y+7, r25	; 0x07
    3bea:	68 87       	std	Y+8, r22	; 0x08
    3bec:	79 87       	std	Y+9, r23	; 0x09
    3bee:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3bf0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bf2:	88 23       	and	r24, r24
    3bf4:	a9 f1       	breq	.+106    	; 0x3c60 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3bf6:	19 82       	std	Y+1, r1	; 0x01
    3bf8:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3bfa:	1b 82       	std	Y+3, r1	; 0x03
    3bfc:	1c 82       	std	Y+4, r1	; 0x04
    3bfe:	24 c0       	rjmp	.+72     	; 0x3c48 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3c00:	88 85       	ldd	r24, Y+8	; 0x08
    3c02:	99 85       	ldd	r25, Y+9	; 0x09
    3c04:	fc 01       	movw	r30, r24
    3c06:	80 81       	ld	r24, Z
    3c08:	28 2f       	mov	r18, r24
    3c0a:	20 68       	ori	r18, 0x80	; 128
    3c0c:	88 85       	ldd	r24, Y+8	; 0x08
    3c0e:	99 85       	ldd	r25, Y+9	; 0x09
    3c10:	fc 01       	movw	r30, r24
    3c12:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3c14:	88 85       	ldd	r24, Y+8	; 0x08
    3c16:	99 85       	ldd	r25, Y+9	; 0x09
    3c18:	fc 01       	movw	r30, r24
    3c1a:	83 81       	ldd	r24, Z+3	; 0x03
    3c1c:	88 2f       	mov	r24, r24
    3c1e:	90 e0       	ldi	r25, 0x00	; 0
    3c20:	81 70       	andi	r24, 0x01	; 1
    3c22:	90 70       	andi	r25, 0x00	; 0
    3c24:	00 97       	sbiw	r24, 0x00	; 0
    3c26:	b1 f3       	breq	.-20     	; 0x3c14 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3c28:	88 85       	ldd	r24, Y+8	; 0x08
    3c2a:	99 85       	ldd	r25, Y+9	; 0x09
    3c2c:	60 e0       	ldi	r22, 0x00	; 0
    3c2e:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <ADC_ResultCh_GetWord_Unsigned>
    3c32:	29 81       	ldd	r18, Y+1	; 0x01
    3c34:	3a 81       	ldd	r19, Y+2	; 0x02
    3c36:	82 0f       	add	r24, r18
    3c38:	93 1f       	adc	r25, r19
    3c3a:	89 83       	std	Y+1, r24	; 0x01
    3c3c:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c40:	9c 81       	ldd	r25, Y+4	; 0x04
    3c42:	01 96       	adiw	r24, 0x01	; 1
    3c44:	8b 83       	std	Y+3, r24	; 0x03
    3c46:	9c 83       	std	Y+4, r25	; 0x04
    3c48:	8b 81       	ldd	r24, Y+3	; 0x03
    3c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c4c:	84 30       	cpi	r24, 0x04	; 4
    3c4e:	91 05       	cpc	r25, r1
    3c50:	bc f2       	brlt	.-82     	; 0x3c00 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3c52:	89 81       	ldd	r24, Y+1	; 0x01
    3c54:	9a 81       	ldd	r25, Y+2	; 0x02
    3c56:	96 95       	lsr	r25
    3c58:	87 95       	ror	r24
    3c5a:	96 95       	lsr	r25
    3c5c:	87 95       	ror	r24
    3c5e:	1b c0       	rjmp	.+54     	; 0x3c96 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3c60:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3c62:	88 85       	ldd	r24, Y+8	; 0x08
    3c64:	99 85       	ldd	r25, Y+9	; 0x09
    3c66:	fc 01       	movw	r30, r24
    3c68:	80 81       	ld	r24, Z
    3c6a:	28 2f       	mov	r18, r24
    3c6c:	20 68       	ori	r18, 0x80	; 128
    3c6e:	88 85       	ldd	r24, Y+8	; 0x08
    3c70:	99 85       	ldd	r25, Y+9	; 0x09
    3c72:	fc 01       	movw	r30, r24
    3c74:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3c76:	88 85       	ldd	r24, Y+8	; 0x08
    3c78:	99 85       	ldd	r25, Y+9	; 0x09
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	83 81       	ldd	r24, Z+3	; 0x03
    3c7e:	88 2f       	mov	r24, r24
    3c80:	90 e0       	ldi	r25, 0x00	; 0
    3c82:	81 70       	andi	r24, 0x01	; 1
    3c84:	90 70       	andi	r25, 0x00	; 0
    3c86:	00 97       	sbiw	r24, 0x00	; 0
    3c88:	b1 f3       	breq	.-20     	; 0x3c76 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3c8a:	88 85       	ldd	r24, Y+8	; 0x08
    3c8c:	99 85       	ldd	r25, Y+9	; 0x09
    3c8e:	0e 94 bc 1b 	call	0x3778	; 0x3778 <ADC_ResultCh_GetWord>
    3c92:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3c94:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3c96:	2a 96       	adiw	r28, 0x0a	; 10
    3c98:	cd bf       	out	0x3d, r28	; 61
    3c9a:	de bf       	out	0x3e, r29	; 62
    3c9c:	df 91       	pop	r29
    3c9e:	cf 91       	pop	r28
    3ca0:	08 95       	ret

00003ca2 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3ca2:	cf 93       	push	r28
    3ca4:	df 93       	push	r29
    3ca6:	cd b7       	in	r28, 0x3d	; 61
    3ca8:	de b7       	in	r29, 0x3e	; 62
    3caa:	2a 97       	sbiw	r28, 0x0a	; 10
    3cac:	cd bf       	out	0x3d, r28	; 61
    3cae:	de bf       	out	0x3e, r29	; 62
    3cb0:	8e 83       	std	Y+6, r24	; 0x06
    3cb2:	9f 83       	std	Y+7, r25	; 0x07
    3cb4:	68 87       	std	Y+8, r22	; 0x08
    3cb6:	79 87       	std	Y+9, r23	; 0x09
    3cb8:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3cba:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cbc:	88 23       	and	r24, r24
    3cbe:	c1 f1       	breq	.+112    	; 0x3d30 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3cc0:	19 82       	std	Y+1, r1	; 0x01
    3cc2:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3cc4:	1b 82       	std	Y+3, r1	; 0x03
    3cc6:	1c 82       	std	Y+4, r1	; 0x04
    3cc8:	24 c0       	rjmp	.+72     	; 0x3d12 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3cca:	88 85       	ldd	r24, Y+8	; 0x08
    3ccc:	99 85       	ldd	r25, Y+9	; 0x09
    3cce:	fc 01       	movw	r30, r24
    3cd0:	80 81       	ld	r24, Z
    3cd2:	28 2f       	mov	r18, r24
    3cd4:	20 68       	ori	r18, 0x80	; 128
    3cd6:	88 85       	ldd	r24, Y+8	; 0x08
    3cd8:	99 85       	ldd	r25, Y+9	; 0x09
    3cda:	fc 01       	movw	r30, r24
    3cdc:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3cde:	88 85       	ldd	r24, Y+8	; 0x08
    3ce0:	99 85       	ldd	r25, Y+9	; 0x09
    3ce2:	fc 01       	movw	r30, r24
    3ce4:	83 81       	ldd	r24, Z+3	; 0x03
    3ce6:	88 2f       	mov	r24, r24
    3ce8:	90 e0       	ldi	r25, 0x00	; 0
    3cea:	81 70       	andi	r24, 0x01	; 1
    3cec:	90 70       	andi	r25, 0x00	; 0
    3cee:	00 97       	sbiw	r24, 0x00	; 0
    3cf0:	b1 f3       	breq	.-20     	; 0x3cde <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3cf2:	88 85       	ldd	r24, Y+8	; 0x08
    3cf4:	99 85       	ldd	r25, Y+9	; 0x09
    3cf6:	60 e0       	ldi	r22, 0x00	; 0
    3cf8:	0e 94 96 1b 	call	0x372c	; 0x372c <ADC_ResultCh_GetWord_Signed>
    3cfc:	29 81       	ldd	r18, Y+1	; 0x01
    3cfe:	3a 81       	ldd	r19, Y+2	; 0x02
    3d00:	82 0f       	add	r24, r18
    3d02:	93 1f       	adc	r25, r19
    3d04:	89 83       	std	Y+1, r24	; 0x01
    3d06:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3d08:	8b 81       	ldd	r24, Y+3	; 0x03
    3d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d0c:	01 96       	adiw	r24, 0x01	; 1
    3d0e:	8b 83       	std	Y+3, r24	; 0x03
    3d10:	9c 83       	std	Y+4, r25	; 0x04
    3d12:	8b 81       	ldd	r24, Y+3	; 0x03
    3d14:	9c 81       	ldd	r25, Y+4	; 0x04
    3d16:	84 30       	cpi	r24, 0x04	; 4
    3d18:	91 05       	cpc	r25, r1
    3d1a:	bc f2       	brlt	.-82     	; 0x3cca <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3d1c:	89 81       	ldd	r24, Y+1	; 0x01
    3d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d20:	99 23       	and	r25, r25
    3d22:	0c f4       	brge	.+2      	; 0x3d26 <ADC_Offset_Get_Signed+0x84>
    3d24:	03 96       	adiw	r24, 0x03	; 3
    3d26:	95 95       	asr	r25
    3d28:	87 95       	ror	r24
    3d2a:	95 95       	asr	r25
    3d2c:	87 95       	ror	r24
    3d2e:	1c c0       	rjmp	.+56     	; 0x3d68 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3d30:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3d32:	88 85       	ldd	r24, Y+8	; 0x08
    3d34:	99 85       	ldd	r25, Y+9	; 0x09
    3d36:	fc 01       	movw	r30, r24
    3d38:	80 81       	ld	r24, Z
    3d3a:	28 2f       	mov	r18, r24
    3d3c:	20 68       	ori	r18, 0x80	; 128
    3d3e:	88 85       	ldd	r24, Y+8	; 0x08
    3d40:	99 85       	ldd	r25, Y+9	; 0x09
    3d42:	fc 01       	movw	r30, r24
    3d44:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3d46:	88 85       	ldd	r24, Y+8	; 0x08
    3d48:	99 85       	ldd	r25, Y+9	; 0x09
    3d4a:	fc 01       	movw	r30, r24
    3d4c:	83 81       	ldd	r24, Z+3	; 0x03
    3d4e:	88 2f       	mov	r24, r24
    3d50:	90 e0       	ldi	r25, 0x00	; 0
    3d52:	81 70       	andi	r24, 0x01	; 1
    3d54:	90 70       	andi	r25, 0x00	; 0
    3d56:	00 97       	sbiw	r24, 0x00	; 0
    3d58:	b1 f3       	breq	.-20     	; 0x3d46 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3d5a:	88 85       	ldd	r24, Y+8	; 0x08
    3d5c:	99 85       	ldd	r25, Y+9	; 0x09
    3d5e:	60 e0       	ldi	r22, 0x00	; 0
    3d60:	0e 94 96 1b 	call	0x372c	; 0x372c <ADC_ResultCh_GetWord_Signed>
    3d64:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3d66:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3d68:	2a 96       	adiw	r28, 0x0a	; 10
    3d6a:	cd bf       	out	0x3d, r28	; 61
    3d6c:	de bf       	out	0x3e, r29	; 62
    3d6e:	df 91       	pop	r29
    3d70:	cf 91       	pop	r28
    3d72:	08 95       	ret

00003d74 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3d74:	1f 93       	push	r17
    3d76:	cf 93       	push	r28
    3d78:	df 93       	push	r29
    3d7a:	cd b7       	in	r28, 0x3d	; 61
    3d7c:	de b7       	in	r29, 0x3e	; 62
    3d7e:	25 97       	sbiw	r28, 0x05	; 5
    3d80:	cd bf       	out	0x3d, r28	; 61
    3d82:	de bf       	out	0x3e, r29	; 62
    3d84:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3d86:	8a ec       	ldi	r24, 0xCA	; 202
    3d88:	91 e0       	ldi	r25, 0x01	; 1
    3d8a:	22 e0       	ldi	r18, 0x02	; 2
    3d8c:	fc 01       	movw	r30, r24
    3d8e:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3d90:	8d 81       	ldd	r24, Y+5	; 0x05
    3d92:	88 2f       	mov	r24, r24
    3d94:	90 e0       	ldi	r25, 0x00	; 0
    3d96:	89 83       	std	Y+1, r24	; 0x01
    3d98:	9a 83       	std	Y+2, r25	; 0x02
    3d9a:	89 81       	ldd	r24, Y+1	; 0x01
    3d9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9e:	fc 01       	movw	r30, r24
    3da0:	14 91       	lpm	r17, Z
    3da2:	1b 83       	std	Y+3, r17	; 0x03
    3da4:	8b 81       	ldd	r24, Y+3	; 0x03
    3da6:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3da8:	8a ec       	ldi	r24, 0xCA	; 202
    3daa:	91 e0       	ldi	r25, 0x01	; 1
    3dac:	fc 01       	movw	r30, r24
    3dae:	10 82       	st	Z, r1

	return result;
    3db0:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3db2:	25 96       	adiw	r28, 0x05	; 5
    3db4:	cd bf       	out	0x3d, r28	; 61
    3db6:	de bf       	out	0x3e, r29	; 62
    3db8:	df 91       	pop	r29
    3dba:	cf 91       	pop	r28
    3dbc:	1f 91       	pop	r17
    3dbe:	08 95       	ret

00003dc0 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3dc0:	cf 93       	push	r28
    3dc2:	df 93       	push	r29
    3dc4:	cd b7       	in	r28, 0x3d	; 61
    3dc6:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3dc8:	24 e1       	ldi	r18, 0x14	; 20
    3dca:	80 e2       	ldi	r24, 0x20	; 32
    3dcc:	91 e2       	ldi	r25, 0x21	; 33
    3dce:	fc 01       	movw	r30, r24
    3dd0:	32 2f       	mov	r19, r18
    3dd2:	11 92       	st	Z+, r1
    3dd4:	3a 95       	dec	r19
    3dd6:	e9 f7       	brne	.-6      	; 0x3dd2 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3dd8:	0e 94 6a 2c 	call	0x58d4	; 0x58d4 <chb_get_short_addr>
    3ddc:	80 93 20 21 	sts	0x2120, r24
    3de0:	90 93 21 21 	sts	0x2121, r25
    chb_drvr_init();
    3de4:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <chb_drvr_init>
}
    3de8:	df 91       	pop	r29
    3dea:	cf 91       	pop	r28
    3dec:	08 95       	ret

00003dee <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3dee:	cf 93       	push	r28
    3df0:	df 93       	push	r29
    3df2:	cd b7       	in	r28, 0x3d	; 61
    3df4:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3df6:	80 e2       	ldi	r24, 0x20	; 32
    3df8:	91 e2       	ldi	r25, 0x21	; 33
}
    3dfa:	df 91       	pop	r29
    3dfc:	cf 91       	pop	r28
    3dfe:	08 95       	ret

00003e00 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3e00:	cf 93       	push	r28
    3e02:	df 93       	push	r29
    3e04:	cd b7       	in	r28, 0x3d	; 61
    3e06:	de b7       	in	r29, 0x3e	; 62
    3e08:	27 97       	sbiw	r28, 0x07	; 7
    3e0a:	cd bf       	out	0x3d, r28	; 61
    3e0c:	de bf       	out	0x3e, r29	; 62
    3e0e:	8b 83       	std	Y+3, r24	; 0x03
    3e10:	9c 83       	std	Y+4, r25	; 0x04
    3e12:	6d 83       	std	Y+5, r22	; 0x05
    3e14:	7e 83       	std	Y+6, r23	; 0x06
    3e16:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3e18:	8b 81       	ldd	r24, Y+3	; 0x03
    3e1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e1c:	89 83       	std	Y+1, r24	; 0x01
    3e1e:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3e20:	8f 81       	ldd	r24, Y+7	; 0x07
    3e22:	28 2f       	mov	r18, r24
    3e24:	25 5f       	subi	r18, 0xF5	; 245
    3e26:	89 81       	ldd	r24, Y+1	; 0x01
    3e28:	9a 81       	ldd	r25, Y+2	; 0x02
    3e2a:	fc 01       	movw	r30, r24
    3e2c:	20 83       	st	Z, r18
    3e2e:	89 81       	ldd	r24, Y+1	; 0x01
    3e30:	9a 81       	ldd	r25, Y+2	; 0x02
    3e32:	01 96       	adiw	r24, 0x01	; 1
    3e34:	89 83       	std	Y+1, r24	; 0x01
    3e36:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3e38:	8d 81       	ldd	r24, Y+5	; 0x05
    3e3a:	9e 81       	ldd	r25, Y+6	; 0x06
    3e3c:	ff ef       	ldi	r31, 0xFF	; 255
    3e3e:	8f 3f       	cpi	r24, 0xFF	; 255
    3e40:	9f 07       	cpc	r25, r31
    3e42:	11 f0       	breq	.+4      	; 0x3e48 <chb_gen_hdr+0x48>
    3e44:	21 e6       	ldi	r18, 0x61	; 97
    3e46:	01 c0       	rjmp	.+2      	; 0x3e4a <chb_gen_hdr+0x4a>
    3e48:	21 e4       	ldi	r18, 0x41	; 65
    3e4a:	89 81       	ldd	r24, Y+1	; 0x01
    3e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4e:	fc 01       	movw	r30, r24
    3e50:	20 83       	st	Z, r18
    3e52:	89 81       	ldd	r24, Y+1	; 0x01
    3e54:	9a 81       	ldd	r25, Y+2	; 0x02
    3e56:	01 96       	adiw	r24, 0x01	; 1
    3e58:	89 83       	std	Y+1, r24	; 0x01
    3e5a:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
    3e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e60:	28 e9       	ldi	r18, 0x98	; 152
    3e62:	fc 01       	movw	r30, r24
    3e64:	20 83       	st	Z, r18
    3e66:	89 81       	ldd	r24, Y+1	; 0x01
    3e68:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6a:	01 96       	adiw	r24, 0x01	; 1
    3e6c:	89 83       	std	Y+1, r24	; 0x01
    3e6e:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3e70:	20 91 22 21 	lds	r18, 0x2122
    3e74:	89 81       	ldd	r24, Y+1	; 0x01
    3e76:	9a 81       	ldd	r25, Y+2	; 0x02
    3e78:	fc 01       	movw	r30, r24
    3e7a:	20 83       	st	Z, r18
    3e7c:	89 81       	ldd	r24, Y+1	; 0x01
    3e7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e80:	01 96       	adiw	r24, 0x01	; 1
    3e82:	89 83       	std	Y+1, r24	; 0x01
    3e84:	9a 83       	std	Y+2, r25	; 0x02
    3e86:	82 2f       	mov	r24, r18
    3e88:	8f 5f       	subi	r24, 0xFF	; 255
    3e8a:	80 93 22 21 	sts	0x2122, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3e8e:	89 81       	ldd	r24, Y+1	; 0x01
    3e90:	9a 81       	ldd	r25, Y+2	; 0x02
    3e92:	24 e3       	ldi	r18, 0x34	; 52
    3e94:	32 e1       	ldi	r19, 0x12	; 18
    3e96:	fc 01       	movw	r30, r24
    3e98:	20 83       	st	Z, r18
    3e9a:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3e9c:	89 81       	ldd	r24, Y+1	; 0x01
    3e9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea0:	02 96       	adiw	r24, 0x02	; 2
    3ea2:	89 83       	std	Y+1, r24	; 0x01
    3ea4:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3ea6:	89 81       	ldd	r24, Y+1	; 0x01
    3ea8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eaa:	2d 81       	ldd	r18, Y+5	; 0x05
    3eac:	3e 81       	ldd	r19, Y+6	; 0x06
    3eae:	fc 01       	movw	r30, r24
    3eb0:	20 83       	st	Z, r18
    3eb2:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3eb4:	89 81       	ldd	r24, Y+1	; 0x01
    3eb6:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb8:	02 96       	adiw	r24, 0x02	; 2
    3eba:	89 83       	std	Y+1, r24	; 0x01
    3ebc:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3ebe:	20 91 20 21 	lds	r18, 0x2120
    3ec2:	30 91 21 21 	lds	r19, 0x2121
    3ec6:	89 81       	ldd	r24, Y+1	; 0x01
    3ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eca:	fc 01       	movw	r30, r24
    3ecc:	20 83       	st	Z, r18
    3ece:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3ed0:	89 81       	ldd	r24, Y+1	; 0x01
    3ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed4:	02 96       	adiw	r24, 0x02	; 2
    3ed6:	89 83       	std	Y+1, r24	; 0x01
    3ed8:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3eda:	29 81       	ldd	r18, Y+1	; 0x01
    3edc:	3a 81       	ldd	r19, Y+2	; 0x02
    3ede:	8b 81       	ldd	r24, Y+3	; 0x03
    3ee0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee2:	a9 01       	movw	r20, r18
    3ee4:	48 1b       	sub	r20, r24
    3ee6:	59 0b       	sbc	r21, r25
    3ee8:	ca 01       	movw	r24, r20
}
    3eea:	27 96       	adiw	r28, 0x07	; 7
    3eec:	cd bf       	out	0x3d, r28	; 61
    3eee:	de bf       	out	0x3e, r29	; 62
    3ef0:	df 91       	pop	r29
    3ef2:	cf 91       	pop	r28
    3ef4:	08 95       	ret

00003ef6 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3ef6:	ef 92       	push	r14
    3ef8:	ff 92       	push	r15
    3efa:	0f 93       	push	r16
    3efc:	1f 93       	push	r17
    3efe:	cf 93       	push	r28
    3f00:	df 93       	push	r29
    3f02:	cd b7       	in	r28, 0x3d	; 61
    3f04:	de b7       	in	r29, 0x3e	; 62
    3f06:	e0 97       	sbiw	r28, 0x30	; 48
    3f08:	cd bf       	out	0x3d, r28	; 61
    3f0a:	de bf       	out	0x3e, r29	; 62
    3f0c:	89 a7       	lds	r24, 0x79
    3f0e:	9a a7       	lds	r25, 0x7a
    3f10:	6b a7       	lds	r22, 0x7b
    3f12:	7c a7       	lds	r23, 0x7c
    3f14:	2d a7       	lds	r18, 0x7d
    3f16:	3e a7       	lds	r19, 0x7e
    3f18:	4f a7       	lds	r20, 0x7f
    3f1a:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    3f1c:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3f1e:	5c c1       	rjmp	.+696    	; 0x41d8 <chb_write+0x2e2>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3f20:	8d a5       	lds	r24, 0x6d
    3f22:	9e a5       	lds	r25, 0x6e
    3f24:	af a5       	lds	r26, 0x6f
    3f26:	b8 a9       	sts	0x48, r27
    3f28:	85 36       	cpi	r24, 0x65	; 101
    3f2a:	91 05       	cpc	r25, r1
    3f2c:	a1 05       	cpc	r26, r1
    3f2e:	b1 05       	cpc	r27, r1
    3f30:	20 f0       	brcs	.+8      	; 0x3f3a <chb_write+0x44>
    3f32:	84 e6       	ldi	r24, 0x64	; 100
    3f34:	90 e0       	ldi	r25, 0x00	; 0
    3f36:	a0 e0       	ldi	r26, 0x00	; 0
    3f38:	b0 e0       	ldi	r27, 0x00	; 0
    3f3a:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    3f3c:	ce 01       	movw	r24, r28
    3f3e:	4f 96       	adiw	r24, 0x1f	; 31
    3f40:	29 a5       	lds	r18, 0x69
    3f42:	3a a5       	lds	r19, 0x6a
    3f44:	b9 01       	movw	r22, r18
    3f46:	4c 81       	ldd	r20, Y+4	; 0x04
    3f48:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <chb_gen_hdr>
    3f4c:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    3f4e:	1a 82       	std	Y+2, r1	; 0x02
    3f50:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3f52:	89 81       	ldd	r24, Y+1	; 0x01
    3f54:	88 2f       	mov	r24, r24
    3f56:	90 e0       	ldi	r25, 0x00	; 0
    3f58:	2b a5       	lds	r18, 0x6b
    3f5a:	3c a5       	lds	r19, 0x6c
    3f5c:	28 0f       	add	r18, r24
    3f5e:	39 1f       	adc	r19, r25
    3f60:	ce 01       	movw	r24, r28
    3f62:	4f 96       	adiw	r24, 0x1f	; 31
    3f64:	b9 01       	movw	r22, r18
    3f66:	4c 81       	ldd	r20, Y+4	; 0x04
    3f68:	0e 94 84 2c 	call	0x5908	; 0x5908 <chb_tx>
    3f6c:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    3f6e:	8e 81       	ldd	r24, Y+6	; 0x06
    3f70:	88 2f       	mov	r24, r24
    3f72:	90 e0       	ldi	r25, 0x00	; 0
    3f74:	83 30       	cpi	r24, 0x03	; 3
    3f76:	91 05       	cpc	r25, r1
    3f78:	09 f1       	breq	.+66     	; 0x3fbc <chb_write+0xc6>
    3f7a:	84 30       	cpi	r24, 0x04	; 4
    3f7c:	91 05       	cpc	r25, r1
    3f7e:	24 f4       	brge	.+8      	; 0x3f88 <chb_write+0x92>
    3f80:	81 30       	cpi	r24, 0x01	; 1
    3f82:	91 05       	cpc	r25, r1
    3f84:	39 f0       	breq	.+14     	; 0x3f94 <chb_write+0x9e>
    3f86:	24 c0       	rjmp	.+72     	; 0x3fd0 <chb_write+0xda>
    3f88:	85 30       	cpi	r24, 0x05	; 5
    3f8a:	91 05       	cpc	r25, r1
    3f8c:	69 f0       	breq	.+26     	; 0x3fa8 <chb_write+0xb2>
    3f8e:	80 34       	cpi	r24, 0x40	; 64
    3f90:	91 05       	cpc	r25, r1
    3f92:	f1 f4       	brne	.+60     	; 0x3fd0 <chb_write+0xda>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3f94:	80 91 27 21 	lds	r24, 0x2127
    3f98:	90 91 28 21 	lds	r25, 0x2128
    3f9c:	01 96       	adiw	r24, 0x01	; 1
    3f9e:	80 93 27 21 	sts	0x2127, r24
    3fa2:	90 93 28 21 	sts	0x2128, r25
                 break;
    3fa6:	15 c0       	rjmp	.+42     	; 0x3fd2 <chb_write+0xdc>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3fa8:	80 91 29 21 	lds	r24, 0x2129
    3fac:	90 91 2a 21 	lds	r25, 0x212A
    3fb0:	01 96       	adiw	r24, 0x01	; 1
    3fb2:	80 93 29 21 	sts	0x2129, r24
    3fb6:	90 93 2a 21 	sts	0x212A, r25
                 break;
    3fba:	0b c0       	rjmp	.+22     	; 0x3fd2 <chb_write+0xdc>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3fbc:	80 91 2b 21 	lds	r24, 0x212B
    3fc0:	90 91 2c 21 	lds	r25, 0x212C
    3fc4:	01 96       	adiw	r24, 0x01	; 1
    3fc6:	80 93 2b 21 	sts	0x212B, r24
    3fca:	90 93 2c 21 	sts	0x212C, r25
                 break;
    3fce:	01 c0       	rjmp	.+2      	; 0x3fd2 <chb_write+0xdc>
 
             default:
                 break;
    3fd0:	00 00       	nop
             }
			if(rtry>=0) _delay_us(100);		//if not successfully sent the first time, wait some time and try again
    3fd2:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd4:	9b 81       	ldd	r25, Y+3	; 0x03
    3fd6:	99 23       	and	r25, r25
    3fd8:	0c f4       	brge	.+2      	; 0x3fdc <chb_write+0xe6>
    3fda:	d5 c0       	rjmp	.+426    	; 0x4186 <chb_write+0x290>
    3fdc:	80 e0       	ldi	r24, 0x00	; 0
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	a8 ec       	ldi	r26, 0xC8	; 200
    3fe2:	b2 e4       	ldi	r27, 0x42	; 66
    3fe4:	8f 83       	std	Y+7, r24	; 0x07
    3fe6:	98 87       	std	Y+8, r25	; 0x08
    3fe8:	a9 87       	std	Y+9, r26	; 0x09
    3fea:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3fec:	6f 81       	ldd	r22, Y+7	; 0x07
    3fee:	78 85       	ldd	r23, Y+8	; 0x08
    3ff0:	89 85       	ldd	r24, Y+9	; 0x09
    3ff2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ff4:	2b ea       	ldi	r18, 0xAB	; 171
    3ff6:	3a ea       	ldi	r19, 0xAA	; 170
    3ff8:	4a ea       	ldi	r20, 0xAA	; 170
    3ffa:	5e e3       	ldi	r21, 0x3E	; 62
    3ffc:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4000:	dc 01       	movw	r26, r24
    4002:	cb 01       	movw	r24, r22
    4004:	8b 87       	std	Y+11, r24	; 0x0b
    4006:	9c 87       	std	Y+12, r25	; 0x0c
    4008:	ad 87       	std	Y+13, r26	; 0x0d
    400a:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    400c:	11 e0       	ldi	r17, 0x01	; 1
    400e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4010:	7c 85       	ldd	r23, Y+12	; 0x0c
    4012:	8d 85       	ldd	r24, Y+13	; 0x0d
    4014:	9e 85       	ldd	r25, Y+14	; 0x0e
    4016:	20 e0       	ldi	r18, 0x00	; 0
    4018:	30 e0       	ldi	r19, 0x00	; 0
    401a:	40 e8       	ldi	r20, 0x80	; 128
    401c:	5f e3       	ldi	r21, 0x3F	; 63
    401e:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    4022:	88 23       	and	r24, r24
    4024:	0c f0       	brlt	.+2      	; 0x4028 <chb_write+0x132>
    4026:	10 e0       	ldi	r17, 0x00	; 0
    4028:	11 23       	and	r17, r17
    402a:	19 f0       	breq	.+6      	; 0x4032 <chb_write+0x13c>
		__ticks = 1;
    402c:	81 e0       	ldi	r24, 0x01	; 1
    402e:	8f 87       	std	Y+15, r24	; 0x0f
    4030:	a3 c0       	rjmp	.+326    	; 0x4178 <chb_write+0x282>
	else if (__tmp > 255)
    4032:	11 e0       	ldi	r17, 0x01	; 1
    4034:	6b 85       	ldd	r22, Y+11	; 0x0b
    4036:	7c 85       	ldd	r23, Y+12	; 0x0c
    4038:	8d 85       	ldd	r24, Y+13	; 0x0d
    403a:	9e 85       	ldd	r25, Y+14	; 0x0e
    403c:	20 e0       	ldi	r18, 0x00	; 0
    403e:	30 e0       	ldi	r19, 0x00	; 0
    4040:	4f e7       	ldi	r20, 0x7F	; 127
    4042:	53 e4       	ldi	r21, 0x43	; 67
    4044:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    4048:	18 16       	cp	r1, r24
    404a:	0c f0       	brlt	.+2      	; 0x404e <chb_write+0x158>
    404c:	10 e0       	ldi	r17, 0x00	; 0
    404e:	11 23       	and	r17, r17
    4050:	09 f4       	brne	.+2      	; 0x4054 <chb_write+0x15e>
    4052:	89 c0       	rjmp	.+274    	; 0x4166 <chb_write+0x270>
	{
		_delay_ms(__us / 1000.0);
    4054:	6f 81       	ldd	r22, Y+7	; 0x07
    4056:	78 85       	ldd	r23, Y+8	; 0x08
    4058:	89 85       	ldd	r24, Y+9	; 0x09
    405a:	9a 85       	ldd	r25, Y+10	; 0x0a
    405c:	20 e0       	ldi	r18, 0x00	; 0
    405e:	30 e0       	ldi	r19, 0x00	; 0
    4060:	4a e7       	ldi	r20, 0x7A	; 122
    4062:	54 e4       	ldi	r21, 0x44	; 68
    4064:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    4068:	dc 01       	movw	r26, r24
    406a:	cb 01       	movw	r24, r22
    406c:	88 8b       	std	Y+16, r24	; 0x10
    406e:	99 8b       	std	Y+17, r25	; 0x11
    4070:	aa 8b       	std	Y+18, r26	; 0x12
    4072:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4074:	68 89       	ldd	r22, Y+16	; 0x10
    4076:	79 89       	ldd	r23, Y+17	; 0x11
    4078:	8a 89       	ldd	r24, Y+18	; 0x12
    407a:	9b 89       	ldd	r25, Y+19	; 0x13
    407c:	20 e0       	ldi	r18, 0x00	; 0
    407e:	30 e0       	ldi	r19, 0x00	; 0
    4080:	4a e7       	ldi	r20, 0x7A	; 122
    4082:	53 e4       	ldi	r21, 0x43	; 67
    4084:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4088:	dc 01       	movw	r26, r24
    408a:	cb 01       	movw	r24, r22
    408c:	8c 8b       	std	Y+20, r24	; 0x14
    408e:	9d 8b       	std	Y+21, r25	; 0x15
    4090:	ae 8b       	std	Y+22, r26	; 0x16
    4092:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    4094:	11 e0       	ldi	r17, 0x01	; 1
    4096:	6c 89       	ldd	r22, Y+20	; 0x14
    4098:	7d 89       	ldd	r23, Y+21	; 0x15
    409a:	8e 89       	ldd	r24, Y+22	; 0x16
    409c:	9f 89       	ldd	r25, Y+23	; 0x17
    409e:	20 e0       	ldi	r18, 0x00	; 0
    40a0:	30 e0       	ldi	r19, 0x00	; 0
    40a2:	40 e8       	ldi	r20, 0x80	; 128
    40a4:	5f e3       	ldi	r21, 0x3F	; 63
    40a6:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    40aa:	88 23       	and	r24, r24
    40ac:	0c f0       	brlt	.+2      	; 0x40b0 <chb_write+0x1ba>
    40ae:	10 e0       	ldi	r17, 0x00	; 0
    40b0:	11 23       	and	r17, r17
    40b2:	29 f0       	breq	.+10     	; 0x40be <chb_write+0x1c8>
		__ticks = 1;
    40b4:	81 e0       	ldi	r24, 0x01	; 1
    40b6:	90 e0       	ldi	r25, 0x00	; 0
    40b8:	88 8f       	std	Y+24, r24	; 0x18
    40ba:	99 8f       	std	Y+25, r25	; 0x19
    40bc:	46 c0       	rjmp	.+140    	; 0x414a <chb_write+0x254>
	else if (__tmp > 65535)
    40be:	11 e0       	ldi	r17, 0x01	; 1
    40c0:	6c 89       	ldd	r22, Y+20	; 0x14
    40c2:	7d 89       	ldd	r23, Y+21	; 0x15
    40c4:	8e 89       	ldd	r24, Y+22	; 0x16
    40c6:	9f 89       	ldd	r25, Y+23	; 0x17
    40c8:	20 e0       	ldi	r18, 0x00	; 0
    40ca:	3f ef       	ldi	r19, 0xFF	; 255
    40cc:	4f e7       	ldi	r20, 0x7F	; 127
    40ce:	57 e4       	ldi	r21, 0x47	; 71
    40d0:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    40d4:	18 16       	cp	r1, r24
    40d6:	0c f0       	brlt	.+2      	; 0x40da <chb_write+0x1e4>
    40d8:	10 e0       	ldi	r17, 0x00	; 0
    40da:	11 23       	and	r17, r17
    40dc:	61 f1       	breq	.+88     	; 0x4136 <chb_write+0x240>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    40de:	68 89       	ldd	r22, Y+16	; 0x10
    40e0:	79 89       	ldd	r23, Y+17	; 0x11
    40e2:	8a 89       	ldd	r24, Y+18	; 0x12
    40e4:	9b 89       	ldd	r25, Y+19	; 0x13
    40e6:	20 e0       	ldi	r18, 0x00	; 0
    40e8:	30 e0       	ldi	r19, 0x00	; 0
    40ea:	40 e2       	ldi	r20, 0x20	; 32
    40ec:	51 e4       	ldi	r21, 0x41	; 65
    40ee:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    40f2:	dc 01       	movw	r26, r24
    40f4:	cb 01       	movw	r24, r22
    40f6:	bc 01       	movw	r22, r24
    40f8:	cd 01       	movw	r24, r26
    40fa:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    40fe:	dc 01       	movw	r26, r24
    4100:	cb 01       	movw	r24, r22
    4102:	88 8f       	std	Y+24, r24	; 0x18
    4104:	99 8f       	std	Y+25, r25	; 0x19
    4106:	12 c0       	rjmp	.+36     	; 0x412c <chb_write+0x236>
    4108:	89 e1       	ldi	r24, 0x19	; 25
    410a:	90 e0       	ldi	r25, 0x00	; 0
    410c:	8a 8f       	std	Y+26, r24	; 0x1a
    410e:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4110:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4112:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4114:	8c 01       	movw	r16, r24
    4116:	c8 01       	movw	r24, r16
    4118:	01 97       	sbiw	r24, 0x01	; 1
    411a:	f1 f7       	brne	.-4      	; 0x4118 <chb_write+0x222>
    411c:	8c 01       	movw	r16, r24
    411e:	0a 8f       	std	Y+26, r16	; 0x1a
    4120:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4122:	88 8d       	ldd	r24, Y+24	; 0x18
    4124:	99 8d       	ldd	r25, Y+25	; 0x19
    4126:	01 97       	sbiw	r24, 0x01	; 1
    4128:	88 8f       	std	Y+24, r24	; 0x18
    412a:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    412c:	88 8d       	ldd	r24, Y+24	; 0x18
    412e:	99 8d       	ldd	r25, Y+25	; 0x19
    4130:	00 97       	sbiw	r24, 0x00	; 0
    4132:	51 f7       	brne	.-44     	; 0x4108 <chb_write+0x212>
    4134:	28 c0       	rjmp	.+80     	; 0x4186 <chb_write+0x290>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4136:	6c 89       	ldd	r22, Y+20	; 0x14
    4138:	7d 89       	ldd	r23, Y+21	; 0x15
    413a:	8e 89       	ldd	r24, Y+22	; 0x16
    413c:	9f 89       	ldd	r25, Y+23	; 0x17
    413e:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    4142:	dc 01       	movw	r26, r24
    4144:	cb 01       	movw	r24, r22
    4146:	88 8f       	std	Y+24, r24	; 0x18
    4148:	99 8f       	std	Y+25, r25	; 0x19
    414a:	88 8d       	ldd	r24, Y+24	; 0x18
    414c:	99 8d       	ldd	r25, Y+25	; 0x19
    414e:	8c 8f       	std	Y+28, r24	; 0x1c
    4150:	9d 8f       	std	Y+29, r25	; 0x1d
    4152:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4154:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4156:	8c 01       	movw	r16, r24
    4158:	c8 01       	movw	r24, r16
    415a:	01 97       	sbiw	r24, 0x01	; 1
    415c:	f1 f7       	brne	.-4      	; 0x415a <chb_write+0x264>
    415e:	8c 01       	movw	r16, r24
    4160:	0c 8f       	std	Y+28, r16	; 0x1c
    4162:	1d 8f       	std	Y+29, r17	; 0x1d
    4164:	10 c0       	rjmp	.+32     	; 0x4186 <chb_write+0x290>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4166:	6b 85       	ldd	r22, Y+11	; 0x0b
    4168:	7c 85       	ldd	r23, Y+12	; 0x0c
    416a:	8d 85       	ldd	r24, Y+13	; 0x0d
    416c:	9e 85       	ldd	r25, Y+14	; 0x0e
    416e:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    4172:	dc 01       	movw	r26, r24
    4174:	cb 01       	movw	r24, r22
    4176:	8f 87       	std	Y+15, r24	; 0x0f
    4178:	8f 85       	ldd	r24, Y+15	; 0x0f
    417a:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    417c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    417e:	18 2f       	mov	r17, r24
    4180:	1a 95       	dec	r17
    4182:	f1 f7       	brne	.-4      	; 0x4180 <chb_write+0x28a>
    4184:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message
    4186:	8a 81       	ldd	r24, Y+2	; 0x02
    4188:	9b 81       	ldd	r25, Y+3	; 0x03
    418a:	84 31       	cpi	r24, 0x14	; 20
    418c:	91 05       	cpc	r25, r1
    418e:	11 f4       	brne	.+4      	; 0x4194 <chb_write+0x29e>
    4190:	8e 81       	ldd	r24, Y+6	; 0x06
    4192:	2c c0       	rjmp	.+88     	; 0x41ec <chb_write+0x2f6>
			rtry++;	
    4194:	8a 81       	ldd	r24, Y+2	; 0x02
    4196:	9b 81       	ldd	r25, Y+3	; 0x03
    4198:	01 96       	adiw	r24, 0x01	; 1
    419a:	8a 83       	std	Y+2, r24	; 0x02
    419c:	9b 83       	std	Y+3, r25	; 0x03
		} while(status != CHB_SUCCESS);			
    419e:	8e 81       	ldd	r24, Y+6	; 0x06
    41a0:	88 23       	and	r24, r24
    41a2:	09 f0       	breq	.+2      	; 0x41a6 <chb_write+0x2b0>
    41a4:	d6 ce       	rjmp	.-596    	; 0x3f52 <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    41a6:	99 81       	ldd	r25, Y+1	; 0x01
    41a8:	8c 81       	ldd	r24, Y+4	; 0x04
    41aa:	89 0f       	add	r24, r25
    41ac:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    41ae:	8c 81       	ldd	r24, Y+4	; 0x04
    41b0:	88 2f       	mov	r24, r24
    41b2:	90 e0       	ldi	r25, 0x00	; 0
    41b4:	a0 e0       	ldi	r26, 0x00	; 0
    41b6:	b0 e0       	ldi	r27, 0x00	; 0
    41b8:	2d a5       	lds	r18, 0x6d
    41ba:	3e a5       	lds	r19, 0x6e
    41bc:	4f a5       	lds	r20, 0x6f
    41be:	58 a9       	sts	0x48, r21
    41c0:	79 01       	movw	r14, r18
    41c2:	8a 01       	movw	r16, r20
    41c4:	e8 1a       	sub	r14, r24
    41c6:	f9 0a       	sbc	r15, r25
    41c8:	0a 0b       	sbc	r16, r26
    41ca:	1b 0b       	sbc	r17, r27
    41cc:	d8 01       	movw	r26, r16
    41ce:	c7 01       	movw	r24, r14
    41d0:	8d a7       	lds	r24, 0x7d
    41d2:	9e a7       	lds	r25, 0x7e
    41d4:	af a7       	lds	r26, 0x7f
    41d6:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    41d8:	8d a5       	lds	r24, 0x6d
    41da:	9e a5       	lds	r25, 0x6e
    41dc:	af a5       	lds	r26, 0x6f
    41de:	b8 a9       	sts	0x48, r27
    41e0:	00 97       	sbiw	r24, 0x00	; 0
    41e2:	a1 05       	cpc	r26, r1
    41e4:	b1 05       	cpc	r27, r1
    41e6:	09 f0       	breq	.+2      	; 0x41ea <chb_write+0x2f4>
    41e8:	9b ce       	rjmp	.-714    	; 0x3f20 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    41ea:	80 e0       	ldi	r24, 0x00	; 0
}
    41ec:	e0 96       	adiw	r28, 0x30	; 48
    41ee:	cd bf       	out	0x3d, r28	; 61
    41f0:	de bf       	out	0x3e, r29	; 62
    41f2:	df 91       	pop	r29
    41f4:	cf 91       	pop	r28
    41f6:	1f 91       	pop	r17
    41f8:	0f 91       	pop	r16
    41fa:	ff 90       	pop	r15
    41fc:	ef 90       	pop	r14
    41fe:	08 95       	ret

00004200 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4200:	cf 93       	push	r28
    4202:	df 93       	push	r29
    4204:	cd b7       	in	r28, 0x3d	; 61
    4206:	de b7       	in	r29, 0x3e	; 62
    4208:	27 97       	sbiw	r28, 0x07	; 7
    420a:	cd bf       	out	0x3d, r28	; 61
    420c:	de bf       	out	0x3e, r29	; 62
    420e:	8e 83       	std	Y+6, r24	; 0x06
    4210:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    4212:	8e 81       	ldd	r24, Y+6	; 0x06
    4214:	9f 81       	ldd	r25, Y+7	; 0x07
    4216:	05 96       	adiw	r24, 0x05	; 5
    4218:	8a 83       	std	Y+2, r24	; 0x02
    421a:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    421c:	0e 94 cd 21 	call	0x439a	; 0x439a <chb_buf_read>
    4220:	8c 83       	std	Y+4, r24	; 0x04
    4222:	8c 81       	ldd	r24, Y+4	; 0x04
    4224:	88 23       	and	r24, r24
    4226:	14 f4       	brge	.+4      	; 0x422c <chb_read+0x2c>
    {
        return 0;
    4228:	80 e0       	ldi	r24, 0x00	; 0
    422a:	80 c0       	rjmp	.+256    	; 0x432c <chb_read+0x12c>
    }
    *data_ptr++ = len;
    422c:	8a 81       	ldd	r24, Y+2	; 0x02
    422e:	9b 81       	ldd	r25, Y+3	; 0x03
    4230:	2c 81       	ldd	r18, Y+4	; 0x04
    4232:	fc 01       	movw	r30, r24
    4234:	20 83       	st	Z, r18
    4236:	8a 81       	ldd	r24, Y+2	; 0x02
    4238:	9b 81       	ldd	r25, Y+3	; 0x03
    423a:	01 96       	adiw	r24, 0x01	; 1
    423c:	8a 83       	std	Y+2, r24	; 0x02
    423e:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4240:	19 82       	std	Y+1, r1	; 0x01
    4242:	0f c0       	rjmp	.+30     	; 0x4262 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    4244:	0e 94 cd 21 	call	0x439a	; 0x439a <chb_buf_read>
    4248:	28 2f       	mov	r18, r24
    424a:	8a 81       	ldd	r24, Y+2	; 0x02
    424c:	9b 81       	ldd	r25, Y+3	; 0x03
    424e:	fc 01       	movw	r30, r24
    4250:	20 83       	st	Z, r18
    4252:	8a 81       	ldd	r24, Y+2	; 0x02
    4254:	9b 81       	ldd	r25, Y+3	; 0x03
    4256:	01 96       	adiw	r24, 0x01	; 1
    4258:	8a 83       	std	Y+2, r24	; 0x02
    425a:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    425c:	89 81       	ldd	r24, Y+1	; 0x01
    425e:	8f 5f       	subi	r24, 0xFF	; 255
    4260:	89 83       	std	Y+1, r24	; 0x01
    4262:	99 81       	ldd	r25, Y+1	; 0x01
    4264:	8c 81       	ldd	r24, Y+4	; 0x04
    4266:	98 17       	cp	r25, r24
    4268:	68 f3       	brcs	.-38     	; 0x4244 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    426a:	8e 81       	ldd	r24, Y+6	; 0x06
    426c:	9f 81       	ldd	r25, Y+7	; 0x07
    426e:	08 96       	adiw	r24, 0x08	; 8
    4270:	8a 83       	std	Y+2, r24	; 0x02
    4272:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4274:	8a 81       	ldd	r24, Y+2	; 0x02
    4276:	9b 81       	ldd	r25, Y+3	; 0x03
    4278:	fc 01       	movw	r30, r24
    427a:	80 81       	ld	r24, Z
    427c:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    427e:	8e 81       	ldd	r24, Y+6	; 0x06
    4280:	9f 81       	ldd	r25, Y+7	; 0x07
    4282:	0b 96       	adiw	r24, 0x0b	; 11
    4284:	8a 83       	std	Y+2, r24	; 0x02
    4286:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    4288:	8a 81       	ldd	r24, Y+2	; 0x02
    428a:	9b 81       	ldd	r25, Y+3	; 0x03
    428c:	fc 01       	movw	r30, r24
    428e:	20 81       	ld	r18, Z
    4290:	31 81       	ldd	r19, Z+1	; 0x01
    4292:	8e 81       	ldd	r24, Y+6	; 0x06
    4294:	9f 81       	ldd	r25, Y+7	; 0x07
    4296:	fc 01       	movw	r30, r24
    4298:	23 83       	std	Z+3, r18	; 0x03
    429a:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    429c:	8a 81       	ldd	r24, Y+2	; 0x02
    429e:	9b 81       	ldd	r25, Y+3	; 0x03
    42a0:	02 96       	adiw	r24, 0x02	; 2
    42a2:	8a 83       	std	Y+2, r24	; 0x02
    42a4:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    42a6:	8a 81       	ldd	r24, Y+2	; 0x02
    42a8:	9b 81       	ldd	r25, Y+3	; 0x03
    42aa:	fc 01       	movw	r30, r24
    42ac:	20 81       	ld	r18, Z
    42ae:	31 81       	ldd	r19, Z+1	; 0x01
    42b0:	8e 81       	ldd	r24, Y+6	; 0x06
    42b2:	9f 81       	ldd	r25, Y+7	; 0x07
    42b4:	fc 01       	movw	r30, r24
    42b6:	21 83       	std	Z+1, r18	; 0x01
    42b8:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    42ba:	8a 81       	ldd	r24, Y+2	; 0x02
    42bc:	9b 81       	ldd	r25, Y+3	; 0x03
    42be:	02 96       	adiw	r24, 0x02	; 2
    42c0:	8a 83       	std	Y+2, r24	; 0x02
    42c2:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    42c4:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <chb_buf_get_len>
    42c8:	88 23       	and	r24, r24
    42ca:	11 f4       	brne	.+4      	; 0x42d0 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    42cc:	10 92 23 21 	sts	0x2123, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    42d0:	80 91 05 20 	lds	r24, 0x2005
    42d4:	9d 81       	ldd	r25, Y+5	; 0x05
    42d6:	98 17       	cp	r25, r24
    42d8:	71 f4       	brne	.+28     	; 0x42f6 <chb_read+0xf6>
    42da:	8e 81       	ldd	r24, Y+6	; 0x06
    42dc:	9f 81       	ldd	r25, Y+7	; 0x07
    42de:	fc 01       	movw	r30, r24
    42e0:	21 81       	ldd	r18, Z+1	; 0x01
    42e2:	32 81       	ldd	r19, Z+2	; 0x02
    42e4:	80 91 06 20 	lds	r24, 0x2006
    42e8:	90 91 07 20 	lds	r25, 0x2007
    42ec:	28 17       	cp	r18, r24
    42ee:	39 07       	cpc	r19, r25
    42f0:	11 f4       	brne	.+4      	; 0x42f6 <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    42f2:	80 e0       	ldi	r24, 0x00	; 0
    42f4:	1b c0       	rjmp	.+54     	; 0x432c <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    42f6:	8d 81       	ldd	r24, Y+5	; 0x05
    42f8:	80 93 05 20 	sts	0x2005, r24
        prev_src_addr = rx->src_addr;
    42fc:	8e 81       	ldd	r24, Y+6	; 0x06
    42fe:	9f 81       	ldd	r25, Y+7	; 0x07
    4300:	fc 01       	movw	r30, r24
    4302:	81 81       	ldd	r24, Z+1	; 0x01
    4304:	92 81       	ldd	r25, Z+2	; 0x02
    4306:	80 93 06 20 	sts	0x2006, r24
    430a:	90 93 07 20 	sts	0x2007, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    430e:	8c 81       	ldd	r24, Y+4	; 0x04
    4310:	88 2f       	mov	r24, r24
    4312:	90 e0       	ldi	r25, 0x00	; 0
    4314:	09 97       	sbiw	r24, 0x09	; 9
    4316:	9c 01       	movw	r18, r24
    4318:	8e 81       	ldd	r24, Y+6	; 0x06
    431a:	9f 81       	ldd	r25, Y+7	; 0x07
    431c:	4a 81       	ldd	r20, Y+2	; 0x02
    431e:	5b 81       	ldd	r21, Y+3	; 0x03
    4320:	ba 01       	movw	r22, r20
    4322:	a9 01       	movw	r20, r18
    4324:	0e 94 0a 5d 	call	0xba14	; 0xba14 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    4328:	8c 81       	ldd	r24, Y+4	; 0x04
    432a:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    432c:	27 96       	adiw	r28, 0x07	; 7
    432e:	cd bf       	out	0x3d, r28	; 61
    4330:	de bf       	out	0x3e, r29	; 62
    4332:	df 91       	pop	r29
    4334:	cf 91       	pop	r28
    4336:	08 95       	ret

00004338 <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    4338:	cf 93       	push	r28
    433a:	df 93       	push	r29
    433c:	cd b7       	in	r28, 0x3d	; 61
    433e:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4340:	10 92 b4 21 	sts	0x21B4, r1
    wr_ptr = 0;
    4344:	10 92 b5 21 	sts	0x21B5, r1
    len = 0;
    4348:	10 92 b6 21 	sts	0x21B6, r1
}
    434c:	df 91       	pop	r29
    434e:	cf 91       	pop	r28
    4350:	08 95       	ret

00004352 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4352:	cf 93       	push	r28
    4354:	df 93       	push	r29
    4356:	0f 92       	push	r0
    4358:	cd b7       	in	r28, 0x3d	; 61
    435a:	de b7       	in	r29, 0x3e	; 62
    435c:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    435e:	80 91 b5 21 	lds	r24, 0x21B5
    4362:	88 2f       	mov	r24, r24
    4364:	90 e0       	ldi	r25, 0x00	; 0
    4366:	8c 5c       	subi	r24, 0xCC	; 204
    4368:	9e 4d       	sbci	r25, 0xDE	; 222
    436a:	29 81       	ldd	r18, Y+1	; 0x01
    436c:	fc 01       	movw	r30, r24
    436e:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4370:	80 91 b5 21 	lds	r24, 0x21B5
    4374:	88 2f       	mov	r24, r24
    4376:	90 e0       	ldi	r25, 0x00	; 0
    4378:	01 96       	adiw	r24, 0x01	; 1
    437a:	20 e8       	ldi	r18, 0x80	; 128
    437c:	30 e0       	ldi	r19, 0x00	; 0
    437e:	b9 01       	movw	r22, r18
    4380:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    4384:	80 93 b5 21 	sts	0x21B5, r24
    len++;
    4388:	80 91 b6 21 	lds	r24, 0x21B6
    438c:	8f 5f       	subi	r24, 0xFF	; 255
    438e:	80 93 b6 21 	sts	0x21B6, r24
}
    4392:	0f 90       	pop	r0
    4394:	df 91       	pop	r29
    4396:	cf 91       	pop	r28
    4398:	08 95       	ret

0000439a <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    439a:	cf 93       	push	r28
    439c:	df 93       	push	r29
    439e:	0f 92       	push	r0
    43a0:	cd b7       	in	r28, 0x3d	; 61
    43a2:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    43a4:	80 91 b4 21 	lds	r24, 0x21B4
    43a8:	88 2f       	mov	r24, r24
    43aa:	90 e0       	ldi	r25, 0x00	; 0
    43ac:	8c 5c       	subi	r24, 0xCC	; 204
    43ae:	9e 4d       	sbci	r25, 0xDE	; 222
    43b0:	fc 01       	movw	r30, r24
    43b2:	80 81       	ld	r24, Z
    43b4:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    43b6:	80 91 b4 21 	lds	r24, 0x21B4
    43ba:	88 2f       	mov	r24, r24
    43bc:	90 e0       	ldi	r25, 0x00	; 0
    43be:	01 96       	adiw	r24, 0x01	; 1
    43c0:	20 e8       	ldi	r18, 0x80	; 128
    43c2:	30 e0       	ldi	r19, 0x00	; 0
    43c4:	b9 01       	movw	r22, r18
    43c6:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    43ca:	80 93 b4 21 	sts	0x21B4, r24
    len--;
    43ce:	80 91 b6 21 	lds	r24, 0x21B6
    43d2:	81 50       	subi	r24, 0x01	; 1
    43d4:	80 93 b6 21 	sts	0x21B6, r24
    return data;
    43d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    43da:	0f 90       	pop	r0
    43dc:	df 91       	pop	r29
    43de:	cf 91       	pop	r28
    43e0:	08 95       	ret

000043e2 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    43e2:	cf 93       	push	r28
    43e4:	df 93       	push	r29
    43e6:	cd b7       	in	r28, 0x3d	; 61
    43e8:	de b7       	in	r29, 0x3e	; 62
    return len;
    43ea:	80 91 b6 21 	lds	r24, 0x21B6
}
    43ee:	df 91       	pop	r29
    43f0:	cf 91       	pop	r28
    43f2:	08 95       	ret

000043f4 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    43f4:	cf 93       	push	r28
    43f6:	df 93       	push	r29
    43f8:	cd b7       	in	r28, 0x3d	; 61
    43fa:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    43fc:	81 e0       	ldi	r24, 0x01	; 1
    43fe:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    4402:	8f 71       	andi	r24, 0x1F	; 31
}
    4404:	df 91       	pop	r29
    4406:	cf 91       	pop	r28
    4408:	08 95       	ret

0000440a <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    440a:	cf 93       	push	r28
    440c:	df 93       	push	r29
    440e:	cd b7       	in	r28, 0x3d	; 61
    4410:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    4412:	82 e0       	ldi	r24, 0x02	; 2
    4414:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    4418:	82 95       	swap	r24
    441a:	86 95       	lsr	r24
    441c:	87 70       	andi	r24, 0x07	; 7
}
    441e:	df 91       	pop	r29
    4420:	cf 91       	pop	r28
    4422:	08 95       	ret

00004424 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    4424:	0f 93       	push	r16
    4426:	1f 93       	push	r17
    4428:	cf 93       	push	r28
    442a:	df 93       	push	r29
    442c:	cd b7       	in	r28, 0x3d	; 61
    442e:	de b7       	in	r29, 0x3e	; 62
    4430:	e0 97       	sbiw	r28, 0x30	; 48
    4432:	cd bf       	out	0x3d, r28	; 61
    4434:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    4436:	84 e6       	ldi	r24, 0x64	; 100
    4438:	96 e0       	ldi	r25, 0x06	; 6
    443a:	24 e6       	ldi	r18, 0x64	; 100
    443c:	36 e0       	ldi	r19, 0x06	; 6
    443e:	f9 01       	movw	r30, r18
    4440:	20 81       	ld	r18, Z
    4442:	21 60       	ori	r18, 0x01	; 1
    4444:	fc 01       	movw	r30, r24
    4446:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    4448:	84 e6       	ldi	r24, 0x64	; 100
    444a:	96 e0       	ldi	r25, 0x06	; 6
    444c:	24 e6       	ldi	r18, 0x64	; 100
    444e:	36 e0       	ldi	r19, 0x06	; 6
    4450:	f9 01       	movw	r30, r18
    4452:	20 81       	ld	r18, Z
    4454:	2d 7f       	andi	r18, 0xFD	; 253
    4456:	fc 01       	movw	r30, r24
    4458:	20 83       	st	Z, r18
    445a:	80 e0       	ldi	r24, 0x00	; 0
    445c:	90 e0       	ldi	r25, 0x00	; 0
    445e:	ae eb       	ldi	r26, 0xBE	; 190
    4460:	b3 e4       	ldi	r27, 0x43	; 67
    4462:	89 83       	std	Y+1, r24	; 0x01
    4464:	9a 83       	std	Y+2, r25	; 0x02
    4466:	ab 83       	std	Y+3, r26	; 0x03
    4468:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    446a:	69 81       	ldd	r22, Y+1	; 0x01
    446c:	7a 81       	ldd	r23, Y+2	; 0x02
    446e:	8b 81       	ldd	r24, Y+3	; 0x03
    4470:	9c 81       	ldd	r25, Y+4	; 0x04
    4472:	2b ea       	ldi	r18, 0xAB	; 171
    4474:	3a ea       	ldi	r19, 0xAA	; 170
    4476:	4a ea       	ldi	r20, 0xAA	; 170
    4478:	5e e3       	ldi	r21, 0x3E	; 62
    447a:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    447e:	dc 01       	movw	r26, r24
    4480:	cb 01       	movw	r24, r22
    4482:	8d 83       	std	Y+5, r24	; 0x05
    4484:	9e 83       	std	Y+6, r25	; 0x06
    4486:	af 83       	std	Y+7, r26	; 0x07
    4488:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    448a:	11 e0       	ldi	r17, 0x01	; 1
    448c:	6d 81       	ldd	r22, Y+5	; 0x05
    448e:	7e 81       	ldd	r23, Y+6	; 0x06
    4490:	8f 81       	ldd	r24, Y+7	; 0x07
    4492:	98 85       	ldd	r25, Y+8	; 0x08
    4494:	20 e0       	ldi	r18, 0x00	; 0
    4496:	30 e0       	ldi	r19, 0x00	; 0
    4498:	40 e8       	ldi	r20, 0x80	; 128
    449a:	5f e3       	ldi	r21, 0x3F	; 63
    449c:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    44a0:	88 23       	and	r24, r24
    44a2:	0c f0       	brlt	.+2      	; 0x44a6 <chb_reset+0x82>
    44a4:	10 e0       	ldi	r17, 0x00	; 0
    44a6:	11 23       	and	r17, r17
    44a8:	19 f0       	breq	.+6      	; 0x44b0 <chb_reset+0x8c>
		__ticks = 1;
    44aa:	81 e0       	ldi	r24, 0x01	; 1
    44ac:	89 87       	std	Y+9, r24	; 0x09
    44ae:	a3 c0       	rjmp	.+326    	; 0x45f6 <chb_reset+0x1d2>
	else if (__tmp > 255)
    44b0:	11 e0       	ldi	r17, 0x01	; 1
    44b2:	6d 81       	ldd	r22, Y+5	; 0x05
    44b4:	7e 81       	ldd	r23, Y+6	; 0x06
    44b6:	8f 81       	ldd	r24, Y+7	; 0x07
    44b8:	98 85       	ldd	r25, Y+8	; 0x08
    44ba:	20 e0       	ldi	r18, 0x00	; 0
    44bc:	30 e0       	ldi	r19, 0x00	; 0
    44be:	4f e7       	ldi	r20, 0x7F	; 127
    44c0:	53 e4       	ldi	r21, 0x43	; 67
    44c2:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    44c6:	18 16       	cp	r1, r24
    44c8:	0c f0       	brlt	.+2      	; 0x44cc <chb_reset+0xa8>
    44ca:	10 e0       	ldi	r17, 0x00	; 0
    44cc:	11 23       	and	r17, r17
    44ce:	09 f4       	brne	.+2      	; 0x44d2 <chb_reset+0xae>
    44d0:	89 c0       	rjmp	.+274    	; 0x45e4 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    44d2:	69 81       	ldd	r22, Y+1	; 0x01
    44d4:	7a 81       	ldd	r23, Y+2	; 0x02
    44d6:	8b 81       	ldd	r24, Y+3	; 0x03
    44d8:	9c 81       	ldd	r25, Y+4	; 0x04
    44da:	20 e0       	ldi	r18, 0x00	; 0
    44dc:	30 e0       	ldi	r19, 0x00	; 0
    44de:	4a e7       	ldi	r20, 0x7A	; 122
    44e0:	54 e4       	ldi	r21, 0x44	; 68
    44e2:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    44e6:	dc 01       	movw	r26, r24
    44e8:	cb 01       	movw	r24, r22
    44ea:	8a 87       	std	Y+10, r24	; 0x0a
    44ec:	9b 87       	std	Y+11, r25	; 0x0b
    44ee:	ac 87       	std	Y+12, r26	; 0x0c
    44f0:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    44f2:	6a 85       	ldd	r22, Y+10	; 0x0a
    44f4:	7b 85       	ldd	r23, Y+11	; 0x0b
    44f6:	8c 85       	ldd	r24, Y+12	; 0x0c
    44f8:	9d 85       	ldd	r25, Y+13	; 0x0d
    44fa:	20 e0       	ldi	r18, 0x00	; 0
    44fc:	30 e0       	ldi	r19, 0x00	; 0
    44fe:	4a e7       	ldi	r20, 0x7A	; 122
    4500:	53 e4       	ldi	r21, 0x43	; 67
    4502:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4506:	dc 01       	movw	r26, r24
    4508:	cb 01       	movw	r24, r22
    450a:	8e 87       	std	Y+14, r24	; 0x0e
    450c:	9f 87       	std	Y+15, r25	; 0x0f
    450e:	a8 8b       	std	Y+16, r26	; 0x10
    4510:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    4512:	11 e0       	ldi	r17, 0x01	; 1
    4514:	6e 85       	ldd	r22, Y+14	; 0x0e
    4516:	7f 85       	ldd	r23, Y+15	; 0x0f
    4518:	88 89       	ldd	r24, Y+16	; 0x10
    451a:	99 89       	ldd	r25, Y+17	; 0x11
    451c:	20 e0       	ldi	r18, 0x00	; 0
    451e:	30 e0       	ldi	r19, 0x00	; 0
    4520:	40 e8       	ldi	r20, 0x80	; 128
    4522:	5f e3       	ldi	r21, 0x3F	; 63
    4524:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    4528:	88 23       	and	r24, r24
    452a:	0c f0       	brlt	.+2      	; 0x452e <chb_reset+0x10a>
    452c:	10 e0       	ldi	r17, 0x00	; 0
    452e:	11 23       	and	r17, r17
    4530:	29 f0       	breq	.+10     	; 0x453c <chb_reset+0x118>
		__ticks = 1;
    4532:	81 e0       	ldi	r24, 0x01	; 1
    4534:	90 e0       	ldi	r25, 0x00	; 0
    4536:	8a 8b       	std	Y+18, r24	; 0x12
    4538:	9b 8b       	std	Y+19, r25	; 0x13
    453a:	46 c0       	rjmp	.+140    	; 0x45c8 <chb_reset+0x1a4>
	else if (__tmp > 65535)
    453c:	11 e0       	ldi	r17, 0x01	; 1
    453e:	6e 85       	ldd	r22, Y+14	; 0x0e
    4540:	7f 85       	ldd	r23, Y+15	; 0x0f
    4542:	88 89       	ldd	r24, Y+16	; 0x10
    4544:	99 89       	ldd	r25, Y+17	; 0x11
    4546:	20 e0       	ldi	r18, 0x00	; 0
    4548:	3f ef       	ldi	r19, 0xFF	; 255
    454a:	4f e7       	ldi	r20, 0x7F	; 127
    454c:	57 e4       	ldi	r21, 0x47	; 71
    454e:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    4552:	18 16       	cp	r1, r24
    4554:	0c f0       	brlt	.+2      	; 0x4558 <chb_reset+0x134>
    4556:	10 e0       	ldi	r17, 0x00	; 0
    4558:	11 23       	and	r17, r17
    455a:	61 f1       	breq	.+88     	; 0x45b4 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    455c:	6a 85       	ldd	r22, Y+10	; 0x0a
    455e:	7b 85       	ldd	r23, Y+11	; 0x0b
    4560:	8c 85       	ldd	r24, Y+12	; 0x0c
    4562:	9d 85       	ldd	r25, Y+13	; 0x0d
    4564:	20 e0       	ldi	r18, 0x00	; 0
    4566:	30 e0       	ldi	r19, 0x00	; 0
    4568:	40 e2       	ldi	r20, 0x20	; 32
    456a:	51 e4       	ldi	r21, 0x41	; 65
    456c:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4570:	dc 01       	movw	r26, r24
    4572:	cb 01       	movw	r24, r22
    4574:	bc 01       	movw	r22, r24
    4576:	cd 01       	movw	r24, r26
    4578:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    457c:	dc 01       	movw	r26, r24
    457e:	cb 01       	movw	r24, r22
    4580:	8a 8b       	std	Y+18, r24	; 0x12
    4582:	9b 8b       	std	Y+19, r25	; 0x13
    4584:	12 c0       	rjmp	.+36     	; 0x45aa <chb_reset+0x186>
    4586:	89 e1       	ldi	r24, 0x19	; 25
    4588:	90 e0       	ldi	r25, 0x00	; 0
    458a:	8c 8b       	std	Y+20, r24	; 0x14
    458c:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    458e:	8c 89       	ldd	r24, Y+20	; 0x14
    4590:	9d 89       	ldd	r25, Y+21	; 0x15
    4592:	8c 01       	movw	r16, r24
    4594:	c8 01       	movw	r24, r16
    4596:	01 97       	sbiw	r24, 0x01	; 1
    4598:	f1 f7       	brne	.-4      	; 0x4596 <chb_reset+0x172>
    459a:	8c 01       	movw	r16, r24
    459c:	0c 8b       	std	Y+20, r16	; 0x14
    459e:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    45a0:	8a 89       	ldd	r24, Y+18	; 0x12
    45a2:	9b 89       	ldd	r25, Y+19	; 0x13
    45a4:	01 97       	sbiw	r24, 0x01	; 1
    45a6:	8a 8b       	std	Y+18, r24	; 0x12
    45a8:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    45aa:	8a 89       	ldd	r24, Y+18	; 0x12
    45ac:	9b 89       	ldd	r25, Y+19	; 0x13
    45ae:	00 97       	sbiw	r24, 0x00	; 0
    45b0:	51 f7       	brne	.-44     	; 0x4586 <chb_reset+0x162>
    45b2:	28 c0       	rjmp	.+80     	; 0x4604 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    45b4:	6e 85       	ldd	r22, Y+14	; 0x0e
    45b6:	7f 85       	ldd	r23, Y+15	; 0x0f
    45b8:	88 89       	ldd	r24, Y+16	; 0x10
    45ba:	99 89       	ldd	r25, Y+17	; 0x11
    45bc:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    45c0:	dc 01       	movw	r26, r24
    45c2:	cb 01       	movw	r24, r22
    45c4:	8a 8b       	std	Y+18, r24	; 0x12
    45c6:	9b 8b       	std	Y+19, r25	; 0x13
    45c8:	8a 89       	ldd	r24, Y+18	; 0x12
    45ca:	9b 89       	ldd	r25, Y+19	; 0x13
    45cc:	8e 8b       	std	Y+22, r24	; 0x16
    45ce:	9f 8b       	std	Y+23, r25	; 0x17
    45d0:	8e 89       	ldd	r24, Y+22	; 0x16
    45d2:	9f 89       	ldd	r25, Y+23	; 0x17
    45d4:	8c 01       	movw	r16, r24
    45d6:	f8 01       	movw	r30, r16
    45d8:	31 97       	sbiw	r30, 0x01	; 1
    45da:	f1 f7       	brne	.-4      	; 0x45d8 <chb_reset+0x1b4>
    45dc:	8f 01       	movw	r16, r30
    45de:	0e 8b       	std	Y+22, r16	; 0x16
    45e0:	1f 8b       	std	Y+23, r17	; 0x17
    45e2:	10 c0       	rjmp	.+32     	; 0x4604 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    45e4:	6d 81       	ldd	r22, Y+5	; 0x05
    45e6:	7e 81       	ldd	r23, Y+6	; 0x06
    45e8:	8f 81       	ldd	r24, Y+7	; 0x07
    45ea:	98 85       	ldd	r25, Y+8	; 0x08
    45ec:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    45f0:	dc 01       	movw	r26, r24
    45f2:	cb 01       	movw	r24, r22
    45f4:	89 87       	std	Y+9, r24	; 0x09
    45f6:	89 85       	ldd	r24, Y+9	; 0x09
    45f8:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    45fa:	88 8d       	ldd	r24, Y+24	; 0x18
    45fc:	18 2f       	mov	r17, r24
    45fe:	1a 95       	dec	r17
    4600:	f1 f7       	brne	.-4      	; 0x45fe <chb_reset+0x1da>
    4602:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    4604:	84 e6       	ldi	r24, 0x64	; 100
    4606:	96 e0       	ldi	r25, 0x06	; 6
    4608:	24 e6       	ldi	r18, 0x64	; 100
    460a:	36 e0       	ldi	r19, 0x06	; 6
    460c:	f9 01       	movw	r30, r18
    460e:	20 81       	ld	r18, Z
    4610:	2e 7f       	andi	r18, 0xFE	; 254
    4612:	fc 01       	movw	r30, r24
    4614:	20 83       	st	Z, r18
    4616:	80 e0       	ldi	r24, 0x00	; 0
    4618:	90 e0       	ldi	r25, 0x00	; 0
    461a:	a0 e8       	ldi	r26, 0x80	; 128
    461c:	bf e3       	ldi	r27, 0x3F	; 63
    461e:	89 8f       	std	Y+25, r24	; 0x19
    4620:	9a 8f       	std	Y+26, r25	; 0x1a
    4622:	ab 8f       	std	Y+27, r26	; 0x1b
    4624:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4626:	69 8d       	ldd	r22, Y+25	; 0x19
    4628:	7a 8d       	ldd	r23, Y+26	; 0x1a
    462a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    462c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    462e:	2b ea       	ldi	r18, 0xAB	; 171
    4630:	3a ea       	ldi	r19, 0xAA	; 170
    4632:	4a ea       	ldi	r20, 0xAA	; 170
    4634:	5e e3       	ldi	r21, 0x3E	; 62
    4636:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    463a:	dc 01       	movw	r26, r24
    463c:	cb 01       	movw	r24, r22
    463e:	8d 8f       	std	Y+29, r24	; 0x1d
    4640:	9e 8f       	std	Y+30, r25	; 0x1e
    4642:	af 8f       	std	Y+31, r26	; 0x1f
    4644:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    4646:	11 e0       	ldi	r17, 0x01	; 1
    4648:	6d 8d       	ldd	r22, Y+29	; 0x1d
    464a:	7e 8d       	ldd	r23, Y+30	; 0x1e
    464c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    464e:	98 a1       	lds	r25, 0x48
    4650:	20 e0       	ldi	r18, 0x00	; 0
    4652:	30 e0       	ldi	r19, 0x00	; 0
    4654:	40 e8       	ldi	r20, 0x80	; 128
    4656:	5f e3       	ldi	r21, 0x3F	; 63
    4658:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    465c:	88 23       	and	r24, r24
    465e:	0c f0       	brlt	.+2      	; 0x4662 <chb_reset+0x23e>
    4660:	10 e0       	ldi	r17, 0x00	; 0
    4662:	11 23       	and	r17, r17
    4664:	19 f0       	breq	.+6      	; 0x466c <chb_reset+0x248>
		__ticks = 1;
    4666:	81 e0       	ldi	r24, 0x01	; 1
    4668:	89 a3       	lds	r24, 0x59
    466a:	a3 c0       	rjmp	.+326    	; 0x47b2 <chb_reset+0x38e>
	else if (__tmp > 255)
    466c:	11 e0       	ldi	r17, 0x01	; 1
    466e:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4670:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4672:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4674:	98 a1       	lds	r25, 0x48
    4676:	20 e0       	ldi	r18, 0x00	; 0
    4678:	30 e0       	ldi	r19, 0x00	; 0
    467a:	4f e7       	ldi	r20, 0x7F	; 127
    467c:	53 e4       	ldi	r21, 0x43	; 67
    467e:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    4682:	18 16       	cp	r1, r24
    4684:	0c f0       	brlt	.+2      	; 0x4688 <chb_reset+0x264>
    4686:	10 e0       	ldi	r17, 0x00	; 0
    4688:	11 23       	and	r17, r17
    468a:	09 f4       	brne	.+2      	; 0x468e <chb_reset+0x26a>
    468c:	89 c0       	rjmp	.+274    	; 0x47a0 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    468e:	69 8d       	ldd	r22, Y+25	; 0x19
    4690:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4692:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4694:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4696:	20 e0       	ldi	r18, 0x00	; 0
    4698:	30 e0       	ldi	r19, 0x00	; 0
    469a:	4a e7       	ldi	r20, 0x7A	; 122
    469c:	54 e4       	ldi	r21, 0x44	; 68
    469e:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    46a2:	dc 01       	movw	r26, r24
    46a4:	cb 01       	movw	r24, r22
    46a6:	8a a3       	lds	r24, 0x5a
    46a8:	9b a3       	lds	r25, 0x5b
    46aa:	ac a3       	lds	r26, 0x5c
    46ac:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    46ae:	6a a1       	lds	r22, 0x4a
    46b0:	7b a1       	lds	r23, 0x4b
    46b2:	8c a1       	lds	r24, 0x4c
    46b4:	9d a1       	lds	r25, 0x4d
    46b6:	20 e0       	ldi	r18, 0x00	; 0
    46b8:	30 e0       	ldi	r19, 0x00	; 0
    46ba:	4a e7       	ldi	r20, 0x7A	; 122
    46bc:	53 e4       	ldi	r21, 0x43	; 67
    46be:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    46c2:	dc 01       	movw	r26, r24
    46c4:	cb 01       	movw	r24, r22
    46c6:	8e a3       	lds	r24, 0x5e
    46c8:	9f a3       	lds	r25, 0x5f
    46ca:	a8 a7       	lds	r26, 0x78
    46cc:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    46ce:	11 e0       	ldi	r17, 0x01	; 1
    46d0:	6e a1       	lds	r22, 0x4e
    46d2:	7f a1       	lds	r23, 0x4f
    46d4:	88 a5       	lds	r24, 0x68
    46d6:	99 a5       	lds	r25, 0x69
    46d8:	20 e0       	ldi	r18, 0x00	; 0
    46da:	30 e0       	ldi	r19, 0x00	; 0
    46dc:	40 e8       	ldi	r20, 0x80	; 128
    46de:	5f e3       	ldi	r21, 0x3F	; 63
    46e0:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    46e4:	88 23       	and	r24, r24
    46e6:	0c f0       	brlt	.+2      	; 0x46ea <chb_reset+0x2c6>
    46e8:	10 e0       	ldi	r17, 0x00	; 0
    46ea:	11 23       	and	r17, r17
    46ec:	29 f0       	breq	.+10     	; 0x46f8 <chb_reset+0x2d4>
		__ticks = 1;
    46ee:	81 e0       	ldi	r24, 0x01	; 1
    46f0:	90 e0       	ldi	r25, 0x00	; 0
    46f2:	8a a7       	lds	r24, 0x7a
    46f4:	9b a7       	lds	r25, 0x7b
    46f6:	46 c0       	rjmp	.+140    	; 0x4784 <chb_reset+0x360>
	else if (__tmp > 65535)
    46f8:	11 e0       	ldi	r17, 0x01	; 1
    46fa:	6e a1       	lds	r22, 0x4e
    46fc:	7f a1       	lds	r23, 0x4f
    46fe:	88 a5       	lds	r24, 0x68
    4700:	99 a5       	lds	r25, 0x69
    4702:	20 e0       	ldi	r18, 0x00	; 0
    4704:	3f ef       	ldi	r19, 0xFF	; 255
    4706:	4f e7       	ldi	r20, 0x7F	; 127
    4708:	57 e4       	ldi	r21, 0x47	; 71
    470a:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    470e:	18 16       	cp	r1, r24
    4710:	0c f0       	brlt	.+2      	; 0x4714 <chb_reset+0x2f0>
    4712:	10 e0       	ldi	r17, 0x00	; 0
    4714:	11 23       	and	r17, r17
    4716:	61 f1       	breq	.+88     	; 0x4770 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4718:	6a a1       	lds	r22, 0x4a
    471a:	7b a1       	lds	r23, 0x4b
    471c:	8c a1       	lds	r24, 0x4c
    471e:	9d a1       	lds	r25, 0x4d
    4720:	20 e0       	ldi	r18, 0x00	; 0
    4722:	30 e0       	ldi	r19, 0x00	; 0
    4724:	40 e2       	ldi	r20, 0x20	; 32
    4726:	51 e4       	ldi	r21, 0x41	; 65
    4728:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    472c:	dc 01       	movw	r26, r24
    472e:	cb 01       	movw	r24, r22
    4730:	bc 01       	movw	r22, r24
    4732:	cd 01       	movw	r24, r26
    4734:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    4738:	dc 01       	movw	r26, r24
    473a:	cb 01       	movw	r24, r22
    473c:	8a a7       	lds	r24, 0x7a
    473e:	9b a7       	lds	r25, 0x7b
    4740:	12 c0       	rjmp	.+36     	; 0x4766 <chb_reset+0x342>
    4742:	89 e1       	ldi	r24, 0x19	; 25
    4744:	90 e0       	ldi	r25, 0x00	; 0
    4746:	8c a7       	lds	r24, 0x7c
    4748:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    474a:	8c a5       	lds	r24, 0x6c
    474c:	9d a5       	lds	r25, 0x6d
    474e:	8c 01       	movw	r16, r24
    4750:	c8 01       	movw	r24, r16
    4752:	01 97       	sbiw	r24, 0x01	; 1
    4754:	f1 f7       	brne	.-4      	; 0x4752 <chb_reset+0x32e>
    4756:	8c 01       	movw	r16, r24
    4758:	0c a7       	lds	r16, 0x7c
    475a:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    475c:	8a a5       	lds	r24, 0x6a
    475e:	9b a5       	lds	r25, 0x6b
    4760:	01 97       	sbiw	r24, 0x01	; 1
    4762:	8a a7       	lds	r24, 0x7a
    4764:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4766:	8a a5       	lds	r24, 0x6a
    4768:	9b a5       	lds	r25, 0x6b
    476a:	00 97       	sbiw	r24, 0x00	; 0
    476c:	51 f7       	brne	.-44     	; 0x4742 <chb_reset+0x31e>
    476e:	28 c0       	rjmp	.+80     	; 0x47c0 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4770:	6e a1       	lds	r22, 0x4e
    4772:	7f a1       	lds	r23, 0x4f
    4774:	88 a5       	lds	r24, 0x68
    4776:	99 a5       	lds	r25, 0x69
    4778:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    477c:	dc 01       	movw	r26, r24
    477e:	cb 01       	movw	r24, r22
    4780:	8a a7       	lds	r24, 0x7a
    4782:	9b a7       	lds	r25, 0x7b
    4784:	8a a5       	lds	r24, 0x6a
    4786:	9b a5       	lds	r25, 0x6b
    4788:	8e a7       	lds	r24, 0x7e
    478a:	9f a7       	lds	r25, 0x7f
    478c:	8e a5       	lds	r24, 0x6e
    478e:	9f a5       	lds	r25, 0x6f
    4790:	8c 01       	movw	r16, r24
    4792:	f8 01       	movw	r30, r16
    4794:	31 97       	sbiw	r30, 0x01	; 1
    4796:	f1 f7       	brne	.-4      	; 0x4794 <chb_reset+0x370>
    4798:	8f 01       	movw	r16, r30
    479a:	0e a7       	lds	r16, 0x7e
    479c:	1f a7       	lds	r17, 0x7f
    479e:	10 c0       	rjmp	.+32     	; 0x47c0 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    47a0:	6d 8d       	ldd	r22, Y+29	; 0x1d
    47a2:	7e 8d       	ldd	r23, Y+30	; 0x1e
    47a4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    47a6:	98 a1       	lds	r25, 0x48
    47a8:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    47ac:	dc 01       	movw	r26, r24
    47ae:	cb 01       	movw	r24, r22
    47b0:	89 a3       	lds	r24, 0x59
    47b2:	89 a1       	lds	r24, 0x49
    47b4:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    47b6:	88 a9       	sts	0x48, r24
    47b8:	18 2f       	mov	r17, r24
    47ba:	1a 95       	dec	r17
    47bc:	f1 f7       	brne	.-4      	; 0x47ba <chb_reset+0x396>
    47be:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    47c0:	84 e6       	ldi	r24, 0x64	; 100
    47c2:	96 e0       	ldi	r25, 0x06	; 6
    47c4:	24 e6       	ldi	r18, 0x64	; 100
    47c6:	36 e0       	ldi	r19, 0x06	; 6
    47c8:	f9 01       	movw	r30, r18
    47ca:	20 81       	ld	r18, Z
    47cc:	21 60       	ori	r18, 0x01	; 1
    47ce:	fc 01       	movw	r30, r24
    47d0:	20 83       	st	Z, r18
    47d2:	01 c0       	rjmp	.+2      	; 0x47d6 <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    47d4:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    47d6:	8d e1       	ldi	r24, 0x1D	; 29
    47d8:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    47dc:	81 30       	cpi	r24, 0x01	; 1
    47de:	d1 f7       	brne	.-12     	; 0x47d4 <chb_reset+0x3b0>
    47e0:	8c e1       	ldi	r24, 0x1C	; 28
    47e2:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    47e6:	87 30       	cpi	r24, 0x07	; 7
    47e8:	a9 f7       	brne	.-22     	; 0x47d4 <chb_reset+0x3b0>
        {
            break;
    47ea:	00 00       	nop
        }
    }
	

}
    47ec:	e0 96       	adiw	r28, 0x30	; 48
    47ee:	cd bf       	out	0x3d, r28	; 61
    47f0:	de bf       	out	0x3e, r29	; 62
    47f2:	df 91       	pop	r29
    47f4:	cf 91       	pop	r28
    47f6:	1f 91       	pop	r17
    47f8:	0f 91       	pop	r16
    47fa:	08 95       	ret

000047fc <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    47fc:	cf 93       	push	r28
    47fe:	df 93       	push	r29
    4800:	0f 92       	push	r0
    4802:	0f 92       	push	r0
    4804:	cd b7       	in	r28, 0x3d	; 61
    4806:	de b7       	in	r29, 0x3e	; 62
    4808:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    480a:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    480c:	8a 81       	ldd	r24, Y+2	; 0x02
    480e:	80 68       	ori	r24, 0x80	; 128
    4810:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4812:	8f e3       	ldi	r24, 0x3F	; 63
    4814:	90 e0       	ldi	r25, 0x00	; 0
    4816:	fc 01       	movw	r30, r24
    4818:	80 81       	ld	r24, Z
    481a:	80 93 37 40 	sts	0x4037, r24
    481e:	f8 94       	cli
    RadioCS(TRUE);
    4820:	81 e0       	ldi	r24, 0x01	; 1
    4822:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4826:	8a 81       	ldd	r24, Y+2	; 0x02
    4828:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    482c:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    482e:	89 81       	ldd	r24, Y+1	; 0x01
    4830:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    4834:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4836:	80 e0       	ldi	r24, 0x00	; 0
    4838:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>
    CHB_LEAVE_CRIT();
    483c:	8f e3       	ldi	r24, 0x3F	; 63
    483e:	90 e0       	ldi	r25, 0x00	; 0
    4840:	20 91 37 40 	lds	r18, 0x4037
    4844:	fc 01       	movw	r30, r24
    4846:	20 83       	st	Z, r18
    4848:	78 94       	sei

    return val;
    484a:	89 81       	ldd	r24, Y+1	; 0x01
}
    484c:	0f 90       	pop	r0
    484e:	0f 90       	pop	r0
    4850:	df 91       	pop	r29
    4852:	cf 91       	pop	r28
    4854:	08 95       	ret

00004856 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4856:	cf 93       	push	r28
    4858:	df 93       	push	r29
    485a:	00 d0       	rcall	.+0      	; 0x485c <chb_reg_read16+0x6>
    485c:	0f 92       	push	r0
    485e:	cd b7       	in	r28, 0x3d	; 61
    4860:	de b7       	in	r29, 0x3e	; 62
    4862:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4864:	1a 82       	std	Y+2, r1	; 0x02
    4866:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    4868:	19 82       	std	Y+1, r1	; 0x01
    486a:	1d c0       	rjmp	.+58     	; 0x48a6 <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    486c:	9c 81       	ldd	r25, Y+4	; 0x04
    486e:	89 81       	ldd	r24, Y+1	; 0x01
    4870:	89 0f       	add	r24, r25
    4872:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    4876:	88 2f       	mov	r24, r24
    4878:	90 e0       	ldi	r25, 0x00	; 0
    487a:	29 81       	ldd	r18, Y+1	; 0x01
    487c:	22 2f       	mov	r18, r18
    487e:	30 e0       	ldi	r19, 0x00	; 0
    4880:	22 0f       	add	r18, r18
    4882:	33 1f       	adc	r19, r19
    4884:	22 0f       	add	r18, r18
    4886:	33 1f       	adc	r19, r19
    4888:	22 0f       	add	r18, r18
    488a:	33 1f       	adc	r19, r19
    488c:	02 2e       	mov	r0, r18
    488e:	02 c0       	rjmp	.+4      	; 0x4894 <chb_reg_read16+0x3e>
    4890:	88 0f       	add	r24, r24
    4892:	99 1f       	adc	r25, r25
    4894:	0a 94       	dec	r0
    4896:	e2 f7       	brpl	.-8      	; 0x4890 <chb_reg_read16+0x3a>
    4898:	98 2f       	mov	r25, r24
    489a:	8c 81       	ldd	r24, Y+4	; 0x04
    489c:	89 2b       	or	r24, r25
    489e:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    48a0:	89 81       	ldd	r24, Y+1	; 0x01
    48a2:	8f 5f       	subi	r24, 0xFF	; 255
    48a4:	89 83       	std	Y+1, r24	; 0x01
    48a6:	89 81       	ldd	r24, Y+1	; 0x01
    48a8:	82 30       	cpi	r24, 0x02	; 2
    48aa:	00 f3       	brcs	.-64     	; 0x486c <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    48ac:	8a 81       	ldd	r24, Y+2	; 0x02
    48ae:	9b 81       	ldd	r25, Y+3	; 0x03
}
    48b0:	24 96       	adiw	r28, 0x04	; 4
    48b2:	cd bf       	out	0x3d, r28	; 61
    48b4:	de bf       	out	0x3e, r29	; 62
    48b6:	df 91       	pop	r29
    48b8:	cf 91       	pop	r28
    48ba:	08 95       	ret

000048bc <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    48bc:	cf 93       	push	r28
    48be:	df 93       	push	r29
    48c0:	00 d0       	rcall	.+0      	; 0x48c2 <chb_reg_write+0x6>
    48c2:	cd b7       	in	r28, 0x3d	; 61
    48c4:	de b7       	in	r29, 0x3e	; 62
    48c6:	8a 83       	std	Y+2, r24	; 0x02
    48c8:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    48ca:	8a 81       	ldd	r24, Y+2	; 0x02
    48cc:	80 6c       	ori	r24, 0xC0	; 192
    48ce:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    48d0:	8f e3       	ldi	r24, 0x3F	; 63
    48d2:	90 e0       	ldi	r25, 0x00	; 0
    48d4:	fc 01       	movw	r30, r24
    48d6:	80 81       	ld	r24, Z
    48d8:	80 93 37 40 	sts	0x4037, r24
    48dc:	f8 94       	cli
    RadioCS(TRUE);
    48de:	81 e0       	ldi	r24, 0x01	; 1
    48e0:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    48e4:	8a 81       	ldd	r24, Y+2	; 0x02
    48e6:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    48ea:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    48ec:	8b 81       	ldd	r24, Y+3	; 0x03
    48ee:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    48f2:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    48f4:	80 e0       	ldi	r24, 0x00	; 0
    48f6:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>
    CHB_LEAVE_CRIT();
    48fa:	8f e3       	ldi	r24, 0x3F	; 63
    48fc:	90 e0       	ldi	r25, 0x00	; 0
    48fe:	20 91 37 40 	lds	r18, 0x4037
    4902:	fc 01       	movw	r30, r24
    4904:	20 83       	st	Z, r18
    4906:	78 94       	sei
}
    4908:	23 96       	adiw	r28, 0x03	; 3
    490a:	cd bf       	out	0x3d, r28	; 61
    490c:	de bf       	out	0x3e, r29	; 62
    490e:	df 91       	pop	r29
    4910:	cf 91       	pop	r28
    4912:	08 95       	ret

00004914 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4914:	cf 93       	push	r28
    4916:	df 93       	push	r29
    4918:	00 d0       	rcall	.+0      	; 0x491a <chb_reg_write16+0x6>
    491a:	0f 92       	push	r0
    491c:	cd b7       	in	r28, 0x3d	; 61
    491e:	de b7       	in	r29, 0x3e	; 62
    4920:	8a 83       	std	Y+2, r24	; 0x02
    4922:	6b 83       	std	Y+3, r22	; 0x03
    4924:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4926:	19 82       	std	Y+1, r1	; 0x01
    4928:	1d c0       	rjmp	.+58     	; 0x4964 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    492a:	9a 81       	ldd	r25, Y+2	; 0x02
    492c:	89 81       	ldd	r24, Y+1	; 0x01
    492e:	49 2f       	mov	r20, r25
    4930:	48 0f       	add	r20, r24
    4932:	89 81       	ldd	r24, Y+1	; 0x01
    4934:	88 2f       	mov	r24, r24
    4936:	90 e0       	ldi	r25, 0x00	; 0
    4938:	9c 01       	movw	r18, r24
    493a:	22 0f       	add	r18, r18
    493c:	33 1f       	adc	r19, r19
    493e:	22 0f       	add	r18, r18
    4940:	33 1f       	adc	r19, r19
    4942:	22 0f       	add	r18, r18
    4944:	33 1f       	adc	r19, r19
    4946:	8b 81       	ldd	r24, Y+3	; 0x03
    4948:	9c 81       	ldd	r25, Y+4	; 0x04
    494a:	02 c0       	rjmp	.+4      	; 0x4950 <chb_reg_write16+0x3c>
    494c:	96 95       	lsr	r25
    494e:	87 95       	ror	r24
    4950:	2a 95       	dec	r18
    4952:	e2 f7       	brpl	.-8      	; 0x494c <chb_reg_write16+0x38>
    4954:	98 2f       	mov	r25, r24
    4956:	84 2f       	mov	r24, r20
    4958:	69 2f       	mov	r22, r25
    495a:	0e 94 5e 24 	call	0x48bc	; 0x48bc <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    495e:	89 81       	ldd	r24, Y+1	; 0x01
    4960:	8f 5f       	subi	r24, 0xFF	; 255
    4962:	89 83       	std	Y+1, r24	; 0x01
    4964:	89 81       	ldd	r24, Y+1	; 0x01
    4966:	82 30       	cpi	r24, 0x02	; 2
    4968:	00 f3       	brcs	.-64     	; 0x492a <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    496a:	24 96       	adiw	r28, 0x04	; 4
    496c:	cd bf       	out	0x3d, r28	; 61
    496e:	de bf       	out	0x3e, r29	; 62
    4970:	df 91       	pop	r29
    4972:	cf 91       	pop	r28
    4974:	08 95       	ret

00004976 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4976:	cf 93       	push	r28
    4978:	df 93       	push	r29
    497a:	00 d0       	rcall	.+0      	; 0x497c <chb_reg_write64+0x6>
    497c:	0f 92       	push	r0
    497e:	cd b7       	in	r28, 0x3d	; 61
    4980:	de b7       	in	r29, 0x3e	; 62
    4982:	8a 83       	std	Y+2, r24	; 0x02
    4984:	6b 83       	std	Y+3, r22	; 0x03
    4986:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4988:	19 82       	std	Y+1, r1	; 0x01
    498a:	14 c0       	rjmp	.+40     	; 0x49b4 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    498c:	9a 81       	ldd	r25, Y+2	; 0x02
    498e:	89 81       	ldd	r24, Y+1	; 0x01
    4990:	49 2f       	mov	r20, r25
    4992:	48 0f       	add	r20, r24
    4994:	89 81       	ldd	r24, Y+1	; 0x01
    4996:	88 2f       	mov	r24, r24
    4998:	90 e0       	ldi	r25, 0x00	; 0
    499a:	2b 81       	ldd	r18, Y+3	; 0x03
    499c:	3c 81       	ldd	r19, Y+4	; 0x04
    499e:	82 0f       	add	r24, r18
    49a0:	93 1f       	adc	r25, r19
    49a2:	fc 01       	movw	r30, r24
    49a4:	90 81       	ld	r25, Z
    49a6:	84 2f       	mov	r24, r20
    49a8:	69 2f       	mov	r22, r25
    49aa:	0e 94 5e 24 	call	0x48bc	; 0x48bc <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    49ae:	89 81       	ldd	r24, Y+1	; 0x01
    49b0:	8f 5f       	subi	r24, 0xFF	; 255
    49b2:	89 83       	std	Y+1, r24	; 0x01
    49b4:	89 81       	ldd	r24, Y+1	; 0x01
    49b6:	88 30       	cpi	r24, 0x08	; 8
    49b8:	48 f3       	brcs	.-46     	; 0x498c <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    49ba:	24 96       	adiw	r28, 0x04	; 4
    49bc:	cd bf       	out	0x3d, r28	; 61
    49be:	de bf       	out	0x3e, r29	; 62
    49c0:	df 91       	pop	r29
    49c2:	cf 91       	pop	r28
    49c4:	08 95       	ret

000049c6 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    49c6:	cf 93       	push	r28
    49c8:	df 93       	push	r29
    49ca:	00 d0       	rcall	.+0      	; 0x49cc <chb_reg_read_mod_write+0x6>
    49cc:	0f 92       	push	r0
    49ce:	cd b7       	in	r28, 0x3d	; 61
    49d0:	de b7       	in	r29, 0x3e	; 62
    49d2:	8a 83       	std	Y+2, r24	; 0x02
    49d4:	6b 83       	std	Y+3, r22	; 0x03
    49d6:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    49d8:	8a 81       	ldd	r24, Y+2	; 0x02
    49da:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    49de:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    49e0:	9b 81       	ldd	r25, Y+3	; 0x03
    49e2:	8c 81       	ldd	r24, Y+4	; 0x04
    49e4:	89 23       	and	r24, r25
    49e6:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    49e8:	8c 81       	ldd	r24, Y+4	; 0x04
    49ea:	98 2f       	mov	r25, r24
    49ec:	90 95       	com	r25
    49ee:	89 81       	ldd	r24, Y+1	; 0x01
    49f0:	89 23       	and	r24, r25
    49f2:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    49f4:	99 81       	ldd	r25, Y+1	; 0x01
    49f6:	8b 81       	ldd	r24, Y+3	; 0x03
    49f8:	89 2b       	or	r24, r25
    49fa:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    49fc:	8a 81       	ldd	r24, Y+2	; 0x02
    49fe:	69 81       	ldd	r22, Y+1	; 0x01
    4a00:	0e 94 5e 24 	call	0x48bc	; 0x48bc <chb_reg_write>
}
    4a04:	24 96       	adiw	r28, 0x04	; 4
    4a06:	cd bf       	out	0x3d, r28	; 61
    4a08:	de bf       	out	0x3e, r29	; 62
    4a0a:	df 91       	pop	r29
    4a0c:	cf 91       	pop	r28
    4a0e:	08 95       	ret

00004a10 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4a10:	cf 93       	push	r28
    4a12:	df 93       	push	r29
    4a14:	cd b7       	in	r28, 0x3d	; 61
    4a16:	de b7       	in	r29, 0x3e	; 62
    4a18:	28 97       	sbiw	r28, 0x08	; 8
    4a1a:	cd bf       	out	0x3d, r28	; 61
    4a1c:	de bf       	out	0x3e, r29	; 62
    4a1e:	8b 83       	std	Y+3, r24	; 0x03
    4a20:	9c 83       	std	Y+4, r25	; 0x04
    4a22:	6d 83       	std	Y+5, r22	; 0x05
    4a24:	4e 83       	std	Y+6, r20	; 0x06
    4a26:	5f 83       	std	Y+7, r21	; 0x07
    4a28:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4a2a:	8d 81       	ldd	r24, Y+5	; 0x05
    4a2c:	28 2f       	mov	r18, r24
    4a2e:	30 e0       	ldi	r19, 0x00	; 0
    4a30:	88 85       	ldd	r24, Y+8	; 0x08
    4a32:	88 2f       	mov	r24, r24
    4a34:	90 e0       	ldi	r25, 0x00	; 0
    4a36:	82 0f       	add	r24, r18
    4a38:	93 1f       	adc	r25, r19
    4a3a:	80 38       	cpi	r24, 0x80	; 128
    4a3c:	91 05       	cpc	r25, r1
    4a3e:	0c f0       	brlt	.+2      	; 0x4a42 <chb_frame_write+0x32>
    4a40:	45 c0       	rjmp	.+138    	; 0x4acc <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4a42:	8f e3       	ldi	r24, 0x3F	; 63
    4a44:	90 e0       	ldi	r25, 0x00	; 0
    4a46:	fc 01       	movw	r30, r24
    4a48:	80 81       	ld	r24, Z
    4a4a:	80 93 37 40 	sts	0x4037, r24
    4a4e:	f8 94       	cli
    RadioCS(TRUE); 
    4a50:	81 e0       	ldi	r24, 0x01	; 1
    4a52:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    4a56:	80 e6       	ldi	r24, 0x60	; 96
    4a58:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    4a5c:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4a5e:	19 82       	std	Y+1, r1	; 0x01
    4a60:	10 c0       	rjmp	.+32     	; 0x4a82 <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4a62:	8b 81       	ldd	r24, Y+3	; 0x03
    4a64:	9c 81       	ldd	r25, Y+4	; 0x04
    4a66:	fc 01       	movw	r30, r24
    4a68:	20 81       	ld	r18, Z
    4a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6e:	01 96       	adiw	r24, 0x01	; 1
    4a70:	8b 83       	std	Y+3, r24	; 0x03
    4a72:	9c 83       	std	Y+4, r25	; 0x04
    4a74:	82 2f       	mov	r24, r18
    4a76:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    4a7a:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4a7c:	89 81       	ldd	r24, Y+1	; 0x01
    4a7e:	8f 5f       	subi	r24, 0xFF	; 255
    4a80:	89 83       	std	Y+1, r24	; 0x01
    4a82:	99 81       	ldd	r25, Y+1	; 0x01
    4a84:	8d 81       	ldd	r24, Y+5	; 0x05
    4a86:	98 17       	cp	r25, r24
    4a88:	60 f3       	brcs	.-40     	; 0x4a62 <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4a8a:	19 82       	std	Y+1, r1	; 0x01
    4a8c:	10 c0       	rjmp	.+32     	; 0x4aae <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4a8e:	8e 81       	ldd	r24, Y+6	; 0x06
    4a90:	9f 81       	ldd	r25, Y+7	; 0x07
    4a92:	fc 01       	movw	r30, r24
    4a94:	20 81       	ld	r18, Z
    4a96:	8e 81       	ldd	r24, Y+6	; 0x06
    4a98:	9f 81       	ldd	r25, Y+7	; 0x07
    4a9a:	01 96       	adiw	r24, 0x01	; 1
    4a9c:	8e 83       	std	Y+6, r24	; 0x06
    4a9e:	9f 83       	std	Y+7, r25	; 0x07
    4aa0:	82 2f       	mov	r24, r18
    4aa2:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    4aa6:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4aa8:	89 81       	ldd	r24, Y+1	; 0x01
    4aaa:	8f 5f       	subi	r24, 0xFF	; 255
    4aac:	89 83       	std	Y+1, r24	; 0x01
    4aae:	99 81       	ldd	r25, Y+1	; 0x01
    4ab0:	88 85       	ldd	r24, Y+8	; 0x08
    4ab2:	98 17       	cp	r25, r24
    4ab4:	60 f3       	brcs	.-40     	; 0x4a8e <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    4ab6:	80 e0       	ldi	r24, 0x00	; 0
    4ab8:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>
    CHB_LEAVE_CRIT();
    4abc:	8f e3       	ldi	r24, 0x3F	; 63
    4abe:	90 e0       	ldi	r25, 0x00	; 0
    4ac0:	20 91 37 40 	lds	r18, 0x4037
    4ac4:	fc 01       	movw	r30, r24
    4ac6:	20 83       	st	Z, r18
    4ac8:	78 94       	sei
    4aca:	01 c0       	rjmp	.+2      	; 0x4ace <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4acc:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4ace:	28 96       	adiw	r28, 0x08	; 8
    4ad0:	cd bf       	out	0x3d, r28	; 61
    4ad2:	de bf       	out	0x3e, r29	; 62
    4ad4:	df 91       	pop	r29
    4ad6:	cf 91       	pop	r28
    4ad8:	08 95       	ret

00004ada <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    4ada:	0f 93       	push	r16
    4adc:	1f 93       	push	r17
    4ade:	cf 93       	push	r28
    4ae0:	df 93       	push	r29
    4ae2:	cd b7       	in	r28, 0x3d	; 61
    4ae4:	de b7       	in	r29, 0x3e	; 62
    4ae6:	e7 97       	sbiw	r28, 0x37	; 55
    4ae8:	cd bf       	out	0x3d, r28	; 61
    4aea:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4aec:	8f e3       	ldi	r24, 0x3F	; 63
    4aee:	90 e0       	ldi	r25, 0x00	; 0
    4af0:	fc 01       	movw	r30, r24
    4af2:	80 81       	ld	r24, Z
    4af4:	80 93 37 40 	sts	0x4037, r24
    4af8:	f8 94       	cli
    RadioCS(TRUE);
    4afa:	81 e0       	ldi	r24, 0x01	; 1
    4afc:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4b00:	80 e2       	ldi	r24, 0x20	; 32
    4b02:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    len = SPID_write(0);
    4b06:	80 e0       	ldi	r24, 0x00	; 0
    4b08:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    4b0c:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4b0e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b10:	83 30       	cpi	r24, 0x03	; 3
    4b12:	08 f4       	brcc	.+2      	; 0x4b16 <chb_frame_read+0x3c>
    4b14:	5c c0       	rjmp	.+184    	; 0x4bce <chb_frame_read+0xf4>
    4b16:	8a 81       	ldd	r24, Y+2	; 0x02
    4b18:	88 23       	and	r24, r24
    4b1a:	0c f4       	brge	.+2      	; 0x4b1e <chb_frame_read+0x44>
    4b1c:	58 c0       	rjmp	.+176    	; 0x4bce <chb_frame_read+0xf4>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b20:	08 2f       	mov	r16, r24
    4b22:	10 e0       	ldi	r17, 0x00	; 0
    4b24:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <chb_buf_get_len>
    4b28:	88 2f       	mov	r24, r24
    4b2a:	90 e0       	ldi	r25, 0x00	; 0
    4b2c:	20 e8       	ldi	r18, 0x80	; 128
    4b2e:	30 e0       	ldi	r19, 0x00	; 0
    4b30:	a9 01       	movw	r20, r18
    4b32:	48 1b       	sub	r20, r24
    4b34:	59 0b       	sbc	r21, r25
    4b36:	ca 01       	movw	r24, r20
    4b38:	08 17       	cp	r16, r24
    4b3a:	19 07       	cpc	r17, r25
    4b3c:	a4 f4       	brge	.+40     	; 0x4b66 <chb_frame_read+0x8c>
        {
            chb_buf_write(len);
    4b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b40:	0e 94 a9 21 	call	0x4352	; 0x4352 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4b44:	19 82       	std	Y+1, r1	; 0x01
    4b46:	0a c0       	rjmp	.+20     	; 0x4b5c <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4b48:	80 e0       	ldi	r24, 0x00	; 0
    4b4a:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    4b4e:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4b50:	8b 81       	ldd	r24, Y+3	; 0x03
    4b52:	0e 94 a9 21 	call	0x4352	; 0x4352 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4b56:	89 81       	ldd	r24, Y+1	; 0x01
    4b58:	8f 5f       	subi	r24, 0xFF	; 255
    4b5a:	89 83       	std	Y+1, r24	; 0x01
    4b5c:	99 81       	ldd	r25, Y+1	; 0x01
    4b5e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b60:	98 17       	cp	r25, r24
    4b62:	90 f3       	brcs	.-28     	; 0x4b48 <chb_frame_read+0x6e>
    4b64:	34 c0       	rjmp	.+104    	; 0x4bce <chb_frame_read+0xf4>
            }
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4b66:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <chb_get_pcb>
    4b6a:	8c 83       	std	Y+4, r24	; 0x04
    4b6c:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4b6e:	19 82       	std	Y+1, r1	; 0x01
    4b70:	07 c0       	rjmp	.+14     	; 0x4b80 <chb_frame_read+0xa6>
            {
                data = SPID_write(0);
    4b72:	80 e0       	ldi	r24, 0x00	; 0
    4b74:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    4b78:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4b7a:	89 81       	ldd	r24, Y+1	; 0x01
    4b7c:	8f 5f       	subi	r24, 0xFF	; 255
    4b7e:	89 83       	std	Y+1, r24	; 0x01
    4b80:	99 81       	ldd	r25, Y+1	; 0x01
    4b82:	8a 81       	ldd	r24, Y+2	; 0x02
    4b84:	98 17       	cp	r25, r24
    4b86:	a8 f3       	brcs	.-22     	; 0x4b72 <chb_frame_read+0x98>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4b88:	8c 81       	ldd	r24, Y+4	; 0x04
    4b8a:	9d 81       	ldd	r25, Y+5	; 0x05
    4b8c:	fc 01       	movw	r30, r24
    4b8e:	85 85       	ldd	r24, Z+13	; 0x0d
    4b90:	96 85       	ldd	r25, Z+14	; 0x0e
    4b92:	9c 01       	movw	r18, r24
    4b94:	2f 5f       	subi	r18, 0xFF	; 255
    4b96:	3f 4f       	sbci	r19, 0xFF	; 255
    4b98:	8c 81       	ldd	r24, Y+4	; 0x04
    4b9a:	9d 81       	ldd	r25, Y+5	; 0x05
    4b9c:	fc 01       	movw	r30, r24
    4b9e:	25 87       	std	Z+13, r18	; 0x0d
    4ba0:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4ba2:	ce 01       	movw	r24, r28
    4ba4:	06 96       	adiw	r24, 0x06	; 6
    4ba6:	28 ee       	ldi	r18, 0xE8	; 232
    4ba8:	31 e0       	ldi	r19, 0x01	; 1
    4baa:	b9 01       	movw	r22, r18
    4bac:	0e 94 03 5d 	call	0xba06	; 0xba06 <strcpy_P>
            printf(buf);
    4bb0:	0f 92       	push	r0
    4bb2:	0f 92       	push	r0
    4bb4:	8d b7       	in	r24, 0x3d	; 61
    4bb6:	9e b7       	in	r25, 0x3e	; 62
    4bb8:	01 96       	adiw	r24, 0x01	; 1
    4bba:	9e 01       	movw	r18, r28
    4bbc:	2a 5f       	subi	r18, 0xFA	; 250
    4bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    4bc0:	fc 01       	movw	r30, r24
    4bc2:	20 83       	st	Z, r18
    4bc4:	31 83       	std	Z+1, r19	; 0x01
    4bc6:	0e 94 1c 5d 	call	0xba38	; 0xba38 <printf>
    4bca:	0f 90       	pop	r0
    4bcc:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4bce:	80 e0       	ldi	r24, 0x00	; 0
    4bd0:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>
    CHB_LEAVE_CRIT();
    4bd4:	8f e3       	ldi	r24, 0x3F	; 63
    4bd6:	90 e0       	ldi	r25, 0x00	; 0
    4bd8:	20 91 37 40 	lds	r18, 0x4037
    4bdc:	fc 01       	movw	r30, r24
    4bde:	20 83       	st	Z, r18
    4be0:	78 94       	sei
}
    4be2:	e7 96       	adiw	r28, 0x37	; 55
    4be4:	cd bf       	out	0x3d, r28	; 61
    4be6:	de bf       	out	0x3e, r29	; 62
    4be8:	df 91       	pop	r29
    4bea:	cf 91       	pop	r28
    4bec:	1f 91       	pop	r17
    4bee:	0f 91       	pop	r16
    4bf0:	08 95       	ret

00004bf2 <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4bf2:	cf 93       	push	r28
    4bf4:	df 93       	push	r29
    4bf6:	0f 92       	push	r0
    4bf8:	cd b7       	in	r28, 0x3d	; 61
    4bfa:	de b7       	in	r29, 0x3e	; 62
    4bfc:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4bfe:	89 81       	ldd	r24, Y+1	; 0x01
    4c00:	88 2f       	mov	r24, r24
    4c02:	90 e0       	ldi	r25, 0x00	; 0
    4c04:	81 30       	cpi	r24, 0x01	; 1
    4c06:	91 05       	cpc	r25, r1
    4c08:	c1 f0       	breq	.+48     	; 0x4c3a <chb_set_mode+0x48>
    4c0a:	82 30       	cpi	r24, 0x02	; 2
    4c0c:	91 05       	cpc	r25, r1
    4c0e:	1c f4       	brge	.+6      	; 0x4c16 <chb_set_mode+0x24>
    4c10:	00 97       	sbiw	r24, 0x00	; 0
    4c12:	41 f0       	breq	.+16     	; 0x4c24 <chb_set_mode+0x32>
    4c14:	33 c0       	rjmp	.+102    	; 0x4c7c <chb_set_mode+0x8a>
    4c16:	82 30       	cpi	r24, 0x02	; 2
    4c18:	91 05       	cpc	r25, r1
    4c1a:	d1 f0       	breq	.+52     	; 0x4c50 <chb_set_mode+0x5e>
    4c1c:	83 30       	cpi	r24, 0x03	; 3
    4c1e:	91 05       	cpc	r25, r1
    4c20:	11 f1       	breq	.+68     	; 0x4c66 <chb_set_mode+0x74>
    4c22:	2c c0       	rjmp	.+88     	; 0x4c7c <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4c24:	8c e0       	ldi	r24, 0x0C	; 12
    4c26:	68 e0       	ldi	r22, 0x08	; 8
    4c28:	4f e3       	ldi	r20, 0x3F	; 63
    4c2a:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4c2e:	86 e1       	ldi	r24, 0x16	; 22
    4c30:	62 e0       	ldi	r22, 0x02	; 2
    4c32:	43 e0       	ldi	r20, 0x03	; 3
    4c34:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        break;
    4c38:	21 c0       	rjmp	.+66     	; 0x4c7c <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4c3a:	8c e0       	ldi	r24, 0x0C	; 12
    4c3c:	6c e0       	ldi	r22, 0x0C	; 12
    4c3e:	4f e3       	ldi	r20, 0x3F	; 63
    4c40:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4c44:	86 e1       	ldi	r24, 0x16	; 22
    4c46:	62 e0       	ldi	r22, 0x02	; 2
    4c48:	43 e0       	ldi	r20, 0x03	; 3
    4c4a:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        break;
    4c4e:	16 c0       	rjmp	.+44     	; 0x4c7c <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4c50:	8c e0       	ldi	r24, 0x0C	; 12
    4c52:	6c e1       	ldi	r22, 0x1C	; 28
    4c54:	4f e3       	ldi	r20, 0x3F	; 63
    4c56:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4c5a:	86 e1       	ldi	r24, 0x16	; 22
    4c5c:	62 e0       	ldi	r22, 0x02	; 2
    4c5e:	43 e0       	ldi	r20, 0x03	; 3
    4c60:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        break;
    4c64:	0b c0       	rjmp	.+22     	; 0x4c7c <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4c66:	8c e0       	ldi	r24, 0x0C	; 12
    4c68:	60 e0       	ldi	r22, 0x00	; 0
    4c6a:	4f e3       	ldi	r20, 0x3F	; 63
    4c6c:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4c70:	86 e1       	ldi	r24, 0x16	; 22
    4c72:	63 e0       	ldi	r22, 0x03	; 3
    4c74:	43 e0       	ldi	r20, 0x03	; 3
    4c76:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
        break;
    4c7a:	00 00       	nop
    }
}
    4c7c:	0f 90       	pop	r0
    4c7e:	df 91       	pop	r29
    4c80:	cf 91       	pop	r28
    4c82:	08 95       	ret

00004c84 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4c84:	0f 93       	push	r16
    4c86:	1f 93       	push	r17
    4c88:	cf 93       	push	r28
    4c8a:	df 93       	push	r29
    4c8c:	cd b7       	in	r28, 0x3d	; 61
    4c8e:	de b7       	in	r29, 0x3e	; 62
    4c90:	6a 97       	sbiw	r28, 0x1a	; 26
    4c92:	cd bf       	out	0x3d, r28	; 61
    4c94:	de bf       	out	0x3e, r29	; 62
    4c96:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4c98:	88 e0       	ldi	r24, 0x08	; 8
    4c9a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4c9c:	4f e1       	ldi	r20, 0x1F	; 31
    4c9e:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4ca2:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_get_state>
    4ca6:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4ca8:	89 81       	ldd	r24, Y+1	; 0x01
    4caa:	86 30       	cpi	r24, 0x06	; 6
    4cac:	21 f0       	breq	.+8      	; 0x4cb6 <chb_set_channel+0x32>
    4cae:	89 81       	ldd	r24, Y+1	; 0x01
    4cb0:	89 30       	cpi	r24, 0x09	; 9
    4cb2:	09 f0       	breq	.+2      	; 0x4cb6 <chb_set_channel+0x32>
    4cb4:	d5 c0       	rjmp	.+426    	; 0x4e60 <chb_set_channel+0x1dc>
    4cb6:	80 e0       	ldi	r24, 0x00	; 0
    4cb8:	90 e0       	ldi	r25, 0x00	; 0
    4cba:	ac ed       	ldi	r26, 0xDC	; 220
    4cbc:	b2 e4       	ldi	r27, 0x42	; 66
    4cbe:	8a 83       	std	Y+2, r24	; 0x02
    4cc0:	9b 83       	std	Y+3, r25	; 0x03
    4cc2:	ac 83       	std	Y+4, r26	; 0x04
    4cc4:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4cc6:	6a 81       	ldd	r22, Y+2	; 0x02
    4cc8:	7b 81       	ldd	r23, Y+3	; 0x03
    4cca:	8c 81       	ldd	r24, Y+4	; 0x04
    4ccc:	9d 81       	ldd	r25, Y+5	; 0x05
    4cce:	2b ea       	ldi	r18, 0xAB	; 171
    4cd0:	3a ea       	ldi	r19, 0xAA	; 170
    4cd2:	4a ea       	ldi	r20, 0xAA	; 170
    4cd4:	5e e3       	ldi	r21, 0x3E	; 62
    4cd6:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4cda:	dc 01       	movw	r26, r24
    4cdc:	cb 01       	movw	r24, r22
    4cde:	8e 83       	std	Y+6, r24	; 0x06
    4ce0:	9f 83       	std	Y+7, r25	; 0x07
    4ce2:	a8 87       	std	Y+8, r26	; 0x08
    4ce4:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4ce6:	11 e0       	ldi	r17, 0x01	; 1
    4ce8:	6e 81       	ldd	r22, Y+6	; 0x06
    4cea:	7f 81       	ldd	r23, Y+7	; 0x07
    4cec:	88 85       	ldd	r24, Y+8	; 0x08
    4cee:	99 85       	ldd	r25, Y+9	; 0x09
    4cf0:	20 e0       	ldi	r18, 0x00	; 0
    4cf2:	30 e0       	ldi	r19, 0x00	; 0
    4cf4:	40 e8       	ldi	r20, 0x80	; 128
    4cf6:	5f e3       	ldi	r21, 0x3F	; 63
    4cf8:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    4cfc:	88 23       	and	r24, r24
    4cfe:	0c f0       	brlt	.+2      	; 0x4d02 <chb_set_channel+0x7e>
    4d00:	10 e0       	ldi	r17, 0x00	; 0
    4d02:	11 23       	and	r17, r17
    4d04:	19 f0       	breq	.+6      	; 0x4d0c <chb_set_channel+0x88>
		__ticks = 1;
    4d06:	81 e0       	ldi	r24, 0x01	; 1
    4d08:	8a 87       	std	Y+10, r24	; 0x0a
    4d0a:	a3 c0       	rjmp	.+326    	; 0x4e52 <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4d0c:	11 e0       	ldi	r17, 0x01	; 1
    4d0e:	6e 81       	ldd	r22, Y+6	; 0x06
    4d10:	7f 81       	ldd	r23, Y+7	; 0x07
    4d12:	88 85       	ldd	r24, Y+8	; 0x08
    4d14:	99 85       	ldd	r25, Y+9	; 0x09
    4d16:	20 e0       	ldi	r18, 0x00	; 0
    4d18:	30 e0       	ldi	r19, 0x00	; 0
    4d1a:	4f e7       	ldi	r20, 0x7F	; 127
    4d1c:	53 e4       	ldi	r21, 0x43	; 67
    4d1e:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    4d22:	18 16       	cp	r1, r24
    4d24:	0c f0       	brlt	.+2      	; 0x4d28 <chb_set_channel+0xa4>
    4d26:	10 e0       	ldi	r17, 0x00	; 0
    4d28:	11 23       	and	r17, r17
    4d2a:	09 f4       	brne	.+2      	; 0x4d2e <chb_set_channel+0xaa>
    4d2c:	89 c0       	rjmp	.+274    	; 0x4e40 <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4d2e:	6a 81       	ldd	r22, Y+2	; 0x02
    4d30:	7b 81       	ldd	r23, Y+3	; 0x03
    4d32:	8c 81       	ldd	r24, Y+4	; 0x04
    4d34:	9d 81       	ldd	r25, Y+5	; 0x05
    4d36:	20 e0       	ldi	r18, 0x00	; 0
    4d38:	30 e0       	ldi	r19, 0x00	; 0
    4d3a:	4a e7       	ldi	r20, 0x7A	; 122
    4d3c:	54 e4       	ldi	r21, 0x44	; 68
    4d3e:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    4d42:	dc 01       	movw	r26, r24
    4d44:	cb 01       	movw	r24, r22
    4d46:	8b 87       	std	Y+11, r24	; 0x0b
    4d48:	9c 87       	std	Y+12, r25	; 0x0c
    4d4a:	ad 87       	std	Y+13, r26	; 0x0d
    4d4c:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4d4e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4d50:	7c 85       	ldd	r23, Y+12	; 0x0c
    4d52:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d54:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d56:	20 e0       	ldi	r18, 0x00	; 0
    4d58:	30 e0       	ldi	r19, 0x00	; 0
    4d5a:	4a e7       	ldi	r20, 0x7A	; 122
    4d5c:	53 e4       	ldi	r21, 0x43	; 67
    4d5e:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4d62:	dc 01       	movw	r26, r24
    4d64:	cb 01       	movw	r24, r22
    4d66:	8f 87       	std	Y+15, r24	; 0x0f
    4d68:	98 8b       	std	Y+16, r25	; 0x10
    4d6a:	a9 8b       	std	Y+17, r26	; 0x11
    4d6c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4d6e:	11 e0       	ldi	r17, 0x01	; 1
    4d70:	6f 85       	ldd	r22, Y+15	; 0x0f
    4d72:	78 89       	ldd	r23, Y+16	; 0x10
    4d74:	89 89       	ldd	r24, Y+17	; 0x11
    4d76:	9a 89       	ldd	r25, Y+18	; 0x12
    4d78:	20 e0       	ldi	r18, 0x00	; 0
    4d7a:	30 e0       	ldi	r19, 0x00	; 0
    4d7c:	40 e8       	ldi	r20, 0x80	; 128
    4d7e:	5f e3       	ldi	r21, 0x3F	; 63
    4d80:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    4d84:	88 23       	and	r24, r24
    4d86:	0c f0       	brlt	.+2      	; 0x4d8a <chb_set_channel+0x106>
    4d88:	10 e0       	ldi	r17, 0x00	; 0
    4d8a:	11 23       	and	r17, r17
    4d8c:	29 f0       	breq	.+10     	; 0x4d98 <chb_set_channel+0x114>
		__ticks = 1;
    4d8e:	81 e0       	ldi	r24, 0x01	; 1
    4d90:	90 e0       	ldi	r25, 0x00	; 0
    4d92:	8b 8b       	std	Y+19, r24	; 0x13
    4d94:	9c 8b       	std	Y+20, r25	; 0x14
    4d96:	46 c0       	rjmp	.+140    	; 0x4e24 <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4d98:	11 e0       	ldi	r17, 0x01	; 1
    4d9a:	6f 85       	ldd	r22, Y+15	; 0x0f
    4d9c:	78 89       	ldd	r23, Y+16	; 0x10
    4d9e:	89 89       	ldd	r24, Y+17	; 0x11
    4da0:	9a 89       	ldd	r25, Y+18	; 0x12
    4da2:	20 e0       	ldi	r18, 0x00	; 0
    4da4:	3f ef       	ldi	r19, 0xFF	; 255
    4da6:	4f e7       	ldi	r20, 0x7F	; 127
    4da8:	57 e4       	ldi	r21, 0x47	; 71
    4daa:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    4dae:	18 16       	cp	r1, r24
    4db0:	0c f0       	brlt	.+2      	; 0x4db4 <chb_set_channel+0x130>
    4db2:	10 e0       	ldi	r17, 0x00	; 0
    4db4:	11 23       	and	r17, r17
    4db6:	61 f1       	breq	.+88     	; 0x4e10 <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4db8:	6b 85       	ldd	r22, Y+11	; 0x0b
    4dba:	7c 85       	ldd	r23, Y+12	; 0x0c
    4dbc:	8d 85       	ldd	r24, Y+13	; 0x0d
    4dbe:	9e 85       	ldd	r25, Y+14	; 0x0e
    4dc0:	20 e0       	ldi	r18, 0x00	; 0
    4dc2:	30 e0       	ldi	r19, 0x00	; 0
    4dc4:	40 e2       	ldi	r20, 0x20	; 32
    4dc6:	51 e4       	ldi	r21, 0x41	; 65
    4dc8:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4dcc:	dc 01       	movw	r26, r24
    4dce:	cb 01       	movw	r24, r22
    4dd0:	bc 01       	movw	r22, r24
    4dd2:	cd 01       	movw	r24, r26
    4dd4:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    4dd8:	dc 01       	movw	r26, r24
    4dda:	cb 01       	movw	r24, r22
    4ddc:	8b 8b       	std	Y+19, r24	; 0x13
    4dde:	9c 8b       	std	Y+20, r25	; 0x14
    4de0:	12 c0       	rjmp	.+36     	; 0x4e06 <chb_set_channel+0x182>
    4de2:	89 e1       	ldi	r24, 0x19	; 25
    4de4:	90 e0       	ldi	r25, 0x00	; 0
    4de6:	8d 8b       	std	Y+21, r24	; 0x15
    4de8:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4dea:	8d 89       	ldd	r24, Y+21	; 0x15
    4dec:	9e 89       	ldd	r25, Y+22	; 0x16
    4dee:	8c 01       	movw	r16, r24
    4df0:	c8 01       	movw	r24, r16
    4df2:	01 97       	sbiw	r24, 0x01	; 1
    4df4:	f1 f7       	brne	.-4      	; 0x4df2 <chb_set_channel+0x16e>
    4df6:	8c 01       	movw	r16, r24
    4df8:	0d 8b       	std	Y+21, r16	; 0x15
    4dfa:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4dfc:	8b 89       	ldd	r24, Y+19	; 0x13
    4dfe:	9c 89       	ldd	r25, Y+20	; 0x14
    4e00:	01 97       	sbiw	r24, 0x01	; 1
    4e02:	8b 8b       	std	Y+19, r24	; 0x13
    4e04:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e06:	8b 89       	ldd	r24, Y+19	; 0x13
    4e08:	9c 89       	ldd	r25, Y+20	; 0x14
    4e0a:	00 97       	sbiw	r24, 0x00	; 0
    4e0c:	51 f7       	brne	.-44     	; 0x4de2 <chb_set_channel+0x15e>
    4e0e:	28 c0       	rjmp	.+80     	; 0x4e60 <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4e10:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e12:	78 89       	ldd	r23, Y+16	; 0x10
    4e14:	89 89       	ldd	r24, Y+17	; 0x11
    4e16:	9a 89       	ldd	r25, Y+18	; 0x12
    4e18:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    4e1c:	dc 01       	movw	r26, r24
    4e1e:	cb 01       	movw	r24, r22
    4e20:	8b 8b       	std	Y+19, r24	; 0x13
    4e22:	9c 8b       	std	Y+20, r25	; 0x14
    4e24:	8b 89       	ldd	r24, Y+19	; 0x13
    4e26:	9c 89       	ldd	r25, Y+20	; 0x14
    4e28:	8f 8b       	std	Y+23, r24	; 0x17
    4e2a:	98 8f       	std	Y+24, r25	; 0x18
    4e2c:	8f 89       	ldd	r24, Y+23	; 0x17
    4e2e:	98 8d       	ldd	r25, Y+24	; 0x18
    4e30:	8c 01       	movw	r16, r24
    4e32:	c8 01       	movw	r24, r16
    4e34:	01 97       	sbiw	r24, 0x01	; 1
    4e36:	f1 f7       	brne	.-4      	; 0x4e34 <chb_set_channel+0x1b0>
    4e38:	8c 01       	movw	r16, r24
    4e3a:	0f 8b       	std	Y+23, r16	; 0x17
    4e3c:	18 8f       	std	Y+24, r17	; 0x18
    4e3e:	10 c0       	rjmp	.+32     	; 0x4e60 <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4e40:	6e 81       	ldd	r22, Y+6	; 0x06
    4e42:	7f 81       	ldd	r23, Y+7	; 0x07
    4e44:	88 85       	ldd	r24, Y+8	; 0x08
    4e46:	99 85       	ldd	r25, Y+9	; 0x09
    4e48:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    4e4c:	dc 01       	movw	r26, r24
    4e4e:	cb 01       	movw	r24, r22
    4e50:	8a 87       	std	Y+10, r24	; 0x0a
    4e52:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e54:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4e56:	89 8d       	ldd	r24, Y+25	; 0x19
    4e58:	18 2f       	mov	r17, r24
    4e5a:	1a 95       	dec	r17
    4e5c:	f1 f7       	brne	.-4      	; 0x4e5a <chb_set_channel+0x1d6>
    4e5e:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4e60:	88 e0       	ldi	r24, 0x08	; 8
    4e62:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    4e66:	88 2f       	mov	r24, r24
    4e68:	90 e0       	ldi	r25, 0x00	; 0
    4e6a:	9c 01       	movw	r18, r24
    4e6c:	2f 71       	andi	r18, 0x1F	; 31
    4e6e:	30 70       	andi	r19, 0x00	; 0
    4e70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4e72:	88 2f       	mov	r24, r24
    4e74:	90 e0       	ldi	r25, 0x00	; 0
    4e76:	28 17       	cp	r18, r24
    4e78:	39 07       	cpc	r19, r25
    4e7a:	11 f4       	brne	.+4      	; 0x4e80 <chb_set_channel+0x1fc>
    4e7c:	80 e4       	ldi	r24, 0x40	; 64
    4e7e:	01 c0       	rjmp	.+2      	; 0x4e82 <chb_set_channel+0x1fe>
    4e80:	83 e4       	ldi	r24, 0x43	; 67
}
    4e82:	6a 96       	adiw	r28, 0x1a	; 26
    4e84:	cd bf       	out	0x3d, r28	; 61
    4e86:	de bf       	out	0x3e, r29	; 62
    4e88:	df 91       	pop	r29
    4e8a:	cf 91       	pop	r28
    4e8c:	1f 91       	pop	r17
    4e8e:	0f 91       	pop	r16
    4e90:	08 95       	ret

00004e92 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4e92:	cf 93       	push	r28
    4e94:	df 93       	push	r29
    4e96:	0f 92       	push	r0
    4e98:	cd b7       	in	r28, 0x3d	; 61
    4e9a:	de b7       	in	r29, 0x3e	; 62
    4e9c:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4e9e:	85 e0       	ldi	r24, 0x05	; 5
    4ea0:	69 81       	ldd	r22, Y+1	; 0x01
    4ea2:	0e 94 5e 24 	call	0x48bc	; 0x48bc <chb_reg_write>
}
    4ea6:	0f 90       	pop	r0
    4ea8:	df 91       	pop	r29
    4eaa:	cf 91       	pop	r28
    4eac:	08 95       	ret

00004eae <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4eae:	0f 93       	push	r16
    4eb0:	1f 93       	push	r17
    4eb2:	cf 93       	push	r28
    4eb4:	df 93       	push	r29
    4eb6:	cd b7       	in	r28, 0x3d	; 61
    4eb8:	de b7       	in	r29, 0x3e	; 62
    4eba:	c2 56       	subi	r28, 0x62	; 98
    4ebc:	d0 40       	sbci	r29, 0x00	; 0
    4ebe:	cd bf       	out	0x3d, r28	; 61
    4ec0:	de bf       	out	0x3e, r29	; 62
    4ec2:	9e 01       	movw	r18, r28
    4ec4:	2e 59       	subi	r18, 0x9E	; 158
    4ec6:	3f 4f       	sbci	r19, 0xFF	; 255
    4ec8:	f9 01       	movw	r30, r18
    4eca:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4ecc:	84 e6       	ldi	r24, 0x64	; 100
    4ece:	96 e0       	ldi	r25, 0x06	; 6
    4ed0:	fc 01       	movw	r30, r24
    4ed2:	80 81       	ld	r24, Z
    4ed4:	88 2f       	mov	r24, r24
    4ed6:	90 e0       	ldi	r25, 0x00	; 0
    4ed8:	82 70       	andi	r24, 0x02	; 2
    4eda:	90 70       	andi	r25, 0x00	; 0
    4edc:	00 97       	sbiw	r24, 0x00	; 0
    4ede:	11 f0       	breq	.+4      	; 0x4ee4 <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4ee0:	84 e4       	ldi	r24, 0x44	; 68
    4ee2:	91 c4       	rjmp	.+2338   	; 0x5806 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4ee4:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_get_state>
    4ee8:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4eea:	89 81       	ldd	r24, Y+1	; 0x01
    4eec:	82 31       	cpi	r24, 0x12	; 18
    4eee:	49 f0       	breq	.+18     	; 0x4f02 <chb_set_state+0x54>
    4ef0:	89 81       	ldd	r24, Y+1	; 0x01
    4ef2:	81 31       	cpi	r24, 0x11	; 17
    4ef4:	31 f0       	breq	.+12     	; 0x4f02 <chb_set_state+0x54>
    4ef6:	89 81       	ldd	r24, Y+1	; 0x01
    4ef8:	81 30       	cpi	r24, 0x01	; 1
    4efa:	19 f0       	breq	.+6      	; 0x4f02 <chb_set_state+0x54>
    4efc:	89 81       	ldd	r24, Y+1	; 0x01
    4efe:	82 30       	cpi	r24, 0x02	; 2
    4f00:	39 f4       	brne	.+14     	; 0x4f10 <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4f02:	00 00       	nop
    4f04:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_get_state>
    4f08:	98 2f       	mov	r25, r24
    4f0a:	89 81       	ldd	r24, Y+1	; 0x01
    4f0c:	98 17       	cp	r25, r24
    4f0e:	d1 f3       	breq	.-12     	; 0x4f04 <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4f10:	ce 01       	movw	r24, r28
    4f12:	8e 59       	subi	r24, 0x9E	; 158
    4f14:	9f 4f       	sbci	r25, 0xFF	; 255
    4f16:	fc 01       	movw	r30, r24
    4f18:	80 81       	ld	r24, Z
    4f1a:	88 2f       	mov	r24, r24
    4f1c:	90 e0       	ldi	r25, 0x00	; 0
    4f1e:	86 31       	cpi	r24, 0x16	; 22
    4f20:	91 05       	cpc	r25, r1
    4f22:	09 f4       	brne	.+2      	; 0x4f26 <chb_set_state+0x78>
    4f24:	cd c1       	rjmp	.+922    	; 0x52c0 <chb_set_state+0x412>
    4f26:	89 31       	cpi	r24, 0x19	; 25
    4f28:	91 05       	cpc	r25, r1
    4f2a:	09 f4       	brne	.+2      	; 0x4f2e <chb_set_state+0x80>
    4f2c:	e9 c0       	rjmp	.+466    	; 0x5100 <chb_set_state+0x252>
    4f2e:	88 30       	cpi	r24, 0x08	; 8
    4f30:	91 05       	cpc	r25, r1
    4f32:	09 f0       	breq	.+2      	; 0x4f36 <chb_set_state+0x88>
    4f34:	f7 c2       	rjmp	.+1518   	; 0x5524 <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4f36:	84 e6       	ldi	r24, 0x64	; 100
    4f38:	96 e0       	ldi	r25, 0x06	; 6
    4f3a:	24 e6       	ldi	r18, 0x64	; 100
    4f3c:	36 e0       	ldi	r19, 0x06	; 6
    4f3e:	f9 01       	movw	r30, r18
    4f40:	20 81       	ld	r18, Z
    4f42:	2d 7f       	andi	r18, 0xFD	; 253
    4f44:	fc 01       	movw	r30, r24
    4f46:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4f48:	82 e0       	ldi	r24, 0x02	; 2
    4f4a:	63 e0       	ldi	r22, 0x03	; 3
    4f4c:	4f e1       	ldi	r20, 0x1F	; 31
    4f4e:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
    4f52:	80 e0       	ldi	r24, 0x00	; 0
    4f54:	90 e0       	ldi	r25, 0x00	; 0
    4f56:	a0 e8       	ldi	r26, 0x80	; 128
    4f58:	bf e3       	ldi	r27, 0x3F	; 63
    4f5a:	8a 83       	std	Y+2, r24	; 0x02
    4f5c:	9b 83       	std	Y+3, r25	; 0x03
    4f5e:	ac 83       	std	Y+4, r26	; 0x04
    4f60:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4f62:	6a 81       	ldd	r22, Y+2	; 0x02
    4f64:	7b 81       	ldd	r23, Y+3	; 0x03
    4f66:	8c 81       	ldd	r24, Y+4	; 0x04
    4f68:	9d 81       	ldd	r25, Y+5	; 0x05
    4f6a:	2b ea       	ldi	r18, 0xAB	; 171
    4f6c:	3a ea       	ldi	r19, 0xAA	; 170
    4f6e:	4a ea       	ldi	r20, 0xAA	; 170
    4f70:	5e e3       	ldi	r21, 0x3E	; 62
    4f72:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4f76:	dc 01       	movw	r26, r24
    4f78:	cb 01       	movw	r24, r22
    4f7a:	8e 83       	std	Y+6, r24	; 0x06
    4f7c:	9f 83       	std	Y+7, r25	; 0x07
    4f7e:	a8 87       	std	Y+8, r26	; 0x08
    4f80:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4f82:	11 e0       	ldi	r17, 0x01	; 1
    4f84:	6e 81       	ldd	r22, Y+6	; 0x06
    4f86:	7f 81       	ldd	r23, Y+7	; 0x07
    4f88:	88 85       	ldd	r24, Y+8	; 0x08
    4f8a:	99 85       	ldd	r25, Y+9	; 0x09
    4f8c:	20 e0       	ldi	r18, 0x00	; 0
    4f8e:	30 e0       	ldi	r19, 0x00	; 0
    4f90:	40 e8       	ldi	r20, 0x80	; 128
    4f92:	5f e3       	ldi	r21, 0x3F	; 63
    4f94:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    4f98:	88 23       	and	r24, r24
    4f9a:	0c f0       	brlt	.+2      	; 0x4f9e <chb_set_state+0xf0>
    4f9c:	10 e0       	ldi	r17, 0x00	; 0
    4f9e:	11 23       	and	r17, r17
    4fa0:	19 f0       	breq	.+6      	; 0x4fa8 <chb_set_state+0xfa>
		__ticks = 1;
    4fa2:	81 e0       	ldi	r24, 0x01	; 1
    4fa4:	8a 87       	std	Y+10, r24	; 0x0a
    4fa6:	a3 c0       	rjmp	.+326    	; 0x50ee <chb_set_state+0x240>
	else if (__tmp > 255)
    4fa8:	11 e0       	ldi	r17, 0x01	; 1
    4faa:	6e 81       	ldd	r22, Y+6	; 0x06
    4fac:	7f 81       	ldd	r23, Y+7	; 0x07
    4fae:	88 85       	ldd	r24, Y+8	; 0x08
    4fb0:	99 85       	ldd	r25, Y+9	; 0x09
    4fb2:	20 e0       	ldi	r18, 0x00	; 0
    4fb4:	30 e0       	ldi	r19, 0x00	; 0
    4fb6:	4f e7       	ldi	r20, 0x7F	; 127
    4fb8:	53 e4       	ldi	r21, 0x43	; 67
    4fba:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    4fbe:	18 16       	cp	r1, r24
    4fc0:	0c f0       	brlt	.+2      	; 0x4fc4 <chb_set_state+0x116>
    4fc2:	10 e0       	ldi	r17, 0x00	; 0
    4fc4:	11 23       	and	r17, r17
    4fc6:	09 f4       	brne	.+2      	; 0x4fca <chb_set_state+0x11c>
    4fc8:	89 c0       	rjmp	.+274    	; 0x50dc <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    4fca:	6a 81       	ldd	r22, Y+2	; 0x02
    4fcc:	7b 81       	ldd	r23, Y+3	; 0x03
    4fce:	8c 81       	ldd	r24, Y+4	; 0x04
    4fd0:	9d 81       	ldd	r25, Y+5	; 0x05
    4fd2:	20 e0       	ldi	r18, 0x00	; 0
    4fd4:	30 e0       	ldi	r19, 0x00	; 0
    4fd6:	4a e7       	ldi	r20, 0x7A	; 122
    4fd8:	54 e4       	ldi	r21, 0x44	; 68
    4fda:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    4fde:	dc 01       	movw	r26, r24
    4fe0:	cb 01       	movw	r24, r22
    4fe2:	8b 87       	std	Y+11, r24	; 0x0b
    4fe4:	9c 87       	std	Y+12, r25	; 0x0c
    4fe6:	ad 87       	std	Y+13, r26	; 0x0d
    4fe8:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4fea:	6b 85       	ldd	r22, Y+11	; 0x0b
    4fec:	7c 85       	ldd	r23, Y+12	; 0x0c
    4fee:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ff0:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ff2:	20 e0       	ldi	r18, 0x00	; 0
    4ff4:	30 e0       	ldi	r19, 0x00	; 0
    4ff6:	4a e7       	ldi	r20, 0x7A	; 122
    4ff8:	53 e4       	ldi	r21, 0x43	; 67
    4ffa:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    4ffe:	dc 01       	movw	r26, r24
    5000:	cb 01       	movw	r24, r22
    5002:	8f 87       	std	Y+15, r24	; 0x0f
    5004:	98 8b       	std	Y+16, r25	; 0x10
    5006:	a9 8b       	std	Y+17, r26	; 0x11
    5008:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    500a:	11 e0       	ldi	r17, 0x01	; 1
    500c:	6f 85       	ldd	r22, Y+15	; 0x0f
    500e:	78 89       	ldd	r23, Y+16	; 0x10
    5010:	89 89       	ldd	r24, Y+17	; 0x11
    5012:	9a 89       	ldd	r25, Y+18	; 0x12
    5014:	20 e0       	ldi	r18, 0x00	; 0
    5016:	30 e0       	ldi	r19, 0x00	; 0
    5018:	40 e8       	ldi	r20, 0x80	; 128
    501a:	5f e3       	ldi	r21, 0x3F	; 63
    501c:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    5020:	88 23       	and	r24, r24
    5022:	0c f0       	brlt	.+2      	; 0x5026 <chb_set_state+0x178>
    5024:	10 e0       	ldi	r17, 0x00	; 0
    5026:	11 23       	and	r17, r17
    5028:	29 f0       	breq	.+10     	; 0x5034 <chb_set_state+0x186>
		__ticks = 1;
    502a:	81 e0       	ldi	r24, 0x01	; 1
    502c:	90 e0       	ldi	r25, 0x00	; 0
    502e:	8b 8b       	std	Y+19, r24	; 0x13
    5030:	9c 8b       	std	Y+20, r25	; 0x14
    5032:	46 c0       	rjmp	.+140    	; 0x50c0 <chb_set_state+0x212>
	else if (__tmp > 65535)
    5034:	11 e0       	ldi	r17, 0x01	; 1
    5036:	6f 85       	ldd	r22, Y+15	; 0x0f
    5038:	78 89       	ldd	r23, Y+16	; 0x10
    503a:	89 89       	ldd	r24, Y+17	; 0x11
    503c:	9a 89       	ldd	r25, Y+18	; 0x12
    503e:	20 e0       	ldi	r18, 0x00	; 0
    5040:	3f ef       	ldi	r19, 0xFF	; 255
    5042:	4f e7       	ldi	r20, 0x7F	; 127
    5044:	57 e4       	ldi	r21, 0x47	; 71
    5046:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    504a:	18 16       	cp	r1, r24
    504c:	0c f0       	brlt	.+2      	; 0x5050 <chb_set_state+0x1a2>
    504e:	10 e0       	ldi	r17, 0x00	; 0
    5050:	11 23       	and	r17, r17
    5052:	61 f1       	breq	.+88     	; 0x50ac <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5054:	6b 85       	ldd	r22, Y+11	; 0x0b
    5056:	7c 85       	ldd	r23, Y+12	; 0x0c
    5058:	8d 85       	ldd	r24, Y+13	; 0x0d
    505a:	9e 85       	ldd	r25, Y+14	; 0x0e
    505c:	20 e0       	ldi	r18, 0x00	; 0
    505e:	30 e0       	ldi	r19, 0x00	; 0
    5060:	40 e2       	ldi	r20, 0x20	; 32
    5062:	51 e4       	ldi	r21, 0x41	; 65
    5064:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5068:	dc 01       	movw	r26, r24
    506a:	cb 01       	movw	r24, r22
    506c:	bc 01       	movw	r22, r24
    506e:	cd 01       	movw	r24, r26
    5070:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5074:	dc 01       	movw	r26, r24
    5076:	cb 01       	movw	r24, r22
    5078:	8b 8b       	std	Y+19, r24	; 0x13
    507a:	9c 8b       	std	Y+20, r25	; 0x14
    507c:	12 c0       	rjmp	.+36     	; 0x50a2 <chb_set_state+0x1f4>
    507e:	89 e1       	ldi	r24, 0x19	; 25
    5080:	90 e0       	ldi	r25, 0x00	; 0
    5082:	8d 8b       	std	Y+21, r24	; 0x15
    5084:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5086:	8d 89       	ldd	r24, Y+21	; 0x15
    5088:	9e 89       	ldd	r25, Y+22	; 0x16
    508a:	8c 01       	movw	r16, r24
    508c:	c8 01       	movw	r24, r16
    508e:	01 97       	sbiw	r24, 0x01	; 1
    5090:	f1 f7       	brne	.-4      	; 0x508e <chb_set_state+0x1e0>
    5092:	8c 01       	movw	r16, r24
    5094:	0d 8b       	std	Y+21, r16	; 0x15
    5096:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5098:	8b 89       	ldd	r24, Y+19	; 0x13
    509a:	9c 89       	ldd	r25, Y+20	; 0x14
    509c:	01 97       	sbiw	r24, 0x01	; 1
    509e:	8b 8b       	std	Y+19, r24	; 0x13
    50a0:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    50a2:	8b 89       	ldd	r24, Y+19	; 0x13
    50a4:	9c 89       	ldd	r25, Y+20	; 0x14
    50a6:	00 97       	sbiw	r24, 0x00	; 0
    50a8:	51 f7       	brne	.-44     	; 0x507e <chb_set_state+0x1d0>
    50aa:	29 c0       	rjmp	.+82     	; 0x50fe <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    50ac:	6f 85       	ldd	r22, Y+15	; 0x0f
    50ae:	78 89       	ldd	r23, Y+16	; 0x10
    50b0:	89 89       	ldd	r24, Y+17	; 0x11
    50b2:	9a 89       	ldd	r25, Y+18	; 0x12
    50b4:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    50b8:	dc 01       	movw	r26, r24
    50ba:	cb 01       	movw	r24, r22
    50bc:	8b 8b       	std	Y+19, r24	; 0x13
    50be:	9c 8b       	std	Y+20, r25	; 0x14
    50c0:	8b 89       	ldd	r24, Y+19	; 0x13
    50c2:	9c 89       	ldd	r25, Y+20	; 0x14
    50c4:	8f 8b       	std	Y+23, r24	; 0x17
    50c6:	98 8f       	std	Y+24, r25	; 0x18
    50c8:	8f 89       	ldd	r24, Y+23	; 0x17
    50ca:	98 8d       	ldd	r25, Y+24	; 0x18
    50cc:	8c 01       	movw	r16, r24
    50ce:	f8 01       	movw	r30, r16
    50d0:	31 97       	sbiw	r30, 0x01	; 1
    50d2:	f1 f7       	brne	.-4      	; 0x50d0 <chb_set_state+0x222>
    50d4:	8f 01       	movw	r16, r30
    50d6:	0f 8b       	std	Y+23, r16	; 0x17
    50d8:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    50da:	24 c2       	rjmp	.+1096   	; 0x5524 <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    50dc:	6e 81       	ldd	r22, Y+6	; 0x06
    50de:	7f 81       	ldd	r23, Y+7	; 0x07
    50e0:	88 85       	ldd	r24, Y+8	; 0x08
    50e2:	99 85       	ldd	r25, Y+9	; 0x09
    50e4:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    50e8:	dc 01       	movw	r26, r24
    50ea:	cb 01       	movw	r24, r22
    50ec:	8a 87       	std	Y+10, r24	; 0x0a
    50ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    50f0:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    50f2:	89 8d       	ldd	r24, Y+25	; 0x19
    50f4:	18 2f       	mov	r17, r24
    50f6:	1a 95       	dec	r17
    50f8:	f1 f7       	brne	.-4      	; 0x50f6 <chb_set_state+0x248>
    50fa:	19 8f       	std	Y+25, r17	; 0x19
    50fc:	13 c2       	rjmp	.+1062   	; 0x5524 <chb_set_state+0x676>
    50fe:	12 c2       	rjmp	.+1060   	; 0x5524 <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    5100:	89 81       	ldd	r24, Y+1	; 0x01
    5102:	86 31       	cpi	r24, 0x16	; 22
    5104:	09 f0       	breq	.+2      	; 0x5108 <chb_set_state+0x25a>
    5106:	0b c2       	rjmp	.+1046   	; 0x551e <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5108:	82 e0       	ldi	r24, 0x02	; 2
    510a:	69 e0       	ldi	r22, 0x09	; 9
    510c:	4f e1       	ldi	r20, 0x1F	; 31
    510e:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
    5112:	80 e0       	ldi	r24, 0x00	; 0
    5114:	90 e0       	ldi	r25, 0x00	; 0
    5116:	a0 e8       	ldi	r26, 0x80	; 128
    5118:	bf e3       	ldi	r27, 0x3F	; 63
    511a:	8a 8f       	std	Y+26, r24	; 0x1a
    511c:	9b 8f       	std	Y+27, r25	; 0x1b
    511e:	ac 8f       	std	Y+28, r26	; 0x1c
    5120:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5122:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5124:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5126:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5128:	9d 8d       	ldd	r25, Y+29	; 0x1d
    512a:	2b ea       	ldi	r18, 0xAB	; 171
    512c:	3a ea       	ldi	r19, 0xAA	; 170
    512e:	4a ea       	ldi	r20, 0xAA	; 170
    5130:	5e e3       	ldi	r21, 0x3E	; 62
    5132:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5136:	dc 01       	movw	r26, r24
    5138:	cb 01       	movw	r24, r22
    513a:	8e 8f       	std	Y+30, r24	; 0x1e
    513c:	9f 8f       	std	Y+31, r25	; 0x1f
    513e:	a8 a3       	lds	r26, 0x58
    5140:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    5142:	11 e0       	ldi	r17, 0x01	; 1
    5144:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5146:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5148:	88 a1       	lds	r24, 0x48
    514a:	99 a1       	lds	r25, 0x49
    514c:	20 e0       	ldi	r18, 0x00	; 0
    514e:	30 e0       	ldi	r19, 0x00	; 0
    5150:	40 e8       	ldi	r20, 0x80	; 128
    5152:	5f e3       	ldi	r21, 0x3F	; 63
    5154:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    5158:	88 23       	and	r24, r24
    515a:	0c f0       	brlt	.+2      	; 0x515e <chb_set_state+0x2b0>
    515c:	10 e0       	ldi	r17, 0x00	; 0
    515e:	11 23       	and	r17, r17
    5160:	19 f0       	breq	.+6      	; 0x5168 <chb_set_state+0x2ba>
		__ticks = 1;
    5162:	81 e0       	ldi	r24, 0x01	; 1
    5164:	8a a3       	lds	r24, 0x5a
    5166:	a3 c0       	rjmp	.+326    	; 0x52ae <chb_set_state+0x400>
	else if (__tmp > 255)
    5168:	11 e0       	ldi	r17, 0x01	; 1
    516a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    516c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    516e:	88 a1       	lds	r24, 0x48
    5170:	99 a1       	lds	r25, 0x49
    5172:	20 e0       	ldi	r18, 0x00	; 0
    5174:	30 e0       	ldi	r19, 0x00	; 0
    5176:	4f e7       	ldi	r20, 0x7F	; 127
    5178:	53 e4       	ldi	r21, 0x43	; 67
    517a:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    517e:	18 16       	cp	r1, r24
    5180:	0c f0       	brlt	.+2      	; 0x5184 <chb_set_state+0x2d6>
    5182:	10 e0       	ldi	r17, 0x00	; 0
    5184:	11 23       	and	r17, r17
    5186:	09 f4       	brne	.+2      	; 0x518a <chb_set_state+0x2dc>
    5188:	89 c0       	rjmp	.+274    	; 0x529c <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    518a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    518c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    518e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5190:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5192:	20 e0       	ldi	r18, 0x00	; 0
    5194:	30 e0       	ldi	r19, 0x00	; 0
    5196:	4a e7       	ldi	r20, 0x7A	; 122
    5198:	54 e4       	ldi	r21, 0x44	; 68
    519a:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    519e:	dc 01       	movw	r26, r24
    51a0:	cb 01       	movw	r24, r22
    51a2:	8b a3       	lds	r24, 0x5b
    51a4:	9c a3       	lds	r25, 0x5c
    51a6:	ad a3       	lds	r26, 0x5d
    51a8:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    51aa:	6b a1       	lds	r22, 0x4b
    51ac:	7c a1       	lds	r23, 0x4c
    51ae:	8d a1       	lds	r24, 0x4d
    51b0:	9e a1       	lds	r25, 0x4e
    51b2:	20 e0       	ldi	r18, 0x00	; 0
    51b4:	30 e0       	ldi	r19, 0x00	; 0
    51b6:	4a e7       	ldi	r20, 0x7A	; 122
    51b8:	53 e4       	ldi	r21, 0x43	; 67
    51ba:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    51be:	dc 01       	movw	r26, r24
    51c0:	cb 01       	movw	r24, r22
    51c2:	8f a3       	lds	r24, 0x5f
    51c4:	98 a7       	lds	r25, 0x78
    51c6:	a9 a7       	lds	r26, 0x79
    51c8:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    51ca:	11 e0       	ldi	r17, 0x01	; 1
    51cc:	6f a1       	lds	r22, 0x4f
    51ce:	78 a5       	lds	r23, 0x68
    51d0:	89 a5       	lds	r24, 0x69
    51d2:	9a a5       	lds	r25, 0x6a
    51d4:	20 e0       	ldi	r18, 0x00	; 0
    51d6:	30 e0       	ldi	r19, 0x00	; 0
    51d8:	40 e8       	ldi	r20, 0x80	; 128
    51da:	5f e3       	ldi	r21, 0x3F	; 63
    51dc:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    51e0:	88 23       	and	r24, r24
    51e2:	0c f0       	brlt	.+2      	; 0x51e6 <chb_set_state+0x338>
    51e4:	10 e0       	ldi	r17, 0x00	; 0
    51e6:	11 23       	and	r17, r17
    51e8:	29 f0       	breq	.+10     	; 0x51f4 <chb_set_state+0x346>
		__ticks = 1;
    51ea:	81 e0       	ldi	r24, 0x01	; 1
    51ec:	90 e0       	ldi	r25, 0x00	; 0
    51ee:	8b a7       	lds	r24, 0x7b
    51f0:	9c a7       	lds	r25, 0x7c
    51f2:	46 c0       	rjmp	.+140    	; 0x5280 <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    51f4:	11 e0       	ldi	r17, 0x01	; 1
    51f6:	6f a1       	lds	r22, 0x4f
    51f8:	78 a5       	lds	r23, 0x68
    51fa:	89 a5       	lds	r24, 0x69
    51fc:	9a a5       	lds	r25, 0x6a
    51fe:	20 e0       	ldi	r18, 0x00	; 0
    5200:	3f ef       	ldi	r19, 0xFF	; 255
    5202:	4f e7       	ldi	r20, 0x7F	; 127
    5204:	57 e4       	ldi	r21, 0x47	; 71
    5206:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    520a:	18 16       	cp	r1, r24
    520c:	0c f0       	brlt	.+2      	; 0x5210 <chb_set_state+0x362>
    520e:	10 e0       	ldi	r17, 0x00	; 0
    5210:	11 23       	and	r17, r17
    5212:	61 f1       	breq	.+88     	; 0x526c <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5214:	6b a1       	lds	r22, 0x4b
    5216:	7c a1       	lds	r23, 0x4c
    5218:	8d a1       	lds	r24, 0x4d
    521a:	9e a1       	lds	r25, 0x4e
    521c:	20 e0       	ldi	r18, 0x00	; 0
    521e:	30 e0       	ldi	r19, 0x00	; 0
    5220:	40 e2       	ldi	r20, 0x20	; 32
    5222:	51 e4       	ldi	r21, 0x41	; 65
    5224:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5228:	dc 01       	movw	r26, r24
    522a:	cb 01       	movw	r24, r22
    522c:	bc 01       	movw	r22, r24
    522e:	cd 01       	movw	r24, r26
    5230:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5234:	dc 01       	movw	r26, r24
    5236:	cb 01       	movw	r24, r22
    5238:	8b a7       	lds	r24, 0x7b
    523a:	9c a7       	lds	r25, 0x7c
    523c:	12 c0       	rjmp	.+36     	; 0x5262 <chb_set_state+0x3b4>
    523e:	89 e1       	ldi	r24, 0x19	; 25
    5240:	90 e0       	ldi	r25, 0x00	; 0
    5242:	8d a7       	lds	r24, 0x7d
    5244:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5246:	8d a5       	lds	r24, 0x6d
    5248:	9e a5       	lds	r25, 0x6e
    524a:	8c 01       	movw	r16, r24
    524c:	c8 01       	movw	r24, r16
    524e:	01 97       	sbiw	r24, 0x01	; 1
    5250:	f1 f7       	brne	.-4      	; 0x524e <chb_set_state+0x3a0>
    5252:	8c 01       	movw	r16, r24
    5254:	0d a7       	lds	r16, 0x7d
    5256:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5258:	8b a5       	lds	r24, 0x6b
    525a:	9c a5       	lds	r25, 0x6c
    525c:	01 97       	sbiw	r24, 0x01	; 1
    525e:	8b a7       	lds	r24, 0x7b
    5260:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5262:	8b a5       	lds	r24, 0x6b
    5264:	9c a5       	lds	r25, 0x6c
    5266:	00 97       	sbiw	r24, 0x00	; 0
    5268:	51 f7       	brne	.-44     	; 0x523e <chb_set_state+0x390>
    526a:	29 c0       	rjmp	.+82     	; 0x52be <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    526c:	6f a1       	lds	r22, 0x4f
    526e:	78 a5       	lds	r23, 0x68
    5270:	89 a5       	lds	r24, 0x69
    5272:	9a a5       	lds	r25, 0x6a
    5274:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5278:	dc 01       	movw	r26, r24
    527a:	cb 01       	movw	r24, r22
    527c:	8b a7       	lds	r24, 0x7b
    527e:	9c a7       	lds	r25, 0x7c
    5280:	8b a5       	lds	r24, 0x6b
    5282:	9c a5       	lds	r25, 0x6c
    5284:	8f a7       	lds	r24, 0x7f
    5286:	98 ab       	sts	0x58, r25
    5288:	8f a5       	lds	r24, 0x6f
    528a:	98 a9       	sts	0x48, r25
    528c:	8c 01       	movw	r16, r24
    528e:	f8 01       	movw	r30, r16
    5290:	31 97       	sbiw	r30, 0x01	; 1
    5292:	f1 f7       	brne	.-4      	; 0x5290 <chb_set_state+0x3e2>
    5294:	8f 01       	movw	r16, r30
    5296:	0f a7       	lds	r16, 0x7f
    5298:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    529a:	41 c1       	rjmp	.+642    	; 0x551e <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    529c:	6e 8d       	ldd	r22, Y+30	; 0x1e
    529e:	7f 8d       	ldd	r23, Y+31	; 0x1f
    52a0:	88 a1       	lds	r24, 0x48
    52a2:	99 a1       	lds	r25, 0x49
    52a4:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    52a8:	dc 01       	movw	r26, r24
    52aa:	cb 01       	movw	r24, r22
    52ac:	8a a3       	lds	r24, 0x5a
    52ae:	8a a1       	lds	r24, 0x4a
    52b0:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    52b2:	89 a9       	sts	0x49, r24
    52b4:	18 2f       	mov	r17, r24
    52b6:	1a 95       	dec	r17
    52b8:	f1 f7       	brne	.-4      	; 0x52b6 <chb_set_state+0x408>
    52ba:	19 ab       	sts	0x59, r17
    52bc:	30 c1       	rjmp	.+608    	; 0x551e <chb_set_state+0x670>
    52be:	2f c1       	rjmp	.+606    	; 0x551e <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    52c0:	89 81       	ldd	r24, Y+1	; 0x01
    52c2:	89 31       	cpi	r24, 0x19	; 25
    52c4:	09 f0       	breq	.+2      	; 0x52c8 <chb_set_state+0x41a>
    52c6:	2d c1       	rjmp	.+602    	; 0x5522 <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    52c8:	82 e0       	ldi	r24, 0x02	; 2
    52ca:	69 e0       	ldi	r22, 0x09	; 9
    52cc:	4f e1       	ldi	r20, 0x1F	; 31
    52ce:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
    52d2:	80 e0       	ldi	r24, 0x00	; 0
    52d4:	90 e0       	ldi	r25, 0x00	; 0
    52d6:	a0 e8       	ldi	r26, 0x80	; 128
    52d8:	bf e3       	ldi	r27, 0x3F	; 63
    52da:	8a ab       	sts	0x5a, r24
    52dc:	9b ab       	sts	0x5b, r25
    52de:	ac ab       	sts	0x5c, r26
    52e0:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    52e2:	6a a9       	sts	0x4a, r22
    52e4:	7b a9       	sts	0x4b, r23
    52e6:	8c a9       	sts	0x4c, r24
    52e8:	9d a9       	sts	0x4d, r25
    52ea:	2b ea       	ldi	r18, 0xAB	; 171
    52ec:	3a ea       	ldi	r19, 0xAA	; 170
    52ee:	4a ea       	ldi	r20, 0xAA	; 170
    52f0:	5e e3       	ldi	r21, 0x3E	; 62
    52f2:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    52f6:	dc 01       	movw	r26, r24
    52f8:	cb 01       	movw	r24, r22
    52fa:	8e ab       	sts	0x5e, r24
    52fc:	9f ab       	sts	0x5f, r25
    52fe:	a8 af       	sts	0x78, r26
    5300:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    5302:	11 e0       	ldi	r17, 0x01	; 1
    5304:	6e a9       	sts	0x4e, r22
    5306:	7f a9       	sts	0x4f, r23
    5308:	88 ad       	sts	0x68, r24
    530a:	99 ad       	sts	0x69, r25
    530c:	20 e0       	ldi	r18, 0x00	; 0
    530e:	30 e0       	ldi	r19, 0x00	; 0
    5310:	40 e8       	ldi	r20, 0x80	; 128
    5312:	5f e3       	ldi	r21, 0x3F	; 63
    5314:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    5318:	88 23       	and	r24, r24
    531a:	0c f0       	brlt	.+2      	; 0x531e <chb_set_state+0x470>
    531c:	10 e0       	ldi	r17, 0x00	; 0
    531e:	11 23       	and	r17, r17
    5320:	19 f0       	breq	.+6      	; 0x5328 <chb_set_state+0x47a>
		__ticks = 1;
    5322:	81 e0       	ldi	r24, 0x01	; 1
    5324:	8a af       	sts	0x7a, r24
    5326:	e6 c0       	rjmp	.+460    	; 0x54f4 <chb_set_state+0x646>
	else if (__tmp > 255)
    5328:	11 e0       	ldi	r17, 0x01	; 1
    532a:	6e a9       	sts	0x4e, r22
    532c:	7f a9       	sts	0x4f, r23
    532e:	88 ad       	sts	0x68, r24
    5330:	99 ad       	sts	0x69, r25
    5332:	20 e0       	ldi	r18, 0x00	; 0
    5334:	30 e0       	ldi	r19, 0x00	; 0
    5336:	4f e7       	ldi	r20, 0x7F	; 127
    5338:	53 e4       	ldi	r21, 0x43	; 67
    533a:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    533e:	18 16       	cp	r1, r24
    5340:	0c f0       	brlt	.+2      	; 0x5344 <chb_set_state+0x496>
    5342:	10 e0       	ldi	r17, 0x00	; 0
    5344:	11 23       	and	r17, r17
    5346:	09 f4       	brne	.+2      	; 0x534a <chb_set_state+0x49c>
    5348:	cc c0       	rjmp	.+408    	; 0x54e2 <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    534a:	6a a9       	sts	0x4a, r22
    534c:	7b a9       	sts	0x4b, r23
    534e:	8c a9       	sts	0x4c, r24
    5350:	9d a9       	sts	0x4d, r25
    5352:	20 e0       	ldi	r18, 0x00	; 0
    5354:	30 e0       	ldi	r19, 0x00	; 0
    5356:	4a e7       	ldi	r20, 0x7A	; 122
    5358:	54 e4       	ldi	r21, 0x44	; 68
    535a:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    535e:	dc 01       	movw	r26, r24
    5360:	cb 01       	movw	r24, r22
    5362:	8b af       	sts	0x7b, r24
    5364:	9c af       	sts	0x7c, r25
    5366:	ad af       	sts	0x7d, r26
    5368:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    536a:	8e 01       	movw	r16, r28
    536c:	01 5c       	subi	r16, 0xC1	; 193
    536e:	1f 4f       	sbci	r17, 0xFF	; 255
    5370:	6b ad       	sts	0x6b, r22
    5372:	7c ad       	sts	0x6c, r23
    5374:	8d ad       	sts	0x6d, r24
    5376:	9e ad       	sts	0x6e, r25
    5378:	20 e0       	ldi	r18, 0x00	; 0
    537a:	30 e0       	ldi	r19, 0x00	; 0
    537c:	4a e7       	ldi	r20, 0x7A	; 122
    537e:	53 e4       	ldi	r21, 0x43	; 67
    5380:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5384:	dc 01       	movw	r26, r24
    5386:	cb 01       	movw	r24, r22
    5388:	f8 01       	movw	r30, r16
    538a:	80 83       	st	Z, r24
    538c:	91 83       	std	Z+1, r25	; 0x01
    538e:	a2 83       	std	Z+2, r26	; 0x02
    5390:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5392:	ce 01       	movw	r24, r28
    5394:	cf 96       	adiw	r24, 0x3f	; 63
    5396:	11 e0       	ldi	r17, 0x01	; 1
    5398:	fc 01       	movw	r30, r24
    539a:	60 81       	ld	r22, Z
    539c:	71 81       	ldd	r23, Z+1	; 0x01
    539e:	82 81       	ldd	r24, Z+2	; 0x02
    53a0:	93 81       	ldd	r25, Z+3	; 0x03
    53a2:	20 e0       	ldi	r18, 0x00	; 0
    53a4:	30 e0       	ldi	r19, 0x00	; 0
    53a6:	40 e8       	ldi	r20, 0x80	; 128
    53a8:	5f e3       	ldi	r21, 0x3F	; 63
    53aa:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    53ae:	88 23       	and	r24, r24
    53b0:	0c f0       	brlt	.+2      	; 0x53b4 <chb_set_state+0x506>
    53b2:	10 e0       	ldi	r17, 0x00	; 0
    53b4:	11 23       	and	r17, r17
    53b6:	49 f0       	breq	.+18     	; 0x53ca <chb_set_state+0x51c>
		__ticks = 1;
    53b8:	ce 01       	movw	r24, r28
    53ba:	8d 5b       	subi	r24, 0xBD	; 189
    53bc:	9f 4f       	sbci	r25, 0xFF	; 255
    53be:	21 e0       	ldi	r18, 0x01	; 1
    53c0:	30 e0       	ldi	r19, 0x00	; 0
    53c2:	fc 01       	movw	r30, r24
    53c4:	20 83       	st	Z, r18
    53c6:	31 83       	std	Z+1, r19	; 0x01
    53c8:	6e c0       	rjmp	.+220    	; 0x54a6 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    53ca:	ce 01       	movw	r24, r28
    53cc:	cf 96       	adiw	r24, 0x3f	; 63
    53ce:	11 e0       	ldi	r17, 0x01	; 1
    53d0:	fc 01       	movw	r30, r24
    53d2:	60 81       	ld	r22, Z
    53d4:	71 81       	ldd	r23, Z+1	; 0x01
    53d6:	82 81       	ldd	r24, Z+2	; 0x02
    53d8:	93 81       	ldd	r25, Z+3	; 0x03
    53da:	20 e0       	ldi	r18, 0x00	; 0
    53dc:	3f ef       	ldi	r19, 0xFF	; 255
    53de:	4f e7       	ldi	r20, 0x7F	; 127
    53e0:	57 e4       	ldi	r21, 0x47	; 71
    53e2:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    53e6:	18 16       	cp	r1, r24
    53e8:	0c f0       	brlt	.+2      	; 0x53ec <chb_set_state+0x53e>
    53ea:	10 e0       	ldi	r17, 0x00	; 0
    53ec:	11 23       	and	r17, r17
    53ee:	09 f4       	brne	.+2      	; 0x53f2 <chb_set_state+0x544>
    53f0:	49 c0       	rjmp	.+146    	; 0x5484 <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    53f2:	6b ad       	sts	0x6b, r22
    53f4:	7c ad       	sts	0x6c, r23
    53f6:	8d ad       	sts	0x6d, r24
    53f8:	9e ad       	sts	0x6e, r25
    53fa:	20 e0       	ldi	r18, 0x00	; 0
    53fc:	30 e0       	ldi	r19, 0x00	; 0
    53fe:	40 e2       	ldi	r20, 0x20	; 32
    5400:	51 e4       	ldi	r21, 0x41	; 65
    5402:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5406:	dc 01       	movw	r26, r24
    5408:	cb 01       	movw	r24, r22
    540a:	8e 01       	movw	r16, r28
    540c:	0d 5b       	subi	r16, 0xBD	; 189
    540e:	1f 4f       	sbci	r17, 0xFF	; 255
    5410:	bc 01       	movw	r22, r24
    5412:	cd 01       	movw	r24, r26
    5414:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5418:	dc 01       	movw	r26, r24
    541a:	cb 01       	movw	r24, r22
    541c:	f8 01       	movw	r30, r16
    541e:	80 83       	st	Z, r24
    5420:	91 83       	std	Z+1, r25	; 0x01
    5422:	27 c0       	rjmp	.+78     	; 0x5472 <chb_set_state+0x5c4>
    5424:	ce 01       	movw	r24, r28
    5426:	8b 5b       	subi	r24, 0xBB	; 187
    5428:	9f 4f       	sbci	r25, 0xFF	; 255
    542a:	29 e1       	ldi	r18, 0x19	; 25
    542c:	30 e0       	ldi	r19, 0x00	; 0
    542e:	fc 01       	movw	r30, r24
    5430:	20 83       	st	Z, r18
    5432:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5434:	ce 01       	movw	r24, r28
    5436:	8b 5b       	subi	r24, 0xBB	; 187
    5438:	9f 4f       	sbci	r25, 0xFF	; 255
    543a:	fc 01       	movw	r30, r24
    543c:	80 81       	ld	r24, Z
    543e:	91 81       	ldd	r25, Z+1	; 0x01
    5440:	8c 01       	movw	r16, r24
    5442:	c8 01       	movw	r24, r16
    5444:	01 97       	sbiw	r24, 0x01	; 1
    5446:	f1 f7       	brne	.-4      	; 0x5444 <chb_set_state+0x596>
    5448:	8c 01       	movw	r16, r24
    544a:	ce 01       	movw	r24, r28
    544c:	8b 5b       	subi	r24, 0xBB	; 187
    544e:	9f 4f       	sbci	r25, 0xFF	; 255
    5450:	fc 01       	movw	r30, r24
    5452:	00 83       	st	Z, r16
    5454:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5456:	ce 01       	movw	r24, r28
    5458:	8d 5b       	subi	r24, 0xBD	; 189
    545a:	9f 4f       	sbci	r25, 0xFF	; 255
    545c:	9e 01       	movw	r18, r28
    545e:	2d 5b       	subi	r18, 0xBD	; 189
    5460:	3f 4f       	sbci	r19, 0xFF	; 255
    5462:	f9 01       	movw	r30, r18
    5464:	20 81       	ld	r18, Z
    5466:	31 81       	ldd	r19, Z+1	; 0x01
    5468:	21 50       	subi	r18, 0x01	; 1
    546a:	30 40       	sbci	r19, 0x00	; 0
    546c:	fc 01       	movw	r30, r24
    546e:	20 83       	st	Z, r18
    5470:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5472:	ce 01       	movw	r24, r28
    5474:	8d 5b       	subi	r24, 0xBD	; 189
    5476:	9f 4f       	sbci	r25, 0xFF	; 255
    5478:	fc 01       	movw	r30, r24
    547a:	80 81       	ld	r24, Z
    547c:	91 81       	ldd	r25, Z+1	; 0x01
    547e:	00 97       	sbiw	r24, 0x00	; 0
    5480:	89 f6       	brne	.-94     	; 0x5424 <chb_set_state+0x576>
    5482:	4c c0       	rjmp	.+152    	; 0x551c <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5484:	8e 01       	movw	r16, r28
    5486:	0d 5b       	subi	r16, 0xBD	; 189
    5488:	1f 4f       	sbci	r17, 0xFF	; 255
    548a:	ce 01       	movw	r24, r28
    548c:	cf 96       	adiw	r24, 0x3f	; 63
    548e:	fc 01       	movw	r30, r24
    5490:	60 81       	ld	r22, Z
    5492:	71 81       	ldd	r23, Z+1	; 0x01
    5494:	82 81       	ldd	r24, Z+2	; 0x02
    5496:	93 81       	ldd	r25, Z+3	; 0x03
    5498:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    549c:	dc 01       	movw	r26, r24
    549e:	cb 01       	movw	r24, r22
    54a0:	f8 01       	movw	r30, r16
    54a2:	80 83       	st	Z, r24
    54a4:	91 83       	std	Z+1, r25	; 0x01
    54a6:	ce 01       	movw	r24, r28
    54a8:	89 5b       	subi	r24, 0xB9	; 185
    54aa:	9f 4f       	sbci	r25, 0xFF	; 255
    54ac:	9e 01       	movw	r18, r28
    54ae:	2d 5b       	subi	r18, 0xBD	; 189
    54b0:	3f 4f       	sbci	r19, 0xFF	; 255
    54b2:	f9 01       	movw	r30, r18
    54b4:	20 81       	ld	r18, Z
    54b6:	31 81       	ldd	r19, Z+1	; 0x01
    54b8:	fc 01       	movw	r30, r24
    54ba:	20 83       	st	Z, r18
    54bc:	31 83       	std	Z+1, r19	; 0x01
    54be:	ce 01       	movw	r24, r28
    54c0:	89 5b       	subi	r24, 0xB9	; 185
    54c2:	9f 4f       	sbci	r25, 0xFF	; 255
    54c4:	fc 01       	movw	r30, r24
    54c6:	80 81       	ld	r24, Z
    54c8:	91 81       	ldd	r25, Z+1	; 0x01
    54ca:	8c 01       	movw	r16, r24
    54cc:	c8 01       	movw	r24, r16
    54ce:	01 97       	sbiw	r24, 0x01	; 1
    54d0:	f1 f7       	brne	.-4      	; 0x54ce <chb_set_state+0x620>
    54d2:	8c 01       	movw	r16, r24
    54d4:	ce 01       	movw	r24, r28
    54d6:	89 5b       	subi	r24, 0xB9	; 185
    54d8:	9f 4f       	sbci	r25, 0xFF	; 255
    54da:	fc 01       	movw	r30, r24
    54dc:	00 83       	st	Z, r16
    54de:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    54e0:	20 c0       	rjmp	.+64     	; 0x5522 <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    54e2:	6e a9       	sts	0x4e, r22
    54e4:	7f a9       	sts	0x4f, r23
    54e6:	88 ad       	sts	0x68, r24
    54e8:	99 ad       	sts	0x69, r25
    54ea:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    54ee:	dc 01       	movw	r26, r24
    54f0:	cb 01       	movw	r24, r22
    54f2:	8a af       	sts	0x7a, r24
    54f4:	ce 01       	movw	r24, r28
    54f6:	87 5b       	subi	r24, 0xB7	; 183
    54f8:	9f 4f       	sbci	r25, 0xFF	; 255
    54fa:	2a ad       	sts	0x6a, r18
    54fc:	fc 01       	movw	r30, r24
    54fe:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5500:	ce 01       	movw	r24, r28
    5502:	87 5b       	subi	r24, 0xB7	; 183
    5504:	9f 4f       	sbci	r25, 0xFF	; 255
    5506:	fc 01       	movw	r30, r24
    5508:	80 81       	ld	r24, Z
    550a:	18 2f       	mov	r17, r24
    550c:	1a 95       	dec	r17
    550e:	f1 f7       	brne	.-4      	; 0x550c <chb_set_state+0x65e>
    5510:	ce 01       	movw	r24, r28
    5512:	87 5b       	subi	r24, 0xB7	; 183
    5514:	9f 4f       	sbci	r25, 0xFF	; 255
    5516:	fc 01       	movw	r30, r24
    5518:	10 83       	st	Z, r17
    551a:	03 c0       	rjmp	.+6      	; 0x5522 <chb_set_state+0x674>
    551c:	02 c0       	rjmp	.+4      	; 0x5522 <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    551e:	00 00       	nop
    5520:	01 c0       	rjmp	.+2      	; 0x5524 <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5522:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    5524:	9e 01       	movw	r18, r28
    5526:	2e 59       	subi	r18, 0x9E	; 158
    5528:	3f 4f       	sbci	r19, 0xFF	; 255
    552a:	82 e0       	ldi	r24, 0x02	; 2
    552c:	f9 01       	movw	r30, r18
    552e:	60 81       	ld	r22, Z
    5530:	4f e1       	ldi	r20, 0x1F	; 31
    5532:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
    5536:	9e 01       	movw	r18, r28
    5538:	26 5b       	subi	r18, 0xB6	; 182
    553a:	3f 4f       	sbci	r19, 0xFF	; 255
    553c:	80 e0       	ldi	r24, 0x00	; 0
    553e:	90 e0       	ldi	r25, 0x00	; 0
    5540:	ac ed       	ldi	r26, 0xDC	; 220
    5542:	b2 e4       	ldi	r27, 0x42	; 66
    5544:	f9 01       	movw	r30, r18
    5546:	80 83       	st	Z, r24
    5548:	91 83       	std	Z+1, r25	; 0x01
    554a:	a2 83       	std	Z+2, r26	; 0x02
    554c:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    554e:	8e 01       	movw	r16, r28
    5550:	02 5b       	subi	r16, 0xB2	; 178
    5552:	1f 4f       	sbci	r17, 0xFF	; 255
    5554:	ce 01       	movw	r24, r28
    5556:	86 5b       	subi	r24, 0xB6	; 182
    5558:	9f 4f       	sbci	r25, 0xFF	; 255
    555a:	fc 01       	movw	r30, r24
    555c:	60 81       	ld	r22, Z
    555e:	71 81       	ldd	r23, Z+1	; 0x01
    5560:	82 81       	ldd	r24, Z+2	; 0x02
    5562:	93 81       	ldd	r25, Z+3	; 0x03
    5564:	2b ea       	ldi	r18, 0xAB	; 171
    5566:	3a ea       	ldi	r19, 0xAA	; 170
    5568:	4a ea       	ldi	r20, 0xAA	; 170
    556a:	5e e3       	ldi	r21, 0x3E	; 62
    556c:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5570:	dc 01       	movw	r26, r24
    5572:	cb 01       	movw	r24, r22
    5574:	f8 01       	movw	r30, r16
    5576:	80 83       	st	Z, r24
    5578:	91 83       	std	Z+1, r25	; 0x01
    557a:	a2 83       	std	Z+2, r26	; 0x02
    557c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    557e:	ce 01       	movw	r24, r28
    5580:	82 5b       	subi	r24, 0xB2	; 178
    5582:	9f 4f       	sbci	r25, 0xFF	; 255
    5584:	11 e0       	ldi	r17, 0x01	; 1
    5586:	fc 01       	movw	r30, r24
    5588:	60 81       	ld	r22, Z
    558a:	71 81       	ldd	r23, Z+1	; 0x01
    558c:	82 81       	ldd	r24, Z+2	; 0x02
    558e:	93 81       	ldd	r25, Z+3	; 0x03
    5590:	20 e0       	ldi	r18, 0x00	; 0
    5592:	30 e0       	ldi	r19, 0x00	; 0
    5594:	40 e8       	ldi	r20, 0x80	; 128
    5596:	5f e3       	ldi	r21, 0x3F	; 63
    5598:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    559c:	88 23       	and	r24, r24
    559e:	0c f0       	brlt	.+2      	; 0x55a2 <chb_set_state+0x6f4>
    55a0:	10 e0       	ldi	r17, 0x00	; 0
    55a2:	11 23       	and	r17, r17
    55a4:	39 f0       	breq	.+14     	; 0x55b4 <chb_set_state+0x706>
		__ticks = 1;
    55a6:	ce 01       	movw	r24, r28
    55a8:	8e 5a       	subi	r24, 0xAE	; 174
    55aa:	9f 4f       	sbci	r25, 0xFF	; 255
    55ac:	21 e0       	ldi	r18, 0x01	; 1
    55ae:	fc 01       	movw	r30, r24
    55b0:	20 83       	st	Z, r18
    55b2:	05 c1       	rjmp	.+522    	; 0x57be <chb_set_state+0x910>
	else if (__tmp > 255)
    55b4:	ce 01       	movw	r24, r28
    55b6:	82 5b       	subi	r24, 0xB2	; 178
    55b8:	9f 4f       	sbci	r25, 0xFF	; 255
    55ba:	11 e0       	ldi	r17, 0x01	; 1
    55bc:	fc 01       	movw	r30, r24
    55be:	60 81       	ld	r22, Z
    55c0:	71 81       	ldd	r23, Z+1	; 0x01
    55c2:	82 81       	ldd	r24, Z+2	; 0x02
    55c4:	93 81       	ldd	r25, Z+3	; 0x03
    55c6:	20 e0       	ldi	r18, 0x00	; 0
    55c8:	30 e0       	ldi	r19, 0x00	; 0
    55ca:	4f e7       	ldi	r20, 0x7F	; 127
    55cc:	53 e4       	ldi	r21, 0x43	; 67
    55ce:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    55d2:	18 16       	cp	r1, r24
    55d4:	0c f0       	brlt	.+2      	; 0x55d8 <chb_set_state+0x72a>
    55d6:	10 e0       	ldi	r17, 0x00	; 0
    55d8:	11 23       	and	r17, r17
    55da:	09 f4       	brne	.+2      	; 0x55de <chb_set_state+0x730>
    55dc:	df c0       	rjmp	.+446    	; 0x579c <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    55de:	ce 01       	movw	r24, r28
    55e0:	86 5b       	subi	r24, 0xB6	; 182
    55e2:	9f 4f       	sbci	r25, 0xFF	; 255
    55e4:	fc 01       	movw	r30, r24
    55e6:	60 81       	ld	r22, Z
    55e8:	71 81       	ldd	r23, Z+1	; 0x01
    55ea:	82 81       	ldd	r24, Z+2	; 0x02
    55ec:	93 81       	ldd	r25, Z+3	; 0x03
    55ee:	20 e0       	ldi	r18, 0x00	; 0
    55f0:	30 e0       	ldi	r19, 0x00	; 0
    55f2:	4a e7       	ldi	r20, 0x7A	; 122
    55f4:	54 e4       	ldi	r21, 0x44	; 68
    55f6:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    55fa:	dc 01       	movw	r26, r24
    55fc:	cb 01       	movw	r24, r22
    55fe:	9e 01       	movw	r18, r28
    5600:	2d 5a       	subi	r18, 0xAD	; 173
    5602:	3f 4f       	sbci	r19, 0xFF	; 255
    5604:	f9 01       	movw	r30, r18
    5606:	80 83       	st	Z, r24
    5608:	91 83       	std	Z+1, r25	; 0x01
    560a:	a2 83       	std	Z+2, r26	; 0x02
    560c:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    560e:	8e 01       	movw	r16, r28
    5610:	09 5a       	subi	r16, 0xA9	; 169
    5612:	1f 4f       	sbci	r17, 0xFF	; 255
    5614:	ce 01       	movw	r24, r28
    5616:	8d 5a       	subi	r24, 0xAD	; 173
    5618:	9f 4f       	sbci	r25, 0xFF	; 255
    561a:	fc 01       	movw	r30, r24
    561c:	60 81       	ld	r22, Z
    561e:	71 81       	ldd	r23, Z+1	; 0x01
    5620:	82 81       	ldd	r24, Z+2	; 0x02
    5622:	93 81       	ldd	r25, Z+3	; 0x03
    5624:	20 e0       	ldi	r18, 0x00	; 0
    5626:	30 e0       	ldi	r19, 0x00	; 0
    5628:	4a e7       	ldi	r20, 0x7A	; 122
    562a:	53 e4       	ldi	r21, 0x43	; 67
    562c:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5630:	dc 01       	movw	r26, r24
    5632:	cb 01       	movw	r24, r22
    5634:	f8 01       	movw	r30, r16
    5636:	80 83       	st	Z, r24
    5638:	91 83       	std	Z+1, r25	; 0x01
    563a:	a2 83       	std	Z+2, r26	; 0x02
    563c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    563e:	ce 01       	movw	r24, r28
    5640:	89 5a       	subi	r24, 0xA9	; 169
    5642:	9f 4f       	sbci	r25, 0xFF	; 255
    5644:	11 e0       	ldi	r17, 0x01	; 1
    5646:	fc 01       	movw	r30, r24
    5648:	60 81       	ld	r22, Z
    564a:	71 81       	ldd	r23, Z+1	; 0x01
    564c:	82 81       	ldd	r24, Z+2	; 0x02
    564e:	93 81       	ldd	r25, Z+3	; 0x03
    5650:	20 e0       	ldi	r18, 0x00	; 0
    5652:	30 e0       	ldi	r19, 0x00	; 0
    5654:	40 e8       	ldi	r20, 0x80	; 128
    5656:	5f e3       	ldi	r21, 0x3F	; 63
    5658:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    565c:	88 23       	and	r24, r24
    565e:	0c f0       	brlt	.+2      	; 0x5662 <chb_set_state+0x7b4>
    5660:	10 e0       	ldi	r17, 0x00	; 0
    5662:	11 23       	and	r17, r17
    5664:	49 f0       	breq	.+18     	; 0x5678 <chb_set_state+0x7ca>
		__ticks = 1;
    5666:	ce 01       	movw	r24, r28
    5668:	85 5a       	subi	r24, 0xA5	; 165
    566a:	9f 4f       	sbci	r25, 0xFF	; 255
    566c:	21 e0       	ldi	r18, 0x01	; 1
    566e:	30 e0       	ldi	r19, 0x00	; 0
    5670:	fc 01       	movw	r30, r24
    5672:	20 83       	st	Z, r18
    5674:	31 83       	std	Z+1, r19	; 0x01
    5676:	74 c0       	rjmp	.+232    	; 0x5760 <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    5678:	ce 01       	movw	r24, r28
    567a:	89 5a       	subi	r24, 0xA9	; 169
    567c:	9f 4f       	sbci	r25, 0xFF	; 255
    567e:	11 e0       	ldi	r17, 0x01	; 1
    5680:	fc 01       	movw	r30, r24
    5682:	60 81       	ld	r22, Z
    5684:	71 81       	ldd	r23, Z+1	; 0x01
    5686:	82 81       	ldd	r24, Z+2	; 0x02
    5688:	93 81       	ldd	r25, Z+3	; 0x03
    568a:	20 e0       	ldi	r18, 0x00	; 0
    568c:	3f ef       	ldi	r19, 0xFF	; 255
    568e:	4f e7       	ldi	r20, 0x7F	; 127
    5690:	57 e4       	ldi	r21, 0x47	; 71
    5692:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    5696:	18 16       	cp	r1, r24
    5698:	0c f0       	brlt	.+2      	; 0x569c <chb_set_state+0x7ee>
    569a:	10 e0       	ldi	r17, 0x00	; 0
    569c:	11 23       	and	r17, r17
    569e:	09 f4       	brne	.+2      	; 0x56a2 <chb_set_state+0x7f4>
    56a0:	4d c0       	rjmp	.+154    	; 0x573c <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    56a2:	ce 01       	movw	r24, r28
    56a4:	8d 5a       	subi	r24, 0xAD	; 173
    56a6:	9f 4f       	sbci	r25, 0xFF	; 255
    56a8:	fc 01       	movw	r30, r24
    56aa:	60 81       	ld	r22, Z
    56ac:	71 81       	ldd	r23, Z+1	; 0x01
    56ae:	82 81       	ldd	r24, Z+2	; 0x02
    56b0:	93 81       	ldd	r25, Z+3	; 0x03
    56b2:	20 e0       	ldi	r18, 0x00	; 0
    56b4:	30 e0       	ldi	r19, 0x00	; 0
    56b6:	40 e2       	ldi	r20, 0x20	; 32
    56b8:	51 e4       	ldi	r21, 0x41	; 65
    56ba:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    56be:	dc 01       	movw	r26, r24
    56c0:	cb 01       	movw	r24, r22
    56c2:	8e 01       	movw	r16, r28
    56c4:	05 5a       	subi	r16, 0xA5	; 165
    56c6:	1f 4f       	sbci	r17, 0xFF	; 255
    56c8:	bc 01       	movw	r22, r24
    56ca:	cd 01       	movw	r24, r26
    56cc:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    56d0:	dc 01       	movw	r26, r24
    56d2:	cb 01       	movw	r24, r22
    56d4:	f8 01       	movw	r30, r16
    56d6:	80 83       	st	Z, r24
    56d8:	91 83       	std	Z+1, r25	; 0x01
    56da:	27 c0       	rjmp	.+78     	; 0x572a <chb_set_state+0x87c>
    56dc:	ce 01       	movw	r24, r28
    56de:	83 5a       	subi	r24, 0xA3	; 163
    56e0:	9f 4f       	sbci	r25, 0xFF	; 255
    56e2:	29 e1       	ldi	r18, 0x19	; 25
    56e4:	30 e0       	ldi	r19, 0x00	; 0
    56e6:	fc 01       	movw	r30, r24
    56e8:	20 83       	st	Z, r18
    56ea:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    56ec:	ce 01       	movw	r24, r28
    56ee:	83 5a       	subi	r24, 0xA3	; 163
    56f0:	9f 4f       	sbci	r25, 0xFF	; 255
    56f2:	fc 01       	movw	r30, r24
    56f4:	80 81       	ld	r24, Z
    56f6:	91 81       	ldd	r25, Z+1	; 0x01
    56f8:	8c 01       	movw	r16, r24
    56fa:	c8 01       	movw	r24, r16
    56fc:	01 97       	sbiw	r24, 0x01	; 1
    56fe:	f1 f7       	brne	.-4      	; 0x56fc <chb_set_state+0x84e>
    5700:	8c 01       	movw	r16, r24
    5702:	ce 01       	movw	r24, r28
    5704:	83 5a       	subi	r24, 0xA3	; 163
    5706:	9f 4f       	sbci	r25, 0xFF	; 255
    5708:	fc 01       	movw	r30, r24
    570a:	00 83       	st	Z, r16
    570c:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    570e:	ce 01       	movw	r24, r28
    5710:	85 5a       	subi	r24, 0xA5	; 165
    5712:	9f 4f       	sbci	r25, 0xFF	; 255
    5714:	9e 01       	movw	r18, r28
    5716:	25 5a       	subi	r18, 0xA5	; 165
    5718:	3f 4f       	sbci	r19, 0xFF	; 255
    571a:	f9 01       	movw	r30, r18
    571c:	20 81       	ld	r18, Z
    571e:	31 81       	ldd	r19, Z+1	; 0x01
    5720:	21 50       	subi	r18, 0x01	; 1
    5722:	30 40       	sbci	r19, 0x00	; 0
    5724:	fc 01       	movw	r30, r24
    5726:	20 83       	st	Z, r18
    5728:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    572a:	ce 01       	movw	r24, r28
    572c:	85 5a       	subi	r24, 0xA5	; 165
    572e:	9f 4f       	sbci	r25, 0xFF	; 255
    5730:	fc 01       	movw	r30, r24
    5732:	80 81       	ld	r24, Z
    5734:	91 81       	ldd	r25, Z+1	; 0x01
    5736:	00 97       	sbiw	r24, 0x00	; 0
    5738:	89 f6       	brne	.-94     	; 0x56dc <chb_set_state+0x82e>
    573a:	58 c0       	rjmp	.+176    	; 0x57ec <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    573c:	8e 01       	movw	r16, r28
    573e:	05 5a       	subi	r16, 0xA5	; 165
    5740:	1f 4f       	sbci	r17, 0xFF	; 255
    5742:	ce 01       	movw	r24, r28
    5744:	89 5a       	subi	r24, 0xA9	; 169
    5746:	9f 4f       	sbci	r25, 0xFF	; 255
    5748:	fc 01       	movw	r30, r24
    574a:	60 81       	ld	r22, Z
    574c:	71 81       	ldd	r23, Z+1	; 0x01
    574e:	82 81       	ldd	r24, Z+2	; 0x02
    5750:	93 81       	ldd	r25, Z+3	; 0x03
    5752:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5756:	dc 01       	movw	r26, r24
    5758:	cb 01       	movw	r24, r22
    575a:	f8 01       	movw	r30, r16
    575c:	80 83       	st	Z, r24
    575e:	91 83       	std	Z+1, r25	; 0x01
    5760:	ce 01       	movw	r24, r28
    5762:	81 5a       	subi	r24, 0xA1	; 161
    5764:	9f 4f       	sbci	r25, 0xFF	; 255
    5766:	9e 01       	movw	r18, r28
    5768:	25 5a       	subi	r18, 0xA5	; 165
    576a:	3f 4f       	sbci	r19, 0xFF	; 255
    576c:	f9 01       	movw	r30, r18
    576e:	20 81       	ld	r18, Z
    5770:	31 81       	ldd	r19, Z+1	; 0x01
    5772:	fc 01       	movw	r30, r24
    5774:	20 83       	st	Z, r18
    5776:	31 83       	std	Z+1, r19	; 0x01
    5778:	ce 01       	movw	r24, r28
    577a:	81 5a       	subi	r24, 0xA1	; 161
    577c:	9f 4f       	sbci	r25, 0xFF	; 255
    577e:	fc 01       	movw	r30, r24
    5780:	80 81       	ld	r24, Z
    5782:	91 81       	ldd	r25, Z+1	; 0x01
    5784:	8c 01       	movw	r16, r24
    5786:	c8 01       	movw	r24, r16
    5788:	01 97       	sbiw	r24, 0x01	; 1
    578a:	f1 f7       	brne	.-4      	; 0x5788 <chb_set_state+0x8da>
    578c:	8c 01       	movw	r16, r24
    578e:	ce 01       	movw	r24, r28
    5790:	81 5a       	subi	r24, 0xA1	; 161
    5792:	9f 4f       	sbci	r25, 0xFF	; 255
    5794:	fc 01       	movw	r30, r24
    5796:	00 83       	st	Z, r16
    5798:	11 83       	std	Z+1, r17	; 0x01
    579a:	28 c0       	rjmp	.+80     	; 0x57ec <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    579c:	8e 01       	movw	r16, r28
    579e:	0e 5a       	subi	r16, 0xAE	; 174
    57a0:	1f 4f       	sbci	r17, 0xFF	; 255
    57a2:	ce 01       	movw	r24, r28
    57a4:	82 5b       	subi	r24, 0xB2	; 178
    57a6:	9f 4f       	sbci	r25, 0xFF	; 255
    57a8:	fc 01       	movw	r30, r24
    57aa:	60 81       	ld	r22, Z
    57ac:	71 81       	ldd	r23, Z+1	; 0x01
    57ae:	82 81       	ldd	r24, Z+2	; 0x02
    57b0:	93 81       	ldd	r25, Z+3	; 0x03
    57b2:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    57b6:	dc 01       	movw	r26, r24
    57b8:	cb 01       	movw	r24, r22
    57ba:	f8 01       	movw	r30, r16
    57bc:	80 83       	st	Z, r24
    57be:	ce 01       	movw	r24, r28
    57c0:	8f 59       	subi	r24, 0x9F	; 159
    57c2:	9f 4f       	sbci	r25, 0xFF	; 255
    57c4:	9e 01       	movw	r18, r28
    57c6:	2e 5a       	subi	r18, 0xAE	; 174
    57c8:	3f 4f       	sbci	r19, 0xFF	; 255
    57ca:	f9 01       	movw	r30, r18
    57cc:	20 81       	ld	r18, Z
    57ce:	fc 01       	movw	r30, r24
    57d0:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    57d2:	ce 01       	movw	r24, r28
    57d4:	8f 59       	subi	r24, 0x9F	; 159
    57d6:	9f 4f       	sbci	r25, 0xFF	; 255
    57d8:	fc 01       	movw	r30, r24
    57da:	80 81       	ld	r24, Z
    57dc:	18 2f       	mov	r17, r24
    57de:	1a 95       	dec	r17
    57e0:	f1 f7       	brne	.-4      	; 0x57de <chb_set_state+0x930>
    57e2:	ce 01       	movw	r24, r28
    57e4:	8f 59       	subi	r24, 0x9F	; 159
    57e6:	9f 4f       	sbci	r25, 0xFF	; 255
    57e8:	fc 01       	movw	r30, r24
    57ea:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    57ec:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_get_state>
    57f0:	28 2f       	mov	r18, r24
    57f2:	ce 01       	movw	r24, r28
    57f4:	8e 59       	subi	r24, 0x9E	; 158
    57f6:	9f 4f       	sbci	r25, 0xFF	; 255
    57f8:	fc 01       	movw	r30, r24
    57fa:	80 81       	ld	r24, Z
    57fc:	28 17       	cp	r18, r24
    57fe:	11 f4       	brne	.+4      	; 0x5804 <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5800:	80 e4       	ldi	r24, 0x40	; 64
    5802:	01 c0       	rjmp	.+2      	; 0x5806 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    5804:	83 e4       	ldi	r24, 0x43	; 67
}
    5806:	ce 59       	subi	r28, 0x9E	; 158
    5808:	df 4f       	sbci	r29, 0xFF	; 255
    580a:	cd bf       	out	0x3d, r28	; 61
    580c:	de bf       	out	0x3e, r29	; 62
    580e:	df 91       	pop	r29
    5810:	cf 91       	pop	r28
    5812:	1f 91       	pop	r17
    5814:	0f 91       	pop	r16
    5816:	08 95       	ret

00005818 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5818:	cf 93       	push	r28
    581a:	df 93       	push	r29
    581c:	0f 92       	push	r0
    581e:	0f 92       	push	r0
    5820:	cd b7       	in	r28, 0x3d	; 61
    5822:	de b7       	in	r29, 0x3e	; 62
    5824:	89 83       	std	Y+1, r24	; 0x01
    5826:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5828:	29 81       	ldd	r18, Y+1	; 0x01
    582a:	3a 81       	ldd	r19, Y+2	; 0x02
    582c:	80 e0       	ldi	r24, 0x00	; 0
    582e:	90 e0       	ldi	r25, 0x00	; 0
    5830:	b9 01       	movw	r22, r18
    5832:	48 e0       	ldi	r20, 0x08	; 8
    5834:	50 e0       	ldi	r21, 0x00	; 0
    5836:	0e 94 6f 30 	call	0x60de	; 0x60de <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    583a:	29 81       	ldd	r18, Y+1	; 0x01
    583c:	3a 81       	ldd	r19, Y+2	; 0x02
    583e:	84 e2       	ldi	r24, 0x24	; 36
    5840:	b9 01       	movw	r22, r18
    5842:	0e 94 bb 24 	call	0x4976	; 0x4976 <chb_reg_write64>
}
    5846:	0f 90       	pop	r0
    5848:	0f 90       	pop	r0
    584a:	df 91       	pop	r29
    584c:	cf 91       	pop	r28
    584e:	08 95       	ret

00005850 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5850:	cf 93       	push	r28
    5852:	df 93       	push	r29
    5854:	0f 92       	push	r0
    5856:	0f 92       	push	r0
    5858:	cd b7       	in	r28, 0x3d	; 61
    585a:	de b7       	in	r29, 0x3e	; 62
    585c:	89 83       	std	Y+1, r24	; 0x01
    585e:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5860:	29 81       	ldd	r18, Y+1	; 0x01
    5862:	3a 81       	ldd	r19, Y+2	; 0x02
    5864:	80 e0       	ldi	r24, 0x00	; 0
    5866:	90 e0       	ldi	r25, 0x00	; 0
    5868:	b9 01       	movw	r22, r18
    586a:	48 e0       	ldi	r20, 0x08	; 8
    586c:	50 e0       	ldi	r21, 0x00	; 0
    586e:	0e 94 ab 30 	call	0x6156	; 0x6156 <chb_eeprom_read>
}
    5872:	0f 90       	pop	r0
    5874:	0f 90       	pop	r0
    5876:	df 91       	pop	r29
    5878:	cf 91       	pop	r28
    587a:	08 95       	ret

0000587c <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    587c:	cf 93       	push	r28
    587e:	df 93       	push	r29
    5880:	00 d0       	rcall	.+0      	; 0x5882 <chb_set_short_addr+0x6>
    5882:	00 d0       	rcall	.+0      	; 0x5884 <chb_set_short_addr+0x8>
    5884:	cd b7       	in	r28, 0x3d	; 61
    5886:	de b7       	in	r29, 0x3e	; 62
    5888:	8d 83       	std	Y+5, r24	; 0x05
    588a:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    588c:	ce 01       	movw	r24, r28
    588e:	05 96       	adiw	r24, 0x05	; 5
    5890:	89 83       	std	Y+1, r24	; 0x01
    5892:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    5894:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <chb_get_pcb>
    5898:	8b 83       	std	Y+3, r24	; 0x03
    589a:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    589c:	29 81       	ldd	r18, Y+1	; 0x01
    589e:	3a 81       	ldd	r19, Y+2	; 0x02
    58a0:	89 e0       	ldi	r24, 0x09	; 9
    58a2:	90 e0       	ldi	r25, 0x00	; 0
    58a4:	b9 01       	movw	r22, r18
    58a6:	42 e0       	ldi	r20, 0x02	; 2
    58a8:	50 e0       	ldi	r21, 0x00	; 0
    58aa:	0e 94 6f 30 	call	0x60de	; 0x60de <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    58ae:	2d 81       	ldd	r18, Y+5	; 0x05
    58b0:	3e 81       	ldd	r19, Y+6	; 0x06
    58b2:	80 e2       	ldi	r24, 0x20	; 32
    58b4:	b9 01       	movw	r22, r18
    58b6:	0e 94 8a 24 	call	0x4914	; 0x4914 <chb_reg_write16>
    pcb->src_addr = addr;
    58ba:	2d 81       	ldd	r18, Y+5	; 0x05
    58bc:	3e 81       	ldd	r19, Y+6	; 0x06
    58be:	8b 81       	ldd	r24, Y+3	; 0x03
    58c0:	9c 81       	ldd	r25, Y+4	; 0x04
    58c2:	fc 01       	movw	r30, r24
    58c4:	20 83       	st	Z, r18
    58c6:	31 83       	std	Z+1, r19	; 0x01
}
    58c8:	26 96       	adiw	r28, 0x06	; 6
    58ca:	cd bf       	out	0x3d, r28	; 61
    58cc:	de bf       	out	0x3e, r29	; 62
    58ce:	df 91       	pop	r29
    58d0:	cf 91       	pop	r28
    58d2:	08 95       	ret

000058d4 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    58d4:	cf 93       	push	r28
    58d6:	df 93       	push	r29
    58d8:	0f 92       	push	r0
    58da:	0f 92       	push	r0
    58dc:	cd b7       	in	r28, 0x3d	; 61
    58de:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    58e0:	89 e0       	ldi	r24, 0x09	; 9
    58e2:	90 e0       	ldi	r25, 0x00	; 0
    58e4:	9e 01       	movw	r18, r28
    58e6:	2f 5f       	subi	r18, 0xFF	; 255
    58e8:	3f 4f       	sbci	r19, 0xFF	; 255
    58ea:	b9 01       	movw	r22, r18
    58ec:	42 e0       	ldi	r20, 0x02	; 2
    58ee:	50 e0       	ldi	r21, 0x00	; 0
    58f0:	0e 94 ab 30 	call	0x6156	; 0x6156 <chb_eeprom_read>
    return *(U16 *)addr;
    58f4:	ce 01       	movw	r24, r28
    58f6:	01 96       	adiw	r24, 0x01	; 1
    58f8:	fc 01       	movw	r30, r24
    58fa:	80 81       	ld	r24, Z
    58fc:	91 81       	ldd	r25, Z+1	; 0x01
}
    58fe:	0f 90       	pop	r0
    5900:	0f 90       	pop	r0
    5902:	df 91       	pop	r29
    5904:	cf 91       	pop	r28
    5906:	08 95       	ret

00005908 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5908:	cf 93       	push	r28
    590a:	df 93       	push	r29
    590c:	cd b7       	in	r28, 0x3d	; 61
    590e:	de b7       	in	r29, 0x3e	; 62
    5910:	28 97       	sbiw	r28, 0x08	; 8
    5912:	cd bf       	out	0x3d, r28	; 61
    5914:	de bf       	out	0x3e, r29	; 62
    5916:	8c 83       	std	Y+4, r24	; 0x04
    5918:	9d 83       	std	Y+5, r25	; 0x05
    591a:	6e 83       	std	Y+6, r22	; 0x06
    591c:	7f 83       	std	Y+7, r23	; 0x07
    591e:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5920:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_get_state>
    5924:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5926:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <chb_get_pcb>
    592a:	8a 83       	std	Y+2, r24	; 0x02
    592c:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    592e:	89 81       	ldd	r24, Y+1	; 0x01
    5930:	82 30       	cpi	r24, 0x02	; 2
    5932:	19 f0       	breq	.+6      	; 0x593a <chb_tx+0x32>
    5934:	89 81       	ldd	r24, Y+1	; 0x01
    5936:	82 31       	cpi	r24, 0x12	; 18
    5938:	11 f4       	brne	.+4      	; 0x593e <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    593a:	84 e4       	ldi	r24, 0x44	; 68
    593c:	23 c0       	rjmp	.+70     	; 0x5984 <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    593e:	88 e0       	ldi	r24, 0x08	; 8
    5940:	0e 94 57 27 	call	0x4eae	; 0x4eae <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    5944:	89 e1       	ldi	r24, 0x19	; 25
    5946:	0e 94 57 27 	call	0x4eae	; 0x4eae <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    594a:	8c 81       	ldd	r24, Y+4	; 0x04
    594c:	9d 81       	ldd	r25, Y+5	; 0x05
    594e:	2e 81       	ldd	r18, Y+6	; 0x06
    5950:	3f 81       	ldd	r19, Y+7	; 0x07
    5952:	6a e0       	ldi	r22, 0x0A	; 10
    5954:	a9 01       	movw	r20, r18
    5956:	28 85       	ldd	r18, Y+8	; 0x08
    5958:	0e 94 08 25 	call	0x4a10	; 0x4a10 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    595c:	82 e0       	ldi	r24, 0x02	; 2
    595e:	62 e0       	ldi	r22, 0x02	; 2
    5960:	4f e1       	ldi	r20, 0x1F	; 31
    5962:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>

    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
    5966:	00 00       	nop
    5968:	8a 81       	ldd	r24, Y+2	; 0x02
    596a:	9b 81       	ldd	r25, Y+3	; 0x03
    596c:	fc 01       	movw	r30, r24
    596e:	94 81       	ldd	r25, Z+4	; 0x04
    5970:	81 e0       	ldi	r24, 0x01	; 1
    5972:	89 27       	eor	r24, r25
    5974:	88 23       	and	r24, r24
    5976:	c1 f7       	brne	.-16     	; 0x5968 <chb_tx+0x60>
    pcb->tx_end = false;
    5978:	8a 81       	ldd	r24, Y+2	; 0x02
    597a:	9b 81       	ldd	r25, Y+3	; 0x03
    597c:	fc 01       	movw	r30, r24
    597e:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5980:	0e 94 05 22 	call	0x440a	; 0x440a <chb_get_status>
}
    5984:	28 96       	adiw	r28, 0x08	; 8
    5986:	cd bf       	out	0x3d, r28	; 61
    5988:	de bf       	out	0x3e, r29	; 62
    598a:	df 91       	pop	r29
    598c:	cf 91       	pop	r28
    598e:	08 95       	ret

00005990 <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5990:	0f 93       	push	r16
    5992:	1f 93       	push	r17
    5994:	cf 93       	push	r28
    5996:	df 93       	push	r29
    5998:	cd b7       	in	r28, 0x3d	; 61
    599a:	de b7       	in	r29, 0x3e	; 62
    599c:	69 97       	sbiw	r28, 0x19	; 25
    599e:	cd bf       	out	0x3d, r28	; 61
    59a0:	de bf       	out	0x3e, r29	; 62
    59a2:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    59a4:	89 8d       	ldd	r24, Y+25	; 0x19
    59a6:	88 23       	and	r24, r24
    59a8:	69 f0       	breq	.+26     	; 0x59c4 <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    59aa:	88 e0       	ldi	r24, 0x08	; 8
    59ac:	0e 94 57 27 	call	0x4eae	; 0x4eae <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    59b0:	84 e6       	ldi	r24, 0x64	; 100
    59b2:	96 e0       	ldi	r25, 0x06	; 6
    59b4:	24 e6       	ldi	r18, 0x64	; 100
    59b6:	36 e0       	ldi	r19, 0x06	; 6
    59b8:	f9 01       	movw	r30, r18
    59ba:	20 81       	ld	r18, Z
    59bc:	22 60       	ori	r18, 0x02	; 2
    59be:	fc 01       	movw	r30, r24
    59c0:	20 83       	st	Z, r18
    59c2:	e1 c0       	rjmp	.+450    	; 0x5b86 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    59c4:	84 e6       	ldi	r24, 0x64	; 100
    59c6:	96 e0       	ldi	r25, 0x06	; 6
    59c8:	24 e6       	ldi	r18, 0x64	; 100
    59ca:	36 e0       	ldi	r19, 0x06	; 6
    59cc:	f9 01       	movw	r30, r18
    59ce:	20 81       	ld	r18, Z
    59d0:	2d 7f       	andi	r18, 0xFD	; 253
    59d2:	fc 01       	movw	r30, r24
    59d4:	20 83       	st	Z, r18
    59d6:	80 e0       	ldi	r24, 0x00	; 0
    59d8:	90 e0       	ldi	r25, 0x00	; 0
    59da:	a0 e7       	ldi	r26, 0x70	; 112
    59dc:	b3 e4       	ldi	r27, 0x43	; 67
    59de:	89 83       	std	Y+1, r24	; 0x01
    59e0:	9a 83       	std	Y+2, r25	; 0x02
    59e2:	ab 83       	std	Y+3, r26	; 0x03
    59e4:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    59e6:	69 81       	ldd	r22, Y+1	; 0x01
    59e8:	7a 81       	ldd	r23, Y+2	; 0x02
    59ea:	8b 81       	ldd	r24, Y+3	; 0x03
    59ec:	9c 81       	ldd	r25, Y+4	; 0x04
    59ee:	2b ea       	ldi	r18, 0xAB	; 171
    59f0:	3a ea       	ldi	r19, 0xAA	; 170
    59f2:	4a ea       	ldi	r20, 0xAA	; 170
    59f4:	5e e3       	ldi	r21, 0x3E	; 62
    59f6:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    59fa:	dc 01       	movw	r26, r24
    59fc:	cb 01       	movw	r24, r22
    59fe:	8d 83       	std	Y+5, r24	; 0x05
    5a00:	9e 83       	std	Y+6, r25	; 0x06
    5a02:	af 83       	std	Y+7, r26	; 0x07
    5a04:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5a06:	11 e0       	ldi	r17, 0x01	; 1
    5a08:	6d 81       	ldd	r22, Y+5	; 0x05
    5a0a:	7e 81       	ldd	r23, Y+6	; 0x06
    5a0c:	8f 81       	ldd	r24, Y+7	; 0x07
    5a0e:	98 85       	ldd	r25, Y+8	; 0x08
    5a10:	20 e0       	ldi	r18, 0x00	; 0
    5a12:	30 e0       	ldi	r19, 0x00	; 0
    5a14:	40 e8       	ldi	r20, 0x80	; 128
    5a16:	5f e3       	ldi	r21, 0x3F	; 63
    5a18:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    5a1c:	88 23       	and	r24, r24
    5a1e:	0c f0       	brlt	.+2      	; 0x5a22 <chb_sleep+0x92>
    5a20:	10 e0       	ldi	r17, 0x00	; 0
    5a22:	11 23       	and	r17, r17
    5a24:	19 f0       	breq	.+6      	; 0x5a2c <chb_sleep+0x9c>
		__ticks = 1;
    5a26:	81 e0       	ldi	r24, 0x01	; 1
    5a28:	89 87       	std	Y+9, r24	; 0x09
    5a2a:	a3 c0       	rjmp	.+326    	; 0x5b72 <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5a2c:	11 e0       	ldi	r17, 0x01	; 1
    5a2e:	6d 81       	ldd	r22, Y+5	; 0x05
    5a30:	7e 81       	ldd	r23, Y+6	; 0x06
    5a32:	8f 81       	ldd	r24, Y+7	; 0x07
    5a34:	98 85       	ldd	r25, Y+8	; 0x08
    5a36:	20 e0       	ldi	r18, 0x00	; 0
    5a38:	30 e0       	ldi	r19, 0x00	; 0
    5a3a:	4f e7       	ldi	r20, 0x7F	; 127
    5a3c:	53 e4       	ldi	r21, 0x43	; 67
    5a3e:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    5a42:	18 16       	cp	r1, r24
    5a44:	0c f0       	brlt	.+2      	; 0x5a48 <chb_sleep+0xb8>
    5a46:	10 e0       	ldi	r17, 0x00	; 0
    5a48:	11 23       	and	r17, r17
    5a4a:	09 f4       	brne	.+2      	; 0x5a4e <chb_sleep+0xbe>
    5a4c:	89 c0       	rjmp	.+274    	; 0x5b60 <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5a4e:	69 81       	ldd	r22, Y+1	; 0x01
    5a50:	7a 81       	ldd	r23, Y+2	; 0x02
    5a52:	8b 81       	ldd	r24, Y+3	; 0x03
    5a54:	9c 81       	ldd	r25, Y+4	; 0x04
    5a56:	20 e0       	ldi	r18, 0x00	; 0
    5a58:	30 e0       	ldi	r19, 0x00	; 0
    5a5a:	4a e7       	ldi	r20, 0x7A	; 122
    5a5c:	54 e4       	ldi	r21, 0x44	; 68
    5a5e:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    5a62:	dc 01       	movw	r26, r24
    5a64:	cb 01       	movw	r24, r22
    5a66:	8a 87       	std	Y+10, r24	; 0x0a
    5a68:	9b 87       	std	Y+11, r25	; 0x0b
    5a6a:	ac 87       	std	Y+12, r26	; 0x0c
    5a6c:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5a6e:	6a 85       	ldd	r22, Y+10	; 0x0a
    5a70:	7b 85       	ldd	r23, Y+11	; 0x0b
    5a72:	8c 85       	ldd	r24, Y+12	; 0x0c
    5a74:	9d 85       	ldd	r25, Y+13	; 0x0d
    5a76:	20 e0       	ldi	r18, 0x00	; 0
    5a78:	30 e0       	ldi	r19, 0x00	; 0
    5a7a:	4a e7       	ldi	r20, 0x7A	; 122
    5a7c:	53 e4       	ldi	r21, 0x43	; 67
    5a7e:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5a82:	dc 01       	movw	r26, r24
    5a84:	cb 01       	movw	r24, r22
    5a86:	8e 87       	std	Y+14, r24	; 0x0e
    5a88:	9f 87       	std	Y+15, r25	; 0x0f
    5a8a:	a8 8b       	std	Y+16, r26	; 0x10
    5a8c:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5a8e:	11 e0       	ldi	r17, 0x01	; 1
    5a90:	6e 85       	ldd	r22, Y+14	; 0x0e
    5a92:	7f 85       	ldd	r23, Y+15	; 0x0f
    5a94:	88 89       	ldd	r24, Y+16	; 0x10
    5a96:	99 89       	ldd	r25, Y+17	; 0x11
    5a98:	20 e0       	ldi	r18, 0x00	; 0
    5a9a:	30 e0       	ldi	r19, 0x00	; 0
    5a9c:	40 e8       	ldi	r20, 0x80	; 128
    5a9e:	5f e3       	ldi	r21, 0x3F	; 63
    5aa0:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    5aa4:	88 23       	and	r24, r24
    5aa6:	0c f0       	brlt	.+2      	; 0x5aaa <chb_sleep+0x11a>
    5aa8:	10 e0       	ldi	r17, 0x00	; 0
    5aaa:	11 23       	and	r17, r17
    5aac:	29 f0       	breq	.+10     	; 0x5ab8 <chb_sleep+0x128>
		__ticks = 1;
    5aae:	81 e0       	ldi	r24, 0x01	; 1
    5ab0:	90 e0       	ldi	r25, 0x00	; 0
    5ab2:	8a 8b       	std	Y+18, r24	; 0x12
    5ab4:	9b 8b       	std	Y+19, r25	; 0x13
    5ab6:	46 c0       	rjmp	.+140    	; 0x5b44 <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5ab8:	11 e0       	ldi	r17, 0x01	; 1
    5aba:	6e 85       	ldd	r22, Y+14	; 0x0e
    5abc:	7f 85       	ldd	r23, Y+15	; 0x0f
    5abe:	88 89       	ldd	r24, Y+16	; 0x10
    5ac0:	99 89       	ldd	r25, Y+17	; 0x11
    5ac2:	20 e0       	ldi	r18, 0x00	; 0
    5ac4:	3f ef       	ldi	r19, 0xFF	; 255
    5ac6:	4f e7       	ldi	r20, 0x7F	; 127
    5ac8:	57 e4       	ldi	r21, 0x47	; 71
    5aca:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    5ace:	18 16       	cp	r1, r24
    5ad0:	0c f0       	brlt	.+2      	; 0x5ad4 <chb_sleep+0x144>
    5ad2:	10 e0       	ldi	r17, 0x00	; 0
    5ad4:	11 23       	and	r17, r17
    5ad6:	61 f1       	breq	.+88     	; 0x5b30 <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5ad8:	6a 85       	ldd	r22, Y+10	; 0x0a
    5ada:	7b 85       	ldd	r23, Y+11	; 0x0b
    5adc:	8c 85       	ldd	r24, Y+12	; 0x0c
    5ade:	9d 85       	ldd	r25, Y+13	; 0x0d
    5ae0:	20 e0       	ldi	r18, 0x00	; 0
    5ae2:	30 e0       	ldi	r19, 0x00	; 0
    5ae4:	40 e2       	ldi	r20, 0x20	; 32
    5ae6:	51 e4       	ldi	r21, 0x41	; 65
    5ae8:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    5aec:	dc 01       	movw	r26, r24
    5aee:	cb 01       	movw	r24, r22
    5af0:	bc 01       	movw	r22, r24
    5af2:	cd 01       	movw	r24, r26
    5af4:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5af8:	dc 01       	movw	r26, r24
    5afa:	cb 01       	movw	r24, r22
    5afc:	8a 8b       	std	Y+18, r24	; 0x12
    5afe:	9b 8b       	std	Y+19, r25	; 0x13
    5b00:	12 c0       	rjmp	.+36     	; 0x5b26 <chb_sleep+0x196>
    5b02:	89 e1       	ldi	r24, 0x19	; 25
    5b04:	90 e0       	ldi	r25, 0x00	; 0
    5b06:	8c 8b       	std	Y+20, r24	; 0x14
    5b08:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5b0a:	8c 89       	ldd	r24, Y+20	; 0x14
    5b0c:	9d 89       	ldd	r25, Y+21	; 0x15
    5b0e:	8c 01       	movw	r16, r24
    5b10:	c8 01       	movw	r24, r16
    5b12:	01 97       	sbiw	r24, 0x01	; 1
    5b14:	f1 f7       	brne	.-4      	; 0x5b12 <chb_sleep+0x182>
    5b16:	8c 01       	movw	r16, r24
    5b18:	0c 8b       	std	Y+20, r16	; 0x14
    5b1a:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5b1c:	8a 89       	ldd	r24, Y+18	; 0x12
    5b1e:	9b 89       	ldd	r25, Y+19	; 0x13
    5b20:	01 97       	sbiw	r24, 0x01	; 1
    5b22:	8a 8b       	std	Y+18, r24	; 0x12
    5b24:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5b26:	8a 89       	ldd	r24, Y+18	; 0x12
    5b28:	9b 89       	ldd	r25, Y+19	; 0x13
    5b2a:	00 97       	sbiw	r24, 0x00	; 0
    5b2c:	51 f7       	brne	.-44     	; 0x5b02 <chb_sleep+0x172>
    5b2e:	28 c0       	rjmp	.+80     	; 0x5b80 <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5b30:	6e 85       	ldd	r22, Y+14	; 0x0e
    5b32:	7f 85       	ldd	r23, Y+15	; 0x0f
    5b34:	88 89       	ldd	r24, Y+16	; 0x10
    5b36:	99 89       	ldd	r25, Y+17	; 0x11
    5b38:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5b3c:	dc 01       	movw	r26, r24
    5b3e:	cb 01       	movw	r24, r22
    5b40:	8a 8b       	std	Y+18, r24	; 0x12
    5b42:	9b 8b       	std	Y+19, r25	; 0x13
    5b44:	8a 89       	ldd	r24, Y+18	; 0x12
    5b46:	9b 89       	ldd	r25, Y+19	; 0x13
    5b48:	8e 8b       	std	Y+22, r24	; 0x16
    5b4a:	9f 8b       	std	Y+23, r25	; 0x17
    5b4c:	8e 89       	ldd	r24, Y+22	; 0x16
    5b4e:	9f 89       	ldd	r25, Y+23	; 0x17
    5b50:	8c 01       	movw	r16, r24
    5b52:	f8 01       	movw	r30, r16
    5b54:	31 97       	sbiw	r30, 0x01	; 1
    5b56:	f1 f7       	brne	.-4      	; 0x5b54 <chb_sleep+0x1c4>
    5b58:	8f 01       	movw	r16, r30
    5b5a:	0e 8b       	std	Y+22, r16	; 0x16
    5b5c:	1f 8b       	std	Y+23, r17	; 0x17
    5b5e:	10 c0       	rjmp	.+32     	; 0x5b80 <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5b60:	6d 81       	ldd	r22, Y+5	; 0x05
    5b62:	7e 81       	ldd	r23, Y+6	; 0x06
    5b64:	8f 81       	ldd	r24, Y+7	; 0x07
    5b66:	98 85       	ldd	r25, Y+8	; 0x08
    5b68:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    5b6c:	dc 01       	movw	r26, r24
    5b6e:	cb 01       	movw	r24, r22
    5b70:	89 87       	std	Y+9, r24	; 0x09
    5b72:	89 85       	ldd	r24, Y+9	; 0x09
    5b74:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5b76:	88 8d       	ldd	r24, Y+24	; 0x18
    5b78:	18 2f       	mov	r17, r24
    5b7a:	1a 95       	dec	r17
    5b7c:	f1 f7       	brne	.-4      	; 0x5b7a <chb_sleep+0x1ea>
    5b7e:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5b80:	86 e1       	ldi	r24, 0x16	; 22
    5b82:	0e 94 57 27 	call	0x4eae	; 0x4eae <chb_set_state>
    }
}
    5b86:	69 96       	adiw	r28, 0x19	; 25
    5b88:	cd bf       	out	0x3d, r28	; 61
    5b8a:	de bf       	out	0x3e, r29	; 62
    5b8c:	df 91       	pop	r29
    5b8e:	cf 91       	pop	r28
    5b90:	1f 91       	pop	r17
    5b92:	0f 91       	pop	r16
    5b94:	08 95       	ret

00005b96 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5b96:	cf 93       	push	r28
    5b98:	df 93       	push	r29
    5b9a:	cd b7       	in	r28, 0x3d	; 61
    5b9c:	de b7       	in	r29, 0x3e	; 62
    5b9e:	ea 97       	sbiw	r28, 0x3a	; 58
    5ba0:	cd bf       	out	0x3d, r28	; 61
    5ba2:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5ba4:	0e 94 12 22 	call	0x4424	; 0x4424 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5ba8:	8e e0       	ldi	r24, 0x0E	; 14
    5baa:	60 e0       	ldi	r22, 0x00	; 0
    5bac:	0e 94 5e 24 	call	0x48bc	; 0x48bc <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5bb0:	82 e0       	ldi	r24, 0x02	; 2
    5bb2:	63 e0       	ldi	r22, 0x03	; 3
    5bb4:	4f e1       	ldi	r20, 0x1F	; 31
    5bb6:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5bba:	00 00       	nop
    5bbc:	81 e0       	ldi	r24, 0x01	; 1
    5bbe:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    5bc2:	88 2f       	mov	r24, r24
    5bc4:	90 e0       	ldi	r25, 0x00	; 0
    5bc6:	8f 71       	andi	r24, 0x1F	; 31
    5bc8:	90 70       	andi	r25, 0x00	; 0
    5bca:	88 30       	cpi	r24, 0x08	; 8
    5bcc:	91 05       	cpc	r25, r1
    5bce:	b1 f7       	brne	.-20     	; 0x5bbc <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5bd0:	8e e2       	ldi	r24, 0x2E	; 46
    5bd2:	60 e4       	ldi	r22, 0x40	; 64
    5bd4:	40 ec       	ldi	r20, 0xC0	; 192
    5bd6:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5bda:	8e e0       	ldi	r24, 0x0E	; 14
    5bdc:	6c e0       	ldi	r22, 0x0C	; 12
    5bde:	0e 94 5e 24 	call	0x48bc	; 0x48bc <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5be2:	84 e0       	ldi	r24, 0x04	; 4
    5be4:	60 e2       	ldi	r22, 0x20	; 32
    5be6:	40 e2       	ldi	r20, 0x20	; 32
    5be8:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5bec:	81 e0       	ldi	r24, 0x01	; 1
    5bee:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5bf2:	81 e0       	ldi	r24, 0x01	; 1
    5bf4:	0e 94 42 26 	call	0x4c84	; 0x4c84 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5bf8:	86 e1       	ldi	r24, 0x16	; 22
    5bfa:	0e 94 57 27 	call	0x4eae	; 0x4eae <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5bfe:	82 e2       	ldi	r24, 0x22	; 34
    5c00:	64 e3       	ldi	r22, 0x34	; 52
    5c02:	72 e1       	ldi	r23, 0x12	; 18
    5c04:	0e 94 8a 24 	call	0x4914	; 0x4914 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5c08:	0e 94 6a 2c 	call	0x58d4	; 0x58d4 <chb_get_short_addr>
    5c0c:	9c 01       	movw	r18, r24
    5c0e:	80 e2       	ldi	r24, 0x20	; 32
    5c10:	b9 01       	movw	r22, r18
    5c12:	0e 94 8a 24 	call	0x4914	; 0x4914 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5c16:	ce 01       	movw	r24, r28
    5c18:	01 96       	adiw	r24, 0x01	; 1
    5c1a:	0e 94 28 2c 	call	0x5850	; 0x5850 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5c1e:	84 e2       	ldi	r24, 0x24	; 36
    5c20:	9e 01       	movw	r18, r28
    5c22:	2f 5f       	subi	r18, 0xFF	; 255
    5c24:	3f 4f       	sbci	r19, 0xFF	; 255
    5c26:	b9 01       	movw	r22, r18
    5c28:	0e 94 bb 24 	call	0x4976	; 0x4976 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5c2c:	82 e7       	ldi	r24, 0x72	; 114
    5c2e:	96 e0       	ldi	r25, 0x06	; 6
    5c30:	22 e7       	ldi	r18, 0x72	; 114
    5c32:	36 e0       	ldi	r19, 0x06	; 6
    5c34:	f9 01       	movw	r30, r18
    5c36:	20 81       	ld	r18, Z
    5c38:	21 60       	ori	r18, 0x01	; 1
    5c3a:	fc 01       	movw	r30, r24
    5c3c:	20 83       	st	Z, r18
    5c3e:	89 e6       	ldi	r24, 0x69	; 105
    5c40:	96 e0       	ldi	r25, 0x06	; 6
    5c42:	29 e6       	ldi	r18, 0x69	; 105
    5c44:	36 e0       	ldi	r19, 0x06	; 6
    5c46:	f9 01       	movw	r30, r18
    5c48:	20 81       	ld	r18, Z
    5c4a:	22 60       	ori	r18, 0x02	; 2
    5c4c:	fc 01       	movw	r30, r24
    5c4e:	20 83       	st	Z, r18
    5c50:	8a e6       	ldi	r24, 0x6A	; 106
    5c52:	96 e0       	ldi	r25, 0x06	; 6
    5c54:	2a e6       	ldi	r18, 0x6A	; 106
    5c56:	36 e0       	ldi	r19, 0x06	; 6
    5c58:	f9 01       	movw	r30, r18
    5c5a:	20 81       	ld	r18, Z
    5c5c:	24 60       	ori	r18, 0x04	; 4
    5c5e:	fc 01       	movw	r30, r24
    5c60:	20 83       	st	Z, r18
	PMIC.CTRL = 0x07;	//enable interrupts on MCU
    5c62:	80 ea       	ldi	r24, 0xA0	; 160
    5c64:	90 e0       	ldi	r25, 0x00	; 0
    5c66:	27 e0       	ldi	r18, 0x07	; 7
    5c68:	fc 01       	movw	r30, r24
    5c6a:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5c6c:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_get_state>
    5c70:	86 31       	cpi	r24, 0x16	; 22
    5c72:	b1 f0       	breq	.+44     	; 0x5ca0 <chb_radio_init+0x10a>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5c74:	ce 01       	movw	r24, r28
    5c76:	09 96       	adiw	r24, 0x09	; 9
    5c78:	2c e0       	ldi	r18, 0x0C	; 12
    5c7a:	32 e0       	ldi	r19, 0x02	; 2
    5c7c:	b9 01       	movw	r22, r18
    5c7e:	0e 94 03 5d 	call	0xba06	; 0xba06 <strcpy_P>
        printf(buf);
    5c82:	0f 92       	push	r0
    5c84:	0f 92       	push	r0
    5c86:	8d b7       	in	r24, 0x3d	; 61
    5c88:	9e b7       	in	r25, 0x3e	; 62
    5c8a:	01 96       	adiw	r24, 0x01	; 1
    5c8c:	9e 01       	movw	r18, r28
    5c8e:	27 5f       	subi	r18, 0xF7	; 247
    5c90:	3f 4f       	sbci	r19, 0xFF	; 255
    5c92:	fc 01       	movw	r30, r24
    5c94:	20 83       	st	Z, r18
    5c96:	31 83       	std	Z+1, r19	; 0x01
    5c98:	0e 94 1c 5d 	call	0xba38	; 0xba38 <printf>
    5c9c:	0f 90       	pop	r0
    5c9e:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5ca0:	10 92 b3 50 	sts	0x50B3, r1
    5ca4:	10 92 b4 50 	sts	0x50B4, r1
    5ca8:	10 92 b5 50 	sts	0x50B5, r1
    5cac:	10 92 b6 50 	sts	0x50B6, r1
}
    5cb0:	ea 96       	adiw	r28, 0x3a	; 58
    5cb2:	cd bf       	out	0x3d, r28	; 61
    5cb4:	de bf       	out	0x3e, r29	; 62
    5cb6:	df 91       	pop	r29
    5cb8:	cf 91       	pop	r28
    5cba:	08 95       	ret

00005cbc <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5cbc:	cf 93       	push	r28
    5cbe:	df 93       	push	r29
    5cc0:	cd b7       	in	r28, 0x3d	; 61
    5cc2:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5cc4:	0e 94 eb 30 	call	0x61d6	; 0x61d6 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5cc8:	80 e6       	ldi	r24, 0x60	; 96
    5cca:	96 e0       	ldi	r25, 0x06	; 6
    5ccc:	20 e6       	ldi	r18, 0x60	; 96
    5cce:	36 e0       	ldi	r19, 0x06	; 6
    5cd0:	f9 01       	movw	r30, r18
    5cd2:	20 81       	ld	r18, Z
    5cd4:	22 60       	ori	r18, 0x02	; 2
    5cd6:	fc 01       	movw	r30, r24
    5cd8:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5cda:	80 e6       	ldi	r24, 0x60	; 96
    5cdc:	96 e0       	ldi	r25, 0x06	; 6
    5cde:	20 e6       	ldi	r18, 0x60	; 96
    5ce0:	36 e0       	ldi	r19, 0x06	; 6
    5ce2:	f9 01       	movw	r30, r18
    5ce4:	20 81       	ld	r18, Z
    5ce6:	21 60       	ori	r18, 0x01	; 1
    5ce8:	fc 01       	movw	r30, r24
    5cea:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5cec:	0e 94 cb 2d 	call	0x5b96	; 0x5b96 <chb_radio_init>
}
    5cf0:	df 91       	pop	r29
    5cf2:	cf 91       	pop	r28
    5cf4:	08 95       	ret

00005cf6 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5cf6:	1f 92       	push	r1
    5cf8:	0f 92       	push	r0
    5cfa:	0f b6       	in	r0, 0x3f	; 63
    5cfc:	0f 92       	push	r0
    5cfe:	00 90 3b 00 	lds	r0, 0x003B
    5d02:	0f 92       	push	r0
    5d04:	11 24       	eor	r1, r1
    5d06:	2f 93       	push	r18
    5d08:	3f 93       	push	r19
    5d0a:	4f 93       	push	r20
    5d0c:	5f 93       	push	r21
    5d0e:	6f 93       	push	r22
    5d10:	7f 93       	push	r23
    5d12:	8f 93       	push	r24
    5d14:	9f 93       	push	r25
    5d16:	af 93       	push	r26
    5d18:	bf 93       	push	r27
    5d1a:	ef 93       	push	r30
    5d1c:	ff 93       	push	r31
    5d1e:	cf 93       	push	r28
    5d20:	df 93       	push	r29
    5d22:	cd b7       	in	r28, 0x3d	; 61
    5d24:	de b7       	in	r29, 0x3e	; 62
    5d26:	25 97       	sbiw	r28, 0x05	; 5
    5d28:	cd bf       	out	0x3d, r28	; 61
    5d2a:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    5d2c:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5d2e:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <chb_get_pcb>
    5d32:	8a 83       	std	Y+2, r24	; 0x02
    5d34:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5d36:	8f e3       	ldi	r24, 0x3F	; 63
    5d38:	90 e0       	ldi	r25, 0x00	; 0
    5d3a:	fc 01       	movw	r30, r24
    5d3c:	80 81       	ld	r24, Z
    5d3e:	80 93 37 40 	sts	0x4037, r24
    5d42:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5d44:	81 e0       	ldi	r24, 0x01	; 1
    5d46:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5d4a:	8f e8       	ldi	r24, 0x8F	; 143
    5d4c:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    5d50:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    5d52:	80 e0       	ldi	r24, 0x00	; 0
    5d54:	0e 94 16 31 	call	0x622c	; 0x622c <SPID_write>
    5d58:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5d5a:	80 e0       	ldi	r24, 0x00	; 0
    5d5c:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <RadioCS>

    while (intp_src)
    5d60:	e1 c0       	rjmp	.+450    	; 0x5f24 <__vector_64+0x22e>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5d62:	89 81       	ldd	r24, Y+1	; 0x01
    5d64:	88 2f       	mov	r24, r24
    5d66:	90 e0       	ldi	r25, 0x00	; 0
    5d68:	84 70       	andi	r24, 0x04	; 4
    5d6a:	90 70       	andi	r25, 0x00	; 0
    5d6c:	00 97       	sbiw	r24, 0x00	; 0
    5d6e:	21 f0       	breq	.+8      	; 0x5d78 <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5d70:	89 81       	ldd	r24, Y+1	; 0x01
    5d72:	8b 7f       	andi	r24, 0xFB	; 251
    5d74:	89 83       	std	Y+1, r24	; 0x01
    5d76:	d6 c0       	rjmp	.+428    	; 0x5f24 <__vector_64+0x22e>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5d78:	89 81       	ldd	r24, Y+1	; 0x01
    5d7a:	88 2f       	mov	r24, r24
    5d7c:	90 e0       	ldi	r25, 0x00	; 0
    5d7e:	88 70       	andi	r24, 0x08	; 8
    5d80:	90 70       	andi	r25, 0x00	; 0
    5d82:	00 97       	sbiw	r24, 0x00	; 0
    5d84:	09 f4       	brne	.+2      	; 0x5d88 <__vector_64+0x92>
    5d86:	90 c0       	rjmp	.+288    	; 0x5ea8 <__vector_64+0x1b2>
        {
            state = chb_get_state();
    5d88:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_get_state>
    5d8c:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5d8e:	8d 81       	ldd	r24, Y+5	; 0x05
    5d90:	86 30       	cpi	r24, 0x06	; 6
    5d92:	39 f0       	breq	.+14     	; 0x5da2 <__vector_64+0xac>
    5d94:	8d 81       	ldd	r24, Y+5	; 0x05
    5d96:	86 31       	cpi	r24, 0x16	; 22
    5d98:	21 f0       	breq	.+8      	; 0x5da2 <__vector_64+0xac>
    5d9a:	8d 81       	ldd	r24, Y+5	; 0x05
    5d9c:	81 31       	cpi	r24, 0x11	; 17
    5d9e:	09 f0       	breq	.+2      	; 0x5da2 <__vector_64+0xac>
    5da0:	72 c0       	rjmp	.+228    	; 0x5e86 <__vector_64+0x190>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5da2:	88 e0       	ldi	r24, 0x08	; 8
    5da4:	0e 94 57 27 	call	0x4eae	; 0x4eae <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5da8:	87 e0       	ldi	r24, 0x07	; 7
    5daa:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    5dae:	28 2f       	mov	r18, r24
    5db0:	8a 81       	ldd	r24, Y+2	; 0x02
    5db2:	9b 81       	ldd	r25, Y+3	; 0x03
    5db4:	fc 01       	movw	r30, r24
    5db6:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5db8:	86 e0       	ldi	r24, 0x06	; 6
    5dba:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
    5dbe:	28 2f       	mov	r18, r24
    5dc0:	22 1f       	adc	r18, r18
    5dc2:	22 27       	eor	r18, r18
    5dc4:	22 1f       	adc	r18, r18
    5dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    5dc8:	9b 81       	ldd	r25, Y+3	; 0x03
    5dca:	fc 01       	movw	r30, r24
    5dcc:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5dce:	8a 81       	ldd	r24, Y+2	; 0x02
    5dd0:	9b 81       	ldd	r25, Y+3	; 0x03
    5dd2:	fc 01       	movw	r30, r24
    5dd4:	83 89       	ldd	r24, Z+19	; 0x13
    5dd6:	88 23       	and	r24, r24
    5dd8:	09 f4       	brne	.+2      	; 0x5ddc <__vector_64+0xe6>
    5dda:	5b c0       	rjmp	.+182    	; 0x5e92 <__vector_64+0x19c>
                    // get the data
                    chb_frame_read();
    5ddc:	0e 94 6d 25 	call	0x4ada	; 0x4ada <chb_frame_read>
                    pcb->rcvd_xfers++;
    5de0:	8a 81       	ldd	r24, Y+2	; 0x02
    5de2:	9b 81       	ldd	r25, Y+3	; 0x03
    5de4:	fc 01       	movw	r30, r24
    5de6:	85 81       	ldd	r24, Z+5	; 0x05
    5de8:	96 81       	ldd	r25, Z+6	; 0x06
    5dea:	9c 01       	movw	r18, r24
    5dec:	2f 5f       	subi	r18, 0xFF	; 255
    5dee:	3f 4f       	sbci	r19, 0xFF	; 255
    5df0:	8a 81       	ldd	r24, Y+2	; 0x02
    5df2:	9b 81       	ldd	r25, Y+3	; 0x03
    5df4:	fc 01       	movw	r30, r24
    5df6:	25 83       	std	Z+5, r18	; 0x05
    5df8:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5dfa:	8a 81       	ldd	r24, Y+2	; 0x02
    5dfc:	9b 81       	ldd	r25, Y+3	; 0x03
    5dfe:	21 e0       	ldi	r18, 0x01	; 1
    5e00:	fc 01       	movw	r30, r24
    5e02:	23 83       	std	Z+3, r18	; 0x03
					StartOfFreeSpace += chb_read(FRAMReadBuffer+StartOfFreeSpace);	//read the data into the FRAM buffer right away --vlad
    5e04:	80 91 b3 50 	lds	r24, 0x50B3
    5e08:	90 91 b4 50 	lds	r25, 0x50B4
    5e0c:	a0 91 b5 50 	lds	r26, 0x50B5
    5e10:	b0 91 b6 50 	lds	r27, 0x50B6
    5e14:	80 54       	subi	r24, 0x40	; 64
    5e16:	9c 4d       	sbci	r25, 0xDC	; 220
    5e18:	0e 94 00 21 	call	0x4200	; 0x4200 <chb_read>
    5e1c:	28 2f       	mov	r18, r24
    5e1e:	30 e0       	ldi	r19, 0x00	; 0
    5e20:	40 e0       	ldi	r20, 0x00	; 0
    5e22:	50 e0       	ldi	r21, 0x00	; 0
    5e24:	80 91 b3 50 	lds	r24, 0x50B3
    5e28:	90 91 b4 50 	lds	r25, 0x50B4
    5e2c:	a0 91 b5 50 	lds	r26, 0x50B5
    5e30:	b0 91 b6 50 	lds	r27, 0x50B6
    5e34:	82 0f       	add	r24, r18
    5e36:	93 1f       	adc	r25, r19
    5e38:	a4 1f       	adc	r26, r20
    5e3a:	b5 1f       	adc	r27, r21
    5e3c:	80 93 b3 50 	sts	0x50B3, r24
    5e40:	90 93 b4 50 	sts	0x50B4, r25
    5e44:	a0 93 b5 50 	sts	0x50B5, r26
    5e48:	b0 93 b6 50 	sts	0x50B6, r27
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).			
    5e4c:	80 91 b3 50 	lds	r24, 0x50B3
    5e50:	90 91 b4 50 	lds	r25, 0x50B4
    5e54:	a0 91 b5 50 	lds	r26, 0x50B5
    5e58:	b0 91 b6 50 	lds	r27, 0x50B6
    5e5c:	80 58       	subi	r24, 0x80	; 128
    5e5e:	9f 4f       	sbci	r25, 0xFF	; 255
    5e60:	af 4f       	sbci	r26, 0xFF	; 255
    5e62:	bf 4f       	sbci	r27, 0xFF	; 255
    5e64:	81 37       	cpi	r24, 0x71	; 113
    5e66:	fc e1       	ldi	r31, 0x1C	; 28
    5e68:	9f 07       	cpc	r25, r31
    5e6a:	f0 e0       	ldi	r31, 0x00	; 0
    5e6c:	af 07       	cpc	r26, r31
    5e6e:	f0 e0       	ldi	r31, 0x00	; 0
    5e70:	bf 07       	cpc	r27, r31
    5e72:	78 f0       	brcs	.+30     	; 0x5e92 <__vector_64+0x19c>
    5e74:	10 92 b3 50 	sts	0x50B3, r1
    5e78:	10 92 b4 50 	sts	0x50B4, r1
    5e7c:	10 92 b5 50 	sts	0x50B5, r1
    5e80:	10 92 b6 50 	sts	0x50B6, r1

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5e84:	06 c0       	rjmp	.+12     	; 0x5e92 <__vector_64+0x19c>
					StartOfFreeSpace += chb_read(FRAMReadBuffer+StartOfFreeSpace);	//read the data into the FRAM buffer right away --vlad
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).			
                }
            }
            else{
                pcb->tx_end = true;
    5e86:	8a 81       	ldd	r24, Y+2	; 0x02
    5e88:	9b 81       	ldd	r25, Y+3	; 0x03
    5e8a:	21 e0       	ldi	r18, 0x01	; 1
    5e8c:	fc 01       	movw	r30, r24
    5e8e:	24 83       	std	Z+4, r18	; 0x04
    5e90:	01 c0       	rjmp	.+2      	; 0x5e94 <__vector_64+0x19e>

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5e92:	00 00       	nop
                }
            }
            else{
                pcb->tx_end = true;
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5e94:	89 81       	ldd	r24, Y+1	; 0x01
    5e96:	87 7f       	andi	r24, 0xF7	; 247
    5e98:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5e9a:	00 00       	nop
    5e9c:	86 e1       	ldi	r24, 0x16	; 22
    5e9e:	0e 94 57 27 	call	0x4eae	; 0x4eae <chb_set_state>
    5ea2:	80 34       	cpi	r24, 0x40	; 64
    5ea4:	d9 f7       	brne	.-10     	; 0x5e9c <__vector_64+0x1a6>
    5ea6:	3e c0       	rjmp	.+124    	; 0x5f24 <__vector_64+0x22e>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5ea8:	89 81       	ldd	r24, Y+1	; 0x01
    5eaa:	88 2f       	mov	r24, r24
    5eac:	90 e0       	ldi	r25, 0x00	; 0
    5eae:	80 74       	andi	r24, 0x40	; 64
    5eb0:	90 70       	andi	r25, 0x00	; 0
    5eb2:	00 97       	sbiw	r24, 0x00	; 0
    5eb4:	89 f0       	breq	.+34     	; 0x5ed8 <__vector_64+0x1e2>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5eb6:	89 81       	ldd	r24, Y+1	; 0x01
    5eb8:	8f 7b       	andi	r24, 0xBF	; 191
    5eba:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5ebc:	8a 81       	ldd	r24, Y+2	; 0x02
    5ebe:	9b 81       	ldd	r25, Y+3	; 0x03
    5ec0:	fc 01       	movw	r30, r24
    5ec2:	87 85       	ldd	r24, Z+15	; 0x0f
    5ec4:	90 89       	ldd	r25, Z+16	; 0x10
    5ec6:	9c 01       	movw	r18, r24
    5ec8:	2f 5f       	subi	r18, 0xFF	; 255
    5eca:	3f 4f       	sbci	r19, 0xFF	; 255
    5ecc:	8a 81       	ldd	r24, Y+2	; 0x02
    5ece:	9b 81       	ldd	r25, Y+3	; 0x03
    5ed0:	fc 01       	movw	r30, r24
    5ed2:	27 87       	std	Z+15, r18	; 0x0f
    5ed4:	30 8b       	std	Z+16, r19	; 0x10
    5ed6:	26 c0       	rjmp	.+76     	; 0x5f24 <__vector_64+0x22e>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5ed8:	89 81       	ldd	r24, Y+1	; 0x01
    5eda:	88 2f       	mov	r24, r24
    5edc:	90 e0       	ldi	r25, 0x00	; 0
    5ede:	82 70       	andi	r24, 0x02	; 2
    5ee0:	90 70       	andi	r25, 0x00	; 0
    5ee2:	00 97       	sbiw	r24, 0x00	; 0
    5ee4:	21 f0       	breq	.+8      	; 0x5eee <__vector_64+0x1f8>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5ee6:	89 81       	ldd	r24, Y+1	; 0x01
    5ee8:	8d 7f       	andi	r24, 0xFD	; 253
    5eea:	89 83       	std	Y+1, r24	; 0x01
    5eec:	1b c0       	rjmp	.+54     	; 0x5f24 <__vector_64+0x22e>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5eee:	89 81       	ldd	r24, Y+1	; 0x01
    5ef0:	88 2f       	mov	r24, r24
    5ef2:	90 e0       	ldi	r25, 0x00	; 0
    5ef4:	81 70       	andi	r24, 0x01	; 1
    5ef6:	90 70       	andi	r25, 0x00	; 0
    5ef8:	88 23       	and	r24, r24
    5efa:	21 f0       	breq	.+8      	; 0x5f04 <__vector_64+0x20e>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5efc:	89 81       	ldd	r24, Y+1	; 0x01
    5efe:	8e 7f       	andi	r24, 0xFE	; 254
    5f00:	89 83       	std	Y+1, r24	; 0x01
    5f02:	10 c0       	rjmp	.+32     	; 0x5f24 <__vector_64+0x22e>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5f04:	89 81       	ldd	r24, Y+1	; 0x01
    5f06:	88 23       	and	r24, r24
    5f08:	6c f4       	brge	.+26     	; 0x5f24 <__vector_64+0x22e>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5f0a:	89 81       	ldd	r24, Y+1	; 0x01
    5f0c:	8f 77       	andi	r24, 0x7F	; 127
    5f0e:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5f10:	8a 81       	ldd	r24, Y+2	; 0x02
    5f12:	9b 81       	ldd	r25, Y+3	; 0x03
    5f14:	fc 01       	movw	r30, r24
    5f16:	81 89       	ldd	r24, Z+17	; 0x11
    5f18:	28 2f       	mov	r18, r24
    5f1a:	2f 5f       	subi	r18, 0xFF	; 255
    5f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f1e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f20:	fc 01       	movw	r30, r24
    5f22:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5f24:	89 81       	ldd	r24, Y+1	; 0x01
    5f26:	88 23       	and	r24, r24
    5f28:	09 f0       	breq	.+2      	; 0x5f2c <__vector_64+0x236>
    5f2a:	1b cf       	rjmp	.-458    	; 0x5d62 <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5f2c:	8f e3       	ldi	r24, 0x3F	; 63
    5f2e:	90 e0       	ldi	r25, 0x00	; 0
    5f30:	20 91 37 40 	lds	r18, 0x4037
    5f34:	fc 01       	movw	r30, r24
    5f36:	20 83       	st	Z, r18
    5f38:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5f3a:	8f e0       	ldi	r24, 0x0F	; 15
    5f3c:	0e 94 fe 23 	call	0x47fc	; 0x47fc <chb_reg_read>
}
    5f40:	25 96       	adiw	r28, 0x05	; 5
    5f42:	cd bf       	out	0x3d, r28	; 61
    5f44:	de bf       	out	0x3e, r29	; 62
    5f46:	df 91       	pop	r29
    5f48:	cf 91       	pop	r28
    5f4a:	ff 91       	pop	r31
    5f4c:	ef 91       	pop	r30
    5f4e:	bf 91       	pop	r27
    5f50:	af 91       	pop	r26
    5f52:	9f 91       	pop	r25
    5f54:	8f 91       	pop	r24
    5f56:	7f 91       	pop	r23
    5f58:	6f 91       	pop	r22
    5f5a:	5f 91       	pop	r21
    5f5c:	4f 91       	pop	r20
    5f5e:	3f 91       	pop	r19
    5f60:	2f 91       	pop	r18
    5f62:	0f 90       	pop	r0
    5f64:	00 92 3b 00 	sts	0x003B, r0
    5f68:	0f 90       	pop	r0
    5f6a:	0f be       	out	0x3f, r0	; 63
    5f6c:	0f 90       	pop	r0
    5f6e:	1f 90       	pop	r1
    5f70:	18 95       	reti

00005f72 <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5f72:	cf 93       	push	r28
    5f74:	df 93       	push	r29
    5f76:	0f 92       	push	r0
    5f78:	cd b7       	in	r28, 0x3d	; 61
    5f7a:	de b7       	in	r29, 0x3e	; 62
    5f7c:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5f7e:	89 81       	ldd	r24, Y+1	; 0x01
    5f80:	88 23       	and	r24, r24
    5f82:	31 f0       	breq	.+12     	; 0x5f90 <RadioCS+0x1e>
    5f84:	80 e6       	ldi	r24, 0x60	; 96
    5f86:	96 e0       	ldi	r25, 0x06	; 6
    5f88:	20 e1       	ldi	r18, 0x10	; 16
    5f8a:	fc 01       	movw	r30, r24
    5f8c:	26 83       	std	Z+6, r18	; 0x06
    5f8e:	05 c0       	rjmp	.+10     	; 0x5f9a <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5f90:	80 e6       	ldi	r24, 0x60	; 96
    5f92:	96 e0       	ldi	r25, 0x06	; 6
    5f94:	20 e1       	ldi	r18, 0x10	; 16
    5f96:	fc 01       	movw	r30, r24
    5f98:	25 83       	std	Z+5, r18	; 0x05
	}
    5f9a:	0f 90       	pop	r0
    5f9c:	df 91       	pop	r29
    5f9e:	cf 91       	pop	r28
    5fa0:	08 95       	ret

00005fa2 <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5fa2:	cf 93       	push	r28
    5fa4:	df 93       	push	r29
    5fa6:	00 d0       	rcall	.+0      	; 0x5fa8 <chb_eep_write_byte+0x6>
    5fa8:	cd b7       	in	r28, 0x3d	; 61
    5faa:	de b7       	in	r29, 0x3e	; 62
    5fac:	89 83       	std	Y+1, r24	; 0x01
    5fae:	9a 83       	std	Y+2, r25	; 0x02
    5fb0:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5fb2:	00 00       	nop
    5fb4:	80 ec       	ldi	r24, 0xC0	; 192
    5fb6:	91 e0       	ldi	r25, 0x01	; 1
    5fb8:	fc 01       	movw	r30, r24
    5fba:	87 85       	ldd	r24, Z+15	; 0x0f
    5fbc:	88 23       	and	r24, r24
    5fbe:	d4 f3       	brlt	.-12     	; 0x5fb4 <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5fc0:	80 ec       	ldi	r24, 0xC0	; 192
    5fc2:	91 e0       	ldi	r25, 0x01	; 1
    5fc4:	fc 01       	movw	r30, r24
    5fc6:	87 85       	ldd	r24, Z+15	; 0x0f
    5fc8:	88 2f       	mov	r24, r24
    5fca:	90 e0       	ldi	r25, 0x00	; 0
    5fcc:	82 70       	andi	r24, 0x02	; 2
    5fce:	90 70       	andi	r25, 0x00	; 0
    5fd0:	00 97       	sbiw	r24, 0x00	; 0
    5fd2:	99 f0       	breq	.+38     	; 0x5ffa <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5fd4:	80 ec       	ldi	r24, 0xC0	; 192
    5fd6:	91 e0       	ldi	r25, 0x01	; 1
    5fd8:	26 e3       	ldi	r18, 0x36	; 54
    5fda:	fc 01       	movw	r30, r24
    5fdc:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5fde:	ef 93       	push	r30
    5fe0:	ff 93       	push	r31
    5fe2:	0f 93       	push	r16
    5fe4:	2f 93       	push	r18
    5fe6:	eb ec       	ldi	r30, 0xCB	; 203
    5fe8:	f1 e0       	ldi	r31, 0x01	; 1
    5fea:	08 ed       	ldi	r16, 0xD8	; 216
    5fec:	21 e0       	ldi	r18, 0x01	; 1
    5fee:	04 bf       	out	0x34, r16	; 52
    5ff0:	20 83       	st	Z, r18
    5ff2:	2f 91       	pop	r18
    5ff4:	0f 91       	pop	r16
    5ff6:	ff 91       	pop	r31
    5ff8:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    5ffa:	80 ec       	ldi	r24, 0xC0	; 192
    5ffc:	91 e0       	ldi	r25, 0x01	; 1
    5ffe:	23 e3       	ldi	r18, 0x33	; 51
    6000:	fc 01       	movw	r30, r24
    6002:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    6004:	80 ec       	ldi	r24, 0xC0	; 192
    6006:	91 e0       	ldi	r25, 0x01	; 1
    6008:	29 81       	ldd	r18, Y+1	; 0x01
    600a:	fc 01       	movw	r30, r24
    600c:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    600e:	80 ec       	ldi	r24, 0xC0	; 192
    6010:	91 e0       	ldi	r25, 0x01	; 1
    6012:	29 81       	ldd	r18, Y+1	; 0x01
    6014:	3a 81       	ldd	r19, Y+2	; 0x02
    6016:	23 2f       	mov	r18, r19
    6018:	33 27       	eor	r19, r19
    601a:	2f 71       	andi	r18, 0x1F	; 31
    601c:	fc 01       	movw	r30, r24
    601e:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    6020:	80 ec       	ldi	r24, 0xC0	; 192
    6022:	91 e0       	ldi	r25, 0x01	; 1
    6024:	fc 01       	movw	r30, r24
    6026:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    6028:	80 ec       	ldi	r24, 0xC0	; 192
    602a:	91 e0       	ldi	r25, 0x01	; 1
    602c:	2b 81       	ldd	r18, Y+3	; 0x03
    602e:	fc 01       	movw	r30, r24
    6030:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    6032:	80 ec       	ldi	r24, 0xC0	; 192
    6034:	91 e0       	ldi	r25, 0x01	; 1
    6036:	25 e3       	ldi	r18, 0x35	; 53
    6038:	fc 01       	movw	r30, r24
    603a:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    603c:	ef 93       	push	r30
    603e:	ff 93       	push	r31
    6040:	0f 93       	push	r16
    6042:	2f 93       	push	r18
    6044:	eb ec       	ldi	r30, 0xCB	; 203
    6046:	f1 e0       	ldi	r31, 0x01	; 1
    6048:	08 ed       	ldi	r16, 0xD8	; 216
    604a:	21 e0       	ldi	r18, 0x01	; 1
    604c:	04 bf       	out	0x34, r16	; 52
    604e:	20 83       	st	Z, r18
    6050:	2f 91       	pop	r18
    6052:	0f 91       	pop	r16
    6054:	ff 91       	pop	r31
    6056:	ef 91       	pop	r30
}
    6058:	23 96       	adiw	r28, 0x03	; 3
    605a:	cd bf       	out	0x3d, r28	; 61
    605c:	de bf       	out	0x3e, r29	; 62
    605e:	df 91       	pop	r29
    6060:	cf 91       	pop	r28
    6062:	08 95       	ret

00006064 <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    6064:	cf 93       	push	r28
    6066:	df 93       	push	r29
    6068:	0f 92       	push	r0
    606a:	0f 92       	push	r0
    606c:	cd b7       	in	r28, 0x3d	; 61
    606e:	de b7       	in	r29, 0x3e	; 62
    6070:	89 83       	std	Y+1, r24	; 0x01
    6072:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    6074:	00 00       	nop
    6076:	80 ec       	ldi	r24, 0xC0	; 192
    6078:	91 e0       	ldi	r25, 0x01	; 1
    607a:	fc 01       	movw	r30, r24
    607c:	87 85       	ldd	r24, Z+15	; 0x0f
    607e:	88 23       	and	r24, r24
    6080:	d4 f3       	brlt	.-12     	; 0x6076 <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    6082:	80 ec       	ldi	r24, 0xC0	; 192
    6084:	91 e0       	ldi	r25, 0x01	; 1
    6086:	29 81       	ldd	r18, Y+1	; 0x01
    6088:	fc 01       	movw	r30, r24
    608a:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    608c:	80 ec       	ldi	r24, 0xC0	; 192
    608e:	91 e0       	ldi	r25, 0x01	; 1
    6090:	29 81       	ldd	r18, Y+1	; 0x01
    6092:	3a 81       	ldd	r19, Y+2	; 0x02
    6094:	23 2f       	mov	r18, r19
    6096:	33 27       	eor	r19, r19
    6098:	2f 71       	andi	r18, 0x1F	; 31
    609a:	fc 01       	movw	r30, r24
    609c:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    609e:	80 ec       	ldi	r24, 0xC0	; 192
    60a0:	91 e0       	ldi	r25, 0x01	; 1
    60a2:	fc 01       	movw	r30, r24
    60a4:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    60a6:	80 ec       	ldi	r24, 0xC0	; 192
    60a8:	91 e0       	ldi	r25, 0x01	; 1
    60aa:	26 e0       	ldi	r18, 0x06	; 6
    60ac:	fc 01       	movw	r30, r24
    60ae:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    60b0:	ef 93       	push	r30
    60b2:	ff 93       	push	r31
    60b4:	0f 93       	push	r16
    60b6:	2f 93       	push	r18
    60b8:	eb ec       	ldi	r30, 0xCB	; 203
    60ba:	f1 e0       	ldi	r31, 0x01	; 1
    60bc:	08 ed       	ldi	r16, 0xD8	; 216
    60be:	21 e0       	ldi	r18, 0x01	; 1
    60c0:	04 bf       	out	0x34, r16	; 52
    60c2:	20 83       	st	Z, r18
    60c4:	2f 91       	pop	r18
    60c6:	0f 91       	pop	r16
    60c8:	ff 91       	pop	r31
    60ca:	ef 91       	pop	r30

    return NVM.DATA0;
    60cc:	80 ec       	ldi	r24, 0xC0	; 192
    60ce:	91 e0       	ldi	r25, 0x01	; 1
    60d0:	fc 01       	movw	r30, r24
    60d2:	84 81       	ldd	r24, Z+4	; 0x04
}
    60d4:	0f 90       	pop	r0
    60d6:	0f 90       	pop	r0
    60d8:	df 91       	pop	r29
    60da:	cf 91       	pop	r28
    60dc:	08 95       	ret

000060de <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    60de:	cf 93       	push	r28
    60e0:	df 93       	push	r29
    60e2:	cd b7       	in	r28, 0x3d	; 61
    60e4:	de b7       	in	r29, 0x3e	; 62
    60e6:	27 97       	sbiw	r28, 0x07	; 7
    60e8:	cd bf       	out	0x3d, r28	; 61
    60ea:	de bf       	out	0x3e, r29	; 62
    60ec:	8a 83       	std	Y+2, r24	; 0x02
    60ee:	9b 83       	std	Y+3, r25	; 0x03
    60f0:	6c 83       	std	Y+4, r22	; 0x04
    60f2:	7d 83       	std	Y+5, r23	; 0x05
    60f4:	4e 83       	std	Y+6, r20	; 0x06
    60f6:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    60f8:	80 ec       	ldi	r24, 0xC0	; 192
    60fa:	91 e0       	ldi	r25, 0x01	; 1
    60fc:	20 ec       	ldi	r18, 0xC0	; 192
    60fe:	31 e0       	ldi	r19, 0x01	; 1
    6100:	f9 01       	movw	r30, r18
    6102:	24 85       	ldd	r18, Z+12	; 0x0c
    6104:	27 7f       	andi	r18, 0xF7	; 247
    6106:	fc 01       	movw	r30, r24
    6108:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    610a:	19 82       	std	Y+1, r1	; 0x01
    610c:	16 c0       	rjmp	.+44     	; 0x613a <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    610e:	89 81       	ldd	r24, Y+1	; 0x01
    6110:	28 2f       	mov	r18, r24
    6112:	30 e0       	ldi	r19, 0x00	; 0
    6114:	8a 81       	ldd	r24, Y+2	; 0x02
    6116:	9b 81       	ldd	r25, Y+3	; 0x03
    6118:	82 0f       	add	r24, r18
    611a:	93 1f       	adc	r25, r19
    611c:	29 81       	ldd	r18, Y+1	; 0x01
    611e:	22 2f       	mov	r18, r18
    6120:	30 e0       	ldi	r19, 0x00	; 0
    6122:	4c 81       	ldd	r20, Y+4	; 0x04
    6124:	5d 81       	ldd	r21, Y+5	; 0x05
    6126:	24 0f       	add	r18, r20
    6128:	35 1f       	adc	r19, r21
    612a:	f9 01       	movw	r30, r18
    612c:	20 81       	ld	r18, Z
    612e:	62 2f       	mov	r22, r18
    6130:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    6134:	89 81       	ldd	r24, Y+1	; 0x01
    6136:	8f 5f       	subi	r24, 0xFF	; 255
    6138:	89 83       	std	Y+1, r24	; 0x01
    613a:	89 81       	ldd	r24, Y+1	; 0x01
    613c:	28 2f       	mov	r18, r24
    613e:	30 e0       	ldi	r19, 0x00	; 0
    6140:	8e 81       	ldd	r24, Y+6	; 0x06
    6142:	9f 81       	ldd	r25, Y+7	; 0x07
    6144:	28 17       	cp	r18, r24
    6146:	39 07       	cpc	r19, r25
    6148:	10 f3       	brcs	.-60     	; 0x610e <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    614a:	27 96       	adiw	r28, 0x07	; 7
    614c:	cd bf       	out	0x3d, r28	; 61
    614e:	de bf       	out	0x3e, r29	; 62
    6150:	df 91       	pop	r29
    6152:	cf 91       	pop	r28
    6154:	08 95       	ret

00006156 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    6156:	0f 93       	push	r16
    6158:	1f 93       	push	r17
    615a:	cf 93       	push	r28
    615c:	df 93       	push	r29
    615e:	cd b7       	in	r28, 0x3d	; 61
    6160:	de b7       	in	r29, 0x3e	; 62
    6162:	27 97       	sbiw	r28, 0x07	; 7
    6164:	cd bf       	out	0x3d, r28	; 61
    6166:	de bf       	out	0x3e, r29	; 62
    6168:	8a 83       	std	Y+2, r24	; 0x02
    616a:	9b 83       	std	Y+3, r25	; 0x03
    616c:	6c 83       	std	Y+4, r22	; 0x04
    616e:	7d 83       	std	Y+5, r23	; 0x05
    6170:	4e 83       	std	Y+6, r20	; 0x06
    6172:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    6174:	80 ec       	ldi	r24, 0xC0	; 192
    6176:	91 e0       	ldi	r25, 0x01	; 1
    6178:	20 ec       	ldi	r18, 0xC0	; 192
    617a:	31 e0       	ldi	r19, 0x01	; 1
    617c:	f9 01       	movw	r30, r18
    617e:	24 85       	ldd	r18, Z+12	; 0x0c
    6180:	27 7f       	andi	r18, 0xF7	; 247
    6182:	fc 01       	movw	r30, r24
    6184:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6186:	19 82       	std	Y+1, r1	; 0x01
    6188:	16 c0       	rjmp	.+44     	; 0x61b6 <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    618a:	89 81       	ldd	r24, Y+1	; 0x01
    618c:	88 2f       	mov	r24, r24
    618e:	90 e0       	ldi	r25, 0x00	; 0
    6190:	2c 81       	ldd	r18, Y+4	; 0x04
    6192:	3d 81       	ldd	r19, Y+5	; 0x05
    6194:	89 01       	movw	r16, r18
    6196:	08 0f       	add	r16, r24
    6198:	19 1f       	adc	r17, r25
    619a:	89 81       	ldd	r24, Y+1	; 0x01
    619c:	28 2f       	mov	r18, r24
    619e:	30 e0       	ldi	r19, 0x00	; 0
    61a0:	8a 81       	ldd	r24, Y+2	; 0x02
    61a2:	9b 81       	ldd	r25, Y+3	; 0x03
    61a4:	82 0f       	add	r24, r18
    61a6:	93 1f       	adc	r25, r19
    61a8:	0e 94 32 30 	call	0x6064	; 0x6064 <chb_eep_read_byte>
    61ac:	f8 01       	movw	r30, r16
    61ae:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    61b0:	89 81       	ldd	r24, Y+1	; 0x01
    61b2:	8f 5f       	subi	r24, 0xFF	; 255
    61b4:	89 83       	std	Y+1, r24	; 0x01
    61b6:	89 81       	ldd	r24, Y+1	; 0x01
    61b8:	28 2f       	mov	r18, r24
    61ba:	30 e0       	ldi	r19, 0x00	; 0
    61bc:	8e 81       	ldd	r24, Y+6	; 0x06
    61be:	9f 81       	ldd	r25, Y+7	; 0x07
    61c0:	28 17       	cp	r18, r24
    61c2:	39 07       	cpc	r19, r25
    61c4:	10 f3       	brcs	.-60     	; 0x618a <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    61c6:	27 96       	adiw	r28, 0x07	; 7
    61c8:	cd bf       	out	0x3d, r28	; 61
    61ca:	de bf       	out	0x3e, r29	; 62
    61cc:	df 91       	pop	r29
    61ce:	cf 91       	pop	r28
    61d0:	1f 91       	pop	r17
    61d2:	0f 91       	pop	r16
    61d4:	08 95       	ret

000061d6 <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    61d6:	cf 93       	push	r28
    61d8:	df 93       	push	r29
    61da:	cd b7       	in	r28, 0x3d	; 61
    61dc:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    61de:	80 e6       	ldi	r24, 0x60	; 96
    61e0:	96 e0       	ldi	r25, 0x06	; 6
    61e2:	20 e6       	ldi	r18, 0x60	; 96
    61e4:	36 e0       	ldi	r19, 0x06	; 6
    61e6:	f9 01       	movw	r30, r18
    61e8:	20 81       	ld	r18, Z
    61ea:	20 6b       	ori	r18, 0xB0	; 176
    61ec:	fc 01       	movw	r30, r24
    61ee:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    61f0:	84 e6       	ldi	r24, 0x64	; 100
    61f2:	96 e0       	ldi	r25, 0x06	; 6
    61f4:	24 e6       	ldi	r18, 0x64	; 100
    61f6:	36 e0       	ldi	r19, 0x06	; 6
    61f8:	f9 01       	movw	r30, r18
    61fa:	20 81       	ld	r18, Z
    61fc:	20 61       	ori	r18, 0x10	; 16
    61fe:	fc 01       	movw	r30, r24
    6200:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    6202:	80 ec       	ldi	r24, 0xC0	; 192
    6204:	99 e0       	ldi	r25, 0x09	; 9
    6206:	20 ec       	ldi	r18, 0xC0	; 192
    6208:	39 e0       	ldi	r19, 0x09	; 9
    620a:	f9 01       	movw	r30, r18
    620c:	20 81       	ld	r18, Z
    620e:	21 65       	ori	r18, 0x51	; 81
    6210:	fc 01       	movw	r30, r24
    6212:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    6214:	84 e6       	ldi	r24, 0x64	; 100
    6216:	96 e0       	ldi	r25, 0x06	; 6
    6218:	24 e6       	ldi	r18, 0x64	; 100
    621a:	36 e0       	ldi	r19, 0x06	; 6
    621c:	f9 01       	movw	r30, r18
    621e:	20 81       	ld	r18, Z
    6220:	20 61       	ori	r18, 0x10	; 16
    6222:	fc 01       	movw	r30, r24
    6224:	20 83       	st	Z, r18
}
    6226:	df 91       	pop	r29
    6228:	cf 91       	pop	r28
    622a:	08 95       	ret

0000622c <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    622c:	cf 93       	push	r28
    622e:	df 93       	push	r29
    6230:	0f 92       	push	r0
    6232:	0f 92       	push	r0
    6234:	cd b7       	in	r28, 0x3d	; 61
    6236:	de b7       	in	r29, 0x3e	; 62
    6238:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    623a:	80 ec       	ldi	r24, 0xC0	; 192
    623c:	99 e0       	ldi	r25, 0x09	; 9
    623e:	2a 81       	ldd	r18, Y+2	; 0x02
    6240:	fc 01       	movw	r30, r24
    6242:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    6244:	00 00       	nop
    6246:	80 ec       	ldi	r24, 0xC0	; 192
    6248:	99 e0       	ldi	r25, 0x09	; 9
    624a:	fc 01       	movw	r30, r24
    624c:	82 81       	ldd	r24, Z+2	; 0x02
    624e:	88 23       	and	r24, r24
    6250:	d4 f7       	brge	.-12     	; 0x6246 <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    6252:	80 ec       	ldi	r24, 0xC0	; 192
    6254:	99 e0       	ldi	r25, 0x09	; 9
    6256:	fc 01       	movw	r30, r24
    6258:	83 81       	ldd	r24, Z+3	; 0x03
    625a:	89 83       	std	Y+1, r24	; 0x01
	return data;
    625c:	89 81       	ldd	r24, Y+1	; 0x01
    625e:	0f 90       	pop	r0
    6260:	0f 90       	pop	r0
    6262:	df 91       	pop	r29
    6264:	cf 91       	pop	r28
    6266:	08 95       	ret

00006268 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    6268:	0f 93       	push	r16
    626a:	cf 93       	push	r28
    626c:	df 93       	push	r29
    626e:	00 d0       	rcall	.+0      	; 0x6270 <CCPWrite+0x8>
    6270:	00 d0       	rcall	.+0      	; 0x6272 <CCPWrite+0xa>
    6272:	cd b7       	in	r28, 0x3d	; 61
    6274:	de b7       	in	r29, 0x3e	; 62
    6276:	8c 83       	std	Y+4, r24	; 0x04
    6278:	9d 83       	std	Y+5, r25	; 0x05
    627a:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    627c:	8f e3       	ldi	r24, 0x3F	; 63
    627e:	90 e0       	ldi	r25, 0x00	; 0
    6280:	fc 01       	movw	r30, r24
    6282:	80 81       	ld	r24, Z
    6284:	8b 83       	std	Y+3, r24	; 0x03
    6286:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    6288:	8c 81       	ldd	r24, Y+4	; 0x04
    628a:	9d 81       	ldd	r25, Y+5	; 0x05
    628c:	89 83       	std	Y+1, r24	; 0x01
    628e:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    6290:	8b e3       	ldi	r24, 0x3B	; 59
    6292:	90 e0       	ldi	r25, 0x00	; 0
    6294:	fc 01       	movw	r30, r24
    6296:	10 82       	st	Z, r1
#endif
	asm volatile(
    6298:	89 81       	ldd	r24, Y+1	; 0x01
    629a:	9a 81       	ldd	r25, Y+2	; 0x02
    629c:	2e 81       	ldd	r18, Y+6	; 0x06
    629e:	fc 01       	movw	r30, r24
    62a0:	08 ed       	ldi	r16, 0xD8	; 216
    62a2:	04 bf       	out	0x34, r16	; 52
    62a4:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    62a6:	8f e3       	ldi	r24, 0x3F	; 63
    62a8:	90 e0       	ldi	r25, 0x00	; 0
    62aa:	2b 81       	ldd	r18, Y+3	; 0x03
    62ac:	fc 01       	movw	r30, r24
    62ae:	20 83       	st	Z, r18
#endif
}
    62b0:	26 96       	adiw	r28, 0x06	; 6
    62b2:	cd bf       	out	0x3d, r28	; 61
    62b4:	de bf       	out	0x3e, r29	; 62
    62b6:	df 91       	pop	r29
    62b8:	cf 91       	pop	r28
    62ba:	0f 91       	pop	r16
    62bc:	08 95       	ret

000062be <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    62be:	cf 93       	push	r28
    62c0:	df 93       	push	r29
    62c2:	00 d0       	rcall	.+0      	; 0x62c4 <CLKSYS_XOSC_Config+0x6>
    62c4:	cd b7       	in	r28, 0x3d	; 61
    62c6:	de b7       	in	r29, 0x3e	; 62
    62c8:	89 83       	std	Y+1, r24	; 0x01
    62ca:	6a 83       	std	Y+2, r22	; 0x02
    62cc:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    62ce:	80 e5       	ldi	r24, 0x50	; 80
    62d0:	90 e0       	ldi	r25, 0x00	; 0
    62d2:	2a 81       	ldd	r18, Y+2	; 0x02
    62d4:	22 23       	and	r18, r18
    62d6:	11 f0       	breq	.+4      	; 0x62dc <CLKSYS_XOSC_Config+0x1e>
    62d8:	20 e2       	ldi	r18, 0x20	; 32
    62da:	01 c0       	rjmp	.+2      	; 0x62de <CLKSYS_XOSC_Config+0x20>
    62dc:	20 e0       	ldi	r18, 0x00	; 0
    62de:	39 81       	ldd	r19, Y+1	; 0x01
    62e0:	32 2b       	or	r19, r18
    62e2:	2b 81       	ldd	r18, Y+3	; 0x03
    62e4:	23 2b       	or	r18, r19
    62e6:	fc 01       	movw	r30, r24
    62e8:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    62ea:	23 96       	adiw	r28, 0x03	; 3
    62ec:	cd bf       	out	0x3d, r28	; 61
    62ee:	de bf       	out	0x3e, r29	; 62
    62f0:	df 91       	pop	r29
    62f2:	cf 91       	pop	r28
    62f4:	08 95       	ret

000062f6 <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    62f6:	cf 93       	push	r28
    62f8:	df 93       	push	r29
    62fa:	0f 92       	push	r0
    62fc:	0f 92       	push	r0
    62fe:	cd b7       	in	r28, 0x3d	; 61
    6300:	de b7       	in	r29, 0x3e	; 62
    6302:	89 83       	std	Y+1, r24	; 0x01
    6304:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    6306:	8a 81       	ldd	r24, Y+2	; 0x02
    6308:	8f 71       	andi	r24, 0x1F	; 31
    630a:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    630c:	80 e5       	ldi	r24, 0x50	; 80
    630e:	90 e0       	ldi	r25, 0x00	; 0
    6310:	39 81       	ldd	r19, Y+1	; 0x01
    6312:	2a 81       	ldd	r18, Y+2	; 0x02
    6314:	23 2b       	or	r18, r19
    6316:	fc 01       	movw	r30, r24
    6318:	25 83       	std	Z+5, r18	; 0x05
}
    631a:	0f 90       	pop	r0
    631c:	0f 90       	pop	r0
    631e:	df 91       	pop	r29
    6320:	cf 91       	pop	r28
    6322:	08 95       	ret

00006324 <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    6324:	cf 93       	push	r28
    6326:	df 93       	push	r29
    6328:	0f 92       	push	r0
    632a:	0f 92       	push	r0
    632c:	cd b7       	in	r28, 0x3d	; 61
    632e:	de b7       	in	r29, 0x3e	; 62
    6330:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    6332:	80 e5       	ldi	r24, 0x50	; 80
    6334:	90 e0       	ldi	r25, 0x00	; 0
    6336:	20 e5       	ldi	r18, 0x50	; 80
    6338:	30 e0       	ldi	r19, 0x00	; 0
    633a:	f9 01       	movw	r30, r18
    633c:	20 81       	ld	r18, Z
    633e:	32 2f       	mov	r19, r18
    6340:	2a 81       	ldd	r18, Y+2	; 0x02
    6342:	20 95       	com	r18
    6344:	23 23       	and	r18, r19
    6346:	fc 01       	movw	r30, r24
    6348:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    634a:	80 e5       	ldi	r24, 0x50	; 80
    634c:	90 e0       	ldi	r25, 0x00	; 0
    634e:	fc 01       	movw	r30, r24
    6350:	90 81       	ld	r25, Z
    6352:	8a 81       	ldd	r24, Y+2	; 0x02
    6354:	89 23       	and	r24, r25
    6356:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    6358:	89 81       	ldd	r24, Y+1	; 0x01
}
    635a:	0f 90       	pop	r0
    635c:	0f 90       	pop	r0
    635e:	df 91       	pop	r29
    6360:	cf 91       	pop	r28
    6362:	08 95       	ret

00006364 <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    6364:	cf 93       	push	r28
    6366:	df 93       	push	r29
    6368:	00 d0       	rcall	.+0      	; 0x636a <CLKSYS_Prescalers_Config+0x6>
    636a:	cd b7       	in	r28, 0x3d	; 61
    636c:	de b7       	in	r29, 0x3e	; 62
    636e:	8a 83       	std	Y+2, r24	; 0x02
    6370:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    6372:	9a 81       	ldd	r25, Y+2	; 0x02
    6374:	8b 81       	ldd	r24, Y+3	; 0x03
    6376:	89 2b       	or	r24, r25
    6378:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    637a:	81 e4       	ldi	r24, 0x41	; 65
    637c:	90 e0       	ldi	r25, 0x00	; 0
    637e:	69 81       	ldd	r22, Y+1	; 0x01
    6380:	0e 94 34 31 	call	0x6268	; 0x6268 <CCPWrite>
}
    6384:	23 96       	adiw	r28, 0x03	; 3
    6386:	cd bf       	out	0x3d, r28	; 61
    6388:	de bf       	out	0x3e, r29	; 62
    638a:	df 91       	pop	r29
    638c:	cf 91       	pop	r28
    638e:	08 95       	ret

00006390 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6390:	cf 93       	push	r28
    6392:	df 93       	push	r29
    6394:	0f 92       	push	r0
    6396:	0f 92       	push	r0
    6398:	cd b7       	in	r28, 0x3d	; 61
    639a:	de b7       	in	r29, 0x3e	; 62
    639c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    639e:	80 e4       	ldi	r24, 0x40	; 64
    63a0:	90 e0       	ldi	r25, 0x00	; 0
    63a2:	fc 01       	movw	r30, r24
    63a4:	80 81       	ld	r24, Z
    63a6:	98 2f       	mov	r25, r24
    63a8:	98 7f       	andi	r25, 0xF8	; 248
    63aa:	8a 81       	ldd	r24, Y+2	; 0x02
    63ac:	89 2b       	or	r24, r25
    63ae:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    63b0:	80 e4       	ldi	r24, 0x40	; 64
    63b2:	90 e0       	ldi	r25, 0x00	; 0
    63b4:	69 81       	ldd	r22, Y+1	; 0x01
    63b6:	0e 94 34 31 	call	0x6268	; 0x6268 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    63ba:	80 e4       	ldi	r24, 0x40	; 64
    63bc:	90 e0       	ldi	r25, 0x00	; 0
    63be:	fc 01       	movw	r30, r24
    63c0:	90 81       	ld	r25, Z
    63c2:	8a 81       	ldd	r24, Y+2	; 0x02
    63c4:	89 23       	and	r24, r25
    63c6:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    63c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    63ca:	0f 90       	pop	r0
    63cc:	0f 90       	pop	r0
    63ce:	df 91       	pop	r29
    63d0:	cf 91       	pop	r28
    63d2:	08 95       	ret

000063d4 <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    63d4:	cf 93       	push	r28
    63d6:	df 93       	push	r29
    63d8:	0f 92       	push	r0
    63da:	cd b7       	in	r28, 0x3d	; 61
    63dc:	de b7       	in	r29, 0x3e	; 62
    63de:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    63e0:	80 e4       	ldi	r24, 0x40	; 64
    63e2:	90 e0       	ldi	r25, 0x00	; 0
    63e4:	20 e4       	ldi	r18, 0x40	; 64
    63e6:	30 e0       	ldi	r19, 0x00	; 0
    63e8:	f9 01       	movw	r30, r18
    63ea:	23 81       	ldd	r18, Z+3	; 0x03
    63ec:	32 2f       	mov	r19, r18
    63ee:	31 7f       	andi	r19, 0xF1	; 241
    63f0:	29 81       	ldd	r18, Y+1	; 0x01
    63f2:	23 2b       	or	r18, r19
    63f4:	21 60       	ori	r18, 0x01	; 1
    63f6:	fc 01       	movw	r30, r24
    63f8:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    63fa:	0f 90       	pop	r0
    63fc:	df 91       	pop	r29
    63fe:	cf 91       	pop	r28
    6400:	08 95       	ret

00006402 <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    6402:	cf 93       	push	r28
    6404:	df 93       	push	r29
    6406:	0f 92       	push	r0
    6408:	0f 92       	push	r0
    640a:	cd b7       	in	r28, 0x3d	; 61
    640c:	de b7       	in	r29, 0x3e	; 62
    640e:	89 83       	std	Y+1, r24	; 0x01
    6410:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    6412:	80 e5       	ldi	r24, 0x50	; 80
    6414:	90 e0       	ldi	r25, 0x00	; 0
    6416:	20 e5       	ldi	r18, 0x50	; 80
    6418:	30 e0       	ldi	r19, 0x00	; 0
    641a:	f9 01       	movw	r30, r18
    641c:	26 81       	ldd	r18, Z+6	; 0x06
    641e:	32 2f       	mov	r19, r18
    6420:	29 81       	ldd	r18, Y+1	; 0x01
    6422:	20 95       	com	r18
    6424:	32 23       	and	r19, r18
    6426:	2a 81       	ldd	r18, Y+2	; 0x02
    6428:	22 23       	and	r18, r18
    642a:	11 f0       	breq	.+4      	; 0x6430 <CLKSYS_AutoCalibration_Enable+0x2e>
    642c:	29 81       	ldd	r18, Y+1	; 0x01
    642e:	01 c0       	rjmp	.+2      	; 0x6432 <CLKSYS_AutoCalibration_Enable+0x30>
    6430:	20 e0       	ldi	r18, 0x00	; 0
    6432:	23 2b       	or	r18, r19
    6434:	fc 01       	movw	r30, r24
    6436:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    6438:	89 81       	ldd	r24, Y+1	; 0x01
    643a:	81 30       	cpi	r24, 0x01	; 1
    643c:	51 f4       	brne	.+20     	; 0x6452 <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    643e:	88 e6       	ldi	r24, 0x68	; 104
    6440:	90 e0       	ldi	r25, 0x00	; 0
    6442:	28 e6       	ldi	r18, 0x68	; 104
    6444:	30 e0       	ldi	r19, 0x00	; 0
    6446:	f9 01       	movw	r30, r18
    6448:	20 81       	ld	r18, Z
    644a:	21 60       	ori	r18, 0x01	; 1
    644c:	fc 01       	movw	r30, r24
    644e:	20 83       	st	Z, r18
    6450:	0c c0       	rjmp	.+24     	; 0x646a <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    6452:	89 81       	ldd	r24, Y+1	; 0x01
    6454:	82 30       	cpi	r24, 0x02	; 2
    6456:	49 f4       	brne	.+18     	; 0x646a <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    6458:	80 e6       	ldi	r24, 0x60	; 96
    645a:	90 e0       	ldi	r25, 0x00	; 0
    645c:	20 e6       	ldi	r18, 0x60	; 96
    645e:	30 e0       	ldi	r19, 0x00	; 0
    6460:	f9 01       	movw	r30, r18
    6462:	20 81       	ld	r18, Z
    6464:	21 60       	ori	r18, 0x01	; 1
    6466:	fc 01       	movw	r30, r24
    6468:	20 83       	st	Z, r18
	}
}
    646a:	0f 90       	pop	r0
    646c:	0f 90       	pop	r0
    646e:	df 91       	pop	r29
    6470:	cf 91       	pop	r28
    6472:	08 95       	ret

00006474 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    6474:	cf 93       	push	r28
    6476:	df 93       	push	r29
    6478:	cd b7       	in	r28, 0x3d	; 61
    647a:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    647c:	83 e5       	ldi	r24, 0x53	; 83
    647e:	90 e0       	ldi	r25, 0x00	; 0
    6480:	63 e0       	ldi	r22, 0x03	; 3
    6482:	0e 94 34 31 	call	0x6268	; 0x6268 <CCPWrite>
}
    6486:	df 91       	pop	r29
    6488:	cf 91       	pop	r28
    648a:	08 95       	ret

0000648c <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    648c:	cf 93       	push	r28
    648e:	df 93       	push	r29
    6490:	cd b7       	in	r28, 0x3d	; 61
    6492:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    6494:	82 e4       	ldi	r24, 0x42	; 66
    6496:	90 e0       	ldi	r25, 0x00	; 0
    6498:	61 e0       	ldi	r22, 0x01	; 1
    649a:	0e 94 34 31 	call	0x6268	; 0x6268 <CCPWrite>
}
    649e:	df 91       	pop	r29
    64a0:	cf 91       	pop	r28
    64a2:	08 95       	ret

000064a4 <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    64a4:	cf 93       	push	r28
    64a6:	df 93       	push	r29
    64a8:	cd b7       	in	r28, 0x3d	; 61
    64aa:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    64ac:	80 ec       	ldi	r24, 0xC0	; 192
    64ae:	60 e0       	ldi	r22, 0x00	; 0
    64b0:	4b e0       	ldi	r20, 0x0B	; 11
    64b2:	0e 94 5f 31 	call	0x62be	; 0x62be <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    64b6:	80 e5       	ldi	r24, 0x50	; 80
    64b8:	90 e0       	ldi	r25, 0x00	; 0
    64ba:	20 e5       	ldi	r18, 0x50	; 80
    64bc:	30 e0       	ldi	r19, 0x00	; 0
    64be:	f9 01       	movw	r30, r18
    64c0:	20 81       	ld	r18, Z
    64c2:	28 60       	ori	r18, 0x08	; 8
    64c4:	fc 01       	movw	r30, r24
    64c6:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    64c8:	80 e5       	ldi	r24, 0x50	; 80
    64ca:	90 e0       	ldi	r25, 0x00	; 0
    64cc:	fc 01       	movw	r30, r24
    64ce:	81 81       	ldd	r24, Z+1	; 0x01
    64d0:	88 2f       	mov	r24, r24
    64d2:	90 e0       	ldi	r25, 0x00	; 0
    64d4:	88 70       	andi	r24, 0x08	; 8
    64d6:	90 70       	andi	r25, 0x00	; 0
    64d8:	00 97       	sbiw	r24, 0x00	; 0
    64da:	b1 f3       	breq	.-20     	; 0x64c8 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    64dc:	80 ec       	ldi	r24, 0xC0	; 192
    64de:	62 e0       	ldi	r22, 0x02	; 2
    64e0:	0e 94 7b 31 	call	0x62f6	; 0x62f6 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    64e4:	80 e5       	ldi	r24, 0x50	; 80
    64e6:	90 e0       	ldi	r25, 0x00	; 0
    64e8:	20 e5       	ldi	r18, 0x50	; 80
    64ea:	30 e0       	ldi	r19, 0x00	; 0
    64ec:	f9 01       	movw	r30, r18
    64ee:	20 81       	ld	r18, Z
    64f0:	20 61       	ori	r18, 0x10	; 16
    64f2:	fc 01       	movw	r30, r24
    64f4:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    64f6:	80 e5       	ldi	r24, 0x50	; 80
    64f8:	90 e0       	ldi	r25, 0x00	; 0
    64fa:	fc 01       	movw	r30, r24
    64fc:	81 81       	ldd	r24, Z+1	; 0x01
    64fe:	88 2f       	mov	r24, r24
    6500:	90 e0       	ldi	r25, 0x00	; 0
    6502:	80 71       	andi	r24, 0x10	; 16
    6504:	90 70       	andi	r25, 0x00	; 0
    6506:	00 97       	sbiw	r24, 0x00	; 0
    6508:	b1 f3       	breq	.-20     	; 0x64f6 <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    650a:	84 e0       	ldi	r24, 0x04	; 4
    650c:	0e 94 c8 31 	call	0x6390	; 0x6390 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6510:	81 e0       	ldi	r24, 0x01	; 1
    6512:	0e 94 92 31 	call	0x6324	; 0x6324 <CLKSYS_Disable>
}
    6516:	df 91       	pop	r29
    6518:	cf 91       	pop	r28
    651a:	08 95       	ret

0000651c <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    651c:	cf 93       	push	r28
    651e:	df 93       	push	r29
    6520:	cd b7       	in	r28, 0x3d	; 61
    6522:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6524:	80 e5       	ldi	r24, 0x50	; 80
    6526:	90 e0       	ldi	r25, 0x00	; 0
    6528:	20 e5       	ldi	r18, 0x50	; 80
    652a:	30 e0       	ldi	r19, 0x00	; 0
    652c:	f9 01       	movw	r30, r18
    652e:	20 81       	ld	r18, Z
    6530:	22 60       	ori	r18, 0x02	; 2
    6532:	fc 01       	movw	r30, r24
    6534:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    6536:	80 e0       	ldi	r24, 0x00	; 0
    6538:	61 e0       	ldi	r22, 0x01	; 1
    653a:	0e 94 b2 31 	call	0x6364	; 0x6364 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    653e:	80 e5       	ldi	r24, 0x50	; 80
    6540:	90 e0       	ldi	r25, 0x00	; 0
    6542:	fc 01       	movw	r30, r24
    6544:	81 81       	ldd	r24, Z+1	; 0x01
    6546:	88 2f       	mov	r24, r24
    6548:	90 e0       	ldi	r25, 0x00	; 0
    654a:	82 70       	andi	r24, 0x02	; 2
    654c:	90 70       	andi	r25, 0x00	; 0
    654e:	00 97       	sbiw	r24, 0x00	; 0
    6550:	b1 f3       	breq	.-20     	; 0x653e <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6552:	81 e0       	ldi	r24, 0x01	; 1
    6554:	0e 94 c8 31 	call	0x6390	; 0x6390 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6558:	81 e0       	ldi	r24, 0x01	; 1
    655a:	0e 94 92 31 	call	0x6324	; 0x6324 <CLKSYS_Disable>
	
}
    655e:	df 91       	pop	r29
    6560:	cf 91       	pop	r28
    6562:	08 95       	ret

00006564 <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    6564:	cf 93       	push	r28
    6566:	df 93       	push	r29
    6568:	cd b7       	in	r28, 0x3d	; 61
    656a:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    656c:	80 e5       	ldi	r24, 0x50	; 80
    656e:	90 e0       	ldi	r25, 0x00	; 0
    6570:	20 e5       	ldi	r18, 0x50	; 80
    6572:	30 e0       	ldi	r19, 0x00	; 0
    6574:	f9 01       	movw	r30, r18
    6576:	20 81       	ld	r18, Z
    6578:	22 60       	ori	r18, 0x02	; 2
    657a:	fc 01       	movw	r30, r24
    657c:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    657e:	80 e0       	ldi	r24, 0x00	; 0
    6580:	60 e0       	ldi	r22, 0x00	; 0
    6582:	0e 94 b2 31 	call	0x6364	; 0x6364 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6586:	80 e5       	ldi	r24, 0x50	; 80
    6588:	90 e0       	ldi	r25, 0x00	; 0
    658a:	fc 01       	movw	r30, r24
    658c:	81 81       	ldd	r24, Z+1	; 0x01
    658e:	88 2f       	mov	r24, r24
    6590:	90 e0       	ldi	r25, 0x00	; 0
    6592:	82 70       	andi	r24, 0x02	; 2
    6594:	90 70       	andi	r25, 0x00	; 0
    6596:	00 97       	sbiw	r24, 0x00	; 0
    6598:	b1 f3       	breq	.-20     	; 0x6586 <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    659a:	81 e0       	ldi	r24, 0x01	; 1
    659c:	0e 94 c8 31 	call	0x6390	; 0x6390 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    65a0:	81 e0       	ldi	r24, 0x01	; 1
    65a2:	0e 94 92 31 	call	0x6324	; 0x6324 <CLKSYS_Disable>
	
}
    65a6:	df 91       	pop	r29
    65a8:	cf 91       	pop	r28
    65aa:	08 95       	ret

000065ac <portExCS>:


void portExCS(uint8_t write) {
    65ac:	0f 93       	push	r16
    65ae:	1f 93       	push	r17
    65b0:	cf 93       	push	r28
    65b2:	df 93       	push	r29
    65b4:	cd b7       	in	r28, 0x3d	; 61
    65b6:	de b7       	in	r29, 0x3e	; 62
    65b8:	69 97       	sbiw	r28, 0x19	; 25
    65ba:	cd bf       	out	0x3d, r28	; 61
    65bc:	de bf       	out	0x3e, r29	; 62
    65be:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    65c0:	89 8d       	ldd	r24, Y+25	; 0x19
    65c2:	88 23       	and	r24, r24
    65c4:	31 f0       	breq	.+12     	; 0x65d2 <portExCS+0x26>
    65c6:	80 e0       	ldi	r24, 0x00	; 0
    65c8:	96 e0       	ldi	r25, 0x06	; 6
    65ca:	28 e0       	ldi	r18, 0x08	; 8
    65cc:	fc 01       	movw	r30, r24
    65ce:	26 83       	std	Z+6, r18	; 0x06
    65d0:	05 c0       	rjmp	.+10     	; 0x65dc <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    65d2:	80 e0       	ldi	r24, 0x00	; 0
    65d4:	96 e0       	ldi	r25, 0x06	; 6
    65d6:	28 e0       	ldi	r18, 0x08	; 8
    65d8:	fc 01       	movw	r30, r24
    65da:	25 83       	std	Z+5, r18	; 0x05
    65dc:	80 e0       	ldi	r24, 0x00	; 0
    65de:	90 e0       	ldi	r25, 0x00	; 0
    65e0:	a0 e2       	ldi	r26, 0x20	; 32
    65e2:	b1 e4       	ldi	r27, 0x41	; 65
    65e4:	89 83       	std	Y+1, r24	; 0x01
    65e6:	9a 83       	std	Y+2, r25	; 0x02
    65e8:	ab 83       	std	Y+3, r26	; 0x03
    65ea:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    65ec:	69 81       	ldd	r22, Y+1	; 0x01
    65ee:	7a 81       	ldd	r23, Y+2	; 0x02
    65f0:	8b 81       	ldd	r24, Y+3	; 0x03
    65f2:	9c 81       	ldd	r25, Y+4	; 0x04
    65f4:	2b ea       	ldi	r18, 0xAB	; 171
    65f6:	3a ea       	ldi	r19, 0xAA	; 170
    65f8:	4a e2       	ldi	r20, 0x2A	; 42
    65fa:	51 e4       	ldi	r21, 0x41	; 65
    65fc:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6600:	dc 01       	movw	r26, r24
    6602:	cb 01       	movw	r24, r22
    6604:	8d 83       	std	Y+5, r24	; 0x05
    6606:	9e 83       	std	Y+6, r25	; 0x06
    6608:	af 83       	std	Y+7, r26	; 0x07
    660a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    660c:	11 e0       	ldi	r17, 0x01	; 1
    660e:	6d 81       	ldd	r22, Y+5	; 0x05
    6610:	7e 81       	ldd	r23, Y+6	; 0x06
    6612:	8f 81       	ldd	r24, Y+7	; 0x07
    6614:	98 85       	ldd	r25, Y+8	; 0x08
    6616:	20 e0       	ldi	r18, 0x00	; 0
    6618:	30 e0       	ldi	r19, 0x00	; 0
    661a:	40 e8       	ldi	r20, 0x80	; 128
    661c:	5f e3       	ldi	r21, 0x3F	; 63
    661e:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    6622:	88 23       	and	r24, r24
    6624:	0c f0       	brlt	.+2      	; 0x6628 <portExCS+0x7c>
    6626:	10 e0       	ldi	r17, 0x00	; 0
    6628:	11 23       	and	r17, r17
    662a:	19 f0       	breq	.+6      	; 0x6632 <portExCS+0x86>
		__ticks = 1;
    662c:	81 e0       	ldi	r24, 0x01	; 1
    662e:	89 87       	std	Y+9, r24	; 0x09
    6630:	a3 c0       	rjmp	.+326    	; 0x6778 <portExCS+0x1cc>
	else if (__tmp > 255)
    6632:	11 e0       	ldi	r17, 0x01	; 1
    6634:	6d 81       	ldd	r22, Y+5	; 0x05
    6636:	7e 81       	ldd	r23, Y+6	; 0x06
    6638:	8f 81       	ldd	r24, Y+7	; 0x07
    663a:	98 85       	ldd	r25, Y+8	; 0x08
    663c:	20 e0       	ldi	r18, 0x00	; 0
    663e:	30 e0       	ldi	r19, 0x00	; 0
    6640:	4f e7       	ldi	r20, 0x7F	; 127
    6642:	53 e4       	ldi	r21, 0x43	; 67
    6644:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    6648:	18 16       	cp	r1, r24
    664a:	0c f0       	brlt	.+2      	; 0x664e <portExCS+0xa2>
    664c:	10 e0       	ldi	r17, 0x00	; 0
    664e:	11 23       	and	r17, r17
    6650:	09 f4       	brne	.+2      	; 0x6654 <portExCS+0xa8>
    6652:	89 c0       	rjmp	.+274    	; 0x6766 <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    6654:	69 81       	ldd	r22, Y+1	; 0x01
    6656:	7a 81       	ldd	r23, Y+2	; 0x02
    6658:	8b 81       	ldd	r24, Y+3	; 0x03
    665a:	9c 81       	ldd	r25, Y+4	; 0x04
    665c:	20 e0       	ldi	r18, 0x00	; 0
    665e:	30 e0       	ldi	r19, 0x00	; 0
    6660:	4a e7       	ldi	r20, 0x7A	; 122
    6662:	54 e4       	ldi	r21, 0x44	; 68
    6664:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    6668:	dc 01       	movw	r26, r24
    666a:	cb 01       	movw	r24, r22
    666c:	8a 87       	std	Y+10, r24	; 0x0a
    666e:	9b 87       	std	Y+11, r25	; 0x0b
    6670:	ac 87       	std	Y+12, r26	; 0x0c
    6672:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6674:	6a 85       	ldd	r22, Y+10	; 0x0a
    6676:	7b 85       	ldd	r23, Y+11	; 0x0b
    6678:	8c 85       	ldd	r24, Y+12	; 0x0c
    667a:	9d 85       	ldd	r25, Y+13	; 0x0d
    667c:	20 e0       	ldi	r18, 0x00	; 0
    667e:	30 e0       	ldi	r19, 0x00	; 0
    6680:	4a ef       	ldi	r20, 0xFA	; 250
    6682:	55 e4       	ldi	r21, 0x45	; 69
    6684:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6688:	dc 01       	movw	r26, r24
    668a:	cb 01       	movw	r24, r22
    668c:	8e 87       	std	Y+14, r24	; 0x0e
    668e:	9f 87       	std	Y+15, r25	; 0x0f
    6690:	a8 8b       	std	Y+16, r26	; 0x10
    6692:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    6694:	11 e0       	ldi	r17, 0x01	; 1
    6696:	6e 85       	ldd	r22, Y+14	; 0x0e
    6698:	7f 85       	ldd	r23, Y+15	; 0x0f
    669a:	88 89       	ldd	r24, Y+16	; 0x10
    669c:	99 89       	ldd	r25, Y+17	; 0x11
    669e:	20 e0       	ldi	r18, 0x00	; 0
    66a0:	30 e0       	ldi	r19, 0x00	; 0
    66a2:	40 e8       	ldi	r20, 0x80	; 128
    66a4:	5f e3       	ldi	r21, 0x3F	; 63
    66a6:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    66aa:	88 23       	and	r24, r24
    66ac:	0c f0       	brlt	.+2      	; 0x66b0 <portExCS+0x104>
    66ae:	10 e0       	ldi	r17, 0x00	; 0
    66b0:	11 23       	and	r17, r17
    66b2:	29 f0       	breq	.+10     	; 0x66be <portExCS+0x112>
		__ticks = 1;
    66b4:	81 e0       	ldi	r24, 0x01	; 1
    66b6:	90 e0       	ldi	r25, 0x00	; 0
    66b8:	8a 8b       	std	Y+18, r24	; 0x12
    66ba:	9b 8b       	std	Y+19, r25	; 0x13
    66bc:	46 c0       	rjmp	.+140    	; 0x674a <portExCS+0x19e>
	else if (__tmp > 65535)
    66be:	11 e0       	ldi	r17, 0x01	; 1
    66c0:	6e 85       	ldd	r22, Y+14	; 0x0e
    66c2:	7f 85       	ldd	r23, Y+15	; 0x0f
    66c4:	88 89       	ldd	r24, Y+16	; 0x10
    66c6:	99 89       	ldd	r25, Y+17	; 0x11
    66c8:	20 e0       	ldi	r18, 0x00	; 0
    66ca:	3f ef       	ldi	r19, 0xFF	; 255
    66cc:	4f e7       	ldi	r20, 0x7F	; 127
    66ce:	57 e4       	ldi	r21, 0x47	; 71
    66d0:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    66d4:	18 16       	cp	r1, r24
    66d6:	0c f0       	brlt	.+2      	; 0x66da <portExCS+0x12e>
    66d8:	10 e0       	ldi	r17, 0x00	; 0
    66da:	11 23       	and	r17, r17
    66dc:	61 f1       	breq	.+88     	; 0x6736 <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    66de:	6a 85       	ldd	r22, Y+10	; 0x0a
    66e0:	7b 85       	ldd	r23, Y+11	; 0x0b
    66e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    66e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    66e6:	20 e0       	ldi	r18, 0x00	; 0
    66e8:	30 e0       	ldi	r19, 0x00	; 0
    66ea:	40 e2       	ldi	r20, 0x20	; 32
    66ec:	51 e4       	ldi	r21, 0x41	; 65
    66ee:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    66f2:	dc 01       	movw	r26, r24
    66f4:	cb 01       	movw	r24, r22
    66f6:	bc 01       	movw	r22, r24
    66f8:	cd 01       	movw	r24, r26
    66fa:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    66fe:	dc 01       	movw	r26, r24
    6700:	cb 01       	movw	r24, r22
    6702:	8a 8b       	std	Y+18, r24	; 0x12
    6704:	9b 8b       	std	Y+19, r25	; 0x13
    6706:	12 c0       	rjmp	.+36     	; 0x672c <portExCS+0x180>
    6708:	80 e2       	ldi	r24, 0x20	; 32
    670a:	93 e0       	ldi	r25, 0x03	; 3
    670c:	8c 8b       	std	Y+20, r24	; 0x14
    670e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6710:	8c 89       	ldd	r24, Y+20	; 0x14
    6712:	9d 89       	ldd	r25, Y+21	; 0x15
    6714:	8c 01       	movw	r16, r24
    6716:	c8 01       	movw	r24, r16
    6718:	01 97       	sbiw	r24, 0x01	; 1
    671a:	f1 f7       	brne	.-4      	; 0x6718 <portExCS+0x16c>
    671c:	8c 01       	movw	r16, r24
    671e:	0c 8b       	std	Y+20, r16	; 0x14
    6720:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6722:	8a 89       	ldd	r24, Y+18	; 0x12
    6724:	9b 89       	ldd	r25, Y+19	; 0x13
    6726:	01 97       	sbiw	r24, 0x01	; 1
    6728:	8a 8b       	std	Y+18, r24	; 0x12
    672a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    672c:	8a 89       	ldd	r24, Y+18	; 0x12
    672e:	9b 89       	ldd	r25, Y+19	; 0x13
    6730:	00 97       	sbiw	r24, 0x00	; 0
    6732:	51 f7       	brne	.-44     	; 0x6708 <portExCS+0x15c>
    6734:	28 c0       	rjmp	.+80     	; 0x6786 <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6736:	6e 85       	ldd	r22, Y+14	; 0x0e
    6738:	7f 85       	ldd	r23, Y+15	; 0x0f
    673a:	88 89       	ldd	r24, Y+16	; 0x10
    673c:	99 89       	ldd	r25, Y+17	; 0x11
    673e:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6742:	dc 01       	movw	r26, r24
    6744:	cb 01       	movw	r24, r22
    6746:	8a 8b       	std	Y+18, r24	; 0x12
    6748:	9b 8b       	std	Y+19, r25	; 0x13
    674a:	8a 89       	ldd	r24, Y+18	; 0x12
    674c:	9b 89       	ldd	r25, Y+19	; 0x13
    674e:	8e 8b       	std	Y+22, r24	; 0x16
    6750:	9f 8b       	std	Y+23, r25	; 0x17
    6752:	8e 89       	ldd	r24, Y+22	; 0x16
    6754:	9f 89       	ldd	r25, Y+23	; 0x17
    6756:	8c 01       	movw	r16, r24
    6758:	f8 01       	movw	r30, r16
    675a:	31 97       	sbiw	r30, 0x01	; 1
    675c:	f1 f7       	brne	.-4      	; 0x675a <portExCS+0x1ae>
    675e:	8f 01       	movw	r16, r30
    6760:	0e 8b       	std	Y+22, r16	; 0x16
    6762:	1f 8b       	std	Y+23, r17	; 0x17
    6764:	10 c0       	rjmp	.+32     	; 0x6786 <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6766:	6d 81       	ldd	r22, Y+5	; 0x05
    6768:	7e 81       	ldd	r23, Y+6	; 0x06
    676a:	8f 81       	ldd	r24, Y+7	; 0x07
    676c:	98 85       	ldd	r25, Y+8	; 0x08
    676e:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6772:	dc 01       	movw	r26, r24
    6774:	cb 01       	movw	r24, r22
    6776:	89 87       	std	Y+9, r24	; 0x09
    6778:	89 85       	ldd	r24, Y+9	; 0x09
    677a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    677c:	88 8d       	ldd	r24, Y+24	; 0x18
    677e:	18 2f       	mov	r17, r24
    6780:	1a 95       	dec	r17
    6782:	f1 f7       	brne	.-4      	; 0x6780 <portExCS+0x1d4>
    6784:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    6786:	69 96       	adiw	r28, 0x19	; 25
    6788:	cd bf       	out	0x3d, r28	; 61
    678a:	de bf       	out	0x3e, r29	; 62
    678c:	df 91       	pop	r29
    678e:	cf 91       	pop	r28
    6790:	1f 91       	pop	r17
    6792:	0f 91       	pop	r16
    6794:	08 95       	ret

00006796 <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    6796:	cf 93       	push	r28
    6798:	df 93       	push	r29
    679a:	00 d0       	rcall	.+0      	; 0x679c <PortEx_DIRSET+0x6>
    679c:	cd b7       	in	r28, 0x3d	; 61
    679e:	de b7       	in	r29, 0x3e	; 62
    67a0:	8a 83       	std	Y+2, r24	; 0x02
    67a2:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    67a4:	80 e0       	ldi	r24, 0x00	; 0
    67a6:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    67aa:	81 e0       	ldi	r24, 0x01	; 1
    67ac:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	portExCS(TRUE);
    67b0:	81 e0       	ldi	r24, 0x01	; 1
    67b2:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    67b6:	8b 81       	ldd	r24, Y+3	; 0x03
    67b8:	88 23       	and	r24, r24
    67ba:	39 f0       	breq	.+14     	; 0x67ca <PortEx_DIRSET+0x34>
    67bc:	90 91 54 50 	lds	r25, 0x5054
    67c0:	8a 81       	ldd	r24, Y+2	; 0x02
    67c2:	89 2b       	or	r24, r25
    67c4:	80 93 54 50 	sts	0x5054, r24
    67c8:	06 c0       	rjmp	.+12     	; 0x67d6 <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    67ca:	90 91 bd 50 	lds	r25, 0x50BD
    67ce:	8a 81       	ldd	r24, Y+2	; 0x02
    67d0:	89 2b       	or	r24, r25
    67d2:	80 93 bd 50 	sts	0x50BD, r24
	
	SPIBuffer[0] = PS_WRITE;
    67d6:	80 e4       	ldi	r24, 0x40	; 64
    67d8:	80 93 45 50 	sts	0x5045, r24
	if(bank) {
    67dc:	8b 81       	ldd	r24, Y+3	; 0x03
    67de:	88 23       	and	r24, r24
    67e0:	41 f0       	breq	.+16     	; 0x67f2 <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    67e2:	10 92 46 50 	sts	0x5046, r1
		SPIBuffer[2] = ~bankA_DIR; 
    67e6:	80 91 54 50 	lds	r24, 0x5054
    67ea:	80 95       	com	r24
    67ec:	80 93 47 50 	sts	0x5047, r24
    67f0:	08 c0       	rjmp	.+16     	; 0x6802 <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    67f2:	81 e0       	ldi	r24, 0x01	; 1
    67f4:	80 93 46 50 	sts	0x5046, r24
		SPIBuffer[2] = ~bankB_DIR;
    67f8:	80 91 bd 50 	lds	r24, 0x50BD
    67fc:	80 95       	com	r24
    67fe:	80 93 47 50 	sts	0x5047, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6802:	19 82       	std	Y+1, r1	; 0x01
    6804:	1b c0       	rjmp	.+54     	; 0x683c <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    6806:	80 ec       	ldi	r24, 0xC0	; 192
    6808:	98 e0       	ldi	r25, 0x08	; 8
    680a:	29 81       	ldd	r18, Y+1	; 0x01
    680c:	22 2f       	mov	r18, r18
    680e:	30 e0       	ldi	r19, 0x00	; 0
    6810:	2b 5b       	subi	r18, 0xBB	; 187
    6812:	3f 4a       	sbci	r19, 0xAF	; 175
    6814:	f9 01       	movw	r30, r18
    6816:	20 81       	ld	r18, Z
    6818:	fc 01       	movw	r30, r24
    681a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    681c:	00 00       	nop
    681e:	80 ec       	ldi	r24, 0xC0	; 192
    6820:	98 e0       	ldi	r25, 0x08	; 8
    6822:	fc 01       	movw	r30, r24
    6824:	82 81       	ldd	r24, Z+2	; 0x02
    6826:	88 23       	and	r24, r24
    6828:	d4 f7       	brge	.-12     	; 0x681e <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    682a:	80 ec       	ldi	r24, 0xC0	; 192
    682c:	98 e0       	ldi	r25, 0x08	; 8
    682e:	fc 01       	movw	r30, r24
    6830:	83 81       	ldd	r24, Z+3	; 0x03
    6832:	80 93 51 50 	sts	0x5051, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6836:	89 81       	ldd	r24, Y+1	; 0x01
    6838:	8f 5f       	subi	r24, 0xFF	; 255
    683a:	89 83       	std	Y+1, r24	; 0x01
    683c:	89 81       	ldd	r24, Y+1	; 0x01
    683e:	83 30       	cpi	r24, 0x03	; 3
    6840:	10 f3       	brcs	.-60     	; 0x6806 <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    6842:	80 e0       	ldi	r24, 0x00	; 0
    6844:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>
	SPICS(FALSE);
    6848:	80 e0       	ldi	r24, 0x00	; 0
    684a:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    684e:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>


}
    6852:	23 96       	adiw	r28, 0x03	; 3
    6854:	cd bf       	out	0x3d, r28	; 61
    6856:	de bf       	out	0x3e, r29	; 62
    6858:	df 91       	pop	r29
    685a:	cf 91       	pop	r28
    685c:	08 95       	ret

0000685e <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    685e:	cf 93       	push	r28
    6860:	df 93       	push	r29
    6862:	00 d0       	rcall	.+0      	; 0x6864 <PortEx_DIRCLR+0x6>
    6864:	cd b7       	in	r28, 0x3d	; 61
    6866:	de b7       	in	r29, 0x3e	; 62
    6868:	8a 83       	std	Y+2, r24	; 0x02
    686a:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    686c:	80 e0       	ldi	r24, 0x00	; 0
    686e:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    6872:	81 e0       	ldi	r24, 0x01	; 1
    6874:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	portExCS(TRUE);
    6878:	81 e0       	ldi	r24, 0x01	; 1
    687a:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    687e:	8b 81       	ldd	r24, Y+3	; 0x03
    6880:	88 23       	and	r24, r24
    6882:	49 f0       	breq	.+18     	; 0x6896 <PortEx_DIRCLR+0x38>
    6884:	80 91 54 50 	lds	r24, 0x5054
    6888:	98 2f       	mov	r25, r24
    688a:	90 95       	com	r25
    688c:	8a 81       	ldd	r24, Y+2	; 0x02
    688e:	89 23       	and	r24, r25
    6890:	80 93 54 50 	sts	0x5054, r24
    6894:	08 c0       	rjmp	.+16     	; 0x68a6 <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    6896:	80 91 bd 50 	lds	r24, 0x50BD
    689a:	98 2f       	mov	r25, r24
    689c:	90 95       	com	r25
    689e:	8a 81       	ldd	r24, Y+2	; 0x02
    68a0:	89 23       	and	r24, r25
    68a2:	80 93 bd 50 	sts	0x50BD, r24
	
	SPIBuffer[0] = PS_WRITE;
    68a6:	80 e4       	ldi	r24, 0x40	; 64
    68a8:	80 93 45 50 	sts	0x5045, r24
	if(bank) {
    68ac:	8b 81       	ldd	r24, Y+3	; 0x03
    68ae:	88 23       	and	r24, r24
    68b0:	41 f0       	breq	.+16     	; 0x68c2 <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    68b2:	10 92 46 50 	sts	0x5046, r1
		SPIBuffer[2] = ~bankA_DIR; 
    68b6:	80 91 54 50 	lds	r24, 0x5054
    68ba:	80 95       	com	r24
    68bc:	80 93 47 50 	sts	0x5047, r24
    68c0:	08 c0       	rjmp	.+16     	; 0x68d2 <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    68c2:	81 e0       	ldi	r24, 0x01	; 1
    68c4:	80 93 46 50 	sts	0x5046, r24
		SPIBuffer[2] = ~bankB_DIR;
    68c8:	80 91 bd 50 	lds	r24, 0x50BD
    68cc:	80 95       	com	r24
    68ce:	80 93 47 50 	sts	0x5047, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    68d2:	19 82       	std	Y+1, r1	; 0x01
    68d4:	1b c0       	rjmp	.+54     	; 0x690c <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    68d6:	80 ec       	ldi	r24, 0xC0	; 192
    68d8:	98 e0       	ldi	r25, 0x08	; 8
    68da:	29 81       	ldd	r18, Y+1	; 0x01
    68dc:	22 2f       	mov	r18, r18
    68de:	30 e0       	ldi	r19, 0x00	; 0
    68e0:	2b 5b       	subi	r18, 0xBB	; 187
    68e2:	3f 4a       	sbci	r19, 0xAF	; 175
    68e4:	f9 01       	movw	r30, r18
    68e6:	20 81       	ld	r18, Z
    68e8:	fc 01       	movw	r30, r24
    68ea:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    68ec:	00 00       	nop
    68ee:	80 ec       	ldi	r24, 0xC0	; 192
    68f0:	98 e0       	ldi	r25, 0x08	; 8
    68f2:	fc 01       	movw	r30, r24
    68f4:	82 81       	ldd	r24, Z+2	; 0x02
    68f6:	88 23       	and	r24, r24
    68f8:	d4 f7       	brge	.-12     	; 0x68ee <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    68fa:	80 ec       	ldi	r24, 0xC0	; 192
    68fc:	98 e0       	ldi	r25, 0x08	; 8
    68fe:	fc 01       	movw	r30, r24
    6900:	83 81       	ldd	r24, Z+3	; 0x03
    6902:	80 93 51 50 	sts	0x5051, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6906:	89 81       	ldd	r24, Y+1	; 0x01
    6908:	8f 5f       	subi	r24, 0xFF	; 255
    690a:	89 83       	std	Y+1, r24	; 0x01
    690c:	89 81       	ldd	r24, Y+1	; 0x01
    690e:	83 30       	cpi	r24, 0x03	; 3
    6910:	10 f3       	brcs	.-60     	; 0x68d6 <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6912:	80 e0       	ldi	r24, 0x00	; 0
    6914:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	portExCS(FALSE);
    6918:	80 e0       	ldi	r24, 0x00	; 0
    691a:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>
	SPIDisable();
    691e:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
}
    6922:	23 96       	adiw	r28, 0x03	; 3
    6924:	cd bf       	out	0x3d, r28	; 61
    6926:	de bf       	out	0x3e, r29	; 62
    6928:	df 91       	pop	r29
    692a:	cf 91       	pop	r28
    692c:	08 95       	ret

0000692e <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    692e:	cf 93       	push	r28
    6930:	df 93       	push	r29
    6932:	00 d0       	rcall	.+0      	; 0x6934 <PortEx_OUTSET+0x6>
    6934:	cd b7       	in	r28, 0x3d	; 61
    6936:	de b7       	in	r29, 0x3e	; 62
    6938:	8a 83       	std	Y+2, r24	; 0x02
    693a:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    693c:	80 e0       	ldi	r24, 0x00	; 0
    693e:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    6942:	81 e0       	ldi	r24, 0x01	; 1
    6944:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	portExCS(TRUE);
    6948:	81 e0       	ldi	r24, 0x01	; 1
    694a:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    694e:	8b 81       	ldd	r24, Y+3	; 0x03
    6950:	88 23       	and	r24, r24
    6952:	39 f0       	breq	.+14     	; 0x6962 <PortEx_OUTSET+0x34>
    6954:	90 91 b7 23 	lds	r25, 0x23B7
    6958:	8a 81       	ldd	r24, Y+2	; 0x02
    695a:	89 2b       	or	r24, r25
    695c:	80 93 b7 23 	sts	0x23B7, r24
    6960:	06 c0       	rjmp	.+12     	; 0x696e <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6962:	90 91 5c 50 	lds	r25, 0x505C
    6966:	8a 81       	ldd	r24, Y+2	; 0x02
    6968:	89 2b       	or	r24, r25
    696a:	80 93 5c 50 	sts	0x505C, r24
	
	SPIBuffer[0] = PS_WRITE;
    696e:	80 e4       	ldi	r24, 0x40	; 64
    6970:	80 93 45 50 	sts	0x5045, r24
	if(bank) {
    6974:	8b 81       	ldd	r24, Y+3	; 0x03
    6976:	88 23       	and	r24, r24
    6978:	41 f0       	breq	.+16     	; 0x698a <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    697a:	84 e1       	ldi	r24, 0x14	; 20
    697c:	80 93 46 50 	sts	0x5046, r24
		SPIBuffer[2] = bankA_OUT;
    6980:	80 91 b7 23 	lds	r24, 0x23B7
    6984:	80 93 47 50 	sts	0x5047, r24
    6988:	07 c0       	rjmp	.+14     	; 0x6998 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    698a:	85 e1       	ldi	r24, 0x15	; 21
    698c:	80 93 46 50 	sts	0x5046, r24
		SPIBuffer[2] = bankB_OUT; 
    6990:	80 91 5c 50 	lds	r24, 0x505C
    6994:	80 93 47 50 	sts	0x5047, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6998:	19 82       	std	Y+1, r1	; 0x01
    699a:	1b c0       	rjmp	.+54     	; 0x69d2 <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    699c:	80 ec       	ldi	r24, 0xC0	; 192
    699e:	98 e0       	ldi	r25, 0x08	; 8
    69a0:	29 81       	ldd	r18, Y+1	; 0x01
    69a2:	22 2f       	mov	r18, r18
    69a4:	30 e0       	ldi	r19, 0x00	; 0
    69a6:	2b 5b       	subi	r18, 0xBB	; 187
    69a8:	3f 4a       	sbci	r19, 0xAF	; 175
    69aa:	f9 01       	movw	r30, r18
    69ac:	20 81       	ld	r18, Z
    69ae:	fc 01       	movw	r30, r24
    69b0:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    69b2:	00 00       	nop
    69b4:	80 ec       	ldi	r24, 0xC0	; 192
    69b6:	98 e0       	ldi	r25, 0x08	; 8
    69b8:	fc 01       	movw	r30, r24
    69ba:	82 81       	ldd	r24, Z+2	; 0x02
    69bc:	88 23       	and	r24, r24
    69be:	d4 f7       	brge	.-12     	; 0x69b4 <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    69c0:	80 ec       	ldi	r24, 0xC0	; 192
    69c2:	98 e0       	ldi	r25, 0x08	; 8
    69c4:	fc 01       	movw	r30, r24
    69c6:	83 81       	ldd	r24, Z+3	; 0x03
    69c8:	80 93 51 50 	sts	0x5051, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    69cc:	89 81       	ldd	r24, Y+1	; 0x01
    69ce:	8f 5f       	subi	r24, 0xFF	; 255
    69d0:	89 83       	std	Y+1, r24	; 0x01
    69d2:	89 81       	ldd	r24, Y+1	; 0x01
    69d4:	83 30       	cpi	r24, 0x03	; 3
    69d6:	10 f3       	brcs	.-60     	; 0x699c <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    69d8:	80 e0       	ldi	r24, 0x00	; 0
    69da:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	portExCS(FALSE);
    69de:	80 e0       	ldi	r24, 0x00	; 0
    69e0:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>
	SPIDisable();
    69e4:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
}
    69e8:	23 96       	adiw	r28, 0x03	; 3
    69ea:	cd bf       	out	0x3d, r28	; 61
    69ec:	de bf       	out	0x3e, r29	; 62
    69ee:	df 91       	pop	r29
    69f0:	cf 91       	pop	r28
    69f2:	08 95       	ret

000069f4 <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    69f4:	cf 93       	push	r28
    69f6:	df 93       	push	r29
    69f8:	00 d0       	rcall	.+0      	; 0x69fa <PortEx_OUTCLR+0x6>
    69fa:	cd b7       	in	r28, 0x3d	; 61
    69fc:	de b7       	in	r29, 0x3e	; 62
    69fe:	8a 83       	std	Y+2, r24	; 0x02
    6a00:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6a02:	80 e0       	ldi	r24, 0x00	; 0
    6a04:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    6a08:	81 e0       	ldi	r24, 0x01	; 1
    6a0a:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	portExCS(TRUE);
    6a0e:	81 e0       	ldi	r24, 0x01	; 1
    6a10:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    6a14:	8b 81       	ldd	r24, Y+3	; 0x03
    6a16:	88 23       	and	r24, r24
    6a18:	49 f0       	breq	.+18     	; 0x6a2c <PortEx_OUTCLR+0x38>
    6a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    6a1c:	98 2f       	mov	r25, r24
    6a1e:	90 95       	com	r25
    6a20:	80 91 b7 23 	lds	r24, 0x23B7
    6a24:	89 23       	and	r24, r25
    6a26:	80 93 b7 23 	sts	0x23B7, r24
    6a2a:	08 c0       	rjmp	.+16     	; 0x6a3c <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6a2c:	8a 81       	ldd	r24, Y+2	; 0x02
    6a2e:	98 2f       	mov	r25, r24
    6a30:	90 95       	com	r25
    6a32:	80 91 5c 50 	lds	r24, 0x505C
    6a36:	89 23       	and	r24, r25
    6a38:	80 93 5c 50 	sts	0x505C, r24
	
	SPIBuffer[0] = PS_WRITE;
    6a3c:	80 e4       	ldi	r24, 0x40	; 64
    6a3e:	80 93 45 50 	sts	0x5045, r24
	if(bank) {
    6a42:	8b 81       	ldd	r24, Y+3	; 0x03
    6a44:	88 23       	and	r24, r24
    6a46:	41 f0       	breq	.+16     	; 0x6a58 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6a48:	84 e1       	ldi	r24, 0x14	; 20
    6a4a:	80 93 46 50 	sts	0x5046, r24
		SPIBuffer[2] = bankA_OUT;
    6a4e:	80 91 b7 23 	lds	r24, 0x23B7
    6a52:	80 93 47 50 	sts	0x5047, r24
    6a56:	07 c0       	rjmp	.+14     	; 0x6a66 <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6a58:	85 e1       	ldi	r24, 0x15	; 21
    6a5a:	80 93 46 50 	sts	0x5046, r24
		SPIBuffer[2] = bankB_OUT; 
    6a5e:	80 91 5c 50 	lds	r24, 0x505C
    6a62:	80 93 47 50 	sts	0x5047, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6a66:	19 82       	std	Y+1, r1	; 0x01
    6a68:	1b c0       	rjmp	.+54     	; 0x6aa0 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6a6a:	80 ec       	ldi	r24, 0xC0	; 192
    6a6c:	98 e0       	ldi	r25, 0x08	; 8
    6a6e:	29 81       	ldd	r18, Y+1	; 0x01
    6a70:	22 2f       	mov	r18, r18
    6a72:	30 e0       	ldi	r19, 0x00	; 0
    6a74:	2b 5b       	subi	r18, 0xBB	; 187
    6a76:	3f 4a       	sbci	r19, 0xAF	; 175
    6a78:	f9 01       	movw	r30, r18
    6a7a:	20 81       	ld	r18, Z
    6a7c:	fc 01       	movw	r30, r24
    6a7e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6a80:	00 00       	nop
    6a82:	80 ec       	ldi	r24, 0xC0	; 192
    6a84:	98 e0       	ldi	r25, 0x08	; 8
    6a86:	fc 01       	movw	r30, r24
    6a88:	82 81       	ldd	r24, Z+2	; 0x02
    6a8a:	88 23       	and	r24, r24
    6a8c:	d4 f7       	brge	.-12     	; 0x6a82 <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6a8e:	80 ec       	ldi	r24, 0xC0	; 192
    6a90:	98 e0       	ldi	r25, 0x08	; 8
    6a92:	fc 01       	movw	r30, r24
    6a94:	83 81       	ldd	r24, Z+3	; 0x03
    6a96:	80 93 51 50 	sts	0x5051, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6a9a:	89 81       	ldd	r24, Y+1	; 0x01
    6a9c:	8f 5f       	subi	r24, 0xFF	; 255
    6a9e:	89 83       	std	Y+1, r24	; 0x01
    6aa0:	89 81       	ldd	r24, Y+1	; 0x01
    6aa2:	83 30       	cpi	r24, 0x03	; 3
    6aa4:	10 f3       	brcs	.-60     	; 0x6a6a <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6aa6:	80 e0       	ldi	r24, 0x00	; 0
    6aa8:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	portExCS(FALSE);
    6aac:	80 e0       	ldi	r24, 0x00	; 0
    6aae:	0e 94 d6 32 	call	0x65ac	; 0x65ac <portExCS>
	SPIDisable();
    6ab2:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
}
    6ab6:	23 96       	adiw	r28, 0x03	; 3
    6ab8:	cd bf       	out	0x3d, r28	; 61
    6aba:	de bf       	out	0x3e, r29	; 62
    6abc:	df 91       	pop	r29
    6abe:	cf 91       	pop	r28
    6ac0:	08 95       	ret

00006ac2 <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6ac2:	0f 93       	push	r16
    6ac4:	1f 93       	push	r17
    6ac6:	cf 93       	push	r28
    6ac8:	df 93       	push	r29
    6aca:	cd b7       	in	r28, 0x3d	; 61
    6acc:	de b7       	in	r29, 0x3e	; 62
    6ace:	2f 97       	sbiw	r28, 0x0f	; 15
    6ad0:	cd bf       	out	0x3d, r28	; 61
    6ad2:	de bf       	out	0x3e, r29	; 62
    6ad4:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6ad6:	8f 85       	ldd	r24, Y+15	; 0x0f
    6ad8:	88 23       	and	r24, r24
    6ada:	09 f4       	brne	.+2      	; 0x6ade <Ext1Power+0x1c>
    6adc:	8b c0       	rjmp	.+278    	; 0x6bf4 <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6ade:	80 ea       	ldi	r24, 0xA0	; 160
    6ae0:	96 e0       	ldi	r25, 0x06	; 6
    6ae2:	20 e2       	ldi	r18, 0x20	; 32
    6ae4:	fc 01       	movw	r30, r24
    6ae6:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6ae8:	80 ea       	ldi	r24, 0xA0	; 160
    6aea:	96 e0       	ldi	r25, 0x06	; 6
    6aec:	20 e2       	ldi	r18, 0x20	; 32
    6aee:	fc 01       	movw	r30, r24
    6af0:	25 83       	std	Z+5, r18	; 0x05
    6af2:	80 e0       	ldi	r24, 0x00	; 0
    6af4:	90 e0       	ldi	r25, 0x00	; 0
    6af6:	a8 ec       	ldi	r26, 0xC8	; 200
    6af8:	b2 e4       	ldi	r27, 0x42	; 66
    6afa:	89 83       	std	Y+1, r24	; 0x01
    6afc:	9a 83       	std	Y+2, r25	; 0x02
    6afe:	ab 83       	std	Y+3, r26	; 0x03
    6b00:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6b02:	69 81       	ldd	r22, Y+1	; 0x01
    6b04:	7a 81       	ldd	r23, Y+2	; 0x02
    6b06:	8b 81       	ldd	r24, Y+3	; 0x03
    6b08:	9c 81       	ldd	r25, Y+4	; 0x04
    6b0a:	20 e0       	ldi	r18, 0x00	; 0
    6b0c:	30 e0       	ldi	r19, 0x00	; 0
    6b0e:	4a ef       	ldi	r20, 0xFA	; 250
    6b10:	55 e4       	ldi	r21, 0x45	; 69
    6b12:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6b16:	dc 01       	movw	r26, r24
    6b18:	cb 01       	movw	r24, r22
    6b1a:	8d 83       	std	Y+5, r24	; 0x05
    6b1c:	9e 83       	std	Y+6, r25	; 0x06
    6b1e:	af 83       	std	Y+7, r26	; 0x07
    6b20:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6b22:	11 e0       	ldi	r17, 0x01	; 1
    6b24:	6d 81       	ldd	r22, Y+5	; 0x05
    6b26:	7e 81       	ldd	r23, Y+6	; 0x06
    6b28:	8f 81       	ldd	r24, Y+7	; 0x07
    6b2a:	98 85       	ldd	r25, Y+8	; 0x08
    6b2c:	20 e0       	ldi	r18, 0x00	; 0
    6b2e:	30 e0       	ldi	r19, 0x00	; 0
    6b30:	40 e8       	ldi	r20, 0x80	; 128
    6b32:	5f e3       	ldi	r21, 0x3F	; 63
    6b34:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    6b38:	88 23       	and	r24, r24
    6b3a:	0c f0       	brlt	.+2      	; 0x6b3e <Ext1Power+0x7c>
    6b3c:	10 e0       	ldi	r17, 0x00	; 0
    6b3e:	11 23       	and	r17, r17
    6b40:	29 f0       	breq	.+10     	; 0x6b4c <Ext1Power+0x8a>
		__ticks = 1;
    6b42:	81 e0       	ldi	r24, 0x01	; 1
    6b44:	90 e0       	ldi	r25, 0x00	; 0
    6b46:	89 87       	std	Y+9, r24	; 0x09
    6b48:	9a 87       	std	Y+10, r25	; 0x0a
    6b4a:	46 c0       	rjmp	.+140    	; 0x6bd8 <Ext1Power+0x116>
	else if (__tmp > 65535)
    6b4c:	11 e0       	ldi	r17, 0x01	; 1
    6b4e:	6d 81       	ldd	r22, Y+5	; 0x05
    6b50:	7e 81       	ldd	r23, Y+6	; 0x06
    6b52:	8f 81       	ldd	r24, Y+7	; 0x07
    6b54:	98 85       	ldd	r25, Y+8	; 0x08
    6b56:	20 e0       	ldi	r18, 0x00	; 0
    6b58:	3f ef       	ldi	r19, 0xFF	; 255
    6b5a:	4f e7       	ldi	r20, 0x7F	; 127
    6b5c:	57 e4       	ldi	r21, 0x47	; 71
    6b5e:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    6b62:	18 16       	cp	r1, r24
    6b64:	0c f0       	brlt	.+2      	; 0x6b68 <Ext1Power+0xa6>
    6b66:	10 e0       	ldi	r17, 0x00	; 0
    6b68:	11 23       	and	r17, r17
    6b6a:	61 f1       	breq	.+88     	; 0x6bc4 <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6b6c:	69 81       	ldd	r22, Y+1	; 0x01
    6b6e:	7a 81       	ldd	r23, Y+2	; 0x02
    6b70:	8b 81       	ldd	r24, Y+3	; 0x03
    6b72:	9c 81       	ldd	r25, Y+4	; 0x04
    6b74:	20 e0       	ldi	r18, 0x00	; 0
    6b76:	30 e0       	ldi	r19, 0x00	; 0
    6b78:	40 e2       	ldi	r20, 0x20	; 32
    6b7a:	51 e4       	ldi	r21, 0x41	; 65
    6b7c:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6b80:	dc 01       	movw	r26, r24
    6b82:	cb 01       	movw	r24, r22
    6b84:	bc 01       	movw	r22, r24
    6b86:	cd 01       	movw	r24, r26
    6b88:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6b8c:	dc 01       	movw	r26, r24
    6b8e:	cb 01       	movw	r24, r22
    6b90:	89 87       	std	Y+9, r24	; 0x09
    6b92:	9a 87       	std	Y+10, r25	; 0x0a
    6b94:	12 c0       	rjmp	.+36     	; 0x6bba <Ext1Power+0xf8>
    6b96:	80 e2       	ldi	r24, 0x20	; 32
    6b98:	93 e0       	ldi	r25, 0x03	; 3
    6b9a:	8b 87       	std	Y+11, r24	; 0x0b
    6b9c:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6b9e:	8b 85       	ldd	r24, Y+11	; 0x0b
    6ba0:	9c 85       	ldd	r25, Y+12	; 0x0c
    6ba2:	8c 01       	movw	r16, r24
    6ba4:	c8 01       	movw	r24, r16
    6ba6:	01 97       	sbiw	r24, 0x01	; 1
    6ba8:	f1 f7       	brne	.-4      	; 0x6ba6 <Ext1Power+0xe4>
    6baa:	8c 01       	movw	r16, r24
    6bac:	0b 87       	std	Y+11, r16	; 0x0b
    6bae:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6bb0:	89 85       	ldd	r24, Y+9	; 0x09
    6bb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bb4:	01 97       	sbiw	r24, 0x01	; 1
    6bb6:	89 87       	std	Y+9, r24	; 0x09
    6bb8:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6bba:	89 85       	ldd	r24, Y+9	; 0x09
    6bbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bbe:	00 97       	sbiw	r24, 0x00	; 0
    6bc0:	51 f7       	brne	.-44     	; 0x6b96 <Ext1Power+0xd4>
    6bc2:	22 c0       	rjmp	.+68     	; 0x6c08 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6bc4:	6d 81       	ldd	r22, Y+5	; 0x05
    6bc6:	7e 81       	ldd	r23, Y+6	; 0x06
    6bc8:	8f 81       	ldd	r24, Y+7	; 0x07
    6bca:	98 85       	ldd	r25, Y+8	; 0x08
    6bcc:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6bd0:	dc 01       	movw	r26, r24
    6bd2:	cb 01       	movw	r24, r22
    6bd4:	89 87       	std	Y+9, r24	; 0x09
    6bd6:	9a 87       	std	Y+10, r25	; 0x0a
    6bd8:	89 85       	ldd	r24, Y+9	; 0x09
    6bda:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bdc:	8d 87       	std	Y+13, r24	; 0x0d
    6bde:	9e 87       	std	Y+14, r25	; 0x0e
    6be0:	8d 85       	ldd	r24, Y+13	; 0x0d
    6be2:	9e 85       	ldd	r25, Y+14	; 0x0e
    6be4:	8c 01       	movw	r16, r24
    6be6:	f8 01       	movw	r30, r16
    6be8:	31 97       	sbiw	r30, 0x01	; 1
    6bea:	f1 f7       	brne	.-4      	; 0x6be8 <Ext1Power+0x126>
    6bec:	8f 01       	movw	r16, r30
    6bee:	0d 87       	std	Y+13, r16	; 0x0d
    6bf0:	1e 87       	std	Y+14, r17	; 0x0e
    6bf2:	0a c0       	rjmp	.+20     	; 0x6c08 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6bf4:	80 ea       	ldi	r24, 0xA0	; 160
    6bf6:	96 e0       	ldi	r25, 0x06	; 6
    6bf8:	20 e2       	ldi	r18, 0x20	; 32
    6bfa:	fc 01       	movw	r30, r24
    6bfc:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6bfe:	80 ea       	ldi	r24, 0xA0	; 160
    6c00:	96 e0       	ldi	r25, 0x06	; 6
    6c02:	20 e2       	ldi	r18, 0x20	; 32
    6c04:	fc 01       	movw	r30, r24
    6c06:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6c08:	2f 96       	adiw	r28, 0x0f	; 15
    6c0a:	cd bf       	out	0x3d, r28	; 61
    6c0c:	de bf       	out	0x3e, r29	; 62
    6c0e:	df 91       	pop	r29
    6c10:	cf 91       	pop	r28
    6c12:	1f 91       	pop	r17
    6c14:	0f 91       	pop	r16
    6c16:	08 95       	ret

00006c18 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6c18:	0f 93       	push	r16
    6c1a:	1f 93       	push	r17
    6c1c:	cf 93       	push	r28
    6c1e:	df 93       	push	r29
    6c20:	cd b7       	in	r28, 0x3d	; 61
    6c22:	de b7       	in	r29, 0x3e	; 62
    6c24:	2f 97       	sbiw	r28, 0x0f	; 15
    6c26:	cd bf       	out	0x3d, r28	; 61
    6c28:	de bf       	out	0x3e, r29	; 62
    6c2a:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6c2c:	8f 85       	ldd	r24, Y+15	; 0x0f
    6c2e:	88 23       	and	r24, r24
    6c30:	09 f4       	brne	.+2      	; 0x6c34 <Ext2Power+0x1c>
    6c32:	8b c0       	rjmp	.+278    	; 0x6d4a <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6c34:	80 ea       	ldi	r24, 0xA0	; 160
    6c36:	96 e0       	ldi	r25, 0x06	; 6
    6c38:	20 e4       	ldi	r18, 0x40	; 64
    6c3a:	fc 01       	movw	r30, r24
    6c3c:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6c3e:	80 ea       	ldi	r24, 0xA0	; 160
    6c40:	96 e0       	ldi	r25, 0x06	; 6
    6c42:	20 e4       	ldi	r18, 0x40	; 64
    6c44:	fc 01       	movw	r30, r24
    6c46:	25 83       	std	Z+5, r18	; 0x05
    6c48:	80 e0       	ldi	r24, 0x00	; 0
    6c4a:	90 e0       	ldi	r25, 0x00	; 0
    6c4c:	a8 ec       	ldi	r26, 0xC8	; 200
    6c4e:	b2 e4       	ldi	r27, 0x42	; 66
    6c50:	89 83       	std	Y+1, r24	; 0x01
    6c52:	9a 83       	std	Y+2, r25	; 0x02
    6c54:	ab 83       	std	Y+3, r26	; 0x03
    6c56:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6c58:	69 81       	ldd	r22, Y+1	; 0x01
    6c5a:	7a 81       	ldd	r23, Y+2	; 0x02
    6c5c:	8b 81       	ldd	r24, Y+3	; 0x03
    6c5e:	9c 81       	ldd	r25, Y+4	; 0x04
    6c60:	20 e0       	ldi	r18, 0x00	; 0
    6c62:	30 e0       	ldi	r19, 0x00	; 0
    6c64:	4a ef       	ldi	r20, 0xFA	; 250
    6c66:	55 e4       	ldi	r21, 0x45	; 69
    6c68:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6c6c:	dc 01       	movw	r26, r24
    6c6e:	cb 01       	movw	r24, r22
    6c70:	8d 83       	std	Y+5, r24	; 0x05
    6c72:	9e 83       	std	Y+6, r25	; 0x06
    6c74:	af 83       	std	Y+7, r26	; 0x07
    6c76:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6c78:	11 e0       	ldi	r17, 0x01	; 1
    6c7a:	6d 81       	ldd	r22, Y+5	; 0x05
    6c7c:	7e 81       	ldd	r23, Y+6	; 0x06
    6c7e:	8f 81       	ldd	r24, Y+7	; 0x07
    6c80:	98 85       	ldd	r25, Y+8	; 0x08
    6c82:	20 e0       	ldi	r18, 0x00	; 0
    6c84:	30 e0       	ldi	r19, 0x00	; 0
    6c86:	40 e8       	ldi	r20, 0x80	; 128
    6c88:	5f e3       	ldi	r21, 0x3F	; 63
    6c8a:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    6c8e:	88 23       	and	r24, r24
    6c90:	0c f0       	brlt	.+2      	; 0x6c94 <Ext2Power+0x7c>
    6c92:	10 e0       	ldi	r17, 0x00	; 0
    6c94:	11 23       	and	r17, r17
    6c96:	29 f0       	breq	.+10     	; 0x6ca2 <Ext2Power+0x8a>
		__ticks = 1;
    6c98:	81 e0       	ldi	r24, 0x01	; 1
    6c9a:	90 e0       	ldi	r25, 0x00	; 0
    6c9c:	89 87       	std	Y+9, r24	; 0x09
    6c9e:	9a 87       	std	Y+10, r25	; 0x0a
    6ca0:	46 c0       	rjmp	.+140    	; 0x6d2e <Ext2Power+0x116>
	else if (__tmp > 65535)
    6ca2:	11 e0       	ldi	r17, 0x01	; 1
    6ca4:	6d 81       	ldd	r22, Y+5	; 0x05
    6ca6:	7e 81       	ldd	r23, Y+6	; 0x06
    6ca8:	8f 81       	ldd	r24, Y+7	; 0x07
    6caa:	98 85       	ldd	r25, Y+8	; 0x08
    6cac:	20 e0       	ldi	r18, 0x00	; 0
    6cae:	3f ef       	ldi	r19, 0xFF	; 255
    6cb0:	4f e7       	ldi	r20, 0x7F	; 127
    6cb2:	57 e4       	ldi	r21, 0x47	; 71
    6cb4:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    6cb8:	18 16       	cp	r1, r24
    6cba:	0c f0       	brlt	.+2      	; 0x6cbe <Ext2Power+0xa6>
    6cbc:	10 e0       	ldi	r17, 0x00	; 0
    6cbe:	11 23       	and	r17, r17
    6cc0:	61 f1       	breq	.+88     	; 0x6d1a <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6cc2:	69 81       	ldd	r22, Y+1	; 0x01
    6cc4:	7a 81       	ldd	r23, Y+2	; 0x02
    6cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    6cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    6cca:	20 e0       	ldi	r18, 0x00	; 0
    6ccc:	30 e0       	ldi	r19, 0x00	; 0
    6cce:	40 e2       	ldi	r20, 0x20	; 32
    6cd0:	51 e4       	ldi	r21, 0x41	; 65
    6cd2:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6cd6:	dc 01       	movw	r26, r24
    6cd8:	cb 01       	movw	r24, r22
    6cda:	bc 01       	movw	r22, r24
    6cdc:	cd 01       	movw	r24, r26
    6cde:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6ce2:	dc 01       	movw	r26, r24
    6ce4:	cb 01       	movw	r24, r22
    6ce6:	89 87       	std	Y+9, r24	; 0x09
    6ce8:	9a 87       	std	Y+10, r25	; 0x0a
    6cea:	12 c0       	rjmp	.+36     	; 0x6d10 <Ext2Power+0xf8>
    6cec:	80 e2       	ldi	r24, 0x20	; 32
    6cee:	93 e0       	ldi	r25, 0x03	; 3
    6cf0:	8b 87       	std	Y+11, r24	; 0x0b
    6cf2:	9c 87       	std	Y+12, r25	; 0x0c
    6cf4:	8b 85       	ldd	r24, Y+11	; 0x0b
    6cf6:	9c 85       	ldd	r25, Y+12	; 0x0c
    6cf8:	8c 01       	movw	r16, r24
    6cfa:	c8 01       	movw	r24, r16
    6cfc:	01 97       	sbiw	r24, 0x01	; 1
    6cfe:	f1 f7       	brne	.-4      	; 0x6cfc <Ext2Power+0xe4>
    6d00:	8c 01       	movw	r16, r24
    6d02:	0b 87       	std	Y+11, r16	; 0x0b
    6d04:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d06:	89 85       	ldd	r24, Y+9	; 0x09
    6d08:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d0a:	01 97       	sbiw	r24, 0x01	; 1
    6d0c:	89 87       	std	Y+9, r24	; 0x09
    6d0e:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d10:	89 85       	ldd	r24, Y+9	; 0x09
    6d12:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d14:	00 97       	sbiw	r24, 0x00	; 0
    6d16:	51 f7       	brne	.-44     	; 0x6cec <Ext2Power+0xd4>
    6d18:	22 c0       	rjmp	.+68     	; 0x6d5e <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d1a:	6d 81       	ldd	r22, Y+5	; 0x05
    6d1c:	7e 81       	ldd	r23, Y+6	; 0x06
    6d1e:	8f 81       	ldd	r24, Y+7	; 0x07
    6d20:	98 85       	ldd	r25, Y+8	; 0x08
    6d22:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6d26:	dc 01       	movw	r26, r24
    6d28:	cb 01       	movw	r24, r22
    6d2a:	89 87       	std	Y+9, r24	; 0x09
    6d2c:	9a 87       	std	Y+10, r25	; 0x0a
    6d2e:	89 85       	ldd	r24, Y+9	; 0x09
    6d30:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d32:	8d 87       	std	Y+13, r24	; 0x0d
    6d34:	9e 87       	std	Y+14, r25	; 0x0e
    6d36:	8d 85       	ldd	r24, Y+13	; 0x0d
    6d38:	9e 85       	ldd	r25, Y+14	; 0x0e
    6d3a:	8c 01       	movw	r16, r24
    6d3c:	f8 01       	movw	r30, r16
    6d3e:	31 97       	sbiw	r30, 0x01	; 1
    6d40:	f1 f7       	brne	.-4      	; 0x6d3e <Ext2Power+0x126>
    6d42:	8f 01       	movw	r16, r30
    6d44:	0d 87       	std	Y+13, r16	; 0x0d
    6d46:	1e 87       	std	Y+14, r17	; 0x0e
    6d48:	0a c0       	rjmp	.+20     	; 0x6d5e <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6d4a:	80 ea       	ldi	r24, 0xA0	; 160
    6d4c:	96 e0       	ldi	r25, 0x06	; 6
    6d4e:	20 e4       	ldi	r18, 0x40	; 64
    6d50:	fc 01       	movw	r30, r24
    6d52:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6d54:	80 ea       	ldi	r24, 0xA0	; 160
    6d56:	96 e0       	ldi	r25, 0x06	; 6
    6d58:	20 e4       	ldi	r18, 0x40	; 64
    6d5a:	fc 01       	movw	r30, r24
    6d5c:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6d5e:	2f 96       	adiw	r28, 0x0f	; 15
    6d60:	cd bf       	out	0x3d, r28	; 61
    6d62:	de bf       	out	0x3e, r29	; 62
    6d64:	df 91       	pop	r29
    6d66:	cf 91       	pop	r28
    6d68:	1f 91       	pop	r17
    6d6a:	0f 91       	pop	r16
    6d6c:	08 95       	ret

00006d6e <HVPower>:

void HVPower(uint8_t on) {
    6d6e:	0f 93       	push	r16
    6d70:	1f 93       	push	r17
    6d72:	cf 93       	push	r28
    6d74:	df 93       	push	r29
    6d76:	cd b7       	in	r28, 0x3d	; 61
    6d78:	de b7       	in	r29, 0x3e	; 62
    6d7a:	a7 97       	sbiw	r28, 0x27	; 39
    6d7c:	cd bf       	out	0x3d, r28	; 61
    6d7e:	de bf       	out	0x3e, r29	; 62
    6d80:	8f a3       	lds	r24, 0x5f
	if (on) {
    6d82:	8f a1       	lds	r24, 0x4f
    6d84:	88 23       	and	r24, r24
    6d86:	09 f4       	brne	.+2      	; 0x6d8a <HVPower+0x1c>
    6d88:	8b c0       	rjmp	.+278    	; 0x6ea0 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6d8a:	80 ea       	ldi	r24, 0xA0	; 160
    6d8c:	96 e0       	ldi	r25, 0x06	; 6
    6d8e:	20 e8       	ldi	r18, 0x80	; 128
    6d90:	fc 01       	movw	r30, r24
    6d92:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6d94:	80 ea       	ldi	r24, 0xA0	; 160
    6d96:	96 e0       	ldi	r25, 0x06	; 6
    6d98:	20 e8       	ldi	r18, 0x80	; 128
    6d9a:	fc 01       	movw	r30, r24
    6d9c:	25 83       	std	Z+5, r18	; 0x05
    6d9e:	80 e0       	ldi	r24, 0x00	; 0
    6da0:	90 e0       	ldi	r25, 0x00	; 0
    6da2:	a8 ec       	ldi	r26, 0xC8	; 200
    6da4:	b2 e4       	ldi	r27, 0x42	; 66
    6da6:	89 83       	std	Y+1, r24	; 0x01
    6da8:	9a 83       	std	Y+2, r25	; 0x02
    6daa:	ab 83       	std	Y+3, r26	; 0x03
    6dac:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6dae:	69 81       	ldd	r22, Y+1	; 0x01
    6db0:	7a 81       	ldd	r23, Y+2	; 0x02
    6db2:	8b 81       	ldd	r24, Y+3	; 0x03
    6db4:	9c 81       	ldd	r25, Y+4	; 0x04
    6db6:	20 e0       	ldi	r18, 0x00	; 0
    6db8:	30 e0       	ldi	r19, 0x00	; 0
    6dba:	4a ef       	ldi	r20, 0xFA	; 250
    6dbc:	55 e4       	ldi	r21, 0x45	; 69
    6dbe:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6dc2:	dc 01       	movw	r26, r24
    6dc4:	cb 01       	movw	r24, r22
    6dc6:	8d 83       	std	Y+5, r24	; 0x05
    6dc8:	9e 83       	std	Y+6, r25	; 0x06
    6dca:	af 83       	std	Y+7, r26	; 0x07
    6dcc:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6dce:	11 e0       	ldi	r17, 0x01	; 1
    6dd0:	6d 81       	ldd	r22, Y+5	; 0x05
    6dd2:	7e 81       	ldd	r23, Y+6	; 0x06
    6dd4:	8f 81       	ldd	r24, Y+7	; 0x07
    6dd6:	98 85       	ldd	r25, Y+8	; 0x08
    6dd8:	20 e0       	ldi	r18, 0x00	; 0
    6dda:	30 e0       	ldi	r19, 0x00	; 0
    6ddc:	40 e8       	ldi	r20, 0x80	; 128
    6dde:	5f e3       	ldi	r21, 0x3F	; 63
    6de0:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    6de4:	88 23       	and	r24, r24
    6de6:	0c f0       	brlt	.+2      	; 0x6dea <HVPower+0x7c>
    6de8:	10 e0       	ldi	r17, 0x00	; 0
    6dea:	11 23       	and	r17, r17
    6dec:	29 f0       	breq	.+10     	; 0x6df8 <HVPower+0x8a>
		__ticks = 1;
    6dee:	81 e0       	ldi	r24, 0x01	; 1
    6df0:	90 e0       	ldi	r25, 0x00	; 0
    6df2:	89 87       	std	Y+9, r24	; 0x09
    6df4:	9a 87       	std	Y+10, r25	; 0x0a
    6df6:	46 c0       	rjmp	.+140    	; 0x6e84 <HVPower+0x116>
	else if (__tmp > 65535)
    6df8:	11 e0       	ldi	r17, 0x01	; 1
    6dfa:	6d 81       	ldd	r22, Y+5	; 0x05
    6dfc:	7e 81       	ldd	r23, Y+6	; 0x06
    6dfe:	8f 81       	ldd	r24, Y+7	; 0x07
    6e00:	98 85       	ldd	r25, Y+8	; 0x08
    6e02:	20 e0       	ldi	r18, 0x00	; 0
    6e04:	3f ef       	ldi	r19, 0xFF	; 255
    6e06:	4f e7       	ldi	r20, 0x7F	; 127
    6e08:	57 e4       	ldi	r21, 0x47	; 71
    6e0a:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    6e0e:	18 16       	cp	r1, r24
    6e10:	0c f0       	brlt	.+2      	; 0x6e14 <HVPower+0xa6>
    6e12:	10 e0       	ldi	r17, 0x00	; 0
    6e14:	11 23       	and	r17, r17
    6e16:	61 f1       	breq	.+88     	; 0x6e70 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e18:	69 81       	ldd	r22, Y+1	; 0x01
    6e1a:	7a 81       	ldd	r23, Y+2	; 0x02
    6e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    6e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    6e20:	20 e0       	ldi	r18, 0x00	; 0
    6e22:	30 e0       	ldi	r19, 0x00	; 0
    6e24:	40 e2       	ldi	r20, 0x20	; 32
    6e26:	51 e4       	ldi	r21, 0x41	; 65
    6e28:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6e2c:	dc 01       	movw	r26, r24
    6e2e:	cb 01       	movw	r24, r22
    6e30:	bc 01       	movw	r22, r24
    6e32:	cd 01       	movw	r24, r26
    6e34:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6e38:	dc 01       	movw	r26, r24
    6e3a:	cb 01       	movw	r24, r22
    6e3c:	89 87       	std	Y+9, r24	; 0x09
    6e3e:	9a 87       	std	Y+10, r25	; 0x0a
    6e40:	12 c0       	rjmp	.+36     	; 0x6e66 <HVPower+0xf8>
    6e42:	80 e2       	ldi	r24, 0x20	; 32
    6e44:	93 e0       	ldi	r25, 0x03	; 3
    6e46:	8b 87       	std	Y+11, r24	; 0x0b
    6e48:	9c 87       	std	Y+12, r25	; 0x0c
    6e4a:	8b 85       	ldd	r24, Y+11	; 0x0b
    6e4c:	9c 85       	ldd	r25, Y+12	; 0x0c
    6e4e:	8c 01       	movw	r16, r24
    6e50:	c8 01       	movw	r24, r16
    6e52:	01 97       	sbiw	r24, 0x01	; 1
    6e54:	f1 f7       	brne	.-4      	; 0x6e52 <HVPower+0xe4>
    6e56:	8c 01       	movw	r16, r24
    6e58:	0b 87       	std	Y+11, r16	; 0x0b
    6e5a:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e5c:	89 85       	ldd	r24, Y+9	; 0x09
    6e5e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e60:	01 97       	sbiw	r24, 0x01	; 1
    6e62:	89 87       	std	Y+9, r24	; 0x09
    6e64:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e66:	89 85       	ldd	r24, Y+9	; 0x09
    6e68:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e6a:	00 97       	sbiw	r24, 0x00	; 0
    6e6c:	51 f7       	brne	.-44     	; 0x6e42 <HVPower+0xd4>
    6e6e:	22 c0       	rjmp	.+68     	; 0x6eb4 <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e70:	6d 81       	ldd	r22, Y+5	; 0x05
    6e72:	7e 81       	ldd	r23, Y+6	; 0x06
    6e74:	8f 81       	ldd	r24, Y+7	; 0x07
    6e76:	98 85       	ldd	r25, Y+8	; 0x08
    6e78:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6e7c:	dc 01       	movw	r26, r24
    6e7e:	cb 01       	movw	r24, r22
    6e80:	89 87       	std	Y+9, r24	; 0x09
    6e82:	9a 87       	std	Y+10, r25	; 0x0a
    6e84:	89 85       	ldd	r24, Y+9	; 0x09
    6e86:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e88:	8d 87       	std	Y+13, r24	; 0x0d
    6e8a:	9e 87       	std	Y+14, r25	; 0x0e
    6e8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e90:	8c 01       	movw	r16, r24
    6e92:	f8 01       	movw	r30, r16
    6e94:	31 97       	sbiw	r30, 0x01	; 1
    6e96:	f1 f7       	brne	.-4      	; 0x6e94 <HVPower+0x126>
    6e98:	8f 01       	movw	r16, r30
    6e9a:	0d 87       	std	Y+13, r16	; 0x0d
    6e9c:	1e 87       	std	Y+14, r17	; 0x0e
    6e9e:	0a c0       	rjmp	.+20     	; 0x6eb4 <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6ea0:	80 ea       	ldi	r24, 0xA0	; 160
    6ea2:	96 e0       	ldi	r25, 0x06	; 6
    6ea4:	20 e8       	ldi	r18, 0x80	; 128
    6ea6:	fc 01       	movw	r30, r24
    6ea8:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6eaa:	80 ea       	ldi	r24, 0xA0	; 160
    6eac:	96 e0       	ldi	r25, 0x06	; 6
    6eae:	20 e8       	ldi	r18, 0x80	; 128
    6eb0:	fc 01       	movw	r30, r24
    6eb2:	22 83       	std	Z+2, r18	; 0x02
    6eb4:	80 e0       	ldi	r24, 0x00	; 0
    6eb6:	90 e0       	ldi	r25, 0x00	; 0
    6eb8:	aa e7       	ldi	r26, 0x7A	; 122
    6eba:	b4 e4       	ldi	r27, 0x44	; 68
    6ebc:	8f 87       	std	Y+15, r24	; 0x0f
    6ebe:	98 8b       	std	Y+16, r25	; 0x10
    6ec0:	a9 8b       	std	Y+17, r26	; 0x11
    6ec2:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6ec4:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ec6:	78 89       	ldd	r23, Y+16	; 0x10
    6ec8:	89 89       	ldd	r24, Y+17	; 0x11
    6eca:	9a 89       	ldd	r25, Y+18	; 0x12
    6ecc:	2b ea       	ldi	r18, 0xAB	; 171
    6ece:	3a ea       	ldi	r19, 0xAA	; 170
    6ed0:	4a e2       	ldi	r20, 0x2A	; 42
    6ed2:	51 e4       	ldi	r21, 0x41	; 65
    6ed4:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6ed8:	dc 01       	movw	r26, r24
    6eda:	cb 01       	movw	r24, r22
    6edc:	8b 8b       	std	Y+19, r24	; 0x13
    6ede:	9c 8b       	std	Y+20, r25	; 0x14
    6ee0:	ad 8b       	std	Y+21, r26	; 0x15
    6ee2:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6ee4:	11 e0       	ldi	r17, 0x01	; 1
    6ee6:	6b 89       	ldd	r22, Y+19	; 0x13
    6ee8:	7c 89       	ldd	r23, Y+20	; 0x14
    6eea:	8d 89       	ldd	r24, Y+21	; 0x15
    6eec:	9e 89       	ldd	r25, Y+22	; 0x16
    6eee:	20 e0       	ldi	r18, 0x00	; 0
    6ef0:	30 e0       	ldi	r19, 0x00	; 0
    6ef2:	40 e8       	ldi	r20, 0x80	; 128
    6ef4:	5f e3       	ldi	r21, 0x3F	; 63
    6ef6:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    6efa:	88 23       	and	r24, r24
    6efc:	0c f0       	brlt	.+2      	; 0x6f00 <HVPower+0x192>
    6efe:	10 e0       	ldi	r17, 0x00	; 0
    6f00:	11 23       	and	r17, r17
    6f02:	19 f0       	breq	.+6      	; 0x6f0a <HVPower+0x19c>
		__ticks = 1;
    6f04:	81 e0       	ldi	r24, 0x01	; 1
    6f06:	8f 8b       	std	Y+23, r24	; 0x17
    6f08:	a3 c0       	rjmp	.+326    	; 0x7050 <HVPower+0x2e2>
	else if (__tmp > 255)
    6f0a:	11 e0       	ldi	r17, 0x01	; 1
    6f0c:	6b 89       	ldd	r22, Y+19	; 0x13
    6f0e:	7c 89       	ldd	r23, Y+20	; 0x14
    6f10:	8d 89       	ldd	r24, Y+21	; 0x15
    6f12:	9e 89       	ldd	r25, Y+22	; 0x16
    6f14:	20 e0       	ldi	r18, 0x00	; 0
    6f16:	30 e0       	ldi	r19, 0x00	; 0
    6f18:	4f e7       	ldi	r20, 0x7F	; 127
    6f1a:	53 e4       	ldi	r21, 0x43	; 67
    6f1c:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    6f20:	18 16       	cp	r1, r24
    6f22:	0c f0       	brlt	.+2      	; 0x6f26 <HVPower+0x1b8>
    6f24:	10 e0       	ldi	r17, 0x00	; 0
    6f26:	11 23       	and	r17, r17
    6f28:	09 f4       	brne	.+2      	; 0x6f2c <HVPower+0x1be>
    6f2a:	89 c0       	rjmp	.+274    	; 0x703e <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6f2c:	6f 85       	ldd	r22, Y+15	; 0x0f
    6f2e:	78 89       	ldd	r23, Y+16	; 0x10
    6f30:	89 89       	ldd	r24, Y+17	; 0x11
    6f32:	9a 89       	ldd	r25, Y+18	; 0x12
    6f34:	20 e0       	ldi	r18, 0x00	; 0
    6f36:	30 e0       	ldi	r19, 0x00	; 0
    6f38:	4a e7       	ldi	r20, 0x7A	; 122
    6f3a:	54 e4       	ldi	r21, 0x44	; 68
    6f3c:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    6f40:	dc 01       	movw	r26, r24
    6f42:	cb 01       	movw	r24, r22
    6f44:	88 8f       	std	Y+24, r24	; 0x18
    6f46:	99 8f       	std	Y+25, r25	; 0x19
    6f48:	aa 8f       	std	Y+26, r26	; 0x1a
    6f4a:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6f4c:	68 8d       	ldd	r22, Y+24	; 0x18
    6f4e:	79 8d       	ldd	r23, Y+25	; 0x19
    6f50:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6f52:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6f54:	20 e0       	ldi	r18, 0x00	; 0
    6f56:	30 e0       	ldi	r19, 0x00	; 0
    6f58:	4a ef       	ldi	r20, 0xFA	; 250
    6f5a:	55 e4       	ldi	r21, 0x45	; 69
    6f5c:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6f60:	dc 01       	movw	r26, r24
    6f62:	cb 01       	movw	r24, r22
    6f64:	8c 8f       	std	Y+28, r24	; 0x1c
    6f66:	9d 8f       	std	Y+29, r25	; 0x1d
    6f68:	ae 8f       	std	Y+30, r26	; 0x1e
    6f6a:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6f6c:	11 e0       	ldi	r17, 0x01	; 1
    6f6e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6f70:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6f72:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6f74:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6f76:	20 e0       	ldi	r18, 0x00	; 0
    6f78:	30 e0       	ldi	r19, 0x00	; 0
    6f7a:	40 e8       	ldi	r20, 0x80	; 128
    6f7c:	5f e3       	ldi	r21, 0x3F	; 63
    6f7e:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    6f82:	88 23       	and	r24, r24
    6f84:	0c f0       	brlt	.+2      	; 0x6f88 <HVPower+0x21a>
    6f86:	10 e0       	ldi	r17, 0x00	; 0
    6f88:	11 23       	and	r17, r17
    6f8a:	29 f0       	breq	.+10     	; 0x6f96 <HVPower+0x228>
		__ticks = 1;
    6f8c:	81 e0       	ldi	r24, 0x01	; 1
    6f8e:	90 e0       	ldi	r25, 0x00	; 0
    6f90:	88 a3       	lds	r24, 0x58
    6f92:	99 a3       	lds	r25, 0x59
    6f94:	46 c0       	rjmp	.+140    	; 0x7022 <HVPower+0x2b4>
	else if (__tmp > 65535)
    6f96:	11 e0       	ldi	r17, 0x01	; 1
    6f98:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6f9a:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6f9c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6f9e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6fa0:	20 e0       	ldi	r18, 0x00	; 0
    6fa2:	3f ef       	ldi	r19, 0xFF	; 255
    6fa4:	4f e7       	ldi	r20, 0x7F	; 127
    6fa6:	57 e4       	ldi	r21, 0x47	; 71
    6fa8:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    6fac:	18 16       	cp	r1, r24
    6fae:	0c f0       	brlt	.+2      	; 0x6fb2 <HVPower+0x244>
    6fb0:	10 e0       	ldi	r17, 0x00	; 0
    6fb2:	11 23       	and	r17, r17
    6fb4:	61 f1       	breq	.+88     	; 0x700e <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6fb6:	68 8d       	ldd	r22, Y+24	; 0x18
    6fb8:	79 8d       	ldd	r23, Y+25	; 0x19
    6fba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6fbc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6fbe:	20 e0       	ldi	r18, 0x00	; 0
    6fc0:	30 e0       	ldi	r19, 0x00	; 0
    6fc2:	40 e2       	ldi	r20, 0x20	; 32
    6fc4:	51 e4       	ldi	r21, 0x41	; 65
    6fc6:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    6fca:	dc 01       	movw	r26, r24
    6fcc:	cb 01       	movw	r24, r22
    6fce:	bc 01       	movw	r22, r24
    6fd0:	cd 01       	movw	r24, r26
    6fd2:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    6fd6:	dc 01       	movw	r26, r24
    6fd8:	cb 01       	movw	r24, r22
    6fda:	88 a3       	lds	r24, 0x58
    6fdc:	99 a3       	lds	r25, 0x59
    6fde:	12 c0       	rjmp	.+36     	; 0x7004 <HVPower+0x296>
    6fe0:	80 e2       	ldi	r24, 0x20	; 32
    6fe2:	93 e0       	ldi	r25, 0x03	; 3
    6fe4:	8a a3       	lds	r24, 0x5a
    6fe6:	9b a3       	lds	r25, 0x5b
    6fe8:	8a a1       	lds	r24, 0x4a
    6fea:	9b a1       	lds	r25, 0x4b
    6fec:	8c 01       	movw	r16, r24
    6fee:	c8 01       	movw	r24, r16
    6ff0:	01 97       	sbiw	r24, 0x01	; 1
    6ff2:	f1 f7       	brne	.-4      	; 0x6ff0 <HVPower+0x282>
    6ff4:	8c 01       	movw	r16, r24
    6ff6:	0a a3       	lds	r16, 0x5a
    6ff8:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6ffa:	88 a1       	lds	r24, 0x48
    6ffc:	99 a1       	lds	r25, 0x49
    6ffe:	01 97       	sbiw	r24, 0x01	; 1
    7000:	88 a3       	lds	r24, 0x58
    7002:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7004:	88 a1       	lds	r24, 0x48
    7006:	99 a1       	lds	r25, 0x49
    7008:	00 97       	sbiw	r24, 0x00	; 0
    700a:	51 f7       	brne	.-44     	; 0x6fe0 <HVPower+0x272>
    700c:	28 c0       	rjmp	.+80     	; 0x705e <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    700e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7010:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7012:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7014:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7016:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    701a:	dc 01       	movw	r26, r24
    701c:	cb 01       	movw	r24, r22
    701e:	88 a3       	lds	r24, 0x58
    7020:	99 a3       	lds	r25, 0x59
    7022:	88 a1       	lds	r24, 0x48
    7024:	99 a1       	lds	r25, 0x49
    7026:	8c a3       	lds	r24, 0x5c
    7028:	9d a3       	lds	r25, 0x5d
    702a:	8c a1       	lds	r24, 0x4c
    702c:	9d a1       	lds	r25, 0x4d
    702e:	8c 01       	movw	r16, r24
    7030:	f8 01       	movw	r30, r16
    7032:	31 97       	sbiw	r30, 0x01	; 1
    7034:	f1 f7       	brne	.-4      	; 0x7032 <HVPower+0x2c4>
    7036:	8f 01       	movw	r16, r30
    7038:	0c a3       	lds	r16, 0x5c
    703a:	1d a3       	lds	r17, 0x5d
    703c:	10 c0       	rjmp	.+32     	; 0x705e <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    703e:	6b 89       	ldd	r22, Y+19	; 0x13
    7040:	7c 89       	ldd	r23, Y+20	; 0x14
    7042:	8d 89       	ldd	r24, Y+21	; 0x15
    7044:	9e 89       	ldd	r25, Y+22	; 0x16
    7046:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    704a:	dc 01       	movw	r26, r24
    704c:	cb 01       	movw	r24, r22
    704e:	8f 8b       	std	Y+23, r24	; 0x17
    7050:	8f 89       	ldd	r24, Y+23	; 0x17
    7052:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7054:	8e a1       	lds	r24, 0x4e
    7056:	18 2f       	mov	r17, r24
    7058:	1a 95       	dec	r17
    705a:	f1 f7       	brne	.-4      	; 0x7058 <HVPower+0x2ea>
    705c:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    705e:	a7 96       	adiw	r28, 0x27	; 39
    7060:	cd bf       	out	0x3d, r28	; 61
    7062:	de bf       	out	0x3e, r29	; 62
    7064:	df 91       	pop	r29
    7066:	cf 91       	pop	r28
    7068:	1f 91       	pop	r17
    706a:	0f 91       	pop	r16
    706c:	08 95       	ret

0000706e <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    706e:	cf 93       	push	r28
    7070:	df 93       	push	r29
    7072:	0f 92       	push	r0
    7074:	cd b7       	in	r28, 0x3d	; 61
    7076:	de b7       	in	r29, 0x3e	; 62
    7078:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    707a:	89 81       	ldd	r24, Y+1	; 0x01
    707c:	88 23       	and	r24, r24
    707e:	31 f0       	breq	.+12     	; 0x708c <lowerMuxCS+0x1e>
    7080:	80 e8       	ldi	r24, 0x80	; 128
    7082:	96 e0       	ldi	r25, 0x06	; 6
    7084:	20 e1       	ldi	r18, 0x10	; 16
    7086:	fc 01       	movw	r30, r24
    7088:	26 83       	std	Z+6, r18	; 0x06
    708a:	05 c0       	rjmp	.+10     	; 0x7096 <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    708c:	80 e8       	ldi	r24, 0x80	; 128
    708e:	96 e0       	ldi	r25, 0x06	; 6
    7090:	20 e1       	ldi	r18, 0x10	; 16
    7092:	fc 01       	movw	r30, r24
    7094:	25 83       	std	Z+5, r18	; 0x05
}
    7096:	0f 90       	pop	r0
    7098:	df 91       	pop	r29
    709a:	cf 91       	pop	r28
    709c:	08 95       	ret

0000709e <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    709e:	cf 93       	push	r28
    70a0:	df 93       	push	r29
    70a2:	0f 92       	push	r0
    70a4:	cd b7       	in	r28, 0x3d	; 61
    70a6:	de b7       	in	r29, 0x3e	; 62
    70a8:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    70aa:	89 81       	ldd	r24, Y+1	; 0x01
    70ac:	88 23       	and	r24, r24
    70ae:	31 f0       	breq	.+12     	; 0x70bc <upperMuxCS+0x1e>
    70b0:	80 e4       	ldi	r24, 0x40	; 64
    70b2:	96 e0       	ldi	r25, 0x06	; 6
    70b4:	22 e0       	ldi	r18, 0x02	; 2
    70b6:	fc 01       	movw	r30, r24
    70b8:	26 83       	std	Z+6, r18	; 0x06
    70ba:	05 c0       	rjmp	.+10     	; 0x70c6 <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    70bc:	80 e4       	ldi	r24, 0x40	; 64
    70be:	96 e0       	ldi	r25, 0x06	; 6
    70c0:	22 e0       	ldi	r18, 0x02	; 2
    70c2:	fc 01       	movw	r30, r24
    70c4:	25 83       	std	Z+5, r18	; 0x05
}
    70c6:	0f 90       	pop	r0
    70c8:	df 91       	pop	r29
    70ca:	cf 91       	pop	r28
    70cc:	08 95       	ret

000070ce <SPIInit>:

void SPIInit(uint8_t mode) {
    70ce:	cf 93       	push	r28
    70d0:	df 93       	push	r29
    70d2:	0f 92       	push	r0
    70d4:	cd b7       	in	r28, 0x3d	; 61
    70d6:	de b7       	in	r29, 0x3e	; 62
    70d8:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    70da:	80 e4       	ldi	r24, 0x40	; 64
    70dc:	96 e0       	ldi	r25, 0x06	; 6
    70de:	20 e1       	ldi	r18, 0x10	; 16
    70e0:	fc 01       	movw	r30, r24
    70e2:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    70e4:	80 e4       	ldi	r24, 0x40	; 64
    70e6:	96 e0       	ldi	r25, 0x06	; 6
    70e8:	28 e3       	ldi	r18, 0x38	; 56
    70ea:	fc 01       	movw	r30, r24
    70ec:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    70ee:	80 e4       	ldi	r24, 0x40	; 64
    70f0:	96 e0       	ldi	r25, 0x06	; 6
    70f2:	20 e1       	ldi	r18, 0x10	; 16
    70f4:	fc 01       	movw	r30, r24
    70f6:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    70f8:	80 ec       	ldi	r24, 0xC0	; 192
    70fa:	98 e0       	ldi	r25, 0x08	; 8
    70fc:	29 81       	ldd	r18, Y+1	; 0x01
    70fe:	21 65       	ori	r18, 0x51	; 81
    7100:	fc 01       	movw	r30, r24
    7102:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    7104:	80 ec       	ldi	r24, 0xC0	; 192
    7106:	98 e0       	ldi	r25, 0x08	; 8
    7108:	fc 01       	movw	r30, r24
    710a:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    710c:	80 e4       	ldi	r24, 0x40	; 64
    710e:	96 e0       	ldi	r25, 0x06	; 6
    7110:	20 ea       	ldi	r18, 0xA0	; 160
    7112:	fc 01       	movw	r30, r24
    7114:	21 83       	std	Z+1, r18	; 0x01

	
}
    7116:	0f 90       	pop	r0
    7118:	df 91       	pop	r29
    711a:	cf 91       	pop	r28
    711c:	08 95       	ret

0000711e <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    711e:	cf 93       	push	r28
    7120:	df 93       	push	r29
    7122:	0f 92       	push	r0
    7124:	0f 92       	push	r0
    7126:	cd b7       	in	r28, 0x3d	; 61
    7128:	de b7       	in	r29, 0x3e	; 62
    712a:	89 83       	std	Y+1, r24	; 0x01
    712c:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    712e:	80 e4       	ldi	r24, 0x40	; 64
    7130:	96 e0       	ldi	r25, 0x06	; 6
    7132:	20 e1       	ldi	r18, 0x10	; 16
    7134:	fc 01       	movw	r30, r24
    7136:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    7138:	80 e4       	ldi	r24, 0x40	; 64
    713a:	96 e0       	ldi	r25, 0x06	; 6
    713c:	28 e3       	ldi	r18, 0x38	; 56
    713e:	fc 01       	movw	r30, r24
    7140:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    7142:	80 e4       	ldi	r24, 0x40	; 64
    7144:	96 e0       	ldi	r25, 0x06	; 6
    7146:	20 e1       	ldi	r18, 0x10	; 16
    7148:	fc 01       	movw	r30, r24
    714a:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    714c:	80 ec       	ldi	r24, 0xC0	; 192
    714e:	98 e0       	ldi	r25, 0x08	; 8
    7150:	3a 81       	ldd	r19, Y+2	; 0x02
    7152:	29 81       	ldd	r18, Y+1	; 0x01
    7154:	23 2b       	or	r18, r19
    7156:	20 65       	ori	r18, 0x50	; 80
    7158:	fc 01       	movw	r30, r24
    715a:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    715c:	80 ec       	ldi	r24, 0xC0	; 192
    715e:	98 e0       	ldi	r25, 0x08	; 8
    7160:	fc 01       	movw	r30, r24
    7162:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    7164:	80 e4       	ldi	r24, 0x40	; 64
    7166:	96 e0       	ldi	r25, 0x06	; 6
    7168:	20 ea       	ldi	r18, 0xA0	; 160
    716a:	fc 01       	movw	r30, r24
    716c:	21 83       	std	Z+1, r18	; 0x01
}
    716e:	0f 90       	pop	r0
    7170:	0f 90       	pop	r0
    7172:	df 91       	pop	r29
    7174:	cf 91       	pop	r28
    7176:	08 95       	ret

00007178 <SPICS>:

void SPICS(uint8_t enable) {
    7178:	cf 93       	push	r28
    717a:	df 93       	push	r29
    717c:	0f 92       	push	r0
    717e:	cd b7       	in	r28, 0x3d	; 61
    7180:	de b7       	in	r29, 0x3e	; 62
    7182:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    7184:	89 81       	ldd	r24, Y+1	; 0x01
    7186:	88 23       	and	r24, r24
    7188:	31 f0       	breq	.+12     	; 0x7196 <SPICS+0x1e>
    718a:	80 e4       	ldi	r24, 0x40	; 64
    718c:	96 e0       	ldi	r25, 0x06	; 6
    718e:	20 e1       	ldi	r18, 0x10	; 16
    7190:	fc 01       	movw	r30, r24
    7192:	26 83       	std	Z+6, r18	; 0x06
    7194:	05 c0       	rjmp	.+10     	; 0x71a0 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    7196:	80 e4       	ldi	r24, 0x40	; 64
    7198:	96 e0       	ldi	r25, 0x06	; 6
    719a:	20 e1       	ldi	r18, 0x10	; 16
    719c:	fc 01       	movw	r30, r24
    719e:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    71a0:	0f 90       	pop	r0
    71a2:	df 91       	pop	r29
    71a4:	cf 91       	pop	r28
    71a6:	08 95       	ret

000071a8 <SPIDisable>:

void SPIDisable() {
    71a8:	cf 93       	push	r28
    71aa:	df 93       	push	r29
    71ac:	cd b7       	in	r28, 0x3d	; 61
    71ae:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    71b0:	80 e4       	ldi	r24, 0x40	; 64
    71b2:	96 e0       	ldi	r25, 0x06	; 6
    71b4:	20 e1       	ldi	r18, 0x10	; 16
    71b6:	fc 01       	movw	r30, r24
    71b8:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    71ba:	80 ec       	ldi	r24, 0xC0	; 192
    71bc:	98 e0       	ldi	r25, 0x08	; 8
    71be:	fc 01       	movw	r30, r24
    71c0:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    71c2:	80 e4       	ldi	r24, 0x40	; 64
    71c4:	96 e0       	ldi	r25, 0x06	; 6
    71c6:	20 e1       	ldi	r18, 0x10	; 16
    71c8:	fc 01       	movw	r30, r24
    71ca:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    71cc:	80 e4       	ldi	r24, 0x40	; 64
    71ce:	96 e0       	ldi	r25, 0x06	; 6
    71d0:	20 eb       	ldi	r18, 0xB0	; 176
    71d2:	fc 01       	movw	r30, r24
    71d4:	22 83       	std	Z+2, r18	; 0x02

}
    71d6:	df 91       	pop	r29
    71d8:	cf 91       	pop	r28
    71da:	08 95       	ret

000071dc <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    71dc:	cf 93       	push	r28
    71de:	df 93       	push	r29
    71e0:	00 d0       	rcall	.+0      	; 0x71e2 <readFRAM+0x6>
    71e2:	0f 92       	push	r0
    71e4:	cd b7       	in	r28, 0x3d	; 61
    71e6:	de b7       	in	r29, 0x3e	; 62
    71e8:	8b 83       	std	Y+3, r24	; 0x03
    71ea:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    71ec:	80 e0       	ldi	r24, 0x00	; 0
    71ee:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    71f2:	80 ec       	ldi	r24, 0xC0	; 192
    71f4:	98 e0       	ldi	r25, 0x08	; 8
    71f6:	20 ed       	ldi	r18, 0xD0	; 208
    71f8:	fc 01       	movw	r30, r24
    71fa:	20 83       	st	Z, r18
	SPICS(TRUE);
    71fc:	81 e0       	ldi	r24, 0x01	; 1
    71fe:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    7202:	80 e2       	ldi	r24, 0x20	; 32
    7204:	96 e0       	ldi	r25, 0x06	; 6
    7206:	28 e0       	ldi	r18, 0x08	; 8
    7208:	fc 01       	movw	r30, r24
    720a:	26 83       	std	Z+6, r18	; 0x06
	nop();
    720c:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    720e:	80 ec       	ldi	r24, 0xC0	; 192
    7210:	98 e0       	ldi	r25, 0x08	; 8
    7212:	23 e0       	ldi	r18, 0x03	; 3
    7214:	fc 01       	movw	r30, r24
    7216:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7218:	00 00       	nop
    721a:	80 ec       	ldi	r24, 0xC0	; 192
    721c:	98 e0       	ldi	r25, 0x08	; 8
    721e:	fc 01       	movw	r30, r24
    7220:	82 81       	ldd	r24, Z+2	; 0x02
    7222:	88 23       	and	r24, r24
    7224:	d4 f7       	brge	.-12     	; 0x721a <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    7226:	80 ec       	ldi	r24, 0xC0	; 192
    7228:	98 e0       	ldi	r25, 0x08	; 8
    722a:	fc 01       	movw	r30, r24
    722c:	83 81       	ldd	r24, Z+3	; 0x03
    722e:	80 93 51 50 	sts	0x5051, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    7232:	80 ec       	ldi	r24, 0xC0	; 192
    7234:	98 e0       	ldi	r25, 0x08	; 8
    7236:	20 91 39 40 	lds	r18, 0x4039
    723a:	fc 01       	movw	r30, r24
    723c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    723e:	00 00       	nop
    7240:	80 ec       	ldi	r24, 0xC0	; 192
    7242:	98 e0       	ldi	r25, 0x08	; 8
    7244:	fc 01       	movw	r30, r24
    7246:	82 81       	ldd	r24, Z+2	; 0x02
    7248:	88 23       	and	r24, r24
    724a:	d4 f7       	brge	.-12     	; 0x7240 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    724c:	80 ec       	ldi	r24, 0xC0	; 192
    724e:	98 e0       	ldi	r25, 0x08	; 8
    7250:	fc 01       	movw	r30, r24
    7252:	83 81       	ldd	r24, Z+3	; 0x03
    7254:	80 93 51 50 	sts	0x5051, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    7258:	80 ec       	ldi	r24, 0xC0	; 192
    725a:	98 e0       	ldi	r25, 0x08	; 8
    725c:	28 e3       	ldi	r18, 0x38	; 56
    725e:	30 e4       	ldi	r19, 0x40	; 64
    7260:	f9 01       	movw	r30, r18
    7262:	20 81       	ld	r18, Z
    7264:	fc 01       	movw	r30, r24
    7266:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7268:	00 00       	nop
    726a:	80 ec       	ldi	r24, 0xC0	; 192
    726c:	98 e0       	ldi	r25, 0x08	; 8
    726e:	fc 01       	movw	r30, r24
    7270:	82 81       	ldd	r24, Z+2	; 0x02
    7272:	88 23       	and	r24, r24
    7274:	d4 f7       	brge	.-12     	; 0x726a <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    7276:	80 ec       	ldi	r24, 0xC0	; 192
    7278:	98 e0       	ldi	r25, 0x08	; 8
    727a:	fc 01       	movw	r30, r24
    727c:	83 81       	ldd	r24, Z+3	; 0x03
    727e:	80 93 51 50 	sts	0x5051, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7282:	19 82       	std	Y+1, r1	; 0x01
    7284:	1a 82       	std	Y+2, r1	; 0x02
    7286:	1b c0       	rjmp	.+54     	; 0x72be <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    7288:	80 ec       	ldi	r24, 0xC0	; 192
    728a:	98 e0       	ldi	r25, 0x08	; 8
    728c:	2a ea       	ldi	r18, 0xAA	; 170
    728e:	fc 01       	movw	r30, r24
    7290:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    7292:	00 00       	nop
    7294:	80 ec       	ldi	r24, 0xC0	; 192
    7296:	98 e0       	ldi	r25, 0x08	; 8
    7298:	fc 01       	movw	r30, r24
    729a:	82 81       	ldd	r24, Z+2	; 0x02
    729c:	88 23       	and	r24, r24
    729e:	d4 f7       	brge	.-12     	; 0x7294 <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    72a0:	80 ec       	ldi	r24, 0xC0	; 192
    72a2:	98 e0       	ldi	r25, 0x08	; 8
    72a4:	fc 01       	movw	r30, r24
    72a6:	23 81       	ldd	r18, Z+3	; 0x03
    72a8:	89 81       	ldd	r24, Y+1	; 0x01
    72aa:	9a 81       	ldd	r25, Y+2	; 0x02
    72ac:	80 54       	subi	r24, 0x40	; 64
    72ae:	9c 4d       	sbci	r25, 0xDC	; 220
    72b0:	fc 01       	movw	r30, r24
    72b2:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    72b4:	89 81       	ldd	r24, Y+1	; 0x01
    72b6:	9a 81       	ldd	r25, Y+2	; 0x02
    72b8:	01 96       	adiw	r24, 0x01	; 1
    72ba:	89 83       	std	Y+1, r24	; 0x01
    72bc:	9a 83       	std	Y+2, r25	; 0x02
    72be:	29 81       	ldd	r18, Y+1	; 0x01
    72c0:	3a 81       	ldd	r19, Y+2	; 0x02
    72c2:	8b 81       	ldd	r24, Y+3	; 0x03
    72c4:	9c 81       	ldd	r25, Y+4	; 0x04
    72c6:	28 17       	cp	r18, r24
    72c8:	39 07       	cpc	r19, r25
    72ca:	f0 f2       	brcs	.-68     	; 0x7288 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    72cc:	80 e2       	ldi	r24, 0x20	; 32
    72ce:	96 e0       	ldi	r25, 0x06	; 6
    72d0:	28 e0       	ldi	r18, 0x08	; 8
    72d2:	fc 01       	movw	r30, r24
    72d4:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    72d6:	80 e0       	ldi	r24, 0x00	; 0
    72d8:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    72dc:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>

}
    72e0:	24 96       	adiw	r28, 0x04	; 4
    72e2:	cd bf       	out	0x3d, r28	; 61
    72e4:	de bf       	out	0x3e, r29	; 62
    72e6:	df 91       	pop	r29
    72e8:	cf 91       	pop	r28
    72ea:	08 95       	ret

000072ec <FRAMTest3Channel>:

void FRAMTest3Channel(void) {
    72ec:	8f 92       	push	r8
    72ee:	9f 92       	push	r9
    72f0:	af 92       	push	r10
    72f2:	bf 92       	push	r11
    72f4:	cf 92       	push	r12
    72f6:	df 92       	push	r13
    72f8:	ef 92       	push	r14
    72fa:	ff 92       	push	r15
    72fc:	0f 93       	push	r16
    72fe:	1f 93       	push	r17
    7300:	cf 93       	push	r28
    7302:	df 93       	push	r29
    7304:	cd b7       	in	r28, 0x3d	; 61
    7306:	de b7       	in	r29, 0x3e	; 62
    7308:	6b 97       	sbiw	r28, 0x1b	; 27
    730a:	cd bf       	out	0x3d, r28	; 61
    730c:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    730e:	19 8e       	std	Y+25, r1	; 0x19
    7310:	1a 8e       	std	Y+26, r1	; 0x1a
    7312:	1b 8e       	std	Y+27, r1	; 0x1b
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
    7314:	9e 01       	movw	r18, r28
    7316:	27 5e       	subi	r18, 0xE7	; 231
    7318:	3f 4f       	sbci	r19, 0xFF	; 255
}

void FRAMTest3Channel(void) {
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    731a:	8e ec       	ldi	r24, 0xCE	; 206
    731c:	b9 01       	movw	r22, r18
    731e:	40 e0       	ldi	r20, 0x00	; 0
    7320:	25 e1       	ldi	r18, 0x15	; 21
    7322:	01 e0       	ldi	r16, 0x01	; 1
    7324:	0f 2e       	mov	r0, r31
    7326:	fd e0       	ldi	r31, 0x0D	; 13
    7328:	ef 2e       	mov	r14, r31
    732a:	ff 24       	eor	r15, r15
    732c:	f0 2d       	mov	r31, r0
    732e:	0f 2e       	mov	r0, r31
    7330:	fe e0       	ldi	r31, 0x0E	; 14
    7332:	cf 2e       	mov	r12, r31
    7334:	dd 24       	eor	r13, r13
    7336:	f0 2d       	mov	r31, r0
    7338:	0f 2e       	mov	r0, r31
    733a:	ff e0       	ldi	r31, 0x0F	; 15
    733c:	af 2e       	mov	r10, r31
    733e:	bb 24       	eor	r11, r11
    7340:	f0 2d       	mov	r31, r0
    7342:	88 24       	eor	r8, r8
    7344:	99 24       	eor	r9, r9
    7346:	68 94       	set
    7348:	84 f8       	bld	r8, 4
    734a:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    734e:	81 e0       	ldi	r24, 0x01	; 1
    7350:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
    7354:	80 e0       	ldi	r24, 0x00	; 0
    7356:	90 e0       	ldi	r25, 0x00	; 0
    7358:	aa e7       	ldi	r26, 0x7A	; 122
    735a:	b3 e4       	ldi	r27, 0x43	; 67
    735c:	89 83       	std	Y+1, r24	; 0x01
    735e:	9a 83       	std	Y+2, r25	; 0x02
    7360:	ab 83       	std	Y+3, r26	; 0x03
    7362:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7364:	69 81       	ldd	r22, Y+1	; 0x01
    7366:	7a 81       	ldd	r23, Y+2	; 0x02
    7368:	8b 81       	ldd	r24, Y+3	; 0x03
    736a:	9c 81       	ldd	r25, Y+4	; 0x04
    736c:	2b ea       	ldi	r18, 0xAB	; 171
    736e:	3a ea       	ldi	r19, 0xAA	; 170
    7370:	4a e2       	ldi	r20, 0x2A	; 42
    7372:	51 e4       	ldi	r21, 0x41	; 65
    7374:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7378:	dc 01       	movw	r26, r24
    737a:	cb 01       	movw	r24, r22
    737c:	8d 83       	std	Y+5, r24	; 0x05
    737e:	9e 83       	std	Y+6, r25	; 0x06
    7380:	af 83       	std	Y+7, r26	; 0x07
    7382:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7384:	11 e0       	ldi	r17, 0x01	; 1
    7386:	6d 81       	ldd	r22, Y+5	; 0x05
    7388:	7e 81       	ldd	r23, Y+6	; 0x06
    738a:	8f 81       	ldd	r24, Y+7	; 0x07
    738c:	98 85       	ldd	r25, Y+8	; 0x08
    738e:	20 e0       	ldi	r18, 0x00	; 0
    7390:	30 e0       	ldi	r19, 0x00	; 0
    7392:	40 e8       	ldi	r20, 0x80	; 128
    7394:	5f e3       	ldi	r21, 0x3F	; 63
    7396:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    739a:	88 23       	and	r24, r24
    739c:	0c f0       	brlt	.+2      	; 0x73a0 <FRAMTest3Channel+0xb4>
    739e:	10 e0       	ldi	r17, 0x00	; 0
    73a0:	11 23       	and	r17, r17
    73a2:	19 f0       	breq	.+6      	; 0x73aa <FRAMTest3Channel+0xbe>
		__ticks = 1;
    73a4:	81 e0       	ldi	r24, 0x01	; 1
    73a6:	89 87       	std	Y+9, r24	; 0x09
    73a8:	a3 c0       	rjmp	.+326    	; 0x74f0 <FRAMTest3Channel+0x204>
	else if (__tmp > 255)
    73aa:	11 e0       	ldi	r17, 0x01	; 1
    73ac:	6d 81       	ldd	r22, Y+5	; 0x05
    73ae:	7e 81       	ldd	r23, Y+6	; 0x06
    73b0:	8f 81       	ldd	r24, Y+7	; 0x07
    73b2:	98 85       	ldd	r25, Y+8	; 0x08
    73b4:	20 e0       	ldi	r18, 0x00	; 0
    73b6:	30 e0       	ldi	r19, 0x00	; 0
    73b8:	4f e7       	ldi	r20, 0x7F	; 127
    73ba:	53 e4       	ldi	r21, 0x43	; 67
    73bc:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    73c0:	18 16       	cp	r1, r24
    73c2:	0c f0       	brlt	.+2      	; 0x73c6 <FRAMTest3Channel+0xda>
    73c4:	10 e0       	ldi	r17, 0x00	; 0
    73c6:	11 23       	and	r17, r17
    73c8:	09 f4       	brne	.+2      	; 0x73cc <FRAMTest3Channel+0xe0>
    73ca:	89 c0       	rjmp	.+274    	; 0x74de <FRAMTest3Channel+0x1f2>
	{
		_delay_ms(__us / 1000.0);
    73cc:	69 81       	ldd	r22, Y+1	; 0x01
    73ce:	7a 81       	ldd	r23, Y+2	; 0x02
    73d0:	8b 81       	ldd	r24, Y+3	; 0x03
    73d2:	9c 81       	ldd	r25, Y+4	; 0x04
    73d4:	20 e0       	ldi	r18, 0x00	; 0
    73d6:	30 e0       	ldi	r19, 0x00	; 0
    73d8:	4a e7       	ldi	r20, 0x7A	; 122
    73da:	54 e4       	ldi	r21, 0x44	; 68
    73dc:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    73e0:	dc 01       	movw	r26, r24
    73e2:	cb 01       	movw	r24, r22
    73e4:	8a 87       	std	Y+10, r24	; 0x0a
    73e6:	9b 87       	std	Y+11, r25	; 0x0b
    73e8:	ac 87       	std	Y+12, r26	; 0x0c
    73ea:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    73ec:	6a 85       	ldd	r22, Y+10	; 0x0a
    73ee:	7b 85       	ldd	r23, Y+11	; 0x0b
    73f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    73f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    73f4:	20 e0       	ldi	r18, 0x00	; 0
    73f6:	30 e0       	ldi	r19, 0x00	; 0
    73f8:	4a ef       	ldi	r20, 0xFA	; 250
    73fa:	55 e4       	ldi	r21, 0x45	; 69
    73fc:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7400:	dc 01       	movw	r26, r24
    7402:	cb 01       	movw	r24, r22
    7404:	8e 87       	std	Y+14, r24	; 0x0e
    7406:	9f 87       	std	Y+15, r25	; 0x0f
    7408:	a8 8b       	std	Y+16, r26	; 0x10
    740a:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    740c:	11 e0       	ldi	r17, 0x01	; 1
    740e:	6e 85       	ldd	r22, Y+14	; 0x0e
    7410:	7f 85       	ldd	r23, Y+15	; 0x0f
    7412:	88 89       	ldd	r24, Y+16	; 0x10
    7414:	99 89       	ldd	r25, Y+17	; 0x11
    7416:	20 e0       	ldi	r18, 0x00	; 0
    7418:	30 e0       	ldi	r19, 0x00	; 0
    741a:	40 e8       	ldi	r20, 0x80	; 128
    741c:	5f e3       	ldi	r21, 0x3F	; 63
    741e:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    7422:	88 23       	and	r24, r24
    7424:	0c f0       	brlt	.+2      	; 0x7428 <FRAMTest3Channel+0x13c>
    7426:	10 e0       	ldi	r17, 0x00	; 0
    7428:	11 23       	and	r17, r17
    742a:	29 f0       	breq	.+10     	; 0x7436 <FRAMTest3Channel+0x14a>
		__ticks = 1;
    742c:	81 e0       	ldi	r24, 0x01	; 1
    742e:	90 e0       	ldi	r25, 0x00	; 0
    7430:	8a 8b       	std	Y+18, r24	; 0x12
    7432:	9b 8b       	std	Y+19, r25	; 0x13
    7434:	46 c0       	rjmp	.+140    	; 0x74c2 <FRAMTest3Channel+0x1d6>
	else if (__tmp > 65535)
    7436:	11 e0       	ldi	r17, 0x01	; 1
    7438:	6e 85       	ldd	r22, Y+14	; 0x0e
    743a:	7f 85       	ldd	r23, Y+15	; 0x0f
    743c:	88 89       	ldd	r24, Y+16	; 0x10
    743e:	99 89       	ldd	r25, Y+17	; 0x11
    7440:	20 e0       	ldi	r18, 0x00	; 0
    7442:	3f ef       	ldi	r19, 0xFF	; 255
    7444:	4f e7       	ldi	r20, 0x7F	; 127
    7446:	57 e4       	ldi	r21, 0x47	; 71
    7448:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    744c:	18 16       	cp	r1, r24
    744e:	0c f0       	brlt	.+2      	; 0x7452 <FRAMTest3Channel+0x166>
    7450:	10 e0       	ldi	r17, 0x00	; 0
    7452:	11 23       	and	r17, r17
    7454:	61 f1       	breq	.+88     	; 0x74ae <FRAMTest3Channel+0x1c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7456:	6a 85       	ldd	r22, Y+10	; 0x0a
    7458:	7b 85       	ldd	r23, Y+11	; 0x0b
    745a:	8c 85       	ldd	r24, Y+12	; 0x0c
    745c:	9d 85       	ldd	r25, Y+13	; 0x0d
    745e:	20 e0       	ldi	r18, 0x00	; 0
    7460:	30 e0       	ldi	r19, 0x00	; 0
    7462:	40 e2       	ldi	r20, 0x20	; 32
    7464:	51 e4       	ldi	r21, 0x41	; 65
    7466:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    746a:	dc 01       	movw	r26, r24
    746c:	cb 01       	movw	r24, r22
    746e:	bc 01       	movw	r22, r24
    7470:	cd 01       	movw	r24, r26
    7472:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    7476:	dc 01       	movw	r26, r24
    7478:	cb 01       	movw	r24, r22
    747a:	8a 8b       	std	Y+18, r24	; 0x12
    747c:	9b 8b       	std	Y+19, r25	; 0x13
    747e:	12 c0       	rjmp	.+36     	; 0x74a4 <FRAMTest3Channel+0x1b8>
    7480:	80 e2       	ldi	r24, 0x20	; 32
    7482:	93 e0       	ldi	r25, 0x03	; 3
    7484:	8c 8b       	std	Y+20, r24	; 0x14
    7486:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7488:	8c 89       	ldd	r24, Y+20	; 0x14
    748a:	9d 89       	ldd	r25, Y+21	; 0x15
    748c:	8c 01       	movw	r16, r24
    748e:	c8 01       	movw	r24, r16
    7490:	01 97       	sbiw	r24, 0x01	; 1
    7492:	f1 f7       	brne	.-4      	; 0x7490 <FRAMTest3Channel+0x1a4>
    7494:	8c 01       	movw	r16, r24
    7496:	0c 8b       	std	Y+20, r16	; 0x14
    7498:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    749a:	8a 89       	ldd	r24, Y+18	; 0x12
    749c:	9b 89       	ldd	r25, Y+19	; 0x13
    749e:	01 97       	sbiw	r24, 0x01	; 1
    74a0:	8a 8b       	std	Y+18, r24	; 0x12
    74a2:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    74a4:	8a 89       	ldd	r24, Y+18	; 0x12
    74a6:	9b 89       	ldd	r25, Y+19	; 0x13
    74a8:	00 97       	sbiw	r24, 0x00	; 0
    74aa:	51 f7       	brne	.-44     	; 0x7480 <FRAMTest3Channel+0x194>
    74ac:	28 c0       	rjmp	.+80     	; 0x74fe <FRAMTest3Channel+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    74ae:	6e 85       	ldd	r22, Y+14	; 0x0e
    74b0:	7f 85       	ldd	r23, Y+15	; 0x0f
    74b2:	88 89       	ldd	r24, Y+16	; 0x10
    74b4:	99 89       	ldd	r25, Y+17	; 0x11
    74b6:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    74ba:	dc 01       	movw	r26, r24
    74bc:	cb 01       	movw	r24, r22
    74be:	8a 8b       	std	Y+18, r24	; 0x12
    74c0:	9b 8b       	std	Y+19, r25	; 0x13
    74c2:	8a 89       	ldd	r24, Y+18	; 0x12
    74c4:	9b 89       	ldd	r25, Y+19	; 0x13
    74c6:	8e 8b       	std	Y+22, r24	; 0x16
    74c8:	9f 8b       	std	Y+23, r25	; 0x17
    74ca:	8e 89       	ldd	r24, Y+22	; 0x16
    74cc:	9f 89       	ldd	r25, Y+23	; 0x17
    74ce:	8c 01       	movw	r16, r24
    74d0:	c8 01       	movw	r24, r16
    74d2:	01 97       	sbiw	r24, 0x01	; 1
    74d4:	f1 f7       	brne	.-4      	; 0x74d2 <FRAMTest3Channel+0x1e6>
    74d6:	8c 01       	movw	r16, r24
    74d8:	0e 8b       	std	Y+22, r16	; 0x16
    74da:	1f 8b       	std	Y+23, r17	; 0x17
    74dc:	10 c0       	rjmp	.+32     	; 0x74fe <FRAMTest3Channel+0x212>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    74de:	6d 81       	ldd	r22, Y+5	; 0x05
    74e0:	7e 81       	ldd	r23, Y+6	; 0x06
    74e2:	8f 81       	ldd	r24, Y+7	; 0x07
    74e4:	98 85       	ldd	r25, Y+8	; 0x08
    74e6:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    74ea:	dc 01       	movw	r26, r24
    74ec:	cb 01       	movw	r24, r22
    74ee:	89 87       	std	Y+9, r24	; 0x09
    74f0:	89 85       	ldd	r24, Y+9	; 0x09
    74f2:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    74f4:	88 8d       	ldd	r24, Y+24	; 0x18
    74f6:	18 2f       	mov	r17, r24
    74f8:	1a 95       	dec	r17
    74fa:	f1 f7       	brne	.-4      	; 0x74f8 <FRAMTest3Channel+0x20c>
    74fc:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    74fe:	0e 94 ef 16 	call	0x2dde	; 0x2dde <calcChecksumFRAM>

	ADCPower(FALSE);
    7502:	80 e0       	ldi	r24, 0x00	; 0
    7504:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	
}
    7508:	6b 96       	adiw	r28, 0x1b	; 27
    750a:	cd bf       	out	0x3d, r28	; 61
    750c:	de bf       	out	0x3e, r29	; 62
    750e:	df 91       	pop	r29
    7510:	cf 91       	pop	r28
    7512:	1f 91       	pop	r17
    7514:	0f 91       	pop	r16
    7516:	ff 90       	pop	r15
    7518:	ef 90       	pop	r14
    751a:	df 90       	pop	r13
    751c:	cf 90       	pop	r12
    751e:	bf 90       	pop	r11
    7520:	af 90       	pop	r10
    7522:	9f 90       	pop	r9
    7524:	8f 90       	pop	r8
    7526:	08 95       	ret

00007528 <FRAMTest1Channel>:

void FRAMTest1Channel(void) {
    7528:	8f 92       	push	r8
    752a:	9f 92       	push	r9
    752c:	af 92       	push	r10
    752e:	bf 92       	push	r11
    7530:	cf 92       	push	r12
    7532:	df 92       	push	r13
    7534:	ef 92       	push	r14
    7536:	0f 93       	push	r16
    7538:	1f 93       	push	r17
    753a:	cf 93       	push	r28
    753c:	df 93       	push	r29
    753e:	cd b7       	in	r28, 0x3d	; 61
    7540:	de b7       	in	r29, 0x3e	; 62
    7542:	68 97       	sbiw	r28, 0x18	; 24
    7544:	cd bf       	out	0x3d, r28	; 61
    7546:	de bf       	out	0x3e, r29	; 62

	CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
    7548:	0f 92       	push	r0
    754a:	0f 92       	push	r0
    754c:	8d b7       	in	r24, 0x3d	; 61
    754e:	9e b7       	in	r25, 0x3e	; 62
    7550:	01 96       	adiw	r24, 0x01	; 1
    7552:	20 e1       	ldi	r18, 0x10	; 16
    7554:	30 e0       	ldi	r19, 0x00	; 0
    7556:	fc 01       	movw	r30, r24
    7558:	20 83       	st	Z, r18
    755a:	31 83       	std	Z+1, r19	; 0x01
    755c:	87 e0       	ldi	r24, 0x07	; 7
    755e:	68 ec       	ldi	r22, 0xC8	; 200
    7560:	40 e0       	ldi	r20, 0x00	; 0
    7562:	20 e0       	ldi	r18, 0x00	; 0
    7564:	05 e1       	ldi	r16, 0x15	; 21
    7566:	ee 24       	eor	r14, r14
    7568:	e3 94       	inc	r14
    756a:	0f 2e       	mov	r0, r31
    756c:	fd e0       	ldi	r31, 0x0D	; 13
    756e:	cf 2e       	mov	r12, r31
    7570:	dd 24       	eor	r13, r13
    7572:	f0 2d       	mov	r31, r0
    7574:	0f 2e       	mov	r0, r31
    7576:	fe e0       	ldi	r31, 0x0E	; 14
    7578:	af 2e       	mov	r10, r31
    757a:	bb 24       	eor	r11, r11
    757c:	f0 2d       	mov	r31, r0
    757e:	0f 2e       	mov	r0, r31
    7580:	ff e0       	ldi	r31, 0x0F	; 15
    7582:	8f 2e       	mov	r8, r31
    7584:	99 24       	eor	r9, r9
    7586:	f0 2d       	mov	r31, r0
    7588:	0e 94 24 13 	call	0x2648	; 0x2648 <CO_collectSeismic1Channel>
    758c:	0f 90       	pop	r0
    758e:	0f 90       	pop	r0
	GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7590:	81 e0       	ldi	r24, 0x01	; 1
    7592:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
    7596:	80 e0       	ldi	r24, 0x00	; 0
    7598:	90 e0       	ldi	r25, 0x00	; 0
    759a:	aa e7       	ldi	r26, 0x7A	; 122
    759c:	b3 e4       	ldi	r27, 0x43	; 67
    759e:	89 83       	std	Y+1, r24	; 0x01
    75a0:	9a 83       	std	Y+2, r25	; 0x02
    75a2:	ab 83       	std	Y+3, r26	; 0x03
    75a4:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    75a6:	69 81       	ldd	r22, Y+1	; 0x01
    75a8:	7a 81       	ldd	r23, Y+2	; 0x02
    75aa:	8b 81       	ldd	r24, Y+3	; 0x03
    75ac:	9c 81       	ldd	r25, Y+4	; 0x04
    75ae:	2b ea       	ldi	r18, 0xAB	; 171
    75b0:	3a ea       	ldi	r19, 0xAA	; 170
    75b2:	4a e2       	ldi	r20, 0x2A	; 42
    75b4:	51 e4       	ldi	r21, 0x41	; 65
    75b6:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    75ba:	dc 01       	movw	r26, r24
    75bc:	cb 01       	movw	r24, r22
    75be:	8d 83       	std	Y+5, r24	; 0x05
    75c0:	9e 83       	std	Y+6, r25	; 0x06
    75c2:	af 83       	std	Y+7, r26	; 0x07
    75c4:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    75c6:	11 e0       	ldi	r17, 0x01	; 1
    75c8:	6d 81       	ldd	r22, Y+5	; 0x05
    75ca:	7e 81       	ldd	r23, Y+6	; 0x06
    75cc:	8f 81       	ldd	r24, Y+7	; 0x07
    75ce:	98 85       	ldd	r25, Y+8	; 0x08
    75d0:	20 e0       	ldi	r18, 0x00	; 0
    75d2:	30 e0       	ldi	r19, 0x00	; 0
    75d4:	40 e8       	ldi	r20, 0x80	; 128
    75d6:	5f e3       	ldi	r21, 0x3F	; 63
    75d8:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    75dc:	88 23       	and	r24, r24
    75de:	0c f0       	brlt	.+2      	; 0x75e2 <FRAMTest1Channel+0xba>
    75e0:	10 e0       	ldi	r17, 0x00	; 0
    75e2:	11 23       	and	r17, r17
    75e4:	19 f0       	breq	.+6      	; 0x75ec <FRAMTest1Channel+0xc4>
		__ticks = 1;
    75e6:	81 e0       	ldi	r24, 0x01	; 1
    75e8:	89 87       	std	Y+9, r24	; 0x09
    75ea:	a3 c0       	rjmp	.+326    	; 0x7732 <FRAMTest1Channel+0x20a>
	else if (__tmp > 255)
    75ec:	11 e0       	ldi	r17, 0x01	; 1
    75ee:	6d 81       	ldd	r22, Y+5	; 0x05
    75f0:	7e 81       	ldd	r23, Y+6	; 0x06
    75f2:	8f 81       	ldd	r24, Y+7	; 0x07
    75f4:	98 85       	ldd	r25, Y+8	; 0x08
    75f6:	20 e0       	ldi	r18, 0x00	; 0
    75f8:	30 e0       	ldi	r19, 0x00	; 0
    75fa:	4f e7       	ldi	r20, 0x7F	; 127
    75fc:	53 e4       	ldi	r21, 0x43	; 67
    75fe:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    7602:	18 16       	cp	r1, r24
    7604:	0c f0       	brlt	.+2      	; 0x7608 <FRAMTest1Channel+0xe0>
    7606:	10 e0       	ldi	r17, 0x00	; 0
    7608:	11 23       	and	r17, r17
    760a:	09 f4       	brne	.+2      	; 0x760e <FRAMTest1Channel+0xe6>
    760c:	89 c0       	rjmp	.+274    	; 0x7720 <FRAMTest1Channel+0x1f8>
	{
		_delay_ms(__us / 1000.0);
    760e:	69 81       	ldd	r22, Y+1	; 0x01
    7610:	7a 81       	ldd	r23, Y+2	; 0x02
    7612:	8b 81       	ldd	r24, Y+3	; 0x03
    7614:	9c 81       	ldd	r25, Y+4	; 0x04
    7616:	20 e0       	ldi	r18, 0x00	; 0
    7618:	30 e0       	ldi	r19, 0x00	; 0
    761a:	4a e7       	ldi	r20, 0x7A	; 122
    761c:	54 e4       	ldi	r21, 0x44	; 68
    761e:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    7622:	dc 01       	movw	r26, r24
    7624:	cb 01       	movw	r24, r22
    7626:	8a 87       	std	Y+10, r24	; 0x0a
    7628:	9b 87       	std	Y+11, r25	; 0x0b
    762a:	ac 87       	std	Y+12, r26	; 0x0c
    762c:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    762e:	6a 85       	ldd	r22, Y+10	; 0x0a
    7630:	7b 85       	ldd	r23, Y+11	; 0x0b
    7632:	8c 85       	ldd	r24, Y+12	; 0x0c
    7634:	9d 85       	ldd	r25, Y+13	; 0x0d
    7636:	20 e0       	ldi	r18, 0x00	; 0
    7638:	30 e0       	ldi	r19, 0x00	; 0
    763a:	4a ef       	ldi	r20, 0xFA	; 250
    763c:	55 e4       	ldi	r21, 0x45	; 69
    763e:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7642:	dc 01       	movw	r26, r24
    7644:	cb 01       	movw	r24, r22
    7646:	8e 87       	std	Y+14, r24	; 0x0e
    7648:	9f 87       	std	Y+15, r25	; 0x0f
    764a:	a8 8b       	std	Y+16, r26	; 0x10
    764c:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    764e:	11 e0       	ldi	r17, 0x01	; 1
    7650:	6e 85       	ldd	r22, Y+14	; 0x0e
    7652:	7f 85       	ldd	r23, Y+15	; 0x0f
    7654:	88 89       	ldd	r24, Y+16	; 0x10
    7656:	99 89       	ldd	r25, Y+17	; 0x11
    7658:	20 e0       	ldi	r18, 0x00	; 0
    765a:	30 e0       	ldi	r19, 0x00	; 0
    765c:	40 e8       	ldi	r20, 0x80	; 128
    765e:	5f e3       	ldi	r21, 0x3F	; 63
    7660:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    7664:	88 23       	and	r24, r24
    7666:	0c f0       	brlt	.+2      	; 0x766a <FRAMTest1Channel+0x142>
    7668:	10 e0       	ldi	r17, 0x00	; 0
    766a:	11 23       	and	r17, r17
    766c:	29 f0       	breq	.+10     	; 0x7678 <FRAMTest1Channel+0x150>
		__ticks = 1;
    766e:	81 e0       	ldi	r24, 0x01	; 1
    7670:	90 e0       	ldi	r25, 0x00	; 0
    7672:	8a 8b       	std	Y+18, r24	; 0x12
    7674:	9b 8b       	std	Y+19, r25	; 0x13
    7676:	46 c0       	rjmp	.+140    	; 0x7704 <FRAMTest1Channel+0x1dc>
	else if (__tmp > 65535)
    7678:	11 e0       	ldi	r17, 0x01	; 1
    767a:	6e 85       	ldd	r22, Y+14	; 0x0e
    767c:	7f 85       	ldd	r23, Y+15	; 0x0f
    767e:	88 89       	ldd	r24, Y+16	; 0x10
    7680:	99 89       	ldd	r25, Y+17	; 0x11
    7682:	20 e0       	ldi	r18, 0x00	; 0
    7684:	3f ef       	ldi	r19, 0xFF	; 255
    7686:	4f e7       	ldi	r20, 0x7F	; 127
    7688:	57 e4       	ldi	r21, 0x47	; 71
    768a:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    768e:	18 16       	cp	r1, r24
    7690:	0c f0       	brlt	.+2      	; 0x7694 <FRAMTest1Channel+0x16c>
    7692:	10 e0       	ldi	r17, 0x00	; 0
    7694:	11 23       	and	r17, r17
    7696:	61 f1       	breq	.+88     	; 0x76f0 <FRAMTest1Channel+0x1c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7698:	6a 85       	ldd	r22, Y+10	; 0x0a
    769a:	7b 85       	ldd	r23, Y+11	; 0x0b
    769c:	8c 85       	ldd	r24, Y+12	; 0x0c
    769e:	9d 85       	ldd	r25, Y+13	; 0x0d
    76a0:	20 e0       	ldi	r18, 0x00	; 0
    76a2:	30 e0       	ldi	r19, 0x00	; 0
    76a4:	40 e2       	ldi	r20, 0x20	; 32
    76a6:	51 e4       	ldi	r21, 0x41	; 65
    76a8:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    76ac:	dc 01       	movw	r26, r24
    76ae:	cb 01       	movw	r24, r22
    76b0:	bc 01       	movw	r22, r24
    76b2:	cd 01       	movw	r24, r26
    76b4:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    76b8:	dc 01       	movw	r26, r24
    76ba:	cb 01       	movw	r24, r22
    76bc:	8a 8b       	std	Y+18, r24	; 0x12
    76be:	9b 8b       	std	Y+19, r25	; 0x13
    76c0:	12 c0       	rjmp	.+36     	; 0x76e6 <FRAMTest1Channel+0x1be>
    76c2:	80 e2       	ldi	r24, 0x20	; 32
    76c4:	93 e0       	ldi	r25, 0x03	; 3
    76c6:	8c 8b       	std	Y+20, r24	; 0x14
    76c8:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    76ca:	8c 89       	ldd	r24, Y+20	; 0x14
    76cc:	9d 89       	ldd	r25, Y+21	; 0x15
    76ce:	8c 01       	movw	r16, r24
    76d0:	c8 01       	movw	r24, r16
    76d2:	01 97       	sbiw	r24, 0x01	; 1
    76d4:	f1 f7       	brne	.-4      	; 0x76d2 <FRAMTest1Channel+0x1aa>
    76d6:	8c 01       	movw	r16, r24
    76d8:	0c 8b       	std	Y+20, r16	; 0x14
    76da:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    76dc:	8a 89       	ldd	r24, Y+18	; 0x12
    76de:	9b 89       	ldd	r25, Y+19	; 0x13
    76e0:	01 97       	sbiw	r24, 0x01	; 1
    76e2:	8a 8b       	std	Y+18, r24	; 0x12
    76e4:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    76e6:	8a 89       	ldd	r24, Y+18	; 0x12
    76e8:	9b 89       	ldd	r25, Y+19	; 0x13
    76ea:	00 97       	sbiw	r24, 0x00	; 0
    76ec:	51 f7       	brne	.-44     	; 0x76c2 <FRAMTest1Channel+0x19a>
    76ee:	28 c0       	rjmp	.+80     	; 0x7740 <FRAMTest1Channel+0x218>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    76f0:	6e 85       	ldd	r22, Y+14	; 0x0e
    76f2:	7f 85       	ldd	r23, Y+15	; 0x0f
    76f4:	88 89       	ldd	r24, Y+16	; 0x10
    76f6:	99 89       	ldd	r25, Y+17	; 0x11
    76f8:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    76fc:	dc 01       	movw	r26, r24
    76fe:	cb 01       	movw	r24, r22
    7700:	8a 8b       	std	Y+18, r24	; 0x12
    7702:	9b 8b       	std	Y+19, r25	; 0x13
    7704:	8a 89       	ldd	r24, Y+18	; 0x12
    7706:	9b 89       	ldd	r25, Y+19	; 0x13
    7708:	8e 8b       	std	Y+22, r24	; 0x16
    770a:	9f 8b       	std	Y+23, r25	; 0x17
    770c:	8e 89       	ldd	r24, Y+22	; 0x16
    770e:	9f 89       	ldd	r25, Y+23	; 0x17
    7710:	8c 01       	movw	r16, r24
    7712:	f8 01       	movw	r30, r16
    7714:	31 97       	sbiw	r30, 0x01	; 1
    7716:	f1 f7       	brne	.-4      	; 0x7714 <FRAMTest1Channel+0x1ec>
    7718:	8f 01       	movw	r16, r30
    771a:	0e 8b       	std	Y+22, r16	; 0x16
    771c:	1f 8b       	std	Y+23, r17	; 0x17
    771e:	10 c0       	rjmp	.+32     	; 0x7740 <FRAMTest1Channel+0x218>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7720:	6d 81       	ldd	r22, Y+5	; 0x05
    7722:	7e 81       	ldd	r23, Y+6	; 0x06
    7724:	8f 81       	ldd	r24, Y+7	; 0x07
    7726:	98 85       	ldd	r25, Y+8	; 0x08
    7728:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    772c:	dc 01       	movw	r26, r24
    772e:	cb 01       	movw	r24, r22
    7730:	89 87       	std	Y+9, r24	; 0x09
    7732:	89 85       	ldd	r24, Y+9	; 0x09
    7734:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7736:	88 8d       	ldd	r24, Y+24	; 0x18
    7738:	18 2f       	mov	r17, r24
    773a:	1a 95       	dec	r17
    773c:	f1 f7       	brne	.-4      	; 0x773a <FRAMTest1Channel+0x212>
    773e:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7740:	0e 94 ef 16 	call	0x2dde	; 0x2dde <calcChecksumFRAM>

	ADCPower(FALSE);
    7744:	80 e0       	ldi	r24, 0x00	; 0
    7746:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>

}
    774a:	68 96       	adiw	r28, 0x18	; 24
    774c:	cd bf       	out	0x3d, r28	; 61
    774e:	de bf       	out	0x3e, r29	; 62
    7750:	df 91       	pop	r29
    7752:	cf 91       	pop	r28
    7754:	1f 91       	pop	r17
    7756:	0f 91       	pop	r16
    7758:	ef 90       	pop	r14
    775a:	df 90       	pop	r13
    775c:	cf 90       	pop	r12
    775e:	bf 90       	pop	r11
    7760:	af 90       	pop	r10
    7762:	9f 90       	pop	r9
    7764:	8f 90       	pop	r8
    7766:	08 95       	ret

00007768 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7768:	0f 93       	push	r16
    776a:	1f 93       	push	r17
    776c:	cf 93       	push	r28
    776e:	df 93       	push	r29
    7770:	cd b7       	in	r28, 0x3d	; 61
    7772:	de b7       	in	r29, 0x3e	; 62
    7774:	68 97       	sbiw	r28, 0x18	; 24
    7776:	cd bf       	out	0x3d, r28	; 61
    7778:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    777a:	0e 94 f7 19 	call	0x33ee	; 0x33ee <FRAMWriteKnowns>
	ADCPower(TRUE);
    777e:	81 e0       	ldi	r24, 0x01	; 1
    7780:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
    7784:	80 e0       	ldi	r24, 0x00	; 0
    7786:	90 e0       	ldi	r25, 0x00	; 0
    7788:	aa e7       	ldi	r26, 0x7A	; 122
    778a:	b3 e4       	ldi	r27, 0x43	; 67
    778c:	89 83       	std	Y+1, r24	; 0x01
    778e:	9a 83       	std	Y+2, r25	; 0x02
    7790:	ab 83       	std	Y+3, r26	; 0x03
    7792:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7794:	69 81       	ldd	r22, Y+1	; 0x01
    7796:	7a 81       	ldd	r23, Y+2	; 0x02
    7798:	8b 81       	ldd	r24, Y+3	; 0x03
    779a:	9c 81       	ldd	r25, Y+4	; 0x04
    779c:	2b ea       	ldi	r18, 0xAB	; 171
    779e:	3a ea       	ldi	r19, 0xAA	; 170
    77a0:	4a e2       	ldi	r20, 0x2A	; 42
    77a2:	51 e4       	ldi	r21, 0x41	; 65
    77a4:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    77a8:	dc 01       	movw	r26, r24
    77aa:	cb 01       	movw	r24, r22
    77ac:	8d 83       	std	Y+5, r24	; 0x05
    77ae:	9e 83       	std	Y+6, r25	; 0x06
    77b0:	af 83       	std	Y+7, r26	; 0x07
    77b2:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    77b4:	11 e0       	ldi	r17, 0x01	; 1
    77b6:	6d 81       	ldd	r22, Y+5	; 0x05
    77b8:	7e 81       	ldd	r23, Y+6	; 0x06
    77ba:	8f 81       	ldd	r24, Y+7	; 0x07
    77bc:	98 85       	ldd	r25, Y+8	; 0x08
    77be:	20 e0       	ldi	r18, 0x00	; 0
    77c0:	30 e0       	ldi	r19, 0x00	; 0
    77c2:	40 e8       	ldi	r20, 0x80	; 128
    77c4:	5f e3       	ldi	r21, 0x3F	; 63
    77c6:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    77ca:	88 23       	and	r24, r24
    77cc:	0c f0       	brlt	.+2      	; 0x77d0 <FRAMWriteKnownsCheck+0x68>
    77ce:	10 e0       	ldi	r17, 0x00	; 0
    77d0:	11 23       	and	r17, r17
    77d2:	19 f0       	breq	.+6      	; 0x77da <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    77d4:	81 e0       	ldi	r24, 0x01	; 1
    77d6:	89 87       	std	Y+9, r24	; 0x09
    77d8:	a3 c0       	rjmp	.+326    	; 0x7920 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    77da:	11 e0       	ldi	r17, 0x01	; 1
    77dc:	6d 81       	ldd	r22, Y+5	; 0x05
    77de:	7e 81       	ldd	r23, Y+6	; 0x06
    77e0:	8f 81       	ldd	r24, Y+7	; 0x07
    77e2:	98 85       	ldd	r25, Y+8	; 0x08
    77e4:	20 e0       	ldi	r18, 0x00	; 0
    77e6:	30 e0       	ldi	r19, 0x00	; 0
    77e8:	4f e7       	ldi	r20, 0x7F	; 127
    77ea:	53 e4       	ldi	r21, 0x43	; 67
    77ec:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    77f0:	18 16       	cp	r1, r24
    77f2:	0c f0       	brlt	.+2      	; 0x77f6 <FRAMWriteKnownsCheck+0x8e>
    77f4:	10 e0       	ldi	r17, 0x00	; 0
    77f6:	11 23       	and	r17, r17
    77f8:	09 f4       	brne	.+2      	; 0x77fc <FRAMWriteKnownsCheck+0x94>
    77fa:	89 c0       	rjmp	.+274    	; 0x790e <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    77fc:	69 81       	ldd	r22, Y+1	; 0x01
    77fe:	7a 81       	ldd	r23, Y+2	; 0x02
    7800:	8b 81       	ldd	r24, Y+3	; 0x03
    7802:	9c 81       	ldd	r25, Y+4	; 0x04
    7804:	20 e0       	ldi	r18, 0x00	; 0
    7806:	30 e0       	ldi	r19, 0x00	; 0
    7808:	4a e7       	ldi	r20, 0x7A	; 122
    780a:	54 e4       	ldi	r21, 0x44	; 68
    780c:	0e 94 df 5a 	call	0xb5be	; 0xb5be <__divsf3>
    7810:	dc 01       	movw	r26, r24
    7812:	cb 01       	movw	r24, r22
    7814:	8a 87       	std	Y+10, r24	; 0x0a
    7816:	9b 87       	std	Y+11, r25	; 0x0b
    7818:	ac 87       	std	Y+12, r26	; 0x0c
    781a:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    781c:	6a 85       	ldd	r22, Y+10	; 0x0a
    781e:	7b 85       	ldd	r23, Y+11	; 0x0b
    7820:	8c 85       	ldd	r24, Y+12	; 0x0c
    7822:	9d 85       	ldd	r25, Y+13	; 0x0d
    7824:	20 e0       	ldi	r18, 0x00	; 0
    7826:	30 e0       	ldi	r19, 0x00	; 0
    7828:	4a ef       	ldi	r20, 0xFA	; 250
    782a:	55 e4       	ldi	r21, 0x45	; 69
    782c:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7830:	dc 01       	movw	r26, r24
    7832:	cb 01       	movw	r24, r22
    7834:	8e 87       	std	Y+14, r24	; 0x0e
    7836:	9f 87       	std	Y+15, r25	; 0x0f
    7838:	a8 8b       	std	Y+16, r26	; 0x10
    783a:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    783c:	11 e0       	ldi	r17, 0x01	; 1
    783e:	6e 85       	ldd	r22, Y+14	; 0x0e
    7840:	7f 85       	ldd	r23, Y+15	; 0x0f
    7842:	88 89       	ldd	r24, Y+16	; 0x10
    7844:	99 89       	ldd	r25, Y+17	; 0x11
    7846:	20 e0       	ldi	r18, 0x00	; 0
    7848:	30 e0       	ldi	r19, 0x00	; 0
    784a:	40 e8       	ldi	r20, 0x80	; 128
    784c:	5f e3       	ldi	r21, 0x3F	; 63
    784e:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    7852:	88 23       	and	r24, r24
    7854:	0c f0       	brlt	.+2      	; 0x7858 <FRAMWriteKnownsCheck+0xf0>
    7856:	10 e0       	ldi	r17, 0x00	; 0
    7858:	11 23       	and	r17, r17
    785a:	29 f0       	breq	.+10     	; 0x7866 <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    785c:	81 e0       	ldi	r24, 0x01	; 1
    785e:	90 e0       	ldi	r25, 0x00	; 0
    7860:	8a 8b       	std	Y+18, r24	; 0x12
    7862:	9b 8b       	std	Y+19, r25	; 0x13
    7864:	46 c0       	rjmp	.+140    	; 0x78f2 <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7866:	11 e0       	ldi	r17, 0x01	; 1
    7868:	6e 85       	ldd	r22, Y+14	; 0x0e
    786a:	7f 85       	ldd	r23, Y+15	; 0x0f
    786c:	88 89       	ldd	r24, Y+16	; 0x10
    786e:	99 89       	ldd	r25, Y+17	; 0x11
    7870:	20 e0       	ldi	r18, 0x00	; 0
    7872:	3f ef       	ldi	r19, 0xFF	; 255
    7874:	4f e7       	ldi	r20, 0x7F	; 127
    7876:	57 e4       	ldi	r21, 0x47	; 71
    7878:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    787c:	18 16       	cp	r1, r24
    787e:	0c f0       	brlt	.+2      	; 0x7882 <FRAMWriteKnownsCheck+0x11a>
    7880:	10 e0       	ldi	r17, 0x00	; 0
    7882:	11 23       	and	r17, r17
    7884:	61 f1       	breq	.+88     	; 0x78de <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7886:	6a 85       	ldd	r22, Y+10	; 0x0a
    7888:	7b 85       	ldd	r23, Y+11	; 0x0b
    788a:	8c 85       	ldd	r24, Y+12	; 0x0c
    788c:	9d 85       	ldd	r25, Y+13	; 0x0d
    788e:	20 e0       	ldi	r18, 0x00	; 0
    7890:	30 e0       	ldi	r19, 0x00	; 0
    7892:	40 e2       	ldi	r20, 0x20	; 32
    7894:	51 e4       	ldi	r21, 0x41	; 65
    7896:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    789a:	dc 01       	movw	r26, r24
    789c:	cb 01       	movw	r24, r22
    789e:	bc 01       	movw	r22, r24
    78a0:	cd 01       	movw	r24, r26
    78a2:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    78a6:	dc 01       	movw	r26, r24
    78a8:	cb 01       	movw	r24, r22
    78aa:	8a 8b       	std	Y+18, r24	; 0x12
    78ac:	9b 8b       	std	Y+19, r25	; 0x13
    78ae:	12 c0       	rjmp	.+36     	; 0x78d4 <FRAMWriteKnownsCheck+0x16c>
    78b0:	80 e2       	ldi	r24, 0x20	; 32
    78b2:	93 e0       	ldi	r25, 0x03	; 3
    78b4:	8c 8b       	std	Y+20, r24	; 0x14
    78b6:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    78b8:	8c 89       	ldd	r24, Y+20	; 0x14
    78ba:	9d 89       	ldd	r25, Y+21	; 0x15
    78bc:	8c 01       	movw	r16, r24
    78be:	c8 01       	movw	r24, r16
    78c0:	01 97       	sbiw	r24, 0x01	; 1
    78c2:	f1 f7       	brne	.-4      	; 0x78c0 <FRAMWriteKnownsCheck+0x158>
    78c4:	8c 01       	movw	r16, r24
    78c6:	0c 8b       	std	Y+20, r16	; 0x14
    78c8:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    78ca:	8a 89       	ldd	r24, Y+18	; 0x12
    78cc:	9b 89       	ldd	r25, Y+19	; 0x13
    78ce:	01 97       	sbiw	r24, 0x01	; 1
    78d0:	8a 8b       	std	Y+18, r24	; 0x12
    78d2:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    78d4:	8a 89       	ldd	r24, Y+18	; 0x12
    78d6:	9b 89       	ldd	r25, Y+19	; 0x13
    78d8:	00 97       	sbiw	r24, 0x00	; 0
    78da:	51 f7       	brne	.-44     	; 0x78b0 <FRAMWriteKnownsCheck+0x148>
    78dc:	28 c0       	rjmp	.+80     	; 0x792e <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    78de:	6e 85       	ldd	r22, Y+14	; 0x0e
    78e0:	7f 85       	ldd	r23, Y+15	; 0x0f
    78e2:	88 89       	ldd	r24, Y+16	; 0x10
    78e4:	99 89       	ldd	r25, Y+17	; 0x11
    78e6:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    78ea:	dc 01       	movw	r26, r24
    78ec:	cb 01       	movw	r24, r22
    78ee:	8a 8b       	std	Y+18, r24	; 0x12
    78f0:	9b 8b       	std	Y+19, r25	; 0x13
    78f2:	8a 89       	ldd	r24, Y+18	; 0x12
    78f4:	9b 89       	ldd	r25, Y+19	; 0x13
    78f6:	8e 8b       	std	Y+22, r24	; 0x16
    78f8:	9f 8b       	std	Y+23, r25	; 0x17
    78fa:	8e 89       	ldd	r24, Y+22	; 0x16
    78fc:	9f 89       	ldd	r25, Y+23	; 0x17
    78fe:	8c 01       	movw	r16, r24
    7900:	c8 01       	movw	r24, r16
    7902:	01 97       	sbiw	r24, 0x01	; 1
    7904:	f1 f7       	brne	.-4      	; 0x7902 <FRAMWriteKnownsCheck+0x19a>
    7906:	8c 01       	movw	r16, r24
    7908:	0e 8b       	std	Y+22, r16	; 0x16
    790a:	1f 8b       	std	Y+23, r17	; 0x17
    790c:	10 c0       	rjmp	.+32     	; 0x792e <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    790e:	6d 81       	ldd	r22, Y+5	; 0x05
    7910:	7e 81       	ldd	r23, Y+6	; 0x06
    7912:	8f 81       	ldd	r24, Y+7	; 0x07
    7914:	98 85       	ldd	r25, Y+8	; 0x08
    7916:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    791a:	dc 01       	movw	r26, r24
    791c:	cb 01       	movw	r24, r22
    791e:	89 87       	std	Y+9, r24	; 0x09
    7920:	89 85       	ldd	r24, Y+9	; 0x09
    7922:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7924:	88 8d       	ldd	r24, Y+24	; 0x18
    7926:	18 2f       	mov	r17, r24
    7928:	1a 95       	dec	r17
    792a:	f1 f7       	brne	.-4      	; 0x7928 <FRAMWriteKnownsCheck+0x1c0>
    792c:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    792e:	0e 94 ef 16 	call	0x2dde	; 0x2dde <calcChecksumFRAM>

	ADCPower(FALSE);
    7932:	80 e0       	ldi	r24, 0x00	; 0
    7934:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>

}
    7938:	68 96       	adiw	r28, 0x18	; 24
    793a:	cd bf       	out	0x3d, r28	; 61
    793c:	de bf       	out	0x3e, r29	; 62
    793e:	df 91       	pop	r29
    7940:	cf 91       	pop	r28
    7942:	1f 91       	pop	r17
    7944:	0f 91       	pop	r16
    7946:	08 95       	ret

00007948 <checkMote>:

//random function for testing stuff	
void checkMote(){
    7948:	0f 93       	push	r16
    794a:	1f 93       	push	r17
    794c:	cf 93       	push	r28
    794e:	df 93       	push	r29
    7950:	cd b7       	in	r28, 0x3d	; 61
    7952:	de b7       	in	r29, 0x3e	; 62
    7954:	aa 97       	sbiw	r28, 0x2a	; 42
    7956:	cd bf       	out	0x3d, r28	; 61
    7958:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    795a:	81 e0       	ldi	r24, 0x01	; 1
    795c:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	Ext1Power(TRUE);
    7960:	81 e0       	ldi	r24, 0x01	; 1
    7962:	0e 94 61 35 	call	0x6ac2	; 0x6ac2 <Ext1Power>
    7966:	80 e0       	ldi	r24, 0x00	; 0
    7968:	90 e0       	ldi	r25, 0x00	; 0
    796a:	a8 ec       	ldi	r26, 0xC8	; 200
    796c:	b2 e4       	ldi	r27, 0x42	; 66
    796e:	89 83       	std	Y+1, r24	; 0x01
    7970:	9a 83       	std	Y+2, r25	; 0x02
    7972:	ab 83       	std	Y+3, r26	; 0x03
    7974:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7976:	69 81       	ldd	r22, Y+1	; 0x01
    7978:	7a 81       	ldd	r23, Y+2	; 0x02
    797a:	8b 81       	ldd	r24, Y+3	; 0x03
    797c:	9c 81       	ldd	r25, Y+4	; 0x04
    797e:	20 e0       	ldi	r18, 0x00	; 0
    7980:	30 e0       	ldi	r19, 0x00	; 0
    7982:	4a ef       	ldi	r20, 0xFA	; 250
    7984:	55 e4       	ldi	r21, 0x45	; 69
    7986:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    798a:	dc 01       	movw	r26, r24
    798c:	cb 01       	movw	r24, r22
    798e:	8d 83       	std	Y+5, r24	; 0x05
    7990:	9e 83       	std	Y+6, r25	; 0x06
    7992:	af 83       	std	Y+7, r26	; 0x07
    7994:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7996:	11 e0       	ldi	r17, 0x01	; 1
    7998:	6d 81       	ldd	r22, Y+5	; 0x05
    799a:	7e 81       	ldd	r23, Y+6	; 0x06
    799c:	8f 81       	ldd	r24, Y+7	; 0x07
    799e:	98 85       	ldd	r25, Y+8	; 0x08
    79a0:	20 e0       	ldi	r18, 0x00	; 0
    79a2:	30 e0       	ldi	r19, 0x00	; 0
    79a4:	40 e8       	ldi	r20, 0x80	; 128
    79a6:	5f e3       	ldi	r21, 0x3F	; 63
    79a8:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    79ac:	88 23       	and	r24, r24
    79ae:	0c f0       	brlt	.+2      	; 0x79b2 <checkMote+0x6a>
    79b0:	10 e0       	ldi	r17, 0x00	; 0
    79b2:	11 23       	and	r17, r17
    79b4:	29 f0       	breq	.+10     	; 0x79c0 <checkMote+0x78>
		__ticks = 1;
    79b6:	81 e0       	ldi	r24, 0x01	; 1
    79b8:	90 e0       	ldi	r25, 0x00	; 0
    79ba:	89 87       	std	Y+9, r24	; 0x09
    79bc:	9a 87       	std	Y+10, r25	; 0x0a
    79be:	46 c0       	rjmp	.+140    	; 0x7a4c <checkMote+0x104>
	else if (__tmp > 65535)
    79c0:	11 e0       	ldi	r17, 0x01	; 1
    79c2:	6d 81       	ldd	r22, Y+5	; 0x05
    79c4:	7e 81       	ldd	r23, Y+6	; 0x06
    79c6:	8f 81       	ldd	r24, Y+7	; 0x07
    79c8:	98 85       	ldd	r25, Y+8	; 0x08
    79ca:	20 e0       	ldi	r18, 0x00	; 0
    79cc:	3f ef       	ldi	r19, 0xFF	; 255
    79ce:	4f e7       	ldi	r20, 0x7F	; 127
    79d0:	57 e4       	ldi	r21, 0x47	; 71
    79d2:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    79d6:	18 16       	cp	r1, r24
    79d8:	0c f0       	brlt	.+2      	; 0x79dc <checkMote+0x94>
    79da:	10 e0       	ldi	r17, 0x00	; 0
    79dc:	11 23       	and	r17, r17
    79de:	61 f1       	breq	.+88     	; 0x7a38 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    79e0:	69 81       	ldd	r22, Y+1	; 0x01
    79e2:	7a 81       	ldd	r23, Y+2	; 0x02
    79e4:	8b 81       	ldd	r24, Y+3	; 0x03
    79e6:	9c 81       	ldd	r25, Y+4	; 0x04
    79e8:	20 e0       	ldi	r18, 0x00	; 0
    79ea:	30 e0       	ldi	r19, 0x00	; 0
    79ec:	40 e2       	ldi	r20, 0x20	; 32
    79ee:	51 e4       	ldi	r21, 0x41	; 65
    79f0:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    79f4:	dc 01       	movw	r26, r24
    79f6:	cb 01       	movw	r24, r22
    79f8:	bc 01       	movw	r22, r24
    79fa:	cd 01       	movw	r24, r26
    79fc:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    7a00:	dc 01       	movw	r26, r24
    7a02:	cb 01       	movw	r24, r22
    7a04:	89 87       	std	Y+9, r24	; 0x09
    7a06:	9a 87       	std	Y+10, r25	; 0x0a
    7a08:	12 c0       	rjmp	.+36     	; 0x7a2e <checkMote+0xe6>
    7a0a:	80 e2       	ldi	r24, 0x20	; 32
    7a0c:	93 e0       	ldi	r25, 0x03	; 3
    7a0e:	8b 87       	std	Y+11, r24	; 0x0b
    7a10:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7a12:	8b 85       	ldd	r24, Y+11	; 0x0b
    7a14:	9c 85       	ldd	r25, Y+12	; 0x0c
    7a16:	8c 01       	movw	r16, r24
    7a18:	c8 01       	movw	r24, r16
    7a1a:	01 97       	sbiw	r24, 0x01	; 1
    7a1c:	f1 f7       	brne	.-4      	; 0x7a1a <checkMote+0xd2>
    7a1e:	8c 01       	movw	r16, r24
    7a20:	0b 87       	std	Y+11, r16	; 0x0b
    7a22:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7a24:	89 85       	ldd	r24, Y+9	; 0x09
    7a26:	9a 85       	ldd	r25, Y+10	; 0x0a
    7a28:	01 97       	sbiw	r24, 0x01	; 1
    7a2a:	89 87       	std	Y+9, r24	; 0x09
    7a2c:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7a2e:	89 85       	ldd	r24, Y+9	; 0x09
    7a30:	9a 85       	ldd	r25, Y+10	; 0x0a
    7a32:	00 97       	sbiw	r24, 0x00	; 0
    7a34:	51 f7       	brne	.-44     	; 0x7a0a <checkMote+0xc2>
    7a36:	17 c0       	rjmp	.+46     	; 0x7a66 <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7a38:	6d 81       	ldd	r22, Y+5	; 0x05
    7a3a:	7e 81       	ldd	r23, Y+6	; 0x06
    7a3c:	8f 81       	ldd	r24, Y+7	; 0x07
    7a3e:	98 85       	ldd	r25, Y+8	; 0x08
    7a40:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    7a44:	dc 01       	movw	r26, r24
    7a46:	cb 01       	movw	r24, r22
    7a48:	89 87       	std	Y+9, r24	; 0x09
    7a4a:	9a 87       	std	Y+10, r25	; 0x0a
    7a4c:	89 85       	ldd	r24, Y+9	; 0x09
    7a4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7a50:	8d 87       	std	Y+13, r24	; 0x0d
    7a52:	9e 87       	std	Y+14, r25	; 0x0e
    7a54:	8d 85       	ldd	r24, Y+13	; 0x0d
    7a56:	9e 85       	ldd	r25, Y+14	; 0x0e
    7a58:	8c 01       	movw	r16, r24
    7a5a:	c8 01       	movw	r24, r16
    7a5c:	01 97       	sbiw	r24, 0x01	; 1
    7a5e:	f1 f7       	brne	.-4      	; 0x7a5c <checkMote+0x114>
    7a60:	8c 01       	movw	r16, r24
    7a62:	0d 87       	std	Y+13, r16	; 0x0d
    7a64:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7a66:	88 e0       	ldi	r24, 0x08	; 8
    7a68:	60 e0       	ldi	r22, 0x00	; 0
    7a6a:	0e 94 cb 33 	call	0x6796	; 0x6796 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7a6e:	88 e0       	ldi	r24, 0x08	; 8
    7a70:	60 e0       	ldi	r22, 0x00	; 0
    7a72:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
    7a76:	80 e0       	ldi	r24, 0x00	; 0
    7a78:	90 e4       	ldi	r25, 0x40	; 64
    7a7a:	ac e9       	ldi	r26, 0x9C	; 156
    7a7c:	b5 e4       	ldi	r27, 0x45	; 69
    7a7e:	8f 87       	std	Y+15, r24	; 0x0f
    7a80:	98 8b       	std	Y+16, r25	; 0x10
    7a82:	a9 8b       	std	Y+17, r26	; 0x11
    7a84:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7a86:	6f 85       	ldd	r22, Y+15	; 0x0f
    7a88:	78 89       	ldd	r23, Y+16	; 0x10
    7a8a:	89 89       	ldd	r24, Y+17	; 0x11
    7a8c:	9a 89       	ldd	r25, Y+18	; 0x12
    7a8e:	20 e0       	ldi	r18, 0x00	; 0
    7a90:	30 e0       	ldi	r19, 0x00	; 0
    7a92:	4a ef       	ldi	r20, 0xFA	; 250
    7a94:	55 e4       	ldi	r21, 0x45	; 69
    7a96:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7a9a:	dc 01       	movw	r26, r24
    7a9c:	cb 01       	movw	r24, r22
    7a9e:	8b 8b       	std	Y+19, r24	; 0x13
    7aa0:	9c 8b       	std	Y+20, r25	; 0x14
    7aa2:	ad 8b       	std	Y+21, r26	; 0x15
    7aa4:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7aa6:	11 e0       	ldi	r17, 0x01	; 1
    7aa8:	6b 89       	ldd	r22, Y+19	; 0x13
    7aaa:	7c 89       	ldd	r23, Y+20	; 0x14
    7aac:	8d 89       	ldd	r24, Y+21	; 0x15
    7aae:	9e 89       	ldd	r25, Y+22	; 0x16
    7ab0:	20 e0       	ldi	r18, 0x00	; 0
    7ab2:	30 e0       	ldi	r19, 0x00	; 0
    7ab4:	40 e8       	ldi	r20, 0x80	; 128
    7ab6:	5f e3       	ldi	r21, 0x3F	; 63
    7ab8:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    7abc:	88 23       	and	r24, r24
    7abe:	0c f0       	brlt	.+2      	; 0x7ac2 <checkMote+0x17a>
    7ac0:	10 e0       	ldi	r17, 0x00	; 0
    7ac2:	11 23       	and	r17, r17
    7ac4:	29 f0       	breq	.+10     	; 0x7ad0 <checkMote+0x188>
		__ticks = 1;
    7ac6:	81 e0       	ldi	r24, 0x01	; 1
    7ac8:	90 e0       	ldi	r25, 0x00	; 0
    7aca:	8f 8b       	std	Y+23, r24	; 0x17
    7acc:	98 8f       	std	Y+24, r25	; 0x18
    7ace:	46 c0       	rjmp	.+140    	; 0x7b5c <checkMote+0x214>
	else if (__tmp > 65535)
    7ad0:	11 e0       	ldi	r17, 0x01	; 1
    7ad2:	6b 89       	ldd	r22, Y+19	; 0x13
    7ad4:	7c 89       	ldd	r23, Y+20	; 0x14
    7ad6:	8d 89       	ldd	r24, Y+21	; 0x15
    7ad8:	9e 89       	ldd	r25, Y+22	; 0x16
    7ada:	20 e0       	ldi	r18, 0x00	; 0
    7adc:	3f ef       	ldi	r19, 0xFF	; 255
    7ade:	4f e7       	ldi	r20, 0x7F	; 127
    7ae0:	57 e4       	ldi	r21, 0x47	; 71
    7ae2:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    7ae6:	18 16       	cp	r1, r24
    7ae8:	0c f0       	brlt	.+2      	; 0x7aec <checkMote+0x1a4>
    7aea:	10 e0       	ldi	r17, 0x00	; 0
    7aec:	11 23       	and	r17, r17
    7aee:	61 f1       	breq	.+88     	; 0x7b48 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7af0:	6f 85       	ldd	r22, Y+15	; 0x0f
    7af2:	78 89       	ldd	r23, Y+16	; 0x10
    7af4:	89 89       	ldd	r24, Y+17	; 0x11
    7af6:	9a 89       	ldd	r25, Y+18	; 0x12
    7af8:	20 e0       	ldi	r18, 0x00	; 0
    7afa:	30 e0       	ldi	r19, 0x00	; 0
    7afc:	40 e2       	ldi	r20, 0x20	; 32
    7afe:	51 e4       	ldi	r21, 0x41	; 65
    7b00:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7b04:	dc 01       	movw	r26, r24
    7b06:	cb 01       	movw	r24, r22
    7b08:	bc 01       	movw	r22, r24
    7b0a:	cd 01       	movw	r24, r26
    7b0c:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    7b10:	dc 01       	movw	r26, r24
    7b12:	cb 01       	movw	r24, r22
    7b14:	8f 8b       	std	Y+23, r24	; 0x17
    7b16:	98 8f       	std	Y+24, r25	; 0x18
    7b18:	12 c0       	rjmp	.+36     	; 0x7b3e <checkMote+0x1f6>
    7b1a:	80 e2       	ldi	r24, 0x20	; 32
    7b1c:	93 e0       	ldi	r25, 0x03	; 3
    7b1e:	89 8f       	std	Y+25, r24	; 0x19
    7b20:	9a 8f       	std	Y+26, r25	; 0x1a
    7b22:	89 8d       	ldd	r24, Y+25	; 0x19
    7b24:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7b26:	8c 01       	movw	r16, r24
    7b28:	c8 01       	movw	r24, r16
    7b2a:	01 97       	sbiw	r24, 0x01	; 1
    7b2c:	f1 f7       	brne	.-4      	; 0x7b2a <checkMote+0x1e2>
    7b2e:	8c 01       	movw	r16, r24
    7b30:	09 8f       	std	Y+25, r16	; 0x19
    7b32:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b34:	8f 89       	ldd	r24, Y+23	; 0x17
    7b36:	98 8d       	ldd	r25, Y+24	; 0x18
    7b38:	01 97       	sbiw	r24, 0x01	; 1
    7b3a:	8f 8b       	std	Y+23, r24	; 0x17
    7b3c:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b3e:	8f 89       	ldd	r24, Y+23	; 0x17
    7b40:	98 8d       	ldd	r25, Y+24	; 0x18
    7b42:	00 97       	sbiw	r24, 0x00	; 0
    7b44:	51 f7       	brne	.-44     	; 0x7b1a <checkMote+0x1d2>
    7b46:	17 c0       	rjmp	.+46     	; 0x7b76 <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b48:	6b 89       	ldd	r22, Y+19	; 0x13
    7b4a:	7c 89       	ldd	r23, Y+20	; 0x14
    7b4c:	8d 89       	ldd	r24, Y+21	; 0x15
    7b4e:	9e 89       	ldd	r25, Y+22	; 0x16
    7b50:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    7b54:	dc 01       	movw	r26, r24
    7b56:	cb 01       	movw	r24, r22
    7b58:	8f 8b       	std	Y+23, r24	; 0x17
    7b5a:	98 8f       	std	Y+24, r25	; 0x18
    7b5c:	8f 89       	ldd	r24, Y+23	; 0x17
    7b5e:	98 8d       	ldd	r25, Y+24	; 0x18
    7b60:	8b 8f       	std	Y+27, r24	; 0x1b
    7b62:	9c 8f       	std	Y+28, r25	; 0x1c
    7b64:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7b66:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7b68:	8c 01       	movw	r16, r24
    7b6a:	c8 01       	movw	r24, r16
    7b6c:	01 97       	sbiw	r24, 0x01	; 1
    7b6e:	f1 f7       	brne	.-4      	; 0x7b6c <checkMote+0x224>
    7b70:	8c 01       	movw	r16, r24
    7b72:	0b 8f       	std	Y+27, r16	; 0x1b
    7b74:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7b76:	88 e0       	ldi	r24, 0x08	; 8
    7b78:	60 e0       	ldi	r22, 0x00	; 0
    7b7a:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
    7b7e:	80 e0       	ldi	r24, 0x00	; 0
    7b80:	90 e4       	ldi	r25, 0x40	; 64
    7b82:	ac e9       	ldi	r26, 0x9C	; 156
    7b84:	b5 e4       	ldi	r27, 0x45	; 69
    7b86:	8d 8f       	std	Y+29, r24	; 0x1d
    7b88:	9e 8f       	std	Y+30, r25	; 0x1e
    7b8a:	af 8f       	std	Y+31, r26	; 0x1f
    7b8c:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7b8e:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7b90:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7b92:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7b94:	98 a1       	lds	r25, 0x48
    7b96:	20 e0       	ldi	r18, 0x00	; 0
    7b98:	30 e0       	ldi	r19, 0x00	; 0
    7b9a:	4a ef       	ldi	r20, 0xFA	; 250
    7b9c:	55 e4       	ldi	r21, 0x45	; 69
    7b9e:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7ba2:	dc 01       	movw	r26, r24
    7ba4:	cb 01       	movw	r24, r22
    7ba6:	89 a3       	lds	r24, 0x59
    7ba8:	9a a3       	lds	r25, 0x5a
    7baa:	ab a3       	lds	r26, 0x5b
    7bac:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7bae:	11 e0       	ldi	r17, 0x01	; 1
    7bb0:	69 a1       	lds	r22, 0x49
    7bb2:	7a a1       	lds	r23, 0x4a
    7bb4:	8b a1       	lds	r24, 0x4b
    7bb6:	9c a1       	lds	r25, 0x4c
    7bb8:	20 e0       	ldi	r18, 0x00	; 0
    7bba:	30 e0       	ldi	r19, 0x00	; 0
    7bbc:	40 e8       	ldi	r20, 0x80	; 128
    7bbe:	5f e3       	ldi	r21, 0x3F	; 63
    7bc0:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    7bc4:	88 23       	and	r24, r24
    7bc6:	0c f0       	brlt	.+2      	; 0x7bca <checkMote+0x282>
    7bc8:	10 e0       	ldi	r17, 0x00	; 0
    7bca:	11 23       	and	r17, r17
    7bcc:	29 f0       	breq	.+10     	; 0x7bd8 <checkMote+0x290>
		__ticks = 1;
    7bce:	81 e0       	ldi	r24, 0x01	; 1
    7bd0:	90 e0       	ldi	r25, 0x00	; 0
    7bd2:	8d a3       	lds	r24, 0x5d
    7bd4:	9e a3       	lds	r25, 0x5e
    7bd6:	46 c0       	rjmp	.+140    	; 0x7c64 <checkMote+0x31c>
	else if (__tmp > 65535)
    7bd8:	11 e0       	ldi	r17, 0x01	; 1
    7bda:	69 a1       	lds	r22, 0x49
    7bdc:	7a a1       	lds	r23, 0x4a
    7bde:	8b a1       	lds	r24, 0x4b
    7be0:	9c a1       	lds	r25, 0x4c
    7be2:	20 e0       	ldi	r18, 0x00	; 0
    7be4:	3f ef       	ldi	r19, 0xFF	; 255
    7be6:	4f e7       	ldi	r20, 0x7F	; 127
    7be8:	57 e4       	ldi	r21, 0x47	; 71
    7bea:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    7bee:	18 16       	cp	r1, r24
    7bf0:	0c f0       	brlt	.+2      	; 0x7bf4 <checkMote+0x2ac>
    7bf2:	10 e0       	ldi	r17, 0x00	; 0
    7bf4:	11 23       	and	r17, r17
    7bf6:	61 f1       	breq	.+88     	; 0x7c50 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7bf8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7bfa:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7bfc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7bfe:	98 a1       	lds	r25, 0x48
    7c00:	20 e0       	ldi	r18, 0x00	; 0
    7c02:	30 e0       	ldi	r19, 0x00	; 0
    7c04:	40 e2       	ldi	r20, 0x20	; 32
    7c06:	51 e4       	ldi	r21, 0x41	; 65
    7c08:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    7c0c:	dc 01       	movw	r26, r24
    7c0e:	cb 01       	movw	r24, r22
    7c10:	bc 01       	movw	r22, r24
    7c12:	cd 01       	movw	r24, r26
    7c14:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    7c18:	dc 01       	movw	r26, r24
    7c1a:	cb 01       	movw	r24, r22
    7c1c:	8d a3       	lds	r24, 0x5d
    7c1e:	9e a3       	lds	r25, 0x5e
    7c20:	12 c0       	rjmp	.+36     	; 0x7c46 <checkMote+0x2fe>
    7c22:	80 e2       	ldi	r24, 0x20	; 32
    7c24:	93 e0       	ldi	r25, 0x03	; 3
    7c26:	8f a3       	lds	r24, 0x5f
    7c28:	98 a7       	lds	r25, 0x78
    7c2a:	8f a1       	lds	r24, 0x4f
    7c2c:	98 a5       	lds	r25, 0x68
    7c2e:	8c 01       	movw	r16, r24
    7c30:	c8 01       	movw	r24, r16
    7c32:	01 97       	sbiw	r24, 0x01	; 1
    7c34:	f1 f7       	brne	.-4      	; 0x7c32 <checkMote+0x2ea>
    7c36:	8c 01       	movw	r16, r24
    7c38:	0f a3       	lds	r16, 0x5f
    7c3a:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7c3c:	8d a1       	lds	r24, 0x4d
    7c3e:	9e a1       	lds	r25, 0x4e
    7c40:	01 97       	sbiw	r24, 0x01	; 1
    7c42:	8d a3       	lds	r24, 0x5d
    7c44:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7c46:	8d a1       	lds	r24, 0x4d
    7c48:	9e a1       	lds	r25, 0x4e
    7c4a:	00 97       	sbiw	r24, 0x00	; 0
    7c4c:	51 f7       	brne	.-44     	; 0x7c22 <checkMote+0x2da>
    7c4e:	18 c0       	rjmp	.+48     	; 0x7c80 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7c50:	69 a1       	lds	r22, 0x49
    7c52:	7a a1       	lds	r23, 0x4a
    7c54:	8b a1       	lds	r24, 0x4b
    7c56:	9c a1       	lds	r25, 0x4c
    7c58:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    7c5c:	dc 01       	movw	r26, r24
    7c5e:	cb 01       	movw	r24, r22
    7c60:	8d a3       	lds	r24, 0x5d
    7c62:	9e a3       	lds	r25, 0x5e
    7c64:	8d a1       	lds	r24, 0x4d
    7c66:	9e a1       	lds	r25, 0x4e
    7c68:	89 a7       	lds	r24, 0x79
    7c6a:	9a a7       	lds	r25, 0x7a
    7c6c:	89 a5       	lds	r24, 0x69
    7c6e:	9a a5       	lds	r25, 0x6a
    7c70:	8c 01       	movw	r16, r24
    7c72:	c8 01       	movw	r24, r16
    7c74:	01 97       	sbiw	r24, 0x01	; 1
    7c76:	f1 f7       	brne	.-4      	; 0x7c74 <checkMote+0x32c>
    7c78:	8c 01       	movw	r16, r24
    7c7a:	09 a7       	lds	r16, 0x79
    7c7c:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7c7e:	f7 ce       	rjmp	.-530    	; 0x7a6e <checkMote+0x126>
    7c80:	f6 ce       	rjmp	.-532    	; 0x7a6e <checkMote+0x126>

00007c82 <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7c82:	cf 93       	push	r28
    7c84:	df 93       	push	r29
    7c86:	cd b7       	in	r28, 0x3d	; 61
    7c88:	de b7       	in	r29, 0x3e	; 62
    7c8a:	28 97       	sbiw	r28, 0x08	; 8
    7c8c:	cd bf       	out	0x3d, r28	; 61
    7c8e:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7c90:	19 82       	std	Y+1, r1	; 0x01
    7c92:	1a 82       	std	Y+2, r1	; 0x02
    7c94:	0c c0       	rjmp	.+24     	; 0x7cae <SD_write_and_read_knowns+0x2c>
    7c96:	29 81       	ldd	r18, Y+1	; 0x01
    7c98:	89 81       	ldd	r24, Y+1	; 0x01
    7c9a:	9a 81       	ldd	r25, Y+2	; 0x02
    7c9c:	80 54       	subi	r24, 0x40	; 64
    7c9e:	9c 4d       	sbci	r25, 0xDC	; 220
    7ca0:	fc 01       	movw	r30, r24
    7ca2:	20 83       	st	Z, r18
    7ca4:	89 81       	ldd	r24, Y+1	; 0x01
    7ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    7ca8:	01 96       	adiw	r24, 0x01	; 1
    7caa:	89 83       	std	Y+1, r24	; 0x01
    7cac:	9a 83       	std	Y+2, r25	; 0x02
    7cae:	89 81       	ldd	r24, Y+1	; 0x01
    7cb0:	9a 81       	ldd	r25, Y+2	; 0x02
    7cb2:	88 31       	cpi	r24, 0x18	; 24
    7cb4:	91 05       	cpc	r25, r1
    7cb6:	7c f3       	brlt	.-34     	; 0x7c96 <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7cb8:	20 ec       	ldi	r18, 0xC0	; 192
    7cba:	33 e2       	ldi	r19, 0x23	; 35
    7cbc:	64 e1       	ldi	r22, 0x14	; 20
    7cbe:	70 e0       	ldi	r23, 0x00	; 0
    7cc0:	80 e0       	ldi	r24, 0x00	; 0
    7cc2:	90 e0       	ldi	r25, 0x00	; 0
    7cc4:	a9 01       	movw	r20, r18
    7cc6:	28 e1       	ldi	r18, 0x18	; 24
    7cc8:	30 e0       	ldi	r19, 0x00	; 0
    7cca:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7cce:	1b 82       	std	Y+3, r1	; 0x03
    7cd0:	1c 82       	std	Y+4, r1	; 0x04
    7cd2:	0b c0       	rjmp	.+22     	; 0x7cea <SD_write_and_read_knowns+0x68>
    7cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    7cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    7cd8:	80 54       	subi	r24, 0x40	; 64
    7cda:	9c 4d       	sbci	r25, 0xDC	; 220
    7cdc:	fc 01       	movw	r30, r24
    7cde:	10 82       	st	Z, r1
    7ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    7ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    7ce4:	01 96       	adiw	r24, 0x01	; 1
    7ce6:	8b 83       	std	Y+3, r24	; 0x03
    7ce8:	9c 83       	std	Y+4, r25	; 0x04
    7cea:	8b 81       	ldd	r24, Y+3	; 0x03
    7cec:	9c 81       	ldd	r25, Y+4	; 0x04
    7cee:	88 31       	cpi	r24, 0x18	; 24
    7cf0:	91 05       	cpc	r25, r1
    7cf2:	84 f3       	brlt	.-32     	; 0x7cd4 <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7cf4:	20 ec       	ldi	r18, 0xC0	; 192
    7cf6:	33 e2       	ldi	r19, 0x23	; 35
    7cf8:	64 e1       	ldi	r22, 0x14	; 20
    7cfa:	70 e0       	ldi	r23, 0x00	; 0
    7cfc:	80 e0       	ldi	r24, 0x00	; 0
    7cfe:	90 e0       	ldi	r25, 0x00	; 0
    7d00:	a9 01       	movw	r20, r18
    7d02:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7d06:	1d 82       	std	Y+5, r1	; 0x05
    7d08:	1e 82       	std	Y+6, r1	; 0x06
    7d0a:	13 c0       	rjmp	.+38     	; 0x7d32 <SD_write_and_read_knowns+0xb0>
    7d0c:	8d 81       	ldd	r24, Y+5	; 0x05
    7d0e:	9e 81       	ldd	r25, Y+6	; 0x06
    7d10:	24 e6       	ldi	r18, 0x64	; 100
    7d12:	30 e0       	ldi	r19, 0x00	; 0
    7d14:	b9 01       	movw	r22, r18
    7d16:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    7d1a:	28 2f       	mov	r18, r24
    7d1c:	8d 81       	ldd	r24, Y+5	; 0x05
    7d1e:	9e 81       	ldd	r25, Y+6	; 0x06
    7d20:	80 54       	subi	r24, 0x40	; 64
    7d22:	9c 4d       	sbci	r25, 0xDC	; 220
    7d24:	fc 01       	movw	r30, r24
    7d26:	20 83       	st	Z, r18
    7d28:	8d 81       	ldd	r24, Y+5	; 0x05
    7d2a:	9e 81       	ldd	r25, Y+6	; 0x06
    7d2c:	01 96       	adiw	r24, 0x01	; 1
    7d2e:	8d 83       	std	Y+5, r24	; 0x05
    7d30:	9e 83       	std	Y+6, r25	; 0x06
    7d32:	8d 81       	ldd	r24, Y+5	; 0x05
    7d34:	9e 81       	ldd	r25, Y+6	; 0x06
    7d36:	f4 e0       	ldi	r31, 0x04	; 4
    7d38:	82 3e       	cpi	r24, 0xE2	; 226
    7d3a:	9f 07       	cpc	r25, r31
    7d3c:	3c f3       	brlt	.-50     	; 0x7d0c <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7d3e:	20 ec       	ldi	r18, 0xC0	; 192
    7d40:	33 e2       	ldi	r19, 0x23	; 35
    7d42:	60 e5       	ldi	r22, 0x50	; 80
    7d44:	70 e0       	ldi	r23, 0x00	; 0
    7d46:	80 e0       	ldi	r24, 0x00	; 0
    7d48:	90 e0       	ldi	r25, 0x00	; 0
    7d4a:	a9 01       	movw	r20, r18
    7d4c:	22 ee       	ldi	r18, 0xE2	; 226
    7d4e:	34 e0       	ldi	r19, 0x04	; 4
    7d50:	0e 94 ca 4e 	call	0x9d94	; 0x9d94 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7d54:	1f 82       	std	Y+7, r1	; 0x07
    7d56:	18 86       	std	Y+8, r1	; 0x08
    7d58:	0b c0       	rjmp	.+22     	; 0x7d70 <SD_write_and_read_knowns+0xee>
    7d5a:	8f 81       	ldd	r24, Y+7	; 0x07
    7d5c:	98 85       	ldd	r25, Y+8	; 0x08
    7d5e:	80 54       	subi	r24, 0x40	; 64
    7d60:	9c 4d       	sbci	r25, 0xDC	; 220
    7d62:	fc 01       	movw	r30, r24
    7d64:	10 82       	st	Z, r1
    7d66:	8f 81       	ldd	r24, Y+7	; 0x07
    7d68:	98 85       	ldd	r25, Y+8	; 0x08
    7d6a:	01 96       	adiw	r24, 0x01	; 1
    7d6c:	8f 83       	std	Y+7, r24	; 0x07
    7d6e:	98 87       	std	Y+8, r25	; 0x08
    7d70:	8f 81       	ldd	r24, Y+7	; 0x07
    7d72:	98 85       	ldd	r25, Y+8	; 0x08
    7d74:	f4 e0       	ldi	r31, 0x04	; 4
    7d76:	82 3e       	cpi	r24, 0xE2	; 226
    7d78:	9f 07       	cpc	r25, r31
    7d7a:	7c f3       	brlt	.-34     	; 0x7d5a <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7d7c:	20 ec       	ldi	r18, 0xC0	; 192
    7d7e:	33 e2       	ldi	r19, 0x23	; 35
    7d80:	60 e5       	ldi	r22, 0x50	; 80
    7d82:	70 e0       	ldi	r23, 0x00	; 0
    7d84:	80 e0       	ldi	r24, 0x00	; 0
    7d86:	90 e0       	ldi	r25, 0x00	; 0
    7d88:	a9 01       	movw	r20, r18
    7d8a:	23 e0       	ldi	r18, 0x03	; 3
    7d8c:	30 e0       	ldi	r19, 0x00	; 0
    7d8e:	0e 94 28 50 	call	0xa050	; 0xa050 <SD_read_multiple_blocks>
}
    7d92:	28 96       	adiw	r28, 0x08	; 8
    7d94:	cd bf       	out	0x3d, r28	; 61
    7d96:	de bf       	out	0x3e, r29	; 62
    7d98:	df 91       	pop	r29
    7d9a:	cf 91       	pop	r28
    7d9c:	08 95       	ret

00007d9e <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7d9e:	cf 93       	push	r28
    7da0:	df 93       	push	r29
    7da2:	00 d0       	rcall	.+0      	; 0x7da4 <SD_write_and_read_knowns_FAT+0x6>
    7da4:	0f 92       	push	r0
    7da6:	cd b7       	in	r28, 0x3d	; 61
    7da8:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7daa:	19 82       	std	Y+1, r1	; 0x01
    7dac:	1a 82       	std	Y+2, r1	; 0x02
    7dae:	0c c0       	rjmp	.+24     	; 0x7dc8 <SD_write_and_read_knowns_FAT+0x2a>
    7db0:	29 81       	ldd	r18, Y+1	; 0x01
    7db2:	89 81       	ldd	r24, Y+1	; 0x01
    7db4:	9a 81       	ldd	r25, Y+2	; 0x02
    7db6:	80 54       	subi	r24, 0x40	; 64
    7db8:	9c 4d       	sbci	r25, 0xDC	; 220
    7dba:	fc 01       	movw	r30, r24
    7dbc:	20 83       	st	Z, r18
    7dbe:	89 81       	ldd	r24, Y+1	; 0x01
    7dc0:	9a 81       	ldd	r25, Y+2	; 0x02
    7dc2:	01 96       	adiw	r24, 0x01	; 1
    7dc4:	89 83       	std	Y+1, r24	; 0x01
    7dc6:	9a 83       	std	Y+2, r25	; 0x02
    7dc8:	89 81       	ldd	r24, Y+1	; 0x01
    7dca:	9a 81       	ldd	r25, Y+2	; 0x02
    7dcc:	88 31       	cpi	r24, 0x18	; 24
    7dce:	91 05       	cpc	r25, r1
    7dd0:	7c f3       	brlt	.-34     	; 0x7db0 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing");
    7dd2:	88 e0       	ldi	r24, 0x08	; 8
    7dd4:	90 e2       	ldi	r25, 0x20	; 32
    7dd6:	0e 94 e1 45 	call	0x8bc2	; 0x8bc2 <writeFile>
    7dda:	80 93 7d 50 	sts	0x507D, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7dde:	1b 82       	std	Y+3, r1	; 0x03
    7de0:	1c 82       	std	Y+4, r1	; 0x04
    7de2:	0b c0       	rjmp	.+22     	; 0x7dfa <SD_write_and_read_knowns_FAT+0x5c>
    7de4:	8b 81       	ldd	r24, Y+3	; 0x03
    7de6:	9c 81       	ldd	r25, Y+4	; 0x04
    7de8:	80 54       	subi	r24, 0x40	; 64
    7dea:	9c 4d       	sbci	r25, 0xDC	; 220
    7dec:	fc 01       	movw	r30, r24
    7dee:	10 82       	st	Z, r1
    7df0:	8b 81       	ldd	r24, Y+3	; 0x03
    7df2:	9c 81       	ldd	r25, Y+4	; 0x04
    7df4:	01 96       	adiw	r24, 0x01	; 1
    7df6:	8b 83       	std	Y+3, r24	; 0x03
    7df8:	9c 83       	std	Y+4, r25	; 0x04
    7dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    7dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    7dfe:	88 31       	cpi	r24, 0x18	; 24
    7e00:	91 05       	cpc	r25, r1
    7e02:	84 f3       	brlt	.-32     	; 0x7de4 <SD_write_and_read_knowns_FAT+0x46>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    7e04:	28 e0       	ldi	r18, 0x08	; 8
    7e06:	30 e2       	ldi	r19, 0x20	; 32
    7e08:	80 e0       	ldi	r24, 0x00	; 0
    7e0a:	b9 01       	movw	r22, r18
    7e0c:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <readFile>
    7e10:	80 93 7d 50 	sts	0x507D, r24
}
    7e14:	24 96       	adiw	r28, 0x04	; 4
    7e16:	cd bf       	out	0x3d, r28	; 61
    7e18:	de bf       	out	0x3e, r29	; 62
    7e1a:	df 91       	pop	r29
    7e1c:	cf 91       	pop	r28
    7e1e:	08 95       	ret

00007e20 <chibi_test_radio>:
	//WriteRadioRegister(RADIOCTRLRGSTR, RX_ON);
	//sei();
}
*/
//function for testing radio transmission
void chibi_test_radio(){
    7e20:	cf 93       	push	r28
    7e22:	df 93       	push	r29
    7e24:	cd b7       	in	r28, 0x3d	; 61
    7e26:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7e28:	0e 94 e0 1e 	call	0x3dc0	; 0x3dc0 <chb_init>
	chb_set_short_addr(0x0002);
    7e2c:	82 e0       	ldi	r24, 0x02	; 2
    7e2e:	90 e0       	ldi	r25, 0x00	; 0
    7e30:	0e 94 3e 2c 	call	0x587c	; 0x587c <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7e34:	00 00       	nop
    7e36:	fe cf       	rjmp	.-4      	; 0x7e34 <chibi_test_radio+0x14>

00007e38 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    7e38:	cf 93       	push	r28
    7e3a:	df 93       	push	r29
    7e3c:	0f 92       	push	r0
    7e3e:	0f 92       	push	r0
    7e40:	cd b7       	in	r28, 0x3d	; 61
    7e42:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    7e44:	0e 94 df 4a 	call	0x95be	; 0x95be <SD_init>
	getBootSectorData();
    7e48:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7e4c:	19 82       	std	Y+1, r1	; 0x01
    7e4e:	1a 82       	std	Y+2, r1	; 0x02
    7e50:	13 c0       	rjmp	.+38     	; 0x7e78 <TestCard+0x40>
    7e52:	89 81       	ldd	r24, Y+1	; 0x01
    7e54:	9a 81       	ldd	r25, Y+2	; 0x02
    7e56:	29 e7       	ldi	r18, 0x79	; 121
    7e58:	30 e0       	ldi	r19, 0x00	; 0
    7e5a:	b9 01       	movw	r22, r18
    7e5c:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    7e60:	28 2f       	mov	r18, r24
    7e62:	89 81       	ldd	r24, Y+1	; 0x01
    7e64:	9a 81       	ldd	r25, Y+2	; 0x02
    7e66:	80 54       	subi	r24, 0x40	; 64
    7e68:	9c 4d       	sbci	r25, 0xDC	; 220
    7e6a:	fc 01       	movw	r30, r24
    7e6c:	20 83       	st	Z, r18
    7e6e:	89 81       	ldd	r24, Y+1	; 0x01
    7e70:	9a 81       	ldd	r25, Y+2	; 0x02
    7e72:	01 96       	adiw	r24, 0x01	; 1
    7e74:	89 83       	std	Y+1, r24	; 0x01
    7e76:	9a 83       	std	Y+2, r25	; 0x02
    7e78:	89 81       	ldd	r24, Y+1	; 0x01
    7e7a:	9a 81       	ldd	r25, Y+2	; 0x02
    7e7c:	f2 e0       	ldi	r31, 0x02	; 2
    7e7e:	80 30       	cpi	r24, 0x00	; 0
    7e80:	9f 07       	cpc	r25, r31
    7e82:	3c f3       	brlt	.-50     	; 0x7e52 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing");//}
    7e84:	88 e0       	ldi	r24, 0x08	; 8
    7e86:	90 e2       	ldi	r25, 0x20	; 32
    7e88:	0e 94 e1 45 	call	0x8bc2	; 0x8bc2 <writeFile>
	nop();
    7e8c:	00 00       	nop
    7e8e:	0f 90       	pop	r0
    7e90:	0f 90       	pop	r0
    7e92:	df 91       	pop	r29
    7e94:	cf 91       	pop	r28
    7e96:	08 95       	ret

00007e98 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    7e98:	ef 92       	push	r14
    7e9a:	ff 92       	push	r15
    7e9c:	0f 93       	push	r16
    7e9e:	1f 93       	push	r17
    7ea0:	cf 93       	push	r28
    7ea2:	df 93       	push	r29
    7ea4:	cd b7       	in	r28, 0x3d	; 61
    7ea6:	de b7       	in	r29, 0x3e	; 62
    7ea8:	2a 97       	sbiw	r28, 0x0a	; 10
    7eaa:	cd bf       	out	0x3d, r28	; 61
    7eac:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    7eae:	10 92 57 50 	sts	0x5057, r1
    7eb2:	10 92 58 50 	sts	0x5058, r1
    7eb6:	10 92 59 50 	sts	0x5059, r1
    7eba:	10 92 5a 50 	sts	0x505A, r1

SD_read_block(0,SDBuffer);
    7ebe:	27 eb       	ldi	r18, 0xB7	; 183
    7ec0:	31 e2       	ldi	r19, 0x21	; 33
    7ec2:	60 e0       	ldi	r22, 0x00	; 0
    7ec4:	70 e0       	ldi	r23, 0x00	; 0
    7ec6:	cb 01       	movw	r24, r22
    7ec8:	a9 01       	movw	r20, r18
    7eca:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    7ece:	87 eb       	ldi	r24, 0xB7	; 183
    7ed0:	91 e2       	ldi	r25, 0x21	; 33
    7ed2:	89 83       	std	Y+1, r24	; 0x01
    7ed4:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    7ed6:	89 81       	ldd	r24, Y+1	; 0x01
    7ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    7eda:	fc 01       	movw	r30, r24
    7edc:	80 81       	ld	r24, Z
    7ede:	89 3e       	cpi	r24, 0xE9	; 233
    7ee0:	09 f4       	brne	.+2      	; 0x7ee4 <getBootSectorData+0x4c>
    7ee2:	4d c0       	rjmp	.+154    	; 0x7f7e <getBootSectorData+0xe6>
    7ee4:	89 81       	ldd	r24, Y+1	; 0x01
    7ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    7ee8:	fc 01       	movw	r30, r24
    7eea:	80 81       	ld	r24, Z
    7eec:	8b 3e       	cpi	r24, 0xEB	; 235
    7eee:	09 f4       	brne	.+2      	; 0x7ef2 <getBootSectorData+0x5a>
    7ef0:	46 c0       	rjmp	.+140    	; 0x7f7e <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    7ef2:	87 eb       	ldi	r24, 0xB7	; 183
    7ef4:	91 e2       	ldi	r25, 0x21	; 33
    7ef6:	8b 83       	std	Y+3, r24	; 0x03
    7ef8:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    7efa:	8b 81       	ldd	r24, Y+3	; 0x03
    7efc:	9c 81       	ldd	r25, Y+4	; 0x04
    7efe:	82 50       	subi	r24, 0x02	; 2
    7f00:	9e 4f       	sbci	r25, 0xFE	; 254
    7f02:	fc 01       	movw	r30, r24
    7f04:	80 81       	ld	r24, Z
    7f06:	91 81       	ldd	r25, Z+1	; 0x01
    7f08:	fa ea       	ldi	r31, 0xAA	; 170
    7f0a:	85 35       	cpi	r24, 0x55	; 85
    7f0c:	9f 07       	cpc	r25, r31
    7f0e:	11 f0       	breq	.+4      	; 0x7f14 <getBootSectorData+0x7c>
    7f10:	81 e0       	ldi	r24, 0x01	; 1
    7f12:	01 c1       	rjmp	.+514    	; 0x8116 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    7f14:	8b 81       	ldd	r24, Y+3	; 0x03
    7f16:	9c 81       	ldd	r25, Y+4	; 0x04
    7f18:	82 54       	subi	r24, 0x42	; 66
    7f1a:	9e 4f       	sbci	r25, 0xFE	; 254
    7f1c:	8d 83       	std	Y+5, r24	; 0x05
    7f1e:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    7f20:	8d 81       	ldd	r24, Y+5	; 0x05
    7f22:	9e 81       	ldd	r25, Y+6	; 0x06
    7f24:	fc 01       	movw	r30, r24
    7f26:	80 85       	ldd	r24, Z+8	; 0x08
    7f28:	91 85       	ldd	r25, Z+9	; 0x09
    7f2a:	a2 85       	ldd	r26, Z+10	; 0x0a
    7f2c:	b3 85       	ldd	r27, Z+11	; 0x0b
    7f2e:	80 93 57 50 	sts	0x5057, r24
    7f32:	90 93 58 50 	sts	0x5058, r25
    7f36:	a0 93 59 50 	sts	0x5059, r26
    7f3a:	b0 93 5a 50 	sts	0x505A, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    7f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    7f40:	9e 81       	ldd	r25, Y+6	; 0x06
    7f42:	fc 01       	movw	r30, r24
    7f44:	80 85       	ldd	r24, Z+8	; 0x08
    7f46:	91 85       	ldd	r25, Z+9	; 0x09
    7f48:	a2 85       	ldd	r26, Z+10	; 0x0a
    7f4a:	b3 85       	ldd	r27, Z+11	; 0x0b
    7f4c:	27 eb       	ldi	r18, 0xB7	; 183
    7f4e:	31 e2       	ldi	r19, 0x21	; 33
    7f50:	bc 01       	movw	r22, r24
    7f52:	cd 01       	movw	r24, r26
    7f54:	a9 01       	movw	r20, r18
    7f56:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    7f5a:	87 eb       	ldi	r24, 0xB7	; 183
    7f5c:	91 e2       	ldi	r25, 0x21	; 33
    7f5e:	89 83       	std	Y+1, r24	; 0x01
    7f60:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    7f62:	89 81       	ldd	r24, Y+1	; 0x01
    7f64:	9a 81       	ldd	r25, Y+2	; 0x02
    7f66:	fc 01       	movw	r30, r24
    7f68:	80 81       	ld	r24, Z
    7f6a:	89 3e       	cpi	r24, 0xE9	; 233
    7f6c:	41 f0       	breq	.+16     	; 0x7f7e <getBootSectorData+0xe6>
    7f6e:	89 81       	ldd	r24, Y+1	; 0x01
    7f70:	9a 81       	ldd	r25, Y+2	; 0x02
    7f72:	fc 01       	movw	r30, r24
    7f74:	80 81       	ld	r24, Z
    7f76:	8b 3e       	cpi	r24, 0xEB	; 235
    7f78:	11 f0       	breq	.+4      	; 0x7f7e <getBootSectorData+0xe6>
    7f7a:	81 e0       	ldi	r24, 0x01	; 1
    7f7c:	cc c0       	rjmp	.+408    	; 0x8116 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    7f7e:	89 81       	ldd	r24, Y+1	; 0x01
    7f80:	9a 81       	ldd	r25, Y+2	; 0x02
    7f82:	fc 01       	movw	r30, r24
    7f84:	83 85       	ldd	r24, Z+11	; 0x0b
    7f86:	94 85       	ldd	r25, Z+12	; 0x0c
    7f88:	80 93 35 40 	sts	0x4035, r24
    7f8c:	90 93 36 40 	sts	0x4036, r25
sectorPerCluster = bpb->sectorPerCluster;
    7f90:	89 81       	ldd	r24, Y+1	; 0x01
    7f92:	9a 81       	ldd	r25, Y+2	; 0x02
    7f94:	fc 01       	movw	r30, r24
    7f96:	85 85       	ldd	r24, Z+13	; 0x0d
    7f98:	88 2f       	mov	r24, r24
    7f9a:	90 e0       	ldi	r25, 0x00	; 0
    7f9c:	80 93 55 50 	sts	0x5055, r24
    7fa0:	90 93 56 50 	sts	0x5056, r25
reservedSectorCount = bpb->reservedSectorCount;
    7fa4:	89 81       	ldd	r24, Y+1	; 0x01
    7fa6:	9a 81       	ldd	r25, Y+2	; 0x02
    7fa8:	fc 01       	movw	r30, r24
    7faa:	86 85       	ldd	r24, Z+14	; 0x0e
    7fac:	97 85       	ldd	r25, Z+15	; 0x0f
    7fae:	80 93 5d 50 	sts	0x505D, r24
    7fb2:	90 93 5e 50 	sts	0x505E, r25
rootCluster = bpb->rootCluster;
    7fb6:	89 81       	ldd	r24, Y+1	; 0x01
    7fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    7fba:	fc 01       	movw	r30, r24
    7fbc:	84 a5       	lds	r24, 0x64
    7fbe:	95 a5       	lds	r25, 0x65
    7fc0:	a6 a5       	lds	r26, 0x66
    7fc2:	b7 a5       	lds	r27, 0x67
    7fc4:	80 93 3f 40 	sts	0x403F, r24
    7fc8:	90 93 40 40 	sts	0x4040, r25
    7fcc:	a0 93 41 40 	sts	0x4041, r26
    7fd0:	b0 93 42 40 	sts	0x4042, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    7fd4:	89 81       	ldd	r24, Y+1	; 0x01
    7fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    7fd8:	fc 01       	movw	r30, r24
    7fda:	24 8d       	ldd	r18, Z+28	; 0x1c
    7fdc:	35 8d       	ldd	r19, Z+29	; 0x1d
    7fde:	46 8d       	ldd	r20, Z+30	; 0x1e
    7fe0:	57 8d       	ldd	r21, Z+31	; 0x1f
    7fe2:	80 91 5d 50 	lds	r24, 0x505D
    7fe6:	90 91 5e 50 	lds	r25, 0x505E
    7fea:	cc 01       	movw	r24, r24
    7fec:	a0 e0       	ldi	r26, 0x00	; 0
    7fee:	b0 e0       	ldi	r27, 0x00	; 0
    7ff0:	79 01       	movw	r14, r18
    7ff2:	8a 01       	movw	r16, r20
    7ff4:	e8 0e       	add	r14, r24
    7ff6:	f9 1e       	adc	r15, r25
    7ff8:	0a 1f       	adc	r16, r26
    7ffa:	1b 1f       	adc	r17, r27
    7ffc:	89 81       	ldd	r24, Y+1	; 0x01
    7ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    8000:	fc 01       	movw	r30, r24
    8002:	80 89       	ldd	r24, Z+16	; 0x10
    8004:	88 2f       	mov	r24, r24
    8006:	90 e0       	ldi	r25, 0x00	; 0
    8008:	a0 e0       	ldi	r26, 0x00	; 0
    800a:	b0 e0       	ldi	r27, 0x00	; 0
    800c:	29 81       	ldd	r18, Y+1	; 0x01
    800e:	3a 81       	ldd	r19, Y+2	; 0x02
    8010:	f9 01       	movw	r30, r18
    8012:	24 a1       	lds	r18, 0x44
    8014:	35 a1       	lds	r19, 0x45
    8016:	46 a1       	lds	r20, 0x46
    8018:	57 a1       	lds	r21, 0x47
    801a:	bc 01       	movw	r22, r24
    801c:	cd 01       	movw	r24, r26
    801e:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    8022:	dc 01       	movw	r26, r24
    8024:	cb 01       	movw	r24, r22
    8026:	8e 0d       	add	r24, r14
    8028:	9f 1d       	adc	r25, r15
    802a:	a0 1f       	adc	r26, r16
    802c:	b1 1f       	adc	r27, r17
    802e:	80 93 bc 23 	sts	0x23BC, r24
    8032:	90 93 bd 23 	sts	0x23BD, r25
    8036:	a0 93 be 23 	sts	0x23BE, r26
    803a:	b0 93 bf 23 	sts	0x23BF, r27

dataSectors = bpb->totalSectors_F32
    803e:	89 81       	ldd	r24, Y+1	; 0x01
    8040:	9a 81       	ldd	r25, Y+2	; 0x02
    8042:	fc 01       	movw	r30, r24
    8044:	20 a1       	lds	r18, 0x40
    8046:	31 a1       	lds	r19, 0x41
    8048:	42 a1       	lds	r20, 0x42
    804a:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    804c:	89 81       	ldd	r24, Y+1	; 0x01
    804e:	9a 81       	ldd	r25, Y+2	; 0x02
    8050:	fc 01       	movw	r30, r24
    8052:	86 85       	ldd	r24, Z+14	; 0x0e
    8054:	97 85       	ldd	r25, Z+15	; 0x0f
    8056:	cc 01       	movw	r24, r24
    8058:	a0 e0       	ldi	r26, 0x00	; 0
    805a:	b0 e0       	ldi	r27, 0x00	; 0
    805c:	79 01       	movw	r14, r18
    805e:	8a 01       	movw	r16, r20
    8060:	e8 1a       	sub	r14, r24
    8062:	f9 0a       	sbc	r15, r25
    8064:	0a 0b       	sbc	r16, r26
    8066:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    8068:	89 81       	ldd	r24, Y+1	; 0x01
    806a:	9a 81       	ldd	r25, Y+2	; 0x02
    806c:	fc 01       	movw	r30, r24
    806e:	80 89       	ldd	r24, Z+16	; 0x10
    8070:	88 2f       	mov	r24, r24
    8072:	90 e0       	ldi	r25, 0x00	; 0
    8074:	a0 e0       	ldi	r26, 0x00	; 0
    8076:	b0 e0       	ldi	r27, 0x00	; 0
    8078:	29 81       	ldd	r18, Y+1	; 0x01
    807a:	3a 81       	ldd	r19, Y+2	; 0x02
    807c:	f9 01       	movw	r30, r18
    807e:	24 a1       	lds	r18, 0x44
    8080:	35 a1       	lds	r19, 0x45
    8082:	46 a1       	lds	r20, 0x46
    8084:	57 a1       	lds	r21, 0x47
    8086:	bc 01       	movw	r22, r24
    8088:	cd 01       	movw	r24, r26
    808a:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    808e:	dc 01       	movw	r26, r24
    8090:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    8092:	a8 01       	movw	r20, r16
    8094:	97 01       	movw	r18, r14
    8096:	28 1b       	sub	r18, r24
    8098:	39 0b       	sbc	r19, r25
    809a:	4a 0b       	sbc	r20, r26
    809c:	5b 0b       	sbc	r21, r27
    809e:	da 01       	movw	r26, r20
    80a0:	c9 01       	movw	r24, r18
    80a2:	8f 83       	std	Y+7, r24	; 0x07
    80a4:	98 87       	std	Y+8, r25	; 0x08
    80a6:	a9 87       	std	Y+9, r26	; 0x09
    80a8:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    80aa:	80 91 55 50 	lds	r24, 0x5055
    80ae:	90 91 56 50 	lds	r25, 0x5056
    80b2:	9c 01       	movw	r18, r24
    80b4:	40 e0       	ldi	r20, 0x00	; 0
    80b6:	50 e0       	ldi	r21, 0x00	; 0
    80b8:	8f 81       	ldd	r24, Y+7	; 0x07
    80ba:	98 85       	ldd	r25, Y+8	; 0x08
    80bc:	a9 85       	ldd	r26, Y+9	; 0x09
    80be:	ba 85       	ldd	r27, Y+10	; 0x0a
    80c0:	bc 01       	movw	r22, r24
    80c2:	cd 01       	movw	r24, r26
    80c4:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    80c8:	da 01       	movw	r26, r20
    80ca:	c9 01       	movw	r24, r18
    80cc:	80 93 3a 40 	sts	0x403A, r24
    80d0:	90 93 3b 40 	sts	0x403B, r25
    80d4:	a0 93 3c 40 	sts	0x403C, r26
    80d8:	b0 93 3d 40 	sts	0x403D, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    80dc:	81 e0       	ldi	r24, 0x01	; 1
    80de:	60 e0       	ldi	r22, 0x00	; 0
    80e0:	20 e0       	ldi	r18, 0x00	; 0
    80e2:	30 e0       	ldi	r19, 0x00	; 0
    80e4:	a9 01       	movw	r20, r18
    80e6:	0e 94 71 41 	call	0x82e2	; 0x82e2 <getSetFreeCluster>
    80ea:	9b 01       	movw	r18, r22
    80ec:	ac 01       	movw	r20, r24
    80ee:	80 91 3a 40 	lds	r24, 0x403A
    80f2:	90 91 3b 40 	lds	r25, 0x403B
    80f6:	a0 91 3c 40 	lds	r26, 0x403C
    80fa:	b0 91 3d 40 	lds	r27, 0x403D
    80fe:	82 17       	cp	r24, r18
    8100:	93 07       	cpc	r25, r19
    8102:	a4 07       	cpc	r26, r20
    8104:	b5 07       	cpc	r27, r21
    8106:	18 f4       	brcc	.+6      	; 0x810e <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    8108:	10 92 b8 50 	sts	0x50B8, r1
    810c:	03 c0       	rjmp	.+6      	; 0x8114 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    810e:	81 e0       	ldi	r24, 0x01	; 1
    8110:	80 93 b8 50 	sts	0x50B8, r24
return 0;
    8114:	80 e0       	ldi	r24, 0x00	; 0
}
    8116:	2a 96       	adiw	r28, 0x0a	; 10
    8118:	cd bf       	out	0x3d, r28	; 61
    811a:	de bf       	out	0x3e, r29	; 62
    811c:	df 91       	pop	r29
    811e:	cf 91       	pop	r28
    8120:	1f 91       	pop	r17
    8122:	0f 91       	pop	r16
    8124:	ff 90       	pop	r15
    8126:	ef 90       	pop	r14
    8128:	08 95       	ret

0000812a <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    812a:	cf 93       	push	r28
    812c:	df 93       	push	r29
    812e:	00 d0       	rcall	.+0      	; 0x8130 <getFirstSector+0x6>
    8130:	0f 92       	push	r0
    8132:	cd b7       	in	r28, 0x3d	; 61
    8134:	de b7       	in	r29, 0x3e	; 62
    8136:	69 83       	std	Y+1, r22	; 0x01
    8138:	7a 83       	std	Y+2, r23	; 0x02
    813a:	8b 83       	std	Y+3, r24	; 0x03
    813c:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    813e:	89 81       	ldd	r24, Y+1	; 0x01
    8140:	9a 81       	ldd	r25, Y+2	; 0x02
    8142:	ab 81       	ldd	r26, Y+3	; 0x03
    8144:	bc 81       	ldd	r27, Y+4	; 0x04
    8146:	02 97       	sbiw	r24, 0x02	; 2
    8148:	a1 09       	sbc	r26, r1
    814a:	b1 09       	sbc	r27, r1
    814c:	20 91 55 50 	lds	r18, 0x5055
    8150:	30 91 56 50 	lds	r19, 0x5056
    8154:	99 01       	movw	r18, r18
    8156:	40 e0       	ldi	r20, 0x00	; 0
    8158:	50 e0       	ldi	r21, 0x00	; 0
    815a:	bc 01       	movw	r22, r24
    815c:	cd 01       	movw	r24, r26
    815e:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    8162:	9b 01       	movw	r18, r22
    8164:	ac 01       	movw	r20, r24
    8166:	80 91 bc 23 	lds	r24, 0x23BC
    816a:	90 91 bd 23 	lds	r25, 0x23BD
    816e:	a0 91 be 23 	lds	r26, 0x23BE
    8172:	b0 91 bf 23 	lds	r27, 0x23BF
    8176:	82 0f       	add	r24, r18
    8178:	93 1f       	adc	r25, r19
    817a:	a4 1f       	adc	r26, r20
    817c:	b5 1f       	adc	r27, r21
}
    817e:	bc 01       	movw	r22, r24
    8180:	cd 01       	movw	r24, r26
    8182:	24 96       	adiw	r28, 0x04	; 4
    8184:	cd bf       	out	0x3d, r28	; 61
    8186:	de bf       	out	0x3e, r29	; 62
    8188:	df 91       	pop	r29
    818a:	cf 91       	pop	r28
    818c:	08 95       	ret

0000818e <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    818e:	ef 92       	push	r14
    8190:	ff 92       	push	r15
    8192:	0f 93       	push	r16
    8194:	1f 93       	push	r17
    8196:	cf 93       	push	r28
    8198:	df 93       	push	r29
    819a:	cd b7       	in	r28, 0x3d	; 61
    819c:	de b7       	in	r29, 0x3e	; 62
    819e:	62 97       	sbiw	r28, 0x12	; 18
    81a0:	cd bf       	out	0x3d, r28	; 61
    81a2:	de bf       	out	0x3e, r29	; 62
    81a4:	6a 87       	std	Y+10, r22	; 0x0a
    81a6:	7b 87       	std	Y+11, r23	; 0x0b
    81a8:	8c 87       	std	Y+12, r24	; 0x0c
    81aa:	9d 87       	std	Y+13, r25	; 0x0d
    81ac:	4e 87       	std	Y+14, r20	; 0x0e
    81ae:	0f 87       	std	Y+15, r16	; 0x0f
    81b0:	18 8b       	std	Y+16, r17	; 0x10
    81b2:	29 8b       	std	Y+17, r18	; 0x11
    81b4:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    81b6:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    81b8:	80 91 5d 50 	lds	r24, 0x505D
    81bc:	90 91 5e 50 	lds	r25, 0x505E
    81c0:	9c 01       	movw	r18, r24
    81c2:	40 e0       	ldi	r20, 0x00	; 0
    81c4:	50 e0       	ldi	r21, 0x00	; 0
    81c6:	80 91 57 50 	lds	r24, 0x5057
    81ca:	90 91 58 50 	lds	r25, 0x5058
    81ce:	a0 91 59 50 	lds	r26, 0x5059
    81d2:	b0 91 5a 50 	lds	r27, 0x505A
    81d6:	79 01       	movw	r14, r18
    81d8:	8a 01       	movw	r16, r20
    81da:	e8 0e       	add	r14, r24
    81dc:	f9 1e       	adc	r15, r25
    81de:	0a 1f       	adc	r16, r26
    81e0:	1b 1f       	adc	r17, r27
    81e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    81e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    81e6:	ac 85       	ldd	r26, Y+12	; 0x0c
    81e8:	bd 85       	ldd	r27, Y+13	; 0x0d
    81ea:	88 0f       	add	r24, r24
    81ec:	99 1f       	adc	r25, r25
    81ee:	aa 1f       	adc	r26, r26
    81f0:	bb 1f       	adc	r27, r27
    81f2:	88 0f       	add	r24, r24
    81f4:	99 1f       	adc	r25, r25
    81f6:	aa 1f       	adc	r26, r26
    81f8:	bb 1f       	adc	r27, r27
    81fa:	20 91 35 40 	lds	r18, 0x4035
    81fe:	30 91 36 40 	lds	r19, 0x4036
    8202:	99 01       	movw	r18, r18
    8204:	40 e0       	ldi	r20, 0x00	; 0
    8206:	50 e0       	ldi	r21, 0x00	; 0
    8208:	bc 01       	movw	r22, r24
    820a:	cd 01       	movw	r24, r26
    820c:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    8210:	da 01       	movw	r26, r20
    8212:	c9 01       	movw	r24, r18
    8214:	8e 0d       	add	r24, r14
    8216:	9f 1d       	adc	r25, r15
    8218:	a0 1f       	adc	r26, r16
    821a:	b1 1f       	adc	r27, r17
    821c:	8a 83       	std	Y+2, r24	; 0x02
    821e:	9b 83       	std	Y+3, r25	; 0x03
    8220:	ac 83       	std	Y+4, r26	; 0x04
    8222:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    8224:	8a 85       	ldd	r24, Y+10	; 0x0a
    8226:	9b 85       	ldd	r25, Y+11	; 0x0b
    8228:	ac 85       	ldd	r26, Y+12	; 0x0c
    822a:	bd 85       	ldd	r27, Y+13	; 0x0d
    822c:	88 0f       	add	r24, r24
    822e:	99 1f       	adc	r25, r25
    8230:	aa 1f       	adc	r26, r26
    8232:	bb 1f       	adc	r27, r27
    8234:	88 0f       	add	r24, r24
    8236:	99 1f       	adc	r25, r25
    8238:	aa 1f       	adc	r26, r26
    823a:	bb 1f       	adc	r27, r27
    823c:	20 91 35 40 	lds	r18, 0x4035
    8240:	30 91 36 40 	lds	r19, 0x4036
    8244:	99 01       	movw	r18, r18
    8246:	40 e0       	ldi	r20, 0x00	; 0
    8248:	50 e0       	ldi	r21, 0x00	; 0
    824a:	bc 01       	movw	r22, r24
    824c:	cd 01       	movw	r24, r26
    824e:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    8252:	dc 01       	movw	r26, r24
    8254:	cb 01       	movw	r24, r22
    8256:	8e 83       	std	Y+6, r24	; 0x06
    8258:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    825a:	8a 81       	ldd	r24, Y+2	; 0x02
    825c:	9b 81       	ldd	r25, Y+3	; 0x03
    825e:	ac 81       	ldd	r26, Y+4	; 0x04
    8260:	bd 81       	ldd	r27, Y+5	; 0x05
    8262:	27 eb       	ldi	r18, 0xB7	; 183
    8264:	31 e2       	ldi	r19, 0x21	; 33
    8266:	bc 01       	movw	r22, r24
    8268:	cd 01       	movw	r24, r26
    826a:	a9 01       	movw	r20, r18
    826c:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    8270:	8e 81       	ldd	r24, Y+6	; 0x06
    8272:	9f 81       	ldd	r25, Y+7	; 0x07
    8274:	89 54       	subi	r24, 0x49	; 73
    8276:	9e 4d       	sbci	r25, 0xDE	; 222
    8278:	88 87       	std	Y+8, r24	; 0x08
    827a:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    827c:	8e 85       	ldd	r24, Y+14	; 0x0e
    827e:	88 23       	and	r24, r24
    8280:	49 f4       	brne	.+18     	; 0x8294 <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    8282:	88 85       	ldd	r24, Y+8	; 0x08
    8284:	99 85       	ldd	r25, Y+9	; 0x09
    8286:	fc 01       	movw	r30, r24
    8288:	80 81       	ld	r24, Z
    828a:	91 81       	ldd	r25, Z+1	; 0x01
    828c:	a2 81       	ldd	r26, Z+2	; 0x02
    828e:	b3 81       	ldd	r27, Z+3	; 0x03
    8290:	bf 70       	andi	r27, 0x0F	; 15
    8292:	1b c0       	rjmp	.+54     	; 0x82ca <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    8294:	28 85       	ldd	r18, Y+8	; 0x08
    8296:	39 85       	ldd	r19, Y+9	; 0x09
    8298:	8f 85       	ldd	r24, Y+15	; 0x0f
    829a:	98 89       	ldd	r25, Y+16	; 0x10
    829c:	a9 89       	ldd	r26, Y+17	; 0x11
    829e:	ba 89       	ldd	r27, Y+18	; 0x12
    82a0:	f9 01       	movw	r30, r18
    82a2:	80 83       	st	Z, r24
    82a4:	91 83       	std	Z+1, r25	; 0x01
    82a6:	a2 83       	std	Z+2, r26	; 0x02
    82a8:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    82aa:	8a 81       	ldd	r24, Y+2	; 0x02
    82ac:	9b 81       	ldd	r25, Y+3	; 0x03
    82ae:	ac 81       	ldd	r26, Y+4	; 0x04
    82b0:	bd 81       	ldd	r27, Y+5	; 0x05
    82b2:	27 eb       	ldi	r18, 0xB7	; 183
    82b4:	31 e2       	ldi	r19, 0x21	; 33
    82b6:	bc 01       	movw	r22, r24
    82b8:	cd 01       	movw	r24, r26
    82ba:	a9 01       	movw	r20, r18
    82bc:	20 e0       	ldi	r18, 0x00	; 0
    82be:	32 e0       	ldi	r19, 0x02	; 2
    82c0:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_write_block>

return (0);
    82c4:	80 e0       	ldi	r24, 0x00	; 0
    82c6:	90 e0       	ldi	r25, 0x00	; 0
    82c8:	dc 01       	movw	r26, r24
}
    82ca:	bc 01       	movw	r22, r24
    82cc:	cd 01       	movw	r24, r26
    82ce:	62 96       	adiw	r28, 0x12	; 18
    82d0:	cd bf       	out	0x3d, r28	; 61
    82d2:	de bf       	out	0x3e, r29	; 62
    82d4:	df 91       	pop	r29
    82d6:	cf 91       	pop	r28
    82d8:	1f 91       	pop	r17
    82da:	0f 91       	pop	r16
    82dc:	ff 90       	pop	r15
    82de:	ef 90       	pop	r14
    82e0:	08 95       	ret

000082e2 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    82e2:	cf 93       	push	r28
    82e4:	df 93       	push	r29
    82e6:	cd b7       	in	r28, 0x3d	; 61
    82e8:	de b7       	in	r29, 0x3e	; 62
    82ea:	28 97       	sbiw	r28, 0x08	; 8
    82ec:	cd bf       	out	0x3d, r28	; 61
    82ee:	de bf       	out	0x3e, r29	; 62
    82f0:	8b 83       	std	Y+3, r24	; 0x03
    82f2:	6c 83       	std	Y+4, r22	; 0x04
    82f4:	2d 83       	std	Y+5, r18	; 0x05
    82f6:	3e 83       	std	Y+6, r19	; 0x06
    82f8:	4f 83       	std	Y+7, r20	; 0x07
    82fa:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    82fc:	87 eb       	ldi	r24, 0xB7	; 183
    82fe:	91 e2       	ldi	r25, 0x21	; 33
    8300:	89 83       	std	Y+1, r24	; 0x01
    8302:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    8304:	80 91 57 50 	lds	r24, 0x5057
    8308:	90 91 58 50 	lds	r25, 0x5058
    830c:	a0 91 59 50 	lds	r26, 0x5059
    8310:	b0 91 5a 50 	lds	r27, 0x505A
    8314:	01 96       	adiw	r24, 0x01	; 1
    8316:	a1 1d       	adc	r26, r1
    8318:	b1 1d       	adc	r27, r1
    831a:	27 eb       	ldi	r18, 0xB7	; 183
    831c:	31 e2       	ldi	r19, 0x21	; 33
    831e:	bc 01       	movw	r22, r24
    8320:	cd 01       	movw	r24, r26
    8322:	a9 01       	movw	r20, r18
    8324:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    8328:	89 81       	ldd	r24, Y+1	; 0x01
    832a:	9a 81       	ldd	r25, Y+2	; 0x02
    832c:	fc 01       	movw	r30, r24
    832e:	80 81       	ld	r24, Z
    8330:	91 81       	ldd	r25, Z+1	; 0x01
    8332:	a2 81       	ldd	r26, Z+2	; 0x02
    8334:	b3 81       	ldd	r27, Z+3	; 0x03
    8336:	82 35       	cpi	r24, 0x52	; 82
    8338:	f2 e5       	ldi	r31, 0x52	; 82
    833a:	9f 07       	cpc	r25, r31
    833c:	f1 e6       	ldi	r31, 0x61	; 97
    833e:	af 07       	cpc	r26, r31
    8340:	f1 e4       	ldi	r31, 0x41	; 65
    8342:	bf 07       	cpc	r27, r31
    8344:	11 f5       	brne	.+68     	; 0x838a <getSetFreeCluster+0xa8>
    8346:	89 81       	ldd	r24, Y+1	; 0x01
    8348:	9a 81       	ldd	r25, Y+2	; 0x02
    834a:	8c 51       	subi	r24, 0x1C	; 28
    834c:	9e 4f       	sbci	r25, 0xFE	; 254
    834e:	fc 01       	movw	r30, r24
    8350:	80 81       	ld	r24, Z
    8352:	91 81       	ldd	r25, Z+1	; 0x01
    8354:	a2 81       	ldd	r26, Z+2	; 0x02
    8356:	b3 81       	ldd	r27, Z+3	; 0x03
    8358:	82 37       	cpi	r24, 0x72	; 114
    835a:	f2 e7       	ldi	r31, 0x72	; 114
    835c:	9f 07       	cpc	r25, r31
    835e:	f1 e4       	ldi	r31, 0x41	; 65
    8360:	af 07       	cpc	r26, r31
    8362:	f1 e6       	ldi	r31, 0x61	; 97
    8364:	bf 07       	cpc	r27, r31
    8366:	89 f4       	brne	.+34     	; 0x838a <getSetFreeCluster+0xa8>
    8368:	89 81       	ldd	r24, Y+1	; 0x01
    836a:	9a 81       	ldd	r25, Y+2	; 0x02
    836c:	84 50       	subi	r24, 0x04	; 4
    836e:	9e 4f       	sbci	r25, 0xFE	; 254
    8370:	fc 01       	movw	r30, r24
    8372:	80 81       	ld	r24, Z
    8374:	91 81       	ldd	r25, Z+1	; 0x01
    8376:	a2 81       	ldd	r26, Z+2	; 0x02
    8378:	b3 81       	ldd	r27, Z+3	; 0x03
    837a:	80 30       	cpi	r24, 0x00	; 0
    837c:	f0 e0       	ldi	r31, 0x00	; 0
    837e:	9f 07       	cpc	r25, r31
    8380:	f5 e5       	ldi	r31, 0x55	; 85
    8382:	af 07       	cpc	r26, r31
    8384:	fa ea       	ldi	r31, 0xAA	; 170
    8386:	bf 07       	cpc	r27, r31
    8388:	21 f0       	breq	.+8      	; 0x8392 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    838a:	8f ef       	ldi	r24, 0xFF	; 255
    838c:	9f ef       	ldi	r25, 0xFF	; 255
    838e:	dc 01       	movw	r26, r24
    8390:	51 c0       	rjmp	.+162    	; 0x8434 <getSetFreeCluster+0x152>

 if(get_set == GET)
    8392:	8c 81       	ldd	r24, Y+4	; 0x04
    8394:	88 23       	and	r24, r24
    8396:	b9 f4       	brne	.+46     	; 0x83c6 <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    8398:	8b 81       	ldd	r24, Y+3	; 0x03
    839a:	81 30       	cpi	r24, 0x01	; 1
    839c:	51 f4       	brne	.+20     	; 0x83b2 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    839e:	89 81       	ldd	r24, Y+1	; 0x01
    83a0:	9a 81       	ldd	r25, Y+2	; 0x02
    83a2:	88 51       	subi	r24, 0x18	; 24
    83a4:	9e 4f       	sbci	r25, 0xFE	; 254
    83a6:	fc 01       	movw	r30, r24
    83a8:	80 81       	ld	r24, Z
    83aa:	91 81       	ldd	r25, Z+1	; 0x01
    83ac:	a2 81       	ldd	r26, Z+2	; 0x02
    83ae:	b3 81       	ldd	r27, Z+3	; 0x03
    83b0:	41 c0       	rjmp	.+130    	; 0x8434 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    83b2:	89 81       	ldd	r24, Y+1	; 0x01
    83b4:	9a 81       	ldd	r25, Y+2	; 0x02
    83b6:	84 51       	subi	r24, 0x14	; 20
    83b8:	9e 4f       	sbci	r25, 0xFE	; 254
    83ba:	fc 01       	movw	r30, r24
    83bc:	80 81       	ld	r24, Z
    83be:	91 81       	ldd	r25, Z+1	; 0x01
    83c0:	a2 81       	ldd	r26, Z+2	; 0x02
    83c2:	b3 81       	ldd	r27, Z+3	; 0x03
    83c4:	37 c0       	rjmp	.+110    	; 0x8434 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    83c6:	8b 81       	ldd	r24, Y+3	; 0x03
    83c8:	81 30       	cpi	r24, 0x01	; 1
    83ca:	79 f4       	brne	.+30     	; 0x83ea <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    83cc:	89 81       	ldd	r24, Y+1	; 0x01
    83ce:	9a 81       	ldd	r25, Y+2	; 0x02
    83d0:	9c 01       	movw	r18, r24
    83d2:	28 51       	subi	r18, 0x18	; 24
    83d4:	3e 4f       	sbci	r19, 0xFE	; 254
    83d6:	8d 81       	ldd	r24, Y+5	; 0x05
    83d8:	9e 81       	ldd	r25, Y+6	; 0x06
    83da:	af 81       	ldd	r26, Y+7	; 0x07
    83dc:	b8 85       	ldd	r27, Y+8	; 0x08
    83de:	f9 01       	movw	r30, r18
    83e0:	80 83       	st	Z, r24
    83e2:	91 83       	std	Z+1, r25	; 0x01
    83e4:	a2 83       	std	Z+2, r26	; 0x02
    83e6:	b3 83       	std	Z+3, r27	; 0x03
    83e8:	0e c0       	rjmp	.+28     	; 0x8406 <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    83ea:	89 81       	ldd	r24, Y+1	; 0x01
    83ec:	9a 81       	ldd	r25, Y+2	; 0x02
    83ee:	9c 01       	movw	r18, r24
    83f0:	24 51       	subi	r18, 0x14	; 20
    83f2:	3e 4f       	sbci	r19, 0xFE	; 254
    83f4:	8d 81       	ldd	r24, Y+5	; 0x05
    83f6:	9e 81       	ldd	r25, Y+6	; 0x06
    83f8:	af 81       	ldd	r26, Y+7	; 0x07
    83fa:	b8 85       	ldd	r27, Y+8	; 0x08
    83fc:	f9 01       	movw	r30, r18
    83fe:	80 83       	st	Z, r24
    8400:	91 83       	std	Z+1, r25	; 0x01
    8402:	a2 83       	std	Z+2, r26	; 0x02
    8404:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    8406:	80 91 57 50 	lds	r24, 0x5057
    840a:	90 91 58 50 	lds	r25, 0x5058
    840e:	a0 91 59 50 	lds	r26, 0x5059
    8412:	b0 91 5a 50 	lds	r27, 0x505A
    8416:	01 96       	adiw	r24, 0x01	; 1
    8418:	a1 1d       	adc	r26, r1
    841a:	b1 1d       	adc	r27, r1
    841c:	27 eb       	ldi	r18, 0xB7	; 183
    841e:	31 e2       	ldi	r19, 0x21	; 33
    8420:	bc 01       	movw	r22, r24
    8422:	cd 01       	movw	r24, r26
    8424:	a9 01       	movw	r20, r18
    8426:	20 e0       	ldi	r18, 0x00	; 0
    8428:	32 e0       	ldi	r19, 0x02	; 2
    842a:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_write_block>
 }
 return 0xffffffff;
    842e:	8f ef       	ldi	r24, 0xFF	; 255
    8430:	9f ef       	ldi	r25, 0xFF	; 255
    8432:	dc 01       	movw	r26, r24
}
    8434:	bc 01       	movw	r22, r24
    8436:	cd 01       	movw	r24, r26
    8438:	28 96       	adiw	r28, 0x08	; 8
    843a:	cd bf       	out	0x3d, r28	; 61
    843c:	de bf       	out	0x3e, r29	; 62
    843e:	df 91       	pop	r29
    8440:	cf 91       	pop	r28
    8442:	08 95       	ret

00008444 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    8444:	0f 93       	push	r16
    8446:	1f 93       	push	r17
    8448:	cf 93       	push	r28
    844a:	df 93       	push	r29
    844c:	cd b7       	in	r28, 0x3d	; 61
    844e:	de b7       	in	r29, 0x3e	; 62
    8450:	6c 97       	sbiw	r28, 0x1c	; 28
    8452:	cd bf       	out	0x3d, r28	; 61
    8454:	de bf       	out	0x3e, r29	; 62
    8456:	8a 8f       	std	Y+26, r24	; 0x1a
    8458:	6b 8f       	std	Y+27, r22	; 0x1b
    845a:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    845c:	80 91 3f 40 	lds	r24, 0x403F
    8460:	90 91 40 40 	lds	r25, 0x4040
    8464:	a0 91 41 40 	lds	r26, 0x4041
    8468:	b0 91 42 40 	lds	r27, 0x4042
    846c:	89 83       	std	Y+1, r24	; 0x01
    846e:	9a 83       	std	Y+2, r25	; 0x02
    8470:	ab 83       	std	Y+3, r26	; 0x03
    8472:	bc 83       	std	Y+4, r27	; 0x04
    8474:	01 c0       	rjmp	.+2      	; 0x8478 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    8476:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    8478:	89 81       	ldd	r24, Y+1	; 0x01
    847a:	9a 81       	ldd	r25, Y+2	; 0x02
    847c:	ab 81       	ldd	r26, Y+3	; 0x03
    847e:	bc 81       	ldd	r27, Y+4	; 0x04
    8480:	bc 01       	movw	r22, r24
    8482:	cd 01       	movw	r24, r26
    8484:	0e 94 95 40 	call	0x812a	; 0x812a <getFirstSector>
    8488:	dc 01       	movw	r26, r24
    848a:	cb 01       	movw	r24, r22
    848c:	88 8b       	std	Y+16, r24	; 0x10
    848e:	99 8b       	std	Y+17, r25	; 0x11
    8490:	aa 8b       	std	Y+18, r26	; 0x12
    8492:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    8494:	1d 82       	std	Y+5, r1	; 0x05
    8496:	1e 82       	std	Y+6, r1	; 0x06
    8498:	1f 82       	std	Y+7, r1	; 0x07
    849a:	18 86       	std	Y+8, r1	; 0x08
    849c:	68 c1       	rjmp	.+720    	; 0x876e <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    849e:	28 89       	ldd	r18, Y+16	; 0x10
    84a0:	39 89       	ldd	r19, Y+17	; 0x11
    84a2:	4a 89       	ldd	r20, Y+18	; 0x12
    84a4:	5b 89       	ldd	r21, Y+19	; 0x13
    84a6:	8d 81       	ldd	r24, Y+5	; 0x05
    84a8:	9e 81       	ldd	r25, Y+6	; 0x06
    84aa:	af 81       	ldd	r26, Y+7	; 0x07
    84ac:	b8 85       	ldd	r27, Y+8	; 0x08
    84ae:	82 0f       	add	r24, r18
    84b0:	93 1f       	adc	r25, r19
    84b2:	a4 1f       	adc	r26, r20
    84b4:	b5 1f       	adc	r27, r21
    84b6:	27 eb       	ldi	r18, 0xB7	; 183
    84b8:	31 e2       	ldi	r19, 0x21	; 33
    84ba:	bc 01       	movw	r22, r24
    84bc:	cd 01       	movw	r24, r26
    84be:	a9 01       	movw	r20, r18
    84c0:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    84c4:	1d 86       	std	Y+13, r1	; 0x0d
    84c6:	1e 86       	std	Y+14, r1	; 0x0e
    84c8:	3d c1       	rjmp	.+634    	; 0x8744 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    84ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    84cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    84ce:	89 54       	subi	r24, 0x49	; 73
    84d0:	9e 4d       	sbci	r25, 0xDE	; 222
    84d2:	8c 8b       	std	Y+20, r24	; 0x14
    84d4:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    84d6:	8c 89       	ldd	r24, Y+20	; 0x14
    84d8:	9d 89       	ldd	r25, Y+21	; 0x15
    84da:	fc 01       	movw	r30, r24
    84dc:	80 81       	ld	r24, Z
    84de:	88 23       	and	r24, r24
    84e0:	19 f4       	brne	.+6      	; 0x84e8 <findFiles+0xa4>
		{
		  return 0;   
    84e2:	80 e0       	ldi	r24, 0x00	; 0
    84e4:	90 e0       	ldi	r25, 0x00	; 0
    84e6:	80 c1       	rjmp	.+768    	; 0x87e8 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    84e8:	8c 89       	ldd	r24, Y+20	; 0x14
    84ea:	9d 89       	ldd	r25, Y+21	; 0x15
    84ec:	fc 01       	movw	r30, r24
    84ee:	80 81       	ld	r24, Z
    84f0:	85 3e       	cpi	r24, 0xE5	; 229
    84f2:	09 f4       	brne	.+2      	; 0x84f6 <findFiles+0xb2>
    84f4:	22 c1       	rjmp	.+580    	; 0x873a <findFiles+0x2f6>
    84f6:	8c 89       	ldd	r24, Y+20	; 0x14
    84f8:	9d 89       	ldd	r25, Y+21	; 0x15
    84fa:	fc 01       	movw	r30, r24
    84fc:	83 85       	ldd	r24, Z+11	; 0x0b
    84fe:	8f 30       	cpi	r24, 0x0F	; 15
    8500:	09 f4       	brne	.+2      	; 0x8504 <findFiles+0xc0>
    8502:	1b c1       	rjmp	.+566    	; 0x873a <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    8504:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8506:	81 30       	cpi	r24, 0x01	; 1
    8508:	21 f0       	breq	.+8      	; 0x8512 <findFiles+0xce>
    850a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    850c:	82 30       	cpi	r24, 0x02	; 2
    850e:	09 f0       	breq	.+2      	; 0x8512 <findFiles+0xce>
    8510:	11 c1       	rjmp	.+546    	; 0x8734 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8512:	1f 86       	std	Y+15, r1	; 0x0f
    8514:	17 c0       	rjmp	.+46     	; 0x8544 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    8516:	8f 85       	ldd	r24, Y+15	; 0x0f
    8518:	88 2f       	mov	r24, r24
    851a:	90 e0       	ldi	r25, 0x00	; 0
    851c:	2c 89       	ldd	r18, Y+20	; 0x14
    851e:	3d 89       	ldd	r19, Y+21	; 0x15
    8520:	82 0f       	add	r24, r18
    8522:	93 1f       	adc	r25, r19
    8524:	fc 01       	movw	r30, r24
    8526:	40 81       	ld	r20, Z
    8528:	8f 85       	ldd	r24, Y+15	; 0x0f
    852a:	88 2f       	mov	r24, r24
    852c:	90 e0       	ldi	r25, 0x00	; 0
    852e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    8530:	3c 8d       	ldd	r19, Y+28	; 0x1c
    8532:	82 0f       	add	r24, r18
    8534:	93 1f       	adc	r25, r19
    8536:	fc 01       	movw	r30, r24
    8538:	80 81       	ld	r24, Z
    853a:	48 17       	cp	r20, r24
    853c:	39 f4       	brne	.+14     	; 0x854c <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    853e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8540:	8f 5f       	subi	r24, 0xFF	; 255
    8542:	8f 87       	std	Y+15, r24	; 0x0f
    8544:	8f 85       	ldd	r24, Y+15	; 0x0f
    8546:	8b 30       	cpi	r24, 0x0B	; 11
    8548:	30 f3       	brcs	.-52     	; 0x8516 <findFiles+0xd2>
    854a:	01 c0       	rjmp	.+2      	; 0x854e <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    854c:	00 00       	nop
            if(j == 11)
    854e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8550:	8b 30       	cpi	r24, 0x0B	; 11
    8552:	09 f0       	breq	.+2      	; 0x8556 <findFiles+0x112>
    8554:	f2 c0       	rjmp	.+484    	; 0x873a <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    8556:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8558:	81 30       	cpi	r24, 0x01	; 1
    855a:	09 f0       	breq	.+2      	; 0x855e <findFiles+0x11a>
    855c:	52 c0       	rjmp	.+164    	; 0x8602 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    855e:	28 89       	ldd	r18, Y+16	; 0x10
    8560:	39 89       	ldd	r19, Y+17	; 0x11
    8562:	4a 89       	ldd	r20, Y+18	; 0x12
    8564:	5b 89       	ldd	r21, Y+19	; 0x13
    8566:	8d 81       	ldd	r24, Y+5	; 0x05
    8568:	9e 81       	ldd	r25, Y+6	; 0x06
    856a:	af 81       	ldd	r26, Y+7	; 0x07
    856c:	b8 85       	ldd	r27, Y+8	; 0x08
    856e:	82 0f       	add	r24, r18
    8570:	93 1f       	adc	r25, r19
    8572:	a4 1f       	adc	r26, r20
    8574:	b5 1f       	adc	r27, r21
    8576:	80 93 b9 50 	sts	0x50B9, r24
    857a:	90 93 ba 50 	sts	0x50BA, r25
    857e:	a0 93 bb 50 	sts	0x50BB, r26
    8582:	b0 93 bc 50 	sts	0x50BC, r27
				appendFileLocation = i;
    8586:	8d 85       	ldd	r24, Y+13	; 0x0d
    8588:	9e 85       	ldd	r25, Y+14	; 0x0e
    858a:	cc 01       	movw	r24, r24
    858c:	a0 e0       	ldi	r26, 0x00	; 0
    858e:	b0 e0       	ldi	r27, 0x00	; 0
    8590:	80 93 b8 23 	sts	0x23B8, r24
    8594:	90 93 b9 23 	sts	0x23B9, r25
    8598:	a0 93 ba 23 	sts	0x23BA, r26
    859c:	b0 93 bb 23 	sts	0x23BB, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    85a0:	8c 89       	ldd	r24, Y+20	; 0x14
    85a2:	9d 89       	ldd	r25, Y+21	; 0x15
    85a4:	fc 01       	movw	r30, r24
    85a6:	84 89       	ldd	r24, Z+20	; 0x14
    85a8:	95 89       	ldd	r25, Z+21	; 0x15
    85aa:	cc 01       	movw	r24, r24
    85ac:	a0 e0       	ldi	r26, 0x00	; 0
    85ae:	b0 e0       	ldi	r27, 0x00	; 0
    85b0:	ac 01       	movw	r20, r24
    85b2:	33 27       	eor	r19, r19
    85b4:	22 27       	eor	r18, r18
    85b6:	8c 89       	ldd	r24, Y+20	; 0x14
    85b8:	9d 89       	ldd	r25, Y+21	; 0x15
    85ba:	fc 01       	movw	r30, r24
    85bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    85be:	93 8d       	ldd	r25, Z+27	; 0x1b
    85c0:	cc 01       	movw	r24, r24
    85c2:	a0 e0       	ldi	r26, 0x00	; 0
    85c4:	b0 e0       	ldi	r27, 0x00	; 0
    85c6:	82 2b       	or	r24, r18
    85c8:	93 2b       	or	r25, r19
    85ca:	a4 2b       	or	r26, r20
    85cc:	b5 2b       	or	r27, r21
    85ce:	80 93 61 50 	sts	0x5061, r24
    85d2:	90 93 62 50 	sts	0x5062, r25
    85d6:	a0 93 63 50 	sts	0x5063, r26
    85da:	b0 93 64 50 	sts	0x5064, r27
				fileSize = dir->fileSize;
    85de:	8c 89       	ldd	r24, Y+20	; 0x14
    85e0:	9d 89       	ldd	r25, Y+21	; 0x15
    85e2:	fc 01       	movw	r30, r24
    85e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    85e6:	95 8d       	ldd	r25, Z+29	; 0x1d
    85e8:	a6 8d       	ldd	r26, Z+30	; 0x1e
    85ea:	b7 8d       	ldd	r27, Z+31	; 0x1f
    85ec:	80 93 31 40 	sts	0x4031, r24
    85f0:	90 93 32 40 	sts	0x4032, r25
    85f4:	a0 93 33 40 	sts	0x4033, r26
    85f8:	b0 93 34 40 	sts	0x4034, r27
			    return (dir);
    85fc:	8c 89       	ldd	r24, Y+20	; 0x14
    85fe:	9d 89       	ldd	r25, Y+21	; 0x15
    8600:	f3 c0       	rjmp	.+486    	; 0x87e8 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8602:	8c 89       	ldd	r24, Y+20	; 0x14
    8604:	9d 89       	ldd	r25, Y+21	; 0x15
    8606:	fc 01       	movw	r30, r24
    8608:	84 89       	ldd	r24, Z+20	; 0x14
    860a:	95 89       	ldd	r25, Z+21	; 0x15
    860c:	cc 01       	movw	r24, r24
    860e:	a0 e0       	ldi	r26, 0x00	; 0
    8610:	b0 e0       	ldi	r27, 0x00	; 0
    8612:	ac 01       	movw	r20, r24
    8614:	33 27       	eor	r19, r19
    8616:	22 27       	eor	r18, r18
    8618:	8c 89       	ldd	r24, Y+20	; 0x14
    861a:	9d 89       	ldd	r25, Y+21	; 0x15
    861c:	fc 01       	movw	r30, r24
    861e:	82 8d       	ldd	r24, Z+26	; 0x1a
    8620:	93 8d       	ldd	r25, Z+27	; 0x1b
    8622:	cc 01       	movw	r24, r24
    8624:	a0 e0       	ldi	r26, 0x00	; 0
    8626:	b0 e0       	ldi	r27, 0x00	; 0
    8628:	82 2b       	or	r24, r18
    862a:	93 2b       	or	r25, r19
    862c:	a4 2b       	or	r26, r20
    862e:	b5 2b       	or	r27, r21
    8630:	89 87       	std	Y+9, r24	; 0x09
    8632:	9a 87       	std	Y+10, r25	; 0x0a
    8634:	ab 87       	std	Y+11, r26	; 0x0b
    8636:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8638:	8c 89       	ldd	r24, Y+20	; 0x14
    863a:	9d 89       	ldd	r25, Y+21	; 0x15
    863c:	25 ee       	ldi	r18, 0xE5	; 229
    863e:	fc 01       	movw	r30, r24
    8640:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8642:	28 89       	ldd	r18, Y+16	; 0x10
    8644:	39 89       	ldd	r19, Y+17	; 0x11
    8646:	4a 89       	ldd	r20, Y+18	; 0x12
    8648:	5b 89       	ldd	r21, Y+19	; 0x13
    864a:	8d 81       	ldd	r24, Y+5	; 0x05
    864c:	9e 81       	ldd	r25, Y+6	; 0x06
    864e:	af 81       	ldd	r26, Y+7	; 0x07
    8650:	b8 85       	ldd	r27, Y+8	; 0x08
    8652:	82 0f       	add	r24, r18
    8654:	93 1f       	adc	r25, r19
    8656:	a4 1f       	adc	r26, r20
    8658:	b5 1f       	adc	r27, r21
    865a:	27 eb       	ldi	r18, 0xB7	; 183
    865c:	31 e2       	ldi	r19, 0x21	; 33
    865e:	bc 01       	movw	r22, r24
    8660:	cd 01       	movw	r24, r26
    8662:	a9 01       	movw	r20, r18
    8664:	20 e0       	ldi	r18, 0x00	; 0
    8666:	32 e0       	ldi	r19, 0x02	; 2
    8668:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    866c:	8c 89       	ldd	r24, Y+20	; 0x14
    866e:	9d 89       	ldd	r25, Y+21	; 0x15
    8670:	fc 01       	movw	r30, r24
    8672:	24 8d       	ldd	r18, Z+28	; 0x1c
    8674:	35 8d       	ldd	r19, Z+29	; 0x1d
    8676:	46 8d       	ldd	r20, Z+30	; 0x1e
    8678:	57 8d       	ldd	r21, Z+31	; 0x1f
    867a:	80 e0       	ldi	r24, 0x00	; 0
    867c:	ba 01       	movw	r22, r20
    867e:	a9 01       	movw	r20, r18
    8680:	0e 94 23 4a 	call	0x9446	; 0x9446 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8684:	82 e0       	ldi	r24, 0x02	; 2
    8686:	60 e0       	ldi	r22, 0x00	; 0
    8688:	20 e0       	ldi	r18, 0x00	; 0
    868a:	30 e0       	ldi	r19, 0x00	; 0
    868c:	a9 01       	movw	r20, r18
    868e:	0e 94 71 41 	call	0x82e2	; 0x82e2 <getSetFreeCluster>
    8692:	dc 01       	movw	r26, r24
    8694:	cb 01       	movw	r24, r22
    8696:	89 83       	std	Y+1, r24	; 0x01
    8698:	9a 83       	std	Y+2, r25	; 0x02
    869a:	ab 83       	std	Y+3, r26	; 0x03
    869c:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    869e:	29 85       	ldd	r18, Y+9	; 0x09
    86a0:	3a 85       	ldd	r19, Y+10	; 0x0a
    86a2:	4b 85       	ldd	r20, Y+11	; 0x0b
    86a4:	5c 85       	ldd	r21, Y+12	; 0x0c
    86a6:	89 81       	ldd	r24, Y+1	; 0x01
    86a8:	9a 81       	ldd	r25, Y+2	; 0x02
    86aa:	ab 81       	ldd	r26, Y+3	; 0x03
    86ac:	bc 81       	ldd	r27, Y+4	; 0x04
    86ae:	28 17       	cp	r18, r24
    86b0:	39 07       	cpc	r19, r25
    86b2:	4a 07       	cpc	r20, r26
    86b4:	5b 07       	cpc	r21, r27
    86b6:	40 f4       	brcc	.+16     	; 0x86c8 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    86b8:	29 85       	ldd	r18, Y+9	; 0x09
    86ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    86bc:	4b 85       	ldd	r20, Y+11	; 0x0b
    86be:	5c 85       	ldd	r21, Y+12	; 0x0c
    86c0:	82 e0       	ldi	r24, 0x02	; 2
    86c2:	61 e0       	ldi	r22, 0x01	; 1
    86c4:	0e 94 71 41 	call	0x82e2	; 0x82e2 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    86c8:	89 85       	ldd	r24, Y+9	; 0x09
    86ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    86cc:	ab 85       	ldd	r26, Y+11	; 0x0b
    86ce:	bc 85       	ldd	r27, Y+12	; 0x0c
    86d0:	bc 01       	movw	r22, r24
    86d2:	cd 01       	movw	r24, r26
    86d4:	40 e0       	ldi	r20, 0x00	; 0
    86d6:	00 e0       	ldi	r16, 0x00	; 0
    86d8:	10 e0       	ldi	r17, 0x00	; 0
    86da:	98 01       	movw	r18, r16
    86dc:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
    86e0:	dc 01       	movw	r26, r24
    86e2:	cb 01       	movw	r24, r22
    86e4:	8e 8b       	std	Y+22, r24	; 0x16
    86e6:	9f 8b       	std	Y+23, r25	; 0x17
    86e8:	a8 8f       	std	Y+24, r26	; 0x18
    86ea:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    86ec:	89 85       	ldd	r24, Y+9	; 0x09
    86ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    86f0:	ab 85       	ldd	r26, Y+11	; 0x0b
    86f2:	bc 85       	ldd	r27, Y+12	; 0x0c
    86f4:	bc 01       	movw	r22, r24
    86f6:	cd 01       	movw	r24, r26
    86f8:	41 e0       	ldi	r20, 0x01	; 1
    86fa:	00 e0       	ldi	r16, 0x00	; 0
    86fc:	10 e0       	ldi	r17, 0x00	; 0
    86fe:	98 01       	movw	r18, r16
    8700:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8704:	8e 89       	ldd	r24, Y+22	; 0x16
    8706:	9f 89       	ldd	r25, Y+23	; 0x17
    8708:	a8 8d       	ldd	r26, Y+24	; 0x18
    870a:	b9 8d       	ldd	r27, Y+25	; 0x19
    870c:	87 3f       	cpi	r24, 0xF7	; 247
    870e:	ff ef       	ldi	r31, 0xFF	; 255
    8710:	9f 07       	cpc	r25, r31
    8712:	ff ef       	ldi	r31, 0xFF	; 255
    8714:	af 07       	cpc	r26, r31
    8716:	ff e0       	ldi	r31, 0x0F	; 15
    8718:	bf 07       	cpc	r27, r31
    871a:	18 f0       	brcs	.+6      	; 0x8722 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    871c:	80 e0       	ldi	r24, 0x00	; 0
    871e:	90 e0       	ldi	r25, 0x00	; 0
    8720:	63 c0       	rjmp	.+198    	; 0x87e8 <findFiles+0x3a4>
					firstCluster = nextCluster;
    8722:	8e 89       	ldd	r24, Y+22	; 0x16
    8724:	9f 89       	ldd	r25, Y+23	; 0x17
    8726:	a8 8d       	ldd	r26, Y+24	; 0x18
    8728:	b9 8d       	ldd	r27, Y+25	; 0x19
    872a:	89 87       	std	Y+9, r24	; 0x09
    872c:	9a 87       	std	Y+10, r25	; 0x0a
    872e:	ab 87       	std	Y+11, r26	; 0x0b
    8730:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8732:	ca cf       	rjmp	.-108    	; 0x86c8 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8734:	80 e0       	ldi	r24, 0x00	; 0
    8736:	90 e0       	ldi	r25, 0x00	; 0
    8738:	57 c0       	rjmp	.+174    	; 0x87e8 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    873a:	8d 85       	ldd	r24, Y+13	; 0x0d
    873c:	9e 85       	ldd	r25, Y+14	; 0x0e
    873e:	80 96       	adiw	r24, 0x20	; 32
    8740:	8d 87       	std	Y+13, r24	; 0x0d
    8742:	9e 87       	std	Y+14, r25	; 0x0e
    8744:	80 91 35 40 	lds	r24, 0x4035
    8748:	90 91 36 40 	lds	r25, 0x4036
    874c:	2d 85       	ldd	r18, Y+13	; 0x0d
    874e:	3e 85       	ldd	r19, Y+14	; 0x0e
    8750:	28 17       	cp	r18, r24
    8752:	39 07       	cpc	r19, r25
    8754:	08 f4       	brcc	.+2      	; 0x8758 <findFiles+0x314>
    8756:	b9 ce       	rjmp	.-654    	; 0x84ca <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8758:	8d 81       	ldd	r24, Y+5	; 0x05
    875a:	9e 81       	ldd	r25, Y+6	; 0x06
    875c:	af 81       	ldd	r26, Y+7	; 0x07
    875e:	b8 85       	ldd	r27, Y+8	; 0x08
    8760:	01 96       	adiw	r24, 0x01	; 1
    8762:	a1 1d       	adc	r26, r1
    8764:	b1 1d       	adc	r27, r1
    8766:	8d 83       	std	Y+5, r24	; 0x05
    8768:	9e 83       	std	Y+6, r25	; 0x06
    876a:	af 83       	std	Y+7, r26	; 0x07
    876c:	b8 87       	std	Y+8, r27	; 0x08
    876e:	80 91 55 50 	lds	r24, 0x5055
    8772:	90 91 56 50 	lds	r25, 0x5056
    8776:	9c 01       	movw	r18, r24
    8778:	40 e0       	ldi	r20, 0x00	; 0
    877a:	50 e0       	ldi	r21, 0x00	; 0
    877c:	8d 81       	ldd	r24, Y+5	; 0x05
    877e:	9e 81       	ldd	r25, Y+6	; 0x06
    8780:	af 81       	ldd	r26, Y+7	; 0x07
    8782:	b8 85       	ldd	r27, Y+8	; 0x08
    8784:	82 17       	cp	r24, r18
    8786:	93 07       	cpc	r25, r19
    8788:	a4 07       	cpc	r26, r20
    878a:	b5 07       	cpc	r27, r21
    878c:	08 f4       	brcc	.+2      	; 0x8790 <findFiles+0x34c>
    878e:	87 ce       	rjmp	.-754    	; 0x849e <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8790:	89 81       	ldd	r24, Y+1	; 0x01
    8792:	9a 81       	ldd	r25, Y+2	; 0x02
    8794:	ab 81       	ldd	r26, Y+3	; 0x03
    8796:	bc 81       	ldd	r27, Y+4	; 0x04
    8798:	bc 01       	movw	r22, r24
    879a:	cd 01       	movw	r24, r26
    879c:	40 e0       	ldi	r20, 0x00	; 0
    879e:	00 e0       	ldi	r16, 0x00	; 0
    87a0:	10 e0       	ldi	r17, 0x00	; 0
    87a2:	98 01       	movw	r18, r16
    87a4:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
    87a8:	dc 01       	movw	r26, r24
    87aa:	cb 01       	movw	r24, r22
    87ac:	89 83       	std	Y+1, r24	; 0x01
    87ae:	9a 83       	std	Y+2, r25	; 0x02
    87b0:	ab 83       	std	Y+3, r26	; 0x03
    87b2:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    87b4:	89 81       	ldd	r24, Y+1	; 0x01
    87b6:	9a 81       	ldd	r25, Y+2	; 0x02
    87b8:	ab 81       	ldd	r26, Y+3	; 0x03
    87ba:	bc 81       	ldd	r27, Y+4	; 0x04
    87bc:	87 3f       	cpi	r24, 0xF7	; 247
    87be:	2f ef       	ldi	r18, 0xFF	; 255
    87c0:	92 07       	cpc	r25, r18
    87c2:	2f ef       	ldi	r18, 0xFF	; 255
    87c4:	a2 07       	cpc	r26, r18
    87c6:	2f e0       	ldi	r18, 0x0F	; 15
    87c8:	b2 07       	cpc	r27, r18
    87ca:	18 f0       	brcs	.+6      	; 0x87d2 <findFiles+0x38e>
   	 return 0;
    87cc:	80 e0       	ldi	r24, 0x00	; 0
    87ce:	90 e0       	ldi	r25, 0x00	; 0
    87d0:	0b c0       	rjmp	.+22     	; 0x87e8 <findFiles+0x3a4>
   if(cluster == 0) 
    87d2:	89 81       	ldd	r24, Y+1	; 0x01
    87d4:	9a 81       	ldd	r25, Y+2	; 0x02
    87d6:	ab 81       	ldd	r26, Y+3	; 0x03
    87d8:	bc 81       	ldd	r27, Y+4	; 0x04
    87da:	00 97       	sbiw	r24, 0x00	; 0
    87dc:	a1 05       	cpc	r26, r1
    87de:	b1 05       	cpc	r27, r1
    87e0:	09 f0       	breq	.+2      	; 0x87e4 <findFiles+0x3a0>
    87e2:	49 ce       	rjmp	.-878    	; 0x8476 <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    87e4:	80 e0       	ldi	r24, 0x00	; 0
    87e6:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    87e8:	6c 96       	adiw	r28, 0x1c	; 28
    87ea:	cd bf       	out	0x3d, r28	; 61
    87ec:	de bf       	out	0x3e, r29	; 62
    87ee:	df 91       	pop	r29
    87f0:	cf 91       	pop	r28
    87f2:	1f 91       	pop	r17
    87f4:	0f 91       	pop	r16
    87f6:	08 95       	ret

000087f8 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    87f8:	0f 93       	push	r16
    87fa:	1f 93       	push	r17
    87fc:	cf 93       	push	r28
    87fe:	df 93       	push	r29
    8800:	cd b7       	in	r28, 0x3d	; 61
    8802:	de b7       	in	r29, 0x3e	; 62
    8804:	67 97       	sbiw	r28, 0x17	; 23
    8806:	cd bf       	out	0x3d, r28	; 61
    8808:	de bf       	out	0x3e, r29	; 62
    880a:	8d 8b       	std	Y+21, r24	; 0x15
    880c:	6e 8b       	std	Y+22, r22	; 0x16
    880e:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8810:	1e 82       	std	Y+6, r1	; 0x06
    8812:	1f 82       	std	Y+7, r1	; 0x07
    8814:	18 86       	std	Y+8, r1	; 0x08
    8816:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8818:	8e 89       	ldd	r24, Y+22	; 0x16
    881a:	9f 89       	ldd	r25, Y+23	; 0x17
    881c:	0e 94 ab 44 	call	0x8956	; 0x8956 <convertFileName>
    8820:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8822:	8a 85       	ldd	r24, Y+10	; 0x0a
    8824:	88 23       	and	r24, r24
    8826:	11 f0       	breq	.+4      	; 0x882c <readFile+0x34>
    8828:	82 e0       	ldi	r24, 0x02	; 2
    882a:	8d c0       	rjmp	.+282    	; 0x8946 <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    882c:	25 e9       	ldi	r18, 0x95	; 149
    882e:	30 e5       	ldi	r19, 0x50	; 80
    8830:	81 e0       	ldi	r24, 0x01	; 1
    8832:	b9 01       	movw	r22, r18
    8834:	0e 94 22 42 	call	0x8444	; 0x8444 <findFiles>
    8838:	8b 87       	std	Y+11, r24	; 0x0b
    883a:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    883c:	8b 85       	ldd	r24, Y+11	; 0x0b
    883e:	9c 85       	ldd	r25, Y+12	; 0x0c
    8840:	00 97       	sbiw	r24, 0x00	; 0
    8842:	39 f4       	brne	.+14     	; 0x8852 <readFile+0x5a>
{
  if(flag == READ) return (1);
    8844:	8d 89       	ldd	r24, Y+21	; 0x15
    8846:	88 23       	and	r24, r24
    8848:	11 f4       	brne	.+4      	; 0x884e <readFile+0x56>
    884a:	81 e0       	ldi	r24, 0x01	; 1
    884c:	7c c0       	rjmp	.+248    	; 0x8946 <readFile+0x14e>
  else return (0);
    884e:	80 e0       	ldi	r24, 0x00	; 0
    8850:	7a c0       	rjmp	.+244    	; 0x8946 <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8852:	8d 89       	ldd	r24, Y+21	; 0x15
    8854:	81 30       	cpi	r24, 0x01	; 1
    8856:	11 f4       	brne	.+4      	; 0x885c <readFile+0x64>
    8858:	81 e0       	ldi	r24, 0x01	; 1
    885a:	75 c0       	rjmp	.+234    	; 0x8946 <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    885c:	8b 85       	ldd	r24, Y+11	; 0x0b
    885e:	9c 85       	ldd	r25, Y+12	; 0x0c
    8860:	fc 01       	movw	r30, r24
    8862:	84 89       	ldd	r24, Z+20	; 0x14
    8864:	95 89       	ldd	r25, Z+21	; 0x15
    8866:	cc 01       	movw	r24, r24
    8868:	a0 e0       	ldi	r26, 0x00	; 0
    886a:	b0 e0       	ldi	r27, 0x00	; 0
    886c:	ac 01       	movw	r20, r24
    886e:	33 27       	eor	r19, r19
    8870:	22 27       	eor	r18, r18
    8872:	8b 85       	ldd	r24, Y+11	; 0x0b
    8874:	9c 85       	ldd	r25, Y+12	; 0x0c
    8876:	fc 01       	movw	r30, r24
    8878:	82 8d       	ldd	r24, Z+26	; 0x1a
    887a:	93 8d       	ldd	r25, Z+27	; 0x1b
    887c:	cc 01       	movw	r24, r24
    887e:	a0 e0       	ldi	r26, 0x00	; 0
    8880:	b0 e0       	ldi	r27, 0x00	; 0
    8882:	82 2b       	or	r24, r18
    8884:	93 2b       	or	r25, r19
    8886:	a4 2b       	or	r26, r20
    8888:	b5 2b       	or	r27, r21
    888a:	89 83       	std	Y+1, r24	; 0x01
    888c:	9a 83       	std	Y+2, r25	; 0x02
    888e:	ab 83       	std	Y+3, r26	; 0x03
    8890:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    8892:	8b 85       	ldd	r24, Y+11	; 0x0b
    8894:	9c 85       	ldd	r25, Y+12	; 0x0c
    8896:	fc 01       	movw	r30, r24
    8898:	84 8d       	ldd	r24, Z+28	; 0x1c
    889a:	95 8d       	ldd	r25, Z+29	; 0x1d
    889c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    889e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    88a0:	8d 87       	std	Y+13, r24	; 0x0d
    88a2:	9e 87       	std	Y+14, r25	; 0x0e
    88a4:	af 87       	std	Y+15, r26	; 0x0f
    88a6:	b8 8b       	std	Y+16, r27	; 0x10
    88a8:	01 c0       	rjmp	.+2      	; 0x88ac <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    88aa:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    88ac:	89 81       	ldd	r24, Y+1	; 0x01
    88ae:	9a 81       	ldd	r25, Y+2	; 0x02
    88b0:	ab 81       	ldd	r26, Y+3	; 0x03
    88b2:	bc 81       	ldd	r27, Y+4	; 0x04
    88b4:	bc 01       	movw	r22, r24
    88b6:	cd 01       	movw	r24, r26
    88b8:	0e 94 95 40 	call	0x812a	; 0x812a <getFirstSector>
    88bc:	dc 01       	movw	r26, r24
    88be:	cb 01       	movw	r24, r22
    88c0:	89 8b       	std	Y+17, r24	; 0x11
    88c2:	9a 8b       	std	Y+18, r25	; 0x12
    88c4:	ab 8b       	std	Y+19, r26	; 0x13
    88c6:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    88c8:	1d 82       	std	Y+5, r1	; 0x05
    88ca:	17 c0       	rjmp	.+46     	; 0x88fa <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    88cc:	8d 81       	ldd	r24, Y+5	; 0x05
    88ce:	28 2f       	mov	r18, r24
    88d0:	30 e0       	ldi	r19, 0x00	; 0
    88d2:	40 e0       	ldi	r20, 0x00	; 0
    88d4:	50 e0       	ldi	r21, 0x00	; 0
    88d6:	89 89       	ldd	r24, Y+17	; 0x11
    88d8:	9a 89       	ldd	r25, Y+18	; 0x12
    88da:	ab 89       	ldd	r26, Y+19	; 0x13
    88dc:	bc 89       	ldd	r27, Y+20	; 0x14
    88de:	82 0f       	add	r24, r18
    88e0:	93 1f       	adc	r25, r19
    88e2:	a4 1f       	adc	r26, r20
    88e4:	b5 1f       	adc	r27, r21
    88e6:	20 ec       	ldi	r18, 0xC0	; 192
    88e8:	33 e2       	ldi	r19, 0x23	; 35
    88ea:	bc 01       	movw	r22, r24
    88ec:	cd 01       	movw	r24, r26
    88ee:	a9 01       	movw	r20, r18
    88f0:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    88f4:	8d 81       	ldd	r24, Y+5	; 0x05
    88f6:	8f 5f       	subi	r24, 0xFF	; 255
    88f8:	8d 83       	std	Y+5, r24	; 0x05
    88fa:	8d 81       	ldd	r24, Y+5	; 0x05
    88fc:	28 2f       	mov	r18, r24
    88fe:	30 e0       	ldi	r19, 0x00	; 0
    8900:	80 91 55 50 	lds	r24, 0x5055
    8904:	90 91 56 50 	lds	r25, 0x5056
    8908:	28 17       	cp	r18, r24
    890a:	39 07       	cpc	r19, r25
    890c:	f8 f2       	brcs	.-66     	; 0x88cc <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    890e:	89 81       	ldd	r24, Y+1	; 0x01
    8910:	9a 81       	ldd	r25, Y+2	; 0x02
    8912:	ab 81       	ldd	r26, Y+3	; 0x03
    8914:	bc 81       	ldd	r27, Y+4	; 0x04
    8916:	bc 01       	movw	r22, r24
    8918:	cd 01       	movw	r24, r26
    891a:	40 e0       	ldi	r20, 0x00	; 0
    891c:	00 e0       	ldi	r16, 0x00	; 0
    891e:	10 e0       	ldi	r17, 0x00	; 0
    8920:	98 01       	movw	r18, r16
    8922:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
    8926:	dc 01       	movw	r26, r24
    8928:	cb 01       	movw	r24, r22
    892a:	89 83       	std	Y+1, r24	; 0x01
    892c:	9a 83       	std	Y+2, r25	; 0x02
    892e:	ab 83       	std	Y+3, r26	; 0x03
    8930:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8932:	89 81       	ldd	r24, Y+1	; 0x01
    8934:	9a 81       	ldd	r25, Y+2	; 0x02
    8936:	ab 81       	ldd	r26, Y+3	; 0x03
    8938:	bc 81       	ldd	r27, Y+4	; 0x04
    893a:	00 97       	sbiw	r24, 0x00	; 0
    893c:	a1 05       	cpc	r26, r1
    893e:	b1 05       	cpc	r27, r1
    8940:	09 f0       	breq	.+2      	; 0x8944 <readFile+0x14c>
    8942:	b3 cf       	rjmp	.-154    	; 0x88aa <readFile+0xb2>
	  return 0;}
    8944:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8946:	67 96       	adiw	r28, 0x17	; 23
    8948:	cd bf       	out	0x3d, r28	; 61
    894a:	de bf       	out	0x3e, r29	; 62
    894c:	df 91       	pop	r29
    894e:	cf 91       	pop	r28
    8950:	1f 91       	pop	r17
    8952:	0f 91       	pop	r16
    8954:	08 95       	ret

00008956 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8956:	cf 93       	push	r28
    8958:	df 93       	push	r29
    895a:	cd b7       	in	r28, 0x3d	; 61
    895c:	de b7       	in	r29, 0x3e	; 62
    895e:	62 97       	sbiw	r28, 0x12	; 18
    8960:	cd bf       	out	0x3d, r28	; 61
    8962:	de bf       	out	0x3e, r29	; 62
    8964:	89 8b       	std	Y+17, r24	; 0x11
    8966:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8968:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    896a:	89 89       	ldd	r24, Y+17	; 0x11
    896c:	9a 89       	ldd	r25, Y+18	; 0x12
    896e:	9c 01       	movw	r18, r24
    8970:	f9 01       	movw	r30, r18
    8972:	01 90       	ld	r0, Z+
    8974:	00 20       	and	r0, r0
    8976:	e9 f7       	brne	.-6      	; 0x8972 <convertFileName+0x1c>
    8978:	cf 01       	movw	r24, r30
    897a:	01 97       	sbiw	r24, 0x01	; 1
    897c:	82 1b       	sub	r24, r18
    897e:	93 0b       	sbc	r25, r19
    8980:	80 31       	cpi	r24, 0x10	; 16
    8982:	91 05       	cpc	r25, r1
    8984:	10 f0       	brcs	.+4      	; 0x898a <convertFileName+0x34>
    8986:	81 e0       	ldi	r24, 0x01	; 1
    8988:	16 c1       	rjmp	.+556    	; 0x8bb6 <convertFileName+0x260>
int i=0;
    898a:	1c 82       	std	Y+4, r1	; 0x04
    898c:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    898e:	13 c0       	rjmp	.+38     	; 0x89b6 <convertFileName+0x60>
	Filename[i] = fileName[i];
    8990:	8c 81       	ldd	r24, Y+4	; 0x04
    8992:	9d 81       	ldd	r25, Y+5	; 0x05
    8994:	29 89       	ldd	r18, Y+17	; 0x11
    8996:	3a 89       	ldd	r19, Y+18	; 0x12
    8998:	82 0f       	add	r24, r18
    899a:	93 1f       	adc	r25, r19
    899c:	fc 01       	movw	r30, r24
    899e:	20 81       	ld	r18, Z
    89a0:	8c 81       	ldd	r24, Y+4	; 0x04
    89a2:	9d 81       	ldd	r25, Y+5	; 0x05
    89a4:	8b 56       	subi	r24, 0x6B	; 107
    89a6:	9f 4a       	sbci	r25, 0xAF	; 175
    89a8:	fc 01       	movw	r30, r24
    89aa:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    89ac:	8c 81       	ldd	r24, Y+4	; 0x04
    89ae:	9d 81       	ldd	r25, Y+5	; 0x05
    89b0:	01 96       	adiw	r24, 0x01	; 1
    89b2:	8c 83       	std	Y+4, r24	; 0x04
    89b4:	9d 83       	std	Y+5, r25	; 0x05
    89b6:	4c 81       	ldd	r20, Y+4	; 0x04
    89b8:	5d 81       	ldd	r21, Y+5	; 0x05
    89ba:	89 89       	ldd	r24, Y+17	; 0x11
    89bc:	9a 89       	ldd	r25, Y+18	; 0x12
    89be:	9c 01       	movw	r18, r24
    89c0:	f9 01       	movw	r30, r18
    89c2:	01 90       	ld	r0, Z+
    89c4:	00 20       	and	r0, r0
    89c6:	e9 f7       	brne	.-6      	; 0x89c2 <convertFileName+0x6c>
    89c8:	cf 01       	movw	r24, r30
    89ca:	01 97       	sbiw	r24, 0x01	; 1
    89cc:	82 1b       	sub	r24, r18
    89ce:	93 0b       	sbc	r25, r19
    89d0:	48 17       	cp	r20, r24
    89d2:	59 07       	cpc	r21, r25
    89d4:	e8 f2       	brcs	.-70     	; 0x8990 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    89d6:	0c c0       	rjmp	.+24     	; 0x89f0 <convertFileName+0x9a>
    89d8:	8c 81       	ldd	r24, Y+4	; 0x04
    89da:	9d 81       	ldd	r25, Y+5	; 0x05
    89dc:	8b 56       	subi	r24, 0x6B	; 107
    89de:	9f 4a       	sbci	r25, 0xAF	; 175
    89e0:	20 e2       	ldi	r18, 0x20	; 32
    89e2:	fc 01       	movw	r30, r24
    89e4:	20 83       	st	Z, r18
    89e6:	8c 81       	ldd	r24, Y+4	; 0x04
    89e8:	9d 81       	ldd	r25, Y+5	; 0x05
    89ea:	01 96       	adiw	r24, 0x01	; 1
    89ec:	8c 83       	std	Y+4, r24	; 0x04
    89ee:	9d 83       	std	Y+5, r25	; 0x05
    89f0:	8c 81       	ldd	r24, Y+4	; 0x04
    89f2:	9d 81       	ldd	r25, Y+5	; 0x05
    89f4:	8f 30       	cpi	r24, 0x0F	; 15
    89f6:	91 05       	cpc	r25, r1
    89f8:	7c f3       	brlt	.-34     	; 0x89d8 <convertFileName+0x82>


for(j=0; j<12; j++)
    89fa:	1a 82       	std	Y+2, r1	; 0x02
    89fc:	0c c0       	rjmp	.+24     	; 0x8a16 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    89fe:	8a 81       	ldd	r24, Y+2	; 0x02
    8a00:	88 2f       	mov	r24, r24
    8a02:	90 e0       	ldi	r25, 0x00	; 0
    8a04:	8b 56       	subi	r24, 0x6B	; 107
    8a06:	9f 4a       	sbci	r25, 0xAF	; 175
    8a08:	fc 01       	movw	r30, r24
    8a0a:	80 81       	ld	r24, Z
    8a0c:	8e 32       	cpi	r24, 0x2E	; 46
    8a0e:	39 f0       	breq	.+14     	; 0x8a1e <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8a10:	8a 81       	ldd	r24, Y+2	; 0x02
    8a12:	8f 5f       	subi	r24, 0xFF	; 255
    8a14:	8a 83       	std	Y+2, r24	; 0x02
    8a16:	8a 81       	ldd	r24, Y+2	; 0x02
    8a18:	8c 30       	cpi	r24, 0x0C	; 12
    8a1a:	88 f3       	brcs	.-30     	; 0x89fe <convertFileName+0xa8>
    8a1c:	01 c0       	rjmp	.+2      	; 0x8a20 <convertFileName+0xca>
if(Filename[j] == '.') break;
    8a1e:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8a20:	8a 81       	ldd	r24, Y+2	; 0x02
    8a22:	89 30       	cpi	r24, 0x09	; 9
    8a24:	28 f0       	brcs	.+10     	; 0x8a30 <convertFileName+0xda>
    8a26:	8a 81       	ldd	r24, Y+2	; 0x02
    8a28:	8c 30       	cpi	r24, 0x0C	; 12
    8a2a:	10 f4       	brcc	.+4      	; 0x8a30 <convertFileName+0xda>
	return 1;}
    8a2c:	81 e0       	ldi	r24, 0x01	; 1
    8a2e:	c3 c0       	rjmp	.+390    	; 0x8bb6 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8a30:	8a 81       	ldd	r24, Y+2	; 0x02
    8a32:	8c 30       	cpi	r24, 0x0C	; 12
    8a34:	11 f4       	brne	.+4      	; 0x8a3a <convertFileName+0xe4>
    8a36:	81 e0       	ldi	r24, 0x01	; 1
    8a38:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8a3a:	1b 82       	std	Y+3, r1	; 0x03
    8a3c:	14 c0       	rjmp	.+40     	; 0x8a66 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    8a40:	88 2f       	mov	r24, r24
    8a42:	90 e0       	ldi	r25, 0x00	; 0
    8a44:	2b 81       	ldd	r18, Y+3	; 0x03
    8a46:	22 2f       	mov	r18, r18
    8a48:	30 e0       	ldi	r19, 0x00	; 0
    8a4a:	2b 56       	subi	r18, 0x6B	; 107
    8a4c:	3f 4a       	sbci	r19, 0xAF	; 175
    8a4e:	f9 01       	movw	r30, r18
    8a50:	40 81       	ld	r20, Z
    8a52:	9e 01       	movw	r18, r28
    8a54:	2a 5f       	subi	r18, 0xFA	; 250
    8a56:	3f 4f       	sbci	r19, 0xFF	; 255
    8a58:	82 0f       	add	r24, r18
    8a5a:	93 1f       	adc	r25, r19
    8a5c:	fc 01       	movw	r30, r24
    8a5e:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8a60:	8b 81       	ldd	r24, Y+3	; 0x03
    8a62:	8f 5f       	subi	r24, 0xFF	; 255
    8a64:	8b 83       	std	Y+3, r24	; 0x03
    8a66:	9b 81       	ldd	r25, Y+3	; 0x03
    8a68:	8a 81       	ldd	r24, Y+2	; 0x02
    8a6a:	98 17       	cp	r25, r24
    8a6c:	40 f3       	brcs	.-48     	; 0x8a3e <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    8a70:	8b 83       	std	Y+3, r24	; 0x03
    8a72:	0e c0       	rjmp	.+28     	; 0x8a90 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8a74:	8b 81       	ldd	r24, Y+3	; 0x03
    8a76:	88 2f       	mov	r24, r24
    8a78:	90 e0       	ldi	r25, 0x00	; 0
    8a7a:	9e 01       	movw	r18, r28
    8a7c:	2a 5f       	subi	r18, 0xFA	; 250
    8a7e:	3f 4f       	sbci	r19, 0xFF	; 255
    8a80:	82 0f       	add	r24, r18
    8a82:	93 1f       	adc	r25, r19
    8a84:	20 e2       	ldi	r18, 0x20	; 32
    8a86:	fc 01       	movw	r30, r24
    8a88:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    8a8c:	8f 5f       	subi	r24, 0xFF	; 255
    8a8e:	8b 83       	std	Y+3, r24	; 0x03
    8a90:	8b 81       	ldd	r24, Y+3	; 0x03
    8a92:	88 30       	cpi	r24, 0x08	; 8
    8a94:	78 f3       	brcs	.-34     	; 0x8a74 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8a96:	99 81       	ldd	r25, Y+1	; 0x01
    8a98:	81 e0       	ldi	r24, 0x01	; 1
    8a9a:	89 27       	eor	r24, r25
    8a9c:	88 23       	and	r24, r24
    8a9e:	19 f0       	breq	.+6      	; 0x8aa6 <convertFileName+0x150>
    8aa0:	8a 81       	ldd	r24, Y+2	; 0x02
    8aa2:	8f 5f       	subi	r24, 0xFF	; 255
    8aa4:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8aa6:	88 e0       	ldi	r24, 0x08	; 8
    8aa8:	8b 83       	std	Y+3, r24	; 0x03
    8aaa:	32 c0       	rjmp	.+100    	; 0x8b10 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8aac:	8a 81       	ldd	r24, Y+2	; 0x02
    8aae:	88 2f       	mov	r24, r24
    8ab0:	90 e0       	ldi	r25, 0x00	; 0
    8ab2:	8b 56       	subi	r24, 0x6B	; 107
    8ab4:	9f 4a       	sbci	r25, 0xAF	; 175
    8ab6:	fc 01       	movw	r30, r24
    8ab8:	80 81       	ld	r24, Z
    8aba:	88 23       	and	r24, r24
    8abc:	19 f1       	breq	.+70     	; 0x8b04 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8abe:	8b 81       	ldd	r24, Y+3	; 0x03
    8ac0:	88 2f       	mov	r24, r24
    8ac2:	90 e0       	ldi	r25, 0x00	; 0
    8ac4:	2a 81       	ldd	r18, Y+2	; 0x02
    8ac6:	22 2f       	mov	r18, r18
    8ac8:	30 e0       	ldi	r19, 0x00	; 0
    8aca:	2b 56       	subi	r18, 0x6B	; 107
    8acc:	3f 4a       	sbci	r19, 0xAF	; 175
    8ace:	f9 01       	movw	r30, r18
    8ad0:	40 81       	ld	r20, Z
    8ad2:	9e 01       	movw	r18, r28
    8ad4:	2a 5f       	subi	r18, 0xFA	; 250
    8ad6:	3f 4f       	sbci	r19, 0xFF	; 255
    8ad8:	82 0f       	add	r24, r18
    8ada:	93 1f       	adc	r25, r19
    8adc:	fc 01       	movw	r30, r24
    8ade:	40 83       	st	Z, r20
    8ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    8ae2:	8f 5f       	subi	r24, 0xFF	; 255
    8ae4:	8a 83       	std	Y+2, r24	; 0x02
    8ae6:	11 c0       	rjmp	.+34     	; 0x8b0a <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    8aea:	88 2f       	mov	r24, r24
    8aec:	90 e0       	ldi	r25, 0x00	; 0
    8aee:	9e 01       	movw	r18, r28
    8af0:	2a 5f       	subi	r18, 0xFA	; 250
    8af2:	3f 4f       	sbci	r19, 0xFF	; 255
    8af4:	82 0f       	add	r24, r18
    8af6:	93 1f       	adc	r25, r19
    8af8:	20 e2       	ldi	r18, 0x20	; 32
    8afa:	fc 01       	movw	r30, r24
    8afc:	20 83       	st	Z, r18
    8afe:	8b 81       	ldd	r24, Y+3	; 0x03
    8b00:	8f 5f       	subi	r24, 0xFF	; 255
    8b02:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8b04:	8b 81       	ldd	r24, Y+3	; 0x03
    8b06:	8b 30       	cpi	r24, 0x0B	; 11
    8b08:	78 f3       	brcs	.-34     	; 0x8ae8 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    8b0c:	8f 5f       	subi	r24, 0xFF	; 255
    8b0e:	8b 83       	std	Y+3, r24	; 0x03
    8b10:	8b 81       	ldd	r24, Y+3	; 0x03
    8b12:	8b 30       	cpi	r24, 0x0B	; 11
    8b14:	58 f2       	brcs	.-106    	; 0x8aac <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8b16:	1a 82       	std	Y+2, r1	; 0x02
    8b18:	31 c0       	rjmp	.+98     	; 0x8b7c <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8b1a:	8a 81       	ldd	r24, Y+2	; 0x02
    8b1c:	88 2f       	mov	r24, r24
    8b1e:	90 e0       	ldi	r25, 0x00	; 0
    8b20:	9e 01       	movw	r18, r28
    8b22:	2a 5f       	subi	r18, 0xFA	; 250
    8b24:	3f 4f       	sbci	r19, 0xFF	; 255
    8b26:	82 0f       	add	r24, r18
    8b28:	93 1f       	adc	r25, r19
    8b2a:	fc 01       	movw	r30, r24
    8b2c:	80 81       	ld	r24, Z
    8b2e:	81 36       	cpi	r24, 0x61	; 97
    8b30:	10 f1       	brcs	.+68     	; 0x8b76 <convertFileName+0x220>
    8b32:	8a 81       	ldd	r24, Y+2	; 0x02
    8b34:	88 2f       	mov	r24, r24
    8b36:	90 e0       	ldi	r25, 0x00	; 0
    8b38:	9e 01       	movw	r18, r28
    8b3a:	2a 5f       	subi	r18, 0xFA	; 250
    8b3c:	3f 4f       	sbci	r19, 0xFF	; 255
    8b3e:	82 0f       	add	r24, r18
    8b40:	93 1f       	adc	r25, r19
    8b42:	fc 01       	movw	r30, r24
    8b44:	80 81       	ld	r24, Z
    8b46:	8b 37       	cpi	r24, 0x7B	; 123
    8b48:	b0 f4       	brcc	.+44     	; 0x8b76 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8b4a:	8a 81       	ldd	r24, Y+2	; 0x02
    8b4c:	88 2f       	mov	r24, r24
    8b4e:	90 e0       	ldi	r25, 0x00	; 0
    8b50:	2a 81       	ldd	r18, Y+2	; 0x02
    8b52:	22 2f       	mov	r18, r18
    8b54:	30 e0       	ldi	r19, 0x00	; 0
    8b56:	ae 01       	movw	r20, r28
    8b58:	4a 5f       	subi	r20, 0xFA	; 250
    8b5a:	5f 4f       	sbci	r21, 0xFF	; 255
    8b5c:	24 0f       	add	r18, r20
    8b5e:	35 1f       	adc	r19, r21
    8b60:	f9 01       	movw	r30, r18
    8b62:	20 81       	ld	r18, Z
    8b64:	42 2f       	mov	r20, r18
    8b66:	40 52       	subi	r20, 0x20	; 32
    8b68:	9e 01       	movw	r18, r28
    8b6a:	2a 5f       	subi	r18, 0xFA	; 250
    8b6c:	3f 4f       	sbci	r19, 0xFF	; 255
    8b6e:	82 0f       	add	r24, r18
    8b70:	93 1f       	adc	r25, r19
    8b72:	fc 01       	movw	r30, r24
    8b74:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8b76:	8a 81       	ldd	r24, Y+2	; 0x02
    8b78:	8f 5f       	subi	r24, 0xFF	; 255
    8b7a:	8a 83       	std	Y+2, r24	; 0x02
    8b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    8b7e:	8b 30       	cpi	r24, 0x0B	; 11
    8b80:	60 f2       	brcs	.-104    	; 0x8b1a <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8b82:	1a 82       	std	Y+2, r1	; 0x02
    8b84:	14 c0       	rjmp	.+40     	; 0x8bae <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8b86:	8a 81       	ldd	r24, Y+2	; 0x02
    8b88:	88 2f       	mov	r24, r24
    8b8a:	90 e0       	ldi	r25, 0x00	; 0
    8b8c:	2a 81       	ldd	r18, Y+2	; 0x02
    8b8e:	22 2f       	mov	r18, r18
    8b90:	30 e0       	ldi	r19, 0x00	; 0
    8b92:	ae 01       	movw	r20, r28
    8b94:	4a 5f       	subi	r20, 0xFA	; 250
    8b96:	5f 4f       	sbci	r21, 0xFF	; 255
    8b98:	24 0f       	add	r18, r20
    8b9a:	35 1f       	adc	r19, r21
    8b9c:	f9 01       	movw	r30, r18
    8b9e:	20 81       	ld	r18, Z
    8ba0:	8b 56       	subi	r24, 0x6B	; 107
    8ba2:	9f 4a       	sbci	r25, 0xAF	; 175
    8ba4:	fc 01       	movw	r30, r24
    8ba6:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    8baa:	8f 5f       	subi	r24, 0xFF	; 255
    8bac:	8a 83       	std	Y+2, r24	; 0x02
    8bae:	8a 81       	ldd	r24, Y+2	; 0x02
    8bb0:	8b 30       	cpi	r24, 0x0B	; 11
    8bb2:	48 f3       	brcs	.-46     	; 0x8b86 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8bb4:	80 e0       	ldi	r24, 0x00	; 0
}
    8bb6:	62 96       	adiw	r28, 0x12	; 18
    8bb8:	cd bf       	out	0x3d, r28	; 61
    8bba:	de bf       	out	0x3e, r29	; 62
    8bbc:	df 91       	pop	r29
    8bbe:	cf 91       	pop	r28
    8bc0:	08 95       	ret

00008bc2 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName){
    8bc2:	ef 92       	push	r14
    8bc4:	ff 92       	push	r15
    8bc6:	0f 93       	push	r16
    8bc8:	1f 93       	push	r17
    8bca:	cf 93       	push	r28
    8bcc:	df 93       	push	r29
    8bce:	cd b7       	in	r28, 0x3d	; 61
    8bd0:	de b7       	in	r29, 0x3e	; 62
    8bd2:	a9 97       	sbiw	r28, 0x29	; 41
    8bd4:	cd bf       	out	0x3d, r28	; 61
    8bd6:	de bf       	out	0x3e, r29	; 62
    8bd8:	88 a7       	lds	r24, 0x78
    8bda:	99 a7       	lds	r25, 0x79
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8bdc:	1a 82       	std	Y+2, r1	; 0x02
    8bde:	1b 82       	std	Y+3, r1	; 0x03
    8be0:	1c 82       	std	Y+4, r1	; 0x04
    8be2:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8be4:	1e 82       	std	Y+6, r1	; 0x06
    8be6:	1f 82       	std	Y+7, r1	; 0x07
    8be8:	18 86       	std	Y+8, r1	; 0x08
    8bea:	19 86       	std	Y+9, r1	; 0x09
    8bec:	1a 86       	std	Y+10, r1	; 0x0a
    8bee:	1b 86       	std	Y+11, r1	; 0x0b
if(strlen(fileName) > 15) return 1;
for(int i=0; i < strlen(fileName); i++){
	Filename[i] = fileName[i];
}
*/
j = readFile (VERIFY, fileName);
    8bf0:	28 a5       	lds	r18, 0x68
    8bf2:	39 a5       	lds	r19, 0x69
    8bf4:	81 e0       	ldi	r24, 0x01	; 1
    8bf6:	b9 01       	movw	r22, r18
    8bf8:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <readFile>
    8bfc:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8bfe:	89 81       	ldd	r24, Y+1	; 0x01
    8c00:	81 30       	cpi	r24, 0x01	; 1
    8c02:	09 f0       	breq	.+2      	; 0x8c06 <writeFile+0x44>
    8c04:	84 c0       	rjmp	.+264    	; 0x8d0e <writeFile+0x14c>
{
  //File already exists, appending data
  appendFile = 1;
    8c06:	81 e0       	ldi	r24, 0x01	; 1
    8c08:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8c0a:	80 91 61 50 	lds	r24, 0x5061
    8c0e:	90 91 62 50 	lds	r25, 0x5062
    8c12:	a0 91 63 50 	lds	r26, 0x5063
    8c16:	b0 91 64 50 	lds	r27, 0x5064
    8c1a:	8c 87       	std	Y+12, r24	; 0x0c
    8c1c:	9d 87       	std	Y+13, r25	; 0x0d
    8c1e:	ae 87       	std	Y+14, r26	; 0x0e
    8c20:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8c22:	1c 8a       	std	Y+20, r1	; 0x14
    8c24:	1d 8a       	std	Y+21, r1	; 0x15
    8c26:	1e 8a       	std	Y+22, r1	; 0x16
    8c28:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8c2a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c2c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8c2e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8c30:	bf 85       	ldd	r27, Y+15	; 0x0f
    8c32:	bc 01       	movw	r22, r24
    8c34:	cd 01       	movw	r24, r26
    8c36:	40 e0       	ldi	r20, 0x00	; 0
    8c38:	00 e0       	ldi	r16, 0x00	; 0
    8c3a:	10 e0       	ldi	r17, 0x00	; 0
    8c3c:	98 01       	movw	r18, r16
    8c3e:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
    8c42:	dc 01       	movw	r26, r24
    8c44:	cb 01       	movw	r24, r22
    8c46:	8a 8f       	std	Y+26, r24	; 0x1a
    8c48:	9b 8f       	std	Y+27, r25	; 0x1b
    8c4a:	ac 8f       	std	Y+28, r26	; 0x1c
    8c4c:	bd 8f       	std	Y+29, r27	; 0x1d
    if(nextCluster == EOF) break;
    8c4e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8c50:	9b 8d       	ldd	r25, Y+27	; 0x1b
    8c52:	ac 8d       	ldd	r26, Y+28	; 0x1c
    8c54:	bd 8d       	ldd	r27, Y+29	; 0x1d
    8c56:	8f 3f       	cpi	r24, 0xFF	; 255
    8c58:	0f ef       	ldi	r16, 0xFF	; 255
    8c5a:	90 07       	cpc	r25, r16
    8c5c:	0f ef       	ldi	r16, 0xFF	; 255
    8c5e:	a0 07       	cpc	r26, r16
    8c60:	0f e0       	ldi	r16, 0x0F	; 15
    8c62:	b0 07       	cpc	r27, r16
    8c64:	a1 f0       	breq	.+40     	; 0x8c8e <writeFile+0xcc>
	cluster = nextCluster;
    8c66:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8c68:	9b 8d       	ldd	r25, Y+27	; 0x1b
    8c6a:	ac 8d       	ldd	r26, Y+28	; 0x1c
    8c6c:	bd 8d       	ldd	r27, Y+29	; 0x1d
    8c6e:	8c 87       	std	Y+12, r24	; 0x0c
    8c70:	9d 87       	std	Y+13, r25	; 0x0d
    8c72:	ae 87       	std	Y+14, r26	; 0x0e
    8c74:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8c76:	8c 89       	ldd	r24, Y+20	; 0x14
    8c78:	9d 89       	ldd	r25, Y+21	; 0x15
    8c7a:	ae 89       	ldd	r26, Y+22	; 0x16
    8c7c:	bf 89       	ldd	r27, Y+23	; 0x17
    8c7e:	01 96       	adiw	r24, 0x01	; 1
    8c80:	a1 1d       	adc	r26, r1
    8c82:	b1 1d       	adc	r27, r1
    8c84:	8c 8b       	std	Y+20, r24	; 0x14
    8c86:	9d 8b       	std	Y+21, r25	; 0x15
    8c88:	ae 8b       	std	Y+22, r26	; 0x16
    8c8a:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8c8c:	ce cf       	rjmp	.-100    	; 0x8c2a <writeFile+0x68>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8c8e:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8c90:	e0 90 31 40 	lds	r14, 0x4031
    8c94:	f0 90 32 40 	lds	r15, 0x4032
    8c98:	00 91 33 40 	lds	r16, 0x4033
    8c9c:	10 91 34 40 	lds	r17, 0x4034
    8ca0:	80 91 55 50 	lds	r24, 0x5055
    8ca4:	90 91 56 50 	lds	r25, 0x5056
    8ca8:	cc 01       	movw	r24, r24
    8caa:	a0 e0       	ldi	r26, 0x00	; 0
    8cac:	b0 e0       	ldi	r27, 0x00	; 0
    8cae:	2c 89       	ldd	r18, Y+20	; 0x14
    8cb0:	3d 89       	ldd	r19, Y+21	; 0x15
    8cb2:	4e 89       	ldd	r20, Y+22	; 0x16
    8cb4:	5f 89       	ldd	r21, Y+23	; 0x17
    8cb6:	bc 01       	movw	r22, r24
    8cb8:	cd 01       	movw	r24, r26
    8cba:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    8cbe:	dc 01       	movw	r26, r24
    8cc0:	cb 01       	movw	r24, r22
    8cc2:	20 91 35 40 	lds	r18, 0x4035
    8cc6:	30 91 36 40 	lds	r19, 0x4036
    8cca:	99 01       	movw	r18, r18
    8ccc:	40 e0       	ldi	r20, 0x00	; 0
    8cce:	50 e0       	ldi	r21, 0x00	; 0
    8cd0:	bc 01       	movw	r22, r24
    8cd2:	cd 01       	movw	r24, r26
    8cd4:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    8cd8:	dc 01       	movw	r26, r24
    8cda:	cb 01       	movw	r24, r22
    8cdc:	a8 01       	movw	r20, r16
    8cde:	97 01       	movw	r18, r14
    8ce0:	28 1b       	sub	r18, r24
    8ce2:	39 0b       	sbc	r19, r25
    8ce4:	4a 0b       	sbc	r20, r26
    8ce6:	5b 0b       	sbc	r21, r27
    8ce8:	da 01       	movw	r26, r20
    8cea:	c9 01       	movw	r24, r18
    8cec:	20 91 35 40 	lds	r18, 0x4035
    8cf0:	30 91 36 40 	lds	r19, 0x4036
    8cf4:	99 01       	movw	r18, r18
    8cf6:	40 e0       	ldi	r20, 0x00	; 0
    8cf8:	50 e0       	ldi	r21, 0x00	; 0
    8cfa:	bc 01       	movw	r22, r24
    8cfc:	cd 01       	movw	r24, r26
    8cfe:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    8d02:	da 01       	movw	r26, r20
    8d04:	c9 01       	movw	r24, r18
    8d06:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8d08:	81 e0       	ldi	r24, 0x01	; 1
    8d0a:	8b 83       	std	Y+3, r24	; 0x03
    8d0c:	69 c0       	rjmp	.+210    	; 0x8de0 <writeFile+0x21e>
}
else if(j == 2) 
    8d0e:	89 81       	ldd	r24, Y+1	; 0x01
    8d10:	82 30       	cpi	r24, 0x02	; 2
    8d12:	11 f4       	brne	.+4      	; 0x8d18 <writeFile+0x156>
   return 1; //invalid file name
    8d14:	81 e0       	ldi	r24, 0x01	; 1
    8d16:	b4 c2       	rjmp	.+1384   	; 0x9280 <writeFile+0x6be>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8d18:	82 e0       	ldi	r24, 0x02	; 2
    8d1a:	60 e0       	ldi	r22, 0x00	; 0
    8d1c:	20 e0       	ldi	r18, 0x00	; 0
    8d1e:	30 e0       	ldi	r19, 0x00	; 0
    8d20:	a9 01       	movw	r20, r18
    8d22:	0e 94 71 41 	call	0x82e2	; 0x82e2 <getSetFreeCluster>
    8d26:	dc 01       	movw	r26, r24
    8d28:	cb 01       	movw	r24, r22
    8d2a:	8c 87       	std	Y+12, r24	; 0x0c
    8d2c:	9d 87       	std	Y+13, r25	; 0x0d
    8d2e:	ae 87       	std	Y+14, r26	; 0x0e
    8d30:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8d32:	80 91 3a 40 	lds	r24, 0x403A
    8d36:	90 91 3b 40 	lds	r25, 0x403B
    8d3a:	a0 91 3c 40 	lds	r26, 0x403C
    8d3e:	b0 91 3d 40 	lds	r27, 0x403D
    8d42:	2c 85       	ldd	r18, Y+12	; 0x0c
    8d44:	3d 85       	ldd	r19, Y+13	; 0x0d
    8d46:	4e 85       	ldd	r20, Y+14	; 0x0e
    8d48:	5f 85       	ldd	r21, Y+15	; 0x0f
    8d4a:	82 17       	cp	r24, r18
    8d4c:	93 07       	cpc	r25, r19
    8d4e:	a4 07       	cpc	r26, r20
    8d50:	b5 07       	cpc	r27, r21
    8d52:	60 f4       	brcc	.+24     	; 0x8d6c <writeFile+0x1aa>
     cluster = rootCluster;
    8d54:	80 91 3f 40 	lds	r24, 0x403F
    8d58:	90 91 40 40 	lds	r25, 0x4040
    8d5c:	a0 91 41 40 	lds	r26, 0x4041
    8d60:	b0 91 42 40 	lds	r27, 0x4042
    8d64:	8c 87       	std	Y+12, r24	; 0x0c
    8d66:	9d 87       	std	Y+13, r25	; 0x0d
    8d68:	ae 87       	std	Y+14, r26	; 0x0e
    8d6a:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8d6c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d6e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d70:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d72:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d74:	bc 01       	movw	r22, r24
    8d76:	cd 01       	movw	r24, r26
    8d78:	0e 94 4a 49 	call	0x9294	; 0x9294 <searchNextFreeCluster>
    8d7c:	dc 01       	movw	r26, r24
    8d7e:	cb 01       	movw	r24, r22
    8d80:	8c 87       	std	Y+12, r24	; 0x0c
    8d82:	9d 87       	std	Y+13, r25	; 0x0d
    8d84:	ae 87       	std	Y+14, r26	; 0x0e
    8d86:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8d88:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d8c:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d8e:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d90:	00 97       	sbiw	r24, 0x00	; 0
    8d92:	a1 05       	cpc	r26, r1
    8d94:	b1 05       	cpc	r27, r1
    8d96:	11 f4       	brne	.+4      	; 0x8d9c <writeFile+0x1da>
   {
	   // No free cluster!
	  return 2;
    8d98:	82 e0       	ldi	r24, 0x02	; 2
    8d9a:	72 c2       	rjmp	.+1252   	; 0x9280 <writeFile+0x6be>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8d9c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d9e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8da0:	ae 85       	ldd	r26, Y+14	; 0x0e
    8da2:	bf 85       	ldd	r27, Y+15	; 0x0f
    8da4:	bc 01       	movw	r22, r24
    8da6:	cd 01       	movw	r24, r26
    8da8:	41 e0       	ldi	r20, 0x01	; 1
    8daa:	0f ef       	ldi	r16, 0xFF	; 255
    8dac:	1f ef       	ldi	r17, 0xFF	; 255
    8dae:	2f ef       	ldi	r18, 0xFF	; 255
    8db0:	3f e0       	ldi	r19, 0x0F	; 15
    8db2:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8db6:	8c 85       	ldd	r24, Y+12	; 0x0c
    8db8:	9d 85       	ldd	r25, Y+13	; 0x0d
    8dba:	ae 85       	ldd	r26, Y+14	; 0x0e
    8dbc:	bf 85       	ldd	r27, Y+15	; 0x0f
    8dbe:	cd 01       	movw	r24, r26
    8dc0:	aa 27       	eor	r26, r26
    8dc2:	bb 27       	eor	r27, r27
    8dc4:	8e 83       	std	Y+6, r24	; 0x06
    8dc6:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8dc8:	8c 85       	ldd	r24, Y+12	; 0x0c
    8dca:	9d 85       	ldd	r25, Y+13	; 0x0d
    8dcc:	88 87       	std	Y+8, r24	; 0x08
    8dce:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8dd0:	10 92 31 40 	sts	0x4031, r1
    8dd4:	10 92 32 40 	sts	0x4032, r1
    8dd8:	10 92 33 40 	sts	0x4033, r1
    8ddc:	10 92 34 40 	sts	0x4034, r1
}

//start writing data here
if(start){
    8de0:	8b 81       	ldd	r24, Y+3	; 0x03
    8de2:	88 23       	and	r24, r24
    8de4:	11 f1       	breq	.+68     	; 0x8e2a <writeFile+0x268>
      start = 0;
    8de6:	1b 82       	std	Y+3, r1	; 0x03
	  startBlock = getFirstSector (cluster) + sector;
    8de8:	8c 85       	ldd	r24, Y+12	; 0x0c
    8dea:	9d 85       	ldd	r25, Y+13	; 0x0d
    8dec:	ae 85       	ldd	r26, Y+14	; 0x0e
    8dee:	bf 85       	ldd	r27, Y+15	; 0x0f
    8df0:	bc 01       	movw	r22, r24
    8df2:	cd 01       	movw	r24, r26
    8df4:	0e 94 95 40 	call	0x812a	; 0x812a <getFirstSector>
    8df8:	dc 01       	movw	r26, r24
    8dfa:	cb 01       	movw	r24, r22
    8dfc:	9c 01       	movw	r18, r24
    8dfe:	8d 81       	ldd	r24, Y+5	; 0x05
    8e00:	88 2f       	mov	r24, r24
    8e02:	90 e0       	ldi	r25, 0x00	; 0
    8e04:	82 0f       	add	r24, r18
    8e06:	93 1f       	adc	r25, r19
    8e08:	8a 87       	std	Y+10, r24	; 0x0a
    8e0a:	9b 87       	std	Y+11, r25	; 0x0b
	  SD_read_block (startBlock,SDBuffer);
    8e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e10:	cc 01       	movw	r24, r24
    8e12:	a0 e0       	ldi	r26, 0x00	; 0
    8e14:	b0 e0       	ldi	r27, 0x00	; 0
    8e16:	27 eb       	ldi	r18, 0xB7	; 183
    8e18:	31 e2       	ldi	r19, 0x21	; 33
    8e1a:	bc 01       	movw	r22, r24
    8e1c:	cd 01       	movw	r24, r26
    8e1e:	a9 01       	movw	r20, r18
    8e20:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
	  j = sector;
    8e24:	8d 81       	ldd	r24, Y+5	; 0x05
    8e26:	89 83       	std	Y+1, r24	; 0x01
    8e28:	0d c0       	rjmp	.+26     	; 0x8e44 <writeFile+0x282>
   }
   else{
      startBlock = getFirstSector (cluster);
    8e2a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e2c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e2e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e30:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e32:	bc 01       	movw	r22, r24
    8e34:	cd 01       	movw	r24, r26
    8e36:	0e 94 95 40 	call	0x812a	; 0x812a <getFirstSector>
    8e3a:	dc 01       	movw	r26, r24
    8e3c:	cb 01       	movw	r24, r22
    8e3e:	8a 87       	std	Y+10, r24	; 0x0a
    8e40:	9b 87       	std	Y+11, r25	; 0x0b
	  j=0;
    8e42:	19 82       	std	Y+1, r1	; 0x01
   }
//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes   
fileSize += 512;
    8e44:	80 91 31 40 	lds	r24, 0x4031
    8e48:	90 91 32 40 	lds	r25, 0x4032
    8e4c:	a0 91 33 40 	lds	r26, 0x4033
    8e50:	b0 91 34 40 	lds	r27, 0x4034
    8e54:	80 50       	subi	r24, 0x00	; 0
    8e56:	9e 4f       	sbci	r25, 0xFE	; 254
    8e58:	af 4f       	sbci	r26, 0xFF	; 255
    8e5a:	bf 4f       	sbci	r27, 0xFF	; 255
    8e5c:	80 93 31 40 	sts	0x4031, r24
    8e60:	90 93 32 40 	sts	0x4032, r25
    8e64:	a0 93 33 40 	sts	0x4033, r26
    8e68:	b0 93 34 40 	sts	0x4034, r27
SD_write_block (startBlock,FRAMReadBuffer,512);
    8e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e70:	cc 01       	movw	r24, r24
    8e72:	a0 e0       	ldi	r26, 0x00	; 0
    8e74:	b0 e0       	ldi	r27, 0x00	; 0
    8e76:	20 ec       	ldi	r18, 0xC0	; 192
    8e78:	33 e2       	ldi	r19, 0x23	; 35
    8e7a:	bc 01       	movw	r22, r24
    8e7c:	cd 01       	movw	r24, r26
    8e7e:	a9 01       	movw	r20, r18
    8e80:	20 e0       	ldi	r18, 0x00	; 0
    8e82:	32 e0       	ldi	r19, 0x02	; 2
    8e84:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_write_block>
j++;
    8e88:	89 81       	ldd	r24, Y+1	; 0x01
    8e8a:	8f 5f       	subi	r24, 0xFF	; 255
    8e8c:	89 83       	std	Y+1, r24	; 0x01
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
    8e8e:	89 81       	ldd	r24, Y+1	; 0x01
    8e90:	28 2f       	mov	r18, r24
    8e92:	30 e0       	ldi	r19, 0x00	; 0
    8e94:	80 91 55 50 	lds	r24, 0x5055
    8e98:	90 91 56 50 	lds	r25, 0x5056
    8e9c:	28 17       	cp	r18, r24
    8e9e:	39 07       	cpc	r19, r25
    8ea0:	e1 f5       	brne	.+120    	; 0x8f1a <writeFile+0x358>
	j = 0; 
    8ea2:	19 82       	std	Y+1, r1	; 0x01
 
	prevCluster = cluster;
    8ea4:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ea6:	9d 85       	ldd	r25, Y+13	; 0x0d
    8ea8:	ae 85       	ldd	r26, Y+14	; 0x0e
    8eaa:	bf 85       	ldd	r27, Y+15	; 0x0f
    8eac:	88 8b       	std	Y+16, r24	; 0x10
    8eae:	99 8b       	std	Y+17, r25	; 0x11
    8eb0:	aa 8b       	std	Y+18, r26	; 0x12
    8eb2:	bb 8b       	std	Y+19, r27	; 0x13
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    8eb4:	88 89       	ldd	r24, Y+16	; 0x10
    8eb6:	99 89       	ldd	r25, Y+17	; 0x11
    8eb8:	aa 89       	ldd	r26, Y+18	; 0x12
    8eba:	bb 89       	ldd	r27, Y+19	; 0x13
    8ebc:	bc 01       	movw	r22, r24
    8ebe:	cd 01       	movw	r24, r26
    8ec0:	0e 94 4a 49 	call	0x9294	; 0x9294 <searchNextFreeCluster>
    8ec4:	dc 01       	movw	r26, r24
    8ec6:	cb 01       	movw	r24, r22
    8ec8:	8c 87       	std	Y+12, r24	; 0x0c
    8eca:	9d 87       	std	Y+13, r25	; 0x0d
    8ecc:	ae 87       	std	Y+14, r26	; 0x0e
    8ece:	bf 87       	std	Y+15, r27	; 0x0f
	if(cluster == 0){
    8ed0:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ed2:	9d 85       	ldd	r25, Y+13	; 0x0d
    8ed4:	ae 85       	ldd	r26, Y+14	; 0x0e
    8ed6:	bf 85       	ldd	r27, Y+15	; 0x0f
    8ed8:	00 97       	sbiw	r24, 0x00	; 0
    8eda:	a1 05       	cpc	r26, r1
    8edc:	b1 05       	cpc	r27, r1
    8ede:	11 f4       	brne	.+4      	; 0x8ee4 <writeFile+0x322>
      //No free cluster!
	  return 2;
    8ee0:	82 e0       	ldi	r24, 0x02	; 2
    8ee2:	ce c1       	rjmp	.+924    	; 0x9280 <writeFile+0x6be>
   }
	getSetNextCluster(prevCluster, SET, cluster);
    8ee4:	88 89       	ldd	r24, Y+16	; 0x10
    8ee6:	99 89       	ldd	r25, Y+17	; 0x11
    8ee8:	aa 89       	ldd	r26, Y+18	; 0x12
    8eea:	bb 89       	ldd	r27, Y+19	; 0x13
    8eec:	0c 85       	ldd	r16, Y+12	; 0x0c
    8eee:	1d 85       	ldd	r17, Y+13	; 0x0d
    8ef0:	2e 85       	ldd	r18, Y+14	; 0x0e
    8ef2:	3f 85       	ldd	r19, Y+15	; 0x0f
    8ef4:	bc 01       	movw	r22, r24
    8ef6:	cd 01       	movw	r24, r26
    8ef8:	41 e0       	ldi	r20, 0x01	; 1
    8efa:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
	getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    8efe:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f00:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f02:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f04:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f06:	bc 01       	movw	r22, r24
    8f08:	cd 01       	movw	r24, r26
    8f0a:	41 e0       	ldi	r20, 0x01	; 1
    8f0c:	0f ef       	ldi	r16, 0xFF	; 255
    8f0e:	1f ef       	ldi	r17, 0xFF	; 255
    8f10:	2f ef       	ldi	r18, 0xFF	; 255
    8f12:	3f e0       	ldi	r19, 0x0F	; 15
    8f14:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
    8f18:	05 c0       	rjmp	.+10     	; 0x8f24 <writeFile+0x362>
}
//otherwise increment the sector offset 
else startBlock++;       
    8f1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    8f1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    8f1e:	01 96       	adiw	r24, 0x01	; 1
    8f20:	8a 87       	std	Y+10, r24	; 0x0a
    8f22:	9b 87       	std	Y+11, r25	; 0x0b

getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    8f24:	2c 85       	ldd	r18, Y+12	; 0x0c
    8f26:	3d 85       	ldd	r19, Y+13	; 0x0d
    8f28:	4e 85       	ldd	r20, Y+14	; 0x0e
    8f2a:	5f 85       	ldd	r21, Y+15	; 0x0f
    8f2c:	82 e0       	ldi	r24, 0x02	; 2
    8f2e:	61 e0       	ldi	r22, 0x01	; 1
    8f30:	0e 94 71 41 	call	0x82e2	; 0x82e2 <getSetFreeCluster>

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    8f34:	8c 81       	ldd	r24, Y+4	; 0x04
    8f36:	88 23       	and	r24, r24
    8f38:	09 f4       	brne	.+2      	; 0x8f3c <writeFile+0x37a>
    8f3a:	66 c0       	rjmp	.+204    	; 0x9008 <writeFile+0x446>
{
  SD_read_block (appendFileSector,SDBuffer);    
    8f3c:	80 91 b9 50 	lds	r24, 0x50B9
    8f40:	90 91 ba 50 	lds	r25, 0x50BA
    8f44:	a0 91 bb 50 	lds	r26, 0x50BB
    8f48:	b0 91 bc 50 	lds	r27, 0x50BC
    8f4c:	27 eb       	ldi	r18, 0xB7	; 183
    8f4e:	31 e2       	ldi	r19, 0x21	; 33
    8f50:	bc 01       	movw	r22, r24
    8f52:	cd 01       	movw	r24, r26
    8f54:	a9 01       	movw	r20, r18
    8f56:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    8f5a:	80 91 b8 23 	lds	r24, 0x23B8
    8f5e:	90 91 b9 23 	lds	r25, 0x23B9
    8f62:	a0 91 ba 23 	lds	r26, 0x23BA
    8f66:	b0 91 bb 23 	lds	r27, 0x23BB
    8f6a:	89 54       	subi	r24, 0x49	; 73
    8f6c:	9e 4d       	sbci	r25, 0xDE	; 222
    8f6e:	8e 8f       	std	Y+30, r24	; 0x1e
    8f70:	9f 8f       	std	Y+31, r25	; 0x1f

  dir->lastAccessDate = 0;   //date of last access ignored
    8f72:	8e 8d       	ldd	r24, Y+30	; 0x1e
    8f74:	9f 8d       	ldd	r25, Y+31	; 0x1f
    8f76:	fc 01       	movw	r30, r24
    8f78:	12 8a       	std	Z+18, r1	; 0x12
    8f7a:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    8f7c:	20 91 31 40 	lds	r18, 0x4031
    8f80:	30 91 32 40 	lds	r19, 0x4032
    8f84:	40 91 33 40 	lds	r20, 0x4033
    8f88:	50 91 34 40 	lds	r21, 0x4034
    8f8c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    8f8e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    8f90:	fc 01       	movw	r30, r24
    8f92:	84 8d       	ldd	r24, Z+28	; 0x1c
    8f94:	95 8d       	ldd	r25, Z+29	; 0x1d
    8f96:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8f98:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8f9a:	79 01       	movw	r14, r18
    8f9c:	8a 01       	movw	r16, r20
    8f9e:	e8 1a       	sub	r14, r24
    8fa0:	f9 0a       	sbc	r15, r25
    8fa2:	0a 0b       	sbc	r16, r26
    8fa4:	1b 0b       	sbc	r17, r27
    8fa6:	d8 01       	movw	r26, r16
    8fa8:	c7 01       	movw	r24, r14
    8faa:	88 a3       	lds	r24, 0x58
    8fac:	99 a3       	lds	r25, 0x59
    8fae:	aa a3       	lds	r26, 0x5a
    8fb0:	bb a3       	lds	r27, 0x5b
  dir->fileSize = fileSize;
    8fb2:	80 91 31 40 	lds	r24, 0x4031
    8fb6:	90 91 32 40 	lds	r25, 0x4032
    8fba:	a0 91 33 40 	lds	r26, 0x4033
    8fbe:	b0 91 34 40 	lds	r27, 0x4034
    8fc2:	2e 8d       	ldd	r18, Y+30	; 0x1e
    8fc4:	3f 8d       	ldd	r19, Y+31	; 0x1f
    8fc6:	f9 01       	movw	r30, r18
    8fc8:	84 8f       	std	Z+28, r24	; 0x1c
    8fca:	95 8f       	std	Z+29, r25	; 0x1d
    8fcc:	a6 8f       	std	Z+30, r26	; 0x1e
    8fce:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    8fd0:	80 91 b9 50 	lds	r24, 0x50B9
    8fd4:	90 91 ba 50 	lds	r25, 0x50BA
    8fd8:	a0 91 bb 50 	lds	r26, 0x50BB
    8fdc:	b0 91 bc 50 	lds	r27, 0x50BC
    8fe0:	27 eb       	ldi	r18, 0xB7	; 183
    8fe2:	31 e2       	ldi	r19, 0x21	; 33
    8fe4:	bc 01       	movw	r22, r24
    8fe6:	cd 01       	movw	r24, r26
    8fe8:	a9 01       	movw	r20, r18
    8fea:	20 e0       	ldi	r18, 0x00	; 0
    8fec:	32 e0       	ldi	r19, 0x02	; 2
    8fee:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    8ff2:	28 a1       	lds	r18, 0x48
    8ff4:	39 a1       	lds	r19, 0x49
    8ff6:	4a a1       	lds	r20, 0x4a
    8ff8:	5b a1       	lds	r21, 0x4b
    8ffa:	81 e0       	ldi	r24, 0x01	; 1
    8ffc:	ba 01       	movw	r22, r20
    8ffe:	a9 01       	movw	r20, r18
    9000:	0e 94 23 4a 	call	0x9446	; 0x9446 <freeMemoryUpdate>

 //File appended!
  return 0;
    9004:	80 e0       	ldi	r24, 0x00	; 0
    9006:	3c c1       	rjmp	.+632    	; 0x9280 <writeFile+0x6be>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9008:	80 91 3f 40 	lds	r24, 0x403F
    900c:	90 91 40 40 	lds	r25, 0x4040
    9010:	a0 91 41 40 	lds	r26, 0x4041
    9014:	b0 91 42 40 	lds	r27, 0x4042
    9018:	88 8b       	std	Y+16, r24	; 0x10
    901a:	99 8b       	std	Y+17, r25	; 0x11
    901c:	aa 8b       	std	Y+18, r26	; 0x12
    901e:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    9020:	88 89       	ldd	r24, Y+16	; 0x10
    9022:	99 89       	ldd	r25, Y+17	; 0x11
    9024:	aa 89       	ldd	r26, Y+18	; 0x12
    9026:	bb 89       	ldd	r27, Y+19	; 0x13
    9028:	bc 01       	movw	r22, r24
    902a:	cd 01       	movw	r24, r26
    902c:	0e 94 95 40 	call	0x812a	; 0x812a <getFirstSector>
    9030:	dc 01       	movw	r26, r24
    9032:	cb 01       	movw	r24, r22
    9034:	8c a3       	lds	r24, 0x5c
    9036:	9d a3       	lds	r25, 0x5d
    9038:	ae a3       	lds	r26, 0x5e
    903a:	bf a3       	lds	r27, 0x5f

   for(sector = 0; sector < sectorPerCluster; sector++)
    903c:	1d 82       	std	Y+5, r1	; 0x05
    903e:	ad c0       	rjmp	.+346    	; 0x919a <writeFile+0x5d8>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    9040:	8d 81       	ldd	r24, Y+5	; 0x05
    9042:	28 2f       	mov	r18, r24
    9044:	30 e0       	ldi	r19, 0x00	; 0
    9046:	40 e0       	ldi	r20, 0x00	; 0
    9048:	50 e0       	ldi	r21, 0x00	; 0
    904a:	8c a1       	lds	r24, 0x4c
    904c:	9d a1       	lds	r25, 0x4d
    904e:	ae a1       	lds	r26, 0x4e
    9050:	bf a1       	lds	r27, 0x4f
    9052:	82 0f       	add	r24, r18
    9054:	93 1f       	adc	r25, r19
    9056:	a4 1f       	adc	r26, r20
    9058:	b5 1f       	adc	r27, r21
    905a:	27 eb       	ldi	r18, 0xB7	; 183
    905c:	31 e2       	ldi	r19, 0x21	; 33
    905e:	bc 01       	movw	r22, r24
    9060:	cd 01       	movw	r24, r26
    9062:	a9 01       	movw	r20, r18
    9064:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    9068:	18 8e       	std	Y+24, r1	; 0x18
    906a:	19 8e       	std	Y+25, r1	; 0x19
    906c:	89 c0       	rjmp	.+274    	; 0x9180 <writeFile+0x5be>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    906e:	88 8d       	ldd	r24, Y+24	; 0x18
    9070:	99 8d       	ldd	r25, Y+25	; 0x19
    9072:	89 54       	subi	r24, 0x49	; 73
    9074:	9e 4d       	sbci	r25, 0xDE	; 222
    9076:	8e 8f       	std	Y+30, r24	; 0x1e
    9078:	9f 8f       	std	Y+31, r25	; 0x1f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    907a:	8a 81       	ldd	r24, Y+2	; 0x02
    907c:	88 23       	and	r24, r24
    907e:	11 f0       	breq	.+4      	; 0x9084 <writeFile+0x4c2>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    9080:	80 e0       	ldi	r24, 0x00	; 0
    9082:	fe c0       	rjmp	.+508    	; 0x9280 <writeFile+0x6be>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    9084:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9086:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9088:	fc 01       	movw	r30, r24
    908a:	80 81       	ld	r24, Z
    908c:	88 23       	and	r24, r24
    908e:	39 f0       	breq	.+14     	; 0x909e <writeFile+0x4dc>
    9090:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9092:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9094:	fc 01       	movw	r30, r24
    9096:	80 81       	ld	r24, Z
    9098:	85 3e       	cpi	r24, 0xE5	; 229
    909a:	09 f0       	breq	.+2      	; 0x909e <writeFile+0x4dc>
    909c:	6c c0       	rjmp	.+216    	; 0x9176 <writeFile+0x5b4>
		{
		  for(j=0; j<11; j++)
    909e:	19 82       	std	Y+1, r1	; 0x01
    90a0:	13 c0       	rjmp	.+38     	; 0x90c8 <writeFile+0x506>
  			dir->name[j] = Filename[j];
    90a2:	89 81       	ldd	r24, Y+1	; 0x01
    90a4:	88 2f       	mov	r24, r24
    90a6:	90 e0       	ldi	r25, 0x00	; 0
    90a8:	29 81       	ldd	r18, Y+1	; 0x01
    90aa:	22 2f       	mov	r18, r18
    90ac:	30 e0       	ldi	r19, 0x00	; 0
    90ae:	2b 56       	subi	r18, 0x6B	; 107
    90b0:	3f 4a       	sbci	r19, 0xAF	; 175
    90b2:	f9 01       	movw	r30, r18
    90b4:	40 81       	ld	r20, Z
    90b6:	2e 8d       	ldd	r18, Y+30	; 0x1e
    90b8:	3f 8d       	ldd	r19, Y+31	; 0x1f
    90ba:	82 0f       	add	r24, r18
    90bc:	93 1f       	adc	r25, r19
    90be:	fc 01       	movw	r30, r24
    90c0:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    90c2:	89 81       	ldd	r24, Y+1	; 0x01
    90c4:	8f 5f       	subi	r24, 0xFF	; 255
    90c6:	89 83       	std	Y+1, r24	; 0x01
    90c8:	89 81       	ldd	r24, Y+1	; 0x01
    90ca:	8b 30       	cpi	r24, 0x0B	; 11
    90cc:	50 f3       	brcs	.-44     	; 0x90a2 <writeFile+0x4e0>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    90ce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    90d0:	9f 8d       	ldd	r25, Y+31	; 0x1f
    90d2:	20 e2       	ldi	r18, 0x20	; 32
    90d4:	fc 01       	movw	r30, r24
    90d6:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    90d8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    90da:	9f 8d       	ldd	r25, Y+31	; 0x1f
    90dc:	fc 01       	movw	r30, r24
    90de:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    90e0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    90e2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    90e4:	fc 01       	movw	r30, r24
    90e6:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    90e8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    90ea:	9f 8d       	ldd	r25, Y+31	; 0x1f
    90ec:	fc 01       	movw	r30, r24
    90ee:	12 8a       	std	Z+18, r1	; 0x12
    90f0:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    90f2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    90f4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    90f6:	2e 81       	ldd	r18, Y+6	; 0x06
    90f8:	3f 81       	ldd	r19, Y+7	; 0x07
    90fa:	fc 01       	movw	r30, r24
    90fc:	24 8b       	std	Z+20, r18	; 0x14
    90fe:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    9100:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9102:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9104:	28 85       	ldd	r18, Y+8	; 0x08
    9106:	39 85       	ldd	r19, Y+9	; 0x09
    9108:	fc 01       	movw	r30, r24
    910a:	22 8f       	std	Z+26, r18	; 0x1a
    910c:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    910e:	80 91 31 40 	lds	r24, 0x4031
    9112:	90 91 32 40 	lds	r25, 0x4032
    9116:	a0 91 33 40 	lds	r26, 0x4033
    911a:	b0 91 34 40 	lds	r27, 0x4034
    911e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    9120:	3f 8d       	ldd	r19, Y+31	; 0x1f
    9122:	f9 01       	movw	r30, r18
    9124:	84 8f       	std	Z+28, r24	; 0x1c
    9126:	95 8f       	std	Z+29, r25	; 0x1d
    9128:	a6 8f       	std	Z+30, r26	; 0x1e
    912a:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    912c:	8d 81       	ldd	r24, Y+5	; 0x05
    912e:	28 2f       	mov	r18, r24
    9130:	30 e0       	ldi	r19, 0x00	; 0
    9132:	40 e0       	ldi	r20, 0x00	; 0
    9134:	50 e0       	ldi	r21, 0x00	; 0
    9136:	8c a1       	lds	r24, 0x4c
    9138:	9d a1       	lds	r25, 0x4d
    913a:	ae a1       	lds	r26, 0x4e
    913c:	bf a1       	lds	r27, 0x4f
    913e:	82 0f       	add	r24, r18
    9140:	93 1f       	adc	r25, r19
    9142:	a4 1f       	adc	r26, r20
    9144:	b5 1f       	adc	r27, r21
    9146:	27 eb       	ldi	r18, 0xB7	; 183
    9148:	31 e2       	ldi	r19, 0x21	; 33
    914a:	bc 01       	movw	r22, r24
    914c:	cd 01       	movw	r24, r26
    914e:	a9 01       	movw	r20, r18
    9150:	20 e0       	ldi	r18, 0x00	; 0
    9152:	32 e0       	ldi	r19, 0x02	; 2
    9154:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_write_block>
		  fileCreatedFlag = 1;
    9158:	81 e0       	ldi	r24, 0x01	; 1
    915a:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    915c:	20 91 31 40 	lds	r18, 0x4031
    9160:	30 91 32 40 	lds	r19, 0x4032
    9164:	40 91 33 40 	lds	r20, 0x4033
    9168:	50 91 34 40 	lds	r21, 0x4034
    916c:	81 e0       	ldi	r24, 0x01	; 1
    916e:	ba 01       	movw	r22, r20
    9170:	a9 01       	movw	r20, r18
    9172:	0e 94 23 4a 	call	0x9446	; 0x9446 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    9176:	88 8d       	ldd	r24, Y+24	; 0x18
    9178:	99 8d       	ldd	r25, Y+25	; 0x19
    917a:	80 96       	adiw	r24, 0x20	; 32
    917c:	88 8f       	std	Y+24, r24	; 0x18
    917e:	99 8f       	std	Y+25, r25	; 0x19
    9180:	28 8d       	ldd	r18, Y+24	; 0x18
    9182:	39 8d       	ldd	r19, Y+25	; 0x19
    9184:	80 91 35 40 	lds	r24, 0x4035
    9188:	90 91 36 40 	lds	r25, 0x4036
    918c:	28 17       	cp	r18, r24
    918e:	39 07       	cpc	r19, r25
    9190:	08 f4       	brcc	.+2      	; 0x9194 <writeFile+0x5d2>
    9192:	6d cf       	rjmp	.-294    	; 0x906e <writeFile+0x4ac>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    9194:	8d 81       	ldd	r24, Y+5	; 0x05
    9196:	8f 5f       	subi	r24, 0xFF	; 255
    9198:	8d 83       	std	Y+5, r24	; 0x05
    919a:	8d 81       	ldd	r24, Y+5	; 0x05
    919c:	28 2f       	mov	r18, r24
    919e:	30 e0       	ldi	r19, 0x00	; 0
    91a0:	80 91 55 50 	lds	r24, 0x5055
    91a4:	90 91 56 50 	lds	r25, 0x5056
    91a8:	28 17       	cp	r18, r24
    91aa:	39 07       	cpc	r19, r25
    91ac:	08 f4       	brcc	.+2      	; 0x91b0 <writeFile+0x5ee>
    91ae:	48 cf       	rjmp	.-368    	; 0x9040 <writeFile+0x47e>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    91b0:	88 89       	ldd	r24, Y+16	; 0x10
    91b2:	99 89       	ldd	r25, Y+17	; 0x11
    91b4:	aa 89       	ldd	r26, Y+18	; 0x12
    91b6:	bb 89       	ldd	r27, Y+19	; 0x13
    91b8:	bc 01       	movw	r22, r24
    91ba:	cd 01       	movw	r24, r26
    91bc:	40 e0       	ldi	r20, 0x00	; 0
    91be:	00 e0       	ldi	r16, 0x00	; 0
    91c0:	10 e0       	ldi	r17, 0x00	; 0
    91c2:	98 01       	movw	r18, r16
    91c4:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
    91c8:	dc 01       	movw	r26, r24
    91ca:	cb 01       	movw	r24, r22
    91cc:	8c 87       	std	Y+12, r24	; 0x0c
    91ce:	9d 87       	std	Y+13, r25	; 0x0d
    91d0:	ae 87       	std	Y+14, r26	; 0x0e
    91d2:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    91d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    91d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    91d8:	ae 85       	ldd	r26, Y+14	; 0x0e
    91da:	bf 85       	ldd	r27, Y+15	; 0x0f
    91dc:	87 3f       	cpi	r24, 0xF7	; 247
    91de:	ff ef       	ldi	r31, 0xFF	; 255
    91e0:	9f 07       	cpc	r25, r31
    91e2:	ff ef       	ldi	r31, 0xFF	; 255
    91e4:	af 07       	cpc	r26, r31
    91e6:	ff e0       	ldi	r31, 0x0F	; 15
    91e8:	bf 07       	cpc	r27, r31
    91ea:	b8 f1       	brcs	.+110    	; 0x925a <writeFile+0x698>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    91ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    91ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    91f0:	ae 85       	ldd	r26, Y+14	; 0x0e
    91f2:	bf 85       	ldd	r27, Y+15	; 0x0f
    91f4:	8f 3f       	cpi	r24, 0xFF	; 255
    91f6:	0f ef       	ldi	r16, 0xFF	; 255
    91f8:	90 07       	cpc	r25, r16
    91fa:	0f ef       	ldi	r16, 0xFF	; 255
    91fc:	a0 07       	cpc	r26, r16
    91fe:	0f e0       	ldi	r16, 0x0F	; 15
    9200:	b0 07       	cpc	r27, r16
    9202:	49 f5       	brne	.+82     	; 0x9256 <writeFile+0x694>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9204:	88 89       	ldd	r24, Y+16	; 0x10
    9206:	99 89       	ldd	r25, Y+17	; 0x11
    9208:	aa 89       	ldd	r26, Y+18	; 0x12
    920a:	bb 89       	ldd	r27, Y+19	; 0x13
    920c:	bc 01       	movw	r22, r24
    920e:	cd 01       	movw	r24, r26
    9210:	0e 94 4a 49 	call	0x9294	; 0x9294 <searchNextFreeCluster>
    9214:	dc 01       	movw	r26, r24
    9216:	cb 01       	movw	r24, r22
    9218:	8c 87       	std	Y+12, r24	; 0x0c
    921a:	9d 87       	std	Y+13, r25	; 0x0d
    921c:	ae 87       	std	Y+14, r26	; 0x0e
    921e:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    9220:	88 89       	ldd	r24, Y+16	; 0x10
    9222:	99 89       	ldd	r25, Y+17	; 0x11
    9224:	aa 89       	ldd	r26, Y+18	; 0x12
    9226:	bb 89       	ldd	r27, Y+19	; 0x13
    9228:	0c 85       	ldd	r16, Y+12	; 0x0c
    922a:	1d 85       	ldd	r17, Y+13	; 0x0d
    922c:	2e 85       	ldd	r18, Y+14	; 0x0e
    922e:	3f 85       	ldd	r19, Y+15	; 0x0f
    9230:	bc 01       	movw	r22, r24
    9232:	cd 01       	movw	r24, r26
    9234:	41 e0       	ldi	r20, 0x01	; 1
    9236:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    923a:	8c 85       	ldd	r24, Y+12	; 0x0c
    923c:	9d 85       	ldd	r25, Y+13	; 0x0d
    923e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9240:	bf 85       	ldd	r27, Y+15	; 0x0f
    9242:	bc 01       	movw	r22, r24
    9244:	cd 01       	movw	r24, r26
    9246:	41 e0       	ldi	r20, 0x01	; 1
    9248:	0f ef       	ldi	r16, 0xFF	; 255
    924a:	1f ef       	ldi	r17, 0xFF	; 255
    924c:	2f ef       	ldi	r18, 0xFF	; 255
    924e:	3f e0       	ldi	r19, 0x0F	; 15
    9250:	0e 94 c7 40 	call	0x818e	; 0x818e <getSetNextCluster>
    9254:	02 c0       	rjmp	.+4      	; 0x925a <writeFile+0x698>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    9256:	83 e0       	ldi	r24, 0x03	; 3
    9258:	13 c0       	rjmp	.+38     	; 0x9280 <writeFile+0x6be>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    925a:	8c 85       	ldd	r24, Y+12	; 0x0c
    925c:	9d 85       	ldd	r25, Y+13	; 0x0d
    925e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9260:	bf 85       	ldd	r27, Y+15	; 0x0f
    9262:	00 97       	sbiw	r24, 0x00	; 0
    9264:	a1 05       	cpc	r26, r1
    9266:	b1 05       	cpc	r27, r1
    9268:	11 f4       	brne	.+4      	; 0x926e <writeFile+0x6ac>
	   return 4;
    926a:	84 e0       	ldi	r24, 0x04	; 4
    926c:	09 c0       	rjmp	.+18     	; 0x9280 <writeFile+0x6be>
	}
   
   prevCluster = cluster;
    926e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9270:	9d 85       	ldd	r25, Y+13	; 0x0d
    9272:	ae 85       	ldd	r26, Y+14	; 0x0e
    9274:	bf 85       	ldd	r27, Y+15	; 0x0f
    9276:	88 8b       	std	Y+16, r24	; 0x10
    9278:	99 8b       	std	Y+17, r25	; 0x11
    927a:	aa 8b       	std	Y+18, r26	; 0x12
    927c:	bb 8b       	std	Y+19, r27	; 0x13
 }
    927e:	d0 ce       	rjmp	.-608    	; 0x9020 <writeFile+0x45e>
 
 return 0;
}
    9280:	a9 96       	adiw	r28, 0x29	; 41
    9282:	cd bf       	out	0x3d, r28	; 61
    9284:	de bf       	out	0x3e, r29	; 62
    9286:	df 91       	pop	r29
    9288:	cf 91       	pop	r28
    928a:	1f 91       	pop	r17
    928c:	0f 91       	pop	r16
    928e:	ff 90       	pop	r15
    9290:	ef 90       	pop	r14
    9292:	08 95       	ret

00009294 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    9294:	ef 92       	push	r14
    9296:	ff 92       	push	r15
    9298:	0f 93       	push	r16
    929a:	1f 93       	push	r17
    929c:	cf 93       	push	r28
    929e:	df 93       	push	r29
    92a0:	cd b7       	in	r28, 0x3d	; 61
    92a2:	de b7       	in	r29, 0x3e	; 62
    92a4:	2f 97       	sbiw	r28, 0x0f	; 15
    92a6:	cd bf       	out	0x3d, r28	; 61
    92a8:	de bf       	out	0x3e, r29	; 62
    92aa:	6c 87       	std	Y+12, r22	; 0x0c
    92ac:	7d 87       	std	Y+13, r23	; 0x0d
    92ae:	8e 87       	std	Y+14, r24	; 0x0e
    92b0:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    92b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    92b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    92b6:	ae 85       	ldd	r26, Y+14	; 0x0e
    92b8:	bf 85       	ldd	r27, Y+15	; 0x0f
    92ba:	80 78       	andi	r24, 0x80	; 128
    92bc:	8c 87       	std	Y+12, r24	; 0x0c
    92be:	9d 87       	std	Y+13, r25	; 0x0d
    92c0:	ae 87       	std	Y+14, r26	; 0x0e
    92c2:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    92c4:	8c 85       	ldd	r24, Y+12	; 0x0c
    92c6:	9d 85       	ldd	r25, Y+13	; 0x0d
    92c8:	ae 85       	ldd	r26, Y+14	; 0x0e
    92ca:	bf 85       	ldd	r27, Y+15	; 0x0f
    92cc:	89 83       	std	Y+1, r24	; 0x01
    92ce:	9a 83       	std	Y+2, r25	; 0x02
    92d0:	ab 83       	std	Y+3, r26	; 0x03
    92d2:	bc 83       	std	Y+4, r27	; 0x04
    92d4:	7a c0       	rjmp	.+244    	; 0x93ca <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    92d6:	80 91 5d 50 	lds	r24, 0x505D
    92da:	90 91 5e 50 	lds	r25, 0x505E
    92de:	9c 01       	movw	r18, r24
    92e0:	40 e0       	ldi	r20, 0x00	; 0
    92e2:	50 e0       	ldi	r21, 0x00	; 0
    92e4:	80 91 57 50 	lds	r24, 0x5057
    92e8:	90 91 58 50 	lds	r25, 0x5058
    92ec:	a0 91 59 50 	lds	r26, 0x5059
    92f0:	b0 91 5a 50 	lds	r27, 0x505A
    92f4:	79 01       	movw	r14, r18
    92f6:	8a 01       	movw	r16, r20
    92f8:	e8 0e       	add	r14, r24
    92fa:	f9 1e       	adc	r15, r25
    92fc:	0a 1f       	adc	r16, r26
    92fe:	1b 1f       	adc	r17, r27
    9300:	89 81       	ldd	r24, Y+1	; 0x01
    9302:	9a 81       	ldd	r25, Y+2	; 0x02
    9304:	ab 81       	ldd	r26, Y+3	; 0x03
    9306:	bc 81       	ldd	r27, Y+4	; 0x04
    9308:	88 0f       	add	r24, r24
    930a:	99 1f       	adc	r25, r25
    930c:	aa 1f       	adc	r26, r26
    930e:	bb 1f       	adc	r27, r27
    9310:	88 0f       	add	r24, r24
    9312:	99 1f       	adc	r25, r25
    9314:	aa 1f       	adc	r26, r26
    9316:	bb 1f       	adc	r27, r27
    9318:	20 91 35 40 	lds	r18, 0x4035
    931c:	30 91 36 40 	lds	r19, 0x4036
    9320:	99 01       	movw	r18, r18
    9322:	40 e0       	ldi	r20, 0x00	; 0
    9324:	50 e0       	ldi	r21, 0x00	; 0
    9326:	bc 01       	movw	r22, r24
    9328:	cd 01       	movw	r24, r26
    932a:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    932e:	da 01       	movw	r26, r20
    9330:	c9 01       	movw	r24, r18
    9332:	8e 0d       	add	r24, r14
    9334:	9f 1d       	adc	r25, r15
    9336:	a0 1f       	adc	r26, r16
    9338:	b1 1f       	adc	r27, r17
    933a:	8e 83       	std	Y+6, r24	; 0x06
    933c:	9f 83       	std	Y+7, r25	; 0x07
    933e:	a8 87       	std	Y+8, r26	; 0x08
    9340:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    9342:	8e 81       	ldd	r24, Y+6	; 0x06
    9344:	9f 81       	ldd	r25, Y+7	; 0x07
    9346:	a8 85       	ldd	r26, Y+8	; 0x08
    9348:	b9 85       	ldd	r27, Y+9	; 0x09
    934a:	27 eb       	ldi	r18, 0xB7	; 183
    934c:	31 e2       	ldi	r19, 0x21	; 33
    934e:	bc 01       	movw	r22, r24
    9350:	cd 01       	movw	r24, r26
    9352:	a9 01       	movw	r20, r18
    9354:	0e 94 54 4e 	call	0x9ca8	; 0x9ca8 <SD_read_block>
      for(i=0; i<128; i++)
    9358:	1d 82       	std	Y+5, r1	; 0x05
    935a:	28 c0       	rjmp	.+80     	; 0x93ac <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    935c:	8d 81       	ldd	r24, Y+5	; 0x05
    935e:	88 2f       	mov	r24, r24
    9360:	90 e0       	ldi	r25, 0x00	; 0
    9362:	88 0f       	add	r24, r24
    9364:	99 1f       	adc	r25, r25
    9366:	88 0f       	add	r24, r24
    9368:	99 1f       	adc	r25, r25
    936a:	89 54       	subi	r24, 0x49	; 73
    936c:	9e 4d       	sbci	r25, 0xDE	; 222
    936e:	8a 87       	std	Y+10, r24	; 0x0a
    9370:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    9372:	8a 85       	ldd	r24, Y+10	; 0x0a
    9374:	9b 85       	ldd	r25, Y+11	; 0x0b
    9376:	fc 01       	movw	r30, r24
    9378:	80 81       	ld	r24, Z
    937a:	91 81       	ldd	r25, Z+1	; 0x01
    937c:	a2 81       	ldd	r26, Z+2	; 0x02
    937e:	b3 81       	ldd	r27, Z+3	; 0x03
    9380:	bf 70       	andi	r27, 0x0F	; 15
    9382:	00 97       	sbiw	r24, 0x00	; 0
    9384:	a1 05       	cpc	r26, r1
    9386:	b1 05       	cpc	r27, r1
    9388:	71 f4       	brne	.+28     	; 0x93a6 <searchNextFreeCluster+0x112>
            return(cluster+i);
    938a:	8d 81       	ldd	r24, Y+5	; 0x05
    938c:	28 2f       	mov	r18, r24
    938e:	30 e0       	ldi	r19, 0x00	; 0
    9390:	40 e0       	ldi	r20, 0x00	; 0
    9392:	50 e0       	ldi	r21, 0x00	; 0
    9394:	89 81       	ldd	r24, Y+1	; 0x01
    9396:	9a 81       	ldd	r25, Y+2	; 0x02
    9398:	ab 81       	ldd	r26, Y+3	; 0x03
    939a:	bc 81       	ldd	r27, Y+4	; 0x04
    939c:	82 0f       	add	r24, r18
    939e:	93 1f       	adc	r25, r19
    93a0:	a4 1f       	adc	r26, r20
    93a2:	b5 1f       	adc	r27, r21
    93a4:	27 c0       	rjmp	.+78     	; 0x93f4 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    93a6:	8d 81       	ldd	r24, Y+5	; 0x05
    93a8:	8f 5f       	subi	r24, 0xFF	; 255
    93aa:	8d 83       	std	Y+5, r24	; 0x05
    93ac:	8d 81       	ldd	r24, Y+5	; 0x05
    93ae:	88 23       	and	r24, r24
    93b0:	ac f6       	brge	.-86     	; 0x935c <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    93b2:	89 81       	ldd	r24, Y+1	; 0x01
    93b4:	9a 81       	ldd	r25, Y+2	; 0x02
    93b6:	ab 81       	ldd	r26, Y+3	; 0x03
    93b8:	bc 81       	ldd	r27, Y+4	; 0x04
    93ba:	80 58       	subi	r24, 0x80	; 128
    93bc:	9f 4f       	sbci	r25, 0xFF	; 255
    93be:	af 4f       	sbci	r26, 0xFF	; 255
    93c0:	bf 4f       	sbci	r27, 0xFF	; 255
    93c2:	89 83       	std	Y+1, r24	; 0x01
    93c4:	9a 83       	std	Y+2, r25	; 0x02
    93c6:	ab 83       	std	Y+3, r26	; 0x03
    93c8:	bc 83       	std	Y+4, r27	; 0x04
    93ca:	80 91 3a 40 	lds	r24, 0x403A
    93ce:	90 91 3b 40 	lds	r25, 0x403B
    93d2:	a0 91 3c 40 	lds	r26, 0x403C
    93d6:	b0 91 3d 40 	lds	r27, 0x403D
    93da:	29 81       	ldd	r18, Y+1	; 0x01
    93dc:	3a 81       	ldd	r19, Y+2	; 0x02
    93de:	4b 81       	ldd	r20, Y+3	; 0x03
    93e0:	5c 81       	ldd	r21, Y+4	; 0x04
    93e2:	28 17       	cp	r18, r24
    93e4:	39 07       	cpc	r19, r25
    93e6:	4a 07       	cpc	r20, r26
    93e8:	5b 07       	cpc	r21, r27
    93ea:	08 f4       	brcc	.+2      	; 0x93ee <searchNextFreeCluster+0x15a>
    93ec:	74 cf       	rjmp	.-280    	; 0x92d6 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    93ee:	80 e0       	ldi	r24, 0x00	; 0
    93f0:	90 e0       	ldi	r25, 0x00	; 0
    93f2:	dc 01       	movw	r26, r24
}
    93f4:	bc 01       	movw	r22, r24
    93f6:	cd 01       	movw	r24, r26
    93f8:	2f 96       	adiw	r28, 0x0f	; 15
    93fa:	cd bf       	out	0x3d, r28	; 61
    93fc:	de bf       	out	0x3e, r29	; 62
    93fe:	df 91       	pop	r29
    9400:	cf 91       	pop	r28
    9402:	1f 91       	pop	r17
    9404:	0f 91       	pop	r16
    9406:	ff 90       	pop	r15
    9408:	ef 90       	pop	r14
    940a:	08 95       	ret

0000940c <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    940c:	cf 93       	push	r28
    940e:	df 93       	push	r29
    9410:	00 d0       	rcall	.+0      	; 0x9412 <deleteFile+0x6>
    9412:	cd b7       	in	r28, 0x3d	; 61
    9414:	de b7       	in	r29, 0x3e	; 62
    9416:	8a 83       	std	Y+2, r24	; 0x02
    9418:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    941a:	8a 81       	ldd	r24, Y+2	; 0x02
    941c:	9b 81       	ldd	r25, Y+3	; 0x03
    941e:	0e 94 ab 44 	call	0x8956	; 0x8956 <convertFileName>
    9422:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9424:	89 81       	ldd	r24, Y+1	; 0x01
    9426:	88 23       	and	r24, r24
    9428:	39 f4       	brne	.+14     	; 0x9438 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    942a:	25 e9       	ldi	r18, 0x95	; 149
    942c:	30 e5       	ldi	r19, 0x50	; 80
    942e:	82 e0       	ldi	r24, 0x02	; 2
    9430:	b9 01       	movw	r22, r18
    9432:	0e 94 22 42 	call	0x8444	; 0x8444 <findFiles>
    9436:	01 c0       	rjmp	.+2      	; 0x943a <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9438:	00 00       	nop

  findFiles (DELETE, Filename);
}
    943a:	23 96       	adiw	r28, 0x03	; 3
    943c:	cd bf       	out	0x3d, r28	; 61
    943e:	de bf       	out	0x3e, r29	; 62
    9440:	df 91       	pop	r29
    9442:	cf 91       	pop	r28
    9444:	08 95       	ret

00009446 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9446:	ef 92       	push	r14
    9448:	ff 92       	push	r15
    944a:	0f 93       	push	r16
    944c:	1f 93       	push	r17
    944e:	cf 93       	push	r28
    9450:	df 93       	push	r29
    9452:	cd b7       	in	r28, 0x3d	; 61
    9454:	de b7       	in	r29, 0x3e	; 62
    9456:	29 97       	sbiw	r28, 0x09	; 9
    9458:	cd bf       	out	0x3d, r28	; 61
    945a:	de bf       	out	0x3e, r29	; 62
    945c:	8d 83       	std	Y+5, r24	; 0x05
    945e:	4e 83       	std	Y+6, r20	; 0x06
    9460:	5f 83       	std	Y+7, r21	; 0x07
    9462:	68 87       	std	Y+8, r22	; 0x08
    9464:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    9466:	8e 81       	ldd	r24, Y+6	; 0x06
    9468:	9f 81       	ldd	r25, Y+7	; 0x07
    946a:	a8 85       	ldd	r26, Y+8	; 0x08
    946c:	b9 85       	ldd	r27, Y+9	; 0x09
    946e:	91 70       	andi	r25, 0x01	; 1
    9470:	a0 70       	andi	r26, 0x00	; 0
    9472:	b0 70       	andi	r27, 0x00	; 0
    9474:	00 97       	sbiw	r24, 0x00	; 0
    9476:	a1 05       	cpc	r26, r1
    9478:	b1 05       	cpc	r27, r1
    947a:	91 f4       	brne	.+36     	; 0x94a0 <freeMemoryUpdate+0x5a>
    947c:	8e 81       	ldd	r24, Y+6	; 0x06
    947e:	9f 81       	ldd	r25, Y+7	; 0x07
    9480:	a8 85       	ldd	r26, Y+8	; 0x08
    9482:	b9 85       	ldd	r27, Y+9	; 0x09
    9484:	07 2e       	mov	r0, r23
    9486:	79 e0       	ldi	r23, 0x09	; 9
    9488:	b6 95       	lsr	r27
    948a:	a7 95       	ror	r26
    948c:	97 95       	ror	r25
    948e:	87 95       	ror	r24
    9490:	7a 95       	dec	r23
    9492:	d1 f7       	brne	.-12     	; 0x9488 <freeMemoryUpdate+0x42>
    9494:	70 2d       	mov	r23, r0
    9496:	8e 83       	std	Y+6, r24	; 0x06
    9498:	9f 83       	std	Y+7, r25	; 0x07
    949a:	a8 87       	std	Y+8, r26	; 0x08
    949c:	b9 87       	std	Y+9, r27	; 0x09
    949e:	14 c0       	rjmp	.+40     	; 0x94c8 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    94a0:	8e 81       	ldd	r24, Y+6	; 0x06
    94a2:	9f 81       	ldd	r25, Y+7	; 0x07
    94a4:	a8 85       	ldd	r26, Y+8	; 0x08
    94a6:	b9 85       	ldd	r27, Y+9	; 0x09
    94a8:	07 2e       	mov	r0, r23
    94aa:	79 e0       	ldi	r23, 0x09	; 9
    94ac:	b6 95       	lsr	r27
    94ae:	a7 95       	ror	r26
    94b0:	97 95       	ror	r25
    94b2:	87 95       	ror	r24
    94b4:	7a 95       	dec	r23
    94b6:	d1 f7       	brne	.-12     	; 0x94ac <freeMemoryUpdate+0x66>
    94b8:	70 2d       	mov	r23, r0
    94ba:	01 96       	adiw	r24, 0x01	; 1
    94bc:	a1 1d       	adc	r26, r1
    94be:	b1 1d       	adc	r27, r1
    94c0:	8e 83       	std	Y+6, r24	; 0x06
    94c2:	9f 83       	std	Y+7, r25	; 0x07
    94c4:	a8 87       	std	Y+8, r26	; 0x08
    94c6:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    94c8:	8e 81       	ldd	r24, Y+6	; 0x06
    94ca:	9f 81       	ldd	r25, Y+7	; 0x07
    94cc:	a8 85       	ldd	r26, Y+8	; 0x08
    94ce:	b9 85       	ldd	r27, Y+9	; 0x09
    94d0:	87 70       	andi	r24, 0x07	; 7
    94d2:	90 70       	andi	r25, 0x00	; 0
    94d4:	a0 70       	andi	r26, 0x00	; 0
    94d6:	b0 70       	andi	r27, 0x00	; 0
    94d8:	00 97       	sbiw	r24, 0x00	; 0
    94da:	a1 05       	cpc	r26, r1
    94dc:	b1 05       	cpc	r27, r1
    94de:	89 f4       	brne	.+34     	; 0x9502 <freeMemoryUpdate+0xbc>
    94e0:	8e 81       	ldd	r24, Y+6	; 0x06
    94e2:	9f 81       	ldd	r25, Y+7	; 0x07
    94e4:	a8 85       	ldd	r26, Y+8	; 0x08
    94e6:	b9 85       	ldd	r27, Y+9	; 0x09
    94e8:	68 94       	set
    94ea:	12 f8       	bld	r1, 2
    94ec:	b6 95       	lsr	r27
    94ee:	a7 95       	ror	r26
    94f0:	97 95       	ror	r25
    94f2:	87 95       	ror	r24
    94f4:	16 94       	lsr	r1
    94f6:	d1 f7       	brne	.-12     	; 0x94ec <freeMemoryUpdate+0xa6>
    94f8:	8e 83       	std	Y+6, r24	; 0x06
    94fa:	9f 83       	std	Y+7, r25	; 0x07
    94fc:	a8 87       	std	Y+8, r26	; 0x08
    94fe:	b9 87       	std	Y+9, r27	; 0x09
    9500:	13 c0       	rjmp	.+38     	; 0x9528 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    9502:	8e 81       	ldd	r24, Y+6	; 0x06
    9504:	9f 81       	ldd	r25, Y+7	; 0x07
    9506:	a8 85       	ldd	r26, Y+8	; 0x08
    9508:	b9 85       	ldd	r27, Y+9	; 0x09
    950a:	68 94       	set
    950c:	12 f8       	bld	r1, 2
    950e:	b6 95       	lsr	r27
    9510:	a7 95       	ror	r26
    9512:	97 95       	ror	r25
    9514:	87 95       	ror	r24
    9516:	16 94       	lsr	r1
    9518:	d1 f7       	brne	.-12     	; 0x950e <freeMemoryUpdate+0xc8>
    951a:	01 96       	adiw	r24, 0x01	; 1
    951c:	a1 1d       	adc	r26, r1
    951e:	b1 1d       	adc	r27, r1
    9520:	8e 83       	std	Y+6, r24	; 0x06
    9522:	9f 83       	std	Y+7, r25	; 0x07
    9524:	a8 87       	std	Y+8, r26	; 0x08
    9526:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9528:	80 91 b8 50 	lds	r24, 0x50B8
    952c:	88 23       	and	r24, r24
    952e:	e9 f1       	breq	.+122    	; 0x95aa <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    9530:	81 e0       	ldi	r24, 0x01	; 1
    9532:	60 e0       	ldi	r22, 0x00	; 0
    9534:	20 e0       	ldi	r18, 0x00	; 0
    9536:	30 e0       	ldi	r19, 0x00	; 0
    9538:	a9 01       	movw	r20, r18
    953a:	0e 94 71 41 	call	0x82e2	; 0x82e2 <getSetFreeCluster>
    953e:	dc 01       	movw	r26, r24
    9540:	cb 01       	movw	r24, r22
    9542:	89 83       	std	Y+1, r24	; 0x01
    9544:	9a 83       	std	Y+2, r25	; 0x02
    9546:	ab 83       	std	Y+3, r26	; 0x03
    9548:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    954a:	8d 81       	ldd	r24, Y+5	; 0x05
    954c:	88 23       	and	r24, r24
    954e:	89 f4       	brne	.+34     	; 0x9572 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    9550:	29 81       	ldd	r18, Y+1	; 0x01
    9552:	3a 81       	ldd	r19, Y+2	; 0x02
    9554:	4b 81       	ldd	r20, Y+3	; 0x03
    9556:	5c 81       	ldd	r21, Y+4	; 0x04
    9558:	8e 81       	ldd	r24, Y+6	; 0x06
    955a:	9f 81       	ldd	r25, Y+7	; 0x07
    955c:	a8 85       	ldd	r26, Y+8	; 0x08
    955e:	b9 85       	ldd	r27, Y+9	; 0x09
    9560:	82 0f       	add	r24, r18
    9562:	93 1f       	adc	r25, r19
    9564:	a4 1f       	adc	r26, r20
    9566:	b5 1f       	adc	r27, r21
    9568:	89 83       	std	Y+1, r24	; 0x01
    956a:	9a 83       	std	Y+2, r25	; 0x02
    956c:	ab 83       	std	Y+3, r26	; 0x03
    956e:	bc 83       	std	Y+4, r27	; 0x04
    9570:	14 c0       	rjmp	.+40     	; 0x959a <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    9572:	29 81       	ldd	r18, Y+1	; 0x01
    9574:	3a 81       	ldd	r19, Y+2	; 0x02
    9576:	4b 81       	ldd	r20, Y+3	; 0x03
    9578:	5c 81       	ldd	r21, Y+4	; 0x04
    957a:	8e 81       	ldd	r24, Y+6	; 0x06
    957c:	9f 81       	ldd	r25, Y+7	; 0x07
    957e:	a8 85       	ldd	r26, Y+8	; 0x08
    9580:	b9 85       	ldd	r27, Y+9	; 0x09
    9582:	79 01       	movw	r14, r18
    9584:	8a 01       	movw	r16, r20
    9586:	e8 1a       	sub	r14, r24
    9588:	f9 0a       	sbc	r15, r25
    958a:	0a 0b       	sbc	r16, r26
    958c:	1b 0b       	sbc	r17, r27
    958e:	d8 01       	movw	r26, r16
    9590:	c7 01       	movw	r24, r14
    9592:	89 83       	std	Y+1, r24	; 0x01
    9594:	9a 83       	std	Y+2, r25	; 0x02
    9596:	ab 83       	std	Y+3, r26	; 0x03
    9598:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    959a:	29 81       	ldd	r18, Y+1	; 0x01
    959c:	3a 81       	ldd	r19, Y+2	; 0x02
    959e:	4b 81       	ldd	r20, Y+3	; 0x03
    95a0:	5c 81       	ldd	r21, Y+4	; 0x04
    95a2:	81 e0       	ldi	r24, 0x01	; 1
    95a4:	61 e0       	ldi	r22, 0x01	; 1
    95a6:	0e 94 71 41 	call	0x82e2	; 0x82e2 <getSetFreeCluster>
  }
}
    95aa:	29 96       	adiw	r28, 0x09	; 9
    95ac:	cd bf       	out	0x3d, r28	; 61
    95ae:	de bf       	out	0x3e, r29	; 62
    95b0:	df 91       	pop	r29
    95b2:	cf 91       	pop	r28
    95b4:	1f 91       	pop	r17
    95b6:	0f 91       	pop	r16
    95b8:	ff 90       	pop	r15
    95ba:	ef 90       	pop	r14
    95bc:	08 95       	ret

000095be <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    95be:	0f 93       	push	r16
    95c0:	1f 93       	push	r17
    95c2:	cf 93       	push	r28
    95c4:	df 93       	push	r29
    95c6:	cd b7       	in	r28, 0x3d	; 61
    95c8:	de b7       	in	r29, 0x3e	; 62
    95ca:	a9 97       	sbiw	r28, 0x29	; 41
    95cc:	cd bf       	out	0x3d, r28	; 61
    95ce:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    95d0:	81 e0       	ldi	r24, 0x01	; 1
    95d2:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    95d6:	81 e0       	ldi	r24, 0x01	; 1
    95d8:	0e 94 61 35 	call	0x6ac2	; 0x6ac2 <Ext1Power>
    95dc:	80 e0       	ldi	r24, 0x00	; 0
    95de:	90 e0       	ldi	r25, 0x00	; 0
    95e0:	a8 ec       	ldi	r26, 0xC8	; 200
    95e2:	b2 e4       	ldi	r27, 0x42	; 66
    95e4:	8e 87       	std	Y+14, r24	; 0x0e
    95e6:	9f 87       	std	Y+15, r25	; 0x0f
    95e8:	a8 8b       	std	Y+16, r26	; 0x10
    95ea:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    95ec:	6e 85       	ldd	r22, Y+14	; 0x0e
    95ee:	7f 85       	ldd	r23, Y+15	; 0x0f
    95f0:	88 89       	ldd	r24, Y+16	; 0x10
    95f2:	99 89       	ldd	r25, Y+17	; 0x11
    95f4:	20 e0       	ldi	r18, 0x00	; 0
    95f6:	30 e0       	ldi	r19, 0x00	; 0
    95f8:	4a ef       	ldi	r20, 0xFA	; 250
    95fa:	55 e4       	ldi	r21, 0x45	; 69
    95fc:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    9600:	dc 01       	movw	r26, r24
    9602:	cb 01       	movw	r24, r22
    9604:	8a 8b       	std	Y+18, r24	; 0x12
    9606:	9b 8b       	std	Y+19, r25	; 0x13
    9608:	ac 8b       	std	Y+20, r26	; 0x14
    960a:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    960c:	11 e0       	ldi	r17, 0x01	; 1
    960e:	6a 89       	ldd	r22, Y+18	; 0x12
    9610:	7b 89       	ldd	r23, Y+19	; 0x13
    9612:	8c 89       	ldd	r24, Y+20	; 0x14
    9614:	9d 89       	ldd	r25, Y+21	; 0x15
    9616:	20 e0       	ldi	r18, 0x00	; 0
    9618:	30 e0       	ldi	r19, 0x00	; 0
    961a:	40 e8       	ldi	r20, 0x80	; 128
    961c:	5f e3       	ldi	r21, 0x3F	; 63
    961e:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    9622:	88 23       	and	r24, r24
    9624:	0c f0       	brlt	.+2      	; 0x9628 <SD_init+0x6a>
    9626:	10 e0       	ldi	r17, 0x00	; 0
    9628:	11 23       	and	r17, r17
    962a:	29 f0       	breq	.+10     	; 0x9636 <SD_init+0x78>
		__ticks = 1;
    962c:	81 e0       	ldi	r24, 0x01	; 1
    962e:	90 e0       	ldi	r25, 0x00	; 0
    9630:	8e 8b       	std	Y+22, r24	; 0x16
    9632:	9f 8b       	std	Y+23, r25	; 0x17
    9634:	46 c0       	rjmp	.+140    	; 0x96c2 <SD_init+0x104>
	else if (__tmp > 65535)
    9636:	11 e0       	ldi	r17, 0x01	; 1
    9638:	6a 89       	ldd	r22, Y+18	; 0x12
    963a:	7b 89       	ldd	r23, Y+19	; 0x13
    963c:	8c 89       	ldd	r24, Y+20	; 0x14
    963e:	9d 89       	ldd	r25, Y+21	; 0x15
    9640:	20 e0       	ldi	r18, 0x00	; 0
    9642:	3f ef       	ldi	r19, 0xFF	; 255
    9644:	4f e7       	ldi	r20, 0x7F	; 127
    9646:	57 e4       	ldi	r21, 0x47	; 71
    9648:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    964c:	18 16       	cp	r1, r24
    964e:	0c f0       	brlt	.+2      	; 0x9652 <SD_init+0x94>
    9650:	10 e0       	ldi	r17, 0x00	; 0
    9652:	11 23       	and	r17, r17
    9654:	61 f1       	breq	.+88     	; 0x96ae <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9656:	6e 85       	ldd	r22, Y+14	; 0x0e
    9658:	7f 85       	ldd	r23, Y+15	; 0x0f
    965a:	88 89       	ldd	r24, Y+16	; 0x10
    965c:	99 89       	ldd	r25, Y+17	; 0x11
    965e:	20 e0       	ldi	r18, 0x00	; 0
    9660:	30 e0       	ldi	r19, 0x00	; 0
    9662:	40 e2       	ldi	r20, 0x20	; 32
    9664:	51 e4       	ldi	r21, 0x41	; 65
    9666:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    966a:	dc 01       	movw	r26, r24
    966c:	cb 01       	movw	r24, r22
    966e:	bc 01       	movw	r22, r24
    9670:	cd 01       	movw	r24, r26
    9672:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    9676:	dc 01       	movw	r26, r24
    9678:	cb 01       	movw	r24, r22
    967a:	8e 8b       	std	Y+22, r24	; 0x16
    967c:	9f 8b       	std	Y+23, r25	; 0x17
    967e:	12 c0       	rjmp	.+36     	; 0x96a4 <SD_init+0xe6>
    9680:	80 e2       	ldi	r24, 0x20	; 32
    9682:	93 e0       	ldi	r25, 0x03	; 3
    9684:	88 8f       	std	Y+24, r24	; 0x18
    9686:	99 8f       	std	Y+25, r25	; 0x19
    9688:	88 8d       	ldd	r24, Y+24	; 0x18
    968a:	99 8d       	ldd	r25, Y+25	; 0x19
    968c:	8c 01       	movw	r16, r24
    968e:	c8 01       	movw	r24, r16
    9690:	01 97       	sbiw	r24, 0x01	; 1
    9692:	f1 f7       	brne	.-4      	; 0x9690 <SD_init+0xd2>
    9694:	8c 01       	movw	r16, r24
    9696:	08 8f       	std	Y+24, r16	; 0x18
    9698:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    969a:	8e 89       	ldd	r24, Y+22	; 0x16
    969c:	9f 89       	ldd	r25, Y+23	; 0x17
    969e:	01 97       	sbiw	r24, 0x01	; 1
    96a0:	8e 8b       	std	Y+22, r24	; 0x16
    96a2:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    96a4:	8e 89       	ldd	r24, Y+22	; 0x16
    96a6:	9f 89       	ldd	r25, Y+23	; 0x17
    96a8:	00 97       	sbiw	r24, 0x00	; 0
    96aa:	51 f7       	brne	.-44     	; 0x9680 <SD_init+0xc2>
    96ac:	17 c0       	rjmp	.+46     	; 0x96dc <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    96ae:	6a 89       	ldd	r22, Y+18	; 0x12
    96b0:	7b 89       	ldd	r23, Y+19	; 0x13
    96b2:	8c 89       	ldd	r24, Y+20	; 0x14
    96b4:	9d 89       	ldd	r25, Y+21	; 0x15
    96b6:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    96ba:	dc 01       	movw	r26, r24
    96bc:	cb 01       	movw	r24, r22
    96be:	8e 8b       	std	Y+22, r24	; 0x16
    96c0:	9f 8b       	std	Y+23, r25	; 0x17
    96c2:	8e 89       	ldd	r24, Y+22	; 0x16
    96c4:	9f 89       	ldd	r25, Y+23	; 0x17
    96c6:	8a 8f       	std	Y+26, r24	; 0x1a
    96c8:	9b 8f       	std	Y+27, r25	; 0x1b
    96ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    96cc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    96ce:	8c 01       	movw	r16, r24
    96d0:	f8 01       	movw	r30, r16
    96d2:	31 97       	sbiw	r30, 0x01	; 1
    96d4:	f1 f7       	brne	.-4      	; 0x96d2 <SD_init+0x114>
    96d6:	8f 01       	movw	r16, r30
    96d8:	0a 8f       	std	Y+26, r16	; 0x1a
    96da:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    96dc:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    96de:	88 e0       	ldi	r24, 0x08	; 8
    96e0:	60 e0       	ldi	r22, 0x00	; 0
    96e2:	0e 94 cb 33 	call	0x6796	; 0x6796 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    96e6:	88 e0       	ldi	r24, 0x08	; 8
    96e8:	60 e0       	ldi	r22, 0x00	; 0
    96ea:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    96ee:	80 e0       	ldi	r24, 0x00	; 0
    96f0:	90 e0       	ldi	r25, 0x00	; 0
    96f2:	63 e0       	ldi	r22, 0x03	; 3
    96f4:	70 e0       	ldi	r23, 0x00	; 0
    96f6:	0e 94 8f 38 	call	0x711e	; 0x711e <SPIInit2>
	SPICS(TRUE);
    96fa:	81 e0       	ldi	r24, 0x01	; 1
    96fc:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9700:	1a 82       	std	Y+2, r1	; 0x02
    9702:	1b 82       	std	Y+3, r1	; 0x03
    9704:	17 c0       	rjmp	.+46     	; 0x9734 <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9706:	80 ec       	ldi	r24, 0xC0	; 192
    9708:	98 e0       	ldi	r25, 0x08	; 8
    970a:	2f ef       	ldi	r18, 0xFF	; 255
    970c:	fc 01       	movw	r30, r24
    970e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9710:	00 00       	nop
    9712:	80 ec       	ldi	r24, 0xC0	; 192
    9714:	98 e0       	ldi	r25, 0x08	; 8
    9716:	fc 01       	movw	r30, r24
    9718:	82 81       	ldd	r24, Z+2	; 0x02
    971a:	88 23       	and	r24, r24
    971c:	d4 f7       	brge	.-12     	; 0x9712 <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    971e:	80 ec       	ldi	r24, 0xC0	; 192
    9720:	98 e0       	ldi	r25, 0x08	; 8
    9722:	fc 01       	movw	r30, r24
    9724:	83 81       	ldd	r24, Z+3	; 0x03
    9726:	80 93 94 50 	sts	0x5094, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    972a:	8a 81       	ldd	r24, Y+2	; 0x02
    972c:	9b 81       	ldd	r25, Y+3	; 0x03
    972e:	01 96       	adiw	r24, 0x01	; 1
    9730:	8a 83       	std	Y+2, r24	; 0x02
    9732:	9b 83       	std	Y+3, r25	; 0x03
    9734:	8a 81       	ldd	r24, Y+2	; 0x02
    9736:	9b 81       	ldd	r25, Y+3	; 0x03
    9738:	8a 30       	cpi	r24, 0x0A	; 10
    973a:	91 05       	cpc	r25, r1
    973c:	24 f3       	brlt	.-56     	; 0x9706 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    973e:	80 e0       	ldi	r24, 0x00	; 0
    9740:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    9744:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9748:	88 e0       	ldi	r24, 0x08	; 8
    974a:	60 e0       	ldi	r22, 0x00	; 0
    974c:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9750:	80 e0       	ldi	r24, 0x00	; 0
    9752:	90 e0       	ldi	r25, 0x00	; 0
    9754:	63 e0       	ldi	r22, 0x03	; 3
    9756:	70 e0       	ldi	r23, 0x00	; 0
    9758:	0e 94 8f 38 	call	0x711e	; 0x711e <SPIInit2>
	SPICS(TRUE);
    975c:	81 e0       	ldi	r24, 0x01	; 1
    975e:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9762:	1c 82       	std	Y+4, r1	; 0x04
    9764:	1d 82       	std	Y+5, r1	; 0x05
    9766:	0d c0       	rjmp	.+26     	; 0x9782 <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    9768:	8c 81       	ldd	r24, Y+4	; 0x04
    976a:	9d 81       	ldd	r25, Y+5	; 0x05
    976c:	8a 30       	cpi	r24, 0x0A	; 10
    976e:	91 05       	cpc	r25, r1
    9770:	1c f0       	brlt	.+6      	; 0x9778 <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    9772:	81 e0       	ldi	r24, 0x01	; 1
    9774:	89 83       	std	Y+1, r24	; 0x01
			break;
    9776:	10 c0       	rjmp	.+32     	; 0x9798 <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9778:	8c 81       	ldd	r24, Y+4	; 0x04
    977a:	9d 81       	ldd	r25, Y+5	; 0x05
    977c:	01 96       	adiw	r24, 0x01	; 1
    977e:	8c 83       	std	Y+4, r24	; 0x04
    9780:	9d 83       	std	Y+5, r25	; 0x05
    9782:	80 e0       	ldi	r24, 0x00	; 0
    9784:	40 e0       	ldi	r20, 0x00	; 0
    9786:	50 e0       	ldi	r21, 0x00	; 0
    9788:	ba 01       	movw	r22, r20
    978a:	25 e9       	ldi	r18, 0x95	; 149
    978c:	08 e0       	ldi	r16, 0x08	; 8
    978e:	10 e0       	ldi	r17, 0x00	; 0
    9790:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
    9794:	81 30       	cpi	r24, 0x01	; 1
    9796:	41 f7       	brne	.-48     	; 0x9768 <SD_init+0x1aa>
    9798:	80 e0       	ldi	r24, 0x00	; 0
    979a:	90 e0       	ldi	r25, 0x00	; 0
    979c:	a8 ec       	ldi	r26, 0xC8	; 200
    979e:	b2 e4       	ldi	r27, 0x42	; 66
    97a0:	8c 8f       	std	Y+28, r24	; 0x1c
    97a2:	9d 8f       	std	Y+29, r25	; 0x1d
    97a4:	ae 8f       	std	Y+30, r26	; 0x1e
    97a6:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    97a8:	6c 8d       	ldd	r22, Y+28	; 0x1c
    97aa:	7d 8d       	ldd	r23, Y+29	; 0x1d
    97ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    97ae:	9f 8d       	ldd	r25, Y+31	; 0x1f
    97b0:	20 e0       	ldi	r18, 0x00	; 0
    97b2:	30 e0       	ldi	r19, 0x00	; 0
    97b4:	4a ef       	ldi	r20, 0xFA	; 250
    97b6:	55 e4       	ldi	r21, 0x45	; 69
    97b8:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    97bc:	dc 01       	movw	r26, r24
    97be:	cb 01       	movw	r24, r22
    97c0:	88 a3       	lds	r24, 0x58
    97c2:	99 a3       	lds	r25, 0x59
    97c4:	aa a3       	lds	r26, 0x5a
    97c6:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    97c8:	11 e0       	ldi	r17, 0x01	; 1
    97ca:	68 a1       	lds	r22, 0x48
    97cc:	79 a1       	lds	r23, 0x49
    97ce:	8a a1       	lds	r24, 0x4a
    97d0:	9b a1       	lds	r25, 0x4b
    97d2:	20 e0       	ldi	r18, 0x00	; 0
    97d4:	30 e0       	ldi	r19, 0x00	; 0
    97d6:	40 e8       	ldi	r20, 0x80	; 128
    97d8:	5f e3       	ldi	r21, 0x3F	; 63
    97da:	0e 94 db 5a 	call	0xb5b6	; 0xb5b6 <__cmpsf2>
    97de:	88 23       	and	r24, r24
    97e0:	0c f0       	brlt	.+2      	; 0x97e4 <SD_init+0x226>
    97e2:	10 e0       	ldi	r17, 0x00	; 0
    97e4:	11 23       	and	r17, r17
    97e6:	29 f0       	breq	.+10     	; 0x97f2 <SD_init+0x234>
		__ticks = 1;
    97e8:	81 e0       	ldi	r24, 0x01	; 1
    97ea:	90 e0       	ldi	r25, 0x00	; 0
    97ec:	8c a3       	lds	r24, 0x5c
    97ee:	9d a3       	lds	r25, 0x5d
    97f0:	46 c0       	rjmp	.+140    	; 0x987e <SD_init+0x2c0>
	else if (__tmp > 65535)
    97f2:	11 e0       	ldi	r17, 0x01	; 1
    97f4:	68 a1       	lds	r22, 0x48
    97f6:	79 a1       	lds	r23, 0x49
    97f8:	8a a1       	lds	r24, 0x4a
    97fa:	9b a1       	lds	r25, 0x4b
    97fc:	20 e0       	ldi	r18, 0x00	; 0
    97fe:	3f ef       	ldi	r19, 0xFF	; 255
    9800:	4f e7       	ldi	r20, 0x7F	; 127
    9802:	57 e4       	ldi	r21, 0x47	; 71
    9804:	0e 94 e8 5b 	call	0xb7d0	; 0xb7d0 <__gesf2>
    9808:	18 16       	cp	r1, r24
    980a:	0c f0       	brlt	.+2      	; 0x980e <SD_init+0x250>
    980c:	10 e0       	ldi	r17, 0x00	; 0
    980e:	11 23       	and	r17, r17
    9810:	61 f1       	breq	.+88     	; 0x986a <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9812:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9814:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9816:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9818:	9f 8d       	ldd	r25, Y+31	; 0x1f
    981a:	20 e0       	ldi	r18, 0x00	; 0
    981c:	30 e0       	ldi	r19, 0x00	; 0
    981e:	40 e2       	ldi	r20, 0x20	; 32
    9820:	51 e4       	ldi	r21, 0x41	; 65
    9822:	0e 94 ec 5b 	call	0xb7d8	; 0xb7d8 <__mulsf3>
    9826:	dc 01       	movw	r26, r24
    9828:	cb 01       	movw	r24, r22
    982a:	bc 01       	movw	r22, r24
    982c:	cd 01       	movw	r24, r26
    982e:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    9832:	dc 01       	movw	r26, r24
    9834:	cb 01       	movw	r24, r22
    9836:	8c a3       	lds	r24, 0x5c
    9838:	9d a3       	lds	r25, 0x5d
    983a:	12 c0       	rjmp	.+36     	; 0x9860 <SD_init+0x2a2>
    983c:	80 e2       	ldi	r24, 0x20	; 32
    983e:	93 e0       	ldi	r25, 0x03	; 3
    9840:	8e a3       	lds	r24, 0x5e
    9842:	9f a3       	lds	r25, 0x5f
    9844:	8e a1       	lds	r24, 0x4e
    9846:	9f a1       	lds	r25, 0x4f
    9848:	8c 01       	movw	r16, r24
    984a:	c8 01       	movw	r24, r16
    984c:	01 97       	sbiw	r24, 0x01	; 1
    984e:	f1 f7       	brne	.-4      	; 0x984c <SD_init+0x28e>
    9850:	8c 01       	movw	r16, r24
    9852:	0e a3       	lds	r16, 0x5e
    9854:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9856:	8c a1       	lds	r24, 0x4c
    9858:	9d a1       	lds	r25, 0x4d
    985a:	01 97       	sbiw	r24, 0x01	; 1
    985c:	8c a3       	lds	r24, 0x5c
    985e:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9860:	8c a1       	lds	r24, 0x4c
    9862:	9d a1       	lds	r25, 0x4d
    9864:	00 97       	sbiw	r24, 0x00	; 0
    9866:	51 f7       	brne	.-44     	; 0x983c <SD_init+0x27e>
    9868:	17 c0       	rjmp	.+46     	; 0x9898 <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    986a:	68 a1       	lds	r22, 0x48
    986c:	79 a1       	lds	r23, 0x49
    986e:	8a a1       	lds	r24, 0x4a
    9870:	9b a1       	lds	r25, 0x4b
    9872:	0e 94 47 5b 	call	0xb68e	; 0xb68e <__fixunssfsi>
    9876:	dc 01       	movw	r26, r24
    9878:	cb 01       	movw	r24, r22
    987a:	8c a3       	lds	r24, 0x5c
    987c:	9d a3       	lds	r25, 0x5d
    987e:	8c a1       	lds	r24, 0x4c
    9880:	9d a1       	lds	r25, 0x4d
    9882:	88 a7       	lds	r24, 0x78
    9884:	99 a7       	lds	r25, 0x79
    9886:	88 a5       	lds	r24, 0x68
    9888:	99 a5       	lds	r25, 0x69
    988a:	8c 01       	movw	r16, r24
    988c:	f8 01       	movw	r30, r16
    988e:	31 97       	sbiw	r30, 0x01	; 1
    9890:	f1 f7       	brne	.-4      	; 0x988e <SD_init+0x2d0>
    9892:	8f 01       	movw	r16, r30
    9894:	08 a7       	lds	r16, 0x78
    9896:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9898:	1e 82       	std	Y+6, r1	; 0x06
    989a:	1f 82       	std	Y+7, r1	; 0x07
    989c:	0d c0       	rjmp	.+26     	; 0x98b8 <SD_init+0x2fa>
		if (i >= 10) {
    989e:	8e 81       	ldd	r24, Y+6	; 0x06
    98a0:	9f 81       	ldd	r25, Y+7	; 0x07
    98a2:	8a 30       	cpi	r24, 0x0A	; 10
    98a4:	91 05       	cpc	r25, r1
    98a6:	1c f0       	brlt	.+6      	; 0x98ae <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    98a8:	81 e0       	ldi	r24, 0x01	; 1
    98aa:	89 83       	std	Y+1, r24	; 0x01
			break;
    98ac:	11 c0       	rjmp	.+34     	; 0x98d0 <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    98ae:	8e 81       	ldd	r24, Y+6	; 0x06
    98b0:	9f 81       	ldd	r25, Y+7	; 0x07
    98b2:	01 96       	adiw	r24, 0x01	; 1
    98b4:	8e 83       	std	Y+6, r24	; 0x06
    98b6:	9f 83       	std	Y+7, r25	; 0x07
    98b8:	88 e0       	ldi	r24, 0x08	; 8
    98ba:	4a ea       	ldi	r20, 0xAA	; 170
    98bc:	51 e0       	ldi	r21, 0x01	; 1
    98be:	60 e0       	ldi	r22, 0x00	; 0
    98c0:	70 e0       	ldi	r23, 0x00	; 0
    98c2:	27 e8       	ldi	r18, 0x87	; 135
    98c4:	08 e0       	ldi	r16, 0x08	; 8
    98c6:	10 e0       	ldi	r17, 0x00	; 0
    98c8:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
    98cc:	81 30       	cpi	r24, 0x01	; 1
    98ce:	39 f7       	brne	.-50     	; 0x989e <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    98d0:	18 86       	std	Y+8, r1	; 0x08
    98d2:	19 86       	std	Y+9, r1	; 0x09
    98d4:	13 c0       	rjmp	.+38     	; 0x98fc <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    98d6:	88 85       	ldd	r24, Y+8	; 0x08
    98d8:	99 85       	ldd	r25, Y+9	; 0x09
    98da:	8c 01       	movw	r16, r24
    98dc:	0e 5f       	subi	r16, 0xFE	; 254
    98de:	1f 4f       	sbci	r17, 0xFF	; 255
    98e0:	8f ef       	ldi	r24, 0xFF	; 255
    98e2:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    98e6:	28 2f       	mov	r18, r24
    98e8:	c8 01       	movw	r24, r16
    98ea:	88 57       	subi	r24, 0x78	; 120
    98ec:	9f 4a       	sbci	r25, 0xAF	; 175
    98ee:	fc 01       	movw	r30, r24
    98f0:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    98f2:	88 85       	ldd	r24, Y+8	; 0x08
    98f4:	99 85       	ldd	r25, Y+9	; 0x09
    98f6:	01 96       	adiw	r24, 0x01	; 1
    98f8:	88 87       	std	Y+8, r24	; 0x08
    98fa:	99 87       	std	Y+9, r25	; 0x09
    98fc:	88 85       	ldd	r24, Y+8	; 0x08
    98fe:	99 85       	ldd	r25, Y+9	; 0x09
    9900:	84 30       	cpi	r24, 0x04	; 4
    9902:	91 05       	cpc	r25, r1
    9904:	44 f3       	brlt	.-48     	; 0x98d6 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9906:	80 91 8c 50 	lds	r24, 0x508C
    990a:	81 30       	cpi	r24, 0x01	; 1
    990c:	21 f4       	brne	.+8      	; 0x9916 <SD_init+0x358>
    990e:	80 91 8d 50 	lds	r24, 0x508D
    9912:	8a 3a       	cpi	r24, 0xAA	; 170
    9914:	11 f0       	breq	.+4      	; 0x991a <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9916:	81 e0       	ldi	r24, 0x01	; 1
    9918:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    991a:	87 e3       	ldi	r24, 0x37	; 55
    991c:	40 e0       	ldi	r20, 0x00	; 0
    991e:	50 e0       	ldi	r21, 0x00	; 0
    9920:	ba 01       	movw	r22, r20
    9922:	2f ef       	ldi	r18, 0xFF	; 255
    9924:	08 e0       	ldi	r16, 0x08	; 8
    9926:	10 e0       	ldi	r17, 0x00	; 0
    9928:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    992c:	81 e0       	ldi	r24, 0x01	; 1
    992e:	40 e0       	ldi	r20, 0x00	; 0
    9930:	50 e0       	ldi	r21, 0x00	; 0
    9932:	60 e0       	ldi	r22, 0x00	; 0
    9934:	70 e4       	ldi	r23, 0x40	; 64
    9936:	2f ef       	ldi	r18, 0xFF	; 255
    9938:	08 e0       	ldi	r16, 0x08	; 8
    993a:	10 e0       	ldi	r17, 0x00	; 0
    993c:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
	} while(Buffer[1]!= 0x00);
    9940:	80 91 89 50 	lds	r24, 0x5089
    9944:	88 23       	and	r24, r24
    9946:	49 f7       	brne	.-46     	; 0x991a <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9948:	1a 86       	std	Y+10, r1	; 0x0a
    994a:	1b 86       	std	Y+11, r1	; 0x0b
    994c:	0d c0       	rjmp	.+26     	; 0x9968 <SD_init+0x3aa>
		if (i >= 10) {
    994e:	8a 85       	ldd	r24, Y+10	; 0x0a
    9950:	9b 85       	ldd	r25, Y+11	; 0x0b
    9952:	8a 30       	cpi	r24, 0x0A	; 10
    9954:	91 05       	cpc	r25, r1
    9956:	1c f0       	brlt	.+6      	; 0x995e <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    9958:	81 e0       	ldi	r24, 0x01	; 1
    995a:	89 83       	std	Y+1, r24	; 0x01
			break;
    995c:	10 c0       	rjmp	.+32     	; 0x997e <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    995e:	8a 85       	ldd	r24, Y+10	; 0x0a
    9960:	9b 85       	ldd	r25, Y+11	; 0x0b
    9962:	01 96       	adiw	r24, 0x01	; 1
    9964:	8a 87       	std	Y+10, r24	; 0x0a
    9966:	9b 87       	std	Y+11, r25	; 0x0b
    9968:	8a e3       	ldi	r24, 0x3A	; 58
    996a:	40 e0       	ldi	r20, 0x00	; 0
    996c:	50 e0       	ldi	r21, 0x00	; 0
    996e:	ba 01       	movw	r22, r20
    9970:	2f ef       	ldi	r18, 0xFF	; 255
    9972:	08 e0       	ldi	r16, 0x08	; 8
    9974:	10 e0       	ldi	r17, 0x00	; 0
    9976:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
    997a:	88 23       	and	r24, r24
    997c:	41 f7       	brne	.-48     	; 0x994e <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    997e:	1c 86       	std	Y+12, r1	; 0x0c
    9980:	1d 86       	std	Y+13, r1	; 0x0d
    9982:	0f c0       	rjmp	.+30     	; 0x99a2 <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9984:	8f ef       	ldi	r24, 0xFF	; 255
    9986:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    998a:	28 2f       	mov	r18, r24
    998c:	8c 85       	ldd	r24, Y+12	; 0x0c
    998e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9990:	88 57       	subi	r24, 0x78	; 120
    9992:	9f 4a       	sbci	r25, 0xAF	; 175
    9994:	fc 01       	movw	r30, r24
    9996:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9998:	8c 85       	ldd	r24, Y+12	; 0x0c
    999a:	9d 85       	ldd	r25, Y+13	; 0x0d
    999c:	01 96       	adiw	r24, 0x01	; 1
    999e:	8c 87       	std	Y+12, r24	; 0x0c
    99a0:	9d 87       	std	Y+13, r25	; 0x0d
    99a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    99a4:	9d 85       	ldd	r25, Y+13	; 0x0d
    99a6:	84 30       	cpi	r24, 0x04	; 4
    99a8:	91 05       	cpc	r25, r1
    99aa:	64 f3       	brlt	.-40     	; 0x9984 <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    99ac:	80 91 88 50 	lds	r24, 0x5088
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    99b0:	80 e0       	ldi	r24, 0x00	; 0
    99b2:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    99b6:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    99ba:	88 e0       	ldi	r24, 0x08	; 8
    99bc:	60 e0       	ldi	r22, 0x00	; 0
    99be:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
	return errorCode;	
    99c2:	89 81       	ldd	r24, Y+1	; 0x01
}	
    99c4:	a9 96       	adiw	r28, 0x29	; 41
    99c6:	cd bf       	out	0x3d, r28	; 61
    99c8:	de bf       	out	0x3e, r29	; 62
    99ca:	df 91       	pop	r29
    99cc:	cf 91       	pop	r28
    99ce:	1f 91       	pop	r17
    99d0:	0f 91       	pop	r16
    99d2:	08 95       	ret

000099d4 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    99d4:	cf 93       	push	r28
    99d6:	df 93       	push	r29
    99d8:	0f 92       	push	r0
    99da:	0f 92       	push	r0
    99dc:	cd b7       	in	r28, 0x3d	; 61
    99de:	de b7       	in	r29, 0x3e	; 62
    99e0:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    99e2:	80 ec       	ldi	r24, 0xC0	; 192
    99e4:	98 e0       	ldi	r25, 0x08	; 8
    99e6:	2a 81       	ldd	r18, Y+2	; 0x02
    99e8:	fc 01       	movw	r30, r24
    99ea:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    99ec:	00 00       	nop
    99ee:	80 ec       	ldi	r24, 0xC0	; 192
    99f0:	98 e0       	ldi	r25, 0x08	; 8
    99f2:	fc 01       	movw	r30, r24
    99f4:	82 81       	ldd	r24, Z+2	; 0x02
    99f6:	88 23       	and	r24, r24
    99f8:	d4 f7       	brge	.-12     	; 0x99ee <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    99fa:	80 ec       	ldi	r24, 0xC0	; 192
    99fc:	98 e0       	ldi	r25, 0x08	; 8
    99fe:	fc 01       	movw	r30, r24
    9a00:	83 81       	ldd	r24, Z+3	; 0x03
    9a02:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9a04:	89 81       	ldd	r24, Y+1	; 0x01
}
    9a06:	0f 90       	pop	r0
    9a08:	0f 90       	pop	r0
    9a0a:	df 91       	pop	r29
    9a0c:	cf 91       	pop	r28
    9a0e:	08 95       	ret

00009a10 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9a10:	0f 93       	push	r16
    9a12:	1f 93       	push	r17
    9a14:	cf 93       	push	r28
    9a16:	df 93       	push	r29
    9a18:	cd b7       	in	r28, 0x3d	; 61
    9a1a:	de b7       	in	r29, 0x3e	; 62
    9a1c:	2a 97       	sbiw	r28, 0x0a	; 10
    9a1e:	cd bf       	out	0x3d, r28	; 61
    9a20:	de bf       	out	0x3e, r29	; 62
    9a22:	8b 83       	std	Y+3, r24	; 0x03
    9a24:	4c 83       	std	Y+4, r20	; 0x04
    9a26:	5d 83       	std	Y+5, r21	; 0x05
    9a28:	6e 83       	std	Y+6, r22	; 0x06
    9a2a:	7f 83       	std	Y+7, r23	; 0x07
    9a2c:	28 87       	std	Y+8, r18	; 0x08
    9a2e:	09 87       	std	Y+9, r16	; 0x09
    9a30:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9a32:	8b 81       	ldd	r24, Y+3	; 0x03
    9a34:	80 64       	ori	r24, 0x40	; 64
    9a36:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9a3a:	8c 81       	ldd	r24, Y+4	; 0x04
    9a3c:	9d 81       	ldd	r25, Y+5	; 0x05
    9a3e:	ae 81       	ldd	r26, Y+6	; 0x06
    9a40:	bf 81       	ldd	r27, Y+7	; 0x07
    9a42:	8b 2f       	mov	r24, r27
    9a44:	99 27       	eor	r25, r25
    9a46:	aa 27       	eor	r26, r26
    9a48:	bb 27       	eor	r27, r27
    9a4a:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9a4e:	8c 81       	ldd	r24, Y+4	; 0x04
    9a50:	9d 81       	ldd	r25, Y+5	; 0x05
    9a52:	ae 81       	ldd	r26, Y+6	; 0x06
    9a54:	bf 81       	ldd	r27, Y+7	; 0x07
    9a56:	cd 01       	movw	r24, r26
    9a58:	aa 27       	eor	r26, r26
    9a5a:	bb 27       	eor	r27, r27
    9a5c:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9a60:	8c 81       	ldd	r24, Y+4	; 0x04
    9a62:	9d 81       	ldd	r25, Y+5	; 0x05
    9a64:	ae 81       	ldd	r26, Y+6	; 0x06
    9a66:	bf 81       	ldd	r27, Y+7	; 0x07
    9a68:	89 2f       	mov	r24, r25
    9a6a:	9a 2f       	mov	r25, r26
    9a6c:	ab 2f       	mov	r26, r27
    9a6e:	bb 27       	eor	r27, r27
    9a70:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9a74:	8c 81       	ldd	r24, Y+4	; 0x04
    9a76:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
	SPI_write(crc);
    9a7a:	88 85       	ldd	r24, Y+8	; 0x08
    9a7c:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
	
	for(int i=0; i<read; i++){
    9a80:	19 82       	std	Y+1, r1	; 0x01
    9a82:	1a 82       	std	Y+2, r1	; 0x02
    9a84:	33 c0       	rjmp	.+102    	; 0x9aec <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9a86:	89 81       	ldd	r24, Y+1	; 0x01
    9a88:	9a 81       	ldd	r25, Y+2	; 0x02
    9a8a:	2d e0       	ldi	r18, 0x0D	; 13
    9a8c:	30 e0       	ldi	r19, 0x00	; 0
    9a8e:	b9 01       	movw	r22, r18
    9a90:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9a94:	8c 01       	movw	r16, r24
    9a96:	8f ef       	ldi	r24, 0xFF	; 255
    9a98:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9a9c:	28 2f       	mov	r18, r24
    9a9e:	c8 01       	movw	r24, r16
    9aa0:	88 57       	subi	r24, 0x78	; 120
    9aa2:	9f 4a       	sbci	r25, 0xAF	; 175
    9aa4:	fc 01       	movw	r30, r24
    9aa6:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9aa8:	89 81       	ldd	r24, Y+1	; 0x01
    9aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    9aac:	2d e0       	ldi	r18, 0x0D	; 13
    9aae:	30 e0       	ldi	r19, 0x00	; 0
    9ab0:	b9 01       	movw	r22, r18
    9ab2:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9ab6:	88 57       	subi	r24, 0x78	; 120
    9ab8:	9f 4a       	sbci	r25, 0xAF	; 175
    9aba:	fc 01       	movw	r30, r24
    9abc:	80 81       	ld	r24, Z
    9abe:	8f 3f       	cpi	r24, 0xFF	; 255
    9ac0:	81 f0       	breq	.+32     	; 0x9ae2 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9ac2:	89 81       	ldd	r24, Y+1	; 0x01
    9ac4:	9a 81       	ldd	r25, Y+2	; 0x02
    9ac6:	2d e0       	ldi	r18, 0x0D	; 13
    9ac8:	30 e0       	ldi	r19, 0x00	; 0
    9aca:	b9 01       	movw	r22, r18
    9acc:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9ad0:	88 57       	subi	r24, 0x78	; 120
    9ad2:	9f 4a       	sbci	r25, 0xAF	; 175
    9ad4:	fc 01       	movw	r30, r24
    9ad6:	80 81       	ld	r24, Z
    9ad8:	80 93 89 50 	sts	0x5089, r24
			return Buffer[1];
    9adc:	80 91 89 50 	lds	r24, 0x5089
    9ae0:	0d c0       	rjmp	.+26     	; 0x9afc <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9ae2:	89 81       	ldd	r24, Y+1	; 0x01
    9ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    9ae6:	01 96       	adiw	r24, 0x01	; 1
    9ae8:	89 83       	std	Y+1, r24	; 0x01
    9aea:	9a 83       	std	Y+2, r25	; 0x02
    9aec:	29 81       	ldd	r18, Y+1	; 0x01
    9aee:	3a 81       	ldd	r19, Y+2	; 0x02
    9af0:	89 85       	ldd	r24, Y+9	; 0x09
    9af2:	9a 85       	ldd	r25, Y+10	; 0x0a
    9af4:	28 17       	cp	r18, r24
    9af6:	39 07       	cpc	r19, r25
    9af8:	34 f2       	brlt	.-116    	; 0x9a86 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9afa:	8f ef       	ldi	r24, 0xFF	; 255
}
    9afc:	2a 96       	adiw	r28, 0x0a	; 10
    9afe:	cd bf       	out	0x3d, r28	; 61
    9b00:	de bf       	out	0x3e, r29	; 62
    9b02:	df 91       	pop	r29
    9b04:	cf 91       	pop	r28
    9b06:	1f 91       	pop	r17
    9b08:	0f 91       	pop	r16
    9b0a:	08 95       	ret

00009b0c <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9b0c:	0f 93       	push	r16
    9b0e:	1f 93       	push	r17
    9b10:	cf 93       	push	r28
    9b12:	df 93       	push	r29
    9b14:	cd b7       	in	r28, 0x3d	; 61
    9b16:	de b7       	in	r29, 0x3e	; 62
    9b18:	62 97       	sbiw	r28, 0x12	; 18
    9b1a:	cd bf       	out	0x3d, r28	; 61
    9b1c:	de bf       	out	0x3e, r29	; 62
    9b1e:	6b 87       	std	Y+11, r22	; 0x0b
    9b20:	7c 87       	std	Y+12, r23	; 0x0c
    9b22:	8d 87       	std	Y+13, r24	; 0x0d
    9b24:	9e 87       	std	Y+14, r25	; 0x0e
    9b26:	4f 87       	std	Y+15, r20	; 0x0f
    9b28:	58 8b       	std	Y+16, r21	; 0x10
    9b2a:	29 8b       	std	Y+17, r18	; 0x11
    9b2c:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9b2e:	88 e0       	ldi	r24, 0x08	; 8
    9b30:	60 e0       	ldi	r22, 0x00	; 0
    9b32:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9b36:	80 e0       	ldi	r24, 0x00	; 0
    9b38:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    9b3c:	81 e0       	ldi	r24, 0x01	; 1
    9b3e:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9b42:	20 e0       	ldi	r18, 0x00	; 0
    9b44:	32 e0       	ldi	r19, 0x02	; 2
    9b46:	89 89       	ldd	r24, Y+17	; 0x11
    9b48:	9a 89       	ldd	r25, Y+18	; 0x12
    9b4a:	a9 01       	movw	r20, r18
    9b4c:	48 1b       	sub	r20, r24
    9b4e:	59 0b       	sbc	r21, r25
    9b50:	ca 01       	movw	r24, r20
    9b52:	89 83       	std	Y+1, r24	; 0x01
    9b54:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9b56:	89 81       	ldd	r24, Y+1	; 0x01
    9b58:	9a 81       	ldd	r25, Y+2	; 0x02
    9b5a:	52 e0       	ldi	r21, 0x02	; 2
    9b5c:	80 30       	cpi	r24, 0x00	; 0
    9b5e:	95 07       	cpc	r25, r21
    9b60:	11 f4       	brne	.+4      	; 0x9b66 <SD_write_block+0x5a>
    9b62:	19 82       	std	Y+1, r1	; 0x01
    9b64:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9b66:	1b 82       	std	Y+3, r1	; 0x03
    9b68:	1c 82       	std	Y+4, r1	; 0x04
    9b6a:	0b c0       	rjmp	.+22     	; 0x9b82 <SD_write_block+0x76>
	if (i >= 10) {
    9b6c:	8b 81       	ldd	r24, Y+3	; 0x03
    9b6e:	9c 81       	ldd	r25, Y+4	; 0x04
    9b70:	8a 30       	cpi	r24, 0x0A	; 10
    9b72:	91 05       	cpc	r25, r1
    9b74:	0c f0       	brlt	.+2      	; 0x9b78 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9b76:	ff cf       	rjmp	.-2      	; 0x9b76 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9b78:	8b 81       	ldd	r24, Y+3	; 0x03
    9b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    9b7c:	01 96       	adiw	r24, 0x01	; 1
    9b7e:	8b 83       	std	Y+3, r24	; 0x03
    9b80:	9c 83       	std	Y+4, r25	; 0x04
    9b82:	2b 85       	ldd	r18, Y+11	; 0x0b
    9b84:	3c 85       	ldd	r19, Y+12	; 0x0c
    9b86:	4d 85       	ldd	r20, Y+13	; 0x0d
    9b88:	5e 85       	ldd	r21, Y+14	; 0x0e
    9b8a:	88 e1       	ldi	r24, 0x18	; 24
    9b8c:	ba 01       	movw	r22, r20
    9b8e:	a9 01       	movw	r20, r18
    9b90:	2f ef       	ldi	r18, 0xFF	; 255
    9b92:	08 e0       	ldi	r16, 0x08	; 8
    9b94:	10 e0       	ldi	r17, 0x00	; 0
    9b96:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
    9b9a:	88 23       	and	r24, r24
    9b9c:	39 f7       	brne	.-50     	; 0x9b6c <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9b9e:	8f ef       	ldi	r24, 0xFF	; 255
    9ba0:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9ba4:	80 93 88 50 	sts	0x5088, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9ba8:	8e ef       	ldi	r24, 0xFE	; 254
    9baa:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9bae:	1d 82       	std	Y+5, r1	; 0x05
    9bb0:	1e 82       	std	Y+6, r1	; 0x06
    9bb2:	1d c0       	rjmp	.+58     	; 0x9bee <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9bb4:	8d 81       	ldd	r24, Y+5	; 0x05
    9bb6:	9e 81       	ldd	r25, Y+6	; 0x06
    9bb8:	2d e0       	ldi	r18, 0x0D	; 13
    9bba:	30 e0       	ldi	r19, 0x00	; 0
    9bbc:	b9 01       	movw	r22, r18
    9bbe:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9bc2:	8c 01       	movw	r16, r24
    9bc4:	8d 81       	ldd	r24, Y+5	; 0x05
    9bc6:	9e 81       	ldd	r25, Y+6	; 0x06
    9bc8:	2f 85       	ldd	r18, Y+15	; 0x0f
    9bca:	38 89       	ldd	r19, Y+16	; 0x10
    9bcc:	82 0f       	add	r24, r18
    9bce:	93 1f       	adc	r25, r19
    9bd0:	fc 01       	movw	r30, r24
    9bd2:	80 81       	ld	r24, Z
    9bd4:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9bd8:	28 2f       	mov	r18, r24
    9bda:	c8 01       	movw	r24, r16
    9bdc:	88 57       	subi	r24, 0x78	; 120
    9bde:	9f 4a       	sbci	r25, 0xAF	; 175
    9be0:	fc 01       	movw	r30, r24
    9be2:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9be4:	8d 81       	ldd	r24, Y+5	; 0x05
    9be6:	9e 81       	ldd	r25, Y+6	; 0x06
    9be8:	01 96       	adiw	r24, 0x01	; 1
    9bea:	8d 83       	std	Y+5, r24	; 0x05
    9bec:	9e 83       	std	Y+6, r25	; 0x06
    9bee:	2d 81       	ldd	r18, Y+5	; 0x05
    9bf0:	3e 81       	ldd	r19, Y+6	; 0x06
    9bf2:	89 89       	ldd	r24, Y+17	; 0x11
    9bf4:	9a 89       	ldd	r25, Y+18	; 0x12
    9bf6:	28 17       	cp	r18, r24
    9bf8:	39 07       	cpc	r19, r25
    9bfa:	e4 f2       	brlt	.-72     	; 0x9bb4 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9bfc:	1f 82       	std	Y+7, r1	; 0x07
    9bfe:	18 86       	std	Y+8, r1	; 0x08
    9c00:	16 c0       	rjmp	.+44     	; 0x9c2e <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9c02:	8f 81       	ldd	r24, Y+7	; 0x07
    9c04:	98 85       	ldd	r25, Y+8	; 0x08
    9c06:	2d e0       	ldi	r18, 0x0D	; 13
    9c08:	30 e0       	ldi	r19, 0x00	; 0
    9c0a:	b9 01       	movw	r22, r18
    9c0c:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9c10:	8c 01       	movw	r16, r24
    9c12:	80 e0       	ldi	r24, 0x00	; 0
    9c14:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9c18:	28 2f       	mov	r18, r24
    9c1a:	c8 01       	movw	r24, r16
    9c1c:	88 57       	subi	r24, 0x78	; 120
    9c1e:	9f 4a       	sbci	r25, 0xAF	; 175
    9c20:	fc 01       	movw	r30, r24
    9c22:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9c24:	8f 81       	ldd	r24, Y+7	; 0x07
    9c26:	98 85       	ldd	r25, Y+8	; 0x08
    9c28:	01 96       	adiw	r24, 0x01	; 1
    9c2a:	8f 83       	std	Y+7, r24	; 0x07
    9c2c:	98 87       	std	Y+8, r25	; 0x08
    9c2e:	2f 81       	ldd	r18, Y+7	; 0x07
    9c30:	38 85       	ldd	r19, Y+8	; 0x08
    9c32:	89 81       	ldd	r24, Y+1	; 0x01
    9c34:	9a 81       	ldd	r25, Y+2	; 0x02
    9c36:	28 17       	cp	r18, r24
    9c38:	39 07       	cpc	r19, r25
    9c3a:	1c f3       	brlt	.-58     	; 0x9c02 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9c3c:	8f ef       	ldi	r24, 0xFF	; 255
    9c3e:	80 93 88 50 	sts	0x5088, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9c42:	19 86       	std	Y+9, r1	; 0x09
    9c44:	1a 86       	std	Y+10, r1	; 0x0a
    9c46:	0a c0       	rjmp	.+20     	; 0x9c5c <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9c48:	8f ef       	ldi	r24, 0xFF	; 255
    9c4a:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9c4e:	80 93 88 50 	sts	0x5088, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9c52:	89 85       	ldd	r24, Y+9	; 0x09
    9c54:	9a 85       	ldd	r25, Y+10	; 0x0a
    9c56:	01 96       	adiw	r24, 0x01	; 1
    9c58:	89 87       	std	Y+9, r24	; 0x09
    9c5a:	9a 87       	std	Y+10, r25	; 0x0a
    9c5c:	89 85       	ldd	r24, Y+9	; 0x09
    9c5e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9c60:	82 30       	cpi	r24, 0x02	; 2
    9c62:	91 05       	cpc	r25, r1
    9c64:	8c f3       	brlt	.-30     	; 0x9c48 <SD_write_block+0x13c>
    9c66:	80 91 88 50 	lds	r24, 0x5088
    9c6a:	8f 3f       	cpi	r24, 0xFF	; 255
    9c6c:	69 f3       	breq	.-38     	; 0x9c48 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9c6e:	80 91 88 50 	lds	r24, 0x5088
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9c72:	05 c0       	rjmp	.+10     	; 0x9c7e <SD_write_block+0x172>
    9c74:	8f ef       	ldi	r24, 0xFF	; 255
    9c76:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9c7a:	80 93 88 50 	sts	0x5088, r24
    9c7e:	80 91 88 50 	lds	r24, 0x5088
    9c82:	8f 3f       	cpi	r24, 0xFF	; 255
    9c84:	b9 f7       	brne	.-18     	; 0x9c74 <SD_write_block+0x168>
	SPICS(FALSE);
    9c86:	80 e0       	ldi	r24, 0x00	; 0
    9c88:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    9c8c:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9c90:	88 e0       	ldi	r24, 0x08	; 8
    9c92:	60 e0       	ldi	r22, 0x00	; 0
    9c94:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
}
    9c98:	62 96       	adiw	r28, 0x12	; 18
    9c9a:	cd bf       	out	0x3d, r28	; 61
    9c9c:	de bf       	out	0x3e, r29	; 62
    9c9e:	df 91       	pop	r29
    9ca0:	cf 91       	pop	r28
    9ca2:	1f 91       	pop	r17
    9ca4:	0f 91       	pop	r16
    9ca6:	08 95       	ret

00009ca8 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9ca8:	0f 93       	push	r16
    9caa:	1f 93       	push	r17
    9cac:	cf 93       	push	r28
    9cae:	df 93       	push	r29
    9cb0:	cd b7       	in	r28, 0x3d	; 61
    9cb2:	de b7       	in	r29, 0x3e	; 62
    9cb4:	2a 97       	sbiw	r28, 0x0a	; 10
    9cb6:	cd bf       	out	0x3d, r28	; 61
    9cb8:	de bf       	out	0x3e, r29	; 62
    9cba:	6d 83       	std	Y+5, r22	; 0x05
    9cbc:	7e 83       	std	Y+6, r23	; 0x06
    9cbe:	8f 83       	std	Y+7, r24	; 0x07
    9cc0:	98 87       	std	Y+8, r25	; 0x08
    9cc2:	49 87       	std	Y+9, r20	; 0x09
    9cc4:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9cc6:	88 e0       	ldi	r24, 0x08	; 8
    9cc8:	60 e0       	ldi	r22, 0x00	; 0
    9cca:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9cce:	80 e0       	ldi	r24, 0x00	; 0
    9cd0:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    9cd4:	81 e0       	ldi	r24, 0x01	; 1
    9cd6:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9cda:	19 82       	std	Y+1, r1	; 0x01
    9cdc:	1a 82       	std	Y+2, r1	; 0x02
    9cde:	0b c0       	rjmp	.+22     	; 0x9cf6 <SD_read_block+0x4e>
		if (i >= 10) {
    9ce0:	89 81       	ldd	r24, Y+1	; 0x01
    9ce2:	9a 81       	ldd	r25, Y+2	; 0x02
    9ce4:	8a 30       	cpi	r24, 0x0A	; 10
    9ce6:	91 05       	cpc	r25, r1
    9ce8:	0c f0       	brlt	.+2      	; 0x9cec <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9cea:	ff cf       	rjmp	.-2      	; 0x9cea <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9cec:	89 81       	ldd	r24, Y+1	; 0x01
    9cee:	9a 81       	ldd	r25, Y+2	; 0x02
    9cf0:	01 96       	adiw	r24, 0x01	; 1
    9cf2:	89 83       	std	Y+1, r24	; 0x01
    9cf4:	9a 83       	std	Y+2, r25	; 0x02
    9cf6:	2d 81       	ldd	r18, Y+5	; 0x05
    9cf8:	3e 81       	ldd	r19, Y+6	; 0x06
    9cfa:	4f 81       	ldd	r20, Y+7	; 0x07
    9cfc:	58 85       	ldd	r21, Y+8	; 0x08
    9cfe:	81 e1       	ldi	r24, 0x11	; 17
    9d00:	ba 01       	movw	r22, r20
    9d02:	a9 01       	movw	r20, r18
    9d04:	2f ef       	ldi	r18, 0xFF	; 255
    9d06:	08 e0       	ldi	r16, 0x08	; 8
    9d08:	10 e0       	ldi	r17, 0x00	; 0
    9d0a:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
    9d0e:	88 23       	and	r24, r24
    9d10:	39 f7       	brne	.-50     	; 0x9ce0 <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9d12:	05 c0       	rjmp	.+10     	; 0x9d1e <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9d14:	8f ef       	ldi	r24, 0xFF	; 255
    9d16:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9d1a:	80 93 88 50 	sts	0x5088, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9d1e:	80 91 88 50 	lds	r24, 0x5088
    9d22:	8e 3f       	cpi	r24, 0xFE	; 254
    9d24:	b9 f7       	brne	.-18     	; 0x9d14 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9d26:	1b 82       	std	Y+3, r1	; 0x03
    9d28:	1c 82       	std	Y+4, r1	; 0x04
    9d2a:	11 c0       	rjmp	.+34     	; 0x9d4e <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9d2c:	8b 81       	ldd	r24, Y+3	; 0x03
    9d2e:	9c 81       	ldd	r25, Y+4	; 0x04
    9d30:	29 85       	ldd	r18, Y+9	; 0x09
    9d32:	3a 85       	ldd	r19, Y+10	; 0x0a
    9d34:	89 01       	movw	r16, r18
    9d36:	08 0f       	add	r16, r24
    9d38:	19 1f       	adc	r17, r25
    9d3a:	8f ef       	ldi	r24, 0xFF	; 255
    9d3c:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9d40:	f8 01       	movw	r30, r16
    9d42:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9d44:	8b 81       	ldd	r24, Y+3	; 0x03
    9d46:	9c 81       	ldd	r25, Y+4	; 0x04
    9d48:	01 96       	adiw	r24, 0x01	; 1
    9d4a:	8b 83       	std	Y+3, r24	; 0x03
    9d4c:	9c 83       	std	Y+4, r25	; 0x04
    9d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    9d50:	9c 81       	ldd	r25, Y+4	; 0x04
    9d52:	f2 e0       	ldi	r31, 0x02	; 2
    9d54:	80 30       	cpi	r24, 0x00	; 0
    9d56:	9f 07       	cpc	r25, r31
    9d58:	4c f3       	brlt	.-46     	; 0x9d2c <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    9d5a:	10 92 94 50 	sts	0x5094, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9d5e:	05 c0       	rjmp	.+10     	; 0x9d6a <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    9d60:	8f ef       	ldi	r24, 0xFF	; 255
    9d62:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9d66:	80 93 94 50 	sts	0x5094, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9d6a:	80 91 94 50 	lds	r24, 0x5094
    9d6e:	8f 3f       	cpi	r24, 0xFF	; 255
    9d70:	b9 f7       	brne	.-18     	; 0x9d60 <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    9d72:	80 e0       	ldi	r24, 0x00	; 0
    9d74:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    9d78:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9d7c:	88 e0       	ldi	r24, 0x08	; 8
    9d7e:	60 e0       	ldi	r22, 0x00	; 0
    9d80:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
}
    9d84:	2a 96       	adiw	r28, 0x0a	; 10
    9d86:	cd bf       	out	0x3d, r28	; 61
    9d88:	de bf       	out	0x3e, r29	; 62
    9d8a:	df 91       	pop	r29
    9d8c:	cf 91       	pop	r28
    9d8e:	1f 91       	pop	r17
    9d90:	0f 91       	pop	r16
    9d92:	08 95       	ret

00009d94 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    9d94:	0f 93       	push	r16
    9d96:	1f 93       	push	r17
    9d98:	cf 93       	push	r28
    9d9a:	df 93       	push	r29
    9d9c:	cd b7       	in	r28, 0x3d	; 61
    9d9e:	de b7       	in	r29, 0x3e	; 62
    9da0:	6a 97       	sbiw	r28, 0x1a	; 26
    9da2:	cd bf       	out	0x3d, r28	; 61
    9da4:	de bf       	out	0x3e, r29	; 62
    9da6:	6b 8b       	std	Y+19, r22	; 0x13
    9da8:	7c 8b       	std	Y+20, r23	; 0x14
    9daa:	8d 8b       	std	Y+21, r24	; 0x15
    9dac:	9e 8b       	std	Y+22, r25	; 0x16
    9dae:	4f 8b       	std	Y+23, r20	; 0x17
    9db0:	58 8f       	std	Y+24, r21	; 0x18
    9db2:	29 8f       	std	Y+25, r18	; 0x19
    9db4:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9db6:	88 e0       	ldi	r24, 0x08	; 8
    9db8:	60 e0       	ldi	r22, 0x00	; 0
    9dba:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9dbe:	80 e0       	ldi	r24, 0x00	; 0
    9dc0:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    9dc4:	81 e0       	ldi	r24, 0x01	; 1
    9dc6:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    9dca:	89 8d       	ldd	r24, Y+25	; 0x19
    9dcc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9dce:	99 23       	and	r25, r25
    9dd0:	14 f4       	brge	.+4      	; 0x9dd6 <SD_write_multiple_blocks+0x42>
    9dd2:	81 50       	subi	r24, 0x01	; 1
    9dd4:	9e 4f       	sbci	r25, 0xFE	; 254
    9dd6:	89 2f       	mov	r24, r25
    9dd8:	99 0f       	add	r25, r25
    9dda:	99 0b       	sbc	r25, r25
    9ddc:	85 95       	asr	r24
    9dde:	89 83       	std	Y+1, r24	; 0x01
    9de0:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    9de2:	89 8d       	ldd	r24, Y+25	; 0x19
    9de4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9de6:	20 e0       	ldi	r18, 0x00	; 0
    9de8:	32 e0       	ldi	r19, 0x02	; 2
    9dea:	b9 01       	movw	r22, r18
    9dec:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9df0:	20 e0       	ldi	r18, 0x00	; 0
    9df2:	32 e0       	ldi	r19, 0x02	; 2
    9df4:	a9 01       	movw	r20, r18
    9df6:	48 1b       	sub	r20, r24
    9df8:	59 0b       	sbc	r21, r25
    9dfa:	ca 01       	movw	r24, r20
    9dfc:	8b 83       	std	Y+3, r24	; 0x03
    9dfe:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9e00:	8b 81       	ldd	r24, Y+3	; 0x03
    9e02:	9c 81       	ldd	r25, Y+4	; 0x04
    9e04:	52 e0       	ldi	r21, 0x02	; 2
    9e06:	80 30       	cpi	r24, 0x00	; 0
    9e08:	95 07       	cpc	r25, r21
    9e0a:	19 f4       	brne	.+6      	; 0x9e12 <SD_write_multiple_blocks+0x7e>
    9e0c:	1b 82       	std	Y+3, r1	; 0x03
    9e0e:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9e10:	05 c0       	rjmp	.+10     	; 0x9e1c <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    9e12:	89 81       	ldd	r24, Y+1	; 0x01
    9e14:	9a 81       	ldd	r25, Y+2	; 0x02
    9e16:	01 96       	adiw	r24, 0x01	; 1
    9e18:	89 83       	std	Y+1, r24	; 0x01
    9e1a:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9e1c:	00 00       	nop
    9e1e:	2b 89       	ldd	r18, Y+19	; 0x13
    9e20:	3c 89       	ldd	r19, Y+20	; 0x14
    9e22:	4d 89       	ldd	r20, Y+21	; 0x15
    9e24:	5e 89       	ldd	r21, Y+22	; 0x16
    9e26:	89 e1       	ldi	r24, 0x19	; 25
    9e28:	ba 01       	movw	r22, r20
    9e2a:	a9 01       	movw	r20, r18
    9e2c:	2f ef       	ldi	r18, 0xFF	; 255
    9e2e:	08 e0       	ldi	r16, 0x08	; 8
    9e30:	10 e0       	ldi	r17, 0x00	; 0
    9e32:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
    9e36:	88 23       	and	r24, r24
    9e38:	91 f7       	brne	.-28     	; 0x9e1e <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    9e3a:	1d 82       	std	Y+5, r1	; 0x05
    9e3c:	1e 82       	std	Y+6, r1	; 0x06
    9e3e:	ba c0       	rjmp	.+372    	; 0x9fb4 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    9e40:	8f ef       	ldi	r24, 0xFF	; 255
    9e42:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9e46:	80 93 89 50 	sts	0x5089, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    9e4a:	8c ef       	ldi	r24, 0xFC	; 252
    9e4c:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9e50:	80 93 89 50 	sts	0x5089, r24
		if(j == (numSectors-1)){
    9e54:	89 81       	ldd	r24, Y+1	; 0x01
    9e56:	9a 81       	ldd	r25, Y+2	; 0x02
    9e58:	9c 01       	movw	r18, r24
    9e5a:	21 50       	subi	r18, 0x01	; 1
    9e5c:	30 40       	sbci	r19, 0x00	; 0
    9e5e:	8d 81       	ldd	r24, Y+5	; 0x05
    9e60:	9e 81       	ldd	r25, Y+6	; 0x06
    9e62:	28 17       	cp	r18, r24
    9e64:	39 07       	cpc	r19, r25
    9e66:	09 f0       	breq	.+2      	; 0x9e6a <SD_write_multiple_blocks+0xd6>
    9e68:	54 c0       	rjmp	.+168    	; 0x9f12 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9e6a:	1f 82       	std	Y+7, r1	; 0x07
    9e6c:	18 86       	std	Y+8, r1	; 0x08
    9e6e:	25 c0       	rjmp	.+74     	; 0x9eba <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9e70:	8f 81       	ldd	r24, Y+7	; 0x07
    9e72:	98 85       	ldd	r25, Y+8	; 0x08
    9e74:	2c e0       	ldi	r18, 0x0C	; 12
    9e76:	30 e0       	ldi	r19, 0x00	; 0
    9e78:	b9 01       	movw	r22, r18
    9e7a:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9e7e:	8c 01       	movw	r16, r24
    9e80:	8d 81       	ldd	r24, Y+5	; 0x05
    9e82:	9e 81       	ldd	r25, Y+6	; 0x06
    9e84:	9c 01       	movw	r18, r24
    9e86:	32 2f       	mov	r19, r18
    9e88:	22 27       	eor	r18, r18
    9e8a:	33 0f       	add	r19, r19
    9e8c:	8f 81       	ldd	r24, Y+7	; 0x07
    9e8e:	98 85       	ldd	r25, Y+8	; 0x08
    9e90:	82 0f       	add	r24, r18
    9e92:	93 1f       	adc	r25, r19
    9e94:	2f 89       	ldd	r18, Y+23	; 0x17
    9e96:	38 8d       	ldd	r19, Y+24	; 0x18
    9e98:	82 0f       	add	r24, r18
    9e9a:	93 1f       	adc	r25, r19
    9e9c:	fc 01       	movw	r30, r24
    9e9e:	80 81       	ld	r24, Z
    9ea0:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9ea4:	28 2f       	mov	r18, r24
    9ea6:	c8 01       	movw	r24, r16
    9ea8:	88 57       	subi	r24, 0x78	; 120
    9eaa:	9f 4a       	sbci	r25, 0xAF	; 175
    9eac:	fc 01       	movw	r30, r24
    9eae:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9eb0:	8f 81       	ldd	r24, Y+7	; 0x07
    9eb2:	98 85       	ldd	r25, Y+8	; 0x08
    9eb4:	01 96       	adiw	r24, 0x01	; 1
    9eb6:	8f 83       	std	Y+7, r24	; 0x07
    9eb8:	98 87       	std	Y+8, r25	; 0x08
    9eba:	20 e0       	ldi	r18, 0x00	; 0
    9ebc:	32 e0       	ldi	r19, 0x02	; 2
    9ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    9ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    9ec2:	28 1b       	sub	r18, r24
    9ec4:	39 0b       	sbc	r19, r25
    9ec6:	8f 81       	ldd	r24, Y+7	; 0x07
    9ec8:	98 85       	ldd	r25, Y+8	; 0x08
    9eca:	82 17       	cp	r24, r18
    9ecc:	93 07       	cpc	r25, r19
    9ece:	84 f2       	brlt	.-96     	; 0x9e70 <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9ed0:	19 86       	std	Y+9, r1	; 0x09
    9ed2:	1a 86       	std	Y+10, r1	; 0x0a
    9ed4:	16 c0       	rjmp	.+44     	; 0x9f02 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    9ed6:	89 85       	ldd	r24, Y+9	; 0x09
    9ed8:	9a 85       	ldd	r25, Y+10	; 0x0a
    9eda:	2c e0       	ldi	r18, 0x0C	; 12
    9edc:	30 e0       	ldi	r19, 0x00	; 0
    9ede:	b9 01       	movw	r22, r18
    9ee0:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9ee4:	8c 01       	movw	r16, r24
    9ee6:	80 e0       	ldi	r24, 0x00	; 0
    9ee8:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9eec:	28 2f       	mov	r18, r24
    9eee:	c8 01       	movw	r24, r16
    9ef0:	88 57       	subi	r24, 0x78	; 120
    9ef2:	9f 4a       	sbci	r25, 0xAF	; 175
    9ef4:	fc 01       	movw	r30, r24
    9ef6:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9ef8:	89 85       	ldd	r24, Y+9	; 0x09
    9efa:	9a 85       	ldd	r25, Y+10	; 0x0a
    9efc:	01 96       	adiw	r24, 0x01	; 1
    9efe:	89 87       	std	Y+9, r24	; 0x09
    9f00:	9a 87       	std	Y+10, r25	; 0x0a
    9f02:	29 85       	ldd	r18, Y+9	; 0x09
    9f04:	3a 85       	ldd	r19, Y+10	; 0x0a
    9f06:	8b 81       	ldd	r24, Y+3	; 0x03
    9f08:	9c 81       	ldd	r25, Y+4	; 0x04
    9f0a:	28 17       	cp	r18, r24
    9f0c:	39 07       	cpc	r19, r25
    9f0e:	1c f3       	brlt	.-58     	; 0x9ed6 <SD_write_multiple_blocks+0x142>
    9f10:	2e c0       	rjmp	.+92     	; 0x9f6e <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9f12:	1b 86       	std	Y+11, r1	; 0x0b
    9f14:	1c 86       	std	Y+12, r1	; 0x0c
    9f16:	25 c0       	rjmp	.+74     	; 0x9f62 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9f18:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f1a:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f1c:	2c e0       	ldi	r18, 0x0C	; 12
    9f1e:	30 e0       	ldi	r19, 0x00	; 0
    9f20:	b9 01       	movw	r22, r18
    9f22:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    9f26:	8c 01       	movw	r16, r24
    9f28:	8d 81       	ldd	r24, Y+5	; 0x05
    9f2a:	9e 81       	ldd	r25, Y+6	; 0x06
    9f2c:	9c 01       	movw	r18, r24
    9f2e:	32 2f       	mov	r19, r18
    9f30:	22 27       	eor	r18, r18
    9f32:	33 0f       	add	r19, r19
    9f34:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f36:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f38:	82 0f       	add	r24, r18
    9f3a:	93 1f       	adc	r25, r19
    9f3c:	2f 89       	ldd	r18, Y+23	; 0x17
    9f3e:	38 8d       	ldd	r19, Y+24	; 0x18
    9f40:	82 0f       	add	r24, r18
    9f42:	93 1f       	adc	r25, r19
    9f44:	fc 01       	movw	r30, r24
    9f46:	80 81       	ld	r24, Z
    9f48:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9f4c:	28 2f       	mov	r18, r24
    9f4e:	c8 01       	movw	r24, r16
    9f50:	88 57       	subi	r24, 0x78	; 120
    9f52:	9f 4a       	sbci	r25, 0xAF	; 175
    9f54:	fc 01       	movw	r30, r24
    9f56:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9f58:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f5a:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f5c:	01 96       	adiw	r24, 0x01	; 1
    9f5e:	8b 87       	std	Y+11, r24	; 0x0b
    9f60:	9c 87       	std	Y+12, r25	; 0x0c
    9f62:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f64:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f66:	f2 e0       	ldi	r31, 0x02	; 2
    9f68:	80 30       	cpi	r24, 0x00	; 0
    9f6a:	9f 07       	cpc	r25, r31
    9f6c:	ac f2       	brlt	.-86     	; 0x9f18 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    9f6e:	1d 86       	std	Y+13, r1	; 0x0d
    9f70:	1e 86       	std	Y+14, r1	; 0x0e
    9f72:	0a c0       	rjmp	.+20     	; 0x9f88 <SD_write_multiple_blocks+0x1f4>
    9f74:	8f ef       	ldi	r24, 0xFF	; 255
    9f76:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9f7a:	80 93 89 50 	sts	0x5089, r24
    9f7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    9f80:	9e 85       	ldd	r25, Y+14	; 0x0e
    9f82:	01 96       	adiw	r24, 0x01	; 1
    9f84:	8d 87       	std	Y+13, r24	; 0x0d
    9f86:	9e 87       	std	Y+14, r25	; 0x0e
    9f88:	8d 85       	ldd	r24, Y+13	; 0x0d
    9f8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    9f8c:	82 30       	cpi	r24, 0x02	; 2
    9f8e:	91 05       	cpc	r25, r1
    9f90:	8c f3       	brlt	.-30     	; 0x9f74 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    9f92:	10 92 89 50 	sts	0x5089, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    9f96:	05 c0       	rjmp	.+10     	; 0x9fa2 <SD_write_multiple_blocks+0x20e>
    9f98:	8f ef       	ldi	r24, 0xFF	; 255
    9f9a:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9f9e:	80 93 89 50 	sts	0x5089, r24
    9fa2:	80 91 89 50 	lds	r24, 0x5089
    9fa6:	8f 3f       	cpi	r24, 0xFF	; 255
    9fa8:	b9 f7       	brne	.-18     	; 0x9f98 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    9faa:	8d 81       	ldd	r24, Y+5	; 0x05
    9fac:	9e 81       	ldd	r25, Y+6	; 0x06
    9fae:	01 96       	adiw	r24, 0x01	; 1
    9fb0:	8d 83       	std	Y+5, r24	; 0x05
    9fb2:	9e 83       	std	Y+6, r25	; 0x06
    9fb4:	2d 81       	ldd	r18, Y+5	; 0x05
    9fb6:	3e 81       	ldd	r19, Y+6	; 0x06
    9fb8:	89 81       	ldd	r24, Y+1	; 0x01
    9fba:	9a 81       	ldd	r25, Y+2	; 0x02
    9fbc:	28 17       	cp	r18, r24
    9fbe:	39 07       	cpc	r19, r25
    9fc0:	0c f4       	brge	.+2      	; 0x9fc4 <SD_write_multiple_blocks+0x230>
    9fc2:	3e cf       	rjmp	.-388    	; 0x9e40 <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    9fc4:	1f 86       	std	Y+15, r1	; 0x0f
    9fc6:	18 8a       	std	Y+16, r1	; 0x10
    9fc8:	0a c0       	rjmp	.+20     	; 0x9fde <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    9fca:	8f ef       	ldi	r24, 0xFF	; 255
    9fcc:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9fd0:	80 93 89 50 	sts	0x5089, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    9fd4:	8f 85       	ldd	r24, Y+15	; 0x0f
    9fd6:	98 89       	ldd	r25, Y+16	; 0x10
    9fd8:	01 96       	adiw	r24, 0x01	; 1
    9fda:	8f 87       	std	Y+15, r24	; 0x0f
    9fdc:	98 8b       	std	Y+16, r25	; 0x10
    9fde:	8f 85       	ldd	r24, Y+15	; 0x0f
    9fe0:	98 89       	ldd	r25, Y+16	; 0x10
    9fe2:	84 30       	cpi	r24, 0x04	; 4
    9fe4:	91 05       	cpc	r25, r1
    9fe6:	8c f3       	brlt	.-30     	; 0x9fca <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    9fe8:	8d ef       	ldi	r24, 0xFD	; 253
    9fea:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9fee:	80 93 89 50 	sts	0x5089, r24
	for(int i=0;i<4;i++){
    9ff2:	19 8a       	std	Y+17, r1	; 0x11
    9ff4:	1a 8a       	std	Y+18, r1	; 0x12
    9ff6:	0a c0       	rjmp	.+20     	; 0xa00c <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    9ff8:	8f ef       	ldi	r24, 0xFF	; 255
    9ffa:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    9ffe:	80 93 89 50 	sts	0x5089, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a002:	89 89       	ldd	r24, Y+17	; 0x11
    a004:	9a 89       	ldd	r25, Y+18	; 0x12
    a006:	01 96       	adiw	r24, 0x01	; 1
    a008:	89 8b       	std	Y+17, r24	; 0x11
    a00a:	9a 8b       	std	Y+18, r25	; 0x12
    a00c:	89 89       	ldd	r24, Y+17	; 0x11
    a00e:	9a 89       	ldd	r25, Y+18	; 0x12
    a010:	84 30       	cpi	r24, 0x04	; 4
    a012:	91 05       	cpc	r25, r1
    a014:	8c f3       	brlt	.-30     	; 0x9ff8 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a016:	10 92 89 50 	sts	0x5089, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a01a:	05 c0       	rjmp	.+10     	; 0xa026 <SD_write_multiple_blocks+0x292>
    a01c:	8f ef       	ldi	r24, 0xFF	; 255
    a01e:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    a022:	80 93 89 50 	sts	0x5089, r24
    a026:	80 91 89 50 	lds	r24, 0x5089
    a02a:	8f 3f       	cpi	r24, 0xFF	; 255
    a02c:	b9 f7       	brne	.-18     	; 0xa01c <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a02e:	80 e0       	ldi	r24, 0x00	; 0
    a030:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    a034:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a038:	88 e0       	ldi	r24, 0x08	; 8
    a03a:	60 e0       	ldi	r22, 0x00	; 0
    a03c:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
}
    a040:	6a 96       	adiw	r28, 0x1a	; 26
    a042:	cd bf       	out	0x3d, r28	; 61
    a044:	de bf       	out	0x3e, r29	; 62
    a046:	df 91       	pop	r29
    a048:	cf 91       	pop	r28
    a04a:	1f 91       	pop	r17
    a04c:	0f 91       	pop	r16
    a04e:	08 95       	ret

0000a050 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a050:	0f 93       	push	r16
    a052:	1f 93       	push	r17
    a054:	cf 93       	push	r28
    a056:	df 93       	push	r29
    a058:	cd b7       	in	r28, 0x3d	; 61
    a05a:	de b7       	in	r29, 0x3e	; 62
    a05c:	2e 97       	sbiw	r28, 0x0e	; 14
    a05e:	cd bf       	out	0x3d, r28	; 61
    a060:	de bf       	out	0x3e, r29	; 62
    a062:	6f 83       	std	Y+7, r22	; 0x07
    a064:	78 87       	std	Y+8, r23	; 0x08
    a066:	89 87       	std	Y+9, r24	; 0x09
    a068:	9a 87       	std	Y+10, r25	; 0x0a
    a06a:	4b 87       	std	Y+11, r20	; 0x0b
    a06c:	5c 87       	std	Y+12, r21	; 0x0c
    a06e:	2d 87       	std	Y+13, r18	; 0x0d
    a070:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a072:	88 e0       	ldi	r24, 0x08	; 8
    a074:	60 e0       	ldi	r22, 0x00	; 0
    a076:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a07a:	80 e0       	ldi	r24, 0x00	; 0
    a07c:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    a080:	81 e0       	ldi	r24, 0x01	; 1
    a082:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a086:	00 00       	nop
    a088:	2f 81       	ldd	r18, Y+7	; 0x07
    a08a:	38 85       	ldd	r19, Y+8	; 0x08
    a08c:	49 85       	ldd	r20, Y+9	; 0x09
    a08e:	5a 85       	ldd	r21, Y+10	; 0x0a
    a090:	82 e1       	ldi	r24, 0x12	; 18
    a092:	ba 01       	movw	r22, r20
    a094:	a9 01       	movw	r20, r18
    a096:	2f ef       	ldi	r18, 0xFF	; 255
    a098:	08 e0       	ldi	r16, 0x08	; 8
    a09a:	10 e0       	ldi	r17, 0x00	; 0
    a09c:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
    a0a0:	88 23       	and	r24, r24
    a0a2:	91 f7       	brne	.-28     	; 0xa088 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a0a4:	19 82       	std	Y+1, r1	; 0x01
    a0a6:	1a 82       	std	Y+2, r1	; 0x02
    a0a8:	4b c0       	rjmp	.+150    	; 0xa140 <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a0aa:	8f ef       	ldi	r24, 0xFF	; 255
    a0ac:	80 93 89 50 	sts	0x5089, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a0b0:	05 c0       	rjmp	.+10     	; 0xa0bc <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a0b2:	8f ef       	ldi	r24, 0xFF	; 255
    a0b4:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    a0b8:	80 93 89 50 	sts	0x5089, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a0bc:	80 91 89 50 	lds	r24, 0x5089
    a0c0:	8e 3f       	cpi	r24, 0xFE	; 254
    a0c2:	b9 f7       	brne	.-18     	; 0xa0b2 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a0c4:	1b 82       	std	Y+3, r1	; 0x03
    a0c6:	1c 82       	std	Y+4, r1	; 0x04
    a0c8:	19 c0       	rjmp	.+50     	; 0xa0fc <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a0ca:	89 81       	ldd	r24, Y+1	; 0x01
    a0cc:	9a 81       	ldd	r25, Y+2	; 0x02
    a0ce:	9c 01       	movw	r18, r24
    a0d0:	32 2f       	mov	r19, r18
    a0d2:	22 27       	eor	r18, r18
    a0d4:	33 0f       	add	r19, r19
    a0d6:	8b 81       	ldd	r24, Y+3	; 0x03
    a0d8:	9c 81       	ldd	r25, Y+4	; 0x04
    a0da:	82 0f       	add	r24, r18
    a0dc:	93 1f       	adc	r25, r19
    a0de:	2b 85       	ldd	r18, Y+11	; 0x0b
    a0e0:	3c 85       	ldd	r19, Y+12	; 0x0c
    a0e2:	89 01       	movw	r16, r18
    a0e4:	08 0f       	add	r16, r24
    a0e6:	19 1f       	adc	r17, r25
    a0e8:	8f ef       	ldi	r24, 0xFF	; 255
    a0ea:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    a0ee:	f8 01       	movw	r30, r16
    a0f0:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a0f2:	8b 81       	ldd	r24, Y+3	; 0x03
    a0f4:	9c 81       	ldd	r25, Y+4	; 0x04
    a0f6:	01 96       	adiw	r24, 0x01	; 1
    a0f8:	8b 83       	std	Y+3, r24	; 0x03
    a0fa:	9c 83       	std	Y+4, r25	; 0x04
    a0fc:	8b 81       	ldd	r24, Y+3	; 0x03
    a0fe:	9c 81       	ldd	r25, Y+4	; 0x04
    a100:	f2 e0       	ldi	r31, 0x02	; 2
    a102:	80 30       	cpi	r24, 0x00	; 0
    a104:	9f 07       	cpc	r25, r31
    a106:	0c f3       	brlt	.-62     	; 0xa0ca <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a108:	1d 82       	std	Y+5, r1	; 0x05
    a10a:	1e 82       	std	Y+6, r1	; 0x06
    a10c:	0f c0       	rjmp	.+30     	; 0xa12c <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a10e:	8f ef       	ldi	r24, 0xFF	; 255
    a110:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    a114:	28 2f       	mov	r18, r24
    a116:	8d 81       	ldd	r24, Y+5	; 0x05
    a118:	9e 81       	ldd	r25, Y+6	; 0x06
    a11a:	88 57       	subi	r24, 0x78	; 120
    a11c:	9f 4a       	sbci	r25, 0xAF	; 175
    a11e:	fc 01       	movw	r30, r24
    a120:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a122:	8d 81       	ldd	r24, Y+5	; 0x05
    a124:	9e 81       	ldd	r25, Y+6	; 0x06
    a126:	01 96       	adiw	r24, 0x01	; 1
    a128:	8d 83       	std	Y+5, r24	; 0x05
    a12a:	9e 83       	std	Y+6, r25	; 0x06
    a12c:	8d 81       	ldd	r24, Y+5	; 0x05
    a12e:	9e 81       	ldd	r25, Y+6	; 0x06
    a130:	82 30       	cpi	r24, 0x02	; 2
    a132:	91 05       	cpc	r25, r1
    a134:	64 f3       	brlt	.-40     	; 0xa10e <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a136:	89 81       	ldd	r24, Y+1	; 0x01
    a138:	9a 81       	ldd	r25, Y+2	; 0x02
    a13a:	01 96       	adiw	r24, 0x01	; 1
    a13c:	89 83       	std	Y+1, r24	; 0x01
    a13e:	9a 83       	std	Y+2, r25	; 0x02
    a140:	29 81       	ldd	r18, Y+1	; 0x01
    a142:	3a 81       	ldd	r19, Y+2	; 0x02
    a144:	8d 85       	ldd	r24, Y+13	; 0x0d
    a146:	9e 85       	ldd	r25, Y+14	; 0x0e
    a148:	28 17       	cp	r18, r24
    a14a:	39 07       	cpc	r19, r25
    a14c:	0c f4       	brge	.+2      	; 0xa150 <SD_read_multiple_blocks+0x100>
    a14e:	ad cf       	rjmp	.-166    	; 0xa0aa <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a150:	8c e0       	ldi	r24, 0x0C	; 12
    a152:	40 e0       	ldi	r20, 0x00	; 0
    a154:	50 e0       	ldi	r21, 0x00	; 0
    a156:	ba 01       	movw	r22, r20
    a158:	2f ef       	ldi	r18, 0xFF	; 255
    a15a:	08 e0       	ldi	r16, 0x08	; 8
    a15c:	10 e0       	ldi	r17, 0x00	; 0
    a15e:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a162:	8f ef       	ldi	r24, 0xFF	; 255
    a164:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    a168:	80 93 88 50 	sts	0x5088, r24
	Buffer[1] = FILLER_BYTE;
    a16c:	10 92 89 50 	sts	0x5089, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a170:	05 c0       	rjmp	.+10     	; 0xa17c <SD_read_multiple_blocks+0x12c>
    a172:	8f ef       	ldi	r24, 0xFF	; 255
    a174:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
    a178:	80 93 89 50 	sts	0x5089, r24
    a17c:	80 91 89 50 	lds	r24, 0x5089
    a180:	8f 3f       	cpi	r24, 0xFF	; 255
    a182:	b9 f7       	brne	.-18     	; 0xa172 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a184:	80 e0       	ldi	r24, 0x00	; 0
    a186:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    a18a:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a18e:	88 e0       	ldi	r24, 0x08	; 8
    a190:	60 e0       	ldi	r22, 0x00	; 0
    a192:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
}
    a196:	2e 96       	adiw	r28, 0x0e	; 14
    a198:	cd bf       	out	0x3d, r28	; 61
    a19a:	de bf       	out	0x3e, r29	; 62
    a19c:	df 91       	pop	r29
    a19e:	cf 91       	pop	r28
    a1a0:	1f 91       	pop	r17
    a1a2:	0f 91       	pop	r16
    a1a4:	08 95       	ret

0000a1a6 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a1a6:	cf 93       	push	r28
    a1a8:	df 93       	push	r29
    a1aa:	cd b7       	in	r28, 0x3d	; 61
    a1ac:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a1ae:	88 e0       	ldi	r24, 0x08	; 8
    a1b0:	60 e0       	ldi	r22, 0x00	; 0
    a1b2:	0e 94 cb 33 	call	0x6796	; 0x6796 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a1b6:	88 e0       	ldi	r24, 0x08	; 8
    a1b8:	60 e0       	ldi	r22, 0x00	; 0
    a1ba:	0e 94 97 34 	call	0x692e	; 0x692e <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a1be:	80 e0       	ldi	r24, 0x00	; 0
    a1c0:	0e 94 67 38 	call	0x70ce	; 0x70ce <SPIInit>
	SPICS(TRUE);
    a1c4:	81 e0       	ldi	r24, 0x01	; 1
    a1c6:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a1ca:	8f ef       	ldi	r24, 0xFF	; 255
    a1cc:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <SPI_write>
	SPICS(FALSE);	//stop spi
    a1d0:	80 e0       	ldi	r24, 0x00	; 0
    a1d2:	0e 94 bc 38 	call	0x7178	; 0x7178 <SPICS>
	SPIDisable();
    a1d6:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a1da:	80 e0       	ldi	r24, 0x00	; 0
    a1dc:	0e 94 ca 04 	call	0x994	; 0x994 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a1e0:	80 e0       	ldi	r24, 0x00	; 0
    a1e2:	0e 94 61 35 	call	0x6ac2	; 0x6ac2 <Ext1Power>
}
    a1e6:	df 91       	pop	r29
    a1e8:	cf 91       	pop	r28
    a1ea:	08 95       	ret

0000a1ec <storeFilename>:

void storeFilename(char* str){
    a1ec:	cf 93       	push	r28
    a1ee:	df 93       	push	r29
    a1f0:	00 d0       	rcall	.+0      	; 0xa1f2 <storeFilename+0x6>
    a1f2:	0f 92       	push	r0
    a1f4:	cd b7       	in	r28, 0x3d	; 61
    a1f6:	de b7       	in	r29, 0x3e	; 62
    a1f8:	8b 83       	std	Y+3, r24	; 0x03
    a1fa:	9c 83       	std	Y+4, r25	; 0x04
	int i=0;
    a1fc:	19 82       	std	Y+1, r1	; 0x01
    a1fe:	1a 82       	std	Y+2, r1	; 0x02
	for (;i<strlen(str) && i<15 ;i++) FileName[i] = str[i];
    a200:	13 c0       	rjmp	.+38     	; 0xa228 <storeFilename+0x3c>
    a202:	89 81       	ldd	r24, Y+1	; 0x01
    a204:	9a 81       	ldd	r25, Y+2	; 0x02
    a206:	2b 81       	ldd	r18, Y+3	; 0x03
    a208:	3c 81       	ldd	r19, Y+4	; 0x04
    a20a:	82 0f       	add	r24, r18
    a20c:	93 1f       	adc	r25, r19
    a20e:	fc 01       	movw	r30, r24
    a210:	20 81       	ld	r18, Z
    a212:	89 81       	ldd	r24, Y+1	; 0x01
    a214:	9a 81       	ldd	r25, Y+2	; 0x02
    a216:	8c 55       	subi	r24, 0x5C	; 92
    a218:	9f 4a       	sbci	r25, 0xAF	; 175
    a21a:	fc 01       	movw	r30, r24
    a21c:	20 83       	st	Z, r18
    a21e:	89 81       	ldd	r24, Y+1	; 0x01
    a220:	9a 81       	ldd	r25, Y+2	; 0x02
    a222:	01 96       	adiw	r24, 0x01	; 1
    a224:	89 83       	std	Y+1, r24	; 0x01
    a226:	9a 83       	std	Y+2, r25	; 0x02
    a228:	49 81       	ldd	r20, Y+1	; 0x01
    a22a:	5a 81       	ldd	r21, Y+2	; 0x02
    a22c:	8b 81       	ldd	r24, Y+3	; 0x03
    a22e:	9c 81       	ldd	r25, Y+4	; 0x04
    a230:	9c 01       	movw	r18, r24
    a232:	f9 01       	movw	r30, r18
    a234:	01 90       	ld	r0, Z+
    a236:	00 20       	and	r0, r0
    a238:	e9 f7       	brne	.-6      	; 0xa234 <storeFilename+0x48>
    a23a:	cf 01       	movw	r24, r30
    a23c:	01 97       	sbiw	r24, 0x01	; 1
    a23e:	82 1b       	sub	r24, r18
    a240:	93 0b       	sbc	r25, r19
    a242:	48 17       	cp	r20, r24
    a244:	59 07       	cpc	r21, r25
    a246:	a0 f4       	brcc	.+40     	; 0xa270 <storeFilename+0x84>
    a248:	89 81       	ldd	r24, Y+1	; 0x01
    a24a:	9a 81       	ldd	r25, Y+2	; 0x02
    a24c:	8f 30       	cpi	r24, 0x0F	; 15
    a24e:	91 05       	cpc	r25, r1
    a250:	c4 f2       	brlt	.-80     	; 0xa202 <storeFilename+0x16>
	for (;i<15;i++)	FileName[i] = " ";
    a252:	0e c0       	rjmp	.+28     	; 0xa270 <storeFilename+0x84>
    a254:	80 e1       	ldi	r24, 0x10	; 16
    a256:	90 e2       	ldi	r25, 0x20	; 32
    a258:	28 2f       	mov	r18, r24
    a25a:	89 81       	ldd	r24, Y+1	; 0x01
    a25c:	9a 81       	ldd	r25, Y+2	; 0x02
    a25e:	8c 55       	subi	r24, 0x5C	; 92
    a260:	9f 4a       	sbci	r25, 0xAF	; 175
    a262:	fc 01       	movw	r30, r24
    a264:	20 83       	st	Z, r18
    a266:	89 81       	ldd	r24, Y+1	; 0x01
    a268:	9a 81       	ldd	r25, Y+2	; 0x02
    a26a:	01 96       	adiw	r24, 0x01	; 1
    a26c:	89 83       	std	Y+1, r24	; 0x01
    a26e:	9a 83       	std	Y+2, r25	; 0x02
    a270:	89 81       	ldd	r24, Y+1	; 0x01
    a272:	9a 81       	ldd	r25, Y+2	; 0x02
    a274:	8f 30       	cpi	r24, 0x0F	; 15
    a276:	91 05       	cpc	r25, r1
    a278:	6c f3       	brlt	.-38     	; 0xa254 <storeFilename+0x68>
    a27a:	24 96       	adiw	r28, 0x04	; 4
    a27c:	cd bf       	out	0x3d, r28	; 61
    a27e:	de bf       	out	0x3e, r29	; 62
    a280:	df 91       	pop	r29
    a282:	cf 91       	pop	r28
    a284:	08 95       	ret

0000a286 <main>:
#include "E-000001-000009_firmware_rev_1_0.h"

volatile int numOfSamples;
//uint8_t Filename[15];

int main(void) {
    a286:	cf 93       	push	r28
    a288:	df 93       	push	r29
    a28a:	0f 92       	push	r0
    a28c:	0f 92       	push	r0
    a28e:	cd b7       	in	r28, 0x3d	; 61
    a290:	de b7       	in	r29, 0x3e	; 62
	
	//TestCard();
	//TestCard();
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    a292:	19 82       	std	Y+1, r1	; 0x01
    a294:	1a 82       	std	Y+2, r1	; 0x02
    a296:	13 c0       	rjmp	.+38     	; 0xa2be <main+0x38>
    a298:	89 81       	ldd	r24, Y+1	; 0x01
    a29a:	9a 81       	ldd	r25, Y+2	; 0x02
    a29c:	29 e7       	ldi	r18, 0x79	; 121
    a29e:	30 e0       	ldi	r19, 0x00	; 0
    a2a0:	b9 01       	movw	r22, r18
    a2a2:	0e 94 82 5c 	call	0xb904	; 0xb904 <__divmodhi4>
    a2a6:	28 2f       	mov	r18, r24
    a2a8:	89 81       	ldd	r24, Y+1	; 0x01
    a2aa:	9a 81       	ldd	r25, Y+2	; 0x02
    a2ac:	80 54       	subi	r24, 0x40	; 64
    a2ae:	9c 4d       	sbci	r25, 0xDC	; 220
    a2b0:	fc 01       	movw	r30, r24
    a2b2:	20 83       	st	Z, r18
    a2b4:	89 81       	ldd	r24, Y+1	; 0x01
    a2b6:	9a 81       	ldd	r25, Y+2	; 0x02
    a2b8:	01 96       	adiw	r24, 0x01	; 1
    a2ba:	89 83       	std	Y+1, r24	; 0x01
    a2bc:	9a 83       	std	Y+2, r25	; 0x02
    a2be:	89 81       	ldd	r24, Y+1	; 0x01
    a2c0:	9a 81       	ldd	r25, Y+2	; 0x02
    a2c2:	f2 e0       	ldi	r31, 0x02	; 2
    a2c4:	80 30       	cpi	r24, 0x00	; 0
    a2c6:	9f 07       	cpc	r25, r31
    a2c8:	3c f3       	brlt	.-50     	; 0xa298 <main+0x12>
	SD_init();
    a2ca:	0e 94 df 4a 	call	0x95be	; 0x95be <SD_init>
	getBootSectorData();
    a2ce:	0e 94 4c 3f 	call	0x7e98	; 0x7e98 <getBootSectorData>
	writeFile("testing");
    a2d2:	82 e1       	ldi	r24, 0x12	; 18
    a2d4:	90 e2       	ldi	r25, 0x20	; 32
    a2d6:	0e 94 e1 45 	call	0x8bc2	; 0x8bc2 <writeFile>
	nop();
    a2da:	00 00       	nop
	_delay_ms(1000);
	numOfSamples++;
	//sei();
	*/
	while(1){
		nop();
    a2dc:	00 00       	nop
	}
    a2de:	fe cf       	rjmp	.-4      	; 0xa2dc <main+0x56>

0000a2e0 <__muldi3>:
    a2e0:	a0 e3       	ldi	r26, 0x30	; 48
    a2e2:	b0 e0       	ldi	r27, 0x00	; 0
    a2e4:	e6 e7       	ldi	r30, 0x76	; 118
    a2e6:	f1 e5       	ldi	r31, 0x51	; 81
    a2e8:	0c 94 d4 5c 	jmp	0xb9a8	; 0xb9a8 <__prologue_saves__+0x4>
    a2ec:	29 8f       	std	Y+25, r18	; 0x19
    a2ee:	3a 8f       	std	Y+26, r19	; 0x1a
    a2f0:	4b 8f       	std	Y+27, r20	; 0x1b
    a2f2:	5c 8f       	std	Y+28, r21	; 0x1c
    a2f4:	6d 8f       	std	Y+29, r22	; 0x1d
    a2f6:	7e 8f       	std	Y+30, r23	; 0x1e
    a2f8:	8f 8f       	std	Y+31, r24	; 0x1f
    a2fa:	98 a3       	lds	r25, 0x58
    a2fc:	a9 8a       	std	Y+17, r10	; 0x11
    a2fe:	ba 8a       	std	Y+18, r11	; 0x12
    a300:	cb 8a       	std	Y+19, r12	; 0x13
    a302:	dc 8a       	std	Y+20, r13	; 0x14
    a304:	ed 8a       	std	Y+21, r14	; 0x15
    a306:	fe 8a       	std	Y+22, r15	; 0x16
    a308:	0f 8b       	std	Y+23, r16	; 0x17
    a30a:	18 8f       	std	Y+24, r17	; 0x18
    a30c:	09 8d       	ldd	r16, Y+25	; 0x19
    a30e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a310:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a312:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a314:	09 a3       	lds	r16, 0x59
    a316:	1a a3       	lds	r17, 0x5a
    a318:	2b a3       	lds	r18, 0x5b
    a31a:	3c a3       	lds	r19, 0x5c
    a31c:	68 01       	movw	r12, r16
    a31e:	79 01       	movw	r14, r18
    a320:	8f ef       	ldi	r24, 0xFF	; 255
    a322:	9f ef       	ldi	r25, 0xFF	; 255
    a324:	a0 e0       	ldi	r26, 0x00	; 0
    a326:	b0 e0       	ldi	r27, 0x00	; 0
    a328:	c8 22       	and	r12, r24
    a32a:	d9 22       	and	r13, r25
    a32c:	ea 22       	and	r14, r26
    a32e:	fb 22       	and	r15, r27
    a330:	89 01       	movw	r16, r18
    a332:	22 27       	eor	r18, r18
    a334:	33 27       	eor	r19, r19
    a336:	09 a7       	lds	r16, 0x79
    a338:	1a a7       	lds	r17, 0x7a
    a33a:	2b a7       	lds	r18, 0x7b
    a33c:	3c a7       	lds	r19, 0x7c
    a33e:	09 89       	ldd	r16, Y+17	; 0x11
    a340:	1a 89       	ldd	r17, Y+18	; 0x12
    a342:	2b 89       	ldd	r18, Y+19	; 0x13
    a344:	3c 89       	ldd	r19, Y+20	; 0x14
    a346:	0d a3       	lds	r16, 0x5d
    a348:	1e a3       	lds	r17, 0x5e
    a34a:	2f a3       	lds	r18, 0x5f
    a34c:	38 a7       	lds	r19, 0x78
    a34e:	48 01       	movw	r8, r16
    a350:	59 01       	movw	r10, r18
    a352:	88 22       	and	r8, r24
    a354:	99 22       	and	r9, r25
    a356:	aa 22       	and	r10, r26
    a358:	bb 22       	and	r11, r27
    a35a:	29 01       	movw	r4, r18
    a35c:	66 24       	eor	r6, r6
    a35e:	77 24       	eor	r7, r7
    a360:	c5 01       	movw	r24, r10
    a362:	b4 01       	movw	r22, r8
    a364:	a7 01       	movw	r20, r14
    a366:	96 01       	movw	r18, r12
    a368:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    a36c:	6d a7       	lds	r22, 0x7d
    a36e:	7e a7       	lds	r23, 0x7e
    a370:	8f a7       	lds	r24, 0x7f
    a372:	98 ab       	sts	0x58, r25
    a374:	c3 01       	movw	r24, r6
    a376:	b2 01       	movw	r22, r4
    a378:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    a37c:	6b 01       	movw	r12, r22
    a37e:	7c 01       	movw	r14, r24
    a380:	c5 01       	movw	r24, r10
    a382:	b4 01       	movw	r22, r8
    a384:	29 a5       	lds	r18, 0x69
    a386:	3a a5       	lds	r19, 0x6a
    a388:	4b a5       	lds	r20, 0x6b
    a38a:	5c a5       	lds	r21, 0x6c
    a38c:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    a390:	4b 01       	movw	r8, r22
    a392:	5c 01       	movw	r10, r24
    a394:	c3 01       	movw	r24, r6
    a396:	b2 01       	movw	r22, r4
    a398:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    a39c:	ab 01       	movw	r20, r22
    a39e:	bc 01       	movw	r22, r24
    a3a0:	c8 0c       	add	r12, r8
    a3a2:	d9 1c       	adc	r13, r9
    a3a4:	ea 1c       	adc	r14, r10
    a3a6:	fb 1c       	adc	r15, r11
    a3a8:	0d a5       	lds	r16, 0x6d
    a3aa:	1e a5       	lds	r17, 0x6e
    a3ac:	2f a5       	lds	r18, 0x6f
    a3ae:	38 a9       	sts	0x48, r19
    a3b0:	c9 01       	movw	r24, r18
    a3b2:	aa 27       	eor	r26, r26
    a3b4:	bb 27       	eor	r27, r27
    a3b6:	c8 0e       	add	r12, r24
    a3b8:	d9 1e       	adc	r13, r25
    a3ba:	ea 1e       	adc	r14, r26
    a3bc:	fb 1e       	adc	r15, r27
    a3be:	c8 14       	cp	r12, r8
    a3c0:	d9 04       	cpc	r13, r9
    a3c2:	ea 04       	cpc	r14, r10
    a3c4:	fb 04       	cpc	r15, r11
    a3c6:	20 f4       	brcc	.+8      	; 0xa3d0 <__muldi3+0xf0>
    a3c8:	40 50       	subi	r20, 0x00	; 0
    a3ca:	50 40       	sbci	r21, 0x00	; 0
    a3cc:	6f 4f       	sbci	r22, 0xFF	; 255
    a3ce:	7f 4f       	sbci	r23, 0xFF	; 255
    a3d0:	c7 01       	movw	r24, r14
    a3d2:	aa 27       	eor	r26, r26
    a3d4:	bb 27       	eor	r27, r27
    a3d6:	84 0f       	add	r24, r20
    a3d8:	95 1f       	adc	r25, r21
    a3da:	a6 1f       	adc	r26, r22
    a3dc:	b7 1f       	adc	r27, r23
    a3de:	8d 83       	std	Y+5, r24	; 0x05
    a3e0:	9e 83       	std	Y+6, r25	; 0x06
    a3e2:	af 83       	std	Y+7, r26	; 0x07
    a3e4:	b8 87       	std	Y+8, r27	; 0x08
    a3e6:	76 01       	movw	r14, r12
    a3e8:	dd 24       	eor	r13, r13
    a3ea:	cc 24       	eor	r12, r12
    a3ec:	4d a5       	lds	r20, 0x6d
    a3ee:	5e a5       	lds	r21, 0x6e
    a3f0:	6f a5       	lds	r22, 0x6f
    a3f2:	78 a9       	sts	0x48, r23
    a3f4:	60 70       	andi	r22, 0x00	; 0
    a3f6:	70 70       	andi	r23, 0x00	; 0
    a3f8:	c4 0e       	add	r12, r20
    a3fa:	d5 1e       	adc	r13, r21
    a3fc:	e6 1e       	adc	r14, r22
    a3fe:	f7 1e       	adc	r15, r23
    a400:	c9 82       	std	Y+1, r12	; 0x01
    a402:	da 82       	std	Y+2, r13	; 0x02
    a404:	eb 82       	std	Y+3, r14	; 0x03
    a406:	fc 82       	std	Y+4, r15	; 0x04
    a408:	1c 2d       	mov	r17, r12
    a40a:	0a 81       	ldd	r16, Y+2	; 0x02
    a40c:	8b 80       	ldd	r8, Y+3	; 0x03
    a40e:	4c 80       	ldd	r4, Y+4	; 0x04
    a410:	8d 87       	std	Y+13, r24	; 0x0d
    a412:	8e 81       	ldd	r24, Y+6	; 0x06
    a414:	8e 87       	std	Y+14, r24	; 0x0e
    a416:	8f 81       	ldd	r24, Y+7	; 0x07
    a418:	8f 87       	std	Y+15, r24	; 0x0f
    a41a:	88 85       	ldd	r24, Y+8	; 0x08
    a41c:	88 8b       	std	Y+16, r24	; 0x10
    a41e:	2d 89       	ldd	r18, Y+21	; 0x15
    a420:	3e 89       	ldd	r19, Y+22	; 0x16
    a422:	4f 89       	ldd	r20, Y+23	; 0x17
    a424:	58 8d       	ldd	r21, Y+24	; 0x18
    a426:	69 a1       	lds	r22, 0x49
    a428:	7a a1       	lds	r23, 0x4a
    a42a:	8b a1       	lds	r24, 0x4b
    a42c:	9c a1       	lds	r25, 0x4c
    a42e:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    a432:	6b 01       	movw	r12, r22
    a434:	7c 01       	movw	r14, r24
    a436:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a438:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a43a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a43c:	58 a1       	lds	r21, 0x48
    a43e:	6d a1       	lds	r22, 0x4d
    a440:	7e a1       	lds	r23, 0x4e
    a442:	8f a1       	lds	r24, 0x4f
    a444:	98 a5       	lds	r25, 0x68
    a446:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    a44a:	dc 01       	movw	r26, r24
    a44c:	cb 01       	movw	r24, r22
    a44e:	c8 0e       	add	r12, r24
    a450:	d9 1e       	adc	r13, r25
    a452:	ea 1e       	adc	r14, r26
    a454:	fb 1e       	adc	r15, r27
    a456:	8d 85       	ldd	r24, Y+13	; 0x0d
    a458:	9e 85       	ldd	r25, Y+14	; 0x0e
    a45a:	af 85       	ldd	r26, Y+15	; 0x0f
    a45c:	b8 89       	ldd	r27, Y+16	; 0x10
    a45e:	8c 0d       	add	r24, r12
    a460:	9d 1d       	adc	r25, r13
    a462:	ae 1d       	adc	r26, r14
    a464:	bf 1d       	adc	r27, r15
    a466:	8d 87       	std	Y+13, r24	; 0x0d
    a468:	9e 87       	std	Y+14, r25	; 0x0e
    a46a:	af 87       	std	Y+15, r26	; 0x0f
    a46c:	b8 8b       	std	Y+16, r27	; 0x10
    a46e:	68 2f       	mov	r22, r24
    a470:	7e 85       	ldd	r23, Y+14	; 0x0e
    a472:	21 2f       	mov	r18, r17
    a474:	30 2f       	mov	r19, r16
    a476:	48 2d       	mov	r20, r8
    a478:	54 2d       	mov	r21, r4
    a47a:	8f 85       	ldd	r24, Y+15	; 0x0f
    a47c:	98 89       	ldd	r25, Y+16	; 0x10
    a47e:	e0 96       	adiw	r28, 0x30	; 48
    a480:	e0 e1       	ldi	r30, 0x10	; 16
    a482:	0c 94 ed 5c 	jmp	0xb9da	; 0xb9da <__epilogue_restores__+0x4>

0000a486 <__ashldi3>:
    a486:	cf 92       	push	r12
    a488:	df 92       	push	r13
    a48a:	ef 92       	push	r14
    a48c:	ff 92       	push	r15
    a48e:	0f 93       	push	r16
    a490:	cf 93       	push	r28
    a492:	df 93       	push	r29
    a494:	cd b7       	in	r28, 0x3d	; 61
    a496:	de b7       	in	r29, 0x3e	; 62
    a498:	60 97       	sbiw	r28, 0x10	; 16
    a49a:	cd bf       	out	0x3d, r28	; 61
    a49c:	de bf       	out	0x3e, r29	; 62
    a49e:	00 23       	and	r16, r16
    a4a0:	09 f4       	brne	.+2      	; 0xa4a4 <__ashldi3+0x1e>
    a4a2:	5a c0       	rjmp	.+180    	; 0xa558 <__ashldi3+0xd2>
    a4a4:	29 87       	std	Y+9, r18	; 0x09
    a4a6:	3a 87       	std	Y+10, r19	; 0x0a
    a4a8:	4b 87       	std	Y+11, r20	; 0x0b
    a4aa:	5c 87       	std	Y+12, r21	; 0x0c
    a4ac:	6d 87       	std	Y+13, r22	; 0x0d
    a4ae:	7e 87       	std	Y+14, r23	; 0x0e
    a4b0:	8f 87       	std	Y+15, r24	; 0x0f
    a4b2:	98 8b       	std	Y+16, r25	; 0x10
    a4b4:	80 e2       	ldi	r24, 0x20	; 32
    a4b6:	80 1b       	sub	r24, r16
    a4b8:	49 85       	ldd	r20, Y+9	; 0x09
    a4ba:	5a 85       	ldd	r21, Y+10	; 0x0a
    a4bc:	6b 85       	ldd	r22, Y+11	; 0x0b
    a4be:	7c 85       	ldd	r23, Y+12	; 0x0c
    a4c0:	18 16       	cp	r1, r24
    a4c2:	b4 f0       	brlt	.+44     	; 0xa4f0 <__ashldi3+0x6a>
    a4c4:	19 82       	std	Y+1, r1	; 0x01
    a4c6:	1a 82       	std	Y+2, r1	; 0x02
    a4c8:	1b 82       	std	Y+3, r1	; 0x03
    a4ca:	1c 82       	std	Y+4, r1	; 0x04
    a4cc:	99 27       	eor	r25, r25
    a4ce:	87 fd       	sbrc	r24, 7
    a4d0:	90 95       	com	r25
    a4d2:	90 95       	com	r25
    a4d4:	81 95       	neg	r24
    a4d6:	9f 4f       	sbci	r25, 0xFF	; 255
    a4d8:	04 c0       	rjmp	.+8      	; 0xa4e2 <__ashldi3+0x5c>
    a4da:	44 0f       	add	r20, r20
    a4dc:	55 1f       	adc	r21, r21
    a4de:	66 1f       	adc	r22, r22
    a4e0:	77 1f       	adc	r23, r23
    a4e2:	8a 95       	dec	r24
    a4e4:	d2 f7       	brpl	.-12     	; 0xa4da <__ashldi3+0x54>
    a4e6:	4d 83       	std	Y+5, r20	; 0x05
    a4e8:	5e 83       	std	Y+6, r21	; 0x06
    a4ea:	6f 83       	std	Y+7, r22	; 0x07
    a4ec:	78 87       	std	Y+8, r23	; 0x08
    a4ee:	2c c0       	rjmp	.+88     	; 0xa548 <__ashldi3+0xc2>
    a4f0:	6a 01       	movw	r12, r20
    a4f2:	7b 01       	movw	r14, r22
    a4f4:	00 2e       	mov	r0, r16
    a4f6:	04 c0       	rjmp	.+8      	; 0xa500 <__ashldi3+0x7a>
    a4f8:	cc 0c       	add	r12, r12
    a4fa:	dd 1c       	adc	r13, r13
    a4fc:	ee 1c       	adc	r14, r14
    a4fe:	ff 1c       	adc	r15, r15
    a500:	0a 94       	dec	r0
    a502:	d2 f7       	brpl	.-12     	; 0xa4f8 <__ashldi3+0x72>
    a504:	c9 82       	std	Y+1, r12	; 0x01
    a506:	da 82       	std	Y+2, r13	; 0x02
    a508:	eb 82       	std	Y+3, r14	; 0x03
    a50a:	fc 82       	std	Y+4, r15	; 0x04
    a50c:	6a 01       	movw	r12, r20
    a50e:	7b 01       	movw	r14, r22
    a510:	04 c0       	rjmp	.+8      	; 0xa51a <__ashldi3+0x94>
    a512:	f6 94       	lsr	r15
    a514:	e7 94       	ror	r14
    a516:	d7 94       	ror	r13
    a518:	c7 94       	ror	r12
    a51a:	8a 95       	dec	r24
    a51c:	d2 f7       	brpl	.-12     	; 0xa512 <__ashldi3+0x8c>
    a51e:	d7 01       	movw	r26, r14
    a520:	c6 01       	movw	r24, r12
    a522:	4d 85       	ldd	r20, Y+13	; 0x0d
    a524:	5e 85       	ldd	r21, Y+14	; 0x0e
    a526:	6f 85       	ldd	r22, Y+15	; 0x0f
    a528:	78 89       	ldd	r23, Y+16	; 0x10
    a52a:	04 c0       	rjmp	.+8      	; 0xa534 <__ashldi3+0xae>
    a52c:	44 0f       	add	r20, r20
    a52e:	55 1f       	adc	r21, r21
    a530:	66 1f       	adc	r22, r22
    a532:	77 1f       	adc	r23, r23
    a534:	0a 95       	dec	r16
    a536:	d2 f7       	brpl	.-12     	; 0xa52c <__ashldi3+0xa6>
    a538:	84 2b       	or	r24, r20
    a53a:	95 2b       	or	r25, r21
    a53c:	a6 2b       	or	r26, r22
    a53e:	b7 2b       	or	r27, r23
    a540:	8d 83       	std	Y+5, r24	; 0x05
    a542:	9e 83       	std	Y+6, r25	; 0x06
    a544:	af 83       	std	Y+7, r26	; 0x07
    a546:	b8 87       	std	Y+8, r27	; 0x08
    a548:	29 81       	ldd	r18, Y+1	; 0x01
    a54a:	3a 81       	ldd	r19, Y+2	; 0x02
    a54c:	4b 81       	ldd	r20, Y+3	; 0x03
    a54e:	5c 81       	ldd	r21, Y+4	; 0x04
    a550:	6d 81       	ldd	r22, Y+5	; 0x05
    a552:	7e 81       	ldd	r23, Y+6	; 0x06
    a554:	8f 81       	ldd	r24, Y+7	; 0x07
    a556:	98 85       	ldd	r25, Y+8	; 0x08
    a558:	60 96       	adiw	r28, 0x10	; 16
    a55a:	cd bf       	out	0x3d, r28	; 61
    a55c:	de bf       	out	0x3e, r29	; 62
    a55e:	df 91       	pop	r29
    a560:	cf 91       	pop	r28
    a562:	0f 91       	pop	r16
    a564:	ff 90       	pop	r15
    a566:	ef 90       	pop	r14
    a568:	df 90       	pop	r13
    a56a:	cf 90       	pop	r12
    a56c:	08 95       	ret

0000a56e <__ashrdi3>:
    a56e:	0f 93       	push	r16
    a570:	cf 93       	push	r28
    a572:	df 93       	push	r29
    a574:	cd b7       	in	r28, 0x3d	; 61
    a576:	de b7       	in	r29, 0x3e	; 62
    a578:	60 97       	sbiw	r28, 0x10	; 16
    a57a:	cd bf       	out	0x3d, r28	; 61
    a57c:	de bf       	out	0x3e, r29	; 62
    a57e:	00 23       	and	r16, r16
    a580:	09 f4       	brne	.+2      	; 0xa584 <__ashrdi3+0x16>
    a582:	56 c0       	rjmp	.+172    	; 0xa630 <__ashrdi3+0xc2>
    a584:	29 87       	std	Y+9, r18	; 0x09
    a586:	3a 87       	std	Y+10, r19	; 0x0a
    a588:	4b 87       	std	Y+11, r20	; 0x0b
    a58a:	5c 87       	std	Y+12, r21	; 0x0c
    a58c:	6d 87       	std	Y+13, r22	; 0x0d
    a58e:	7e 87       	std	Y+14, r23	; 0x0e
    a590:	8f 87       	std	Y+15, r24	; 0x0f
    a592:	98 8b       	std	Y+16, r25	; 0x10
    a594:	20 e2       	ldi	r18, 0x20	; 32
    a596:	20 1b       	sub	r18, r16
    a598:	8d 85       	ldd	r24, Y+13	; 0x0d
    a59a:	9e 85       	ldd	r25, Y+14	; 0x0e
    a59c:	af 85       	ldd	r26, Y+15	; 0x0f
    a59e:	b8 89       	ldd	r27, Y+16	; 0x10
    a5a0:	ac 01       	movw	r20, r24
    a5a2:	bd 01       	movw	r22, r26
    a5a4:	12 16       	cp	r1, r18
    a5a6:	b4 f0       	brlt	.+44     	; 0xa5d4 <__ashrdi3+0x66>
    a5a8:	77 0f       	add	r23, r23
    a5aa:	44 0b       	sbc	r20, r20
    a5ac:	54 2f       	mov	r21, r20
    a5ae:	ba 01       	movw	r22, r20
    a5b0:	4d 83       	std	Y+5, r20	; 0x05
    a5b2:	5e 83       	std	Y+6, r21	; 0x06
    a5b4:	6f 83       	std	Y+7, r22	; 0x07
    a5b6:	78 87       	std	Y+8, r23	; 0x08
    a5b8:	33 27       	eor	r19, r19
    a5ba:	27 fd       	sbrc	r18, 7
    a5bc:	30 95       	com	r19
    a5be:	30 95       	com	r19
    a5c0:	21 95       	neg	r18
    a5c2:	3f 4f       	sbci	r19, 0xFF	; 255
    a5c4:	04 c0       	rjmp	.+8      	; 0xa5ce <__ashrdi3+0x60>
    a5c6:	b5 95       	asr	r27
    a5c8:	a7 95       	ror	r26
    a5ca:	97 95       	ror	r25
    a5cc:	87 95       	ror	r24
    a5ce:	2a 95       	dec	r18
    a5d0:	d2 f7       	brpl	.-12     	; 0xa5c6 <__ashrdi3+0x58>
    a5d2:	22 c0       	rjmp	.+68     	; 0xa618 <__ashrdi3+0xaa>
    a5d4:	00 2e       	mov	r0, r16
    a5d6:	04 c0       	rjmp	.+8      	; 0xa5e0 <__ashrdi3+0x72>
    a5d8:	75 95       	asr	r23
    a5da:	67 95       	ror	r22
    a5dc:	57 95       	ror	r21
    a5de:	47 95       	ror	r20
    a5e0:	0a 94       	dec	r0
    a5e2:	d2 f7       	brpl	.-12     	; 0xa5d8 <__ashrdi3+0x6a>
    a5e4:	4d 83       	std	Y+5, r20	; 0x05
    a5e6:	5e 83       	std	Y+6, r21	; 0x06
    a5e8:	6f 83       	std	Y+7, r22	; 0x07
    a5ea:	78 87       	std	Y+8, r23	; 0x08
    a5ec:	04 c0       	rjmp	.+8      	; 0xa5f6 <__ashrdi3+0x88>
    a5ee:	88 0f       	add	r24, r24
    a5f0:	99 1f       	adc	r25, r25
    a5f2:	aa 1f       	adc	r26, r26
    a5f4:	bb 1f       	adc	r27, r27
    a5f6:	2a 95       	dec	r18
    a5f8:	d2 f7       	brpl	.-12     	; 0xa5ee <__ashrdi3+0x80>
    a5fa:	49 85       	ldd	r20, Y+9	; 0x09
    a5fc:	5a 85       	ldd	r21, Y+10	; 0x0a
    a5fe:	6b 85       	ldd	r22, Y+11	; 0x0b
    a600:	7c 85       	ldd	r23, Y+12	; 0x0c
    a602:	04 c0       	rjmp	.+8      	; 0xa60c <__ashrdi3+0x9e>
    a604:	76 95       	lsr	r23
    a606:	67 95       	ror	r22
    a608:	57 95       	ror	r21
    a60a:	47 95       	ror	r20
    a60c:	0a 95       	dec	r16
    a60e:	d2 f7       	brpl	.-12     	; 0xa604 <__ashrdi3+0x96>
    a610:	84 2b       	or	r24, r20
    a612:	95 2b       	or	r25, r21
    a614:	a6 2b       	or	r26, r22
    a616:	b7 2b       	or	r27, r23
    a618:	89 83       	std	Y+1, r24	; 0x01
    a61a:	9a 83       	std	Y+2, r25	; 0x02
    a61c:	ab 83       	std	Y+3, r26	; 0x03
    a61e:	bc 83       	std	Y+4, r27	; 0x04
    a620:	29 81       	ldd	r18, Y+1	; 0x01
    a622:	3a 81       	ldd	r19, Y+2	; 0x02
    a624:	4b 81       	ldd	r20, Y+3	; 0x03
    a626:	5c 81       	ldd	r21, Y+4	; 0x04
    a628:	6d 81       	ldd	r22, Y+5	; 0x05
    a62a:	7e 81       	ldd	r23, Y+6	; 0x06
    a62c:	8f 81       	ldd	r24, Y+7	; 0x07
    a62e:	98 85       	ldd	r25, Y+8	; 0x08
    a630:	60 96       	adiw	r28, 0x10	; 16
    a632:	cd bf       	out	0x3d, r28	; 61
    a634:	de bf       	out	0x3e, r29	; 62
    a636:	df 91       	pop	r29
    a638:	cf 91       	pop	r28
    a63a:	0f 91       	pop	r16
    a63c:	08 95       	ret

0000a63e <__divdi3>:
    a63e:	a8 e4       	ldi	r26, 0x48	; 72
    a640:	b0 e0       	ldi	r27, 0x00	; 0
    a642:	e5 e2       	ldi	r30, 0x25	; 37
    a644:	f3 e5       	ldi	r31, 0x53	; 83
    a646:	0c 94 d3 5c 	jmp	0xb9a6	; 0xb9a6 <__prologue_saves__+0x2>
    a64a:	f5 01       	movw	r30, r10
    a64c:	29 a3       	lds	r18, 0x59
    a64e:	3a a3       	lds	r19, 0x5a
    a650:	4b a3       	lds	r20, 0x5b
    a652:	5c a3       	lds	r21, 0x5c
    a654:	6d a3       	lds	r22, 0x5d
    a656:	7e a3       	lds	r23, 0x5e
    a658:	8f a3       	lds	r24, 0x5f
    a65a:	98 a7       	lds	r25, 0x78
    a65c:	a9 8e       	std	Y+25, r10	; 0x19
    a65e:	fa 8f       	std	Y+26, r31	; 0x1a
    a660:	cb 8e       	std	Y+27, r12	; 0x1b
    a662:	dc 8e       	std	Y+28, r13	; 0x1c
    a664:	ed 8e       	std	Y+29, r14	; 0x1d
    a666:	fe 8e       	std	Y+30, r15	; 0x1e
    a668:	0f 8f       	std	Y+31, r16	; 0x1f
    a66a:	18 a3       	lds	r17, 0x58
    a66c:	8d a0       	lds	r24, 0x8d
    a66e:	9e a0       	lds	r25, 0x8e
    a670:	af a0       	lds	r26, 0x8f
    a672:	b8 a4       	lds	r27, 0xa8
    a674:	b7 fe       	sbrs	r11, 7
    a676:	67 c0       	rjmp	.+206    	; 0xa746 <__divdi3+0x108>
    a678:	21 95       	neg	r18
    a67a:	b1 e0       	ldi	r27, 0x01	; 1
    a67c:	12 16       	cp	r1, r18
    a67e:	08 f0       	brcs	.+2      	; 0xa682 <__divdi3+0x44>
    a680:	b0 e0       	ldi	r27, 0x00	; 0
    a682:	31 95       	neg	r19
    a684:	a1 e0       	ldi	r26, 0x01	; 1
    a686:	13 16       	cp	r1, r19
    a688:	08 f0       	brcs	.+2      	; 0xa68c <__divdi3+0x4e>
    a68a:	a0 e0       	ldi	r26, 0x00	; 0
    a68c:	b3 2e       	mov	r11, r19
    a68e:	bb 1a       	sub	r11, r27
    a690:	bb 2d       	mov	r27, r11
    a692:	88 24       	eor	r8, r8
    a694:	83 94       	inc	r8
    a696:	3b 15       	cp	r19, r11
    a698:	08 f0       	brcs	.+2      	; 0xa69c <__divdi3+0x5e>
    a69a:	88 24       	eor	r8, r8
    a69c:	a8 29       	or	r26, r8
    a69e:	41 95       	neg	r20
    a6a0:	31 e0       	ldi	r19, 0x01	; 1
    a6a2:	14 16       	cp	r1, r20
    a6a4:	08 f0       	brcs	.+2      	; 0xa6a8 <__divdi3+0x6a>
    a6a6:	30 e0       	ldi	r19, 0x00	; 0
    a6a8:	b4 2e       	mov	r11, r20
    a6aa:	ba 1a       	sub	r11, r26
    a6ac:	ab 2d       	mov	r26, r11
    a6ae:	88 24       	eor	r8, r8
    a6b0:	83 94       	inc	r8
    a6b2:	4b 15       	cp	r20, r11
    a6b4:	08 f0       	brcs	.+2      	; 0xa6b8 <__divdi3+0x7a>
    a6b6:	88 24       	eor	r8, r8
    a6b8:	38 29       	or	r19, r8
    a6ba:	51 95       	neg	r21
    a6bc:	41 e0       	ldi	r20, 0x01	; 1
    a6be:	15 16       	cp	r1, r21
    a6c0:	08 f0       	brcs	.+2      	; 0xa6c4 <__divdi3+0x86>
    a6c2:	40 e0       	ldi	r20, 0x00	; 0
    a6c4:	45 2e       	mov	r4, r21
    a6c6:	43 1a       	sub	r4, r19
    a6c8:	31 e0       	ldi	r19, 0x01	; 1
    a6ca:	54 15       	cp	r21, r4
    a6cc:	08 f0       	brcs	.+2      	; 0xa6d0 <__divdi3+0x92>
    a6ce:	30 e0       	ldi	r19, 0x00	; 0
    a6d0:	43 2b       	or	r20, r19
    a6d2:	61 95       	neg	r22
    a6d4:	31 e0       	ldi	r19, 0x01	; 1
    a6d6:	16 16       	cp	r1, r22
    a6d8:	08 f0       	brcs	.+2      	; 0xa6dc <__divdi3+0x9e>
    a6da:	30 e0       	ldi	r19, 0x00	; 0
    a6dc:	86 2e       	mov	r8, r22
    a6de:	84 1a       	sub	r8, r20
    a6e0:	41 e0       	ldi	r20, 0x01	; 1
    a6e2:	68 15       	cp	r22, r8
    a6e4:	08 f0       	brcs	.+2      	; 0xa6e8 <__divdi3+0xaa>
    a6e6:	40 e0       	ldi	r20, 0x00	; 0
    a6e8:	34 2b       	or	r19, r20
    a6ea:	71 95       	neg	r23
    a6ec:	41 e0       	ldi	r20, 0x01	; 1
    a6ee:	17 16       	cp	r1, r23
    a6f0:	08 f0       	brcs	.+2      	; 0xa6f4 <__divdi3+0xb6>
    a6f2:	40 e0       	ldi	r20, 0x00	; 0
    a6f4:	57 2f       	mov	r21, r23
    a6f6:	53 1b       	sub	r21, r19
    a6f8:	31 e0       	ldi	r19, 0x01	; 1
    a6fa:	75 17       	cp	r23, r21
    a6fc:	08 f0       	brcs	.+2      	; 0xa700 <__divdi3+0xc2>
    a6fe:	30 e0       	ldi	r19, 0x00	; 0
    a700:	43 2b       	or	r20, r19
    a702:	81 95       	neg	r24
    a704:	31 e0       	ldi	r19, 0x01	; 1
    a706:	18 16       	cp	r1, r24
    a708:	08 f0       	brcs	.+2      	; 0xa70c <__divdi3+0xce>
    a70a:	30 e0       	ldi	r19, 0x00	; 0
    a70c:	68 2f       	mov	r22, r24
    a70e:	64 1b       	sub	r22, r20
    a710:	46 2f       	mov	r20, r22
    a712:	61 e0       	ldi	r22, 0x01	; 1
    a714:	84 17       	cp	r24, r20
    a716:	08 f0       	brcs	.+2      	; 0xa71a <__divdi3+0xdc>
    a718:	60 e0       	ldi	r22, 0x00	; 0
    a71a:	36 2b       	or	r19, r22
    a71c:	91 95       	neg	r25
    a71e:	93 1b       	sub	r25, r19
    a720:	29 a3       	lds	r18, 0x59
    a722:	ba a3       	lds	r27, 0x5a
    a724:	ab a3       	lds	r26, 0x5b
    a726:	4c a2       	lds	r20, 0x9c
    a728:	8d a2       	lds	r24, 0x9d
    a72a:	5e a3       	lds	r21, 0x5e
    a72c:	4f a3       	lds	r20, 0x5f
    a72e:	98 a7       	lds	r25, 0x78
    a730:	8f ef       	ldi	r24, 0xFF	; 255
    a732:	9f ef       	ldi	r25, 0xFF	; 255
    a734:	af ef       	ldi	r26, 0xFF	; 255
    a736:	bf ef       	ldi	r27, 0xFF	; 255
    a738:	25 96       	adiw	r28, 0x05	; 5
    a73a:	8c af       	sts	0x7c, r24
    a73c:	9d af       	sts	0x7d, r25
    a73e:	ae af       	sts	0x7e, r26
    a740:	bf af       	sts	0x7f, r27
    a742:	25 97       	sbiw	r28, 0x05	; 5
    a744:	06 c0       	rjmp	.+12     	; 0xa752 <__divdi3+0x114>
    a746:	25 96       	adiw	r28, 0x05	; 5
    a748:	1c ae       	sts	0xbc, r17
    a74a:	1d ae       	sts	0xbd, r17
    a74c:	1e ae       	sts	0xbe, r17
    a74e:	1f ae       	sts	0xbf, r17
    a750:	25 97       	sbiw	r28, 0x05	; 5
    a752:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a754:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a756:	af 8d       	ldd	r26, Y+31	; 0x1f
    a758:	b8 a1       	lds	r27, 0x48
    a75a:	b7 ff       	sbrs	r27, 7
    a75c:	68 c0       	rjmp	.+208    	; 0xa82e <__divdi3+0x1f0>
    a75e:	25 96       	adiw	r28, 0x05	; 5
    a760:	2c ad       	sts	0x6c, r18
    a762:	3d ad       	sts	0x6d, r19
    a764:	4e ad       	sts	0x6e, r20
    a766:	5f ad       	sts	0x6f, r21
    a768:	25 97       	sbiw	r28, 0x05	; 5
    a76a:	20 95       	com	r18
    a76c:	30 95       	com	r19
    a76e:	40 95       	com	r20
    a770:	50 95       	com	r21
    a772:	25 96       	adiw	r28, 0x05	; 5
    a774:	2c af       	sts	0x7c, r18
    a776:	3d af       	sts	0x7d, r19
    a778:	4e af       	sts	0x7e, r20
    a77a:	5f af       	sts	0x7f, r21
    a77c:	25 97       	sbiw	r28, 0x05	; 5
    a77e:	e1 95       	neg	r30
    a780:	81 e0       	ldi	r24, 0x01	; 1
    a782:	1e 16       	cp	r1, r30
    a784:	08 f0       	brcs	.+2      	; 0xa788 <__divdi3+0x14a>
    a786:	80 e0       	ldi	r24, 0x00	; 0
    a788:	f1 95       	neg	r31
    a78a:	91 e0       	ldi	r25, 0x01	; 1
    a78c:	1f 16       	cp	r1, r31
    a78e:	08 f0       	brcs	.+2      	; 0xa792 <__divdi3+0x154>
    a790:	90 e0       	ldi	r25, 0x00	; 0
    a792:	4f 2f       	mov	r20, r31
    a794:	48 1b       	sub	r20, r24
    a796:	81 e0       	ldi	r24, 0x01	; 1
    a798:	f4 17       	cp	r31, r20
    a79a:	08 f0       	brcs	.+2      	; 0xa79e <__divdi3+0x160>
    a79c:	80 e0       	ldi	r24, 0x00	; 0
    a79e:	98 2b       	or	r25, r24
    a7a0:	c1 94       	neg	r12
    a7a2:	81 e0       	ldi	r24, 0x01	; 1
    a7a4:	1c 14       	cp	r1, r12
    a7a6:	08 f0       	brcs	.+2      	; 0xa7aa <__divdi3+0x16c>
    a7a8:	80 e0       	ldi	r24, 0x00	; 0
    a7aa:	6c 2d       	mov	r22, r12
    a7ac:	69 1b       	sub	r22, r25
    a7ae:	91 e0       	ldi	r25, 0x01	; 1
    a7b0:	c6 16       	cp	r12, r22
    a7b2:	08 f0       	brcs	.+2      	; 0xa7b6 <__divdi3+0x178>
    a7b4:	90 e0       	ldi	r25, 0x00	; 0
    a7b6:	89 2b       	or	r24, r25
    a7b8:	d1 94       	neg	r13
    a7ba:	91 e0       	ldi	r25, 0x01	; 1
    a7bc:	1d 14       	cp	r1, r13
    a7be:	08 f0       	brcs	.+2      	; 0xa7c2 <__divdi3+0x184>
    a7c0:	90 e0       	ldi	r25, 0x00	; 0
    a7c2:	5d 2d       	mov	r21, r13
    a7c4:	58 1b       	sub	r21, r24
    a7c6:	81 e0       	ldi	r24, 0x01	; 1
    a7c8:	d5 16       	cp	r13, r21
    a7ca:	08 f0       	brcs	.+2      	; 0xa7ce <__divdi3+0x190>
    a7cc:	80 e0       	ldi	r24, 0x00	; 0
    a7ce:	98 2b       	or	r25, r24
    a7d0:	e1 94       	neg	r14
    a7d2:	81 e0       	ldi	r24, 0x01	; 1
    a7d4:	1e 14       	cp	r1, r14
    a7d6:	08 f0       	brcs	.+2      	; 0xa7da <__divdi3+0x19c>
    a7d8:	80 e0       	ldi	r24, 0x00	; 0
    a7da:	3e 2d       	mov	r19, r14
    a7dc:	39 1b       	sub	r19, r25
    a7de:	91 e0       	ldi	r25, 0x01	; 1
    a7e0:	e3 16       	cp	r14, r19
    a7e2:	08 f0       	brcs	.+2      	; 0xa7e6 <__divdi3+0x1a8>
    a7e4:	90 e0       	ldi	r25, 0x00	; 0
    a7e6:	89 2b       	or	r24, r25
    a7e8:	f1 94       	neg	r15
    a7ea:	91 e0       	ldi	r25, 0x01	; 1
    a7ec:	1f 14       	cp	r1, r15
    a7ee:	08 f0       	brcs	.+2      	; 0xa7f2 <__divdi3+0x1b4>
    a7f0:	90 e0       	ldi	r25, 0x00	; 0
    a7f2:	2f 2d       	mov	r18, r15
    a7f4:	28 1b       	sub	r18, r24
    a7f6:	81 e0       	ldi	r24, 0x01	; 1
    a7f8:	f2 16       	cp	r15, r18
    a7fa:	08 f0       	brcs	.+2      	; 0xa7fe <__divdi3+0x1c0>
    a7fc:	80 e0       	ldi	r24, 0x00	; 0
    a7fe:	98 2b       	or	r25, r24
    a800:	01 95       	neg	r16
    a802:	81 e0       	ldi	r24, 0x01	; 1
    a804:	10 16       	cp	r1, r16
    a806:	08 f0       	brcs	.+2      	; 0xa80a <__divdi3+0x1cc>
    a808:	80 e0       	ldi	r24, 0x00	; 0
    a80a:	70 2f       	mov	r23, r16
    a80c:	79 1b       	sub	r23, r25
    a80e:	97 2f       	mov	r25, r23
    a810:	71 e0       	ldi	r23, 0x01	; 1
    a812:	09 17       	cp	r16, r25
    a814:	08 f0       	brcs	.+2      	; 0xa818 <__divdi3+0x1da>
    a816:	70 e0       	ldi	r23, 0x00	; 0
    a818:	87 2b       	or	r24, r23
    a81a:	11 95       	neg	r17
    a81c:	18 1b       	sub	r17, r24
    a81e:	e9 8f       	std	Y+25, r30	; 0x19
    a820:	4a 8f       	std	Y+26, r20	; 0x1a
    a822:	6b 8f       	std	Y+27, r22	; 0x1b
    a824:	5c 8f       	std	Y+28, r21	; 0x1c
    a826:	3d 8f       	std	Y+29, r19	; 0x1d
    a828:	2e 8f       	std	Y+30, r18	; 0x1e
    a82a:	9f 8f       	std	Y+31, r25	; 0x1f
    a82c:	18 a3       	lds	r17, 0x58
    a82e:	79 8d       	ldd	r23, Y+25	; 0x19
    a830:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a832:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a834:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a836:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a838:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a83a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a83c:	88 a1       	lds	r24, 0x48
    a83e:	e9 a1       	lds	r30, 0x49
    a840:	e9 8b       	std	Y+17, r30	; 0x11
    a842:	ea a1       	lds	r30, 0x4a
    a844:	ea 8b       	std	Y+18, r30	; 0x12
    a846:	eb a1       	lds	r30, 0x4b
    a848:	eb 8b       	std	Y+19, r30	; 0x13
    a84a:	ec a1       	lds	r30, 0x4c
    a84c:	ec 8b       	std	Y+20, r30	; 0x14
    a84e:	ed a1       	lds	r30, 0x4d
    a850:	ed 8b       	std	Y+21, r30	; 0x15
    a852:	ee a1       	lds	r30, 0x4e
    a854:	ee 8b       	std	Y+22, r30	; 0x16
    a856:	ef a1       	lds	r30, 0x4f
    a858:	ef 8b       	std	Y+23, r30	; 0x17
    a85a:	e8 a5       	lds	r30, 0x68
    a85c:	e8 8f       	std	Y+24, r30	; 0x18
    a85e:	79 87       	std	Y+9, r23	; 0x09
    a860:	6a 87       	std	Y+10, r22	; 0x0a
    a862:	5b 87       	std	Y+11, r21	; 0x0b
    a864:	4c 87       	std	Y+12, r20	; 0x0c
    a866:	3d 87       	std	Y+13, r19	; 0x0d
    a868:	2e 87       	std	Y+14, r18	; 0x0e
    a86a:	9f 87       	std	Y+15, r25	; 0x0f
    a86c:	88 8b       	std	Y+16, r24	; 0x10
    a86e:	89 84       	ldd	r8, Y+9	; 0x09
    a870:	9a 84       	ldd	r9, Y+10	; 0x0a
    a872:	ab 84       	ldd	r10, Y+11	; 0x0b
    a874:	bc 84       	ldd	r11, Y+12	; 0x0c
    a876:	8d 85       	ldd	r24, Y+13	; 0x0d
    a878:	9e 85       	ldd	r25, Y+14	; 0x0e
    a87a:	af 85       	ldd	r26, Y+15	; 0x0f
    a87c:	b8 89       	ldd	r27, Y+16	; 0x10
    a87e:	e9 88       	ldd	r14, Y+17	; 0x11
    a880:	fa 88       	ldd	r15, Y+18	; 0x12
    a882:	0b 89       	ldd	r16, Y+19	; 0x13
    a884:	1c 89       	ldd	r17, Y+20	; 0x14
    a886:	ed aa       	sts	0x9d, r30
    a888:	fe aa       	sts	0x9e, r31
    a88a:	0f ab       	sts	0x5f, r16
    a88c:	18 af       	sts	0x78, r17
    a88e:	cd 88       	ldd	r12, Y+21	; 0x15
    a890:	de 88       	ldd	r13, Y+22	; 0x16
    a892:	ef 88       	ldd	r14, Y+23	; 0x17
    a894:	f8 8c       	ldd	r15, Y+24	; 0x18
    a896:	00 97       	sbiw	r24, 0x00	; 0
    a898:	a1 05       	cpc	r26, r1
    a89a:	b1 05       	cpc	r27, r1
    a89c:	09 f0       	breq	.+2      	; 0xa8a0 <__divdi3+0x262>
    a89e:	bd c3       	rjmp	.+1914   	; 0xb01a <__divdi3+0x9dc>
    a8a0:	c8 14       	cp	r12, r8
    a8a2:	d9 04       	cpc	r13, r9
    a8a4:	ea 04       	cpc	r14, r10
    a8a6:	fb 04       	cpc	r15, r11
    a8a8:	08 f0       	brcs	.+2      	; 0xa8ac <__divdi3+0x26e>
    a8aa:	4d c1       	rjmp	.+666    	; 0xab46 <__divdi3+0x508>
    a8ac:	00 e0       	ldi	r16, 0x00	; 0
    a8ae:	80 16       	cp	r8, r16
    a8b0:	00 e0       	ldi	r16, 0x00	; 0
    a8b2:	90 06       	cpc	r9, r16
    a8b4:	01 e0       	ldi	r16, 0x01	; 1
    a8b6:	a0 06       	cpc	r10, r16
    a8b8:	00 e0       	ldi	r16, 0x00	; 0
    a8ba:	b0 06       	cpc	r11, r16
    a8bc:	58 f4       	brcc	.+22     	; 0xa8d4 <__divdi3+0x296>
    a8be:	1f ef       	ldi	r17, 0xFF	; 255
    a8c0:	81 16       	cp	r8, r17
    a8c2:	91 04       	cpc	r9, r1
    a8c4:	a1 04       	cpc	r10, r1
    a8c6:	b1 04       	cpc	r11, r1
    a8c8:	09 f0       	breq	.+2      	; 0xa8cc <__divdi3+0x28e>
    a8ca:	90 f4       	brcc	.+36     	; 0xa8f0 <__divdi3+0x2b2>
    a8cc:	80 e0       	ldi	r24, 0x00	; 0
    a8ce:	90 e0       	ldi	r25, 0x00	; 0
    a8d0:	dc 01       	movw	r26, r24
    a8d2:	17 c0       	rjmp	.+46     	; 0xa902 <__divdi3+0x2c4>
    a8d4:	20 e0       	ldi	r18, 0x00	; 0
    a8d6:	82 16       	cp	r8, r18
    a8d8:	20 e0       	ldi	r18, 0x00	; 0
    a8da:	92 06       	cpc	r9, r18
    a8dc:	20 e0       	ldi	r18, 0x00	; 0
    a8de:	a2 06       	cpc	r10, r18
    a8e0:	21 e0       	ldi	r18, 0x01	; 1
    a8e2:	b2 06       	cpc	r11, r18
    a8e4:	50 f4       	brcc	.+20     	; 0xa8fa <__divdi3+0x2bc>
    a8e6:	80 e1       	ldi	r24, 0x10	; 16
    a8e8:	90 e0       	ldi	r25, 0x00	; 0
    a8ea:	a0 e0       	ldi	r26, 0x00	; 0
    a8ec:	b0 e0       	ldi	r27, 0x00	; 0
    a8ee:	09 c0       	rjmp	.+18     	; 0xa902 <__divdi3+0x2c4>
    a8f0:	88 e0       	ldi	r24, 0x08	; 8
    a8f2:	90 e0       	ldi	r25, 0x00	; 0
    a8f4:	a0 e0       	ldi	r26, 0x00	; 0
    a8f6:	b0 e0       	ldi	r27, 0x00	; 0
    a8f8:	04 c0       	rjmp	.+8      	; 0xa902 <__divdi3+0x2c4>
    a8fa:	88 e1       	ldi	r24, 0x18	; 24
    a8fc:	90 e0       	ldi	r25, 0x00	; 0
    a8fe:	a0 e0       	ldi	r26, 0x00	; 0
    a900:	b0 e0       	ldi	r27, 0x00	; 0
    a902:	b5 01       	movw	r22, r10
    a904:	a4 01       	movw	r20, r8
    a906:	08 2e       	mov	r0, r24
    a908:	04 c0       	rjmp	.+8      	; 0xa912 <__divdi3+0x2d4>
    a90a:	76 95       	lsr	r23
    a90c:	67 95       	ror	r22
    a90e:	57 95       	ror	r21
    a910:	47 95       	ror	r20
    a912:	0a 94       	dec	r0
    a914:	d2 f7       	brpl	.-12     	; 0xa90a <__divdi3+0x2cc>
    a916:	fa 01       	movw	r30, r20
    a918:	e6 5e       	subi	r30, 0xE6	; 230
    a91a:	ff 4d       	sbci	r31, 0xDF	; 223
    a91c:	20 81       	ld	r18, Z
    a91e:	40 e2       	ldi	r20, 0x20	; 32
    a920:	50 e0       	ldi	r21, 0x00	; 0
    a922:	60 e0       	ldi	r22, 0x00	; 0
    a924:	70 e0       	ldi	r23, 0x00	; 0
    a926:	48 1b       	sub	r20, r24
    a928:	59 0b       	sbc	r21, r25
    a92a:	6a 0b       	sbc	r22, r26
    a92c:	7b 0b       	sbc	r23, r27
    a92e:	42 1b       	sub	r20, r18
    a930:	51 09       	sbc	r21, r1
    a932:	61 09       	sbc	r22, r1
    a934:	71 09       	sbc	r23, r1
    a936:	41 15       	cp	r20, r1
    a938:	51 05       	cpc	r21, r1
    a93a:	61 05       	cpc	r22, r1
    a93c:	71 05       	cpc	r23, r1
    a93e:	a1 f1       	breq	.+104    	; 0xa9a8 <__divdi3+0x36a>
    a940:	04 2e       	mov	r0, r20
    a942:	04 c0       	rjmp	.+8      	; 0xa94c <__divdi3+0x30e>
    a944:	88 0c       	add	r8, r8
    a946:	99 1c       	adc	r9, r9
    a948:	aa 1c       	adc	r10, r10
    a94a:	bb 1c       	adc	r11, r11
    a94c:	0a 94       	dec	r0
    a94e:	d2 f7       	brpl	.-12     	; 0xa944 <__divdi3+0x306>
    a950:	97 01       	movw	r18, r14
    a952:	86 01       	movw	r16, r12
    a954:	04 2e       	mov	r0, r20
    a956:	04 c0       	rjmp	.+8      	; 0xa960 <__divdi3+0x322>
    a958:	00 0f       	add	r16, r16
    a95a:	11 1f       	adc	r17, r17
    a95c:	22 1f       	adc	r18, r18
    a95e:	33 1f       	adc	r19, r19
    a960:	0a 94       	dec	r0
    a962:	d2 f7       	brpl	.-12     	; 0xa958 <__divdi3+0x31a>
    a964:	80 e2       	ldi	r24, 0x20	; 32
    a966:	90 e0       	ldi	r25, 0x00	; 0
    a968:	84 1b       	sub	r24, r20
    a96a:	95 0b       	sbc	r25, r21
    a96c:	cd a8       	sts	0x8d, r28
    a96e:	de a8       	sts	0x8e, r29
    a970:	ef a8       	sts	0x8f, r30
    a972:	f8 ac       	sts	0xa8, r31
    a974:	04 c0       	rjmp	.+8      	; 0xa97e <__divdi3+0x340>
    a976:	f6 94       	lsr	r15
    a978:	e7 94       	ror	r14
    a97a:	d7 94       	ror	r13
    a97c:	c7 94       	ror	r12
    a97e:	8a 95       	dec	r24
    a980:	d2 f7       	brpl	.-12     	; 0xa976 <__divdi3+0x338>
    a982:	c0 2a       	or	r12, r16
    a984:	d1 2a       	or	r13, r17
    a986:	e2 2a       	or	r14, r18
    a988:	f3 2a       	or	r15, r19
    a98a:	0d a9       	sts	0x4d, r16
    a98c:	1e a9       	sts	0x4e, r17
    a98e:	2f a9       	sts	0x4f, r18
    a990:	38 ad       	sts	0x68, r19
    a992:	04 c0       	rjmp	.+8      	; 0xa99c <__divdi3+0x35e>
    a994:	00 0f       	add	r16, r16
    a996:	11 1f       	adc	r17, r17
    a998:	22 1f       	adc	r18, r18
    a99a:	33 1f       	adc	r19, r19
    a99c:	4a 95       	dec	r20
    a99e:	d2 f7       	brpl	.-12     	; 0xa994 <__divdi3+0x356>
    a9a0:	0d ab       	sts	0x5d, r16
    a9a2:	1e ab       	sts	0x5e, r17
    a9a4:	2f ab       	sts	0x5f, r18
    a9a6:	38 af       	sts	0x78, r19
    a9a8:	25 01       	movw	r4, r10
    a9aa:	66 24       	eor	r6, r6
    a9ac:	77 24       	eor	r7, r7
    a9ae:	95 01       	movw	r18, r10
    a9b0:	84 01       	movw	r16, r8
    a9b2:	20 70       	andi	r18, 0x00	; 0
    a9b4:	30 70       	andi	r19, 0x00	; 0
    a9b6:	09 ab       	sts	0x59, r16
    a9b8:	1a ab       	sts	0x5a, r17
    a9ba:	2b ab       	sts	0x5b, r18
    a9bc:	3c ab       	sts	0x5c, r19
    a9be:	c7 01       	movw	r24, r14
    a9c0:	b6 01       	movw	r22, r12
    a9c2:	a3 01       	movw	r20, r6
    a9c4:	92 01       	movw	r18, r4
    a9c6:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    a9ca:	2d a7       	lds	r18, 0x7d
    a9cc:	3e a7       	lds	r19, 0x7e
    a9ce:	4f a7       	lds	r20, 0x7f
    a9d0:	58 ab       	sts	0x58, r21
    a9d2:	69 a7       	lds	r22, 0x79
    a9d4:	7a a7       	lds	r23, 0x7a
    a9d6:	8b a7       	lds	r24, 0x7b
    a9d8:	9c a7       	lds	r25, 0x7c
    a9da:	c7 01       	movw	r24, r14
    a9dc:	b6 01       	movw	r22, r12
    a9de:	a3 01       	movw	r20, r6
    a9e0:	92 01       	movw	r18, r4
    a9e2:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    a9e6:	ca 01       	movw	r24, r20
    a9e8:	b9 01       	movw	r22, r18
    a9ea:	29 a9       	sts	0x49, r18
    a9ec:	3a a9       	sts	0x4a, r19
    a9ee:	4b a9       	sts	0x4b, r20
    a9f0:	5c a9       	sts	0x4c, r21
    a9f2:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    a9f6:	ab 01       	movw	r20, r22
    a9f8:	bc 01       	movw	r22, r24
    a9fa:	09 a5       	lds	r16, 0x69
    a9fc:	1a a5       	lds	r17, 0x6a
    a9fe:	2b a5       	lds	r18, 0x6b
    aa00:	3c a5       	lds	r19, 0x6c
    aa02:	78 01       	movw	r14, r16
    aa04:	dd 24       	eor	r13, r13
    aa06:	cc 24       	eor	r12, r12
    aa08:	0d a9       	sts	0x4d, r16
    aa0a:	1e a9       	sts	0x4e, r17
    aa0c:	2f a9       	sts	0x4f, r18
    aa0e:	38 ad       	sts	0x68, r19
    aa10:	c9 01       	movw	r24, r18
    aa12:	aa 27       	eor	r26, r26
    aa14:	bb 27       	eor	r27, r27
    aa16:	c8 2a       	or	r12, r24
    aa18:	d9 2a       	or	r13, r25
    aa1a:	ea 2a       	or	r14, r26
    aa1c:	fb 2a       	or	r15, r27
    aa1e:	0d a5       	lds	r16, 0x6d
    aa20:	1e a5       	lds	r17, 0x6e
    aa22:	2f a5       	lds	r18, 0x6f
    aa24:	38 a9       	sts	0x48, r19
    aa26:	c4 16       	cp	r12, r20
    aa28:	d5 06       	cpc	r13, r21
    aa2a:	e6 06       	cpc	r14, r22
    aa2c:	f7 06       	cpc	r15, r23
    aa2e:	38 f5       	brcc	.+78     	; 0xaa7e <__divdi3+0x440>
    aa30:	01 50       	subi	r16, 0x01	; 1
    aa32:	10 40       	sbci	r17, 0x00	; 0
    aa34:	20 40       	sbci	r18, 0x00	; 0
    aa36:	30 40       	sbci	r19, 0x00	; 0
    aa38:	09 a7       	lds	r16, 0x79
    aa3a:	1a a7       	lds	r17, 0x7a
    aa3c:	2b a7       	lds	r18, 0x7b
    aa3e:	3c a7       	lds	r19, 0x7c
    aa40:	c8 0c       	add	r12, r8
    aa42:	d9 1c       	adc	r13, r9
    aa44:	ea 1c       	adc	r14, r10
    aa46:	fb 1c       	adc	r15, r11
    aa48:	c8 14       	cp	r12, r8
    aa4a:	d9 04       	cpc	r13, r9
    aa4c:	ea 04       	cpc	r14, r10
    aa4e:	fb 04       	cpc	r15, r11
    aa50:	d0 f0       	brcs	.+52     	; 0xaa86 <__divdi3+0x448>
    aa52:	c4 16       	cp	r12, r20
    aa54:	d5 06       	cpc	r13, r21
    aa56:	e6 06       	cpc	r14, r22
    aa58:	f7 06       	cpc	r15, r23
    aa5a:	a8 f4       	brcc	.+42     	; 0xaa86 <__divdi3+0x448>
    aa5c:	0d a5       	lds	r16, 0x6d
    aa5e:	1e a5       	lds	r17, 0x6e
    aa60:	2f a5       	lds	r18, 0x6f
    aa62:	38 a9       	sts	0x48, r19
    aa64:	02 50       	subi	r16, 0x02	; 2
    aa66:	10 40       	sbci	r17, 0x00	; 0
    aa68:	20 40       	sbci	r18, 0x00	; 0
    aa6a:	30 40       	sbci	r19, 0x00	; 0
    aa6c:	09 a7       	lds	r16, 0x79
    aa6e:	1a a7       	lds	r17, 0x7a
    aa70:	2b a7       	lds	r18, 0x7b
    aa72:	3c a7       	lds	r19, 0x7c
    aa74:	c8 0c       	add	r12, r8
    aa76:	d9 1c       	adc	r13, r9
    aa78:	ea 1c       	adc	r14, r10
    aa7a:	fb 1c       	adc	r15, r11
    aa7c:	04 c0       	rjmp	.+8      	; 0xaa86 <__divdi3+0x448>
    aa7e:	09 a7       	lds	r16, 0x79
    aa80:	1a a7       	lds	r17, 0x7a
    aa82:	2b a7       	lds	r18, 0x7b
    aa84:	3c a7       	lds	r19, 0x7c
    aa86:	c4 1a       	sub	r12, r20
    aa88:	d5 0a       	sbc	r13, r21
    aa8a:	e6 0a       	sbc	r14, r22
    aa8c:	f7 0a       	sbc	r15, r23
    aa8e:	c7 01       	movw	r24, r14
    aa90:	b6 01       	movw	r22, r12
    aa92:	a3 01       	movw	r20, r6
    aa94:	92 01       	movw	r18, r4
    aa96:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    aa9a:	2d a7       	lds	r18, 0x7d
    aa9c:	3e a7       	lds	r19, 0x7e
    aa9e:	4f a7       	lds	r20, 0x7f
    aaa0:	58 ab       	sts	0x58, r21
    aaa2:	69 af       	sts	0x79, r22
    aaa4:	7a af       	sts	0x7a, r23
    aaa6:	8b af       	sts	0x7b, r24
    aaa8:	9c af       	sts	0x7c, r25
    aaaa:	c7 01       	movw	r24, r14
    aaac:	b6 01       	movw	r22, r12
    aaae:	a3 01       	movw	r20, r6
    aab0:	92 01       	movw	r18, r4
    aab2:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    aab6:	ca 01       	movw	r24, r20
    aab8:	b9 01       	movw	r22, r18
    aaba:	29 a9       	sts	0x49, r18
    aabc:	3a a9       	sts	0x4a, r19
    aabe:	4b a9       	sts	0x4b, r20
    aac0:	5c a9       	sts	0x4c, r21
    aac2:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    aac6:	6b 01       	movw	r12, r22
    aac8:	7c 01       	movw	r14, r24
    aaca:	49 ad       	sts	0x69, r20
    aacc:	5a ad       	sts	0x6a, r21
    aace:	6b ad       	sts	0x6b, r22
    aad0:	7c ad       	sts	0x6c, r23
    aad2:	9a 01       	movw	r18, r20
    aad4:	11 27       	eor	r17, r17
    aad6:	00 27       	eor	r16, r16
    aad8:	4d a9       	sts	0x4d, r20
    aada:	5e a9       	sts	0x4e, r21
    aadc:	6f a9       	sts	0x4f, r22
    aade:	78 ad       	sts	0x68, r23
    aae0:	60 70       	andi	r22, 0x00	; 0
    aae2:	70 70       	andi	r23, 0x00	; 0
    aae4:	04 2b       	or	r16, r20
    aae6:	15 2b       	or	r17, r21
    aae8:	26 2b       	or	r18, r22
    aaea:	37 2b       	or	r19, r23
    aaec:	8d a5       	lds	r24, 0x6d
    aaee:	9e a5       	lds	r25, 0x6e
    aaf0:	af a5       	lds	r26, 0x6f
    aaf2:	b8 a9       	sts	0x48, r27
    aaf4:	0c 15       	cp	r16, r12
    aaf6:	1d 05       	cpc	r17, r13
    aaf8:	2e 05       	cpc	r18, r14
    aafa:	3f 05       	cpc	r19, r15
    aafc:	c0 f4       	brcc	.+48     	; 0xab2e <__divdi3+0x4f0>
    aafe:	01 97       	sbiw	r24, 0x01	; 1
    ab00:	a1 09       	sbc	r26, r1
    ab02:	b1 09       	sbc	r27, r1
    ab04:	08 0d       	add	r16, r8
    ab06:	19 1d       	adc	r17, r9
    ab08:	2a 1d       	adc	r18, r10
    ab0a:	3b 1d       	adc	r19, r11
    ab0c:	08 15       	cp	r16, r8
    ab0e:	19 05       	cpc	r17, r9
    ab10:	2a 05       	cpc	r18, r10
    ab12:	3b 05       	cpc	r19, r11
    ab14:	60 f0       	brcs	.+24     	; 0xab2e <__divdi3+0x4f0>
    ab16:	0c 15       	cp	r16, r12
    ab18:	1d 05       	cpc	r17, r13
    ab1a:	2e 05       	cpc	r18, r14
    ab1c:	3f 05       	cpc	r19, r15
    ab1e:	38 f4       	brcc	.+14     	; 0xab2e <__divdi3+0x4f0>
    ab20:	8d a5       	lds	r24, 0x6d
    ab22:	9e a5       	lds	r25, 0x6e
    ab24:	af a5       	lds	r26, 0x6f
    ab26:	b8 a9       	sts	0x48, r27
    ab28:	02 97       	sbiw	r24, 0x02	; 2
    ab2a:	a1 09       	sbc	r26, r1
    ab2c:	b1 09       	sbc	r27, r1
    ab2e:	09 a5       	lds	r16, 0x69
    ab30:	1a a5       	lds	r17, 0x6a
    ab32:	2b a5       	lds	r18, 0x6b
    ab34:	3c a5       	lds	r19, 0x6c
    ab36:	78 01       	movw	r14, r16
    ab38:	dd 24       	eor	r13, r13
    ab3a:	cc 24       	eor	r12, r12
    ab3c:	c8 2a       	or	r12, r24
    ab3e:	d9 2a       	or	r13, r25
    ab40:	ea 2a       	or	r14, r26
    ab42:	fb 2a       	or	r15, r27
    ab44:	b7 c4       	rjmp	.+2414   	; 0xb4b4 <__divdi3+0xe76>
    ab46:	81 14       	cp	r8, r1
    ab48:	91 04       	cpc	r9, r1
    ab4a:	a1 04       	cpc	r10, r1
    ab4c:	b1 04       	cpc	r11, r1
    ab4e:	51 f4       	brne	.+20     	; 0xab64 <__divdi3+0x526>
    ab50:	61 e0       	ldi	r22, 0x01	; 1
    ab52:	70 e0       	ldi	r23, 0x00	; 0
    ab54:	80 e0       	ldi	r24, 0x00	; 0
    ab56:	90 e0       	ldi	r25, 0x00	; 0
    ab58:	a5 01       	movw	r20, r10
    ab5a:	94 01       	movw	r18, r8
    ab5c:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    ab60:	49 01       	movw	r8, r18
    ab62:	5a 01       	movw	r10, r20
    ab64:	10 e0       	ldi	r17, 0x00	; 0
    ab66:	81 16       	cp	r8, r17
    ab68:	10 e0       	ldi	r17, 0x00	; 0
    ab6a:	91 06       	cpc	r9, r17
    ab6c:	11 e0       	ldi	r17, 0x01	; 1
    ab6e:	a1 06       	cpc	r10, r17
    ab70:	10 e0       	ldi	r17, 0x00	; 0
    ab72:	b1 06       	cpc	r11, r17
    ab74:	58 f4       	brcc	.+22     	; 0xab8c <__divdi3+0x54e>
    ab76:	2f ef       	ldi	r18, 0xFF	; 255
    ab78:	82 16       	cp	r8, r18
    ab7a:	91 04       	cpc	r9, r1
    ab7c:	a1 04       	cpc	r10, r1
    ab7e:	b1 04       	cpc	r11, r1
    ab80:	09 f0       	breq	.+2      	; 0xab84 <__divdi3+0x546>
    ab82:	90 f4       	brcc	.+36     	; 0xaba8 <__divdi3+0x56a>
    ab84:	80 e0       	ldi	r24, 0x00	; 0
    ab86:	90 e0       	ldi	r25, 0x00	; 0
    ab88:	dc 01       	movw	r26, r24
    ab8a:	17 c0       	rjmp	.+46     	; 0xabba <__divdi3+0x57c>
    ab8c:	30 e0       	ldi	r19, 0x00	; 0
    ab8e:	83 16       	cp	r8, r19
    ab90:	30 e0       	ldi	r19, 0x00	; 0
    ab92:	93 06       	cpc	r9, r19
    ab94:	30 e0       	ldi	r19, 0x00	; 0
    ab96:	a3 06       	cpc	r10, r19
    ab98:	31 e0       	ldi	r19, 0x01	; 1
    ab9a:	b3 06       	cpc	r11, r19
    ab9c:	50 f4       	brcc	.+20     	; 0xabb2 <__divdi3+0x574>
    ab9e:	80 e1       	ldi	r24, 0x10	; 16
    aba0:	90 e0       	ldi	r25, 0x00	; 0
    aba2:	a0 e0       	ldi	r26, 0x00	; 0
    aba4:	b0 e0       	ldi	r27, 0x00	; 0
    aba6:	09 c0       	rjmp	.+18     	; 0xabba <__divdi3+0x57c>
    aba8:	88 e0       	ldi	r24, 0x08	; 8
    abaa:	90 e0       	ldi	r25, 0x00	; 0
    abac:	a0 e0       	ldi	r26, 0x00	; 0
    abae:	b0 e0       	ldi	r27, 0x00	; 0
    abb0:	04 c0       	rjmp	.+8      	; 0xabba <__divdi3+0x57c>
    abb2:	88 e1       	ldi	r24, 0x18	; 24
    abb4:	90 e0       	ldi	r25, 0x00	; 0
    abb6:	a0 e0       	ldi	r26, 0x00	; 0
    abb8:	b0 e0       	ldi	r27, 0x00	; 0
    abba:	b5 01       	movw	r22, r10
    abbc:	a4 01       	movw	r20, r8
    abbe:	08 2e       	mov	r0, r24
    abc0:	04 c0       	rjmp	.+8      	; 0xabca <__divdi3+0x58c>
    abc2:	76 95       	lsr	r23
    abc4:	67 95       	ror	r22
    abc6:	57 95       	ror	r21
    abc8:	47 95       	ror	r20
    abca:	0a 94       	dec	r0
    abcc:	d2 f7       	brpl	.-12     	; 0xabc2 <__divdi3+0x584>
    abce:	fa 01       	movw	r30, r20
    abd0:	e6 5e       	subi	r30, 0xE6	; 230
    abd2:	ff 4d       	sbci	r31, 0xDF	; 223
    abd4:	20 81       	ld	r18, Z
    abd6:	ac 01       	movw	r20, r24
    abd8:	bd 01       	movw	r22, r26
    abda:	42 0f       	add	r20, r18
    abdc:	51 1d       	adc	r21, r1
    abde:	61 1d       	adc	r22, r1
    abe0:	71 1d       	adc	r23, r1
    abe2:	80 e2       	ldi	r24, 0x20	; 32
    abe4:	90 e0       	ldi	r25, 0x00	; 0
    abe6:	a0 e0       	ldi	r26, 0x00	; 0
    abe8:	b0 e0       	ldi	r27, 0x00	; 0
    abea:	84 1b       	sub	r24, r20
    abec:	95 0b       	sbc	r25, r21
    abee:	a6 0b       	sbc	r26, r22
    abf0:	b7 0b       	sbc	r27, r23
    abf2:	51 f4       	brne	.+20     	; 0xac08 <__divdi3+0x5ca>
    abf4:	c8 18       	sub	r12, r8
    abf6:	d9 08       	sbc	r13, r9
    abf8:	ea 08       	sbc	r14, r10
    abfa:	fb 08       	sbc	r15, r11
    abfc:	f1 e0       	ldi	r31, 0x01	; 1
    abfe:	4f 2e       	mov	r4, r31
    ac00:	51 2c       	mov	r5, r1
    ac02:	61 2c       	mov	r6, r1
    ac04:	71 2c       	mov	r7, r1
    ac06:	28 c1       	rjmp	.+592    	; 0xae58 <__divdi3+0x81a>
    ac08:	08 2e       	mov	r0, r24
    ac0a:	04 c0       	rjmp	.+8      	; 0xac14 <__divdi3+0x5d6>
    ac0c:	88 0c       	add	r8, r8
    ac0e:	99 1c       	adc	r9, r9
    ac10:	aa 1c       	adc	r10, r10
    ac12:	bb 1c       	adc	r11, r11
    ac14:	0a 94       	dec	r0
    ac16:	d2 f7       	brpl	.-12     	; 0xac0c <__divdi3+0x5ce>
    ac18:	97 01       	movw	r18, r14
    ac1a:	86 01       	movw	r16, r12
    ac1c:	04 2e       	mov	r0, r20
    ac1e:	04 c0       	rjmp	.+8      	; 0xac28 <__divdi3+0x5ea>
    ac20:	36 95       	lsr	r19
    ac22:	27 95       	ror	r18
    ac24:	17 95       	ror	r17
    ac26:	07 95       	ror	r16
    ac28:	0a 94       	dec	r0
    ac2a:	d2 f7       	brpl	.-12     	; 0xac20 <__divdi3+0x5e2>
    ac2c:	09 ab       	sts	0x59, r16
    ac2e:	1a ab       	sts	0x5a, r17
    ac30:	2b ab       	sts	0x5b, r18
    ac32:	3c ab       	sts	0x5c, r19
    ac34:	97 01       	movw	r18, r14
    ac36:	86 01       	movw	r16, r12
    ac38:	08 2e       	mov	r0, r24
    ac3a:	04 c0       	rjmp	.+8      	; 0xac44 <__divdi3+0x606>
    ac3c:	00 0f       	add	r16, r16
    ac3e:	11 1f       	adc	r17, r17
    ac40:	22 1f       	adc	r18, r18
    ac42:	33 1f       	adc	r19, r19
    ac44:	0a 94       	dec	r0
    ac46:	d2 f7       	brpl	.-12     	; 0xac3c <__divdi3+0x5fe>
    ac48:	0d a7       	lds	r16, 0x7d
    ac4a:	1e a7       	lds	r17, 0x7e
    ac4c:	2f a7       	lds	r18, 0x7f
    ac4e:	38 ab       	sts	0x58, r19
    ac50:	ed a8       	sts	0x8d, r30
    ac52:	fe a8       	sts	0x8e, r31
    ac54:	0f a9       	sts	0x4f, r16
    ac56:	18 ad       	sts	0x68, r17
    ac58:	04 c0       	rjmp	.+8      	; 0xac62 <__divdi3+0x624>
    ac5a:	16 95       	lsr	r17
    ac5c:	07 95       	ror	r16
    ac5e:	f7 94       	ror	r15
    ac60:	e7 94       	ror	r14
    ac62:	4a 95       	dec	r20
    ac64:	d2 f7       	brpl	.-12     	; 0xac5a <__divdi3+0x61c>
    ac66:	b8 01       	movw	r22, r16
    ac68:	a7 01       	movw	r20, r14
    ac6a:	0d a5       	lds	r16, 0x6d
    ac6c:	1e a5       	lds	r17, 0x6e
    ac6e:	2f a5       	lds	r18, 0x6f
    ac70:	38 a9       	sts	0x48, r19
    ac72:	04 2b       	or	r16, r20
    ac74:	15 2b       	or	r17, r21
    ac76:	26 2b       	or	r18, r22
    ac78:	37 2b       	or	r19, r23
    ac7a:	0d a7       	lds	r16, 0x7d
    ac7c:	1e a7       	lds	r17, 0x7e
    ac7e:	2f a7       	lds	r18, 0x7f
    ac80:	38 ab       	sts	0x58, r19
    ac82:	ed a8       	sts	0x8d, r30
    ac84:	fe a8       	sts	0x8e, r31
    ac86:	0f a9       	sts	0x4f, r16
    ac88:	18 ad       	sts	0x68, r17
    ac8a:	04 c0       	rjmp	.+8      	; 0xac94 <__divdi3+0x656>
    ac8c:	ee 0c       	add	r14, r14
    ac8e:	ff 1c       	adc	r15, r15
    ac90:	00 1f       	adc	r16, r16
    ac92:	11 1f       	adc	r17, r17
    ac94:	8a 95       	dec	r24
    ac96:	d2 f7       	brpl	.-12     	; 0xac8c <__divdi3+0x64e>
    ac98:	ed aa       	sts	0x9d, r30
    ac9a:	fe aa       	sts	0x9e, r31
    ac9c:	0f ab       	sts	0x5f, r16
    ac9e:	18 af       	sts	0x78, r17
    aca0:	25 01       	movw	r4, r10
    aca2:	66 24       	eor	r6, r6
    aca4:	77 24       	eor	r7, r7
    aca6:	95 01       	movw	r18, r10
    aca8:	84 01       	movw	r16, r8
    acaa:	20 70       	andi	r18, 0x00	; 0
    acac:	30 70       	andi	r19, 0x00	; 0
    acae:	09 af       	sts	0x79, r16
    acb0:	1a af       	sts	0x7a, r17
    acb2:	2b af       	sts	0x7b, r18
    acb4:	3c af       	sts	0x7c, r19
    acb6:	69 a9       	sts	0x49, r22
    acb8:	7a a9       	sts	0x4a, r23
    acba:	8b a9       	sts	0x4b, r24
    acbc:	9c a9       	sts	0x4c, r25
    acbe:	a3 01       	movw	r20, r6
    acc0:	92 01       	movw	r18, r4
    acc2:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    acc6:	29 a7       	lds	r18, 0x79
    acc8:	3a a7       	lds	r19, 0x7a
    acca:	4b a7       	lds	r20, 0x7b
    accc:	5c a7       	lds	r21, 0x7c
    acce:	6b 01       	movw	r12, r22
    acd0:	7c 01       	movw	r14, r24
    acd2:	69 a9       	sts	0x49, r22
    acd4:	7a a9       	sts	0x4a, r23
    acd6:	8b a9       	sts	0x4b, r24
    acd8:	9c a9       	sts	0x4c, r25
    acda:	a3 01       	movw	r20, r6
    acdc:	92 01       	movw	r18, r4
    acde:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    ace2:	ca 01       	movw	r24, r20
    ace4:	b9 01       	movw	r22, r18
    ace6:	29 ad       	sts	0x69, r18
    ace8:	3a ad       	sts	0x6a, r19
    acea:	4b ad       	sts	0x6b, r20
    acec:	5c ad       	sts	0x6c, r21
    acee:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    acf2:	ab 01       	movw	r20, r22
    acf4:	bc 01       	movw	r22, r24
    acf6:	76 01       	movw	r14, r12
    acf8:	dd 24       	eor	r13, r13
    acfa:	cc 24       	eor	r12, r12
    acfc:	0d a5       	lds	r16, 0x6d
    acfe:	1e a5       	lds	r17, 0x6e
    ad00:	2f a5       	lds	r18, 0x6f
    ad02:	38 a9       	sts	0x48, r19
    ad04:	c9 01       	movw	r24, r18
    ad06:	aa 27       	eor	r26, r26
    ad08:	bb 27       	eor	r27, r27
    ad0a:	c8 2a       	or	r12, r24
    ad0c:	d9 2a       	or	r13, r25
    ad0e:	ea 2a       	or	r14, r26
    ad10:	fb 2a       	or	r15, r27
    ad12:	09 a5       	lds	r16, 0x69
    ad14:	1a a5       	lds	r17, 0x6a
    ad16:	2b a5       	lds	r18, 0x6b
    ad18:	3c a5       	lds	r19, 0x6c
    ad1a:	c4 16       	cp	r12, r20
    ad1c:	d5 06       	cpc	r13, r21
    ad1e:	e6 06       	cpc	r14, r22
    ad20:	f7 06       	cpc	r15, r23
    ad22:	38 f5       	brcc	.+78     	; 0xad72 <__divdi3+0x734>
    ad24:	01 50       	subi	r16, 0x01	; 1
    ad26:	10 40       	sbci	r17, 0x00	; 0
    ad28:	20 40       	sbci	r18, 0x00	; 0
    ad2a:	30 40       	sbci	r19, 0x00	; 0
    ad2c:	09 ab       	sts	0x59, r16
    ad2e:	1a ab       	sts	0x5a, r17
    ad30:	2b ab       	sts	0x5b, r18
    ad32:	3c ab       	sts	0x5c, r19
    ad34:	c8 0c       	add	r12, r8
    ad36:	d9 1c       	adc	r13, r9
    ad38:	ea 1c       	adc	r14, r10
    ad3a:	fb 1c       	adc	r15, r11
    ad3c:	c8 14       	cp	r12, r8
    ad3e:	d9 04       	cpc	r13, r9
    ad40:	ea 04       	cpc	r14, r10
    ad42:	fb 04       	cpc	r15, r11
    ad44:	d0 f0       	brcs	.+52     	; 0xad7a <__divdi3+0x73c>
    ad46:	c4 16       	cp	r12, r20
    ad48:	d5 06       	cpc	r13, r21
    ad4a:	e6 06       	cpc	r14, r22
    ad4c:	f7 06       	cpc	r15, r23
    ad4e:	a8 f4       	brcc	.+42     	; 0xad7a <__divdi3+0x73c>
    ad50:	09 a5       	lds	r16, 0x69
    ad52:	1a a5       	lds	r17, 0x6a
    ad54:	2b a5       	lds	r18, 0x6b
    ad56:	3c a5       	lds	r19, 0x6c
    ad58:	02 50       	subi	r16, 0x02	; 2
    ad5a:	10 40       	sbci	r17, 0x00	; 0
    ad5c:	20 40       	sbci	r18, 0x00	; 0
    ad5e:	30 40       	sbci	r19, 0x00	; 0
    ad60:	09 ab       	sts	0x59, r16
    ad62:	1a ab       	sts	0x5a, r17
    ad64:	2b ab       	sts	0x5b, r18
    ad66:	3c ab       	sts	0x5c, r19
    ad68:	c8 0c       	add	r12, r8
    ad6a:	d9 1c       	adc	r13, r9
    ad6c:	ea 1c       	adc	r14, r10
    ad6e:	fb 1c       	adc	r15, r11
    ad70:	04 c0       	rjmp	.+8      	; 0xad7a <__divdi3+0x73c>
    ad72:	09 ab       	sts	0x59, r16
    ad74:	1a ab       	sts	0x5a, r17
    ad76:	2b ab       	sts	0x5b, r18
    ad78:	3c ab       	sts	0x5c, r19
    ad7a:	c4 1a       	sub	r12, r20
    ad7c:	d5 0a       	sbc	r13, r21
    ad7e:	e6 0a       	sbc	r14, r22
    ad80:	f7 0a       	sbc	r15, r23
    ad82:	c7 01       	movw	r24, r14
    ad84:	b6 01       	movw	r22, r12
    ad86:	a3 01       	movw	r20, r6
    ad88:	92 01       	movw	r18, r4
    ad8a:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    ad8e:	29 a7       	lds	r18, 0x79
    ad90:	3a a7       	lds	r19, 0x7a
    ad92:	4b a7       	lds	r20, 0x7b
    ad94:	5c a7       	lds	r21, 0x7c
    ad96:	21 96       	adiw	r28, 0x01	; 1
    ad98:	6c af       	sts	0x7c, r22
    ad9a:	7d af       	sts	0x7d, r23
    ad9c:	8e af       	sts	0x7e, r24
    ad9e:	9f af       	sts	0x7f, r25
    ada0:	21 97       	sbiw	r28, 0x01	; 1
    ada2:	c7 01       	movw	r24, r14
    ada4:	b6 01       	movw	r22, r12
    ada6:	a3 01       	movw	r20, r6
    ada8:	92 01       	movw	r18, r4
    adaa:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    adae:	ca 01       	movw	r24, r20
    adb0:	b9 01       	movw	r22, r18
    adb2:	29 ad       	sts	0x69, r18
    adb4:	3a ad       	sts	0x6a, r19
    adb6:	4b ad       	sts	0x6b, r20
    adb8:	5c ad       	sts	0x6c, r21
    adba:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    adbe:	8b 01       	movw	r16, r22
    adc0:	9c 01       	movw	r18, r24
    adc2:	21 96       	adiw	r28, 0x01	; 1
    adc4:	4c ad       	sts	0x6c, r20
    adc6:	5d ad       	sts	0x6d, r21
    adc8:	6e ad       	sts	0x6e, r22
    adca:	7f ad       	sts	0x6f, r23
    adcc:	21 97       	sbiw	r28, 0x01	; 1
    adce:	da 01       	movw	r26, r20
    add0:	99 27       	eor	r25, r25
    add2:	88 27       	eor	r24, r24
    add4:	4d a5       	lds	r20, 0x6d
    add6:	5e a5       	lds	r21, 0x6e
    add8:	6f a5       	lds	r22, 0x6f
    adda:	78 a9       	sts	0x48, r23
    addc:	60 70       	andi	r22, 0x00	; 0
    adde:	70 70       	andi	r23, 0x00	; 0
    ade0:	84 2b       	or	r24, r20
    ade2:	95 2b       	or	r25, r21
    ade4:	a6 2b       	or	r26, r22
    ade6:	b7 2b       	or	r27, r23
    ade8:	49 a5       	lds	r20, 0x69
    adea:	5a a5       	lds	r21, 0x6a
    adec:	6b a5       	lds	r22, 0x6b
    adee:	7c a5       	lds	r23, 0x6c
    adf0:	80 17       	cp	r24, r16
    adf2:	91 07       	cpc	r25, r17
    adf4:	a2 07       	cpc	r26, r18
    adf6:	b3 07       	cpc	r27, r19
    adf8:	f0 f4       	brcc	.+60     	; 0xae36 <__divdi3+0x7f8>
    adfa:	41 50       	subi	r20, 0x01	; 1
    adfc:	50 40       	sbci	r21, 0x00	; 0
    adfe:	60 40       	sbci	r22, 0x00	; 0
    ae00:	70 40       	sbci	r23, 0x00	; 0
    ae02:	88 0d       	add	r24, r8
    ae04:	99 1d       	adc	r25, r9
    ae06:	aa 1d       	adc	r26, r10
    ae08:	bb 1d       	adc	r27, r11
    ae0a:	88 15       	cp	r24, r8
    ae0c:	99 05       	cpc	r25, r9
    ae0e:	aa 05       	cpc	r26, r10
    ae10:	bb 05       	cpc	r27, r11
    ae12:	88 f0       	brcs	.+34     	; 0xae36 <__divdi3+0x7f8>
    ae14:	80 17       	cp	r24, r16
    ae16:	91 07       	cpc	r25, r17
    ae18:	a2 07       	cpc	r26, r18
    ae1a:	b3 07       	cpc	r27, r19
    ae1c:	60 f4       	brcc	.+24     	; 0xae36 <__divdi3+0x7f8>
    ae1e:	49 a5       	lds	r20, 0x69
    ae20:	5a a5       	lds	r21, 0x6a
    ae22:	6b a5       	lds	r22, 0x6b
    ae24:	7c a5       	lds	r23, 0x6c
    ae26:	42 50       	subi	r20, 0x02	; 2
    ae28:	50 40       	sbci	r21, 0x00	; 0
    ae2a:	60 40       	sbci	r22, 0x00	; 0
    ae2c:	70 40       	sbci	r23, 0x00	; 0
    ae2e:	88 0d       	add	r24, r8
    ae30:	99 1d       	adc	r25, r9
    ae32:	aa 1d       	adc	r26, r10
    ae34:	bb 1d       	adc	r27, r11
    ae36:	6c 01       	movw	r12, r24
    ae38:	7d 01       	movw	r14, r26
    ae3a:	c0 1a       	sub	r12, r16
    ae3c:	d1 0a       	sbc	r13, r17
    ae3e:	e2 0a       	sbc	r14, r18
    ae40:	f3 0a       	sbc	r15, r19
    ae42:	09 a9       	sts	0x49, r16
    ae44:	1a a9       	sts	0x4a, r17
    ae46:	2b a9       	sts	0x4b, r18
    ae48:	3c a9       	sts	0x4c, r19
    ae4a:	38 01       	movw	r6, r16
    ae4c:	55 24       	eor	r5, r5
    ae4e:	44 24       	eor	r4, r4
    ae50:	44 2a       	or	r4, r20
    ae52:	55 2a       	or	r5, r21
    ae54:	66 2a       	or	r6, r22
    ae56:	77 2a       	or	r7, r23
    ae58:	85 01       	movw	r16, r10
    ae5a:	22 27       	eor	r18, r18
    ae5c:	33 27       	eor	r19, r19
    ae5e:	0d a7       	lds	r16, 0x7d
    ae60:	1e a7       	lds	r17, 0x7e
    ae62:	2f a7       	lds	r18, 0x7f
    ae64:	38 ab       	sts	0x58, r19
    ae66:	95 01       	movw	r18, r10
    ae68:	84 01       	movw	r16, r8
    ae6a:	20 70       	andi	r18, 0x00	; 0
    ae6c:	30 70       	andi	r19, 0x00	; 0
    ae6e:	09 af       	sts	0x79, r16
    ae70:	1a af       	sts	0x7a, r17
    ae72:	2b af       	sts	0x7b, r18
    ae74:	3c af       	sts	0x7c, r19
    ae76:	c7 01       	movw	r24, r14
    ae78:	b6 01       	movw	r22, r12
    ae7a:	2d a5       	lds	r18, 0x6d
    ae7c:	3e a5       	lds	r19, 0x6e
    ae7e:	4f a5       	lds	r20, 0x6f
    ae80:	58 a9       	sts	0x48, r21
    ae82:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    ae86:	29 a7       	lds	r18, 0x79
    ae88:	3a a7       	lds	r19, 0x7a
    ae8a:	4b a7       	lds	r20, 0x7b
    ae8c:	5c a7       	lds	r21, 0x7c
    ae8e:	69 ab       	sts	0x59, r22
    ae90:	7a ab       	sts	0x5a, r23
    ae92:	8b ab       	sts	0x5b, r24
    ae94:	9c ab       	sts	0x5c, r25
    ae96:	c7 01       	movw	r24, r14
    ae98:	b6 01       	movw	r22, r12
    ae9a:	2d a5       	lds	r18, 0x6d
    ae9c:	3e a5       	lds	r19, 0x6e
    ae9e:	4f a5       	lds	r20, 0x6f
    aea0:	58 a9       	sts	0x48, r21
    aea2:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    aea6:	ca 01       	movw	r24, r20
    aea8:	b9 01       	movw	r22, r18
    aeaa:	29 ad       	sts	0x69, r18
    aeac:	3a ad       	sts	0x6a, r19
    aeae:	4b ad       	sts	0x6b, r20
    aeb0:	5c ad       	sts	0x6c, r21
    aeb2:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    aeb6:	ab 01       	movw	r20, r22
    aeb8:	bc 01       	movw	r22, r24
    aeba:	09 a9       	sts	0x49, r16
    aebc:	1a a9       	sts	0x4a, r17
    aebe:	2b a9       	sts	0x4b, r18
    aec0:	3c a9       	sts	0x4c, r19
    aec2:	78 01       	movw	r14, r16
    aec4:	dd 24       	eor	r13, r13
    aec6:	cc 24       	eor	r12, r12
    aec8:	0d a9       	sts	0x4d, r16
    aeca:	1e a9       	sts	0x4e, r17
    aecc:	2f a9       	sts	0x4f, r18
    aece:	38 ad       	sts	0x68, r19
    aed0:	c9 01       	movw	r24, r18
    aed2:	aa 27       	eor	r26, r26
    aed4:	bb 27       	eor	r27, r27
    aed6:	c8 2a       	or	r12, r24
    aed8:	d9 2a       	or	r13, r25
    aeda:	ea 2a       	or	r14, r26
    aedc:	fb 2a       	or	r15, r27
    aede:	09 a5       	lds	r16, 0x69
    aee0:	1a a5       	lds	r17, 0x6a
    aee2:	2b a5       	lds	r18, 0x6b
    aee4:	3c a5       	lds	r19, 0x6c
    aee6:	c4 16       	cp	r12, r20
    aee8:	d5 06       	cpc	r13, r21
    aeea:	e6 06       	cpc	r14, r22
    aeec:	f7 06       	cpc	r15, r23
    aeee:	38 f5       	brcc	.+78     	; 0xaf3e <__divdi3+0x900>
    aef0:	01 50       	subi	r16, 0x01	; 1
    aef2:	10 40       	sbci	r17, 0x00	; 0
    aef4:	20 40       	sbci	r18, 0x00	; 0
    aef6:	30 40       	sbci	r19, 0x00	; 0
    aef8:	09 ab       	sts	0x59, r16
    aefa:	1a ab       	sts	0x5a, r17
    aefc:	2b ab       	sts	0x5b, r18
    aefe:	3c ab       	sts	0x5c, r19
    af00:	c8 0c       	add	r12, r8
    af02:	d9 1c       	adc	r13, r9
    af04:	ea 1c       	adc	r14, r10
    af06:	fb 1c       	adc	r15, r11
    af08:	c8 14       	cp	r12, r8
    af0a:	d9 04       	cpc	r13, r9
    af0c:	ea 04       	cpc	r14, r10
    af0e:	fb 04       	cpc	r15, r11
    af10:	d0 f0       	brcs	.+52     	; 0xaf46 <__divdi3+0x908>
    af12:	c4 16       	cp	r12, r20
    af14:	d5 06       	cpc	r13, r21
    af16:	e6 06       	cpc	r14, r22
    af18:	f7 06       	cpc	r15, r23
    af1a:	a8 f4       	brcc	.+42     	; 0xaf46 <__divdi3+0x908>
    af1c:	09 a5       	lds	r16, 0x69
    af1e:	1a a5       	lds	r17, 0x6a
    af20:	2b a5       	lds	r18, 0x6b
    af22:	3c a5       	lds	r19, 0x6c
    af24:	02 50       	subi	r16, 0x02	; 2
    af26:	10 40       	sbci	r17, 0x00	; 0
    af28:	20 40       	sbci	r18, 0x00	; 0
    af2a:	30 40       	sbci	r19, 0x00	; 0
    af2c:	09 ab       	sts	0x59, r16
    af2e:	1a ab       	sts	0x5a, r17
    af30:	2b ab       	sts	0x5b, r18
    af32:	3c ab       	sts	0x5c, r19
    af34:	c8 0c       	add	r12, r8
    af36:	d9 1c       	adc	r13, r9
    af38:	ea 1c       	adc	r14, r10
    af3a:	fb 1c       	adc	r15, r11
    af3c:	04 c0       	rjmp	.+8      	; 0xaf46 <__divdi3+0x908>
    af3e:	09 ab       	sts	0x59, r16
    af40:	1a ab       	sts	0x5a, r17
    af42:	2b ab       	sts	0x5b, r18
    af44:	3c ab       	sts	0x5c, r19
    af46:	c4 1a       	sub	r12, r20
    af48:	d5 0a       	sbc	r13, r21
    af4a:	e6 0a       	sbc	r14, r22
    af4c:	f7 0a       	sbc	r15, r23
    af4e:	c7 01       	movw	r24, r14
    af50:	b6 01       	movw	r22, r12
    af52:	2d a5       	lds	r18, 0x6d
    af54:	3e a5       	lds	r19, 0x6e
    af56:	4f a5       	lds	r20, 0x6f
    af58:	58 a9       	sts	0x48, r21
    af5a:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    af5e:	29 a7       	lds	r18, 0x79
    af60:	3a a7       	lds	r19, 0x7a
    af62:	4b a7       	lds	r20, 0x7b
    af64:	5c a7       	lds	r21, 0x7c
    af66:	21 96       	adiw	r28, 0x01	; 1
    af68:	6c af       	sts	0x7c, r22
    af6a:	7d af       	sts	0x7d, r23
    af6c:	8e af       	sts	0x7e, r24
    af6e:	9f af       	sts	0x7f, r25
    af70:	21 97       	sbiw	r28, 0x01	; 1
    af72:	c7 01       	movw	r24, r14
    af74:	b6 01       	movw	r22, r12
    af76:	2d a5       	lds	r18, 0x6d
    af78:	3e a5       	lds	r19, 0x6e
    af7a:	4f a5       	lds	r20, 0x6f
    af7c:	58 a9       	sts	0x48, r21
    af7e:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    af82:	ca 01       	movw	r24, r20
    af84:	b9 01       	movw	r22, r18
    af86:	29 ad       	sts	0x69, r18
    af88:	3a ad       	sts	0x6a, r19
    af8a:	4b ad       	sts	0x6b, r20
    af8c:	5c ad       	sts	0x6c, r21
    af8e:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    af92:	8b 01       	movw	r16, r22
    af94:	9c 01       	movw	r18, r24
    af96:	21 96       	adiw	r28, 0x01	; 1
    af98:	4c ad       	sts	0x6c, r20
    af9a:	5d ad       	sts	0x6d, r21
    af9c:	6e ad       	sts	0x6e, r22
    af9e:	7f ad       	sts	0x6f, r23
    afa0:	21 97       	sbiw	r28, 0x01	; 1
    afa2:	da 01       	movw	r26, r20
    afa4:	99 27       	eor	r25, r25
    afa6:	88 27       	eor	r24, r24
    afa8:	4d a9       	sts	0x4d, r20
    afaa:	5e a9       	sts	0x4e, r21
    afac:	6f a9       	sts	0x4f, r22
    afae:	78 ad       	sts	0x68, r23
    afb0:	60 70       	andi	r22, 0x00	; 0
    afb2:	70 70       	andi	r23, 0x00	; 0
    afb4:	84 2b       	or	r24, r20
    afb6:	95 2b       	or	r25, r21
    afb8:	a6 2b       	or	r26, r22
    afba:	b7 2b       	or	r27, r23
    afbc:	49 a5       	lds	r20, 0x69
    afbe:	5a a5       	lds	r21, 0x6a
    afc0:	6b a5       	lds	r22, 0x6b
    afc2:	7c a5       	lds	r23, 0x6c
    afc4:	80 17       	cp	r24, r16
    afc6:	91 07       	cpc	r25, r17
    afc8:	a2 07       	cpc	r26, r18
    afca:	b3 07       	cpc	r27, r19
    afcc:	d0 f4       	brcc	.+52     	; 0xb002 <__divdi3+0x9c4>
    afce:	41 50       	subi	r20, 0x01	; 1
    afd0:	50 40       	sbci	r21, 0x00	; 0
    afd2:	60 40       	sbci	r22, 0x00	; 0
    afd4:	70 40       	sbci	r23, 0x00	; 0
    afd6:	88 0d       	add	r24, r8
    afd8:	99 1d       	adc	r25, r9
    afda:	aa 1d       	adc	r26, r10
    afdc:	bb 1d       	adc	r27, r11
    afde:	88 15       	cp	r24, r8
    afe0:	99 05       	cpc	r25, r9
    afe2:	aa 05       	cpc	r26, r10
    afe4:	bb 05       	cpc	r27, r11
    afe6:	68 f0       	brcs	.+26     	; 0xb002 <__divdi3+0x9c4>
    afe8:	80 17       	cp	r24, r16
    afea:	91 07       	cpc	r25, r17
    afec:	a2 07       	cpc	r26, r18
    afee:	b3 07       	cpc	r27, r19
    aff0:	40 f4       	brcc	.+16     	; 0xb002 <__divdi3+0x9c4>
    aff2:	49 a5       	lds	r20, 0x69
    aff4:	5a a5       	lds	r21, 0x6a
    aff6:	6b a5       	lds	r22, 0x6b
    aff8:	7c a5       	lds	r23, 0x6c
    affa:	42 50       	subi	r20, 0x02	; 2
    affc:	50 40       	sbci	r21, 0x00	; 0
    affe:	60 40       	sbci	r22, 0x00	; 0
    b000:	70 40       	sbci	r23, 0x00	; 0
    b002:	09 a9       	sts	0x49, r16
    b004:	1a a9       	sts	0x4a, r17
    b006:	2b a9       	sts	0x4b, r18
    b008:	3c a9       	sts	0x4c, r19
    b00a:	78 01       	movw	r14, r16
    b00c:	dd 24       	eor	r13, r13
    b00e:	cc 24       	eor	r12, r12
    b010:	c4 2a       	or	r12, r20
    b012:	d5 2a       	or	r13, r21
    b014:	e6 2a       	or	r14, r22
    b016:	f7 2a       	or	r15, r23
    b018:	50 c2       	rjmp	.+1184   	; 0xb4ba <__divdi3+0xe7c>
    b01a:	c8 16       	cp	r12, r24
    b01c:	d9 06       	cpc	r13, r25
    b01e:	ea 06       	cpc	r14, r26
    b020:	fb 06       	cpc	r15, r27
    b022:	08 f4       	brcc	.+2      	; 0xb026 <__divdi3+0x9e8>
    b024:	37 c2       	rjmp	.+1134   	; 0xb494 <__divdi3+0xe56>
    b026:	80 30       	cpi	r24, 0x00	; 0
    b028:	10 e0       	ldi	r17, 0x00	; 0
    b02a:	91 07       	cpc	r25, r17
    b02c:	11 e0       	ldi	r17, 0x01	; 1
    b02e:	a1 07       	cpc	r26, r17
    b030:	10 e0       	ldi	r17, 0x00	; 0
    b032:	b1 07       	cpc	r27, r17
    b034:	50 f4       	brcc	.+20     	; 0xb04a <__divdi3+0xa0c>
    b036:	8f 3f       	cpi	r24, 0xFF	; 255
    b038:	91 05       	cpc	r25, r1
    b03a:	a1 05       	cpc	r26, r1
    b03c:	b1 05       	cpc	r27, r1
    b03e:	09 f0       	breq	.+2      	; 0xb042 <__divdi3+0xa04>
    b040:	88 f4       	brcc	.+34     	; 0xb064 <__divdi3+0xa26>
    b042:	00 e0       	ldi	r16, 0x00	; 0
    b044:	10 e0       	ldi	r17, 0x00	; 0
    b046:	98 01       	movw	r18, r16
    b048:	16 c0       	rjmp	.+44     	; 0xb076 <__divdi3+0xa38>
    b04a:	80 30       	cpi	r24, 0x00	; 0
    b04c:	20 e0       	ldi	r18, 0x00	; 0
    b04e:	92 07       	cpc	r25, r18
    b050:	20 e0       	ldi	r18, 0x00	; 0
    b052:	a2 07       	cpc	r26, r18
    b054:	21 e0       	ldi	r18, 0x01	; 1
    b056:	b2 07       	cpc	r27, r18
    b058:	50 f4       	brcc	.+20     	; 0xb06e <__divdi3+0xa30>
    b05a:	00 e1       	ldi	r16, 0x10	; 16
    b05c:	10 e0       	ldi	r17, 0x00	; 0
    b05e:	20 e0       	ldi	r18, 0x00	; 0
    b060:	30 e0       	ldi	r19, 0x00	; 0
    b062:	09 c0       	rjmp	.+18     	; 0xb076 <__divdi3+0xa38>
    b064:	08 e0       	ldi	r16, 0x08	; 8
    b066:	10 e0       	ldi	r17, 0x00	; 0
    b068:	20 e0       	ldi	r18, 0x00	; 0
    b06a:	30 e0       	ldi	r19, 0x00	; 0
    b06c:	04 c0       	rjmp	.+8      	; 0xb076 <__divdi3+0xa38>
    b06e:	08 e1       	ldi	r16, 0x18	; 24
    b070:	10 e0       	ldi	r17, 0x00	; 0
    b072:	20 e0       	ldi	r18, 0x00	; 0
    b074:	30 e0       	ldi	r19, 0x00	; 0
    b076:	ac 01       	movw	r20, r24
    b078:	bd 01       	movw	r22, r26
    b07a:	00 2e       	mov	r0, r16
    b07c:	04 c0       	rjmp	.+8      	; 0xb086 <__divdi3+0xa48>
    b07e:	76 95       	lsr	r23
    b080:	67 95       	ror	r22
    b082:	57 95       	ror	r21
    b084:	47 95       	ror	r20
    b086:	0a 94       	dec	r0
    b088:	d2 f7       	brpl	.-12     	; 0xb07e <__divdi3+0xa40>
    b08a:	fa 01       	movw	r30, r20
    b08c:	e6 5e       	subi	r30, 0xE6	; 230
    b08e:	ff 4d       	sbci	r31, 0xDF	; 223
    b090:	40 81       	ld	r20, Z
    b092:	04 0f       	add	r16, r20
    b094:	11 1d       	adc	r17, r1
    b096:	21 1d       	adc	r18, r1
    b098:	31 1d       	adc	r19, r1
    b09a:	40 e2       	ldi	r20, 0x20	; 32
    b09c:	50 e0       	ldi	r21, 0x00	; 0
    b09e:	60 e0       	ldi	r22, 0x00	; 0
    b0a0:	70 e0       	ldi	r23, 0x00	; 0
    b0a2:	40 1b       	sub	r20, r16
    b0a4:	51 0b       	sbc	r21, r17
    b0a6:	62 0b       	sbc	r22, r18
    b0a8:	73 0b       	sbc	r23, r19
    b0aa:	a1 f4       	brne	.+40     	; 0xb0d4 <__divdi3+0xa96>
    b0ac:	8c 15       	cp	r24, r12
    b0ae:	9d 05       	cpc	r25, r13
    b0b0:	ae 05       	cpc	r26, r14
    b0b2:	bf 05       	cpc	r27, r15
    b0b4:	08 f4       	brcc	.+2      	; 0xb0b8 <__divdi3+0xa7a>
    b0b6:	f5 c1       	rjmp	.+1002   	; 0xb4a2 <__divdi3+0xe64>
    b0b8:	ed a8       	sts	0x8d, r30
    b0ba:	fe a8       	sts	0x8e, r31
    b0bc:	0f a9       	sts	0x4f, r16
    b0be:	18 ad       	sts	0x68, r17
    b0c0:	44 24       	eor	r4, r4
    b0c2:	55 24       	eor	r5, r5
    b0c4:	32 01       	movw	r6, r4
    b0c6:	e8 14       	cp	r14, r8
    b0c8:	f9 04       	cpc	r15, r9
    b0ca:	0a 05       	cpc	r16, r10
    b0cc:	1b 05       	cpc	r17, r11
    b0ce:	08 f0       	brcs	.+2      	; 0xb0d2 <__divdi3+0xa94>
    b0d0:	eb c1       	rjmp	.+982    	; 0xb4a8 <__divdi3+0xe6a>
    b0d2:	e3 c1       	rjmp	.+966    	; 0xb49a <__divdi3+0xe5c>
    b0d4:	34 2e       	mov	r3, r20
    b0d6:	2c 01       	movw	r4, r24
    b0d8:	3d 01       	movw	r6, r26
    b0da:	04 c0       	rjmp	.+8      	; 0xb0e4 <__divdi3+0xaa6>
    b0dc:	44 0c       	add	r4, r4
    b0de:	55 1c       	adc	r5, r5
    b0e0:	66 1c       	adc	r6, r6
    b0e2:	77 1c       	adc	r7, r7
    b0e4:	4a 95       	dec	r20
    b0e6:	d2 f7       	brpl	.-12     	; 0xb0dc <__divdi3+0xa9e>
    b0e8:	d5 01       	movw	r26, r10
    b0ea:	c4 01       	movw	r24, r8
    b0ec:	00 2e       	mov	r0, r16
    b0ee:	04 c0       	rjmp	.+8      	; 0xb0f8 <__divdi3+0xaba>
    b0f0:	b6 95       	lsr	r27
    b0f2:	a7 95       	ror	r26
    b0f4:	97 95       	ror	r25
    b0f6:	87 95       	ror	r24
    b0f8:	0a 94       	dec	r0
    b0fa:	d2 f7       	brpl	.-12     	; 0xb0f0 <__divdi3+0xab2>
    b0fc:	48 2a       	or	r4, r24
    b0fe:	59 2a       	or	r5, r25
    b100:	6a 2a       	or	r6, r26
    b102:	7b 2a       	or	r7, r27
    b104:	a5 01       	movw	r20, r10
    b106:	94 01       	movw	r18, r8
    b108:	03 2c       	mov	r0, r3
    b10a:	04 c0       	rjmp	.+8      	; 0xb114 <__divdi3+0xad6>
    b10c:	22 0f       	add	r18, r18
    b10e:	33 1f       	adc	r19, r19
    b110:	44 1f       	adc	r20, r20
    b112:	55 1f       	adc	r21, r21
    b114:	0a 94       	dec	r0
    b116:	d2 f7       	brpl	.-12     	; 0xb10c <__divdi3+0xace>
    b118:	29 af       	sts	0x79, r18
    b11a:	3a af       	sts	0x7a, r19
    b11c:	4b af       	sts	0x7b, r20
    b11e:	5c af       	sts	0x7c, r21
    b120:	b7 01       	movw	r22, r14
    b122:	a6 01       	movw	r20, r12
    b124:	00 2e       	mov	r0, r16
    b126:	04 c0       	rjmp	.+8      	; 0xb130 <__divdi3+0xaf2>
    b128:	76 95       	lsr	r23
    b12a:	67 95       	ror	r22
    b12c:	57 95       	ror	r21
    b12e:	47 95       	ror	r20
    b130:	0a 94       	dec	r0
    b132:	d2 f7       	brpl	.-12     	; 0xb128 <__divdi3+0xaea>
    b134:	49 ab       	sts	0x59, r20
    b136:	5a ab       	sts	0x5a, r21
    b138:	6b ab       	sts	0x5b, r22
    b13a:	7c ab       	sts	0x5c, r23
    b13c:	c7 01       	movw	r24, r14
    b13e:	b6 01       	movw	r22, r12
    b140:	03 2c       	mov	r0, r3
    b142:	04 c0       	rjmp	.+8      	; 0xb14c <__divdi3+0xb0e>
    b144:	66 0f       	add	r22, r22
    b146:	77 1f       	adc	r23, r23
    b148:	88 1f       	adc	r24, r24
    b14a:	99 1f       	adc	r25, r25
    b14c:	0a 94       	dec	r0
    b14e:	d2 f7       	brpl	.-12     	; 0xb144 <__divdi3+0xb06>
    b150:	6d a7       	lds	r22, 0x7d
    b152:	7e a7       	lds	r23, 0x7e
    b154:	8f a7       	lds	r24, 0x7f
    b156:	98 ab       	sts	0x58, r25
    b158:	8d a9       	sts	0x4d, r24
    b15a:	9e a9       	sts	0x4e, r25
    b15c:	af a9       	sts	0x4f, r26
    b15e:	b8 ad       	sts	0x68, r27
    b160:	04 c0       	rjmp	.+8      	; 0xb16a <__divdi3+0xb2c>
    b162:	b6 95       	lsr	r27
    b164:	a7 95       	ror	r26
    b166:	97 95       	ror	r25
    b168:	87 95       	ror	r24
    b16a:	0a 95       	dec	r16
    b16c:	d2 f7       	brpl	.-12     	; 0xb162 <__divdi3+0xb24>
    b16e:	4d a5       	lds	r20, 0x6d
    b170:	5e a5       	lds	r21, 0x6e
    b172:	6f a5       	lds	r22, 0x6f
    b174:	78 a9       	sts	0x48, r23
    b176:	48 2b       	or	r20, r24
    b178:	59 2b       	or	r21, r25
    b17a:	6a 2b       	or	r22, r26
    b17c:	7b 2b       	or	r23, r27
    b17e:	4d a7       	lds	r20, 0x7d
    b180:	5e a7       	lds	r21, 0x7e
    b182:	6f a7       	lds	r22, 0x7f
    b184:	78 ab       	sts	0x58, r23
    b186:	43 01       	movw	r8, r6
    b188:	aa 24       	eor	r10, r10
    b18a:	bb 24       	eor	r11, r11
    b18c:	93 01       	movw	r18, r6
    b18e:	82 01       	movw	r16, r4
    b190:	20 70       	andi	r18, 0x00	; 0
    b192:	30 70       	andi	r19, 0x00	; 0
    b194:	21 96       	adiw	r28, 0x01	; 1
    b196:	0c af       	sts	0x7c, r16
    b198:	1d af       	sts	0x7d, r17
    b19a:	2e af       	sts	0x7e, r18
    b19c:	3f af       	sts	0x7f, r19
    b19e:	21 97       	sbiw	r28, 0x01	; 1
    b1a0:	69 a9       	sts	0x49, r22
    b1a2:	7a a9       	sts	0x4a, r23
    b1a4:	8b a9       	sts	0x4b, r24
    b1a6:	9c a9       	sts	0x4c, r25
    b1a8:	a5 01       	movw	r20, r10
    b1aa:	94 01       	movw	r18, r8
    b1ac:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    b1b0:	29 a7       	lds	r18, 0x79
    b1b2:	3a a7       	lds	r19, 0x7a
    b1b4:	4b a7       	lds	r20, 0x7b
    b1b6:	5c a7       	lds	r21, 0x7c
    b1b8:	6b 01       	movw	r12, r22
    b1ba:	7c 01       	movw	r14, r24
    b1bc:	69 a9       	sts	0x49, r22
    b1be:	7a a9       	sts	0x4a, r23
    b1c0:	8b a9       	sts	0x4b, r24
    b1c2:	9c a9       	sts	0x4c, r25
    b1c4:	a5 01       	movw	r20, r10
    b1c6:	94 01       	movw	r18, r8
    b1c8:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    b1cc:	ca 01       	movw	r24, r20
    b1ce:	b9 01       	movw	r22, r18
    b1d0:	21 96       	adiw	r28, 0x01	; 1
    b1d2:	2c ad       	sts	0x6c, r18
    b1d4:	3d ad       	sts	0x6d, r19
    b1d6:	4e ad       	sts	0x6e, r20
    b1d8:	5f ad       	sts	0x6f, r21
    b1da:	21 97       	sbiw	r28, 0x01	; 1
    b1dc:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    b1e0:	dc 01       	movw	r26, r24
    b1e2:	cb 01       	movw	r24, r22
    b1e4:	76 01       	movw	r14, r12
    b1e6:	dd 24       	eor	r13, r13
    b1e8:	cc 24       	eor	r12, r12
    b1ea:	0d a5       	lds	r16, 0x6d
    b1ec:	1e a5       	lds	r17, 0x6e
    b1ee:	2f a5       	lds	r18, 0x6f
    b1f0:	38 a9       	sts	0x48, r19
    b1f2:	a9 01       	movw	r20, r18
    b1f4:	66 27       	eor	r22, r22
    b1f6:	77 27       	eor	r23, r23
    b1f8:	c4 2a       	or	r12, r20
    b1fa:	d5 2a       	or	r13, r21
    b1fc:	e6 2a       	or	r14, r22
    b1fe:	f7 2a       	or	r15, r23
    b200:	09 a5       	lds	r16, 0x69
    b202:	1a a5       	lds	r17, 0x6a
    b204:	2b a5       	lds	r18, 0x6b
    b206:	3c a5       	lds	r19, 0x6c
    b208:	c8 16       	cp	r12, r24
    b20a:	d9 06       	cpc	r13, r25
    b20c:	ea 06       	cpc	r14, r26
    b20e:	fb 06       	cpc	r15, r27
    b210:	38 f5       	brcc	.+78     	; 0xb260 <__divdi3+0xc22>
    b212:	01 50       	subi	r16, 0x01	; 1
    b214:	10 40       	sbci	r17, 0x00	; 0
    b216:	20 40       	sbci	r18, 0x00	; 0
    b218:	30 40       	sbci	r19, 0x00	; 0
    b21a:	09 ab       	sts	0x59, r16
    b21c:	1a ab       	sts	0x5a, r17
    b21e:	2b ab       	sts	0x5b, r18
    b220:	3c ab       	sts	0x5c, r19
    b222:	c4 0c       	add	r12, r4
    b224:	d5 1c       	adc	r13, r5
    b226:	e6 1c       	adc	r14, r6
    b228:	f7 1c       	adc	r15, r7
    b22a:	c4 14       	cp	r12, r4
    b22c:	d5 04       	cpc	r13, r5
    b22e:	e6 04       	cpc	r14, r6
    b230:	f7 04       	cpc	r15, r7
    b232:	d0 f0       	brcs	.+52     	; 0xb268 <__divdi3+0xc2a>
    b234:	c8 16       	cp	r12, r24
    b236:	d9 06       	cpc	r13, r25
    b238:	ea 06       	cpc	r14, r26
    b23a:	fb 06       	cpc	r15, r27
    b23c:	a8 f4       	brcc	.+42     	; 0xb268 <__divdi3+0xc2a>
    b23e:	09 a5       	lds	r16, 0x69
    b240:	1a a5       	lds	r17, 0x6a
    b242:	2b a5       	lds	r18, 0x6b
    b244:	3c a5       	lds	r19, 0x6c
    b246:	02 50       	subi	r16, 0x02	; 2
    b248:	10 40       	sbci	r17, 0x00	; 0
    b24a:	20 40       	sbci	r18, 0x00	; 0
    b24c:	30 40       	sbci	r19, 0x00	; 0
    b24e:	09 ab       	sts	0x59, r16
    b250:	1a ab       	sts	0x5a, r17
    b252:	2b ab       	sts	0x5b, r18
    b254:	3c ab       	sts	0x5c, r19
    b256:	c4 0c       	add	r12, r4
    b258:	d5 1c       	adc	r13, r5
    b25a:	e6 1c       	adc	r14, r6
    b25c:	f7 1c       	adc	r15, r7
    b25e:	04 c0       	rjmp	.+8      	; 0xb268 <__divdi3+0xc2a>
    b260:	09 ab       	sts	0x59, r16
    b262:	1a ab       	sts	0x5a, r17
    b264:	2b ab       	sts	0x5b, r18
    b266:	3c ab       	sts	0x5c, r19
    b268:	c8 1a       	sub	r12, r24
    b26a:	d9 0a       	sbc	r13, r25
    b26c:	ea 0a       	sbc	r14, r26
    b26e:	fb 0a       	sbc	r15, r27
    b270:	c7 01       	movw	r24, r14
    b272:	b6 01       	movw	r22, r12
    b274:	a5 01       	movw	r20, r10
    b276:	94 01       	movw	r18, r8
    b278:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    b27c:	29 a7       	lds	r18, 0x79
    b27e:	3a a7       	lds	r19, 0x7a
    b280:	4b a7       	lds	r20, 0x7b
    b282:	5c a7       	lds	r21, 0x7c
    b284:	29 96       	adiw	r28, 0x09	; 9
    b286:	6c af       	sts	0x7c, r22
    b288:	7d af       	sts	0x7d, r23
    b28a:	8e af       	sts	0x7e, r24
    b28c:	9f af       	sts	0x7f, r25
    b28e:	29 97       	sbiw	r28, 0x09	; 9
    b290:	c7 01       	movw	r24, r14
    b292:	b6 01       	movw	r22, r12
    b294:	a5 01       	movw	r20, r10
    b296:	94 01       	movw	r18, r8
    b298:	0e 94 95 5c 	call	0xb92a	; 0xb92a <__udivmodsi4>
    b29c:	ca 01       	movw	r24, r20
    b29e:	b9 01       	movw	r22, r18
    b2a0:	21 96       	adiw	r28, 0x01	; 1
    b2a2:	2c ad       	sts	0x6c, r18
    b2a4:	3d ad       	sts	0x6d, r19
    b2a6:	4e ad       	sts	0x6e, r20
    b2a8:	5f ad       	sts	0x6f, r21
    b2aa:	21 97       	sbiw	r28, 0x01	; 1
    b2ac:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    b2b0:	4b 01       	movw	r8, r22
    b2b2:	5c 01       	movw	r10, r24
    b2b4:	29 96       	adiw	r28, 0x09	; 9
    b2b6:	4c ad       	sts	0x6c, r20
    b2b8:	5d ad       	sts	0x6d, r21
    b2ba:	6e ad       	sts	0x6e, r22
    b2bc:	7f ad       	sts	0x6f, r23
    b2be:	29 97       	sbiw	r28, 0x09	; 9
    b2c0:	9a 01       	movw	r18, r20
    b2c2:	11 27       	eor	r17, r17
    b2c4:	00 27       	eor	r16, r16
    b2c6:	8d a5       	lds	r24, 0x6d
    b2c8:	9e a5       	lds	r25, 0x6e
    b2ca:	af a5       	lds	r26, 0x6f
    b2cc:	b8 a9       	sts	0x48, r27
    b2ce:	a0 70       	andi	r26, 0x00	; 0
    b2d0:	b0 70       	andi	r27, 0x00	; 0
    b2d2:	08 2b       	or	r16, r24
    b2d4:	19 2b       	or	r17, r25
    b2d6:	2a 2b       	or	r18, r26
    b2d8:	3b 2b       	or	r19, r27
    b2da:	89 a5       	lds	r24, 0x69
    b2dc:	9a a5       	lds	r25, 0x6a
    b2de:	ab a5       	lds	r26, 0x6b
    b2e0:	bc a5       	lds	r27, 0x6c
    b2e2:	08 15       	cp	r16, r8
    b2e4:	19 05       	cpc	r17, r9
    b2e6:	2a 05       	cpc	r18, r10
    b2e8:	3b 05       	cpc	r19, r11
    b2ea:	e0 f4       	brcc	.+56     	; 0xb324 <__divdi3+0xce6>
    b2ec:	01 97       	sbiw	r24, 0x01	; 1
    b2ee:	a1 09       	sbc	r26, r1
    b2f0:	b1 09       	sbc	r27, r1
    b2f2:	04 0d       	add	r16, r4
    b2f4:	15 1d       	adc	r17, r5
    b2f6:	26 1d       	adc	r18, r6
    b2f8:	37 1d       	adc	r19, r7
    b2fa:	04 15       	cp	r16, r4
    b2fc:	15 05       	cpc	r17, r5
    b2fe:	26 05       	cpc	r18, r6
    b300:	37 05       	cpc	r19, r7
    b302:	80 f0       	brcs	.+32     	; 0xb324 <__divdi3+0xce6>
    b304:	08 15       	cp	r16, r8
    b306:	19 05       	cpc	r17, r9
    b308:	2a 05       	cpc	r18, r10
    b30a:	3b 05       	cpc	r19, r11
    b30c:	58 f4       	brcc	.+22     	; 0xb324 <__divdi3+0xce6>
    b30e:	89 a5       	lds	r24, 0x69
    b310:	9a a5       	lds	r25, 0x6a
    b312:	ab a5       	lds	r26, 0x6b
    b314:	bc a5       	lds	r27, 0x6c
    b316:	02 97       	sbiw	r24, 0x02	; 2
    b318:	a1 09       	sbc	r26, r1
    b31a:	b1 09       	sbc	r27, r1
    b31c:	04 0d       	add	r16, r4
    b31e:	15 1d       	adc	r17, r5
    b320:	26 1d       	adc	r18, r6
    b322:	37 1d       	adc	r19, r7
    b324:	b9 01       	movw	r22, r18
    b326:	a8 01       	movw	r20, r16
    b328:	48 19       	sub	r20, r8
    b32a:	59 09       	sbc	r21, r9
    b32c:	6a 09       	sbc	r22, r10
    b32e:	7b 09       	sbc	r23, r11
    b330:	4d a7       	lds	r20, 0x7d
    b332:	5e a7       	lds	r21, 0x7e
    b334:	6f a7       	lds	r22, 0x7f
    b336:	78 ab       	sts	0x58, r23
    b338:	09 a9       	sts	0x49, r16
    b33a:	1a a9       	sts	0x4a, r17
    b33c:	2b a9       	sts	0x4b, r18
    b33e:	3c a9       	sts	0x4c, r19
    b340:	78 01       	movw	r14, r16
    b342:	dd 24       	eor	r13, r13
    b344:	cc 24       	eor	r12, r12
    b346:	c8 2a       	or	r12, r24
    b348:	d9 2a       	or	r13, r25
    b34a:	ea 2a       	or	r14, r26
    b34c:	fb 2a       	or	r15, r27
    b34e:	ff ef       	ldi	r31, 0xFF	; 255
    b350:	8f 2e       	mov	r8, r31
    b352:	ff ef       	ldi	r31, 0xFF	; 255
    b354:	9f 2e       	mov	r9, r31
    b356:	a1 2c       	mov	r10, r1
    b358:	b1 2c       	mov	r11, r1
    b35a:	8c 20       	and	r8, r12
    b35c:	9d 20       	and	r9, r13
    b35e:	ae 20       	and	r10, r14
    b360:	bf 20       	and	r11, r15
    b362:	87 01       	movw	r16, r14
    b364:	22 27       	eor	r18, r18
    b366:	33 27       	eor	r19, r19
    b368:	09 a7       	lds	r16, 0x79
    b36a:	1a a7       	lds	r17, 0x7a
    b36c:	2b a7       	lds	r18, 0x7b
    b36e:	3c a7       	lds	r19, 0x7c
    b370:	49 ac       	sts	0xa9, r20
    b372:	5a ac       	sts	0xaa, r21
    b374:	6b ac       	sts	0xab, r22
    b376:	7c ac       	sts	0xac, r23
    b378:	2f ef       	ldi	r18, 0xFF	; 255
    b37a:	3f ef       	ldi	r19, 0xFF	; 255
    b37c:	40 e0       	ldi	r20, 0x00	; 0
    b37e:	50 e0       	ldi	r21, 0x00	; 0
    b380:	42 22       	and	r4, r18
    b382:	53 22       	and	r5, r19
    b384:	64 22       	and	r6, r20
    b386:	75 22       	and	r7, r21
    b388:	29 ad       	sts	0x69, r18
    b38a:	3a ad       	sts	0x6a, r19
    b38c:	4b ad       	sts	0x6b, r20
    b38e:	5c ad       	sts	0x6c, r21
    b390:	8a 01       	movw	r16, r20
    b392:	22 27       	eor	r18, r18
    b394:	33 27       	eor	r19, r19
    b396:	09 ab       	sts	0x59, r16
    b398:	1a ab       	sts	0x5a, r17
    b39a:	2b ab       	sts	0x5b, r18
    b39c:	3c ab       	sts	0x5c, r19
    b39e:	c5 01       	movw	r24, r10
    b3a0:	b4 01       	movw	r22, r8
    b3a2:	a3 01       	movw	r20, r6
    b3a4:	92 01       	movw	r18, r4
    b3a6:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    b3aa:	69 af       	sts	0x79, r22
    b3ac:	7a af       	sts	0x7a, r23
    b3ae:	8b af       	sts	0x7b, r24
    b3b0:	9c af       	sts	0x7c, r25
    b3b2:	c5 01       	movw	r24, r10
    b3b4:	b4 01       	movw	r22, r8
    b3b6:	29 a9       	sts	0x49, r18
    b3b8:	3a a9       	sts	0x4a, r19
    b3ba:	4b a9       	sts	0x4b, r20
    b3bc:	5c a9       	sts	0x4c, r21
    b3be:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    b3c2:	4b 01       	movw	r8, r22
    b3c4:	5c 01       	movw	r10, r24
    b3c6:	69 a5       	lds	r22, 0x69
    b3c8:	7a a5       	lds	r23, 0x6a
    b3ca:	8b a5       	lds	r24, 0x6b
    b3cc:	9c a5       	lds	r25, 0x6c
    b3ce:	a3 01       	movw	r20, r6
    b3d0:	92 01       	movw	r18, r4
    b3d2:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    b3d6:	2b 01       	movw	r4, r22
    b3d8:	3c 01       	movw	r6, r24
    b3da:	69 a5       	lds	r22, 0x69
    b3dc:	7a a5       	lds	r23, 0x6a
    b3de:	8b a5       	lds	r24, 0x6b
    b3e0:	9c a5       	lds	r25, 0x6c
    b3e2:	29 a9       	sts	0x49, r18
    b3e4:	3a a9       	sts	0x4a, r19
    b3e6:	4b a9       	sts	0x4b, r20
    b3e8:	5c a9       	sts	0x4c, r21
    b3ea:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <__mulsi3>
    b3ee:	ab 01       	movw	r20, r22
    b3f0:	bc 01       	movw	r22, r24
    b3f2:	84 0c       	add	r8, r4
    b3f4:	95 1c       	adc	r9, r5
    b3f6:	a6 1c       	adc	r10, r6
    b3f8:	b7 1c       	adc	r11, r7
    b3fa:	09 ad       	sts	0x69, r16
    b3fc:	1a ad       	sts	0x6a, r17
    b3fe:	2b ad       	sts	0x6b, r18
    b400:	3c ad       	sts	0x6c, r19
    b402:	c9 01       	movw	r24, r18
    b404:	aa 27       	eor	r26, r26
    b406:	bb 27       	eor	r27, r27
    b408:	88 0e       	add	r8, r24
    b40a:	99 1e       	adc	r9, r25
    b40c:	aa 1e       	adc	r10, r26
    b40e:	bb 1e       	adc	r11, r27
    b410:	84 14       	cp	r8, r4
    b412:	95 04       	cpc	r9, r5
    b414:	a6 04       	cpc	r10, r6
    b416:	b7 04       	cpc	r11, r7
    b418:	20 f4       	brcc	.+8      	; 0xb422 <__divdi3+0xde4>
    b41a:	40 50       	subi	r20, 0x00	; 0
    b41c:	50 40       	sbci	r21, 0x00	; 0
    b41e:	6f 4f       	sbci	r22, 0xFF	; 255
    b420:	7f 4f       	sbci	r23, 0xFF	; 255
    b422:	c5 01       	movw	r24, r10
    b424:	aa 27       	eor	r26, r26
    b426:	bb 27       	eor	r27, r27
    b428:	84 0f       	add	r24, r20
    b42a:	95 1f       	adc	r25, r21
    b42c:	a6 1f       	adc	r26, r22
    b42e:	b7 1f       	adc	r27, r23
    b430:	0d a5       	lds	r16, 0x6d
    b432:	1e a5       	lds	r17, 0x6e
    b434:	2f a5       	lds	r18, 0x6f
    b436:	38 a9       	sts	0x48, r19
    b438:	08 17       	cp	r16, r24
    b43a:	19 07       	cpc	r17, r25
    b43c:	2a 07       	cpc	r18, r26
    b43e:	3b 07       	cpc	r19, r27
    b440:	18 f1       	brcs	.+70     	; 0xb488 <__divdi3+0xe4a>
    b442:	80 17       	cp	r24, r16
    b444:	91 07       	cpc	r25, r17
    b446:	a2 07       	cpc	r26, r18
    b448:	b3 07       	cpc	r27, r19
    b44a:	a1 f5       	brne	.+104    	; 0xb4b4 <__divdi3+0xe76>
    b44c:	54 01       	movw	r10, r8
    b44e:	99 24       	eor	r9, r9
    b450:	88 24       	eor	r8, r8
    b452:	89 ad       	sts	0x69, r24
    b454:	9a ad       	sts	0x6a, r25
    b456:	ab ad       	sts	0x6b, r26
    b458:	bc ad       	sts	0x6c, r27
    b45a:	a0 70       	andi	r26, 0x00	; 0
    b45c:	b0 70       	andi	r27, 0x00	; 0
    b45e:	88 0e       	add	r8, r24
    b460:	99 1e       	adc	r9, r25
    b462:	aa 1e       	adc	r10, r26
    b464:	bb 1e       	adc	r11, r27
    b466:	4d a9       	sts	0x4d, r20
    b468:	5e a9       	sts	0x4e, r21
    b46a:	6f a9       	sts	0x4f, r22
    b46c:	78 ad       	sts	0x68, r23
    b46e:	03 2c       	mov	r0, r3
    b470:	04 c0       	rjmp	.+8      	; 0xb47a <__divdi3+0xe3c>
    b472:	44 0f       	add	r20, r20
    b474:	55 1f       	adc	r21, r21
    b476:	66 1f       	adc	r22, r22
    b478:	77 1f       	adc	r23, r23
    b47a:	0a 94       	dec	r0
    b47c:	d2 f7       	brpl	.-12     	; 0xb472 <__divdi3+0xe34>
    b47e:	48 15       	cp	r20, r8
    b480:	59 05       	cpc	r21, r9
    b482:	6a 05       	cpc	r22, r10
    b484:	7b 05       	cpc	r23, r11
    b486:	b0 f4       	brcc	.+44     	; 0xb4b4 <__divdi3+0xe76>
    b488:	08 94       	sec
    b48a:	c1 08       	sbc	r12, r1
    b48c:	d1 08       	sbc	r13, r1
    b48e:	e1 08       	sbc	r14, r1
    b490:	f1 08       	sbc	r15, r1
    b492:	10 c0       	rjmp	.+32     	; 0xb4b4 <__divdi3+0xe76>
    b494:	44 24       	eor	r4, r4
    b496:	55 24       	eor	r5, r5
    b498:	32 01       	movw	r6, r4
    b49a:	cc 24       	eor	r12, r12
    b49c:	dd 24       	eor	r13, r13
    b49e:	76 01       	movw	r14, r12
    b4a0:	0c c0       	rjmp	.+24     	; 0xb4ba <__divdi3+0xe7c>
    b4a2:	44 24       	eor	r4, r4
    b4a4:	55 24       	eor	r5, r5
    b4a6:	32 01       	movw	r6, r4
    b4a8:	81 e0       	ldi	r24, 0x01	; 1
    b4aa:	c8 2e       	mov	r12, r24
    b4ac:	d1 2c       	mov	r13, r1
    b4ae:	e1 2c       	mov	r14, r1
    b4b0:	f1 2c       	mov	r15, r1
    b4b2:	03 c0       	rjmp	.+6      	; 0xb4ba <__divdi3+0xe7c>
    b4b4:	44 24       	eor	r4, r4
    b4b6:	55 24       	eor	r5, r5
    b4b8:	32 01       	movw	r6, r4
    b4ba:	fe 01       	movw	r30, r28
    b4bc:	31 96       	adiw	r30, 0x01	; 1
    b4be:	88 e0       	ldi	r24, 0x08	; 8
    b4c0:	df 01       	movw	r26, r30
    b4c2:	1d 92       	st	X+, r1
    b4c4:	8a 95       	dec	r24
    b4c6:	e9 f7       	brne	.-6      	; 0xb4c2 <__divdi3+0xe84>
    b4c8:	c9 82       	std	Y+1, r12	; 0x01
    b4ca:	da 82       	std	Y+2, r13	; 0x02
    b4cc:	eb 82       	std	Y+3, r14	; 0x03
    b4ce:	fc 82       	std	Y+4, r15	; 0x04
    b4d0:	4d 82       	std	Y+5, r4	; 0x05
    b4d2:	5e 82       	std	Y+6, r5	; 0x06
    b4d4:	6f 82       	std	Y+7, r6	; 0x07
    b4d6:	78 86       	std	Y+8, r7	; 0x08
    b4d8:	2c 2d       	mov	r18, r12
    b4da:	3a 81       	ldd	r19, Y+2	; 0x02
    b4dc:	4b 81       	ldd	r20, Y+3	; 0x03
    b4de:	5c 81       	ldd	r21, Y+4	; 0x04
    b4e0:	64 2d       	mov	r22, r4
    b4e2:	7e 81       	ldd	r23, Y+6	; 0x06
    b4e4:	8f 81       	ldd	r24, Y+7	; 0x07
    b4e6:	98 85       	ldd	r25, Y+8	; 0x08
    b4e8:	25 96       	adiw	r28, 0x05	; 5
    b4ea:	ec ac       	sts	0xac, r30
    b4ec:	fd ac       	sts	0xad, r31
    b4ee:	0e ad       	sts	0x6e, r16
    b4f0:	1f ad       	sts	0x6f, r17
    b4f2:	25 97       	sbiw	r28, 0x05	; 5
    b4f4:	e1 14       	cp	r14, r1
    b4f6:	f1 04       	cpc	r15, r1
    b4f8:	01 05       	cpc	r16, r1
    b4fa:	11 05       	cpc	r17, r1
    b4fc:	09 f4       	brne	.+2      	; 0xb500 <__divdi3+0xec2>
    b4fe:	56 c0       	rjmp	.+172    	; 0xb5ac <__divdi3+0xf6e>
    b500:	21 95       	neg	r18
    b502:	e1 e0       	ldi	r30, 0x01	; 1
    b504:	12 16       	cp	r1, r18
    b506:	08 f0       	brcs	.+2      	; 0xb50a <__divdi3+0xecc>
    b508:	e0 e0       	ldi	r30, 0x00	; 0
    b50a:	31 95       	neg	r19
    b50c:	f1 e0       	ldi	r31, 0x01	; 1
    b50e:	13 16       	cp	r1, r19
    b510:	08 f0       	brcs	.+2      	; 0xb514 <__divdi3+0xed6>
    b512:	f0 e0       	ldi	r31, 0x00	; 0
    b514:	03 2f       	mov	r16, r19
    b516:	0e 1b       	sub	r16, r30
    b518:	e1 e0       	ldi	r30, 0x01	; 1
    b51a:	30 17       	cp	r19, r16
    b51c:	08 f0       	brcs	.+2      	; 0xb520 <__divdi3+0xee2>
    b51e:	e0 e0       	ldi	r30, 0x00	; 0
    b520:	fe 2b       	or	r31, r30
    b522:	41 95       	neg	r20
    b524:	e1 e0       	ldi	r30, 0x01	; 1
    b526:	14 16       	cp	r1, r20
    b528:	08 f0       	brcs	.+2      	; 0xb52c <__divdi3+0xeee>
    b52a:	e0 e0       	ldi	r30, 0x00	; 0
    b52c:	14 2f       	mov	r17, r20
    b52e:	1f 1b       	sub	r17, r31
    b530:	31 e0       	ldi	r19, 0x01	; 1
    b532:	41 17       	cp	r20, r17
    b534:	08 f0       	brcs	.+2      	; 0xb538 <__divdi3+0xefa>
    b536:	30 e0       	ldi	r19, 0x00	; 0
    b538:	e3 2b       	or	r30, r19
    b53a:	51 95       	neg	r21
    b53c:	f1 e0       	ldi	r31, 0x01	; 1
    b53e:	15 16       	cp	r1, r21
    b540:	08 f0       	brcs	.+2      	; 0xb544 <__divdi3+0xf06>
    b542:	f0 e0       	ldi	r31, 0x00	; 0
    b544:	b5 2f       	mov	r27, r21
    b546:	be 1b       	sub	r27, r30
    b548:	31 e0       	ldi	r19, 0x01	; 1
    b54a:	5b 17       	cp	r21, r27
    b54c:	08 f0       	brcs	.+2      	; 0xb550 <__divdi3+0xf12>
    b54e:	30 e0       	ldi	r19, 0x00	; 0
    b550:	f3 2b       	or	r31, r19
    b552:	61 95       	neg	r22
    b554:	e1 e0       	ldi	r30, 0x01	; 1
    b556:	16 16       	cp	r1, r22
    b558:	08 f0       	brcs	.+2      	; 0xb55c <__divdi3+0xf1e>
    b55a:	e0 e0       	ldi	r30, 0x00	; 0
    b55c:	46 2e       	mov	r4, r22
    b55e:	4f 1a       	sub	r4, r31
    b560:	31 e0       	ldi	r19, 0x01	; 1
    b562:	64 15       	cp	r22, r4
    b564:	08 f0       	brcs	.+2      	; 0xb568 <__divdi3+0xf2a>
    b566:	30 e0       	ldi	r19, 0x00	; 0
    b568:	e3 2b       	or	r30, r19
    b56a:	71 95       	neg	r23
    b56c:	f1 e0       	ldi	r31, 0x01	; 1
    b56e:	17 16       	cp	r1, r23
    b570:	08 f0       	brcs	.+2      	; 0xb574 <__divdi3+0xf36>
    b572:	f0 e0       	ldi	r31, 0x00	; 0
    b574:	a7 2f       	mov	r26, r23
    b576:	ae 1b       	sub	r26, r30
    b578:	31 e0       	ldi	r19, 0x01	; 1
    b57a:	7a 17       	cp	r23, r26
    b57c:	08 f0       	brcs	.+2      	; 0xb580 <__divdi3+0xf42>
    b57e:	30 e0       	ldi	r19, 0x00	; 0
    b580:	f3 2b       	or	r31, r19
    b582:	81 95       	neg	r24
    b584:	e1 e0       	ldi	r30, 0x01	; 1
    b586:	18 16       	cp	r1, r24
    b588:	08 f0       	brcs	.+2      	; 0xb58c <__divdi3+0xf4e>
    b58a:	e0 e0       	ldi	r30, 0x00	; 0
    b58c:	f8 2e       	mov	r15, r24
    b58e:	ff 1a       	sub	r15, r31
    b590:	ff 2d       	mov	r31, r15
    b592:	31 e0       	ldi	r19, 0x01	; 1
    b594:	8f 15       	cp	r24, r15
    b596:	08 f0       	brcs	.+2      	; 0xb59a <__divdi3+0xf5c>
    b598:	30 e0       	ldi	r19, 0x00	; 0
    b59a:	e3 2b       	or	r30, r19
    b59c:	91 95       	neg	r25
    b59e:	30 2f       	mov	r19, r16
    b5a0:	41 2f       	mov	r20, r17
    b5a2:	5b 2f       	mov	r21, r27
    b5a4:	64 2d       	mov	r22, r4
    b5a6:	7a 2f       	mov	r23, r26
    b5a8:	8f 2f       	mov	r24, r31
    b5aa:	9e 1b       	sub	r25, r30
    b5ac:	c8 5b       	subi	r28, 0xB8	; 184
    b5ae:	df 4f       	sbci	r29, 0xFF	; 255
    b5b0:	e1 e1       	ldi	r30, 0x11	; 17
    b5b2:	0c 94 ec 5c 	jmp	0xb9d8	; 0xb9d8 <__epilogue_restores__+0x2>

0000b5b6 <__cmpsf2>:
    b5b6:	97 d0       	rcall	.+302    	; 0xb6e6 <__fp_cmp>
    b5b8:	08 f4       	brcc	.+2      	; 0xb5bc <__cmpsf2+0x6>
    b5ba:	81 e0       	ldi	r24, 0x01	; 1
    b5bc:	08 95       	ret

0000b5be <__divsf3>:
    b5be:	0c d0       	rcall	.+24     	; 0xb5d8 <__divsf3x>
    b5c0:	cd c0       	rjmp	.+410    	; 0xb75c <__fp_round>
    b5c2:	c5 d0       	rcall	.+394    	; 0xb74e <__fp_pscB>
    b5c4:	40 f0       	brcs	.+16     	; 0xb5d6 <__divsf3+0x18>
    b5c6:	bc d0       	rcall	.+376    	; 0xb740 <__fp_pscA>
    b5c8:	30 f0       	brcs	.+12     	; 0xb5d6 <__divsf3+0x18>
    b5ca:	21 f4       	brne	.+8      	; 0xb5d4 <__divsf3+0x16>
    b5cc:	5f 3f       	cpi	r21, 0xFF	; 255
    b5ce:	19 f0       	breq	.+6      	; 0xb5d6 <__divsf3+0x18>
    b5d0:	ae c0       	rjmp	.+348    	; 0xb72e <__fp_inf>
    b5d2:	51 11       	cpse	r21, r1
    b5d4:	f7 c0       	rjmp	.+494    	; 0xb7c4 <__fp_szero>
    b5d6:	b1 c0       	rjmp	.+354    	; 0xb73a <__fp_nan>

0000b5d8 <__divsf3x>:
    b5d8:	d2 d0       	rcall	.+420    	; 0xb77e <__fp_split3>
    b5da:	98 f3       	brcs	.-26     	; 0xb5c2 <__divsf3+0x4>

0000b5dc <__divsf3_pse>:
    b5dc:	99 23       	and	r25, r25
    b5de:	c9 f3       	breq	.-14     	; 0xb5d2 <__divsf3+0x14>
    b5e0:	55 23       	and	r21, r21
    b5e2:	b1 f3       	breq	.-20     	; 0xb5d0 <__divsf3+0x12>
    b5e4:	95 1b       	sub	r25, r21
    b5e6:	55 0b       	sbc	r21, r21
    b5e8:	bb 27       	eor	r27, r27
    b5ea:	aa 27       	eor	r26, r26
    b5ec:	62 17       	cp	r22, r18
    b5ee:	73 07       	cpc	r23, r19
    b5f0:	84 07       	cpc	r24, r20
    b5f2:	38 f0       	brcs	.+14     	; 0xb602 <__divsf3_pse+0x26>
    b5f4:	9f 5f       	subi	r25, 0xFF	; 255
    b5f6:	5f 4f       	sbci	r21, 0xFF	; 255
    b5f8:	22 0f       	add	r18, r18
    b5fa:	33 1f       	adc	r19, r19
    b5fc:	44 1f       	adc	r20, r20
    b5fe:	aa 1f       	adc	r26, r26
    b600:	a9 f3       	breq	.-22     	; 0xb5ec <__divsf3_pse+0x10>
    b602:	33 d0       	rcall	.+102    	; 0xb66a <__divsf3_pse+0x8e>
    b604:	0e 2e       	mov	r0, r30
    b606:	3a f0       	brmi	.+14     	; 0xb616 <__divsf3_pse+0x3a>
    b608:	e0 e8       	ldi	r30, 0x80	; 128
    b60a:	30 d0       	rcall	.+96     	; 0xb66c <__divsf3_pse+0x90>
    b60c:	91 50       	subi	r25, 0x01	; 1
    b60e:	50 40       	sbci	r21, 0x00	; 0
    b610:	e6 95       	lsr	r30
    b612:	00 1c       	adc	r0, r0
    b614:	ca f7       	brpl	.-14     	; 0xb608 <__divsf3_pse+0x2c>
    b616:	29 d0       	rcall	.+82     	; 0xb66a <__divsf3_pse+0x8e>
    b618:	fe 2f       	mov	r31, r30
    b61a:	27 d0       	rcall	.+78     	; 0xb66a <__divsf3_pse+0x8e>
    b61c:	66 0f       	add	r22, r22
    b61e:	77 1f       	adc	r23, r23
    b620:	88 1f       	adc	r24, r24
    b622:	bb 1f       	adc	r27, r27
    b624:	26 17       	cp	r18, r22
    b626:	37 07       	cpc	r19, r23
    b628:	48 07       	cpc	r20, r24
    b62a:	ab 07       	cpc	r26, r27
    b62c:	b0 e8       	ldi	r27, 0x80	; 128
    b62e:	09 f0       	breq	.+2      	; 0xb632 <__divsf3_pse+0x56>
    b630:	bb 0b       	sbc	r27, r27
    b632:	80 2d       	mov	r24, r0
    b634:	bf 01       	movw	r22, r30
    b636:	ff 27       	eor	r31, r31
    b638:	93 58       	subi	r25, 0x83	; 131
    b63a:	5f 4f       	sbci	r21, 0xFF	; 255
    b63c:	2a f0       	brmi	.+10     	; 0xb648 <__divsf3_pse+0x6c>
    b63e:	9e 3f       	cpi	r25, 0xFE	; 254
    b640:	51 05       	cpc	r21, r1
    b642:	68 f0       	brcs	.+26     	; 0xb65e <__divsf3_pse+0x82>
    b644:	74 c0       	rjmp	.+232    	; 0xb72e <__fp_inf>
    b646:	be c0       	rjmp	.+380    	; 0xb7c4 <__fp_szero>
    b648:	5f 3f       	cpi	r21, 0xFF	; 255
    b64a:	ec f3       	brlt	.-6      	; 0xb646 <__divsf3_pse+0x6a>
    b64c:	98 3e       	cpi	r25, 0xE8	; 232
    b64e:	dc f3       	brlt	.-10     	; 0xb646 <__divsf3_pse+0x6a>
    b650:	86 95       	lsr	r24
    b652:	77 95       	ror	r23
    b654:	67 95       	ror	r22
    b656:	b7 95       	ror	r27
    b658:	f7 95       	ror	r31
    b65a:	9f 5f       	subi	r25, 0xFF	; 255
    b65c:	c9 f7       	brne	.-14     	; 0xb650 <__divsf3_pse+0x74>
    b65e:	88 0f       	add	r24, r24
    b660:	91 1d       	adc	r25, r1
    b662:	96 95       	lsr	r25
    b664:	87 95       	ror	r24
    b666:	97 f9       	bld	r25, 7
    b668:	08 95       	ret
    b66a:	e1 e0       	ldi	r30, 0x01	; 1
    b66c:	66 0f       	add	r22, r22
    b66e:	77 1f       	adc	r23, r23
    b670:	88 1f       	adc	r24, r24
    b672:	bb 1f       	adc	r27, r27
    b674:	62 17       	cp	r22, r18
    b676:	73 07       	cpc	r23, r19
    b678:	84 07       	cpc	r24, r20
    b67a:	ba 07       	cpc	r27, r26
    b67c:	20 f0       	brcs	.+8      	; 0xb686 <__divsf3_pse+0xaa>
    b67e:	62 1b       	sub	r22, r18
    b680:	73 0b       	sbc	r23, r19
    b682:	84 0b       	sbc	r24, r20
    b684:	ba 0b       	sbc	r27, r26
    b686:	ee 1f       	adc	r30, r30
    b688:	88 f7       	brcc	.-30     	; 0xb66c <__divsf3_pse+0x90>
    b68a:	e0 95       	com	r30
    b68c:	08 95       	ret

0000b68e <__fixunssfsi>:
    b68e:	7f d0       	rcall	.+254    	; 0xb78e <__fp_splitA>
    b690:	88 f0       	brcs	.+34     	; 0xb6b4 <__fixunssfsi+0x26>
    b692:	9f 57       	subi	r25, 0x7F	; 127
    b694:	90 f0       	brcs	.+36     	; 0xb6ba <__fixunssfsi+0x2c>
    b696:	b9 2f       	mov	r27, r25
    b698:	99 27       	eor	r25, r25
    b69a:	b7 51       	subi	r27, 0x17	; 23
    b69c:	a0 f0       	brcs	.+40     	; 0xb6c6 <__fixunssfsi+0x38>
    b69e:	d1 f0       	breq	.+52     	; 0xb6d4 <__fixunssfsi+0x46>
    b6a0:	66 0f       	add	r22, r22
    b6a2:	77 1f       	adc	r23, r23
    b6a4:	88 1f       	adc	r24, r24
    b6a6:	99 1f       	adc	r25, r25
    b6a8:	1a f0       	brmi	.+6      	; 0xb6b0 <__fixunssfsi+0x22>
    b6aa:	ba 95       	dec	r27
    b6ac:	c9 f7       	brne	.-14     	; 0xb6a0 <__fixunssfsi+0x12>
    b6ae:	12 c0       	rjmp	.+36     	; 0xb6d4 <__fixunssfsi+0x46>
    b6b0:	b1 30       	cpi	r27, 0x01	; 1
    b6b2:	81 f0       	breq	.+32     	; 0xb6d4 <__fixunssfsi+0x46>
    b6b4:	86 d0       	rcall	.+268    	; 0xb7c2 <__fp_zero>
    b6b6:	b1 e0       	ldi	r27, 0x01	; 1
    b6b8:	08 95       	ret
    b6ba:	83 c0       	rjmp	.+262    	; 0xb7c2 <__fp_zero>
    b6bc:	67 2f       	mov	r22, r23
    b6be:	78 2f       	mov	r23, r24
    b6c0:	88 27       	eor	r24, r24
    b6c2:	b8 5f       	subi	r27, 0xF8	; 248
    b6c4:	39 f0       	breq	.+14     	; 0xb6d4 <__fixunssfsi+0x46>
    b6c6:	b9 3f       	cpi	r27, 0xF9	; 249
    b6c8:	cc f3       	brlt	.-14     	; 0xb6bc <__fixunssfsi+0x2e>
    b6ca:	86 95       	lsr	r24
    b6cc:	77 95       	ror	r23
    b6ce:	67 95       	ror	r22
    b6d0:	b3 95       	inc	r27
    b6d2:	d9 f7       	brne	.-10     	; 0xb6ca <__fixunssfsi+0x3c>
    b6d4:	3e f4       	brtc	.+14     	; 0xb6e4 <__fixunssfsi+0x56>
    b6d6:	90 95       	com	r25
    b6d8:	80 95       	com	r24
    b6da:	70 95       	com	r23
    b6dc:	61 95       	neg	r22
    b6de:	7f 4f       	sbci	r23, 0xFF	; 255
    b6e0:	8f 4f       	sbci	r24, 0xFF	; 255
    b6e2:	9f 4f       	sbci	r25, 0xFF	; 255
    b6e4:	08 95       	ret

0000b6e6 <__fp_cmp>:
    b6e6:	99 0f       	add	r25, r25
    b6e8:	00 08       	sbc	r0, r0
    b6ea:	55 0f       	add	r21, r21
    b6ec:	aa 0b       	sbc	r26, r26
    b6ee:	e0 e8       	ldi	r30, 0x80	; 128
    b6f0:	fe ef       	ldi	r31, 0xFE	; 254
    b6f2:	16 16       	cp	r1, r22
    b6f4:	17 06       	cpc	r1, r23
    b6f6:	e8 07       	cpc	r30, r24
    b6f8:	f9 07       	cpc	r31, r25
    b6fa:	c0 f0       	brcs	.+48     	; 0xb72c <__fp_cmp+0x46>
    b6fc:	12 16       	cp	r1, r18
    b6fe:	13 06       	cpc	r1, r19
    b700:	e4 07       	cpc	r30, r20
    b702:	f5 07       	cpc	r31, r21
    b704:	98 f0       	brcs	.+38     	; 0xb72c <__fp_cmp+0x46>
    b706:	62 1b       	sub	r22, r18
    b708:	73 0b       	sbc	r23, r19
    b70a:	84 0b       	sbc	r24, r20
    b70c:	95 0b       	sbc	r25, r21
    b70e:	39 f4       	brne	.+14     	; 0xb71e <__fp_cmp+0x38>
    b710:	0a 26       	eor	r0, r26
    b712:	61 f0       	breq	.+24     	; 0xb72c <__fp_cmp+0x46>
    b714:	23 2b       	or	r18, r19
    b716:	24 2b       	or	r18, r20
    b718:	25 2b       	or	r18, r21
    b71a:	21 f4       	brne	.+8      	; 0xb724 <__fp_cmp+0x3e>
    b71c:	08 95       	ret
    b71e:	0a 26       	eor	r0, r26
    b720:	09 f4       	brne	.+2      	; 0xb724 <__fp_cmp+0x3e>
    b722:	a1 40       	sbci	r26, 0x01	; 1
    b724:	a6 95       	lsr	r26
    b726:	8f ef       	ldi	r24, 0xFF	; 255
    b728:	81 1d       	adc	r24, r1
    b72a:	81 1d       	adc	r24, r1
    b72c:	08 95       	ret

0000b72e <__fp_inf>:
    b72e:	97 f9       	bld	r25, 7
    b730:	9f 67       	ori	r25, 0x7F	; 127
    b732:	80 e8       	ldi	r24, 0x80	; 128
    b734:	70 e0       	ldi	r23, 0x00	; 0
    b736:	60 e0       	ldi	r22, 0x00	; 0
    b738:	08 95       	ret

0000b73a <__fp_nan>:
    b73a:	9f ef       	ldi	r25, 0xFF	; 255
    b73c:	80 ec       	ldi	r24, 0xC0	; 192
    b73e:	08 95       	ret

0000b740 <__fp_pscA>:
    b740:	00 24       	eor	r0, r0
    b742:	0a 94       	dec	r0
    b744:	16 16       	cp	r1, r22
    b746:	17 06       	cpc	r1, r23
    b748:	18 06       	cpc	r1, r24
    b74a:	09 06       	cpc	r0, r25
    b74c:	08 95       	ret

0000b74e <__fp_pscB>:
    b74e:	00 24       	eor	r0, r0
    b750:	0a 94       	dec	r0
    b752:	12 16       	cp	r1, r18
    b754:	13 06       	cpc	r1, r19
    b756:	14 06       	cpc	r1, r20
    b758:	05 06       	cpc	r0, r21
    b75a:	08 95       	ret

0000b75c <__fp_round>:
    b75c:	09 2e       	mov	r0, r25
    b75e:	03 94       	inc	r0
    b760:	00 0c       	add	r0, r0
    b762:	11 f4       	brne	.+4      	; 0xb768 <__fp_round+0xc>
    b764:	88 23       	and	r24, r24
    b766:	52 f0       	brmi	.+20     	; 0xb77c <__fp_round+0x20>
    b768:	bb 0f       	add	r27, r27
    b76a:	40 f4       	brcc	.+16     	; 0xb77c <__fp_round+0x20>
    b76c:	bf 2b       	or	r27, r31
    b76e:	11 f4       	brne	.+4      	; 0xb774 <__fp_round+0x18>
    b770:	60 ff       	sbrs	r22, 0
    b772:	04 c0       	rjmp	.+8      	; 0xb77c <__fp_round+0x20>
    b774:	6f 5f       	subi	r22, 0xFF	; 255
    b776:	7f 4f       	sbci	r23, 0xFF	; 255
    b778:	8f 4f       	sbci	r24, 0xFF	; 255
    b77a:	9f 4f       	sbci	r25, 0xFF	; 255
    b77c:	08 95       	ret

0000b77e <__fp_split3>:
    b77e:	57 fd       	sbrc	r21, 7
    b780:	90 58       	subi	r25, 0x80	; 128
    b782:	44 0f       	add	r20, r20
    b784:	55 1f       	adc	r21, r21
    b786:	59 f0       	breq	.+22     	; 0xb79e <__fp_splitA+0x10>
    b788:	5f 3f       	cpi	r21, 0xFF	; 255
    b78a:	71 f0       	breq	.+28     	; 0xb7a8 <__fp_splitA+0x1a>
    b78c:	47 95       	ror	r20

0000b78e <__fp_splitA>:
    b78e:	88 0f       	add	r24, r24
    b790:	97 fb       	bst	r25, 7
    b792:	99 1f       	adc	r25, r25
    b794:	61 f0       	breq	.+24     	; 0xb7ae <__fp_splitA+0x20>
    b796:	9f 3f       	cpi	r25, 0xFF	; 255
    b798:	79 f0       	breq	.+30     	; 0xb7b8 <__fp_splitA+0x2a>
    b79a:	87 95       	ror	r24
    b79c:	08 95       	ret
    b79e:	12 16       	cp	r1, r18
    b7a0:	13 06       	cpc	r1, r19
    b7a2:	14 06       	cpc	r1, r20
    b7a4:	55 1f       	adc	r21, r21
    b7a6:	f2 cf       	rjmp	.-28     	; 0xb78c <__fp_split3+0xe>
    b7a8:	46 95       	lsr	r20
    b7aa:	f1 df       	rcall	.-30     	; 0xb78e <__fp_splitA>
    b7ac:	08 c0       	rjmp	.+16     	; 0xb7be <__fp_splitA+0x30>
    b7ae:	16 16       	cp	r1, r22
    b7b0:	17 06       	cpc	r1, r23
    b7b2:	18 06       	cpc	r1, r24
    b7b4:	99 1f       	adc	r25, r25
    b7b6:	f1 cf       	rjmp	.-30     	; 0xb79a <__fp_splitA+0xc>
    b7b8:	86 95       	lsr	r24
    b7ba:	71 05       	cpc	r23, r1
    b7bc:	61 05       	cpc	r22, r1
    b7be:	08 94       	sec
    b7c0:	08 95       	ret

0000b7c2 <__fp_zero>:
    b7c2:	e8 94       	clt

0000b7c4 <__fp_szero>:
    b7c4:	bb 27       	eor	r27, r27
    b7c6:	66 27       	eor	r22, r22
    b7c8:	77 27       	eor	r23, r23
    b7ca:	cb 01       	movw	r24, r22
    b7cc:	97 f9       	bld	r25, 7
    b7ce:	08 95       	ret

0000b7d0 <__gesf2>:
    b7d0:	8a df       	rcall	.-236    	; 0xb6e6 <__fp_cmp>
    b7d2:	08 f4       	brcc	.+2      	; 0xb7d6 <__gesf2+0x6>
    b7d4:	8f ef       	ldi	r24, 0xFF	; 255
    b7d6:	08 95       	ret

0000b7d8 <__mulsf3>:
    b7d8:	0b d0       	rcall	.+22     	; 0xb7f0 <__mulsf3x>
    b7da:	c0 cf       	rjmp	.-128    	; 0xb75c <__fp_round>
    b7dc:	b1 df       	rcall	.-158    	; 0xb740 <__fp_pscA>
    b7de:	28 f0       	brcs	.+10     	; 0xb7ea <__mulsf3+0x12>
    b7e0:	b6 df       	rcall	.-148    	; 0xb74e <__fp_pscB>
    b7e2:	18 f0       	brcs	.+6      	; 0xb7ea <__mulsf3+0x12>
    b7e4:	95 23       	and	r25, r21
    b7e6:	09 f0       	breq	.+2      	; 0xb7ea <__mulsf3+0x12>
    b7e8:	a2 cf       	rjmp	.-188    	; 0xb72e <__fp_inf>
    b7ea:	a7 cf       	rjmp	.-178    	; 0xb73a <__fp_nan>
    b7ec:	11 24       	eor	r1, r1
    b7ee:	ea cf       	rjmp	.-44     	; 0xb7c4 <__fp_szero>

0000b7f0 <__mulsf3x>:
    b7f0:	c6 df       	rcall	.-116    	; 0xb77e <__fp_split3>
    b7f2:	a0 f3       	brcs	.-24     	; 0xb7dc <__mulsf3+0x4>

0000b7f4 <__mulsf3_pse>:
    b7f4:	95 9f       	mul	r25, r21
    b7f6:	d1 f3       	breq	.-12     	; 0xb7ec <__mulsf3+0x14>
    b7f8:	95 0f       	add	r25, r21
    b7fa:	50 e0       	ldi	r21, 0x00	; 0
    b7fc:	55 1f       	adc	r21, r21
    b7fe:	62 9f       	mul	r22, r18
    b800:	f0 01       	movw	r30, r0
    b802:	72 9f       	mul	r23, r18
    b804:	bb 27       	eor	r27, r27
    b806:	f0 0d       	add	r31, r0
    b808:	b1 1d       	adc	r27, r1
    b80a:	63 9f       	mul	r22, r19
    b80c:	aa 27       	eor	r26, r26
    b80e:	f0 0d       	add	r31, r0
    b810:	b1 1d       	adc	r27, r1
    b812:	aa 1f       	adc	r26, r26
    b814:	64 9f       	mul	r22, r20
    b816:	66 27       	eor	r22, r22
    b818:	b0 0d       	add	r27, r0
    b81a:	a1 1d       	adc	r26, r1
    b81c:	66 1f       	adc	r22, r22
    b81e:	82 9f       	mul	r24, r18
    b820:	22 27       	eor	r18, r18
    b822:	b0 0d       	add	r27, r0
    b824:	a1 1d       	adc	r26, r1
    b826:	62 1f       	adc	r22, r18
    b828:	73 9f       	mul	r23, r19
    b82a:	b0 0d       	add	r27, r0
    b82c:	a1 1d       	adc	r26, r1
    b82e:	62 1f       	adc	r22, r18
    b830:	83 9f       	mul	r24, r19
    b832:	a0 0d       	add	r26, r0
    b834:	61 1d       	adc	r22, r1
    b836:	22 1f       	adc	r18, r18
    b838:	74 9f       	mul	r23, r20
    b83a:	33 27       	eor	r19, r19
    b83c:	a0 0d       	add	r26, r0
    b83e:	61 1d       	adc	r22, r1
    b840:	23 1f       	adc	r18, r19
    b842:	84 9f       	mul	r24, r20
    b844:	60 0d       	add	r22, r0
    b846:	21 1d       	adc	r18, r1
    b848:	82 2f       	mov	r24, r18
    b84a:	76 2f       	mov	r23, r22
    b84c:	6a 2f       	mov	r22, r26
    b84e:	11 24       	eor	r1, r1
    b850:	9f 57       	subi	r25, 0x7F	; 127
    b852:	50 40       	sbci	r21, 0x00	; 0
    b854:	8a f0       	brmi	.+34     	; 0xb878 <__mulsf3_pse+0x84>
    b856:	e1 f0       	breq	.+56     	; 0xb890 <__mulsf3_pse+0x9c>
    b858:	88 23       	and	r24, r24
    b85a:	4a f0       	brmi	.+18     	; 0xb86e <__mulsf3_pse+0x7a>
    b85c:	ee 0f       	add	r30, r30
    b85e:	ff 1f       	adc	r31, r31
    b860:	bb 1f       	adc	r27, r27
    b862:	66 1f       	adc	r22, r22
    b864:	77 1f       	adc	r23, r23
    b866:	88 1f       	adc	r24, r24
    b868:	91 50       	subi	r25, 0x01	; 1
    b86a:	50 40       	sbci	r21, 0x00	; 0
    b86c:	a9 f7       	brne	.-22     	; 0xb858 <__mulsf3_pse+0x64>
    b86e:	9e 3f       	cpi	r25, 0xFE	; 254
    b870:	51 05       	cpc	r21, r1
    b872:	70 f0       	brcs	.+28     	; 0xb890 <__mulsf3_pse+0x9c>
    b874:	5c cf       	rjmp	.-328    	; 0xb72e <__fp_inf>
    b876:	a6 cf       	rjmp	.-180    	; 0xb7c4 <__fp_szero>
    b878:	5f 3f       	cpi	r21, 0xFF	; 255
    b87a:	ec f3       	brlt	.-6      	; 0xb876 <__mulsf3_pse+0x82>
    b87c:	98 3e       	cpi	r25, 0xE8	; 232
    b87e:	dc f3       	brlt	.-10     	; 0xb876 <__mulsf3_pse+0x82>
    b880:	86 95       	lsr	r24
    b882:	77 95       	ror	r23
    b884:	67 95       	ror	r22
    b886:	b7 95       	ror	r27
    b888:	f7 95       	ror	r31
    b88a:	e7 95       	ror	r30
    b88c:	9f 5f       	subi	r25, 0xFF	; 255
    b88e:	c1 f7       	brne	.-16     	; 0xb880 <__mulsf3_pse+0x8c>
    b890:	fe 2b       	or	r31, r30
    b892:	88 0f       	add	r24, r24
    b894:	91 1d       	adc	r25, r1
    b896:	96 95       	lsr	r25
    b898:	87 95       	ror	r24
    b89a:	97 f9       	bld	r25, 7
    b89c:	08 95       	ret

0000b89e <__mulsi3>:
    b89e:	62 9f       	mul	r22, r18
    b8a0:	d0 01       	movw	r26, r0
    b8a2:	73 9f       	mul	r23, r19
    b8a4:	f0 01       	movw	r30, r0
    b8a6:	82 9f       	mul	r24, r18
    b8a8:	e0 0d       	add	r30, r0
    b8aa:	f1 1d       	adc	r31, r1
    b8ac:	64 9f       	mul	r22, r20
    b8ae:	e0 0d       	add	r30, r0
    b8b0:	f1 1d       	adc	r31, r1
    b8b2:	92 9f       	mul	r25, r18
    b8b4:	f0 0d       	add	r31, r0
    b8b6:	83 9f       	mul	r24, r19
    b8b8:	f0 0d       	add	r31, r0
    b8ba:	74 9f       	mul	r23, r20
    b8bc:	f0 0d       	add	r31, r0
    b8be:	65 9f       	mul	r22, r21
    b8c0:	f0 0d       	add	r31, r0
    b8c2:	99 27       	eor	r25, r25
    b8c4:	72 9f       	mul	r23, r18
    b8c6:	b0 0d       	add	r27, r0
    b8c8:	e1 1d       	adc	r30, r1
    b8ca:	f9 1f       	adc	r31, r25
    b8cc:	63 9f       	mul	r22, r19
    b8ce:	b0 0d       	add	r27, r0
    b8d0:	e1 1d       	adc	r30, r1
    b8d2:	f9 1f       	adc	r31, r25
    b8d4:	bd 01       	movw	r22, r26
    b8d6:	cf 01       	movw	r24, r30
    b8d8:	11 24       	eor	r1, r1
    b8da:	08 95       	ret

0000b8dc <__udivmodhi4>:
    b8dc:	aa 1b       	sub	r26, r26
    b8de:	bb 1b       	sub	r27, r27
    b8e0:	51 e1       	ldi	r21, 0x11	; 17
    b8e2:	07 c0       	rjmp	.+14     	; 0xb8f2 <__udivmodhi4_ep>

0000b8e4 <__udivmodhi4_loop>:
    b8e4:	aa 1f       	adc	r26, r26
    b8e6:	bb 1f       	adc	r27, r27
    b8e8:	a6 17       	cp	r26, r22
    b8ea:	b7 07       	cpc	r27, r23
    b8ec:	10 f0       	brcs	.+4      	; 0xb8f2 <__udivmodhi4_ep>
    b8ee:	a6 1b       	sub	r26, r22
    b8f0:	b7 0b       	sbc	r27, r23

0000b8f2 <__udivmodhi4_ep>:
    b8f2:	88 1f       	adc	r24, r24
    b8f4:	99 1f       	adc	r25, r25
    b8f6:	5a 95       	dec	r21
    b8f8:	a9 f7       	brne	.-22     	; 0xb8e4 <__udivmodhi4_loop>
    b8fa:	80 95       	com	r24
    b8fc:	90 95       	com	r25
    b8fe:	bc 01       	movw	r22, r24
    b900:	cd 01       	movw	r24, r26
    b902:	08 95       	ret

0000b904 <__divmodhi4>:
    b904:	97 fb       	bst	r25, 7
    b906:	09 2e       	mov	r0, r25
    b908:	07 26       	eor	r0, r23
    b90a:	0a d0       	rcall	.+20     	; 0xb920 <__divmodhi4_neg1>
    b90c:	77 fd       	sbrc	r23, 7
    b90e:	04 d0       	rcall	.+8      	; 0xb918 <__divmodhi4_neg2>
    b910:	e5 df       	rcall	.-54     	; 0xb8dc <__udivmodhi4>
    b912:	06 d0       	rcall	.+12     	; 0xb920 <__divmodhi4_neg1>
    b914:	00 20       	and	r0, r0
    b916:	1a f4       	brpl	.+6      	; 0xb91e <__divmodhi4_exit>

0000b918 <__divmodhi4_neg2>:
    b918:	70 95       	com	r23
    b91a:	61 95       	neg	r22
    b91c:	7f 4f       	sbci	r23, 0xFF	; 255

0000b91e <__divmodhi4_exit>:
    b91e:	08 95       	ret

0000b920 <__divmodhi4_neg1>:
    b920:	f6 f7       	brtc	.-4      	; 0xb91e <__divmodhi4_exit>
    b922:	90 95       	com	r25
    b924:	81 95       	neg	r24
    b926:	9f 4f       	sbci	r25, 0xFF	; 255
    b928:	08 95       	ret

0000b92a <__udivmodsi4>:
    b92a:	a1 e2       	ldi	r26, 0x21	; 33
    b92c:	1a 2e       	mov	r1, r26
    b92e:	aa 1b       	sub	r26, r26
    b930:	bb 1b       	sub	r27, r27
    b932:	fd 01       	movw	r30, r26
    b934:	0d c0       	rjmp	.+26     	; 0xb950 <__udivmodsi4_ep>

0000b936 <__udivmodsi4_loop>:
    b936:	aa 1f       	adc	r26, r26
    b938:	bb 1f       	adc	r27, r27
    b93a:	ee 1f       	adc	r30, r30
    b93c:	ff 1f       	adc	r31, r31
    b93e:	a2 17       	cp	r26, r18
    b940:	b3 07       	cpc	r27, r19
    b942:	e4 07       	cpc	r30, r20
    b944:	f5 07       	cpc	r31, r21
    b946:	20 f0       	brcs	.+8      	; 0xb950 <__udivmodsi4_ep>
    b948:	a2 1b       	sub	r26, r18
    b94a:	b3 0b       	sbc	r27, r19
    b94c:	e4 0b       	sbc	r30, r20
    b94e:	f5 0b       	sbc	r31, r21

0000b950 <__udivmodsi4_ep>:
    b950:	66 1f       	adc	r22, r22
    b952:	77 1f       	adc	r23, r23
    b954:	88 1f       	adc	r24, r24
    b956:	99 1f       	adc	r25, r25
    b958:	1a 94       	dec	r1
    b95a:	69 f7       	brne	.-38     	; 0xb936 <__udivmodsi4_loop>
    b95c:	60 95       	com	r22
    b95e:	70 95       	com	r23
    b960:	80 95       	com	r24
    b962:	90 95       	com	r25
    b964:	9b 01       	movw	r18, r22
    b966:	ac 01       	movw	r20, r24
    b968:	bd 01       	movw	r22, r26
    b96a:	cf 01       	movw	r24, r30
    b96c:	08 95       	ret

0000b96e <__divmodsi4>:
    b96e:	97 fb       	bst	r25, 7
    b970:	09 2e       	mov	r0, r25
    b972:	05 26       	eor	r0, r21
    b974:	0e d0       	rcall	.+28     	; 0xb992 <__divmodsi4_neg1>
    b976:	57 fd       	sbrc	r21, 7
    b978:	04 d0       	rcall	.+8      	; 0xb982 <__divmodsi4_neg2>
    b97a:	d7 df       	rcall	.-82     	; 0xb92a <__udivmodsi4>
    b97c:	0a d0       	rcall	.+20     	; 0xb992 <__divmodsi4_neg1>
    b97e:	00 1c       	adc	r0, r0
    b980:	38 f4       	brcc	.+14     	; 0xb990 <__divmodsi4_exit>

0000b982 <__divmodsi4_neg2>:
    b982:	50 95       	com	r21
    b984:	40 95       	com	r20
    b986:	30 95       	com	r19
    b988:	21 95       	neg	r18
    b98a:	3f 4f       	sbci	r19, 0xFF	; 255
    b98c:	4f 4f       	sbci	r20, 0xFF	; 255
    b98e:	5f 4f       	sbci	r21, 0xFF	; 255

0000b990 <__divmodsi4_exit>:
    b990:	08 95       	ret

0000b992 <__divmodsi4_neg1>:
    b992:	f6 f7       	brtc	.-4      	; 0xb990 <__divmodsi4_exit>
    b994:	90 95       	com	r25
    b996:	80 95       	com	r24
    b998:	70 95       	com	r23
    b99a:	61 95       	neg	r22
    b99c:	7f 4f       	sbci	r23, 0xFF	; 255
    b99e:	8f 4f       	sbci	r24, 0xFF	; 255
    b9a0:	9f 4f       	sbci	r25, 0xFF	; 255
    b9a2:	08 95       	ret

0000b9a4 <__prologue_saves__>:
    b9a4:	2f 92       	push	r2
    b9a6:	3f 92       	push	r3
    b9a8:	4f 92       	push	r4
    b9aa:	5f 92       	push	r5
    b9ac:	6f 92       	push	r6
    b9ae:	7f 92       	push	r7
    b9b0:	8f 92       	push	r8
    b9b2:	9f 92       	push	r9
    b9b4:	af 92       	push	r10
    b9b6:	bf 92       	push	r11
    b9b8:	cf 92       	push	r12
    b9ba:	df 92       	push	r13
    b9bc:	ef 92       	push	r14
    b9be:	ff 92       	push	r15
    b9c0:	0f 93       	push	r16
    b9c2:	1f 93       	push	r17
    b9c4:	cf 93       	push	r28
    b9c6:	df 93       	push	r29
    b9c8:	cd b7       	in	r28, 0x3d	; 61
    b9ca:	de b7       	in	r29, 0x3e	; 62
    b9cc:	ca 1b       	sub	r28, r26
    b9ce:	db 0b       	sbc	r29, r27
    b9d0:	cd bf       	out	0x3d, r28	; 61
    b9d2:	de bf       	out	0x3e, r29	; 62
    b9d4:	19 94       	eijmp

0000b9d6 <__epilogue_restores__>:
    b9d6:	2a 88       	ldd	r2, Y+18	; 0x12
    b9d8:	39 88       	ldd	r3, Y+17	; 0x11
    b9da:	48 88       	ldd	r4, Y+16	; 0x10
    b9dc:	5f 84       	ldd	r5, Y+15	; 0x0f
    b9de:	6e 84       	ldd	r6, Y+14	; 0x0e
    b9e0:	7d 84       	ldd	r7, Y+13	; 0x0d
    b9e2:	8c 84       	ldd	r8, Y+12	; 0x0c
    b9e4:	9b 84       	ldd	r9, Y+11	; 0x0b
    b9e6:	aa 84       	ldd	r10, Y+10	; 0x0a
    b9e8:	b9 84       	ldd	r11, Y+9	; 0x09
    b9ea:	c8 84       	ldd	r12, Y+8	; 0x08
    b9ec:	df 80       	ldd	r13, Y+7	; 0x07
    b9ee:	ee 80       	ldd	r14, Y+6	; 0x06
    b9f0:	fd 80       	ldd	r15, Y+5	; 0x05
    b9f2:	0c 81       	ldd	r16, Y+4	; 0x04
    b9f4:	1b 81       	ldd	r17, Y+3	; 0x03
    b9f6:	aa 81       	ldd	r26, Y+2	; 0x02
    b9f8:	b9 81       	ldd	r27, Y+1	; 0x01
    b9fa:	ce 0f       	add	r28, r30
    b9fc:	d1 1d       	adc	r29, r1
    b9fe:	cd bf       	out	0x3d, r28	; 61
    ba00:	de bf       	out	0x3e, r29	; 62
    ba02:	ed 01       	movw	r28, r26
    ba04:	08 95       	ret

0000ba06 <strcpy_P>:
    ba06:	fb 01       	movw	r30, r22
    ba08:	dc 01       	movw	r26, r24
    ba0a:	05 90       	lpm	r0, Z+
    ba0c:	0d 92       	st	X+, r0
    ba0e:	00 20       	and	r0, r0
    ba10:	e1 f7       	brne	.-8      	; 0xba0a <strcpy_P+0x4>
    ba12:	08 95       	ret

0000ba14 <memmove>:
    ba14:	68 17       	cp	r22, r24
    ba16:	79 07       	cpc	r23, r25
    ba18:	68 f4       	brcc	.+26     	; 0xba34 <memmove+0x20>
    ba1a:	fb 01       	movw	r30, r22
    ba1c:	dc 01       	movw	r26, r24
    ba1e:	e4 0f       	add	r30, r20
    ba20:	f5 1f       	adc	r31, r21
    ba22:	a4 0f       	add	r26, r20
    ba24:	b5 1f       	adc	r27, r21
    ba26:	02 c0       	rjmp	.+4      	; 0xba2c <memmove+0x18>
    ba28:	02 90       	ld	r0, -Z
    ba2a:	0e 92       	st	-X, r0
    ba2c:	41 50       	subi	r20, 0x01	; 1
    ba2e:	50 40       	sbci	r21, 0x00	; 0
    ba30:	d8 f7       	brcc	.-10     	; 0xba28 <memmove+0x14>
    ba32:	08 95       	ret
    ba34:	0c 94 3a 5f 	jmp	0xbe74	; 0xbe74 <memcpy>

0000ba38 <printf>:
    ba38:	cf 93       	push	r28
    ba3a:	df 93       	push	r29
    ba3c:	cd b7       	in	r28, 0x3d	; 61
    ba3e:	de b7       	in	r29, 0x3e	; 62
    ba40:	fe 01       	movw	r30, r28
    ba42:	36 96       	adiw	r30, 0x06	; 6
    ba44:	61 91       	ld	r22, Z+
    ba46:	71 91       	ld	r23, Z+
    ba48:	80 91 c2 50 	lds	r24, 0x50C2
    ba4c:	90 91 c3 50 	lds	r25, 0x50C3
    ba50:	af 01       	movw	r20, r30
    ba52:	0e 94 2e 5d 	call	0xba5c	; 0xba5c <vfprintf>
    ba56:	df 91       	pop	r29
    ba58:	cf 91       	pop	r28
    ba5a:	08 95       	ret

0000ba5c <vfprintf>:
    ba5c:	2f 92       	push	r2
    ba5e:	3f 92       	push	r3
    ba60:	4f 92       	push	r4
    ba62:	5f 92       	push	r5
    ba64:	6f 92       	push	r6
    ba66:	7f 92       	push	r7
    ba68:	8f 92       	push	r8
    ba6a:	9f 92       	push	r9
    ba6c:	af 92       	push	r10
    ba6e:	bf 92       	push	r11
    ba70:	cf 92       	push	r12
    ba72:	df 92       	push	r13
    ba74:	ef 92       	push	r14
    ba76:	ff 92       	push	r15
    ba78:	0f 93       	push	r16
    ba7a:	1f 93       	push	r17
    ba7c:	cf 93       	push	r28
    ba7e:	df 93       	push	r29
    ba80:	cd b7       	in	r28, 0x3d	; 61
    ba82:	de b7       	in	r29, 0x3e	; 62
    ba84:	2d 97       	sbiw	r28, 0x0d	; 13
    ba86:	cd bf       	out	0x3d, r28	; 61
    ba88:	de bf       	out	0x3e, r29	; 62
    ba8a:	3c 01       	movw	r6, r24
    ba8c:	6c 87       	std	Y+12, r22	; 0x0c
    ba8e:	7d 87       	std	Y+13, r23	; 0x0d
    ba90:	5a 01       	movw	r10, r20
    ba92:	fc 01       	movw	r30, r24
    ba94:	16 82       	std	Z+6, r1	; 0x06
    ba96:	17 82       	std	Z+7, r1	; 0x07
    ba98:	83 81       	ldd	r24, Z+3	; 0x03
    ba9a:	81 ff       	sbrs	r24, 1
    ba9c:	c8 c1       	rjmp	.+912    	; 0xbe2e <vfprintf+0x3d2>
    ba9e:	2e 01       	movw	r4, r28
    baa0:	08 94       	sec
    baa2:	41 1c       	adc	r4, r1
    baa4:	51 1c       	adc	r5, r1
    baa6:	f3 01       	movw	r30, r6
    baa8:	93 81       	ldd	r25, Z+3	; 0x03
    baaa:	ec 85       	ldd	r30, Y+12	; 0x0c
    baac:	fd 85       	ldd	r31, Y+13	; 0x0d
    baae:	93 fd       	sbrc	r25, 3
    bab0:	85 91       	lpm	r24, Z+
    bab2:	93 ff       	sbrs	r25, 3
    bab4:	81 91       	ld	r24, Z+
    bab6:	ec 87       	std	Y+12, r30	; 0x0c
    bab8:	fd 87       	std	Y+13, r31	; 0x0d
    baba:	88 23       	and	r24, r24
    babc:	09 f4       	brne	.+2      	; 0xbac0 <vfprintf+0x64>
    babe:	b3 c1       	rjmp	.+870    	; 0xbe26 <vfprintf+0x3ca>
    bac0:	85 32       	cpi	r24, 0x25	; 37
    bac2:	41 f4       	brne	.+16     	; 0xbad4 <vfprintf+0x78>
    bac4:	93 fd       	sbrc	r25, 3
    bac6:	85 91       	lpm	r24, Z+
    bac8:	93 ff       	sbrs	r25, 3
    baca:	81 91       	ld	r24, Z+
    bacc:	ec 87       	std	Y+12, r30	; 0x0c
    bace:	fd 87       	std	Y+13, r31	; 0x0d
    bad0:	85 32       	cpi	r24, 0x25	; 37
    bad2:	29 f4       	brne	.+10     	; 0xbade <vfprintf+0x82>
    bad4:	90 e0       	ldi	r25, 0x00	; 0
    bad6:	b3 01       	movw	r22, r6
    bad8:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    badc:	e4 cf       	rjmp	.-56     	; 0xbaa6 <vfprintf+0x4a>
    bade:	ff 24       	eor	r15, r15
    bae0:	ee 24       	eor	r14, r14
    bae2:	10 e0       	ldi	r17, 0x00	; 0
    bae4:	10 32       	cpi	r17, 0x20	; 32
    bae6:	b0 f4       	brcc	.+44     	; 0xbb14 <vfprintf+0xb8>
    bae8:	8b 32       	cpi	r24, 0x2B	; 43
    baea:	69 f0       	breq	.+26     	; 0xbb06 <vfprintf+0xaa>
    baec:	8c 32       	cpi	r24, 0x2C	; 44
    baee:	28 f4       	brcc	.+10     	; 0xbafa <vfprintf+0x9e>
    baf0:	80 32       	cpi	r24, 0x20	; 32
    baf2:	51 f0       	breq	.+20     	; 0xbb08 <vfprintf+0xac>
    baf4:	83 32       	cpi	r24, 0x23	; 35
    baf6:	71 f4       	brne	.+28     	; 0xbb14 <vfprintf+0xb8>
    baf8:	0b c0       	rjmp	.+22     	; 0xbb10 <vfprintf+0xb4>
    bafa:	8d 32       	cpi	r24, 0x2D	; 45
    bafc:	39 f0       	breq	.+14     	; 0xbb0c <vfprintf+0xb0>
    bafe:	80 33       	cpi	r24, 0x30	; 48
    bb00:	49 f4       	brne	.+18     	; 0xbb14 <vfprintf+0xb8>
    bb02:	11 60       	ori	r17, 0x01	; 1
    bb04:	2c c0       	rjmp	.+88     	; 0xbb5e <vfprintf+0x102>
    bb06:	12 60       	ori	r17, 0x02	; 2
    bb08:	14 60       	ori	r17, 0x04	; 4
    bb0a:	29 c0       	rjmp	.+82     	; 0xbb5e <vfprintf+0x102>
    bb0c:	18 60       	ori	r17, 0x08	; 8
    bb0e:	27 c0       	rjmp	.+78     	; 0xbb5e <vfprintf+0x102>
    bb10:	10 61       	ori	r17, 0x10	; 16
    bb12:	25 c0       	rjmp	.+74     	; 0xbb5e <vfprintf+0x102>
    bb14:	17 fd       	sbrc	r17, 7
    bb16:	2e c0       	rjmp	.+92     	; 0xbb74 <vfprintf+0x118>
    bb18:	28 2f       	mov	r18, r24
    bb1a:	20 53       	subi	r18, 0x30	; 48
    bb1c:	2a 30       	cpi	r18, 0x0A	; 10
    bb1e:	98 f4       	brcc	.+38     	; 0xbb46 <vfprintf+0xea>
    bb20:	16 ff       	sbrs	r17, 6
    bb22:	08 c0       	rjmp	.+16     	; 0xbb34 <vfprintf+0xd8>
    bb24:	8f 2d       	mov	r24, r15
    bb26:	88 0f       	add	r24, r24
    bb28:	f8 2e       	mov	r15, r24
    bb2a:	ff 0c       	add	r15, r15
    bb2c:	ff 0c       	add	r15, r15
    bb2e:	f8 0e       	add	r15, r24
    bb30:	f2 0e       	add	r15, r18
    bb32:	15 c0       	rjmp	.+42     	; 0xbb5e <vfprintf+0x102>
    bb34:	8e 2d       	mov	r24, r14
    bb36:	88 0f       	add	r24, r24
    bb38:	e8 2e       	mov	r14, r24
    bb3a:	ee 0c       	add	r14, r14
    bb3c:	ee 0c       	add	r14, r14
    bb3e:	e8 0e       	add	r14, r24
    bb40:	e2 0e       	add	r14, r18
    bb42:	10 62       	ori	r17, 0x20	; 32
    bb44:	0c c0       	rjmp	.+24     	; 0xbb5e <vfprintf+0x102>
    bb46:	8e 32       	cpi	r24, 0x2E	; 46
    bb48:	21 f4       	brne	.+8      	; 0xbb52 <vfprintf+0xf6>
    bb4a:	16 fd       	sbrc	r17, 6
    bb4c:	6c c1       	rjmp	.+728    	; 0xbe26 <vfprintf+0x3ca>
    bb4e:	10 64       	ori	r17, 0x40	; 64
    bb50:	06 c0       	rjmp	.+12     	; 0xbb5e <vfprintf+0x102>
    bb52:	8c 36       	cpi	r24, 0x6C	; 108
    bb54:	11 f4       	brne	.+4      	; 0xbb5a <vfprintf+0xfe>
    bb56:	10 68       	ori	r17, 0x80	; 128
    bb58:	02 c0       	rjmp	.+4      	; 0xbb5e <vfprintf+0x102>
    bb5a:	88 36       	cpi	r24, 0x68	; 104
    bb5c:	59 f4       	brne	.+22     	; 0xbb74 <vfprintf+0x118>
    bb5e:	ec 85       	ldd	r30, Y+12	; 0x0c
    bb60:	fd 85       	ldd	r31, Y+13	; 0x0d
    bb62:	93 fd       	sbrc	r25, 3
    bb64:	85 91       	lpm	r24, Z+
    bb66:	93 ff       	sbrs	r25, 3
    bb68:	81 91       	ld	r24, Z+
    bb6a:	ec 87       	std	Y+12, r30	; 0x0c
    bb6c:	fd 87       	std	Y+13, r31	; 0x0d
    bb6e:	88 23       	and	r24, r24
    bb70:	09 f0       	breq	.+2      	; 0xbb74 <vfprintf+0x118>
    bb72:	b8 cf       	rjmp	.-144    	; 0xbae4 <vfprintf+0x88>
    bb74:	98 2f       	mov	r25, r24
    bb76:	95 54       	subi	r25, 0x45	; 69
    bb78:	93 30       	cpi	r25, 0x03	; 3
    bb7a:	18 f0       	brcs	.+6      	; 0xbb82 <vfprintf+0x126>
    bb7c:	90 52       	subi	r25, 0x20	; 32
    bb7e:	93 30       	cpi	r25, 0x03	; 3
    bb80:	38 f4       	brcc	.+14     	; 0xbb90 <vfprintf+0x134>
    bb82:	24 e0       	ldi	r18, 0x04	; 4
    bb84:	30 e0       	ldi	r19, 0x00	; 0
    bb86:	a2 0e       	add	r10, r18
    bb88:	b3 1e       	adc	r11, r19
    bb8a:	3f e3       	ldi	r19, 0x3F	; 63
    bb8c:	39 83       	std	Y+1, r19	; 0x01
    bb8e:	0f c0       	rjmp	.+30     	; 0xbbae <vfprintf+0x152>
    bb90:	83 36       	cpi	r24, 0x63	; 99
    bb92:	31 f0       	breq	.+12     	; 0xbba0 <vfprintf+0x144>
    bb94:	83 37       	cpi	r24, 0x73	; 115
    bb96:	81 f0       	breq	.+32     	; 0xbbb8 <vfprintf+0x15c>
    bb98:	83 35       	cpi	r24, 0x53	; 83
    bb9a:	09 f0       	breq	.+2      	; 0xbb9e <vfprintf+0x142>
    bb9c:	5a c0       	rjmp	.+180    	; 0xbc52 <vfprintf+0x1f6>
    bb9e:	22 c0       	rjmp	.+68     	; 0xbbe4 <vfprintf+0x188>
    bba0:	f5 01       	movw	r30, r10
    bba2:	80 81       	ld	r24, Z
    bba4:	89 83       	std	Y+1, r24	; 0x01
    bba6:	22 e0       	ldi	r18, 0x02	; 2
    bba8:	30 e0       	ldi	r19, 0x00	; 0
    bbaa:	a2 0e       	add	r10, r18
    bbac:	b3 1e       	adc	r11, r19
    bbae:	21 e0       	ldi	r18, 0x01	; 1
    bbb0:	c2 2e       	mov	r12, r18
    bbb2:	d1 2c       	mov	r13, r1
    bbb4:	42 01       	movw	r8, r4
    bbb6:	14 c0       	rjmp	.+40     	; 0xbbe0 <vfprintf+0x184>
    bbb8:	92 e0       	ldi	r25, 0x02	; 2
    bbba:	29 2e       	mov	r2, r25
    bbbc:	31 2c       	mov	r3, r1
    bbbe:	2a 0c       	add	r2, r10
    bbc0:	3b 1c       	adc	r3, r11
    bbc2:	f5 01       	movw	r30, r10
    bbc4:	80 80       	ld	r8, Z
    bbc6:	91 80       	ldd	r9, Z+1	; 0x01
    bbc8:	16 ff       	sbrs	r17, 6
    bbca:	03 c0       	rjmp	.+6      	; 0xbbd2 <vfprintf+0x176>
    bbcc:	6f 2d       	mov	r22, r15
    bbce:	70 e0       	ldi	r23, 0x00	; 0
    bbd0:	02 c0       	rjmp	.+4      	; 0xbbd6 <vfprintf+0x17a>
    bbd2:	6f ef       	ldi	r22, 0xFF	; 255
    bbd4:	7f ef       	ldi	r23, 0xFF	; 255
    bbd6:	c4 01       	movw	r24, r8
    bbd8:	0e 94 43 5f 	call	0xbe86	; 0xbe86 <strnlen>
    bbdc:	6c 01       	movw	r12, r24
    bbde:	51 01       	movw	r10, r2
    bbe0:	1f 77       	andi	r17, 0x7F	; 127
    bbe2:	15 c0       	rjmp	.+42     	; 0xbc0e <vfprintf+0x1b2>
    bbe4:	82 e0       	ldi	r24, 0x02	; 2
    bbe6:	28 2e       	mov	r2, r24
    bbe8:	31 2c       	mov	r3, r1
    bbea:	2a 0c       	add	r2, r10
    bbec:	3b 1c       	adc	r3, r11
    bbee:	f5 01       	movw	r30, r10
    bbf0:	80 80       	ld	r8, Z
    bbf2:	91 80       	ldd	r9, Z+1	; 0x01
    bbf4:	16 ff       	sbrs	r17, 6
    bbf6:	03 c0       	rjmp	.+6      	; 0xbbfe <vfprintf+0x1a2>
    bbf8:	6f 2d       	mov	r22, r15
    bbfa:	70 e0       	ldi	r23, 0x00	; 0
    bbfc:	02 c0       	rjmp	.+4      	; 0xbc02 <vfprintf+0x1a6>
    bbfe:	6f ef       	ldi	r22, 0xFF	; 255
    bc00:	7f ef       	ldi	r23, 0xFF	; 255
    bc02:	c4 01       	movw	r24, r8
    bc04:	0e 94 2f 5f 	call	0xbe5e	; 0xbe5e <strnlen_P>
    bc08:	6c 01       	movw	r12, r24
    bc0a:	10 68       	ori	r17, 0x80	; 128
    bc0c:	51 01       	movw	r10, r2
    bc0e:	13 fd       	sbrc	r17, 3
    bc10:	1c c0       	rjmp	.+56     	; 0xbc4a <vfprintf+0x1ee>
    bc12:	06 c0       	rjmp	.+12     	; 0xbc20 <vfprintf+0x1c4>
    bc14:	80 e2       	ldi	r24, 0x20	; 32
    bc16:	90 e0       	ldi	r25, 0x00	; 0
    bc18:	b3 01       	movw	r22, r6
    bc1a:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    bc1e:	ea 94       	dec	r14
    bc20:	8e 2d       	mov	r24, r14
    bc22:	90 e0       	ldi	r25, 0x00	; 0
    bc24:	c8 16       	cp	r12, r24
    bc26:	d9 06       	cpc	r13, r25
    bc28:	a8 f3       	brcs	.-22     	; 0xbc14 <vfprintf+0x1b8>
    bc2a:	0f c0       	rjmp	.+30     	; 0xbc4a <vfprintf+0x1ee>
    bc2c:	f4 01       	movw	r30, r8
    bc2e:	17 fd       	sbrc	r17, 7
    bc30:	85 91       	lpm	r24, Z+
    bc32:	17 ff       	sbrs	r17, 7
    bc34:	81 91       	ld	r24, Z+
    bc36:	4f 01       	movw	r8, r30
    bc38:	90 e0       	ldi	r25, 0x00	; 0
    bc3a:	b3 01       	movw	r22, r6
    bc3c:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    bc40:	e1 10       	cpse	r14, r1
    bc42:	ea 94       	dec	r14
    bc44:	08 94       	sec
    bc46:	c1 08       	sbc	r12, r1
    bc48:	d1 08       	sbc	r13, r1
    bc4a:	c1 14       	cp	r12, r1
    bc4c:	d1 04       	cpc	r13, r1
    bc4e:	71 f7       	brne	.-36     	; 0xbc2c <vfprintf+0x1d0>
    bc50:	e7 c0       	rjmp	.+462    	; 0xbe20 <vfprintf+0x3c4>
    bc52:	84 36       	cpi	r24, 0x64	; 100
    bc54:	11 f0       	breq	.+4      	; 0xbc5a <vfprintf+0x1fe>
    bc56:	89 36       	cpi	r24, 0x69	; 105
    bc58:	51 f5       	brne	.+84     	; 0xbcae <vfprintf+0x252>
    bc5a:	f5 01       	movw	r30, r10
    bc5c:	17 ff       	sbrs	r17, 7
    bc5e:	07 c0       	rjmp	.+14     	; 0xbc6e <vfprintf+0x212>
    bc60:	80 81       	ld	r24, Z
    bc62:	91 81       	ldd	r25, Z+1	; 0x01
    bc64:	a2 81       	ldd	r26, Z+2	; 0x02
    bc66:	b3 81       	ldd	r27, Z+3	; 0x03
    bc68:	24 e0       	ldi	r18, 0x04	; 4
    bc6a:	30 e0       	ldi	r19, 0x00	; 0
    bc6c:	08 c0       	rjmp	.+16     	; 0xbc7e <vfprintf+0x222>
    bc6e:	80 81       	ld	r24, Z
    bc70:	91 81       	ldd	r25, Z+1	; 0x01
    bc72:	aa 27       	eor	r26, r26
    bc74:	97 fd       	sbrc	r25, 7
    bc76:	a0 95       	com	r26
    bc78:	ba 2f       	mov	r27, r26
    bc7a:	22 e0       	ldi	r18, 0x02	; 2
    bc7c:	30 e0       	ldi	r19, 0x00	; 0
    bc7e:	a2 0e       	add	r10, r18
    bc80:	b3 1e       	adc	r11, r19
    bc82:	01 2f       	mov	r16, r17
    bc84:	0f 76       	andi	r16, 0x6F	; 111
    bc86:	b7 ff       	sbrs	r27, 7
    bc88:	08 c0       	rjmp	.+16     	; 0xbc9a <vfprintf+0x23e>
    bc8a:	b0 95       	com	r27
    bc8c:	a0 95       	com	r26
    bc8e:	90 95       	com	r25
    bc90:	81 95       	neg	r24
    bc92:	9f 4f       	sbci	r25, 0xFF	; 255
    bc94:	af 4f       	sbci	r26, 0xFF	; 255
    bc96:	bf 4f       	sbci	r27, 0xFF	; 255
    bc98:	00 68       	ori	r16, 0x80	; 128
    bc9a:	bc 01       	movw	r22, r24
    bc9c:	cd 01       	movw	r24, r26
    bc9e:	a2 01       	movw	r20, r4
    bca0:	2a e0       	ldi	r18, 0x0A	; 10
    bca2:	30 e0       	ldi	r19, 0x00	; 0
    bca4:	0e 94 7a 5f 	call	0xbef4	; 0xbef4 <__ultoa_invert>
    bca8:	d8 2e       	mov	r13, r24
    bcaa:	d4 18       	sub	r13, r4
    bcac:	3f c0       	rjmp	.+126    	; 0xbd2c <vfprintf+0x2d0>
    bcae:	85 37       	cpi	r24, 0x75	; 117
    bcb0:	21 f4       	brne	.+8      	; 0xbcba <vfprintf+0x25e>
    bcb2:	1f 7e       	andi	r17, 0xEF	; 239
    bcb4:	2a e0       	ldi	r18, 0x0A	; 10
    bcb6:	30 e0       	ldi	r19, 0x00	; 0
    bcb8:	20 c0       	rjmp	.+64     	; 0xbcfa <vfprintf+0x29e>
    bcba:	19 7f       	andi	r17, 0xF9	; 249
    bcbc:	8f 36       	cpi	r24, 0x6F	; 111
    bcbe:	a9 f0       	breq	.+42     	; 0xbcea <vfprintf+0x28e>
    bcc0:	80 37       	cpi	r24, 0x70	; 112
    bcc2:	20 f4       	brcc	.+8      	; 0xbccc <vfprintf+0x270>
    bcc4:	88 35       	cpi	r24, 0x58	; 88
    bcc6:	09 f0       	breq	.+2      	; 0xbcca <vfprintf+0x26e>
    bcc8:	ae c0       	rjmp	.+348    	; 0xbe26 <vfprintf+0x3ca>
    bcca:	0b c0       	rjmp	.+22     	; 0xbce2 <vfprintf+0x286>
    bccc:	80 37       	cpi	r24, 0x70	; 112
    bcce:	21 f0       	breq	.+8      	; 0xbcd8 <vfprintf+0x27c>
    bcd0:	88 37       	cpi	r24, 0x78	; 120
    bcd2:	09 f0       	breq	.+2      	; 0xbcd6 <vfprintf+0x27a>
    bcd4:	a8 c0       	rjmp	.+336    	; 0xbe26 <vfprintf+0x3ca>
    bcd6:	01 c0       	rjmp	.+2      	; 0xbcda <vfprintf+0x27e>
    bcd8:	10 61       	ori	r17, 0x10	; 16
    bcda:	14 ff       	sbrs	r17, 4
    bcdc:	09 c0       	rjmp	.+18     	; 0xbcf0 <vfprintf+0x294>
    bcde:	14 60       	ori	r17, 0x04	; 4
    bce0:	07 c0       	rjmp	.+14     	; 0xbcf0 <vfprintf+0x294>
    bce2:	14 ff       	sbrs	r17, 4
    bce4:	08 c0       	rjmp	.+16     	; 0xbcf6 <vfprintf+0x29a>
    bce6:	16 60       	ori	r17, 0x06	; 6
    bce8:	06 c0       	rjmp	.+12     	; 0xbcf6 <vfprintf+0x29a>
    bcea:	28 e0       	ldi	r18, 0x08	; 8
    bcec:	30 e0       	ldi	r19, 0x00	; 0
    bcee:	05 c0       	rjmp	.+10     	; 0xbcfa <vfprintf+0x29e>
    bcf0:	20 e1       	ldi	r18, 0x10	; 16
    bcf2:	30 e0       	ldi	r19, 0x00	; 0
    bcf4:	02 c0       	rjmp	.+4      	; 0xbcfa <vfprintf+0x29e>
    bcf6:	20 e1       	ldi	r18, 0x10	; 16
    bcf8:	32 e0       	ldi	r19, 0x02	; 2
    bcfa:	f5 01       	movw	r30, r10
    bcfc:	17 ff       	sbrs	r17, 7
    bcfe:	07 c0       	rjmp	.+14     	; 0xbd0e <vfprintf+0x2b2>
    bd00:	60 81       	ld	r22, Z
    bd02:	71 81       	ldd	r23, Z+1	; 0x01
    bd04:	82 81       	ldd	r24, Z+2	; 0x02
    bd06:	93 81       	ldd	r25, Z+3	; 0x03
    bd08:	44 e0       	ldi	r20, 0x04	; 4
    bd0a:	50 e0       	ldi	r21, 0x00	; 0
    bd0c:	06 c0       	rjmp	.+12     	; 0xbd1a <vfprintf+0x2be>
    bd0e:	60 81       	ld	r22, Z
    bd10:	71 81       	ldd	r23, Z+1	; 0x01
    bd12:	80 e0       	ldi	r24, 0x00	; 0
    bd14:	90 e0       	ldi	r25, 0x00	; 0
    bd16:	42 e0       	ldi	r20, 0x02	; 2
    bd18:	50 e0       	ldi	r21, 0x00	; 0
    bd1a:	a4 0e       	add	r10, r20
    bd1c:	b5 1e       	adc	r11, r21
    bd1e:	a2 01       	movw	r20, r4
    bd20:	0e 94 7a 5f 	call	0xbef4	; 0xbef4 <__ultoa_invert>
    bd24:	d8 2e       	mov	r13, r24
    bd26:	d4 18       	sub	r13, r4
    bd28:	01 2f       	mov	r16, r17
    bd2a:	0f 77       	andi	r16, 0x7F	; 127
    bd2c:	06 ff       	sbrs	r16, 6
    bd2e:	09 c0       	rjmp	.+18     	; 0xbd42 <vfprintf+0x2e6>
    bd30:	0e 7f       	andi	r16, 0xFE	; 254
    bd32:	df 14       	cp	r13, r15
    bd34:	30 f4       	brcc	.+12     	; 0xbd42 <vfprintf+0x2e6>
    bd36:	04 ff       	sbrs	r16, 4
    bd38:	06 c0       	rjmp	.+12     	; 0xbd46 <vfprintf+0x2ea>
    bd3a:	02 fd       	sbrc	r16, 2
    bd3c:	04 c0       	rjmp	.+8      	; 0xbd46 <vfprintf+0x2ea>
    bd3e:	0f 7e       	andi	r16, 0xEF	; 239
    bd40:	02 c0       	rjmp	.+4      	; 0xbd46 <vfprintf+0x2ea>
    bd42:	1d 2d       	mov	r17, r13
    bd44:	01 c0       	rjmp	.+2      	; 0xbd48 <vfprintf+0x2ec>
    bd46:	1f 2d       	mov	r17, r15
    bd48:	80 2f       	mov	r24, r16
    bd4a:	90 e0       	ldi	r25, 0x00	; 0
    bd4c:	04 ff       	sbrs	r16, 4
    bd4e:	0c c0       	rjmp	.+24     	; 0xbd68 <vfprintf+0x30c>
    bd50:	fe 01       	movw	r30, r28
    bd52:	ed 0d       	add	r30, r13
    bd54:	f1 1d       	adc	r31, r1
    bd56:	20 81       	ld	r18, Z
    bd58:	20 33       	cpi	r18, 0x30	; 48
    bd5a:	11 f4       	brne	.+4      	; 0xbd60 <vfprintf+0x304>
    bd5c:	09 7e       	andi	r16, 0xE9	; 233
    bd5e:	09 c0       	rjmp	.+18     	; 0xbd72 <vfprintf+0x316>
    bd60:	02 ff       	sbrs	r16, 2
    bd62:	06 c0       	rjmp	.+12     	; 0xbd70 <vfprintf+0x314>
    bd64:	1e 5f       	subi	r17, 0xFE	; 254
    bd66:	05 c0       	rjmp	.+10     	; 0xbd72 <vfprintf+0x316>
    bd68:	86 78       	andi	r24, 0x86	; 134
    bd6a:	90 70       	andi	r25, 0x00	; 0
    bd6c:	00 97       	sbiw	r24, 0x00	; 0
    bd6e:	09 f0       	breq	.+2      	; 0xbd72 <vfprintf+0x316>
    bd70:	1f 5f       	subi	r17, 0xFF	; 255
    bd72:	80 2e       	mov	r8, r16
    bd74:	99 24       	eor	r9, r9
    bd76:	03 fd       	sbrc	r16, 3
    bd78:	12 c0       	rjmp	.+36     	; 0xbd9e <vfprintf+0x342>
    bd7a:	00 ff       	sbrs	r16, 0
    bd7c:	0d c0       	rjmp	.+26     	; 0xbd98 <vfprintf+0x33c>
    bd7e:	fd 2c       	mov	r15, r13
    bd80:	1e 15       	cp	r17, r14
    bd82:	50 f4       	brcc	.+20     	; 0xbd98 <vfprintf+0x33c>
    bd84:	fe 0c       	add	r15, r14
    bd86:	f1 1a       	sub	r15, r17
    bd88:	1e 2d       	mov	r17, r14
    bd8a:	06 c0       	rjmp	.+12     	; 0xbd98 <vfprintf+0x33c>
    bd8c:	80 e2       	ldi	r24, 0x20	; 32
    bd8e:	90 e0       	ldi	r25, 0x00	; 0
    bd90:	b3 01       	movw	r22, r6
    bd92:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    bd96:	1f 5f       	subi	r17, 0xFF	; 255
    bd98:	1e 15       	cp	r17, r14
    bd9a:	c0 f3       	brcs	.-16     	; 0xbd8c <vfprintf+0x330>
    bd9c:	04 c0       	rjmp	.+8      	; 0xbda6 <vfprintf+0x34a>
    bd9e:	1e 15       	cp	r17, r14
    bda0:	10 f4       	brcc	.+4      	; 0xbda6 <vfprintf+0x34a>
    bda2:	e1 1a       	sub	r14, r17
    bda4:	01 c0       	rjmp	.+2      	; 0xbda8 <vfprintf+0x34c>
    bda6:	ee 24       	eor	r14, r14
    bda8:	84 fe       	sbrs	r8, 4
    bdaa:	0f c0       	rjmp	.+30     	; 0xbdca <vfprintf+0x36e>
    bdac:	80 e3       	ldi	r24, 0x30	; 48
    bdae:	90 e0       	ldi	r25, 0x00	; 0
    bdb0:	b3 01       	movw	r22, r6
    bdb2:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    bdb6:	82 fe       	sbrs	r8, 2
    bdb8:	1f c0       	rjmp	.+62     	; 0xbdf8 <vfprintf+0x39c>
    bdba:	81 fe       	sbrs	r8, 1
    bdbc:	03 c0       	rjmp	.+6      	; 0xbdc4 <vfprintf+0x368>
    bdbe:	88 e5       	ldi	r24, 0x58	; 88
    bdc0:	90 e0       	ldi	r25, 0x00	; 0
    bdc2:	10 c0       	rjmp	.+32     	; 0xbde4 <vfprintf+0x388>
    bdc4:	88 e7       	ldi	r24, 0x78	; 120
    bdc6:	90 e0       	ldi	r25, 0x00	; 0
    bdc8:	0d c0       	rjmp	.+26     	; 0xbde4 <vfprintf+0x388>
    bdca:	c4 01       	movw	r24, r8
    bdcc:	86 78       	andi	r24, 0x86	; 134
    bdce:	90 70       	andi	r25, 0x00	; 0
    bdd0:	00 97       	sbiw	r24, 0x00	; 0
    bdd2:	91 f0       	breq	.+36     	; 0xbdf8 <vfprintf+0x39c>
    bdd4:	81 fc       	sbrc	r8, 1
    bdd6:	02 c0       	rjmp	.+4      	; 0xbddc <vfprintf+0x380>
    bdd8:	80 e2       	ldi	r24, 0x20	; 32
    bdda:	01 c0       	rjmp	.+2      	; 0xbdde <vfprintf+0x382>
    bddc:	8b e2       	ldi	r24, 0x2B	; 43
    bdde:	07 fd       	sbrc	r16, 7
    bde0:	8d e2       	ldi	r24, 0x2D	; 45
    bde2:	90 e0       	ldi	r25, 0x00	; 0
    bde4:	b3 01       	movw	r22, r6
    bde6:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    bdea:	06 c0       	rjmp	.+12     	; 0xbdf8 <vfprintf+0x39c>
    bdec:	80 e3       	ldi	r24, 0x30	; 48
    bdee:	90 e0       	ldi	r25, 0x00	; 0
    bdf0:	b3 01       	movw	r22, r6
    bdf2:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    bdf6:	fa 94       	dec	r15
    bdf8:	df 14       	cp	r13, r15
    bdfa:	c0 f3       	brcs	.-16     	; 0xbdec <vfprintf+0x390>
    bdfc:	da 94       	dec	r13
    bdfe:	f2 01       	movw	r30, r4
    be00:	ed 0d       	add	r30, r13
    be02:	f1 1d       	adc	r31, r1
    be04:	80 81       	ld	r24, Z
    be06:	90 e0       	ldi	r25, 0x00	; 0
    be08:	b3 01       	movw	r22, r6
    be0a:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    be0e:	dd 20       	and	r13, r13
    be10:	a9 f7       	brne	.-22     	; 0xbdfc <vfprintf+0x3a0>
    be12:	06 c0       	rjmp	.+12     	; 0xbe20 <vfprintf+0x3c4>
    be14:	80 e2       	ldi	r24, 0x20	; 32
    be16:	90 e0       	ldi	r25, 0x00	; 0
    be18:	b3 01       	movw	r22, r6
    be1a:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <fputc>
    be1e:	ea 94       	dec	r14
    be20:	ee 20       	and	r14, r14
    be22:	c1 f7       	brne	.-16     	; 0xbe14 <vfprintf+0x3b8>
    be24:	40 ce       	rjmp	.-896    	; 0xbaa6 <vfprintf+0x4a>
    be26:	f3 01       	movw	r30, r6
    be28:	86 81       	ldd	r24, Z+6	; 0x06
    be2a:	97 81       	ldd	r25, Z+7	; 0x07
    be2c:	02 c0       	rjmp	.+4      	; 0xbe32 <vfprintf+0x3d6>
    be2e:	8f ef       	ldi	r24, 0xFF	; 255
    be30:	9f ef       	ldi	r25, 0xFF	; 255
    be32:	2d 96       	adiw	r28, 0x0d	; 13
    be34:	cd bf       	out	0x3d, r28	; 61
    be36:	de bf       	out	0x3e, r29	; 62
    be38:	df 91       	pop	r29
    be3a:	cf 91       	pop	r28
    be3c:	1f 91       	pop	r17
    be3e:	0f 91       	pop	r16
    be40:	ff 90       	pop	r15
    be42:	ef 90       	pop	r14
    be44:	df 90       	pop	r13
    be46:	cf 90       	pop	r12
    be48:	bf 90       	pop	r11
    be4a:	af 90       	pop	r10
    be4c:	9f 90       	pop	r9
    be4e:	8f 90       	pop	r8
    be50:	7f 90       	pop	r7
    be52:	6f 90       	pop	r6
    be54:	5f 90       	pop	r5
    be56:	4f 90       	pop	r4
    be58:	3f 90       	pop	r3
    be5a:	2f 90       	pop	r2
    be5c:	08 95       	ret

0000be5e <strnlen_P>:
    be5e:	fc 01       	movw	r30, r24
    be60:	05 90       	lpm	r0, Z+
    be62:	61 50       	subi	r22, 0x01	; 1
    be64:	70 40       	sbci	r23, 0x00	; 0
    be66:	01 10       	cpse	r0, r1
    be68:	d8 f7       	brcc	.-10     	; 0xbe60 <strnlen_P+0x2>
    be6a:	80 95       	com	r24
    be6c:	90 95       	com	r25
    be6e:	8e 0f       	add	r24, r30
    be70:	9f 1f       	adc	r25, r31
    be72:	08 95       	ret

0000be74 <memcpy>:
    be74:	fb 01       	movw	r30, r22
    be76:	dc 01       	movw	r26, r24
    be78:	02 c0       	rjmp	.+4      	; 0xbe7e <memcpy+0xa>
    be7a:	01 90       	ld	r0, Z+
    be7c:	0d 92       	st	X+, r0
    be7e:	41 50       	subi	r20, 0x01	; 1
    be80:	50 40       	sbci	r21, 0x00	; 0
    be82:	d8 f7       	brcc	.-10     	; 0xbe7a <memcpy+0x6>
    be84:	08 95       	ret

0000be86 <strnlen>:
    be86:	fc 01       	movw	r30, r24
    be88:	61 50       	subi	r22, 0x01	; 1
    be8a:	70 40       	sbci	r23, 0x00	; 0
    be8c:	01 90       	ld	r0, Z+
    be8e:	01 10       	cpse	r0, r1
    be90:	d8 f7       	brcc	.-10     	; 0xbe88 <strnlen+0x2>
    be92:	80 95       	com	r24
    be94:	90 95       	com	r25
    be96:	8e 0f       	add	r24, r30
    be98:	9f 1f       	adc	r25, r31
    be9a:	08 95       	ret

0000be9c <fputc>:
    be9c:	0f 93       	push	r16
    be9e:	1f 93       	push	r17
    bea0:	cf 93       	push	r28
    bea2:	df 93       	push	r29
    bea4:	8c 01       	movw	r16, r24
    bea6:	eb 01       	movw	r28, r22
    bea8:	8b 81       	ldd	r24, Y+3	; 0x03
    beaa:	81 ff       	sbrs	r24, 1
    beac:	1b c0       	rjmp	.+54     	; 0xbee4 <fputc+0x48>
    beae:	82 ff       	sbrs	r24, 2
    beb0:	0d c0       	rjmp	.+26     	; 0xbecc <fputc+0x30>
    beb2:	2e 81       	ldd	r18, Y+6	; 0x06
    beb4:	3f 81       	ldd	r19, Y+7	; 0x07
    beb6:	8c 81       	ldd	r24, Y+4	; 0x04
    beb8:	9d 81       	ldd	r25, Y+5	; 0x05
    beba:	28 17       	cp	r18, r24
    bebc:	39 07       	cpc	r19, r25
    bebe:	64 f4       	brge	.+24     	; 0xbed8 <fputc+0x3c>
    bec0:	e8 81       	ld	r30, Y
    bec2:	f9 81       	ldd	r31, Y+1	; 0x01
    bec4:	01 93       	st	Z+, r16
    bec6:	e8 83       	st	Y, r30
    bec8:	f9 83       	std	Y+1, r31	; 0x01
    beca:	06 c0       	rjmp	.+12     	; 0xbed8 <fputc+0x3c>
    becc:	e8 85       	ldd	r30, Y+8	; 0x08
    bece:	f9 85       	ldd	r31, Y+9	; 0x09
    bed0:	80 2f       	mov	r24, r16
    bed2:	19 95       	eicall
    bed4:	00 97       	sbiw	r24, 0x00	; 0
    bed6:	31 f4       	brne	.+12     	; 0xbee4 <fputc+0x48>
    bed8:	8e 81       	ldd	r24, Y+6	; 0x06
    beda:	9f 81       	ldd	r25, Y+7	; 0x07
    bedc:	01 96       	adiw	r24, 0x01	; 1
    bede:	8e 83       	std	Y+6, r24	; 0x06
    bee0:	9f 83       	std	Y+7, r25	; 0x07
    bee2:	02 c0       	rjmp	.+4      	; 0xbee8 <fputc+0x4c>
    bee4:	0f ef       	ldi	r16, 0xFF	; 255
    bee6:	1f ef       	ldi	r17, 0xFF	; 255
    bee8:	c8 01       	movw	r24, r16
    beea:	df 91       	pop	r29
    beec:	cf 91       	pop	r28
    beee:	1f 91       	pop	r17
    bef0:	0f 91       	pop	r16
    bef2:	08 95       	ret

0000bef4 <__ultoa_invert>:
    bef4:	fa 01       	movw	r30, r20
    bef6:	aa 27       	eor	r26, r26
    bef8:	28 30       	cpi	r18, 0x08	; 8
    befa:	51 f1       	breq	.+84     	; 0xbf50 <__ultoa_invert+0x5c>
    befc:	20 31       	cpi	r18, 0x10	; 16
    befe:	81 f1       	breq	.+96     	; 0xbf60 <__ultoa_invert+0x6c>
    bf00:	e8 94       	clt
    bf02:	6f 93       	push	r22
    bf04:	6e 7f       	andi	r22, 0xFE	; 254
    bf06:	6e 5f       	subi	r22, 0xFE	; 254
    bf08:	7f 4f       	sbci	r23, 0xFF	; 255
    bf0a:	8f 4f       	sbci	r24, 0xFF	; 255
    bf0c:	9f 4f       	sbci	r25, 0xFF	; 255
    bf0e:	af 4f       	sbci	r26, 0xFF	; 255
    bf10:	b1 e0       	ldi	r27, 0x01	; 1
    bf12:	3e d0       	rcall	.+124    	; 0xbf90 <__ultoa_invert+0x9c>
    bf14:	b4 e0       	ldi	r27, 0x04	; 4
    bf16:	3c d0       	rcall	.+120    	; 0xbf90 <__ultoa_invert+0x9c>
    bf18:	67 0f       	add	r22, r23
    bf1a:	78 1f       	adc	r23, r24
    bf1c:	89 1f       	adc	r24, r25
    bf1e:	9a 1f       	adc	r25, r26
    bf20:	a1 1d       	adc	r26, r1
    bf22:	68 0f       	add	r22, r24
    bf24:	79 1f       	adc	r23, r25
    bf26:	8a 1f       	adc	r24, r26
    bf28:	91 1d       	adc	r25, r1
    bf2a:	a1 1d       	adc	r26, r1
    bf2c:	6a 0f       	add	r22, r26
    bf2e:	71 1d       	adc	r23, r1
    bf30:	81 1d       	adc	r24, r1
    bf32:	91 1d       	adc	r25, r1
    bf34:	a1 1d       	adc	r26, r1
    bf36:	20 d0       	rcall	.+64     	; 0xbf78 <__ultoa_invert+0x84>
    bf38:	09 f4       	brne	.+2      	; 0xbf3c <__ultoa_invert+0x48>
    bf3a:	68 94       	set
    bf3c:	3f 91       	pop	r19
    bf3e:	2a e0       	ldi	r18, 0x0A	; 10
    bf40:	26 9f       	mul	r18, r22
    bf42:	11 24       	eor	r1, r1
    bf44:	30 19       	sub	r19, r0
    bf46:	30 5d       	subi	r19, 0xD0	; 208
    bf48:	31 93       	st	Z+, r19
    bf4a:	de f6       	brtc	.-74     	; 0xbf02 <__ultoa_invert+0xe>
    bf4c:	cf 01       	movw	r24, r30
    bf4e:	08 95       	ret
    bf50:	46 2f       	mov	r20, r22
    bf52:	47 70       	andi	r20, 0x07	; 7
    bf54:	40 5d       	subi	r20, 0xD0	; 208
    bf56:	41 93       	st	Z+, r20
    bf58:	b3 e0       	ldi	r27, 0x03	; 3
    bf5a:	0f d0       	rcall	.+30     	; 0xbf7a <__ultoa_invert+0x86>
    bf5c:	c9 f7       	brne	.-14     	; 0xbf50 <__ultoa_invert+0x5c>
    bf5e:	f6 cf       	rjmp	.-20     	; 0xbf4c <__ultoa_invert+0x58>
    bf60:	46 2f       	mov	r20, r22
    bf62:	4f 70       	andi	r20, 0x0F	; 15
    bf64:	40 5d       	subi	r20, 0xD0	; 208
    bf66:	4a 33       	cpi	r20, 0x3A	; 58
    bf68:	18 f0       	brcs	.+6      	; 0xbf70 <__ultoa_invert+0x7c>
    bf6a:	49 5d       	subi	r20, 0xD9	; 217
    bf6c:	31 fd       	sbrc	r19, 1
    bf6e:	40 52       	subi	r20, 0x20	; 32
    bf70:	41 93       	st	Z+, r20
    bf72:	02 d0       	rcall	.+4      	; 0xbf78 <__ultoa_invert+0x84>
    bf74:	a9 f7       	brne	.-22     	; 0xbf60 <__ultoa_invert+0x6c>
    bf76:	ea cf       	rjmp	.-44     	; 0xbf4c <__ultoa_invert+0x58>
    bf78:	b4 e0       	ldi	r27, 0x04	; 4
    bf7a:	a6 95       	lsr	r26
    bf7c:	97 95       	ror	r25
    bf7e:	87 95       	ror	r24
    bf80:	77 95       	ror	r23
    bf82:	67 95       	ror	r22
    bf84:	ba 95       	dec	r27
    bf86:	c9 f7       	brne	.-14     	; 0xbf7a <__ultoa_invert+0x86>
    bf88:	00 97       	sbiw	r24, 0x00	; 0
    bf8a:	61 05       	cpc	r22, r1
    bf8c:	71 05       	cpc	r23, r1
    bf8e:	08 95       	ret
    bf90:	9b 01       	movw	r18, r22
    bf92:	ac 01       	movw	r20, r24
    bf94:	0a 2e       	mov	r0, r26
    bf96:	06 94       	lsr	r0
    bf98:	57 95       	ror	r21
    bf9a:	47 95       	ror	r20
    bf9c:	37 95       	ror	r19
    bf9e:	27 95       	ror	r18
    bfa0:	ba 95       	dec	r27
    bfa2:	c9 f7       	brne	.-14     	; 0xbf96 <__ultoa_invert+0xa2>
    bfa4:	62 0f       	add	r22, r18
    bfa6:	73 1f       	adc	r23, r19
    bfa8:	84 1f       	adc	r24, r20
    bfaa:	95 1f       	adc	r25, r21
    bfac:	a0 1d       	adc	r26, r0
    bfae:	08 95       	ret

0000bfb0 <_exit>:
    bfb0:	f8 94       	cli

0000bfb2 <__stop_program>:
    bfb2:	ff cf       	rjmp	.-2      	; 0xbfb2 <__stop_program>
