
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007730  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  00007730  000077c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002faa  0080210e  0080210e  000078d2  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  000078d4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a1cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000ab98  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c28f  00000000  00000000  0000afb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000272a  00000000  00000000  00017247  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000058a4  00000000  00000000  00019971  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001be4  00000000  00000000  0001f218  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004686  00000000  00000000  00020dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000827b  00000000  00000000  00025482  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fd97  00000000  00000000  0002d6fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001a8  00000000  00000000  001ad494  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 cd 0c 	jmp	0x199a	; 0x199a <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 05 12 	jmp	0x240a	; 0x240a <__vector_16>
      44:	0c 94 dd 11 	jmp	0x23ba	; 0x23ba <__vector_17>
      48:	0c 94 b5 11 	jmp	0x236a	; 0x236a <__vector_18>
      4c:	0c 94 6f 11 	jmp	0x22de	; 0x22de <__vector_19>
      50:	0c 94 ea 0a 	jmp	0x15d4	; 0x15d4 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 d1 03 	jmp	0x7a2	; 0x7a2 <__vector_47>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 b5 1c 	jmp	0x396a	; 0x396a <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 ac 0e 	jmp	0x1d58	; 0x1d58 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 47 11 	jmp	0x228e	; 0x228e <__vector_79>
     140:	0c 94 1f 11 	jmp	0x223e	; 0x223e <__vector_80>
     144:	0c 94 f7 10 	jmp	0x21ee	; 0x21ee <__vector_81>
     148:	0c 94 cd 10 	jmp	0x219a	; 0x219a <__vector_82>
     14c:	0c 94 ef 07 	jmp	0xfde	; 0xfde <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 7c 0b 	jmp	0x16f8	; 0x16f8 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e0 e3       	ldi	r30, 0x30	; 48
     244:	f7 e7       	ldi	r31, 0x77	; 119
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a8 3b       	cpi	r26, 0xB8	; 184
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 04 03 	call	0x608	; 0x608 <main>
     26a:	0c 94 96 3b 	jmp	0x772c	; 0x772c <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 2d 3e 	sts	0x3E2D, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 2d 3e 	sts	0x3E2D, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 1f 3e 	lds	r24, 0x3E1F
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 1e 3e 	lds	r24, 0x3E1E
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 2d 3e 	sts	0x3E2D, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	2d e2       	ldi	r18, 0x2D	; 45
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 1e 3e 	lds	r24, 0x3E1E
     376:	90 91 1f 3e 	lds	r25, 0x3E1F
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 1e 3e 	sts	0x3E1E, r16
     382:	10 93 1f 3e 	sts	0x3E1F, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 2d 3e 	sts	0x3E2D, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	ed ea       	ldi	r30, 0xAD	; 173
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 18 04 	call	0x830	; 0x830 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 f2 36 	call	0x6de4	; 0x6de4 <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 f9 35 	call	0x6bf2	; 0x6bf2 <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 c6 36 	call	0x6d8c	; 0x6d8c <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 f2 36 	call	0x6de4	; 0x6de4 <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 f9 35 	call	0x6bf2	; 0x6bf2 <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 80 37 	call	0x6f00	; 0x6f00 <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <main>:
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

volatile uint8_t TimedOut = 0;

int main(){
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	c6 56       	subi	r28, 0x66	; 102
     612:	d0 40       	sbci	r29, 0x00	; 0
     614:	cd bf       	out	0x3d, r28	; 61
     616:	de bf       	out	0x3e, r29	; 62

	uint32_t length;
	uint16_t dest_addr;
	uint16_t ack = 0;
     618:	19 82       	std	Y+1, r1	; 0x01
     61a:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t  MessageBuffer[100];
	uint16_t NumReceivedMessages, NumMessages, TimeoutCount;
	//set timeout about 2 sec
	uint16_t timeout = 4000;
	
	set_32MHz();
     61c:	0e 94 18 04 	call	0x830	; 0x830 <set_32MHz>
	
	chb_init();
     620:	0e 94 80 18 	call	0x3100	; 0x3100 <chb_init>
	chb_set_short_addr(0x0000);
     624:	80 e0       	ldi	r24, 0x00	; 0
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	0e 94 a3 1a 	call	0x3546	; 0x3546 <chb_set_short_addr>
	chb_set_channel(1);
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <chb_set_channel>
	StartSerial((uint32_t)57600);
     632:	60 e0       	ldi	r22, 0x00	; 0
     634:	71 ee       	ldi	r23, 0xE1	; 225
     636:	80 e0       	ldi	r24, 0x00	; 0
     638:	90 e0       	ldi	r25, 0x00	; 0
     63a:	0e 94 3c 02 	call	0x478	; 0x478 <StartSerial>

	while(!chb_set_state(CHB_RX_AACK_ON) == RADIO_SUCCESS);
     63e:	86 e1       	ldi	r24, 0x16	; 22
     640:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <chb_set_state>
	pcb_t* pcb = chb_get_pcb();
     644:	0e 94 a1 18 	call	0x3142	; 0x3142 <chb_get_pcb>
     648:	2c 01       	movw	r4, r24
	
	
	//set the period to 2 seconds
	TCE0.PER = timeout;
     64a:	e0 e0       	ldi	r30, 0x00	; 0
     64c:	fa e0       	ldi	r31, 0x0A	; 10
     64e:	80 ea       	ldi	r24, 0xA0	; 160
     650:	9f e0       	ldi	r25, 0x0F	; 15
     652:	86 a3       	lds	r24, 0x56
     654:	97 a3       	lds	r25, 0x57
	TCE0.CTRLFSET = 0x08;
     656:	88 e0       	ldi	r24, 0x08	; 8
     658:	81 87       	std	Z+9, r24	; 0x09
	//set overflow interrupt
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	86 83       	std	Z+6, r24	; 0x06
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
     65e:	e0 ea       	ldi	r30, 0xA0	; 160
     660:	f0 e0       	ldi	r31, 0x00	; 0
     662:	82 81       	ldd	r24, Z+2	; 0x02
     664:	81 60       	ori	r24, 0x01	; 1
     666:	82 83       	std	Z+2, r24	; 0x02
	sei();
     668:	78 94       	sei
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     66a:	0f 2e       	mov	r0, r31
     66c:	f0 ea       	ldi	r31, 0xA0	; 160
     66e:	6f 2e       	mov	r6, r31
     670:	f8 e0       	ldi	r31, 0x08	; 8
     672:	7f 2e       	mov	r7, r31
     674:	f0 2d       	mov	r31, r0
		if(length > 0){
			//process/send the bytes over radio
			chb_write(dest_addr,MessageBuffer+1,length-1);
		}
		
		TCE0.CTRLA = 0x07;
     676:	0f 2e       	mov	r0, r31
     678:	22 24       	eor	r2, r2
     67a:	fa e0       	ldi	r31, 0x0A	; 10
     67c:	3f 2e       	mov	r3, r31
     67e:	f0 2d       	mov	r31, r0
	sei();
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     680:	f3 01       	movw	r30, r6
     682:	81 81       	ldd	r24, Z+1	; 0x01
     684:	88 23       	and	r24, r24
     686:	e4 f7       	brge	.-8      	; 0x680 <main+0x78>
		length = SerialReadByte();
     688:	0e 94 c3 02 	call	0x586	; 0x586 <SerialReadByte>
     68c:	88 2e       	mov	r8, r24
     68e:	99 24       	eor	r9, r9
     690:	aa 24       	eor	r10, r10
     692:	bb 24       	eor	r11, r11
		for(uint32_t i = 0; i<length; i++){
     694:	81 14       	cp	r8, r1
     696:	91 04       	cpc	r9, r1
     698:	a1 04       	cpc	r10, r1
     69a:	b1 04       	cpc	r11, r1
     69c:	09 f4       	brne	.+2      	; 0x6a0 <main+0x98>
     69e:	7e c0       	rjmp	.+252    	; 0x79c <main+0x194>
     6a0:	8e 01       	movw	r16, r28
     6a2:	0d 5f       	subi	r16, 0xFD	; 253
     6a4:	1f 4f       	sbci	r17, 0xFF	; 255
     6a6:	cc 24       	eor	r12, r12
     6a8:	dd 24       	eor	r13, r13
     6aa:	76 01       	movw	r14, r12
			MessageBuffer[i] = SerialReadByte();
     6ac:	0e 94 c3 02 	call	0x586	; 0x586 <SerialReadByte>
     6b0:	f8 01       	movw	r30, r16
     6b2:	81 93       	st	Z+, r24
     6b4:	8f 01       	movw	r16, r30
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
		length = SerialReadByte();
		for(uint32_t i = 0; i<length; i++){
     6b6:	08 94       	sec
     6b8:	c1 1c       	adc	r12, r1
     6ba:	d1 1c       	adc	r13, r1
     6bc:	e1 1c       	adc	r14, r1
     6be:	f1 1c       	adc	r15, r1
     6c0:	8c 14       	cp	r8, r12
     6c2:	9d 04       	cpc	r9, r13
     6c4:	ae 04       	cpc	r10, r14
     6c6:	bf 04       	cpc	r11, r15
     6c8:	89 f7       	brne	.-30     	; 0x6ac <main+0xa4>
			MessageBuffer[i] = SerialReadByte();
		}
		dest_addr = (uint16_t)(MessageBuffer[0]);
     6ca:	cb 80       	ldd	r12, Y+3	; 0x03
     6cc:	ff 24       	eor	r15, r15
			
		
		if(length > 0){
			//process/send the bytes over radio
			chb_write(dest_addr,MessageBuffer+1,length-1);
     6ce:	a5 01       	movw	r20, r10
     6d0:	94 01       	movw	r18, r8
     6d2:	21 50       	subi	r18, 0x01	; 1
     6d4:	30 40       	sbci	r19, 0x00	; 0
     6d6:	40 40       	sbci	r20, 0x00	; 0
     6d8:	50 40       	sbci	r21, 0x00	; 0
     6da:	8c 2d       	mov	r24, r12
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	be 01       	movw	r22, r28
     6e0:	6c 5f       	subi	r22, 0xFC	; 252
     6e2:	7f 4f       	sbci	r23, 0xFF	; 255
     6e4:	0e 94 a4 18 	call	0x3148	; 0x3148 <chb_write>
		}
		
		TCE0.CTRLA = 0x07;
     6e8:	87 e0       	ldi	r24, 0x07	; 7
     6ea:	f1 01       	movw	r30, r2
     6ec:	80 83       	st	Z, r24
		TimedOut = 0;
     6ee:	10 92 0e 21 	sts	0x210E, r1
		//set prescalar of 1024... each timer tick is 512 micro seconds
		//TCE0.CTRLA = 0x07;
		//wait for response/data over radio
		while(!pcb->data_rcv){
     6f2:	04 c0       	rjmp	.+8      	; 0x6fc <main+0xf4>
			//no response detected so go back to waiting for next serial command
			if(TimedOut) break;
     6f4:	80 91 0e 21 	lds	r24, 0x210E
     6f8:	88 23       	and	r24, r24
     6fa:	21 f4       	brne	.+8      	; 0x704 <main+0xfc>
		TCE0.CTRLA = 0x07;
		TimedOut = 0;
		//set prescalar of 1024... each timer tick is 512 micro seconds
		//TCE0.CTRLA = 0x07;
		//wait for response/data over radio
		while(!pcb->data_rcv){
     6fc:	f2 01       	movw	r30, r4
     6fe:	83 81       	ldd	r24, Z+3	; 0x03
     700:	88 23       	and	r24, r24
     702:	c1 f3       	breq	.-16     	; 0x6f4 <main+0xec>
			//no response detected so go back to waiting for next serial command
			if(TimedOut) break;
			//if(TCF0.CNT - TimeoutCount >= timeout) break;
		}
 		if(TimedOut) {
     704:	80 91 0e 21 	lds	r24, 0x210E
     708:	88 23       	and	r24, r24
     70a:	29 f0       	breq	.+10     	; 0x716 <main+0x10e>
			TCE0.CTRLA = 0x00;
     70c:	f1 01       	movw	r30, r2
     70e:	10 82       	st	Z, r1
			TCE0.CTRLFSET = 0x08;
     710:	88 e0       	ldi	r24, 0x08	; 8
     712:	81 87       	std	Z+9, r24	; 0x09
 			continue;
     714:	b5 cf       	rjmp	.-150    	; 0x680 <main+0x78>
 		}			
		//if(TCF0.CNT - TimeoutCount >= timeout) continue;
		//read the data. expecting a 1 byte message containing number of messages that follow
		length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
     716:	8d ea       	ldi	r24, 0xAD	; 173
     718:	91 e2       	ldi	r25, 0x21	; 33
     71a:	0e 94 44 19 	call	0x3288	; 0x3288 <chb_read>
		if (length == 2){
     71e:	82 30       	cpi	r24, 0x02	; 2
     720:	09 f0       	breq	.+2      	; 0x724 <main+0x11c>
     722:	ae cf       	rjmp	.-164    	; 0x680 <main+0x78>
			length = 0;
			NumReceivedMessages = 0;
			//get the number of messages (2 bytes)
			NumMessages = ((uint16_t*)FRAMReadBuffer)[0];
     724:	ed ea       	ldi	r30, 0xAD	; 173
     726:	f1 e2       	ldi	r31, 0x21	; 33
     728:	80 80       	ld	r8, Z
     72a:	91 80       	ldd	r9, Z+1	; 0x01
			//start timeout clock
			//TimeoutCount = TCF0.CNT;
			//reset timer count
			//TCE0.CTRLA = 0x00;
			TCE0.CTRLFSET = 0x08;
     72c:	88 e0       	ldi	r24, 0x08	; 8
     72e:	f1 01       	movw	r30, r2
     730:	81 87       	std	Z+9, r24	; 0x09
			//clear timeout flag
			TimedOut = 0;
     732:	10 92 0e 21 	sts	0x210E, r1
			//TCE0.CTRLA = 0x07;
			while(NumReceivedMessages <NumMessages){
     736:	81 14       	cp	r8, r1
     738:	91 04       	cpc	r9, r1
     73a:	59 f1       	breq	.+86     	; 0x792 <main+0x18a>
		//if(TCF0.CNT - TimeoutCount >= timeout) continue;
		//read the data. expecting a 1 byte message containing number of messages that follow
		length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
		if (length == 2){
			length = 0;
			NumReceivedMessages = 0;
     73c:	00 e0       	ldi	r16, 0x00	; 0
     73e:	10 e0       	ldi	r17, 0x00	; 0
			//clear timeout flag
			TimedOut = 0;
			//TCE0.CTRLA = 0x07;
			while(NumReceivedMessages <NumMessages){
				//wait for all messages to come in
				if(pcb->data_rcv){
     740:	f2 01       	movw	r30, r4
     742:	83 81       	ldd	r24, Z+3	; 0x03
     744:	88 23       	and	r24, r24
     746:	f1 f0       	breq	.+60     	; 0x784 <main+0x17c>
					length = chb_read((chb_rx_data_t*)(FRAMReadBuffer));
     748:	8d ea       	ldi	r24, 0xAD	; 173
     74a:	91 e2       	ldi	r25, 0x21	; 33
     74c:	0e 94 44 19 	call	0x3288	; 0x3288 <chb_read>
     750:	48 2f       	mov	r20, r24
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	60 e0       	ldi	r22, 0x00	; 0
     756:	70 e0       	ldi	r23, 0x00	; 0
					//pass the data to USB
					SerialWriteBuffer(FRAMReadBuffer,length);
     758:	8d ea       	ldi	r24, 0xAD	; 173
     75a:	91 e2       	ldi	r25, 0x21	; 33
     75c:	0e 94 cb 02 	call	0x596	; 0x596 <SerialWriteBuffer>
					NumReceivedMessages++;
     760:	0f 5f       	subi	r16, 0xFF	; 255
     762:	1f 4f       	sbci	r17, 0xFF	; 255
					//reset timeout count
					//TimeoutCount = TCF0.CNT;
					//reset timer count
					//TCE0.CTRLA = 0x00;
					//send acknowledgment
					chb_write(dest_addr,&ack,2);
     764:	8c 2d       	mov	r24, r12
     766:	9f 2d       	mov	r25, r15
     768:	be 01       	movw	r22, r28
     76a:	6f 5f       	subi	r22, 0xFF	; 255
     76c:	7f 4f       	sbci	r23, 0xFF	; 255
     76e:	22 e0       	ldi	r18, 0x02	; 2
     770:	30 e0       	ldi	r19, 0x00	; 0
     772:	40 e0       	ldi	r20, 0x00	; 0
     774:	50 e0       	ldi	r21, 0x00	; 0
     776:	0e 94 a4 18 	call	0x3148	; 0x3148 <chb_write>
					TCE0.CTRLFSET = 0x08;
     77a:	88 e0       	ldi	r24, 0x08	; 8
     77c:	f1 01       	movw	r30, r2
     77e:	81 87       	std	Z+9, r24	; 0x09
					//clear timeout flag
					TimedOut = 0;
     780:	10 92 0e 21 	sts	0x210E, r1
					//TCE0.CTRLA = 0x07;
				}
				//if(TCF0.CNT - TimeoutCount >= timeout) break;
				if(TimedOut) break;		
     784:	80 91 0e 21 	lds	r24, 0x210E
     788:	88 23       	and	r24, r24
     78a:	19 f4       	brne	.+6      	; 0x792 <main+0x18a>
			//TCE0.CTRLA = 0x00;
			TCE0.CTRLFSET = 0x08;
			//clear timeout flag
			TimedOut = 0;
			//TCE0.CTRLA = 0x07;
			while(NumReceivedMessages <NumMessages){
     78c:	08 15       	cp	r16, r8
     78e:	19 05       	cpc	r17, r9
     790:	b8 f2       	brcs	.-82     	; 0x740 <main+0x138>
				//if(TCF0.CNT - TimeoutCount >= timeout) break;
				if(TimedOut) break;		
			}
			//SerialWriteBuffer(FRAMReadBuffer,length);
			//check if timed out
			TCE0.CTRLA = 0x00;
     792:	f1 01       	movw	r30, r2
     794:	10 82       	st	Z, r1
			TCE0.CTRLFSET = 0x08;
     796:	88 e0       	ldi	r24, 0x08	; 8
     798:	81 87       	std	Z+9, r24	; 0x09
	sei();
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     79a:	72 cf       	rjmp	.-284    	; 0x680 <main+0x78>
		length = SerialReadByte();
		for(uint32_t i = 0; i<length; i++){
			MessageBuffer[i] = SerialReadByte();
		}
		dest_addr = (uint16_t)(MessageBuffer[0]);
     79c:	cb 80       	ldd	r12, Y+3	; 0x03
     79e:	ff 24       	eor	r15, r15
     7a0:	a3 cf       	rjmp	.-186    	; 0x6e8 <main+0xe0>

000007a2 <__vector_47>:
			TCE0.CTRLFSET = 0x08;
		}	
	}
}

ISR(TCE0_OVF_vect){
     7a2:	1f 92       	push	r1
     7a4:	0f 92       	push	r0
     7a6:	0f b6       	in	r0, 0x3f	; 63
     7a8:	0f 92       	push	r0
     7aa:	11 24       	eor	r1, r1
     7ac:	8f 93       	push	r24
	//reset timer count
	//TCE0.CTRLA = 0x00;
	//TCE0.CTRLFSET = 0x0C;
	//set timeout flag
	TimedOut = 1;
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	80 93 0e 21 	sts	0x210E, r24
     7b4:	8f 91       	pop	r24
     7b6:	0f 90       	pop	r0
     7b8:	0f be       	out	0x3f, r0	; 63
     7ba:	0f 90       	pop	r0
     7bc:	1f 90       	pop	r1
     7be:	18 95       	reti

000007c0 <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     7c0:	10 92 33 3e 	sts	0x3E33, r1
}
     7c4:	08 95       	ret

000007c6 <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     7c6:	80 ec       	ldi	r24, 0xC0	; 192
     7c8:	60 e0       	ldi	r22, 0x00	; 0
     7ca:	4b e0       	ldi	r20, 0x0B	; 11
     7cc:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     7d0:	e0 e5       	ldi	r30, 0x50	; 80
     7d2:	f0 e0       	ldi	r31, 0x00	; 0
     7d4:	80 81       	ld	r24, Z
     7d6:	88 60       	ori	r24, 0x08	; 8
     7d8:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     7da:	81 81       	ldd	r24, Z+1	; 0x01
     7dc:	83 ff       	sbrs	r24, 3
     7de:	fd cf       	rjmp	.-6      	; 0x7da <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     7e0:	80 ec       	ldi	r24, 0xC0	; 192
     7e2:	62 e0       	ldi	r22, 0x02	; 2
     7e4:	0e 94 a1 1e 	call	0x3d42	; 0x3d42 <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     7e8:	e0 e5       	ldi	r30, 0x50	; 80
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	80 81       	ld	r24, Z
     7ee:	80 61       	ori	r24, 0x10	; 16
     7f0:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     7f2:	81 81       	ldd	r24, Z+1	; 0x01
     7f4:	84 ff       	sbrs	r24, 4
     7f6:	fd cf       	rjmp	.-6      	; 0x7f2 <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     7f8:	84 e0       	ldi	r24, 0x04	; 4
     7fa:	0e 94 b7 1e 	call	0x3d6e	; 0x3d6e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     7fe:	81 e0       	ldi	r24, 0x01	; 1
     800:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <CLKSYS_Disable>
}
     804:	08 95       	ret

00000806 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     806:	e0 e5       	ldi	r30, 0x50	; 80
     808:	f0 e0       	ldi	r31, 0x00	; 0
     80a:	80 81       	ld	r24, Z
     80c:	82 60       	ori	r24, 0x02	; 2
     80e:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	61 e0       	ldi	r22, 0x01	; 1
     814:	0e 94 b1 1e 	call	0x3d62	; 0x3d62 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     818:	e0 e5       	ldi	r30, 0x50	; 80
     81a:	f0 e0       	ldi	r31, 0x00	; 0
     81c:	81 81       	ldd	r24, Z+1	; 0x01
     81e:	81 ff       	sbrs	r24, 1
     820:	fd cf       	rjmp	.-6      	; 0x81c <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	0e 94 b7 1e 	call	0x3d6e	; 0x3d6e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <CLKSYS_Disable>
	
}
     82e:	08 95       	ret

00000830 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     830:	e0 e5       	ldi	r30, 0x50	; 80
     832:	f0 e0       	ldi	r31, 0x00	; 0
     834:	80 81       	ld	r24, Z
     836:	82 60       	ori	r24, 0x02	; 2
     838:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	60 e0       	ldi	r22, 0x00	; 0
     83e:	0e 94 b1 1e 	call	0x3d62	; 0x3d62 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     842:	e0 e5       	ldi	r30, 0x50	; 80
     844:	f0 e0       	ldi	r31, 0x00	; 0
     846:	81 81       	ldd	r24, Z+1	; 0x01
     848:	81 ff       	sbrs	r24, 1
     84a:	fd cf       	rjmp	.-6      	; 0x846 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     84c:	81 e0       	ldi	r24, 0x01	; 1
     84e:	0e 94 b7 1e 	call	0x3d6e	; 0x3d6e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <CLKSYS_Disable>
	
}
     858:	08 95       	ret

0000085a <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     85a:	88 23       	and	r24, r24
     85c:	29 f0       	breq	.+10     	; 0x868 <portExCS+0xe>
     85e:	88 e0       	ldi	r24, 0x08	; 8
     860:	e0 e0       	ldi	r30, 0x00	; 0
     862:	f6 e0       	ldi	r31, 0x06	; 6
     864:	86 83       	std	Z+6, r24	; 0x06
     866:	04 c0       	rjmp	.+8      	; 0x870 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     868:	88 e0       	ldi	r24, 0x08	; 8
     86a:	e0 e0       	ldi	r30, 0x00	; 0
     86c:	f6 e0       	ldi	r31, 0x06	; 6
     86e:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     870:	8a e6       	ldi	r24, 0x6A	; 106
     872:	8a 95       	dec	r24
     874:	f1 f7       	brne	.-4      	; 0x872 <portExCS+0x18>
     876:	00 c0       	rjmp	.+0      	; 0x878 <portExCS+0x1e>
	}
	_delay_us(10);
}
     878:	08 95       	ret

0000087a <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     87a:	88 23       	and	r24, r24
     87c:	79 f0       	breq	.+30     	; 0x89c <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     87e:	e0 ea       	ldi	r30, 0xA0	; 160
     880:	f6 e0       	ldi	r31, 0x06	; 6
     882:	80 e2       	ldi	r24, 0x20	; 32
     884:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     886:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     888:	8f ef       	ldi	r24, 0xFF	; 255
     88a:	93 ec       	ldi	r25, 0xC3	; 195
     88c:	a9 e0       	ldi	r26, 0x09	; 9
     88e:	81 50       	subi	r24, 0x01	; 1
     890:	90 40       	sbci	r25, 0x00	; 0
     892:	a0 40       	sbci	r26, 0x00	; 0
     894:	e1 f7       	brne	.-8      	; 0x88e <Ext1Power+0x14>
     896:	00 c0       	rjmp	.+0      	; 0x898 <Ext1Power+0x1e>
     898:	00 00       	nop
     89a:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     89c:	e0 ea       	ldi	r30, 0xA0	; 160
     89e:	f6 e0       	ldi	r31, 0x06	; 6
     8a0:	80 e2       	ldi	r24, 0x20	; 32
     8a2:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     8a4:	82 83       	std	Z+2, r24	; 0x02
     8a6:	08 95       	ret

000008a8 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     8a8:	88 23       	and	r24, r24
     8aa:	79 f0       	breq	.+30     	; 0x8ca <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     8ac:	e0 ea       	ldi	r30, 0xA0	; 160
     8ae:	f6 e0       	ldi	r31, 0x06	; 6
     8b0:	80 e4       	ldi	r24, 0x40	; 64
     8b2:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     8b4:	85 83       	std	Z+5, r24	; 0x05
     8b6:	8f ef       	ldi	r24, 0xFF	; 255
     8b8:	93 ec       	ldi	r25, 0xC3	; 195
     8ba:	a9 e0       	ldi	r26, 0x09	; 9
     8bc:	81 50       	subi	r24, 0x01	; 1
     8be:	90 40       	sbci	r25, 0x00	; 0
     8c0:	a0 40       	sbci	r26, 0x00	; 0
     8c2:	e1 f7       	brne	.-8      	; 0x8bc <Ext2Power+0x14>
     8c4:	00 c0       	rjmp	.+0      	; 0x8c6 <Ext2Power+0x1e>
     8c6:	00 00       	nop
     8c8:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     8ca:	e0 ea       	ldi	r30, 0xA0	; 160
     8cc:	f6 e0       	ldi	r31, 0x06	; 6
     8ce:	80 e4       	ldi	r24, 0x40	; 64
     8d0:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     8d2:	82 83       	std	Z+2, r24	; 0x02
     8d4:	08 95       	ret

000008d6 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     8d6:	88 23       	and	r24, r24
     8d8:	79 f0       	breq	.+30     	; 0x8f8 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     8da:	e0 ea       	ldi	r30, 0xA0	; 160
     8dc:	f6 e0       	ldi	r31, 0x06	; 6
     8de:	80 e8       	ldi	r24, 0x80	; 128
     8e0:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     8e2:	85 83       	std	Z+5, r24	; 0x05
     8e4:	8f ef       	ldi	r24, 0xFF	; 255
     8e6:	93 ec       	ldi	r25, 0xC3	; 195
     8e8:	a9 e0       	ldi	r26, 0x09	; 9
     8ea:	81 50       	subi	r24, 0x01	; 1
     8ec:	90 40       	sbci	r25, 0x00	; 0
     8ee:	a0 40       	sbci	r26, 0x00	; 0
     8f0:	e1 f7       	brne	.-8      	; 0x8ea <HVPower+0x14>
     8f2:	00 c0       	rjmp	.+0      	; 0x8f4 <HVPower+0x1e>
     8f4:	00 00       	nop
     8f6:	05 c0       	rjmp	.+10     	; 0x902 <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     8f8:	e0 ea       	ldi	r30, 0xA0	; 160
     8fa:	f6 e0       	ldi	r31, 0x06	; 6
     8fc:	80 e8       	ldi	r24, 0x80	; 128
     8fe:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     900:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     902:	af e3       	ldi	r26, 0x3F	; 63
     904:	bf e1       	ldi	r27, 0x1F	; 31
     906:	11 97       	sbiw	r26, 0x01	; 1
     908:	f1 f7       	brne	.-4      	; 0x906 <HVPower+0x30>
     90a:	00 c0       	rjmp	.+0      	; 0x90c <HVPower+0x36>
     90c:	00 00       	nop
	}
	_delay_us(1000);
}
     90e:	08 95       	ret

00000910 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     910:	88 23       	and	r24, r24
     912:	29 f0       	breq	.+10     	; 0x91e <lowerMuxCS+0xe>
     914:	80 e1       	ldi	r24, 0x10	; 16
     916:	e0 e8       	ldi	r30, 0x80	; 128
     918:	f6 e0       	ldi	r31, 0x06	; 6
     91a:	86 83       	std	Z+6, r24	; 0x06
     91c:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     91e:	80 e1       	ldi	r24, 0x10	; 16
     920:	e0 e8       	ldi	r30, 0x80	; 128
     922:	f6 e0       	ldi	r31, 0x06	; 6
     924:	85 83       	std	Z+5, r24	; 0x05
     926:	08 95       	ret

00000928 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     928:	88 23       	and	r24, r24
     92a:	29 f0       	breq	.+10     	; 0x936 <upperMuxCS+0xe>
     92c:	82 e0       	ldi	r24, 0x02	; 2
     92e:	e0 e4       	ldi	r30, 0x40	; 64
     930:	f6 e0       	ldi	r31, 0x06	; 6
     932:	86 83       	std	Z+6, r24	; 0x06
     934:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     936:	82 e0       	ldi	r24, 0x02	; 2
     938:	e0 e4       	ldi	r30, 0x40	; 64
     93a:	f6 e0       	ldi	r31, 0x06	; 6
     93c:	85 83       	std	Z+5, r24	; 0x05
     93e:	08 95       	ret

00000940 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     940:	e0 e4       	ldi	r30, 0x40	; 64
     942:	f6 e0       	ldi	r31, 0x06	; 6
     944:	90 e1       	ldi	r25, 0x10	; 16
     946:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     948:	28 e3       	ldi	r18, 0x38	; 56
     94a:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     94c:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     94e:	81 65       	ori	r24, 0x51	; 81
     950:	a0 ec       	ldi	r26, 0xC0	; 192
     952:	b8 e0       	ldi	r27, 0x08	; 8
     954:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     956:	11 96       	adiw	r26, 0x01	; 1
     958:	1c 92       	st	X, r1
     95a:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     95c:	80 ea       	ldi	r24, 0xA0	; 160
     95e:	81 83       	std	Z+1, r24	; 0x01

	
}
     960:	08 95       	ret

00000962 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     962:	e0 e4       	ldi	r30, 0x40	; 64
     964:	f6 e0       	ldi	r31, 0x06	; 6
     966:	90 e1       	ldi	r25, 0x10	; 16
     968:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     96a:	28 e3       	ldi	r18, 0x38	; 56
     96c:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     96e:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     970:	80 65       	ori	r24, 0x50	; 80
     972:	68 2b       	or	r22, r24
     974:	a0 ec       	ldi	r26, 0xC0	; 192
     976:	b8 e0       	ldi	r27, 0x08	; 8
     978:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     97a:	11 96       	adiw	r26, 0x01	; 1
     97c:	1c 92       	st	X, r1
     97e:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     980:	80 ea       	ldi	r24, 0xA0	; 160
     982:	81 83       	std	Z+1, r24	; 0x01
}
     984:	08 95       	ret

00000986 <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     986:	88 23       	and	r24, r24
     988:	29 f0       	breq	.+10     	; 0x994 <SPICS+0xe>
     98a:	80 e1       	ldi	r24, 0x10	; 16
     98c:	e0 e4       	ldi	r30, 0x40	; 64
     98e:	f6 e0       	ldi	r31, 0x06	; 6
     990:	86 83       	std	Z+6, r24	; 0x06
     992:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     994:	80 e1       	ldi	r24, 0x10	; 16
     996:	e0 e4       	ldi	r30, 0x40	; 64
     998:	f6 e0       	ldi	r31, 0x06	; 6
     99a:	85 83       	std	Z+5, r24	; 0x05
     99c:	08 95       	ret

0000099e <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     99e:	e0 e4       	ldi	r30, 0x40	; 64
     9a0:	f6 e0       	ldi	r31, 0x06	; 6
     9a2:	80 e1       	ldi	r24, 0x10	; 16
     9a4:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     9a6:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     9aa:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     9ac:	80 eb       	ldi	r24, 0xB0	; 176
     9ae:	82 83       	std	Z+2, r24	; 0x02

}
     9b0:	08 95       	ret

000009b2 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     9b2:	cf 93       	push	r28
     9b4:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     9b6:	c8 2f       	mov	r28, r24
     9b8:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     9ba:	d8 2f       	mov	r29, r24
     9bc:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     9be:	28 2f       	mov	r18, r24
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	a9 01       	movw	r20, r18
     9c4:	45 70       	andi	r20, 0x05	; 5
     9c6:	50 70       	andi	r21, 0x00	; 0
     9c8:	41 15       	cp	r20, r1
     9ca:	51 05       	cpc	r21, r1
     9cc:	49 f0       	breq	.+18     	; 0x9e0 <set_filter+0x2e>
     9ce:	90 91 31 3e 	lds	r25, 0x3E31
     9d2:	48 2f       	mov	r20, r24
     9d4:	42 95       	swap	r20
     9d6:	4f 70       	andi	r20, 0x0F	; 15
     9d8:	90 7f       	andi	r25, 0xF0	; 240
     9da:	94 2b       	or	r25, r20
     9dc:	90 93 31 3e 	sts	0x3E31, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     9e0:	2a 70       	andi	r18, 0x0A	; 10
     9e2:	30 70       	andi	r19, 0x00	; 0
     9e4:	21 15       	cp	r18, r1
     9e6:	31 05       	cpc	r19, r1
     9e8:	39 f0       	breq	.+14     	; 0x9f8 <set_filter+0x46>
     9ea:	90 91 31 3e 	lds	r25, 0x3E31
     9ee:	80 7f       	andi	r24, 0xF0	; 240
     9f0:	9f 70       	andi	r25, 0x0F	; 15
     9f2:	89 2b       	or	r24, r25
     9f4:	80 93 31 3e 	sts	0x3E31, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     9f8:	84 e0       	ldi	r24, 0x04	; 4
     9fa:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     9fe:	80 91 31 3e 	lds	r24, 0x3E31
     a02:	80 93 21 3e 	sts	0x3E21, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     a06:	cc 23       	and	r28, r28
     a08:	19 f0       	breq	.+6      	; 0xa10 <set_filter+0x5e>
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	0e 94 88 04 	call	0x910	; 0x910 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     a10:	dd 23       	and	r29, r29
     a12:	19 f0       	breq	.+6      	; 0xa1a <set_filter+0x68>
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	0e 94 94 04 	call	0x928	; 0x928 <upperMuxCS>

	SPICS(TRUE);
     a1a:	81 e0       	ldi	r24, 0x01	; 1
     a1c:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     a20:	8f ef       	ldi	r24, 0xFF	; 255
     a22:	e0 ec       	ldi	r30, 0xC0	; 192
     a24:	f8 e0       	ldi	r31, 0x08	; 8
     a26:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     a28:	82 81       	ldd	r24, Z+2	; 0x02
     a2a:	88 23       	and	r24, r24
     a2c:	ec f7       	brge	.-6      	; 0xa28 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     a2e:	e0 ec       	ldi	r30, 0xC0	; 192
     a30:	f8 e0       	ldi	r31, 0x08	; 8
     a32:	83 81       	ldd	r24, Z+3	; 0x03
     a34:	80 93 2d 3e 	sts	0x3E2D, r24

	nop();
     a38:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     a3a:	ad e2       	ldi	r26, 0x2D	; 45
     a3c:	be e3       	ldi	r27, 0x3E	; 62
     a3e:	1c 97       	sbiw	r26, 0x0c	; 12
     a40:	8c 91       	ld	r24, X
     a42:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     a44:	82 81       	ldd	r24, Z+2	; 0x02
     a46:	88 23       	and	r24, r24
     a48:	ec f7       	brge	.-6      	; 0xa44 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     a4a:	e0 ec       	ldi	r30, 0xC0	; 192
     a4c:	f8 e0       	ldi	r31, 0x08	; 8
     a4e:	83 81       	ldd	r24, Z+3	; 0x03
     a50:	80 93 2d 3e 	sts	0x3E2D, r24
	SPICS(FALSE);
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     a5a:	cc 23       	and	r28, r28
     a5c:	19 f0       	breq	.+6      	; 0xa64 <set_filter+0xb2>
     a5e:	80 e0       	ldi	r24, 0x00	; 0
     a60:	0e 94 88 04 	call	0x910	; 0x910 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     a64:	dd 23       	and	r29, r29
     a66:	19 f0       	breq	.+6      	; 0xa6e <set_filter+0xbc>
     a68:	80 e0       	ldi	r24, 0x00	; 0
     a6a:	0e 94 94 04 	call	0x928	; 0x928 <upperMuxCS>
	SPIDisable();
     a6e:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
}
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
     a76:	08 95       	ret

00000a78 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     a78:	cf 93       	push	r28
     a7a:	df 93       	push	r29
     a7c:	c8 2f       	mov	r28, r24
     a7e:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     a80:	80 e0       	ldi	r24, 0x00	; 0
     a82:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
     a86:	81 e0       	ldi	r24, 0x01	; 1
     a88:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	portExCS(TRUE);
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     a92:	dd 23       	and	r29, r29
     a94:	89 f0       	breq	.+34     	; 0xab8 <PortEx_OUTCLR+0x40>
     a96:	80 91 ac 21 	lds	r24, 0x21AC
     a9a:	c0 95       	com	r28
     a9c:	c8 23       	and	r28, r24
     a9e:	c0 93 ac 21 	sts	0x21AC, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     aa2:	80 e4       	ldi	r24, 0x40	; 64
     aa4:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     aa8:	84 e1       	ldi	r24, 0x14	; 20
     aaa:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankA_OUT;
     aae:	80 91 ac 21 	lds	r24, 0x21AC
     ab2:	80 93 23 3e 	sts	0x3E23, r24
     ab6:	10 c0       	rjmp	.+32     	; 0xad8 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     ab8:	80 91 32 3e 	lds	r24, 0x3E32
     abc:	c0 95       	com	r28
     abe:	c8 23       	and	r28, r24
     ac0:	c0 93 32 3e 	sts	0x3E32, r28
	
	SPIBuffer[0] = PS_WRITE;
     ac4:	80 e4       	ldi	r24, 0x40	; 64
     ac6:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     aca:	85 e1       	ldi	r24, 0x15	; 21
     acc:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankB_OUT; 
     ad0:	80 91 32 3e 	lds	r24, 0x3E32
     ad4:	80 93 23 3e 	sts	0x3E23, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     ad8:	80 e0       	ldi	r24, 0x00	; 0
     ada:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     adc:	21 e2       	ldi	r18, 0x21	; 33
     ade:	3e e3       	ldi	r19, 0x3E	; 62
     ae0:	a0 ec       	ldi	r26, 0xC0	; 192
     ae2:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     ae4:	cd e2       	ldi	r28, 0x2D	; 45
     ae6:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     ae8:	f9 01       	movw	r30, r18
     aea:	e8 0f       	add	r30, r24
     aec:	f9 1f       	adc	r31, r25
     aee:	40 81       	ld	r20, Z
     af0:	13 96       	adiw	r26, 0x03	; 3
     af2:	4c 93       	st	X, r20
     af4:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     af6:	12 96       	adiw	r26, 0x02	; 2
     af8:	4c 91       	ld	r20, X
     afa:	12 97       	sbiw	r26, 0x02	; 2
     afc:	44 23       	and	r20, r20
     afe:	dc f7       	brge	.-10     	; 0xaf6 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     b00:	13 96       	adiw	r26, 0x03	; 3
     b02:	4c 91       	ld	r20, X
     b04:	13 97       	sbiw	r26, 0x03	; 3
     b06:	48 83       	st	Y, r20
     b08:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     b0a:	83 30       	cpi	r24, 0x03	; 3
     b0c:	91 05       	cpc	r25, r1
     b0e:	61 f7       	brne	.-40     	; 0xae8 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     b10:	80 e0       	ldi	r24, 0x00	; 0
     b12:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	portExCS(FALSE);
     b16:	80 e0       	ldi	r24, 0x00	; 0
     b18:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>
	SPIDisable();
     b1c:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
}
     b20:	df 91       	pop	r29
     b22:	cf 91       	pop	r28
     b24:	08 95       	ret

00000b26 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     b26:	cf 93       	push	r28
     b28:	df 93       	push	r29
     b2a:	c8 2f       	mov	r28, r24
     b2c:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     b2e:	80 e0       	ldi	r24, 0x00	; 0
     b30:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
     b34:	81 e0       	ldi	r24, 0x01	; 1
     b36:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	portExCS(TRUE);
     b3a:	81 e0       	ldi	r24, 0x01	; 1
     b3c:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     b40:	dd 23       	and	r29, r29
     b42:	81 f0       	breq	.+32     	; 0xb64 <PortEx_OUTSET+0x3e>
     b44:	80 91 ac 21 	lds	r24, 0x21AC
     b48:	c8 2b       	or	r28, r24
     b4a:	c0 93 ac 21 	sts	0x21AC, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     b4e:	80 e4       	ldi	r24, 0x40	; 64
     b50:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     b54:	84 e1       	ldi	r24, 0x14	; 20
     b56:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankA_OUT;
     b5a:	80 91 ac 21 	lds	r24, 0x21AC
     b5e:	80 93 23 3e 	sts	0x3E23, r24
     b62:	0f c0       	rjmp	.+30     	; 0xb82 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     b64:	80 91 32 3e 	lds	r24, 0x3E32
     b68:	c8 2b       	or	r28, r24
     b6a:	c0 93 32 3e 	sts	0x3E32, r28
	
	SPIBuffer[0] = PS_WRITE;
     b6e:	80 e4       	ldi	r24, 0x40	; 64
     b70:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     b74:	85 e1       	ldi	r24, 0x15	; 21
     b76:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankB_OUT; 
     b7a:	80 91 32 3e 	lds	r24, 0x3E32
     b7e:	80 93 23 3e 	sts	0x3E23, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b86:	21 e2       	ldi	r18, 0x21	; 33
     b88:	3e e3       	ldi	r19, 0x3E	; 62
     b8a:	a0 ec       	ldi	r26, 0xC0	; 192
     b8c:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     b8e:	cd e2       	ldi	r28, 0x2D	; 45
     b90:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b92:	f9 01       	movw	r30, r18
     b94:	e8 0f       	add	r30, r24
     b96:	f9 1f       	adc	r31, r25
     b98:	40 81       	ld	r20, Z
     b9a:	13 96       	adiw	r26, 0x03	; 3
     b9c:	4c 93       	st	X, r20
     b9e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     ba0:	12 96       	adiw	r26, 0x02	; 2
     ba2:	4c 91       	ld	r20, X
     ba4:	12 97       	sbiw	r26, 0x02	; 2
     ba6:	44 23       	and	r20, r20
     ba8:	dc f7       	brge	.-10     	; 0xba0 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     baa:	13 96       	adiw	r26, 0x03	; 3
     bac:	4c 91       	ld	r20, X
     bae:	13 97       	sbiw	r26, 0x03	; 3
     bb0:	48 83       	st	Y, r20
     bb2:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     bb4:	83 30       	cpi	r24, 0x03	; 3
     bb6:	91 05       	cpc	r25, r1
     bb8:	61 f7       	brne	.-40     	; 0xb92 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	portExCS(FALSE);
     bc0:	80 e0       	ldi	r24, 0x00	; 0
     bc2:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>
	SPIDisable();
     bc6:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
}
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	08 95       	ret

00000bd0 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     bd0:	cf 93       	push	r28
     bd2:	df 93       	push	r29
     bd4:	c8 2f       	mov	r28, r24
     bd6:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     bd8:	80 e0       	ldi	r24, 0x00	; 0
     bda:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
     bde:	81 e0       	ldi	r24, 0x01	; 1
     be0:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	portExCS(TRUE);
     be4:	81 e0       	ldi	r24, 0x01	; 1
     be6:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     bea:	dd 23       	and	r29, r29
     bec:	89 f0       	breq	.+34     	; 0xc10 <PortEx_DIRCLR+0x40>
     bee:	80 91 30 3e 	lds	r24, 0x3E30
     bf2:	80 95       	com	r24
     bf4:	c8 23       	and	r28, r24
     bf6:	c0 93 30 3e 	sts	0x3E30, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     bfa:	80 e4       	ldi	r24, 0x40	; 64
     bfc:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     c00:	10 92 22 3e 	sts	0x3E22, r1
		SPIBuffer[2] = ~bankA_DIR; 
     c04:	80 91 30 3e 	lds	r24, 0x3E30
     c08:	80 95       	com	r24
     c0a:	80 93 23 3e 	sts	0x3E23, r24
     c0e:	11 c0       	rjmp	.+34     	; 0xc32 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     c10:	80 91 47 3e 	lds	r24, 0x3E47
     c14:	80 95       	com	r24
     c16:	c8 23       	and	r28, r24
     c18:	c0 93 47 3e 	sts	0x3E47, r28
	
	SPIBuffer[0] = PS_WRITE;
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     c22:	81 e0       	ldi	r24, 0x01	; 1
     c24:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = ~bankB_DIR;
     c28:	80 91 47 3e 	lds	r24, 0x3E47
     c2c:	80 95       	com	r24
     c2e:	80 93 23 3e 	sts	0x3E23, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     c32:	80 e0       	ldi	r24, 0x00	; 0
     c34:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     c36:	21 e2       	ldi	r18, 0x21	; 33
     c38:	3e e3       	ldi	r19, 0x3E	; 62
     c3a:	a0 ec       	ldi	r26, 0xC0	; 192
     c3c:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     c3e:	cd e2       	ldi	r28, 0x2D	; 45
     c40:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     c42:	f9 01       	movw	r30, r18
     c44:	e8 0f       	add	r30, r24
     c46:	f9 1f       	adc	r31, r25
     c48:	40 81       	ld	r20, Z
     c4a:	13 96       	adiw	r26, 0x03	; 3
     c4c:	4c 93       	st	X, r20
     c4e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     c50:	12 96       	adiw	r26, 0x02	; 2
     c52:	4c 91       	ld	r20, X
     c54:	12 97       	sbiw	r26, 0x02	; 2
     c56:	44 23       	and	r20, r20
     c58:	dc f7       	brge	.-10     	; 0xc50 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     c5a:	13 96       	adiw	r26, 0x03	; 3
     c5c:	4c 91       	ld	r20, X
     c5e:	13 97       	sbiw	r26, 0x03	; 3
     c60:	48 83       	st	Y, r20
     c62:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     c64:	83 30       	cpi	r24, 0x03	; 3
     c66:	91 05       	cpc	r25, r1
     c68:	61 f7       	brne	.-40     	; 0xc42 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     c6a:	80 e0       	ldi	r24, 0x00	; 0
     c6c:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	portExCS(FALSE);
     c70:	80 e0       	ldi	r24, 0x00	; 0
     c72:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>
	SPIDisable();
     c76:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
}
     c7a:	df 91       	pop	r29
     c7c:	cf 91       	pop	r28
     c7e:	08 95       	ret

00000c80 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
     c84:	c8 2f       	mov	r28, r24
     c86:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     c88:	80 e0       	ldi	r24, 0x00	; 0
     c8a:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	portExCS(TRUE);
     c94:	81 e0       	ldi	r24, 0x01	; 1
     c96:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     c9a:	dd 23       	and	r29, r29
     c9c:	81 f0       	breq	.+32     	; 0xcbe <PortEx_DIRSET+0x3e>
     c9e:	80 91 30 3e 	lds	r24, 0x3E30
     ca2:	c8 2b       	or	r28, r24
     ca4:	c0 93 30 3e 	sts	0x3E30, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     ca8:	80 e4       	ldi	r24, 0x40	; 64
     caa:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     cae:	10 92 22 3e 	sts	0x3E22, r1
		SPIBuffer[2] = ~bankA_DIR; 
     cb2:	80 91 30 3e 	lds	r24, 0x3E30
     cb6:	80 95       	com	r24
     cb8:	80 93 23 3e 	sts	0x3E23, r24
     cbc:	10 c0       	rjmp	.+32     	; 0xcde <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     cbe:	80 91 47 3e 	lds	r24, 0x3E47
     cc2:	c8 2b       	or	r28, r24
     cc4:	c0 93 47 3e 	sts	0x3E47, r28
	
	SPIBuffer[0] = PS_WRITE;
     cc8:	80 e4       	ldi	r24, 0x40	; 64
     cca:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = ~bankB_DIR;
     cd4:	80 91 47 3e 	lds	r24, 0x3E47
     cd8:	80 95       	com	r24
     cda:	80 93 23 3e 	sts	0x3E23, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     ce2:	21 e2       	ldi	r18, 0x21	; 33
     ce4:	3e e3       	ldi	r19, 0x3E	; 62
     ce6:	a0 ec       	ldi	r26, 0xC0	; 192
     ce8:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     cea:	cd e2       	ldi	r28, 0x2D	; 45
     cec:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     cee:	f9 01       	movw	r30, r18
     cf0:	e8 0f       	add	r30, r24
     cf2:	f9 1f       	adc	r31, r25
     cf4:	40 81       	ld	r20, Z
     cf6:	13 96       	adiw	r26, 0x03	; 3
     cf8:	4c 93       	st	X, r20
     cfa:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     cfc:	12 96       	adiw	r26, 0x02	; 2
     cfe:	4c 91       	ld	r20, X
     d00:	12 97       	sbiw	r26, 0x02	; 2
     d02:	44 23       	and	r20, r20
     d04:	dc f7       	brge	.-10     	; 0xcfc <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     d06:	13 96       	adiw	r26, 0x03	; 3
     d08:	4c 91       	ld	r20, X
     d0a:	13 97       	sbiw	r26, 0x03	; 3
     d0c:	48 83       	st	Y, r20
     d0e:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     d10:	83 30       	cpi	r24, 0x03	; 3
     d12:	91 05       	cpc	r25, r1
     d14:	61 f7       	brne	.-40     	; 0xcee <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	0e 94 2d 04 	call	0x85a	; 0x85a <portExCS>
	SPICS(FALSE);
     d1c:	80 e0       	ldi	r24, 0x00	; 0
     d1e:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
     d22:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>


}
     d26:	df 91       	pop	r29
     d28:	cf 91       	pop	r28
     d2a:	08 95       	ret

00000d2c <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     d2c:	0f 93       	push	r16
     d2e:	1f 93       	push	r17
     d30:	cf 93       	push	r28
     d32:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     d34:	88 23       	and	r24, r24
     d36:	09 f4       	brne	.+2      	; 0xd3a <ADCPower+0xe>
     d38:	4e c0       	rjmp	.+156    	; 0xdd6 <ADCPower+0xaa>
     d3a:	80 91 33 3e 	lds	r24, 0x3E33
     d3e:	88 23       	and	r24, r24
     d40:	09 f0       	breq	.+2      	; 0xd44 <ADCPower+0x18>
     d42:	81 c0       	rjmp	.+258    	; 0xe46 <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     d44:	00 e0       	ldi	r16, 0x00	; 0
     d46:	16 e0       	ldi	r17, 0x06	; 6
     d48:	8e ed       	ldi	r24, 0xDE	; 222
     d4a:	d8 01       	movw	r26, r16
     d4c:	11 96       	adiw	r26, 0x01	; 1
     d4e:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     d50:	c0 e2       	ldi	r28, 0x20	; 32
     d52:	d6 e0       	ldi	r29, 0x06	; 6
     d54:	4e e0       	ldi	r20, 0x0E	; 14
     d56:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     d58:	e0 e4       	ldi	r30, 0x40	; 64
     d5a:	f6 e0       	ldi	r31, 0x06	; 6
     d5c:	63 e0       	ldi	r22, 0x03	; 3
     d5e:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     d60:	80 e8       	ldi	r24, 0x80	; 128
     d62:	96 e0       	ldi	r25, 0x06	; 6
     d64:	50 e1       	ldi	r21, 0x10	; 16
     d66:	dc 01       	movw	r26, r24
     d68:	11 96       	adiw	r26, 0x01	; 1
     d6a:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     d6c:	20 ea       	ldi	r18, 0xA0	; 160
     d6e:	36 e0       	ldi	r19, 0x06	; 6
     d70:	d9 01       	movw	r26, r18
     d72:	11 96       	adiw	r26, 0x01	; 1
     d74:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     d76:	7e e9       	ldi	r23, 0x9E	; 158
     d78:	d8 01       	movw	r26, r16
     d7a:	15 96       	adiw	r26, 0x05	; 5
     d7c:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     d7e:	78 e0       	ldi	r23, 0x08	; 8
     d80:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     d82:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     d84:	ec 01       	movw	r28, r24
     d86:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     d88:	d9 01       	movw	r26, r18
     d8a:	15 96       	adiw	r26, 0x05	; 5
     d8c:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     d8e:	10 92 31 3e 	sts	0x3E31, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d92:	8f ef       	ldi	r24, 0xFF	; 255
     d94:	93 ec       	ldi	r25, 0xC3	; 195
     d96:	a9 e0       	ldi	r26, 0x09	; 9
     d98:	81 50       	subi	r24, 0x01	; 1
     d9a:	90 40       	sbci	r25, 0x00	; 0
     d9c:	a0 40       	sbci	r26, 0x00	; 0
     d9e:	e1 f7       	brne	.-8      	; 0xd98 <ADCPower+0x6c>
     da0:	00 c0       	rjmp	.+0      	; 0xda2 <ADCPower+0x76>
     da2:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     da4:	80 e4       	ldi	r24, 0x40	; 64
     da6:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     da8:	10 92 32 3e 	sts	0x3E32, r1
     dac:	10 92 47 3e 	sts	0x3E47, r1
     db0:	10 92 ac 21 	sts	0x21AC, r1
     db4:	10 92 30 3e 	sts	0x3E30, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     db8:	8f ef       	ldi	r24, 0xFF	; 255
     dba:	61 e0       	ldi	r22, 0x01	; 1
     dbc:	0e 94 40 06 	call	0xc80	; 0xc80 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     dc0:	8f ef       	ldi	r24, 0xFF	; 255
     dc2:	61 e0       	ldi	r22, 0x01	; 1
     dc4:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     dc8:	8f ef       	ldi	r24, 0xFF	; 255
     dca:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <set_filter>
		ADC_POWER_ON = TRUE;
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	80 93 33 3e 	sts	0x3E33, r24
     dd4:	38 c0       	rjmp	.+112    	; 0xe46 <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     dd6:	80 91 33 3e 	lds	r24, 0x3E33
     dda:	88 23       	and	r24, r24
     ddc:	a1 f1       	breq	.+104    	; 0xe46 <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     dde:	00 e0       	ldi	r16, 0x00	; 0
     de0:	16 e0       	ldi	r17, 0x06	; 6
     de2:	7e ed       	ldi	r23, 0xDE	; 222
     de4:	d8 01       	movw	r26, r16
     de6:	16 96       	adiw	r26, 0x06	; 6
     de8:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     dea:	a0 e2       	ldi	r26, 0x20	; 32
     dec:	b6 e0       	ldi	r27, 0x06	; 6
     dee:	4e e0       	ldi	r20, 0x0E	; 14
     df0:	16 96       	adiw	r26, 0x06	; 6
     df2:	4c 93       	st	X, r20
     df4:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     df6:	20 e4       	ldi	r18, 0x40	; 64
     df8:	36 e0       	ldi	r19, 0x06	; 6
     dfa:	63 e0       	ldi	r22, 0x03	; 3
     dfc:	e9 01       	movw	r28, r18
     dfe:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     e00:	c0 e8       	ldi	r28, 0x80	; 128
     e02:	d6 e0       	ldi	r29, 0x06	; 6
     e04:	50 e1       	ldi	r21, 0x10	; 16
     e06:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     e08:	80 ea       	ldi	r24, 0xA0	; 160
     e0a:	96 e0       	ldi	r25, 0x06	; 6
     e0c:	fc 01       	movw	r30, r24
     e0e:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     e10:	f8 01       	movw	r30, r16
     e12:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     e14:	12 96       	adiw	r26, 0x02	; 2
     e16:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     e18:	d9 01       	movw	r26, r18
     e1a:	12 96       	adiw	r26, 0x02	; 2
     e1c:	6c 93       	st	X, r22
     e1e:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     e20:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     e22:	ec 01       	movw	r28, r24
     e24:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     e26:	80 e4       	ldi	r24, 0x40	; 64
     e28:	12 96       	adiw	r26, 0x02	; 2
     e2a:	8c 93       	st	X, r24
     e2c:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     e2e:	10 92 32 3e 	sts	0x3E32, r1
     e32:	10 92 47 3e 	sts	0x3E47, r1
     e36:	10 92 ac 21 	sts	0x21AC, r1
     e3a:	10 92 30 3e 	sts	0x3E30, r1
		channelStatus = 0x00;
     e3e:	10 92 31 3e 	sts	0x3E31, r1
		ADC_POWER_ON = FALSE;
     e42:	10 92 33 3e 	sts	0x3E33, r1
	}
}
     e46:	df 91       	pop	r29
     e48:	cf 91       	pop	r28
     e4a:	1f 91       	pop	r17
     e4c:	0f 91       	pop	r16
     e4e:	08 95       	ret

00000e50 <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     e50:	2f 92       	push	r2
     e52:	3f 92       	push	r3
     e54:	4f 92       	push	r4
     e56:	5f 92       	push	r5
     e58:	6f 92       	push	r6
     e5a:	7f 92       	push	r7
     e5c:	8f 92       	push	r8
     e5e:	9f 92       	push	r9
     e60:	af 92       	push	r10
     e62:	bf 92       	push	r11
     e64:	cf 92       	push	r12
     e66:	df 92       	push	r13
     e68:	ef 92       	push	r14
     e6a:	ff 92       	push	r15
     e6c:	0f 93       	push	r16
     e6e:	1f 93       	push	r17
     e70:	cf 93       	push	r28
     e72:	df 93       	push	r29
     e74:	cd b7       	in	r28, 0x3d	; 61
     e76:	de b7       	in	r29, 0x3e	; 62
     e78:	64 97       	sbiw	r28, 0x14	; 20
     e7a:	cd bf       	out	0x3d, r28	; 61
     e7c:	de bf       	out	0x3e, r29	; 62
     e7e:	2a 01       	movw	r4, r20
     e80:	3b 01       	movw	r6, r22
     e82:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     e84:	f9 01       	movw	r30, r18
     e86:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     e88:	41 15       	cp	r20, r1
     e8a:	51 05       	cpc	r21, r1
     e8c:	61 05       	cpc	r22, r1
     e8e:	71 05       	cpc	r23, r1
     e90:	09 f4       	brne	.+2      	; 0xe94 <DeciToString+0x44>
     e92:	4d c0       	rjmp	.+154    	; 0xf2e <DeciToString+0xde>
     e94:	88 2e       	mov	r8, r24
     e96:	99 2e       	mov	r9, r25
     e98:	cc 24       	eor	r12, r12
     e9a:	dd 24       	eor	r13, r13
     e9c:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     e9e:	5e 01       	movw	r10, r28
     ea0:	08 94       	sec
     ea2:	a1 1c       	adc	r10, r1
     ea4:	b1 1c       	adc	r11, r1
     ea6:	0f 2e       	mov	r0, r31
     ea8:	f0 e0       	ldi	r31, 0x00	; 0
     eaa:	2f 2e       	mov	r2, r31
     eac:	f0 e2       	ldi	r31, 0x20	; 32
     eae:	3f 2e       	mov	r3, r31
     eb0:	f0 2d       	mov	r31, r0
     eb2:	f4 01       	movw	r30, r8
     eb4:	81 91       	ld	r24, Z+
     eb6:	91 91       	ld	r25, Z+
     eb8:	a1 91       	ld	r26, Z+
     eba:	b1 91       	ld	r27, Z+
     ebc:	4f 01       	movw	r8, r30
     ebe:	2d b7       	in	r18, 0x3d	; 61
     ec0:	3e b7       	in	r19, 0x3e	; 62
     ec2:	28 50       	subi	r18, 0x08	; 8
     ec4:	30 40       	sbci	r19, 0x00	; 0
     ec6:	2d bf       	out	0x3d, r18	; 61
     ec8:	3e bf       	out	0x3e, r19	; 62
     eca:	2f 5f       	subi	r18, 0xFF	; 255
     ecc:	3f 4f       	sbci	r19, 0xFF	; 255
     ece:	ed b7       	in	r30, 0x3d	; 61
     ed0:	fe b7       	in	r31, 0x3e	; 62
     ed2:	a1 82       	std	Z+1, r10	; 0x01
     ed4:	b2 82       	std	Z+2, r11	; 0x02
     ed6:	f9 01       	movw	r30, r18
     ed8:	22 82       	std	Z+2, r2	; 0x02
     eda:	33 82       	std	Z+3, r3	; 0x03
     edc:	84 83       	std	Z+4, r24	; 0x04
     ede:	95 83       	std	Z+5, r25	; 0x05
     ee0:	a6 83       	std	Z+6, r26	; 0x06
     ee2:	b7 83       	std	Z+7, r27	; 0x07
     ee4:	0e 94 b3 38 	call	0x7166	; 0x7166 <sprintf>
		strcat(ReturnString,b);
     ee8:	2d b7       	in	r18, 0x3d	; 61
     eea:	3e b7       	in	r19, 0x3e	; 62
     eec:	28 5f       	subi	r18, 0xF8	; 248
     eee:	3f 4f       	sbci	r19, 0xFF	; 255
     ef0:	2d bf       	out	0x3d, r18	; 61
     ef2:	3e bf       	out	0x3e, r19	; 62
     ef4:	c8 01       	movw	r24, r16
     ef6:	b5 01       	movw	r22, r10
     ef8:	0e 94 75 38 	call	0x70ea	; 0x70ea <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     efc:	a0 2f       	mov	r26, r16
     efe:	b1 2f       	mov	r27, r17
     f00:	fd 01       	movw	r30, r26
     f02:	01 90       	ld	r0, Z+
     f04:	00 20       	and	r0, r0
     f06:	e9 f7       	brne	.-6      	; 0xf02 <DeciToString+0xb2>
     f08:	31 97       	sbiw	r30, 0x01	; 1
     f0a:	ea 1b       	sub	r30, r26
     f0c:	fb 0b       	sbc	r31, r27
     f0e:	e0 0f       	add	r30, r16
     f10:	f1 1f       	adc	r31, r17
     f12:	8a e0       	ldi	r24, 0x0A	; 10
     f14:	90 e0       	ldi	r25, 0x00	; 0
     f16:	80 83       	st	Z, r24
     f18:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     f1a:	08 94       	sec
     f1c:	c1 1c       	adc	r12, r1
     f1e:	d1 1c       	adc	r13, r1
     f20:	e1 1c       	adc	r14, r1
     f22:	f1 1c       	adc	r15, r1
     f24:	c4 14       	cp	r12, r4
     f26:	d5 04       	cpc	r13, r5
     f28:	e6 04       	cpc	r14, r6
     f2a:	f7 04       	cpc	r15, r7
     f2c:	11 f6       	brne	.-124    	; 0xeb2 <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     f2e:	64 96       	adiw	r28, 0x14	; 20
     f30:	cd bf       	out	0x3d, r28	; 61
     f32:	de bf       	out	0x3e, r29	; 62
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	1f 91       	pop	r17
     f3a:	0f 91       	pop	r16
     f3c:	ff 90       	pop	r15
     f3e:	ef 90       	pop	r14
     f40:	df 90       	pop	r13
     f42:	cf 90       	pop	r12
     f44:	bf 90       	pop	r11
     f46:	af 90       	pop	r10
     f48:	9f 90       	pop	r9
     f4a:	8f 90       	pop	r8
     f4c:	7f 90       	pop	r7
     f4e:	6f 90       	pop	r6
     f50:	5f 90       	pop	r5
     f52:	4f 90       	pop	r4
     f54:	3f 90       	pop	r3
     f56:	2f 90       	pop	r2
     f58:	08 95       	ret

00000f5a <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     f5a:	e0 ec       	ldi	r30, 0xC0	; 192
     f5c:	f8 e0       	ldi	r31, 0x08	; 8
     f5e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     f60:	82 81       	ldd	r24, Z+2	; 0x02
     f62:	88 23       	and	r24, r24
     f64:	ec f7       	brge	.-6      	; 0xf60 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     f66:	e0 ec       	ldi	r30, 0xC0	; 192
     f68:	f8 e0       	ldi	r31, 0x08	; 8
     f6a:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     f6c:	08 95       	ret

00000f6e <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	8c 01       	movw	r16, r24
	moteID = 1;
     f76:	c1 e0       	ldi	r28, 0x01	; 1
     f78:	c0 93 46 3e 	sts	0x3E46, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     f7c:	83 e0       	ldi	r24, 0x03	; 3
     f7e:	80 93 20 3e 	sts	0x3E20, r24
	chb_init();
     f82:	0e 94 80 18 	call	0x3100	; 0x3100 <chb_init>
	chb_set_short_addr(moteID);
     f86:	80 91 46 3e 	lds	r24, 0x3E46
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	0e 94 a3 1a 	call	0x3546	; 0x3546 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     f90:	88 ec       	ldi	r24, 0xC8	; 200
     f92:	e0 e8       	ldi	r30, 0x80	; 128
     f94:	f1 e0       	ldi	r31, 0x01	; 1
     f96:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     f98:	e0 e4       	ldi	r30, 0x40	; 64
     f9a:	f9 e0       	ldi	r31, 0x09	; 9
     f9c:	89 e0       	ldi	r24, 0x09	; 9
     f9e:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     fa0:	82 e0       	ldi	r24, 0x02	; 2
     fa2:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     fa4:	24 ef       	ldi	r18, 0xF4	; 244
     fa6:	31 e0       	ldi	r19, 0x01	; 1
     fa8:	02 9f       	mul	r16, r18
     faa:	c0 01       	movw	r24, r0
     fac:	03 9f       	mul	r16, r19
     fae:	90 0d       	add	r25, r0
     fb0:	12 9f       	mul	r17, r18
     fb2:	90 0d       	add	r25, r0
     fb4:	11 24       	eor	r1, r1
     fb6:	86 a3       	lds	r24, 0x56
     fb8:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     fba:	e0 e4       	ldi	r30, 0x40	; 64
     fbc:	f8 e0       	ldi	r31, 0x08	; 8
     fbe:	80 e0       	ldi	r24, 0x00	; 0
     fc0:	9a ef       	ldi	r25, 0xFA	; 250
     fc2:	86 a3       	lds	r24, 0x56
     fc4:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     fc6:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     fc8:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     fca:	e0 ea       	ldi	r30, 0xA0	; 160
     fcc:	f0 e0       	ldi	r31, 0x00	; 0
     fce:	82 81       	ldd	r24, Z+2	; 0x02
     fd0:	87 60       	ori	r24, 0x07	; 7
     fd2:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     fd4:	78 94       	sei
}
     fd6:	cf 91       	pop	r28
     fd8:	1f 91       	pop	r17
     fda:	0f 91       	pop	r16
     fdc:	08 95       	ret

00000fde <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     fde:	78 94       	sei
     fe0:	1f 92       	push	r1
     fe2:	0f 92       	push	r0
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	0f 92       	push	r0
     fe8:	0b b6       	in	r0, 0x3b	; 59
     fea:	0f 92       	push	r0
     fec:	11 24       	eor	r1, r1
     fee:	ef 92       	push	r14
     ff0:	ff 92       	push	r15
     ff2:	0f 93       	push	r16
     ff4:	1f 93       	push	r17
     ff6:	2f 93       	push	r18
     ff8:	3f 93       	push	r19
     ffa:	4f 93       	push	r20
     ffc:	5f 93       	push	r21
     ffe:	6f 93       	push	r22
    1000:	7f 93       	push	r23
    1002:	8f 93       	push	r24
    1004:	9f 93       	push	r25
    1006:	af 93       	push	r26
    1008:	bf 93       	push	r27
    100a:	ef 93       	push	r30
    100c:	ff 93       	push	r31
    100e:	cf 93       	push	r28
    1010:	df 93       	push	r29
    1012:	cd b7       	in	r28, 0x3d	; 61
    1014:	de b7       	in	r29, 0x3e	; 62
    1016:	28 97       	sbiw	r28, 0x08	; 8
    1018:	cd bf       	out	0x3d, r28	; 61
    101a:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    101c:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    1020:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    1024:	82 e0       	ldi	r24, 0x02	; 2
    1026:	80 93 20 3e 	sts	0x3E20, r24
	char message[8];
	strcpy(message,"reset");
    102a:	de 01       	movw	r26, r28
    102c:	11 96       	adiw	r26, 0x01	; 1
    102e:	e4 e0       	ldi	r30, 0x04	; 4
    1030:	f0 e2       	ldi	r31, 0x20	; 32
    1032:	86 e0       	ldi	r24, 0x06	; 6
    1034:	01 90       	ld	r0, Z+
    1036:	0d 92       	st	X+, r0
    1038:	81 50       	subi	r24, 0x01	; 1
    103a:	e1 f7       	brne	.-8      	; 0x1034 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    103c:	0a ea       	ldi	r16, 0xAA	; 170
    103e:	10 e5       	ldi	r17, 0x50	; 80
    1040:	80 91 46 3e 	lds	r24, 0x3E46
    1044:	90 e0       	ldi	r25, 0x00	; 0
    1046:	b8 01       	movw	r22, r16
    1048:	4a e0       	ldi	r20, 0x0A	; 10
    104a:	50 e0       	ldi	r21, 0x00	; 0
    104c:	0e 94 80 38 	call	0x7100	; 0x7100 <itoa>
	strcat(message,buff);
    1050:	7e 01       	movw	r14, r28
    1052:	08 94       	sec
    1054:	e1 1c       	adc	r14, r1
    1056:	f1 1c       	adc	r15, r1
    1058:	c7 01       	movw	r24, r14
    105a:	b8 01       	movw	r22, r16
    105c:	0e 94 75 38 	call	0x70ea	; 0x70ea <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    1060:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    1064:	f7 01       	movw	r30, r14
    1066:	01 90       	ld	r0, Z+
    1068:	00 20       	and	r0, r0
    106a:	e9 f7       	brne	.-6      	; 0x1066 <__vector_83+0x88>
    106c:	31 97       	sbiw	r30, 0x01	; 1
    106e:	ee 19       	sub	r30, r14
    1070:	ff 09       	sbc	r31, r15
    1072:	9f 01       	movw	r18, r30
    1074:	40 e0       	ldi	r20, 0x00	; 0
    1076:	50 e0       	ldi	r21, 0x00	; 0
    1078:	80 e0       	ldi	r24, 0x00	; 0
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	b7 01       	movw	r22, r14
    107e:	0e 94 a4 18 	call	0x3148	; 0x3148 <chb_write>
}	
    1082:	28 96       	adiw	r28, 0x08	; 8
    1084:	cd bf       	out	0x3d, r28	; 61
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	df 91       	pop	r29
    108a:	cf 91       	pop	r28
    108c:	ff 91       	pop	r31
    108e:	ef 91       	pop	r30
    1090:	bf 91       	pop	r27
    1092:	af 91       	pop	r26
    1094:	9f 91       	pop	r25
    1096:	8f 91       	pop	r24
    1098:	7f 91       	pop	r23
    109a:	6f 91       	pop	r22
    109c:	5f 91       	pop	r21
    109e:	4f 91       	pop	r20
    10a0:	3f 91       	pop	r19
    10a2:	2f 91       	pop	r18
    10a4:	1f 91       	pop	r17
    10a6:	0f 91       	pop	r16
    10a8:	ff 90       	pop	r15
    10aa:	ef 90       	pop	r14
    10ac:	0f 90       	pop	r0
    10ae:	0b be       	out	0x3b, r0	; 59
    10b0:	0f 90       	pop	r0
    10b2:	0f be       	out	0x3f, r0	; 63
    10b4:	0f 90       	pop	r0
    10b6:	1f 90       	pop	r1
    10b8:	18 95       	reti

000010ba <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    10ba:	4f 92       	push	r4
    10bc:	5f 92       	push	r5
    10be:	6f 92       	push	r6
    10c0:	7f 92       	push	r7
    10c2:	8f 92       	push	r8
    10c4:	9f 92       	push	r9
    10c6:	af 92       	push	r10
    10c8:	bf 92       	push	r11
    10ca:	ef 92       	push	r14
    10cc:	ff 92       	push	r15
    10ce:	0f 93       	push	r16
    10d0:	1f 93       	push	r17
    10d2:	cf 93       	push	r28
    10d4:	df 93       	push	r29
    10d6:	cd b7       	in	r28, 0x3d	; 61
    10d8:	de b7       	in	r29, 0x3e	; 62
    10da:	2b 97       	sbiw	r28, 0x0b	; 11
    10dc:	cd bf       	out	0x3d, r28	; 61
    10de:	de bf       	out	0x3e, r29	; 62
    10e0:	8e 83       	std	Y+6, r24	; 0x06
    10e2:	9f 83       	std	Y+7, r25	; 0x07
    10e4:	68 87       	std	Y+8, r22	; 0x08
    10e6:	79 87       	std	Y+9, r23	; 0x09
    10e8:	4a 87       	std	Y+10, r20	; 0x0a
    10ea:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    10f2:	80 e0       	ldi	r24, 0x00	; 0
    10f4:	92 e0       	ldi	r25, 0x02	; 2
    10f6:	0e 94 63 18 	call	0x30c6	; 0x30c6 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    10fa:	00 e0       	ldi	r16, 0x00	; 0
    10fc:	12 e0       	ldi	r17, 0x02	; 2
    10fe:	d8 01       	movw	r26, r16
    1100:	11 96       	adiw	r26, 0x01	; 1
    1102:	8c 91       	ld	r24, X
    1104:	11 97       	sbiw	r26, 0x01	; 1
    1106:	89 7e       	andi	r24, 0xE9	; 233
    1108:	11 96       	adiw	r26, 0x01	; 1
    110a:	8c 93       	st	X, r24
    110c:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    110e:	14 96       	adiw	r26, 0x04	; 4
    1110:	8c 91       	ld	r24, X
    1112:	14 97       	sbiw	r26, 0x04	; 4
    1114:	88 7f       	andi	r24, 0xF8	; 248
    1116:	83 60       	ori	r24, 0x03	; 3
    1118:	14 96       	adiw	r26, 0x04	; 4
    111a:	8c 93       	st	X, r24
    111c:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    111e:	12 96       	adiw	r26, 0x02	; 2
    1120:	8c 91       	ld	r24, X
    1122:	12 97       	sbiw	r26, 0x02	; 2
    1124:	8f 7c       	andi	r24, 0xCF	; 207
    1126:	12 96       	adiw	r26, 0x02	; 2
    1128:	8c 93       	st	X, r24
    112a:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    112c:	0f 2e       	mov	r0, r31
    112e:	f0 e2       	ldi	r31, 0x20	; 32
    1130:	ef 2e       	mov	r14, r31
    1132:	f2 e0       	ldi	r31, 0x02	; 2
    1134:	ff 2e       	mov	r15, r31
    1136:	f0 2d       	mov	r31, r0
    1138:	f7 01       	movw	r30, r14
    113a:	80 81       	ld	r24, Z
    113c:	80 7e       	andi	r24, 0xE0	; 224
    113e:	81 60       	ori	r24, 0x01	; 1
    1140:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1142:	89 e0       	ldi	r24, 0x09	; 9
    1144:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    1146:	8c 91       	ld	r24, X
    1148:	81 60       	ori	r24, 0x01	; 1
    114a:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    114c:	80 e0       	ldi	r24, 0x00	; 0
    114e:	92 e0       	ldi	r25, 0x02	; 2
    1150:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    1154:	80 e0       	ldi	r24, 0x00	; 0
    1156:	92 e0       	ldi	r25, 0x02	; 2
    1158:	60 e2       	ldi	r22, 0x20	; 32
    115a:	72 e0       	ldi	r23, 0x02	; 2
    115c:	40 e0       	ldi	r20, 0x00	; 0
    115e:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <ADC_Offset_Get_Unsigned>
    1162:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    1164:	d8 01       	movw	r26, r16
    1166:	8c 91       	ld	r24, X
    1168:	8e 7f       	andi	r24, 0xFE	; 254
    116a:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    116c:	f7 01       	movw	r30, r14
    116e:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    1170:	13 96       	adiw	r26, 0x03	; 3
    1172:	8c 91       	ld	r24, X
    1174:	13 97       	sbiw	r26, 0x03	; 3
    1176:	8f 73       	andi	r24, 0x3F	; 63
    1178:	13 96       	adiw	r26, 0x03	; 3
    117a:	8c 93       	st	X, r24
    117c:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    117e:	8c 91       	ld	r24, X
    1180:	81 60       	ori	r24, 0x01	; 1
    1182:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1184:	80 e0       	ldi	r24, 0x00	; 0
    1186:	92 e0       	ldi	r25, 0x02	; 2
    1188:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    118c:	d8 01       	movw	r26, r16
    118e:	11 96       	adiw	r26, 0x01	; 1
    1190:	8c 91       	ld	r24, X
    1192:	11 97       	sbiw	r26, 0x01	; 1
    1194:	88 60       	ori	r24, 0x08	; 8
    1196:	11 96       	adiw	r26, 0x01	; 1
    1198:	8c 93       	st	X, r24
    119a:	ee 24       	eor	r14, r14
    119c:	ff 24       	eor	r15, r15
    119e:	68 94       	set
    11a0:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    11a2:	44 24       	eor	r4, r4
    11a4:	55 24       	eor	r5, r5
    11a6:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    11a8:	20 e0       	ldi	r18, 0x00	; 0
    11aa:	30 e1       	ldi	r19, 0x10	; 16
    11ac:	40 e0       	ldi	r20, 0x00	; 0
    11ae:	50 e0       	ldi	r21, 0x00	; 0
    11b0:	2a 83       	std	Y+2, r18	; 0x02
    11b2:	3b 83       	std	Y+3, r19	; 0x03
    11b4:	4c 83       	std	Y+4, r20	; 0x04
    11b6:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    11b8:	88 24       	eor	r8, r8
    11ba:	99 24       	eor	r9, r9
    11bc:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    11be:	00 e2       	ldi	r16, 0x20	; 32
    11c0:	12 e0       	ldi	r17, 0x02	; 2
    11c2:	d8 01       	movw	r26, r16
    11c4:	13 96       	adiw	r26, 0x03	; 3
    11c6:	8c 91       	ld	r24, X
    11c8:	13 97       	sbiw	r26, 0x03	; 3
    11ca:	80 ff       	sbrs	r24, 0
    11cc:	fa cf       	rjmp	.-12     	; 0x11c2 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    11ce:	69 81       	ldd	r22, Y+1	; 0x01
    11d0:	c8 01       	movw	r24, r16
    11d2:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    11d6:	a0 e0       	ldi	r26, 0x00	; 0
    11d8:	b0 e0       	ldi	r27, 0x00	; 0
    11da:	88 0e       	add	r8, r24
    11dc:	99 1e       	adc	r9, r25
    11de:	aa 1e       	adc	r10, r26
    11e0:	bb 1e       	adc	r11, r27
    11e2:	48 16       	cp	r4, r24
    11e4:	59 06       	cpc	r5, r25
    11e6:	6a 06       	cpc	r6, r26
    11e8:	7b 06       	cpc	r7, r27
    11ea:	10 f4       	brcc	.+4      	; 0x11f0 <CO_collectTemp+0x136>
    11ec:	2c 01       	movw	r4, r24
    11ee:	3d 01       	movw	r6, r26
    11f0:	2a 81       	ldd	r18, Y+2	; 0x02
    11f2:	3b 81       	ldd	r19, Y+3	; 0x03
    11f4:	4c 81       	ldd	r20, Y+4	; 0x04
    11f6:	5d 81       	ldd	r21, Y+5	; 0x05
    11f8:	82 17       	cp	r24, r18
    11fa:	93 07       	cpc	r25, r19
    11fc:	a4 07       	cpc	r26, r20
    11fe:	b5 07       	cpc	r27, r21
    1200:	20 f4       	brcc	.+8      	; 0x120a <CO_collectTemp+0x150>
    1202:	8a 83       	std	Y+2, r24	; 0x02
    1204:	9b 83       	std	Y+3, r25	; 0x03
    1206:	ac 83       	std	Y+4, r26	; 0x04
    1208:	bd 83       	std	Y+5, r27	; 0x05
    120a:	08 94       	sec
    120c:	e1 08       	sbc	r14, r1
    120e:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1210:	e1 14       	cp	r14, r1
    1212:	f1 04       	cpc	r15, r1
    1214:	b1 f6       	brne	.-84     	; 0x11c2 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    1216:	e0 e0       	ldi	r30, 0x00	; 0
    1218:	f2 e0       	ldi	r31, 0x02	; 2
    121a:	81 81       	ldd	r24, Z+1	; 0x01
    121c:	87 7f       	andi	r24, 0xF7	; 247
    121e:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    1220:	80 81       	ld	r24, Z
    1222:	82 60       	ori	r24, 0x02	; 2
    1224:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    1226:	80 81       	ld	r24, Z
    1228:	8e 7f       	andi	r24, 0xFE	; 254
    122a:	80 83       	st	Z, r24

	ADCPower(FALSE);
    122c:	80 e0       	ldi	r24, 0x00	; 0
    122e:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>

	average = sum / NUM_SAMPLES;
    1232:	c5 01       	movw	r24, r10
    1234:	b4 01       	movw	r22, r8
    1236:	05 2e       	mov	r0, r21
    1238:	5a e0       	ldi	r21, 0x0A	; 10
    123a:	96 95       	lsr	r25
    123c:	87 95       	ror	r24
    123e:	77 95       	ror	r23
    1240:	67 95       	ror	r22
    1242:	5a 95       	dec	r21
    1244:	d1 f7       	brne	.-12     	; 0x123a <CO_collectTemp+0x180>
    1246:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1248:	28 ee       	ldi	r18, 0xE8	; 232
    124a:	33 e0       	ldi	r19, 0x03	; 3
    124c:	40 e0       	ldi	r20, 0x00	; 0
    124e:	50 e0       	ldi	r21, 0x00	; 0
    1250:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    1254:	0f 2e       	mov	r0, r31
    1256:	ff ef       	ldi	r31, 0xFF	; 255
    1258:	8f 2e       	mov	r8, r31
    125a:	ff e0       	ldi	r31, 0x0F	; 15
    125c:	9f 2e       	mov	r9, r31
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	af 2e       	mov	r10, r31
    1262:	f0 e0       	ldi	r31, 0x00	; 0
    1264:	bf 2e       	mov	r11, r31
    1266:	f0 2d       	mov	r31, r0
    1268:	a5 01       	movw	r20, r10
    126a:	94 01       	movw	r18, r8
    126c:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    1270:	c9 01       	movw	r24, r18
    1272:	c2 97       	sbiw	r24, 0x32	; 50
    1274:	ae 81       	ldd	r26, Y+6	; 0x06
    1276:	bf 81       	ldd	r27, Y+7	; 0x07
    1278:	8d 93       	st	X+, r24
    127a:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    127c:	c3 01       	movw	r24, r6
    127e:	b2 01       	movw	r22, r4
    1280:	28 ee       	ldi	r18, 0xE8	; 232
    1282:	33 e0       	ldi	r19, 0x03	; 3
    1284:	40 e0       	ldi	r20, 0x00	; 0
    1286:	50 e0       	ldi	r21, 0x00	; 0
    1288:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    128c:	a5 01       	movw	r20, r10
    128e:	94 01       	movw	r18, r8
    1290:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    1294:	c9 01       	movw	r24, r18
    1296:	c2 97       	sbiw	r24, 0x32	; 50
    1298:	ea 85       	ldd	r30, Y+10	; 0x0a
    129a:	fb 85       	ldd	r31, Y+11	; 0x0b
    129c:	80 83       	st	Z, r24
    129e:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    12a0:	6a 81       	ldd	r22, Y+2	; 0x02
    12a2:	7b 81       	ldd	r23, Y+3	; 0x03
    12a4:	8c 81       	ldd	r24, Y+4	; 0x04
    12a6:	9d 81       	ldd	r25, Y+5	; 0x05
    12a8:	28 ee       	ldi	r18, 0xE8	; 232
    12aa:	33 e0       	ldi	r19, 0x03	; 3
    12ac:	40 e0       	ldi	r20, 0x00	; 0
    12ae:	50 e0       	ldi	r21, 0x00	; 0
    12b0:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    12b4:	a5 01       	movw	r20, r10
    12b6:	94 01       	movw	r18, r8
    12b8:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    12bc:	22 53       	subi	r18, 0x32	; 50
    12be:	30 40       	sbci	r19, 0x00	; 0
    12c0:	a8 85       	ldd	r26, Y+8	; 0x08
    12c2:	b9 85       	ldd	r27, Y+9	; 0x09
    12c4:	2d 93       	st	X+, r18
    12c6:	3c 93       	st	X, r19
    12c8:	11 97       	sbiw	r26, 0x01	; 1
}
    12ca:	2b 96       	adiw	r28, 0x0b	; 11
    12cc:	cd bf       	out	0x3d, r28	; 61
    12ce:	de bf       	out	0x3e, r29	; 62
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	bf 90       	pop	r11
    12de:	af 90       	pop	r10
    12e0:	9f 90       	pop	r9
    12e2:	8f 90       	pop	r8
    12e4:	7f 90       	pop	r7
    12e6:	6f 90       	pop	r6
    12e8:	5f 90       	pop	r5
    12ea:	4f 90       	pop	r4
    12ec:	08 95       	ret

000012ee <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    12ee:	4f 92       	push	r4
    12f0:	5f 92       	push	r5
    12f2:	6f 92       	push	r6
    12f4:	7f 92       	push	r7
    12f6:	8f 92       	push	r8
    12f8:	9f 92       	push	r9
    12fa:	af 92       	push	r10
    12fc:	bf 92       	push	r11
    12fe:	ef 92       	push	r14
    1300:	ff 92       	push	r15
    1302:	0f 93       	push	r16
    1304:	1f 93       	push	r17
    1306:	cf 93       	push	r28
    1308:	df 93       	push	r29
    130a:	cd b7       	in	r28, 0x3d	; 61
    130c:	de b7       	in	r29, 0x3e	; 62
    130e:	2b 97       	sbiw	r28, 0x0b	; 11
    1310:	cd bf       	out	0x3d, r28	; 61
    1312:	de bf       	out	0x3e, r29	; 62
    1314:	8e 83       	std	Y+6, r24	; 0x06
    1316:	9f 83       	std	Y+7, r25	; 0x07
    1318:	68 87       	std	Y+8, r22	; 0x08
    131a:	79 87       	std	Y+9, r23	; 0x09
    131c:	4a 87       	std	Y+10, r20	; 0x0a
    131e:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    1320:	81 e0       	ldi	r24, 0x01	; 1
    1322:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    1326:	84 e0       	ldi	r24, 0x04	; 4
    1328:	60 e0       	ldi	r22, 0x00	; 0
    132a:	0e 94 40 06 	call	0xc80	; 0xc80 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    132e:	84 e0       	ldi	r24, 0x04	; 4
    1330:	60 e0       	ldi	r22, 0x00	; 0
    1332:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
    1336:	2f ef       	ldi	r18, 0xFF	; 255
    1338:	33 ec       	ldi	r19, 0xC3	; 195
    133a:	49 e0       	ldi	r20, 0x09	; 9
    133c:	21 50       	subi	r18, 0x01	; 1
    133e:	30 40       	sbci	r19, 0x00	; 0
    1340:	40 40       	sbci	r20, 0x00	; 0
    1342:	e1 f7       	brne	.-8      	; 0x133c <CO_collectBatt+0x4e>
    1344:	00 c0       	rjmp	.+0      	; 0x1346 <CO_collectBatt+0x58>
    1346:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    1348:	80 e4       	ldi	r24, 0x40	; 64
    134a:	92 e0       	ldi	r25, 0x02	; 2
    134c:	0e 94 63 18 	call	0x30c6	; 0x30c6 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    1350:	00 e4       	ldi	r16, 0x40	; 64
    1352:	12 e0       	ldi	r17, 0x02	; 2
    1354:	d8 01       	movw	r26, r16
    1356:	11 96       	adiw	r26, 0x01	; 1
    1358:	8c 91       	ld	r24, X
    135a:	11 97       	sbiw	r26, 0x01	; 1
    135c:	89 7e       	andi	r24, 0xE9	; 233
    135e:	11 96       	adiw	r26, 0x01	; 1
    1360:	8c 93       	st	X, r24
    1362:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    1364:	14 96       	adiw	r26, 0x04	; 4
    1366:	8c 91       	ld	r24, X
    1368:	14 97       	sbiw	r26, 0x04	; 4
    136a:	88 7f       	andi	r24, 0xF8	; 248
    136c:	83 60       	ori	r24, 0x03	; 3
    136e:	14 96       	adiw	r26, 0x04	; 4
    1370:	8c 93       	st	X, r24
    1372:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    1374:	12 96       	adiw	r26, 0x02	; 2
    1376:	8c 91       	ld	r24, X
    1378:	12 97       	sbiw	r26, 0x02	; 2
    137a:	8f 7c       	andi	r24, 0xCF	; 207
    137c:	12 96       	adiw	r26, 0x02	; 2
    137e:	8c 93       	st	X, r24
    1380:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    1382:	0f 2e       	mov	r0, r31
    1384:	f0 e6       	ldi	r31, 0x60	; 96
    1386:	ef 2e       	mov	r14, r31
    1388:	f2 e0       	ldi	r31, 0x02	; 2
    138a:	ff 2e       	mov	r15, r31
    138c:	f0 2d       	mov	r31, r0
    138e:	f7 01       	movw	r30, r14
    1390:	80 81       	ld	r24, Z
    1392:	80 7e       	andi	r24, 0xE0	; 224
    1394:	81 60       	ori	r24, 0x01	; 1
    1396:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1398:	89 e0       	ldi	r24, 0x09	; 9
    139a:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    139c:	8c 91       	ld	r24, X
    139e:	81 60       	ori	r24, 0x01	; 1
    13a0:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    13a2:	80 e4       	ldi	r24, 0x40	; 64
    13a4:	92 e0       	ldi	r25, 0x02	; 2
    13a6:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    13aa:	80 e4       	ldi	r24, 0x40	; 64
    13ac:	92 e0       	ldi	r25, 0x02	; 2
    13ae:	60 e6       	ldi	r22, 0x60	; 96
    13b0:	72 e0       	ldi	r23, 0x02	; 2
    13b2:	40 e0       	ldi	r20, 0x00	; 0
    13b4:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <ADC_Offset_Get_Unsigned>
    13b8:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    13ba:	d8 01       	movw	r26, r16
    13bc:	8c 91       	ld	r24, X
    13be:	8e 7f       	andi	r24, 0xFE	; 254
    13c0:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    13c2:	f7 01       	movw	r30, r14
    13c4:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    13c6:	13 96       	adiw	r26, 0x03	; 3
    13c8:	8c 91       	ld	r24, X
    13ca:	13 97       	sbiw	r26, 0x03	; 3
    13cc:	8f 73       	andi	r24, 0x3F	; 63
    13ce:	13 96       	adiw	r26, 0x03	; 3
    13d0:	8c 93       	st	X, r24
    13d2:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    13d4:	8c 91       	ld	r24, X
    13d6:	81 60       	ori	r24, 0x01	; 1
    13d8:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    13da:	80 e4       	ldi	r24, 0x40	; 64
    13dc:	92 e0       	ldi	r25, 0x02	; 2
    13de:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    13e2:	d8 01       	movw	r26, r16
    13e4:	11 96       	adiw	r26, 0x01	; 1
    13e6:	8c 91       	ld	r24, X
    13e8:	11 97       	sbiw	r26, 0x01	; 1
    13ea:	88 60       	ori	r24, 0x08	; 8
    13ec:	11 96       	adiw	r26, 0x01	; 1
    13ee:	8c 93       	st	X, r24
    13f0:	ee 24       	eor	r14, r14
    13f2:	ff 24       	eor	r15, r15
    13f4:	68 94       	set
    13f6:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    13f8:	44 24       	eor	r4, r4
    13fa:	55 24       	eor	r5, r5
    13fc:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    13fe:	20 e0       	ldi	r18, 0x00	; 0
    1400:	30 e1       	ldi	r19, 0x10	; 16
    1402:	40 e0       	ldi	r20, 0x00	; 0
    1404:	50 e0       	ldi	r21, 0x00	; 0
    1406:	2a 83       	std	Y+2, r18	; 0x02
    1408:	3b 83       	std	Y+3, r19	; 0x03
    140a:	4c 83       	std	Y+4, r20	; 0x04
    140c:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    140e:	88 24       	eor	r8, r8
    1410:	99 24       	eor	r9, r9
    1412:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    1414:	00 e6       	ldi	r16, 0x60	; 96
    1416:	12 e0       	ldi	r17, 0x02	; 2
    1418:	d8 01       	movw	r26, r16
    141a:	13 96       	adiw	r26, 0x03	; 3
    141c:	8c 91       	ld	r24, X
    141e:	13 97       	sbiw	r26, 0x03	; 3
    1420:	80 ff       	sbrs	r24, 0
    1422:	fa cf       	rjmp	.-12     	; 0x1418 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    1424:	69 81       	ldd	r22, Y+1	; 0x01
    1426:	c8 01       	movw	r24, r16
    1428:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    142c:	a0 e0       	ldi	r26, 0x00	; 0
    142e:	b0 e0       	ldi	r27, 0x00	; 0
    1430:	88 0e       	add	r8, r24
    1432:	99 1e       	adc	r9, r25
    1434:	aa 1e       	adc	r10, r26
    1436:	bb 1e       	adc	r11, r27
    1438:	48 16       	cp	r4, r24
    143a:	59 06       	cpc	r5, r25
    143c:	6a 06       	cpc	r6, r26
    143e:	7b 06       	cpc	r7, r27
    1440:	10 f4       	brcc	.+4      	; 0x1446 <CO_collectBatt+0x158>
    1442:	2c 01       	movw	r4, r24
    1444:	3d 01       	movw	r6, r26
    1446:	2a 81       	ldd	r18, Y+2	; 0x02
    1448:	3b 81       	ldd	r19, Y+3	; 0x03
    144a:	4c 81       	ldd	r20, Y+4	; 0x04
    144c:	5d 81       	ldd	r21, Y+5	; 0x05
    144e:	82 17       	cp	r24, r18
    1450:	93 07       	cpc	r25, r19
    1452:	a4 07       	cpc	r26, r20
    1454:	b5 07       	cpc	r27, r21
    1456:	20 f4       	brcc	.+8      	; 0x1460 <CO_collectBatt+0x172>
    1458:	8a 83       	std	Y+2, r24	; 0x02
    145a:	9b 83       	std	Y+3, r25	; 0x03
    145c:	ac 83       	std	Y+4, r26	; 0x04
    145e:	bd 83       	std	Y+5, r27	; 0x05
    1460:	08 94       	sec
    1462:	e1 08       	sbc	r14, r1
    1464:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1466:	e1 14       	cp	r14, r1
    1468:	f1 04       	cpc	r15, r1
    146a:	b1 f6       	brne	.-84     	; 0x1418 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    146c:	e0 e4       	ldi	r30, 0x40	; 64
    146e:	f2 e0       	ldi	r31, 0x02	; 2
    1470:	81 81       	ldd	r24, Z+1	; 0x01
    1472:	87 7f       	andi	r24, 0xF7	; 247
    1474:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    1476:	80 81       	ld	r24, Z
    1478:	8e 7f       	andi	r24, 0xFE	; 254
    147a:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    147c:	84 e0       	ldi	r24, 0x04	; 4
    147e:	60 e0       	ldi	r22, 0x00	; 0
    1480:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    1484:	80 e0       	ldi	r24, 0x00	; 0
    1486:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    148a:	c5 01       	movw	r24, r10
    148c:	b4 01       	movw	r22, r8
    148e:	05 2e       	mov	r0, r21
    1490:	5a e0       	ldi	r21, 0x0A	; 10
    1492:	96 95       	lsr	r25
    1494:	87 95       	ror	r24
    1496:	77 95       	ror	r23
    1498:	67 95       	ror	r22
    149a:	5a 95       	dec	r21
    149c:	d1 f7       	brne	.-12     	; 0x1492 <CO_collectBatt+0x1a4>
    149e:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    14a0:	28 ee       	ldi	r18, 0xE8	; 232
    14a2:	33 e0       	ldi	r19, 0x03	; 3
    14a4:	40 e0       	ldi	r20, 0x00	; 0
    14a6:	50 e0       	ldi	r21, 0x00	; 0
    14a8:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    14ac:	0f 2e       	mov	r0, r31
    14ae:	ff ef       	ldi	r31, 0xFF	; 255
    14b0:	8f 2e       	mov	r8, r31
    14b2:	ff e0       	ldi	r31, 0x0F	; 15
    14b4:	9f 2e       	mov	r9, r31
    14b6:	f0 e0       	ldi	r31, 0x00	; 0
    14b8:	af 2e       	mov	r10, r31
    14ba:	f0 e0       	ldi	r31, 0x00	; 0
    14bc:	bf 2e       	mov	r11, r31
    14be:	f0 2d       	mov	r31, r0
    14c0:	a5 01       	movw	r20, r10
    14c2:	94 01       	movw	r18, r8
    14c4:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    14c8:	c9 01       	movw	r24, r18
    14ca:	c2 97       	sbiw	r24, 0x32	; 50
    14cc:	ae 81       	ldd	r26, Y+6	; 0x06
    14ce:	bf 81       	ldd	r27, Y+7	; 0x07
    14d0:	8d 93       	st	X+, r24
    14d2:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    14d4:	c3 01       	movw	r24, r6
    14d6:	b2 01       	movw	r22, r4
    14d8:	28 ee       	ldi	r18, 0xE8	; 232
    14da:	33 e0       	ldi	r19, 0x03	; 3
    14dc:	40 e0       	ldi	r20, 0x00	; 0
    14de:	50 e0       	ldi	r21, 0x00	; 0
    14e0:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    14e4:	a5 01       	movw	r20, r10
    14e6:	94 01       	movw	r18, r8
    14e8:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    14ec:	c9 01       	movw	r24, r18
    14ee:	c2 97       	sbiw	r24, 0x32	; 50
    14f0:	ea 85       	ldd	r30, Y+10	; 0x0a
    14f2:	fb 85       	ldd	r31, Y+11	; 0x0b
    14f4:	80 83       	st	Z, r24
    14f6:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    14f8:	6a 81       	ldd	r22, Y+2	; 0x02
    14fa:	7b 81       	ldd	r23, Y+3	; 0x03
    14fc:	8c 81       	ldd	r24, Y+4	; 0x04
    14fe:	9d 81       	ldd	r25, Y+5	; 0x05
    1500:	28 ee       	ldi	r18, 0xE8	; 232
    1502:	33 e0       	ldi	r19, 0x03	; 3
    1504:	40 e0       	ldi	r20, 0x00	; 0
    1506:	50 e0       	ldi	r21, 0x00	; 0
    1508:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    150c:	a5 01       	movw	r20, r10
    150e:	94 01       	movw	r18, r8
    1510:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    1514:	22 53       	subi	r18, 0x32	; 50
    1516:	30 40       	sbci	r19, 0x00	; 0
    1518:	a8 85       	ldd	r26, Y+8	; 0x08
    151a:	b9 85       	ldd	r27, Y+9	; 0x09
    151c:	2d 93       	st	X+, r18
    151e:	3c 93       	st	X, r19
    1520:	11 97       	sbiw	r26, 0x01	; 1
}
    1522:	2b 96       	adiw	r28, 0x0b	; 11
    1524:	cd bf       	out	0x3d, r28	; 61
    1526:	de bf       	out	0x3e, r29	; 62
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	1f 91       	pop	r17
    152e:	0f 91       	pop	r16
    1530:	ff 90       	pop	r15
    1532:	ef 90       	pop	r14
    1534:	bf 90       	pop	r11
    1536:	af 90       	pop	r10
    1538:	9f 90       	pop	r9
    153a:	8f 90       	pop	r8
    153c:	7f 90       	pop	r7
    153e:	6f 90       	pop	r6
    1540:	5f 90       	pop	r5
    1542:	4f 90       	pop	r4
    1544:	08 95       	ret

00001546 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    1546:	cf 93       	push	r28
    1548:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    154a:	21 e0       	ldi	r18, 0x01	; 1
    154c:	30 e0       	ldi	r19, 0x00	; 0
    154e:	a9 01       	movw	r20, r18
    1550:	02 c0       	rjmp	.+4      	; 0x1556 <set_ampGain+0x10>
    1552:	44 0f       	add	r20, r20
    1554:	55 1f       	adc	r21, r21
    1556:	8a 95       	dec	r24
    1558:	e2 f7       	brpl	.-8      	; 0x1552 <set_ampGain+0xc>
    155a:	ca 01       	movw	r24, r20
    155c:	61 e0       	ldi	r22, 0x01	; 1
    155e:	0e 94 3c 05 	call	0xa78	; 0xa78 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    1562:	c0 ff       	sbrs	r28, 0
    1564:	05 c0       	rjmp	.+10     	; 0x1570 <set_ampGain+0x2a>
    1566:	80 e4       	ldi	r24, 0x40	; 64
    1568:	e0 e0       	ldi	r30, 0x00	; 0
    156a:	f6 e0       	ldi	r31, 0x06	; 6
    156c:	85 83       	std	Z+5, r24	; 0x05
    156e:	04 c0       	rjmp	.+8      	; 0x1578 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    1570:	80 e4       	ldi	r24, 0x40	; 64
    1572:	e0 e0       	ldi	r30, 0x00	; 0
    1574:	f6 e0       	ldi	r31, 0x06	; 6
    1576:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1578:	c1 ff       	sbrs	r28, 1
    157a:	05 c0       	rjmp	.+10     	; 0x1586 <set_ampGain+0x40>
    157c:	82 e0       	ldi	r24, 0x02	; 2
    157e:	e0 e2       	ldi	r30, 0x20	; 32
    1580:	f6 e0       	ldi	r31, 0x06	; 6
    1582:	85 83       	std	Z+5, r24	; 0x05
    1584:	04 c0       	rjmp	.+8      	; 0x158e <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    1586:	82 e0       	ldi	r24, 0x02	; 2
    1588:	e0 e2       	ldi	r30, 0x20	; 32
    158a:	f6 e0       	ldi	r31, 0x06	; 6
    158c:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    158e:	c2 ff       	sbrs	r28, 2
    1590:	05 c0       	rjmp	.+10     	; 0x159c <set_ampGain+0x56>
    1592:	84 e0       	ldi	r24, 0x04	; 4
    1594:	e0 e2       	ldi	r30, 0x20	; 32
    1596:	f6 e0       	ldi	r31, 0x06	; 6
    1598:	85 83       	std	Z+5, r24	; 0x05
    159a:	04 c0       	rjmp	.+8      	; 0x15a4 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    159c:	84 e0       	ldi	r24, 0x04	; 4
    159e:	e0 e2       	ldi	r30, 0x20	; 32
    15a0:	f6 e0       	ldi	r31, 0x06	; 6
    15a2:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    15a4:	5a e0       	ldi	r21, 0x0A	; 10
    15a6:	5a 95       	dec	r21
    15a8:	f1 f7       	brne	.-4      	; 0x15a6 <set_ampGain+0x60>
    15aa:	00 c0       	rjmp	.+0      	; 0x15ac <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    15ac:	8f ef       	ldi	r24, 0xFF	; 255
    15ae:	61 e0       	ldi	r22, 0x01	; 1
    15b0:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    15b4:	cf 91       	pop	r28
    15b6:	08 95       	ret

000015b8 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    15b8:	88 23       	and	r24, r24
    15ba:	31 f0       	breq	.+12     	; 0x15c8 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    15bc:	e0 e0       	ldi	r30, 0x00	; 0
    15be:	f6 e0       	ldi	r31, 0x06	; 6
    15c0:	80 e2       	ldi	r24, 0x20	; 32
    15c2:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    15c4:	85 83       	std	Z+5, r24	; 0x05
    15c6:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    15c8:	e0 e0       	ldi	r30, 0x00	; 0
    15ca:	f6 e0       	ldi	r31, 0x06	; 6
    15cc:	80 e2       	ldi	r24, 0x20	; 32
    15ce:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    15d0:	82 83       	std	Z+2, r24	; 0x02
    15d2:	08 95       	ret

000015d4 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    15d4:	1f 92       	push	r1
    15d6:	0f 92       	push	r0
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	0f 92       	push	r0
    15dc:	0b b6       	in	r0, 0x3b	; 59
    15de:	0f 92       	push	r0
    15e0:	11 24       	eor	r1, r1
    15e2:	2f 93       	push	r18
    15e4:	3f 93       	push	r19
    15e6:	4f 93       	push	r20
    15e8:	5f 93       	push	r21
    15ea:	6f 93       	push	r22
    15ec:	7f 93       	push	r23
    15ee:	8f 93       	push	r24
    15f0:	9f 93       	push	r25
    15f2:	af 93       	push	r26
    15f4:	bf 93       	push	r27
    15f6:	ef 93       	push	r30
    15f8:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    15fa:	e0 e4       	ldi	r30, 0x40	; 64
    15fc:	fa e0       	ldi	r31, 0x0A	; 10
    15fe:	80 81       	ld	r24, Z
    1600:	80 7f       	andi	r24, 0xF0	; 240
    1602:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1604:	a0 e0       	ldi	r26, 0x00	; 0
    1606:	b8 e0       	ldi	r27, 0x08	; 8
    1608:	8c 91       	ld	r24, X
    160a:	80 7f       	andi	r24, 0xF0	; 240
    160c:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    160e:	a0 e0       	ldi	r26, 0x00	; 0
    1610:	b9 e0       	ldi	r27, 0x09	; 9
    1612:	8c 91       	ld	r24, X
    1614:	80 7f       	andi	r24, 0xF0	; 240
    1616:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1618:	80 81       	ld	r24, Z
    161a:	80 7f       	andi	r24, 0xF0	; 240
    161c:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    1626:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	enableADCMUX(FALSE);
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	80 93 a7 50 	sts	0x50A7, r24
	DataAvailable = 1;
    1636:	80 93 48 3e 	sts	0x3E48, r24
}
    163a:	ff 91       	pop	r31
    163c:	ef 91       	pop	r30
    163e:	bf 91       	pop	r27
    1640:	af 91       	pop	r26
    1642:	9f 91       	pop	r25
    1644:	8f 91       	pop	r24
    1646:	7f 91       	pop	r23
    1648:	6f 91       	pop	r22
    164a:	5f 91       	pop	r21
    164c:	4f 91       	pop	r20
    164e:	3f 91       	pop	r19
    1650:	2f 91       	pop	r18
    1652:	0f 90       	pop	r0
    1654:	0b be       	out	0x3b, r0	; 59
    1656:	0f 90       	pop	r0
    1658:	0f be       	out	0x3f, r0	; 63
    165a:	0f 90       	pop	r0
    165c:	1f 90       	pop	r1
    165e:	18 95       	reti

00001660 <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1660:	e0 e4       	ldi	r30, 0x40	; 64
    1662:	fa e0       	ldi	r31, 0x0A	; 10
    1664:	80 81       	ld	r24, Z
    1666:	80 7f       	andi	r24, 0xF0	; 240
    1668:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    166a:	a0 e0       	ldi	r26, 0x00	; 0
    166c:	b8 e0       	ldi	r27, 0x08	; 8
    166e:	8c 91       	ld	r24, X
    1670:	80 7f       	andi	r24, 0xF0	; 240
    1672:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1674:	a0 e0       	ldi	r26, 0x00	; 0
    1676:	b9 e0       	ldi	r27, 0x09	; 9
    1678:	8c 91       	ld	r24, X
    167a:	80 7f       	andi	r24, 0xF0	; 240
    167c:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    167e:	80 81       	ld	r24, Z
    1680:	80 7f       	andi	r24, 0xF0	; 240
    1682:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1686:	80 e0       	ldi	r24, 0x00	; 0
    1688:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    168c:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	enableADCMUX(FALSE);
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    1696:	81 e0       	ldi	r24, 0x01	; 1
    1698:	80 93 a7 50 	sts	0x50A7, r24
	DataAvailable = 1;
    169c:	80 93 48 3e 	sts	0x3E48, r24
}
    16a0:	08 95       	ret

000016a2 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    16a2:	cf 93       	push	r28
    16a4:	df 93       	push	r29
    16a6:	0f 92       	push	r0
    16a8:	0f 92       	push	r0
    16aa:	cd b7       	in	r28, 0x3d	; 61
    16ac:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    16ae:	80 91 a7 50 	lds	r24, 0x50A7
    16b2:	88 23       	and	r24, r24
    16b4:	89 f0       	breq	.+34     	; 0x16d8 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    16b6:	e0 e4       	ldi	r30, 0x40	; 64
    16b8:	f8 e0       	ldi	r31, 0x08	; 8
    16ba:	80 a1       	lds	r24, 0x40
    16bc:	91 a1       	lds	r25, 0x41
    16be:	89 83       	std	Y+1, r24	; 0x01
    16c0:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    16c2:	89 81       	ldd	r24, Y+1	; 0x01
    16c4:	9a 81       	ldd	r25, Y+2	; 0x02
    16c6:	00 97       	sbiw	r24, 0x00	; 0
    16c8:	21 f4       	brne	.+8      	; 0x16d2 <ADC_Get_Num_Samples+0x30>
    16ca:	86 a1       	lds	r24, 0x46
    16cc:	97 a1       	lds	r25, 0x47
    16ce:	89 83       	std	Y+1, r24	; 0x01
    16d0:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    16d2:	89 81       	ldd	r24, Y+1	; 0x01
    16d4:	9a 81       	ldd	r25, Y+2	; 0x02
    16d6:	02 c0       	rjmp	.+4      	; 0x16dc <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    16d8:	80 e0       	ldi	r24, 0x00	; 0
    16da:	90 e0       	ldi	r25, 0x00	; 0
}
    16dc:	0f 90       	pop	r0
    16de:	0f 90       	pop	r0
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	08 95       	ret

000016e6 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    16e6:	e0 ea       	ldi	r30, 0xA0	; 160
    16e8:	f6 e0       	ldi	r31, 0x06	; 6
    16ea:	13 86       	std	Z+11, r1	; 0x0b
}
    16ec:	08 95       	ret

000016ee <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	e0 ea       	ldi	r30, 0xA0	; 160
    16f2:	f6 e0       	ldi	r31, 0x06	; 6
    16f4:	83 87       	std	Z+11, r24	; 0x0b
}	
    16f6:	08 95       	ret

000016f8 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    16f8:	1f 92       	push	r1
    16fa:	0f 92       	push	r0
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	0f 92       	push	r0
    1700:	0b b6       	in	r0, 0x3b	; 59
    1702:	0f 92       	push	r0
    1704:	11 24       	eor	r1, r1
    1706:	6f 92       	push	r6
    1708:	7f 92       	push	r7
    170a:	8f 92       	push	r8
    170c:	9f 92       	push	r9
    170e:	af 92       	push	r10
    1710:	bf 92       	push	r11
    1712:	cf 92       	push	r12
    1714:	df 92       	push	r13
    1716:	ef 92       	push	r14
    1718:	ff 92       	push	r15
    171a:	0f 93       	push	r16
    171c:	1f 93       	push	r17
    171e:	2f 93       	push	r18
    1720:	3f 93       	push	r19
    1722:	4f 93       	push	r20
    1724:	5f 93       	push	r21
    1726:	6f 93       	push	r22
    1728:	7f 93       	push	r23
    172a:	8f 93       	push	r24
    172c:	9f 93       	push	r25
    172e:	af 93       	push	r26
    1730:	bf 93       	push	r27
    1732:	ef 93       	push	r30
    1734:	ff 93       	push	r31
    1736:	cf 93       	push	r28
    1738:	df 93       	push	r29
    173a:	cd b7       	in	r28, 0x3d	; 61
    173c:	de b7       	in	r29, 0x3e	; 62
    173e:	2c 97       	sbiw	r28, 0x0c	; 12
    1740:	cd bf       	out	0x3d, r28	; 61
    1742:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    1744:	80 91 5d 40 	lds	r24, 0x405D
    1748:	88 23       	and	r24, r24
    174a:	8c f0       	brlt	.+34     	; 0x176e <__vector_104+0x76>
		discardCount++;
    174c:	80 91 5d 40 	lds	r24, 0x405D
    1750:	8f 5f       	subi	r24, 0xFF	; 255
    1752:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
    1756:	80 91 5d 40 	lds	r24, 0x405D
    175a:	80 38       	cpi	r24, 0x80	; 128
    175c:	09 f0       	breq	.+2      	; 0x1760 <__vector_104+0x68>
    175e:	e9 c0       	rjmp	.+466    	; 0x1932 <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1760:	e0 e4       	ldi	r30, 0x40	; 64
    1762:	f8 e0       	ldi	r31, 0x08	; 8
    1764:	80 81       	ld	r24, Z
    1766:	80 7f       	andi	r24, 0xF0	; 240
    1768:	89 60       	ori	r24, 0x09	; 9
    176a:	80 83       	st	Z, r24
    176c:	e2 c0       	rjmp	.+452    	; 0x1932 <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    176e:	81 e0       	ldi	r24, 0x01	; 1
    1770:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1774:	82 e0       	ldi	r24, 0x02	; 2
    1776:	e0 ea       	ldi	r30, 0xA0	; 160
    1778:	f6 e0       	ldi	r31, 0x06	; 6
    177a:	86 83       	std	Z+6, r24	; 0x06
    177c:	80 e0       	ldi	r24, 0x00	; 0
    177e:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1780:	e0 ec       	ldi	r30, 0xC0	; 192
    1782:	f8 e0       	ldi	r31, 0x08	; 8
    1784:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1786:	21 e2       	ldi	r18, 0x21	; 33
    1788:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    178a:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    178c:	42 81       	ldd	r20, Z+2	; 0x02
    178e:	44 23       	and	r20, r20
    1790:	ec f7       	brge	.-6      	; 0x178c <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1792:	43 81       	ldd	r20, Z+3	; 0x03
    1794:	d9 01       	movw	r26, r18
    1796:	a8 0f       	add	r26, r24
    1798:	b9 1f       	adc	r27, r25
    179a:	4c 93       	st	X, r20
    179c:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    179e:	83 30       	cpi	r24, 0x03	; 3
    17a0:	91 05       	cpc	r25, r1
    17a2:	99 f7       	brne	.-26     	; 0x178a <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    17a4:	82 e0       	ldi	r24, 0x02	; 2
    17a6:	e0 ea       	ldi	r30, 0xA0	; 160
    17a8:	f6 e0       	ldi	r31, 0x06	; 6
    17aa:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    17b2:	80 91 21 3e 	lds	r24, 0x3E21
    17b6:	88 23       	and	r24, r24
    17b8:	1c f4       	brge	.+6      	; 0x17c0 <__vector_104+0xc8>
    17ba:	8f ef       	ldi	r24, 0xFF	; 255
    17bc:	8c 83       	std	Y+4, r24	; 0x04
    17be:	01 c0       	rjmp	.+2      	; 0x17c2 <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    17c0:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    17c2:	80 91 21 3e 	lds	r24, 0x3E21
    17c6:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    17c8:	80 91 22 3e 	lds	r24, 0x3E22
    17cc:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    17ce:	80 91 23 3e 	lds	r24, 0x3E23
    17d2:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    17d4:	89 81       	ldd	r24, Y+1	; 0x01
    17d6:	9a 81       	ldd	r25, Y+2	; 0x02
    17d8:	ab 81       	ldd	r26, Y+3	; 0x03
    17da:	bc 81       	ldd	r27, Y+4	; 0x04
    17dc:	ac 01       	movw	r20, r24
    17de:	bd 01       	movw	r22, r26
    17e0:	77 0f       	add	r23, r23
    17e2:	44 0b       	sbc	r20, r20
    17e4:	54 2f       	mov	r21, r20
    17e6:	ba 01       	movw	r22, r20
    17e8:	8d 83       	std	Y+5, r24	; 0x05
    17ea:	9e 83       	std	Y+6, r25	; 0x06
    17ec:	af 83       	std	Y+7, r26	; 0x07
    17ee:	b8 87       	std	Y+8, r27	; 0x08
    17f0:	49 87       	std	Y+9, r20	; 0x09
    17f2:	4a 87       	std	Y+10, r20	; 0x0a
    17f4:	4b 87       	std	Y+11, r20	; 0x0b
    17f6:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    17f8:	60 91 66 50 	lds	r22, 0x5066
    17fc:	70 91 67 50 	lds	r23, 0x5067
    1800:	80 91 68 50 	lds	r24, 0x5068
    1804:	90 91 69 50 	lds	r25, 0x5069
    1808:	8d 80       	ldd	r8, Y+5	; 0x05
    180a:	1e 81       	ldd	r17, Y+6	; 0x06
    180c:	0f 81       	ldd	r16, Y+7	; 0x07
    180e:	f8 84       	ldd	r15, Y+8	; 0x08
    1810:	e9 84       	ldd	r14, Y+9	; 0x09
    1812:	da 84       	ldd	r13, Y+10	; 0x0a
    1814:	cb 84       	ldd	r12, Y+11	; 0x0b
    1816:	bc 84       	ldd	r11, Y+12	; 0x0c
    1818:	20 91 a8 50 	lds	r18, 0x50A8
    181c:	30 91 a9 50 	lds	r19, 0x50A9
    1820:	40 e0       	ldi	r20, 0x00	; 0
    1822:	50 e0       	ldi	r21, 0x00	; 0
    1824:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    1828:	66 0f       	add	r22, r22
    182a:	77 1f       	adc	r23, r23
    182c:	66 0f       	add	r22, r22
    182e:	77 1f       	adc	r23, r23
    1830:	80 91 64 50 	lds	r24, 0x5064
    1834:	90 91 65 50 	lds	r25, 0x5065
    1838:	3c 01       	movw	r6, r24
    183a:	66 0e       	add	r6, r22
    183c:	77 1e       	adc	r7, r23
    183e:	28 2d       	mov	r18, r8
    1840:	31 2f       	mov	r19, r17
    1842:	40 2f       	mov	r20, r16
    1844:	5f 2d       	mov	r21, r15
    1846:	6e 2d       	mov	r22, r14
    1848:	7d 2d       	mov	r23, r13
    184a:	8c 2d       	mov	r24, r12
    184c:	9b 2d       	mov	r25, r11
    184e:	0f 2e       	mov	r0, r31
    1850:	f0 ea       	ldi	r31, 0xA0	; 160
    1852:	af 2e       	mov	r10, r31
    1854:	f0 2d       	mov	r31, r0
    1856:	0f 2e       	mov	r0, r31
    1858:	f5 e2       	ldi	r31, 0x25	; 37
    185a:	bf 2e       	mov	r11, r31
    185c:	f0 2d       	mov	r31, r0
    185e:	0f 2e       	mov	r0, r31
    1860:	f6 e2       	ldi	r31, 0x26	; 38
    1862:	cf 2e       	mov	r12, r31
    1864:	f0 2d       	mov	r31, r0
    1866:	dd 24       	eor	r13, r13
    1868:	ee 24       	eor	r14, r14
    186a:	ff 24       	eor	r15, r15
    186c:	00 e0       	ldi	r16, 0x00	; 0
    186e:	10 e0       	ldi	r17, 0x00	; 0
    1870:	0e 94 8e 2c 	call	0x591c	; 0x591c <__muldi3>
    1874:	aa 24       	eor	r10, r10
    1876:	aa 94       	dec	r10
    1878:	bb 24       	eor	r11, r11
    187a:	ba 94       	dec	r11
    187c:	0f 2e       	mov	r0, r31
    187e:	ff e7       	ldi	r31, 0x7F	; 127
    1880:	cf 2e       	mov	r12, r31
    1882:	f0 2d       	mov	r31, r0
    1884:	0e 94 3d 2e 	call	0x5c7a	; 0x5c7a <__divdi3>
    1888:	01 e0       	ldi	r16, 0x01	; 1
    188a:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <__ashldi3>
    188e:	0f 2e       	mov	r0, r31
    1890:	f3 e0       	ldi	r31, 0x03	; 3
    1892:	af 2e       	mov	r10, r31
    1894:	f0 2d       	mov	r31, r0
    1896:	bb 24       	eor	r11, r11
    1898:	cc 24       	eor	r12, r12
    189a:	00 e0       	ldi	r16, 0x00	; 0
    189c:	0e 94 3d 2e 	call	0x5c7a	; 0x5c7a <__divdi3>
    18a0:	82 2e       	mov	r8, r18
    18a2:	93 2e       	mov	r9, r19
    18a4:	a4 2e       	mov	r10, r20
    18a6:	b5 2e       	mov	r11, r21
    18a8:	b0 94       	com	r11
    18aa:	a0 94       	com	r10
    18ac:	90 94       	com	r9
    18ae:	80 94       	com	r8
    18b0:	81 1c       	adc	r8, r1
    18b2:	91 1c       	adc	r9, r1
    18b4:	a1 1c       	adc	r10, r1
    18b6:	b1 1c       	adc	r11, r1
    18b8:	f3 01       	movw	r30, r6
    18ba:	80 82       	st	Z, r8
    18bc:	91 82       	std	Z+1, r9	; 0x01
    18be:	a2 82       	std	Z+2, r10	; 0x02
    18c0:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    18c2:	80 91 49 40 	lds	r24, 0x4049
    18c6:	88 23       	and	r24, r24
    18c8:	09 f1       	breq	.+66     	; 0x190c <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    18ca:	60 91 66 50 	lds	r22, 0x5066
    18ce:	70 91 67 50 	lds	r23, 0x5067
    18d2:	80 91 68 50 	lds	r24, 0x5068
    18d6:	90 91 69 50 	lds	r25, 0x5069
    18da:	20 91 a8 50 	lds	r18, 0x50A8
    18de:	30 91 a9 50 	lds	r19, 0x50A9
    18e2:	40 e0       	ldi	r20, 0x00	; 0
    18e4:	50 e0       	ldi	r21, 0x00	; 0
    18e6:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    18ea:	dc 01       	movw	r26, r24
    18ec:	cb 01       	movw	r24, r22
    18ee:	9c 01       	movw	r18, r24
    18f0:	22 0f       	add	r18, r18
    18f2:	33 1f       	adc	r19, r19
    18f4:	22 0f       	add	r18, r18
    18f6:	33 1f       	adc	r19, r19
    18f8:	80 91 64 50 	lds	r24, 0x5064
    18fc:	90 91 65 50 	lds	r25, 0x5065
    1900:	82 0f       	add	r24, r18
    1902:	93 1f       	adc	r25, r19
    1904:	64 e0       	ldi	r22, 0x04	; 4
    1906:	70 e0       	ldi	r23, 0x00	; 0
    1908:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    190c:	80 91 66 50 	lds	r24, 0x5066
    1910:	90 91 67 50 	lds	r25, 0x5067
    1914:	a0 91 68 50 	lds	r26, 0x5068
    1918:	b0 91 69 50 	lds	r27, 0x5069
    191c:	01 96       	adiw	r24, 0x01	; 1
    191e:	a1 1d       	adc	r26, r1
    1920:	b1 1d       	adc	r27, r1
    1922:	80 93 66 50 	sts	0x5066, r24
    1926:	90 93 67 50 	sts	0x5067, r25
    192a:	a0 93 68 50 	sts	0x5068, r26
    192e:	b0 93 69 50 	sts	0x5069, r27
	}
}
    1932:	2c 96       	adiw	r28, 0x0c	; 12
    1934:	cd bf       	out	0x3d, r28	; 61
    1936:	de bf       	out	0x3e, r29	; 62
    1938:	df 91       	pop	r29
    193a:	cf 91       	pop	r28
    193c:	ff 91       	pop	r31
    193e:	ef 91       	pop	r30
    1940:	bf 91       	pop	r27
    1942:	af 91       	pop	r26
    1944:	9f 91       	pop	r25
    1946:	8f 91       	pop	r24
    1948:	7f 91       	pop	r23
    194a:	6f 91       	pop	r22
    194c:	5f 91       	pop	r21
    194e:	4f 91       	pop	r20
    1950:	3f 91       	pop	r19
    1952:	2f 91       	pop	r18
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	ff 90       	pop	r15
    195a:	ef 90       	pop	r14
    195c:	df 90       	pop	r13
    195e:	cf 90       	pop	r12
    1960:	bf 90       	pop	r11
    1962:	af 90       	pop	r10
    1964:	9f 90       	pop	r9
    1966:	8f 90       	pop	r8
    1968:	7f 90       	pop	r7
    196a:	6f 90       	pop	r6
    196c:	0f 90       	pop	r0
    196e:	0b be       	out	0x3b, r0	; 59
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	0f 90       	pop	r0
    1976:	1f 90       	pop	r1
    1978:	18 95       	reti

0000197a <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    197a:	88 23       	and	r24, r24
    197c:	49 f0       	breq	.+18     	; 0x1990 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    197e:	80 e2       	ldi	r24, 0x20	; 32
    1980:	60 e0       	ldi	r22, 0x00	; 0
    1982:	0e 94 40 06 	call	0xc80	; 0xc80 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1986:	80 e2       	ldi	r24, 0x20	; 32
    1988:	60 e0       	ldi	r22, 0x00	; 0
    198a:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
    198e:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1990:	80 e2       	ldi	r24, 0x20	; 32
    1992:	60 e0       	ldi	r22, 0x00	; 0
    1994:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <PortEx_DIRCLR>
    1998:	08 95       	ret

0000199a <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    199a:	1f 92       	push	r1
    199c:	0f 92       	push	r0
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	0f 92       	push	r0
    19a2:	0b b6       	in	r0, 0x3b	; 59
    19a4:	0f 92       	push	r0
    19a6:	11 24       	eor	r1, r1
    19a8:	6f 92       	push	r6
    19aa:	7f 92       	push	r7
    19ac:	8f 92       	push	r8
    19ae:	9f 92       	push	r9
    19b0:	af 92       	push	r10
    19b2:	bf 92       	push	r11
    19b4:	cf 92       	push	r12
    19b6:	df 92       	push	r13
    19b8:	ef 92       	push	r14
    19ba:	ff 92       	push	r15
    19bc:	0f 93       	push	r16
    19be:	1f 93       	push	r17
    19c0:	2f 93       	push	r18
    19c2:	3f 93       	push	r19
    19c4:	4f 93       	push	r20
    19c6:	5f 93       	push	r21
    19c8:	6f 93       	push	r22
    19ca:	7f 93       	push	r23
    19cc:	8f 93       	push	r24
    19ce:	9f 93       	push	r25
    19d0:	af 93       	push	r26
    19d2:	bf 93       	push	r27
    19d4:	ef 93       	push	r30
    19d6:	ff 93       	push	r31
    19d8:	cf 93       	push	r28
    19da:	df 93       	push	r29
    19dc:	cd b7       	in	r28, 0x3d	; 61
    19de:	de b7       	in	r29, 0x3e	; 62
    19e0:	2c 97       	sbiw	r28, 0x0c	; 12
    19e2:	cd bf       	out	0x3d, r28	; 61
    19e4:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    19e6:	19 82       	std	Y+1, r1	; 0x01
    19e8:	1a 82       	std	Y+2, r1	; 0x02
    19ea:	1b 82       	std	Y+3, r1	; 0x03
    19ec:	1c 82       	std	Y+4, r1	; 0x04
    19ee:	1d 82       	std	Y+5, r1	; 0x05
    19f0:	1e 82       	std	Y+6, r1	; 0x06
    19f2:	1f 82       	std	Y+7, r1	; 0x07
    19f4:	18 86       	std	Y+8, r1	; 0x08
    19f6:	80 e0       	ldi	r24, 0x00	; 0
    19f8:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    19fa:	21 e2       	ldi	r18, 0x21	; 33
    19fc:	3e e3       	ldi	r19, 0x3E	; 62
    19fe:	88 24       	eor	r8, r8
    1a00:	8a 94       	dec	r8
    1a02:	ac 01       	movw	r20, r24
    1a04:	f9 01       	movw	r30, r18
    1a06:	e8 0f       	add	r30, r24
    1a08:	f9 1f       	adc	r31, r25
    1a0a:	60 81       	ld	r22, Z
    1a0c:	66 23       	and	r22, r22
    1a0e:	14 f4       	brge	.+4      	; 0x1a14 <__vector_14+0x7a>
    1a10:	8c 86       	std	Y+12, r8	; 0x0c
    1a12:	01 c0       	rjmp	.+2      	; 0x1a16 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1a14:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1a16:	42 0f       	add	r20, r18
    1a18:	53 1f       	adc	r21, r19
    1a1a:	fa 01       	movw	r30, r20
    1a1c:	40 81       	ld	r20, Z
    1a1e:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1a20:	fc 01       	movw	r30, r24
    1a22:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1a24:	e2 0f       	add	r30, r18
    1a26:	f3 1f       	adc	r31, r19
    1a28:	40 81       	ld	r20, Z
    1a2a:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1a2c:	fc 01       	movw	r30, r24
    1a2e:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1a30:	e2 0f       	add	r30, r18
    1a32:	f3 1f       	adc	r31, r19
    1a34:	40 81       	ld	r20, Z
    1a36:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1a38:	49 85       	ldd	r20, Y+9	; 0x09
    1a3a:	5a 85       	ldd	r21, Y+10	; 0x0a
    1a3c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a3e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a40:	a9 80       	ldd	r10, Y+1	; 0x01
    1a42:	ba 80       	ldd	r11, Y+2	; 0x02
    1a44:	cb 80       	ldd	r12, Y+3	; 0x03
    1a46:	dc 80       	ldd	r13, Y+4	; 0x04
    1a48:	ed 80       	ldd	r14, Y+5	; 0x05
    1a4a:	fe 80       	ldd	r15, Y+6	; 0x06
    1a4c:	0f 81       	ldd	r16, Y+7	; 0x07
    1a4e:	18 85       	ldd	r17, Y+8	; 0x08
    1a50:	b4 2f       	mov	r27, r20
    1a52:	a5 2f       	mov	r26, r21
    1a54:	f6 2f       	mov	r31, r22
    1a56:	e7 2f       	mov	r30, r23
    1a58:	77 0f       	add	r23, r23
    1a5a:	44 0b       	sbc	r20, r20
    1a5c:	54 2f       	mov	r21, r20
    1a5e:	ba 01       	movw	r22, r20
    1a60:	64 2e       	mov	r6, r20
    1a62:	74 2e       	mov	r7, r20
    1a64:	94 2e       	mov	r9, r20
    1a66:	ab 0e       	add	r10, r27
    1a68:	61 e0       	ldi	r22, 0x01	; 1
    1a6a:	ab 16       	cp	r10, r27
    1a6c:	08 f0       	brcs	.+2      	; 0x1a70 <__vector_14+0xd6>
    1a6e:	60 e0       	ldi	r22, 0x00	; 0
    1a70:	ba 0e       	add	r11, r26
    1a72:	51 e0       	ldi	r21, 0x01	; 1
    1a74:	ba 16       	cp	r11, r26
    1a76:	08 f0       	brcs	.+2      	; 0x1a7a <__vector_14+0xe0>
    1a78:	50 e0       	ldi	r21, 0x00	; 0
    1a7a:	a6 2f       	mov	r26, r22
    1a7c:	ab 0d       	add	r26, r11
    1a7e:	61 e0       	ldi	r22, 0x01	; 1
    1a80:	ab 15       	cp	r26, r11
    1a82:	08 f0       	brcs	.+2      	; 0x1a86 <__vector_14+0xec>
    1a84:	60 e0       	ldi	r22, 0x00	; 0
    1a86:	56 2b       	or	r21, r22
    1a88:	cf 0e       	add	r12, r31
    1a8a:	61 e0       	ldi	r22, 0x01	; 1
    1a8c:	cf 16       	cp	r12, r31
    1a8e:	08 f0       	brcs	.+2      	; 0x1a92 <__vector_14+0xf8>
    1a90:	60 e0       	ldi	r22, 0x00	; 0
    1a92:	f5 2f       	mov	r31, r21
    1a94:	fc 0d       	add	r31, r12
    1a96:	51 e0       	ldi	r21, 0x01	; 1
    1a98:	fc 15       	cp	r31, r12
    1a9a:	08 f0       	brcs	.+2      	; 0x1a9e <__vector_14+0x104>
    1a9c:	50 e0       	ldi	r21, 0x00	; 0
    1a9e:	65 2b       	or	r22, r21
    1aa0:	de 0e       	add	r13, r30
    1aa2:	51 e0       	ldi	r21, 0x01	; 1
    1aa4:	de 16       	cp	r13, r30
    1aa6:	08 f0       	brcs	.+2      	; 0x1aaa <__vector_14+0x110>
    1aa8:	50 e0       	ldi	r21, 0x00	; 0
    1aaa:	e6 2f       	mov	r30, r22
    1aac:	ed 0d       	add	r30, r13
    1aae:	61 e0       	ldi	r22, 0x01	; 1
    1ab0:	ed 15       	cp	r30, r13
    1ab2:	08 f0       	brcs	.+2      	; 0x1ab6 <__vector_14+0x11c>
    1ab4:	60 e0       	ldi	r22, 0x00	; 0
    1ab6:	56 2b       	or	r21, r22
    1ab8:	e6 0c       	add	r14, r6
    1aba:	71 e0       	ldi	r23, 0x01	; 1
    1abc:	e6 14       	cp	r14, r6
    1abe:	08 f0       	brcs	.+2      	; 0x1ac2 <__vector_14+0x128>
    1ac0:	70 e0       	ldi	r23, 0x00	; 0
    1ac2:	b5 2f       	mov	r27, r21
    1ac4:	be 0d       	add	r27, r14
    1ac6:	51 e0       	ldi	r21, 0x01	; 1
    1ac8:	be 15       	cp	r27, r14
    1aca:	08 f0       	brcs	.+2      	; 0x1ace <__vector_14+0x134>
    1acc:	50 e0       	ldi	r21, 0x00	; 0
    1ace:	75 2b       	or	r23, r21
    1ad0:	f7 0c       	add	r15, r7
    1ad2:	61 e0       	ldi	r22, 0x01	; 1
    1ad4:	f7 14       	cp	r15, r7
    1ad6:	08 f0       	brcs	.+2      	; 0x1ada <__vector_14+0x140>
    1ad8:	60 e0       	ldi	r22, 0x00	; 0
    1ada:	7f 0d       	add	r23, r15
    1adc:	51 e0       	ldi	r21, 0x01	; 1
    1ade:	7f 15       	cp	r23, r15
    1ae0:	08 f0       	brcs	.+2      	; 0x1ae4 <__vector_14+0x14a>
    1ae2:	50 e0       	ldi	r21, 0x00	; 0
    1ae4:	65 2b       	or	r22, r21
    1ae6:	09 0d       	add	r16, r9
    1ae8:	51 e0       	ldi	r21, 0x01	; 1
    1aea:	09 15       	cp	r16, r9
    1aec:	08 f0       	brcs	.+2      	; 0x1af0 <__vector_14+0x156>
    1aee:	50 e0       	ldi	r21, 0x00	; 0
    1af0:	60 0f       	add	r22, r16
    1af2:	ff 24       	eor	r15, r15
    1af4:	f3 94       	inc	r15
    1af6:	60 17       	cp	r22, r16
    1af8:	08 f0       	brcs	.+2      	; 0x1afc <__vector_14+0x162>
    1afa:	ff 24       	eor	r15, r15
    1afc:	5f 29       	or	r21, r15
    1afe:	41 0f       	add	r20, r17
    1b00:	54 0f       	add	r21, r20
    1b02:	a9 82       	std	Y+1, r10	; 0x01
    1b04:	aa 83       	std	Y+2, r26	; 0x02
    1b06:	fb 83       	std	Y+3, r31	; 0x03
    1b08:	ec 83       	std	Y+4, r30	; 0x04
    1b0a:	bd 83       	std	Y+5, r27	; 0x05
    1b0c:	7e 83       	std	Y+6, r23	; 0x06
    1b0e:	6f 83       	std	Y+7, r22	; 0x07
    1b10:	58 87       	std	Y+8, r21	; 0x08
    1b12:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1b14:	8c 30       	cpi	r24, 0x0C	; 12
    1b16:	91 05       	cpc	r25, r1
    1b18:	09 f0       	breq	.+2      	; 0x1b1c <__vector_14+0x182>
    1b1a:	73 cf       	rjmp	.-282    	; 0x1a02 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1b1c:	e9 80       	ldd	r14, Y+1	; 0x01
    1b1e:	fa 80       	ldd	r15, Y+2	; 0x02
    1b20:	0b 81       	ldd	r16, Y+3	; 0x03
    1b22:	1c 81       	ldd	r17, Y+4	; 0x04
    1b24:	bd 81       	ldd	r27, Y+5	; 0x05
    1b26:	ae 81       	ldd	r26, Y+6	; 0x06
    1b28:	ff 81       	ldd	r31, Y+7	; 0x07
    1b2a:	e8 85       	ldd	r30, Y+8	; 0x08
    1b2c:	2e 2d       	mov	r18, r14
    1b2e:	3f 2d       	mov	r19, r15
    1b30:	40 2f       	mov	r20, r16
    1b32:	51 2f       	mov	r21, r17
    1b34:	6b 2f       	mov	r22, r27
    1b36:	7a 2f       	mov	r23, r26
    1b38:	8f 2f       	mov	r24, r31
    1b3a:	9e 2f       	mov	r25, r30
    1b3c:	ee 23       	and	r30, r30
    1b3e:	0c f0       	brlt	.+2      	; 0x1b42 <__vector_14+0x1a8>
    1b40:	4a c0       	rjmp	.+148    	; 0x1bd6 <__vector_14+0x23c>
    1b42:	93 e0       	ldi	r25, 0x03	; 3
    1b44:	e9 0e       	add	r14, r25
    1b46:	91 e0       	ldi	r25, 0x01	; 1
    1b48:	e2 16       	cp	r14, r18
    1b4a:	08 f0       	brcs	.+2      	; 0x1b4e <__vector_14+0x1b4>
    1b4c:	90 e0       	ldi	r25, 0x00	; 0
    1b4e:	21 e0       	ldi	r18, 0x01	; 1
    1b50:	f3 16       	cp	r15, r19
    1b52:	08 f0       	brcs	.+2      	; 0x1b56 <__vector_14+0x1bc>
    1b54:	20 e0       	ldi	r18, 0x00	; 0
    1b56:	39 2f       	mov	r19, r25
    1b58:	3f 0d       	add	r19, r15
    1b5a:	91 e0       	ldi	r25, 0x01	; 1
    1b5c:	3f 15       	cp	r19, r15
    1b5e:	08 f0       	brcs	.+2      	; 0x1b62 <__vector_14+0x1c8>
    1b60:	90 e0       	ldi	r25, 0x00	; 0
    1b62:	29 2b       	or	r18, r25
    1b64:	91 e0       	ldi	r25, 0x01	; 1
    1b66:	04 17       	cp	r16, r20
    1b68:	08 f0       	brcs	.+2      	; 0x1b6c <__vector_14+0x1d2>
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	42 2f       	mov	r20, r18
    1b6e:	40 0f       	add	r20, r16
    1b70:	21 e0       	ldi	r18, 0x01	; 1
    1b72:	40 17       	cp	r20, r16
    1b74:	08 f0       	brcs	.+2      	; 0x1b78 <__vector_14+0x1de>
    1b76:	20 e0       	ldi	r18, 0x00	; 0
    1b78:	92 2b       	or	r25, r18
    1b7a:	21 e0       	ldi	r18, 0x01	; 1
    1b7c:	15 17       	cp	r17, r21
    1b7e:	08 f0       	brcs	.+2      	; 0x1b82 <__vector_14+0x1e8>
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	59 2f       	mov	r21, r25
    1b84:	51 0f       	add	r21, r17
    1b86:	91 e0       	ldi	r25, 0x01	; 1
    1b88:	51 17       	cp	r21, r17
    1b8a:	08 f0       	brcs	.+2      	; 0x1b8e <__vector_14+0x1f4>
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	29 2b       	or	r18, r25
    1b90:	91 e0       	ldi	r25, 0x01	; 1
    1b92:	b6 17       	cp	r27, r22
    1b94:	08 f0       	brcs	.+2      	; 0x1b98 <__vector_14+0x1fe>
    1b96:	90 e0       	ldi	r25, 0x00	; 0
    1b98:	62 2f       	mov	r22, r18
    1b9a:	6b 0f       	add	r22, r27
    1b9c:	21 e0       	ldi	r18, 0x01	; 1
    1b9e:	6b 17       	cp	r22, r27
    1ba0:	08 f0       	brcs	.+2      	; 0x1ba4 <__vector_14+0x20a>
    1ba2:	20 e0       	ldi	r18, 0x00	; 0
    1ba4:	92 2b       	or	r25, r18
    1ba6:	21 e0       	ldi	r18, 0x01	; 1
    1ba8:	a7 17       	cp	r26, r23
    1baa:	08 f0       	brcs	.+2      	; 0x1bae <__vector_14+0x214>
    1bac:	20 e0       	ldi	r18, 0x00	; 0
    1bae:	79 2f       	mov	r23, r25
    1bb0:	7a 0f       	add	r23, r26
    1bb2:	91 e0       	ldi	r25, 0x01	; 1
    1bb4:	7a 17       	cp	r23, r26
    1bb6:	08 f0       	brcs	.+2      	; 0x1bba <__vector_14+0x220>
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	29 2b       	or	r18, r25
    1bbc:	91 e0       	ldi	r25, 0x01	; 1
    1bbe:	f8 17       	cp	r31, r24
    1bc0:	08 f0       	brcs	.+2      	; 0x1bc4 <__vector_14+0x22a>
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	82 2f       	mov	r24, r18
    1bc6:	8f 0f       	add	r24, r31
    1bc8:	21 e0       	ldi	r18, 0x01	; 1
    1bca:	8f 17       	cp	r24, r31
    1bcc:	08 f0       	brcs	.+2      	; 0x1bd0 <__vector_14+0x236>
    1bce:	20 e0       	ldi	r18, 0x00	; 0
    1bd0:	92 2b       	or	r25, r18
    1bd2:	2e 2d       	mov	r18, r14
    1bd4:	9e 0f       	add	r25, r30
    1bd6:	02 e0       	ldi	r16, 0x02	; 2
    1bd8:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <__ashrdi3>
    1bdc:	29 83       	std	Y+1, r18	; 0x01
    1bde:	3a 83       	std	Y+2, r19	; 0x02
    1be0:	4b 83       	std	Y+3, r20	; 0x03
    1be2:	5c 83       	std	Y+4, r21	; 0x04
    1be4:	6d 83       	std	Y+5, r22	; 0x05
    1be6:	7e 83       	std	Y+6, r23	; 0x06
    1be8:	8f 83       	std	Y+7, r24	; 0x07
    1bea:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1bec:	60 91 66 50 	lds	r22, 0x5066
    1bf0:	70 91 67 50 	lds	r23, 0x5067
    1bf4:	80 91 68 50 	lds	r24, 0x5068
    1bf8:	90 91 69 50 	lds	r25, 0x5069
    1bfc:	19 81       	ldd	r17, Y+1	; 0x01
    1bfe:	0a 81       	ldd	r16, Y+2	; 0x02
    1c00:	fb 80       	ldd	r15, Y+3	; 0x03
    1c02:	ec 80       	ldd	r14, Y+4	; 0x04
    1c04:	dd 80       	ldd	r13, Y+5	; 0x05
    1c06:	ce 80       	ldd	r12, Y+6	; 0x06
    1c08:	bf 80       	ldd	r11, Y+7	; 0x07
    1c0a:	a8 84       	ldd	r10, Y+8	; 0x08
    1c0c:	20 91 a8 50 	lds	r18, 0x50A8
    1c10:	30 91 a9 50 	lds	r19, 0x50A9
    1c14:	40 e0       	ldi	r20, 0x00	; 0
    1c16:	50 e0       	ldi	r21, 0x00	; 0
    1c18:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    1c1c:	dc 01       	movw	r26, r24
    1c1e:	cb 01       	movw	r24, r22
    1c20:	88 0f       	add	r24, r24
    1c22:	99 1f       	adc	r25, r25
    1c24:	88 0f       	add	r24, r24
    1c26:	99 1f       	adc	r25, r25
    1c28:	80 90 64 50 	lds	r8, 0x5064
    1c2c:	90 90 65 50 	lds	r9, 0x5065
    1c30:	88 0e       	add	r8, r24
    1c32:	99 1e       	adc	r9, r25
    1c34:	21 2f       	mov	r18, r17
    1c36:	30 2f       	mov	r19, r16
    1c38:	4f 2d       	mov	r20, r15
    1c3a:	5e 2d       	mov	r21, r14
    1c3c:	6d 2d       	mov	r22, r13
    1c3e:	7c 2d       	mov	r23, r12
    1c40:	8b 2d       	mov	r24, r11
    1c42:	9a 2d       	mov	r25, r10
    1c44:	0f 2e       	mov	r0, r31
    1c46:	f0 ea       	ldi	r31, 0xA0	; 160
    1c48:	af 2e       	mov	r10, r31
    1c4a:	f0 2d       	mov	r31, r0
    1c4c:	0f 2e       	mov	r0, r31
    1c4e:	f5 e2       	ldi	r31, 0x25	; 37
    1c50:	bf 2e       	mov	r11, r31
    1c52:	f0 2d       	mov	r31, r0
    1c54:	0f 2e       	mov	r0, r31
    1c56:	f6 e2       	ldi	r31, 0x26	; 38
    1c58:	cf 2e       	mov	r12, r31
    1c5a:	f0 2d       	mov	r31, r0
    1c5c:	dd 24       	eor	r13, r13
    1c5e:	ee 24       	eor	r14, r14
    1c60:	ff 24       	eor	r15, r15
    1c62:	00 e0       	ldi	r16, 0x00	; 0
    1c64:	10 e0       	ldi	r17, 0x00	; 0
    1c66:	0e 94 8e 2c 	call	0x591c	; 0x591c <__muldi3>
    1c6a:	aa 24       	eor	r10, r10
    1c6c:	aa 94       	dec	r10
    1c6e:	bb 24       	eor	r11, r11
    1c70:	ba 94       	dec	r11
    1c72:	0f 2e       	mov	r0, r31
    1c74:	ff e7       	ldi	r31, 0x7F	; 127
    1c76:	cf 2e       	mov	r12, r31
    1c78:	f0 2d       	mov	r31, r0
    1c7a:	0e 94 3d 2e 	call	0x5c7a	; 0x5c7a <__divdi3>
    1c7e:	01 e0       	ldi	r16, 0x01	; 1
    1c80:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <__ashldi3>
    1c84:	0f 2e       	mov	r0, r31
    1c86:	f3 e0       	ldi	r31, 0x03	; 3
    1c88:	af 2e       	mov	r10, r31
    1c8a:	f0 2d       	mov	r31, r0
    1c8c:	bb 24       	eor	r11, r11
    1c8e:	cc 24       	eor	r12, r12
    1c90:	00 e0       	ldi	r16, 0x00	; 0
    1c92:	0e 94 3d 2e 	call	0x5c7a	; 0x5c7a <__divdi3>
    1c96:	f4 01       	movw	r30, r8
    1c98:	20 83       	st	Z, r18
    1c9a:	31 83       	std	Z+1, r19	; 0x01
    1c9c:	42 83       	std	Z+2, r20	; 0x02
    1c9e:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    1ca0:	80 91 49 40 	lds	r24, 0x4049
    1ca4:	88 23       	and	r24, r24
    1ca6:	09 f1       	breq	.+66     	; 0x1cea <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1ca8:	60 91 66 50 	lds	r22, 0x5066
    1cac:	70 91 67 50 	lds	r23, 0x5067
    1cb0:	80 91 68 50 	lds	r24, 0x5068
    1cb4:	90 91 69 50 	lds	r25, 0x5069
    1cb8:	20 91 a8 50 	lds	r18, 0x50A8
    1cbc:	30 91 a9 50 	lds	r19, 0x50A9
    1cc0:	40 e0       	ldi	r20, 0x00	; 0
    1cc2:	50 e0       	ldi	r21, 0x00	; 0
    1cc4:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    1cc8:	dc 01       	movw	r26, r24
    1cca:	cb 01       	movw	r24, r22
    1ccc:	9c 01       	movw	r18, r24
    1cce:	22 0f       	add	r18, r18
    1cd0:	33 1f       	adc	r19, r19
    1cd2:	22 0f       	add	r18, r18
    1cd4:	33 1f       	adc	r19, r19
    1cd6:	80 91 64 50 	lds	r24, 0x5064
    1cda:	90 91 65 50 	lds	r25, 0x5065
    1cde:	82 0f       	add	r24, r18
    1ce0:	93 1f       	adc	r25, r19
    1ce2:	64 e0       	ldi	r22, 0x04	; 4
    1ce4:	70 e0       	ldi	r23, 0x00	; 0
    1ce6:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    1cea:	80 91 66 50 	lds	r24, 0x5066
    1cee:	90 91 67 50 	lds	r25, 0x5067
    1cf2:	a0 91 68 50 	lds	r26, 0x5068
    1cf6:	b0 91 69 50 	lds	r27, 0x5069
    1cfa:	01 96       	adiw	r24, 0x01	; 1
    1cfc:	a1 1d       	adc	r26, r1
    1cfe:	b1 1d       	adc	r27, r1
    1d00:	80 93 66 50 	sts	0x5066, r24
    1d04:	90 93 67 50 	sts	0x5067, r25
    1d08:	a0 93 68 50 	sts	0x5068, r26
    1d0c:	b0 93 69 50 	sts	0x5069, r27

}
    1d10:	2c 96       	adiw	r28, 0x0c	; 12
    1d12:	cd bf       	out	0x3d, r28	; 61
    1d14:	de bf       	out	0x3e, r29	; 62
    1d16:	df 91       	pop	r29
    1d18:	cf 91       	pop	r28
    1d1a:	ff 91       	pop	r31
    1d1c:	ef 91       	pop	r30
    1d1e:	bf 91       	pop	r27
    1d20:	af 91       	pop	r26
    1d22:	9f 91       	pop	r25
    1d24:	8f 91       	pop	r24
    1d26:	7f 91       	pop	r23
    1d28:	6f 91       	pop	r22
    1d2a:	5f 91       	pop	r21
    1d2c:	4f 91       	pop	r20
    1d2e:	3f 91       	pop	r19
    1d30:	2f 91       	pop	r18
    1d32:	1f 91       	pop	r17
    1d34:	0f 91       	pop	r16
    1d36:	ff 90       	pop	r15
    1d38:	ef 90       	pop	r14
    1d3a:	df 90       	pop	r13
    1d3c:	cf 90       	pop	r12
    1d3e:	bf 90       	pop	r11
    1d40:	af 90       	pop	r10
    1d42:	9f 90       	pop	r9
    1d44:	8f 90       	pop	r8
    1d46:	7f 90       	pop	r7
    1d48:	6f 90       	pop	r6
    1d4a:	0f 90       	pop	r0
    1d4c:	0b be       	out	0x3b, r0	; 59
    1d4e:	0f 90       	pop	r0
    1d50:	0f be       	out	0x3f, r0	; 63
    1d52:	0f 90       	pop	r0
    1d54:	1f 90       	pop	r1
    1d56:	18 95       	reti

00001d58 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1d58:	1f 92       	push	r1
    1d5a:	0f 92       	push	r0
    1d5c:	0f b6       	in	r0, 0x3f	; 63
    1d5e:	0f 92       	push	r0
    1d60:	0b b6       	in	r0, 0x3b	; 59
    1d62:	0f 92       	push	r0
    1d64:	11 24       	eor	r1, r1
    1d66:	6f 92       	push	r6
    1d68:	7f 92       	push	r7
    1d6a:	8f 92       	push	r8
    1d6c:	9f 92       	push	r9
    1d6e:	af 92       	push	r10
    1d70:	bf 92       	push	r11
    1d72:	cf 92       	push	r12
    1d74:	df 92       	push	r13
    1d76:	ef 92       	push	r14
    1d78:	ff 92       	push	r15
    1d7a:	0f 93       	push	r16
    1d7c:	1f 93       	push	r17
    1d7e:	2f 93       	push	r18
    1d80:	3f 93       	push	r19
    1d82:	4f 93       	push	r20
    1d84:	5f 93       	push	r21
    1d86:	6f 93       	push	r22
    1d88:	7f 93       	push	r23
    1d8a:	8f 93       	push	r24
    1d8c:	9f 93       	push	r25
    1d8e:	af 93       	push	r26
    1d90:	bf 93       	push	r27
    1d92:	ef 93       	push	r30
    1d94:	ff 93       	push	r31
    1d96:	cf 93       	push	r28
    1d98:	df 93       	push	r29
    1d9a:	cd b7       	in	r28, 0x3d	; 61
    1d9c:	de b7       	in	r29, 0x3e	; 62
    1d9e:	2c 97       	sbiw	r28, 0x0c	; 12
    1da0:	cd bf       	out	0x3d, r28	; 61
    1da2:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    1da4:	19 82       	std	Y+1, r1	; 0x01
    1da6:	1a 82       	std	Y+2, r1	; 0x02
    1da8:	1b 82       	std	Y+3, r1	; 0x03
    1daa:	1c 82       	std	Y+4, r1	; 0x04
    1dac:	1d 82       	std	Y+5, r1	; 0x05
    1dae:	1e 82       	std	Y+6, r1	; 0x06
    1db0:	1f 82       	std	Y+7, r1	; 0x07
    1db2:	18 86       	std	Y+8, r1	; 0x08
    1db4:	80 e0       	ldi	r24, 0x00	; 0
    1db6:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1db8:	21 e2       	ldi	r18, 0x21	; 33
    1dba:	3e e3       	ldi	r19, 0x3E	; 62
    1dbc:	88 24       	eor	r8, r8
    1dbe:	8a 94       	dec	r8
    1dc0:	ac 01       	movw	r20, r24
    1dc2:	f9 01       	movw	r30, r18
    1dc4:	e8 0f       	add	r30, r24
    1dc6:	f9 1f       	adc	r31, r25
    1dc8:	60 81       	ld	r22, Z
    1dca:	66 23       	and	r22, r22
    1dcc:	14 f4       	brge	.+4      	; 0x1dd2 <__vector_77+0x7a>
    1dce:	8c 86       	std	Y+12, r8	; 0x0c
    1dd0:	01 c0       	rjmp	.+2      	; 0x1dd4 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1dd2:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1dd4:	42 0f       	add	r20, r18
    1dd6:	53 1f       	adc	r21, r19
    1dd8:	fa 01       	movw	r30, r20
    1dda:	40 81       	ld	r20, Z
    1ddc:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1dde:	fc 01       	movw	r30, r24
    1de0:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1de2:	e2 0f       	add	r30, r18
    1de4:	f3 1f       	adc	r31, r19
    1de6:	40 81       	ld	r20, Z
    1de8:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1dea:	fc 01       	movw	r30, r24
    1dec:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1dee:	e2 0f       	add	r30, r18
    1df0:	f3 1f       	adc	r31, r19
    1df2:	40 81       	ld	r20, Z
    1df4:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1df6:	49 85       	ldd	r20, Y+9	; 0x09
    1df8:	5a 85       	ldd	r21, Y+10	; 0x0a
    1dfa:	6b 85       	ldd	r22, Y+11	; 0x0b
    1dfc:	7c 85       	ldd	r23, Y+12	; 0x0c
    1dfe:	a9 80       	ldd	r10, Y+1	; 0x01
    1e00:	ba 80       	ldd	r11, Y+2	; 0x02
    1e02:	cb 80       	ldd	r12, Y+3	; 0x03
    1e04:	dc 80       	ldd	r13, Y+4	; 0x04
    1e06:	ed 80       	ldd	r14, Y+5	; 0x05
    1e08:	fe 80       	ldd	r15, Y+6	; 0x06
    1e0a:	0f 81       	ldd	r16, Y+7	; 0x07
    1e0c:	18 85       	ldd	r17, Y+8	; 0x08
    1e0e:	b4 2f       	mov	r27, r20
    1e10:	a5 2f       	mov	r26, r21
    1e12:	f6 2f       	mov	r31, r22
    1e14:	e7 2f       	mov	r30, r23
    1e16:	77 0f       	add	r23, r23
    1e18:	44 0b       	sbc	r20, r20
    1e1a:	54 2f       	mov	r21, r20
    1e1c:	ba 01       	movw	r22, r20
    1e1e:	64 2e       	mov	r6, r20
    1e20:	74 2e       	mov	r7, r20
    1e22:	94 2e       	mov	r9, r20
    1e24:	ab 0e       	add	r10, r27
    1e26:	61 e0       	ldi	r22, 0x01	; 1
    1e28:	ab 16       	cp	r10, r27
    1e2a:	08 f0       	brcs	.+2      	; 0x1e2e <__vector_77+0xd6>
    1e2c:	60 e0       	ldi	r22, 0x00	; 0
    1e2e:	ba 0e       	add	r11, r26
    1e30:	51 e0       	ldi	r21, 0x01	; 1
    1e32:	ba 16       	cp	r11, r26
    1e34:	08 f0       	brcs	.+2      	; 0x1e38 <__vector_77+0xe0>
    1e36:	50 e0       	ldi	r21, 0x00	; 0
    1e38:	a6 2f       	mov	r26, r22
    1e3a:	ab 0d       	add	r26, r11
    1e3c:	61 e0       	ldi	r22, 0x01	; 1
    1e3e:	ab 15       	cp	r26, r11
    1e40:	08 f0       	brcs	.+2      	; 0x1e44 <__vector_77+0xec>
    1e42:	60 e0       	ldi	r22, 0x00	; 0
    1e44:	56 2b       	or	r21, r22
    1e46:	cf 0e       	add	r12, r31
    1e48:	61 e0       	ldi	r22, 0x01	; 1
    1e4a:	cf 16       	cp	r12, r31
    1e4c:	08 f0       	brcs	.+2      	; 0x1e50 <__vector_77+0xf8>
    1e4e:	60 e0       	ldi	r22, 0x00	; 0
    1e50:	f5 2f       	mov	r31, r21
    1e52:	fc 0d       	add	r31, r12
    1e54:	51 e0       	ldi	r21, 0x01	; 1
    1e56:	fc 15       	cp	r31, r12
    1e58:	08 f0       	brcs	.+2      	; 0x1e5c <__vector_77+0x104>
    1e5a:	50 e0       	ldi	r21, 0x00	; 0
    1e5c:	65 2b       	or	r22, r21
    1e5e:	de 0e       	add	r13, r30
    1e60:	51 e0       	ldi	r21, 0x01	; 1
    1e62:	de 16       	cp	r13, r30
    1e64:	08 f0       	brcs	.+2      	; 0x1e68 <__vector_77+0x110>
    1e66:	50 e0       	ldi	r21, 0x00	; 0
    1e68:	e6 2f       	mov	r30, r22
    1e6a:	ed 0d       	add	r30, r13
    1e6c:	61 e0       	ldi	r22, 0x01	; 1
    1e6e:	ed 15       	cp	r30, r13
    1e70:	08 f0       	brcs	.+2      	; 0x1e74 <__vector_77+0x11c>
    1e72:	60 e0       	ldi	r22, 0x00	; 0
    1e74:	56 2b       	or	r21, r22
    1e76:	e6 0c       	add	r14, r6
    1e78:	71 e0       	ldi	r23, 0x01	; 1
    1e7a:	e6 14       	cp	r14, r6
    1e7c:	08 f0       	brcs	.+2      	; 0x1e80 <__vector_77+0x128>
    1e7e:	70 e0       	ldi	r23, 0x00	; 0
    1e80:	b5 2f       	mov	r27, r21
    1e82:	be 0d       	add	r27, r14
    1e84:	51 e0       	ldi	r21, 0x01	; 1
    1e86:	be 15       	cp	r27, r14
    1e88:	08 f0       	brcs	.+2      	; 0x1e8c <__vector_77+0x134>
    1e8a:	50 e0       	ldi	r21, 0x00	; 0
    1e8c:	75 2b       	or	r23, r21
    1e8e:	f7 0c       	add	r15, r7
    1e90:	61 e0       	ldi	r22, 0x01	; 1
    1e92:	f7 14       	cp	r15, r7
    1e94:	08 f0       	brcs	.+2      	; 0x1e98 <__vector_77+0x140>
    1e96:	60 e0       	ldi	r22, 0x00	; 0
    1e98:	7f 0d       	add	r23, r15
    1e9a:	51 e0       	ldi	r21, 0x01	; 1
    1e9c:	7f 15       	cp	r23, r15
    1e9e:	08 f0       	brcs	.+2      	; 0x1ea2 <__vector_77+0x14a>
    1ea0:	50 e0       	ldi	r21, 0x00	; 0
    1ea2:	65 2b       	or	r22, r21
    1ea4:	09 0d       	add	r16, r9
    1ea6:	51 e0       	ldi	r21, 0x01	; 1
    1ea8:	09 15       	cp	r16, r9
    1eaa:	08 f0       	brcs	.+2      	; 0x1eae <__vector_77+0x156>
    1eac:	50 e0       	ldi	r21, 0x00	; 0
    1eae:	60 0f       	add	r22, r16
    1eb0:	ff 24       	eor	r15, r15
    1eb2:	f3 94       	inc	r15
    1eb4:	60 17       	cp	r22, r16
    1eb6:	08 f0       	brcs	.+2      	; 0x1eba <__vector_77+0x162>
    1eb8:	ff 24       	eor	r15, r15
    1eba:	5f 29       	or	r21, r15
    1ebc:	41 0f       	add	r20, r17
    1ebe:	54 0f       	add	r21, r20
    1ec0:	a9 82       	std	Y+1, r10	; 0x01
    1ec2:	aa 83       	std	Y+2, r26	; 0x02
    1ec4:	fb 83       	std	Y+3, r31	; 0x03
    1ec6:	ec 83       	std	Y+4, r30	; 0x04
    1ec8:	bd 83       	std	Y+5, r27	; 0x05
    1eca:	7e 83       	std	Y+6, r23	; 0x06
    1ecc:	6f 83       	std	Y+7, r22	; 0x07
    1ece:	58 87       	std	Y+8, r21	; 0x08
    1ed0:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1ed2:	8c 30       	cpi	r24, 0x0C	; 12
    1ed4:	91 05       	cpc	r25, r1
    1ed6:	09 f0       	breq	.+2      	; 0x1eda <__vector_77+0x182>
    1ed8:	73 cf       	rjmp	.-282    	; 0x1dc0 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1eda:	e9 80       	ldd	r14, Y+1	; 0x01
    1edc:	fa 80       	ldd	r15, Y+2	; 0x02
    1ede:	0b 81       	ldd	r16, Y+3	; 0x03
    1ee0:	1c 81       	ldd	r17, Y+4	; 0x04
    1ee2:	bd 81       	ldd	r27, Y+5	; 0x05
    1ee4:	ae 81       	ldd	r26, Y+6	; 0x06
    1ee6:	ff 81       	ldd	r31, Y+7	; 0x07
    1ee8:	e8 85       	ldd	r30, Y+8	; 0x08
    1eea:	2e 2d       	mov	r18, r14
    1eec:	3f 2d       	mov	r19, r15
    1eee:	40 2f       	mov	r20, r16
    1ef0:	51 2f       	mov	r21, r17
    1ef2:	6b 2f       	mov	r22, r27
    1ef4:	7a 2f       	mov	r23, r26
    1ef6:	8f 2f       	mov	r24, r31
    1ef8:	9e 2f       	mov	r25, r30
    1efa:	ee 23       	and	r30, r30
    1efc:	0c f0       	brlt	.+2      	; 0x1f00 <__vector_77+0x1a8>
    1efe:	4a c0       	rjmp	.+148    	; 0x1f94 <__vector_77+0x23c>
    1f00:	93 e0       	ldi	r25, 0x03	; 3
    1f02:	e9 0e       	add	r14, r25
    1f04:	91 e0       	ldi	r25, 0x01	; 1
    1f06:	e2 16       	cp	r14, r18
    1f08:	08 f0       	brcs	.+2      	; 0x1f0c <__vector_77+0x1b4>
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	21 e0       	ldi	r18, 0x01	; 1
    1f0e:	f3 16       	cp	r15, r19
    1f10:	08 f0       	brcs	.+2      	; 0x1f14 <__vector_77+0x1bc>
    1f12:	20 e0       	ldi	r18, 0x00	; 0
    1f14:	39 2f       	mov	r19, r25
    1f16:	3f 0d       	add	r19, r15
    1f18:	91 e0       	ldi	r25, 0x01	; 1
    1f1a:	3f 15       	cp	r19, r15
    1f1c:	08 f0       	brcs	.+2      	; 0x1f20 <__vector_77+0x1c8>
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	29 2b       	or	r18, r25
    1f22:	91 e0       	ldi	r25, 0x01	; 1
    1f24:	04 17       	cp	r16, r20
    1f26:	08 f0       	brcs	.+2      	; 0x1f2a <__vector_77+0x1d2>
    1f28:	90 e0       	ldi	r25, 0x00	; 0
    1f2a:	42 2f       	mov	r20, r18
    1f2c:	40 0f       	add	r20, r16
    1f2e:	21 e0       	ldi	r18, 0x01	; 1
    1f30:	40 17       	cp	r20, r16
    1f32:	08 f0       	brcs	.+2      	; 0x1f36 <__vector_77+0x1de>
    1f34:	20 e0       	ldi	r18, 0x00	; 0
    1f36:	92 2b       	or	r25, r18
    1f38:	21 e0       	ldi	r18, 0x01	; 1
    1f3a:	15 17       	cp	r17, r21
    1f3c:	08 f0       	brcs	.+2      	; 0x1f40 <__vector_77+0x1e8>
    1f3e:	20 e0       	ldi	r18, 0x00	; 0
    1f40:	59 2f       	mov	r21, r25
    1f42:	51 0f       	add	r21, r17
    1f44:	91 e0       	ldi	r25, 0x01	; 1
    1f46:	51 17       	cp	r21, r17
    1f48:	08 f0       	brcs	.+2      	; 0x1f4c <__vector_77+0x1f4>
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	29 2b       	or	r18, r25
    1f4e:	91 e0       	ldi	r25, 0x01	; 1
    1f50:	b6 17       	cp	r27, r22
    1f52:	08 f0       	brcs	.+2      	; 0x1f56 <__vector_77+0x1fe>
    1f54:	90 e0       	ldi	r25, 0x00	; 0
    1f56:	62 2f       	mov	r22, r18
    1f58:	6b 0f       	add	r22, r27
    1f5a:	21 e0       	ldi	r18, 0x01	; 1
    1f5c:	6b 17       	cp	r22, r27
    1f5e:	08 f0       	brcs	.+2      	; 0x1f62 <__vector_77+0x20a>
    1f60:	20 e0       	ldi	r18, 0x00	; 0
    1f62:	92 2b       	or	r25, r18
    1f64:	21 e0       	ldi	r18, 0x01	; 1
    1f66:	a7 17       	cp	r26, r23
    1f68:	08 f0       	brcs	.+2      	; 0x1f6c <__vector_77+0x214>
    1f6a:	20 e0       	ldi	r18, 0x00	; 0
    1f6c:	79 2f       	mov	r23, r25
    1f6e:	7a 0f       	add	r23, r26
    1f70:	91 e0       	ldi	r25, 0x01	; 1
    1f72:	7a 17       	cp	r23, r26
    1f74:	08 f0       	brcs	.+2      	; 0x1f78 <__vector_77+0x220>
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	29 2b       	or	r18, r25
    1f7a:	91 e0       	ldi	r25, 0x01	; 1
    1f7c:	f8 17       	cp	r31, r24
    1f7e:	08 f0       	brcs	.+2      	; 0x1f82 <__vector_77+0x22a>
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	82 2f       	mov	r24, r18
    1f84:	8f 0f       	add	r24, r31
    1f86:	21 e0       	ldi	r18, 0x01	; 1
    1f88:	8f 17       	cp	r24, r31
    1f8a:	08 f0       	brcs	.+2      	; 0x1f8e <__vector_77+0x236>
    1f8c:	20 e0       	ldi	r18, 0x00	; 0
    1f8e:	92 2b       	or	r25, r18
    1f90:	2e 2d       	mov	r18, r14
    1f92:	9e 0f       	add	r25, r30
    1f94:	02 e0       	ldi	r16, 0x02	; 2
    1f96:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <__ashrdi3>
    1f9a:	29 83       	std	Y+1, r18	; 0x01
    1f9c:	3a 83       	std	Y+2, r19	; 0x02
    1f9e:	4b 83       	std	Y+3, r20	; 0x03
    1fa0:	5c 83       	std	Y+4, r21	; 0x04
    1fa2:	6d 83       	std	Y+5, r22	; 0x05
    1fa4:	7e 83       	std	Y+6, r23	; 0x06
    1fa6:	8f 83       	std	Y+7, r24	; 0x07
    1fa8:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1faa:	60 91 66 50 	lds	r22, 0x5066
    1fae:	70 91 67 50 	lds	r23, 0x5067
    1fb2:	80 91 68 50 	lds	r24, 0x5068
    1fb6:	90 91 69 50 	lds	r25, 0x5069
    1fba:	19 81       	ldd	r17, Y+1	; 0x01
    1fbc:	0a 81       	ldd	r16, Y+2	; 0x02
    1fbe:	fb 80       	ldd	r15, Y+3	; 0x03
    1fc0:	ec 80       	ldd	r14, Y+4	; 0x04
    1fc2:	dd 80       	ldd	r13, Y+5	; 0x05
    1fc4:	ce 80       	ldd	r12, Y+6	; 0x06
    1fc6:	bf 80       	ldd	r11, Y+7	; 0x07
    1fc8:	a8 84       	ldd	r10, Y+8	; 0x08
    1fca:	20 91 a8 50 	lds	r18, 0x50A8
    1fce:	30 91 a9 50 	lds	r19, 0x50A9
    1fd2:	40 e0       	ldi	r20, 0x00	; 0
    1fd4:	50 e0       	ldi	r21, 0x00	; 0
    1fd6:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    1fda:	dc 01       	movw	r26, r24
    1fdc:	cb 01       	movw	r24, r22
    1fde:	88 0f       	add	r24, r24
    1fe0:	99 1f       	adc	r25, r25
    1fe2:	88 0f       	add	r24, r24
    1fe4:	99 1f       	adc	r25, r25
    1fe6:	80 90 64 50 	lds	r8, 0x5064
    1fea:	90 90 65 50 	lds	r9, 0x5065
    1fee:	88 0e       	add	r8, r24
    1ff0:	99 1e       	adc	r9, r25
    1ff2:	21 2f       	mov	r18, r17
    1ff4:	30 2f       	mov	r19, r16
    1ff6:	4f 2d       	mov	r20, r15
    1ff8:	5e 2d       	mov	r21, r14
    1ffa:	6d 2d       	mov	r22, r13
    1ffc:	7c 2d       	mov	r23, r12
    1ffe:	8b 2d       	mov	r24, r11
    2000:	9a 2d       	mov	r25, r10
    2002:	0f 2e       	mov	r0, r31
    2004:	f0 ea       	ldi	r31, 0xA0	; 160
    2006:	af 2e       	mov	r10, r31
    2008:	f0 2d       	mov	r31, r0
    200a:	0f 2e       	mov	r0, r31
    200c:	f5 e2       	ldi	r31, 0x25	; 37
    200e:	bf 2e       	mov	r11, r31
    2010:	f0 2d       	mov	r31, r0
    2012:	0f 2e       	mov	r0, r31
    2014:	f6 e2       	ldi	r31, 0x26	; 38
    2016:	cf 2e       	mov	r12, r31
    2018:	f0 2d       	mov	r31, r0
    201a:	dd 24       	eor	r13, r13
    201c:	ee 24       	eor	r14, r14
    201e:	ff 24       	eor	r15, r15
    2020:	00 e0       	ldi	r16, 0x00	; 0
    2022:	10 e0       	ldi	r17, 0x00	; 0
    2024:	0e 94 8e 2c 	call	0x591c	; 0x591c <__muldi3>
    2028:	aa 24       	eor	r10, r10
    202a:	aa 94       	dec	r10
    202c:	bb 24       	eor	r11, r11
    202e:	ba 94       	dec	r11
    2030:	0f 2e       	mov	r0, r31
    2032:	ff e7       	ldi	r31, 0x7F	; 127
    2034:	cf 2e       	mov	r12, r31
    2036:	f0 2d       	mov	r31, r0
    2038:	0e 94 3d 2e 	call	0x5c7a	; 0x5c7a <__divdi3>
    203c:	01 e0       	ldi	r16, 0x01	; 1
    203e:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <__ashldi3>
    2042:	0f 2e       	mov	r0, r31
    2044:	f3 e0       	ldi	r31, 0x03	; 3
    2046:	af 2e       	mov	r10, r31
    2048:	f0 2d       	mov	r31, r0
    204a:	bb 24       	eor	r11, r11
    204c:	cc 24       	eor	r12, r12
    204e:	00 e0       	ldi	r16, 0x00	; 0
    2050:	0e 94 3d 2e 	call	0x5c7a	; 0x5c7a <__divdi3>
    2054:	f4 01       	movw	r30, r8
    2056:	20 83       	st	Z, r18
    2058:	31 83       	std	Z+1, r19	; 0x01
    205a:	42 83       	std	Z+2, r20	; 0x02
    205c:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    205e:	80 91 49 40 	lds	r24, 0x4049
    2062:	88 23       	and	r24, r24
    2064:	09 f1       	breq	.+66     	; 0x20a8 <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    2066:	60 91 66 50 	lds	r22, 0x5066
    206a:	70 91 67 50 	lds	r23, 0x5067
    206e:	80 91 68 50 	lds	r24, 0x5068
    2072:	90 91 69 50 	lds	r25, 0x5069
    2076:	20 91 a8 50 	lds	r18, 0x50A8
    207a:	30 91 a9 50 	lds	r19, 0x50A9
    207e:	40 e0       	ldi	r20, 0x00	; 0
    2080:	50 e0       	ldi	r21, 0x00	; 0
    2082:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    2086:	dc 01       	movw	r26, r24
    2088:	cb 01       	movw	r24, r22
    208a:	9c 01       	movw	r18, r24
    208c:	22 0f       	add	r18, r18
    208e:	33 1f       	adc	r19, r19
    2090:	22 0f       	add	r18, r18
    2092:	33 1f       	adc	r19, r19
    2094:	80 91 64 50 	lds	r24, 0x5064
    2098:	90 91 65 50 	lds	r25, 0x5065
    209c:	82 0f       	add	r24, r18
    209e:	93 1f       	adc	r25, r19
    20a0:	64 e0       	ldi	r22, 0x04	; 4
    20a2:	70 e0       	ldi	r23, 0x00	; 0
    20a4:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    20a8:	80 91 66 50 	lds	r24, 0x5066
    20ac:	90 91 67 50 	lds	r25, 0x5067
    20b0:	a0 91 68 50 	lds	r26, 0x5068
    20b4:	b0 91 69 50 	lds	r27, 0x5069
    20b8:	01 96       	adiw	r24, 0x01	; 1
    20ba:	a1 1d       	adc	r26, r1
    20bc:	b1 1d       	adc	r27, r1
    20be:	80 93 66 50 	sts	0x5066, r24
    20c2:	90 93 67 50 	sts	0x5067, r25
    20c6:	a0 93 68 50 	sts	0x5068, r26
    20ca:	b0 93 69 50 	sts	0x5069, r27
}
    20ce:	2c 96       	adiw	r28, 0x0c	; 12
    20d0:	cd bf       	out	0x3d, r28	; 61
    20d2:	de bf       	out	0x3e, r29	; 62
    20d4:	df 91       	pop	r29
    20d6:	cf 91       	pop	r28
    20d8:	ff 91       	pop	r31
    20da:	ef 91       	pop	r30
    20dc:	bf 91       	pop	r27
    20de:	af 91       	pop	r26
    20e0:	9f 91       	pop	r25
    20e2:	8f 91       	pop	r24
    20e4:	7f 91       	pop	r23
    20e6:	6f 91       	pop	r22
    20e8:	5f 91       	pop	r21
    20ea:	4f 91       	pop	r20
    20ec:	3f 91       	pop	r19
    20ee:	2f 91       	pop	r18
    20f0:	1f 91       	pop	r17
    20f2:	0f 91       	pop	r16
    20f4:	ff 90       	pop	r15
    20f6:	ef 90       	pop	r14
    20f8:	df 90       	pop	r13
    20fa:	cf 90       	pop	r12
    20fc:	bf 90       	pop	r11
    20fe:	af 90       	pop	r10
    2100:	9f 90       	pop	r9
    2102:	8f 90       	pop	r8
    2104:	7f 90       	pop	r7
    2106:	6f 90       	pop	r6
    2108:	0f 90       	pop	r0
    210a:	0b be       	out	0x3b, r0	; 59
    210c:	0f 90       	pop	r0
    210e:	0f be       	out	0x3f, r0	; 63
    2110:	0f 90       	pop	r0
    2112:	1f 90       	pop	r1
    2114:	18 95       	reti

00002116 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	SPICS(TRUE);
    2116:	81 e0       	ldi	r24, 0x01	; 1
    2118:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    211c:	82 e0       	ldi	r24, 0x02	; 2
    211e:	e0 ea       	ldi	r30, 0xA0	; 160
    2120:	f6 e0       	ldi	r31, 0x06	; 6
    2122:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2124:	8a ea       	ldi	r24, 0xAA	; 170
    2126:	e0 ec       	ldi	r30, 0xC0	; 192
    2128:	f8 e0       	ldi	r31, 0x08	; 8
    212a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    212c:	82 81       	ldd	r24, Z+2	; 0x02
    212e:	88 23       	and	r24, r24
    2130:	ec f7       	brge	.-6      	; 0x212c <sampleCurrentChannel+0x16>
	SPIBuffer[SPICount] = SPIC.DATA;
    2132:	90 91 a1 50 	lds	r25, 0x50A1
    2136:	e0 ec       	ldi	r30, 0xC0	; 192
    2138:	f8 e0       	ldi	r31, 0x08	; 8
    213a:	83 81       	ldd	r24, Z+3	; 0x03
    213c:	a1 e2       	ldi	r26, 0x21	; 33
    213e:	be e3       	ldi	r27, 0x3E	; 62
    2140:	a9 0f       	add	r26, r25
    2142:	b1 1d       	adc	r27, r1
    2144:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2146:	8a ea       	ldi	r24, 0xAA	; 170
    2148:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    214a:	82 81       	ldd	r24, Z+2	; 0x02
    214c:	88 23       	and	r24, r24
    214e:	ec f7       	brge	.-6      	; 0x214a <sampleCurrentChannel+0x34>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2150:	a0 91 a1 50 	lds	r26, 0x50A1
    2154:	b0 e0       	ldi	r27, 0x00	; 0
    2156:	e0 ec       	ldi	r30, 0xC0	; 192
    2158:	f8 e0       	ldi	r31, 0x08	; 8
    215a:	83 81       	ldd	r24, Z+3	; 0x03
    215c:	ae 5d       	subi	r26, 0xDE	; 222
    215e:	b1 4c       	sbci	r27, 0xC1	; 193
    2160:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2162:	8a ea       	ldi	r24, 0xAA	; 170
    2164:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2166:	82 81       	ldd	r24, Z+2	; 0x02
    2168:	88 23       	and	r24, r24
    216a:	ec f7       	brge	.-6      	; 0x2166 <sampleCurrentChannel+0x50>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    216c:	e0 91 a1 50 	lds	r30, 0x50A1
    2170:	f0 e0       	ldi	r31, 0x00	; 0
    2172:	a0 ec       	ldi	r26, 0xC0	; 192
    2174:	b8 e0       	ldi	r27, 0x08	; 8
    2176:	13 96       	adiw	r26, 0x03	; 3
    2178:	8c 91       	ld	r24, X
    217a:	ed 5d       	subi	r30, 0xDD	; 221
    217c:	f1 4c       	sbci	r31, 0xC1	; 193
    217e:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2180:	82 e0       	ldi	r24, 0x02	; 2
    2182:	e0 ea       	ldi	r30, 0xA0	; 160
    2184:	f6 e0       	ldi	r31, 0x06	; 6
    2186:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    2188:	80 91 a1 50 	lds	r24, 0x50A1
    218c:	8d 5f       	subi	r24, 0xFD	; 253
    218e:	80 93 a1 50 	sts	0x50A1, r24
	SPICS(FALSE);
    2192:	80 e0       	ldi	r24, 0x00	; 0
    2194:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
}
    2198:	08 95       	ret

0000219a <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    219a:	1f 92       	push	r1
    219c:	0f 92       	push	r0
    219e:	0f b6       	in	r0, 0x3f	; 63
    21a0:	0f 92       	push	r0
    21a2:	0b b6       	in	r0, 0x3b	; 59
    21a4:	0f 92       	push	r0
    21a6:	11 24       	eor	r1, r1
    21a8:	2f 93       	push	r18
    21aa:	3f 93       	push	r19
    21ac:	4f 93       	push	r20
    21ae:	5f 93       	push	r21
    21b0:	6f 93       	push	r22
    21b2:	7f 93       	push	r23
    21b4:	8f 93       	push	r24
    21b6:	9f 93       	push	r25
    21b8:	af 93       	push	r26
    21ba:	bf 93       	push	r27
    21bc:	ef 93       	push	r30
    21be:	ff 93       	push	r31
	sampleCurrentChannel();
    21c0:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
	SPICount = 0;
    21c4:	10 92 a1 50 	sts	0x50A1, r1
}
    21c8:	ff 91       	pop	r31
    21ca:	ef 91       	pop	r30
    21cc:	bf 91       	pop	r27
    21ce:	af 91       	pop	r26
    21d0:	9f 91       	pop	r25
    21d2:	8f 91       	pop	r24
    21d4:	7f 91       	pop	r23
    21d6:	6f 91       	pop	r22
    21d8:	5f 91       	pop	r21
    21da:	4f 91       	pop	r20
    21dc:	3f 91       	pop	r19
    21de:	2f 91       	pop	r18
    21e0:	0f 90       	pop	r0
    21e2:	0b be       	out	0x3b, r0	; 59
    21e4:	0f 90       	pop	r0
    21e6:	0f be       	out	0x3f, r0	; 63
    21e8:	0f 90       	pop	r0
    21ea:	1f 90       	pop	r1
    21ec:	18 95       	reti

000021ee <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    21ee:	1f 92       	push	r1
    21f0:	0f 92       	push	r0
    21f2:	0f b6       	in	r0, 0x3f	; 63
    21f4:	0f 92       	push	r0
    21f6:	0b b6       	in	r0, 0x3b	; 59
    21f8:	0f 92       	push	r0
    21fa:	11 24       	eor	r1, r1
    21fc:	2f 93       	push	r18
    21fe:	3f 93       	push	r19
    2200:	4f 93       	push	r20
    2202:	5f 93       	push	r21
    2204:	6f 93       	push	r22
    2206:	7f 93       	push	r23
    2208:	8f 93       	push	r24
    220a:	9f 93       	push	r25
    220c:	af 93       	push	r26
    220e:	bf 93       	push	r27
    2210:	ef 93       	push	r30
    2212:	ff 93       	push	r31
	sampleCurrentChannel();
    2214:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
}
    2218:	ff 91       	pop	r31
    221a:	ef 91       	pop	r30
    221c:	bf 91       	pop	r27
    221e:	af 91       	pop	r26
    2220:	9f 91       	pop	r25
    2222:	8f 91       	pop	r24
    2224:	7f 91       	pop	r23
    2226:	6f 91       	pop	r22
    2228:	5f 91       	pop	r21
    222a:	4f 91       	pop	r20
    222c:	3f 91       	pop	r19
    222e:	2f 91       	pop	r18
    2230:	0f 90       	pop	r0
    2232:	0b be       	out	0x3b, r0	; 59
    2234:	0f 90       	pop	r0
    2236:	0f be       	out	0x3f, r0	; 63
    2238:	0f 90       	pop	r0
    223a:	1f 90       	pop	r1
    223c:	18 95       	reti

0000223e <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    223e:	1f 92       	push	r1
    2240:	0f 92       	push	r0
    2242:	0f b6       	in	r0, 0x3f	; 63
    2244:	0f 92       	push	r0
    2246:	0b b6       	in	r0, 0x3b	; 59
    2248:	0f 92       	push	r0
    224a:	11 24       	eor	r1, r1
    224c:	2f 93       	push	r18
    224e:	3f 93       	push	r19
    2250:	4f 93       	push	r20
    2252:	5f 93       	push	r21
    2254:	6f 93       	push	r22
    2256:	7f 93       	push	r23
    2258:	8f 93       	push	r24
    225a:	9f 93       	push	r25
    225c:	af 93       	push	r26
    225e:	bf 93       	push	r27
    2260:	ef 93       	push	r30
    2262:	ff 93       	push	r31
	sampleCurrentChannel();
    2264:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
}
    2268:	ff 91       	pop	r31
    226a:	ef 91       	pop	r30
    226c:	bf 91       	pop	r27
    226e:	af 91       	pop	r26
    2270:	9f 91       	pop	r25
    2272:	8f 91       	pop	r24
    2274:	7f 91       	pop	r23
    2276:	6f 91       	pop	r22
    2278:	5f 91       	pop	r21
    227a:	4f 91       	pop	r20
    227c:	3f 91       	pop	r19
    227e:	2f 91       	pop	r18
    2280:	0f 90       	pop	r0
    2282:	0b be       	out	0x3b, r0	; 59
    2284:	0f 90       	pop	r0
    2286:	0f be       	out	0x3f, r0	; 63
    2288:	0f 90       	pop	r0
    228a:	1f 90       	pop	r1
    228c:	18 95       	reti

0000228e <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    228e:	1f 92       	push	r1
    2290:	0f 92       	push	r0
    2292:	0f b6       	in	r0, 0x3f	; 63
    2294:	0f 92       	push	r0
    2296:	0b b6       	in	r0, 0x3b	; 59
    2298:	0f 92       	push	r0
    229a:	11 24       	eor	r1, r1
    229c:	2f 93       	push	r18
    229e:	3f 93       	push	r19
    22a0:	4f 93       	push	r20
    22a2:	5f 93       	push	r21
    22a4:	6f 93       	push	r22
    22a6:	7f 93       	push	r23
    22a8:	8f 93       	push	r24
    22aa:	9f 93       	push	r25
    22ac:	af 93       	push	r26
    22ae:	bf 93       	push	r27
    22b0:	ef 93       	push	r30
    22b2:	ff 93       	push	r31
	sampleCurrentChannel();
    22b4:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
}
    22b8:	ff 91       	pop	r31
    22ba:	ef 91       	pop	r30
    22bc:	bf 91       	pop	r27
    22be:	af 91       	pop	r26
    22c0:	9f 91       	pop	r25
    22c2:	8f 91       	pop	r24
    22c4:	7f 91       	pop	r23
    22c6:	6f 91       	pop	r22
    22c8:	5f 91       	pop	r21
    22ca:	4f 91       	pop	r20
    22cc:	3f 91       	pop	r19
    22ce:	2f 91       	pop	r18
    22d0:	0f 90       	pop	r0
    22d2:	0b be       	out	0x3b, r0	; 59
    22d4:	0f 90       	pop	r0
    22d6:	0f be       	out	0x3f, r0	; 63
    22d8:	0f 90       	pop	r0
    22da:	1f 90       	pop	r1
    22dc:	18 95       	reti

000022de <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    22de:	1f 92       	push	r1
    22e0:	0f 92       	push	r0
    22e2:	0f b6       	in	r0, 0x3f	; 63
    22e4:	0f 92       	push	r0
    22e6:	0b b6       	in	r0, 0x3b	; 59
    22e8:	0f 92       	push	r0
    22ea:	11 24       	eor	r1, r1
    22ec:	2f 93       	push	r18
    22ee:	3f 93       	push	r19
    22f0:	4f 93       	push	r20
    22f2:	5f 93       	push	r21
    22f4:	6f 93       	push	r22
    22f6:	7f 93       	push	r23
    22f8:	8f 93       	push	r24
    22fa:	9f 93       	push	r25
    22fc:	af 93       	push	r26
    22fe:	bf 93       	push	r27
    2300:	ef 93       	push	r30
    2302:	ff 93       	push	r31
	sampleCurrentChannel();
    2304:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
	SPICount = 0;
    2308:	10 92 a1 50 	sts	0x50A1, r1
	if(PORTB.OUT & PIN1_bm) {
    230c:	e0 e2       	ldi	r30, 0x20	; 32
    230e:	f6 e0       	ldi	r31, 0x06	; 6
    2310:	84 81       	ldd	r24, Z+4	; 0x04
    2312:	81 ff       	sbrs	r24, 1
    2314:	0f c0       	rjmp	.+30     	; 0x2334 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2316:	e0 e0       	ldi	r30, 0x00	; 0
    2318:	f6 e0       	ldi	r31, 0x06	; 6
    231a:	84 81       	ldd	r24, Z+4	; 0x04
    231c:	86 ff       	sbrs	r24, 6
    231e:	05 c0       	rjmp	.+10     	; 0x232a <__vector_19+0x4c>
    2320:	82 e0       	ldi	r24, 0x02	; 2
    2322:	e0 e2       	ldi	r30, 0x20	; 32
    2324:	f6 e0       	ldi	r31, 0x06	; 6
    2326:	87 83       	std	Z+7, r24	; 0x07
    2328:	0d c0       	rjmp	.+26     	; 0x2344 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    232a:	80 e4       	ldi	r24, 0x40	; 64
    232c:	e0 e0       	ldi	r30, 0x00	; 0
    232e:	f6 e0       	ldi	r31, 0x06	; 6
    2330:	87 83       	std	Z+7, r24	; 0x07
    2332:	08 c0       	rjmp	.+16     	; 0x2344 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2334:	80 e4       	ldi	r24, 0x40	; 64
    2336:	e0 e0       	ldi	r30, 0x00	; 0
    2338:	f6 e0       	ldi	r31, 0x06	; 6
    233a:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    233c:	82 e0       	ldi	r24, 0x02	; 2
    233e:	e0 e2       	ldi	r30, 0x20	; 32
    2340:	f6 e0       	ldi	r31, 0x06	; 6
    2342:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    2344:	ff 91       	pop	r31
    2346:	ef 91       	pop	r30
    2348:	bf 91       	pop	r27
    234a:	af 91       	pop	r26
    234c:	9f 91       	pop	r25
    234e:	8f 91       	pop	r24
    2350:	7f 91       	pop	r23
    2352:	6f 91       	pop	r22
    2354:	5f 91       	pop	r21
    2356:	4f 91       	pop	r20
    2358:	3f 91       	pop	r19
    235a:	2f 91       	pop	r18
    235c:	0f 90       	pop	r0
    235e:	0b be       	out	0x3b, r0	; 59
    2360:	0f 90       	pop	r0
    2362:	0f be       	out	0x3f, r0	; 63
    2364:	0f 90       	pop	r0
    2366:	1f 90       	pop	r1
    2368:	18 95       	reti

0000236a <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    236a:	1f 92       	push	r1
    236c:	0f 92       	push	r0
    236e:	0f b6       	in	r0, 0x3f	; 63
    2370:	0f 92       	push	r0
    2372:	0b b6       	in	r0, 0x3b	; 59
    2374:	0f 92       	push	r0
    2376:	11 24       	eor	r1, r1
    2378:	2f 93       	push	r18
    237a:	3f 93       	push	r19
    237c:	4f 93       	push	r20
    237e:	5f 93       	push	r21
    2380:	6f 93       	push	r22
    2382:	7f 93       	push	r23
    2384:	8f 93       	push	r24
    2386:	9f 93       	push	r25
    2388:	af 93       	push	r26
    238a:	bf 93       	push	r27
    238c:	ef 93       	push	r30
    238e:	ff 93       	push	r31
	sampleCurrentChannel();
    2390:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
}
    2394:	ff 91       	pop	r31
    2396:	ef 91       	pop	r30
    2398:	bf 91       	pop	r27
    239a:	af 91       	pop	r26
    239c:	9f 91       	pop	r25
    239e:	8f 91       	pop	r24
    23a0:	7f 91       	pop	r23
    23a2:	6f 91       	pop	r22
    23a4:	5f 91       	pop	r21
    23a6:	4f 91       	pop	r20
    23a8:	3f 91       	pop	r19
    23aa:	2f 91       	pop	r18
    23ac:	0f 90       	pop	r0
    23ae:	0b be       	out	0x3b, r0	; 59
    23b0:	0f 90       	pop	r0
    23b2:	0f be       	out	0x3f, r0	; 63
    23b4:	0f 90       	pop	r0
    23b6:	1f 90       	pop	r1
    23b8:	18 95       	reti

000023ba <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    23ba:	1f 92       	push	r1
    23bc:	0f 92       	push	r0
    23be:	0f b6       	in	r0, 0x3f	; 63
    23c0:	0f 92       	push	r0
    23c2:	0b b6       	in	r0, 0x3b	; 59
    23c4:	0f 92       	push	r0
    23c6:	11 24       	eor	r1, r1
    23c8:	2f 93       	push	r18
    23ca:	3f 93       	push	r19
    23cc:	4f 93       	push	r20
    23ce:	5f 93       	push	r21
    23d0:	6f 93       	push	r22
    23d2:	7f 93       	push	r23
    23d4:	8f 93       	push	r24
    23d6:	9f 93       	push	r25
    23d8:	af 93       	push	r26
    23da:	bf 93       	push	r27
    23dc:	ef 93       	push	r30
    23de:	ff 93       	push	r31
	sampleCurrentChannel();
    23e0:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
}
    23e4:	ff 91       	pop	r31
    23e6:	ef 91       	pop	r30
    23e8:	bf 91       	pop	r27
    23ea:	af 91       	pop	r26
    23ec:	9f 91       	pop	r25
    23ee:	8f 91       	pop	r24
    23f0:	7f 91       	pop	r23
    23f2:	6f 91       	pop	r22
    23f4:	5f 91       	pop	r21
    23f6:	4f 91       	pop	r20
    23f8:	3f 91       	pop	r19
    23fa:	2f 91       	pop	r18
    23fc:	0f 90       	pop	r0
    23fe:	0b be       	out	0x3b, r0	; 59
    2400:	0f 90       	pop	r0
    2402:	0f be       	out	0x3f, r0	; 63
    2404:	0f 90       	pop	r0
    2406:	1f 90       	pop	r1
    2408:	18 95       	reti

0000240a <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    240a:	1f 92       	push	r1
    240c:	0f 92       	push	r0
    240e:	0f b6       	in	r0, 0x3f	; 63
    2410:	0f 92       	push	r0
    2412:	0b b6       	in	r0, 0x3b	; 59
    2414:	0f 92       	push	r0
    2416:	11 24       	eor	r1, r1
    2418:	2f 93       	push	r18
    241a:	3f 93       	push	r19
    241c:	4f 93       	push	r20
    241e:	5f 93       	push	r21
    2420:	6f 93       	push	r22
    2422:	7f 93       	push	r23
    2424:	8f 93       	push	r24
    2426:	9f 93       	push	r25
    2428:	af 93       	push	r26
    242a:	bf 93       	push	r27
    242c:	ef 93       	push	r30
    242e:	ff 93       	push	r31
	sampleCurrentChannel();
    2430:	0e 94 8b 10 	call	0x2116	; 0x2116 <sampleCurrentChannel>
}
    2434:	ff 91       	pop	r31
    2436:	ef 91       	pop	r30
    2438:	bf 91       	pop	r27
    243a:	af 91       	pop	r26
    243c:	9f 91       	pop	r25
    243e:	8f 91       	pop	r24
    2440:	7f 91       	pop	r23
    2442:	6f 91       	pop	r22
    2444:	5f 91       	pop	r21
    2446:	4f 91       	pop	r20
    2448:	3f 91       	pop	r19
    244a:	2f 91       	pop	r18
    244c:	0f 90       	pop	r0
    244e:	0b be       	out	0x3b, r0	; 59
    2450:	0f 90       	pop	r0
    2452:	0f be       	out	0x3f, r0	; 63
    2454:	0f 90       	pop	r0
    2456:	1f 90       	pop	r1
    2458:	18 95       	reti

0000245a <writeSE2FRAM>:
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    245a:	ff 92       	push	r15
    245c:	0f 93       	push	r16
    245e:	1f 93       	push	r17
    2460:	cf 93       	push	r28
    2462:	df 93       	push	r29
    2464:	cd b7       	in	r28, 0x3d	; 61
    2466:	de b7       	in	r29, 0x3e	; 62
    2468:	28 97       	sbiw	r28, 0x08	; 8
    246a:	cd bf       	out	0x3d, r28	; 61
    246c:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    246e:	19 82       	std	Y+1, r1	; 0x01
    2470:	1a 82       	std	Y+2, r1	; 0x02
    2472:	1b 82       	std	Y+3, r1	; 0x03
    2474:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2476:	80 91 66 50 	lds	r24, 0x5066
    247a:	90 91 67 50 	lds	r25, 0x5067
    247e:	a0 91 68 50 	lds	r26, 0x5068
    2482:	b0 91 69 50 	lds	r27, 0x5069
    2486:	01 96       	adiw	r24, 0x01	; 1
    2488:	a1 1d       	adc	r26, r1
    248a:	b1 1d       	adc	r27, r1
    248c:	80 93 66 50 	sts	0x5066, r24
    2490:	90 93 67 50 	sts	0x5067, r25
    2494:	a0 93 68 50 	sts	0x5068, r26
    2498:	b0 93 69 50 	sts	0x5069, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    249c:	80 ed       	ldi	r24, 0xD0	; 208
    249e:	80 93 c0 08 	sts	0x08C0, r24
    24a2:	20 e0       	ldi	r18, 0x00	; 0
    24a4:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    24a6:	01 e2       	ldi	r16, 0x21	; 33
    24a8:	1e e3       	ldi	r17, 0x3E	; 62
    24aa:	ff 24       	eor	r15, r15
    24ac:	fa 94       	dec	r15
    24ae:	c9 01       	movw	r24, r18
    24b0:	f8 01       	movw	r30, r16
    24b2:	e2 0f       	add	r30, r18
    24b4:	f3 1f       	adc	r31, r19
    24b6:	40 81       	ld	r20, Z
    24b8:	44 23       	and	r20, r20
    24ba:	14 f4       	brge	.+4      	; 0x24c0 <writeSE2FRAM+0x66>
    24bc:	f8 86       	std	Y+8, r15	; 0x08
    24be:	01 c0       	rjmp	.+2      	; 0x24c2 <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    24c0:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    24c2:	80 0f       	add	r24, r16
    24c4:	91 1f       	adc	r25, r17
    24c6:	fc 01       	movw	r30, r24
    24c8:	80 81       	ld	r24, Z
    24ca:	8f 83       	std	Y+7, r24	; 0x07
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    24cc:	f9 01       	movw	r30, r18
    24ce:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    24d0:	e0 0f       	add	r30, r16
    24d2:	f1 1f       	adc	r31, r17
    24d4:	80 81       	ld	r24, Z
    24d6:	8e 83       	std	Y+6, r24	; 0x06
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    24d8:	f9 01       	movw	r30, r18
    24da:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    24dc:	e0 0f       	add	r30, r16
    24de:	f1 1f       	adc	r31, r17
    24e0:	80 81       	ld	r24, Z
    24e2:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    24e4:	49 81       	ldd	r20, Y+1	; 0x01
    24e6:	5a 81       	ldd	r21, Y+2	; 0x02
    24e8:	6b 81       	ldd	r22, Y+3	; 0x03
    24ea:	7c 81       	ldd	r23, Y+4	; 0x04
    24ec:	8d 81       	ldd	r24, Y+5	; 0x05
    24ee:	9e 81       	ldd	r25, Y+6	; 0x06
    24f0:	af 81       	ldd	r26, Y+7	; 0x07
    24f2:	b8 85       	ldd	r27, Y+8	; 0x08
    24f4:	84 0f       	add	r24, r20
    24f6:	95 1f       	adc	r25, r21
    24f8:	a6 1f       	adc	r26, r22
    24fa:	b7 1f       	adc	r27, r23
    24fc:	89 83       	std	Y+1, r24	; 0x01
    24fe:	9a 83       	std	Y+2, r25	; 0x02
    2500:	ab 83       	std	Y+3, r26	; 0x03
    2502:	bc 83       	std	Y+4, r27	; 0x04
    2504:	2d 5f       	subi	r18, 0xFD	; 253
    2506:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2508:	2c 30       	cpi	r18, 0x0C	; 12
    250a:	31 05       	cpc	r19, r1
    250c:	81 f6       	brne	.-96     	; 0x24ae <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    250e:	69 81       	ldd	r22, Y+1	; 0x01
    2510:	7a 81       	ldd	r23, Y+2	; 0x02
    2512:	8b 81       	ldd	r24, Y+3	; 0x03
    2514:	9c 81       	ldd	r25, Y+4	; 0x04
    2516:	24 e0       	ldi	r18, 0x04	; 4
    2518:	30 e0       	ldi	r19, 0x00	; 0
    251a:	40 e0       	ldi	r20, 0x00	; 0
    251c:	50 e0       	ldi	r21, 0x00	; 0
    251e:	0e 94 fc 37 	call	0x6ff8	; 0x6ff8 <__divmodsi4>
    2522:	29 83       	std	Y+1, r18	; 0x01
    2524:	3a 83       	std	Y+2, r19	; 0x02
    2526:	4b 83       	std	Y+3, r20	; 0x03
    2528:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    252a:	29 81       	ldd	r18, Y+1	; 0x01
    252c:	83 e2       	ldi	r24, 0x23	; 35
    252e:	9e e3       	ldi	r25, 0x3E	; 62
    2530:	20 93 23 3e 	sts	0x3E23, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2534:	2a 81       	ldd	r18, Y+2	; 0x02
    2536:	fc 01       	movw	r30, r24
    2538:	31 97       	sbiw	r30, 0x01	; 1
    253a:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    253c:	2b 81       	ldd	r18, Y+3	; 0x03
    253e:	02 97       	sbiw	r24, 0x02	; 2
    2540:	fc 01       	movw	r30, r24
    2542:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2544:	80 e1       	ldi	r24, 0x10	; 16
    2546:	e0 e4       	ldi	r30, 0x40	; 64
    2548:	f6 e0       	ldi	r31, 0x06	; 6
    254a:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    254c:	88 e0       	ldi	r24, 0x08	; 8
    254e:	e0 e2       	ldi	r30, 0x20	; 32
    2550:	f6 e0       	ldi	r31, 0x06	; 6
    2552:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2554:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2556:	86 e0       	ldi	r24, 0x06	; 6
    2558:	e0 ec       	ldi	r30, 0xC0	; 192
    255a:	f8 e0       	ldi	r31, 0x08	; 8
    255c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    255e:	82 81       	ldd	r24, Z+2	; 0x02
    2560:	88 23       	and	r24, r24
    2562:	ec f7       	brge	.-6      	; 0x255e <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    2564:	e0 ec       	ldi	r30, 0xC0	; 192
    2566:	f8 e0       	ldi	r31, 0x08	; 8
    2568:	83 81       	ldd	r24, Z+3	; 0x03
    256a:	80 93 2d 3e 	sts	0x3E2D, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    256e:	a0 e2       	ldi	r26, 0x20	; 32
    2570:	b6 e0       	ldi	r27, 0x06	; 6
    2572:	88 e0       	ldi	r24, 0x08	; 8
    2574:	15 96       	adiw	r26, 0x05	; 5
    2576:	8c 93       	st	X, r24
    2578:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    257a:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    257c:	16 96       	adiw	r26, 0x06	; 6
    257e:	8c 93       	st	X, r24
    2580:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    2582:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2584:	82 e0       	ldi	r24, 0x02	; 2
    2586:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2588:	82 81       	ldd	r24, Z+2	; 0x02
    258a:	88 23       	and	r24, r24
    258c:	ec f7       	brge	.-6      	; 0x2588 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    258e:	e0 ec       	ldi	r30, 0xC0	; 192
    2590:	f8 e0       	ldi	r31, 0x08	; 8
    2592:	83 81       	ldd	r24, Z+3	; 0x03
    2594:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2598:	80 91 1f 3e 	lds	r24, 0x3E1F
    259c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    259e:	82 81       	ldd	r24, Z+2	; 0x02
    25a0:	88 23       	and	r24, r24
    25a2:	ec f7       	brge	.-6      	; 0x259e <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    25a4:	e0 ec       	ldi	r30, 0xC0	; 192
    25a6:	f8 e0       	ldi	r31, 0x08	; 8
    25a8:	83 81       	ldd	r24, Z+3	; 0x03
    25aa:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    25ae:	80 91 1e 3e 	lds	r24, 0x3E1E
    25b2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25b4:	82 81       	ldd	r24, Z+2	; 0x02
    25b6:	88 23       	and	r24, r24
    25b8:	ec f7       	brge	.-6      	; 0x25b4 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    25ba:	e0 ec       	ldi	r30, 0xC0	; 192
    25bc:	f8 e0       	ldi	r31, 0x08	; 8
    25be:	83 81       	ldd	r24, Z+3	; 0x03
    25c0:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[0];
    25c4:	80 91 21 3e 	lds	r24, 0x3E21
    25c8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25ca:	82 81       	ldd	r24, Z+2	; 0x02
    25cc:	88 23       	and	r24, r24
    25ce:	ec f7       	brge	.-6      	; 0x25ca <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    25d0:	e0 ec       	ldi	r30, 0xC0	; 192
    25d2:	f8 e0       	ldi	r31, 0x08	; 8
    25d4:	83 81       	ldd	r24, Z+3	; 0x03
    25d6:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[1];
    25da:	80 91 22 3e 	lds	r24, 0x3E22
    25de:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25e0:	82 81       	ldd	r24, Z+2	; 0x02
    25e2:	88 23       	and	r24, r24
    25e4:	ec f7       	brge	.-6      	; 0x25e0 <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    25e6:	e0 ec       	ldi	r30, 0xC0	; 192
    25e8:	f8 e0       	ldi	r31, 0x08	; 8
    25ea:	83 81       	ldd	r24, Z+3	; 0x03
    25ec:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[2];
    25f0:	80 91 23 3e 	lds	r24, 0x3E23
    25f4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25f6:	82 81       	ldd	r24, Z+2	; 0x02
    25f8:	88 23       	and	r24, r24
    25fa:	ec f7       	brge	.-6      	; 0x25f6 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    25fc:	a0 ec       	ldi	r26, 0xC0	; 192
    25fe:	b8 e0       	ldi	r27, 0x08	; 8
    2600:	13 96       	adiw	r26, 0x03	; 3
    2602:	8c 91       	ld	r24, X
    2604:	13 97       	sbiw	r26, 0x03	; 3
    2606:	80 93 2d 3e 	sts	0x3E2D, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    260a:	88 e0       	ldi	r24, 0x08	; 8
    260c:	e0 e2       	ldi	r30, 0x20	; 32
    260e:	f6 e0       	ldi	r31, 0x06	; 6
    2610:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2612:	e0 e4       	ldi	r30, 0x40	; 64
    2614:	f6 e0       	ldi	r31, 0x06	; 6
    2616:	80 e1       	ldi	r24, 0x10	; 16
    2618:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    261a:	94 e5       	ldi	r25, 0x54	; 84
    261c:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    261e:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    2620:	80 91 1e 3e 	lds	r24, 0x3E1E
    2624:	90 91 1f 3e 	lds	r25, 0x3E1F
    2628:	03 96       	adiw	r24, 0x03	; 3
    262a:	80 93 1e 3e 	sts	0x3E1E, r24
    262e:	90 93 1f 3e 	sts	0x3E1F, r25
	checksumADC[0] += SPIBuffer[0];
    2632:	80 91 12 21 	lds	r24, 0x2112
    2636:	e1 e2       	ldi	r30, 0x21	; 33
    2638:	fe e3       	ldi	r31, 0x3E	; 62
    263a:	90 81       	ld	r25, Z
    263c:	89 0f       	add	r24, r25
    263e:	80 93 12 21 	sts	0x2112, r24
	checksumADC[1] += SPIBuffer[1];
    2642:	80 91 13 21 	lds	r24, 0x2113
    2646:	91 81       	ldd	r25, Z+1	; 0x01
    2648:	89 0f       	add	r24, r25
    264a:	80 93 13 21 	sts	0x2113, r24
	checksumADC[2] += SPIBuffer[2];
    264e:	80 91 14 21 	lds	r24, 0x2114
    2652:	92 81       	ldd	r25, Z+2	; 0x02
    2654:	89 0f       	add	r24, r25
    2656:	80 93 14 21 	sts	0x2114, r24
}
    265a:	28 96       	adiw	r28, 0x08	; 8
    265c:	cd bf       	out	0x3d, r28	; 61
    265e:	de bf       	out	0x3e, r29	; 62
    2660:	df 91       	pop	r29
    2662:	cf 91       	pop	r28
    2664:	1f 91       	pop	r17
    2666:	0f 91       	pop	r16
    2668:	ff 90       	pop	r15
    266a:	08 95       	ret

0000266c <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    266c:	2f 92       	push	r2
    266e:	3f 92       	push	r3
    2670:	4f 92       	push	r4
    2672:	5f 92       	push	r5
    2674:	6f 92       	push	r6
    2676:	7f 92       	push	r7
    2678:	8f 92       	push	r8
    267a:	9f 92       	push	r9
    267c:	af 92       	push	r10
    267e:	bf 92       	push	r11
    2680:	cf 92       	push	r12
    2682:	df 92       	push	r13
    2684:	ef 92       	push	r14
    2686:	ff 92       	push	r15
    2688:	0f 93       	push	r16
    268a:	1f 93       	push	r17
    268c:	cf 93       	push	r28
    268e:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    2690:	10 92 1e 3e 	sts	0x3E1E, r1
    2694:	10 92 1f 3e 	sts	0x3E1F, r1
	sampleCount = 0;
    2698:	10 92 66 50 	sts	0x5066, r1
    269c:	10 92 67 50 	sts	0x5067, r1
    26a0:	10 92 68 50 	sts	0x5068, r1
    26a4:	10 92 69 50 	sts	0x5069, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    26a8:	84 e1       	ldi	r24, 0x14	; 20
    26aa:	91 e2       	ldi	r25, 0x21	; 33
    26ac:	10 92 14 21 	sts	0x2114, r1
    26b0:	fc 01       	movw	r30, r24
    26b2:	31 97       	sbiw	r30, 0x01	; 1
    26b4:	10 82       	st	Z, r1
    26b6:	02 97       	sbiw	r24, 0x02	; 2
    26b8:	dc 01       	movw	r26, r24
    26ba:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    26bc:	81 e0       	ldi	r24, 0x01	; 1
    26be:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    26c2:	84 e0       	ldi	r24, 0x04	; 4
    26c4:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    26c8:	80 ed       	ldi	r24, 0xD0	; 208
    26ca:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    26ce:	8d e0       	ldi	r24, 0x0D	; 13
    26d0:	80 93 21 3e 	sts	0x3E21, r24
	SPIBuffer[1] = 0xF3;
    26d4:	83 ef       	ldi	r24, 0xF3	; 243
    26d6:	80 93 22 3e 	sts	0x3E22, r24
	SPIBuffer[2] = 0x57;
    26da:	87 e5       	ldi	r24, 0x57	; 87
    26dc:	80 93 23 3e 	sts	0x3E23, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    26e0:	80 91 66 50 	lds	r24, 0x5066
    26e4:	90 91 67 50 	lds	r25, 0x5067
    26e8:	a0 91 68 50 	lds	r26, 0x5068
    26ec:	b0 91 69 50 	lds	r27, 0x5069
    26f0:	83 35       	cpi	r24, 0x53	; 83
    26f2:	e5 e5       	ldi	r30, 0x55	; 85
    26f4:	9e 07       	cpc	r25, r30
    26f6:	e0 e0       	ldi	r30, 0x00	; 0
    26f8:	ae 07       	cpc	r26, r30
    26fa:	e0 e0       	ldi	r30, 0x00	; 0
    26fc:	be 07       	cpc	r27, r30
    26fe:	08 f0       	brcs	.+2      	; 0x2702 <FRAMWriteKnowns+0x96>
    2700:	cc c0       	rjmp	.+408    	; 0x289a <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2702:	0f 2e       	mov	r0, r31
    2704:	f0 e4       	ldi	r31, 0x40	; 64
    2706:	ef 2e       	mov	r14, r31
    2708:	f6 e0       	ldi	r31, 0x06	; 6
    270a:	ff 2e       	mov	r15, r31
    270c:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    270e:	40 e2       	ldi	r20, 0x20	; 32
    2710:	56 e0       	ldi	r21, 0x06	; 6
    2712:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2714:	e0 ec       	ldi	r30, 0xC0	; 192
    2716:	f8 e0       	ldi	r31, 0x08	; 8
    2718:	0f 2e       	mov	r0, r31
    271a:	f6 e0       	ldi	r31, 0x06	; 6
    271c:	7f 2e       	mov	r7, r31
    271e:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    2720:	cd e2       	ldi	r28, 0x2D	; 45
    2722:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2724:	66 24       	eor	r6, r6
    2726:	68 94       	set
    2728:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    272a:	0f 2e       	mov	r0, r31
    272c:	fe e1       	ldi	r31, 0x1E	; 30
    272e:	cf 2e       	mov	r12, r31
    2730:	fe e3       	ldi	r31, 0x3E	; 62
    2732:	df 2e       	mov	r13, r31
    2734:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2736:	8e 01       	movw	r16, r28
    2738:	0c 50       	subi	r16, 0x0C	; 12
    273a:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    273c:	0f 2e       	mov	r0, r31
    273e:	f5 ef       	ldi	r31, 0xF5	; 245
    2740:	4f 2e       	mov	r4, r31
    2742:	ff ef       	ldi	r31, 0xFF	; 255
    2744:	5f 2e       	mov	r5, r31
    2746:	f0 2d       	mov	r31, r0
    2748:	4c 0e       	add	r4, r28
    274a:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    274c:	0f 2e       	mov	r0, r31
    274e:	f6 ef       	ldi	r31, 0xF6	; 246
    2750:	2f 2e       	mov	r2, r31
    2752:	ff ef       	ldi	r31, 0xFF	; 255
    2754:	3f 2e       	mov	r3, r31
    2756:	f0 2d       	mov	r31, r0
    2758:	2c 0e       	add	r2, r28
    275a:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    275c:	62 e1       	ldi	r22, 0x12	; 18
    275e:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    2760:	5b 01       	movw	r10, r22
    2762:	08 94       	sec
    2764:	a1 1c       	adc	r10, r1
    2766:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2768:	88 24       	eor	r8, r8
    276a:	99 24       	eor	r9, r9
    276c:	68 94       	set
    276e:	81 f8       	bld	r8, 1
    2770:	86 0e       	add	r8, r22
    2772:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2774:	30 e1       	ldi	r19, 0x10	; 16
    2776:	d7 01       	movw	r26, r14
    2778:	16 96       	adiw	r26, 0x06	; 6
    277a:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    277c:	da 01       	movw	r26, r20
    277e:	16 96       	adiw	r26, 0x06	; 6
    2780:	2c 93       	st	X, r18
    2782:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2784:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2786:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2788:	82 81       	ldd	r24, Z+2	; 0x02
    278a:	88 23       	and	r24, r24
    278c:	ec f7       	brge	.-6      	; 0x2788 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    278e:	83 81       	ldd	r24, Z+3	; 0x03
    2790:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    2792:	da 01       	movw	r26, r20
    2794:	15 96       	adiw	r26, 0x05	; 5
    2796:	2c 93       	st	X, r18
    2798:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    279a:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    279c:	16 96       	adiw	r26, 0x06	; 6
    279e:	2c 93       	st	X, r18
    27a0:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    27a2:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    27a4:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27a6:	82 81       	ldd	r24, Z+2	; 0x02
    27a8:	88 23       	and	r24, r24
    27aa:	ec f7       	brge	.-6      	; 0x27a6 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    27ac:	83 81       	ldd	r24, Z+3	; 0x03
    27ae:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    27b0:	d6 01       	movw	r26, r12
    27b2:	11 96       	adiw	r26, 0x01	; 1
    27b4:	8c 91       	ld	r24, X
    27b6:	11 97       	sbiw	r26, 0x01	; 1
    27b8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27ba:	82 81       	ldd	r24, Z+2	; 0x02
    27bc:	88 23       	and	r24, r24
    27be:	ec f7       	brge	.-6      	; 0x27ba <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    27c0:	83 81       	ldd	r24, Z+3	; 0x03
    27c2:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    27c4:	d6 01       	movw	r26, r12
    27c6:	8c 91       	ld	r24, X
    27c8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27ca:	82 81       	ldd	r24, Z+2	; 0x02
    27cc:	88 23       	and	r24, r24
    27ce:	ec f7       	brge	.-6      	; 0x27ca <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    27d0:	83 81       	ldd	r24, Z+3	; 0x03
    27d2:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    27d4:	d8 01       	movw	r26, r16
    27d6:	8c 91       	ld	r24, X
    27d8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27da:	82 81       	ldd	r24, Z+2	; 0x02
    27dc:	88 23       	and	r24, r24
    27de:	ec f7       	brge	.-6      	; 0x27da <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    27e0:	83 81       	ldd	r24, Z+3	; 0x03
    27e2:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    27e4:	d2 01       	movw	r26, r4
    27e6:	8c 91       	ld	r24, X
    27e8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27ea:	82 81       	ldd	r24, Z+2	; 0x02
    27ec:	88 23       	and	r24, r24
    27ee:	ec f7       	brge	.-6      	; 0x27ea <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    27f0:	83 81       	ldd	r24, Z+3	; 0x03
    27f2:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    27f4:	d1 01       	movw	r26, r2
    27f6:	8c 91       	ld	r24, X
    27f8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27fa:	82 81       	ldd	r24, Z+2	; 0x02
    27fc:	88 23       	and	r24, r24
    27fe:	ec f7       	brge	.-6      	; 0x27fa <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    2800:	83 81       	ldd	r24, Z+3	; 0x03
    2802:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2804:	da 01       	movw	r26, r20
    2806:	15 96       	adiw	r26, 0x05	; 5
    2808:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    280a:	30 e1       	ldi	r19, 0x10	; 16
    280c:	d7 01       	movw	r26, r14
    280e:	15 96       	adiw	r26, 0x05	; 5
    2810:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    2812:	80 91 1e 3e 	lds	r24, 0x3E1E
    2816:	90 91 1f 3e 	lds	r25, 0x3E1F
    281a:	03 96       	adiw	r24, 0x03	; 3
    281c:	80 93 1e 3e 	sts	0x3E1E, r24
    2820:	90 93 1f 3e 	sts	0x3E1F, r25
		checksumADC[0] += SPIBuffer[0];
    2824:	db 01       	movw	r26, r22
    2826:	8c 91       	ld	r24, X
    2828:	d8 01       	movw	r26, r16
    282a:	9c 91       	ld	r25, X
    282c:	89 0f       	add	r24, r25
    282e:	db 01       	movw	r26, r22
    2830:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2832:	d5 01       	movw	r26, r10
    2834:	8c 91       	ld	r24, X
    2836:	a2 e2       	ldi	r26, 0x22	; 34
    2838:	be e3       	ldi	r27, 0x3E	; 62
    283a:	9c 91       	ld	r25, X
    283c:	89 0f       	add	r24, r25
    283e:	d5 01       	movw	r26, r10
    2840:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2842:	d4 01       	movw	r26, r8
    2844:	8c 91       	ld	r24, X
    2846:	a3 e2       	ldi	r26, 0x23	; 35
    2848:	be e3       	ldi	r27, 0x3E	; 62
    284a:	9c 91       	ld	r25, X
    284c:	89 0f       	add	r24, r25
    284e:	d4 01       	movw	r26, r8
    2850:	8c 93       	st	X, r24
		
		sampleCount++;
    2852:	80 91 66 50 	lds	r24, 0x5066
    2856:	90 91 67 50 	lds	r25, 0x5067
    285a:	a0 91 68 50 	lds	r26, 0x5068
    285e:	b0 91 69 50 	lds	r27, 0x5069
    2862:	01 96       	adiw	r24, 0x01	; 1
    2864:	a1 1d       	adc	r26, r1
    2866:	b1 1d       	adc	r27, r1
    2868:	80 93 66 50 	sts	0x5066, r24
    286c:	90 93 67 50 	sts	0x5067, r25
    2870:	a0 93 68 50 	sts	0x5068, r26
    2874:	b0 93 69 50 	sts	0x5069, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2878:	80 91 66 50 	lds	r24, 0x5066
    287c:	90 91 67 50 	lds	r25, 0x5067
    2880:	a0 91 68 50 	lds	r26, 0x5068
    2884:	b0 91 69 50 	lds	r27, 0x5069
    2888:	83 35       	cpi	r24, 0x53	; 83
    288a:	35 e5       	ldi	r19, 0x55	; 85
    288c:	93 07       	cpc	r25, r19
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	a3 07       	cpc	r26, r19
    2892:	30 e0       	ldi	r19, 0x00	; 0
    2894:	b3 07       	cpc	r27, r19
    2896:	08 f4       	brcc	.+2      	; 0x289a <FRAMWriteKnowns+0x22e>
    2898:	6d cf       	rjmp	.-294    	; 0x2774 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    289a:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	ADCPower(FALSE);
    289e:	80 e0       	ldi	r24, 0x00	; 0
    28a0:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
}
    28a4:	df 91       	pop	r29
    28a6:	cf 91       	pop	r28
    28a8:	1f 91       	pop	r17
    28aa:	0f 91       	pop	r16
    28ac:	ff 90       	pop	r15
    28ae:	ef 90       	pop	r14
    28b0:	df 90       	pop	r13
    28b2:	cf 90       	pop	r12
    28b4:	bf 90       	pop	r11
    28b6:	af 90       	pop	r10
    28b8:	9f 90       	pop	r9
    28ba:	8f 90       	pop	r8
    28bc:	7f 90       	pop	r7
    28be:	6f 90       	pop	r6
    28c0:	5f 90       	pop	r5
    28c2:	4f 90       	pop	r4
    28c4:	3f 90       	pop	r3
    28c6:	2f 90       	pop	r2
    28c8:	08 95       	ret

000028ca <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    28ca:	80 ff       	sbrs	r24, 0
    28cc:	05 c0       	rjmp	.+10     	; 0x28d8 <setADCInput+0xe>
    28ce:	20 e4       	ldi	r18, 0x40	; 64
    28d0:	e0 e0       	ldi	r30, 0x00	; 0
    28d2:	f6 e0       	ldi	r31, 0x06	; 6
    28d4:	25 83       	std	Z+5, r18	; 0x05
    28d6:	04 c0       	rjmp	.+8      	; 0x28e0 <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    28d8:	20 e4       	ldi	r18, 0x40	; 64
    28da:	e0 e0       	ldi	r30, 0x00	; 0
    28dc:	f6 e0       	ldi	r31, 0x06	; 6
    28de:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    28e0:	81 ff       	sbrs	r24, 1
    28e2:	05 c0       	rjmp	.+10     	; 0x28ee <setADCInput+0x24>
    28e4:	22 e0       	ldi	r18, 0x02	; 2
    28e6:	e0 e2       	ldi	r30, 0x20	; 32
    28e8:	f6 e0       	ldi	r31, 0x06	; 6
    28ea:	25 83       	std	Z+5, r18	; 0x05
    28ec:	04 c0       	rjmp	.+8      	; 0x28f6 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    28ee:	22 e0       	ldi	r18, 0x02	; 2
    28f0:	e0 e2       	ldi	r30, 0x20	; 32
    28f2:	f6 e0       	ldi	r31, 0x06	; 6
    28f4:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    28f6:	82 ff       	sbrs	r24, 2
    28f8:	05 c0       	rjmp	.+10     	; 0x2904 <setADCInput+0x3a>
    28fa:	84 e0       	ldi	r24, 0x04	; 4
    28fc:	e0 e2       	ldi	r30, 0x20	; 32
    28fe:	f6 e0       	ldi	r31, 0x06	; 6
    2900:	85 83       	std	Z+5, r24	; 0x05
    2902:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2904:	84 e0       	ldi	r24, 0x04	; 4
    2906:	e0 e2       	ldi	r30, 0x20	; 32
    2908:	f6 e0       	ldi	r31, 0x06	; 6
    290a:	86 83       	std	Z+6, r24	; 0x06
    290c:	08 95       	ret

0000290e <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    290e:	2f 92       	push	r2
    2910:	3f 92       	push	r3
    2912:	4f 92       	push	r4
    2914:	5f 92       	push	r5
    2916:	7f 92       	push	r7
    2918:	8f 92       	push	r8
    291a:	9f 92       	push	r9
    291c:	af 92       	push	r10
    291e:	bf 92       	push	r11
    2920:	cf 92       	push	r12
    2922:	df 92       	push	r13
    2924:	ef 92       	push	r14
    2926:	ff 92       	push	r15
    2928:	0f 93       	push	r16
    292a:	1f 93       	push	r17
    292c:	cf 93       	push	r28
    292e:	df 93       	push	r29
    2930:	cd b7       	in	r28, 0x3d	; 61
    2932:	de b7       	in	r29, 0x3e	; 62
    2934:	18 2f       	mov	r17, r24
    2936:	76 2e       	mov	r7, r22
    2938:	f4 2e       	mov	r15, r20
    293a:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    293c:	89 8d       	ldd	r24, Y+25	; 0x19
    293e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2940:	80 93 64 50 	sts	0x5064, r24
    2944:	90 93 65 50 	sts	0x5065, r25
	ADC_Sampling_Finished = 0;
    2948:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    294c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    294e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2950:	80 93 a8 50 	sts	0x50A8, r24
    2954:	90 93 a9 50 	sts	0x50A9, r25
	if(use_FRAM){
    2958:	8d 8d       	ldd	r24, Y+29	; 0x1d
    295a:	88 23       	and	r24, r24
    295c:	21 f0       	breq	.+8      	; 0x2966 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	80 93 49 40 	sts	0x4049, r24
    2964:	02 c0       	rjmp	.+4      	; 0x296a <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2966:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    296a:	81 e0       	ldi	r24, 0x01	; 1
    296c:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2970:	81 2f       	mov	r24, r17
    2972:	6f 2d       	mov	r22, r15
    2974:	0e 94 a3 0a 	call	0x1546	; 0x1546 <set_ampGain>
	set_filter(filterConfig);
    2978:	87 2d       	mov	r24, r7
    297a:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    297e:	8e 2d       	mov	r24, r14
    2980:	0e 94 bd 0c 	call	0x197a	; 0x197a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2984:	84 e0       	ldi	r24, 0x04	; 4
    2986:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    298a:	84 e5       	ldi	r24, 0x54	; 84
    298c:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2990:	81 e0       	ldi	r24, 0x01	; 1
    2992:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <enableADCMUX>
	setADCInput(channel);
    2996:	81 2f       	mov	r24, r17
    2998:	0e 94 65 14 	call	0x28ca	; 0x28ca <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    299c:	e0 ea       	ldi	r30, 0xA0	; 160
    299e:	f6 e0       	ldi	r31, 0x06	; 6
    29a0:	22 e0       	ldi	r18, 0x02	; 2
    29a2:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    29a4:	77 24       	eor	r7, r7
    29a6:	73 94       	inc	r7
    29a8:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    29aa:	0f 2e       	mov	r0, r31
    29ac:	f0 e8       	ldi	r31, 0x80	; 128
    29ae:	4f 2e       	mov	r4, r31
    29b0:	f1 e0       	ldi	r31, 0x01	; 1
    29b2:	5f 2e       	mov	r5, r31
    29b4:	f0 2d       	mov	r31, r0
    29b6:	88 e7       	ldi	r24, 0x78	; 120
    29b8:	d2 01       	movw	r26, r4
    29ba:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    29bc:	e0 e0       	ldi	r30, 0x00	; 0
    29be:	f9 e0       	ldi	r31, 0x09	; 9
    29c0:	80 ef       	ldi	r24, 0xF0	; 240
    29c2:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    29c4:	c0 a6       	lds	r28, 0xb0
    29c6:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    29c8:	a2 a6       	lds	r26, 0xb2
    29ca:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    29cc:	84 a6       	lds	r24, 0xb4
    29ce:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    29d0:	8d 89       	ldd	r24, Y+21	; 0x15
    29d2:	9e 89       	ldd	r25, Y+22	; 0x16
    29d4:	86 a7       	lds	r24, 0x76
    29d6:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    29d8:	80 2f       	mov	r24, r16
    29da:	90 e0       	ldi	r25, 0x00	; 0
    29dc:	01 97       	sbiw	r24, 0x01	; 1
    29de:	86 a3       	lds	r24, 0x56
    29e0:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    29e2:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    29e4:	8f ef       	ldi	r24, 0xFF	; 255
    29e6:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    29e8:	80 81       	ld	r24, Z
    29ea:	80 7f       	andi	r24, 0xF0	; 240
    29ec:	88 60       	ori	r24, 0x08	; 8
    29ee:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    29f0:	10 92 66 50 	sts	0x5066, r1
    29f4:	10 92 67 50 	sts	0x5067, r1
    29f8:	10 92 68 50 	sts	0x5068, r1
    29fc:	10 92 69 50 	sts	0x5069, r1
	SPICount = 0;
    2a00:	10 92 a1 50 	sts	0x50A1, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2a04:	80 e2       	ldi	r24, 0x20	; 32
    2a06:	e0 e8       	ldi	r30, 0x80	; 128
    2a08:	f6 e0       	ldi	r31, 0x06	; 6
    2a0a:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a0c:	00 e4       	ldi	r16, 0x40	; 64
    2a0e:	1a e0       	ldi	r17, 0x0A	; 10
    2a10:	83 e2       	ldi	r24, 0x23	; 35
    2a12:	f8 01       	movw	r30, r16
    2a14:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2a16:	61 01       	movw	r12, r2
    2a18:	ee 24       	eor	r14, r14
    2a1a:	ff 24       	eor	r15, r15
    2a1c:	60 e8       	ldi	r22, 0x80	; 128
    2a1e:	74 e8       	ldi	r23, 0x84	; 132
    2a20:	8e e1       	ldi	r24, 0x1E	; 30
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	a7 01       	movw	r20, r14
    2a26:	96 01       	movw	r18, r12
    2a28:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    2a2c:	d8 01       	movw	r26, r16
    2a2e:	96 96       	adiw	r26, 0x26	; 38
    2a30:	2d 93       	st	X+, r18
    2a32:	3c 93       	st	X, r19
    2a34:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2a36:	60 e4       	ldi	r22, 0x40	; 64
    2a38:	72 e4       	ldi	r23, 0x42	; 66
    2a3a:	8f e0       	ldi	r24, 0x0F	; 15
    2a3c:	90 e0       	ldi	r25, 0x00	; 0
    2a3e:	a7 01       	movw	r20, r14
    2a40:	96 01       	movw	r18, r12
    2a42:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    2a46:	f8 01       	movw	r30, r16
    2a48:	22 af       	sts	0x72, r18
    2a4a:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2a4c:	e0 e4       	ldi	r30, 0x40	; 64
    2a4e:	f8 e0       	ldi	r31, 0x08	; 8
    2a50:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2a52:	8c e0       	ldi	r24, 0x0C	; 12
    2a54:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2a56:	8f 89       	ldd	r24, Y+23	; 0x17
    2a58:	98 8d       	ldd	r25, Y+24	; 0x18
    2a5a:	86 a3       	lds	r24, 0x56
    2a5c:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2a5e:	80 ed       	ldi	r24, 0xD0	; 208
    2a60:	d2 01       	movw	r26, r4
    2a62:	11 96       	adiw	r26, 0x01	; 1
    2a64:	8c 93       	st	X, r24
    2a66:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2a68:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2a6a:	80 81       	ld	r24, Z
    2a6c:	80 7f       	andi	r24, 0xF0	; 240
    2a6e:	89 60       	ori	r24, 0x09	; 9
    2a70:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2a72:	f8 01       	movw	r30, r16
    2a74:	80 81       	ld	r24, Z
    2a76:	80 7f       	andi	r24, 0xF0	; 240
    2a78:	81 60       	ori	r24, 0x01	; 1
    2a7a:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2a7c:	e0 ea       	ldi	r30, 0xA0	; 160
    2a7e:	f0 e0       	ldi	r31, 0x00	; 0
    2a80:	82 81       	ldd	r24, Z+2	; 0x02
    2a82:	87 60       	ori	r24, 0x07	; 7
    2a84:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2a86:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2a88:	df 91       	pop	r29
    2a8a:	cf 91       	pop	r28
    2a8c:	1f 91       	pop	r17
    2a8e:	0f 91       	pop	r16
    2a90:	ff 90       	pop	r15
    2a92:	ef 90       	pop	r14
    2a94:	df 90       	pop	r13
    2a96:	cf 90       	pop	r12
    2a98:	bf 90       	pop	r11
    2a9a:	af 90       	pop	r10
    2a9c:	9f 90       	pop	r9
    2a9e:	8f 90       	pop	r8
    2aa0:	7f 90       	pop	r7
    2aa2:	5f 90       	pop	r5
    2aa4:	4f 90       	pop	r4
    2aa6:	3f 90       	pop	r3
    2aa8:	2f 90       	pop	r2
    2aaa:	08 95       	ret

00002aac <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2aac:	2f 92       	push	r2
    2aae:	3f 92       	push	r3
    2ab0:	4f 92       	push	r4
    2ab2:	5f 92       	push	r5
    2ab4:	6f 92       	push	r6
    2ab6:	7f 92       	push	r7
    2ab8:	8f 92       	push	r8
    2aba:	9f 92       	push	r9
    2abc:	af 92       	push	r10
    2abe:	bf 92       	push	r11
    2ac0:	cf 92       	push	r12
    2ac2:	df 92       	push	r13
    2ac4:	ef 92       	push	r14
    2ac6:	ff 92       	push	r15
    2ac8:	0f 93       	push	r16
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	0f 92       	push	r0
    2ad0:	0f 92       	push	r0
    2ad2:	cd b7       	in	r28, 0x3d	; 61
    2ad4:	de b7       	in	r29, 0x3e	; 62
    2ad6:	96 2f       	mov	r25, r22
    2ad8:	49 83       	std	Y+1, r20	; 0x01
    2ada:	5a 83       	std	Y+2, r21	; 0x02
    2adc:	52 2f       	mov	r21, r18
    2ade:	70 2f       	mov	r23, r16
    2ae0:	37 01       	movw	r6, r14
    2ae2:	26 01       	movw	r4, r12
    2ae4:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2ae6:	2d b7       	in	r18, 0x3d	; 61
    2ae8:	3e b7       	in	r19, 0x3e	; 62
    2aea:	29 50       	subi	r18, 0x09	; 9
    2aec:	30 40       	sbci	r19, 0x00	; 0
    2aee:	2d bf       	out	0x3d, r18	; 61
    2af0:	3e bf       	out	0x3e, r19	; 62
    2af2:	ed b7       	in	r30, 0x3d	; 61
    2af4:	fe b7       	in	r31, 0x3e	; 62
    2af6:	31 96       	adiw	r30, 0x01	; 1
    2af8:	ad b7       	in	r26, 0x3d	; 61
    2afa:	be b7       	in	r27, 0x3e	; 62
    2afc:	11 96       	adiw	r26, 0x01	; 1
    2afe:	8d 92       	st	X+, r8
    2b00:	9c 92       	st	X, r9
    2b02:	12 97       	sbiw	r26, 0x02	; 2
    2b04:	2f 89       	ldd	r18, Y+23	; 0x17
    2b06:	38 8d       	ldd	r19, Y+24	; 0x18
    2b08:	22 83       	std	Z+2, r18	; 0x02
    2b0a:	33 83       	std	Z+3, r19	; 0x03
    2b0c:	29 8d       	ldd	r18, Y+25	; 0x19
    2b0e:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2b10:	24 83       	std	Z+4, r18	; 0x04
    2b12:	35 83       	std	Z+5, r19	; 0x05
    2b14:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2b16:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2b18:	26 83       	std	Z+6, r18	; 0x06
    2b1a:	37 83       	std	Z+7, r19	; 0x07
    2b1c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2b1e:	20 87       	std	Z+8, r18	; 0x08
    2b20:	64 ec       	ldi	r22, 0xC4	; 196
    2b22:	49 2f       	mov	r20, r25
    2b24:	29 81       	ldd	r18, Y+1	; 0x01
    2b26:	3a 81       	ldd	r19, Y+2	; 0x02
    2b28:	05 2f       	mov	r16, r21
    2b2a:	e7 2e       	mov	r14, r23
    2b2c:	63 01       	movw	r12, r6
    2b2e:	52 01       	movw	r10, r4
    2b30:	41 01       	movw	r8, r2
    2b32:	0e 94 87 14 	call	0x290e	; 0x290e <CO_collectSeismic1Channel_ext>
    2b36:	2d b7       	in	r18, 0x3d	; 61
    2b38:	3e b7       	in	r19, 0x3e	; 62
    2b3a:	27 5f       	subi	r18, 0xF7	; 247
    2b3c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b3e:	2d bf       	out	0x3d, r18	; 61
    2b40:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2b42:	0f 90       	pop	r0
    2b44:	0f 90       	pop	r0
    2b46:	df 91       	pop	r29
    2b48:	cf 91       	pop	r28
    2b4a:	0f 91       	pop	r16
    2b4c:	ff 90       	pop	r15
    2b4e:	ef 90       	pop	r14
    2b50:	df 90       	pop	r13
    2b52:	cf 90       	pop	r12
    2b54:	bf 90       	pop	r11
    2b56:	af 90       	pop	r10
    2b58:	9f 90       	pop	r9
    2b5a:	8f 90       	pop	r8
    2b5c:	7f 90       	pop	r7
    2b5e:	6f 90       	pop	r6
    2b60:	5f 90       	pop	r5
    2b62:	4f 90       	pop	r4
    2b64:	3f 90       	pop	r3
    2b66:	2f 90       	pop	r2
    2b68:	08 95       	ret

00002b6a <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2b6a:	2f 92       	push	r2
    2b6c:	3f 92       	push	r3
    2b6e:	5f 92       	push	r5
    2b70:	6f 92       	push	r6
    2b72:	7f 92       	push	r7
    2b74:	8f 92       	push	r8
    2b76:	9f 92       	push	r9
    2b78:	af 92       	push	r10
    2b7a:	bf 92       	push	r11
    2b7c:	cf 92       	push	r12
    2b7e:	df 92       	push	r13
    2b80:	ef 92       	push	r14
    2b82:	ff 92       	push	r15
    2b84:	0f 93       	push	r16
    2b86:	1f 93       	push	r17
    2b88:	cf 93       	push	r28
    2b8a:	df 93       	push	r29
    2b8c:	0f 92       	push	r0
    2b8e:	0f 92       	push	r0
    2b90:	cd b7       	in	r28, 0x3d	; 61
    2b92:	de b7       	in	r29, 0x3e	; 62
    2b94:	18 2f       	mov	r17, r24
    2b96:	3b 01       	movw	r6, r22
    2b98:	49 83       	std	Y+1, r20	; 0x01
    2b9a:	5a 83       	std	Y+2, r21	; 0x02
    2b9c:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2b9e:	89 8d       	ldd	r24, Y+25	; 0x19
    2ba0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2ba2:	80 93 64 50 	sts	0x5064, r24
    2ba6:	90 93 65 50 	sts	0x5065, r25
	ADC_Sampling_Finished = 0;
    2baa:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    2bae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2bb0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2bb2:	80 93 a8 50 	sts	0x50A8, r24
    2bb6:	90 93 a9 50 	sts	0x50A9, r25
	if(use_FRAM){
    2bba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2bbc:	88 23       	and	r24, r24
    2bbe:	21 f0       	breq	.+8      	; 0x2bc8 <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2bc0:	81 e0       	ldi	r24, 0x01	; 1
    2bc2:	80 93 49 40 	sts	0x4049, r24
    2bc6:	02 c0       	rjmp	.+4      	; 0x2bcc <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2bc8:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2bcc:	81 e0       	ldi	r24, 0x01	; 1
    2bce:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2bd2:	85 e0       	ldi	r24, 0x05	; 5
    2bd4:	d3 01       	movw	r26, r6
    2bd6:	6c 91       	ld	r22, X
    2bd8:	0e 94 a3 0a 	call	0x1546	; 0x1546 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2bdc:	86 e0       	ldi	r24, 0x06	; 6
    2bde:	f3 01       	movw	r30, r6
    2be0:	61 81       	ldd	r22, Z+1	; 0x01
    2be2:	0e 94 a3 0a 	call	0x1546	; 0x1546 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2be6:	87 e0       	ldi	r24, 0x07	; 7
    2be8:	d3 01       	movw	r26, r6
    2bea:	12 96       	adiw	r26, 0x02	; 2
    2bec:	6c 91       	ld	r22, X
    2bee:	0e 94 a3 0a 	call	0x1546	; 0x1546 <set_ampGain>
	set_filter(filterConfig);
    2bf2:	81 2f       	mov	r24, r17
    2bf4:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2bf8:	80 2f       	mov	r24, r16
    2bfa:	0e 94 bd 0c 	call	0x197a	; 0x197a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2bfe:	84 e0       	ldi	r24, 0x04	; 4
    2c00:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2c04:	84 e5       	ldi	r24, 0x54	; 84
    2c06:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2c0a:	81 e0       	ldi	r24, 0x01	; 1
    2c0c:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2c10:	85 e0       	ldi	r24, 0x05	; 5
    2c12:	0e 94 65 14 	call	0x28ca	; 0x28ca <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2c16:	e0 ea       	ldi	r30, 0xA0	; 160
    2c18:	f6 e0       	ldi	r31, 0x06	; 6
    2c1a:	22 e0       	ldi	r18, 0x02	; 2
    2c1c:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2c1e:	66 24       	eor	r6, r6
    2c20:	63 94       	inc	r6
    2c22:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2c24:	0f 2e       	mov	r0, r31
    2c26:	f0 e8       	ldi	r31, 0x80	; 128
    2c28:	2f 2e       	mov	r2, r31
    2c2a:	f1 e0       	ldi	r31, 0x01	; 1
    2c2c:	3f 2e       	mov	r3, r31
    2c2e:	f0 2d       	mov	r31, r0
    2c30:	88 e7       	ldi	r24, 0x78	; 120
    2c32:	f1 01       	movw	r30, r2
    2c34:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2c36:	e0 e0       	ldi	r30, 0x00	; 0
    2c38:	f8 e0       	ldi	r31, 0x08	; 8
    2c3a:	80 ef       	ldi	r24, 0xF0	; 240
    2c3c:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2c3e:	e0 a6       	lds	r30, 0xb0
    2c40:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2c42:	c2 a6       	lds	r28, 0xb2
    2c44:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2c46:	a4 a6       	lds	r26, 0xb4
    2c48:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2c4a:	86 a6       	lds	r24, 0xb6
    2c4c:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2c4e:	85 2d       	mov	r24, r5
    2c50:	90 e0       	ldi	r25, 0x00	; 0
    2c52:	01 97       	sbiw	r24, 0x01	; 1
    2c54:	86 a3       	lds	r24, 0x56
    2c56:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2c58:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2c5a:	8f ef       	ldi	r24, 0xFF	; 255
    2c5c:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2c5e:	80 81       	ld	r24, Z
    2c60:	80 7f       	andi	r24, 0xF0	; 240
    2c62:	88 60       	ori	r24, 0x08	; 8
    2c64:	80 83       	st	Z, r24

	sampleCount = 0;
    2c66:	10 92 66 50 	sts	0x5066, r1
    2c6a:	10 92 67 50 	sts	0x5067, r1
    2c6e:	10 92 68 50 	sts	0x5068, r1
    2c72:	10 92 69 50 	sts	0x5069, r1
	SPICount = 0;
    2c76:	10 92 a1 50 	sts	0x50A1, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2c7a:	84 e1       	ldi	r24, 0x14	; 20
    2c7c:	91 e2       	ldi	r25, 0x21	; 33
    2c7e:	10 92 14 21 	sts	0x2114, r1
    2c82:	fc 01       	movw	r30, r24
    2c84:	31 97       	sbiw	r30, 0x01	; 1
    2c86:	10 82       	st	Z, r1
    2c88:	02 97       	sbiw	r24, 0x02	; 2
    2c8a:	dc 01       	movw	r26, r24
    2c8c:	1c 92       	st	X, r1

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2c8e:	80 e2       	ldi	r24, 0x20	; 32
    2c90:	e0 e8       	ldi	r30, 0x80	; 128
    2c92:	f6 e0       	ldi	r31, 0x06	; 6
    2c94:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2c96:	00 e4       	ldi	r16, 0x40	; 64
    2c98:	1a e0       	ldi	r17, 0x0A	; 10
    2c9a:	83 e2       	ldi	r24, 0x23	; 35
    2c9c:	f8 01       	movw	r30, r16
    2c9e:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2ca0:	89 81       	ldd	r24, Y+1	; 0x01
    2ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ca4:	6c 01       	movw	r12, r24
    2ca6:	ee 24       	eor	r14, r14
    2ca8:	ff 24       	eor	r15, r15
    2caa:	60 e8       	ldi	r22, 0x80	; 128
    2cac:	74 e8       	ldi	r23, 0x84	; 132
    2cae:	8e e1       	ldi	r24, 0x1E	; 30
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	a7 01       	movw	r20, r14
    2cb4:	96 01       	movw	r18, r12
    2cb6:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    2cba:	d8 01       	movw	r26, r16
    2cbc:	96 96       	adiw	r26, 0x26	; 38
    2cbe:	2d 93       	st	X+, r18
    2cc0:	3c 93       	st	X, r19
    2cc2:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2cc4:	60 e4       	ldi	r22, 0x40	; 64
    2cc6:	72 e4       	ldi	r23, 0x42	; 66
    2cc8:	8f e0       	ldi	r24, 0x0F	; 15
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	a7 01       	movw	r20, r14
    2cce:	96 01       	movw	r18, r12
    2cd0:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    2cd4:	f8 01       	movw	r30, r16
    2cd6:	22 af       	sts	0x72, r18
    2cd8:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2cda:	e0 e4       	ldi	r30, 0x40	; 64
    2cdc:	f8 e0       	ldi	r31, 0x08	; 8
    2cde:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2ce0:	8c e0       	ldi	r24, 0x0C	; 12
    2ce2:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2ce4:	8f 89       	ldd	r24, Y+23	; 0x17
    2ce6:	98 8d       	ldd	r25, Y+24	; 0x18
    2ce8:	86 a3       	lds	r24, 0x56
    2cea:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2cec:	80 ec       	ldi	r24, 0xC0	; 192
    2cee:	d1 01       	movw	r26, r2
    2cf0:	11 96       	adiw	r26, 0x01	; 1
    2cf2:	8c 93       	st	X, r24
    2cf4:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2cf6:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2cf8:	80 81       	ld	r24, Z
    2cfa:	80 7f       	andi	r24, 0xF0	; 240
    2cfc:	89 60       	ori	r24, 0x09	; 9
    2cfe:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2d00:	f8 01       	movw	r30, r16
    2d02:	80 81       	ld	r24, Z
    2d04:	80 7f       	andi	r24, 0xF0	; 240
    2d06:	81 60       	ori	r24, 0x01	; 1
    2d08:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    2d0a:	e0 ea       	ldi	r30, 0xA0	; 160
    2d0c:	f0 e0       	ldi	r31, 0x00	; 0
    2d0e:	82 81       	ldd	r24, Z+2	; 0x02
    2d10:	87 60       	ori	r24, 0x07	; 7
    2d12:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2d14:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2d16:	0f 90       	pop	r0
    2d18:	0f 90       	pop	r0
    2d1a:	df 91       	pop	r29
    2d1c:	cf 91       	pop	r28
    2d1e:	1f 91       	pop	r17
    2d20:	0f 91       	pop	r16
    2d22:	ff 90       	pop	r15
    2d24:	ef 90       	pop	r14
    2d26:	df 90       	pop	r13
    2d28:	cf 90       	pop	r12
    2d2a:	bf 90       	pop	r11
    2d2c:	af 90       	pop	r10
    2d2e:	9f 90       	pop	r9
    2d30:	8f 90       	pop	r8
    2d32:	7f 90       	pop	r7
    2d34:	6f 90       	pop	r6
    2d36:	5f 90       	pop	r5
    2d38:	3f 90       	pop	r3
    2d3a:	2f 90       	pop	r2
    2d3c:	08 95       	ret

00002d3e <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2d3e:	2f 92       	push	r2
    2d40:	3f 92       	push	r3
    2d42:	4f 92       	push	r4
    2d44:	5f 92       	push	r5
    2d46:	6f 92       	push	r6
    2d48:	7f 92       	push	r7
    2d4a:	8f 92       	push	r8
    2d4c:	9f 92       	push	r9
    2d4e:	af 92       	push	r10
    2d50:	bf 92       	push	r11
    2d52:	cf 92       	push	r12
    2d54:	df 92       	push	r13
    2d56:	ef 92       	push	r14
    2d58:	ff 92       	push	r15
    2d5a:	0f 93       	push	r16
    2d5c:	1f 93       	push	r17
    2d5e:	cf 93       	push	r28
    2d60:	df 93       	push	r29
    2d62:	00 d0       	rcall	.+0      	; 0x2d64 <CO_collectSeismic3Axises+0x26>
    2d64:	0f 92       	push	r0
    2d66:	cd b7       	in	r28, 0x3d	; 61
    2d68:	de b7       	in	r29, 0x3e	; 62
    2d6a:	dc 01       	movw	r26, r24
    2d6c:	3b 01       	movw	r6, r22
    2d6e:	94 2f       	mov	r25, r20
    2d70:	32 2f       	mov	r19, r18
    2d72:	28 01       	movw	r4, r16
    2d74:	17 01       	movw	r2, r14
    2d76:	c9 82       	std	Y+1, r12	; 0x01
    2d78:	da 82       	std	Y+2, r13	; 0x02
    2d7a:	ab 82       	std	Y+3, r10	; 0x03
    2d7c:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    2d7e:	4d b7       	in	r20, 0x3d	; 61
    2d80:	5e b7       	in	r21, 0x3e	; 62
    2d82:	47 50       	subi	r20, 0x07	; 7
    2d84:	50 40       	sbci	r21, 0x00	; 0
    2d86:	4d bf       	out	0x3d, r20	; 61
    2d88:	5e bf       	out	0x3e, r21	; 62
    2d8a:	6d b7       	in	r22, 0x3d	; 61
    2d8c:	7e b7       	in	r23, 0x3e	; 62
    2d8e:	6f 5f       	subi	r22, 0xFF	; 255
    2d90:	7f 4f       	sbci	r23, 0xFF	; 255
    2d92:	ed b7       	in	r30, 0x3d	; 61
    2d94:	fe b7       	in	r31, 0x3e	; 62
    2d96:	81 82       	std	Z+1, r8	; 0x01
    2d98:	92 82       	std	Z+2, r9	; 0x02
    2d9a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2d9c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2d9e:	fb 01       	movw	r30, r22
    2da0:	42 83       	std	Z+2, r20	; 0x02
    2da2:	53 83       	std	Z+3, r21	; 0x03
    2da4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2da6:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2da8:	44 83       	std	Z+4, r20	; 0x04
    2daa:	55 83       	std	Z+5, r21	; 0x05
    2dac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2dae:	86 83       	std	Z+6, r24	; 0x06
    2db0:	84 ec       	ldi	r24, 0xC4	; 196
    2db2:	bd 01       	movw	r22, r26
    2db4:	a3 01       	movw	r20, r6
    2db6:	29 2f       	mov	r18, r25
    2db8:	03 2f       	mov	r16, r19
    2dba:	72 01       	movw	r14, r4
    2dbc:	61 01       	movw	r12, r2
    2dbe:	a9 80       	ldd	r10, Y+1	; 0x01
    2dc0:	ba 80       	ldd	r11, Y+2	; 0x02
    2dc2:	8b 80       	ldd	r8, Y+3	; 0x03
    2dc4:	9c 80       	ldd	r9, Y+4	; 0x04
    2dc6:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <CO_collectSeismic3Axises_ext>
    2dca:	4d b7       	in	r20, 0x3d	; 61
    2dcc:	5e b7       	in	r21, 0x3e	; 62
    2dce:	49 5f       	subi	r20, 0xF9	; 249
    2dd0:	5f 4f       	sbci	r21, 0xFF	; 255
    2dd2:	4d bf       	out	0x3d, r20	; 61
    2dd4:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    2dd6:	24 96       	adiw	r28, 0x04	; 4
    2dd8:	cd bf       	out	0x3d, r28	; 61
    2dda:	de bf       	out	0x3e, r29	; 62
    2ddc:	df 91       	pop	r29
    2dde:	cf 91       	pop	r28
    2de0:	1f 91       	pop	r17
    2de2:	0f 91       	pop	r16
    2de4:	ff 90       	pop	r15
    2de6:	ef 90       	pop	r14
    2de8:	df 90       	pop	r13
    2dea:	cf 90       	pop	r12
    2dec:	bf 90       	pop	r11
    2dee:	af 90       	pop	r10
    2df0:	9f 90       	pop	r9
    2df2:	8f 90       	pop	r8
    2df4:	7f 90       	pop	r7
    2df6:	6f 90       	pop	r6
    2df8:	5f 90       	pop	r5
    2dfa:	4f 90       	pop	r4
    2dfc:	3f 90       	pop	r3
    2dfe:	2f 90       	pop	r2
    2e00:	08 95       	ret

00002e02 <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2e02:	6f 92       	push	r6
    2e04:	7f 92       	push	r7
    2e06:	8f 92       	push	r8
    2e08:	9f 92       	push	r9
    2e0a:	af 92       	push	r10
    2e0c:	bf 92       	push	r11
    2e0e:	cf 92       	push	r12
    2e10:	df 92       	push	r13
    2e12:	ef 92       	push	r14
    2e14:	ff 92       	push	r15
    2e16:	0f 93       	push	r16
    2e18:	1f 93       	push	r17
    2e1a:	cf 93       	push	r28
    2e1c:	df 93       	push	r29
    2e1e:	c8 2f       	mov	r28, r24
    2e20:	b6 2e       	mov	r11, r22
    2e22:	d4 2f       	mov	r29, r20
    2e24:	49 01       	movw	r8, r18
    2e26:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    2e28:	e0 92 64 50 	sts	0x5064, r14
    2e2c:	f0 92 65 50 	sts	0x5065, r15
	ADC_Sampling_Finished = 0;
    2e30:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    2e34:	c0 92 a8 50 	sts	0x50A8, r12
    2e38:	d0 92 a9 50 	sts	0x50A9, r13
	if(use_FRAM){
    2e3c:	aa 20       	and	r10, r10
    2e3e:	21 f0       	breq	.+8      	; 0x2e48 <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    2e40:	81 e0       	ldi	r24, 0x01	; 1
    2e42:	80 93 49 40 	sts	0x4049, r24
    2e46:	02 c0       	rjmp	.+4      	; 0x2e4c <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    2e48:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2e4c:	81 e0       	ldi	r24, 0x01	; 1
    2e4e:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    2e52:	8c 2f       	mov	r24, r28
    2e54:	6d 2f       	mov	r22, r29
    2e56:	0e 94 a3 0a 	call	0x1546	; 0x1546 <set_ampGain>
	set_filter(filterConfig);
    2e5a:	8b 2d       	mov	r24, r11
    2e5c:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    2e60:	8c 2f       	mov	r24, r28
    2e62:	85 50       	subi	r24, 0x05	; 5
    2e64:	83 30       	cpi	r24, 0x03	; 3
    2e66:	18 f4       	brcc	.+6      	; 0x2e6e <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2e68:	81 e0       	ldi	r24, 0x01	; 1
    2e6a:	0e 94 bd 0c 	call	0x197a	; 0x197a <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2e6e:	81 e0       	ldi	r24, 0x01	; 1
    2e70:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <enableADCMUX>
	setADCInput(channel);
    2e74:	8c 2f       	mov	r24, r28
    2e76:	0e 94 65 14 	call	0x28ca	; 0x28ca <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2e7a:	84 e0       	ldi	r24, 0x04	; 4
    2e7c:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2e80:	84 e5       	ldi	r24, 0x54	; 84
    2e82:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2e86:	e0 ea       	ldi	r30, 0xA0	; 160
    2e88:	f6 e0       	ldi	r31, 0x06	; 6
    2e8a:	ee 24       	eor	r14, r14
    2e8c:	e3 94       	inc	r14
    2e8e:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2e90:	82 e0       	ldi	r24, 0x02	; 2
    2e92:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    2e94:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2e96:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2e98:	80 e2       	ldi	r24, 0x20	; 32
    2e9a:	e0 e8       	ldi	r30, 0x80	; 128
    2e9c:	f6 e0       	ldi	r31, 0x06	; 6
    2e9e:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2ea0:	c0 e4       	ldi	r28, 0x40	; 64
    2ea2:	da e0       	ldi	r29, 0x0A	; 10
    2ea4:	83 e2       	ldi	r24, 0x23	; 35
    2ea6:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2ea8:	94 01       	movw	r18, r8
    2eaa:	40 e0       	ldi	r20, 0x00	; 0
    2eac:	50 e0       	ldi	r21, 0x00	; 0
    2eae:	60 e8       	ldi	r22, 0x80	; 128
    2eb0:	74 e8       	ldi	r23, 0x84	; 132
    2eb2:	8e e1       	ldi	r24, 0x1E	; 30
    2eb4:	90 e0       	ldi	r25, 0x00	; 0
    2eb6:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    2eba:	89 01       	movw	r16, r18
    2ebc:	9a 01       	movw	r18, r20
    2ebe:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    2ec0:	0e a3       	lds	r16, 0x5e
    2ec2:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    2ec4:	96 95       	lsr	r25
    2ec6:	87 95       	ror	r24
    2ec8:	8a af       	sts	0x7a, r24
    2eca:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2ecc:	e0 e4       	ldi	r30, 0x40	; 64
    2ece:	f8 e0       	ldi	r31, 0x08	; 8
    2ed0:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    2ed2:	8c e0       	ldi	r24, 0x0C	; 12
    2ed4:	81 87       	std	Z+9, r24	; 0x09
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    2ed6:	66 a2       	lds	r22, 0x96
    2ed8:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2eda:	88 e7       	ldi	r24, 0x78	; 120
    2edc:	a0 e8       	ldi	r26, 0x80	; 128
    2ede:	b1 e0       	ldi	r27, 0x01	; 1
    2ee0:	11 96       	adiw	r26, 0x01	; 1
    2ee2:	8c 93       	st	X, r24
    2ee4:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2ee6:	e6 82       	std	Z+6, r14	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2ee8:	88 81       	ld	r24, Y
    2eea:	80 7f       	andi	r24, 0xF0	; 240
    2eec:	81 60       	ori	r24, 0x01	; 1
    2eee:	88 83       	st	Y, r24
	
	sampleCount = 0;
    2ef0:	10 92 66 50 	sts	0x5066, r1
    2ef4:	10 92 67 50 	sts	0x5067, r1
    2ef8:	10 92 68 50 	sts	0x5068, r1
    2efc:	10 92 69 50 	sts	0x5069, r1
	discardCount = 0;
    2f00:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2f04:	e0 ea       	ldi	r30, 0xA0	; 160
    2f06:	f0 e0       	ldi	r31, 0x00	; 0
    2f08:	82 81       	ldd	r24, Z+2	; 0x02
    2f0a:	83 60       	ori	r24, 0x03	; 3
    2f0c:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2f0e:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2f10:	df 91       	pop	r29
    2f12:	cf 91       	pop	r28
    2f14:	1f 91       	pop	r17
    2f16:	0f 91       	pop	r16
    2f18:	ff 90       	pop	r15
    2f1a:	ef 90       	pop	r14
    2f1c:	df 90       	pop	r13
    2f1e:	cf 90       	pop	r12
    2f20:	bf 90       	pop	r11
    2f22:	af 90       	pop	r10
    2f24:	9f 90       	pop	r9
    2f26:	8f 90       	pop	r8
    2f28:	7f 90       	pop	r7
    2f2a:	6f 90       	pop	r6
    2f2c:	08 95       	ret

00002f2e <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2f2e:	8f 92       	push	r8
    2f30:	9f 92       	push	r9
    2f32:	af 92       	push	r10
    2f34:	cf 92       	push	r12
    2f36:	df 92       	push	r13
    2f38:	ef 92       	push	r14
    2f3a:	ff 92       	push	r15
    2f3c:	0f 93       	push	r16
    2f3e:	1f 93       	push	r17
    2f40:	cf 93       	push	r28
    2f42:	df 93       	push	r29
    2f44:	96 2f       	mov	r25, r22
    2f46:	fa 01       	movw	r30, r20
    2f48:	d9 01       	movw	r26, r18
    2f4a:	e8 01       	movw	r28, r16
    2f4c:	47 01       	movw	r8, r14
    2f4e:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    2f50:	61 ec       	ldi	r22, 0xC1	; 193
    2f52:	49 2f       	mov	r20, r25
    2f54:	9f 01       	movw	r18, r30
    2f56:	8d 01       	movw	r16, r26
    2f58:	7e 01       	movw	r14, r28
    2f5a:	64 01       	movw	r12, r8
    2f5c:	0e 94 01 17 	call	0x2e02	; 0x2e02 <CO_collectADC_ext>
}
    2f60:	df 91       	pop	r29
    2f62:	cf 91       	pop	r28
    2f64:	1f 91       	pop	r17
    2f66:	0f 91       	pop	r16
    2f68:	ff 90       	pop	r15
    2f6a:	ef 90       	pop	r14
    2f6c:	df 90       	pop	r13
    2f6e:	cf 90       	pop	r12
    2f70:	af 90       	pop	r10
    2f72:	9f 90       	pop	r9
    2f74:	8f 90       	pop	r8
    2f76:	08 95       	ret

00002f78 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2f78:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2f7a:	81 e0       	ldi	r24, 0x01	; 1
    2f7c:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2f7e:	84 81       	ldd	r24, Z+4	; 0x04
    2f80:	95 81       	ldd	r25, Z+5	; 0x05
    2f82:	86 1b       	sub	r24, r22
    2f84:	91 09       	sbc	r25, r1

	return answer;
}
    2f86:	08 95       	ret

00002f88 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2f88:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2f8a:	81 e0       	ldi	r24, 0x01	; 1
    2f8c:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2f8e:	84 81       	ldd	r24, Z+4	; 0x04
    2f90:	95 81       	ldd	r25, Z+5	; 0x05
    2f92:	77 27       	eor	r23, r23
    2f94:	67 fd       	sbrc	r22, 7
    2f96:	70 95       	com	r23
    2f98:	86 1b       	sub	r24, r22
    2f9a:	97 0b       	sbc	r25, r23

	return answer;
}
    2f9c:	08 95       	ret

00002f9e <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2f9e:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2fa0:	81 e0       	ldi	r24, 0x01	; 1
    2fa2:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    2fa4:	84 81       	ldd	r24, Z+4	; 0x04
    2fa6:	95 81       	ldd	r25, Z+5	; 0x05
}
    2fa8:	08 95       	ret

00002faa <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2faa:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2fac:	81 e0       	ldi	r24, 0x01	; 1
    2fae:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2fb0:	84 81       	ldd	r24, Z+4	; 0x04
}
    2fb2:	08 95       	ret

00002fb4 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    2fb4:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2fb6:	81 e0       	ldi	r24, 0x01	; 1
    2fb8:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2fba:	85 81       	ldd	r24, Z+5	; 0x05
}
    2fbc:	08 95       	ret

00002fbe <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2fbe:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2fc0:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    2fc2:	14 82       	std	Z+4, r1	; 0x04
    2fc4:	9a e2       	ldi	r25, 0x2A	; 42
    2fc6:	9a 95       	dec	r25
    2fc8:	f1 f7       	brne	.-4      	; 0x2fc6 <ADC_Wait_8MHz+0x8>
    2fca:	00 c0       	rjmp	.+0      	; 0x2fcc <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2fcc:	84 83       	std	Z+4, r24	; 0x04
}
    2fce:	08 95       	ret

00002fd0 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2fd0:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2fd2:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    2fd4:	91 e0       	ldi	r25, 0x01	; 1
    2fd6:	94 83       	std	Z+4, r25	; 0x04
    2fd8:	95 e5       	ldi	r25, 0x55	; 85
    2fda:	9a 95       	dec	r25
    2fdc:	f1 f7       	brne	.-4      	; 0x2fda <ADC_Wait_32MHz+0xa>
    2fde:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2fe0:	84 83       	std	Z+4, r24	; 0x04
}
    2fe2:	08 95       	ret

00002fe4 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2fe4:	ef 92       	push	r14
    2fe6:	ff 92       	push	r15
    2fe8:	0f 93       	push	r16
    2fea:	1f 93       	push	r17
    2fec:	cf 93       	push	r28
    2fee:	df 93       	push	r29
    2ff0:	eb 01       	movw	r28, r22
    if (oversampling)
    2ff2:	44 23       	and	r20, r20
    2ff4:	c9 f0       	breq	.+50     	; 0x3028 <ADC_Offset_Get_Unsigned+0x44>
    2ff6:	04 e0       	ldi	r16, 0x04	; 4
    2ff8:	10 e0       	ldi	r17, 0x00	; 0
    2ffa:	ee 24       	eor	r14, r14
    2ffc:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2ffe:	88 81       	ld	r24, Y
    3000:	80 68       	ori	r24, 0x80	; 128
    3002:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3004:	8b 81       	ldd	r24, Y+3	; 0x03
    3006:	80 ff       	sbrs	r24, 0
    3008:	fd cf       	rjmp	.-6      	; 0x3004 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    300a:	ce 01       	movw	r24, r28
    300c:	60 e0       	ldi	r22, 0x00	; 0
    300e:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <ADC_ResultCh_GetWord_Unsigned>
    3012:	e8 0e       	add	r14, r24
    3014:	f9 1e       	adc	r15, r25
    3016:	01 50       	subi	r16, 0x01	; 1
    3018:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    301a:	89 f7       	brne	.-30     	; 0x2ffe <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    301c:	c7 01       	movw	r24, r14
    301e:	96 95       	lsr	r25
    3020:	87 95       	ror	r24
    3022:	96 95       	lsr	r25
    3024:	87 95       	ror	r24
    3026:	09 c0       	rjmp	.+18     	; 0x303a <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3028:	88 81       	ld	r24, Y
    302a:	80 68       	ori	r24, 0x80	; 128
    302c:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    302e:	8b 81       	ldd	r24, Y+3	; 0x03
    3030:	80 ff       	sbrs	r24, 0
    3032:	fd cf       	rjmp	.-6      	; 0x302e <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3034:	ce 01       	movw	r24, r28
    3036:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    303a:	df 91       	pop	r29
    303c:	cf 91       	pop	r28
    303e:	1f 91       	pop	r17
    3040:	0f 91       	pop	r16
    3042:	ff 90       	pop	r15
    3044:	ef 90       	pop	r14
    3046:	08 95       	ret

00003048 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3048:	ef 92       	push	r14
    304a:	ff 92       	push	r15
    304c:	0f 93       	push	r16
    304e:	1f 93       	push	r17
    3050:	cf 93       	push	r28
    3052:	df 93       	push	r29
    3054:	eb 01       	movw	r28, r22
    if (oversampling)
    3056:	44 23       	and	r20, r20
    3058:	e1 f0       	breq	.+56     	; 0x3092 <ADC_Offset_Get_Signed+0x4a>
    305a:	04 e0       	ldi	r16, 0x04	; 4
    305c:	10 e0       	ldi	r17, 0x00	; 0
    305e:	ee 24       	eor	r14, r14
    3060:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3062:	88 81       	ld	r24, Y
    3064:	80 68       	ori	r24, 0x80	; 128
    3066:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3068:	8b 81       	ldd	r24, Y+3	; 0x03
    306a:	80 ff       	sbrs	r24, 0
    306c:	fd cf       	rjmp	.-6      	; 0x3068 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    306e:	ce 01       	movw	r24, r28
    3070:	60 e0       	ldi	r22, 0x00	; 0
    3072:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <ADC_ResultCh_GetWord_Signed>
    3076:	e8 0e       	add	r14, r24
    3078:	f9 1e       	adc	r15, r25
    307a:	01 50       	subi	r16, 0x01	; 1
    307c:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    307e:	89 f7       	brne	.-30     	; 0x3062 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3080:	c7 01       	movw	r24, r14
    3082:	99 23       	and	r25, r25
    3084:	0c f4       	brge	.+2      	; 0x3088 <ADC_Offset_Get_Signed+0x40>
    3086:	03 96       	adiw	r24, 0x03	; 3
    3088:	95 95       	asr	r25
    308a:	87 95       	ror	r24
    308c:	95 95       	asr	r25
    308e:	87 95       	ror	r24
    3090:	0a c0       	rjmp	.+20     	; 0x30a6 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3092:	88 81       	ld	r24, Y
    3094:	80 68       	ori	r24, 0x80	; 128
    3096:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3098:	8b 81       	ldd	r24, Y+3	; 0x03
    309a:	80 ff       	sbrs	r24, 0
    309c:	fd cf       	rjmp	.-6      	; 0x3098 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    309e:	ce 01       	movw	r24, r28
    30a0:	60 e0       	ldi	r22, 0x00	; 0
    30a2:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    30a6:	df 91       	pop	r29
    30a8:	cf 91       	pop	r28
    30aa:	1f 91       	pop	r17
    30ac:	0f 91       	pop	r16
    30ae:	ff 90       	pop	r15
    30b0:	ef 90       	pop	r14
    30b2:	08 95       	ret

000030b4 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    30b4:	aa ec       	ldi	r26, 0xCA	; 202
    30b6:	b1 e0       	ldi	r27, 0x01	; 1
    30b8:	92 e0       	ldi	r25, 0x02	; 2
    30ba:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    30bc:	e8 2f       	mov	r30, r24
    30be:	f0 e0       	ldi	r31, 0x00	; 0
    30c0:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    30c2:	1c 92       	st	X, r1

	return result;
}
    30c4:	08 95       	ret

000030c6 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    30c6:	cf 93       	push	r28
    30c8:	df 93       	push	r29
    30ca:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    30cc:	82 e0       	ldi	r24, 0x02	; 2
    30ce:	c0 30       	cpi	r28, 0x00	; 0
    30d0:	d8 07       	cpc	r29, r24
    30d2:	59 f4       	brne	.+22     	; 0x30ea <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    30d4:	80 e2       	ldi	r24, 0x20	; 32
    30d6:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <SP_ReadCalibrationByte>
    30da:	c0 e0       	ldi	r28, 0x00	; 0
    30dc:	d2 e0       	ldi	r29, 0x02	; 2
    30de:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    30e0:	81 e2       	ldi	r24, 0x21	; 33
    30e2:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <SP_ReadCalibrationByte>
    30e6:	8d 87       	std	Y+13, r24	; 0x0d
    30e8:	08 c0       	rjmp	.+16     	; 0x30fa <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    30ea:	84 e2       	ldi	r24, 0x24	; 36
    30ec:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <SP_ReadCalibrationByte>
    30f0:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    30f2:	85 e2       	ldi	r24, 0x25	; 37
    30f4:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <SP_ReadCalibrationByte>
    30f8:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    30fa:	df 91       	pop	r29
    30fc:	cf 91       	pop	r28
    30fe:	08 95       	ret

00003100 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    3100:	84 e1       	ldi	r24, 0x14	; 20
    3102:	e5 e1       	ldi	r30, 0x15	; 21
    3104:	f1 e2       	ldi	r31, 0x21	; 33
    3106:	df 01       	movw	r26, r30
    3108:	1d 92       	st	X+, r1
    310a:	8a 95       	dec	r24
    310c:	e9 f7       	brne	.-6      	; 0x3108 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    310e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <chb_get_short_addr>
    3112:	80 93 15 21 	sts	0x2115, r24
    3116:	90 93 16 21 	sts	0x2116, r25
    chb_drvr_init();
    311a:	0e 94 33 1c 	call	0x3866	; 0x3866 <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    311e:	08 95       	ret

00003120 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    3120:	e0 e8       	ldi	r30, 0x80	; 128
    3122:	f6 e0       	ldi	r31, 0x06	; 6
    3124:	84 e0       	ldi	r24, 0x04	; 4
    3126:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3128:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    312a:	92 e0       	ldi	r25, 0x02	; 2
    312c:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    312e:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3130:	83 e0       	ldi	r24, 0x03	; 3
    3132:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3134:	e0 ea       	ldi	r30, 0xA0	; 160
    3136:	f0 e0       	ldi	r31, 0x00	; 0
    3138:	82 81       	ldd	r24, Z+2	; 0x02
    313a:	84 60       	ori	r24, 0x04	; 4
    313c:	82 83       	std	Z+2, r24	; 0x02
	sei();
    313e:	78 94       	sei
}
    3140:	08 95       	ret

00003142 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    3142:	85 e1       	ldi	r24, 0x15	; 21
    3144:	91 e2       	ldi	r25, 0x21	; 33
    3146:	08 95       	ret

00003148 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3148:	2f 92       	push	r2
    314a:	3f 92       	push	r3
    314c:	4f 92       	push	r4
    314e:	5f 92       	push	r5
    3150:	6f 92       	push	r6
    3152:	7f 92       	push	r7
    3154:	8f 92       	push	r8
    3156:	9f 92       	push	r9
    3158:	af 92       	push	r10
    315a:	bf 92       	push	r11
    315c:	cf 92       	push	r12
    315e:	df 92       	push	r13
    3160:	ef 92       	push	r14
    3162:	ff 92       	push	r15
    3164:	0f 93       	push	r16
    3166:	1f 93       	push	r17
    3168:	cf 93       	push	r28
    316a:	df 93       	push	r29
    316c:	cd b7       	in	r28, 0x3d	; 61
    316e:	de b7       	in	r29, 0x3e	; 62
    3170:	2a 97       	sbiw	r28, 0x0a	; 10
    3172:	cd bf       	out	0x3d, r28	; 61
    3174:	de bf       	out	0x3e, r29	; 62
    3176:	2c 01       	movw	r4, r24
    3178:	1b 01       	movw	r2, r22
    317a:	69 01       	movw	r12, r18
    317c:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    317e:	21 15       	cp	r18, r1
    3180:	31 05       	cpc	r19, r1
    3182:	41 05       	cpc	r20, r1
    3184:	51 05       	cpc	r21, r1
    3186:	09 f4       	brne	.+2      	; 0x318a <chb_write+0x42>
    3188:	68 c0       	rjmp	.+208    	; 0x325a <chb_write+0x112>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    318a:	88 24       	eor	r8, r8
    318c:	99 24       	eor	r9, r9
    318e:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3190:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    3192:	0f 2e       	mov	r0, r31
    3194:	f7 e1       	ldi	r31, 0x17	; 23
    3196:	6f 2e       	mov	r6, r31
    3198:	f1 e2       	ldi	r31, 0x21	; 33
    319a:	7f 2e       	mov	r7, r31
    319c:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    319e:	1c 2d       	mov	r17, r12
    31a0:	85 e6       	ldi	r24, 0x65	; 101
    31a2:	c8 16       	cp	r12, r24
    31a4:	d1 04       	cpc	r13, r1
    31a6:	e1 04       	cpc	r14, r1
    31a8:	f1 04       	cpc	r15, r1
    31aa:	08 f0       	brcs	.+2      	; 0x31ae <chb_write+0x66>
    31ac:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    31ae:	81 2f       	mov	r24, r17
    31b0:	85 5f       	subi	r24, 0xF5	; 245
    31b2:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    31b4:	9f ef       	ldi	r25, 0xFF	; 255
    31b6:	49 16       	cp	r4, r25
    31b8:	9f ef       	ldi	r25, 0xFF	; 255
    31ba:	59 06       	cpc	r5, r25
    31bc:	11 f0       	breq	.+4      	; 0x31c2 <chb_write+0x7a>
    31be:	81 e6       	ldi	r24, 0x61	; 97
    31c0:	01 c0       	rjmp	.+2      	; 0x31c4 <chb_write+0x7c>
    31c2:	81 e4       	ldi	r24, 0x41	; 65
    31c4:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    31c6:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    31c8:	f3 01       	movw	r30, r6
    31ca:	80 81       	ld	r24, Z
    31cc:	8c 83       	std	Y+4, r24	; 0x04
    31ce:	8f 5f       	subi	r24, 0xFF	; 255
    31d0:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    31d2:	84 e3       	ldi	r24, 0x34	; 52
    31d4:	92 e1       	ldi	r25, 0x12	; 18
    31d6:	8d 83       	std	Y+5, r24	; 0x05
    31d8:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    31da:	4f 82       	std	Y+7, r4	; 0x07
    31dc:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    31de:	e5 e1       	ldi	r30, 0x15	; 21
    31e0:	f1 e2       	ldi	r31, 0x21	; 33
    31e2:	80 81       	ld	r24, Z
    31e4:	91 81       	ldd	r25, Z+1	; 0x01
    31e6:	89 87       	std	Y+9, r24	; 0x09
    31e8:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    31ea:	b1 01       	movw	r22, r2
    31ec:	68 0d       	add	r22, r8
    31ee:	79 1d       	adc	r23, r9
    31f0:	ce 01       	movw	r24, r28
    31f2:	01 96       	adiw	r24, 0x01	; 1
    31f4:	41 2f       	mov	r20, r17
    31f6:	0e 94 6f 1b 	call	0x36de	; 0x36de <chb_tx>

             switch (status)
    31fa:	83 30       	cpi	r24, 0x03	; 3
    31fc:	c9 f0       	breq	.+50     	; 0x3230 <chb_write+0xe8>
    31fe:	84 30       	cpi	r24, 0x04	; 4
    3200:	18 f4       	brcc	.+6      	; 0x3208 <chb_write+0xc0>
    3202:	81 30       	cpi	r24, 0x01	; 1
    3204:	e1 f4       	brne	.+56     	; 0x323e <chb_write+0xf6>
    3206:	04 c0       	rjmp	.+8      	; 0x3210 <chb_write+0xc8>
    3208:	85 30       	cpi	r24, 0x05	; 5
    320a:	51 f0       	breq	.+20     	; 0x3220 <chb_write+0xd8>
    320c:	80 34       	cpi	r24, 0x40	; 64
    320e:	b9 f4       	brne	.+46     	; 0x323e <chb_write+0xf6>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3210:	ec e1       	ldi	r30, 0x1C	; 28
    3212:	f1 e2       	ldi	r31, 0x21	; 33
    3214:	80 81       	ld	r24, Z
    3216:	91 81       	ldd	r25, Z+1	; 0x01
    3218:	01 96       	adiw	r24, 0x01	; 1
    321a:	80 83       	st	Z, r24
    321c:	91 83       	std	Z+1, r25	; 0x01
                 break;
    321e:	0f c0       	rjmp	.+30     	; 0x323e <chb_write+0xf6>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3220:	ee e1       	ldi	r30, 0x1E	; 30
    3222:	f1 e2       	ldi	r31, 0x21	; 33
    3224:	80 81       	ld	r24, Z
    3226:	91 81       	ldd	r25, Z+1	; 0x01
    3228:	01 96       	adiw	r24, 0x01	; 1
    322a:	80 83       	st	Z, r24
    322c:	91 83       	std	Z+1, r25	; 0x01
				 //rtry++;
                 break;
    322e:	07 c0       	rjmp	.+14     	; 0x323e <chb_write+0xf6>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3230:	e0 e2       	ldi	r30, 0x20	; 32
    3232:	f1 e2       	ldi	r31, 0x21	; 33
    3234:	80 81       	ld	r24, Z
    3236:	91 81       	ldd	r25, Z+1	; 0x01
    3238:	01 96       	adiw	r24, 0x01	; 1
    323a:	80 83       	st	Z, r24
    323c:	91 83       	std	Z+1, r25	; 0x01
             }
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    323e:	81 2f       	mov	r24, r17
    3240:	90 e0       	ldi	r25, 0x00	; 0
    3242:	a0 e0       	ldi	r26, 0x00	; 0
    3244:	b0 e0       	ldi	r27, 0x00	; 0
    3246:	88 0e       	add	r8, r24
    3248:	99 1e       	adc	r9, r25
    324a:	aa 1e       	adc	r10, r26
    324c:	bb 1e       	adc	r11, r27
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    324e:	c8 1a       	sub	r12, r24
    3250:	d9 0a       	sbc	r13, r25
    3252:	ea 0a       	sbc	r14, r26
    3254:	fb 0a       	sbc	r15, r27
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3256:	09 f0       	breq	.+2      	; 0x325a <chb_write+0x112>
    3258:	a2 cf       	rjmp	.-188    	; 0x319e <chb_write+0x56>
		frm_offset += frm_len;
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
    return CHB_SUCCESS;
}
    325a:	80 e0       	ldi	r24, 0x00	; 0
    325c:	2a 96       	adiw	r28, 0x0a	; 10
    325e:	cd bf       	out	0x3d, r28	; 61
    3260:	de bf       	out	0x3e, r29	; 62
    3262:	df 91       	pop	r29
    3264:	cf 91       	pop	r28
    3266:	1f 91       	pop	r17
    3268:	0f 91       	pop	r16
    326a:	ff 90       	pop	r15
    326c:	ef 90       	pop	r14
    326e:	df 90       	pop	r13
    3270:	cf 90       	pop	r12
    3272:	bf 90       	pop	r11
    3274:	af 90       	pop	r10
    3276:	9f 90       	pop	r9
    3278:	8f 90       	pop	r8
    327a:	7f 90       	pop	r7
    327c:	6f 90       	pop	r6
    327e:	5f 90       	pop	r5
    3280:	4f 90       	pop	r4
    3282:	3f 90       	pop	r3
    3284:	2f 90       	pop	r2
    3286:	08 95       	ret

00003288 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3288:	df 92       	push	r13
    328a:	ef 92       	push	r14
    328c:	ff 92       	push	r15
    328e:	0f 93       	push	r16
    3290:	1f 93       	push	r17
    3292:	cf 93       	push	r28
    3294:	df 93       	push	r29
    3296:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    3298:	0e 94 bf 19 	call	0x337e	; 0x337e <chb_buf_read>
    329c:	d8 2e       	mov	r13, r24
    329e:	88 23       	and	r24, r24
    32a0:	0c f4       	brge	.+2      	; 0x32a4 <chb_read+0x1c>
    32a2:	46 c0       	rjmp	.+140    	; 0x3330 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    32a4:	f7 01       	movw	r30, r14
    32a6:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    32a8:	88 23       	and	r24, r24
    32aa:	71 f0       	breq	.+28     	; 0x32c8 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    32ac:	e7 01       	movw	r28, r14
    32ae:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    32b0:	87 01       	movw	r16, r14
    32b2:	09 5f       	subi	r16, 0xF9	; 249
    32b4:	1f 4f       	sbci	r17, 0xFF	; 255
    32b6:	81 50       	subi	r24, 0x01	; 1
    32b8:	08 0f       	add	r16, r24
    32ba:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    32bc:	0e 94 bf 19 	call	0x337e	; 0x337e <chb_buf_read>
    32c0:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    32c2:	c0 17       	cp	r28, r16
    32c4:	d1 07       	cpc	r29, r17
    32c6:	d1 f7       	brne	.-12     	; 0x32bc <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    32c8:	f7 01       	movw	r30, r14
    32ca:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    32cc:	83 85       	ldd	r24, Z+11	; 0x0b
    32ce:	94 85       	ldd	r25, Z+12	; 0x0c
    32d0:	83 83       	std	Z+3, r24	; 0x03
    32d2:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    32d4:	85 85       	ldd	r24, Z+13	; 0x0d
    32d6:	96 85       	ldd	r25, Z+14	; 0x0e
    32d8:	81 83       	std	Z+1, r24	; 0x01
    32da:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    32dc:	0e 94 d6 19 	call	0x33ac	; 0x33ac <chb_buf_get_len>
    32e0:	88 23       	and	r24, r24
    32e2:	11 f4       	brne	.+4      	; 0x32e8 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    32e4:	10 92 18 21 	sts	0x2118, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    32e8:	80 91 0a 20 	lds	r24, 0x200A
    32ec:	c8 17       	cp	r28, r24
    32ee:	51 f4       	brne	.+20     	; 0x3304 <chb_read+0x7c>
    32f0:	f7 01       	movw	r30, r14
    32f2:	21 81       	ldd	r18, Z+1	; 0x01
    32f4:	32 81       	ldd	r19, Z+2	; 0x02
    32f6:	80 91 0b 20 	lds	r24, 0x200B
    32fa:	90 91 0c 20 	lds	r25, 0x200C
    32fe:	28 17       	cp	r18, r24
    3300:	39 07       	cpc	r19, r25
    3302:	c1 f0       	breq	.+48     	; 0x3334 <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    3304:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    3308:	f7 01       	movw	r30, r14
    330a:	81 81       	ldd	r24, Z+1	; 0x01
    330c:	92 81       	ldd	r25, Z+2	; 0x02
    330e:	80 93 0b 20 	sts	0x200B, r24
    3312:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    3316:	b7 01       	movw	r22, r14
    3318:	61 5f       	subi	r22, 0xF1	; 241
    331a:	7f 4f       	sbci	r23, 0xFF	; 255
    331c:	4d 2d       	mov	r20, r13
    331e:	50 e0       	ldi	r21, 0x00	; 0
    3320:	49 50       	subi	r20, 0x09	; 9
    3322:	50 40       	sbci	r21, 0x00	; 0
    3324:	c7 01       	movw	r24, r14
    3326:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    332a:	8d 2d       	mov	r24, r13
    332c:	8b 50       	subi	r24, 0x0B	; 11
    332e:	03 c0       	rjmp	.+6      	; 0x3336 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    3330:	80 e0       	ldi	r24, 0x00	; 0
    3332:	01 c0       	rjmp	.+2      	; 0x3336 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    3334:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    3336:	df 91       	pop	r29
    3338:	cf 91       	pop	r28
    333a:	1f 91       	pop	r17
    333c:	0f 91       	pop	r16
    333e:	ff 90       	pop	r15
    3340:	ef 90       	pop	r14
    3342:	df 90       	pop	r13
    3344:	08 95       	ret

00003346 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    3346:	10 92 29 21 	sts	0x2129, r1
    wr_ptr = 0;
    334a:	10 92 2a 21 	sts	0x212A, r1
    len = 0;
    334e:	10 92 2b 21 	sts	0x212B, r1
}
    3352:	08 95       	ret

00003354 <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    3354:	20 91 2a 21 	lds	r18, 0x212A
    3358:	30 e0       	ldi	r19, 0x00	; 0
    335a:	f9 01       	movw	r30, r18
    335c:	e4 5d       	subi	r30, 0xD4	; 212
    335e:	fe 4d       	sbci	r31, 0xDE	; 222
    3360:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    3362:	c9 01       	movw	r24, r18
    3364:	01 96       	adiw	r24, 0x01	; 1
    3366:	60 e8       	ldi	r22, 0x80	; 128
    3368:	70 e0       	ldi	r23, 0x00	; 0
    336a:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    336e:	80 93 2a 21 	sts	0x212A, r24
    len++;
    3372:	80 91 2b 21 	lds	r24, 0x212B
    3376:	8f 5f       	subi	r24, 0xFF	; 255
    3378:	80 93 2b 21 	sts	0x212B, r24
}
    337c:	08 95       	ret

0000337e <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    337e:	20 91 29 21 	lds	r18, 0x2129
    3382:	30 e0       	ldi	r19, 0x00	; 0
    3384:	f9 01       	movw	r30, r18
    3386:	e4 5d       	subi	r30, 0xD4	; 212
    3388:	fe 4d       	sbci	r31, 0xDE	; 222
    338a:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    338c:	2f 5f       	subi	r18, 0xFF	; 255
    338e:	3f 4f       	sbci	r19, 0xFF	; 255
    3390:	c9 01       	movw	r24, r18
    3392:	60 e8       	ldi	r22, 0x80	; 128
    3394:	70 e0       	ldi	r23, 0x00	; 0
    3396:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    339a:	80 93 29 21 	sts	0x2129, r24
    len--;
    339e:	80 91 2b 21 	lds	r24, 0x212B
    33a2:	81 50       	subi	r24, 0x01	; 1
    33a4:	80 93 2b 21 	sts	0x212B, r24
    return data;
}
    33a8:	84 2f       	mov	r24, r20
    33aa:	08 95       	ret

000033ac <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    33ac:	80 91 2b 21 	lds	r24, 0x212B
    33b0:	08 95       	ret

000033b2 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    33b2:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    33b4:	80 e0       	ldi	r24, 0x00	; 0
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	48 e0       	ldi	r20, 0x08	; 8
    33ba:	50 e0       	ldi	r21, 0x00	; 0
    33bc:	0e 94 2c 1e 	call	0x3c58	; 0x3c58 <chb_eeprom_read>
}
    33c0:	08 95       	ret

000033c2 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    33c2:	cf 93       	push	r28
    33c4:	df 93       	push	r29
    33c6:	0f 92       	push	r0
    33c8:	0f 92       	push	r0
    33ca:	cd b7       	in	r28, 0x3d	; 61
    33cc:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    33ce:	89 e0       	ldi	r24, 0x09	; 9
    33d0:	90 e0       	ldi	r25, 0x00	; 0
    33d2:	be 01       	movw	r22, r28
    33d4:	6f 5f       	subi	r22, 0xFF	; 255
    33d6:	7f 4f       	sbci	r23, 0xFF	; 255
    33d8:	42 e0       	ldi	r20, 0x02	; 2
    33da:	50 e0       	ldi	r21, 0x00	; 0
    33dc:	0e 94 2c 1e 	call	0x3c58	; 0x3c58 <chb_eeprom_read>
    return *(U16 *)addr;
}
    33e0:	89 81       	ldd	r24, Y+1	; 0x01
    33e2:	9a 81       	ldd	r25, Y+2	; 0x02
    33e4:	0f 90       	pop	r0
    33e6:	0f 90       	pop	r0
    33e8:	df 91       	pop	r29
    33ea:	cf 91       	pop	r28
    33ec:	08 95       	ret

000033ee <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    33ee:	88 23       	and	r24, r24
    33f0:	29 f0       	breq	.+10     	; 0x33fc <RadioCS+0xe>
    33f2:	80 e1       	ldi	r24, 0x10	; 16
    33f4:	e0 e6       	ldi	r30, 0x60	; 96
    33f6:	f6 e0       	ldi	r31, 0x06	; 6
    33f8:	86 83       	std	Z+6, r24	; 0x06
    33fa:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    33fc:	80 e1       	ldi	r24, 0x10	; 16
    33fe:	e0 e6       	ldi	r30, 0x60	; 96
    3400:	f6 e0       	ldi	r31, 0x06	; 6
    3402:	85 83       	std	Z+5, r24	; 0x05
    3404:	08 95       	ret

00003406 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    3406:	df 92       	push	r13
    3408:	ef 92       	push	r14
    340a:	ff 92       	push	r15
    340c:	0f 93       	push	r16
    340e:	1f 93       	push	r17
    3410:	cf 93       	push	r28
    3412:	df 93       	push	r29
    3414:	8c 01       	movw	r16, r24
    3416:	c6 2f       	mov	r28, r22
    3418:	7a 01       	movw	r14, r20
    341a:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    341c:	82 2f       	mov	r24, r18
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	86 0f       	add	r24, r22
    3422:	91 1d       	adc	r25, r1
    3424:	80 38       	cpi	r24, 0x80	; 128
    3426:	91 05       	cpc	r25, r1
    3428:	8c f5       	brge	.+98     	; 0x348c <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    342a:	8f b7       	in	r24, 0x3f	; 63
    342c:	80 93 58 40 	sts	0x4058, r24
    3430:	f8 94       	cli
    RadioCS(TRUE); 
    3432:	81 e0       	ldi	r24, 0x01	; 1
    3434:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    3438:	80 e6       	ldi	r24, 0x60	; 96
    343a:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    343e:	cc 23       	and	r28, r28
    3440:	79 f0       	breq	.+30     	; 0x3460 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    3442:	c8 01       	movw	r24, r16
    3444:	01 96       	adiw	r24, 0x01	; 1
    3446:	c1 50       	subi	r28, 0x01	; 1
    3448:	9c 01       	movw	r18, r24
    344a:	2c 0f       	add	r18, r28
    344c:	31 1d       	adc	r19, r1
    344e:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    3450:	f8 01       	movw	r30, r16
    3452:	81 91       	ld	r24, Z+
    3454:	8f 01       	movw	r16, r30
    3456:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    345a:	0c 17       	cp	r16, r28
    345c:	1d 07       	cpc	r17, r29
    345e:	c1 f7       	brne	.-16     	; 0x3450 <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3460:	dd 20       	and	r13, r13
    3462:	69 f0       	breq	.+26     	; 0x347e <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    3464:	e7 01       	movw	r28, r14
    3466:	21 96       	adiw	r28, 0x01	; 1
    3468:	da 94       	dec	r13
    346a:	cd 0d       	add	r28, r13
    346c:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    346e:	f7 01       	movw	r30, r14
    3470:	81 91       	ld	r24, Z+
    3472:	7f 01       	movw	r14, r30
    3474:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3478:	ec 16       	cp	r14, r28
    347a:	fd 06       	cpc	r15, r29
    347c:	c1 f7       	brne	.-16     	; 0x346e <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    347e:	80 e0       	ldi	r24, 0x00	; 0
    3480:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>
    CHB_LEAVE_CRIT();
    3484:	80 91 58 40 	lds	r24, 0x4058
    3488:	8f bf       	out	0x3f, r24	; 63
    348a:	78 94       	sei
}
    348c:	df 91       	pop	r29
    348e:	cf 91       	pop	r28
    3490:	1f 91       	pop	r17
    3492:	0f 91       	pop	r16
    3494:	ff 90       	pop	r15
    3496:	ef 90       	pop	r14
    3498:	df 90       	pop	r13
    349a:	08 95       	ret

0000349c <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    349c:	cf 93       	push	r28
    349e:	df 93       	push	r29
    34a0:	d8 2f       	mov	r29, r24
    34a2:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    34a4:	8f b7       	in	r24, 0x3f	; 63
    34a6:	80 93 58 40 	sts	0x4058, r24
    34aa:	f8 94       	cli
    RadioCS(TRUE);
    34ac:	81 e0       	ldi	r24, 0x01	; 1
    34ae:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    34b2:	8d 2f       	mov	r24, r29
    34b4:	80 6c       	ori	r24, 0xC0	; 192
    34b6:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    34ba:	8c 2f       	mov	r24, r28
    34bc:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>

    RadioCS(FALSE);
    34c0:	80 e0       	ldi	r24, 0x00	; 0
    34c2:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>
    CHB_LEAVE_CRIT();
    34c6:	80 91 58 40 	lds	r24, 0x4058
    34ca:	8f bf       	out	0x3f, r24	; 63
    34cc:	78 94       	sei
}
    34ce:	df 91       	pop	r29
    34d0:	cf 91       	pop	r28
    34d2:	08 95       	ret

000034d4 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    34d4:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    34d6:	85 e0       	ldi	r24, 0x05	; 5
    34d8:	0e 94 4e 1a 	call	0x349c	; 0x349c <chb_reg_write>
}
    34dc:	08 95       	ret

000034de <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    34de:	0f 93       	push	r16
    34e0:	1f 93       	push	r17
    34e2:	cf 93       	push	r28
    34e4:	df 93       	push	r29
    34e6:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    34e8:	c6 2f       	mov	r28, r22
    34ea:	d7 2f       	mov	r29, r23
    34ec:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    34ee:	69 91       	ld	r22, Y+
    34f0:	81 2f       	mov	r24, r17
    34f2:	80 0f       	add	r24, r16
    34f4:	0e 94 4e 1a 	call	0x349c	; 0x349c <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    34f8:	1f 5f       	subi	r17, 0xFF	; 255
    34fa:	18 30       	cpi	r17, 0x08	; 8
    34fc:	c1 f7       	brne	.-16     	; 0x34ee <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    34fe:	df 91       	pop	r29
    3500:	cf 91       	pop	r28
    3502:	1f 91       	pop	r17
    3504:	0f 91       	pop	r16
    3506:	08 95       	ret

00003508 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3508:	cf 93       	push	r28
    350a:	df 93       	push	r29
    350c:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    350e:	80 e0       	ldi	r24, 0x00	; 0
    3510:	90 e0       	ldi	r25, 0x00	; 0
    3512:	be 01       	movw	r22, r28
    3514:	48 e0       	ldi	r20, 0x08	; 8
    3516:	50 e0       	ldi	r21, 0x00	; 0
    3518:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    351c:	84 e2       	ldi	r24, 0x24	; 36
    351e:	be 01       	movw	r22, r28
    3520:	0e 94 6f 1a 	call	0x34de	; 0x34de <chb_reg_write64>
}
    3524:	df 91       	pop	r29
    3526:	cf 91       	pop	r28
    3528:	08 95       	ret

0000352a <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    352a:	cf 93       	push	r28
    352c:	df 93       	push	r29
    352e:	c8 2f       	mov	r28, r24
    3530:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    3532:	0e 94 4e 1a 	call	0x349c	; 0x349c <chb_reg_write>
    3536:	8c 2f       	mov	r24, r28
    3538:	8f 5f       	subi	r24, 0xFF	; 255
    353a:	6d 2f       	mov	r22, r29
    353c:	0e 94 4e 1a 	call	0x349c	; 0x349c <chb_reg_write>
    }
}
    3540:	df 91       	pop	r29
    3542:	cf 91       	pop	r28
    3544:	08 95       	ret

00003546 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    3546:	0f 93       	push	r16
    3548:	1f 93       	push	r17
    354a:	cf 93       	push	r28
    354c:	df 93       	push	r29
    354e:	0f 92       	push	r0
    3550:	0f 92       	push	r0
    3552:	cd b7       	in	r28, 0x3d	; 61
    3554:	de b7       	in	r29, 0x3e	; 62
    3556:	89 83       	std	Y+1, r24	; 0x01
    3558:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    355a:	0e 94 a1 18 	call	0x3142	; 0x3142 <chb_get_pcb>
    355e:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    3560:	89 e0       	ldi	r24, 0x09	; 9
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	be 01       	movw	r22, r28
    3566:	6f 5f       	subi	r22, 0xFF	; 255
    3568:	7f 4f       	sbci	r23, 0xFF	; 255
    356a:	42 e0       	ldi	r20, 0x02	; 2
    356c:	50 e0       	ldi	r21, 0x00	; 0
    356e:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    3572:	69 81       	ldd	r22, Y+1	; 0x01
    3574:	7a 81       	ldd	r23, Y+2	; 0x02
    3576:	80 e2       	ldi	r24, 0x20	; 32
    3578:	0e 94 95 1a 	call	0x352a	; 0x352a <chb_reg_write16>
    pcb->src_addr = addr;
    357c:	89 81       	ldd	r24, Y+1	; 0x01
    357e:	9a 81       	ldd	r25, Y+2	; 0x02
    3580:	f8 01       	movw	r30, r16
    3582:	80 83       	st	Z, r24
    3584:	91 83       	std	Z+1, r25	; 0x01
}
    3586:	0f 90       	pop	r0
    3588:	0f 90       	pop	r0
    358a:	df 91       	pop	r29
    358c:	cf 91       	pop	r28
    358e:	1f 91       	pop	r17
    3590:	0f 91       	pop	r16
    3592:	08 95       	ret

00003594 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    3594:	cf 93       	push	r28
    3596:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3598:	8f b7       	in	r24, 0x3f	; 63
    359a:	80 93 58 40 	sts	0x4058, r24
    359e:	f8 94       	cli
    RadioCS(TRUE);
    35a0:	81 e0       	ldi	r24, 0x01	; 1
    35a2:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    35a6:	8c 2f       	mov	r24, r28
    35a8:	80 68       	ori	r24, 0x80	; 128
    35aa:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    val = SPID_write(val);
    35ae:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    35b2:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    35b4:	80 e0       	ldi	r24, 0x00	; 0
    35b6:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>
    CHB_LEAVE_CRIT();
    35ba:	80 91 58 40 	lds	r24, 0x4058
    35be:	8f bf       	out	0x3f, r24	; 63
    35c0:	78 94       	sei

    return val;
}
    35c2:	8c 2f       	mov	r24, r28
    35c4:	cf 91       	pop	r28
    35c6:	08 95       	ret

000035c8 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    35c8:	81 e0       	ldi	r24, 0x01	; 1
    35ca:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
}
    35ce:	8f 71       	andi	r24, 0x1F	; 31
    35d0:	08 95       	ret

000035d2 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    35d2:	1f 93       	push	r17
    35d4:	cf 93       	push	r28
    35d6:	df 93       	push	r29
    35d8:	c8 2f       	mov	r28, r24
    35da:	16 2f       	mov	r17, r22
    35dc:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    35de:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    35e2:	6d 2f       	mov	r22, r29
    35e4:	60 95       	com	r22
    35e6:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    35e8:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    35ea:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    35ec:	8c 2f       	mov	r24, r28
    35ee:	0e 94 4e 1a 	call	0x349c	; 0x349c <chb_reg_write>
}
    35f2:	df 91       	pop	r29
    35f4:	cf 91       	pop	r28
    35f6:	1f 91       	pop	r17
    35f8:	08 95       	ret

000035fa <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    35fa:	cf 93       	push	r28
    35fc:	df 93       	push	r29
    35fe:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    3600:	80 91 64 06 	lds	r24, 0x0664
    3604:	81 fd       	sbrc	r24, 1
    3606:	4b c0       	rjmp	.+150    	; 0x369e <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3608:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_state>
    360c:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    360e:	81 51       	subi	r24, 0x11	; 17
    3610:	82 30       	cpi	r24, 0x02	; 2
    3612:	20 f0       	brcs	.+8      	; 0x361c <chb_set_state+0x22>
    3614:	c1 30       	cpi	r28, 0x01	; 1
    3616:	11 f0       	breq	.+4      	; 0x361c <chb_set_state+0x22>
    3618:	c2 30       	cpi	r28, 0x02	; 2
    361a:	21 f4       	brne	.+8      	; 0x3624 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    361c:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_state>
    3620:	8c 17       	cp	r24, r28
    3622:	e1 f3       	breq	.-8      	; 0x361c <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    3624:	d6 31       	cpi	r29, 0x16	; 22
    3626:	f9 f0       	breq	.+62     	; 0x3666 <chb_set_state+0x6c>
    3628:	d9 31       	cpi	r29, 0x19	; 25
    362a:	89 f0       	breq	.+34     	; 0x364e <chb_set_state+0x54>
    362c:	d8 30       	cpi	r29, 0x08	; 8
    362e:	31 f5       	brne	.+76     	; 0x367c <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    3630:	e4 e6       	ldi	r30, 0x64	; 100
    3632:	f6 e0       	ldi	r31, 0x06	; 6
    3634:	80 81       	ld	r24, Z
    3636:	8d 7f       	andi	r24, 0xFD	; 253
    3638:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    363a:	82 e0       	ldi	r24, 0x02	; 2
    363c:	63 e0       	ldi	r22, 0x03	; 3
    363e:	4f e1       	ldi	r20, 0x1F	; 31
    3640:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
    3644:	8a e0       	ldi	r24, 0x0A	; 10
    3646:	8a 95       	dec	r24
    3648:	f1 f7       	brne	.-4      	; 0x3646 <chb_set_state+0x4c>
    364a:	00 c0       	rjmp	.+0      	; 0x364c <chb_set_state+0x52>
    364c:	17 c0       	rjmp	.+46     	; 0x367c <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    364e:	c6 31       	cpi	r28, 0x16	; 22
    3650:	a9 f4       	brne	.+42     	; 0x367c <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3652:	82 e0       	ldi	r24, 0x02	; 2
    3654:	69 e0       	ldi	r22, 0x09	; 9
    3656:	4f e1       	ldi	r20, 0x1F	; 31
    3658:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
    365c:	9a e0       	ldi	r25, 0x0A	; 10
    365e:	9a 95       	dec	r25
    3660:	f1 f7       	brne	.-4      	; 0x365e <chb_set_state+0x64>
    3662:	00 c0       	rjmp	.+0      	; 0x3664 <chb_set_state+0x6a>
    3664:	0b c0       	rjmp	.+22     	; 0x367c <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    3666:	c9 31       	cpi	r28, 0x19	; 25
    3668:	49 f4       	brne	.+18     	; 0x367c <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    366a:	82 e0       	ldi	r24, 0x02	; 2
    366c:	69 e0       	ldi	r22, 0x09	; 9
    366e:	4f e1       	ldi	r20, 0x1F	; 31
    3670:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
    3674:	8a e0       	ldi	r24, 0x0A	; 10
    3676:	8a 95       	dec	r24
    3678:	f1 f7       	brne	.-4      	; 0x3676 <chb_set_state+0x7c>
    367a:	00 c0       	rjmp	.+0      	; 0x367c <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    367c:	82 e0       	ldi	r24, 0x02	; 2
    367e:	6d 2f       	mov	r22, r29
    3680:	4f e1       	ldi	r20, 0x1F	; 31
    3682:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
    3686:	8f e6       	ldi	r24, 0x6F	; 111
    3688:	93 e0       	ldi	r25, 0x03	; 3
    368a:	01 97       	sbiw	r24, 0x01	; 1
    368c:	f1 f7       	brne	.-4      	; 0x368a <chb_set_state+0x90>
    368e:	00 c0       	rjmp	.+0      	; 0x3690 <chb_set_state+0x96>
    3690:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    3692:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_state>
    3696:	8d 17       	cp	r24, r29
    3698:	21 f4       	brne	.+8      	; 0x36a2 <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    369a:	80 e4       	ldi	r24, 0x40	; 64
    369c:	03 c0       	rjmp	.+6      	; 0x36a4 <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    369e:	84 e4       	ldi	r24, 0x44	; 68
    36a0:	01 c0       	rjmp	.+2      	; 0x36a4 <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    36a2:	83 e4       	ldi	r24, 0x43	; 67
}
    36a4:	df 91       	pop	r29
    36a6:	cf 91       	pop	r28
    36a8:	08 95       	ret

000036aa <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    36aa:	88 23       	and	r24, r24
    36ac:	49 f0       	breq	.+18     	; 0x36c0 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    36ae:	88 e0       	ldi	r24, 0x08	; 8
    36b0:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    36b4:	e4 e6       	ldi	r30, 0x64	; 100
    36b6:	f6 e0       	ldi	r31, 0x06	; 6
    36b8:	80 81       	ld	r24, Z
    36ba:	82 60       	ori	r24, 0x02	; 2
    36bc:	80 83       	st	Z, r24
    36be:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    36c0:	e4 e6       	ldi	r30, 0x64	; 100
    36c2:	f6 e0       	ldi	r31, 0x06	; 6
    36c4:	80 81       	ld	r24, Z
    36c6:	8d 7f       	andi	r24, 0xFD	; 253
    36c8:	80 83       	st	Z, r24
    36ca:	8f e7       	ldi	r24, 0x7F	; 127
    36cc:	97 e0       	ldi	r25, 0x07	; 7
    36ce:	01 97       	sbiw	r24, 0x01	; 1
    36d0:	f1 f7       	brne	.-4      	; 0x36ce <chb_sleep+0x24>
    36d2:	00 c0       	rjmp	.+0      	; 0x36d4 <chb_sleep+0x2a>
    36d4:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    36d6:	86 e1       	ldi	r24, 0x16	; 22
    36d8:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <chb_set_state>
    36dc:	08 95       	ret

000036de <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    36de:	cf 92       	push	r12
    36e0:	df 92       	push	r13
    36e2:	ef 92       	push	r14
    36e4:	ff 92       	push	r15
    36e6:	0f 93       	push	r16
    36e8:	1f 93       	push	r17
    36ea:	cf 93       	push	r28
    36ec:	df 93       	push	r29
    36ee:	7c 01       	movw	r14, r24
    36f0:	6b 01       	movw	r12, r22
    36f2:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    36f4:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_state>
    36f8:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    36fa:	0e 94 a1 18 	call	0x3142	; 0x3142 <chb_get_pcb>
    36fe:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3700:	12 30       	cpi	r17, 0x02	; 2
    3702:	f1 f0       	breq	.+60     	; 0x3740 <chb_tx+0x62>
    3704:	12 31       	cpi	r17, 0x12	; 18
    3706:	f1 f0       	breq	.+60     	; 0x3744 <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    3708:	88 e0       	ldi	r24, 0x08	; 8
    370a:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    370e:	89 e1       	ldi	r24, 0x19	; 25
    3710:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    3714:	c7 01       	movw	r24, r14
    3716:	6a e0       	ldi	r22, 0x0A	; 10
    3718:	a6 01       	movw	r20, r12
    371a:	20 2f       	mov	r18, r16
    371c:	0e 94 03 1a 	call	0x3406	; 0x3406 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3720:	82 e0       	ldi	r24, 0x02	; 2
    3722:	62 e0       	ldi	r22, 0x02	; 2
    3724:	4f e1       	ldi	r20, 0x1F	; 31
    3726:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    372a:	8c 81       	ldd	r24, Y+4	; 0x04
    372c:	88 23       	and	r24, r24
    372e:	e9 f3       	breq	.-6      	; 0x372a <chb_tx+0x4c>
    pcb->tx_end = false;
    3730:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3732:	82 e0       	ldi	r24, 0x02	; 2
    3734:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    3738:	82 95       	swap	r24
    373a:	86 95       	lsr	r24
    373c:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    373e:	03 c0       	rjmp	.+6      	; 0x3746 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3740:	84 e4       	ldi	r24, 0x44	; 68
    3742:	01 c0       	rjmp	.+2      	; 0x3746 <chb_tx+0x68>
    3744:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3746:	df 91       	pop	r29
    3748:	cf 91       	pop	r28
    374a:	1f 91       	pop	r17
    374c:	0f 91       	pop	r16
    374e:	ff 90       	pop	r15
    3750:	ef 90       	pop	r14
    3752:	df 90       	pop	r13
    3754:	cf 90       	pop	r12
    3756:	08 95       	ret

00003758 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3758:	81 30       	cpi	r24, 0x01	; 1
    375a:	91 f0       	breq	.+36     	; 0x3780 <chb_set_mode+0x28>
    375c:	81 30       	cpi	r24, 0x01	; 1
    375e:	28 f0       	brcs	.+10     	; 0x376a <chb_set_mode+0x12>
    3760:	82 30       	cpi	r24, 0x02	; 2
    3762:	c9 f0       	breq	.+50     	; 0x3796 <chb_set_mode+0x3e>
    3764:	83 30       	cpi	r24, 0x03	; 3
    3766:	61 f5       	brne	.+88     	; 0x37c0 <chb_set_mode+0x68>
    3768:	21 c0       	rjmp	.+66     	; 0x37ac <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    376a:	8c e0       	ldi	r24, 0x0C	; 12
    376c:	68 e0       	ldi	r22, 0x08	; 8
    376e:	4f e3       	ldi	r20, 0x3F	; 63
    3770:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3774:	86 e1       	ldi	r24, 0x16	; 22
    3776:	62 e0       	ldi	r22, 0x02	; 2
    3778:	43 e0       	ldi	r20, 0x03	; 3
    377a:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
        break;
    377e:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    3780:	8c e0       	ldi	r24, 0x0C	; 12
    3782:	6c e0       	ldi	r22, 0x0C	; 12
    3784:	4f e3       	ldi	r20, 0x3F	; 63
    3786:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    378a:	86 e1       	ldi	r24, 0x16	; 22
    378c:	62 e0       	ldi	r22, 0x02	; 2
    378e:	43 e0       	ldi	r20, 0x03	; 3
    3790:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
        break;
    3794:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3796:	8c e0       	ldi	r24, 0x0C	; 12
    3798:	6c e1       	ldi	r22, 0x1C	; 28
    379a:	4f e3       	ldi	r20, 0x3F	; 63
    379c:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    37a0:	86 e1       	ldi	r24, 0x16	; 22
    37a2:	62 e0       	ldi	r22, 0x02	; 2
    37a4:	43 e0       	ldi	r20, 0x03	; 3
    37a6:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
        break;
    37aa:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    37ac:	8c e0       	ldi	r24, 0x0C	; 12
    37ae:	60 e0       	ldi	r22, 0x00	; 0
    37b0:	4f e3       	ldi	r20, 0x3F	; 63
    37b2:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    37b6:	86 e1       	ldi	r24, 0x16	; 22
    37b8:	63 e0       	ldi	r22, 0x03	; 3
    37ba:	43 e0       	ldi	r20, 0x03	; 3
    37bc:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
    37c0:	08 95       	ret

000037c2 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    37c2:	cf 93       	push	r28
    37c4:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    37c6:	88 e0       	ldi	r24, 0x08	; 8
    37c8:	6c 2f       	mov	r22, r28
    37ca:	4f e1       	ldi	r20, 0x1F	; 31
    37cc:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    37d0:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    37d4:	86 30       	cpi	r24, 0x06	; 6
    37d6:	11 f0       	breq	.+4      	; 0x37dc <chb_set_channel+0x1a>
    37d8:	89 30       	cpi	r24, 0x09	; 9
    37da:	31 f4       	brne	.+12     	; 0x37e8 <chb_set_channel+0x26>
    37dc:	8f e6       	ldi	r24, 0x6F	; 111
    37de:	93 e0       	ldi	r25, 0x03	; 3
    37e0:	01 97       	sbiw	r24, 0x01	; 1
    37e2:	f1 f7       	brne	.-4      	; 0x37e0 <chb_set_channel+0x1e>
    37e4:	00 c0       	rjmp	.+0      	; 0x37e6 <chb_set_channel+0x24>
    37e6:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    37e8:	88 e0       	ldi	r24, 0x08	; 8
    37ea:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    37ee:	90 e0       	ldi	r25, 0x00	; 0
    37f0:	8f 71       	andi	r24, 0x1F	; 31
    37f2:	90 70       	andi	r25, 0x00	; 0
    37f4:	6c 2f       	mov	r22, r28
    37f6:	70 e0       	ldi	r23, 0x00	; 0
    37f8:	86 17       	cp	r24, r22
    37fa:	97 07       	cpc	r25, r23
    37fc:	11 f4       	brne	.+4      	; 0x3802 <chb_set_channel+0x40>
    37fe:	80 e4       	ldi	r24, 0x40	; 64
    3800:	01 c0       	rjmp	.+2      	; 0x3804 <chb_set_channel+0x42>
    3802:	83 e4       	ldi	r24, 0x43	; 67
}
    3804:	cf 91       	pop	r28
    3806:	08 95       	ret

00003808 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3808:	cf 93       	push	r28
    380a:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    380c:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    3810:	8c 2b       	or	r24, r28
    3812:	8f 5f       	subi	r24, 0xFF	; 255
    3814:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    }
    return val;
}
    3818:	80 e0       	ldi	r24, 0x00	; 0
    381a:	90 e0       	ldi	r25, 0x00	; 0
    381c:	cf 91       	pop	r28
    381e:	08 95       	ret

00003820 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3820:	e4 e6       	ldi	r30, 0x64	; 100
    3822:	f6 e0       	ldi	r31, 0x06	; 6
    3824:	80 81       	ld	r24, Z
    3826:	81 60       	ori	r24, 0x01	; 1
    3828:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    382a:	80 81       	ld	r24, Z
    382c:	8d 7f       	andi	r24, 0xFD	; 253
    382e:	80 83       	st	Z, r24
    3830:	8f ed       	ldi	r24, 0xDF	; 223
    3832:	9b e0       	ldi	r25, 0x0B	; 11
    3834:	01 97       	sbiw	r24, 0x01	; 1
    3836:	f1 f7       	brne	.-4      	; 0x3834 <chb_reset+0x14>
    3838:	00 c0       	rjmp	.+0      	; 0x383a <chb_reset+0x1a>
    383a:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    383c:	80 81       	ld	r24, Z
    383e:	8e 7f       	andi	r24, 0xFE	; 254
    3840:	80 83       	st	Z, r24
    3842:	9a e0       	ldi	r25, 0x0A	; 10
    3844:	9a 95       	dec	r25
    3846:	f1 f7       	brne	.-4      	; 0x3844 <chb_reset+0x24>
    3848:	00 c0       	rjmp	.+0      	; 0x384a <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    384a:	80 81       	ld	r24, Z
    384c:	81 60       	ori	r24, 0x01	; 1
    384e:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3850:	8d e1       	ldi	r24, 0x1D	; 29
    3852:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    3856:	81 30       	cpi	r24, 0x01	; 1
    3858:	d9 f7       	brne	.-10     	; 0x3850 <chb_reset+0x30>
    385a:	8c e1       	ldi	r24, 0x1C	; 28
    385c:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    3860:	87 30       	cpi	r24, 0x07	; 7
    3862:	b1 f7       	brne	.-20     	; 0x3850 <chb_reset+0x30>
            break;
        }
    }
	

}
    3864:	08 95       	ret

00003866 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3866:	0f 93       	push	r16
    3868:	1f 93       	push	r17
    386a:	cf 93       	push	r28
    386c:	df 93       	push	r29
    386e:	cd b7       	in	r28, 0x3d	; 61
    3870:	de b7       	in	r29, 0x3e	; 62
    3872:	ea 97       	sbiw	r28, 0x3a	; 58
    3874:	cd bf       	out	0x3d, r28	; 61
    3876:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3878:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    387c:	e0 e6       	ldi	r30, 0x60	; 96
    387e:	f6 e0       	ldi	r31, 0x06	; 6
    3880:	80 81       	ld	r24, Z
    3882:	82 60       	ori	r24, 0x02	; 2
    3884:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3886:	80 81       	ld	r24, Z
    3888:	81 60       	ori	r24, 0x01	; 1
    388a:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    388c:	0e 94 10 1c 	call	0x3820	; 0x3820 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    3890:	8e e0       	ldi	r24, 0x0E	; 14
    3892:	60 e0       	ldi	r22, 0x00	; 0
    3894:	0e 94 4e 1a 	call	0x349c	; 0x349c <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3898:	82 e0       	ldi	r24, 0x02	; 2
    389a:	63 e0       	ldi	r22, 0x03	; 3
    389c:	4f e1       	ldi	r20, 0x1F	; 31
    389e:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    38a2:	81 e0       	ldi	r24, 0x01	; 1
    38a4:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    38a8:	8f 71       	andi	r24, 0x1F	; 31
    38aa:	88 30       	cpi	r24, 0x08	; 8
    38ac:	d1 f7       	brne	.-12     	; 0x38a2 <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    38ae:	8e e2       	ldi	r24, 0x2E	; 46
    38b0:	60 e4       	ldi	r22, 0x40	; 64
    38b2:	40 ec       	ldi	r20, 0xC0	; 192
    38b4:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    38b8:	8e e0       	ldi	r24, 0x0E	; 14
    38ba:	6c e0       	ldi	r22, 0x0C	; 12
    38bc:	0e 94 4e 1a 	call	0x349c	; 0x349c <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    38c0:	84 e0       	ldi	r24, 0x04	; 4
    38c2:	60 e2       	ldi	r22, 0x20	; 32
    38c4:	40 e2       	ldi	r20, 0x20	; 32
    38c6:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	0e 94 ac 1b 	call	0x3758	; 0x3758 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    38d0:	81 e0       	ldi	r24, 0x01	; 1
    38d2:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    38d6:	86 e1       	ldi	r24, 0x16	; 22
    38d8:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    38dc:	82 e2       	ldi	r24, 0x22	; 34
    38de:	64 e3       	ldi	r22, 0x34	; 52
    38e0:	72 e1       	ldi	r23, 0x12	; 18
    38e2:	0e 94 95 1a 	call	0x352a	; 0x352a <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    38e6:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <chb_get_short_addr>
    38ea:	bc 01       	movw	r22, r24
    38ec:	80 e2       	ldi	r24, 0x20	; 32
    38ee:	0e 94 95 1a 	call	0x352a	; 0x352a <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    38f2:	ce 01       	movw	r24, r28
    38f4:	01 96       	adiw	r24, 0x01	; 1
    38f6:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    38fa:	84 e2       	ldi	r24, 0x24	; 36
    38fc:	be 01       	movw	r22, r28
    38fe:	6f 5f       	subi	r22, 0xFF	; 255
    3900:	7f 4f       	sbci	r23, 0xFF	; 255
    3902:	0e 94 6f 1a 	call	0x34de	; 0x34de <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3906:	e2 e7       	ldi	r30, 0x72	; 114
    3908:	f6 e0       	ldi	r31, 0x06	; 6
    390a:	80 81       	ld	r24, Z
    390c:	81 60       	ori	r24, 0x01	; 1
    390e:	80 83       	st	Z, r24
    3910:	e9 e6       	ldi	r30, 0x69	; 105
    3912:	f6 e0       	ldi	r31, 0x06	; 6
    3914:	80 81       	ld	r24, Z
    3916:	83 60       	ori	r24, 0x03	; 3
    3918:	80 83       	st	Z, r24
    391a:	ea e6       	ldi	r30, 0x6A	; 106
    391c:	f6 e0       	ldi	r31, 0x06	; 6
    391e:	80 81       	ld	r24, Z
    3920:	84 60       	ori	r24, 0x04	; 4
    3922:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3924:	e0 ea       	ldi	r30, 0xA0	; 160
    3926:	f0 e0       	ldi	r31, 0x00	; 0
    3928:	82 81       	ldd	r24, Z+2	; 0x02
    392a:	87 60       	ori	r24, 0x07	; 7
    392c:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    392e:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_state>
    3932:	86 31       	cpi	r24, 0x16	; 22
    3934:	91 f0       	breq	.+36     	; 0x395a <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3936:	8e 01       	movw	r16, r28
    3938:	07 5f       	subi	r16, 0xF7	; 247
    393a:	1f 4f       	sbci	r17, 0xFF	; 255
    393c:	c8 01       	movw	r24, r16
    393e:	68 ee       	ldi	r22, 0xE8	; 232
    3940:	71 e0       	ldi	r23, 0x01	; 1
    3942:	0e 94 5c 38 	call	0x70b8	; 0x70b8 <strcpy_P>
        printf(buf);
    3946:	0f 92       	push	r0
    3948:	0f 92       	push	r0
    394a:	ed b7       	in	r30, 0x3d	; 61
    394c:	fe b7       	in	r31, 0x3e	; 62
    394e:	01 83       	std	Z+1, r16	; 0x01
    3950:	12 83       	std	Z+2, r17	; 0x02
    3952:	0e 94 a1 38 	call	0x7142	; 0x7142 <printf>
    3956:	0f 90       	pop	r0
    3958:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    395a:	ea 96       	adiw	r28, 0x3a	; 58
    395c:	cd bf       	out	0x3d, r28	; 61
    395e:	de bf       	out	0x3e, r29	; 62
    3960:	df 91       	pop	r29
    3962:	cf 91       	pop	r28
    3964:	1f 91       	pop	r17
    3966:	0f 91       	pop	r16
    3968:	08 95       	ret

0000396a <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    396a:	1f 92       	push	r1
    396c:	0f 92       	push	r0
    396e:	0f b6       	in	r0, 0x3f	; 63
    3970:	0f 92       	push	r0
    3972:	0b b6       	in	r0, 0x3b	; 59
    3974:	0f 92       	push	r0
    3976:	11 24       	eor	r1, r1
    3978:	6f 92       	push	r6
    397a:	7f 92       	push	r7
    397c:	8f 92       	push	r8
    397e:	9f 92       	push	r9
    3980:	af 92       	push	r10
    3982:	bf 92       	push	r11
    3984:	df 92       	push	r13
    3986:	ef 92       	push	r14
    3988:	ff 92       	push	r15
    398a:	0f 93       	push	r16
    398c:	1f 93       	push	r17
    398e:	2f 93       	push	r18
    3990:	3f 93       	push	r19
    3992:	4f 93       	push	r20
    3994:	5f 93       	push	r21
    3996:	6f 93       	push	r22
    3998:	7f 93       	push	r23
    399a:	8f 93       	push	r24
    399c:	9f 93       	push	r25
    399e:	af 93       	push	r26
    39a0:	bf 93       	push	r27
    39a2:	ef 93       	push	r30
    39a4:	ff 93       	push	r31
    39a6:	cf 93       	push	r28
    39a8:	df 93       	push	r29
    39aa:	cd b7       	in	r28, 0x3d	; 61
    39ac:	de b7       	in	r29, 0x3e	; 62
    39ae:	e2 97       	sbiw	r28, 0x32	; 50
    39b0:	cd bf       	out	0x3d, r28	; 61
    39b2:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    39b4:	0e 94 a1 18 	call	0x3142	; 0x3142 <chb_get_pcb>
    39b8:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    39ba:	8f b7       	in	r24, 0x3f	; 63
    39bc:	80 93 58 40 	sts	0x4058, r24
    39c0:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    39c2:	81 e0       	ldi	r24, 0x01	; 1
    39c4:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    39c8:	8f e8       	ldi	r24, 0x8F	; 143
    39ca:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    intp_src = SPID_write(0);
    39ce:	80 e0       	ldi	r24, 0x00	; 0
    39d0:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    39d4:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    39d6:	80 e0       	ldi	r24, 0x00	; 0
    39d8:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>

    while (intp_src)
    39dc:	11 23       	and	r17, r17
    39de:	09 f4       	brne	.+2      	; 0x39e2 <__vector_64+0x78>
    39e0:	ae c0       	rjmp	.+348    	; 0x3b3e <__vector_64+0x1d4>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    39e2:	aa 24       	eor	r10, r10
    39e4:	bb 24       	eor	r11, r11
    39e6:	68 94       	set
    39e8:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    39ea:	0f 2e       	mov	r0, r31
    39ec:	f8 e0       	ldi	r31, 0x08	; 8
    39ee:	8f 2e       	mov	r8, r31
    39f0:	f2 e0       	ldi	r31, 0x02	; 2
    39f2:	9f 2e       	mov	r9, r31
    39f4:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    39f6:	12 ff       	sbrs	r17, 2
    39f8:	02 c0       	rjmp	.+4      	; 0x39fe <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    39fa:	1b 7f       	andi	r17, 0xFB	; 251
    39fc:	9d c0       	rjmp	.+314    	; 0x3b38 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    39fe:	13 ff       	sbrs	r17, 3
    3a00:	82 c0       	rjmp	.+260    	; 0x3b06 <__vector_64+0x19c>
        {
            state = chb_get_state();
    3a02:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3a06:	86 30       	cpi	r24, 0x06	; 6
    3a08:	29 f0       	breq	.+10     	; 0x3a14 <__vector_64+0xaa>
    3a0a:	86 31       	cpi	r24, 0x16	; 22
    3a0c:	19 f0       	breq	.+6      	; 0x3a14 <__vector_64+0xaa>
    3a0e:	81 31       	cpi	r24, 0x11	; 17
    3a10:	09 f0       	breq	.+2      	; 0x3a14 <__vector_64+0xaa>
    3a12:	6f c0       	rjmp	.+222    	; 0x3af2 <__vector_64+0x188>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				//chb_set_state(CHB_TRX_OFF);
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3a14:	87 e0       	ldi	r24, 0x07	; 7
    3a16:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    3a1a:	f7 01       	movw	r30, r14
    3a1c:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3a1e:	86 e0       	ldi	r24, 0x06	; 6
    3a20:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
    3a24:	88 1f       	adc	r24, r24
    3a26:	88 27       	eor	r24, r24
    3a28:	88 1f       	adc	r24, r24
    3a2a:	f7 01       	movw	r30, r14
    3a2c:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3a2e:	88 23       	and	r24, r24
    3a30:	09 f4       	brne	.+2      	; 0x3a34 <__vector_64+0xca>
    3a32:	62 c0       	rjmp	.+196    	; 0x3af8 <__vector_64+0x18e>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3a34:	8f b7       	in	r24, 0x3f	; 63
    3a36:	80 93 58 40 	sts	0x4058, r24
    3a3a:	f8 94       	cli
    RadioCS(TRUE);
    3a3c:	81 e0       	ldi	r24, 0x01	; 1
    3a3e:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3a42:	80 e2       	ldi	r24, 0x20	; 32
    3a44:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    len = SPID_write(0);
    3a48:	80 e0       	ldi	r24, 0x00	; 0
    3a4a:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
    3a4e:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3a50:	83 50       	subi	r24, 0x03	; 3
    3a52:	8d 37       	cpi	r24, 0x7D	; 125
    3a54:	f0 f5       	brcc	.+124    	; 0x3ad2 <__vector_64+0x168>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3a56:	0e 94 d6 19 	call	0x33ac	; 0x33ac <chb_buf_get_len>
    3a5a:	2d 2d       	mov	r18, r13
    3a5c:	30 e0       	ldi	r19, 0x00	; 0
    3a5e:	a5 01       	movw	r20, r10
    3a60:	48 1b       	sub	r20, r24
    3a62:	51 09       	sbc	r21, r1
    3a64:	24 17       	cp	r18, r20
    3a66:	35 07       	cpc	r19, r21
    3a68:	7c f4       	brge	.+30     	; 0x3a88 <__vector_64+0x11e>
        {
            chb_buf_write(len);
    3a6a:	8d 2d       	mov	r24, r13
    3a6c:	0e 94 aa 19 	call	0x3354	; 0x3354 <chb_buf_write>
            
            for (i=0; i<len; i++)
    3a70:	dd 20       	and	r13, r13
    3a72:	79 f1       	breq	.+94     	; 0x3ad2 <__vector_64+0x168>
    3a74:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3a76:	80 e0       	ldi	r24, 0x00	; 0
    3a78:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
                chb_buf_write(data);
    3a7c:	0e 94 aa 19 	call	0x3354	; 0x3354 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3a80:	0f 5f       	subi	r16, 0xFF	; 255
    3a82:	0d 15       	cp	r16, r13
    3a84:	c1 f7       	brne	.-16     	; 0x3a76 <__vector_64+0x10c>
    3a86:	25 c0       	rjmp	.+74     	; 0x3ad2 <__vector_64+0x168>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3a88:	0e 94 a1 18 	call	0x3142	; 0x3142 <chb_get_pcb>
    3a8c:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3a8e:	dd 20       	and	r13, r13
    3a90:	39 f0       	breq	.+14     	; 0x3aa0 <__vector_64+0x136>
    3a92:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3a94:	80 e0       	ldi	r24, 0x00	; 0
    3a96:	0e 94 77 1e 	call	0x3cee	; 0x3cee <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3a9a:	0f 5f       	subi	r16, 0xFF	; 255
    3a9c:	0d 15       	cp	r16, r13
    3a9e:	d1 f7       	brne	.-12     	; 0x3a94 <__vector_64+0x12a>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3aa0:	f3 01       	movw	r30, r6
    3aa2:	85 85       	ldd	r24, Z+13	; 0x0d
    3aa4:	96 85       	ldd	r25, Z+14	; 0x0e
    3aa6:	01 96       	adiw	r24, 0x01	; 1
    3aa8:	85 87       	std	Z+13, r24	; 0x0d
    3aaa:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3aac:	ce 01       	movw	r24, r28
    3aae:	01 96       	adiw	r24, 0x01	; 1
    3ab0:	b4 01       	movw	r22, r8
    3ab2:	0e 94 5c 38 	call	0x70b8	; 0x70b8 <strcpy_P>
            printf(buf);
    3ab6:	0f 92       	push	r0
    3ab8:	0f 92       	push	r0
    3aba:	41 e0       	ldi	r20, 0x01	; 1
    3abc:	50 e0       	ldi	r21, 0x00	; 0
    3abe:	4c 0f       	add	r20, r28
    3ac0:	5d 1f       	adc	r21, r29
    3ac2:	ed b7       	in	r30, 0x3d	; 61
    3ac4:	fe b7       	in	r31, 0x3e	; 62
    3ac6:	41 83       	std	Z+1, r20	; 0x01
    3ac8:	52 83       	std	Z+2, r21	; 0x02
    3aca:	0e 94 a1 38 	call	0x7142	; 0x7142 <printf>
    3ace:	0f 90       	pop	r0
    3ad0:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3ad2:	80 e0       	ldi	r24, 0x00	; 0
    3ad4:	0e 94 f7 19 	call	0x33ee	; 0x33ee <RadioCS>
    CHB_LEAVE_CRIT();
    3ad8:	80 91 58 40 	lds	r24, 0x4058
    3adc:	8f bf       	out	0x3f, r24	; 63
    3ade:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3ae0:	f7 01       	movw	r30, r14
    3ae2:	85 81       	ldd	r24, Z+5	; 0x05
    3ae4:	96 81       	ldd	r25, Z+6	; 0x06
    3ae6:	01 96       	adiw	r24, 0x01	; 1
    3ae8:	85 83       	std	Z+5, r24	; 0x05
    3aea:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3aec:	81 e0       	ldi	r24, 0x01	; 1
    3aee:	83 83       	std	Z+3, r24	; 0x03
    3af0:	03 c0       	rjmp	.+6      	; 0x3af8 <__vector_64+0x18e>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    3af2:	81 e0       	ldi	r24, 0x01	; 1
    3af4:	f7 01       	movw	r30, r14
    3af6:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3af8:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3afa:	86 e1       	ldi	r24, 0x16	; 22
    3afc:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <chb_set_state>
    3b00:	80 34       	cpi	r24, 0x40	; 64
    3b02:	d9 f7       	brne	.-10     	; 0x3afa <__vector_64+0x190>
    3b04:	19 c0       	rjmp	.+50     	; 0x3b38 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3b06:	16 ff       	sbrs	r17, 6
    3b08:	08 c0       	rjmp	.+16     	; 0x3b1a <__vector_64+0x1b0>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3b0a:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3b0c:	f7 01       	movw	r30, r14
    3b0e:	87 85       	ldd	r24, Z+15	; 0x0f
    3b10:	90 89       	ldd	r25, Z+16	; 0x10
    3b12:	01 96       	adiw	r24, 0x01	; 1
    3b14:	87 87       	std	Z+15, r24	; 0x0f
    3b16:	90 8b       	std	Z+16, r25	; 0x10
    3b18:	0f c0       	rjmp	.+30     	; 0x3b38 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3b1a:	11 ff       	sbrs	r17, 1
    3b1c:	02 c0       	rjmp	.+4      	; 0x3b22 <__vector_64+0x1b8>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3b1e:	1d 7f       	andi	r17, 0xFD	; 253
    3b20:	0b c0       	rjmp	.+22     	; 0x3b38 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3b22:	10 ff       	sbrs	r17, 0
    3b24:	02 c0       	rjmp	.+4      	; 0x3b2a <__vector_64+0x1c0>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3b26:	1e 7f       	andi	r17, 0xFE	; 254
    3b28:	07 c0       	rjmp	.+14     	; 0x3b38 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3b2a:	11 23       	and	r17, r17
    3b2c:	2c f4       	brge	.+10     	; 0x3b38 <__vector_64+0x1ce>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3b2e:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    3b30:	f7 01       	movw	r30, r14
    3b32:	81 89       	ldd	r24, Z+17	; 0x11
    3b34:	8f 5f       	subi	r24, 0xFF	; 255
    3b36:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3b38:	11 23       	and	r17, r17
    3b3a:	09 f0       	breq	.+2      	; 0x3b3e <__vector_64+0x1d4>
    3b3c:	5c cf       	rjmp	.-328    	; 0x39f6 <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3b3e:	80 91 58 40 	lds	r24, 0x4058
    3b42:	8f bf       	out	0x3f, r24	; 63
    3b44:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3b46:	8f e0       	ldi	r24, 0x0F	; 15
    3b48:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_reg_read>
}
    3b4c:	e2 96       	adiw	r28, 0x32	; 50
    3b4e:	cd bf       	out	0x3d, r28	; 61
    3b50:	de bf       	out	0x3e, r29	; 62
    3b52:	df 91       	pop	r29
    3b54:	cf 91       	pop	r28
    3b56:	ff 91       	pop	r31
    3b58:	ef 91       	pop	r30
    3b5a:	bf 91       	pop	r27
    3b5c:	af 91       	pop	r26
    3b5e:	9f 91       	pop	r25
    3b60:	8f 91       	pop	r24
    3b62:	7f 91       	pop	r23
    3b64:	6f 91       	pop	r22
    3b66:	5f 91       	pop	r21
    3b68:	4f 91       	pop	r20
    3b6a:	3f 91       	pop	r19
    3b6c:	2f 91       	pop	r18
    3b6e:	1f 91       	pop	r17
    3b70:	0f 91       	pop	r16
    3b72:	ff 90       	pop	r15
    3b74:	ef 90       	pop	r14
    3b76:	df 90       	pop	r13
    3b78:	bf 90       	pop	r11
    3b7a:	af 90       	pop	r10
    3b7c:	9f 90       	pop	r9
    3b7e:	8f 90       	pop	r8
    3b80:	7f 90       	pop	r7
    3b82:	6f 90       	pop	r6
    3b84:	0f 90       	pop	r0
    3b86:	0b be       	out	0x3b, r0	; 59
    3b88:	0f 90       	pop	r0
    3b8a:	0f be       	out	0x3f, r0	; 63
    3b8c:	0f 90       	pop	r0
    3b8e:	1f 90       	pop	r1
    3b90:	18 95       	reti

00003b92 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3b92:	0f 93       	push	r16
    3b94:	1f 93       	push	r17
    3b96:	cf 93       	push	r28
    3b98:	df 93       	push	r29
    3b9a:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3b9c:	e0 ec       	ldi	r30, 0xC0	; 192
    3b9e:	f1 e0       	ldi	r31, 0x01	; 1
    3ba0:	84 85       	ldd	r24, Z+12	; 0x0c
    3ba2:	87 7f       	andi	r24, 0xF7	; 247
    3ba4:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3ba6:	41 15       	cp	r20, r1
    3ba8:	51 05       	cpc	r21, r1
    3baa:	09 f4       	brne	.+2      	; 0x3bae <chb_eeprom_write+0x1c>
    3bac:	50 c0       	rjmp	.+160    	; 0x3c4e <chb_eeprom_write+0xbc>
    3bae:	e0 e0       	ldi	r30, 0x00	; 0
    3bb0:	f0 e0       	ldi	r31, 0x00	; 0
    3bb2:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3bb4:	a0 ec       	ldi	r26, 0xC0	; 192
    3bb6:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3bb8:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3bba:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3bbc:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3bbe:	cf 01       	movw	r24, r30
    3bc0:	80 0f       	add	r24, r16
    3bc2:	91 1f       	adc	r25, r17
    3bc4:	e6 0f       	add	r30, r22
    3bc6:	f7 1f       	adc	r31, r23
    3bc8:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3bca:	1f 96       	adiw	r26, 0x0f	; 15
    3bcc:	ec 91       	ld	r30, X
    3bce:	1f 97       	sbiw	r26, 0x0f	; 15
    3bd0:	ee 23       	and	r30, r30
    3bd2:	dc f3       	brlt	.-10     	; 0x3bca <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3bd4:	1f 96       	adiw	r26, 0x0f	; 15
    3bd6:	ec 91       	ld	r30, X
    3bd8:	1f 97       	sbiw	r26, 0x0f	; 15
    3bda:	e1 ff       	sbrs	r30, 1
    3bdc:	11 c0       	rjmp	.+34     	; 0x3c00 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3bde:	1a 96       	adiw	r26, 0x0a	; 10
    3be0:	dc 93       	st	X, r29
    3be2:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3be4:	ef 93       	push	r30
    3be6:	ff 93       	push	r31
    3be8:	0f 93       	push	r16
    3bea:	2f 93       	push	r18
    3bec:	eb ec       	ldi	r30, 0xCB	; 203
    3bee:	f1 e0       	ldi	r31, 0x01	; 1
    3bf0:	08 ed       	ldi	r16, 0xD8	; 216
    3bf2:	21 e0       	ldi	r18, 0x01	; 1
    3bf4:	04 bf       	out	0x34, r16	; 52
    3bf6:	20 83       	st	Z, r18
    3bf8:	2f 91       	pop	r18
    3bfa:	0f 91       	pop	r16
    3bfc:	ff 91       	pop	r31
    3bfe:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3c00:	1a 96       	adiw	r26, 0x0a	; 10
    3c02:	cc 93       	st	X, r28
    3c04:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3c06:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3c08:	89 2f       	mov	r24, r25
    3c0a:	8f 71       	andi	r24, 0x1F	; 31
    3c0c:	11 96       	adiw	r26, 0x01	; 1
    3c0e:	8c 93       	st	X, r24
    3c10:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3c12:	12 96       	adiw	r26, 0x02	; 2
    3c14:	1c 92       	st	X, r1
    3c16:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3c18:	14 96       	adiw	r26, 0x04	; 4
    3c1a:	fc 93       	st	X, r31
    3c1c:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3c1e:	1a 96       	adiw	r26, 0x0a	; 10
    3c20:	3c 93       	st	X, r19
    3c22:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3c24:	ef 93       	push	r30
    3c26:	ff 93       	push	r31
    3c28:	0f 93       	push	r16
    3c2a:	2f 93       	push	r18
    3c2c:	eb ec       	ldi	r30, 0xCB	; 203
    3c2e:	f1 e0       	ldi	r31, 0x01	; 1
    3c30:	08 ed       	ldi	r16, 0xD8	; 216
    3c32:	21 e0       	ldi	r18, 0x01	; 1
    3c34:	04 bf       	out	0x34, r16	; 52
    3c36:	20 83       	st	Z, r18
    3c38:	2f 91       	pop	r18
    3c3a:	0f 91       	pop	r16
    3c3c:	ff 91       	pop	r31
    3c3e:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3c40:	2f 5f       	subi	r18, 0xFF	; 255
    3c42:	e2 2f       	mov	r30, r18
    3c44:	f0 e0       	ldi	r31, 0x00	; 0
    3c46:	e4 17       	cp	r30, r20
    3c48:	f5 07       	cpc	r31, r21
    3c4a:	08 f4       	brcc	.+2      	; 0x3c4e <chb_eeprom_write+0xbc>
    3c4c:	b8 cf       	rjmp	.-144    	; 0x3bbe <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3c4e:	df 91       	pop	r29
    3c50:	cf 91       	pop	r28
    3c52:	1f 91       	pop	r17
    3c54:	0f 91       	pop	r16
    3c56:	08 95       	ret

00003c58 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3c58:	1f 93       	push	r17
    3c5a:	cf 93       	push	r28
    3c5c:	df 93       	push	r29
    3c5e:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3c60:	e0 ec       	ldi	r30, 0xC0	; 192
    3c62:	f1 e0       	ldi	r31, 0x01	; 1
    3c64:	84 85       	ldd	r24, Z+12	; 0x0c
    3c66:	87 7f       	andi	r24, 0xF7	; 247
    3c68:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3c6a:	41 15       	cp	r20, r1
    3c6c:	51 05       	cpc	r21, r1
    3c6e:	41 f1       	breq	.+80     	; 0x3cc0 <chb_eeprom_read+0x68>
    3c70:	80 e0       	ldi	r24, 0x00	; 0
    3c72:	90 e0       	ldi	r25, 0x00	; 0
    3c74:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3c76:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3c78:	db 01       	movw	r26, r22
    3c7a:	a8 0f       	add	r26, r24
    3c7c:	b9 1f       	adc	r27, r25
    3c7e:	82 0f       	add	r24, r18
    3c80:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3c82:	17 85       	ldd	r17, Z+15	; 0x0f
    3c84:	11 23       	and	r17, r17
    3c86:	ec f3       	brlt	.-6      	; 0x3c82 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3c88:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3c8a:	89 2f       	mov	r24, r25
    3c8c:	8f 71       	andi	r24, 0x1F	; 31
    3c8e:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3c90:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3c92:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3c94:	ef 93       	push	r30
    3c96:	ff 93       	push	r31
    3c98:	0f 93       	push	r16
    3c9a:	2f 93       	push	r18
    3c9c:	eb ec       	ldi	r30, 0xCB	; 203
    3c9e:	f1 e0       	ldi	r31, 0x01	; 1
    3ca0:	08 ed       	ldi	r16, 0xD8	; 216
    3ca2:	21 e0       	ldi	r18, 0x01	; 1
    3ca4:	04 bf       	out	0x34, r16	; 52
    3ca6:	20 83       	st	Z, r18
    3ca8:	2f 91       	pop	r18
    3caa:	0f 91       	pop	r16
    3cac:	ff 91       	pop	r31
    3cae:	ef 91       	pop	r30

    return NVM.DATA0;
    3cb0:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3cb2:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3cb4:	cf 5f       	subi	r28, 0xFF	; 255
    3cb6:	8c 2f       	mov	r24, r28
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
    3cba:	84 17       	cp	r24, r20
    3cbc:	95 07       	cpc	r25, r21
    3cbe:	e0 f2       	brcs	.-72     	; 0x3c78 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3cc0:	df 91       	pop	r29
    3cc2:	cf 91       	pop	r28
    3cc4:	1f 91       	pop	r17
    3cc6:	08 95       	ret

00003cc8 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3cc8:	e0 e6       	ldi	r30, 0x60	; 96
    3cca:	f6 e0       	ldi	r31, 0x06	; 6
    3ccc:	80 81       	ld	r24, Z
    3cce:	80 6b       	ori	r24, 0xB0	; 176
    3cd0:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3cd2:	e4 e6       	ldi	r30, 0x64	; 100
    3cd4:	f6 e0       	ldi	r31, 0x06	; 6
    3cd6:	80 81       	ld	r24, Z
    3cd8:	80 61       	ori	r24, 0x10	; 16
    3cda:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3cdc:	a0 ec       	ldi	r26, 0xC0	; 192
    3cde:	b9 e0       	ldi	r27, 0x09	; 9
    3ce0:	8c 91       	ld	r24, X
    3ce2:	81 65       	ori	r24, 0x51	; 81
    3ce4:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3ce6:	80 81       	ld	r24, Z
    3ce8:	80 61       	ori	r24, 0x10	; 16
    3cea:	80 83       	st	Z, r24
}
    3cec:	08 95       	ret

00003cee <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3cee:	e0 ec       	ldi	r30, 0xC0	; 192
    3cf0:	f9 e0       	ldi	r31, 0x09	; 9
    3cf2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3cf4:	82 81       	ldd	r24, Z+2	; 0x02
    3cf6:	88 23       	and	r24, r24
    3cf8:	ec f7       	brge	.-6      	; 0x3cf4 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3cfa:	e0 ec       	ldi	r30, 0xC0	; 192
    3cfc:	f9 e0       	ldi	r31, 0x09	; 9
    3cfe:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3d00:	08 95       	ret

00003d02 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3d02:	0f 93       	push	r16
    3d04:	cf 93       	push	r28
    3d06:	df 93       	push	r29
    3d08:	0f 92       	push	r0
    3d0a:	cd b7       	in	r28, 0x3d	; 61
    3d0c:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    3d0e:	2f b7       	in	r18, 0x3f	; 63
    3d10:	29 83       	std	Y+1, r18	; 0x01
    3d12:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3d14:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3d16:	fc 01       	movw	r30, r24
    3d18:	08 ed       	ldi	r16, 0xD8	; 216
    3d1a:	04 bf       	out	0x34, r16	; 52
    3d1c:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    3d1e:	89 81       	ldd	r24, Y+1	; 0x01
    3d20:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3d22:	0f 90       	pop	r0
    3d24:	df 91       	pop	r29
    3d26:	cf 91       	pop	r28
    3d28:	0f 91       	pop	r16
    3d2a:	08 95       	ret

00003d2c <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    3d2c:	66 23       	and	r22, r22
    3d2e:	11 f0       	breq	.+4      	; 0x3d34 <CLKSYS_XOSC_Config+0x8>
    3d30:	90 e2       	ldi	r25, 0x20	; 32
    3d32:	01 c0       	rjmp	.+2      	; 0x3d36 <CLKSYS_XOSC_Config+0xa>
    3d34:	90 e0       	ldi	r25, 0x00	; 0
    3d36:	84 2b       	or	r24, r20
    3d38:	89 2b       	or	r24, r25
    3d3a:	e0 e5       	ldi	r30, 0x50	; 80
    3d3c:	f0 e0       	ldi	r31, 0x00	; 0
    3d3e:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3d40:	08 95       	ret

00003d42 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3d42:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3d44:	86 2b       	or	r24, r22
    3d46:	e0 e5       	ldi	r30, 0x50	; 80
    3d48:	f0 e0       	ldi	r31, 0x00	; 0
    3d4a:	85 83       	std	Z+5, r24	; 0x05
}
    3d4c:	08 95       	ret

00003d4e <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    3d4e:	e0 e5       	ldi	r30, 0x50	; 80
    3d50:	f0 e0       	ldi	r31, 0x00	; 0
    3d52:	90 81       	ld	r25, Z
    3d54:	28 2f       	mov	r18, r24
    3d56:	20 95       	com	r18
    3d58:	92 23       	and	r25, r18
    3d5a:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    3d5c:	90 81       	ld	r25, Z
	return clkEnabled;
}
    3d5e:	89 23       	and	r24, r25
    3d60:	08 95       	ret

00003d62 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    3d62:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    3d64:	81 e4       	ldi	r24, 0x41	; 65
    3d66:	90 e0       	ldi	r25, 0x00	; 0
    3d68:	0e 94 81 1e 	call	0x3d02	; 0x3d02 <CCPWrite>
}
    3d6c:	08 95       	ret

00003d6e <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    3d6e:	1f 93       	push	r17
    3d70:	cf 93       	push	r28
    3d72:	df 93       	push	r29
    3d74:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    3d76:	c0 e4       	ldi	r28, 0x40	; 64
    3d78:	d0 e0       	ldi	r29, 0x00	; 0
    3d7a:	68 81       	ld	r22, Y
    3d7c:	68 7f       	andi	r22, 0xF8	; 248
    3d7e:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    3d80:	80 e4       	ldi	r24, 0x40	; 64
    3d82:	90 e0       	ldi	r25, 0x00	; 0
    3d84:	0e 94 81 1e 	call	0x3d02	; 0x3d02 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    3d88:	88 81       	ld	r24, Y
	return clkCtrl;
}
    3d8a:	81 23       	and	r24, r17
    3d8c:	df 91       	pop	r29
    3d8e:	cf 91       	pop	r28
    3d90:	1f 91       	pop	r17
    3d92:	08 95       	ret

00003d94 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    3d94:	e0 e4       	ldi	r30, 0x40	; 64
    3d96:	f0 e0       	ldi	r31, 0x00	; 0
    3d98:	93 81       	ldd	r25, Z+3	; 0x03
    3d9a:	91 7f       	andi	r25, 0xF1	; 241
    3d9c:	91 60       	ori	r25, 0x01	; 1
    3d9e:	89 2b       	or	r24, r25
    3da0:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    3da2:	08 95       	ret

00003da4 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    3da4:	e0 e5       	ldi	r30, 0x50	; 80
    3da6:	f0 e0       	ldi	r31, 0x00	; 0
    3da8:	26 81       	ldd	r18, Z+6	; 0x06
    3daa:	98 2f       	mov	r25, r24
    3dac:	38 2f       	mov	r19, r24
    3dae:	30 95       	com	r19
    3db0:	23 23       	and	r18, r19
    3db2:	66 23       	and	r22, r22
    3db4:	09 f4       	brne	.+2      	; 0x3db8 <CLKSYS_AutoCalibration_Enable+0x14>
    3db6:	90 e0       	ldi	r25, 0x00	; 0
    3db8:	92 2b       	or	r25, r18
    3dba:	e0 e5       	ldi	r30, 0x50	; 80
    3dbc:	f0 e0       	ldi	r31, 0x00	; 0
    3dbe:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3dc0:	81 30       	cpi	r24, 0x01	; 1
    3dc2:	31 f4       	brne	.+12     	; 0x3dd0 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3dc4:	e8 e6       	ldi	r30, 0x68	; 104
    3dc6:	f0 e0       	ldi	r31, 0x00	; 0
    3dc8:	80 81       	ld	r24, Z
    3dca:	81 60       	ori	r24, 0x01	; 1
    3dcc:	80 83       	st	Z, r24
    3dce:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3dd0:	82 30       	cpi	r24, 0x02	; 2
    3dd2:	29 f4       	brne	.+10     	; 0x3dde <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3dd4:	e0 e6       	ldi	r30, 0x60	; 96
    3dd6:	f0 e0       	ldi	r31, 0x00	; 0
    3dd8:	80 81       	ld	r24, Z
    3dda:	81 60       	ori	r24, 0x01	; 1
    3ddc:	80 83       	st	Z, r24
    3dde:	08 95       	ret

00003de0 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3de0:	83 e5       	ldi	r24, 0x53	; 83
    3de2:	90 e0       	ldi	r25, 0x00	; 0
    3de4:	63 e0       	ldi	r22, 0x03	; 3
    3de6:	0e 94 81 1e 	call	0x3d02	; 0x3d02 <CCPWrite>
}
    3dea:	08 95       	ret

00003dec <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    3dec:	82 e4       	ldi	r24, 0x42	; 66
    3dee:	90 e0       	ldi	r25, 0x00	; 0
    3df0:	61 e0       	ldi	r22, 0x01	; 1
    3df2:	0e 94 81 1e 	call	0x3d02	; 0x3d02 <CCPWrite>
}
    3df6:	08 95       	ret

00003df8 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    3df8:	cf 92       	push	r12
    3dfa:	df 92       	push	r13
    3dfc:	ef 92       	push	r14
    3dfe:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3e00:	20 91 6a 50 	lds	r18, 0x506A
    3e04:	30 91 6b 50 	lds	r19, 0x506B
    3e08:	c0 90 4e 40 	lds	r12, 0x404E
    3e0c:	d0 90 4f 40 	lds	r13, 0x404F
    3e10:	e0 90 50 40 	lds	r14, 0x4050
    3e14:	f0 90 51 40 	lds	r15, 0x4051
    3e18:	62 50       	subi	r22, 0x02	; 2
    3e1a:	70 40       	sbci	r23, 0x00	; 0
    3e1c:	80 40       	sbci	r24, 0x00	; 0
    3e1e:	90 40       	sbci	r25, 0x00	; 0
    3e20:	40 e0       	ldi	r20, 0x00	; 0
    3e22:	50 e0       	ldi	r21, 0x00	; 0
    3e24:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    3e28:	dc 01       	movw	r26, r24
    3e2a:	cb 01       	movw	r24, r22
    3e2c:	c8 0e       	add	r12, r24
    3e2e:	d9 1e       	adc	r13, r25
    3e30:	ea 1e       	adc	r14, r26
    3e32:	fb 1e       	adc	r15, r27
}
    3e34:	6c 2d       	mov	r22, r12
    3e36:	7d 2d       	mov	r23, r13
    3e38:	8e 2d       	mov	r24, r14
    3e3a:	9f 2d       	mov	r25, r15
    3e3c:	ff 90       	pop	r15
    3e3e:	ef 90       	pop	r14
    3e40:	df 90       	pop	r13
    3e42:	cf 90       	pop	r12
    3e44:	08 95       	ret

00003e46 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    3e46:	3f 92       	push	r3
    3e48:	4f 92       	push	r4
    3e4a:	5f 92       	push	r5
    3e4c:	6f 92       	push	r6
    3e4e:	7f 92       	push	r7
    3e50:	8f 92       	push	r8
    3e52:	9f 92       	push	r9
    3e54:	af 92       	push	r10
    3e56:	bf 92       	push	r11
    3e58:	cf 92       	push	r12
    3e5a:	df 92       	push	r13
    3e5c:	ef 92       	push	r14
    3e5e:	ff 92       	push	r15
    3e60:	0f 93       	push	r16
    3e62:	1f 93       	push	r17
    3e64:	cf 93       	push	r28
    3e66:	df 93       	push	r29
    3e68:	00 d0       	rcall	.+0      	; 0x3e6a <getSetNextCluster+0x24>
    3e6a:	0f 92       	push	r0
    3e6c:	cd b7       	in	r28, 0x3d	; 61
    3e6e:	de b7       	in	r29, 0x3e	; 62
    3e70:	dc 01       	movw	r26, r24
    3e72:	cb 01       	movw	r24, r22
    3e74:	34 2e       	mov	r3, r20
    3e76:	09 83       	std	Y+1, r16	; 0x01
    3e78:	1a 83       	std	Y+2, r17	; 0x02
    3e7a:	2b 83       	std	Y+3, r18	; 0x03
    3e7c:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    3e7e:	80 90 70 50 	lds	r8, 0x5070
    3e82:	90 90 71 50 	lds	r9, 0x5071
    3e86:	2c 01       	movw	r4, r24
    3e88:	3d 01       	movw	r6, r26
    3e8a:	44 0c       	add	r4, r4
    3e8c:	55 1c       	adc	r5, r5
    3e8e:	66 1c       	adc	r6, r6
    3e90:	77 1c       	adc	r7, r7
    3e92:	44 0c       	add	r4, r4
    3e94:	55 1c       	adc	r5, r5
    3e96:	66 1c       	adc	r6, r6
    3e98:	77 1c       	adc	r7, r7
    3e9a:	20 91 56 40 	lds	r18, 0x4056
    3e9e:	30 91 57 40 	lds	r19, 0x4057
    3ea2:	aa 24       	eor	r10, r10
    3ea4:	bb 24       	eor	r11, r11
    3ea6:	80 91 6c 50 	lds	r24, 0x506C
    3eaa:	90 91 6d 50 	lds	r25, 0x506D
    3eae:	a0 91 6e 50 	lds	r26, 0x506E
    3eb2:	b0 91 6f 50 	lds	r27, 0x506F
    3eb6:	88 0e       	add	r8, r24
    3eb8:	99 1e       	adc	r9, r25
    3eba:	aa 1e       	adc	r10, r26
    3ebc:	bb 1e       	adc	r11, r27
    3ebe:	40 e0       	ldi	r20, 0x00	; 0
    3ec0:	50 e0       	ldi	r21, 0x00	; 0
    3ec2:	c3 01       	movw	r24, r6
    3ec4:	b2 01       	movw	r22, r4
    3ec6:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    3eca:	69 01       	movw	r12, r18
    3ecc:	7a 01       	movw	r14, r20
    3ece:	c8 0c       	add	r12, r8
    3ed0:	d9 1c       	adc	r13, r9
    3ed2:	ea 1c       	adc	r14, r10
    3ed4:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3ed6:	00 91 56 40 	lds	r16, 0x4056
    3eda:	10 91 57 40 	lds	r17, 0x4057

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    3ede:	c7 01       	movw	r24, r14
    3ee0:	b6 01       	movw	r22, r12
    3ee2:	49 e4       	ldi	r20, 0x49	; 73
    3ee4:	5e e3       	ldi	r21, 0x3E	; 62
    3ee6:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3eea:	98 01       	movw	r18, r16
    3eec:	40 e0       	ldi	r20, 0x00	; 0
    3eee:	50 e0       	ldi	r21, 0x00	; 0
    3ef0:	c3 01       	movw	r24, r6
    3ef2:	b2 01       	movw	r22, r4
    3ef4:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    3ef8:	67 5b       	subi	r22, 0xB7	; 183
    3efa:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    3efc:	33 20       	and	r3, r3
    3efe:	41 f4       	brne	.+16     	; 0x3f10 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    3f00:	db 01       	movw	r26, r22
    3f02:	0d 91       	ld	r16, X+
    3f04:	1d 91       	ld	r17, X+
    3f06:	2d 91       	ld	r18, X+
    3f08:	3c 91       	ld	r19, X
    3f0a:	13 97       	sbiw	r26, 0x03	; 3
    3f0c:	3f 70       	andi	r19, 0x0F	; 15
    3f0e:	14 c0       	rjmp	.+40     	; 0x3f38 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    3f10:	89 81       	ldd	r24, Y+1	; 0x01
    3f12:	9a 81       	ldd	r25, Y+2	; 0x02
    3f14:	ab 81       	ldd	r26, Y+3	; 0x03
    3f16:	bc 81       	ldd	r27, Y+4	; 0x04
    3f18:	fb 01       	movw	r30, r22
    3f1a:	80 83       	st	Z, r24
    3f1c:	91 83       	std	Z+1, r25	; 0x01
    3f1e:	a2 83       	std	Z+2, r26	; 0x02
    3f20:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    3f22:	c7 01       	movw	r24, r14
    3f24:	b6 01       	movw	r22, r12
    3f26:	49 e4       	ldi	r20, 0x49	; 73
    3f28:	5e e3       	ldi	r21, 0x3E	; 62
    3f2a:	20 e0       	ldi	r18, 0x00	; 0
    3f2c:	32 e0       	ldi	r19, 0x02	; 2
    3f2e:	0e 94 4d 29 	call	0x529a	; 0x529a <SD_write_block>

return (0);
    3f32:	00 e0       	ldi	r16, 0x00	; 0
    3f34:	10 e0       	ldi	r17, 0x00	; 0
    3f36:	98 01       	movw	r18, r16
}
    3f38:	60 2f       	mov	r22, r16
    3f3a:	71 2f       	mov	r23, r17
    3f3c:	82 2f       	mov	r24, r18
    3f3e:	93 2f       	mov	r25, r19
    3f40:	24 96       	adiw	r28, 0x04	; 4
    3f42:	cd bf       	out	0x3d, r28	; 61
    3f44:	de bf       	out	0x3e, r29	; 62
    3f46:	df 91       	pop	r29
    3f48:	cf 91       	pop	r28
    3f4a:	1f 91       	pop	r17
    3f4c:	0f 91       	pop	r16
    3f4e:	ff 90       	pop	r15
    3f50:	ef 90       	pop	r14
    3f52:	df 90       	pop	r13
    3f54:	cf 90       	pop	r12
    3f56:	bf 90       	pop	r11
    3f58:	af 90       	pop	r10
    3f5a:	9f 90       	pop	r9
    3f5c:	8f 90       	pop	r8
    3f5e:	7f 90       	pop	r7
    3f60:	6f 90       	pop	r6
    3f62:	5f 90       	pop	r5
    3f64:	4f 90       	pop	r4
    3f66:	3f 90       	pop	r3
    3f68:	08 95       	ret

00003f6a <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    3f6a:	cf 92       	push	r12
    3f6c:	df 92       	push	r13
    3f6e:	ef 92       	push	r14
    3f70:	ff 92       	push	r15
    3f72:	0f 93       	push	r16
    3f74:	1f 93       	push	r17
    3f76:	cf 93       	push	r28
    3f78:	c8 2f       	mov	r28, r24
    3f7a:	06 2f       	mov	r16, r22
    3f7c:	69 01       	movw	r12, r18
    3f7e:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    3f80:	80 91 6c 50 	lds	r24, 0x506C
    3f84:	90 91 6d 50 	lds	r25, 0x506D
    3f88:	a0 91 6e 50 	lds	r26, 0x506E
    3f8c:	b0 91 6f 50 	lds	r27, 0x506F
    3f90:	bc 01       	movw	r22, r24
    3f92:	cd 01       	movw	r24, r26
    3f94:	6f 5f       	subi	r22, 0xFF	; 255
    3f96:	7f 4f       	sbci	r23, 0xFF	; 255
    3f98:	8f 4f       	sbci	r24, 0xFF	; 255
    3f9a:	9f 4f       	sbci	r25, 0xFF	; 255
    3f9c:	49 e4       	ldi	r20, 0x49	; 73
    3f9e:	5e e3       	ldi	r21, 0x3E	; 62
    3fa0:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    3fa4:	80 91 49 3e 	lds	r24, 0x3E49
    3fa8:	90 91 4a 3e 	lds	r25, 0x3E4A
    3fac:	a0 91 4b 3e 	lds	r26, 0x3E4B
    3fb0:	b0 91 4c 3e 	lds	r27, 0x3E4C
    3fb4:	82 35       	cpi	r24, 0x52	; 82
    3fb6:	22 e5       	ldi	r18, 0x52	; 82
    3fb8:	92 07       	cpc	r25, r18
    3fba:	21 e6       	ldi	r18, 0x61	; 97
    3fbc:	a2 07       	cpc	r26, r18
    3fbe:	21 e4       	ldi	r18, 0x41	; 65
    3fc0:	b2 07       	cpc	r27, r18
    3fc2:	09 f0       	breq	.+2      	; 0x3fc6 <getSetFreeCluster+0x5c>
    3fc4:	63 c0       	rjmp	.+198    	; 0x408c <getSetFreeCluster+0x122>
    3fc6:	80 91 2d 40 	lds	r24, 0x402D
    3fca:	90 91 2e 40 	lds	r25, 0x402E
    3fce:	a0 91 2f 40 	lds	r26, 0x402F
    3fd2:	b0 91 30 40 	lds	r27, 0x4030
    3fd6:	82 37       	cpi	r24, 0x72	; 114
    3fd8:	22 e7       	ldi	r18, 0x72	; 114
    3fda:	92 07       	cpc	r25, r18
    3fdc:	21 e4       	ldi	r18, 0x41	; 65
    3fde:	a2 07       	cpc	r26, r18
    3fe0:	21 e6       	ldi	r18, 0x61	; 97
    3fe2:	b2 07       	cpc	r27, r18
    3fe4:	09 f0       	breq	.+2      	; 0x3fe8 <getSetFreeCluster+0x7e>
    3fe6:	56 c0       	rjmp	.+172    	; 0x4094 <getSetFreeCluster+0x12a>
    3fe8:	80 91 45 40 	lds	r24, 0x4045
    3fec:	90 91 46 40 	lds	r25, 0x4046
    3ff0:	a0 91 47 40 	lds	r26, 0x4047
    3ff4:	b0 91 48 40 	lds	r27, 0x4048
    3ff8:	80 30       	cpi	r24, 0x00	; 0
    3ffa:	20 e0       	ldi	r18, 0x00	; 0
    3ffc:	92 07       	cpc	r25, r18
    3ffe:	25 e5       	ldi	r18, 0x55	; 85
    4000:	a2 07       	cpc	r26, r18
    4002:	2a ea       	ldi	r18, 0xAA	; 170
    4004:	b2 07       	cpc	r27, r18
    4006:	09 f0       	breq	.+2      	; 0x400a <getSetFreeCluster+0xa0>
    4008:	49 c0       	rjmp	.+146    	; 0x409c <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    400a:	00 23       	and	r16, r16
    400c:	a1 f4       	brne	.+40     	; 0x4036 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    400e:	c1 30       	cpi	r28, 0x01	; 1
    4010:	49 f4       	brne	.+18     	; 0x4024 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    4012:	00 91 31 40 	lds	r16, 0x4031
    4016:	10 91 32 40 	lds	r17, 0x4032
    401a:	20 91 33 40 	lds	r18, 0x4033
    401e:	30 91 34 40 	lds	r19, 0x4034
    4022:	3f c0       	rjmp	.+126    	; 0x40a2 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    4024:	00 91 35 40 	lds	r16, 0x4035
    4028:	10 91 36 40 	lds	r17, 0x4036
    402c:	20 91 37 40 	lds	r18, 0x4037
    4030:	30 91 38 40 	lds	r19, 0x4038
    4034:	36 c0       	rjmp	.+108    	; 0x40a2 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4036:	c1 30       	cpi	r28, 0x01	; 1
    4038:	49 f4       	brne	.+18     	; 0x404c <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    403a:	c0 92 31 40 	sts	0x4031, r12
    403e:	d0 92 32 40 	sts	0x4032, r13
    4042:	e0 92 33 40 	sts	0x4033, r14
    4046:	f0 92 34 40 	sts	0x4034, r15
    404a:	08 c0       	rjmp	.+16     	; 0x405c <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    404c:	c0 92 35 40 	sts	0x4035, r12
    4050:	d0 92 36 40 	sts	0x4036, r13
    4054:	e0 92 37 40 	sts	0x4037, r14
    4058:	f0 92 38 40 	sts	0x4038, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    405c:	80 91 6c 50 	lds	r24, 0x506C
    4060:	90 91 6d 50 	lds	r25, 0x506D
    4064:	a0 91 6e 50 	lds	r26, 0x506E
    4068:	b0 91 6f 50 	lds	r27, 0x506F
    406c:	bc 01       	movw	r22, r24
    406e:	cd 01       	movw	r24, r26
    4070:	6f 5f       	subi	r22, 0xFF	; 255
    4072:	7f 4f       	sbci	r23, 0xFF	; 255
    4074:	8f 4f       	sbci	r24, 0xFF	; 255
    4076:	9f 4f       	sbci	r25, 0xFF	; 255
    4078:	49 e4       	ldi	r20, 0x49	; 73
    407a:	5e e3       	ldi	r21, 0x3E	; 62
    407c:	20 e0       	ldi	r18, 0x00	; 0
    407e:	32 e0       	ldi	r19, 0x02	; 2
    4080:	0e 94 4d 29 	call	0x529a	; 0x529a <SD_write_block>
 }
 return 0xffffffff;
    4084:	0f ef       	ldi	r16, 0xFF	; 255
    4086:	1f ef       	ldi	r17, 0xFF	; 255
    4088:	98 01       	movw	r18, r16
    408a:	0b c0       	rjmp	.+22     	; 0x40a2 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    408c:	0f ef       	ldi	r16, 0xFF	; 255
    408e:	1f ef       	ldi	r17, 0xFF	; 255
    4090:	98 01       	movw	r18, r16
    4092:	07 c0       	rjmp	.+14     	; 0x40a2 <getSetFreeCluster+0x138>
    4094:	0f ef       	ldi	r16, 0xFF	; 255
    4096:	1f ef       	ldi	r17, 0xFF	; 255
    4098:	98 01       	movw	r18, r16
    409a:	03 c0       	rjmp	.+6      	; 0x40a2 <getSetFreeCluster+0x138>
    409c:	0f ef       	ldi	r16, 0xFF	; 255
    409e:	1f ef       	ldi	r17, 0xFF	; 255
    40a0:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    40a2:	60 2f       	mov	r22, r16
    40a4:	71 2f       	mov	r23, r17
    40a6:	82 2f       	mov	r24, r18
    40a8:	93 2f       	mov	r25, r19
    40aa:	cf 91       	pop	r28
    40ac:	1f 91       	pop	r17
    40ae:	0f 91       	pop	r16
    40b0:	ff 90       	pop	r15
    40b2:	ef 90       	pop	r14
    40b4:	df 90       	pop	r13
    40b6:	cf 90       	pop	r12
    40b8:	08 95       	ret

000040ba <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    40ba:	ef 92       	push	r14
    40bc:	ff 92       	push	r15
    40be:	0f 93       	push	r16
    40c0:	1f 93       	push	r17
    40c2:	cf 93       	push	r28
    40c4:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    40c6:	10 92 6c 50 	sts	0x506C, r1
    40ca:	10 92 6d 50 	sts	0x506D, r1
    40ce:	10 92 6e 50 	sts	0x506E, r1
    40d2:	10 92 6f 50 	sts	0x506F, r1

SD_read_block(0,SDBuffer);
    40d6:	60 e0       	ldi	r22, 0x00	; 0
    40d8:	70 e0       	ldi	r23, 0x00	; 0
    40da:	cb 01       	movw	r24, r22
    40dc:	49 e4       	ldi	r20, 0x49	; 73
    40de:	5e e3       	ldi	r21, 0x3E	; 62
    40e0:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    40e4:	80 91 49 3e 	lds	r24, 0x3E49
    40e8:	89 3e       	cpi	r24, 0xE9	; 233
    40ea:	31 f1       	breq	.+76     	; 0x4138 <getBootSectorData+0x7e>
    40ec:	8b 3e       	cpi	r24, 0xEB	; 235
    40ee:	21 f1       	breq	.+72     	; 0x4138 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    40f0:	80 91 47 40 	lds	r24, 0x4047
    40f4:	90 91 48 40 	lds	r25, 0x4048
    40f8:	2a ea       	ldi	r18, 0xAA	; 170
    40fa:	85 35       	cpi	r24, 0x55	; 85
    40fc:	92 07       	cpc	r25, r18
    40fe:	09 f0       	breq	.+2      	; 0x4102 <getBootSectorData+0x48>
    4100:	b7 c0       	rjmp	.+366    	; 0x4270 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    4102:	60 91 0f 40 	lds	r22, 0x400F
    4106:	70 91 10 40 	lds	r23, 0x4010
    410a:	80 91 11 40 	lds	r24, 0x4011
    410e:	90 91 12 40 	lds	r25, 0x4012
    4112:	60 93 6c 50 	sts	0x506C, r22
    4116:	70 93 6d 50 	sts	0x506D, r23
    411a:	80 93 6e 50 	sts	0x506E, r24
    411e:	90 93 6f 50 	sts	0x506F, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    4122:	49 e4       	ldi	r20, 0x49	; 73
    4124:	5e e3       	ldi	r21, 0x3E	; 62
    4126:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    412a:	80 91 49 3e 	lds	r24, 0x3E49
    412e:	89 3e       	cpi	r24, 0xE9	; 233
    4130:	19 f0       	breq	.+6      	; 0x4138 <getBootSectorData+0x7e>
    4132:	8b 3e       	cpi	r24, 0xEB	; 235
    4134:	09 f0       	breq	.+2      	; 0x4138 <getBootSectorData+0x7e>
    4136:	9e c0       	rjmp	.+316    	; 0x4274 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4138:	80 91 54 3e 	lds	r24, 0x3E54
    413c:	90 91 55 3e 	lds	r25, 0x3E55
    4140:	80 93 56 40 	sts	0x4056, r24
    4144:	90 93 57 40 	sts	0x4057, r25
sectorPerCluster = bpb->sectorPerCluster;
    4148:	80 91 56 3e 	lds	r24, 0x3E56
    414c:	90 e0       	ldi	r25, 0x00	; 0
    414e:	80 93 6a 50 	sts	0x506A, r24
    4152:	90 93 6b 50 	sts	0x506B, r25
reservedSectorCount = bpb->reservedSectorCount;
    4156:	e0 90 57 3e 	lds	r14, 0x3E57
    415a:	f0 90 58 3e 	lds	r15, 0x3E58
    415e:	e0 92 70 50 	sts	0x5070, r14
    4162:	f0 92 71 50 	sts	0x5071, r15
rootCluster = bpb->rootCluster;
    4166:	80 91 75 3e 	lds	r24, 0x3E75
    416a:	90 91 76 3e 	lds	r25, 0x3E76
    416e:	a0 91 77 3e 	lds	r26, 0x3E77
    4172:	b0 91 78 3e 	lds	r27, 0x3E78
    4176:	80 93 5e 40 	sts	0x405E, r24
    417a:	90 93 5f 40 	sts	0x405F, r25
    417e:	a0 93 60 40 	sts	0x4060, r26
    4182:	b0 93 61 40 	sts	0x4061, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    4186:	c0 91 70 50 	lds	r28, 0x5070
    418a:	d0 91 71 50 	lds	r29, 0x5071
    418e:	60 91 59 3e 	lds	r22, 0x3E59
    4192:	70 e0       	ldi	r23, 0x00	; 0
    4194:	80 e0       	ldi	r24, 0x00	; 0
    4196:	90 e0       	ldi	r25, 0x00	; 0
    4198:	20 91 6d 3e 	lds	r18, 0x3E6D
    419c:	30 91 6e 3e 	lds	r19, 0x3E6E
    41a0:	40 91 6f 3e 	lds	r20, 0x3E6F
    41a4:	50 91 70 3e 	lds	r21, 0x3E70
    41a8:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    41ac:	8b 01       	movw	r16, r22
    41ae:	9c 01       	movw	r18, r24
    41b0:	ae 01       	movw	r20, r28
    41b2:	60 e0       	ldi	r22, 0x00	; 0
    41b4:	70 e0       	ldi	r23, 0x00	; 0
    41b6:	80 91 65 3e 	lds	r24, 0x3E65
    41ba:	90 91 66 3e 	lds	r25, 0x3E66
    41be:	a0 91 67 3e 	lds	r26, 0x3E67
    41c2:	b0 91 68 3e 	lds	r27, 0x3E68
    41c6:	84 0f       	add	r24, r20
    41c8:	95 1f       	adc	r25, r21
    41ca:	a6 1f       	adc	r26, r22
    41cc:	b7 1f       	adc	r27, r23
    41ce:	80 0f       	add	r24, r16
    41d0:	91 1f       	adc	r25, r17
    41d2:	a2 1f       	adc	r26, r18
    41d4:	b3 1f       	adc	r27, r19
    41d6:	80 93 4e 40 	sts	0x404E, r24
    41da:	90 93 4f 40 	sts	0x404F, r25
    41de:	a0 93 50 40 	sts	0x4050, r26
    41e2:	b0 93 51 40 	sts	0x4051, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    41e6:	e0 91 6a 50 	lds	r30, 0x506A
    41ea:	f0 91 6b 50 	lds	r31, 0x506B
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    41ee:	c7 01       	movw	r24, r14
    41f0:	a0 e0       	ldi	r26, 0x00	; 0
    41f2:	b0 e0       	ldi	r27, 0x00	; 0
    41f4:	40 91 69 3e 	lds	r20, 0x3E69
    41f8:	50 91 6a 3e 	lds	r21, 0x3E6A
    41fc:	60 91 6b 3e 	lds	r22, 0x3E6B
    4200:	70 91 6c 3e 	lds	r23, 0x3E6C
    4204:	48 1b       	sub	r20, r24
    4206:	59 0b       	sbc	r21, r25
    4208:	6a 0b       	sbc	r22, r26
    420a:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    420c:	cb 01       	movw	r24, r22
    420e:	ba 01       	movw	r22, r20
    4210:	60 1b       	sub	r22, r16
    4212:	71 0b       	sbc	r23, r17
    4214:	82 0b       	sbc	r24, r18
    4216:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4218:	9f 01       	movw	r18, r30
    421a:	40 e0       	ldi	r20, 0x00	; 0
    421c:	50 e0       	ldi	r21, 0x00	; 0
    421e:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    4222:	20 93 59 40 	sts	0x4059, r18
    4226:	30 93 5a 40 	sts	0x405A, r19
    422a:	40 93 5b 40 	sts	0x405B, r20
    422e:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    4232:	81 e0       	ldi	r24, 0x01	; 1
    4234:	60 e0       	ldi	r22, 0x00	; 0
    4236:	20 e0       	ldi	r18, 0x00	; 0
    4238:	30 e0       	ldi	r19, 0x00	; 0
    423a:	a9 01       	movw	r20, r18
    423c:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <getSetFreeCluster>
    4240:	ab 01       	movw	r20, r22
    4242:	bc 01       	movw	r22, r24
    4244:	80 91 59 40 	lds	r24, 0x4059
    4248:	90 91 5a 40 	lds	r25, 0x405A
    424c:	a0 91 5b 40 	lds	r26, 0x405B
    4250:	b0 91 5c 40 	lds	r27, 0x405C
    4254:	84 17       	cp	r24, r20
    4256:	95 07       	cpc	r25, r21
    4258:	a6 07       	cpc	r26, r22
    425a:	b7 07       	cpc	r27, r23
    425c:	20 f4       	brcc	.+8      	; 0x4266 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    425e:	10 92 a2 50 	sts	0x50A2, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4262:	80 e0       	ldi	r24, 0x00	; 0
    4264:	08 c0       	rjmp	.+16     	; 0x4276 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4266:	81 e0       	ldi	r24, 0x01	; 1
    4268:	80 93 a2 50 	sts	0x50A2, r24
return 0;
    426c:	80 e0       	ldi	r24, 0x00	; 0
    426e:	03 c0       	rjmp	.+6      	; 0x4276 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4270:	81 e0       	ldi	r24, 0x01	; 1
    4272:	01 c0       	rjmp	.+2      	; 0x4276 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4274:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4276:	df 91       	pop	r29
    4278:	cf 91       	pop	r28
    427a:	1f 91       	pop	r17
    427c:	0f 91       	pop	r16
    427e:	ff 90       	pop	r15
    4280:	ef 90       	pop	r14
    4282:	08 95       	ret

00004284 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4284:	0f 93       	push	r16
    4286:	1f 93       	push	r17
    4288:	cf 93       	push	r28
    428a:	df 93       	push	r29
    428c:	cd b7       	in	r28, 0x3d	; 61
    428e:	de b7       	in	r29, 0x3e	; 62
    4290:	2b 97       	sbiw	r28, 0x0b	; 11
    4292:	cd bf       	out	0x3d, r28	; 61
    4294:	de bf       	out	0x3e, r29	; 62
    4296:	78 2f       	mov	r23, r24
    4298:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    429a:	e8 2f       	mov	r30, r24
    429c:	f9 2f       	mov	r31, r25
    429e:	df 01       	movw	r26, r30
    42a0:	0d 90       	ld	r0, X+
    42a2:	00 20       	and	r0, r0
    42a4:	e9 f7       	brne	.-6      	; 0x42a0 <convertFileName+0x1c>
    42a6:	11 97       	sbiw	r26, 0x01	; 1
    42a8:	ae 1b       	sub	r26, r30
    42aa:	bf 0b       	sbc	r27, r31
    42ac:	a0 31       	cpi	r26, 0x10	; 16
    42ae:	b1 05       	cpc	r27, r1
    42b0:	08 f0       	brcs	.+2      	; 0x42b4 <convertFileName+0x30>
    42b2:	9c c0       	rjmp	.+312    	; 0x43ec <convertFileName+0x168>
    42b4:	28 2f       	mov	r18, r24
    42b6:	39 2f       	mov	r19, r25
    42b8:	02 e9       	ldi	r16, 0x92	; 146
    42ba:	10 e5       	ldi	r17, 0x50	; 80
    42bc:	a8 01       	movw	r20, r16
    42be:	80 e0       	ldi	r24, 0x00	; 0
    42c0:	90 e0       	ldi	r25, 0x00	; 0
    42c2:	07 c0       	rjmp	.+14     	; 0x42d2 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    42c4:	d9 01       	movw	r26, r18
    42c6:	ed 91       	ld	r30, X+
    42c8:	9d 01       	movw	r18, r26
    42ca:	da 01       	movw	r26, r20
    42cc:	ed 93       	st	X+, r30
    42ce:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    42d0:	01 96       	adiw	r24, 0x01	; 1
    42d2:	a7 2f       	mov	r26, r23
    42d4:	b6 2f       	mov	r27, r22
    42d6:	fd 01       	movw	r30, r26
    42d8:	01 90       	ld	r0, Z+
    42da:	00 20       	and	r0, r0
    42dc:	e9 f7       	brne	.-6      	; 0x42d8 <convertFileName+0x54>
    42de:	31 97       	sbiw	r30, 0x01	; 1
    42e0:	ea 1b       	sub	r30, r26
    42e2:	fb 0b       	sbc	r31, r27
    42e4:	8e 17       	cp	r24, r30
    42e6:	9f 07       	cpc	r25, r31
    42e8:	68 f3       	brcs	.-38     	; 0x42c4 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    42ea:	8f 30       	cpi	r24, 0x0F	; 15
    42ec:	91 05       	cpc	r25, r1
    42ee:	54 f4       	brge	.+20     	; 0x4304 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    42f0:	fc 01       	movw	r30, r24
    42f2:	ee 56       	subi	r30, 0x6E	; 110
    42f4:	ff 4a       	sbci	r31, 0xAF	; 175
    42f6:	81 ea       	ldi	r24, 0xA1	; 161
    42f8:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    42fa:	20 e2       	ldi	r18, 0x20	; 32
    42fc:	21 93       	st	Z+, r18
    42fe:	e8 17       	cp	r30, r24
    4300:	f9 07       	cpc	r31, r25
    4302:	e1 f7       	brne	.-8      	; 0x42fc <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4304:	80 91 92 50 	lds	r24, 0x5092
    4308:	8e 32       	cpi	r24, 0x2E	; 46
    430a:	91 f0       	breq	.+36     	; 0x4330 <convertFileName+0xac>
    430c:	e3 e9       	ldi	r30, 0x93	; 147
    430e:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4310:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    4312:	81 91       	ld	r24, Z+
    4314:	8e 32       	cpi	r24, 0x2E	; 46
    4316:	21 f0       	breq	.+8      	; 0x4320 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4318:	2f 5f       	subi	r18, 0xFF	; 255
    431a:	2c 30       	cpi	r18, 0x0C	; 12
    431c:	d1 f7       	brne	.-12     	; 0x4312 <convertFileName+0x8e>
    431e:	05 c0       	rjmp	.+10     	; 0x432a <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    4320:	82 2f       	mov	r24, r18
    4322:	89 50       	subi	r24, 0x09	; 9
    4324:	83 30       	cpi	r24, 0x03	; 3
    4326:	08 f4       	brcc	.+2      	; 0x432a <convertFileName+0xa6>
    4328:	63 c0       	rjmp	.+198    	; 0x43f0 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    432a:	22 23       	and	r18, r18
    432c:	29 f4       	brne	.+10     	; 0x4338 <convertFileName+0xb4>
    432e:	01 c0       	rjmp	.+2      	; 0x4332 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4330:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4332:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    4334:	90 e2       	ldi	r25, 0x20	; 32
    4336:	10 c0       	rjmp	.+32     	; 0x4358 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4338:	de 01       	movw	r26, r28
    433a:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    433c:	82 2f       	mov	r24, r18
    433e:	81 50       	subi	r24, 0x01	; 1
    4340:	90 e0       	ldi	r25, 0x00	; 0
    4342:	8d 56       	subi	r24, 0x6D	; 109
    4344:	9f 4a       	sbci	r25, 0xAF	; 175
    4346:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    4348:	31 91       	ld	r19, Z+
    434a:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    434c:	e8 17       	cp	r30, r24
    434e:	f9 07       	cpc	r31, r25
    4350:	d9 f7       	brne	.-10     	; 0x4348 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4352:	28 30       	cpi	r18, 0x08	; 8
    4354:	70 f3       	brcs	.-36     	; 0x4332 <convertFileName+0xae>
    4356:	0a c0       	rjmp	.+20     	; 0x436c <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    4358:	e1 e0       	ldi	r30, 0x01	; 1
    435a:	f0 e0       	ldi	r31, 0x00	; 0
    435c:	ec 0f       	add	r30, r28
    435e:	fd 1f       	adc	r31, r29
    4360:	e8 0f       	add	r30, r24
    4362:	f1 1d       	adc	r31, r1
    4364:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4366:	8f 5f       	subi	r24, 0xFF	; 255
    4368:	88 30       	cpi	r24, 0x08	; 8
    436a:	b0 f3       	brcs	.-20     	; 0x4358 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    436c:	2c 30       	cpi	r18, 0x0C	; 12
    436e:	09 f0       	breq	.+2      	; 0x4372 <convertFileName+0xee>
    4370:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4372:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4374:	82 e9       	ldi	r24, 0x92	; 146
    4376:	90 e5       	ldi	r25, 0x50	; 80
    4378:	fc 01       	movw	r30, r24
    437a:	e2 0f       	add	r30, r18
    437c:	f1 1d       	adc	r31, r1
    437e:	40 81       	ld	r20, Z
    4380:	44 23       	and	r20, r20
    4382:	19 f4       	brne	.+6      	; 0x438a <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4384:	3b 30       	cpi	r19, 0x0B	; 11
    4386:	50 f0       	brcs	.+20     	; 0x439c <convertFileName+0x118>
    4388:	15 c0       	rjmp	.+42     	; 0x43b4 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    438a:	e1 e0       	ldi	r30, 0x01	; 1
    438c:	f0 e0       	ldi	r31, 0x00	; 0
    438e:	ec 0f       	add	r30, r28
    4390:	fd 1f       	adc	r31, r29
    4392:	e3 0f       	add	r30, r19
    4394:	f1 1d       	adc	r31, r1
    4396:	40 83       	st	Z, r20
    4398:	2f 5f       	subi	r18, 0xFF	; 255
    439a:	0c c0       	rjmp	.+24     	; 0x43b4 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    439c:	80 e2       	ldi	r24, 0x20	; 32
    439e:	e1 e0       	ldi	r30, 0x01	; 1
    43a0:	f0 e0       	ldi	r31, 0x00	; 0
    43a2:	ec 0f       	add	r30, r28
    43a4:	fd 1f       	adc	r31, r29
    43a6:	e3 0f       	add	r30, r19
    43a8:	f1 1d       	adc	r31, r1
    43aa:	80 83       	st	Z, r24
    43ac:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    43ae:	3b 30       	cpi	r19, 0x0B	; 11
    43b0:	b1 f7       	brne	.-20     	; 0x439e <convertFileName+0x11a>
    43b2:	03 c0       	rjmp	.+6      	; 0x43ba <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    43b4:	3f 5f       	subi	r19, 0xFF	; 255
    43b6:	3b 30       	cpi	r19, 0x0B	; 11
    43b8:	f8 f2       	brcs	.-66     	; 0x4378 <convertFileName+0xf4>
    43ba:	de 01       	movw	r26, r28
    43bc:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    43be:	ce 01       	movw	r24, r28
    43c0:	0c 96       	adiw	r24, 0x0c	; 12
    43c2:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    43c4:	20 81       	ld	r18, Z
    43c6:	32 2f       	mov	r19, r18
    43c8:	31 56       	subi	r19, 0x61	; 97
    43ca:	3a 31       	cpi	r19, 0x1A	; 26
    43cc:	10 f4       	brcc	.+4      	; 0x43d2 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    43ce:	20 52       	subi	r18, 0x20	; 32
    43d0:	20 83       	st	Z, r18
    43d2:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    43d4:	e8 17       	cp	r30, r24
    43d6:	f9 07       	cpc	r31, r25
    43d8:	a9 f7       	brne	.-22     	; 0x43c4 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    43da:	2d 91       	ld	r18, X+
    43dc:	f8 01       	movw	r30, r16
    43de:	21 93       	st	Z+, r18
    43e0:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    43e2:	a8 17       	cp	r26, r24
    43e4:	b9 07       	cpc	r27, r25
    43e6:	c9 f7       	brne	.-14     	; 0x43da <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    43e8:	80 e0       	ldi	r24, 0x00	; 0
    43ea:	03 c0       	rjmp	.+6      	; 0x43f2 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    43ec:	81 e0       	ldi	r24, 0x01	; 1
    43ee:	01 c0       	rjmp	.+2      	; 0x43f2 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    43f0:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    43f2:	2b 96       	adiw	r28, 0x0b	; 11
    43f4:	cd bf       	out	0x3d, r28	; 61
    43f6:	de bf       	out	0x3e, r29	; 62
    43f8:	df 91       	pop	r29
    43fa:	cf 91       	pop	r28
    43fc:	1f 91       	pop	r17
    43fe:	0f 91       	pop	r16
    4400:	08 95       	ret

00004402 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4402:	4f 92       	push	r4
    4404:	5f 92       	push	r5
    4406:	6f 92       	push	r6
    4408:	7f 92       	push	r7
    440a:	8f 92       	push	r8
    440c:	9f 92       	push	r9
    440e:	af 92       	push	r10
    4410:	bf 92       	push	r11
    4412:	cf 92       	push	r12
    4414:	df 92       	push	r13
    4416:	ef 92       	push	r14
    4418:	ff 92       	push	r15
    441a:	cf 93       	push	r28
    441c:	df 93       	push	r29
    441e:	2b 01       	movw	r4, r22
    4420:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4422:	20 e8       	ldi	r18, 0x80	; 128
    4424:	3f ef       	ldi	r19, 0xFF	; 255
    4426:	4f ef       	ldi	r20, 0xFF	; 255
    4428:	5f ef       	ldi	r21, 0xFF	; 255
    442a:	42 22       	and	r4, r18
    442c:	53 22       	and	r5, r19
    442e:	64 22       	and	r6, r20
    4430:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4432:	80 91 59 40 	lds	r24, 0x4059
    4436:	90 91 5a 40 	lds	r25, 0x405A
    443a:	a0 91 5b 40 	lds	r26, 0x405B
    443e:	b0 91 5c 40 	lds	r27, 0x405C
    4442:	48 16       	cp	r4, r24
    4444:	59 06       	cpc	r5, r25
    4446:	6a 06       	cpc	r6, r26
    4448:	7b 06       	cpc	r7, r27
    444a:	08 f0       	brcs	.+2      	; 0x444e <searchNextFreeCluster+0x4c>
    444c:	77 c0       	rjmp	.+238    	; 0x453c <searchNextFreeCluster+0x13a>
    444e:	53 01       	movw	r10, r6
    4450:	42 01       	movw	r8, r4
    4452:	88 0c       	add	r8, r8
    4454:	99 1c       	adc	r9, r9
    4456:	aa 1c       	adc	r10, r10
    4458:	bb 1c       	adc	r11, r11
    445a:	88 0c       	add	r8, r8
    445c:	99 1c       	adc	r9, r9
    445e:	aa 1c       	adc	r10, r10
    4460:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4462:	c9 e4       	ldi	r28, 0x49	; 73
    4464:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4466:	c0 90 70 50 	lds	r12, 0x5070
    446a:	d0 90 71 50 	lds	r13, 0x5071
    446e:	20 91 56 40 	lds	r18, 0x4056
    4472:	30 91 57 40 	lds	r19, 0x4057
    4476:	ee 24       	eor	r14, r14
    4478:	ff 24       	eor	r15, r15
    447a:	80 91 6c 50 	lds	r24, 0x506C
    447e:	90 91 6d 50 	lds	r25, 0x506D
    4482:	a0 91 6e 50 	lds	r26, 0x506E
    4486:	b0 91 6f 50 	lds	r27, 0x506F
    448a:	c8 0e       	add	r12, r24
    448c:	d9 1e       	adc	r13, r25
    448e:	ea 1e       	adc	r14, r26
    4490:	fb 1e       	adc	r15, r27
    4492:	40 e0       	ldi	r20, 0x00	; 0
    4494:	50 e0       	ldi	r21, 0x00	; 0
    4496:	c5 01       	movw	r24, r10
    4498:	b4 01       	movw	r22, r8
    449a:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    449e:	c7 01       	movw	r24, r14
    44a0:	b6 01       	movw	r22, r12
    44a2:	62 0f       	add	r22, r18
    44a4:	73 1f       	adc	r23, r19
    44a6:	84 1f       	adc	r24, r20
    44a8:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    44aa:	ae 01       	movw	r20, r28
    44ac:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    44b0:	88 81       	ld	r24, Y
    44b2:	99 81       	ldd	r25, Y+1	; 0x01
    44b4:	aa 81       	ldd	r26, Y+2	; 0x02
    44b6:	bb 81       	ldd	r27, Y+3	; 0x03
    44b8:	bf 70       	andi	r27, 0x0F	; 15
    44ba:	00 97       	sbiw	r24, 0x00	; 0
    44bc:	a1 05       	cpc	r26, r1
    44be:	b1 05       	cpc	r27, r1
    44c0:	99 f0       	breq	.+38     	; 0x44e8 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    44c2:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    44c4:	e2 2f       	mov	r30, r18
    44c6:	f0 e0       	ldi	r31, 0x00	; 0
    44c8:	ee 0f       	add	r30, r30
    44ca:	ff 1f       	adc	r31, r31
    44cc:	ee 0f       	add	r30, r30
    44ce:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    44d0:	e7 5b       	subi	r30, 0xB7	; 183
    44d2:	f1 4c       	sbci	r31, 0xC1	; 193
    44d4:	80 81       	ld	r24, Z
    44d6:	91 81       	ldd	r25, Z+1	; 0x01
    44d8:	a2 81       	ldd	r26, Z+2	; 0x02
    44da:	b3 81       	ldd	r27, Z+3	; 0x03
    44dc:	bf 70       	andi	r27, 0x0F	; 15
    44de:	00 97       	sbiw	r24, 0x00	; 0
    44e0:	a1 05       	cpc	r26, r1
    44e2:	b1 05       	cpc	r27, r1
    44e4:	39 f4       	brne	.+14     	; 0x44f4 <searchNextFreeCluster+0xf2>
    44e6:	01 c0       	rjmp	.+2      	; 0x44ea <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    44e8:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    44ea:	42 0e       	add	r4, r18
    44ec:	51 1c       	adc	r5, r1
    44ee:	61 1c       	adc	r6, r1
    44f0:	71 1c       	adc	r7, r1
    44f2:	27 c0       	rjmp	.+78     	; 0x4542 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    44f4:	2f 5f       	subi	r18, 0xFF	; 255
    44f6:	32 f7       	brpl	.-52     	; 0x44c4 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    44f8:	80 e8       	ldi	r24, 0x80	; 128
    44fa:	90 e0       	ldi	r25, 0x00	; 0
    44fc:	a0 e0       	ldi	r26, 0x00	; 0
    44fe:	b0 e0       	ldi	r27, 0x00	; 0
    4500:	48 0e       	add	r4, r24
    4502:	59 1e       	adc	r5, r25
    4504:	6a 1e       	adc	r6, r26
    4506:	7b 1e       	adc	r7, r27
    4508:	80 91 59 40 	lds	r24, 0x4059
    450c:	90 91 5a 40 	lds	r25, 0x405A
    4510:	a0 91 5b 40 	lds	r26, 0x405B
    4514:	b0 91 5c 40 	lds	r27, 0x405C
    4518:	20 e0       	ldi	r18, 0x00	; 0
    451a:	32 e0       	ldi	r19, 0x02	; 2
    451c:	40 e0       	ldi	r20, 0x00	; 0
    451e:	50 e0       	ldi	r21, 0x00	; 0
    4520:	82 0e       	add	r8, r18
    4522:	93 1e       	adc	r9, r19
    4524:	a4 1e       	adc	r10, r20
    4526:	b5 1e       	adc	r11, r21
    4528:	48 16       	cp	r4, r24
    452a:	59 06       	cpc	r5, r25
    452c:	6a 06       	cpc	r6, r26
    452e:	7b 06       	cpc	r7, r27
    4530:	08 f4       	brcc	.+2      	; 0x4534 <searchNextFreeCluster+0x132>
    4532:	99 cf       	rjmp	.-206    	; 0x4466 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4534:	44 24       	eor	r4, r4
    4536:	55 24       	eor	r5, r5
    4538:	32 01       	movw	r6, r4
    453a:	03 c0       	rjmp	.+6      	; 0x4542 <searchNextFreeCluster+0x140>
    453c:	44 24       	eor	r4, r4
    453e:	55 24       	eor	r5, r5
    4540:	32 01       	movw	r6, r4
}
    4542:	64 2d       	mov	r22, r4
    4544:	75 2d       	mov	r23, r5
    4546:	86 2d       	mov	r24, r6
    4548:	97 2d       	mov	r25, r7
    454a:	df 91       	pop	r29
    454c:	cf 91       	pop	r28
    454e:	ff 90       	pop	r15
    4550:	ef 90       	pop	r14
    4552:	df 90       	pop	r13
    4554:	cf 90       	pop	r12
    4556:	bf 90       	pop	r11
    4558:	af 90       	pop	r10
    455a:	9f 90       	pop	r9
    455c:	8f 90       	pop	r8
    455e:	7f 90       	pop	r7
    4560:	6f 90       	pop	r6
    4562:	5f 90       	pop	r5
    4564:	4f 90       	pop	r4
    4566:	08 95       	ret

00004568 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4568:	cf 92       	push	r12
    456a:	df 92       	push	r13
    456c:	ef 92       	push	r14
    456e:	ff 92       	push	r15
    4570:	cf 93       	push	r28
    4572:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4574:	db 01       	movw	r26, r22
    4576:	ca 01       	movw	r24, r20
    4578:	91 70       	andi	r25, 0x01	; 1
    457a:	a0 70       	andi	r26, 0x00	; 0
    457c:	b0 70       	andi	r27, 0x00	; 0
    457e:	00 97       	sbiw	r24, 0x00	; 0
    4580:	a1 05       	cpc	r26, r1
    4582:	b1 05       	cpc	r27, r1
    4584:	51 f4       	brne	.+20     	; 0x459a <freeMemoryUpdate+0x32>
    4586:	03 2e       	mov	r0, r19
    4588:	39 e0       	ldi	r19, 0x09	; 9
    458a:	76 95       	lsr	r23
    458c:	67 95       	ror	r22
    458e:	57 95       	ror	r21
    4590:	47 95       	ror	r20
    4592:	3a 95       	dec	r19
    4594:	d1 f7       	brne	.-12     	; 0x458a <freeMemoryUpdate+0x22>
    4596:	30 2d       	mov	r19, r0
    4598:	0d c0       	rjmp	.+26     	; 0x45b4 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    459a:	03 2e       	mov	r0, r19
    459c:	39 e0       	ldi	r19, 0x09	; 9
    459e:	76 95       	lsr	r23
    45a0:	67 95       	ror	r22
    45a2:	57 95       	ror	r21
    45a4:	47 95       	ror	r20
    45a6:	3a 95       	dec	r19
    45a8:	d1 f7       	brne	.-12     	; 0x459e <freeMemoryUpdate+0x36>
    45aa:	30 2d       	mov	r19, r0
    45ac:	4f 5f       	subi	r20, 0xFF	; 255
    45ae:	5f 4f       	sbci	r21, 0xFF	; 255
    45b0:	6f 4f       	sbci	r22, 0xFF	; 255
    45b2:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    45b4:	db 01       	movw	r26, r22
    45b6:	ca 01       	movw	r24, r20
    45b8:	87 70       	andi	r24, 0x07	; 7
    45ba:	90 70       	andi	r25, 0x00	; 0
    45bc:	a0 70       	andi	r26, 0x00	; 0
    45be:	b0 70       	andi	r27, 0x00	; 0
    45c0:	00 97       	sbiw	r24, 0x00	; 0
    45c2:	a1 05       	cpc	r26, r1
    45c4:	b1 05       	cpc	r27, r1
    45c6:	59 f4       	brne	.+22     	; 0x45de <freeMemoryUpdate+0x76>
    45c8:	6a 01       	movw	r12, r20
    45ca:	7b 01       	movw	r14, r22
    45cc:	68 94       	set
    45ce:	12 f8       	bld	r1, 2
    45d0:	f6 94       	lsr	r15
    45d2:	e7 94       	ror	r14
    45d4:	d7 94       	ror	r13
    45d6:	c7 94       	ror	r12
    45d8:	16 94       	lsr	r1
    45da:	d1 f7       	brne	.-12     	; 0x45d0 <freeMemoryUpdate+0x68>
    45dc:	0f c0       	rjmp	.+30     	; 0x45fc <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    45de:	6a 01       	movw	r12, r20
    45e0:	7b 01       	movw	r14, r22
    45e2:	68 94       	set
    45e4:	12 f8       	bld	r1, 2
    45e6:	f6 94       	lsr	r15
    45e8:	e7 94       	ror	r14
    45ea:	d7 94       	ror	r13
    45ec:	c7 94       	ror	r12
    45ee:	16 94       	lsr	r1
    45f0:	d1 f7       	brne	.-12     	; 0x45e6 <freeMemoryUpdate+0x7e>
    45f2:	08 94       	sec
    45f4:	c1 1c       	adc	r12, r1
    45f6:	d1 1c       	adc	r13, r1
    45f8:	e1 1c       	adc	r14, r1
    45fa:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    45fc:	80 91 a2 50 	lds	r24, 0x50A2
    4600:	88 23       	and	r24, r24
    4602:	d1 f0       	breq	.+52     	; 0x4638 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4604:	81 e0       	ldi	r24, 0x01	; 1
    4606:	60 e0       	ldi	r22, 0x00	; 0
    4608:	20 e0       	ldi	r18, 0x00	; 0
    460a:	30 e0       	ldi	r19, 0x00	; 0
    460c:	a9 01       	movw	r20, r18
    460e:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <getSetFreeCluster>
	if(flag == ADD)
    4612:	cc 23       	and	r28, r28
    4614:	39 f4       	brne	.+14     	; 0x4624 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4616:	9b 01       	movw	r18, r22
    4618:	ac 01       	movw	r20, r24
    461a:	2c 0d       	add	r18, r12
    461c:	3d 1d       	adc	r19, r13
    461e:	4e 1d       	adc	r20, r14
    4620:	5f 1d       	adc	r21, r15
    4622:	06 c0       	rjmp	.+12     	; 0x4630 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4624:	9b 01       	movw	r18, r22
    4626:	ac 01       	movw	r20, r24
    4628:	2c 19       	sub	r18, r12
    462a:	3d 09       	sbc	r19, r13
    462c:	4e 09       	sbc	r20, r14
    462e:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4630:	81 e0       	ldi	r24, 0x01	; 1
    4632:	61 e0       	ldi	r22, 0x01	; 1
    4634:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <getSetFreeCluster>
  }
}
    4638:	cf 91       	pop	r28
    463a:	ff 90       	pop	r15
    463c:	ef 90       	pop	r14
    463e:	df 90       	pop	r13
    4640:	cf 90       	pop	r12
    4642:	08 95       	ret

00004644 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4644:	2f 92       	push	r2
    4646:	3f 92       	push	r3
    4648:	4f 92       	push	r4
    464a:	5f 92       	push	r5
    464c:	6f 92       	push	r6
    464e:	7f 92       	push	r7
    4650:	8f 92       	push	r8
    4652:	9f 92       	push	r9
    4654:	af 92       	push	r10
    4656:	bf 92       	push	r11
    4658:	cf 92       	push	r12
    465a:	df 92       	push	r13
    465c:	ef 92       	push	r14
    465e:	ff 92       	push	r15
    4660:	0f 93       	push	r16
    4662:	1f 93       	push	r17
    4664:	cf 93       	push	r28
    4666:	df 93       	push	r29
    4668:	cd b7       	in	r28, 0x3d	; 61
    466a:	de b7       	in	r29, 0x3e	; 62
    466c:	2c 97       	sbiw	r28, 0x0c	; 12
    466e:	cd bf       	out	0x3d, r28	; 61
    4670:	de bf       	out	0x3e, r29	; 62
    4672:	88 2e       	mov	r8, r24
    4674:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4676:	80 91 5e 40 	lds	r24, 0x405E
    467a:	90 91 5f 40 	lds	r25, 0x405F
    467e:	a0 91 60 40 	lds	r26, 0x4060
    4682:	b0 91 61 40 	lds	r27, 0x4061
    4686:	89 87       	std	Y+9, r24	; 0x09
    4688:	9a 87       	std	Y+10, r25	; 0x0a
    468a:	ab 87       	std	Y+11, r26	; 0x0b
    468c:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    468e:	0f 2e       	mov	r0, r31
    4690:	f9 e4       	ldi	r31, 0x49	; 73
    4692:	2f 2e       	mov	r2, r31
    4694:	fe e3       	ldi	r31, 0x3E	; 62
    4696:	3f 2e       	mov	r3, r31
    4698:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    469a:	c8 2c       	mov	r12, r8
    469c:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    469e:	d2 2c       	mov	r13, r2
    46a0:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    46a2:	5b 01       	movw	r10, r22
    46a4:	08 94       	sec
    46a6:	a1 1c       	adc	r10, r1
    46a8:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    46aa:	69 85       	ldd	r22, Y+9	; 0x09
    46ac:	7a 85       	ldd	r23, Y+10	; 0x0a
    46ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    46b0:	9c 85       	ldd	r25, Y+12	; 0x0c
    46b2:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <getFirstSector>
    46b6:	6d 83       	std	Y+5, r22	; 0x05
    46b8:	7e 83       	std	Y+6, r23	; 0x06
    46ba:	8f 83       	std	Y+7, r24	; 0x07
    46bc:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    46be:	80 91 6a 50 	lds	r24, 0x506A
    46c2:	90 91 6b 50 	lds	r25, 0x506B
    46c6:	00 97       	sbiw	r24, 0x00	; 0
    46c8:	09 f4       	brne	.+2      	; 0x46cc <findFiles+0x88>
    46ca:	13 c1       	rjmp	.+550    	; 0x48f2 <findFiles+0x2ae>
    46cc:	44 24       	eor	r4, r4
    46ce:	55 24       	eor	r5, r5
    46d0:	32 01       	movw	r6, r4
    46d2:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    46d4:	8d 81       	ldd	r24, Y+5	; 0x05
    46d6:	9e 81       	ldd	r25, Y+6	; 0x06
    46d8:	af 81       	ldd	r26, Y+7	; 0x07
    46da:	b8 85       	ldd	r27, Y+8	; 0x08
    46dc:	84 0d       	add	r24, r4
    46de:	95 1d       	adc	r25, r5
    46e0:	a6 1d       	adc	r26, r6
    46e2:	b7 1d       	adc	r27, r7
    46e4:	89 83       	std	Y+1, r24	; 0x01
    46e6:	9a 83       	std	Y+2, r25	; 0x02
    46e8:	ab 83       	std	Y+3, r26	; 0x03
    46ea:	bc 83       	std	Y+4, r27	; 0x04
    46ec:	bc 01       	movw	r22, r24
    46ee:	cd 01       	movw	r24, r26
    46f0:	4d 2d       	mov	r20, r13
    46f2:	59 2d       	mov	r21, r9
    46f4:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    46f8:	80 91 56 40 	lds	r24, 0x4056
    46fc:	90 91 57 40 	lds	r25, 0x4057
    4700:	00 97       	sbiw	r24, 0x00	; 0
    4702:	09 f4       	brne	.+2      	; 0x4706 <findFiles+0xc2>
    4704:	e4 c0       	rjmp	.+456    	; 0x48ce <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4706:	d1 01       	movw	r26, r2
    4708:	8c 91       	ld	r24, X
    470a:	88 23       	and	r24, r24
    470c:	09 f4       	brne	.+2      	; 0x4710 <findFiles+0xcc>
    470e:	10 c1       	rjmp	.+544    	; 0x4930 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4710:	4d 2d       	mov	r20, r13
    4712:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4714:	20 e0       	ldi	r18, 0x00	; 0
    4716:	30 e0       	ldi	r19, 0x00	; 0
    4718:	08 c0       	rjmp	.+16     	; 0x472a <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    471a:	a9 01       	movw	r20, r18
    471c:	47 5b       	subi	r20, 0xB7	; 183
    471e:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4720:	fa 01       	movw	r30, r20
    4722:	80 81       	ld	r24, Z
    4724:	88 23       	and	r24, r24
    4726:	09 f4       	brne	.+2      	; 0x472a <findFiles+0xe6>
    4728:	06 c1       	rjmp	.+524    	; 0x4936 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    472a:	85 3e       	cpi	r24, 0xE5	; 229
    472c:	09 f4       	brne	.+2      	; 0x4730 <findFiles+0xec>
    472e:	c5 c0       	rjmp	.+394    	; 0x48ba <findFiles+0x276>
    4730:	da 01       	movw	r26, r20
    4732:	1b 96       	adiw	r26, 0x0b	; 11
    4734:	8c 91       	ld	r24, X
    4736:	1b 97       	sbiw	r26, 0x0b	; 11
    4738:	8f 30       	cpi	r24, 0x0F	; 15
    473a:	09 f4       	brne	.+2      	; 0x473e <findFiles+0xfa>
    473c:	be c0       	rjmp	.+380    	; 0x48ba <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    473e:	12 30       	cpi	r17, 0x02	; 2
    4740:	08 f0       	brcs	.+2      	; 0x4744 <findFiles+0x100>
    4742:	fc c0       	rjmp	.+504    	; 0x493c <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4744:	9c 91       	ld	r25, X
    4746:	f7 01       	movw	r30, r14
    4748:	80 81       	ld	r24, Z
    474a:	98 17       	cp	r25, r24
    474c:	09 f0       	breq	.+2      	; 0x4750 <findFiles+0x10c>
    474e:	b5 c0       	rjmp	.+362    	; 0x48ba <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4750:	fa 01       	movw	r30, r20
    4752:	31 96       	adiw	r30, 0x01	; 1
    4754:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4756:	81 e0       	ldi	r24, 0x01	; 1
    4758:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    475a:	41 91       	ld	r20, Z+
    475c:	9d 91       	ld	r25, X+
    475e:	49 17       	cp	r20, r25
    4760:	31 f4       	brne	.+12     	; 0x476e <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4762:	8f 5f       	subi	r24, 0xFF	; 255
    4764:	8b 30       	cpi	r24, 0x0B	; 11
    4766:	c9 f7       	brne	.-14     	; 0x475a <findFiles+0x116>
    4768:	8b 01       	movw	r16, r22
    476a:	6b 01       	movw	r12, r22
    476c:	05 c0       	rjmp	.+10     	; 0x4778 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    476e:	8b 30       	cpi	r24, 0x0B	; 11
    4770:	09 f0       	breq	.+2      	; 0x4774 <findFiles+0x130>
    4772:	a3 c0       	rjmp	.+326    	; 0x48ba <findFiles+0x276>
    4774:	8b 01       	movw	r16, r22
    4776:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4778:	f1 e0       	ldi	r31, 0x01	; 1
    477a:	8f 16       	cp	r8, r31
    477c:	09 f0       	breq	.+2      	; 0x4780 <findFiles+0x13c>
    477e:	41 c0       	rjmp	.+130    	; 0x4802 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4780:	89 81       	ldd	r24, Y+1	; 0x01
    4782:	9a 81       	ldd	r25, Y+2	; 0x02
    4784:	ab 81       	ldd	r26, Y+3	; 0x03
    4786:	bc 81       	ldd	r27, Y+4	; 0x04
    4788:	80 93 a3 50 	sts	0x50A3, r24
    478c:	90 93 a4 50 	sts	0x50A4, r25
    4790:	a0 93 a5 50 	sts	0x50A5, r26
    4794:	b0 93 a6 50 	sts	0x50A6, r27
				appendFileLocation = i;
    4798:	c9 01       	movw	r24, r18
    479a:	a0 e0       	ldi	r26, 0x00	; 0
    479c:	b0 e0       	ldi	r27, 0x00	; 0
    479e:	80 93 4a 40 	sts	0x404A, r24
    47a2:	90 93 4b 40 	sts	0x404B, r25
    47a6:	a0 93 4c 40 	sts	0x404C, r26
    47aa:	b0 93 4d 40 	sts	0x404D, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    47ae:	d6 01       	movw	r26, r12
    47b0:	54 96       	adiw	r26, 0x14	; 20
    47b2:	4d 91       	ld	r20, X+
    47b4:	5c 91       	ld	r21, X
    47b6:	55 97       	sbiw	r26, 0x15	; 21
    47b8:	60 e0       	ldi	r22, 0x00	; 0
    47ba:	70 e0       	ldi	r23, 0x00	; 0
    47bc:	ba 01       	movw	r22, r20
    47be:	55 27       	eor	r21, r21
    47c0:	44 27       	eor	r20, r20
    47c2:	5a 96       	adiw	r26, 0x1a	; 26
    47c4:	8d 91       	ld	r24, X+
    47c6:	9c 91       	ld	r25, X
    47c8:	5b 97       	sbiw	r26, 0x1b	; 27
    47ca:	a0 e0       	ldi	r26, 0x00	; 0
    47cc:	b0 e0       	ldi	r27, 0x00	; 0
    47ce:	84 2b       	or	r24, r20
    47d0:	95 2b       	or	r25, r21
    47d2:	a6 2b       	or	r26, r22
    47d4:	b7 2b       	or	r27, r23
    47d6:	80 93 74 50 	sts	0x5074, r24
    47da:	90 93 75 50 	sts	0x5075, r25
    47de:	a0 93 76 50 	sts	0x5076, r26
    47e2:	b0 93 77 50 	sts	0x5077, r27
				fileSize = dir->fileSize;
    47e6:	f6 01       	movw	r30, r12
    47e8:	84 8d       	ldd	r24, Z+28	; 0x1c
    47ea:	95 8d       	ldd	r25, Z+29	; 0x1d
    47ec:	a6 8d       	ldd	r26, Z+30	; 0x1e
    47ee:	b7 8d       	ldd	r27, Z+31	; 0x1f
    47f0:	80 93 52 40 	sts	0x4052, r24
    47f4:	90 93 53 40 	sts	0x4053, r25
    47f8:	a0 93 54 40 	sts	0x4054, r26
    47fc:	b0 93 55 40 	sts	0x4055, r27
			    return (dir);
    4800:	a5 c0       	rjmp	.+330    	; 0x494c <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4802:	d6 01       	movw	r26, r12
    4804:	54 96       	adiw	r26, 0x14	; 20
    4806:	8d 91       	ld	r24, X+
    4808:	9c 91       	ld	r25, X
    480a:	55 97       	sbiw	r26, 0x15	; 21
    480c:	a0 e0       	ldi	r26, 0x00	; 0
    480e:	b0 e0       	ldi	r27, 0x00	; 0
    4810:	3c 01       	movw	r6, r24
    4812:	55 24       	eor	r5, r5
    4814:	44 24       	eor	r4, r4
    4816:	f6 01       	movw	r30, r12
    4818:	82 8d       	ldd	r24, Z+26	; 0x1a
    481a:	93 8d       	ldd	r25, Z+27	; 0x1b
    481c:	a0 e0       	ldi	r26, 0x00	; 0
    481e:	b0 e0       	ldi	r27, 0x00	; 0
    4820:	48 2a       	or	r4, r24
    4822:	59 2a       	or	r5, r25
    4824:	6a 2a       	or	r6, r26
    4826:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4828:	85 ee       	ldi	r24, 0xE5	; 229
    482a:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    482c:	69 81       	ldd	r22, Y+1	; 0x01
    482e:	7a 81       	ldd	r23, Y+2	; 0x02
    4830:	8b 81       	ldd	r24, Y+3	; 0x03
    4832:	9c 81       	ldd	r25, Y+4	; 0x04
    4834:	49 e4       	ldi	r20, 0x49	; 73
    4836:	5e e3       	ldi	r21, 0x3E	; 62
    4838:	20 e0       	ldi	r18, 0x00	; 0
    483a:	32 e0       	ldi	r19, 0x02	; 2
    483c:	0e 94 4d 29 	call	0x529a	; 0x529a <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4840:	d6 01       	movw	r26, r12
    4842:	5c 96       	adiw	r26, 0x1c	; 28
    4844:	4d 91       	ld	r20, X+
    4846:	5d 91       	ld	r21, X+
    4848:	6d 91       	ld	r22, X+
    484a:	7c 91       	ld	r23, X
    484c:	5f 97       	sbiw	r26, 0x1f	; 31
    484e:	80 e0       	ldi	r24, 0x00	; 0
    4850:	0e 94 b4 22 	call	0x4568	; 0x4568 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4854:	82 e0       	ldi	r24, 0x02	; 2
    4856:	60 e0       	ldi	r22, 0x00	; 0
    4858:	20 e0       	ldi	r18, 0x00	; 0
    485a:	30 e0       	ldi	r19, 0x00	; 0
    485c:	a9 01       	movw	r20, r18
    485e:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <getSetFreeCluster>
    4862:	dc 01       	movw	r26, r24
    4864:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4866:	48 16       	cp	r4, r24
    4868:	59 06       	cpc	r5, r25
    486a:	6a 06       	cpc	r6, r26
    486c:	7b 06       	cpc	r7, r27
    486e:	30 f4       	brcc	.+12     	; 0x487c <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4870:	82 e0       	ldi	r24, 0x02	; 2
    4872:	61 e0       	ldi	r22, 0x01	; 1
    4874:	a3 01       	movw	r20, r6
    4876:	92 01       	movw	r18, r4
    4878:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    487c:	c3 01       	movw	r24, r6
    487e:	b2 01       	movw	r22, r4
    4880:	40 e0       	ldi	r20, 0x00	; 0
    4882:	00 e0       	ldi	r16, 0x00	; 0
    4884:	10 e0       	ldi	r17, 0x00	; 0
    4886:	98 01       	movw	r18, r16
    4888:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
    488c:	6b 01       	movw	r12, r22
    488e:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4890:	c3 01       	movw	r24, r6
    4892:	b2 01       	movw	r22, r4
    4894:	41 e0       	ldi	r20, 0x01	; 1
    4896:	00 e0       	ldi	r16, 0x00	; 0
    4898:	10 e0       	ldi	r17, 0x00	; 0
    489a:	98 01       	movw	r18, r16
    489c:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    48a0:	b7 ef       	ldi	r27, 0xF7	; 247
    48a2:	cb 16       	cp	r12, r27
    48a4:	bf ef       	ldi	r27, 0xFF	; 255
    48a6:	db 06       	cpc	r13, r27
    48a8:	bf ef       	ldi	r27, 0xFF	; 255
    48aa:	eb 06       	cpc	r14, r27
    48ac:	bf e0       	ldi	r27, 0x0F	; 15
    48ae:	fb 06       	cpc	r15, r27
    48b0:	08 f0       	brcs	.+2      	; 0x48b4 <findFiles+0x270>
    48b2:	47 c0       	rjmp	.+142    	; 0x4942 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    48b4:	26 01       	movw	r4, r12
    48b6:	37 01       	movw	r6, r14
    48b8:	e1 cf       	rjmp	.-62     	; 0x487c <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    48ba:	20 5e       	subi	r18, 0xE0	; 224
    48bc:	3f 4f       	sbci	r19, 0xFF	; 255
    48be:	80 91 56 40 	lds	r24, 0x4056
    48c2:	90 91 57 40 	lds	r25, 0x4057
    48c6:	28 17       	cp	r18, r24
    48c8:	39 07       	cpc	r19, r25
    48ca:	08 f4       	brcc	.+2      	; 0x48ce <findFiles+0x28a>
    48cc:	26 cf       	rjmp	.-436    	; 0x471a <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    48ce:	08 94       	sec
    48d0:	41 1c       	adc	r4, r1
    48d2:	51 1c       	adc	r5, r1
    48d4:	61 1c       	adc	r6, r1
    48d6:	71 1c       	adc	r7, r1
    48d8:	80 91 6a 50 	lds	r24, 0x506A
    48dc:	90 91 6b 50 	lds	r25, 0x506B
    48e0:	a0 e0       	ldi	r26, 0x00	; 0
    48e2:	b0 e0       	ldi	r27, 0x00	; 0
    48e4:	48 16       	cp	r4, r24
    48e6:	59 06       	cpc	r5, r25
    48e8:	6a 06       	cpc	r6, r26
    48ea:	7b 06       	cpc	r7, r27
    48ec:	08 f4       	brcc	.+2      	; 0x48f0 <findFiles+0x2ac>
    48ee:	f2 ce       	rjmp	.-540    	; 0x46d4 <findFiles+0x90>
    48f0:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    48f2:	69 85       	ldd	r22, Y+9	; 0x09
    48f4:	7a 85       	ldd	r23, Y+10	; 0x0a
    48f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    48f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    48fa:	40 e0       	ldi	r20, 0x00	; 0
    48fc:	00 e0       	ldi	r16, 0x00	; 0
    48fe:	10 e0       	ldi	r17, 0x00	; 0
    4900:	98 01       	movw	r18, r16
    4902:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
    4906:	69 87       	std	Y+9, r22	; 0x09
    4908:	7a 87       	std	Y+10, r23	; 0x0a
    490a:	8b 87       	std	Y+11, r24	; 0x0b
    490c:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    490e:	67 3f       	cpi	r22, 0xF7	; 247
    4910:	ef ef       	ldi	r30, 0xFF	; 255
    4912:	7e 07       	cpc	r23, r30
    4914:	ef ef       	ldi	r30, 0xFF	; 255
    4916:	8e 07       	cpc	r24, r30
    4918:	ef e0       	ldi	r30, 0x0F	; 15
    491a:	9e 07       	cpc	r25, r30
    491c:	a8 f4       	brcc	.+42     	; 0x4948 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    491e:	61 15       	cp	r22, r1
    4920:	71 05       	cpc	r23, r1
    4922:	81 05       	cpc	r24, r1
    4924:	91 05       	cpc	r25, r1
    4926:	09 f0       	breq	.+2      	; 0x492a <findFiles+0x2e6>
    4928:	c0 ce       	rjmp	.-640    	; 0x46aa <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    492a:	00 e0       	ldi	r16, 0x00	; 0
    492c:	10 e0       	ldi	r17, 0x00	; 0
    492e:	0e c0       	rjmp	.+28     	; 0x494c <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4930:	00 e0       	ldi	r16, 0x00	; 0
    4932:	10 e0       	ldi	r17, 0x00	; 0
    4934:	0b c0       	rjmp	.+22     	; 0x494c <findFiles+0x308>
    4936:	00 e0       	ldi	r16, 0x00	; 0
    4938:	10 e0       	ldi	r17, 0x00	; 0
    493a:	08 c0       	rjmp	.+16     	; 0x494c <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    493c:	00 e0       	ldi	r16, 0x00	; 0
    493e:	10 e0       	ldi	r17, 0x00	; 0
    4940:	05 c0       	rjmp	.+10     	; 0x494c <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4942:	00 e0       	ldi	r16, 0x00	; 0
    4944:	10 e0       	ldi	r17, 0x00	; 0
    4946:	02 c0       	rjmp	.+4      	; 0x494c <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4948:	00 e0       	ldi	r16, 0x00	; 0
    494a:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    494c:	80 2f       	mov	r24, r16
    494e:	91 2f       	mov	r25, r17
    4950:	2c 96       	adiw	r28, 0x0c	; 12
    4952:	cd bf       	out	0x3d, r28	; 61
    4954:	de bf       	out	0x3e, r29	; 62
    4956:	df 91       	pop	r29
    4958:	cf 91       	pop	r28
    495a:	1f 91       	pop	r17
    495c:	0f 91       	pop	r16
    495e:	ff 90       	pop	r15
    4960:	ef 90       	pop	r14
    4962:	df 90       	pop	r13
    4964:	cf 90       	pop	r12
    4966:	bf 90       	pop	r11
    4968:	af 90       	pop	r10
    496a:	9f 90       	pop	r9
    496c:	8f 90       	pop	r8
    496e:	7f 90       	pop	r7
    4970:	6f 90       	pop	r6
    4972:	5f 90       	pop	r5
    4974:	4f 90       	pop	r4
    4976:	3f 90       	pop	r3
    4978:	2f 90       	pop	r2
    497a:	08 95       	ret

0000497c <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    497c:	0e 94 42 21 	call	0x4284	; 0x4284 <convertFileName>
  if(error) return;
    4980:	88 23       	and	r24, r24
    4982:	29 f4       	brne	.+10     	; 0x498e <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4984:	82 e0       	ldi	r24, 0x02	; 2
    4986:	62 e9       	ldi	r22, 0x92	; 146
    4988:	70 e5       	ldi	r23, 0x50	; 80
    498a:	0e 94 22 23 	call	0x4644	; 0x4644 <findFiles>
    498e:	08 95       	ret

00004990 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4990:	4f 92       	push	r4
    4992:	5f 92       	push	r5
    4994:	6f 92       	push	r6
    4996:	7f 92       	push	r7
    4998:	af 92       	push	r10
    499a:	bf 92       	push	r11
    499c:	cf 92       	push	r12
    499e:	df 92       	push	r13
    49a0:	ef 92       	push	r14
    49a2:	ff 92       	push	r15
    49a4:	0f 93       	push	r16
    49a6:	1f 93       	push	r17
    49a8:	cf 93       	push	r28
    49aa:	c8 2f       	mov	r28, r24
    49ac:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    49ae:	0e 94 42 21 	call	0x4284	; 0x4284 <convertFileName>
if(error) return 2;
    49b2:	88 23       	and	r24, r24
    49b4:	09 f0       	breq	.+2      	; 0x49b8 <readFile+0x28>
    49b6:	57 c0       	rjmp	.+174    	; 0x4a66 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    49b8:	81 e0       	ldi	r24, 0x01	; 1
    49ba:	62 e9       	ldi	r22, 0x92	; 146
    49bc:	70 e5       	ldi	r23, 0x50	; 80
    49be:	0e 94 22 23 	call	0x4644	; 0x4644 <findFiles>
    49c2:	fc 01       	movw	r30, r24
if(dir == 0) 
    49c4:	00 97       	sbiw	r24, 0x00	; 0
    49c6:	31 f4       	brne	.+12     	; 0x49d4 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    49c8:	81 e0       	ldi	r24, 0x01	; 1
    49ca:	cc 23       	and	r28, r28
    49cc:	09 f4       	brne	.+2      	; 0x49d0 <readFile+0x40>
    49ce:	4e c0       	rjmp	.+156    	; 0x4a6c <readFile+0xdc>
    49d0:	80 e0       	ldi	r24, 0x00	; 0
    49d2:	4c c0       	rjmp	.+152    	; 0x4a6c <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    49d4:	c1 30       	cpi	r28, 0x01	; 1
    49d6:	09 f4       	brne	.+2      	; 0x49da <readFile+0x4a>
    49d8:	48 c0       	rjmp	.+144    	; 0x4a6a <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    49da:	44 88       	ldd	r4, Z+20	; 0x14
    49dc:	55 88       	ldd	r5, Z+21	; 0x15
    49de:	66 24       	eor	r6, r6
    49e0:	77 24       	eor	r7, r7
    49e2:	32 01       	movw	r6, r4
    49e4:	55 24       	eor	r5, r5
    49e6:	44 24       	eor	r4, r4
    49e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    49ea:	93 8d       	ldd	r25, Z+27	; 0x1b
    49ec:	a0 e0       	ldi	r26, 0x00	; 0
    49ee:	b0 e0       	ldi	r27, 0x00	; 0
    49f0:	48 2a       	or	r4, r24
    49f2:	59 2a       	or	r5, r25
    49f4:	6a 2a       	or	r6, r26
    49f6:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    49f8:	0f 2e       	mov	r0, r31
    49fa:	fd ea       	ldi	r31, 0xAD	; 173
    49fc:	af 2e       	mov	r10, r31
    49fe:	f1 e2       	ldi	r31, 0x21	; 33
    4a00:	bf 2e       	mov	r11, r31
    4a02:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4a04:	c3 01       	movw	r24, r6
    4a06:	b2 01       	movw	r22, r4
    4a08:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <getFirstSector>
    4a0c:	6b 01       	movw	r12, r22
    4a0e:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4a10:	80 91 6a 50 	lds	r24, 0x506A
    4a14:	90 91 6b 50 	lds	r25, 0x506B
    4a18:	00 97       	sbiw	r24, 0x00	; 0
    4a1a:	a1 f0       	breq	.+40     	; 0x4a44 <readFile+0xb4>
    4a1c:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4a1e:	c7 01       	movw	r24, r14
    4a20:	b6 01       	movw	r22, r12
    4a22:	6c 0f       	add	r22, r28
    4a24:	71 1d       	adc	r23, r1
    4a26:	81 1d       	adc	r24, r1
    4a28:	91 1d       	adc	r25, r1
    4a2a:	a5 01       	movw	r20, r10
    4a2c:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4a30:	cf 5f       	subi	r28, 0xFF	; 255
    4a32:	80 91 6a 50 	lds	r24, 0x506A
    4a36:	90 91 6b 50 	lds	r25, 0x506B
    4a3a:	2c 2f       	mov	r18, r28
    4a3c:	30 e0       	ldi	r19, 0x00	; 0
    4a3e:	28 17       	cp	r18, r24
    4a40:	39 07       	cpc	r19, r25
    4a42:	68 f3       	brcs	.-38     	; 0x4a1e <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4a44:	c3 01       	movw	r24, r6
    4a46:	b2 01       	movw	r22, r4
    4a48:	40 e0       	ldi	r20, 0x00	; 0
    4a4a:	00 e0       	ldi	r16, 0x00	; 0
    4a4c:	10 e0       	ldi	r17, 0x00	; 0
    4a4e:	98 01       	movw	r18, r16
    4a50:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
    4a54:	2b 01       	movw	r4, r22
    4a56:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4a58:	61 15       	cp	r22, r1
    4a5a:	71 05       	cpc	r23, r1
    4a5c:	81 05       	cpc	r24, r1
    4a5e:	91 05       	cpc	r25, r1
    4a60:	89 f6       	brne	.-94     	; 0x4a04 <readFile+0x74>
	  return 0;}
    4a62:	80 e0       	ldi	r24, 0x00	; 0
    4a64:	03 c0       	rjmp	.+6      	; 0x4a6c <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4a66:	82 e0       	ldi	r24, 0x02	; 2
    4a68:	01 c0       	rjmp	.+2      	; 0x4a6c <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4a6a:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4a6c:	cf 91       	pop	r28
    4a6e:	1f 91       	pop	r17
    4a70:	0f 91       	pop	r16
    4a72:	ff 90       	pop	r15
    4a74:	ef 90       	pop	r14
    4a76:	df 90       	pop	r13
    4a78:	cf 90       	pop	r12
    4a7a:	bf 90       	pop	r11
    4a7c:	af 90       	pop	r10
    4a7e:	7f 90       	pop	r7
    4a80:	6f 90       	pop	r6
    4a82:	5f 90       	pop	r5
    4a84:	4f 90       	pop	r4
    4a86:	08 95       	ret

00004a88 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4a88:	2f 92       	push	r2
    4a8a:	3f 92       	push	r3
    4a8c:	4f 92       	push	r4
    4a8e:	5f 92       	push	r5
    4a90:	6f 92       	push	r6
    4a92:	7f 92       	push	r7
    4a94:	8f 92       	push	r8
    4a96:	9f 92       	push	r9
    4a98:	af 92       	push	r10
    4a9a:	bf 92       	push	r11
    4a9c:	cf 92       	push	r12
    4a9e:	df 92       	push	r13
    4aa0:	ef 92       	push	r14
    4aa2:	ff 92       	push	r15
    4aa4:	0f 93       	push	r16
    4aa6:	1f 93       	push	r17
    4aa8:	cf 93       	push	r28
    4aaa:	df 93       	push	r29
    4aac:	cd b7       	in	r28, 0x3d	; 61
    4aae:	de b7       	in	r29, 0x3e	; 62
    4ab0:	60 97       	sbiw	r28, 0x10	; 16
    4ab2:	cd bf       	out	0x3d, r28	; 61
    4ab4:	de bf       	out	0x3e, r29	; 62
    4ab6:	fc 01       	movw	r30, r24
    4ab8:	6d 83       	std	Y+5, r22	; 0x05
    4aba:	7e 83       	std	Y+6, r23	; 0x06
    4abc:	49 01       	movw	r8, r18
    4abe:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4ac0:	81 e0       	ldi	r24, 0x01	; 1
    4ac2:	bf 01       	movw	r22, r30
    4ac4:	0e 94 c8 24 	call	0x4990	; 0x4990 <readFile>

if(j == 1) 
    4ac8:	81 30       	cpi	r24, 0x01	; 1
    4aca:	09 f0       	breq	.+2      	; 0x4ace <writeFile+0x46>
    4acc:	7b c0       	rjmp	.+246    	; 0x4bc4 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4ace:	00 91 74 50 	lds	r16, 0x5074
    4ad2:	10 91 75 50 	lds	r17, 0x5075
    4ad6:	20 91 76 50 	lds	r18, 0x5076
    4ada:	30 91 77 50 	lds	r19, 0x5077
    4ade:	09 83       	std	Y+1, r16	; 0x01
    4ae0:	1a 83       	std	Y+2, r17	; 0x02
    4ae2:	2b 83       	std	Y+3, r18	; 0x03
    4ae4:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4ae6:	cc 24       	eor	r12, r12
    4ae8:	dd 24       	eor	r13, r13
    4aea:	76 01       	movw	r14, r12
    4aec:	24 01       	movw	r4, r8
    4aee:	35 01       	movw	r6, r10
    4af0:	48 01       	movw	r8, r16
    4af2:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4af4:	c5 01       	movw	r24, r10
    4af6:	b4 01       	movw	r22, r8
    4af8:	40 e0       	ldi	r20, 0x00	; 0
    4afa:	00 e0       	ldi	r16, 0x00	; 0
    4afc:	10 e0       	ldi	r17, 0x00	; 0
    4afe:	98 01       	movw	r18, r16
    4b00:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
    4b04:	dc 01       	movw	r26, r24
    4b06:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4b08:	8f 3f       	cpi	r24, 0xFF	; 255
    4b0a:	1f ef       	ldi	r17, 0xFF	; 255
    4b0c:	91 07       	cpc	r25, r17
    4b0e:	1f ef       	ldi	r17, 0xFF	; 255
    4b10:	a1 07       	cpc	r26, r17
    4b12:	1f ef       	ldi	r17, 0xFF	; 255
    4b14:	b1 07       	cpc	r27, r17
    4b16:	41 f0       	breq	.+16     	; 0x4b28 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4b18:	08 94       	sec
    4b1a:	c1 1c       	adc	r12, r1
    4b1c:	d1 1c       	adc	r13, r1
    4b1e:	e1 1c       	adc	r14, r1
    4b20:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4b22:	4c 01       	movw	r8, r24
    4b24:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4b26:	e6 cf       	rjmp	.-52     	; 0x4af4 <writeFile+0x6c>
    4b28:	89 82       	std	Y+1, r8	; 0x01
    4b2a:	9a 82       	std	Y+2, r9	; 0x02
    4b2c:	ab 82       	std	Y+3, r10	; 0x03
    4b2e:	bc 82       	std	Y+4, r11	; 0x04
    4b30:	53 01       	movw	r10, r6
    4b32:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4b34:	20 91 6a 50 	lds	r18, 0x506A
    4b38:	30 91 6b 50 	lds	r19, 0x506B
    4b3c:	80 91 56 40 	lds	r24, 0x4056
    4b40:	90 91 57 40 	lds	r25, 0x4057
    4b44:	60 90 56 40 	lds	r6, 0x4056
    4b48:	70 90 57 40 	lds	r7, 0x4057
    4b4c:	bc 01       	movw	r22, r24
    4b4e:	80 e0       	ldi	r24, 0x00	; 0
    4b50:	90 e0       	ldi	r25, 0x00	; 0
    4b52:	40 e0       	ldi	r20, 0x00	; 0
    4b54:	50 e0       	ldi	r21, 0x00	; 0
    4b56:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    4b5a:	a7 01       	movw	r20, r14
    4b5c:	96 01       	movw	r18, r12
    4b5e:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    4b62:	dc 01       	movw	r26, r24
    4b64:	cb 01       	movw	r24, r22
    4b66:	40 91 52 40 	lds	r20, 0x4052
    4b6a:	50 91 53 40 	lds	r21, 0x4053
    4b6e:	60 91 54 40 	lds	r22, 0x4054
    4b72:	70 91 55 40 	lds	r23, 0x4055
    4b76:	8a 01       	movw	r16, r20
    4b78:	9b 01       	movw	r18, r22
    4b7a:	08 1b       	sub	r16, r24
    4b7c:	19 0b       	sbc	r17, r25
    4b7e:	2a 0b       	sbc	r18, r26
    4b80:	3b 0b       	sbc	r19, r27
    4b82:	c9 01       	movw	r24, r18
    4b84:	b8 01       	movw	r22, r16
    4b86:	93 01       	movw	r18, r6
    4b88:	40 e0       	ldi	r20, 0x00	; 0
    4b8a:	50 e0       	ldi	r21, 0x00	; 0
    4b8c:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    4b90:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4b92:	69 81       	ldd	r22, Y+1	; 0x01
    4b94:	7a 81       	ldd	r23, Y+2	; 0x02
    4b96:	8b 81       	ldd	r24, Y+3	; 0x03
    4b98:	9c 81       	ldd	r25, Y+4	; 0x04
    4b9a:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <getFirstSector>
    4b9e:	dc 01       	movw	r26, r24
    4ba0:	cb 01       	movw	r24, r22
    4ba2:	20 2e       	mov	r2, r16
    4ba4:	33 24       	eor	r3, r3
    4ba6:	28 0e       	add	r2, r24
    4ba8:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4baa:	b1 01       	movw	r22, r2
    4bac:	80 e0       	ldi	r24, 0x00	; 0
    4bae:	90 e0       	ldi	r25, 0x00	; 0
    4bb0:	49 e4       	ldi	r20, 0x49	; 73
    4bb2:	5e e3       	ldi	r21, 0x3E	; 62
    4bb4:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4bb8:	1f 86       	std	Y+15, r1	; 0x0f
    4bba:	18 8a       	std	Y+16, r1	; 0x10
    4bbc:	19 86       	std	Y+9, r1	; 0x09
    4bbe:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4bc0:	11 e0       	ldi	r17, 0x01	; 1
    4bc2:	4c c0       	rjmp	.+152    	; 0x4c5c <writeFile+0x1d4>
}
else if(j == 2) 
    4bc4:	82 30       	cpi	r24, 0x02	; 2
    4bc6:	09 f4       	brne	.+2      	; 0x4bca <writeFile+0x142>
    4bc8:	0c c2       	rjmp	.+1048   	; 0x4fe2 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4bca:	82 e0       	ldi	r24, 0x02	; 2
    4bcc:	60 e0       	ldi	r22, 0x00	; 0
    4bce:	20 e0       	ldi	r18, 0x00	; 0
    4bd0:	30 e0       	ldi	r19, 0x00	; 0
    4bd2:	a9 01       	movw	r20, r18
    4bd4:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <getSetFreeCluster>
  if(cluster > totalClusters)
    4bd8:	00 91 59 40 	lds	r16, 0x4059
    4bdc:	10 91 5a 40 	lds	r17, 0x405A
    4be0:	20 91 5b 40 	lds	r18, 0x405B
    4be4:	30 91 5c 40 	lds	r19, 0x405C
    4be8:	06 17       	cp	r16, r22
    4bea:	17 07       	cpc	r17, r23
    4bec:	28 07       	cpc	r18, r24
    4bee:	39 07       	cpc	r19, r25
    4bf0:	40 f4       	brcc	.+16     	; 0x4c02 <writeFile+0x17a>
     cluster = rootCluster;
    4bf2:	60 91 5e 40 	lds	r22, 0x405E
    4bf6:	70 91 5f 40 	lds	r23, 0x405F
    4bfa:	80 91 60 40 	lds	r24, 0x4060
    4bfe:	90 91 61 40 	lds	r25, 0x4061

  cluster = searchNextFreeCluster(cluster);
    4c02:	0e 94 01 22 	call	0x4402	; 0x4402 <searchNextFreeCluster>
    4c06:	69 83       	std	Y+1, r22	; 0x01
    4c08:	7a 83       	std	Y+2, r23	; 0x02
    4c0a:	8b 83       	std	Y+3, r24	; 0x03
    4c0c:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4c0e:	61 15       	cp	r22, r1
    4c10:	71 05       	cpc	r23, r1
    4c12:	81 05       	cpc	r24, r1
    4c14:	91 05       	cpc	r25, r1
    4c16:	09 f4       	brne	.+2      	; 0x4c1a <writeFile+0x192>
    4c18:	e6 c1       	rjmp	.+972    	; 0x4fe6 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4c1a:	41 e0       	ldi	r20, 0x01	; 1
    4c1c:	0f ef       	ldi	r16, 0xFF	; 255
    4c1e:	1f ef       	ldi	r17, 0xFF	; 255
    4c20:	98 01       	movw	r18, r16
    4c22:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4c26:	2b 81       	ldd	r18, Y+3	; 0x03
    4c28:	3c 81       	ldd	r19, Y+4	; 0x04
    4c2a:	29 87       	std	Y+9, r18	; 0x09
    4c2c:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4c2e:	89 81       	ldd	r24, Y+1	; 0x01
    4c30:	9a 81       	ldd	r25, Y+2	; 0x02
    4c32:	8f 87       	std	Y+15, r24	; 0x0f
    4c34:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4c36:	10 92 52 40 	sts	0x4052, r1
    4c3a:	10 92 53 40 	sts	0x4053, r1
    4c3e:	10 92 54 40 	sts	0x4054, r1
    4c42:	10 92 55 40 	sts	0x4055, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4c46:	69 81       	ldd	r22, Y+1	; 0x01
    4c48:	7a 81       	ldd	r23, Y+2	; 0x02
    4c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4c4e:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <getFirstSector>
    4c52:	dc 01       	movw	r26, r24
    4c54:	cb 01       	movw	r24, r22
    4c56:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4c58:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4c5a:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4c5c:	81 14       	cp	r8, r1
    4c5e:	91 04       	cpc	r9, r1
    4c60:	a1 04       	cpc	r10, r1
    4c62:	b1 04       	cpc	r11, r1
    4c64:	09 f4       	brne	.+2      	; 0x4c68 <writeFile+0x1e0>
    4c66:	8d c0       	rjmp	.+282    	; 0x4d82 <writeFile+0x2fa>
    4c68:	44 24       	eor	r4, r4
    4c6a:	55 24       	eor	r5, r5
    4c6c:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4c6e:	c0 2e       	mov	r12, r16
    4c70:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4c72:	90 e0       	ldi	r25, 0x00	; 0
    4c74:	89 16       	cp	r8, r25
    4c76:	92 e0       	ldi	r25, 0x02	; 2
    4c78:	99 06       	cpc	r9, r25
    4c7a:	90 e0       	ldi	r25, 0x00	; 0
    4c7c:	a9 06       	cpc	r10, r25
    4c7e:	90 e0       	ldi	r25, 0x00	; 0
    4c80:	b9 06       	cpc	r11, r25
    4c82:	88 f0       	brcs	.+34     	; 0x4ca6 <writeFile+0x21e>
		 writtenData += 512;
    4c84:	00 e0       	ldi	r16, 0x00	; 0
    4c86:	12 e0       	ldi	r17, 0x02	; 2
    4c88:	20 e0       	ldi	r18, 0x00	; 0
    4c8a:	30 e0       	ldi	r19, 0x00	; 0
    4c8c:	40 0e       	add	r4, r16
    4c8e:	51 1e       	adc	r5, r17
    4c90:	62 1e       	adc	r6, r18
    4c92:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4c94:	80 e0       	ldi	r24, 0x00	; 0
    4c96:	9e ef       	ldi	r25, 0xFE	; 254
    4c98:	af ef       	ldi	r26, 0xFF	; 255
    4c9a:	bf ef       	ldi	r27, 0xFF	; 255
    4c9c:	88 0e       	add	r8, r24
    4c9e:	99 1e       	adc	r9, r25
    4ca0:	aa 1e       	adc	r10, r26
    4ca2:	bb 1e       	adc	r11, r27
    4ca4:	0c c0       	rjmp	.+24     	; 0x4cbe <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4ca6:	48 0c       	add	r4, r8
    4ca8:	59 1c       	adc	r5, r9
    4caa:	6a 1c       	adc	r6, r10
    4cac:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4cae:	95 01       	movw	r18, r10
    4cb0:	84 01       	movw	r16, r8
    4cb2:	11 70       	andi	r17, 0x01	; 1
    4cb4:	20 70       	andi	r18, 0x00	; 0
    4cb6:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4cb8:	88 24       	eor	r8, r8
    4cba:	99 24       	eor	r9, r9
    4cbc:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4cbe:	80 91 52 40 	lds	r24, 0x4052
    4cc2:	90 91 53 40 	lds	r25, 0x4053
    4cc6:	a0 91 54 40 	lds	r26, 0x4054
    4cca:	b0 91 55 40 	lds	r27, 0x4055
    4cce:	80 50       	subi	r24, 0x00	; 0
    4cd0:	9e 4f       	sbci	r25, 0xFE	; 254
    4cd2:	af 4f       	sbci	r26, 0xFF	; 255
    4cd4:	bf 4f       	sbci	r27, 0xFF	; 255
    4cd6:	80 93 52 40 	sts	0x4052, r24
    4cda:	90 93 53 40 	sts	0x4053, r25
    4cde:	a0 93 54 40 	sts	0x4054, r26
    4ce2:	b0 93 55 40 	sts	0x4055, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4ce6:	b1 01       	movw	r22, r2
    4ce8:	80 e0       	ldi	r24, 0x00	; 0
    4cea:	90 e0       	ldi	r25, 0x00	; 0
    4cec:	a2 01       	movw	r20, r4
    4cee:	40 1b       	sub	r20, r16
    4cf0:	51 0b       	sbc	r21, r17
    4cf2:	ad 81       	ldd	r26, Y+5	; 0x05
    4cf4:	be 81       	ldd	r27, Y+6	; 0x06
    4cf6:	4a 0f       	add	r20, r26
    4cf8:	5b 1f       	adc	r21, r27
    4cfa:	98 01       	movw	r18, r16
    4cfc:	0e 94 4d 29 	call	0x529a	; 0x529a <SD_write_block>
	j++;
    4d00:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4d02:	20 91 6a 50 	lds	r18, 0x506A
    4d06:	30 91 6b 50 	lds	r19, 0x506B
    4d0a:	8c 2d       	mov	r24, r12
    4d0c:	90 e0       	ldi	r25, 0x00	; 0
    4d0e:	82 17       	cp	r24, r18
    4d10:	93 07       	cpc	r25, r19
    4d12:	29 f5       	brne	.+74     	; 0x4d5e <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4d14:	69 81       	ldd	r22, Y+1	; 0x01
    4d16:	7a 81       	ldd	r23, Y+2	; 0x02
    4d18:	8b 81       	ldd	r24, Y+3	; 0x03
    4d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    4d1c:	0e 94 01 22 	call	0x4402	; 0x4402 <searchNextFreeCluster>
    4d20:	6b 01       	movw	r12, r22
    4d22:	7c 01       	movw	r14, r24
		if(cluster == 0){
    4d24:	61 15       	cp	r22, r1
    4d26:	71 05       	cpc	r23, r1
    4d28:	81 05       	cpc	r24, r1
    4d2a:	91 05       	cpc	r25, r1
    4d2c:	09 f4       	brne	.+2      	; 0x4d30 <writeFile+0x2a8>
    4d2e:	5d c1       	rjmp	.+698    	; 0x4fea <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    4d30:	69 81       	ldd	r22, Y+1	; 0x01
    4d32:	7a 81       	ldd	r23, Y+2	; 0x02
    4d34:	8b 81       	ldd	r24, Y+3	; 0x03
    4d36:	9c 81       	ldd	r25, Y+4	; 0x04
    4d38:	41 e0       	ldi	r20, 0x01	; 1
    4d3a:	97 01       	movw	r18, r14
    4d3c:	86 01       	movw	r16, r12
    4d3e:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    4d42:	c7 01       	movw	r24, r14
    4d44:	b6 01       	movw	r22, r12
    4d46:	41 e0       	ldi	r20, 0x01	; 1
    4d48:	0f ef       	ldi	r16, 0xFF	; 255
    4d4a:	1f ef       	ldi	r17, 0xFF	; 255
    4d4c:	98 01       	movw	r18, r16
    4d4e:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4d52:	c9 82       	std	Y+1, r12	; 0x01
    4d54:	da 82       	std	Y+2, r13	; 0x02
    4d56:	eb 82       	std	Y+3, r14	; 0x03
    4d58:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    4d5a:	cc 24       	eor	r12, r12
    4d5c:	03 c0       	rjmp	.+6      	; 0x4d64 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    4d5e:	08 94       	sec
    4d60:	21 1c       	adc	r2, r1
    4d62:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    4d64:	82 e0       	ldi	r24, 0x02	; 2
    4d66:	61 e0       	ldi	r22, 0x01	; 1
    4d68:	29 81       	ldd	r18, Y+1	; 0x01
    4d6a:	3a 81       	ldd	r19, Y+2	; 0x02
    4d6c:	4b 81       	ldd	r20, Y+3	; 0x03
    4d6e:	5c 81       	ldd	r21, Y+4	; 0x04
    4d70:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4d74:	81 14       	cp	r8, r1
    4d76:	91 04       	cpc	r9, r1
    4d78:	a1 04       	cpc	r10, r1
    4d7a:	b1 04       	cpc	r11, r1
    4d7c:	09 f0       	breq	.+2      	; 0x4d80 <writeFile+0x2f8>
    4d7e:	79 cf       	rjmp	.-270    	; 0x4c72 <writeFile+0x1ea>
    4d80:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    4d82:	11 23       	and	r17, r17
    4d84:	09 f4       	brne	.+2      	; 0x4d88 <writeFile+0x300>
    4d86:	3f c0       	rjmp	.+126    	; 0x4e06 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    4d88:	60 91 a3 50 	lds	r22, 0x50A3
    4d8c:	70 91 a4 50 	lds	r23, 0x50A4
    4d90:	80 91 a5 50 	lds	r24, 0x50A5
    4d94:	90 91 a6 50 	lds	r25, 0x50A6
    4d98:	09 e4       	ldi	r16, 0x49	; 73
    4d9a:	1e e3       	ldi	r17, 0x3E	; 62
    4d9c:	a8 01       	movw	r20, r16
    4d9e:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4da2:	e0 91 4a 40 	lds	r30, 0x404A
    4da6:	f0 91 4b 40 	lds	r31, 0x404B
    4daa:	e0 0f       	add	r30, r16
    4dac:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4dae:	12 8a       	std	Z+18, r1	; 0x12
    4db0:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4db2:	80 91 52 40 	lds	r24, 0x4052
    4db6:	90 91 53 40 	lds	r25, 0x4053
    4dba:	a0 91 54 40 	lds	r26, 0x4054
    4dbe:	b0 91 55 40 	lds	r27, 0x4055
    4dc2:	44 8d       	ldd	r20, Z+28	; 0x1c
    4dc4:	55 8d       	ldd	r21, Z+29	; 0x1d
    4dc6:	66 8d       	ldd	r22, Z+30	; 0x1e
    4dc8:	77 8d       	ldd	r23, Z+31	; 0x1f
    4dca:	6c 01       	movw	r12, r24
    4dcc:	7d 01       	movw	r14, r26
    4dce:	c4 1a       	sub	r12, r20
    4dd0:	d5 0a       	sbc	r13, r21
    4dd2:	e6 0a       	sbc	r14, r22
    4dd4:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4dd6:	84 8f       	std	Z+28, r24	; 0x1c
    4dd8:	95 8f       	std	Z+29, r25	; 0x1d
    4dda:	a6 8f       	std	Z+30, r26	; 0x1e
    4ddc:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4dde:	60 91 a3 50 	lds	r22, 0x50A3
    4de2:	70 91 a4 50 	lds	r23, 0x50A4
    4de6:	80 91 a5 50 	lds	r24, 0x50A5
    4dea:	90 91 a6 50 	lds	r25, 0x50A6
    4dee:	a8 01       	movw	r20, r16
    4df0:	20 e0       	ldi	r18, 0x00	; 0
    4df2:	32 e0       	ldi	r19, 0x02	; 2
    4df4:	0e 94 4d 29 	call	0x529a	; 0x529a <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    4df8:	81 e0       	ldi	r24, 0x01	; 1
    4dfa:	b7 01       	movw	r22, r14
    4dfc:	a6 01       	movw	r20, r12
    4dfe:	0e 94 b4 22 	call	0x4568	; 0x4568 <freeMemoryUpdate>

 //File appended!
  return 0;
    4e02:	80 e0       	ldi	r24, 0x00	; 0
    4e04:	f9 c0       	rjmp	.+498    	; 0x4ff8 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    4e06:	00 91 5e 40 	lds	r16, 0x405E
    4e0a:	10 91 5f 40 	lds	r17, 0x405F
    4e0e:	20 91 60 40 	lds	r18, 0x4060
    4e12:	30 91 61 40 	lds	r19, 0x4061
    4e16:	0b 87       	std	Y+11, r16	; 0x0b
    4e18:	1c 87       	std	Y+12, r17	; 0x0c
    4e1a:	2d 87       	std	Y+13, r18	; 0x0d
    4e1c:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4e1e:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4e20:	82 e9       	ldi	r24, 0x92	; 146
    4e22:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4e24:	0f 2e       	mov	r0, r31
    4e26:	fb e0       	ldi	r31, 0x0B	; 11
    4e28:	af 2e       	mov	r10, r31
    4e2a:	bb 24       	eor	r11, r11
    4e2c:	f0 2d       	mov	r31, r0
    4e2e:	a8 0e       	add	r10, r24
    4e30:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4e32:	88 24       	eor	r8, r8
    4e34:	68 94       	set
    4e36:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4e38:	0f 2e       	mov	r0, r31
    4e3a:	f9 e4       	ldi	r31, 0x49	; 73
    4e3c:	4f 2e       	mov	r4, r31
    4e3e:	fe e3       	ldi	r31, 0x3E	; 62
    4e40:	5f 2e       	mov	r5, r31
    4e42:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4e44:	28 2e       	mov	r2, r24
    4e46:	99 2e       	mov	r9, r25
    4e48:	37 2c       	mov	r3, r7
    4e4a:	6f 84       	ldd	r6, Y+15	; 0x0f
    4e4c:	78 88       	ldd	r7, Y+16	; 0x10
    4e4e:	04 c0       	rjmp	.+8      	; 0x4e58 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    4e50:	cb 86       	std	Y+11, r12	; 0x0b
    4e52:	dc 86       	std	Y+12, r13	; 0x0c
    4e54:	ed 86       	std	Y+13, r14	; 0x0d
    4e56:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    4e58:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e5a:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e5e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e60:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <getFirstSector>
    4e64:	6d 83       	std	Y+5, r22	; 0x05
    4e66:	7e 83       	std	Y+6, r23	; 0x06
    4e68:	8f 83       	std	Y+7, r24	; 0x07
    4e6a:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4e6c:	80 91 6a 50 	lds	r24, 0x506A
    4e70:	90 91 6b 50 	lds	r25, 0x506B
    4e74:	00 97       	sbiw	r24, 0x00	; 0
    4e76:	09 f4       	brne	.+2      	; 0x4e7a <writeFile+0x3f2>
    4e78:	77 c0       	rjmp	.+238    	; 0x4f68 <writeFile+0x4e0>
    4e7a:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4e7c:	cd 80       	ldd	r12, Y+5	; 0x05
    4e7e:	de 80       	ldd	r13, Y+6	; 0x06
    4e80:	ef 80       	ldd	r14, Y+7	; 0x07
    4e82:	f8 84       	ldd	r15, Y+8	; 0x08
    4e84:	19 81       	ldd	r17, Y+1	; 0x01
    4e86:	c1 0e       	add	r12, r17
    4e88:	d1 1c       	adc	r13, r1
    4e8a:	e1 1c       	adc	r14, r1
    4e8c:	f1 1c       	adc	r15, r1
    4e8e:	c7 01       	movw	r24, r14
    4e90:	b6 01       	movw	r22, r12
    4e92:	a2 01       	movw	r20, r4
    4e94:	0e 94 02 2a 	call	0x5404	; 0x5404 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    4e98:	80 91 56 40 	lds	r24, 0x4056
    4e9c:	90 91 57 40 	lds	r25, 0x4057
    4ea0:	00 97       	sbiw	r24, 0x00	; 0
    4ea2:	09 f4       	brne	.+2      	; 0x4ea6 <writeFile+0x41e>
    4ea4:	54 c0       	rjmp	.+168    	; 0x4f4e <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4ea6:	33 20       	and	r3, r3
    4ea8:	09 f0       	breq	.+2      	; 0x4eac <writeFile+0x424>
    4eaa:	a1 c0       	rjmp	.+322    	; 0x4fee <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4eac:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4eae:	00 e0       	ldi	r16, 0x00	; 0
    4eb0:	10 e0       	ldi	r17, 0x00	; 0
    4eb2:	06 c0       	rjmp	.+12     	; 0x4ec0 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4eb4:	a8 01       	movw	r20, r16
    4eb6:	47 5b       	subi	r20, 0xB7	; 183
    4eb8:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4eba:	22 23       	and	r18, r18
    4ebc:	09 f0       	breq	.+2      	; 0x4ec0 <writeFile+0x438>
    4ebe:	99 c0       	rjmp	.+306    	; 0x4ff2 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4ec0:	da 01       	movw	r26, r20
    4ec2:	8c 91       	ld	r24, X
    4ec4:	88 23       	and	r24, r24
    4ec6:	21 f4       	brne	.+8      	; 0x4ed0 <writeFile+0x448>
    4ec8:	e2 2d       	mov	r30, r2
    4eca:	f9 2d       	mov	r31, r9
    4ecc:	da 01       	movw	r26, r20
    4ece:	04 c0       	rjmp	.+8      	; 0x4ed8 <writeFile+0x450>
    4ed0:	85 3e       	cpi	r24, 0xE5	; 229
    4ed2:	d1 f3       	breq	.-12     	; 0x4ec8 <writeFile+0x440>
    4ed4:	23 2d       	mov	r18, r3
    4ed6:	30 c0       	rjmp	.+96     	; 0x4f38 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    4ed8:	81 91       	ld	r24, Z+
    4eda:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    4edc:	ea 15       	cp	r30, r10
    4ede:	fb 05       	cpc	r31, r11
    4ee0:	d9 f7       	brne	.-10     	; 0x4ed8 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4ee2:	fa 01       	movw	r30, r20
    4ee4:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    4ee6:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    4ee8:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    4eea:	12 8a       	std	Z+18, r1	; 0x12
    4eec:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    4eee:	29 85       	ldd	r18, Y+9	; 0x09
    4ef0:	3a 85       	ldd	r19, Y+10	; 0x0a
    4ef2:	24 8b       	std	Z+20, r18	; 0x14
    4ef4:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    4ef6:	62 8e       	std	Z+26, r6	; 0x1a
    4ef8:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    4efa:	80 91 52 40 	lds	r24, 0x4052
    4efe:	90 91 53 40 	lds	r25, 0x4053
    4f02:	a0 91 54 40 	lds	r26, 0x4054
    4f06:	b0 91 55 40 	lds	r27, 0x4055
    4f0a:	84 8f       	std	Z+28, r24	; 0x1c
    4f0c:	95 8f       	std	Z+29, r25	; 0x1d
    4f0e:	a6 8f       	std	Z+30, r26	; 0x1e
    4f10:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    4f12:	c7 01       	movw	r24, r14
    4f14:	b6 01       	movw	r22, r12
    4f16:	a2 01       	movw	r20, r4
    4f18:	20 e0       	ldi	r18, 0x00	; 0
    4f1a:	32 e0       	ldi	r19, 0x02	; 2
    4f1c:	0e 94 4d 29 	call	0x529a	; 0x529a <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    4f20:	40 91 52 40 	lds	r20, 0x4052
    4f24:	50 91 53 40 	lds	r21, 0x4053
    4f28:	60 91 54 40 	lds	r22, 0x4054
    4f2c:	70 91 55 40 	lds	r23, 0x4055
    4f30:	81 e0       	ldi	r24, 0x01	; 1
    4f32:	0e 94 b4 22 	call	0x4568	; 0x4568 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    4f36:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4f38:	00 5e       	subi	r16, 0xE0	; 224
    4f3a:	1f 4f       	sbci	r17, 0xFF	; 255
    4f3c:	80 91 56 40 	lds	r24, 0x4056
    4f40:	90 91 57 40 	lds	r25, 0x4057
    4f44:	08 17       	cp	r16, r24
    4f46:	19 07       	cpc	r17, r25
    4f48:	08 f4       	brcc	.+2      	; 0x4f4c <writeFile+0x4c4>
    4f4a:	b4 cf       	rjmp	.-152    	; 0x4eb4 <writeFile+0x42c>
    4f4c:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4f4e:	09 81       	ldd	r16, Y+1	; 0x01
    4f50:	0f 5f       	subi	r16, 0xFF	; 255
    4f52:	09 83       	std	Y+1, r16	; 0x01
    4f54:	20 91 6a 50 	lds	r18, 0x506A
    4f58:	30 91 6b 50 	lds	r19, 0x506B
    4f5c:	80 2f       	mov	r24, r16
    4f5e:	90 e0       	ldi	r25, 0x00	; 0
    4f60:	82 17       	cp	r24, r18
    4f62:	93 07       	cpc	r25, r19
    4f64:	08 f4       	brcc	.+2      	; 0x4f68 <writeFile+0x4e0>
    4f66:	8a cf       	rjmp	.-236    	; 0x4e7c <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    4f68:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f6a:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f6e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f70:	40 e0       	ldi	r20, 0x00	; 0
    4f72:	00 e0       	ldi	r16, 0x00	; 0
    4f74:	10 e0       	ldi	r17, 0x00	; 0
    4f76:	98 01       	movw	r18, r16
    4f78:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
    4f7c:	6b 01       	movw	r12, r22
    4f7e:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    4f80:	67 3f       	cpi	r22, 0xF7	; 247
    4f82:	1f ef       	ldi	r17, 0xFF	; 255
    4f84:	71 07       	cpc	r23, r17
    4f86:	1f ef       	ldi	r17, 0xFF	; 255
    4f88:	81 07       	cpc	r24, r17
    4f8a:	1f e0       	ldi	r17, 0x0F	; 15
    4f8c:	91 07       	cpc	r25, r17
    4f8e:	08 f1       	brcs	.+66     	; 0x4fd2 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    4f90:	6f 3f       	cpi	r22, 0xFF	; 255
    4f92:	2f ef       	ldi	r18, 0xFF	; 255
    4f94:	72 07       	cpc	r23, r18
    4f96:	2f ef       	ldi	r18, 0xFF	; 255
    4f98:	82 07       	cpc	r24, r18
    4f9a:	2f ef       	ldi	r18, 0xFF	; 255
    4f9c:	92 07       	cpc	r25, r18
    4f9e:	59 f5       	brne	.+86     	; 0x4ff6 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    4fa0:	6b 85       	ldd	r22, Y+11	; 0x0b
    4fa2:	7c 85       	ldd	r23, Y+12	; 0x0c
    4fa4:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fa6:	9e 85       	ldd	r25, Y+14	; 0x0e
    4fa8:	0e 94 01 22 	call	0x4402	; 0x4402 <searchNextFreeCluster>
    4fac:	6b 01       	movw	r12, r22
    4fae:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    4fb0:	6b 85       	ldd	r22, Y+11	; 0x0b
    4fb2:	7c 85       	ldd	r23, Y+12	; 0x0c
    4fb4:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fb6:	9e 85       	ldd	r25, Y+14	; 0x0e
    4fb8:	41 e0       	ldi	r20, 0x01	; 1
    4fba:	97 01       	movw	r18, r14
    4fbc:	86 01       	movw	r16, r12
    4fbe:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    4fc2:	c7 01       	movw	r24, r14
    4fc4:	b6 01       	movw	r22, r12
    4fc6:	41 e0       	ldi	r20, 0x01	; 1
    4fc8:	0f ef       	ldi	r16, 0xFF	; 255
    4fca:	1f ef       	ldi	r17, 0xFF	; 255
    4fcc:	98 01       	movw	r18, r16
    4fce:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    4fd2:	c1 14       	cp	r12, r1
    4fd4:	d1 04       	cpc	r13, r1
    4fd6:	e1 04       	cpc	r14, r1
    4fd8:	f1 04       	cpc	r15, r1
    4fda:	09 f0       	breq	.+2      	; 0x4fde <writeFile+0x556>
    4fdc:	39 cf       	rjmp	.-398    	; 0x4e50 <writeFile+0x3c8>
	   return 4;
    4fde:	84 e0       	ldi	r24, 0x04	; 4
    4fe0:	0b c0       	rjmp	.+22     	; 0x4ff8 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    4fe2:	81 e0       	ldi	r24, 0x01	; 1
    4fe4:	09 c0       	rjmp	.+18     	; 0x4ff8 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    4fe6:	82 e0       	ldi	r24, 0x02	; 2
    4fe8:	07 c0       	rjmp	.+14     	; 0x4ff8 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    4fea:	82 e0       	ldi	r24, 0x02	; 2
    4fec:	05 c0       	rjmp	.+10     	; 0x4ff8 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    4fee:	80 e0       	ldi	r24, 0x00	; 0
    4ff0:	03 c0       	rjmp	.+6      	; 0x4ff8 <writeFile+0x570>
    4ff2:	80 e0       	ldi	r24, 0x00	; 0
    4ff4:	01 c0       	rjmp	.+2      	; 0x4ff8 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    4ff6:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    4ff8:	60 96       	adiw	r28, 0x10	; 16
    4ffa:	cd bf       	out	0x3d, r28	; 61
    4ffc:	de bf       	out	0x3e, r29	; 62
    4ffe:	df 91       	pop	r29
    5000:	cf 91       	pop	r28
    5002:	1f 91       	pop	r17
    5004:	0f 91       	pop	r16
    5006:	ff 90       	pop	r15
    5008:	ef 90       	pop	r14
    500a:	df 90       	pop	r13
    500c:	cf 90       	pop	r12
    500e:	bf 90       	pop	r11
    5010:	af 90       	pop	r10
    5012:	9f 90       	pop	r9
    5014:	8f 90       	pop	r8
    5016:	7f 90       	pop	r7
    5018:	6f 90       	pop	r6
    501a:	5f 90       	pop	r5
    501c:	4f 90       	pop	r4
    501e:	3f 90       	pop	r3
    5020:	2f 90       	pop	r2
    5022:	08 95       	ret

00005024 <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    5024:	8f 92       	push	r8
    5026:	9f 92       	push	r9
    5028:	af 92       	push	r10
    502a:	bf 92       	push	r11
    502c:	cf 92       	push	r12
    502e:	df 92       	push	r13
    5030:	ef 92       	push	r14
    5032:	ff 92       	push	r15
    5034:	0f 93       	push	r16
    5036:	1f 93       	push	r17
    5038:	cf 93       	push	r28
    503a:	df 93       	push	r29
    503c:	84 2e       	mov	r8, r20
    503e:	a5 2e       	mov	r10, r21
    5040:	c6 2e       	mov	r12, r22
    5042:	c7 2f       	mov	r28, r23
    5044:	d2 2f       	mov	r29, r18
    5046:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    5048:	80 64       	ori	r24, 0x40	; 64
    504a:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    504e:	8c 2f       	mov	r24, r28
    5050:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    5054:	8c 2d       	mov	r24, r12
    5056:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    505a:	8a 2d       	mov	r24, r10
    505c:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5060:	88 2d       	mov	r24, r8
    5062:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
	SPI_write(crc);
    5066:	8d 2f       	mov	r24, r29
    5068:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
	
	for(int i=0; i<read; i++){
    506c:	10 16       	cp	r1, r16
    506e:	11 06       	cpc	r1, r17
    5070:	64 f5       	brge	.+88     	; 0x50ca <SD_command+0xa6>
    5072:	00 e0       	ldi	r16, 0x00	; 0
    5074:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    5076:	0f 2e       	mov	r0, r31
    5078:	fd e0       	ldi	r31, 0x0D	; 13
    507a:	cf 2e       	mov	r12, r31
    507c:	dd 24       	eor	r13, r13
    507e:	f0 2d       	mov	r31, r0
    5080:	0f 2e       	mov	r0, r31
    5082:	f5 e3       	ldi	r31, 0x35	; 53
    5084:	af 2e       	mov	r10, r31
    5086:	fe e3       	ldi	r31, 0x3E	; 62
    5088:	bf 2e       	mov	r11, r31
    508a:	f0 2d       	mov	r31, r0
    508c:	c8 01       	movw	r24, r16
    508e:	b6 01       	movw	r22, r12
    5090:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    5094:	ec 01       	movw	r28, r24
    5096:	8f ef       	ldi	r24, 0xFF	; 255
    5098:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    509c:	f5 01       	movw	r30, r10
    509e:	ec 0f       	add	r30, r28
    50a0:	fd 1f       	adc	r31, r29
    50a2:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    50a4:	80 81       	ld	r24, Z
    50a6:	8f 3f       	cpi	r24, 0xFF	; 255
    50a8:	49 f0       	breq	.+18     	; 0x50bc <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    50aa:	fe 01       	movw	r30, r28
    50ac:	eb 5c       	subi	r30, 0xCB	; 203
    50ae:	f1 4c       	sbci	r31, 0xC1	; 193
    50b0:	80 81       	ld	r24, Z
    50b2:	80 93 36 3e 	sts	0x3E36, r24
			return Buffer[1];
    50b6:	80 91 36 3e 	lds	r24, 0x3E36
    50ba:	08 c0       	rjmp	.+16     	; 0x50cc <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    50bc:	0f 5f       	subi	r16, 0xFF	; 255
    50be:	1f 4f       	sbci	r17, 0xFF	; 255
    50c0:	0e 15       	cp	r16, r14
    50c2:	1f 05       	cpc	r17, r15
    50c4:	19 f7       	brne	.-58     	; 0x508c <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    50c6:	8f ef       	ldi	r24, 0xFF	; 255
    50c8:	01 c0       	rjmp	.+2      	; 0x50cc <SD_command+0xa8>
    50ca:	8f ef       	ldi	r24, 0xFF	; 255
}
    50cc:	df 91       	pop	r29
    50ce:	cf 91       	pop	r28
    50d0:	1f 91       	pop	r17
    50d2:	0f 91       	pop	r16
    50d4:	ff 90       	pop	r15
    50d6:	ef 90       	pop	r14
    50d8:	df 90       	pop	r13
    50da:	cf 90       	pop	r12
    50dc:	bf 90       	pop	r11
    50de:	af 90       	pop	r10
    50e0:	9f 90       	pop	r9
    50e2:	8f 90       	pop	r8
    50e4:	08 95       	ret

000050e6 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    50e6:	ff 92       	push	r15
    50e8:	0f 93       	push	r16
    50ea:	1f 93       	push	r17
    50ec:	cf 93       	push	r28
    50ee:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    50f0:	81 e0       	ldi	r24, 0x01	; 1
    50f2:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    50f6:	81 e0       	ldi	r24, 0x01	; 1
    50f8:	0e 94 3d 04 	call	0x87a	; 0x87a <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    50fc:	8f ef       	ldi	r24, 0xFF	; 255
    50fe:	93 ec       	ldi	r25, 0xC3	; 195
    5100:	a9 e0       	ldi	r26, 0x09	; 9
    5102:	81 50       	subi	r24, 0x01	; 1
    5104:	90 40       	sbci	r25, 0x00	; 0
    5106:	a0 40       	sbci	r26, 0x00	; 0
    5108:	e1 f7       	brne	.-8      	; 0x5102 <SD_init+0x1c>
    510a:	00 c0       	rjmp	.+0      	; 0x510c <SD_init+0x26>
    510c:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    510e:	88 e0       	ldi	r24, 0x08	; 8
    5110:	60 e0       	ldi	r22, 0x00	; 0
    5112:	0e 94 40 06 	call	0xc80	; 0xc80 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    5116:	88 e0       	ldi	r24, 0x08	; 8
    5118:	60 e0       	ldi	r22, 0x00	; 0
    511a:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    511e:	80 e0       	ldi	r24, 0x00	; 0
    5120:	63 e0       	ldi	r22, 0x03	; 3
    5122:	0e 94 b1 04 	call	0x962	; 0x962 <SPIInit2>
	SPICS(TRUE);
    5126:	81 e0       	ldi	r24, 0x01	; 1
    5128:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
    512c:	8a e0       	ldi	r24, 0x0A	; 10
    512e:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5130:	e0 ec       	ldi	r30, 0xC0	; 192
    5132:	f8 e0       	ldi	r31, 0x08	; 8
    5134:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    5136:	a1 e4       	ldi	r26, 0x41	; 65
    5138:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    513a:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    513c:	22 81       	ldd	r18, Z+2	; 0x02
    513e:	22 23       	and	r18, r18
    5140:	ec f7       	brge	.-6      	; 0x513c <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    5142:	23 81       	ldd	r18, Z+3	; 0x03
    5144:	2c 93       	st	X, r18
    5146:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    5148:	c1 f7       	brne	.-16     	; 0x513a <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    514a:	80 e0       	ldi	r24, 0x00	; 0
    514c:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    5150:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5154:	88 e0       	ldi	r24, 0x08	; 8
    5156:	60 e0       	ldi	r22, 0x00	; 0
    5158:	0e 94 3c 05 	call	0xa78	; 0xa78 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    515c:	80 e0       	ldi	r24, 0x00	; 0
    515e:	63 e0       	ldi	r22, 0x03	; 3
    5160:	0e 94 b1 04 	call	0x962	; 0x962 <SPIInit2>
	SPICS(TRUE);
    5164:	81 e0       	ldi	r24, 0x01	; 1
    5166:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    516a:	cb e0       	ldi	r28, 0x0B	; 11
    516c:	d0 e0       	ldi	r29, 0x00	; 0
    516e:	02 c0       	rjmp	.+4      	; 0x5174 <SD_init+0x8e>
    5170:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    5172:	69 f0       	breq	.+26     	; 0x518e <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    5174:	80 e0       	ldi	r24, 0x00	; 0
    5176:	40 e0       	ldi	r20, 0x00	; 0
    5178:	50 e0       	ldi	r21, 0x00	; 0
    517a:	ba 01       	movw	r22, r20
    517c:	25 e9       	ldi	r18, 0x95	; 149
    517e:	08 e0       	ldi	r16, 0x08	; 8
    5180:	10 e0       	ldi	r17, 0x00	; 0
    5182:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
    5186:	81 30       	cpi	r24, 0x01	; 1
    5188:	99 f7       	brne	.-26     	; 0x5170 <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    518a:	ff 24       	eor	r15, r15
    518c:	02 c0       	rjmp	.+4      	; 0x5192 <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    518e:	ff 24       	eor	r15, r15
    5190:	f3 94       	inc	r15
    5192:	8f ef       	ldi	r24, 0xFF	; 255
    5194:	93 ec       	ldi	r25, 0xC3	; 195
    5196:	a9 e0       	ldi	r26, 0x09	; 9
    5198:	81 50       	subi	r24, 0x01	; 1
    519a:	90 40       	sbci	r25, 0x00	; 0
    519c:	a0 40       	sbci	r26, 0x00	; 0
    519e:	e1 f7       	brne	.-8      	; 0x5198 <SD_init+0xb2>
    51a0:	00 c0       	rjmp	.+0      	; 0x51a2 <SD_init+0xbc>
    51a2:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    51a4:	cb e0       	ldi	r28, 0x0B	; 11
    51a6:	d0 e0       	ldi	r29, 0x00	; 0
    51a8:	02 c0       	rjmp	.+4      	; 0x51ae <SD_init+0xc8>
    51aa:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    51ac:	69 f0       	breq	.+26     	; 0x51c8 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    51ae:	88 e0       	ldi	r24, 0x08	; 8
    51b0:	4a ea       	ldi	r20, 0xAA	; 170
    51b2:	51 e0       	ldi	r21, 0x01	; 1
    51b4:	60 e0       	ldi	r22, 0x00	; 0
    51b6:	70 e0       	ldi	r23, 0x00	; 0
    51b8:	27 e8       	ldi	r18, 0x87	; 135
    51ba:	08 e0       	ldi	r16, 0x08	; 8
    51bc:	10 e0       	ldi	r17, 0x00	; 0
    51be:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
    51c2:	81 30       	cpi	r24, 0x01	; 1
    51c4:	91 f7       	brne	.-28     	; 0x51aa <SD_init+0xc4>
    51c6:	02 c0       	rjmp	.+4      	; 0x51cc <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    51c8:	ff 24       	eor	r15, r15
    51ca:	f3 94       	inc	r15
    51cc:	c2 e0       	ldi	r28, 0x02	; 2
    51ce:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    51d0:	05 e3       	ldi	r16, 0x35	; 53
    51d2:	1e e3       	ldi	r17, 0x3E	; 62
    51d4:	8f ef       	ldi	r24, 0xFF	; 255
    51d6:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    51da:	f8 01       	movw	r30, r16
    51dc:	ec 0f       	add	r30, r28
    51de:	fd 1f       	adc	r31, r29
    51e0:	80 83       	st	Z, r24
    51e2:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    51e4:	c6 30       	cpi	r28, 0x06	; 6
    51e6:	d1 05       	cpc	r29, r1
    51e8:	a9 f7       	brne	.-22     	; 0x51d4 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    51ea:	80 91 39 3e 	lds	r24, 0x3E39
    51ee:	81 30       	cpi	r24, 0x01	; 1
    51f0:	29 f4       	brne	.+10     	; 0x51fc <SD_init+0x116>
    51f2:	80 91 3a 3e 	lds	r24, 0x3E3A
    51f6:	8a 3a       	cpi	r24, 0xAA	; 170
    51f8:	21 f4       	brne	.+8      	; 0x5202 <SD_init+0x11c>
    51fa:	05 c0       	rjmp	.+10     	; 0x5206 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    51fc:	ff 24       	eor	r15, r15
    51fe:	f3 94       	inc	r15
    5200:	02 c0       	rjmp	.+4      	; 0x5206 <SD_init+0x120>
    5202:	ff 24       	eor	r15, r15
    5204:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    5206:	c6 e3       	ldi	r28, 0x36	; 54
    5208:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    520a:	87 e3       	ldi	r24, 0x37	; 55
    520c:	40 e0       	ldi	r20, 0x00	; 0
    520e:	50 e0       	ldi	r21, 0x00	; 0
    5210:	ba 01       	movw	r22, r20
    5212:	2f ef       	ldi	r18, 0xFF	; 255
    5214:	08 e0       	ldi	r16, 0x08	; 8
    5216:	10 e0       	ldi	r17, 0x00	; 0
    5218:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    521c:	81 e0       	ldi	r24, 0x01	; 1
    521e:	40 e0       	ldi	r20, 0x00	; 0
    5220:	50 e0       	ldi	r21, 0x00	; 0
    5222:	60 e0       	ldi	r22, 0x00	; 0
    5224:	70 e4       	ldi	r23, 0x40	; 64
    5226:	2f ef       	ldi	r18, 0xFF	; 255
    5228:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
	} while(Buffer[1]!= 0x00);	
    522c:	88 81       	ld	r24, Y
    522e:	88 23       	and	r24, r24
    5230:	61 f7       	brne	.-40     	; 0x520a <SD_init+0x124>
    5232:	cb e0       	ldi	r28, 0x0B	; 11
    5234:	d0 e0       	ldi	r29, 0x00	; 0
    5236:	02 c0       	rjmp	.+4      	; 0x523c <SD_init+0x156>
    5238:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    523a:	61 f0       	breq	.+24     	; 0x5254 <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    523c:	8a e3       	ldi	r24, 0x3A	; 58
    523e:	40 e0       	ldi	r20, 0x00	; 0
    5240:	50 e0       	ldi	r21, 0x00	; 0
    5242:	ba 01       	movw	r22, r20
    5244:	2f ef       	ldi	r18, 0xFF	; 255
    5246:	08 e0       	ldi	r16, 0x08	; 8
    5248:	10 e0       	ldi	r17, 0x00	; 0
    524a:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
    524e:	88 23       	and	r24, r24
    5250:	99 f7       	brne	.-26     	; 0x5238 <SD_init+0x152>
    5252:	02 c0       	rjmp	.+4      	; 0x5258 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5254:	ff 24       	eor	r15, r15
    5256:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5258:	c0 e0       	ldi	r28, 0x00	; 0
    525a:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    525c:	05 e3       	ldi	r16, 0x35	; 53
    525e:	1e e3       	ldi	r17, 0x3E	; 62
    5260:	8f ef       	ldi	r24, 0xFF	; 255
    5262:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5266:	f8 01       	movw	r30, r16
    5268:	ec 0f       	add	r30, r28
    526a:	fd 1f       	adc	r31, r29
    526c:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    526e:	21 96       	adiw	r28, 0x01	; 1
    5270:	c4 30       	cpi	r28, 0x04	; 4
    5272:	d1 05       	cpc	r29, r1
    5274:	a9 f7       	brne	.-22     	; 0x5260 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5276:	80 91 35 3e 	lds	r24, 0x3E35
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    527a:	80 e0       	ldi	r24, 0x00	; 0
    527c:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    5280:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5284:	88 e0       	ldi	r24, 0x08	; 8
    5286:	60 e0       	ldi	r22, 0x00	; 0
    5288:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
	
	return errorCode;					
}
    528c:	8f 2d       	mov	r24, r15
    528e:	df 91       	pop	r29
    5290:	cf 91       	pop	r28
    5292:	1f 91       	pop	r17
    5294:	0f 91       	pop	r16
    5296:	ff 90       	pop	r15
    5298:	08 95       	ret

0000529a <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    529a:	6f 92       	push	r6
    529c:	7f 92       	push	r7
    529e:	8f 92       	push	r8
    52a0:	9f 92       	push	r9
    52a2:	af 92       	push	r10
    52a4:	bf 92       	push	r11
    52a6:	cf 92       	push	r12
    52a8:	df 92       	push	r13
    52aa:	ef 92       	push	r14
    52ac:	ff 92       	push	r15
    52ae:	0f 93       	push	r16
    52b0:	1f 93       	push	r17
    52b2:	cf 93       	push	r28
    52b4:	df 93       	push	r29
    52b6:	4b 01       	movw	r8, r22
    52b8:	5c 01       	movw	r10, r24
    52ba:	74 2e       	mov	r7, r20
    52bc:	65 2e       	mov	r6, r21
    52be:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    52c0:	88 e0       	ldi	r24, 0x08	; 8
    52c2:	60 e0       	ldi	r22, 0x00	; 0
    52c4:	0e 94 3c 05 	call	0xa78	; 0xa78 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    52c8:	80 e0       	ldi	r24, 0x00	; 0
    52ca:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
    52ce:	81 e0       	ldi	r24, 0x01	; 1
    52d0:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    52d4:	80 e0       	ldi	r24, 0x00	; 0
    52d6:	92 e0       	ldi	r25, 0x02	; 2
    52d8:	7c 01       	movw	r14, r24
    52da:	ec 18       	sub	r14, r12
    52dc:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    52de:	80 e0       	ldi	r24, 0x00	; 0
    52e0:	e8 16       	cp	r14, r24
    52e2:	82 e0       	ldi	r24, 0x02	; 2
    52e4:	f8 06       	cpc	r15, r24
    52e6:	11 f4       	brne	.+4      	; 0x52ec <SD_write_block+0x52>
    52e8:	ee 24       	eor	r14, r14
    52ea:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    52ec:	cb e0       	ldi	r28, 0x0B	; 11
    52ee:	d0 e0       	ldi	r29, 0x00	; 0
    52f0:	03 c0       	rjmp	.+6      	; 0x52f8 <SD_write_block+0x5e>
    52f2:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    52f4:	09 f4       	brne	.+2      	; 0x52f8 <SD_write_block+0x5e>
    52f6:	ff cf       	rjmp	.-2      	; 0x52f6 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    52f8:	88 e1       	ldi	r24, 0x18	; 24
    52fa:	b5 01       	movw	r22, r10
    52fc:	a4 01       	movw	r20, r8
    52fe:	2f ef       	ldi	r18, 0xFF	; 255
    5300:	08 e0       	ldi	r16, 0x08	; 8
    5302:	10 e0       	ldi	r17, 0x00	; 0
    5304:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
    5308:	88 23       	and	r24, r24
    530a:	99 f7       	brne	.-26     	; 0x52f2 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    530c:	8f ef       	ldi	r24, 0xFF	; 255
    530e:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5312:	80 93 35 3e 	sts	0x3E35, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    5316:	8e ef       	ldi	r24, 0xFE	; 254
    5318:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    531c:	1c 14       	cp	r1, r12
    531e:	1d 04       	cpc	r1, r13
    5320:	bc f4       	brge	.+46     	; 0x5350 <SD_write_block+0xb6>
    5322:	87 2c       	mov	r8, r7
    5324:	96 2c       	mov	r9, r6
    5326:	00 e0       	ldi	r16, 0x00	; 0
    5328:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    532a:	c8 01       	movw	r24, r16
    532c:	6d e0       	ldi	r22, 0x0D	; 13
    532e:	70 e0       	ldi	r23, 0x00	; 0
    5330:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    5334:	ec 01       	movw	r28, r24
    5336:	f4 01       	movw	r30, r8
    5338:	81 91       	ld	r24, Z+
    533a:	4f 01       	movw	r8, r30
    533c:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5340:	cb 5c       	subi	r28, 0xCB	; 203
    5342:	d1 4c       	sbci	r29, 0xC1	; 193
    5344:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5346:	0f 5f       	subi	r16, 0xFF	; 255
    5348:	1f 4f       	sbci	r17, 0xFF	; 255
    534a:	0c 15       	cp	r16, r12
    534c:	1d 05       	cpc	r17, r13
    534e:	69 f7       	brne	.-38     	; 0x532a <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5350:	1e 14       	cp	r1, r14
    5352:	1f 04       	cpc	r1, r15
    5354:	ec f4       	brge	.+58     	; 0x5390 <SD_write_block+0xf6>
    5356:	00 e0       	ldi	r16, 0x00	; 0
    5358:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    535a:	0f 2e       	mov	r0, r31
    535c:	fd e0       	ldi	r31, 0x0D	; 13
    535e:	cf 2e       	mov	r12, r31
    5360:	dd 24       	eor	r13, r13
    5362:	f0 2d       	mov	r31, r0
    5364:	0f 2e       	mov	r0, r31
    5366:	f5 e3       	ldi	r31, 0x35	; 53
    5368:	8f 2e       	mov	r8, r31
    536a:	fe e3       	ldi	r31, 0x3E	; 62
    536c:	9f 2e       	mov	r9, r31
    536e:	f0 2d       	mov	r31, r0
    5370:	c8 01       	movw	r24, r16
    5372:	b6 01       	movw	r22, r12
    5374:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    5378:	ec 01       	movw	r28, r24
    537a:	80 e0       	ldi	r24, 0x00	; 0
    537c:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5380:	c8 0d       	add	r28, r8
    5382:	d9 1d       	adc	r29, r9
    5384:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5386:	0f 5f       	subi	r16, 0xFF	; 255
    5388:	1f 4f       	sbci	r17, 0xFF	; 255
    538a:	0e 15       	cp	r16, r14
    538c:	1f 05       	cpc	r17, r15
    538e:	81 f7       	brne	.-32     	; 0x5370 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    5390:	8f ef       	ldi	r24, 0xFF	; 255
    5392:	80 93 35 3e 	sts	0x3E35, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5396:	c0 e0       	ldi	r28, 0x00	; 0
    5398:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    539a:	05 e3       	ldi	r16, 0x35	; 53
    539c:	1e e3       	ldi	r17, 0x3E	; 62
    539e:	8f ef       	ldi	r24, 0xFF	; 255
    53a0:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    53a4:	f8 01       	movw	r30, r16
    53a6:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    53a8:	21 96       	adiw	r28, 0x01	; 1
    53aa:	c2 30       	cpi	r28, 0x02	; 2
    53ac:	d1 05       	cpc	r29, r1
    53ae:	bc f3       	brlt	.-18     	; 0x539e <SD_write_block+0x104>
    53b0:	80 81       	ld	r24, Z
    53b2:	8f 3f       	cpi	r24, 0xFF	; 255
    53b4:	a1 f3       	breq	.-24     	; 0x539e <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    53b6:	80 91 35 3e 	lds	r24, 0x3E35
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    53ba:	80 91 35 3e 	lds	r24, 0x3E35
    53be:	8f 3f       	cpi	r24, 0xFF	; 255
    53c0:	49 f0       	breq	.+18     	; 0x53d4 <SD_write_block+0x13a>
    53c2:	c5 e3       	ldi	r28, 0x35	; 53
    53c4:	de e3       	ldi	r29, 0x3E	; 62
    53c6:	8f ef       	ldi	r24, 0xFF	; 255
    53c8:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    53cc:	88 83       	st	Y, r24
    53ce:	88 81       	ld	r24, Y
    53d0:	8f 3f       	cpi	r24, 0xFF	; 255
    53d2:	c9 f7       	brne	.-14     	; 0x53c6 <SD_write_block+0x12c>
	SPICS(FALSE);
    53d4:	80 e0       	ldi	r24, 0x00	; 0
    53d6:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    53da:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    53de:	88 e0       	ldi	r24, 0x08	; 8
    53e0:	60 e0       	ldi	r22, 0x00	; 0
    53e2:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
}
    53e6:	df 91       	pop	r29
    53e8:	cf 91       	pop	r28
    53ea:	1f 91       	pop	r17
    53ec:	0f 91       	pop	r16
    53ee:	ff 90       	pop	r15
    53f0:	ef 90       	pop	r14
    53f2:	df 90       	pop	r13
    53f4:	cf 90       	pop	r12
    53f6:	bf 90       	pop	r11
    53f8:	af 90       	pop	r10
    53fa:	9f 90       	pop	r9
    53fc:	8f 90       	pop	r8
    53fe:	7f 90       	pop	r7
    5400:	6f 90       	pop	r6
    5402:	08 95       	ret

00005404 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    5404:	af 92       	push	r10
    5406:	bf 92       	push	r11
    5408:	cf 92       	push	r12
    540a:	df 92       	push	r13
    540c:	ef 92       	push	r14
    540e:	ff 92       	push	r15
    5410:	0f 93       	push	r16
    5412:	1f 93       	push	r17
    5414:	cf 93       	push	r28
    5416:	df 93       	push	r29
    5418:	6b 01       	movw	r12, r22
    541a:	7c 01       	movw	r14, r24
    541c:	b4 2e       	mov	r11, r20
    541e:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5420:	88 e0       	ldi	r24, 0x08	; 8
    5422:	60 e0       	ldi	r22, 0x00	; 0
    5424:	0e 94 3c 05 	call	0xa78	; 0xa78 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5428:	80 e0       	ldi	r24, 0x00	; 0
    542a:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
    542e:	81 e0       	ldi	r24, 0x01	; 1
    5430:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5434:	cb e0       	ldi	r28, 0x0B	; 11
    5436:	d0 e0       	ldi	r29, 0x00	; 0
    5438:	03 c0       	rjmp	.+6      	; 0x5440 <SD_read_block+0x3c>
    543a:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    543c:	09 f4       	brne	.+2      	; 0x5440 <SD_read_block+0x3c>
    543e:	ff cf       	rjmp	.-2      	; 0x543e <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5440:	81 e1       	ldi	r24, 0x11	; 17
    5442:	b7 01       	movw	r22, r14
    5444:	a6 01       	movw	r20, r12
    5446:	2f ef       	ldi	r18, 0xFF	; 255
    5448:	08 e0       	ldi	r16, 0x08	; 8
    544a:	10 e0       	ldi	r17, 0x00	; 0
    544c:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
    5450:	88 23       	and	r24, r24
    5452:	99 f7       	brne	.-26     	; 0x543a <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5454:	80 91 35 3e 	lds	r24, 0x3E35
    5458:	8e 3f       	cpi	r24, 0xFE	; 254
    545a:	49 f0       	breq	.+18     	; 0x546e <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    545c:	c5 e3       	ldi	r28, 0x35	; 53
    545e:	de e3       	ldi	r29, 0x3E	; 62
    5460:	8f ef       	ldi	r24, 0xFF	; 255
    5462:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5466:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5468:	88 81       	ld	r24, Y
    546a:	8e 3f       	cpi	r24, 0xFE	; 254
    546c:	c9 f7       	brne	.-14     	; 0x5460 <SD_read_block+0x5c>
    546e:	0b 2d       	mov	r16, r11
    5470:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5472:	c0 e0       	ldi	r28, 0x00	; 0
    5474:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5476:	8f ef       	ldi	r24, 0xFF	; 255
    5478:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    547c:	f8 01       	movw	r30, r16
    547e:	81 93       	st	Z+, r24
    5480:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5482:	21 96       	adiw	r28, 0x01	; 1
    5484:	f2 e0       	ldi	r31, 0x02	; 2
    5486:	c0 30       	cpi	r28, 0x00	; 0
    5488:	df 07       	cpc	r29, r31
    548a:	a9 f7       	brne	.-22     	; 0x5476 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    548c:	10 92 41 3e 	sts	0x3E41, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5490:	80 91 41 3e 	lds	r24, 0x3E41
    5494:	8f 3f       	cpi	r24, 0xFF	; 255
    5496:	49 f0       	breq	.+18     	; 0x54aa <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5498:	c1 e4       	ldi	r28, 0x41	; 65
    549a:	de e3       	ldi	r29, 0x3E	; 62
    549c:	8f ef       	ldi	r24, 0xFF	; 255
    549e:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    54a2:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    54a4:	88 81       	ld	r24, Y
    54a6:	8f 3f       	cpi	r24, 0xFF	; 255
    54a8:	c9 f7       	brne	.-14     	; 0x549c <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    54aa:	80 e0       	ldi	r24, 0x00	; 0
    54ac:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    54b0:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    54b4:	88 e0       	ldi	r24, 0x08	; 8
    54b6:	60 e0       	ldi	r22, 0x00	; 0
    54b8:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
}
    54bc:	df 91       	pop	r29
    54be:	cf 91       	pop	r28
    54c0:	1f 91       	pop	r17
    54c2:	0f 91       	pop	r16
    54c4:	ff 90       	pop	r15
    54c6:	ef 90       	pop	r14
    54c8:	df 90       	pop	r13
    54ca:	cf 90       	pop	r12
    54cc:	bf 90       	pop	r11
    54ce:	af 90       	pop	r10
    54d0:	08 95       	ret

000054d2 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    54d2:	2f 92       	push	r2
    54d4:	3f 92       	push	r3
    54d6:	4f 92       	push	r4
    54d8:	5f 92       	push	r5
    54da:	6f 92       	push	r6
    54dc:	7f 92       	push	r7
    54de:	8f 92       	push	r8
    54e0:	9f 92       	push	r9
    54e2:	af 92       	push	r10
    54e4:	bf 92       	push	r11
    54e6:	cf 92       	push	r12
    54e8:	df 92       	push	r13
    54ea:	ef 92       	push	r14
    54ec:	ff 92       	push	r15
    54ee:	0f 93       	push	r16
    54f0:	1f 93       	push	r17
    54f2:	cf 93       	push	r28
    54f4:	df 93       	push	r29
    54f6:	cd b7       	in	r28, 0x3d	; 61
    54f8:	de b7       	in	r29, 0x3e	; 62
    54fa:	2a 97       	sbiw	r28, 0x0a	; 10
    54fc:	cd bf       	out	0x3d, r28	; 61
    54fe:	de bf       	out	0x3e, r29	; 62
    5500:	6b 01       	movw	r12, r22
    5502:	7c 01       	movw	r14, r24
    5504:	4f 83       	std	Y+7, r20	; 0x07
    5506:	58 87       	std	Y+8, r21	; 0x08
    5508:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    550a:	88 e0       	ldi	r24, 0x08	; 8
    550c:	60 e0       	ldi	r22, 0x00	; 0
    550e:	0e 94 3c 05 	call	0xa78	; 0xa78 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5512:	80 e0       	ldi	r24, 0x00	; 0
    5514:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
    5518:	81 e0       	ldi	r24, 0x01	; 1
    551a:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    551e:	c8 01       	movw	r24, r16
    5520:	11 23       	and	r17, r17
    5522:	14 f4       	brge	.+4      	; 0x5528 <SD_write_multiple_blocks+0x56>
    5524:	81 50       	subi	r24, 0x01	; 1
    5526:	9e 4f       	sbci	r25, 0xFE	; 254
    5528:	9c 01       	movw	r18, r24
    552a:	23 2f       	mov	r18, r19
    552c:	33 0f       	add	r19, r19
    552e:	33 0b       	sbc	r19, r19
    5530:	25 95       	asr	r18
    5532:	2b 83       	std	Y+3, r18	; 0x03
    5534:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5536:	20 e0       	ldi	r18, 0x00	; 0
    5538:	32 e0       	ldi	r19, 0x02	; 2
    553a:	c8 01       	movw	r24, r16
    553c:	b9 01       	movw	r22, r18
    553e:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    5542:	29 01       	movw	r4, r18
    5544:	48 1a       	sub	r4, r24
    5546:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5548:	30 e0       	ldi	r19, 0x00	; 0
    554a:	43 16       	cp	r4, r19
    554c:	32 e0       	ldi	r19, 0x02	; 2
    554e:	53 06       	cpc	r5, r19
    5550:	31 f0       	breq	.+12     	; 0x555e <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5552:	8b 81       	ldd	r24, Y+3	; 0x03
    5554:	9c 81       	ldd	r25, Y+4	; 0x04
    5556:	01 96       	adiw	r24, 0x01	; 1
    5558:	8b 83       	std	Y+3, r24	; 0x03
    555a:	9c 83       	std	Y+4, r25	; 0x04
    555c:	02 c0       	rjmp	.+4      	; 0x5562 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    555e:	44 24       	eor	r4, r4
    5560:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5562:	89 e1       	ldi	r24, 0x19	; 25
    5564:	b7 01       	movw	r22, r14
    5566:	a6 01       	movw	r20, r12
    5568:	2f ef       	ldi	r18, 0xFF	; 255
    556a:	08 e0       	ldi	r16, 0x08	; 8
    556c:	10 e0       	ldi	r17, 0x00	; 0
    556e:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
    5572:	88 23       	and	r24, r24
    5574:	b1 f7       	brne	.-20     	; 0x5562 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5576:	eb 81       	ldd	r30, Y+3	; 0x03
    5578:	fc 81       	ldd	r31, Y+4	; 0x04
    557a:	1e 16       	cp	r1, r30
    557c:	1f 06       	cpc	r1, r31
    557e:	0c f0       	brlt	.+2      	; 0x5582 <SD_write_multiple_blocks+0xb0>
    5580:	ac c0       	rjmp	.+344    	; 0x56da <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5582:	31 97       	sbiw	r30, 0x01	; 1
    5584:	ed 83       	std	Y+5, r30	; 0x05
    5586:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5588:	9f 01       	movw	r18, r30
    558a:	32 2f       	mov	r19, r18
    558c:	22 27       	eor	r18, r18
    558e:	33 0f       	add	r19, r19
    5590:	8f 81       	ldd	r24, Y+7	; 0x07
    5592:	98 85       	ldd	r25, Y+8	; 0x08
    5594:	89 83       	std	Y+1, r24	; 0x01
    5596:	9a 83       	std	Y+2, r25	; 0x02
    5598:	66 24       	eor	r6, r6
    559a:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    559c:	0f 2e       	mov	r0, r31
    559e:	f6 e3       	ldi	r31, 0x36	; 54
    55a0:	8f 2e       	mov	r8, r31
    55a2:	fe e3       	ldi	r31, 0x3E	; 62
    55a4:	9f 2e       	mov	r9, r31
    55a6:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    55a8:	0f 2e       	mov	r0, r31
    55aa:	fc e0       	ldi	r31, 0x0C	; 12
    55ac:	cf 2e       	mov	r12, r31
    55ae:	dd 24       	eor	r13, r13
    55b0:	f0 2d       	mov	r31, r0
    55b2:	0f 2e       	mov	r0, r31
    55b4:	f5 e3       	ldi	r31, 0x35	; 53
    55b6:	af 2e       	mov	r10, r31
    55b8:	fe e3       	ldi	r31, 0x3E	; 62
    55ba:	bf 2e       	mov	r11, r31
    55bc:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    55be:	80 e0       	ldi	r24, 0x00	; 0
    55c0:	92 e0       	ldi	r25, 0x02	; 2
    55c2:	1c 01       	movw	r2, r24
    55c4:	24 18       	sub	r2, r4
    55c6:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    55c8:	ef 81       	ldd	r30, Y+7	; 0x07
    55ca:	f8 85       	ldd	r31, Y+8	; 0x08
    55cc:	e2 0f       	add	r30, r18
    55ce:	f3 1f       	adc	r31, r19
    55d0:	ef 83       	std	Y+7, r30	; 0x07
    55d2:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    55d4:	8f ef       	ldi	r24, 0xFF	; 255
    55d6:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    55da:	f4 01       	movw	r30, r8
    55dc:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    55de:	8c ef       	ldi	r24, 0xFC	; 252
    55e0:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    55e4:	f4 01       	movw	r30, r8
    55e6:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    55e8:	2d 81       	ldd	r18, Y+5	; 0x05
    55ea:	3e 81       	ldd	r19, Y+6	; 0x06
    55ec:	26 15       	cp	r18, r6
    55ee:	37 05       	cpc	r19, r7
    55f0:	09 f0       	breq	.+2      	; 0x55f4 <SD_write_multiple_blocks+0x122>
    55f2:	41 c0       	rjmp	.+130    	; 0x5676 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    55f4:	12 14       	cp	r1, r2
    55f6:	13 04       	cpc	r1, r3
    55f8:	cc f4       	brge	.+50     	; 0x562c <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    55fa:	ef 80       	ldd	r14, Y+7	; 0x07
    55fc:	f8 84       	ldd	r15, Y+8	; 0x08
    55fe:	00 e0       	ldi	r16, 0x00	; 0
    5600:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5602:	c8 01       	movw	r24, r16
    5604:	b6 01       	movw	r22, r12
    5606:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    560a:	89 87       	std	Y+9, r24	; 0x09
    560c:	9a 87       	std	Y+10, r25	; 0x0a
    560e:	f7 01       	movw	r30, r14
    5610:	81 91       	ld	r24, Z+
    5612:	7f 01       	movw	r14, r30
    5614:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5618:	e9 85       	ldd	r30, Y+9	; 0x09
    561a:	fa 85       	ldd	r31, Y+10	; 0x0a
    561c:	ea 0d       	add	r30, r10
    561e:	fb 1d       	adc	r31, r11
    5620:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5622:	0f 5f       	subi	r16, 0xFF	; 255
    5624:	1f 4f       	sbci	r17, 0xFF	; 255
    5626:	02 15       	cp	r16, r2
    5628:	13 05       	cpc	r17, r3
    562a:	59 f7       	brne	.-42     	; 0x5602 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    562c:	14 14       	cp	r1, r4
    562e:	15 04       	cpc	r1, r5
    5630:	9c f4       	brge	.+38     	; 0x5658 <SD_write_multiple_blocks+0x186>
    5632:	00 e0       	ldi	r16, 0x00	; 0
    5634:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5636:	c8 01       	movw	r24, r16
    5638:	b6 01       	movw	r22, r12
    563a:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    563e:	7c 01       	movw	r14, r24
    5640:	80 e0       	ldi	r24, 0x00	; 0
    5642:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5646:	f5 01       	movw	r30, r10
    5648:	ee 0d       	add	r30, r14
    564a:	ff 1d       	adc	r31, r15
    564c:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    564e:	0f 5f       	subi	r16, 0xFF	; 255
    5650:	1f 4f       	sbci	r17, 0xFF	; 255
    5652:	04 15       	cp	r16, r4
    5654:	15 05       	cpc	r17, r5
    5656:	79 f7       	brne	.-34     	; 0x5636 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5658:	8f ef       	ldi	r24, 0xFF	; 255
    565a:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    565e:	f4 01       	movw	r30, r8
    5660:	80 83       	st	Z, r24
    5662:	8f ef       	ldi	r24, 0xFF	; 255
    5664:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5668:	f4 01       	movw	r30, r8
    566a:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    566c:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    566e:	80 81       	ld	r24, Z
    5670:	8f 3f       	cpi	r24, 0xFF	; 255
    5672:	e1 f4       	brne	.+56     	; 0x56ac <SD_write_multiple_blocks+0x1da>
    5674:	23 c0       	rjmp	.+70     	; 0x56bc <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5676:	e9 80       	ldd	r14, Y+1	; 0x01
    5678:	fa 80       	ldd	r15, Y+2	; 0x02
    567a:	00 e0       	ldi	r16, 0x00	; 0
    567c:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    567e:	c8 01       	movw	r24, r16
    5680:	b6 01       	movw	r22, r12
    5682:	0e 94 c7 37 	call	0x6f8e	; 0x6f8e <__divmodhi4>
    5686:	89 87       	std	Y+9, r24	; 0x09
    5688:	9a 87       	std	Y+10, r25	; 0x0a
    568a:	f7 01       	movw	r30, r14
    568c:	81 91       	ld	r24, Z+
    568e:	7f 01       	movw	r14, r30
    5690:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5694:	e9 85       	ldd	r30, Y+9	; 0x09
    5696:	fa 85       	ldd	r31, Y+10	; 0x0a
    5698:	ea 0d       	add	r30, r10
    569a:	fb 1d       	adc	r31, r11
    569c:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    569e:	0f 5f       	subi	r16, 0xFF	; 255
    56a0:	1f 4f       	sbci	r17, 0xFF	; 255
    56a2:	f2 e0       	ldi	r31, 0x02	; 2
    56a4:	00 30       	cpi	r16, 0x00	; 0
    56a6:	1f 07       	cpc	r17, r31
    56a8:	51 f7       	brne	.-44     	; 0x567e <SD_write_multiple_blocks+0x1ac>
    56aa:	d6 cf       	rjmp	.-84     	; 0x5658 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    56ac:	8f ef       	ldi	r24, 0xFF	; 255
    56ae:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    56b2:	f4 01       	movw	r30, r8
    56b4:	80 83       	st	Z, r24
    56b6:	80 81       	ld	r24, Z
    56b8:	8f 3f       	cpi	r24, 0xFF	; 255
    56ba:	c1 f7       	brne	.-16     	; 0x56ac <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    56bc:	08 94       	sec
    56be:	61 1c       	adc	r6, r1
    56c0:	71 1c       	adc	r7, r1
    56c2:	29 81       	ldd	r18, Y+1	; 0x01
    56c4:	3a 81       	ldd	r19, Y+2	; 0x02
    56c6:	20 50       	subi	r18, 0x00	; 0
    56c8:	3e 4f       	sbci	r19, 0xFE	; 254
    56ca:	29 83       	std	Y+1, r18	; 0x01
    56cc:	3a 83       	std	Y+2, r19	; 0x02
    56ce:	8b 81       	ldd	r24, Y+3	; 0x03
    56d0:	9c 81       	ldd	r25, Y+4	; 0x04
    56d2:	68 16       	cp	r6, r24
    56d4:	79 06       	cpc	r7, r25
    56d6:	09 f0       	breq	.+2      	; 0x56da <SD_write_multiple_blocks+0x208>
    56d8:	7d cf       	rjmp	.-262    	; 0x55d4 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    56da:	ee 24       	eor	r14, r14
    56dc:	ff 24       	eor	r15, r15
    56de:	68 94       	set
    56e0:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    56e2:	06 e3       	ldi	r16, 0x36	; 54
    56e4:	1e e3       	ldi	r17, 0x3E	; 62
    56e6:	8f ef       	ldi	r24, 0xFF	; 255
    56e8:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    56ec:	f8 01       	movw	r30, r16
    56ee:	80 83       	st	Z, r24
    56f0:	08 94       	sec
    56f2:	e1 08       	sbc	r14, r1
    56f4:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    56f6:	e1 14       	cp	r14, r1
    56f8:	f1 04       	cpc	r15, r1
    56fa:	a9 f7       	brne	.-22     	; 0x56e6 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    56fc:	8d ef       	ldi	r24, 0xFD	; 253
    56fe:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5702:	80 93 36 3e 	sts	0x3E36, r24
    5706:	ee 24       	eor	r14, r14
    5708:	ff 24       	eor	r15, r15
    570a:	68 94       	set
    570c:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    570e:	06 e3       	ldi	r16, 0x36	; 54
    5710:	1e e3       	ldi	r17, 0x3E	; 62
    5712:	8f ef       	ldi	r24, 0xFF	; 255
    5714:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5718:	f8 01       	movw	r30, r16
    571a:	80 83       	st	Z, r24
    571c:	08 94       	sec
    571e:	e1 08       	sbc	r14, r1
    5720:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5722:	e1 14       	cp	r14, r1
    5724:	f1 04       	cpc	r15, r1
    5726:	a9 f7       	brne	.-22     	; 0x5712 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5728:	10 92 36 3e 	sts	0x3E36, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    572c:	80 91 36 3e 	lds	r24, 0x3E36
    5730:	8f 3f       	cpi	r24, 0xFF	; 255
    5732:	51 f0       	breq	.+20     	; 0x5748 <SD_write_multiple_blocks+0x276>
    5734:	06 e3       	ldi	r16, 0x36	; 54
    5736:	1e e3       	ldi	r17, 0x3E	; 62
    5738:	8f ef       	ldi	r24, 0xFF	; 255
    573a:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    573e:	f8 01       	movw	r30, r16
    5740:	80 83       	st	Z, r24
    5742:	80 81       	ld	r24, Z
    5744:	8f 3f       	cpi	r24, 0xFF	; 255
    5746:	c1 f7       	brne	.-16     	; 0x5738 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5748:	80 e0       	ldi	r24, 0x00	; 0
    574a:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    574e:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5752:	88 e0       	ldi	r24, 0x08	; 8
    5754:	60 e0       	ldi	r22, 0x00	; 0
    5756:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
}
    575a:	2a 96       	adiw	r28, 0x0a	; 10
    575c:	cd bf       	out	0x3d, r28	; 61
    575e:	de bf       	out	0x3e, r29	; 62
    5760:	df 91       	pop	r29
    5762:	cf 91       	pop	r28
    5764:	1f 91       	pop	r17
    5766:	0f 91       	pop	r16
    5768:	ff 90       	pop	r15
    576a:	ef 90       	pop	r14
    576c:	df 90       	pop	r13
    576e:	cf 90       	pop	r12
    5770:	bf 90       	pop	r11
    5772:	af 90       	pop	r10
    5774:	9f 90       	pop	r9
    5776:	8f 90       	pop	r8
    5778:	7f 90       	pop	r7
    577a:	6f 90       	pop	r6
    577c:	5f 90       	pop	r5
    577e:	4f 90       	pop	r4
    5780:	3f 90       	pop	r3
    5782:	2f 90       	pop	r2
    5784:	08 95       	ret

00005786 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5786:	2f 92       	push	r2
    5788:	3f 92       	push	r3
    578a:	4f 92       	push	r4
    578c:	5f 92       	push	r5
    578e:	6f 92       	push	r6
    5790:	7f 92       	push	r7
    5792:	8f 92       	push	r8
    5794:	9f 92       	push	r9
    5796:	af 92       	push	r10
    5798:	bf 92       	push	r11
    579a:	cf 92       	push	r12
    579c:	df 92       	push	r13
    579e:	ef 92       	push	r14
    57a0:	ff 92       	push	r15
    57a2:	0f 93       	push	r16
    57a4:	1f 93       	push	r17
    57a6:	cf 93       	push	r28
    57a8:	df 93       	push	r29
    57aa:	6b 01       	movw	r12, r22
    57ac:	7c 01       	movw	r14, r24
    57ae:	c4 2f       	mov	r28, r20
    57b0:	85 2e       	mov	r8, r21
    57b2:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    57b4:	88 e0       	ldi	r24, 0x08	; 8
    57b6:	60 e0       	ldi	r22, 0x00	; 0
    57b8:	0e 94 3c 05 	call	0xa78	; 0xa78 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    57bc:	80 e0       	ldi	r24, 0x00	; 0
    57be:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
    57c2:	81 e0       	ldi	r24, 0x01	; 1
    57c4:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    57c8:	82 e1       	ldi	r24, 0x12	; 18
    57ca:	b7 01       	movw	r22, r14
    57cc:	a6 01       	movw	r20, r12
    57ce:	2f ef       	ldi	r18, 0xFF	; 255
    57d0:	08 e0       	ldi	r16, 0x08	; 8
    57d2:	10 e0       	ldi	r17, 0x00	; 0
    57d4:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
    57d8:	88 23       	and	r24, r24
    57da:	b1 f7       	brne	.-20     	; 0x57c8 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    57dc:	16 14       	cp	r1, r6
    57de:	17 04       	cpc	r1, r7
    57e0:	0c f0       	brlt	.+2      	; 0x57e4 <SD_read_multiple_blocks+0x5e>
    57e2:	46 c0       	rjmp	.+140    	; 0x5870 <SD_read_multiple_blocks+0xea>
    57e4:	ac 2e       	mov	r10, r28
    57e6:	b8 2c       	mov	r11, r8
    57e8:	88 24       	eor	r8, r8
    57ea:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    57ec:	0f 2e       	mov	r0, r31
    57ee:	f6 e3       	ldi	r31, 0x36	; 54
    57f0:	cf 2e       	mov	r12, r31
    57f2:	fe e3       	ldi	r31, 0x3E	; 62
    57f4:	df 2e       	mov	r13, r31
    57f6:	f0 2d       	mov	r31, r0
    57f8:	ff 24       	eor	r15, r15
    57fa:	fa 94       	dec	r15
    57fc:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    57fe:	0f 2e       	mov	r0, r31
    5800:	f5 e3       	ldi	r31, 0x35	; 53
    5802:	4f 2e       	mov	r4, r31
    5804:	fe e3       	ldi	r31, 0x3E	; 62
    5806:	5f 2e       	mov	r5, r31
    5808:	f0 2d       	mov	r31, r0
    580a:	12 01       	movw	r2, r4
    580c:	08 94       	sec
    580e:	21 1c       	adc	r2, r1
    5810:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5812:	f6 01       	movw	r30, r12
    5814:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5816:	80 81       	ld	r24, Z
    5818:	8e 3f       	cpi	r24, 0xFE	; 254
    581a:	41 f0       	breq	.+16     	; 0x582c <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    581c:	8f 2d       	mov	r24, r15
    581e:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5822:	f6 01       	movw	r30, r12
    5824:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5826:	80 81       	ld	r24, Z
    5828:	8e 3f       	cpi	r24, 0xFE	; 254
    582a:	c1 f7       	brne	.-16     	; 0x581c <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    582c:	85 01       	movw	r16, r10
    582e:	c0 e0       	ldi	r28, 0x00	; 0
    5830:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5832:	8f 2d       	mov	r24, r15
    5834:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5838:	f8 01       	movw	r30, r16
    583a:	81 93       	st	Z+, r24
    583c:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    583e:	21 96       	adiw	r28, 0x01	; 1
    5840:	f2 e0       	ldi	r31, 0x02	; 2
    5842:	c0 30       	cpi	r28, 0x00	; 0
    5844:	df 07       	cpc	r29, r31
    5846:	a9 f7       	brne	.-22     	; 0x5832 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5848:	8f 2d       	mov	r24, r15
    584a:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    584e:	f2 01       	movw	r30, r4
    5850:	80 83       	st	Z, r24
    5852:	8f 2d       	mov	r24, r15
    5854:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5858:	f1 01       	movw	r30, r2
    585a:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    585c:	08 94       	sec
    585e:	81 1c       	adc	r8, r1
    5860:	91 1c       	adc	r9, r1
    5862:	80 e0       	ldi	r24, 0x00	; 0
    5864:	92 e0       	ldi	r25, 0x02	; 2
    5866:	a8 0e       	add	r10, r24
    5868:	b9 1e       	adc	r11, r25
    586a:	86 14       	cp	r8, r6
    586c:	97 04       	cpc	r9, r7
    586e:	89 f6       	brne	.-94     	; 0x5812 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5870:	8c e0       	ldi	r24, 0x0C	; 12
    5872:	40 e0       	ldi	r20, 0x00	; 0
    5874:	50 e0       	ldi	r21, 0x00	; 0
    5876:	ba 01       	movw	r22, r20
    5878:	2f ef       	ldi	r18, 0xFF	; 255
    587a:	08 e0       	ldi	r16, 0x08	; 8
    587c:	10 e0       	ldi	r17, 0x00	; 0
    587e:	0e 94 12 28 	call	0x5024	; 0x5024 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5882:	8f ef       	ldi	r24, 0xFF	; 255
    5884:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    5888:	80 93 35 3e 	sts	0x3E35, r24
	Buffer[1] = FILLER_BYTE;
    588c:	10 92 36 3e 	sts	0x3E36, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5890:	80 91 36 3e 	lds	r24, 0x3E36
    5894:	8f 3f       	cpi	r24, 0xFF	; 255
    5896:	49 f0       	breq	.+18     	; 0x58aa <SD_read_multiple_blocks+0x124>
    5898:	c6 e3       	ldi	r28, 0x36	; 54
    589a:	de e3       	ldi	r29, 0x3E	; 62
    589c:	8f ef       	ldi	r24, 0xFF	; 255
    589e:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
    58a2:	88 83       	st	Y, r24
    58a4:	88 81       	ld	r24, Y
    58a6:	8f 3f       	cpi	r24, 0xFF	; 255
    58a8:	c9 f7       	brne	.-14     	; 0x589c <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    58aa:	80 e0       	ldi	r24, 0x00	; 0
    58ac:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    58b0:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    58b4:	88 e0       	ldi	r24, 0x08	; 8
    58b6:	60 e0       	ldi	r22, 0x00	; 0
    58b8:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
}
    58bc:	df 91       	pop	r29
    58be:	cf 91       	pop	r28
    58c0:	1f 91       	pop	r17
    58c2:	0f 91       	pop	r16
    58c4:	ff 90       	pop	r15
    58c6:	ef 90       	pop	r14
    58c8:	df 90       	pop	r13
    58ca:	cf 90       	pop	r12
    58cc:	bf 90       	pop	r11
    58ce:	af 90       	pop	r10
    58d0:	9f 90       	pop	r9
    58d2:	8f 90       	pop	r8
    58d4:	7f 90       	pop	r7
    58d6:	6f 90       	pop	r6
    58d8:	5f 90       	pop	r5
    58da:	4f 90       	pop	r4
    58dc:	3f 90       	pop	r3
    58de:	2f 90       	pop	r2
    58e0:	08 95       	ret

000058e2 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    58e2:	88 e0       	ldi	r24, 0x08	; 8
    58e4:	60 e0       	ldi	r22, 0x00	; 0
    58e6:	0e 94 40 06 	call	0xc80	; 0xc80 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    58ea:	88 e0       	ldi	r24, 0x08	; 8
    58ec:	60 e0       	ldi	r22, 0x00	; 0
    58ee:	0e 94 93 05 	call	0xb26	; 0xb26 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    58f2:	80 e0       	ldi	r24, 0x00	; 0
    58f4:	0e 94 a0 04 	call	0x940	; 0x940 <SPIInit>
	SPICS(TRUE);
    58f8:	81 e0       	ldi	r24, 0x01	; 1
    58fa:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    58fe:	8f ef       	ldi	r24, 0xFF	; 255
    5900:	0e 94 ad 07 	call	0xf5a	; 0xf5a <SPI_write>
	SPICS(FALSE);	//stop spi
    5904:	80 e0       	ldi	r24, 0x00	; 0
    5906:	0e 94 c3 04 	call	0x986	; 0x986 <SPICS>
	SPIDisable();
    590a:	0e 94 cf 04 	call	0x99e	; 0x99e <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    590e:	80 e0       	ldi	r24, 0x00	; 0
    5910:	0e 94 96 06 	call	0xd2c	; 0xd2c <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5914:	80 e0       	ldi	r24, 0x00	; 0
    5916:	0e 94 3d 04 	call	0x87a	; 0x87a <Ext1Power>
}
    591a:	08 95       	ret

0000591c <__muldi3>:
    591c:	a0 e3       	ldi	r26, 0x30	; 48
    591e:	b0 e0       	ldi	r27, 0x00	; 0
    5920:	e4 e9       	ldi	r30, 0x94	; 148
    5922:	fc e2       	ldi	r31, 0x2C	; 44
    5924:	0c 94 2d 38 	jmp	0x705a	; 0x705a <__prologue_saves__+0x4>
    5928:	29 8f       	std	Y+25, r18	; 0x19
    592a:	3a 8f       	std	Y+26, r19	; 0x1a
    592c:	4b 8f       	std	Y+27, r20	; 0x1b
    592e:	5c 8f       	std	Y+28, r21	; 0x1c
    5930:	6d 8f       	std	Y+29, r22	; 0x1d
    5932:	7e 8f       	std	Y+30, r23	; 0x1e
    5934:	8f 8f       	std	Y+31, r24	; 0x1f
    5936:	98 a3       	lds	r25, 0x58
    5938:	a9 8a       	std	Y+17, r10	; 0x11
    593a:	ba 8a       	std	Y+18, r11	; 0x12
    593c:	cb 8a       	std	Y+19, r12	; 0x13
    593e:	dc 8a       	std	Y+20, r13	; 0x14
    5940:	ed 8a       	std	Y+21, r14	; 0x15
    5942:	fe 8a       	std	Y+22, r15	; 0x16
    5944:	0f 8b       	std	Y+23, r16	; 0x17
    5946:	18 8f       	std	Y+24, r17	; 0x18
    5948:	09 8d       	ldd	r16, Y+25	; 0x19
    594a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    594c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    594e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5950:	09 a3       	lds	r16, 0x59
    5952:	1a a3       	lds	r17, 0x5a
    5954:	2b a3       	lds	r18, 0x5b
    5956:	3c a3       	lds	r19, 0x5c
    5958:	68 01       	movw	r12, r16
    595a:	79 01       	movw	r14, r18
    595c:	8f ef       	ldi	r24, 0xFF	; 255
    595e:	9f ef       	ldi	r25, 0xFF	; 255
    5960:	a0 e0       	ldi	r26, 0x00	; 0
    5962:	b0 e0       	ldi	r27, 0x00	; 0
    5964:	c8 22       	and	r12, r24
    5966:	d9 22       	and	r13, r25
    5968:	ea 22       	and	r14, r26
    596a:	fb 22       	and	r15, r27
    596c:	89 01       	movw	r16, r18
    596e:	22 27       	eor	r18, r18
    5970:	33 27       	eor	r19, r19
    5972:	09 a7       	lds	r16, 0x79
    5974:	1a a7       	lds	r17, 0x7a
    5976:	2b a7       	lds	r18, 0x7b
    5978:	3c a7       	lds	r19, 0x7c
    597a:	09 89       	ldd	r16, Y+17	; 0x11
    597c:	1a 89       	ldd	r17, Y+18	; 0x12
    597e:	2b 89       	ldd	r18, Y+19	; 0x13
    5980:	3c 89       	ldd	r19, Y+20	; 0x14
    5982:	0d a3       	lds	r16, 0x5d
    5984:	1e a3       	lds	r17, 0x5e
    5986:	2f a3       	lds	r18, 0x5f
    5988:	38 a7       	lds	r19, 0x78
    598a:	48 01       	movw	r8, r16
    598c:	59 01       	movw	r10, r18
    598e:	88 22       	and	r8, r24
    5990:	99 22       	and	r9, r25
    5992:	aa 22       	and	r10, r26
    5994:	bb 22       	and	r11, r27
    5996:	29 01       	movw	r4, r18
    5998:	66 24       	eor	r6, r6
    599a:	77 24       	eor	r7, r7
    599c:	c5 01       	movw	r24, r10
    599e:	b4 01       	movw	r22, r8
    59a0:	a7 01       	movw	r20, r14
    59a2:	96 01       	movw	r18, r12
    59a4:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    59a8:	6d a7       	lds	r22, 0x7d
    59aa:	7e a7       	lds	r23, 0x7e
    59ac:	8f a7       	lds	r24, 0x7f
    59ae:	98 ab       	sts	0x58, r25
    59b0:	c3 01       	movw	r24, r6
    59b2:	b2 01       	movw	r22, r4
    59b4:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    59b8:	6b 01       	movw	r12, r22
    59ba:	7c 01       	movw	r14, r24
    59bc:	c5 01       	movw	r24, r10
    59be:	b4 01       	movw	r22, r8
    59c0:	29 a5       	lds	r18, 0x69
    59c2:	3a a5       	lds	r19, 0x6a
    59c4:	4b a5       	lds	r20, 0x6b
    59c6:	5c a5       	lds	r21, 0x6c
    59c8:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    59cc:	4b 01       	movw	r8, r22
    59ce:	5c 01       	movw	r10, r24
    59d0:	c3 01       	movw	r24, r6
    59d2:	b2 01       	movw	r22, r4
    59d4:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    59d8:	ab 01       	movw	r20, r22
    59da:	bc 01       	movw	r22, r24
    59dc:	c8 0c       	add	r12, r8
    59de:	d9 1c       	adc	r13, r9
    59e0:	ea 1c       	adc	r14, r10
    59e2:	fb 1c       	adc	r15, r11
    59e4:	0d a5       	lds	r16, 0x6d
    59e6:	1e a5       	lds	r17, 0x6e
    59e8:	2f a5       	lds	r18, 0x6f
    59ea:	38 a9       	sts	0x48, r19
    59ec:	c9 01       	movw	r24, r18
    59ee:	aa 27       	eor	r26, r26
    59f0:	bb 27       	eor	r27, r27
    59f2:	c8 0e       	add	r12, r24
    59f4:	d9 1e       	adc	r13, r25
    59f6:	ea 1e       	adc	r14, r26
    59f8:	fb 1e       	adc	r15, r27
    59fa:	c8 14       	cp	r12, r8
    59fc:	d9 04       	cpc	r13, r9
    59fe:	ea 04       	cpc	r14, r10
    5a00:	fb 04       	cpc	r15, r11
    5a02:	20 f4       	brcc	.+8      	; 0x5a0c <__muldi3+0xf0>
    5a04:	40 50       	subi	r20, 0x00	; 0
    5a06:	50 40       	sbci	r21, 0x00	; 0
    5a08:	6f 4f       	sbci	r22, 0xFF	; 255
    5a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    5a0c:	c7 01       	movw	r24, r14
    5a0e:	aa 27       	eor	r26, r26
    5a10:	bb 27       	eor	r27, r27
    5a12:	84 0f       	add	r24, r20
    5a14:	95 1f       	adc	r25, r21
    5a16:	a6 1f       	adc	r26, r22
    5a18:	b7 1f       	adc	r27, r23
    5a1a:	8d 83       	std	Y+5, r24	; 0x05
    5a1c:	9e 83       	std	Y+6, r25	; 0x06
    5a1e:	af 83       	std	Y+7, r26	; 0x07
    5a20:	b8 87       	std	Y+8, r27	; 0x08
    5a22:	76 01       	movw	r14, r12
    5a24:	dd 24       	eor	r13, r13
    5a26:	cc 24       	eor	r12, r12
    5a28:	4d a5       	lds	r20, 0x6d
    5a2a:	5e a5       	lds	r21, 0x6e
    5a2c:	6f a5       	lds	r22, 0x6f
    5a2e:	78 a9       	sts	0x48, r23
    5a30:	60 70       	andi	r22, 0x00	; 0
    5a32:	70 70       	andi	r23, 0x00	; 0
    5a34:	c4 0e       	add	r12, r20
    5a36:	d5 1e       	adc	r13, r21
    5a38:	e6 1e       	adc	r14, r22
    5a3a:	f7 1e       	adc	r15, r23
    5a3c:	c9 82       	std	Y+1, r12	; 0x01
    5a3e:	da 82       	std	Y+2, r13	; 0x02
    5a40:	eb 82       	std	Y+3, r14	; 0x03
    5a42:	fc 82       	std	Y+4, r15	; 0x04
    5a44:	1c 2d       	mov	r17, r12
    5a46:	0a 81       	ldd	r16, Y+2	; 0x02
    5a48:	8b 80       	ldd	r8, Y+3	; 0x03
    5a4a:	4c 80       	ldd	r4, Y+4	; 0x04
    5a4c:	8d 87       	std	Y+13, r24	; 0x0d
    5a4e:	8e 81       	ldd	r24, Y+6	; 0x06
    5a50:	8e 87       	std	Y+14, r24	; 0x0e
    5a52:	8f 81       	ldd	r24, Y+7	; 0x07
    5a54:	8f 87       	std	Y+15, r24	; 0x0f
    5a56:	88 85       	ldd	r24, Y+8	; 0x08
    5a58:	88 8b       	std	Y+16, r24	; 0x10
    5a5a:	2d 89       	ldd	r18, Y+21	; 0x15
    5a5c:	3e 89       	ldd	r19, Y+22	; 0x16
    5a5e:	4f 89       	ldd	r20, Y+23	; 0x17
    5a60:	58 8d       	ldd	r21, Y+24	; 0x18
    5a62:	69 a1       	lds	r22, 0x49
    5a64:	7a a1       	lds	r23, 0x4a
    5a66:	8b a1       	lds	r24, 0x4b
    5a68:	9c a1       	lds	r25, 0x4c
    5a6a:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    5a6e:	6b 01       	movw	r12, r22
    5a70:	7c 01       	movw	r14, r24
    5a72:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5a74:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5a76:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5a78:	58 a1       	lds	r21, 0x48
    5a7a:	6d a1       	lds	r22, 0x4d
    5a7c:	7e a1       	lds	r23, 0x4e
    5a7e:	8f a1       	lds	r24, 0x4f
    5a80:	98 a5       	lds	r25, 0x68
    5a82:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    5a86:	dc 01       	movw	r26, r24
    5a88:	cb 01       	movw	r24, r22
    5a8a:	c8 0e       	add	r12, r24
    5a8c:	d9 1e       	adc	r13, r25
    5a8e:	ea 1e       	adc	r14, r26
    5a90:	fb 1e       	adc	r15, r27
    5a92:	8d 85       	ldd	r24, Y+13	; 0x0d
    5a94:	9e 85       	ldd	r25, Y+14	; 0x0e
    5a96:	af 85       	ldd	r26, Y+15	; 0x0f
    5a98:	b8 89       	ldd	r27, Y+16	; 0x10
    5a9a:	8c 0d       	add	r24, r12
    5a9c:	9d 1d       	adc	r25, r13
    5a9e:	ae 1d       	adc	r26, r14
    5aa0:	bf 1d       	adc	r27, r15
    5aa2:	8d 87       	std	Y+13, r24	; 0x0d
    5aa4:	9e 87       	std	Y+14, r25	; 0x0e
    5aa6:	af 87       	std	Y+15, r26	; 0x0f
    5aa8:	b8 8b       	std	Y+16, r27	; 0x10
    5aaa:	68 2f       	mov	r22, r24
    5aac:	7e 85       	ldd	r23, Y+14	; 0x0e
    5aae:	21 2f       	mov	r18, r17
    5ab0:	30 2f       	mov	r19, r16
    5ab2:	48 2d       	mov	r20, r8
    5ab4:	54 2d       	mov	r21, r4
    5ab6:	8f 85       	ldd	r24, Y+15	; 0x0f
    5ab8:	98 89       	ldd	r25, Y+16	; 0x10
    5aba:	e0 96       	adiw	r28, 0x30	; 48
    5abc:	e0 e1       	ldi	r30, 0x10	; 16
    5abe:	0c 94 46 38 	jmp	0x708c	; 0x708c <__epilogue_restores__+0x4>

00005ac2 <__ashldi3>:
    5ac2:	cf 92       	push	r12
    5ac4:	df 92       	push	r13
    5ac6:	ef 92       	push	r14
    5ac8:	ff 92       	push	r15
    5aca:	0f 93       	push	r16
    5acc:	cf 93       	push	r28
    5ace:	df 93       	push	r29
    5ad0:	cd b7       	in	r28, 0x3d	; 61
    5ad2:	de b7       	in	r29, 0x3e	; 62
    5ad4:	60 97       	sbiw	r28, 0x10	; 16
    5ad6:	cd bf       	out	0x3d, r28	; 61
    5ad8:	de bf       	out	0x3e, r29	; 62
    5ada:	00 23       	and	r16, r16
    5adc:	09 f4       	brne	.+2      	; 0x5ae0 <__ashldi3+0x1e>
    5ade:	5a c0       	rjmp	.+180    	; 0x5b94 <__ashldi3+0xd2>
    5ae0:	29 87       	std	Y+9, r18	; 0x09
    5ae2:	3a 87       	std	Y+10, r19	; 0x0a
    5ae4:	4b 87       	std	Y+11, r20	; 0x0b
    5ae6:	5c 87       	std	Y+12, r21	; 0x0c
    5ae8:	6d 87       	std	Y+13, r22	; 0x0d
    5aea:	7e 87       	std	Y+14, r23	; 0x0e
    5aec:	8f 87       	std	Y+15, r24	; 0x0f
    5aee:	98 8b       	std	Y+16, r25	; 0x10
    5af0:	80 e2       	ldi	r24, 0x20	; 32
    5af2:	80 1b       	sub	r24, r16
    5af4:	49 85       	ldd	r20, Y+9	; 0x09
    5af6:	5a 85       	ldd	r21, Y+10	; 0x0a
    5af8:	6b 85       	ldd	r22, Y+11	; 0x0b
    5afa:	7c 85       	ldd	r23, Y+12	; 0x0c
    5afc:	18 16       	cp	r1, r24
    5afe:	b4 f0       	brlt	.+44     	; 0x5b2c <__ashldi3+0x6a>
    5b00:	19 82       	std	Y+1, r1	; 0x01
    5b02:	1a 82       	std	Y+2, r1	; 0x02
    5b04:	1b 82       	std	Y+3, r1	; 0x03
    5b06:	1c 82       	std	Y+4, r1	; 0x04
    5b08:	99 27       	eor	r25, r25
    5b0a:	87 fd       	sbrc	r24, 7
    5b0c:	90 95       	com	r25
    5b0e:	90 95       	com	r25
    5b10:	81 95       	neg	r24
    5b12:	9f 4f       	sbci	r25, 0xFF	; 255
    5b14:	04 c0       	rjmp	.+8      	; 0x5b1e <__ashldi3+0x5c>
    5b16:	44 0f       	add	r20, r20
    5b18:	55 1f       	adc	r21, r21
    5b1a:	66 1f       	adc	r22, r22
    5b1c:	77 1f       	adc	r23, r23
    5b1e:	8a 95       	dec	r24
    5b20:	d2 f7       	brpl	.-12     	; 0x5b16 <__ashldi3+0x54>
    5b22:	4d 83       	std	Y+5, r20	; 0x05
    5b24:	5e 83       	std	Y+6, r21	; 0x06
    5b26:	6f 83       	std	Y+7, r22	; 0x07
    5b28:	78 87       	std	Y+8, r23	; 0x08
    5b2a:	2c c0       	rjmp	.+88     	; 0x5b84 <__ashldi3+0xc2>
    5b2c:	6a 01       	movw	r12, r20
    5b2e:	7b 01       	movw	r14, r22
    5b30:	00 2e       	mov	r0, r16
    5b32:	04 c0       	rjmp	.+8      	; 0x5b3c <__ashldi3+0x7a>
    5b34:	cc 0c       	add	r12, r12
    5b36:	dd 1c       	adc	r13, r13
    5b38:	ee 1c       	adc	r14, r14
    5b3a:	ff 1c       	adc	r15, r15
    5b3c:	0a 94       	dec	r0
    5b3e:	d2 f7       	brpl	.-12     	; 0x5b34 <__ashldi3+0x72>
    5b40:	c9 82       	std	Y+1, r12	; 0x01
    5b42:	da 82       	std	Y+2, r13	; 0x02
    5b44:	eb 82       	std	Y+3, r14	; 0x03
    5b46:	fc 82       	std	Y+4, r15	; 0x04
    5b48:	6a 01       	movw	r12, r20
    5b4a:	7b 01       	movw	r14, r22
    5b4c:	04 c0       	rjmp	.+8      	; 0x5b56 <__ashldi3+0x94>
    5b4e:	f6 94       	lsr	r15
    5b50:	e7 94       	ror	r14
    5b52:	d7 94       	ror	r13
    5b54:	c7 94       	ror	r12
    5b56:	8a 95       	dec	r24
    5b58:	d2 f7       	brpl	.-12     	; 0x5b4e <__ashldi3+0x8c>
    5b5a:	d7 01       	movw	r26, r14
    5b5c:	c6 01       	movw	r24, r12
    5b5e:	4d 85       	ldd	r20, Y+13	; 0x0d
    5b60:	5e 85       	ldd	r21, Y+14	; 0x0e
    5b62:	6f 85       	ldd	r22, Y+15	; 0x0f
    5b64:	78 89       	ldd	r23, Y+16	; 0x10
    5b66:	04 c0       	rjmp	.+8      	; 0x5b70 <__ashldi3+0xae>
    5b68:	44 0f       	add	r20, r20
    5b6a:	55 1f       	adc	r21, r21
    5b6c:	66 1f       	adc	r22, r22
    5b6e:	77 1f       	adc	r23, r23
    5b70:	0a 95       	dec	r16
    5b72:	d2 f7       	brpl	.-12     	; 0x5b68 <__ashldi3+0xa6>
    5b74:	84 2b       	or	r24, r20
    5b76:	95 2b       	or	r25, r21
    5b78:	a6 2b       	or	r26, r22
    5b7a:	b7 2b       	or	r27, r23
    5b7c:	8d 83       	std	Y+5, r24	; 0x05
    5b7e:	9e 83       	std	Y+6, r25	; 0x06
    5b80:	af 83       	std	Y+7, r26	; 0x07
    5b82:	b8 87       	std	Y+8, r27	; 0x08
    5b84:	29 81       	ldd	r18, Y+1	; 0x01
    5b86:	3a 81       	ldd	r19, Y+2	; 0x02
    5b88:	4b 81       	ldd	r20, Y+3	; 0x03
    5b8a:	5c 81       	ldd	r21, Y+4	; 0x04
    5b8c:	6d 81       	ldd	r22, Y+5	; 0x05
    5b8e:	7e 81       	ldd	r23, Y+6	; 0x06
    5b90:	8f 81       	ldd	r24, Y+7	; 0x07
    5b92:	98 85       	ldd	r25, Y+8	; 0x08
    5b94:	60 96       	adiw	r28, 0x10	; 16
    5b96:	cd bf       	out	0x3d, r28	; 61
    5b98:	de bf       	out	0x3e, r29	; 62
    5b9a:	df 91       	pop	r29
    5b9c:	cf 91       	pop	r28
    5b9e:	0f 91       	pop	r16
    5ba0:	ff 90       	pop	r15
    5ba2:	ef 90       	pop	r14
    5ba4:	df 90       	pop	r13
    5ba6:	cf 90       	pop	r12
    5ba8:	08 95       	ret

00005baa <__ashrdi3>:
    5baa:	0f 93       	push	r16
    5bac:	cf 93       	push	r28
    5bae:	df 93       	push	r29
    5bb0:	cd b7       	in	r28, 0x3d	; 61
    5bb2:	de b7       	in	r29, 0x3e	; 62
    5bb4:	60 97       	sbiw	r28, 0x10	; 16
    5bb6:	cd bf       	out	0x3d, r28	; 61
    5bb8:	de bf       	out	0x3e, r29	; 62
    5bba:	00 23       	and	r16, r16
    5bbc:	09 f4       	brne	.+2      	; 0x5bc0 <__ashrdi3+0x16>
    5bbe:	56 c0       	rjmp	.+172    	; 0x5c6c <__ashrdi3+0xc2>
    5bc0:	29 87       	std	Y+9, r18	; 0x09
    5bc2:	3a 87       	std	Y+10, r19	; 0x0a
    5bc4:	4b 87       	std	Y+11, r20	; 0x0b
    5bc6:	5c 87       	std	Y+12, r21	; 0x0c
    5bc8:	6d 87       	std	Y+13, r22	; 0x0d
    5bca:	7e 87       	std	Y+14, r23	; 0x0e
    5bcc:	8f 87       	std	Y+15, r24	; 0x0f
    5bce:	98 8b       	std	Y+16, r25	; 0x10
    5bd0:	20 e2       	ldi	r18, 0x20	; 32
    5bd2:	20 1b       	sub	r18, r16
    5bd4:	8d 85       	ldd	r24, Y+13	; 0x0d
    5bd6:	9e 85       	ldd	r25, Y+14	; 0x0e
    5bd8:	af 85       	ldd	r26, Y+15	; 0x0f
    5bda:	b8 89       	ldd	r27, Y+16	; 0x10
    5bdc:	ac 01       	movw	r20, r24
    5bde:	bd 01       	movw	r22, r26
    5be0:	12 16       	cp	r1, r18
    5be2:	b4 f0       	brlt	.+44     	; 0x5c10 <__ashrdi3+0x66>
    5be4:	77 0f       	add	r23, r23
    5be6:	44 0b       	sbc	r20, r20
    5be8:	54 2f       	mov	r21, r20
    5bea:	ba 01       	movw	r22, r20
    5bec:	4d 83       	std	Y+5, r20	; 0x05
    5bee:	5e 83       	std	Y+6, r21	; 0x06
    5bf0:	6f 83       	std	Y+7, r22	; 0x07
    5bf2:	78 87       	std	Y+8, r23	; 0x08
    5bf4:	33 27       	eor	r19, r19
    5bf6:	27 fd       	sbrc	r18, 7
    5bf8:	30 95       	com	r19
    5bfa:	30 95       	com	r19
    5bfc:	21 95       	neg	r18
    5bfe:	3f 4f       	sbci	r19, 0xFF	; 255
    5c00:	04 c0       	rjmp	.+8      	; 0x5c0a <__ashrdi3+0x60>
    5c02:	b5 95       	asr	r27
    5c04:	a7 95       	ror	r26
    5c06:	97 95       	ror	r25
    5c08:	87 95       	ror	r24
    5c0a:	2a 95       	dec	r18
    5c0c:	d2 f7       	brpl	.-12     	; 0x5c02 <__ashrdi3+0x58>
    5c0e:	22 c0       	rjmp	.+68     	; 0x5c54 <__ashrdi3+0xaa>
    5c10:	00 2e       	mov	r0, r16
    5c12:	04 c0       	rjmp	.+8      	; 0x5c1c <__ashrdi3+0x72>
    5c14:	75 95       	asr	r23
    5c16:	67 95       	ror	r22
    5c18:	57 95       	ror	r21
    5c1a:	47 95       	ror	r20
    5c1c:	0a 94       	dec	r0
    5c1e:	d2 f7       	brpl	.-12     	; 0x5c14 <__ashrdi3+0x6a>
    5c20:	4d 83       	std	Y+5, r20	; 0x05
    5c22:	5e 83       	std	Y+6, r21	; 0x06
    5c24:	6f 83       	std	Y+7, r22	; 0x07
    5c26:	78 87       	std	Y+8, r23	; 0x08
    5c28:	04 c0       	rjmp	.+8      	; 0x5c32 <__ashrdi3+0x88>
    5c2a:	88 0f       	add	r24, r24
    5c2c:	99 1f       	adc	r25, r25
    5c2e:	aa 1f       	adc	r26, r26
    5c30:	bb 1f       	adc	r27, r27
    5c32:	2a 95       	dec	r18
    5c34:	d2 f7       	brpl	.-12     	; 0x5c2a <__ashrdi3+0x80>
    5c36:	49 85       	ldd	r20, Y+9	; 0x09
    5c38:	5a 85       	ldd	r21, Y+10	; 0x0a
    5c3a:	6b 85       	ldd	r22, Y+11	; 0x0b
    5c3c:	7c 85       	ldd	r23, Y+12	; 0x0c
    5c3e:	04 c0       	rjmp	.+8      	; 0x5c48 <__ashrdi3+0x9e>
    5c40:	76 95       	lsr	r23
    5c42:	67 95       	ror	r22
    5c44:	57 95       	ror	r21
    5c46:	47 95       	ror	r20
    5c48:	0a 95       	dec	r16
    5c4a:	d2 f7       	brpl	.-12     	; 0x5c40 <__ashrdi3+0x96>
    5c4c:	84 2b       	or	r24, r20
    5c4e:	95 2b       	or	r25, r21
    5c50:	a6 2b       	or	r26, r22
    5c52:	b7 2b       	or	r27, r23
    5c54:	89 83       	std	Y+1, r24	; 0x01
    5c56:	9a 83       	std	Y+2, r25	; 0x02
    5c58:	ab 83       	std	Y+3, r26	; 0x03
    5c5a:	bc 83       	std	Y+4, r27	; 0x04
    5c5c:	29 81       	ldd	r18, Y+1	; 0x01
    5c5e:	3a 81       	ldd	r19, Y+2	; 0x02
    5c60:	4b 81       	ldd	r20, Y+3	; 0x03
    5c62:	5c 81       	ldd	r21, Y+4	; 0x04
    5c64:	6d 81       	ldd	r22, Y+5	; 0x05
    5c66:	7e 81       	ldd	r23, Y+6	; 0x06
    5c68:	8f 81       	ldd	r24, Y+7	; 0x07
    5c6a:	98 85       	ldd	r25, Y+8	; 0x08
    5c6c:	60 96       	adiw	r28, 0x10	; 16
    5c6e:	cd bf       	out	0x3d, r28	; 61
    5c70:	de bf       	out	0x3e, r29	; 62
    5c72:	df 91       	pop	r29
    5c74:	cf 91       	pop	r28
    5c76:	0f 91       	pop	r16
    5c78:	08 95       	ret

00005c7a <__divdi3>:
    5c7a:	a8 e4       	ldi	r26, 0x48	; 72
    5c7c:	b0 e0       	ldi	r27, 0x00	; 0
    5c7e:	e3 e4       	ldi	r30, 0x43	; 67
    5c80:	fe e2       	ldi	r31, 0x2E	; 46
    5c82:	0c 94 2c 38 	jmp	0x7058	; 0x7058 <__prologue_saves__+0x2>
    5c86:	f5 01       	movw	r30, r10
    5c88:	29 a3       	lds	r18, 0x59
    5c8a:	3a a3       	lds	r19, 0x5a
    5c8c:	4b a3       	lds	r20, 0x5b
    5c8e:	5c a3       	lds	r21, 0x5c
    5c90:	6d a3       	lds	r22, 0x5d
    5c92:	7e a3       	lds	r23, 0x5e
    5c94:	8f a3       	lds	r24, 0x5f
    5c96:	98 a7       	lds	r25, 0x78
    5c98:	a9 8e       	std	Y+25, r10	; 0x19
    5c9a:	fa 8f       	std	Y+26, r31	; 0x1a
    5c9c:	cb 8e       	std	Y+27, r12	; 0x1b
    5c9e:	dc 8e       	std	Y+28, r13	; 0x1c
    5ca0:	ed 8e       	std	Y+29, r14	; 0x1d
    5ca2:	fe 8e       	std	Y+30, r15	; 0x1e
    5ca4:	0f 8f       	std	Y+31, r16	; 0x1f
    5ca6:	18 a3       	lds	r17, 0x58
    5ca8:	8d a0       	lds	r24, 0x8d
    5caa:	9e a0       	lds	r25, 0x8e
    5cac:	af a0       	lds	r26, 0x8f
    5cae:	b8 a4       	lds	r27, 0xa8
    5cb0:	b7 fe       	sbrs	r11, 7
    5cb2:	67 c0       	rjmp	.+206    	; 0x5d82 <__divdi3+0x108>
    5cb4:	21 95       	neg	r18
    5cb6:	b1 e0       	ldi	r27, 0x01	; 1
    5cb8:	12 16       	cp	r1, r18
    5cba:	08 f0       	brcs	.+2      	; 0x5cbe <__divdi3+0x44>
    5cbc:	b0 e0       	ldi	r27, 0x00	; 0
    5cbe:	31 95       	neg	r19
    5cc0:	a1 e0       	ldi	r26, 0x01	; 1
    5cc2:	13 16       	cp	r1, r19
    5cc4:	08 f0       	brcs	.+2      	; 0x5cc8 <__divdi3+0x4e>
    5cc6:	a0 e0       	ldi	r26, 0x00	; 0
    5cc8:	b3 2e       	mov	r11, r19
    5cca:	bb 1a       	sub	r11, r27
    5ccc:	bb 2d       	mov	r27, r11
    5cce:	88 24       	eor	r8, r8
    5cd0:	83 94       	inc	r8
    5cd2:	3b 15       	cp	r19, r11
    5cd4:	08 f0       	brcs	.+2      	; 0x5cd8 <__divdi3+0x5e>
    5cd6:	88 24       	eor	r8, r8
    5cd8:	a8 29       	or	r26, r8
    5cda:	41 95       	neg	r20
    5cdc:	31 e0       	ldi	r19, 0x01	; 1
    5cde:	14 16       	cp	r1, r20
    5ce0:	08 f0       	brcs	.+2      	; 0x5ce4 <__divdi3+0x6a>
    5ce2:	30 e0       	ldi	r19, 0x00	; 0
    5ce4:	b4 2e       	mov	r11, r20
    5ce6:	ba 1a       	sub	r11, r26
    5ce8:	ab 2d       	mov	r26, r11
    5cea:	88 24       	eor	r8, r8
    5cec:	83 94       	inc	r8
    5cee:	4b 15       	cp	r20, r11
    5cf0:	08 f0       	brcs	.+2      	; 0x5cf4 <__divdi3+0x7a>
    5cf2:	88 24       	eor	r8, r8
    5cf4:	38 29       	or	r19, r8
    5cf6:	51 95       	neg	r21
    5cf8:	41 e0       	ldi	r20, 0x01	; 1
    5cfa:	15 16       	cp	r1, r21
    5cfc:	08 f0       	brcs	.+2      	; 0x5d00 <__divdi3+0x86>
    5cfe:	40 e0       	ldi	r20, 0x00	; 0
    5d00:	45 2e       	mov	r4, r21
    5d02:	43 1a       	sub	r4, r19
    5d04:	31 e0       	ldi	r19, 0x01	; 1
    5d06:	54 15       	cp	r21, r4
    5d08:	08 f0       	brcs	.+2      	; 0x5d0c <__divdi3+0x92>
    5d0a:	30 e0       	ldi	r19, 0x00	; 0
    5d0c:	43 2b       	or	r20, r19
    5d0e:	61 95       	neg	r22
    5d10:	31 e0       	ldi	r19, 0x01	; 1
    5d12:	16 16       	cp	r1, r22
    5d14:	08 f0       	brcs	.+2      	; 0x5d18 <__divdi3+0x9e>
    5d16:	30 e0       	ldi	r19, 0x00	; 0
    5d18:	86 2e       	mov	r8, r22
    5d1a:	84 1a       	sub	r8, r20
    5d1c:	41 e0       	ldi	r20, 0x01	; 1
    5d1e:	68 15       	cp	r22, r8
    5d20:	08 f0       	brcs	.+2      	; 0x5d24 <__divdi3+0xaa>
    5d22:	40 e0       	ldi	r20, 0x00	; 0
    5d24:	34 2b       	or	r19, r20
    5d26:	71 95       	neg	r23
    5d28:	41 e0       	ldi	r20, 0x01	; 1
    5d2a:	17 16       	cp	r1, r23
    5d2c:	08 f0       	brcs	.+2      	; 0x5d30 <__divdi3+0xb6>
    5d2e:	40 e0       	ldi	r20, 0x00	; 0
    5d30:	57 2f       	mov	r21, r23
    5d32:	53 1b       	sub	r21, r19
    5d34:	31 e0       	ldi	r19, 0x01	; 1
    5d36:	75 17       	cp	r23, r21
    5d38:	08 f0       	brcs	.+2      	; 0x5d3c <__divdi3+0xc2>
    5d3a:	30 e0       	ldi	r19, 0x00	; 0
    5d3c:	43 2b       	or	r20, r19
    5d3e:	81 95       	neg	r24
    5d40:	31 e0       	ldi	r19, 0x01	; 1
    5d42:	18 16       	cp	r1, r24
    5d44:	08 f0       	brcs	.+2      	; 0x5d48 <__divdi3+0xce>
    5d46:	30 e0       	ldi	r19, 0x00	; 0
    5d48:	68 2f       	mov	r22, r24
    5d4a:	64 1b       	sub	r22, r20
    5d4c:	46 2f       	mov	r20, r22
    5d4e:	61 e0       	ldi	r22, 0x01	; 1
    5d50:	84 17       	cp	r24, r20
    5d52:	08 f0       	brcs	.+2      	; 0x5d56 <__divdi3+0xdc>
    5d54:	60 e0       	ldi	r22, 0x00	; 0
    5d56:	36 2b       	or	r19, r22
    5d58:	91 95       	neg	r25
    5d5a:	93 1b       	sub	r25, r19
    5d5c:	29 a3       	lds	r18, 0x59
    5d5e:	ba a3       	lds	r27, 0x5a
    5d60:	ab a3       	lds	r26, 0x5b
    5d62:	4c a2       	lds	r20, 0x9c
    5d64:	8d a2       	lds	r24, 0x9d
    5d66:	5e a3       	lds	r21, 0x5e
    5d68:	4f a3       	lds	r20, 0x5f
    5d6a:	98 a7       	lds	r25, 0x78
    5d6c:	8f ef       	ldi	r24, 0xFF	; 255
    5d6e:	9f ef       	ldi	r25, 0xFF	; 255
    5d70:	af ef       	ldi	r26, 0xFF	; 255
    5d72:	bf ef       	ldi	r27, 0xFF	; 255
    5d74:	25 96       	adiw	r28, 0x05	; 5
    5d76:	8c af       	sts	0x7c, r24
    5d78:	9d af       	sts	0x7d, r25
    5d7a:	ae af       	sts	0x7e, r26
    5d7c:	bf af       	sts	0x7f, r27
    5d7e:	25 97       	sbiw	r28, 0x05	; 5
    5d80:	06 c0       	rjmp	.+12     	; 0x5d8e <__divdi3+0x114>
    5d82:	25 96       	adiw	r28, 0x05	; 5
    5d84:	1c ae       	sts	0xbc, r17
    5d86:	1d ae       	sts	0xbd, r17
    5d88:	1e ae       	sts	0xbe, r17
    5d8a:	1f ae       	sts	0xbf, r17
    5d8c:	25 97       	sbiw	r28, 0x05	; 5
    5d8e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5d90:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5d92:	af 8d       	ldd	r26, Y+31	; 0x1f
    5d94:	b8 a1       	lds	r27, 0x48
    5d96:	b7 ff       	sbrs	r27, 7
    5d98:	68 c0       	rjmp	.+208    	; 0x5e6a <__divdi3+0x1f0>
    5d9a:	25 96       	adiw	r28, 0x05	; 5
    5d9c:	2c ad       	sts	0x6c, r18
    5d9e:	3d ad       	sts	0x6d, r19
    5da0:	4e ad       	sts	0x6e, r20
    5da2:	5f ad       	sts	0x6f, r21
    5da4:	25 97       	sbiw	r28, 0x05	; 5
    5da6:	20 95       	com	r18
    5da8:	30 95       	com	r19
    5daa:	40 95       	com	r20
    5dac:	50 95       	com	r21
    5dae:	25 96       	adiw	r28, 0x05	; 5
    5db0:	2c af       	sts	0x7c, r18
    5db2:	3d af       	sts	0x7d, r19
    5db4:	4e af       	sts	0x7e, r20
    5db6:	5f af       	sts	0x7f, r21
    5db8:	25 97       	sbiw	r28, 0x05	; 5
    5dba:	e1 95       	neg	r30
    5dbc:	81 e0       	ldi	r24, 0x01	; 1
    5dbe:	1e 16       	cp	r1, r30
    5dc0:	08 f0       	brcs	.+2      	; 0x5dc4 <__divdi3+0x14a>
    5dc2:	80 e0       	ldi	r24, 0x00	; 0
    5dc4:	f1 95       	neg	r31
    5dc6:	91 e0       	ldi	r25, 0x01	; 1
    5dc8:	1f 16       	cp	r1, r31
    5dca:	08 f0       	brcs	.+2      	; 0x5dce <__divdi3+0x154>
    5dcc:	90 e0       	ldi	r25, 0x00	; 0
    5dce:	4f 2f       	mov	r20, r31
    5dd0:	48 1b       	sub	r20, r24
    5dd2:	81 e0       	ldi	r24, 0x01	; 1
    5dd4:	f4 17       	cp	r31, r20
    5dd6:	08 f0       	brcs	.+2      	; 0x5dda <__divdi3+0x160>
    5dd8:	80 e0       	ldi	r24, 0x00	; 0
    5dda:	98 2b       	or	r25, r24
    5ddc:	c1 94       	neg	r12
    5dde:	81 e0       	ldi	r24, 0x01	; 1
    5de0:	1c 14       	cp	r1, r12
    5de2:	08 f0       	brcs	.+2      	; 0x5de6 <__divdi3+0x16c>
    5de4:	80 e0       	ldi	r24, 0x00	; 0
    5de6:	6c 2d       	mov	r22, r12
    5de8:	69 1b       	sub	r22, r25
    5dea:	91 e0       	ldi	r25, 0x01	; 1
    5dec:	c6 16       	cp	r12, r22
    5dee:	08 f0       	brcs	.+2      	; 0x5df2 <__divdi3+0x178>
    5df0:	90 e0       	ldi	r25, 0x00	; 0
    5df2:	89 2b       	or	r24, r25
    5df4:	d1 94       	neg	r13
    5df6:	91 e0       	ldi	r25, 0x01	; 1
    5df8:	1d 14       	cp	r1, r13
    5dfa:	08 f0       	brcs	.+2      	; 0x5dfe <__divdi3+0x184>
    5dfc:	90 e0       	ldi	r25, 0x00	; 0
    5dfe:	5d 2d       	mov	r21, r13
    5e00:	58 1b       	sub	r21, r24
    5e02:	81 e0       	ldi	r24, 0x01	; 1
    5e04:	d5 16       	cp	r13, r21
    5e06:	08 f0       	brcs	.+2      	; 0x5e0a <__divdi3+0x190>
    5e08:	80 e0       	ldi	r24, 0x00	; 0
    5e0a:	98 2b       	or	r25, r24
    5e0c:	e1 94       	neg	r14
    5e0e:	81 e0       	ldi	r24, 0x01	; 1
    5e10:	1e 14       	cp	r1, r14
    5e12:	08 f0       	brcs	.+2      	; 0x5e16 <__divdi3+0x19c>
    5e14:	80 e0       	ldi	r24, 0x00	; 0
    5e16:	3e 2d       	mov	r19, r14
    5e18:	39 1b       	sub	r19, r25
    5e1a:	91 e0       	ldi	r25, 0x01	; 1
    5e1c:	e3 16       	cp	r14, r19
    5e1e:	08 f0       	brcs	.+2      	; 0x5e22 <__divdi3+0x1a8>
    5e20:	90 e0       	ldi	r25, 0x00	; 0
    5e22:	89 2b       	or	r24, r25
    5e24:	f1 94       	neg	r15
    5e26:	91 e0       	ldi	r25, 0x01	; 1
    5e28:	1f 14       	cp	r1, r15
    5e2a:	08 f0       	brcs	.+2      	; 0x5e2e <__divdi3+0x1b4>
    5e2c:	90 e0       	ldi	r25, 0x00	; 0
    5e2e:	2f 2d       	mov	r18, r15
    5e30:	28 1b       	sub	r18, r24
    5e32:	81 e0       	ldi	r24, 0x01	; 1
    5e34:	f2 16       	cp	r15, r18
    5e36:	08 f0       	brcs	.+2      	; 0x5e3a <__divdi3+0x1c0>
    5e38:	80 e0       	ldi	r24, 0x00	; 0
    5e3a:	98 2b       	or	r25, r24
    5e3c:	01 95       	neg	r16
    5e3e:	81 e0       	ldi	r24, 0x01	; 1
    5e40:	10 16       	cp	r1, r16
    5e42:	08 f0       	brcs	.+2      	; 0x5e46 <__divdi3+0x1cc>
    5e44:	80 e0       	ldi	r24, 0x00	; 0
    5e46:	70 2f       	mov	r23, r16
    5e48:	79 1b       	sub	r23, r25
    5e4a:	97 2f       	mov	r25, r23
    5e4c:	71 e0       	ldi	r23, 0x01	; 1
    5e4e:	09 17       	cp	r16, r25
    5e50:	08 f0       	brcs	.+2      	; 0x5e54 <__divdi3+0x1da>
    5e52:	70 e0       	ldi	r23, 0x00	; 0
    5e54:	87 2b       	or	r24, r23
    5e56:	11 95       	neg	r17
    5e58:	18 1b       	sub	r17, r24
    5e5a:	e9 8f       	std	Y+25, r30	; 0x19
    5e5c:	4a 8f       	std	Y+26, r20	; 0x1a
    5e5e:	6b 8f       	std	Y+27, r22	; 0x1b
    5e60:	5c 8f       	std	Y+28, r21	; 0x1c
    5e62:	3d 8f       	std	Y+29, r19	; 0x1d
    5e64:	2e 8f       	std	Y+30, r18	; 0x1e
    5e66:	9f 8f       	std	Y+31, r25	; 0x1f
    5e68:	18 a3       	lds	r17, 0x58
    5e6a:	79 8d       	ldd	r23, Y+25	; 0x19
    5e6c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5e6e:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5e70:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5e72:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5e74:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5e76:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5e78:	88 a1       	lds	r24, 0x48
    5e7a:	e9 a1       	lds	r30, 0x49
    5e7c:	e9 8b       	std	Y+17, r30	; 0x11
    5e7e:	ea a1       	lds	r30, 0x4a
    5e80:	ea 8b       	std	Y+18, r30	; 0x12
    5e82:	eb a1       	lds	r30, 0x4b
    5e84:	eb 8b       	std	Y+19, r30	; 0x13
    5e86:	ec a1       	lds	r30, 0x4c
    5e88:	ec 8b       	std	Y+20, r30	; 0x14
    5e8a:	ed a1       	lds	r30, 0x4d
    5e8c:	ed 8b       	std	Y+21, r30	; 0x15
    5e8e:	ee a1       	lds	r30, 0x4e
    5e90:	ee 8b       	std	Y+22, r30	; 0x16
    5e92:	ef a1       	lds	r30, 0x4f
    5e94:	ef 8b       	std	Y+23, r30	; 0x17
    5e96:	e8 a5       	lds	r30, 0x68
    5e98:	e8 8f       	std	Y+24, r30	; 0x18
    5e9a:	79 87       	std	Y+9, r23	; 0x09
    5e9c:	6a 87       	std	Y+10, r22	; 0x0a
    5e9e:	5b 87       	std	Y+11, r21	; 0x0b
    5ea0:	4c 87       	std	Y+12, r20	; 0x0c
    5ea2:	3d 87       	std	Y+13, r19	; 0x0d
    5ea4:	2e 87       	std	Y+14, r18	; 0x0e
    5ea6:	9f 87       	std	Y+15, r25	; 0x0f
    5ea8:	88 8b       	std	Y+16, r24	; 0x10
    5eaa:	89 84       	ldd	r8, Y+9	; 0x09
    5eac:	9a 84       	ldd	r9, Y+10	; 0x0a
    5eae:	ab 84       	ldd	r10, Y+11	; 0x0b
    5eb0:	bc 84       	ldd	r11, Y+12	; 0x0c
    5eb2:	8d 85       	ldd	r24, Y+13	; 0x0d
    5eb4:	9e 85       	ldd	r25, Y+14	; 0x0e
    5eb6:	af 85       	ldd	r26, Y+15	; 0x0f
    5eb8:	b8 89       	ldd	r27, Y+16	; 0x10
    5eba:	e9 88       	ldd	r14, Y+17	; 0x11
    5ebc:	fa 88       	ldd	r15, Y+18	; 0x12
    5ebe:	0b 89       	ldd	r16, Y+19	; 0x13
    5ec0:	1c 89       	ldd	r17, Y+20	; 0x14
    5ec2:	ed aa       	sts	0x9d, r30
    5ec4:	fe aa       	sts	0x9e, r31
    5ec6:	0f ab       	sts	0x5f, r16
    5ec8:	18 af       	sts	0x78, r17
    5eca:	cd 88       	ldd	r12, Y+21	; 0x15
    5ecc:	de 88       	ldd	r13, Y+22	; 0x16
    5ece:	ef 88       	ldd	r14, Y+23	; 0x17
    5ed0:	f8 8c       	ldd	r15, Y+24	; 0x18
    5ed2:	00 97       	sbiw	r24, 0x00	; 0
    5ed4:	a1 05       	cpc	r26, r1
    5ed6:	b1 05       	cpc	r27, r1
    5ed8:	09 f0       	breq	.+2      	; 0x5edc <__divdi3+0x262>
    5eda:	bd c3       	rjmp	.+1914   	; 0x6656 <__stack+0x657>
    5edc:	c8 14       	cp	r12, r8
    5ede:	d9 04       	cpc	r13, r9
    5ee0:	ea 04       	cpc	r14, r10
    5ee2:	fb 04       	cpc	r15, r11
    5ee4:	08 f0       	brcs	.+2      	; 0x5ee8 <__divdi3+0x26e>
    5ee6:	4d c1       	rjmp	.+666    	; 0x6182 <__stack+0x183>
    5ee8:	00 e0       	ldi	r16, 0x00	; 0
    5eea:	80 16       	cp	r8, r16
    5eec:	00 e0       	ldi	r16, 0x00	; 0
    5eee:	90 06       	cpc	r9, r16
    5ef0:	01 e0       	ldi	r16, 0x01	; 1
    5ef2:	a0 06       	cpc	r10, r16
    5ef4:	00 e0       	ldi	r16, 0x00	; 0
    5ef6:	b0 06       	cpc	r11, r16
    5ef8:	58 f4       	brcc	.+22     	; 0x5f10 <__divdi3+0x296>
    5efa:	1f ef       	ldi	r17, 0xFF	; 255
    5efc:	81 16       	cp	r8, r17
    5efe:	91 04       	cpc	r9, r1
    5f00:	a1 04       	cpc	r10, r1
    5f02:	b1 04       	cpc	r11, r1
    5f04:	09 f0       	breq	.+2      	; 0x5f08 <__divdi3+0x28e>
    5f06:	90 f4       	brcc	.+36     	; 0x5f2c <__divdi3+0x2b2>
    5f08:	80 e0       	ldi	r24, 0x00	; 0
    5f0a:	90 e0       	ldi	r25, 0x00	; 0
    5f0c:	dc 01       	movw	r26, r24
    5f0e:	17 c0       	rjmp	.+46     	; 0x5f3e <__divdi3+0x2c4>
    5f10:	20 e0       	ldi	r18, 0x00	; 0
    5f12:	82 16       	cp	r8, r18
    5f14:	20 e0       	ldi	r18, 0x00	; 0
    5f16:	92 06       	cpc	r9, r18
    5f18:	20 e0       	ldi	r18, 0x00	; 0
    5f1a:	a2 06       	cpc	r10, r18
    5f1c:	21 e0       	ldi	r18, 0x01	; 1
    5f1e:	b2 06       	cpc	r11, r18
    5f20:	50 f4       	brcc	.+20     	; 0x5f36 <__divdi3+0x2bc>
    5f22:	80 e1       	ldi	r24, 0x10	; 16
    5f24:	90 e0       	ldi	r25, 0x00	; 0
    5f26:	a0 e0       	ldi	r26, 0x00	; 0
    5f28:	b0 e0       	ldi	r27, 0x00	; 0
    5f2a:	09 c0       	rjmp	.+18     	; 0x5f3e <__divdi3+0x2c4>
    5f2c:	88 e0       	ldi	r24, 0x08	; 8
    5f2e:	90 e0       	ldi	r25, 0x00	; 0
    5f30:	a0 e0       	ldi	r26, 0x00	; 0
    5f32:	b0 e0       	ldi	r27, 0x00	; 0
    5f34:	04 c0       	rjmp	.+8      	; 0x5f3e <__divdi3+0x2c4>
    5f36:	88 e1       	ldi	r24, 0x18	; 24
    5f38:	90 e0       	ldi	r25, 0x00	; 0
    5f3a:	a0 e0       	ldi	r26, 0x00	; 0
    5f3c:	b0 e0       	ldi	r27, 0x00	; 0
    5f3e:	b5 01       	movw	r22, r10
    5f40:	a4 01       	movw	r20, r8
    5f42:	08 2e       	mov	r0, r24
    5f44:	04 c0       	rjmp	.+8      	; 0x5f4e <__divdi3+0x2d4>
    5f46:	76 95       	lsr	r23
    5f48:	67 95       	ror	r22
    5f4a:	57 95       	ror	r21
    5f4c:	47 95       	ror	r20
    5f4e:	0a 94       	dec	r0
    5f50:	d2 f7       	brpl	.-12     	; 0x5f46 <__divdi3+0x2cc>
    5f52:	fa 01       	movw	r30, r20
    5f54:	e3 5f       	subi	r30, 0xF3	; 243
    5f56:	ff 4d       	sbci	r31, 0xDF	; 223
    5f58:	20 81       	ld	r18, Z
    5f5a:	40 e2       	ldi	r20, 0x20	; 32
    5f5c:	50 e0       	ldi	r21, 0x00	; 0
    5f5e:	60 e0       	ldi	r22, 0x00	; 0
    5f60:	70 e0       	ldi	r23, 0x00	; 0
    5f62:	48 1b       	sub	r20, r24
    5f64:	59 0b       	sbc	r21, r25
    5f66:	6a 0b       	sbc	r22, r26
    5f68:	7b 0b       	sbc	r23, r27
    5f6a:	42 1b       	sub	r20, r18
    5f6c:	51 09       	sbc	r21, r1
    5f6e:	61 09       	sbc	r22, r1
    5f70:	71 09       	sbc	r23, r1
    5f72:	41 15       	cp	r20, r1
    5f74:	51 05       	cpc	r21, r1
    5f76:	61 05       	cpc	r22, r1
    5f78:	71 05       	cpc	r23, r1
    5f7a:	a1 f1       	breq	.+104    	; 0x5fe4 <__divdi3+0x36a>
    5f7c:	04 2e       	mov	r0, r20
    5f7e:	04 c0       	rjmp	.+8      	; 0x5f88 <__divdi3+0x30e>
    5f80:	88 0c       	add	r8, r8
    5f82:	99 1c       	adc	r9, r9
    5f84:	aa 1c       	adc	r10, r10
    5f86:	bb 1c       	adc	r11, r11
    5f88:	0a 94       	dec	r0
    5f8a:	d2 f7       	brpl	.-12     	; 0x5f80 <__divdi3+0x306>
    5f8c:	97 01       	movw	r18, r14
    5f8e:	86 01       	movw	r16, r12
    5f90:	04 2e       	mov	r0, r20
    5f92:	04 c0       	rjmp	.+8      	; 0x5f9c <__divdi3+0x322>
    5f94:	00 0f       	add	r16, r16
    5f96:	11 1f       	adc	r17, r17
    5f98:	22 1f       	adc	r18, r18
    5f9a:	33 1f       	adc	r19, r19
    5f9c:	0a 94       	dec	r0
    5f9e:	d2 f7       	brpl	.-12     	; 0x5f94 <__divdi3+0x31a>
    5fa0:	80 e2       	ldi	r24, 0x20	; 32
    5fa2:	90 e0       	ldi	r25, 0x00	; 0
    5fa4:	84 1b       	sub	r24, r20
    5fa6:	95 0b       	sbc	r25, r21
    5fa8:	cd a8       	sts	0x8d, r28
    5faa:	de a8       	sts	0x8e, r29
    5fac:	ef a8       	sts	0x8f, r30
    5fae:	f8 ac       	sts	0xa8, r31
    5fb0:	04 c0       	rjmp	.+8      	; 0x5fba <__divdi3+0x340>
    5fb2:	f6 94       	lsr	r15
    5fb4:	e7 94       	ror	r14
    5fb6:	d7 94       	ror	r13
    5fb8:	c7 94       	ror	r12
    5fba:	8a 95       	dec	r24
    5fbc:	d2 f7       	brpl	.-12     	; 0x5fb2 <__divdi3+0x338>
    5fbe:	c0 2a       	or	r12, r16
    5fc0:	d1 2a       	or	r13, r17
    5fc2:	e2 2a       	or	r14, r18
    5fc4:	f3 2a       	or	r15, r19
    5fc6:	0d a9       	sts	0x4d, r16
    5fc8:	1e a9       	sts	0x4e, r17
    5fca:	2f a9       	sts	0x4f, r18
    5fcc:	38 ad       	sts	0x68, r19
    5fce:	04 c0       	rjmp	.+8      	; 0x5fd8 <__divdi3+0x35e>
    5fd0:	00 0f       	add	r16, r16
    5fd2:	11 1f       	adc	r17, r17
    5fd4:	22 1f       	adc	r18, r18
    5fd6:	33 1f       	adc	r19, r19
    5fd8:	4a 95       	dec	r20
    5fda:	d2 f7       	brpl	.-12     	; 0x5fd0 <__divdi3+0x356>
    5fdc:	0d ab       	sts	0x5d, r16
    5fde:	1e ab       	sts	0x5e, r17
    5fe0:	2f ab       	sts	0x5f, r18
    5fe2:	38 af       	sts	0x78, r19
    5fe4:	25 01       	movw	r4, r10
    5fe6:	66 24       	eor	r6, r6
    5fe8:	77 24       	eor	r7, r7
    5fea:	95 01       	movw	r18, r10
    5fec:	84 01       	movw	r16, r8
    5fee:	20 70       	andi	r18, 0x00	; 0
    5ff0:	30 70       	andi	r19, 0x00	; 0
    5ff2:	09 ab       	sts	0x59, r16
    5ff4:	1a ab       	sts	0x5a, r17
    5ff6:	2b ab       	sts	0x5b, r18
    5ff8:	3c ab       	sts	0x5c, r19
    5ffa:	c7 01       	movw	r24, r14
    5ffc:	b6 01       	movw	r22, r12
    5ffe:	a3 01       	movw	r20, r6
    6000:	92 01       	movw	r18, r4
    6002:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    6006:	2d a7       	lds	r18, 0x7d
    6008:	3e a7       	lds	r19, 0x7e
    600a:	4f a7       	lds	r20, 0x7f
    600c:	58 ab       	sts	0x58, r21
    600e:	69 a7       	lds	r22, 0x79
    6010:	7a a7       	lds	r23, 0x7a
    6012:	8b a7       	lds	r24, 0x7b
    6014:	9c a7       	lds	r25, 0x7c
    6016:	c7 01       	movw	r24, r14
    6018:	b6 01       	movw	r22, r12
    601a:	a3 01       	movw	r20, r6
    601c:	92 01       	movw	r18, r4
    601e:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    6022:	ca 01       	movw	r24, r20
    6024:	b9 01       	movw	r22, r18
    6026:	29 a9       	sts	0x49, r18
    6028:	3a a9       	sts	0x4a, r19
    602a:	4b a9       	sts	0x4b, r20
    602c:	5c a9       	sts	0x4c, r21
    602e:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    6032:	ab 01       	movw	r20, r22
    6034:	bc 01       	movw	r22, r24
    6036:	09 a5       	lds	r16, 0x69
    6038:	1a a5       	lds	r17, 0x6a
    603a:	2b a5       	lds	r18, 0x6b
    603c:	3c a5       	lds	r19, 0x6c
    603e:	78 01       	movw	r14, r16
    6040:	dd 24       	eor	r13, r13
    6042:	cc 24       	eor	r12, r12
    6044:	0d a9       	sts	0x4d, r16
    6046:	1e a9       	sts	0x4e, r17
    6048:	2f a9       	sts	0x4f, r18
    604a:	38 ad       	sts	0x68, r19
    604c:	c9 01       	movw	r24, r18
    604e:	aa 27       	eor	r26, r26
    6050:	bb 27       	eor	r27, r27
    6052:	c8 2a       	or	r12, r24
    6054:	d9 2a       	or	r13, r25
    6056:	ea 2a       	or	r14, r26
    6058:	fb 2a       	or	r15, r27
    605a:	0d a5       	lds	r16, 0x6d
    605c:	1e a5       	lds	r17, 0x6e
    605e:	2f a5       	lds	r18, 0x6f
    6060:	38 a9       	sts	0x48, r19
    6062:	c4 16       	cp	r12, r20
    6064:	d5 06       	cpc	r13, r21
    6066:	e6 06       	cpc	r14, r22
    6068:	f7 06       	cpc	r15, r23
    606a:	38 f5       	brcc	.+78     	; 0x60ba <__stack+0xbb>
    606c:	01 50       	subi	r16, 0x01	; 1
    606e:	10 40       	sbci	r17, 0x00	; 0
    6070:	20 40       	sbci	r18, 0x00	; 0
    6072:	30 40       	sbci	r19, 0x00	; 0
    6074:	09 a7       	lds	r16, 0x79
    6076:	1a a7       	lds	r17, 0x7a
    6078:	2b a7       	lds	r18, 0x7b
    607a:	3c a7       	lds	r19, 0x7c
    607c:	c8 0c       	add	r12, r8
    607e:	d9 1c       	adc	r13, r9
    6080:	ea 1c       	adc	r14, r10
    6082:	fb 1c       	adc	r15, r11
    6084:	c8 14       	cp	r12, r8
    6086:	d9 04       	cpc	r13, r9
    6088:	ea 04       	cpc	r14, r10
    608a:	fb 04       	cpc	r15, r11
    608c:	d0 f0       	brcs	.+52     	; 0x60c2 <__stack+0xc3>
    608e:	c4 16       	cp	r12, r20
    6090:	d5 06       	cpc	r13, r21
    6092:	e6 06       	cpc	r14, r22
    6094:	f7 06       	cpc	r15, r23
    6096:	a8 f4       	brcc	.+42     	; 0x60c2 <__stack+0xc3>
    6098:	0d a5       	lds	r16, 0x6d
    609a:	1e a5       	lds	r17, 0x6e
    609c:	2f a5       	lds	r18, 0x6f
    609e:	38 a9       	sts	0x48, r19
    60a0:	02 50       	subi	r16, 0x02	; 2
    60a2:	10 40       	sbci	r17, 0x00	; 0
    60a4:	20 40       	sbci	r18, 0x00	; 0
    60a6:	30 40       	sbci	r19, 0x00	; 0
    60a8:	09 a7       	lds	r16, 0x79
    60aa:	1a a7       	lds	r17, 0x7a
    60ac:	2b a7       	lds	r18, 0x7b
    60ae:	3c a7       	lds	r19, 0x7c
    60b0:	c8 0c       	add	r12, r8
    60b2:	d9 1c       	adc	r13, r9
    60b4:	ea 1c       	adc	r14, r10
    60b6:	fb 1c       	adc	r15, r11
    60b8:	04 c0       	rjmp	.+8      	; 0x60c2 <__stack+0xc3>
    60ba:	09 a7       	lds	r16, 0x79
    60bc:	1a a7       	lds	r17, 0x7a
    60be:	2b a7       	lds	r18, 0x7b
    60c0:	3c a7       	lds	r19, 0x7c
    60c2:	c4 1a       	sub	r12, r20
    60c4:	d5 0a       	sbc	r13, r21
    60c6:	e6 0a       	sbc	r14, r22
    60c8:	f7 0a       	sbc	r15, r23
    60ca:	c7 01       	movw	r24, r14
    60cc:	b6 01       	movw	r22, r12
    60ce:	a3 01       	movw	r20, r6
    60d0:	92 01       	movw	r18, r4
    60d2:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    60d6:	2d a7       	lds	r18, 0x7d
    60d8:	3e a7       	lds	r19, 0x7e
    60da:	4f a7       	lds	r20, 0x7f
    60dc:	58 ab       	sts	0x58, r21
    60de:	69 af       	sts	0x79, r22
    60e0:	7a af       	sts	0x7a, r23
    60e2:	8b af       	sts	0x7b, r24
    60e4:	9c af       	sts	0x7c, r25
    60e6:	c7 01       	movw	r24, r14
    60e8:	b6 01       	movw	r22, r12
    60ea:	a3 01       	movw	r20, r6
    60ec:	92 01       	movw	r18, r4
    60ee:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    60f2:	ca 01       	movw	r24, r20
    60f4:	b9 01       	movw	r22, r18
    60f6:	29 a9       	sts	0x49, r18
    60f8:	3a a9       	sts	0x4a, r19
    60fa:	4b a9       	sts	0x4b, r20
    60fc:	5c a9       	sts	0x4c, r21
    60fe:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    6102:	6b 01       	movw	r12, r22
    6104:	7c 01       	movw	r14, r24
    6106:	49 ad       	sts	0x69, r20
    6108:	5a ad       	sts	0x6a, r21
    610a:	6b ad       	sts	0x6b, r22
    610c:	7c ad       	sts	0x6c, r23
    610e:	9a 01       	movw	r18, r20
    6110:	11 27       	eor	r17, r17
    6112:	00 27       	eor	r16, r16
    6114:	4d a9       	sts	0x4d, r20
    6116:	5e a9       	sts	0x4e, r21
    6118:	6f a9       	sts	0x4f, r22
    611a:	78 ad       	sts	0x68, r23
    611c:	60 70       	andi	r22, 0x00	; 0
    611e:	70 70       	andi	r23, 0x00	; 0
    6120:	04 2b       	or	r16, r20
    6122:	15 2b       	or	r17, r21
    6124:	26 2b       	or	r18, r22
    6126:	37 2b       	or	r19, r23
    6128:	8d a5       	lds	r24, 0x6d
    612a:	9e a5       	lds	r25, 0x6e
    612c:	af a5       	lds	r26, 0x6f
    612e:	b8 a9       	sts	0x48, r27
    6130:	0c 15       	cp	r16, r12
    6132:	1d 05       	cpc	r17, r13
    6134:	2e 05       	cpc	r18, r14
    6136:	3f 05       	cpc	r19, r15
    6138:	c0 f4       	brcc	.+48     	; 0x616a <__stack+0x16b>
    613a:	01 97       	sbiw	r24, 0x01	; 1
    613c:	a1 09       	sbc	r26, r1
    613e:	b1 09       	sbc	r27, r1
    6140:	08 0d       	add	r16, r8
    6142:	19 1d       	adc	r17, r9
    6144:	2a 1d       	adc	r18, r10
    6146:	3b 1d       	adc	r19, r11
    6148:	08 15       	cp	r16, r8
    614a:	19 05       	cpc	r17, r9
    614c:	2a 05       	cpc	r18, r10
    614e:	3b 05       	cpc	r19, r11
    6150:	60 f0       	brcs	.+24     	; 0x616a <__stack+0x16b>
    6152:	0c 15       	cp	r16, r12
    6154:	1d 05       	cpc	r17, r13
    6156:	2e 05       	cpc	r18, r14
    6158:	3f 05       	cpc	r19, r15
    615a:	38 f4       	brcc	.+14     	; 0x616a <__stack+0x16b>
    615c:	8d a5       	lds	r24, 0x6d
    615e:	9e a5       	lds	r25, 0x6e
    6160:	af a5       	lds	r26, 0x6f
    6162:	b8 a9       	sts	0x48, r27
    6164:	02 97       	sbiw	r24, 0x02	; 2
    6166:	a1 09       	sbc	r26, r1
    6168:	b1 09       	sbc	r27, r1
    616a:	09 a5       	lds	r16, 0x69
    616c:	1a a5       	lds	r17, 0x6a
    616e:	2b a5       	lds	r18, 0x6b
    6170:	3c a5       	lds	r19, 0x6c
    6172:	78 01       	movw	r14, r16
    6174:	dd 24       	eor	r13, r13
    6176:	cc 24       	eor	r12, r12
    6178:	c8 2a       	or	r12, r24
    617a:	d9 2a       	or	r13, r25
    617c:	ea 2a       	or	r14, r26
    617e:	fb 2a       	or	r15, r27
    6180:	b7 c4       	rjmp	.+2414   	; 0x6af0 <__stack+0xaf1>
    6182:	81 14       	cp	r8, r1
    6184:	91 04       	cpc	r9, r1
    6186:	a1 04       	cpc	r10, r1
    6188:	b1 04       	cpc	r11, r1
    618a:	51 f4       	brne	.+20     	; 0x61a0 <__stack+0x1a1>
    618c:	61 e0       	ldi	r22, 0x01	; 1
    618e:	70 e0       	ldi	r23, 0x00	; 0
    6190:	80 e0       	ldi	r24, 0x00	; 0
    6192:	90 e0       	ldi	r25, 0x00	; 0
    6194:	a5 01       	movw	r20, r10
    6196:	94 01       	movw	r18, r8
    6198:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    619c:	49 01       	movw	r8, r18
    619e:	5a 01       	movw	r10, r20
    61a0:	10 e0       	ldi	r17, 0x00	; 0
    61a2:	81 16       	cp	r8, r17
    61a4:	10 e0       	ldi	r17, 0x00	; 0
    61a6:	91 06       	cpc	r9, r17
    61a8:	11 e0       	ldi	r17, 0x01	; 1
    61aa:	a1 06       	cpc	r10, r17
    61ac:	10 e0       	ldi	r17, 0x00	; 0
    61ae:	b1 06       	cpc	r11, r17
    61b0:	58 f4       	brcc	.+22     	; 0x61c8 <__stack+0x1c9>
    61b2:	2f ef       	ldi	r18, 0xFF	; 255
    61b4:	82 16       	cp	r8, r18
    61b6:	91 04       	cpc	r9, r1
    61b8:	a1 04       	cpc	r10, r1
    61ba:	b1 04       	cpc	r11, r1
    61bc:	09 f0       	breq	.+2      	; 0x61c0 <__stack+0x1c1>
    61be:	90 f4       	brcc	.+36     	; 0x61e4 <__stack+0x1e5>
    61c0:	80 e0       	ldi	r24, 0x00	; 0
    61c2:	90 e0       	ldi	r25, 0x00	; 0
    61c4:	dc 01       	movw	r26, r24
    61c6:	17 c0       	rjmp	.+46     	; 0x61f6 <__stack+0x1f7>
    61c8:	30 e0       	ldi	r19, 0x00	; 0
    61ca:	83 16       	cp	r8, r19
    61cc:	30 e0       	ldi	r19, 0x00	; 0
    61ce:	93 06       	cpc	r9, r19
    61d0:	30 e0       	ldi	r19, 0x00	; 0
    61d2:	a3 06       	cpc	r10, r19
    61d4:	31 e0       	ldi	r19, 0x01	; 1
    61d6:	b3 06       	cpc	r11, r19
    61d8:	50 f4       	brcc	.+20     	; 0x61ee <__stack+0x1ef>
    61da:	80 e1       	ldi	r24, 0x10	; 16
    61dc:	90 e0       	ldi	r25, 0x00	; 0
    61de:	a0 e0       	ldi	r26, 0x00	; 0
    61e0:	b0 e0       	ldi	r27, 0x00	; 0
    61e2:	09 c0       	rjmp	.+18     	; 0x61f6 <__stack+0x1f7>
    61e4:	88 e0       	ldi	r24, 0x08	; 8
    61e6:	90 e0       	ldi	r25, 0x00	; 0
    61e8:	a0 e0       	ldi	r26, 0x00	; 0
    61ea:	b0 e0       	ldi	r27, 0x00	; 0
    61ec:	04 c0       	rjmp	.+8      	; 0x61f6 <__stack+0x1f7>
    61ee:	88 e1       	ldi	r24, 0x18	; 24
    61f0:	90 e0       	ldi	r25, 0x00	; 0
    61f2:	a0 e0       	ldi	r26, 0x00	; 0
    61f4:	b0 e0       	ldi	r27, 0x00	; 0
    61f6:	b5 01       	movw	r22, r10
    61f8:	a4 01       	movw	r20, r8
    61fa:	08 2e       	mov	r0, r24
    61fc:	04 c0       	rjmp	.+8      	; 0x6206 <__stack+0x207>
    61fe:	76 95       	lsr	r23
    6200:	67 95       	ror	r22
    6202:	57 95       	ror	r21
    6204:	47 95       	ror	r20
    6206:	0a 94       	dec	r0
    6208:	d2 f7       	brpl	.-12     	; 0x61fe <__stack+0x1ff>
    620a:	fa 01       	movw	r30, r20
    620c:	e3 5f       	subi	r30, 0xF3	; 243
    620e:	ff 4d       	sbci	r31, 0xDF	; 223
    6210:	20 81       	ld	r18, Z
    6212:	ac 01       	movw	r20, r24
    6214:	bd 01       	movw	r22, r26
    6216:	42 0f       	add	r20, r18
    6218:	51 1d       	adc	r21, r1
    621a:	61 1d       	adc	r22, r1
    621c:	71 1d       	adc	r23, r1
    621e:	80 e2       	ldi	r24, 0x20	; 32
    6220:	90 e0       	ldi	r25, 0x00	; 0
    6222:	a0 e0       	ldi	r26, 0x00	; 0
    6224:	b0 e0       	ldi	r27, 0x00	; 0
    6226:	84 1b       	sub	r24, r20
    6228:	95 0b       	sbc	r25, r21
    622a:	a6 0b       	sbc	r26, r22
    622c:	b7 0b       	sbc	r27, r23
    622e:	51 f4       	brne	.+20     	; 0x6244 <__stack+0x245>
    6230:	c8 18       	sub	r12, r8
    6232:	d9 08       	sbc	r13, r9
    6234:	ea 08       	sbc	r14, r10
    6236:	fb 08       	sbc	r15, r11
    6238:	f1 e0       	ldi	r31, 0x01	; 1
    623a:	4f 2e       	mov	r4, r31
    623c:	51 2c       	mov	r5, r1
    623e:	61 2c       	mov	r6, r1
    6240:	71 2c       	mov	r7, r1
    6242:	28 c1       	rjmp	.+592    	; 0x6494 <__stack+0x495>
    6244:	08 2e       	mov	r0, r24
    6246:	04 c0       	rjmp	.+8      	; 0x6250 <__stack+0x251>
    6248:	88 0c       	add	r8, r8
    624a:	99 1c       	adc	r9, r9
    624c:	aa 1c       	adc	r10, r10
    624e:	bb 1c       	adc	r11, r11
    6250:	0a 94       	dec	r0
    6252:	d2 f7       	brpl	.-12     	; 0x6248 <__stack+0x249>
    6254:	97 01       	movw	r18, r14
    6256:	86 01       	movw	r16, r12
    6258:	04 2e       	mov	r0, r20
    625a:	04 c0       	rjmp	.+8      	; 0x6264 <__stack+0x265>
    625c:	36 95       	lsr	r19
    625e:	27 95       	ror	r18
    6260:	17 95       	ror	r17
    6262:	07 95       	ror	r16
    6264:	0a 94       	dec	r0
    6266:	d2 f7       	brpl	.-12     	; 0x625c <__stack+0x25d>
    6268:	09 ab       	sts	0x59, r16
    626a:	1a ab       	sts	0x5a, r17
    626c:	2b ab       	sts	0x5b, r18
    626e:	3c ab       	sts	0x5c, r19
    6270:	97 01       	movw	r18, r14
    6272:	86 01       	movw	r16, r12
    6274:	08 2e       	mov	r0, r24
    6276:	04 c0       	rjmp	.+8      	; 0x6280 <__stack+0x281>
    6278:	00 0f       	add	r16, r16
    627a:	11 1f       	adc	r17, r17
    627c:	22 1f       	adc	r18, r18
    627e:	33 1f       	adc	r19, r19
    6280:	0a 94       	dec	r0
    6282:	d2 f7       	brpl	.-12     	; 0x6278 <__stack+0x279>
    6284:	0d a7       	lds	r16, 0x7d
    6286:	1e a7       	lds	r17, 0x7e
    6288:	2f a7       	lds	r18, 0x7f
    628a:	38 ab       	sts	0x58, r19
    628c:	ed a8       	sts	0x8d, r30
    628e:	fe a8       	sts	0x8e, r31
    6290:	0f a9       	sts	0x4f, r16
    6292:	18 ad       	sts	0x68, r17
    6294:	04 c0       	rjmp	.+8      	; 0x629e <__stack+0x29f>
    6296:	16 95       	lsr	r17
    6298:	07 95       	ror	r16
    629a:	f7 94       	ror	r15
    629c:	e7 94       	ror	r14
    629e:	4a 95       	dec	r20
    62a0:	d2 f7       	brpl	.-12     	; 0x6296 <__stack+0x297>
    62a2:	b8 01       	movw	r22, r16
    62a4:	a7 01       	movw	r20, r14
    62a6:	0d a5       	lds	r16, 0x6d
    62a8:	1e a5       	lds	r17, 0x6e
    62aa:	2f a5       	lds	r18, 0x6f
    62ac:	38 a9       	sts	0x48, r19
    62ae:	04 2b       	or	r16, r20
    62b0:	15 2b       	or	r17, r21
    62b2:	26 2b       	or	r18, r22
    62b4:	37 2b       	or	r19, r23
    62b6:	0d a7       	lds	r16, 0x7d
    62b8:	1e a7       	lds	r17, 0x7e
    62ba:	2f a7       	lds	r18, 0x7f
    62bc:	38 ab       	sts	0x58, r19
    62be:	ed a8       	sts	0x8d, r30
    62c0:	fe a8       	sts	0x8e, r31
    62c2:	0f a9       	sts	0x4f, r16
    62c4:	18 ad       	sts	0x68, r17
    62c6:	04 c0       	rjmp	.+8      	; 0x62d0 <__stack+0x2d1>
    62c8:	ee 0c       	add	r14, r14
    62ca:	ff 1c       	adc	r15, r15
    62cc:	00 1f       	adc	r16, r16
    62ce:	11 1f       	adc	r17, r17
    62d0:	8a 95       	dec	r24
    62d2:	d2 f7       	brpl	.-12     	; 0x62c8 <__stack+0x2c9>
    62d4:	ed aa       	sts	0x9d, r30
    62d6:	fe aa       	sts	0x9e, r31
    62d8:	0f ab       	sts	0x5f, r16
    62da:	18 af       	sts	0x78, r17
    62dc:	25 01       	movw	r4, r10
    62de:	66 24       	eor	r6, r6
    62e0:	77 24       	eor	r7, r7
    62e2:	95 01       	movw	r18, r10
    62e4:	84 01       	movw	r16, r8
    62e6:	20 70       	andi	r18, 0x00	; 0
    62e8:	30 70       	andi	r19, 0x00	; 0
    62ea:	09 af       	sts	0x79, r16
    62ec:	1a af       	sts	0x7a, r17
    62ee:	2b af       	sts	0x7b, r18
    62f0:	3c af       	sts	0x7c, r19
    62f2:	69 a9       	sts	0x49, r22
    62f4:	7a a9       	sts	0x4a, r23
    62f6:	8b a9       	sts	0x4b, r24
    62f8:	9c a9       	sts	0x4c, r25
    62fa:	a3 01       	movw	r20, r6
    62fc:	92 01       	movw	r18, r4
    62fe:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    6302:	29 a7       	lds	r18, 0x79
    6304:	3a a7       	lds	r19, 0x7a
    6306:	4b a7       	lds	r20, 0x7b
    6308:	5c a7       	lds	r21, 0x7c
    630a:	6b 01       	movw	r12, r22
    630c:	7c 01       	movw	r14, r24
    630e:	69 a9       	sts	0x49, r22
    6310:	7a a9       	sts	0x4a, r23
    6312:	8b a9       	sts	0x4b, r24
    6314:	9c a9       	sts	0x4c, r25
    6316:	a3 01       	movw	r20, r6
    6318:	92 01       	movw	r18, r4
    631a:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    631e:	ca 01       	movw	r24, r20
    6320:	b9 01       	movw	r22, r18
    6322:	29 ad       	sts	0x69, r18
    6324:	3a ad       	sts	0x6a, r19
    6326:	4b ad       	sts	0x6b, r20
    6328:	5c ad       	sts	0x6c, r21
    632a:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    632e:	ab 01       	movw	r20, r22
    6330:	bc 01       	movw	r22, r24
    6332:	76 01       	movw	r14, r12
    6334:	dd 24       	eor	r13, r13
    6336:	cc 24       	eor	r12, r12
    6338:	0d a5       	lds	r16, 0x6d
    633a:	1e a5       	lds	r17, 0x6e
    633c:	2f a5       	lds	r18, 0x6f
    633e:	38 a9       	sts	0x48, r19
    6340:	c9 01       	movw	r24, r18
    6342:	aa 27       	eor	r26, r26
    6344:	bb 27       	eor	r27, r27
    6346:	c8 2a       	or	r12, r24
    6348:	d9 2a       	or	r13, r25
    634a:	ea 2a       	or	r14, r26
    634c:	fb 2a       	or	r15, r27
    634e:	09 a5       	lds	r16, 0x69
    6350:	1a a5       	lds	r17, 0x6a
    6352:	2b a5       	lds	r18, 0x6b
    6354:	3c a5       	lds	r19, 0x6c
    6356:	c4 16       	cp	r12, r20
    6358:	d5 06       	cpc	r13, r21
    635a:	e6 06       	cpc	r14, r22
    635c:	f7 06       	cpc	r15, r23
    635e:	38 f5       	brcc	.+78     	; 0x63ae <__stack+0x3af>
    6360:	01 50       	subi	r16, 0x01	; 1
    6362:	10 40       	sbci	r17, 0x00	; 0
    6364:	20 40       	sbci	r18, 0x00	; 0
    6366:	30 40       	sbci	r19, 0x00	; 0
    6368:	09 ab       	sts	0x59, r16
    636a:	1a ab       	sts	0x5a, r17
    636c:	2b ab       	sts	0x5b, r18
    636e:	3c ab       	sts	0x5c, r19
    6370:	c8 0c       	add	r12, r8
    6372:	d9 1c       	adc	r13, r9
    6374:	ea 1c       	adc	r14, r10
    6376:	fb 1c       	adc	r15, r11
    6378:	c8 14       	cp	r12, r8
    637a:	d9 04       	cpc	r13, r9
    637c:	ea 04       	cpc	r14, r10
    637e:	fb 04       	cpc	r15, r11
    6380:	d0 f0       	brcs	.+52     	; 0x63b6 <__stack+0x3b7>
    6382:	c4 16       	cp	r12, r20
    6384:	d5 06       	cpc	r13, r21
    6386:	e6 06       	cpc	r14, r22
    6388:	f7 06       	cpc	r15, r23
    638a:	a8 f4       	brcc	.+42     	; 0x63b6 <__stack+0x3b7>
    638c:	09 a5       	lds	r16, 0x69
    638e:	1a a5       	lds	r17, 0x6a
    6390:	2b a5       	lds	r18, 0x6b
    6392:	3c a5       	lds	r19, 0x6c
    6394:	02 50       	subi	r16, 0x02	; 2
    6396:	10 40       	sbci	r17, 0x00	; 0
    6398:	20 40       	sbci	r18, 0x00	; 0
    639a:	30 40       	sbci	r19, 0x00	; 0
    639c:	09 ab       	sts	0x59, r16
    639e:	1a ab       	sts	0x5a, r17
    63a0:	2b ab       	sts	0x5b, r18
    63a2:	3c ab       	sts	0x5c, r19
    63a4:	c8 0c       	add	r12, r8
    63a6:	d9 1c       	adc	r13, r9
    63a8:	ea 1c       	adc	r14, r10
    63aa:	fb 1c       	adc	r15, r11
    63ac:	04 c0       	rjmp	.+8      	; 0x63b6 <__stack+0x3b7>
    63ae:	09 ab       	sts	0x59, r16
    63b0:	1a ab       	sts	0x5a, r17
    63b2:	2b ab       	sts	0x5b, r18
    63b4:	3c ab       	sts	0x5c, r19
    63b6:	c4 1a       	sub	r12, r20
    63b8:	d5 0a       	sbc	r13, r21
    63ba:	e6 0a       	sbc	r14, r22
    63bc:	f7 0a       	sbc	r15, r23
    63be:	c7 01       	movw	r24, r14
    63c0:	b6 01       	movw	r22, r12
    63c2:	a3 01       	movw	r20, r6
    63c4:	92 01       	movw	r18, r4
    63c6:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    63ca:	29 a7       	lds	r18, 0x79
    63cc:	3a a7       	lds	r19, 0x7a
    63ce:	4b a7       	lds	r20, 0x7b
    63d0:	5c a7       	lds	r21, 0x7c
    63d2:	21 96       	adiw	r28, 0x01	; 1
    63d4:	6c af       	sts	0x7c, r22
    63d6:	7d af       	sts	0x7d, r23
    63d8:	8e af       	sts	0x7e, r24
    63da:	9f af       	sts	0x7f, r25
    63dc:	21 97       	sbiw	r28, 0x01	; 1
    63de:	c7 01       	movw	r24, r14
    63e0:	b6 01       	movw	r22, r12
    63e2:	a3 01       	movw	r20, r6
    63e4:	92 01       	movw	r18, r4
    63e6:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    63ea:	ca 01       	movw	r24, r20
    63ec:	b9 01       	movw	r22, r18
    63ee:	29 ad       	sts	0x69, r18
    63f0:	3a ad       	sts	0x6a, r19
    63f2:	4b ad       	sts	0x6b, r20
    63f4:	5c ad       	sts	0x6c, r21
    63f6:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    63fa:	8b 01       	movw	r16, r22
    63fc:	9c 01       	movw	r18, r24
    63fe:	21 96       	adiw	r28, 0x01	; 1
    6400:	4c ad       	sts	0x6c, r20
    6402:	5d ad       	sts	0x6d, r21
    6404:	6e ad       	sts	0x6e, r22
    6406:	7f ad       	sts	0x6f, r23
    6408:	21 97       	sbiw	r28, 0x01	; 1
    640a:	da 01       	movw	r26, r20
    640c:	99 27       	eor	r25, r25
    640e:	88 27       	eor	r24, r24
    6410:	4d a5       	lds	r20, 0x6d
    6412:	5e a5       	lds	r21, 0x6e
    6414:	6f a5       	lds	r22, 0x6f
    6416:	78 a9       	sts	0x48, r23
    6418:	60 70       	andi	r22, 0x00	; 0
    641a:	70 70       	andi	r23, 0x00	; 0
    641c:	84 2b       	or	r24, r20
    641e:	95 2b       	or	r25, r21
    6420:	a6 2b       	or	r26, r22
    6422:	b7 2b       	or	r27, r23
    6424:	49 a5       	lds	r20, 0x69
    6426:	5a a5       	lds	r21, 0x6a
    6428:	6b a5       	lds	r22, 0x6b
    642a:	7c a5       	lds	r23, 0x6c
    642c:	80 17       	cp	r24, r16
    642e:	91 07       	cpc	r25, r17
    6430:	a2 07       	cpc	r26, r18
    6432:	b3 07       	cpc	r27, r19
    6434:	f0 f4       	brcc	.+60     	; 0x6472 <__stack+0x473>
    6436:	41 50       	subi	r20, 0x01	; 1
    6438:	50 40       	sbci	r21, 0x00	; 0
    643a:	60 40       	sbci	r22, 0x00	; 0
    643c:	70 40       	sbci	r23, 0x00	; 0
    643e:	88 0d       	add	r24, r8
    6440:	99 1d       	adc	r25, r9
    6442:	aa 1d       	adc	r26, r10
    6444:	bb 1d       	adc	r27, r11
    6446:	88 15       	cp	r24, r8
    6448:	99 05       	cpc	r25, r9
    644a:	aa 05       	cpc	r26, r10
    644c:	bb 05       	cpc	r27, r11
    644e:	88 f0       	brcs	.+34     	; 0x6472 <__stack+0x473>
    6450:	80 17       	cp	r24, r16
    6452:	91 07       	cpc	r25, r17
    6454:	a2 07       	cpc	r26, r18
    6456:	b3 07       	cpc	r27, r19
    6458:	60 f4       	brcc	.+24     	; 0x6472 <__stack+0x473>
    645a:	49 a5       	lds	r20, 0x69
    645c:	5a a5       	lds	r21, 0x6a
    645e:	6b a5       	lds	r22, 0x6b
    6460:	7c a5       	lds	r23, 0x6c
    6462:	42 50       	subi	r20, 0x02	; 2
    6464:	50 40       	sbci	r21, 0x00	; 0
    6466:	60 40       	sbci	r22, 0x00	; 0
    6468:	70 40       	sbci	r23, 0x00	; 0
    646a:	88 0d       	add	r24, r8
    646c:	99 1d       	adc	r25, r9
    646e:	aa 1d       	adc	r26, r10
    6470:	bb 1d       	adc	r27, r11
    6472:	6c 01       	movw	r12, r24
    6474:	7d 01       	movw	r14, r26
    6476:	c0 1a       	sub	r12, r16
    6478:	d1 0a       	sbc	r13, r17
    647a:	e2 0a       	sbc	r14, r18
    647c:	f3 0a       	sbc	r15, r19
    647e:	09 a9       	sts	0x49, r16
    6480:	1a a9       	sts	0x4a, r17
    6482:	2b a9       	sts	0x4b, r18
    6484:	3c a9       	sts	0x4c, r19
    6486:	38 01       	movw	r6, r16
    6488:	55 24       	eor	r5, r5
    648a:	44 24       	eor	r4, r4
    648c:	44 2a       	or	r4, r20
    648e:	55 2a       	or	r5, r21
    6490:	66 2a       	or	r6, r22
    6492:	77 2a       	or	r7, r23
    6494:	85 01       	movw	r16, r10
    6496:	22 27       	eor	r18, r18
    6498:	33 27       	eor	r19, r19
    649a:	0d a7       	lds	r16, 0x7d
    649c:	1e a7       	lds	r17, 0x7e
    649e:	2f a7       	lds	r18, 0x7f
    64a0:	38 ab       	sts	0x58, r19
    64a2:	95 01       	movw	r18, r10
    64a4:	84 01       	movw	r16, r8
    64a6:	20 70       	andi	r18, 0x00	; 0
    64a8:	30 70       	andi	r19, 0x00	; 0
    64aa:	09 af       	sts	0x79, r16
    64ac:	1a af       	sts	0x7a, r17
    64ae:	2b af       	sts	0x7b, r18
    64b0:	3c af       	sts	0x7c, r19
    64b2:	c7 01       	movw	r24, r14
    64b4:	b6 01       	movw	r22, r12
    64b6:	2d a5       	lds	r18, 0x6d
    64b8:	3e a5       	lds	r19, 0x6e
    64ba:	4f a5       	lds	r20, 0x6f
    64bc:	58 a9       	sts	0x48, r21
    64be:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    64c2:	29 a7       	lds	r18, 0x79
    64c4:	3a a7       	lds	r19, 0x7a
    64c6:	4b a7       	lds	r20, 0x7b
    64c8:	5c a7       	lds	r21, 0x7c
    64ca:	69 ab       	sts	0x59, r22
    64cc:	7a ab       	sts	0x5a, r23
    64ce:	8b ab       	sts	0x5b, r24
    64d0:	9c ab       	sts	0x5c, r25
    64d2:	c7 01       	movw	r24, r14
    64d4:	b6 01       	movw	r22, r12
    64d6:	2d a5       	lds	r18, 0x6d
    64d8:	3e a5       	lds	r19, 0x6e
    64da:	4f a5       	lds	r20, 0x6f
    64dc:	58 a9       	sts	0x48, r21
    64de:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    64e2:	ca 01       	movw	r24, r20
    64e4:	b9 01       	movw	r22, r18
    64e6:	29 ad       	sts	0x69, r18
    64e8:	3a ad       	sts	0x6a, r19
    64ea:	4b ad       	sts	0x6b, r20
    64ec:	5c ad       	sts	0x6c, r21
    64ee:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    64f2:	ab 01       	movw	r20, r22
    64f4:	bc 01       	movw	r22, r24
    64f6:	09 a9       	sts	0x49, r16
    64f8:	1a a9       	sts	0x4a, r17
    64fa:	2b a9       	sts	0x4b, r18
    64fc:	3c a9       	sts	0x4c, r19
    64fe:	78 01       	movw	r14, r16
    6500:	dd 24       	eor	r13, r13
    6502:	cc 24       	eor	r12, r12
    6504:	0d a9       	sts	0x4d, r16
    6506:	1e a9       	sts	0x4e, r17
    6508:	2f a9       	sts	0x4f, r18
    650a:	38 ad       	sts	0x68, r19
    650c:	c9 01       	movw	r24, r18
    650e:	aa 27       	eor	r26, r26
    6510:	bb 27       	eor	r27, r27
    6512:	c8 2a       	or	r12, r24
    6514:	d9 2a       	or	r13, r25
    6516:	ea 2a       	or	r14, r26
    6518:	fb 2a       	or	r15, r27
    651a:	09 a5       	lds	r16, 0x69
    651c:	1a a5       	lds	r17, 0x6a
    651e:	2b a5       	lds	r18, 0x6b
    6520:	3c a5       	lds	r19, 0x6c
    6522:	c4 16       	cp	r12, r20
    6524:	d5 06       	cpc	r13, r21
    6526:	e6 06       	cpc	r14, r22
    6528:	f7 06       	cpc	r15, r23
    652a:	38 f5       	brcc	.+78     	; 0x657a <__stack+0x57b>
    652c:	01 50       	subi	r16, 0x01	; 1
    652e:	10 40       	sbci	r17, 0x00	; 0
    6530:	20 40       	sbci	r18, 0x00	; 0
    6532:	30 40       	sbci	r19, 0x00	; 0
    6534:	09 ab       	sts	0x59, r16
    6536:	1a ab       	sts	0x5a, r17
    6538:	2b ab       	sts	0x5b, r18
    653a:	3c ab       	sts	0x5c, r19
    653c:	c8 0c       	add	r12, r8
    653e:	d9 1c       	adc	r13, r9
    6540:	ea 1c       	adc	r14, r10
    6542:	fb 1c       	adc	r15, r11
    6544:	c8 14       	cp	r12, r8
    6546:	d9 04       	cpc	r13, r9
    6548:	ea 04       	cpc	r14, r10
    654a:	fb 04       	cpc	r15, r11
    654c:	d0 f0       	brcs	.+52     	; 0x6582 <__stack+0x583>
    654e:	c4 16       	cp	r12, r20
    6550:	d5 06       	cpc	r13, r21
    6552:	e6 06       	cpc	r14, r22
    6554:	f7 06       	cpc	r15, r23
    6556:	a8 f4       	brcc	.+42     	; 0x6582 <__stack+0x583>
    6558:	09 a5       	lds	r16, 0x69
    655a:	1a a5       	lds	r17, 0x6a
    655c:	2b a5       	lds	r18, 0x6b
    655e:	3c a5       	lds	r19, 0x6c
    6560:	02 50       	subi	r16, 0x02	; 2
    6562:	10 40       	sbci	r17, 0x00	; 0
    6564:	20 40       	sbci	r18, 0x00	; 0
    6566:	30 40       	sbci	r19, 0x00	; 0
    6568:	09 ab       	sts	0x59, r16
    656a:	1a ab       	sts	0x5a, r17
    656c:	2b ab       	sts	0x5b, r18
    656e:	3c ab       	sts	0x5c, r19
    6570:	c8 0c       	add	r12, r8
    6572:	d9 1c       	adc	r13, r9
    6574:	ea 1c       	adc	r14, r10
    6576:	fb 1c       	adc	r15, r11
    6578:	04 c0       	rjmp	.+8      	; 0x6582 <__stack+0x583>
    657a:	09 ab       	sts	0x59, r16
    657c:	1a ab       	sts	0x5a, r17
    657e:	2b ab       	sts	0x5b, r18
    6580:	3c ab       	sts	0x5c, r19
    6582:	c4 1a       	sub	r12, r20
    6584:	d5 0a       	sbc	r13, r21
    6586:	e6 0a       	sbc	r14, r22
    6588:	f7 0a       	sbc	r15, r23
    658a:	c7 01       	movw	r24, r14
    658c:	b6 01       	movw	r22, r12
    658e:	2d a5       	lds	r18, 0x6d
    6590:	3e a5       	lds	r19, 0x6e
    6592:	4f a5       	lds	r20, 0x6f
    6594:	58 a9       	sts	0x48, r21
    6596:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    659a:	29 a7       	lds	r18, 0x79
    659c:	3a a7       	lds	r19, 0x7a
    659e:	4b a7       	lds	r20, 0x7b
    65a0:	5c a7       	lds	r21, 0x7c
    65a2:	21 96       	adiw	r28, 0x01	; 1
    65a4:	6c af       	sts	0x7c, r22
    65a6:	7d af       	sts	0x7d, r23
    65a8:	8e af       	sts	0x7e, r24
    65aa:	9f af       	sts	0x7f, r25
    65ac:	21 97       	sbiw	r28, 0x01	; 1
    65ae:	c7 01       	movw	r24, r14
    65b0:	b6 01       	movw	r22, r12
    65b2:	2d a5       	lds	r18, 0x6d
    65b4:	3e a5       	lds	r19, 0x6e
    65b6:	4f a5       	lds	r20, 0x6f
    65b8:	58 a9       	sts	0x48, r21
    65ba:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    65be:	ca 01       	movw	r24, r20
    65c0:	b9 01       	movw	r22, r18
    65c2:	29 ad       	sts	0x69, r18
    65c4:	3a ad       	sts	0x6a, r19
    65c6:	4b ad       	sts	0x6b, r20
    65c8:	5c ad       	sts	0x6c, r21
    65ca:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    65ce:	8b 01       	movw	r16, r22
    65d0:	9c 01       	movw	r18, r24
    65d2:	21 96       	adiw	r28, 0x01	; 1
    65d4:	4c ad       	sts	0x6c, r20
    65d6:	5d ad       	sts	0x6d, r21
    65d8:	6e ad       	sts	0x6e, r22
    65da:	7f ad       	sts	0x6f, r23
    65dc:	21 97       	sbiw	r28, 0x01	; 1
    65de:	da 01       	movw	r26, r20
    65e0:	99 27       	eor	r25, r25
    65e2:	88 27       	eor	r24, r24
    65e4:	4d a9       	sts	0x4d, r20
    65e6:	5e a9       	sts	0x4e, r21
    65e8:	6f a9       	sts	0x4f, r22
    65ea:	78 ad       	sts	0x68, r23
    65ec:	60 70       	andi	r22, 0x00	; 0
    65ee:	70 70       	andi	r23, 0x00	; 0
    65f0:	84 2b       	or	r24, r20
    65f2:	95 2b       	or	r25, r21
    65f4:	a6 2b       	or	r26, r22
    65f6:	b7 2b       	or	r27, r23
    65f8:	49 a5       	lds	r20, 0x69
    65fa:	5a a5       	lds	r21, 0x6a
    65fc:	6b a5       	lds	r22, 0x6b
    65fe:	7c a5       	lds	r23, 0x6c
    6600:	80 17       	cp	r24, r16
    6602:	91 07       	cpc	r25, r17
    6604:	a2 07       	cpc	r26, r18
    6606:	b3 07       	cpc	r27, r19
    6608:	d0 f4       	brcc	.+52     	; 0x663e <__stack+0x63f>
    660a:	41 50       	subi	r20, 0x01	; 1
    660c:	50 40       	sbci	r21, 0x00	; 0
    660e:	60 40       	sbci	r22, 0x00	; 0
    6610:	70 40       	sbci	r23, 0x00	; 0
    6612:	88 0d       	add	r24, r8
    6614:	99 1d       	adc	r25, r9
    6616:	aa 1d       	adc	r26, r10
    6618:	bb 1d       	adc	r27, r11
    661a:	88 15       	cp	r24, r8
    661c:	99 05       	cpc	r25, r9
    661e:	aa 05       	cpc	r26, r10
    6620:	bb 05       	cpc	r27, r11
    6622:	68 f0       	brcs	.+26     	; 0x663e <__stack+0x63f>
    6624:	80 17       	cp	r24, r16
    6626:	91 07       	cpc	r25, r17
    6628:	a2 07       	cpc	r26, r18
    662a:	b3 07       	cpc	r27, r19
    662c:	40 f4       	brcc	.+16     	; 0x663e <__stack+0x63f>
    662e:	49 a5       	lds	r20, 0x69
    6630:	5a a5       	lds	r21, 0x6a
    6632:	6b a5       	lds	r22, 0x6b
    6634:	7c a5       	lds	r23, 0x6c
    6636:	42 50       	subi	r20, 0x02	; 2
    6638:	50 40       	sbci	r21, 0x00	; 0
    663a:	60 40       	sbci	r22, 0x00	; 0
    663c:	70 40       	sbci	r23, 0x00	; 0
    663e:	09 a9       	sts	0x49, r16
    6640:	1a a9       	sts	0x4a, r17
    6642:	2b a9       	sts	0x4b, r18
    6644:	3c a9       	sts	0x4c, r19
    6646:	78 01       	movw	r14, r16
    6648:	dd 24       	eor	r13, r13
    664a:	cc 24       	eor	r12, r12
    664c:	c4 2a       	or	r12, r20
    664e:	d5 2a       	or	r13, r21
    6650:	e6 2a       	or	r14, r22
    6652:	f7 2a       	or	r15, r23
    6654:	50 c2       	rjmp	.+1184   	; 0x6af6 <__stack+0xaf7>
    6656:	c8 16       	cp	r12, r24
    6658:	d9 06       	cpc	r13, r25
    665a:	ea 06       	cpc	r14, r26
    665c:	fb 06       	cpc	r15, r27
    665e:	08 f4       	brcc	.+2      	; 0x6662 <__stack+0x663>
    6660:	37 c2       	rjmp	.+1134   	; 0x6ad0 <__stack+0xad1>
    6662:	80 30       	cpi	r24, 0x00	; 0
    6664:	10 e0       	ldi	r17, 0x00	; 0
    6666:	91 07       	cpc	r25, r17
    6668:	11 e0       	ldi	r17, 0x01	; 1
    666a:	a1 07       	cpc	r26, r17
    666c:	10 e0       	ldi	r17, 0x00	; 0
    666e:	b1 07       	cpc	r27, r17
    6670:	50 f4       	brcc	.+20     	; 0x6686 <__stack+0x687>
    6672:	8f 3f       	cpi	r24, 0xFF	; 255
    6674:	91 05       	cpc	r25, r1
    6676:	a1 05       	cpc	r26, r1
    6678:	b1 05       	cpc	r27, r1
    667a:	09 f0       	breq	.+2      	; 0x667e <__stack+0x67f>
    667c:	88 f4       	brcc	.+34     	; 0x66a0 <__stack+0x6a1>
    667e:	00 e0       	ldi	r16, 0x00	; 0
    6680:	10 e0       	ldi	r17, 0x00	; 0
    6682:	98 01       	movw	r18, r16
    6684:	16 c0       	rjmp	.+44     	; 0x66b2 <__stack+0x6b3>
    6686:	80 30       	cpi	r24, 0x00	; 0
    6688:	20 e0       	ldi	r18, 0x00	; 0
    668a:	92 07       	cpc	r25, r18
    668c:	20 e0       	ldi	r18, 0x00	; 0
    668e:	a2 07       	cpc	r26, r18
    6690:	21 e0       	ldi	r18, 0x01	; 1
    6692:	b2 07       	cpc	r27, r18
    6694:	50 f4       	brcc	.+20     	; 0x66aa <__stack+0x6ab>
    6696:	00 e1       	ldi	r16, 0x10	; 16
    6698:	10 e0       	ldi	r17, 0x00	; 0
    669a:	20 e0       	ldi	r18, 0x00	; 0
    669c:	30 e0       	ldi	r19, 0x00	; 0
    669e:	09 c0       	rjmp	.+18     	; 0x66b2 <__stack+0x6b3>
    66a0:	08 e0       	ldi	r16, 0x08	; 8
    66a2:	10 e0       	ldi	r17, 0x00	; 0
    66a4:	20 e0       	ldi	r18, 0x00	; 0
    66a6:	30 e0       	ldi	r19, 0x00	; 0
    66a8:	04 c0       	rjmp	.+8      	; 0x66b2 <__stack+0x6b3>
    66aa:	08 e1       	ldi	r16, 0x18	; 24
    66ac:	10 e0       	ldi	r17, 0x00	; 0
    66ae:	20 e0       	ldi	r18, 0x00	; 0
    66b0:	30 e0       	ldi	r19, 0x00	; 0
    66b2:	ac 01       	movw	r20, r24
    66b4:	bd 01       	movw	r22, r26
    66b6:	00 2e       	mov	r0, r16
    66b8:	04 c0       	rjmp	.+8      	; 0x66c2 <__stack+0x6c3>
    66ba:	76 95       	lsr	r23
    66bc:	67 95       	ror	r22
    66be:	57 95       	ror	r21
    66c0:	47 95       	ror	r20
    66c2:	0a 94       	dec	r0
    66c4:	d2 f7       	brpl	.-12     	; 0x66ba <__stack+0x6bb>
    66c6:	fa 01       	movw	r30, r20
    66c8:	e3 5f       	subi	r30, 0xF3	; 243
    66ca:	ff 4d       	sbci	r31, 0xDF	; 223
    66cc:	40 81       	ld	r20, Z
    66ce:	04 0f       	add	r16, r20
    66d0:	11 1d       	adc	r17, r1
    66d2:	21 1d       	adc	r18, r1
    66d4:	31 1d       	adc	r19, r1
    66d6:	40 e2       	ldi	r20, 0x20	; 32
    66d8:	50 e0       	ldi	r21, 0x00	; 0
    66da:	60 e0       	ldi	r22, 0x00	; 0
    66dc:	70 e0       	ldi	r23, 0x00	; 0
    66de:	40 1b       	sub	r20, r16
    66e0:	51 0b       	sbc	r21, r17
    66e2:	62 0b       	sbc	r22, r18
    66e4:	73 0b       	sbc	r23, r19
    66e6:	a1 f4       	brne	.+40     	; 0x6710 <__stack+0x711>
    66e8:	8c 15       	cp	r24, r12
    66ea:	9d 05       	cpc	r25, r13
    66ec:	ae 05       	cpc	r26, r14
    66ee:	bf 05       	cpc	r27, r15
    66f0:	08 f4       	brcc	.+2      	; 0x66f4 <__stack+0x6f5>
    66f2:	f5 c1       	rjmp	.+1002   	; 0x6ade <__stack+0xadf>
    66f4:	ed a8       	sts	0x8d, r30
    66f6:	fe a8       	sts	0x8e, r31
    66f8:	0f a9       	sts	0x4f, r16
    66fa:	18 ad       	sts	0x68, r17
    66fc:	44 24       	eor	r4, r4
    66fe:	55 24       	eor	r5, r5
    6700:	32 01       	movw	r6, r4
    6702:	e8 14       	cp	r14, r8
    6704:	f9 04       	cpc	r15, r9
    6706:	0a 05       	cpc	r16, r10
    6708:	1b 05       	cpc	r17, r11
    670a:	08 f0       	brcs	.+2      	; 0x670e <__stack+0x70f>
    670c:	eb c1       	rjmp	.+982    	; 0x6ae4 <__stack+0xae5>
    670e:	e3 c1       	rjmp	.+966    	; 0x6ad6 <__stack+0xad7>
    6710:	34 2e       	mov	r3, r20
    6712:	2c 01       	movw	r4, r24
    6714:	3d 01       	movw	r6, r26
    6716:	04 c0       	rjmp	.+8      	; 0x6720 <__stack+0x721>
    6718:	44 0c       	add	r4, r4
    671a:	55 1c       	adc	r5, r5
    671c:	66 1c       	adc	r6, r6
    671e:	77 1c       	adc	r7, r7
    6720:	4a 95       	dec	r20
    6722:	d2 f7       	brpl	.-12     	; 0x6718 <__stack+0x719>
    6724:	d5 01       	movw	r26, r10
    6726:	c4 01       	movw	r24, r8
    6728:	00 2e       	mov	r0, r16
    672a:	04 c0       	rjmp	.+8      	; 0x6734 <__stack+0x735>
    672c:	b6 95       	lsr	r27
    672e:	a7 95       	ror	r26
    6730:	97 95       	ror	r25
    6732:	87 95       	ror	r24
    6734:	0a 94       	dec	r0
    6736:	d2 f7       	brpl	.-12     	; 0x672c <__stack+0x72d>
    6738:	48 2a       	or	r4, r24
    673a:	59 2a       	or	r5, r25
    673c:	6a 2a       	or	r6, r26
    673e:	7b 2a       	or	r7, r27
    6740:	a5 01       	movw	r20, r10
    6742:	94 01       	movw	r18, r8
    6744:	03 2c       	mov	r0, r3
    6746:	04 c0       	rjmp	.+8      	; 0x6750 <__stack+0x751>
    6748:	22 0f       	add	r18, r18
    674a:	33 1f       	adc	r19, r19
    674c:	44 1f       	adc	r20, r20
    674e:	55 1f       	adc	r21, r21
    6750:	0a 94       	dec	r0
    6752:	d2 f7       	brpl	.-12     	; 0x6748 <__stack+0x749>
    6754:	29 af       	sts	0x79, r18
    6756:	3a af       	sts	0x7a, r19
    6758:	4b af       	sts	0x7b, r20
    675a:	5c af       	sts	0x7c, r21
    675c:	b7 01       	movw	r22, r14
    675e:	a6 01       	movw	r20, r12
    6760:	00 2e       	mov	r0, r16
    6762:	04 c0       	rjmp	.+8      	; 0x676c <__stack+0x76d>
    6764:	76 95       	lsr	r23
    6766:	67 95       	ror	r22
    6768:	57 95       	ror	r21
    676a:	47 95       	ror	r20
    676c:	0a 94       	dec	r0
    676e:	d2 f7       	brpl	.-12     	; 0x6764 <__stack+0x765>
    6770:	49 ab       	sts	0x59, r20
    6772:	5a ab       	sts	0x5a, r21
    6774:	6b ab       	sts	0x5b, r22
    6776:	7c ab       	sts	0x5c, r23
    6778:	c7 01       	movw	r24, r14
    677a:	b6 01       	movw	r22, r12
    677c:	03 2c       	mov	r0, r3
    677e:	04 c0       	rjmp	.+8      	; 0x6788 <__stack+0x789>
    6780:	66 0f       	add	r22, r22
    6782:	77 1f       	adc	r23, r23
    6784:	88 1f       	adc	r24, r24
    6786:	99 1f       	adc	r25, r25
    6788:	0a 94       	dec	r0
    678a:	d2 f7       	brpl	.-12     	; 0x6780 <__stack+0x781>
    678c:	6d a7       	lds	r22, 0x7d
    678e:	7e a7       	lds	r23, 0x7e
    6790:	8f a7       	lds	r24, 0x7f
    6792:	98 ab       	sts	0x58, r25
    6794:	8d a9       	sts	0x4d, r24
    6796:	9e a9       	sts	0x4e, r25
    6798:	af a9       	sts	0x4f, r26
    679a:	b8 ad       	sts	0x68, r27
    679c:	04 c0       	rjmp	.+8      	; 0x67a6 <__stack+0x7a7>
    679e:	b6 95       	lsr	r27
    67a0:	a7 95       	ror	r26
    67a2:	97 95       	ror	r25
    67a4:	87 95       	ror	r24
    67a6:	0a 95       	dec	r16
    67a8:	d2 f7       	brpl	.-12     	; 0x679e <__stack+0x79f>
    67aa:	4d a5       	lds	r20, 0x6d
    67ac:	5e a5       	lds	r21, 0x6e
    67ae:	6f a5       	lds	r22, 0x6f
    67b0:	78 a9       	sts	0x48, r23
    67b2:	48 2b       	or	r20, r24
    67b4:	59 2b       	or	r21, r25
    67b6:	6a 2b       	or	r22, r26
    67b8:	7b 2b       	or	r23, r27
    67ba:	4d a7       	lds	r20, 0x7d
    67bc:	5e a7       	lds	r21, 0x7e
    67be:	6f a7       	lds	r22, 0x7f
    67c0:	78 ab       	sts	0x58, r23
    67c2:	43 01       	movw	r8, r6
    67c4:	aa 24       	eor	r10, r10
    67c6:	bb 24       	eor	r11, r11
    67c8:	93 01       	movw	r18, r6
    67ca:	82 01       	movw	r16, r4
    67cc:	20 70       	andi	r18, 0x00	; 0
    67ce:	30 70       	andi	r19, 0x00	; 0
    67d0:	21 96       	adiw	r28, 0x01	; 1
    67d2:	0c af       	sts	0x7c, r16
    67d4:	1d af       	sts	0x7d, r17
    67d6:	2e af       	sts	0x7e, r18
    67d8:	3f af       	sts	0x7f, r19
    67da:	21 97       	sbiw	r28, 0x01	; 1
    67dc:	69 a9       	sts	0x49, r22
    67de:	7a a9       	sts	0x4a, r23
    67e0:	8b a9       	sts	0x4b, r24
    67e2:	9c a9       	sts	0x4c, r25
    67e4:	a5 01       	movw	r20, r10
    67e6:	94 01       	movw	r18, r8
    67e8:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    67ec:	29 a7       	lds	r18, 0x79
    67ee:	3a a7       	lds	r19, 0x7a
    67f0:	4b a7       	lds	r20, 0x7b
    67f2:	5c a7       	lds	r21, 0x7c
    67f4:	6b 01       	movw	r12, r22
    67f6:	7c 01       	movw	r14, r24
    67f8:	69 a9       	sts	0x49, r22
    67fa:	7a a9       	sts	0x4a, r23
    67fc:	8b a9       	sts	0x4b, r24
    67fe:	9c a9       	sts	0x4c, r25
    6800:	a5 01       	movw	r20, r10
    6802:	94 01       	movw	r18, r8
    6804:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    6808:	ca 01       	movw	r24, r20
    680a:	b9 01       	movw	r22, r18
    680c:	21 96       	adiw	r28, 0x01	; 1
    680e:	2c ad       	sts	0x6c, r18
    6810:	3d ad       	sts	0x6d, r19
    6812:	4e ad       	sts	0x6e, r20
    6814:	5f ad       	sts	0x6f, r21
    6816:	21 97       	sbiw	r28, 0x01	; 1
    6818:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    681c:	dc 01       	movw	r26, r24
    681e:	cb 01       	movw	r24, r22
    6820:	76 01       	movw	r14, r12
    6822:	dd 24       	eor	r13, r13
    6824:	cc 24       	eor	r12, r12
    6826:	0d a5       	lds	r16, 0x6d
    6828:	1e a5       	lds	r17, 0x6e
    682a:	2f a5       	lds	r18, 0x6f
    682c:	38 a9       	sts	0x48, r19
    682e:	a9 01       	movw	r20, r18
    6830:	66 27       	eor	r22, r22
    6832:	77 27       	eor	r23, r23
    6834:	c4 2a       	or	r12, r20
    6836:	d5 2a       	or	r13, r21
    6838:	e6 2a       	or	r14, r22
    683a:	f7 2a       	or	r15, r23
    683c:	09 a5       	lds	r16, 0x69
    683e:	1a a5       	lds	r17, 0x6a
    6840:	2b a5       	lds	r18, 0x6b
    6842:	3c a5       	lds	r19, 0x6c
    6844:	c8 16       	cp	r12, r24
    6846:	d9 06       	cpc	r13, r25
    6848:	ea 06       	cpc	r14, r26
    684a:	fb 06       	cpc	r15, r27
    684c:	38 f5       	brcc	.+78     	; 0x689c <__stack+0x89d>
    684e:	01 50       	subi	r16, 0x01	; 1
    6850:	10 40       	sbci	r17, 0x00	; 0
    6852:	20 40       	sbci	r18, 0x00	; 0
    6854:	30 40       	sbci	r19, 0x00	; 0
    6856:	09 ab       	sts	0x59, r16
    6858:	1a ab       	sts	0x5a, r17
    685a:	2b ab       	sts	0x5b, r18
    685c:	3c ab       	sts	0x5c, r19
    685e:	c4 0c       	add	r12, r4
    6860:	d5 1c       	adc	r13, r5
    6862:	e6 1c       	adc	r14, r6
    6864:	f7 1c       	adc	r15, r7
    6866:	c4 14       	cp	r12, r4
    6868:	d5 04       	cpc	r13, r5
    686a:	e6 04       	cpc	r14, r6
    686c:	f7 04       	cpc	r15, r7
    686e:	d0 f0       	brcs	.+52     	; 0x68a4 <__stack+0x8a5>
    6870:	c8 16       	cp	r12, r24
    6872:	d9 06       	cpc	r13, r25
    6874:	ea 06       	cpc	r14, r26
    6876:	fb 06       	cpc	r15, r27
    6878:	a8 f4       	brcc	.+42     	; 0x68a4 <__stack+0x8a5>
    687a:	09 a5       	lds	r16, 0x69
    687c:	1a a5       	lds	r17, 0x6a
    687e:	2b a5       	lds	r18, 0x6b
    6880:	3c a5       	lds	r19, 0x6c
    6882:	02 50       	subi	r16, 0x02	; 2
    6884:	10 40       	sbci	r17, 0x00	; 0
    6886:	20 40       	sbci	r18, 0x00	; 0
    6888:	30 40       	sbci	r19, 0x00	; 0
    688a:	09 ab       	sts	0x59, r16
    688c:	1a ab       	sts	0x5a, r17
    688e:	2b ab       	sts	0x5b, r18
    6890:	3c ab       	sts	0x5c, r19
    6892:	c4 0c       	add	r12, r4
    6894:	d5 1c       	adc	r13, r5
    6896:	e6 1c       	adc	r14, r6
    6898:	f7 1c       	adc	r15, r7
    689a:	04 c0       	rjmp	.+8      	; 0x68a4 <__stack+0x8a5>
    689c:	09 ab       	sts	0x59, r16
    689e:	1a ab       	sts	0x5a, r17
    68a0:	2b ab       	sts	0x5b, r18
    68a2:	3c ab       	sts	0x5c, r19
    68a4:	c8 1a       	sub	r12, r24
    68a6:	d9 0a       	sbc	r13, r25
    68a8:	ea 0a       	sbc	r14, r26
    68aa:	fb 0a       	sbc	r15, r27
    68ac:	c7 01       	movw	r24, r14
    68ae:	b6 01       	movw	r22, r12
    68b0:	a5 01       	movw	r20, r10
    68b2:	94 01       	movw	r18, r8
    68b4:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    68b8:	29 a7       	lds	r18, 0x79
    68ba:	3a a7       	lds	r19, 0x7a
    68bc:	4b a7       	lds	r20, 0x7b
    68be:	5c a7       	lds	r21, 0x7c
    68c0:	29 96       	adiw	r28, 0x09	; 9
    68c2:	6c af       	sts	0x7c, r22
    68c4:	7d af       	sts	0x7d, r23
    68c6:	8e af       	sts	0x7e, r24
    68c8:	9f af       	sts	0x7f, r25
    68ca:	29 97       	sbiw	r28, 0x09	; 9
    68cc:	c7 01       	movw	r24, r14
    68ce:	b6 01       	movw	r22, r12
    68d0:	a5 01       	movw	r20, r10
    68d2:	94 01       	movw	r18, r8
    68d4:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <__udivmodsi4>
    68d8:	ca 01       	movw	r24, r20
    68da:	b9 01       	movw	r22, r18
    68dc:	21 96       	adiw	r28, 0x01	; 1
    68de:	2c ad       	sts	0x6c, r18
    68e0:	3d ad       	sts	0x6d, r19
    68e2:	4e ad       	sts	0x6e, r20
    68e4:	5f ad       	sts	0x6f, r21
    68e6:	21 97       	sbiw	r28, 0x01	; 1
    68e8:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    68ec:	4b 01       	movw	r8, r22
    68ee:	5c 01       	movw	r10, r24
    68f0:	29 96       	adiw	r28, 0x09	; 9
    68f2:	4c ad       	sts	0x6c, r20
    68f4:	5d ad       	sts	0x6d, r21
    68f6:	6e ad       	sts	0x6e, r22
    68f8:	7f ad       	sts	0x6f, r23
    68fa:	29 97       	sbiw	r28, 0x09	; 9
    68fc:	9a 01       	movw	r18, r20
    68fe:	11 27       	eor	r17, r17
    6900:	00 27       	eor	r16, r16
    6902:	8d a5       	lds	r24, 0x6d
    6904:	9e a5       	lds	r25, 0x6e
    6906:	af a5       	lds	r26, 0x6f
    6908:	b8 a9       	sts	0x48, r27
    690a:	a0 70       	andi	r26, 0x00	; 0
    690c:	b0 70       	andi	r27, 0x00	; 0
    690e:	08 2b       	or	r16, r24
    6910:	19 2b       	or	r17, r25
    6912:	2a 2b       	or	r18, r26
    6914:	3b 2b       	or	r19, r27
    6916:	89 a5       	lds	r24, 0x69
    6918:	9a a5       	lds	r25, 0x6a
    691a:	ab a5       	lds	r26, 0x6b
    691c:	bc a5       	lds	r27, 0x6c
    691e:	08 15       	cp	r16, r8
    6920:	19 05       	cpc	r17, r9
    6922:	2a 05       	cpc	r18, r10
    6924:	3b 05       	cpc	r19, r11
    6926:	e0 f4       	brcc	.+56     	; 0x6960 <__stack+0x961>
    6928:	01 97       	sbiw	r24, 0x01	; 1
    692a:	a1 09       	sbc	r26, r1
    692c:	b1 09       	sbc	r27, r1
    692e:	04 0d       	add	r16, r4
    6930:	15 1d       	adc	r17, r5
    6932:	26 1d       	adc	r18, r6
    6934:	37 1d       	adc	r19, r7
    6936:	04 15       	cp	r16, r4
    6938:	15 05       	cpc	r17, r5
    693a:	26 05       	cpc	r18, r6
    693c:	37 05       	cpc	r19, r7
    693e:	80 f0       	brcs	.+32     	; 0x6960 <__stack+0x961>
    6940:	08 15       	cp	r16, r8
    6942:	19 05       	cpc	r17, r9
    6944:	2a 05       	cpc	r18, r10
    6946:	3b 05       	cpc	r19, r11
    6948:	58 f4       	brcc	.+22     	; 0x6960 <__stack+0x961>
    694a:	89 a5       	lds	r24, 0x69
    694c:	9a a5       	lds	r25, 0x6a
    694e:	ab a5       	lds	r26, 0x6b
    6950:	bc a5       	lds	r27, 0x6c
    6952:	02 97       	sbiw	r24, 0x02	; 2
    6954:	a1 09       	sbc	r26, r1
    6956:	b1 09       	sbc	r27, r1
    6958:	04 0d       	add	r16, r4
    695a:	15 1d       	adc	r17, r5
    695c:	26 1d       	adc	r18, r6
    695e:	37 1d       	adc	r19, r7
    6960:	b9 01       	movw	r22, r18
    6962:	a8 01       	movw	r20, r16
    6964:	48 19       	sub	r20, r8
    6966:	59 09       	sbc	r21, r9
    6968:	6a 09       	sbc	r22, r10
    696a:	7b 09       	sbc	r23, r11
    696c:	4d a7       	lds	r20, 0x7d
    696e:	5e a7       	lds	r21, 0x7e
    6970:	6f a7       	lds	r22, 0x7f
    6972:	78 ab       	sts	0x58, r23
    6974:	09 a9       	sts	0x49, r16
    6976:	1a a9       	sts	0x4a, r17
    6978:	2b a9       	sts	0x4b, r18
    697a:	3c a9       	sts	0x4c, r19
    697c:	78 01       	movw	r14, r16
    697e:	dd 24       	eor	r13, r13
    6980:	cc 24       	eor	r12, r12
    6982:	c8 2a       	or	r12, r24
    6984:	d9 2a       	or	r13, r25
    6986:	ea 2a       	or	r14, r26
    6988:	fb 2a       	or	r15, r27
    698a:	ff ef       	ldi	r31, 0xFF	; 255
    698c:	8f 2e       	mov	r8, r31
    698e:	ff ef       	ldi	r31, 0xFF	; 255
    6990:	9f 2e       	mov	r9, r31
    6992:	a1 2c       	mov	r10, r1
    6994:	b1 2c       	mov	r11, r1
    6996:	8c 20       	and	r8, r12
    6998:	9d 20       	and	r9, r13
    699a:	ae 20       	and	r10, r14
    699c:	bf 20       	and	r11, r15
    699e:	87 01       	movw	r16, r14
    69a0:	22 27       	eor	r18, r18
    69a2:	33 27       	eor	r19, r19
    69a4:	09 a7       	lds	r16, 0x79
    69a6:	1a a7       	lds	r17, 0x7a
    69a8:	2b a7       	lds	r18, 0x7b
    69aa:	3c a7       	lds	r19, 0x7c
    69ac:	49 ac       	sts	0xa9, r20
    69ae:	5a ac       	sts	0xaa, r21
    69b0:	6b ac       	sts	0xab, r22
    69b2:	7c ac       	sts	0xac, r23
    69b4:	2f ef       	ldi	r18, 0xFF	; 255
    69b6:	3f ef       	ldi	r19, 0xFF	; 255
    69b8:	40 e0       	ldi	r20, 0x00	; 0
    69ba:	50 e0       	ldi	r21, 0x00	; 0
    69bc:	42 22       	and	r4, r18
    69be:	53 22       	and	r5, r19
    69c0:	64 22       	and	r6, r20
    69c2:	75 22       	and	r7, r21
    69c4:	29 ad       	sts	0x69, r18
    69c6:	3a ad       	sts	0x6a, r19
    69c8:	4b ad       	sts	0x6b, r20
    69ca:	5c ad       	sts	0x6c, r21
    69cc:	8a 01       	movw	r16, r20
    69ce:	22 27       	eor	r18, r18
    69d0:	33 27       	eor	r19, r19
    69d2:	09 ab       	sts	0x59, r16
    69d4:	1a ab       	sts	0x5a, r17
    69d6:	2b ab       	sts	0x5b, r18
    69d8:	3c ab       	sts	0x5c, r19
    69da:	c5 01       	movw	r24, r10
    69dc:	b4 01       	movw	r22, r8
    69de:	a3 01       	movw	r20, r6
    69e0:	92 01       	movw	r18, r4
    69e2:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    69e6:	69 af       	sts	0x79, r22
    69e8:	7a af       	sts	0x7a, r23
    69ea:	8b af       	sts	0x7b, r24
    69ec:	9c af       	sts	0x7c, r25
    69ee:	c5 01       	movw	r24, r10
    69f0:	b4 01       	movw	r22, r8
    69f2:	29 a9       	sts	0x49, r18
    69f4:	3a a9       	sts	0x4a, r19
    69f6:	4b a9       	sts	0x4b, r20
    69f8:	5c a9       	sts	0x4c, r21
    69fa:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    69fe:	4b 01       	movw	r8, r22
    6a00:	5c 01       	movw	r10, r24
    6a02:	69 a5       	lds	r22, 0x69
    6a04:	7a a5       	lds	r23, 0x6a
    6a06:	8b a5       	lds	r24, 0x6b
    6a08:	9c a5       	lds	r25, 0x6c
    6a0a:	a3 01       	movw	r20, r6
    6a0c:	92 01       	movw	r18, r4
    6a0e:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    6a12:	2b 01       	movw	r4, r22
    6a14:	3c 01       	movw	r6, r24
    6a16:	69 a5       	lds	r22, 0x69
    6a18:	7a a5       	lds	r23, 0x6a
    6a1a:	8b a5       	lds	r24, 0x6b
    6a1c:	9c a5       	lds	r25, 0x6c
    6a1e:	29 a9       	sts	0x49, r18
    6a20:	3a a9       	sts	0x4a, r19
    6a22:	4b a9       	sts	0x4b, r20
    6a24:	5c a9       	sts	0x4c, r21
    6a26:	0e 94 a8 37 	call	0x6f50	; 0x6f50 <__mulsi3>
    6a2a:	ab 01       	movw	r20, r22
    6a2c:	bc 01       	movw	r22, r24
    6a2e:	84 0c       	add	r8, r4
    6a30:	95 1c       	adc	r9, r5
    6a32:	a6 1c       	adc	r10, r6
    6a34:	b7 1c       	adc	r11, r7
    6a36:	09 ad       	sts	0x69, r16
    6a38:	1a ad       	sts	0x6a, r17
    6a3a:	2b ad       	sts	0x6b, r18
    6a3c:	3c ad       	sts	0x6c, r19
    6a3e:	c9 01       	movw	r24, r18
    6a40:	aa 27       	eor	r26, r26
    6a42:	bb 27       	eor	r27, r27
    6a44:	88 0e       	add	r8, r24
    6a46:	99 1e       	adc	r9, r25
    6a48:	aa 1e       	adc	r10, r26
    6a4a:	bb 1e       	adc	r11, r27
    6a4c:	84 14       	cp	r8, r4
    6a4e:	95 04       	cpc	r9, r5
    6a50:	a6 04       	cpc	r10, r6
    6a52:	b7 04       	cpc	r11, r7
    6a54:	20 f4       	brcc	.+8      	; 0x6a5e <__stack+0xa5f>
    6a56:	40 50       	subi	r20, 0x00	; 0
    6a58:	50 40       	sbci	r21, 0x00	; 0
    6a5a:	6f 4f       	sbci	r22, 0xFF	; 255
    6a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    6a5e:	c5 01       	movw	r24, r10
    6a60:	aa 27       	eor	r26, r26
    6a62:	bb 27       	eor	r27, r27
    6a64:	84 0f       	add	r24, r20
    6a66:	95 1f       	adc	r25, r21
    6a68:	a6 1f       	adc	r26, r22
    6a6a:	b7 1f       	adc	r27, r23
    6a6c:	0d a5       	lds	r16, 0x6d
    6a6e:	1e a5       	lds	r17, 0x6e
    6a70:	2f a5       	lds	r18, 0x6f
    6a72:	38 a9       	sts	0x48, r19
    6a74:	08 17       	cp	r16, r24
    6a76:	19 07       	cpc	r17, r25
    6a78:	2a 07       	cpc	r18, r26
    6a7a:	3b 07       	cpc	r19, r27
    6a7c:	18 f1       	brcs	.+70     	; 0x6ac4 <__stack+0xac5>
    6a7e:	80 17       	cp	r24, r16
    6a80:	91 07       	cpc	r25, r17
    6a82:	a2 07       	cpc	r26, r18
    6a84:	b3 07       	cpc	r27, r19
    6a86:	a1 f5       	brne	.+104    	; 0x6af0 <__stack+0xaf1>
    6a88:	54 01       	movw	r10, r8
    6a8a:	99 24       	eor	r9, r9
    6a8c:	88 24       	eor	r8, r8
    6a8e:	89 ad       	sts	0x69, r24
    6a90:	9a ad       	sts	0x6a, r25
    6a92:	ab ad       	sts	0x6b, r26
    6a94:	bc ad       	sts	0x6c, r27
    6a96:	a0 70       	andi	r26, 0x00	; 0
    6a98:	b0 70       	andi	r27, 0x00	; 0
    6a9a:	88 0e       	add	r8, r24
    6a9c:	99 1e       	adc	r9, r25
    6a9e:	aa 1e       	adc	r10, r26
    6aa0:	bb 1e       	adc	r11, r27
    6aa2:	4d a9       	sts	0x4d, r20
    6aa4:	5e a9       	sts	0x4e, r21
    6aa6:	6f a9       	sts	0x4f, r22
    6aa8:	78 ad       	sts	0x68, r23
    6aaa:	03 2c       	mov	r0, r3
    6aac:	04 c0       	rjmp	.+8      	; 0x6ab6 <__stack+0xab7>
    6aae:	44 0f       	add	r20, r20
    6ab0:	55 1f       	adc	r21, r21
    6ab2:	66 1f       	adc	r22, r22
    6ab4:	77 1f       	adc	r23, r23
    6ab6:	0a 94       	dec	r0
    6ab8:	d2 f7       	brpl	.-12     	; 0x6aae <__stack+0xaaf>
    6aba:	48 15       	cp	r20, r8
    6abc:	59 05       	cpc	r21, r9
    6abe:	6a 05       	cpc	r22, r10
    6ac0:	7b 05       	cpc	r23, r11
    6ac2:	b0 f4       	brcc	.+44     	; 0x6af0 <__stack+0xaf1>
    6ac4:	08 94       	sec
    6ac6:	c1 08       	sbc	r12, r1
    6ac8:	d1 08       	sbc	r13, r1
    6aca:	e1 08       	sbc	r14, r1
    6acc:	f1 08       	sbc	r15, r1
    6ace:	10 c0       	rjmp	.+32     	; 0x6af0 <__stack+0xaf1>
    6ad0:	44 24       	eor	r4, r4
    6ad2:	55 24       	eor	r5, r5
    6ad4:	32 01       	movw	r6, r4
    6ad6:	cc 24       	eor	r12, r12
    6ad8:	dd 24       	eor	r13, r13
    6ada:	76 01       	movw	r14, r12
    6adc:	0c c0       	rjmp	.+24     	; 0x6af6 <__stack+0xaf7>
    6ade:	44 24       	eor	r4, r4
    6ae0:	55 24       	eor	r5, r5
    6ae2:	32 01       	movw	r6, r4
    6ae4:	81 e0       	ldi	r24, 0x01	; 1
    6ae6:	c8 2e       	mov	r12, r24
    6ae8:	d1 2c       	mov	r13, r1
    6aea:	e1 2c       	mov	r14, r1
    6aec:	f1 2c       	mov	r15, r1
    6aee:	03 c0       	rjmp	.+6      	; 0x6af6 <__stack+0xaf7>
    6af0:	44 24       	eor	r4, r4
    6af2:	55 24       	eor	r5, r5
    6af4:	32 01       	movw	r6, r4
    6af6:	fe 01       	movw	r30, r28
    6af8:	31 96       	adiw	r30, 0x01	; 1
    6afa:	88 e0       	ldi	r24, 0x08	; 8
    6afc:	df 01       	movw	r26, r30
    6afe:	1d 92       	st	X+, r1
    6b00:	8a 95       	dec	r24
    6b02:	e9 f7       	brne	.-6      	; 0x6afe <__stack+0xaff>
    6b04:	c9 82       	std	Y+1, r12	; 0x01
    6b06:	da 82       	std	Y+2, r13	; 0x02
    6b08:	eb 82       	std	Y+3, r14	; 0x03
    6b0a:	fc 82       	std	Y+4, r15	; 0x04
    6b0c:	4d 82       	std	Y+5, r4	; 0x05
    6b0e:	5e 82       	std	Y+6, r5	; 0x06
    6b10:	6f 82       	std	Y+7, r6	; 0x07
    6b12:	78 86       	std	Y+8, r7	; 0x08
    6b14:	2c 2d       	mov	r18, r12
    6b16:	3a 81       	ldd	r19, Y+2	; 0x02
    6b18:	4b 81       	ldd	r20, Y+3	; 0x03
    6b1a:	5c 81       	ldd	r21, Y+4	; 0x04
    6b1c:	64 2d       	mov	r22, r4
    6b1e:	7e 81       	ldd	r23, Y+6	; 0x06
    6b20:	8f 81       	ldd	r24, Y+7	; 0x07
    6b22:	98 85       	ldd	r25, Y+8	; 0x08
    6b24:	25 96       	adiw	r28, 0x05	; 5
    6b26:	ec ac       	sts	0xac, r30
    6b28:	fd ac       	sts	0xad, r31
    6b2a:	0e ad       	sts	0x6e, r16
    6b2c:	1f ad       	sts	0x6f, r17
    6b2e:	25 97       	sbiw	r28, 0x05	; 5
    6b30:	e1 14       	cp	r14, r1
    6b32:	f1 04       	cpc	r15, r1
    6b34:	01 05       	cpc	r16, r1
    6b36:	11 05       	cpc	r17, r1
    6b38:	09 f4       	brne	.+2      	; 0x6b3c <__stack+0xb3d>
    6b3a:	56 c0       	rjmp	.+172    	; 0x6be8 <__stack+0xbe9>
    6b3c:	21 95       	neg	r18
    6b3e:	e1 e0       	ldi	r30, 0x01	; 1
    6b40:	12 16       	cp	r1, r18
    6b42:	08 f0       	brcs	.+2      	; 0x6b46 <__stack+0xb47>
    6b44:	e0 e0       	ldi	r30, 0x00	; 0
    6b46:	31 95       	neg	r19
    6b48:	f1 e0       	ldi	r31, 0x01	; 1
    6b4a:	13 16       	cp	r1, r19
    6b4c:	08 f0       	brcs	.+2      	; 0x6b50 <__stack+0xb51>
    6b4e:	f0 e0       	ldi	r31, 0x00	; 0
    6b50:	03 2f       	mov	r16, r19
    6b52:	0e 1b       	sub	r16, r30
    6b54:	e1 e0       	ldi	r30, 0x01	; 1
    6b56:	30 17       	cp	r19, r16
    6b58:	08 f0       	brcs	.+2      	; 0x6b5c <__stack+0xb5d>
    6b5a:	e0 e0       	ldi	r30, 0x00	; 0
    6b5c:	fe 2b       	or	r31, r30
    6b5e:	41 95       	neg	r20
    6b60:	e1 e0       	ldi	r30, 0x01	; 1
    6b62:	14 16       	cp	r1, r20
    6b64:	08 f0       	brcs	.+2      	; 0x6b68 <__stack+0xb69>
    6b66:	e0 e0       	ldi	r30, 0x00	; 0
    6b68:	14 2f       	mov	r17, r20
    6b6a:	1f 1b       	sub	r17, r31
    6b6c:	31 e0       	ldi	r19, 0x01	; 1
    6b6e:	41 17       	cp	r20, r17
    6b70:	08 f0       	brcs	.+2      	; 0x6b74 <__stack+0xb75>
    6b72:	30 e0       	ldi	r19, 0x00	; 0
    6b74:	e3 2b       	or	r30, r19
    6b76:	51 95       	neg	r21
    6b78:	f1 e0       	ldi	r31, 0x01	; 1
    6b7a:	15 16       	cp	r1, r21
    6b7c:	08 f0       	brcs	.+2      	; 0x6b80 <__stack+0xb81>
    6b7e:	f0 e0       	ldi	r31, 0x00	; 0
    6b80:	b5 2f       	mov	r27, r21
    6b82:	be 1b       	sub	r27, r30
    6b84:	31 e0       	ldi	r19, 0x01	; 1
    6b86:	5b 17       	cp	r21, r27
    6b88:	08 f0       	brcs	.+2      	; 0x6b8c <__stack+0xb8d>
    6b8a:	30 e0       	ldi	r19, 0x00	; 0
    6b8c:	f3 2b       	or	r31, r19
    6b8e:	61 95       	neg	r22
    6b90:	e1 e0       	ldi	r30, 0x01	; 1
    6b92:	16 16       	cp	r1, r22
    6b94:	08 f0       	brcs	.+2      	; 0x6b98 <__stack+0xb99>
    6b96:	e0 e0       	ldi	r30, 0x00	; 0
    6b98:	46 2e       	mov	r4, r22
    6b9a:	4f 1a       	sub	r4, r31
    6b9c:	31 e0       	ldi	r19, 0x01	; 1
    6b9e:	64 15       	cp	r22, r4
    6ba0:	08 f0       	brcs	.+2      	; 0x6ba4 <__stack+0xba5>
    6ba2:	30 e0       	ldi	r19, 0x00	; 0
    6ba4:	e3 2b       	or	r30, r19
    6ba6:	71 95       	neg	r23
    6ba8:	f1 e0       	ldi	r31, 0x01	; 1
    6baa:	17 16       	cp	r1, r23
    6bac:	08 f0       	brcs	.+2      	; 0x6bb0 <__stack+0xbb1>
    6bae:	f0 e0       	ldi	r31, 0x00	; 0
    6bb0:	a7 2f       	mov	r26, r23
    6bb2:	ae 1b       	sub	r26, r30
    6bb4:	31 e0       	ldi	r19, 0x01	; 1
    6bb6:	7a 17       	cp	r23, r26
    6bb8:	08 f0       	brcs	.+2      	; 0x6bbc <__stack+0xbbd>
    6bba:	30 e0       	ldi	r19, 0x00	; 0
    6bbc:	f3 2b       	or	r31, r19
    6bbe:	81 95       	neg	r24
    6bc0:	e1 e0       	ldi	r30, 0x01	; 1
    6bc2:	18 16       	cp	r1, r24
    6bc4:	08 f0       	brcs	.+2      	; 0x6bc8 <__stack+0xbc9>
    6bc6:	e0 e0       	ldi	r30, 0x00	; 0
    6bc8:	f8 2e       	mov	r15, r24
    6bca:	ff 1a       	sub	r15, r31
    6bcc:	ff 2d       	mov	r31, r15
    6bce:	31 e0       	ldi	r19, 0x01	; 1
    6bd0:	8f 15       	cp	r24, r15
    6bd2:	08 f0       	brcs	.+2      	; 0x6bd6 <__stack+0xbd7>
    6bd4:	30 e0       	ldi	r19, 0x00	; 0
    6bd6:	e3 2b       	or	r30, r19
    6bd8:	91 95       	neg	r25
    6bda:	30 2f       	mov	r19, r16
    6bdc:	41 2f       	mov	r20, r17
    6bde:	5b 2f       	mov	r21, r27
    6be0:	64 2d       	mov	r22, r4
    6be2:	7a 2f       	mov	r23, r26
    6be4:	8f 2f       	mov	r24, r31
    6be6:	9e 1b       	sub	r25, r30
    6be8:	c8 5b       	subi	r28, 0xB8	; 184
    6bea:	df 4f       	sbci	r29, 0xFF	; 255
    6bec:	e1 e1       	ldi	r30, 0x11	; 17
    6bee:	0c 94 45 38 	jmp	0x708a	; 0x708a <__epilogue_restores__+0x2>

00006bf2 <__subsf3>:
    6bf2:	50 58       	subi	r21, 0x80	; 128

00006bf4 <__addsf3>:
    6bf4:	bb 27       	eor	r27, r27
    6bf6:	aa 27       	eor	r26, r26
    6bf8:	0e d0       	rcall	.+28     	; 0x6c16 <__addsf3x>
    6bfa:	48 c1       	rjmp	.+656    	; 0x6e8c <__fp_round>
    6bfc:	39 d1       	rcall	.+626    	; 0x6e70 <__fp_pscA>
    6bfe:	30 f0       	brcs	.+12     	; 0x6c0c <__addsf3+0x18>
    6c00:	3e d1       	rcall	.+636    	; 0x6e7e <__fp_pscB>
    6c02:	20 f0       	brcs	.+8      	; 0x6c0c <__addsf3+0x18>
    6c04:	31 f4       	brne	.+12     	; 0x6c12 <__addsf3+0x1e>
    6c06:	9f 3f       	cpi	r25, 0xFF	; 255
    6c08:	11 f4       	brne	.+4      	; 0x6c0e <__addsf3+0x1a>
    6c0a:	1e f4       	brtc	.+6      	; 0x6c12 <__addsf3+0x1e>
    6c0c:	2e c1       	rjmp	.+604    	; 0x6e6a <__fp_nan>
    6c0e:	0e f4       	brtc	.+2      	; 0x6c12 <__addsf3+0x1e>
    6c10:	e0 95       	com	r30
    6c12:	e7 fb       	bst	r30, 7
    6c14:	24 c1       	rjmp	.+584    	; 0x6e5e <__fp_inf>

00006c16 <__addsf3x>:
    6c16:	e9 2f       	mov	r30, r25
    6c18:	4a d1       	rcall	.+660    	; 0x6eae <__fp_split3>
    6c1a:	80 f3       	brcs	.-32     	; 0x6bfc <__addsf3+0x8>
    6c1c:	ba 17       	cp	r27, r26
    6c1e:	62 07       	cpc	r22, r18
    6c20:	73 07       	cpc	r23, r19
    6c22:	84 07       	cpc	r24, r20
    6c24:	95 07       	cpc	r25, r21
    6c26:	18 f0       	brcs	.+6      	; 0x6c2e <__addsf3x+0x18>
    6c28:	71 f4       	brne	.+28     	; 0x6c46 <__addsf3x+0x30>
    6c2a:	9e f5       	brtc	.+102    	; 0x6c92 <__addsf3x+0x7c>
    6c2c:	62 c1       	rjmp	.+708    	; 0x6ef2 <__fp_zero>
    6c2e:	0e f4       	brtc	.+2      	; 0x6c32 <__addsf3x+0x1c>
    6c30:	e0 95       	com	r30
    6c32:	0b 2e       	mov	r0, r27
    6c34:	ba 2f       	mov	r27, r26
    6c36:	a0 2d       	mov	r26, r0
    6c38:	0b 01       	movw	r0, r22
    6c3a:	b9 01       	movw	r22, r18
    6c3c:	90 01       	movw	r18, r0
    6c3e:	0c 01       	movw	r0, r24
    6c40:	ca 01       	movw	r24, r20
    6c42:	a0 01       	movw	r20, r0
    6c44:	11 24       	eor	r1, r1
    6c46:	ff 27       	eor	r31, r31
    6c48:	59 1b       	sub	r21, r25
    6c4a:	99 f0       	breq	.+38     	; 0x6c72 <__addsf3x+0x5c>
    6c4c:	59 3f       	cpi	r21, 0xF9	; 249
    6c4e:	50 f4       	brcc	.+20     	; 0x6c64 <__addsf3x+0x4e>
    6c50:	50 3e       	cpi	r21, 0xE0	; 224
    6c52:	68 f1       	brcs	.+90     	; 0x6cae <__addsf3x+0x98>
    6c54:	1a 16       	cp	r1, r26
    6c56:	f0 40       	sbci	r31, 0x00	; 0
    6c58:	a2 2f       	mov	r26, r18
    6c5a:	23 2f       	mov	r18, r19
    6c5c:	34 2f       	mov	r19, r20
    6c5e:	44 27       	eor	r20, r20
    6c60:	58 5f       	subi	r21, 0xF8	; 248
    6c62:	f3 cf       	rjmp	.-26     	; 0x6c4a <__addsf3x+0x34>
    6c64:	46 95       	lsr	r20
    6c66:	37 95       	ror	r19
    6c68:	27 95       	ror	r18
    6c6a:	a7 95       	ror	r26
    6c6c:	f0 40       	sbci	r31, 0x00	; 0
    6c6e:	53 95       	inc	r21
    6c70:	c9 f7       	brne	.-14     	; 0x6c64 <__addsf3x+0x4e>
    6c72:	7e f4       	brtc	.+30     	; 0x6c92 <__addsf3x+0x7c>
    6c74:	1f 16       	cp	r1, r31
    6c76:	ba 0b       	sbc	r27, r26
    6c78:	62 0b       	sbc	r22, r18
    6c7a:	73 0b       	sbc	r23, r19
    6c7c:	84 0b       	sbc	r24, r20
    6c7e:	ba f0       	brmi	.+46     	; 0x6cae <__addsf3x+0x98>
    6c80:	91 50       	subi	r25, 0x01	; 1
    6c82:	a1 f0       	breq	.+40     	; 0x6cac <__addsf3x+0x96>
    6c84:	ff 0f       	add	r31, r31
    6c86:	bb 1f       	adc	r27, r27
    6c88:	66 1f       	adc	r22, r22
    6c8a:	77 1f       	adc	r23, r23
    6c8c:	88 1f       	adc	r24, r24
    6c8e:	c2 f7       	brpl	.-16     	; 0x6c80 <__addsf3x+0x6a>
    6c90:	0e c0       	rjmp	.+28     	; 0x6cae <__addsf3x+0x98>
    6c92:	ba 0f       	add	r27, r26
    6c94:	62 1f       	adc	r22, r18
    6c96:	73 1f       	adc	r23, r19
    6c98:	84 1f       	adc	r24, r20
    6c9a:	48 f4       	brcc	.+18     	; 0x6cae <__addsf3x+0x98>
    6c9c:	87 95       	ror	r24
    6c9e:	77 95       	ror	r23
    6ca0:	67 95       	ror	r22
    6ca2:	b7 95       	ror	r27
    6ca4:	f7 95       	ror	r31
    6ca6:	9e 3f       	cpi	r25, 0xFE	; 254
    6ca8:	08 f0       	brcs	.+2      	; 0x6cac <__addsf3x+0x96>
    6caa:	b3 cf       	rjmp	.-154    	; 0x6c12 <__addsf3+0x1e>
    6cac:	93 95       	inc	r25
    6cae:	88 0f       	add	r24, r24
    6cb0:	08 f0       	brcs	.+2      	; 0x6cb4 <__addsf3x+0x9e>
    6cb2:	99 27       	eor	r25, r25
    6cb4:	ee 0f       	add	r30, r30
    6cb6:	97 95       	ror	r25
    6cb8:	87 95       	ror	r24
    6cba:	08 95       	ret

00006cbc <__divsf3>:
    6cbc:	0c d0       	rcall	.+24     	; 0x6cd6 <__divsf3x>
    6cbe:	e6 c0       	rjmp	.+460    	; 0x6e8c <__fp_round>
    6cc0:	de d0       	rcall	.+444    	; 0x6e7e <__fp_pscB>
    6cc2:	40 f0       	brcs	.+16     	; 0x6cd4 <__divsf3+0x18>
    6cc4:	d5 d0       	rcall	.+426    	; 0x6e70 <__fp_pscA>
    6cc6:	30 f0       	brcs	.+12     	; 0x6cd4 <__divsf3+0x18>
    6cc8:	21 f4       	brne	.+8      	; 0x6cd2 <__divsf3+0x16>
    6cca:	5f 3f       	cpi	r21, 0xFF	; 255
    6ccc:	19 f0       	breq	.+6      	; 0x6cd4 <__divsf3+0x18>
    6cce:	c7 c0       	rjmp	.+398    	; 0x6e5e <__fp_inf>
    6cd0:	51 11       	cpse	r21, r1
    6cd2:	10 c1       	rjmp	.+544    	; 0x6ef4 <__fp_szero>
    6cd4:	ca c0       	rjmp	.+404    	; 0x6e6a <__fp_nan>

00006cd6 <__divsf3x>:
    6cd6:	eb d0       	rcall	.+470    	; 0x6eae <__fp_split3>
    6cd8:	98 f3       	brcs	.-26     	; 0x6cc0 <__divsf3+0x4>

00006cda <__divsf3_pse>:
    6cda:	99 23       	and	r25, r25
    6cdc:	c9 f3       	breq	.-14     	; 0x6cd0 <__divsf3+0x14>
    6cde:	55 23       	and	r21, r21
    6ce0:	b1 f3       	breq	.-20     	; 0x6cce <__divsf3+0x12>
    6ce2:	95 1b       	sub	r25, r21
    6ce4:	55 0b       	sbc	r21, r21
    6ce6:	bb 27       	eor	r27, r27
    6ce8:	aa 27       	eor	r26, r26
    6cea:	62 17       	cp	r22, r18
    6cec:	73 07       	cpc	r23, r19
    6cee:	84 07       	cpc	r24, r20
    6cf0:	38 f0       	brcs	.+14     	; 0x6d00 <__divsf3_pse+0x26>
    6cf2:	9f 5f       	subi	r25, 0xFF	; 255
    6cf4:	5f 4f       	sbci	r21, 0xFF	; 255
    6cf6:	22 0f       	add	r18, r18
    6cf8:	33 1f       	adc	r19, r19
    6cfa:	44 1f       	adc	r20, r20
    6cfc:	aa 1f       	adc	r26, r26
    6cfe:	a9 f3       	breq	.-22     	; 0x6cea <__divsf3_pse+0x10>
    6d00:	33 d0       	rcall	.+102    	; 0x6d68 <__divsf3_pse+0x8e>
    6d02:	0e 2e       	mov	r0, r30
    6d04:	3a f0       	brmi	.+14     	; 0x6d14 <__divsf3_pse+0x3a>
    6d06:	e0 e8       	ldi	r30, 0x80	; 128
    6d08:	30 d0       	rcall	.+96     	; 0x6d6a <__divsf3_pse+0x90>
    6d0a:	91 50       	subi	r25, 0x01	; 1
    6d0c:	50 40       	sbci	r21, 0x00	; 0
    6d0e:	e6 95       	lsr	r30
    6d10:	00 1c       	adc	r0, r0
    6d12:	ca f7       	brpl	.-14     	; 0x6d06 <__divsf3_pse+0x2c>
    6d14:	29 d0       	rcall	.+82     	; 0x6d68 <__divsf3_pse+0x8e>
    6d16:	fe 2f       	mov	r31, r30
    6d18:	27 d0       	rcall	.+78     	; 0x6d68 <__divsf3_pse+0x8e>
    6d1a:	66 0f       	add	r22, r22
    6d1c:	77 1f       	adc	r23, r23
    6d1e:	88 1f       	adc	r24, r24
    6d20:	bb 1f       	adc	r27, r27
    6d22:	26 17       	cp	r18, r22
    6d24:	37 07       	cpc	r19, r23
    6d26:	48 07       	cpc	r20, r24
    6d28:	ab 07       	cpc	r26, r27
    6d2a:	b0 e8       	ldi	r27, 0x80	; 128
    6d2c:	09 f0       	breq	.+2      	; 0x6d30 <__divsf3_pse+0x56>
    6d2e:	bb 0b       	sbc	r27, r27
    6d30:	80 2d       	mov	r24, r0
    6d32:	bf 01       	movw	r22, r30
    6d34:	ff 27       	eor	r31, r31
    6d36:	93 58       	subi	r25, 0x83	; 131
    6d38:	5f 4f       	sbci	r21, 0xFF	; 255
    6d3a:	2a f0       	brmi	.+10     	; 0x6d46 <__divsf3_pse+0x6c>
    6d3c:	9e 3f       	cpi	r25, 0xFE	; 254
    6d3e:	51 05       	cpc	r21, r1
    6d40:	68 f0       	brcs	.+26     	; 0x6d5c <__divsf3_pse+0x82>
    6d42:	8d c0       	rjmp	.+282    	; 0x6e5e <__fp_inf>
    6d44:	d7 c0       	rjmp	.+430    	; 0x6ef4 <__fp_szero>
    6d46:	5f 3f       	cpi	r21, 0xFF	; 255
    6d48:	ec f3       	brlt	.-6      	; 0x6d44 <__divsf3_pse+0x6a>
    6d4a:	98 3e       	cpi	r25, 0xE8	; 232
    6d4c:	dc f3       	brlt	.-10     	; 0x6d44 <__divsf3_pse+0x6a>
    6d4e:	86 95       	lsr	r24
    6d50:	77 95       	ror	r23
    6d52:	67 95       	ror	r22
    6d54:	b7 95       	ror	r27
    6d56:	f7 95       	ror	r31
    6d58:	9f 5f       	subi	r25, 0xFF	; 255
    6d5a:	c9 f7       	brne	.-14     	; 0x6d4e <__divsf3_pse+0x74>
    6d5c:	88 0f       	add	r24, r24
    6d5e:	91 1d       	adc	r25, r1
    6d60:	96 95       	lsr	r25
    6d62:	87 95       	ror	r24
    6d64:	97 f9       	bld	r25, 7
    6d66:	08 95       	ret
    6d68:	e1 e0       	ldi	r30, 0x01	; 1
    6d6a:	66 0f       	add	r22, r22
    6d6c:	77 1f       	adc	r23, r23
    6d6e:	88 1f       	adc	r24, r24
    6d70:	bb 1f       	adc	r27, r27
    6d72:	62 17       	cp	r22, r18
    6d74:	73 07       	cpc	r23, r19
    6d76:	84 07       	cpc	r24, r20
    6d78:	ba 07       	cpc	r27, r26
    6d7a:	20 f0       	brcs	.+8      	; 0x6d84 <__divsf3_pse+0xaa>
    6d7c:	62 1b       	sub	r22, r18
    6d7e:	73 0b       	sbc	r23, r19
    6d80:	84 0b       	sbc	r24, r20
    6d82:	ba 0b       	sbc	r27, r26
    6d84:	ee 1f       	adc	r30, r30
    6d86:	88 f7       	brcc	.-30     	; 0x6d6a <__divsf3_pse+0x90>
    6d88:	e0 95       	com	r30
    6d8a:	08 95       	ret

00006d8c <__fixunssfsi>:
    6d8c:	98 d0       	rcall	.+304    	; 0x6ebe <__fp_splitA>
    6d8e:	88 f0       	brcs	.+34     	; 0x6db2 <__fixunssfsi+0x26>
    6d90:	9f 57       	subi	r25, 0x7F	; 127
    6d92:	90 f0       	brcs	.+36     	; 0x6db8 <__fixunssfsi+0x2c>
    6d94:	b9 2f       	mov	r27, r25
    6d96:	99 27       	eor	r25, r25
    6d98:	b7 51       	subi	r27, 0x17	; 23
    6d9a:	a0 f0       	brcs	.+40     	; 0x6dc4 <__fixunssfsi+0x38>
    6d9c:	d1 f0       	breq	.+52     	; 0x6dd2 <__fixunssfsi+0x46>
    6d9e:	66 0f       	add	r22, r22
    6da0:	77 1f       	adc	r23, r23
    6da2:	88 1f       	adc	r24, r24
    6da4:	99 1f       	adc	r25, r25
    6da6:	1a f0       	brmi	.+6      	; 0x6dae <__fixunssfsi+0x22>
    6da8:	ba 95       	dec	r27
    6daa:	c9 f7       	brne	.-14     	; 0x6d9e <__fixunssfsi+0x12>
    6dac:	12 c0       	rjmp	.+36     	; 0x6dd2 <__fixunssfsi+0x46>
    6dae:	b1 30       	cpi	r27, 0x01	; 1
    6db0:	81 f0       	breq	.+32     	; 0x6dd2 <__fixunssfsi+0x46>
    6db2:	9f d0       	rcall	.+318    	; 0x6ef2 <__fp_zero>
    6db4:	b1 e0       	ldi	r27, 0x01	; 1
    6db6:	08 95       	ret
    6db8:	9c c0       	rjmp	.+312    	; 0x6ef2 <__fp_zero>
    6dba:	67 2f       	mov	r22, r23
    6dbc:	78 2f       	mov	r23, r24
    6dbe:	88 27       	eor	r24, r24
    6dc0:	b8 5f       	subi	r27, 0xF8	; 248
    6dc2:	39 f0       	breq	.+14     	; 0x6dd2 <__fixunssfsi+0x46>
    6dc4:	b9 3f       	cpi	r27, 0xF9	; 249
    6dc6:	cc f3       	brlt	.-14     	; 0x6dba <__fixunssfsi+0x2e>
    6dc8:	86 95       	lsr	r24
    6dca:	77 95       	ror	r23
    6dcc:	67 95       	ror	r22
    6dce:	b3 95       	inc	r27
    6dd0:	d9 f7       	brne	.-10     	; 0x6dc8 <__fixunssfsi+0x3c>
    6dd2:	3e f4       	brtc	.+14     	; 0x6de2 <__fixunssfsi+0x56>
    6dd4:	90 95       	com	r25
    6dd6:	80 95       	com	r24
    6dd8:	70 95       	com	r23
    6dda:	61 95       	neg	r22
    6ddc:	7f 4f       	sbci	r23, 0xFF	; 255
    6dde:	8f 4f       	sbci	r24, 0xFF	; 255
    6de0:	9f 4f       	sbci	r25, 0xFF	; 255
    6de2:	08 95       	ret

00006de4 <__floatunsisf>:
    6de4:	e8 94       	clt
    6de6:	09 c0       	rjmp	.+18     	; 0x6dfa <__floatsisf+0x12>

00006de8 <__floatsisf>:
    6de8:	97 fb       	bst	r25, 7
    6dea:	3e f4       	brtc	.+14     	; 0x6dfa <__floatsisf+0x12>
    6dec:	90 95       	com	r25
    6dee:	80 95       	com	r24
    6df0:	70 95       	com	r23
    6df2:	61 95       	neg	r22
    6df4:	7f 4f       	sbci	r23, 0xFF	; 255
    6df6:	8f 4f       	sbci	r24, 0xFF	; 255
    6df8:	9f 4f       	sbci	r25, 0xFF	; 255
    6dfa:	99 23       	and	r25, r25
    6dfc:	a9 f0       	breq	.+42     	; 0x6e28 <__floatsisf+0x40>
    6dfe:	f9 2f       	mov	r31, r25
    6e00:	96 e9       	ldi	r25, 0x96	; 150
    6e02:	bb 27       	eor	r27, r27
    6e04:	93 95       	inc	r25
    6e06:	f6 95       	lsr	r31
    6e08:	87 95       	ror	r24
    6e0a:	77 95       	ror	r23
    6e0c:	67 95       	ror	r22
    6e0e:	b7 95       	ror	r27
    6e10:	f1 11       	cpse	r31, r1
    6e12:	f8 cf       	rjmp	.-16     	; 0x6e04 <__floatsisf+0x1c>
    6e14:	fa f4       	brpl	.+62     	; 0x6e54 <__floatsisf+0x6c>
    6e16:	bb 0f       	add	r27, r27
    6e18:	11 f4       	brne	.+4      	; 0x6e1e <__floatsisf+0x36>
    6e1a:	60 ff       	sbrs	r22, 0
    6e1c:	1b c0       	rjmp	.+54     	; 0x6e54 <__floatsisf+0x6c>
    6e1e:	6f 5f       	subi	r22, 0xFF	; 255
    6e20:	7f 4f       	sbci	r23, 0xFF	; 255
    6e22:	8f 4f       	sbci	r24, 0xFF	; 255
    6e24:	9f 4f       	sbci	r25, 0xFF	; 255
    6e26:	16 c0       	rjmp	.+44     	; 0x6e54 <__floatsisf+0x6c>
    6e28:	88 23       	and	r24, r24
    6e2a:	11 f0       	breq	.+4      	; 0x6e30 <__floatsisf+0x48>
    6e2c:	96 e9       	ldi	r25, 0x96	; 150
    6e2e:	11 c0       	rjmp	.+34     	; 0x6e52 <__floatsisf+0x6a>
    6e30:	77 23       	and	r23, r23
    6e32:	21 f0       	breq	.+8      	; 0x6e3c <__floatsisf+0x54>
    6e34:	9e e8       	ldi	r25, 0x8E	; 142
    6e36:	87 2f       	mov	r24, r23
    6e38:	76 2f       	mov	r23, r22
    6e3a:	05 c0       	rjmp	.+10     	; 0x6e46 <__floatsisf+0x5e>
    6e3c:	66 23       	and	r22, r22
    6e3e:	71 f0       	breq	.+28     	; 0x6e5c <__floatsisf+0x74>
    6e40:	96 e8       	ldi	r25, 0x86	; 134
    6e42:	86 2f       	mov	r24, r22
    6e44:	70 e0       	ldi	r23, 0x00	; 0
    6e46:	60 e0       	ldi	r22, 0x00	; 0
    6e48:	2a f0       	brmi	.+10     	; 0x6e54 <__floatsisf+0x6c>
    6e4a:	9a 95       	dec	r25
    6e4c:	66 0f       	add	r22, r22
    6e4e:	77 1f       	adc	r23, r23
    6e50:	88 1f       	adc	r24, r24
    6e52:	da f7       	brpl	.-10     	; 0x6e4a <__floatsisf+0x62>
    6e54:	88 0f       	add	r24, r24
    6e56:	96 95       	lsr	r25
    6e58:	87 95       	ror	r24
    6e5a:	97 f9       	bld	r25, 7
    6e5c:	08 95       	ret

00006e5e <__fp_inf>:
    6e5e:	97 f9       	bld	r25, 7
    6e60:	9f 67       	ori	r25, 0x7F	; 127
    6e62:	80 e8       	ldi	r24, 0x80	; 128
    6e64:	70 e0       	ldi	r23, 0x00	; 0
    6e66:	60 e0       	ldi	r22, 0x00	; 0
    6e68:	08 95       	ret

00006e6a <__fp_nan>:
    6e6a:	9f ef       	ldi	r25, 0xFF	; 255
    6e6c:	80 ec       	ldi	r24, 0xC0	; 192
    6e6e:	08 95       	ret

00006e70 <__fp_pscA>:
    6e70:	00 24       	eor	r0, r0
    6e72:	0a 94       	dec	r0
    6e74:	16 16       	cp	r1, r22
    6e76:	17 06       	cpc	r1, r23
    6e78:	18 06       	cpc	r1, r24
    6e7a:	09 06       	cpc	r0, r25
    6e7c:	08 95       	ret

00006e7e <__fp_pscB>:
    6e7e:	00 24       	eor	r0, r0
    6e80:	0a 94       	dec	r0
    6e82:	12 16       	cp	r1, r18
    6e84:	13 06       	cpc	r1, r19
    6e86:	14 06       	cpc	r1, r20
    6e88:	05 06       	cpc	r0, r21
    6e8a:	08 95       	ret

00006e8c <__fp_round>:
    6e8c:	09 2e       	mov	r0, r25
    6e8e:	03 94       	inc	r0
    6e90:	00 0c       	add	r0, r0
    6e92:	11 f4       	brne	.+4      	; 0x6e98 <__fp_round+0xc>
    6e94:	88 23       	and	r24, r24
    6e96:	52 f0       	brmi	.+20     	; 0x6eac <__fp_round+0x20>
    6e98:	bb 0f       	add	r27, r27
    6e9a:	40 f4       	brcc	.+16     	; 0x6eac <__fp_round+0x20>
    6e9c:	bf 2b       	or	r27, r31
    6e9e:	11 f4       	brne	.+4      	; 0x6ea4 <__fp_round+0x18>
    6ea0:	60 ff       	sbrs	r22, 0
    6ea2:	04 c0       	rjmp	.+8      	; 0x6eac <__fp_round+0x20>
    6ea4:	6f 5f       	subi	r22, 0xFF	; 255
    6ea6:	7f 4f       	sbci	r23, 0xFF	; 255
    6ea8:	8f 4f       	sbci	r24, 0xFF	; 255
    6eaa:	9f 4f       	sbci	r25, 0xFF	; 255
    6eac:	08 95       	ret

00006eae <__fp_split3>:
    6eae:	57 fd       	sbrc	r21, 7
    6eb0:	90 58       	subi	r25, 0x80	; 128
    6eb2:	44 0f       	add	r20, r20
    6eb4:	55 1f       	adc	r21, r21
    6eb6:	59 f0       	breq	.+22     	; 0x6ece <__fp_splitA+0x10>
    6eb8:	5f 3f       	cpi	r21, 0xFF	; 255
    6eba:	71 f0       	breq	.+28     	; 0x6ed8 <__fp_splitA+0x1a>
    6ebc:	47 95       	ror	r20

00006ebe <__fp_splitA>:
    6ebe:	88 0f       	add	r24, r24
    6ec0:	97 fb       	bst	r25, 7
    6ec2:	99 1f       	adc	r25, r25
    6ec4:	61 f0       	breq	.+24     	; 0x6ede <__fp_splitA+0x20>
    6ec6:	9f 3f       	cpi	r25, 0xFF	; 255
    6ec8:	79 f0       	breq	.+30     	; 0x6ee8 <__fp_splitA+0x2a>
    6eca:	87 95       	ror	r24
    6ecc:	08 95       	ret
    6ece:	12 16       	cp	r1, r18
    6ed0:	13 06       	cpc	r1, r19
    6ed2:	14 06       	cpc	r1, r20
    6ed4:	55 1f       	adc	r21, r21
    6ed6:	f2 cf       	rjmp	.-28     	; 0x6ebc <__fp_split3+0xe>
    6ed8:	46 95       	lsr	r20
    6eda:	f1 df       	rcall	.-30     	; 0x6ebe <__fp_splitA>
    6edc:	08 c0       	rjmp	.+16     	; 0x6eee <__fp_splitA+0x30>
    6ede:	16 16       	cp	r1, r22
    6ee0:	17 06       	cpc	r1, r23
    6ee2:	18 06       	cpc	r1, r24
    6ee4:	99 1f       	adc	r25, r25
    6ee6:	f1 cf       	rjmp	.-30     	; 0x6eca <__fp_splitA+0xc>
    6ee8:	86 95       	lsr	r24
    6eea:	71 05       	cpc	r23, r1
    6eec:	61 05       	cpc	r22, r1
    6eee:	08 94       	sec
    6ef0:	08 95       	ret

00006ef2 <__fp_zero>:
    6ef2:	e8 94       	clt

00006ef4 <__fp_szero>:
    6ef4:	bb 27       	eor	r27, r27
    6ef6:	66 27       	eor	r22, r22
    6ef8:	77 27       	eor	r23, r23
    6efa:	cb 01       	movw	r24, r22
    6efc:	97 f9       	bld	r25, 7
    6efe:	08 95       	ret

00006f00 <__gesf2>:
    6f00:	03 d0       	rcall	.+6      	; 0x6f08 <__fp_cmp>
    6f02:	08 f4       	brcc	.+2      	; 0x6f06 <__gesf2+0x6>
    6f04:	8f ef       	ldi	r24, 0xFF	; 255
    6f06:	08 95       	ret

00006f08 <__fp_cmp>:
    6f08:	99 0f       	add	r25, r25
    6f0a:	00 08       	sbc	r0, r0
    6f0c:	55 0f       	add	r21, r21
    6f0e:	aa 0b       	sbc	r26, r26
    6f10:	e0 e8       	ldi	r30, 0x80	; 128
    6f12:	fe ef       	ldi	r31, 0xFE	; 254
    6f14:	16 16       	cp	r1, r22
    6f16:	17 06       	cpc	r1, r23
    6f18:	e8 07       	cpc	r30, r24
    6f1a:	f9 07       	cpc	r31, r25
    6f1c:	c0 f0       	brcs	.+48     	; 0x6f4e <__fp_cmp+0x46>
    6f1e:	12 16       	cp	r1, r18
    6f20:	13 06       	cpc	r1, r19
    6f22:	e4 07       	cpc	r30, r20
    6f24:	f5 07       	cpc	r31, r21
    6f26:	98 f0       	brcs	.+38     	; 0x6f4e <__fp_cmp+0x46>
    6f28:	62 1b       	sub	r22, r18
    6f2a:	73 0b       	sbc	r23, r19
    6f2c:	84 0b       	sbc	r24, r20
    6f2e:	95 0b       	sbc	r25, r21
    6f30:	39 f4       	brne	.+14     	; 0x6f40 <__fp_cmp+0x38>
    6f32:	0a 26       	eor	r0, r26
    6f34:	61 f0       	breq	.+24     	; 0x6f4e <__fp_cmp+0x46>
    6f36:	23 2b       	or	r18, r19
    6f38:	24 2b       	or	r18, r20
    6f3a:	25 2b       	or	r18, r21
    6f3c:	21 f4       	brne	.+8      	; 0x6f46 <__fp_cmp+0x3e>
    6f3e:	08 95       	ret
    6f40:	0a 26       	eor	r0, r26
    6f42:	09 f4       	brne	.+2      	; 0x6f46 <__fp_cmp+0x3e>
    6f44:	a1 40       	sbci	r26, 0x01	; 1
    6f46:	a6 95       	lsr	r26
    6f48:	8f ef       	ldi	r24, 0xFF	; 255
    6f4a:	81 1d       	adc	r24, r1
    6f4c:	81 1d       	adc	r24, r1
    6f4e:	08 95       	ret

00006f50 <__mulsi3>:
    6f50:	62 9f       	mul	r22, r18
    6f52:	d0 01       	movw	r26, r0
    6f54:	73 9f       	mul	r23, r19
    6f56:	f0 01       	movw	r30, r0
    6f58:	82 9f       	mul	r24, r18
    6f5a:	e0 0d       	add	r30, r0
    6f5c:	f1 1d       	adc	r31, r1
    6f5e:	64 9f       	mul	r22, r20
    6f60:	e0 0d       	add	r30, r0
    6f62:	f1 1d       	adc	r31, r1
    6f64:	92 9f       	mul	r25, r18
    6f66:	f0 0d       	add	r31, r0
    6f68:	83 9f       	mul	r24, r19
    6f6a:	f0 0d       	add	r31, r0
    6f6c:	74 9f       	mul	r23, r20
    6f6e:	f0 0d       	add	r31, r0
    6f70:	65 9f       	mul	r22, r21
    6f72:	f0 0d       	add	r31, r0
    6f74:	99 27       	eor	r25, r25
    6f76:	72 9f       	mul	r23, r18
    6f78:	b0 0d       	add	r27, r0
    6f7a:	e1 1d       	adc	r30, r1
    6f7c:	f9 1f       	adc	r31, r25
    6f7e:	63 9f       	mul	r22, r19
    6f80:	b0 0d       	add	r27, r0
    6f82:	e1 1d       	adc	r30, r1
    6f84:	f9 1f       	adc	r31, r25
    6f86:	bd 01       	movw	r22, r26
    6f88:	cf 01       	movw	r24, r30
    6f8a:	11 24       	eor	r1, r1
    6f8c:	08 95       	ret

00006f8e <__divmodhi4>:
    6f8e:	97 fb       	bst	r25, 7
    6f90:	09 2e       	mov	r0, r25
    6f92:	07 26       	eor	r0, r23
    6f94:	0a d0       	rcall	.+20     	; 0x6faa <__divmodhi4_neg1>
    6f96:	77 fd       	sbrc	r23, 7
    6f98:	04 d0       	rcall	.+8      	; 0x6fa2 <__divmodhi4_neg2>
    6f9a:	49 d0       	rcall	.+146    	; 0x702e <__udivmodhi4>
    6f9c:	06 d0       	rcall	.+12     	; 0x6faa <__divmodhi4_neg1>
    6f9e:	00 20       	and	r0, r0
    6fa0:	1a f4       	brpl	.+6      	; 0x6fa8 <__divmodhi4_exit>

00006fa2 <__divmodhi4_neg2>:
    6fa2:	70 95       	com	r23
    6fa4:	61 95       	neg	r22
    6fa6:	7f 4f       	sbci	r23, 0xFF	; 255

00006fa8 <__divmodhi4_exit>:
    6fa8:	08 95       	ret

00006faa <__divmodhi4_neg1>:
    6faa:	f6 f7       	brtc	.-4      	; 0x6fa8 <__divmodhi4_exit>
    6fac:	90 95       	com	r25
    6fae:	81 95       	neg	r24
    6fb0:	9f 4f       	sbci	r25, 0xFF	; 255
    6fb2:	08 95       	ret

00006fb4 <__udivmodsi4>:
    6fb4:	a1 e2       	ldi	r26, 0x21	; 33
    6fb6:	1a 2e       	mov	r1, r26
    6fb8:	aa 1b       	sub	r26, r26
    6fba:	bb 1b       	sub	r27, r27
    6fbc:	fd 01       	movw	r30, r26
    6fbe:	0d c0       	rjmp	.+26     	; 0x6fda <__udivmodsi4_ep>

00006fc0 <__udivmodsi4_loop>:
    6fc0:	aa 1f       	adc	r26, r26
    6fc2:	bb 1f       	adc	r27, r27
    6fc4:	ee 1f       	adc	r30, r30
    6fc6:	ff 1f       	adc	r31, r31
    6fc8:	a2 17       	cp	r26, r18
    6fca:	b3 07       	cpc	r27, r19
    6fcc:	e4 07       	cpc	r30, r20
    6fce:	f5 07       	cpc	r31, r21
    6fd0:	20 f0       	brcs	.+8      	; 0x6fda <__udivmodsi4_ep>
    6fd2:	a2 1b       	sub	r26, r18
    6fd4:	b3 0b       	sbc	r27, r19
    6fd6:	e4 0b       	sbc	r30, r20
    6fd8:	f5 0b       	sbc	r31, r21

00006fda <__udivmodsi4_ep>:
    6fda:	66 1f       	adc	r22, r22
    6fdc:	77 1f       	adc	r23, r23
    6fde:	88 1f       	adc	r24, r24
    6fe0:	99 1f       	adc	r25, r25
    6fe2:	1a 94       	dec	r1
    6fe4:	69 f7       	brne	.-38     	; 0x6fc0 <__udivmodsi4_loop>
    6fe6:	60 95       	com	r22
    6fe8:	70 95       	com	r23
    6fea:	80 95       	com	r24
    6fec:	90 95       	com	r25
    6fee:	9b 01       	movw	r18, r22
    6ff0:	ac 01       	movw	r20, r24
    6ff2:	bd 01       	movw	r22, r26
    6ff4:	cf 01       	movw	r24, r30
    6ff6:	08 95       	ret

00006ff8 <__divmodsi4>:
    6ff8:	97 fb       	bst	r25, 7
    6ffa:	09 2e       	mov	r0, r25
    6ffc:	05 26       	eor	r0, r21
    6ffe:	0e d0       	rcall	.+28     	; 0x701c <__divmodsi4_neg1>
    7000:	57 fd       	sbrc	r21, 7
    7002:	04 d0       	rcall	.+8      	; 0x700c <__divmodsi4_neg2>
    7004:	d7 df       	rcall	.-82     	; 0x6fb4 <__udivmodsi4>
    7006:	0a d0       	rcall	.+20     	; 0x701c <__divmodsi4_neg1>
    7008:	00 1c       	adc	r0, r0
    700a:	38 f4       	brcc	.+14     	; 0x701a <__divmodsi4_exit>

0000700c <__divmodsi4_neg2>:
    700c:	50 95       	com	r21
    700e:	40 95       	com	r20
    7010:	30 95       	com	r19
    7012:	21 95       	neg	r18
    7014:	3f 4f       	sbci	r19, 0xFF	; 255
    7016:	4f 4f       	sbci	r20, 0xFF	; 255
    7018:	5f 4f       	sbci	r21, 0xFF	; 255

0000701a <__divmodsi4_exit>:
    701a:	08 95       	ret

0000701c <__divmodsi4_neg1>:
    701c:	f6 f7       	brtc	.-4      	; 0x701a <__divmodsi4_exit>
    701e:	90 95       	com	r25
    7020:	80 95       	com	r24
    7022:	70 95       	com	r23
    7024:	61 95       	neg	r22
    7026:	7f 4f       	sbci	r23, 0xFF	; 255
    7028:	8f 4f       	sbci	r24, 0xFF	; 255
    702a:	9f 4f       	sbci	r25, 0xFF	; 255
    702c:	08 95       	ret

0000702e <__udivmodhi4>:
    702e:	aa 1b       	sub	r26, r26
    7030:	bb 1b       	sub	r27, r27
    7032:	51 e1       	ldi	r21, 0x11	; 17
    7034:	07 c0       	rjmp	.+14     	; 0x7044 <__udivmodhi4_ep>

00007036 <__udivmodhi4_loop>:
    7036:	aa 1f       	adc	r26, r26
    7038:	bb 1f       	adc	r27, r27
    703a:	a6 17       	cp	r26, r22
    703c:	b7 07       	cpc	r27, r23
    703e:	10 f0       	brcs	.+4      	; 0x7044 <__udivmodhi4_ep>
    7040:	a6 1b       	sub	r26, r22
    7042:	b7 0b       	sbc	r27, r23

00007044 <__udivmodhi4_ep>:
    7044:	88 1f       	adc	r24, r24
    7046:	99 1f       	adc	r25, r25
    7048:	5a 95       	dec	r21
    704a:	a9 f7       	brne	.-22     	; 0x7036 <__udivmodhi4_loop>
    704c:	80 95       	com	r24
    704e:	90 95       	com	r25
    7050:	bc 01       	movw	r22, r24
    7052:	cd 01       	movw	r24, r26
    7054:	08 95       	ret

00007056 <__prologue_saves__>:
    7056:	2f 92       	push	r2
    7058:	3f 92       	push	r3
    705a:	4f 92       	push	r4
    705c:	5f 92       	push	r5
    705e:	6f 92       	push	r6
    7060:	7f 92       	push	r7
    7062:	8f 92       	push	r8
    7064:	9f 92       	push	r9
    7066:	af 92       	push	r10
    7068:	bf 92       	push	r11
    706a:	cf 92       	push	r12
    706c:	df 92       	push	r13
    706e:	ef 92       	push	r14
    7070:	ff 92       	push	r15
    7072:	0f 93       	push	r16
    7074:	1f 93       	push	r17
    7076:	cf 93       	push	r28
    7078:	df 93       	push	r29
    707a:	cd b7       	in	r28, 0x3d	; 61
    707c:	de b7       	in	r29, 0x3e	; 62
    707e:	ca 1b       	sub	r28, r26
    7080:	db 0b       	sbc	r29, r27
    7082:	cd bf       	out	0x3d, r28	; 61
    7084:	de bf       	out	0x3e, r29	; 62
    7086:	19 94       	eijmp

00007088 <__epilogue_restores__>:
    7088:	2a 88       	ldd	r2, Y+18	; 0x12
    708a:	39 88       	ldd	r3, Y+17	; 0x11
    708c:	48 88       	ldd	r4, Y+16	; 0x10
    708e:	5f 84       	ldd	r5, Y+15	; 0x0f
    7090:	6e 84       	ldd	r6, Y+14	; 0x0e
    7092:	7d 84       	ldd	r7, Y+13	; 0x0d
    7094:	8c 84       	ldd	r8, Y+12	; 0x0c
    7096:	9b 84       	ldd	r9, Y+11	; 0x0b
    7098:	aa 84       	ldd	r10, Y+10	; 0x0a
    709a:	b9 84       	ldd	r11, Y+9	; 0x09
    709c:	c8 84       	ldd	r12, Y+8	; 0x08
    709e:	df 80       	ldd	r13, Y+7	; 0x07
    70a0:	ee 80       	ldd	r14, Y+6	; 0x06
    70a2:	fd 80       	ldd	r15, Y+5	; 0x05
    70a4:	0c 81       	ldd	r16, Y+4	; 0x04
    70a6:	1b 81       	ldd	r17, Y+3	; 0x03
    70a8:	aa 81       	ldd	r26, Y+2	; 0x02
    70aa:	b9 81       	ldd	r27, Y+1	; 0x01
    70ac:	ce 0f       	add	r28, r30
    70ae:	d1 1d       	adc	r29, r1
    70b0:	cd bf       	out	0x3d, r28	; 61
    70b2:	de bf       	out	0x3e, r29	; 62
    70b4:	ed 01       	movw	r28, r26
    70b6:	08 95       	ret

000070b8 <strcpy_P>:
    70b8:	fb 01       	movw	r30, r22
    70ba:	dc 01       	movw	r26, r24
    70bc:	05 90       	lpm	r0, Z+
    70be:	0d 92       	st	X+, r0
    70c0:	00 20       	and	r0, r0
    70c2:	e1 f7       	brne	.-8      	; 0x70bc <strcpy_P+0x4>
    70c4:	08 95       	ret

000070c6 <memmove>:
    70c6:	68 17       	cp	r22, r24
    70c8:	79 07       	cpc	r23, r25
    70ca:	68 f4       	brcc	.+26     	; 0x70e6 <memmove+0x20>
    70cc:	fb 01       	movw	r30, r22
    70ce:	dc 01       	movw	r26, r24
    70d0:	e4 0f       	add	r30, r20
    70d2:	f5 1f       	adc	r31, r21
    70d4:	a4 0f       	add	r26, r20
    70d6:	b5 1f       	adc	r27, r21
    70d8:	02 c0       	rjmp	.+4      	; 0x70de <memmove+0x18>
    70da:	02 90       	ld	r0, -Z
    70dc:	0e 92       	st	-X, r0
    70de:	41 50       	subi	r20, 0x01	; 1
    70e0:	50 40       	sbci	r21, 0x00	; 0
    70e2:	d8 f7       	brcc	.-10     	; 0x70da <memmove+0x14>
    70e4:	08 95       	ret
    70e6:	0c 94 e8 3a 	jmp	0x75d0	; 0x75d0 <memcpy>

000070ea <strcat>:
    70ea:	fb 01       	movw	r30, r22
    70ec:	dc 01       	movw	r26, r24
    70ee:	0d 90       	ld	r0, X+
    70f0:	00 20       	and	r0, r0
    70f2:	e9 f7       	brne	.-6      	; 0x70ee <strcat+0x4>
    70f4:	11 97       	sbiw	r26, 0x01	; 1
    70f6:	01 90       	ld	r0, Z+
    70f8:	0d 92       	st	X+, r0
    70fa:	00 20       	and	r0, r0
    70fc:	e1 f7       	brne	.-8      	; 0x70f6 <strcat+0xc>
    70fe:	08 95       	ret

00007100 <itoa>:
    7100:	fb 01       	movw	r30, r22
    7102:	9f 01       	movw	r18, r30
    7104:	e8 94       	clt
    7106:	42 30       	cpi	r20, 0x02	; 2
    7108:	c4 f0       	brlt	.+48     	; 0x713a <itoa+0x3a>
    710a:	45 32       	cpi	r20, 0x25	; 37
    710c:	b4 f4       	brge	.+44     	; 0x713a <itoa+0x3a>
    710e:	4a 30       	cpi	r20, 0x0A	; 10
    7110:	29 f4       	brne	.+10     	; 0x711c <itoa+0x1c>
    7112:	97 fb       	bst	r25, 7
    7114:	1e f4       	brtc	.+6      	; 0x711c <itoa+0x1c>
    7116:	90 95       	com	r25
    7118:	81 95       	neg	r24
    711a:	9f 4f       	sbci	r25, 0xFF	; 255
    711c:	64 2f       	mov	r22, r20
    711e:	77 27       	eor	r23, r23
    7120:	0e 94 17 38 	call	0x702e	; 0x702e <__udivmodhi4>
    7124:	80 5d       	subi	r24, 0xD0	; 208
    7126:	8a 33       	cpi	r24, 0x3A	; 58
    7128:	0c f0       	brlt	.+2      	; 0x712c <itoa+0x2c>
    712a:	89 5d       	subi	r24, 0xD9	; 217
    712c:	81 93       	st	Z+, r24
    712e:	cb 01       	movw	r24, r22
    7130:	00 97       	sbiw	r24, 0x00	; 0
    7132:	a1 f7       	brne	.-24     	; 0x711c <itoa+0x1c>
    7134:	16 f4       	brtc	.+4      	; 0x713a <itoa+0x3a>
    7136:	5d e2       	ldi	r21, 0x2D	; 45
    7138:	51 93       	st	Z+, r21
    713a:	10 82       	st	Z, r1
    713c:	c9 01       	movw	r24, r18
    713e:	0c 94 fc 3a 	jmp	0x75f8	; 0x75f8 <strrev>

00007142 <printf>:
    7142:	cf 93       	push	r28
    7144:	df 93       	push	r29
    7146:	cd b7       	in	r28, 0x3d	; 61
    7148:	de b7       	in	r29, 0x3e	; 62
    714a:	fe 01       	movw	r30, r28
    714c:	36 96       	adiw	r30, 0x06	; 6
    714e:	61 91       	ld	r22, Z+
    7150:	71 91       	ld	r23, Z+
    7152:	80 91 b4 50 	lds	r24, 0x50B4
    7156:	90 91 b5 50 	lds	r25, 0x50B5
    715a:	af 01       	movw	r20, r30
    715c:	0e 94 dc 38 	call	0x71b8	; 0x71b8 <vfprintf>
    7160:	df 91       	pop	r29
    7162:	cf 91       	pop	r28
    7164:	08 95       	ret

00007166 <sprintf>:
    7166:	0f 93       	push	r16
    7168:	1f 93       	push	r17
    716a:	cf 93       	push	r28
    716c:	df 93       	push	r29
    716e:	cd b7       	in	r28, 0x3d	; 61
    7170:	de b7       	in	r29, 0x3e	; 62
    7172:	2e 97       	sbiw	r28, 0x0e	; 14
    7174:	cd bf       	out	0x3d, r28	; 61
    7176:	de bf       	out	0x3e, r29	; 62
    7178:	0e 89       	ldd	r16, Y+22	; 0x16
    717a:	1f 89       	ldd	r17, Y+23	; 0x17
    717c:	86 e0       	ldi	r24, 0x06	; 6
    717e:	8c 83       	std	Y+4, r24	; 0x04
    7180:	09 83       	std	Y+1, r16	; 0x01
    7182:	1a 83       	std	Y+2, r17	; 0x02
    7184:	8f ef       	ldi	r24, 0xFF	; 255
    7186:	9f e7       	ldi	r25, 0x7F	; 127
    7188:	8d 83       	std	Y+5, r24	; 0x05
    718a:	9e 83       	std	Y+6, r25	; 0x06
    718c:	ae 01       	movw	r20, r28
    718e:	46 5e       	subi	r20, 0xE6	; 230
    7190:	5f 4f       	sbci	r21, 0xFF	; 255
    7192:	ce 01       	movw	r24, r28
    7194:	01 96       	adiw	r24, 0x01	; 1
    7196:	68 8d       	ldd	r22, Y+24	; 0x18
    7198:	79 8d       	ldd	r23, Y+25	; 0x19
    719a:	0e 94 dc 38 	call	0x71b8	; 0x71b8 <vfprintf>
    719e:	ef 81       	ldd	r30, Y+7	; 0x07
    71a0:	f8 85       	ldd	r31, Y+8	; 0x08
    71a2:	e0 0f       	add	r30, r16
    71a4:	f1 1f       	adc	r31, r17
    71a6:	10 82       	st	Z, r1
    71a8:	2e 96       	adiw	r28, 0x0e	; 14
    71aa:	cd bf       	out	0x3d, r28	; 61
    71ac:	de bf       	out	0x3e, r29	; 62
    71ae:	df 91       	pop	r29
    71b0:	cf 91       	pop	r28
    71b2:	1f 91       	pop	r17
    71b4:	0f 91       	pop	r16
    71b6:	08 95       	ret

000071b8 <vfprintf>:
    71b8:	2f 92       	push	r2
    71ba:	3f 92       	push	r3
    71bc:	4f 92       	push	r4
    71be:	5f 92       	push	r5
    71c0:	6f 92       	push	r6
    71c2:	7f 92       	push	r7
    71c4:	8f 92       	push	r8
    71c6:	9f 92       	push	r9
    71c8:	af 92       	push	r10
    71ca:	bf 92       	push	r11
    71cc:	cf 92       	push	r12
    71ce:	df 92       	push	r13
    71d0:	ef 92       	push	r14
    71d2:	ff 92       	push	r15
    71d4:	0f 93       	push	r16
    71d6:	1f 93       	push	r17
    71d8:	cf 93       	push	r28
    71da:	df 93       	push	r29
    71dc:	cd b7       	in	r28, 0x3d	; 61
    71de:	de b7       	in	r29, 0x3e	; 62
    71e0:	2d 97       	sbiw	r28, 0x0d	; 13
    71e2:	cd bf       	out	0x3d, r28	; 61
    71e4:	de bf       	out	0x3e, r29	; 62
    71e6:	3c 01       	movw	r6, r24
    71e8:	6c 87       	std	Y+12, r22	; 0x0c
    71ea:	7d 87       	std	Y+13, r23	; 0x0d
    71ec:	5a 01       	movw	r10, r20
    71ee:	fc 01       	movw	r30, r24
    71f0:	16 82       	std	Z+6, r1	; 0x06
    71f2:	17 82       	std	Z+7, r1	; 0x07
    71f4:	83 81       	ldd	r24, Z+3	; 0x03
    71f6:	81 ff       	sbrs	r24, 1
    71f8:	c8 c1       	rjmp	.+912    	; 0x758a <vfprintf+0x3d2>
    71fa:	2e 01       	movw	r4, r28
    71fc:	08 94       	sec
    71fe:	41 1c       	adc	r4, r1
    7200:	51 1c       	adc	r5, r1
    7202:	f3 01       	movw	r30, r6
    7204:	93 81       	ldd	r25, Z+3	; 0x03
    7206:	ec 85       	ldd	r30, Y+12	; 0x0c
    7208:	fd 85       	ldd	r31, Y+13	; 0x0d
    720a:	93 fd       	sbrc	r25, 3
    720c:	85 91       	lpm	r24, Z+
    720e:	93 ff       	sbrs	r25, 3
    7210:	81 91       	ld	r24, Z+
    7212:	ec 87       	std	Y+12, r30	; 0x0c
    7214:	fd 87       	std	Y+13, r31	; 0x0d
    7216:	88 23       	and	r24, r24
    7218:	09 f4       	brne	.+2      	; 0x721c <vfprintf+0x64>
    721a:	b3 c1       	rjmp	.+870    	; 0x7582 <vfprintf+0x3ca>
    721c:	85 32       	cpi	r24, 0x25	; 37
    721e:	41 f4       	brne	.+16     	; 0x7230 <vfprintf+0x78>
    7220:	93 fd       	sbrc	r25, 3
    7222:	85 91       	lpm	r24, Z+
    7224:	93 ff       	sbrs	r25, 3
    7226:	81 91       	ld	r24, Z+
    7228:	ec 87       	std	Y+12, r30	; 0x0c
    722a:	fd 87       	std	Y+13, r31	; 0x0d
    722c:	85 32       	cpi	r24, 0x25	; 37
    722e:	29 f4       	brne	.+10     	; 0x723a <vfprintf+0x82>
    7230:	90 e0       	ldi	r25, 0x00	; 0
    7232:	b3 01       	movw	r22, r6
    7234:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    7238:	e4 cf       	rjmp	.-56     	; 0x7202 <vfprintf+0x4a>
    723a:	ff 24       	eor	r15, r15
    723c:	ee 24       	eor	r14, r14
    723e:	10 e0       	ldi	r17, 0x00	; 0
    7240:	10 32       	cpi	r17, 0x20	; 32
    7242:	b0 f4       	brcc	.+44     	; 0x7270 <vfprintf+0xb8>
    7244:	8b 32       	cpi	r24, 0x2B	; 43
    7246:	69 f0       	breq	.+26     	; 0x7262 <vfprintf+0xaa>
    7248:	8c 32       	cpi	r24, 0x2C	; 44
    724a:	28 f4       	brcc	.+10     	; 0x7256 <vfprintf+0x9e>
    724c:	80 32       	cpi	r24, 0x20	; 32
    724e:	51 f0       	breq	.+20     	; 0x7264 <vfprintf+0xac>
    7250:	83 32       	cpi	r24, 0x23	; 35
    7252:	71 f4       	brne	.+28     	; 0x7270 <vfprintf+0xb8>
    7254:	0b c0       	rjmp	.+22     	; 0x726c <vfprintf+0xb4>
    7256:	8d 32       	cpi	r24, 0x2D	; 45
    7258:	39 f0       	breq	.+14     	; 0x7268 <vfprintf+0xb0>
    725a:	80 33       	cpi	r24, 0x30	; 48
    725c:	49 f4       	brne	.+18     	; 0x7270 <vfprintf+0xb8>
    725e:	11 60       	ori	r17, 0x01	; 1
    7260:	2c c0       	rjmp	.+88     	; 0x72ba <vfprintf+0x102>
    7262:	12 60       	ori	r17, 0x02	; 2
    7264:	14 60       	ori	r17, 0x04	; 4
    7266:	29 c0       	rjmp	.+82     	; 0x72ba <vfprintf+0x102>
    7268:	18 60       	ori	r17, 0x08	; 8
    726a:	27 c0       	rjmp	.+78     	; 0x72ba <vfprintf+0x102>
    726c:	10 61       	ori	r17, 0x10	; 16
    726e:	25 c0       	rjmp	.+74     	; 0x72ba <vfprintf+0x102>
    7270:	17 fd       	sbrc	r17, 7
    7272:	2e c0       	rjmp	.+92     	; 0x72d0 <vfprintf+0x118>
    7274:	28 2f       	mov	r18, r24
    7276:	20 53       	subi	r18, 0x30	; 48
    7278:	2a 30       	cpi	r18, 0x0A	; 10
    727a:	98 f4       	brcc	.+38     	; 0x72a2 <vfprintf+0xea>
    727c:	16 ff       	sbrs	r17, 6
    727e:	08 c0       	rjmp	.+16     	; 0x7290 <vfprintf+0xd8>
    7280:	8f 2d       	mov	r24, r15
    7282:	88 0f       	add	r24, r24
    7284:	f8 2e       	mov	r15, r24
    7286:	ff 0c       	add	r15, r15
    7288:	ff 0c       	add	r15, r15
    728a:	f8 0e       	add	r15, r24
    728c:	f2 0e       	add	r15, r18
    728e:	15 c0       	rjmp	.+42     	; 0x72ba <vfprintf+0x102>
    7290:	8e 2d       	mov	r24, r14
    7292:	88 0f       	add	r24, r24
    7294:	e8 2e       	mov	r14, r24
    7296:	ee 0c       	add	r14, r14
    7298:	ee 0c       	add	r14, r14
    729a:	e8 0e       	add	r14, r24
    729c:	e2 0e       	add	r14, r18
    729e:	10 62       	ori	r17, 0x20	; 32
    72a0:	0c c0       	rjmp	.+24     	; 0x72ba <vfprintf+0x102>
    72a2:	8e 32       	cpi	r24, 0x2E	; 46
    72a4:	21 f4       	brne	.+8      	; 0x72ae <vfprintf+0xf6>
    72a6:	16 fd       	sbrc	r17, 6
    72a8:	6c c1       	rjmp	.+728    	; 0x7582 <vfprintf+0x3ca>
    72aa:	10 64       	ori	r17, 0x40	; 64
    72ac:	06 c0       	rjmp	.+12     	; 0x72ba <vfprintf+0x102>
    72ae:	8c 36       	cpi	r24, 0x6C	; 108
    72b0:	11 f4       	brne	.+4      	; 0x72b6 <vfprintf+0xfe>
    72b2:	10 68       	ori	r17, 0x80	; 128
    72b4:	02 c0       	rjmp	.+4      	; 0x72ba <vfprintf+0x102>
    72b6:	88 36       	cpi	r24, 0x68	; 104
    72b8:	59 f4       	brne	.+22     	; 0x72d0 <vfprintf+0x118>
    72ba:	ec 85       	ldd	r30, Y+12	; 0x0c
    72bc:	fd 85       	ldd	r31, Y+13	; 0x0d
    72be:	93 fd       	sbrc	r25, 3
    72c0:	85 91       	lpm	r24, Z+
    72c2:	93 ff       	sbrs	r25, 3
    72c4:	81 91       	ld	r24, Z+
    72c6:	ec 87       	std	Y+12, r30	; 0x0c
    72c8:	fd 87       	std	Y+13, r31	; 0x0d
    72ca:	88 23       	and	r24, r24
    72cc:	09 f0       	breq	.+2      	; 0x72d0 <vfprintf+0x118>
    72ce:	b8 cf       	rjmp	.-144    	; 0x7240 <vfprintf+0x88>
    72d0:	98 2f       	mov	r25, r24
    72d2:	95 54       	subi	r25, 0x45	; 69
    72d4:	93 30       	cpi	r25, 0x03	; 3
    72d6:	18 f0       	brcs	.+6      	; 0x72de <vfprintf+0x126>
    72d8:	90 52       	subi	r25, 0x20	; 32
    72da:	93 30       	cpi	r25, 0x03	; 3
    72dc:	38 f4       	brcc	.+14     	; 0x72ec <vfprintf+0x134>
    72de:	24 e0       	ldi	r18, 0x04	; 4
    72e0:	30 e0       	ldi	r19, 0x00	; 0
    72e2:	a2 0e       	add	r10, r18
    72e4:	b3 1e       	adc	r11, r19
    72e6:	3f e3       	ldi	r19, 0x3F	; 63
    72e8:	39 83       	std	Y+1, r19	; 0x01
    72ea:	0f c0       	rjmp	.+30     	; 0x730a <vfprintf+0x152>
    72ec:	83 36       	cpi	r24, 0x63	; 99
    72ee:	31 f0       	breq	.+12     	; 0x72fc <vfprintf+0x144>
    72f0:	83 37       	cpi	r24, 0x73	; 115
    72f2:	81 f0       	breq	.+32     	; 0x7314 <vfprintf+0x15c>
    72f4:	83 35       	cpi	r24, 0x53	; 83
    72f6:	09 f0       	breq	.+2      	; 0x72fa <vfprintf+0x142>
    72f8:	5a c0       	rjmp	.+180    	; 0x73ae <vfprintf+0x1f6>
    72fa:	22 c0       	rjmp	.+68     	; 0x7340 <vfprintf+0x188>
    72fc:	f5 01       	movw	r30, r10
    72fe:	80 81       	ld	r24, Z
    7300:	89 83       	std	Y+1, r24	; 0x01
    7302:	22 e0       	ldi	r18, 0x02	; 2
    7304:	30 e0       	ldi	r19, 0x00	; 0
    7306:	a2 0e       	add	r10, r18
    7308:	b3 1e       	adc	r11, r19
    730a:	21 e0       	ldi	r18, 0x01	; 1
    730c:	c2 2e       	mov	r12, r18
    730e:	d1 2c       	mov	r13, r1
    7310:	42 01       	movw	r8, r4
    7312:	14 c0       	rjmp	.+40     	; 0x733c <vfprintf+0x184>
    7314:	92 e0       	ldi	r25, 0x02	; 2
    7316:	29 2e       	mov	r2, r25
    7318:	31 2c       	mov	r3, r1
    731a:	2a 0c       	add	r2, r10
    731c:	3b 1c       	adc	r3, r11
    731e:	f5 01       	movw	r30, r10
    7320:	80 80       	ld	r8, Z
    7322:	91 80       	ldd	r9, Z+1	; 0x01
    7324:	16 ff       	sbrs	r17, 6
    7326:	03 c0       	rjmp	.+6      	; 0x732e <vfprintf+0x176>
    7328:	6f 2d       	mov	r22, r15
    732a:	70 e0       	ldi	r23, 0x00	; 0
    732c:	02 c0       	rjmp	.+4      	; 0x7332 <vfprintf+0x17a>
    732e:	6f ef       	ldi	r22, 0xFF	; 255
    7330:	7f ef       	ldi	r23, 0xFF	; 255
    7332:	c4 01       	movw	r24, r8
    7334:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <strnlen>
    7338:	6c 01       	movw	r12, r24
    733a:	51 01       	movw	r10, r2
    733c:	1f 77       	andi	r17, 0x7F	; 127
    733e:	15 c0       	rjmp	.+42     	; 0x736a <vfprintf+0x1b2>
    7340:	82 e0       	ldi	r24, 0x02	; 2
    7342:	28 2e       	mov	r2, r24
    7344:	31 2c       	mov	r3, r1
    7346:	2a 0c       	add	r2, r10
    7348:	3b 1c       	adc	r3, r11
    734a:	f5 01       	movw	r30, r10
    734c:	80 80       	ld	r8, Z
    734e:	91 80       	ldd	r9, Z+1	; 0x01
    7350:	16 ff       	sbrs	r17, 6
    7352:	03 c0       	rjmp	.+6      	; 0x735a <vfprintf+0x1a2>
    7354:	6f 2d       	mov	r22, r15
    7356:	70 e0       	ldi	r23, 0x00	; 0
    7358:	02 c0       	rjmp	.+4      	; 0x735e <vfprintf+0x1a6>
    735a:	6f ef       	ldi	r22, 0xFF	; 255
    735c:	7f ef       	ldi	r23, 0xFF	; 255
    735e:	c4 01       	movw	r24, r8
    7360:	0e 94 dd 3a 	call	0x75ba	; 0x75ba <strnlen_P>
    7364:	6c 01       	movw	r12, r24
    7366:	10 68       	ori	r17, 0x80	; 128
    7368:	51 01       	movw	r10, r2
    736a:	13 fd       	sbrc	r17, 3
    736c:	1c c0       	rjmp	.+56     	; 0x73a6 <vfprintf+0x1ee>
    736e:	06 c0       	rjmp	.+12     	; 0x737c <vfprintf+0x1c4>
    7370:	80 e2       	ldi	r24, 0x20	; 32
    7372:	90 e0       	ldi	r25, 0x00	; 0
    7374:	b3 01       	movw	r22, r6
    7376:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    737a:	ea 94       	dec	r14
    737c:	8e 2d       	mov	r24, r14
    737e:	90 e0       	ldi	r25, 0x00	; 0
    7380:	c8 16       	cp	r12, r24
    7382:	d9 06       	cpc	r13, r25
    7384:	a8 f3       	brcs	.-22     	; 0x7370 <vfprintf+0x1b8>
    7386:	0f c0       	rjmp	.+30     	; 0x73a6 <vfprintf+0x1ee>
    7388:	f4 01       	movw	r30, r8
    738a:	17 fd       	sbrc	r17, 7
    738c:	85 91       	lpm	r24, Z+
    738e:	17 ff       	sbrs	r17, 7
    7390:	81 91       	ld	r24, Z+
    7392:	4f 01       	movw	r8, r30
    7394:	90 e0       	ldi	r25, 0x00	; 0
    7396:	b3 01       	movw	r22, r6
    7398:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    739c:	e1 10       	cpse	r14, r1
    739e:	ea 94       	dec	r14
    73a0:	08 94       	sec
    73a2:	c1 08       	sbc	r12, r1
    73a4:	d1 08       	sbc	r13, r1
    73a6:	c1 14       	cp	r12, r1
    73a8:	d1 04       	cpc	r13, r1
    73aa:	71 f7       	brne	.-36     	; 0x7388 <vfprintf+0x1d0>
    73ac:	e7 c0       	rjmp	.+462    	; 0x757c <vfprintf+0x3c4>
    73ae:	84 36       	cpi	r24, 0x64	; 100
    73b0:	11 f0       	breq	.+4      	; 0x73b6 <vfprintf+0x1fe>
    73b2:	89 36       	cpi	r24, 0x69	; 105
    73b4:	51 f5       	brne	.+84     	; 0x740a <vfprintf+0x252>
    73b6:	f5 01       	movw	r30, r10
    73b8:	17 ff       	sbrs	r17, 7
    73ba:	07 c0       	rjmp	.+14     	; 0x73ca <vfprintf+0x212>
    73bc:	80 81       	ld	r24, Z
    73be:	91 81       	ldd	r25, Z+1	; 0x01
    73c0:	a2 81       	ldd	r26, Z+2	; 0x02
    73c2:	b3 81       	ldd	r27, Z+3	; 0x03
    73c4:	24 e0       	ldi	r18, 0x04	; 4
    73c6:	30 e0       	ldi	r19, 0x00	; 0
    73c8:	08 c0       	rjmp	.+16     	; 0x73da <vfprintf+0x222>
    73ca:	80 81       	ld	r24, Z
    73cc:	91 81       	ldd	r25, Z+1	; 0x01
    73ce:	aa 27       	eor	r26, r26
    73d0:	97 fd       	sbrc	r25, 7
    73d2:	a0 95       	com	r26
    73d4:	ba 2f       	mov	r27, r26
    73d6:	22 e0       	ldi	r18, 0x02	; 2
    73d8:	30 e0       	ldi	r19, 0x00	; 0
    73da:	a2 0e       	add	r10, r18
    73dc:	b3 1e       	adc	r11, r19
    73de:	01 2f       	mov	r16, r17
    73e0:	0f 76       	andi	r16, 0x6F	; 111
    73e2:	b7 ff       	sbrs	r27, 7
    73e4:	08 c0       	rjmp	.+16     	; 0x73f6 <vfprintf+0x23e>
    73e6:	b0 95       	com	r27
    73e8:	a0 95       	com	r26
    73ea:	90 95       	com	r25
    73ec:	81 95       	neg	r24
    73ee:	9f 4f       	sbci	r25, 0xFF	; 255
    73f0:	af 4f       	sbci	r26, 0xFF	; 255
    73f2:	bf 4f       	sbci	r27, 0xFF	; 255
    73f4:	00 68       	ori	r16, 0x80	; 128
    73f6:	bc 01       	movw	r22, r24
    73f8:	cd 01       	movw	r24, r26
    73fa:	a2 01       	movw	r20, r4
    73fc:	2a e0       	ldi	r18, 0x0A	; 10
    73fe:	30 e0       	ldi	r19, 0x00	; 0
    7400:	0e 94 38 3b 	call	0x7670	; 0x7670 <__ultoa_invert>
    7404:	d8 2e       	mov	r13, r24
    7406:	d4 18       	sub	r13, r4
    7408:	3f c0       	rjmp	.+126    	; 0x7488 <vfprintf+0x2d0>
    740a:	85 37       	cpi	r24, 0x75	; 117
    740c:	21 f4       	brne	.+8      	; 0x7416 <vfprintf+0x25e>
    740e:	1f 7e       	andi	r17, 0xEF	; 239
    7410:	2a e0       	ldi	r18, 0x0A	; 10
    7412:	30 e0       	ldi	r19, 0x00	; 0
    7414:	20 c0       	rjmp	.+64     	; 0x7456 <vfprintf+0x29e>
    7416:	19 7f       	andi	r17, 0xF9	; 249
    7418:	8f 36       	cpi	r24, 0x6F	; 111
    741a:	a9 f0       	breq	.+42     	; 0x7446 <vfprintf+0x28e>
    741c:	80 37       	cpi	r24, 0x70	; 112
    741e:	20 f4       	brcc	.+8      	; 0x7428 <vfprintf+0x270>
    7420:	88 35       	cpi	r24, 0x58	; 88
    7422:	09 f0       	breq	.+2      	; 0x7426 <vfprintf+0x26e>
    7424:	ae c0       	rjmp	.+348    	; 0x7582 <vfprintf+0x3ca>
    7426:	0b c0       	rjmp	.+22     	; 0x743e <vfprintf+0x286>
    7428:	80 37       	cpi	r24, 0x70	; 112
    742a:	21 f0       	breq	.+8      	; 0x7434 <vfprintf+0x27c>
    742c:	88 37       	cpi	r24, 0x78	; 120
    742e:	09 f0       	breq	.+2      	; 0x7432 <vfprintf+0x27a>
    7430:	a8 c0       	rjmp	.+336    	; 0x7582 <vfprintf+0x3ca>
    7432:	01 c0       	rjmp	.+2      	; 0x7436 <vfprintf+0x27e>
    7434:	10 61       	ori	r17, 0x10	; 16
    7436:	14 ff       	sbrs	r17, 4
    7438:	09 c0       	rjmp	.+18     	; 0x744c <vfprintf+0x294>
    743a:	14 60       	ori	r17, 0x04	; 4
    743c:	07 c0       	rjmp	.+14     	; 0x744c <vfprintf+0x294>
    743e:	14 ff       	sbrs	r17, 4
    7440:	08 c0       	rjmp	.+16     	; 0x7452 <vfprintf+0x29a>
    7442:	16 60       	ori	r17, 0x06	; 6
    7444:	06 c0       	rjmp	.+12     	; 0x7452 <vfprintf+0x29a>
    7446:	28 e0       	ldi	r18, 0x08	; 8
    7448:	30 e0       	ldi	r19, 0x00	; 0
    744a:	05 c0       	rjmp	.+10     	; 0x7456 <vfprintf+0x29e>
    744c:	20 e1       	ldi	r18, 0x10	; 16
    744e:	30 e0       	ldi	r19, 0x00	; 0
    7450:	02 c0       	rjmp	.+4      	; 0x7456 <vfprintf+0x29e>
    7452:	20 e1       	ldi	r18, 0x10	; 16
    7454:	32 e0       	ldi	r19, 0x02	; 2
    7456:	f5 01       	movw	r30, r10
    7458:	17 ff       	sbrs	r17, 7
    745a:	07 c0       	rjmp	.+14     	; 0x746a <vfprintf+0x2b2>
    745c:	60 81       	ld	r22, Z
    745e:	71 81       	ldd	r23, Z+1	; 0x01
    7460:	82 81       	ldd	r24, Z+2	; 0x02
    7462:	93 81       	ldd	r25, Z+3	; 0x03
    7464:	44 e0       	ldi	r20, 0x04	; 4
    7466:	50 e0       	ldi	r21, 0x00	; 0
    7468:	06 c0       	rjmp	.+12     	; 0x7476 <vfprintf+0x2be>
    746a:	60 81       	ld	r22, Z
    746c:	71 81       	ldd	r23, Z+1	; 0x01
    746e:	80 e0       	ldi	r24, 0x00	; 0
    7470:	90 e0       	ldi	r25, 0x00	; 0
    7472:	42 e0       	ldi	r20, 0x02	; 2
    7474:	50 e0       	ldi	r21, 0x00	; 0
    7476:	a4 0e       	add	r10, r20
    7478:	b5 1e       	adc	r11, r21
    747a:	a2 01       	movw	r20, r4
    747c:	0e 94 38 3b 	call	0x7670	; 0x7670 <__ultoa_invert>
    7480:	d8 2e       	mov	r13, r24
    7482:	d4 18       	sub	r13, r4
    7484:	01 2f       	mov	r16, r17
    7486:	0f 77       	andi	r16, 0x7F	; 127
    7488:	06 ff       	sbrs	r16, 6
    748a:	09 c0       	rjmp	.+18     	; 0x749e <vfprintf+0x2e6>
    748c:	0e 7f       	andi	r16, 0xFE	; 254
    748e:	df 14       	cp	r13, r15
    7490:	30 f4       	brcc	.+12     	; 0x749e <vfprintf+0x2e6>
    7492:	04 ff       	sbrs	r16, 4
    7494:	06 c0       	rjmp	.+12     	; 0x74a2 <vfprintf+0x2ea>
    7496:	02 fd       	sbrc	r16, 2
    7498:	04 c0       	rjmp	.+8      	; 0x74a2 <vfprintf+0x2ea>
    749a:	0f 7e       	andi	r16, 0xEF	; 239
    749c:	02 c0       	rjmp	.+4      	; 0x74a2 <vfprintf+0x2ea>
    749e:	1d 2d       	mov	r17, r13
    74a0:	01 c0       	rjmp	.+2      	; 0x74a4 <vfprintf+0x2ec>
    74a2:	1f 2d       	mov	r17, r15
    74a4:	80 2f       	mov	r24, r16
    74a6:	90 e0       	ldi	r25, 0x00	; 0
    74a8:	04 ff       	sbrs	r16, 4
    74aa:	0c c0       	rjmp	.+24     	; 0x74c4 <vfprintf+0x30c>
    74ac:	fe 01       	movw	r30, r28
    74ae:	ed 0d       	add	r30, r13
    74b0:	f1 1d       	adc	r31, r1
    74b2:	20 81       	ld	r18, Z
    74b4:	20 33       	cpi	r18, 0x30	; 48
    74b6:	11 f4       	brne	.+4      	; 0x74bc <vfprintf+0x304>
    74b8:	09 7e       	andi	r16, 0xE9	; 233
    74ba:	09 c0       	rjmp	.+18     	; 0x74ce <vfprintf+0x316>
    74bc:	02 ff       	sbrs	r16, 2
    74be:	06 c0       	rjmp	.+12     	; 0x74cc <vfprintf+0x314>
    74c0:	1e 5f       	subi	r17, 0xFE	; 254
    74c2:	05 c0       	rjmp	.+10     	; 0x74ce <vfprintf+0x316>
    74c4:	86 78       	andi	r24, 0x86	; 134
    74c6:	90 70       	andi	r25, 0x00	; 0
    74c8:	00 97       	sbiw	r24, 0x00	; 0
    74ca:	09 f0       	breq	.+2      	; 0x74ce <vfprintf+0x316>
    74cc:	1f 5f       	subi	r17, 0xFF	; 255
    74ce:	80 2e       	mov	r8, r16
    74d0:	99 24       	eor	r9, r9
    74d2:	03 fd       	sbrc	r16, 3
    74d4:	12 c0       	rjmp	.+36     	; 0x74fa <vfprintf+0x342>
    74d6:	00 ff       	sbrs	r16, 0
    74d8:	0d c0       	rjmp	.+26     	; 0x74f4 <vfprintf+0x33c>
    74da:	fd 2c       	mov	r15, r13
    74dc:	1e 15       	cp	r17, r14
    74de:	50 f4       	brcc	.+20     	; 0x74f4 <vfprintf+0x33c>
    74e0:	fe 0c       	add	r15, r14
    74e2:	f1 1a       	sub	r15, r17
    74e4:	1e 2d       	mov	r17, r14
    74e6:	06 c0       	rjmp	.+12     	; 0x74f4 <vfprintf+0x33c>
    74e8:	80 e2       	ldi	r24, 0x20	; 32
    74ea:	90 e0       	ldi	r25, 0x00	; 0
    74ec:	b3 01       	movw	r22, r6
    74ee:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    74f2:	1f 5f       	subi	r17, 0xFF	; 255
    74f4:	1e 15       	cp	r17, r14
    74f6:	c0 f3       	brcs	.-16     	; 0x74e8 <vfprintf+0x330>
    74f8:	04 c0       	rjmp	.+8      	; 0x7502 <vfprintf+0x34a>
    74fa:	1e 15       	cp	r17, r14
    74fc:	10 f4       	brcc	.+4      	; 0x7502 <vfprintf+0x34a>
    74fe:	e1 1a       	sub	r14, r17
    7500:	01 c0       	rjmp	.+2      	; 0x7504 <vfprintf+0x34c>
    7502:	ee 24       	eor	r14, r14
    7504:	84 fe       	sbrs	r8, 4
    7506:	0f c0       	rjmp	.+30     	; 0x7526 <vfprintf+0x36e>
    7508:	80 e3       	ldi	r24, 0x30	; 48
    750a:	90 e0       	ldi	r25, 0x00	; 0
    750c:	b3 01       	movw	r22, r6
    750e:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    7512:	82 fe       	sbrs	r8, 2
    7514:	1f c0       	rjmp	.+62     	; 0x7554 <vfprintf+0x39c>
    7516:	81 fe       	sbrs	r8, 1
    7518:	03 c0       	rjmp	.+6      	; 0x7520 <vfprintf+0x368>
    751a:	88 e5       	ldi	r24, 0x58	; 88
    751c:	90 e0       	ldi	r25, 0x00	; 0
    751e:	10 c0       	rjmp	.+32     	; 0x7540 <vfprintf+0x388>
    7520:	88 e7       	ldi	r24, 0x78	; 120
    7522:	90 e0       	ldi	r25, 0x00	; 0
    7524:	0d c0       	rjmp	.+26     	; 0x7540 <vfprintf+0x388>
    7526:	c4 01       	movw	r24, r8
    7528:	86 78       	andi	r24, 0x86	; 134
    752a:	90 70       	andi	r25, 0x00	; 0
    752c:	00 97       	sbiw	r24, 0x00	; 0
    752e:	91 f0       	breq	.+36     	; 0x7554 <vfprintf+0x39c>
    7530:	81 fc       	sbrc	r8, 1
    7532:	02 c0       	rjmp	.+4      	; 0x7538 <vfprintf+0x380>
    7534:	80 e2       	ldi	r24, 0x20	; 32
    7536:	01 c0       	rjmp	.+2      	; 0x753a <vfprintf+0x382>
    7538:	8b e2       	ldi	r24, 0x2B	; 43
    753a:	07 fd       	sbrc	r16, 7
    753c:	8d e2       	ldi	r24, 0x2D	; 45
    753e:	90 e0       	ldi	r25, 0x00	; 0
    7540:	b3 01       	movw	r22, r6
    7542:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    7546:	06 c0       	rjmp	.+12     	; 0x7554 <vfprintf+0x39c>
    7548:	80 e3       	ldi	r24, 0x30	; 48
    754a:	90 e0       	ldi	r25, 0x00	; 0
    754c:	b3 01       	movw	r22, r6
    754e:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    7552:	fa 94       	dec	r15
    7554:	df 14       	cp	r13, r15
    7556:	c0 f3       	brcs	.-16     	; 0x7548 <vfprintf+0x390>
    7558:	da 94       	dec	r13
    755a:	f2 01       	movw	r30, r4
    755c:	ed 0d       	add	r30, r13
    755e:	f1 1d       	adc	r31, r1
    7560:	80 81       	ld	r24, Z
    7562:	90 e0       	ldi	r25, 0x00	; 0
    7564:	b3 01       	movw	r22, r6
    7566:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    756a:	dd 20       	and	r13, r13
    756c:	a9 f7       	brne	.-22     	; 0x7558 <vfprintf+0x3a0>
    756e:	06 c0       	rjmp	.+12     	; 0x757c <vfprintf+0x3c4>
    7570:	80 e2       	ldi	r24, 0x20	; 32
    7572:	90 e0       	ldi	r25, 0x00	; 0
    7574:	b3 01       	movw	r22, r6
    7576:	0e 94 0c 3b 	call	0x7618	; 0x7618 <fputc>
    757a:	ea 94       	dec	r14
    757c:	ee 20       	and	r14, r14
    757e:	c1 f7       	brne	.-16     	; 0x7570 <vfprintf+0x3b8>
    7580:	40 ce       	rjmp	.-896    	; 0x7202 <vfprintf+0x4a>
    7582:	f3 01       	movw	r30, r6
    7584:	86 81       	ldd	r24, Z+6	; 0x06
    7586:	97 81       	ldd	r25, Z+7	; 0x07
    7588:	02 c0       	rjmp	.+4      	; 0x758e <vfprintf+0x3d6>
    758a:	8f ef       	ldi	r24, 0xFF	; 255
    758c:	9f ef       	ldi	r25, 0xFF	; 255
    758e:	2d 96       	adiw	r28, 0x0d	; 13
    7590:	cd bf       	out	0x3d, r28	; 61
    7592:	de bf       	out	0x3e, r29	; 62
    7594:	df 91       	pop	r29
    7596:	cf 91       	pop	r28
    7598:	1f 91       	pop	r17
    759a:	0f 91       	pop	r16
    759c:	ff 90       	pop	r15
    759e:	ef 90       	pop	r14
    75a0:	df 90       	pop	r13
    75a2:	cf 90       	pop	r12
    75a4:	bf 90       	pop	r11
    75a6:	af 90       	pop	r10
    75a8:	9f 90       	pop	r9
    75aa:	8f 90       	pop	r8
    75ac:	7f 90       	pop	r7
    75ae:	6f 90       	pop	r6
    75b0:	5f 90       	pop	r5
    75b2:	4f 90       	pop	r4
    75b4:	3f 90       	pop	r3
    75b6:	2f 90       	pop	r2
    75b8:	08 95       	ret

000075ba <strnlen_P>:
    75ba:	fc 01       	movw	r30, r24
    75bc:	05 90       	lpm	r0, Z+
    75be:	61 50       	subi	r22, 0x01	; 1
    75c0:	70 40       	sbci	r23, 0x00	; 0
    75c2:	01 10       	cpse	r0, r1
    75c4:	d8 f7       	brcc	.-10     	; 0x75bc <strnlen_P+0x2>
    75c6:	80 95       	com	r24
    75c8:	90 95       	com	r25
    75ca:	8e 0f       	add	r24, r30
    75cc:	9f 1f       	adc	r25, r31
    75ce:	08 95       	ret

000075d0 <memcpy>:
    75d0:	fb 01       	movw	r30, r22
    75d2:	dc 01       	movw	r26, r24
    75d4:	02 c0       	rjmp	.+4      	; 0x75da <memcpy+0xa>
    75d6:	01 90       	ld	r0, Z+
    75d8:	0d 92       	st	X+, r0
    75da:	41 50       	subi	r20, 0x01	; 1
    75dc:	50 40       	sbci	r21, 0x00	; 0
    75de:	d8 f7       	brcc	.-10     	; 0x75d6 <memcpy+0x6>
    75e0:	08 95       	ret

000075e2 <strnlen>:
    75e2:	fc 01       	movw	r30, r24
    75e4:	61 50       	subi	r22, 0x01	; 1
    75e6:	70 40       	sbci	r23, 0x00	; 0
    75e8:	01 90       	ld	r0, Z+
    75ea:	01 10       	cpse	r0, r1
    75ec:	d8 f7       	brcc	.-10     	; 0x75e4 <strnlen+0x2>
    75ee:	80 95       	com	r24
    75f0:	90 95       	com	r25
    75f2:	8e 0f       	add	r24, r30
    75f4:	9f 1f       	adc	r25, r31
    75f6:	08 95       	ret

000075f8 <strrev>:
    75f8:	dc 01       	movw	r26, r24
    75fa:	fc 01       	movw	r30, r24
    75fc:	67 2f       	mov	r22, r23
    75fe:	71 91       	ld	r23, Z+
    7600:	77 23       	and	r23, r23
    7602:	e1 f7       	brne	.-8      	; 0x75fc <strrev+0x4>
    7604:	32 97       	sbiw	r30, 0x02	; 2
    7606:	04 c0       	rjmp	.+8      	; 0x7610 <strrev+0x18>
    7608:	7c 91       	ld	r23, X
    760a:	6d 93       	st	X+, r22
    760c:	70 83       	st	Z, r23
    760e:	62 91       	ld	r22, -Z
    7610:	ae 17       	cp	r26, r30
    7612:	bf 07       	cpc	r27, r31
    7614:	c8 f3       	brcs	.-14     	; 0x7608 <strrev+0x10>
    7616:	08 95       	ret

00007618 <fputc>:
    7618:	0f 93       	push	r16
    761a:	1f 93       	push	r17
    761c:	cf 93       	push	r28
    761e:	df 93       	push	r29
    7620:	8c 01       	movw	r16, r24
    7622:	eb 01       	movw	r28, r22
    7624:	8b 81       	ldd	r24, Y+3	; 0x03
    7626:	81 ff       	sbrs	r24, 1
    7628:	1b c0       	rjmp	.+54     	; 0x7660 <fputc+0x48>
    762a:	82 ff       	sbrs	r24, 2
    762c:	0d c0       	rjmp	.+26     	; 0x7648 <fputc+0x30>
    762e:	2e 81       	ldd	r18, Y+6	; 0x06
    7630:	3f 81       	ldd	r19, Y+7	; 0x07
    7632:	8c 81       	ldd	r24, Y+4	; 0x04
    7634:	9d 81       	ldd	r25, Y+5	; 0x05
    7636:	28 17       	cp	r18, r24
    7638:	39 07       	cpc	r19, r25
    763a:	64 f4       	brge	.+24     	; 0x7654 <fputc+0x3c>
    763c:	e8 81       	ld	r30, Y
    763e:	f9 81       	ldd	r31, Y+1	; 0x01
    7640:	01 93       	st	Z+, r16
    7642:	e8 83       	st	Y, r30
    7644:	f9 83       	std	Y+1, r31	; 0x01
    7646:	06 c0       	rjmp	.+12     	; 0x7654 <fputc+0x3c>
    7648:	e8 85       	ldd	r30, Y+8	; 0x08
    764a:	f9 85       	ldd	r31, Y+9	; 0x09
    764c:	80 2f       	mov	r24, r16
    764e:	19 95       	eicall
    7650:	00 97       	sbiw	r24, 0x00	; 0
    7652:	31 f4       	brne	.+12     	; 0x7660 <fputc+0x48>
    7654:	8e 81       	ldd	r24, Y+6	; 0x06
    7656:	9f 81       	ldd	r25, Y+7	; 0x07
    7658:	01 96       	adiw	r24, 0x01	; 1
    765a:	8e 83       	std	Y+6, r24	; 0x06
    765c:	9f 83       	std	Y+7, r25	; 0x07
    765e:	02 c0       	rjmp	.+4      	; 0x7664 <fputc+0x4c>
    7660:	0f ef       	ldi	r16, 0xFF	; 255
    7662:	1f ef       	ldi	r17, 0xFF	; 255
    7664:	c8 01       	movw	r24, r16
    7666:	df 91       	pop	r29
    7668:	cf 91       	pop	r28
    766a:	1f 91       	pop	r17
    766c:	0f 91       	pop	r16
    766e:	08 95       	ret

00007670 <__ultoa_invert>:
    7670:	fa 01       	movw	r30, r20
    7672:	aa 27       	eor	r26, r26
    7674:	28 30       	cpi	r18, 0x08	; 8
    7676:	51 f1       	breq	.+84     	; 0x76cc <__ultoa_invert+0x5c>
    7678:	20 31       	cpi	r18, 0x10	; 16
    767a:	81 f1       	breq	.+96     	; 0x76dc <__ultoa_invert+0x6c>
    767c:	e8 94       	clt
    767e:	6f 93       	push	r22
    7680:	6e 7f       	andi	r22, 0xFE	; 254
    7682:	6e 5f       	subi	r22, 0xFE	; 254
    7684:	7f 4f       	sbci	r23, 0xFF	; 255
    7686:	8f 4f       	sbci	r24, 0xFF	; 255
    7688:	9f 4f       	sbci	r25, 0xFF	; 255
    768a:	af 4f       	sbci	r26, 0xFF	; 255
    768c:	b1 e0       	ldi	r27, 0x01	; 1
    768e:	3e d0       	rcall	.+124    	; 0x770c <__ultoa_invert+0x9c>
    7690:	b4 e0       	ldi	r27, 0x04	; 4
    7692:	3c d0       	rcall	.+120    	; 0x770c <__ultoa_invert+0x9c>
    7694:	67 0f       	add	r22, r23
    7696:	78 1f       	adc	r23, r24
    7698:	89 1f       	adc	r24, r25
    769a:	9a 1f       	adc	r25, r26
    769c:	a1 1d       	adc	r26, r1
    769e:	68 0f       	add	r22, r24
    76a0:	79 1f       	adc	r23, r25
    76a2:	8a 1f       	adc	r24, r26
    76a4:	91 1d       	adc	r25, r1
    76a6:	a1 1d       	adc	r26, r1
    76a8:	6a 0f       	add	r22, r26
    76aa:	71 1d       	adc	r23, r1
    76ac:	81 1d       	adc	r24, r1
    76ae:	91 1d       	adc	r25, r1
    76b0:	a1 1d       	adc	r26, r1
    76b2:	20 d0       	rcall	.+64     	; 0x76f4 <__ultoa_invert+0x84>
    76b4:	09 f4       	brne	.+2      	; 0x76b8 <__ultoa_invert+0x48>
    76b6:	68 94       	set
    76b8:	3f 91       	pop	r19
    76ba:	2a e0       	ldi	r18, 0x0A	; 10
    76bc:	26 9f       	mul	r18, r22
    76be:	11 24       	eor	r1, r1
    76c0:	30 19       	sub	r19, r0
    76c2:	30 5d       	subi	r19, 0xD0	; 208
    76c4:	31 93       	st	Z+, r19
    76c6:	de f6       	brtc	.-74     	; 0x767e <__ultoa_invert+0xe>
    76c8:	cf 01       	movw	r24, r30
    76ca:	08 95       	ret
    76cc:	46 2f       	mov	r20, r22
    76ce:	47 70       	andi	r20, 0x07	; 7
    76d0:	40 5d       	subi	r20, 0xD0	; 208
    76d2:	41 93       	st	Z+, r20
    76d4:	b3 e0       	ldi	r27, 0x03	; 3
    76d6:	0f d0       	rcall	.+30     	; 0x76f6 <__ultoa_invert+0x86>
    76d8:	c9 f7       	brne	.-14     	; 0x76cc <__ultoa_invert+0x5c>
    76da:	f6 cf       	rjmp	.-20     	; 0x76c8 <__ultoa_invert+0x58>
    76dc:	46 2f       	mov	r20, r22
    76de:	4f 70       	andi	r20, 0x0F	; 15
    76e0:	40 5d       	subi	r20, 0xD0	; 208
    76e2:	4a 33       	cpi	r20, 0x3A	; 58
    76e4:	18 f0       	brcs	.+6      	; 0x76ec <__ultoa_invert+0x7c>
    76e6:	49 5d       	subi	r20, 0xD9	; 217
    76e8:	31 fd       	sbrc	r19, 1
    76ea:	40 52       	subi	r20, 0x20	; 32
    76ec:	41 93       	st	Z+, r20
    76ee:	02 d0       	rcall	.+4      	; 0x76f4 <__ultoa_invert+0x84>
    76f0:	a9 f7       	brne	.-22     	; 0x76dc <__ultoa_invert+0x6c>
    76f2:	ea cf       	rjmp	.-44     	; 0x76c8 <__ultoa_invert+0x58>
    76f4:	b4 e0       	ldi	r27, 0x04	; 4
    76f6:	a6 95       	lsr	r26
    76f8:	97 95       	ror	r25
    76fa:	87 95       	ror	r24
    76fc:	77 95       	ror	r23
    76fe:	67 95       	ror	r22
    7700:	ba 95       	dec	r27
    7702:	c9 f7       	brne	.-14     	; 0x76f6 <__ultoa_invert+0x86>
    7704:	00 97       	sbiw	r24, 0x00	; 0
    7706:	61 05       	cpc	r22, r1
    7708:	71 05       	cpc	r23, r1
    770a:	08 95       	ret
    770c:	9b 01       	movw	r18, r22
    770e:	ac 01       	movw	r20, r24
    7710:	0a 2e       	mov	r0, r26
    7712:	06 94       	lsr	r0
    7714:	57 95       	ror	r21
    7716:	47 95       	ror	r20
    7718:	37 95       	ror	r19
    771a:	27 95       	ror	r18
    771c:	ba 95       	dec	r27
    771e:	c9 f7       	brne	.-14     	; 0x7712 <__ultoa_invert+0xa2>
    7720:	62 0f       	add	r22, r18
    7722:	73 1f       	adc	r23, r19
    7724:	84 1f       	adc	r24, r20
    7726:	95 1f       	adc	r25, r21
    7728:	a0 1d       	adc	r26, r0
    772a:	08 95       	ret

0000772c <_exit>:
    772c:	f8 94       	cli

0000772e <__stop_program>:
    772e:	ff cf       	rjmp	.-2      	; 0x772e <__stop_program>
