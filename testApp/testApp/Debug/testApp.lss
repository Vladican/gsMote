
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000774a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  0000774a  000077de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002faa  0080210e  0080210e  000078ec  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  000078ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a1e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000abb0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c28f  00000000  00000000  0000afd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000272a  00000000  00000000  0001725f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000058a7  00000000  00000000  00019989  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001be4  00000000  00000000  0001f230  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004686  00000000  00000000  00020e14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008271  00000000  00000000  0002549a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fd97  00000000  00000000  0002d70b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001a8  00000000  00000000  001ad4a2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 da 0c 	jmp	0x19b4	; 0x19b4 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 12 12 	jmp	0x2424	; 0x2424 <__vector_16>
      44:	0c 94 ea 11 	jmp	0x23d4	; 0x23d4 <__vector_17>
      48:	0c 94 c2 11 	jmp	0x2384	; 0x2384 <__vector_18>
      4c:	0c 94 7c 11 	jmp	0x22f8	; 0x22f8 <__vector_19>
      50:	0c 94 f7 0a 	jmp	0x15ee	; 0x15ee <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 de 03 	jmp	0x7bc	; 0x7bc <__vector_47>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 c2 1c 	jmp	0x3984	; 0x3984 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 b9 0e 	jmp	0x1d72	; 0x1d72 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 54 11 	jmp	0x22a8	; 0x22a8 <__vector_79>
     140:	0c 94 2c 11 	jmp	0x2258	; 0x2258 <__vector_80>
     144:	0c 94 04 11 	jmp	0x2208	; 0x2208 <__vector_81>
     148:	0c 94 da 10 	jmp	0x21b4	; 0x21b4 <__vector_82>
     14c:	0c 94 fc 07 	jmp	0xff8	; 0xff8 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ea e4       	ldi	r30, 0x4A	; 74
     244:	f7 e7       	ldi	r31, 0x77	; 119
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a8 3b       	cpi	r26, 0xB8	; 184
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 04 03 	call	0x608	; 0x608 <main>
     26a:	0c 94 a3 3b 	jmp	0x7746	; 0x7746 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 2d 3e 	sts	0x3E2D, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 2d 3e 	sts	0x3E2D, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 1f 3e 	lds	r24, 0x3E1F
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 1e 3e 	lds	r24, 0x3E1E
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 2d 3e 	sts	0x3E2D, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	2d e2       	ldi	r18, 0x2D	; 45
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 1e 3e 	lds	r24, 0x3E1E
     376:	90 91 1f 3e 	lds	r25, 0x3E1F
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 1e 3e 	sts	0x3E1E, r16
     382:	10 93 1f 3e 	sts	0x3E1F, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 2d 3e 	sts	0x3E2D, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	ed ea       	ldi	r30, 0xAD	; 173
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 25 04 	call	0x84a	; 0x84a <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 ff 36 	call	0x6dfe	; 0x6dfe <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 6b 36 	call	0x6cd6	; 0x6cd6 <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 06 36 	call	0x6c0c	; 0x6c0c <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 d3 36 	call	0x6da6	; 0x6da6 <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 ff 36 	call	0x6dfe	; 0x6dfe <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 06 36 	call	0x6c0c	; 0x6c0c <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 8d 37 	call	0x6f1a	; 0x6f1a <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <main>:
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

volatile uint8_t TimedOut = 0;

int main(){
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	c6 56       	subi	r28, 0x66	; 102
     612:	d0 40       	sbci	r29, 0x00	; 0
     614:	cd bf       	out	0x3d, r28	; 61
     616:	de bf       	out	0x3e, r29	; 62

	uint32_t length;
	uint16_t dest_addr;
	uint16_t ack = 0;
     618:	19 82       	std	Y+1, r1	; 0x01
     61a:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t  MessageBuffer[100];
	uint16_t NumReceivedMessages, NumMessages, TimeoutCount;
	//set timeout about 2 sec
	uint16_t timeout = 4000;
	
	set_32MHz();
     61c:	0e 94 25 04 	call	0x84a	; 0x84a <set_32MHz>
	
	chb_init();
     620:	0e 94 8d 18 	call	0x311a	; 0x311a <chb_init>
	chb_set_short_addr(0x0000);
     624:	80 e0       	ldi	r24, 0x00	; 0
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	0e 94 b0 1a 	call	0x3560	; 0x3560 <chb_set_short_addr>
	chb_set_channel(1);
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <chb_set_channel>
	StartSerial((uint32_t)57600);
     632:	60 e0       	ldi	r22, 0x00	; 0
     634:	71 ee       	ldi	r23, 0xE1	; 225
     636:	80 e0       	ldi	r24, 0x00	; 0
     638:	90 e0       	ldi	r25, 0x00	; 0
     63a:	0e 94 3c 02 	call	0x478	; 0x478 <StartSerial>

	while(!chb_set_state(CHB_RX_AACK_ON) == RADIO_SUCCESS);
     63e:	86 e1       	ldi	r24, 0x16	; 22
     640:	0e 94 0a 1b 	call	0x3614	; 0x3614 <chb_set_state>
	pcb_t* pcb = chb_get_pcb();
     644:	0e 94 ae 18 	call	0x315c	; 0x315c <chb_get_pcb>
     648:	2c 01       	movw	r4, r24
	
	
	//set the period to 2 seconds
	TCE0.PER = timeout;
     64a:	e0 e0       	ldi	r30, 0x00	; 0
     64c:	fa e0       	ldi	r31, 0x0A	; 10
     64e:	80 ea       	ldi	r24, 0xA0	; 160
     650:	9f e0       	ldi	r25, 0x0F	; 15
     652:	86 a3       	lds	r24, 0x56
     654:	97 a3       	lds	r25, 0x57
	TCE0.CTRLFSET = 0x08;
     656:	88 e0       	ldi	r24, 0x08	; 8
     658:	81 87       	std	Z+9, r24	; 0x09
	//set overflow interrupt
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	86 83       	std	Z+6, r24	; 0x06
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
     65e:	e0 ea       	ldi	r30, 0xA0	; 160
     660:	f0 e0       	ldi	r31, 0x00	; 0
     662:	82 81       	ldd	r24, Z+2	; 0x02
     664:	81 60       	ori	r24, 0x01	; 1
     666:	82 83       	std	Z+2, r24	; 0x02
	sei();
     668:	78 94       	sei
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     66a:	0f 2e       	mov	r0, r31
     66c:	f0 ea       	ldi	r31, 0xA0	; 160
     66e:	6f 2e       	mov	r6, r31
     670:	f8 e0       	ldi	r31, 0x08	; 8
     672:	7f 2e       	mov	r7, r31
     674:	f0 2d       	mov	r31, r0
			}				
			//process/send the bytes over radio
			chb_write(dest_addr,MessageBuffer+2,length-2);
		}
		
		TCE0.CTRLA = 0x07;
     676:	0f 2e       	mov	r0, r31
     678:	22 24       	eor	r2, r2
     67a:	fa e0       	ldi	r31, 0x0A	; 10
     67c:	3f 2e       	mov	r3, r31
     67e:	f0 2d       	mov	r31, r0
	sei();
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     680:	f3 01       	movw	r30, r6
     682:	81 81       	ldd	r24, Z+1	; 0x01
     684:	88 23       	and	r24, r24
     686:	e4 f7       	brge	.-8      	; 0x680 <main+0x78>
		length = SerialReadByte();
     688:	0e 94 c3 02 	call	0x586	; 0x586 <SerialReadByte>
     68c:	88 2e       	mov	r8, r24
     68e:	99 24       	eor	r9, r9
     690:	aa 24       	eor	r10, r10
     692:	bb 24       	eor	r11, r11
		for(uint32_t i = 0; i<length; i++){
     694:	81 14       	cp	r8, r1
     696:	91 04       	cpc	r9, r1
     698:	a1 04       	cpc	r10, r1
     69a:	b1 04       	cpc	r11, r1
     69c:	09 f4       	brne	.+2      	; 0x6a0 <main+0x98>
     69e:	8b c0       	rjmp	.+278    	; 0x7b6 <main+0x1ae>
     6a0:	8e 01       	movw	r16, r28
     6a2:	0d 5f       	subi	r16, 0xFD	; 253
     6a4:	1f 4f       	sbci	r17, 0xFF	; 255
     6a6:	cc 24       	eor	r12, r12
     6a8:	dd 24       	eor	r13, r13
     6aa:	76 01       	movw	r14, r12
			MessageBuffer[i] = SerialReadByte();
     6ac:	0e 94 c3 02 	call	0x586	; 0x586 <SerialReadByte>
     6b0:	f8 01       	movw	r30, r16
     6b2:	81 93       	st	Z+, r24
     6b4:	8f 01       	movw	r16, r30
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
		length = SerialReadByte();
		for(uint32_t i = 0; i<length; i++){
     6b6:	08 94       	sec
     6b8:	c1 1c       	adc	r12, r1
     6ba:	d1 1c       	adc	r13, r1
     6bc:	e1 1c       	adc	r14, r1
     6be:	f1 1c       	adc	r15, r1
     6c0:	8c 14       	cp	r8, r12
     6c2:	9d 04       	cpc	r9, r13
     6c4:	ae 04       	cpc	r10, r14
     6c6:	bf 04       	cpc	r11, r15
     6c8:	89 f7       	brne	.-30     	; 0x6ac <main+0xa4>
			MessageBuffer[i] = SerialReadByte();
		}
		dest_addr = ((uint16_t*)MessageBuffer)[0];
     6ca:	0b 81       	ldd	r16, Y+3	; 0x03
     6cc:	1c 81       	ldd	r17, Y+4	; 0x04
			
		
		if(length > 2){
     6ce:	f3 e0       	ldi	r31, 0x03	; 3
     6d0:	8f 16       	cp	r8, r31
     6d2:	91 04       	cpc	r9, r1
     6d4:	a1 04       	cpc	r10, r1
     6d6:	b1 04       	cpc	r11, r1
     6d8:	a0 f0       	brcs	.+40     	; 0x702 <main+0xfa>
			//clear out message buffer in case any stray message was received
			if(pcb->data_rcv){ 
     6da:	f2 01       	movw	r30, r4
     6dc:	83 81       	ldd	r24, Z+3	; 0x03
     6de:	88 23       	and	r24, r24
     6e0:	21 f0       	breq	.+8      	; 0x6ea <main+0xe2>
				chb_read((chb_rx_data_t*)FRAMReadBuffer);
     6e2:	8d ea       	ldi	r24, 0xAD	; 173
     6e4:	91 e2       	ldi	r25, 0x21	; 33
     6e6:	0e 94 51 19 	call	0x32a2	; 0x32a2 <chb_read>
			}				
			//process/send the bytes over radio
			chb_write(dest_addr,MessageBuffer+2,length-2);
     6ea:	a5 01       	movw	r20, r10
     6ec:	94 01       	movw	r18, r8
     6ee:	22 50       	subi	r18, 0x02	; 2
     6f0:	30 40       	sbci	r19, 0x00	; 0
     6f2:	40 40       	sbci	r20, 0x00	; 0
     6f4:	50 40       	sbci	r21, 0x00	; 0
     6f6:	c8 01       	movw	r24, r16
     6f8:	be 01       	movw	r22, r28
     6fa:	6b 5f       	subi	r22, 0xFB	; 251
     6fc:	7f 4f       	sbci	r23, 0xFF	; 255
     6fe:	0e 94 b1 18 	call	0x3162	; 0x3162 <chb_write>
		}
		
		TCE0.CTRLA = 0x07;
     702:	87 e0       	ldi	r24, 0x07	; 7
     704:	f1 01       	movw	r30, r2
     706:	80 83       	st	Z, r24
		TimedOut = 0;
     708:	10 92 0e 21 	sts	0x210E, r1
		//set prescalar of 1024... each timer tick is 512 micro seconds
		//TCE0.CTRLA = 0x07;
		//wait for response/data over radio
		while(!pcb->data_rcv){
     70c:	04 c0       	rjmp	.+8      	; 0x716 <main+0x10e>
			//no response detected so go back to waiting for next serial command
			if(TimedOut) break;
     70e:	80 91 0e 21 	lds	r24, 0x210E
     712:	88 23       	and	r24, r24
     714:	21 f4       	brne	.+8      	; 0x71e <main+0x116>
		TCE0.CTRLA = 0x07;
		TimedOut = 0;
		//set prescalar of 1024... each timer tick is 512 micro seconds
		//TCE0.CTRLA = 0x07;
		//wait for response/data over radio
		while(!pcb->data_rcv){
     716:	f2 01       	movw	r30, r4
     718:	83 81       	ldd	r24, Z+3	; 0x03
     71a:	88 23       	and	r24, r24
     71c:	c1 f3       	breq	.-16     	; 0x70e <main+0x106>
			//no response detected so go back to waiting for next serial command
			if(TimedOut) break;
			//if(TCF0.CNT - TimeoutCount >= timeout) break;
		}
 		if(TimedOut) {
     71e:	80 91 0e 21 	lds	r24, 0x210E
     722:	88 23       	and	r24, r24
     724:	29 f0       	breq	.+10     	; 0x730 <main+0x128>
			TCE0.CTRLA = 0x00;
     726:	f1 01       	movw	r30, r2
     728:	10 82       	st	Z, r1
			TCE0.CTRLFSET = 0x08;
     72a:	88 e0       	ldi	r24, 0x08	; 8
     72c:	81 87       	std	Z+9, r24	; 0x09
 			continue;
     72e:	a8 cf       	rjmp	.-176    	; 0x680 <main+0x78>
 		}			
		//if(TCF0.CNT - TimeoutCount >= timeout) continue;
		//read the data. expecting a 1 byte message containing number of messages that follow
		length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
     730:	8d ea       	ldi	r24, 0xAD	; 173
     732:	91 e2       	ldi	r25, 0x21	; 33
     734:	0e 94 51 19 	call	0x32a2	; 0x32a2 <chb_read>
		if (length == 2){
     738:	82 30       	cpi	r24, 0x02	; 2
     73a:	09 f0       	breq	.+2      	; 0x73e <main+0x136>
     73c:	a1 cf       	rjmp	.-190    	; 0x680 <main+0x78>
			length = 0;
			NumReceivedMessages = 0;
			//get the number of messages (2 bytes)
			NumMessages = ((uint16_t*)FRAMReadBuffer)[0];
     73e:	ed ea       	ldi	r30, 0xAD	; 173
     740:	f1 e2       	ldi	r31, 0x21	; 33
     742:	80 80       	ld	r8, Z
     744:	91 80       	ldd	r9, Z+1	; 0x01
			//start timeout clock
			//TimeoutCount = TCF0.CNT;
			//reset timer count
			//TCE0.CTRLA = 0x00;
			TCE0.CTRLFSET = 0x08;
     746:	88 e0       	ldi	r24, 0x08	; 8
     748:	f1 01       	movw	r30, r2
     74a:	81 87       	std	Z+9, r24	; 0x09
			//clear timeout flag
			TimedOut = 0;
     74c:	10 92 0e 21 	sts	0x210E, r1
			//TCE0.CTRLA = 0x07;
			while(NumReceivedMessages <NumMessages){
     750:	81 14       	cp	r8, r1
     752:	91 04       	cpc	r9, r1
     754:	59 f1       	breq	.+86     	; 0x7ac <main+0x1a4>
		//if(TCF0.CNT - TimeoutCount >= timeout) continue;
		//read the data. expecting a 1 byte message containing number of messages that follow
		length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
		if (length == 2){
			length = 0;
			NumReceivedMessages = 0;
     756:	cc 24       	eor	r12, r12
     758:	dd 24       	eor	r13, r13
			//clear timeout flag
			TimedOut = 0;
			//TCE0.CTRLA = 0x07;
			while(NumReceivedMessages <NumMessages){
				//wait for all messages to come in
				if(pcb->data_rcv){
     75a:	f2 01       	movw	r30, r4
     75c:	83 81       	ldd	r24, Z+3	; 0x03
     75e:	88 23       	and	r24, r24
     760:	f1 f0       	breq	.+60     	; 0x79e <main+0x196>
					length = chb_read((chb_rx_data_t*)(FRAMReadBuffer));
     762:	8d ea       	ldi	r24, 0xAD	; 173
     764:	91 e2       	ldi	r25, 0x21	; 33
     766:	0e 94 51 19 	call	0x32a2	; 0x32a2 <chb_read>
     76a:	48 2f       	mov	r20, r24
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	60 e0       	ldi	r22, 0x00	; 0
     770:	70 e0       	ldi	r23, 0x00	; 0
					//pass the data to USB
					SerialWriteBuffer(FRAMReadBuffer,length);
     772:	8d ea       	ldi	r24, 0xAD	; 173
     774:	91 e2       	ldi	r25, 0x21	; 33
     776:	0e 94 cb 02 	call	0x596	; 0x596 <SerialWriteBuffer>
					NumReceivedMessages++;
     77a:	08 94       	sec
     77c:	c1 1c       	adc	r12, r1
     77e:	d1 1c       	adc	r13, r1
					//reset timeout count
					//TimeoutCount = TCF0.CNT;
					//reset timer count
					//TCE0.CTRLA = 0x00;
					//send acknowledgment
					chb_write(dest_addr,&ack,2);
     780:	c8 01       	movw	r24, r16
     782:	be 01       	movw	r22, r28
     784:	6f 5f       	subi	r22, 0xFF	; 255
     786:	7f 4f       	sbci	r23, 0xFF	; 255
     788:	22 e0       	ldi	r18, 0x02	; 2
     78a:	30 e0       	ldi	r19, 0x00	; 0
     78c:	40 e0       	ldi	r20, 0x00	; 0
     78e:	50 e0       	ldi	r21, 0x00	; 0
     790:	0e 94 b1 18 	call	0x3162	; 0x3162 <chb_write>
					TCE0.CTRLFSET = 0x08;
     794:	88 e0       	ldi	r24, 0x08	; 8
     796:	f1 01       	movw	r30, r2
     798:	81 87       	std	Z+9, r24	; 0x09
					//clear timeout flag
					TimedOut = 0;
     79a:	10 92 0e 21 	sts	0x210E, r1
					//TCE0.CTRLA = 0x07;
				}
				//if(TCF0.CNT - TimeoutCount >= timeout) break;
				if(TimedOut) break;		
     79e:	80 91 0e 21 	lds	r24, 0x210E
     7a2:	88 23       	and	r24, r24
     7a4:	19 f4       	brne	.+6      	; 0x7ac <main+0x1a4>
			//TCE0.CTRLA = 0x00;
			TCE0.CTRLFSET = 0x08;
			//clear timeout flag
			TimedOut = 0;
			//TCE0.CTRLA = 0x07;
			while(NumReceivedMessages <NumMessages){
     7a6:	c8 14       	cp	r12, r8
     7a8:	d9 04       	cpc	r13, r9
     7aa:	b8 f2       	brcs	.-82     	; 0x75a <main+0x152>
				//if(TCF0.CNT - TimeoutCount >= timeout) break;
				if(TimedOut) break;		
			}
			//SerialWriteBuffer(FRAMReadBuffer,length);
			//check if timed out
			TCE0.CTRLA = 0x00;
     7ac:	f1 01       	movw	r30, r2
     7ae:	10 82       	st	Z, r1
			TCE0.CTRLFSET = 0x08;
     7b0:	88 e0       	ldi	r24, 0x08	; 8
     7b2:	81 87       	std	Z+9, r24	; 0x09
	sei();
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     7b4:	65 cf       	rjmp	.-310    	; 0x680 <main+0x78>
		length = SerialReadByte();
		for(uint32_t i = 0; i<length; i++){
			MessageBuffer[i] = SerialReadByte();
		}
		dest_addr = ((uint16_t*)MessageBuffer)[0];
     7b6:	0b 81       	ldd	r16, Y+3	; 0x03
     7b8:	1c 81       	ldd	r17, Y+4	; 0x04
     7ba:	a3 cf       	rjmp	.-186    	; 0x702 <main+0xfa>

000007bc <__vector_47>:
			TCE0.CTRLFSET = 0x08;
		}	
	}
}

ISR(TCE0_OVF_vect){
     7bc:	1f 92       	push	r1
     7be:	0f 92       	push	r0
     7c0:	0f b6       	in	r0, 0x3f	; 63
     7c2:	0f 92       	push	r0
     7c4:	11 24       	eor	r1, r1
     7c6:	8f 93       	push	r24
	//reset timer count
	//TCE0.CTRLA = 0x00;
	//TCE0.CTRLFSET = 0x0C;
	//set timeout flag
	TimedOut = 1;
     7c8:	81 e0       	ldi	r24, 0x01	; 1
     7ca:	80 93 0e 21 	sts	0x210E, r24
     7ce:	8f 91       	pop	r24
     7d0:	0f 90       	pop	r0
     7d2:	0f be       	out	0x3f, r0	; 63
     7d4:	0f 90       	pop	r0
     7d6:	1f 90       	pop	r1
     7d8:	18 95       	reti

000007da <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     7da:	10 92 33 3e 	sts	0x3E33, r1
}
     7de:	08 95       	ret

000007e0 <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     7e0:	80 ec       	ldi	r24, 0xC0	; 192
     7e2:	60 e0       	ldi	r22, 0x00	; 0
     7e4:	4b e0       	ldi	r20, 0x0B	; 11
     7e6:	0e 94 a3 1e 	call	0x3d46	; 0x3d46 <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     7ea:	e0 e5       	ldi	r30, 0x50	; 80
     7ec:	f0 e0       	ldi	r31, 0x00	; 0
     7ee:	80 81       	ld	r24, Z
     7f0:	88 60       	ori	r24, 0x08	; 8
     7f2:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     7f4:	81 81       	ldd	r24, Z+1	; 0x01
     7f6:	83 ff       	sbrs	r24, 3
     7f8:	fd cf       	rjmp	.-6      	; 0x7f4 <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     7fa:	80 ec       	ldi	r24, 0xC0	; 192
     7fc:	62 e0       	ldi	r22, 0x02	; 2
     7fe:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     802:	e0 e5       	ldi	r30, 0x50	; 80
     804:	f0 e0       	ldi	r31, 0x00	; 0
     806:	80 81       	ld	r24, Z
     808:	80 61       	ori	r24, 0x10	; 16
     80a:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     80c:	81 81       	ldd	r24, Z+1	; 0x01
     80e:	84 ff       	sbrs	r24, 4
     810:	fd cf       	rjmp	.-6      	; 0x80c <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     812:	84 e0       	ldi	r24, 0x04	; 4
     814:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <CLKSYS_Disable>
}
     81e:	08 95       	ret

00000820 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     820:	e0 e5       	ldi	r30, 0x50	; 80
     822:	f0 e0       	ldi	r31, 0x00	; 0
     824:	80 81       	ld	r24, Z
     826:	82 60       	ori	r24, 0x02	; 2
     828:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     82a:	80 e0       	ldi	r24, 0x00	; 0
     82c:	61 e0       	ldi	r22, 0x01	; 1
     82e:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     832:	e0 e5       	ldi	r30, 0x50	; 80
     834:	f0 e0       	ldi	r31, 0x00	; 0
     836:	81 81       	ldd	r24, Z+1	; 0x01
     838:	81 ff       	sbrs	r24, 1
     83a:	fd cf       	rjmp	.-6      	; 0x836 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     842:	81 e0       	ldi	r24, 0x01	; 1
     844:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <CLKSYS_Disable>
	
}
     848:	08 95       	ret

0000084a <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     84a:	e0 e5       	ldi	r30, 0x50	; 80
     84c:	f0 e0       	ldi	r31, 0x00	; 0
     84e:	80 81       	ld	r24, Z
     850:	82 60       	ori	r24, 0x02	; 2
     852:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	60 e0       	ldi	r22, 0x00	; 0
     858:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     85c:	e0 e5       	ldi	r30, 0x50	; 80
     85e:	f0 e0       	ldi	r31, 0x00	; 0
     860:	81 81       	ldd	r24, Z+1	; 0x01
     862:	81 ff       	sbrs	r24, 1
     864:	fd cf       	rjmp	.-6      	; 0x860 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     86c:	81 e0       	ldi	r24, 0x01	; 1
     86e:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <CLKSYS_Disable>
	
}
     872:	08 95       	ret

00000874 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     874:	88 23       	and	r24, r24
     876:	29 f0       	breq	.+10     	; 0x882 <portExCS+0xe>
     878:	88 e0       	ldi	r24, 0x08	; 8
     87a:	e0 e0       	ldi	r30, 0x00	; 0
     87c:	f6 e0       	ldi	r31, 0x06	; 6
     87e:	86 83       	std	Z+6, r24	; 0x06
     880:	04 c0       	rjmp	.+8      	; 0x88a <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     882:	88 e0       	ldi	r24, 0x08	; 8
     884:	e0 e0       	ldi	r30, 0x00	; 0
     886:	f6 e0       	ldi	r31, 0x06	; 6
     888:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     88a:	8a e6       	ldi	r24, 0x6A	; 106
     88c:	8a 95       	dec	r24
     88e:	f1 f7       	brne	.-4      	; 0x88c <portExCS+0x18>
     890:	00 c0       	rjmp	.+0      	; 0x892 <portExCS+0x1e>
	}
	_delay_us(10);
}
     892:	08 95       	ret

00000894 <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     894:	88 23       	and	r24, r24
     896:	79 f0       	breq	.+30     	; 0x8b6 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     898:	e0 ea       	ldi	r30, 0xA0	; 160
     89a:	f6 e0       	ldi	r31, 0x06	; 6
     89c:	80 e2       	ldi	r24, 0x20	; 32
     89e:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     8a0:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     8a2:	8f ef       	ldi	r24, 0xFF	; 255
     8a4:	93 ec       	ldi	r25, 0xC3	; 195
     8a6:	a9 e0       	ldi	r26, 0x09	; 9
     8a8:	81 50       	subi	r24, 0x01	; 1
     8aa:	90 40       	sbci	r25, 0x00	; 0
     8ac:	a0 40       	sbci	r26, 0x00	; 0
     8ae:	e1 f7       	brne	.-8      	; 0x8a8 <Ext1Power+0x14>
     8b0:	00 c0       	rjmp	.+0      	; 0x8b2 <Ext1Power+0x1e>
     8b2:	00 00       	nop
     8b4:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     8b6:	e0 ea       	ldi	r30, 0xA0	; 160
     8b8:	f6 e0       	ldi	r31, 0x06	; 6
     8ba:	80 e2       	ldi	r24, 0x20	; 32
     8bc:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     8be:	82 83       	std	Z+2, r24	; 0x02
     8c0:	08 95       	ret

000008c2 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     8c2:	88 23       	and	r24, r24
     8c4:	79 f0       	breq	.+30     	; 0x8e4 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     8c6:	e0 ea       	ldi	r30, 0xA0	; 160
     8c8:	f6 e0       	ldi	r31, 0x06	; 6
     8ca:	80 e4       	ldi	r24, 0x40	; 64
     8cc:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     8ce:	85 83       	std	Z+5, r24	; 0x05
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	93 ec       	ldi	r25, 0xC3	; 195
     8d4:	a9 e0       	ldi	r26, 0x09	; 9
     8d6:	81 50       	subi	r24, 0x01	; 1
     8d8:	90 40       	sbci	r25, 0x00	; 0
     8da:	a0 40       	sbci	r26, 0x00	; 0
     8dc:	e1 f7       	brne	.-8      	; 0x8d6 <Ext2Power+0x14>
     8de:	00 c0       	rjmp	.+0      	; 0x8e0 <Ext2Power+0x1e>
     8e0:	00 00       	nop
     8e2:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     8e4:	e0 ea       	ldi	r30, 0xA0	; 160
     8e6:	f6 e0       	ldi	r31, 0x06	; 6
     8e8:	80 e4       	ldi	r24, 0x40	; 64
     8ea:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     8ec:	82 83       	std	Z+2, r24	; 0x02
     8ee:	08 95       	ret

000008f0 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     8f0:	88 23       	and	r24, r24
     8f2:	79 f0       	breq	.+30     	; 0x912 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     8f4:	e0 ea       	ldi	r30, 0xA0	; 160
     8f6:	f6 e0       	ldi	r31, 0x06	; 6
     8f8:	80 e8       	ldi	r24, 0x80	; 128
     8fa:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     8fc:	85 83       	std	Z+5, r24	; 0x05
     8fe:	8f ef       	ldi	r24, 0xFF	; 255
     900:	93 ec       	ldi	r25, 0xC3	; 195
     902:	a9 e0       	ldi	r26, 0x09	; 9
     904:	81 50       	subi	r24, 0x01	; 1
     906:	90 40       	sbci	r25, 0x00	; 0
     908:	a0 40       	sbci	r26, 0x00	; 0
     90a:	e1 f7       	brne	.-8      	; 0x904 <HVPower+0x14>
     90c:	00 c0       	rjmp	.+0      	; 0x90e <HVPower+0x1e>
     90e:	00 00       	nop
     910:	05 c0       	rjmp	.+10     	; 0x91c <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     912:	e0 ea       	ldi	r30, 0xA0	; 160
     914:	f6 e0       	ldi	r31, 0x06	; 6
     916:	80 e8       	ldi	r24, 0x80	; 128
     918:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     91a:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     91c:	af e3       	ldi	r26, 0x3F	; 63
     91e:	bf e1       	ldi	r27, 0x1F	; 31
     920:	11 97       	sbiw	r26, 0x01	; 1
     922:	f1 f7       	brne	.-4      	; 0x920 <HVPower+0x30>
     924:	00 c0       	rjmp	.+0      	; 0x926 <HVPower+0x36>
     926:	00 00       	nop
	}
	_delay_us(1000);
}
     928:	08 95       	ret

0000092a <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     92a:	88 23       	and	r24, r24
     92c:	29 f0       	breq	.+10     	; 0x938 <lowerMuxCS+0xe>
     92e:	80 e1       	ldi	r24, 0x10	; 16
     930:	e0 e8       	ldi	r30, 0x80	; 128
     932:	f6 e0       	ldi	r31, 0x06	; 6
     934:	86 83       	std	Z+6, r24	; 0x06
     936:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     938:	80 e1       	ldi	r24, 0x10	; 16
     93a:	e0 e8       	ldi	r30, 0x80	; 128
     93c:	f6 e0       	ldi	r31, 0x06	; 6
     93e:	85 83       	std	Z+5, r24	; 0x05
     940:	08 95       	ret

00000942 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     942:	88 23       	and	r24, r24
     944:	29 f0       	breq	.+10     	; 0x950 <upperMuxCS+0xe>
     946:	82 e0       	ldi	r24, 0x02	; 2
     948:	e0 e4       	ldi	r30, 0x40	; 64
     94a:	f6 e0       	ldi	r31, 0x06	; 6
     94c:	86 83       	std	Z+6, r24	; 0x06
     94e:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     950:	82 e0       	ldi	r24, 0x02	; 2
     952:	e0 e4       	ldi	r30, 0x40	; 64
     954:	f6 e0       	ldi	r31, 0x06	; 6
     956:	85 83       	std	Z+5, r24	; 0x05
     958:	08 95       	ret

0000095a <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     95a:	e0 e4       	ldi	r30, 0x40	; 64
     95c:	f6 e0       	ldi	r31, 0x06	; 6
     95e:	90 e1       	ldi	r25, 0x10	; 16
     960:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     962:	28 e3       	ldi	r18, 0x38	; 56
     964:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     966:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     968:	81 65       	ori	r24, 0x51	; 81
     96a:	a0 ec       	ldi	r26, 0xC0	; 192
     96c:	b8 e0       	ldi	r27, 0x08	; 8
     96e:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     970:	11 96       	adiw	r26, 0x01	; 1
     972:	1c 92       	st	X, r1
     974:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     976:	80 ea       	ldi	r24, 0xA0	; 160
     978:	81 83       	std	Z+1, r24	; 0x01

	
}
     97a:	08 95       	ret

0000097c <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     97c:	e0 e4       	ldi	r30, 0x40	; 64
     97e:	f6 e0       	ldi	r31, 0x06	; 6
     980:	90 e1       	ldi	r25, 0x10	; 16
     982:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     984:	28 e3       	ldi	r18, 0x38	; 56
     986:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     988:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     98a:	80 65       	ori	r24, 0x50	; 80
     98c:	68 2b       	or	r22, r24
     98e:	a0 ec       	ldi	r26, 0xC0	; 192
     990:	b8 e0       	ldi	r27, 0x08	; 8
     992:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     994:	11 96       	adiw	r26, 0x01	; 1
     996:	1c 92       	st	X, r1
     998:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     99a:	80 ea       	ldi	r24, 0xA0	; 160
     99c:	81 83       	std	Z+1, r24	; 0x01
}
     99e:	08 95       	ret

000009a0 <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     9a0:	88 23       	and	r24, r24
     9a2:	29 f0       	breq	.+10     	; 0x9ae <SPICS+0xe>
     9a4:	80 e1       	ldi	r24, 0x10	; 16
     9a6:	e0 e4       	ldi	r30, 0x40	; 64
     9a8:	f6 e0       	ldi	r31, 0x06	; 6
     9aa:	86 83       	std	Z+6, r24	; 0x06
     9ac:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     9ae:	80 e1       	ldi	r24, 0x10	; 16
     9b0:	e0 e4       	ldi	r30, 0x40	; 64
     9b2:	f6 e0       	ldi	r31, 0x06	; 6
     9b4:	85 83       	std	Z+5, r24	; 0x05
     9b6:	08 95       	ret

000009b8 <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     9b8:	e0 e4       	ldi	r30, 0x40	; 64
     9ba:	f6 e0       	ldi	r31, 0x06	; 6
     9bc:	80 e1       	ldi	r24, 0x10	; 16
     9be:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     9c0:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     9c4:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     9c6:	80 eb       	ldi	r24, 0xB0	; 176
     9c8:	82 83       	std	Z+2, r24	; 0x02

}
     9ca:	08 95       	ret

000009cc <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     9d0:	c8 2f       	mov	r28, r24
     9d2:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     9d4:	d8 2f       	mov	r29, r24
     9d6:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     9d8:	28 2f       	mov	r18, r24
     9da:	30 e0       	ldi	r19, 0x00	; 0
     9dc:	a9 01       	movw	r20, r18
     9de:	45 70       	andi	r20, 0x05	; 5
     9e0:	50 70       	andi	r21, 0x00	; 0
     9e2:	41 15       	cp	r20, r1
     9e4:	51 05       	cpc	r21, r1
     9e6:	49 f0       	breq	.+18     	; 0x9fa <set_filter+0x2e>
     9e8:	90 91 31 3e 	lds	r25, 0x3E31
     9ec:	48 2f       	mov	r20, r24
     9ee:	42 95       	swap	r20
     9f0:	4f 70       	andi	r20, 0x0F	; 15
     9f2:	90 7f       	andi	r25, 0xF0	; 240
     9f4:	94 2b       	or	r25, r20
     9f6:	90 93 31 3e 	sts	0x3E31, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     9fa:	2a 70       	andi	r18, 0x0A	; 10
     9fc:	30 70       	andi	r19, 0x00	; 0
     9fe:	21 15       	cp	r18, r1
     a00:	31 05       	cpc	r19, r1
     a02:	39 f0       	breq	.+14     	; 0xa12 <set_filter+0x46>
     a04:	90 91 31 3e 	lds	r25, 0x3E31
     a08:	80 7f       	andi	r24, 0xF0	; 240
     a0a:	9f 70       	andi	r25, 0x0F	; 15
     a0c:	89 2b       	or	r24, r25
     a0e:	80 93 31 3e 	sts	0x3E31, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     a12:	84 e0       	ldi	r24, 0x04	; 4
     a14:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     a18:	80 91 31 3e 	lds	r24, 0x3E31
     a1c:	80 93 21 3e 	sts	0x3E21, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     a20:	cc 23       	and	r28, r28
     a22:	19 f0       	breq	.+6      	; 0xa2a <set_filter+0x5e>
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	0e 94 95 04 	call	0x92a	; 0x92a <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     a2a:	dd 23       	and	r29, r29
     a2c:	19 f0       	breq	.+6      	; 0xa34 <set_filter+0x68>
     a2e:	81 e0       	ldi	r24, 0x01	; 1
     a30:	0e 94 a1 04 	call	0x942	; 0x942 <upperMuxCS>

	SPICS(TRUE);
     a34:	81 e0       	ldi	r24, 0x01	; 1
     a36:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     a3a:	8f ef       	ldi	r24, 0xFF	; 255
     a3c:	e0 ec       	ldi	r30, 0xC0	; 192
     a3e:	f8 e0       	ldi	r31, 0x08	; 8
     a40:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     a42:	82 81       	ldd	r24, Z+2	; 0x02
     a44:	88 23       	and	r24, r24
     a46:	ec f7       	brge	.-6      	; 0xa42 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     a48:	e0 ec       	ldi	r30, 0xC0	; 192
     a4a:	f8 e0       	ldi	r31, 0x08	; 8
     a4c:	83 81       	ldd	r24, Z+3	; 0x03
     a4e:	80 93 2d 3e 	sts	0x3E2D, r24

	nop();
     a52:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     a54:	ad e2       	ldi	r26, 0x2D	; 45
     a56:	be e3       	ldi	r27, 0x3E	; 62
     a58:	1c 97       	sbiw	r26, 0x0c	; 12
     a5a:	8c 91       	ld	r24, X
     a5c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     a5e:	82 81       	ldd	r24, Z+2	; 0x02
     a60:	88 23       	and	r24, r24
     a62:	ec f7       	brge	.-6      	; 0xa5e <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     a64:	e0 ec       	ldi	r30, 0xC0	; 192
     a66:	f8 e0       	ldi	r31, 0x08	; 8
     a68:	83 81       	ldd	r24, Z+3	; 0x03
     a6a:	80 93 2d 3e 	sts	0x3E2D, r24
	SPICS(FALSE);
     a6e:	80 e0       	ldi	r24, 0x00	; 0
     a70:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     a74:	cc 23       	and	r28, r28
     a76:	19 f0       	breq	.+6      	; 0xa7e <set_filter+0xb2>
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	0e 94 95 04 	call	0x92a	; 0x92a <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     a7e:	dd 23       	and	r29, r29
     a80:	19 f0       	breq	.+6      	; 0xa88 <set_filter+0xbc>
     a82:	80 e0       	ldi	r24, 0x00	; 0
     a84:	0e 94 a1 04 	call	0x942	; 0x942 <upperMuxCS>
	SPIDisable();
     a88:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
}
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	08 95       	ret

00000a92 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     a92:	cf 93       	push	r28
     a94:	df 93       	push	r29
     a96:	c8 2f       	mov	r28, r24
     a98:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	portExCS(TRUE);
     aa6:	81 e0       	ldi	r24, 0x01	; 1
     aa8:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     aac:	dd 23       	and	r29, r29
     aae:	89 f0       	breq	.+34     	; 0xad2 <PortEx_OUTCLR+0x40>
     ab0:	80 91 ac 21 	lds	r24, 0x21AC
     ab4:	c0 95       	com	r28
     ab6:	c8 23       	and	r28, r24
     ab8:	c0 93 ac 21 	sts	0x21AC, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     abc:	80 e4       	ldi	r24, 0x40	; 64
     abe:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     ac2:	84 e1       	ldi	r24, 0x14	; 20
     ac4:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankA_OUT;
     ac8:	80 91 ac 21 	lds	r24, 0x21AC
     acc:	80 93 23 3e 	sts	0x3E23, r24
     ad0:	10 c0       	rjmp	.+32     	; 0xaf2 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     ad2:	80 91 32 3e 	lds	r24, 0x3E32
     ad6:	c0 95       	com	r28
     ad8:	c8 23       	and	r28, r24
     ada:	c0 93 32 3e 	sts	0x3E32, r28
	
	SPIBuffer[0] = PS_WRITE;
     ade:	80 e4       	ldi	r24, 0x40	; 64
     ae0:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     ae4:	85 e1       	ldi	r24, 0x15	; 21
     ae6:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankB_OUT; 
     aea:	80 91 32 3e 	lds	r24, 0x3E32
     aee:	80 93 23 3e 	sts	0x3E23, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     af2:	80 e0       	ldi	r24, 0x00	; 0
     af4:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     af6:	21 e2       	ldi	r18, 0x21	; 33
     af8:	3e e3       	ldi	r19, 0x3E	; 62
     afa:	a0 ec       	ldi	r26, 0xC0	; 192
     afc:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     afe:	cd e2       	ldi	r28, 0x2D	; 45
     b00:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b02:	f9 01       	movw	r30, r18
     b04:	e8 0f       	add	r30, r24
     b06:	f9 1f       	adc	r31, r25
     b08:	40 81       	ld	r20, Z
     b0a:	13 96       	adiw	r26, 0x03	; 3
     b0c:	4c 93       	st	X, r20
     b0e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     b10:	12 96       	adiw	r26, 0x02	; 2
     b12:	4c 91       	ld	r20, X
     b14:	12 97       	sbiw	r26, 0x02	; 2
     b16:	44 23       	and	r20, r20
     b18:	dc f7       	brge	.-10     	; 0xb10 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     b1a:	13 96       	adiw	r26, 0x03	; 3
     b1c:	4c 91       	ld	r20, X
     b1e:	13 97       	sbiw	r26, 0x03	; 3
     b20:	48 83       	st	Y, r20
     b22:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     b24:	83 30       	cpi	r24, 0x03	; 3
     b26:	91 05       	cpc	r25, r1
     b28:	61 f7       	brne	.-40     	; 0xb02 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     b2a:	80 e0       	ldi	r24, 0x00	; 0
     b2c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	portExCS(FALSE);
     b30:	80 e0       	ldi	r24, 0x00	; 0
     b32:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>
	SPIDisable();
     b36:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
}
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret

00000b40 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     b40:	cf 93       	push	r28
     b42:	df 93       	push	r29
     b44:	c8 2f       	mov	r28, r24
     b46:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	portExCS(TRUE);
     b54:	81 e0       	ldi	r24, 0x01	; 1
     b56:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     b5a:	dd 23       	and	r29, r29
     b5c:	81 f0       	breq	.+32     	; 0xb7e <PortEx_OUTSET+0x3e>
     b5e:	80 91 ac 21 	lds	r24, 0x21AC
     b62:	c8 2b       	or	r28, r24
     b64:	c0 93 ac 21 	sts	0x21AC, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     b68:	80 e4       	ldi	r24, 0x40	; 64
     b6a:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     b6e:	84 e1       	ldi	r24, 0x14	; 20
     b70:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankA_OUT;
     b74:	80 91 ac 21 	lds	r24, 0x21AC
     b78:	80 93 23 3e 	sts	0x3E23, r24
     b7c:	0f c0       	rjmp	.+30     	; 0xb9c <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     b7e:	80 91 32 3e 	lds	r24, 0x3E32
     b82:	c8 2b       	or	r28, r24
     b84:	c0 93 32 3e 	sts	0x3E32, r28
	
	SPIBuffer[0] = PS_WRITE;
     b88:	80 e4       	ldi	r24, 0x40	; 64
     b8a:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     b8e:	85 e1       	ldi	r24, 0x15	; 21
     b90:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankB_OUT; 
     b94:	80 91 32 3e 	lds	r24, 0x3E32
     b98:	80 93 23 3e 	sts	0x3E23, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     b9c:	80 e0       	ldi	r24, 0x00	; 0
     b9e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     ba0:	21 e2       	ldi	r18, 0x21	; 33
     ba2:	3e e3       	ldi	r19, 0x3E	; 62
     ba4:	a0 ec       	ldi	r26, 0xC0	; 192
     ba6:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     ba8:	cd e2       	ldi	r28, 0x2D	; 45
     baa:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     bac:	f9 01       	movw	r30, r18
     bae:	e8 0f       	add	r30, r24
     bb0:	f9 1f       	adc	r31, r25
     bb2:	40 81       	ld	r20, Z
     bb4:	13 96       	adiw	r26, 0x03	; 3
     bb6:	4c 93       	st	X, r20
     bb8:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     bba:	12 96       	adiw	r26, 0x02	; 2
     bbc:	4c 91       	ld	r20, X
     bbe:	12 97       	sbiw	r26, 0x02	; 2
     bc0:	44 23       	and	r20, r20
     bc2:	dc f7       	brge	.-10     	; 0xbba <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     bc4:	13 96       	adiw	r26, 0x03	; 3
     bc6:	4c 91       	ld	r20, X
     bc8:	13 97       	sbiw	r26, 0x03	; 3
     bca:	48 83       	st	Y, r20
     bcc:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     bce:	83 30       	cpi	r24, 0x03	; 3
     bd0:	91 05       	cpc	r25, r1
     bd2:	61 f7       	brne	.-40     	; 0xbac <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	portExCS(FALSE);
     bda:	80 e0       	ldi	r24, 0x00	; 0
     bdc:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>
	SPIDisable();
     be0:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
}
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	08 95       	ret

00000bea <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
     bee:	c8 2f       	mov	r28, r24
     bf0:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     bf2:	80 e0       	ldi	r24, 0x00	; 0
     bf4:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	portExCS(TRUE);
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     c04:	dd 23       	and	r29, r29
     c06:	89 f0       	breq	.+34     	; 0xc2a <PortEx_DIRCLR+0x40>
     c08:	80 91 30 3e 	lds	r24, 0x3E30
     c0c:	80 95       	com	r24
     c0e:	c8 23       	and	r28, r24
     c10:	c0 93 30 3e 	sts	0x3E30, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     c14:	80 e4       	ldi	r24, 0x40	; 64
     c16:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     c1a:	10 92 22 3e 	sts	0x3E22, r1
		SPIBuffer[2] = ~bankA_DIR; 
     c1e:	80 91 30 3e 	lds	r24, 0x3E30
     c22:	80 95       	com	r24
     c24:	80 93 23 3e 	sts	0x3E23, r24
     c28:	11 c0       	rjmp	.+34     	; 0xc4c <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     c2a:	80 91 47 3e 	lds	r24, 0x3E47
     c2e:	80 95       	com	r24
     c30:	c8 23       	and	r28, r24
     c32:	c0 93 47 3e 	sts	0x3E47, r28
	
	SPIBuffer[0] = PS_WRITE;
     c36:	80 e4       	ldi	r24, 0x40	; 64
     c38:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     c3c:	81 e0       	ldi	r24, 0x01	; 1
     c3e:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = ~bankB_DIR;
     c42:	80 91 47 3e 	lds	r24, 0x3E47
     c46:	80 95       	com	r24
     c48:	80 93 23 3e 	sts	0x3E23, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     c4c:	80 e0       	ldi	r24, 0x00	; 0
     c4e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     c50:	21 e2       	ldi	r18, 0x21	; 33
     c52:	3e e3       	ldi	r19, 0x3E	; 62
     c54:	a0 ec       	ldi	r26, 0xC0	; 192
     c56:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     c58:	cd e2       	ldi	r28, 0x2D	; 45
     c5a:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     c5c:	f9 01       	movw	r30, r18
     c5e:	e8 0f       	add	r30, r24
     c60:	f9 1f       	adc	r31, r25
     c62:	40 81       	ld	r20, Z
     c64:	13 96       	adiw	r26, 0x03	; 3
     c66:	4c 93       	st	X, r20
     c68:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     c6a:	12 96       	adiw	r26, 0x02	; 2
     c6c:	4c 91       	ld	r20, X
     c6e:	12 97       	sbiw	r26, 0x02	; 2
     c70:	44 23       	and	r20, r20
     c72:	dc f7       	brge	.-10     	; 0xc6a <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     c74:	13 96       	adiw	r26, 0x03	; 3
     c76:	4c 91       	ld	r20, X
     c78:	13 97       	sbiw	r26, 0x03	; 3
     c7a:	48 83       	st	Y, r20
     c7c:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     c7e:	83 30       	cpi	r24, 0x03	; 3
     c80:	91 05       	cpc	r25, r1
     c82:	61 f7       	brne	.-40     	; 0xc5c <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     c84:	80 e0       	ldi	r24, 0x00	; 0
     c86:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	portExCS(FALSE);
     c8a:	80 e0       	ldi	r24, 0x00	; 0
     c8c:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>
	SPIDisable();
     c90:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
}
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	08 95       	ret

00000c9a <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	c8 2f       	mov	r28, r24
     ca0:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
     ca8:	81 e0       	ldi	r24, 0x01	; 1
     caa:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	portExCS(TRUE);
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     cb4:	dd 23       	and	r29, r29
     cb6:	81 f0       	breq	.+32     	; 0xcd8 <PortEx_DIRSET+0x3e>
     cb8:	80 91 30 3e 	lds	r24, 0x3E30
     cbc:	c8 2b       	or	r28, r24
     cbe:	c0 93 30 3e 	sts	0x3E30, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     cc2:	80 e4       	ldi	r24, 0x40	; 64
     cc4:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     cc8:	10 92 22 3e 	sts	0x3E22, r1
		SPIBuffer[2] = ~bankA_DIR; 
     ccc:	80 91 30 3e 	lds	r24, 0x3E30
     cd0:	80 95       	com	r24
     cd2:	80 93 23 3e 	sts	0x3E23, r24
     cd6:	10 c0       	rjmp	.+32     	; 0xcf8 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     cd8:	80 91 47 3e 	lds	r24, 0x3E47
     cdc:	c8 2b       	or	r28, r24
     cde:	c0 93 47 3e 	sts	0x3E47, r28
	
	SPIBuffer[0] = PS_WRITE;
     ce2:	80 e4       	ldi	r24, 0x40	; 64
     ce4:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     ce8:	81 e0       	ldi	r24, 0x01	; 1
     cea:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = ~bankB_DIR;
     cee:	80 91 47 3e 	lds	r24, 0x3E47
     cf2:	80 95       	com	r24
     cf4:	80 93 23 3e 	sts	0x3E23, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     cf8:	80 e0       	ldi	r24, 0x00	; 0
     cfa:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     cfc:	21 e2       	ldi	r18, 0x21	; 33
     cfe:	3e e3       	ldi	r19, 0x3E	; 62
     d00:	a0 ec       	ldi	r26, 0xC0	; 192
     d02:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     d04:	cd e2       	ldi	r28, 0x2D	; 45
     d06:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     d08:	f9 01       	movw	r30, r18
     d0a:	e8 0f       	add	r30, r24
     d0c:	f9 1f       	adc	r31, r25
     d0e:	40 81       	ld	r20, Z
     d10:	13 96       	adiw	r26, 0x03	; 3
     d12:	4c 93       	st	X, r20
     d14:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     d16:	12 96       	adiw	r26, 0x02	; 2
     d18:	4c 91       	ld	r20, X
     d1a:	12 97       	sbiw	r26, 0x02	; 2
     d1c:	44 23       	and	r20, r20
     d1e:	dc f7       	brge	.-10     	; 0xd16 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     d20:	13 96       	adiw	r26, 0x03	; 3
     d22:	4c 91       	ld	r20, X
     d24:	13 97       	sbiw	r26, 0x03	; 3
     d26:	48 83       	st	Y, r20
     d28:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     d2a:	83 30       	cpi	r24, 0x03	; 3
     d2c:	91 05       	cpc	r25, r1
     d2e:	61 f7       	brne	.-40     	; 0xd08 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     d30:	80 e0       	ldi	r24, 0x00	; 0
     d32:	0e 94 3a 04 	call	0x874	; 0x874 <portExCS>
	SPICS(FALSE);
     d36:	80 e0       	ldi	r24, 0x00	; 0
     d38:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
     d3c:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>


}
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	08 95       	ret

00000d46 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     d46:	0f 93       	push	r16
     d48:	1f 93       	push	r17
     d4a:	cf 93       	push	r28
     d4c:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     d4e:	88 23       	and	r24, r24
     d50:	09 f4       	brne	.+2      	; 0xd54 <ADCPower+0xe>
     d52:	4e c0       	rjmp	.+156    	; 0xdf0 <ADCPower+0xaa>
     d54:	80 91 33 3e 	lds	r24, 0x3E33
     d58:	88 23       	and	r24, r24
     d5a:	09 f0       	breq	.+2      	; 0xd5e <ADCPower+0x18>
     d5c:	81 c0       	rjmp	.+258    	; 0xe60 <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     d5e:	00 e0       	ldi	r16, 0x00	; 0
     d60:	16 e0       	ldi	r17, 0x06	; 6
     d62:	8e ed       	ldi	r24, 0xDE	; 222
     d64:	d8 01       	movw	r26, r16
     d66:	11 96       	adiw	r26, 0x01	; 1
     d68:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     d6a:	c0 e2       	ldi	r28, 0x20	; 32
     d6c:	d6 e0       	ldi	r29, 0x06	; 6
     d6e:	4e e0       	ldi	r20, 0x0E	; 14
     d70:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     d72:	e0 e4       	ldi	r30, 0x40	; 64
     d74:	f6 e0       	ldi	r31, 0x06	; 6
     d76:	63 e0       	ldi	r22, 0x03	; 3
     d78:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     d7a:	80 e8       	ldi	r24, 0x80	; 128
     d7c:	96 e0       	ldi	r25, 0x06	; 6
     d7e:	50 e1       	ldi	r21, 0x10	; 16
     d80:	dc 01       	movw	r26, r24
     d82:	11 96       	adiw	r26, 0x01	; 1
     d84:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     d86:	20 ea       	ldi	r18, 0xA0	; 160
     d88:	36 e0       	ldi	r19, 0x06	; 6
     d8a:	d9 01       	movw	r26, r18
     d8c:	11 96       	adiw	r26, 0x01	; 1
     d8e:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     d90:	7e e9       	ldi	r23, 0x9E	; 158
     d92:	d8 01       	movw	r26, r16
     d94:	15 96       	adiw	r26, 0x05	; 5
     d96:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     d98:	78 e0       	ldi	r23, 0x08	; 8
     d9a:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     d9c:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     d9e:	ec 01       	movw	r28, r24
     da0:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     da2:	d9 01       	movw	r26, r18
     da4:	15 96       	adiw	r26, 0x05	; 5
     da6:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     da8:	10 92 31 3e 	sts	0x3E31, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     dac:	8f ef       	ldi	r24, 0xFF	; 255
     dae:	93 ec       	ldi	r25, 0xC3	; 195
     db0:	a9 e0       	ldi	r26, 0x09	; 9
     db2:	81 50       	subi	r24, 0x01	; 1
     db4:	90 40       	sbci	r25, 0x00	; 0
     db6:	a0 40       	sbci	r26, 0x00	; 0
     db8:	e1 f7       	brne	.-8      	; 0xdb2 <ADCPower+0x6c>
     dba:	00 c0       	rjmp	.+0      	; 0xdbc <ADCPower+0x76>
     dbc:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     dbe:	80 e4       	ldi	r24, 0x40	; 64
     dc0:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     dc2:	10 92 32 3e 	sts	0x3E32, r1
     dc6:	10 92 47 3e 	sts	0x3E47, r1
     dca:	10 92 ac 21 	sts	0x21AC, r1
     dce:	10 92 30 3e 	sts	0x3E30, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     dd2:	8f ef       	ldi	r24, 0xFF	; 255
     dd4:	61 e0       	ldi	r22, 0x01	; 1
     dd6:	0e 94 4d 06 	call	0xc9a	; 0xc9a <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     dda:	8f ef       	ldi	r24, 0xFF	; 255
     ddc:	61 e0       	ldi	r22, 0x01	; 1
     dde:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     de2:	8f ef       	ldi	r24, 0xFF	; 255
     de4:	0e 94 e6 04 	call	0x9cc	; 0x9cc <set_filter>
		ADC_POWER_ON = TRUE;
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	80 93 33 3e 	sts	0x3E33, r24
     dee:	38 c0       	rjmp	.+112    	; 0xe60 <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     df0:	80 91 33 3e 	lds	r24, 0x3E33
     df4:	88 23       	and	r24, r24
     df6:	a1 f1       	breq	.+104    	; 0xe60 <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     df8:	00 e0       	ldi	r16, 0x00	; 0
     dfa:	16 e0       	ldi	r17, 0x06	; 6
     dfc:	7e ed       	ldi	r23, 0xDE	; 222
     dfe:	d8 01       	movw	r26, r16
     e00:	16 96       	adiw	r26, 0x06	; 6
     e02:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     e04:	a0 e2       	ldi	r26, 0x20	; 32
     e06:	b6 e0       	ldi	r27, 0x06	; 6
     e08:	4e e0       	ldi	r20, 0x0E	; 14
     e0a:	16 96       	adiw	r26, 0x06	; 6
     e0c:	4c 93       	st	X, r20
     e0e:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     e10:	20 e4       	ldi	r18, 0x40	; 64
     e12:	36 e0       	ldi	r19, 0x06	; 6
     e14:	63 e0       	ldi	r22, 0x03	; 3
     e16:	e9 01       	movw	r28, r18
     e18:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     e1a:	c0 e8       	ldi	r28, 0x80	; 128
     e1c:	d6 e0       	ldi	r29, 0x06	; 6
     e1e:	50 e1       	ldi	r21, 0x10	; 16
     e20:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     e22:	80 ea       	ldi	r24, 0xA0	; 160
     e24:	96 e0       	ldi	r25, 0x06	; 6
     e26:	fc 01       	movw	r30, r24
     e28:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     e2a:	f8 01       	movw	r30, r16
     e2c:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     e2e:	12 96       	adiw	r26, 0x02	; 2
     e30:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     e32:	d9 01       	movw	r26, r18
     e34:	12 96       	adiw	r26, 0x02	; 2
     e36:	6c 93       	st	X, r22
     e38:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     e3a:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     e3c:	ec 01       	movw	r28, r24
     e3e:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     e40:	80 e4       	ldi	r24, 0x40	; 64
     e42:	12 96       	adiw	r26, 0x02	; 2
     e44:	8c 93       	st	X, r24
     e46:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     e48:	10 92 32 3e 	sts	0x3E32, r1
     e4c:	10 92 47 3e 	sts	0x3E47, r1
     e50:	10 92 ac 21 	sts	0x21AC, r1
     e54:	10 92 30 3e 	sts	0x3E30, r1
		channelStatus = 0x00;
     e58:	10 92 31 3e 	sts	0x3E31, r1
		ADC_POWER_ON = FALSE;
     e5c:	10 92 33 3e 	sts	0x3E33, r1
	}
}
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	08 95       	ret

00000e6a <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     e6a:	2f 92       	push	r2
     e6c:	3f 92       	push	r3
     e6e:	4f 92       	push	r4
     e70:	5f 92       	push	r5
     e72:	6f 92       	push	r6
     e74:	7f 92       	push	r7
     e76:	8f 92       	push	r8
     e78:	9f 92       	push	r9
     e7a:	af 92       	push	r10
     e7c:	bf 92       	push	r11
     e7e:	cf 92       	push	r12
     e80:	df 92       	push	r13
     e82:	ef 92       	push	r14
     e84:	ff 92       	push	r15
     e86:	0f 93       	push	r16
     e88:	1f 93       	push	r17
     e8a:	cf 93       	push	r28
     e8c:	df 93       	push	r29
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
     e92:	64 97       	sbiw	r28, 0x14	; 20
     e94:	cd bf       	out	0x3d, r28	; 61
     e96:	de bf       	out	0x3e, r29	; 62
     e98:	2a 01       	movw	r4, r20
     e9a:	3b 01       	movw	r6, r22
     e9c:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     e9e:	f9 01       	movw	r30, r18
     ea0:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     ea2:	41 15       	cp	r20, r1
     ea4:	51 05       	cpc	r21, r1
     ea6:	61 05       	cpc	r22, r1
     ea8:	71 05       	cpc	r23, r1
     eaa:	09 f4       	brne	.+2      	; 0xeae <DeciToString+0x44>
     eac:	4d c0       	rjmp	.+154    	; 0xf48 <DeciToString+0xde>
     eae:	88 2e       	mov	r8, r24
     eb0:	99 2e       	mov	r9, r25
     eb2:	cc 24       	eor	r12, r12
     eb4:	dd 24       	eor	r13, r13
     eb6:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     eb8:	5e 01       	movw	r10, r28
     eba:	08 94       	sec
     ebc:	a1 1c       	adc	r10, r1
     ebe:	b1 1c       	adc	r11, r1
     ec0:	0f 2e       	mov	r0, r31
     ec2:	f0 e0       	ldi	r31, 0x00	; 0
     ec4:	2f 2e       	mov	r2, r31
     ec6:	f0 e2       	ldi	r31, 0x20	; 32
     ec8:	3f 2e       	mov	r3, r31
     eca:	f0 2d       	mov	r31, r0
     ecc:	f4 01       	movw	r30, r8
     ece:	81 91       	ld	r24, Z+
     ed0:	91 91       	ld	r25, Z+
     ed2:	a1 91       	ld	r26, Z+
     ed4:	b1 91       	ld	r27, Z+
     ed6:	4f 01       	movw	r8, r30
     ed8:	2d b7       	in	r18, 0x3d	; 61
     eda:	3e b7       	in	r19, 0x3e	; 62
     edc:	28 50       	subi	r18, 0x08	; 8
     ede:	30 40       	sbci	r19, 0x00	; 0
     ee0:	2d bf       	out	0x3d, r18	; 61
     ee2:	3e bf       	out	0x3e, r19	; 62
     ee4:	2f 5f       	subi	r18, 0xFF	; 255
     ee6:	3f 4f       	sbci	r19, 0xFF	; 255
     ee8:	ed b7       	in	r30, 0x3d	; 61
     eea:	fe b7       	in	r31, 0x3e	; 62
     eec:	a1 82       	std	Z+1, r10	; 0x01
     eee:	b2 82       	std	Z+2, r11	; 0x02
     ef0:	f9 01       	movw	r30, r18
     ef2:	22 82       	std	Z+2, r2	; 0x02
     ef4:	33 82       	std	Z+3, r3	; 0x03
     ef6:	84 83       	std	Z+4, r24	; 0x04
     ef8:	95 83       	std	Z+5, r25	; 0x05
     efa:	a6 83       	std	Z+6, r26	; 0x06
     efc:	b7 83       	std	Z+7, r27	; 0x07
     efe:	0e 94 c0 38 	call	0x7180	; 0x7180 <sprintf>
		strcat(ReturnString,b);
     f02:	2d b7       	in	r18, 0x3d	; 61
     f04:	3e b7       	in	r19, 0x3e	; 62
     f06:	28 5f       	subi	r18, 0xF8	; 248
     f08:	3f 4f       	sbci	r19, 0xFF	; 255
     f0a:	2d bf       	out	0x3d, r18	; 61
     f0c:	3e bf       	out	0x3e, r19	; 62
     f0e:	c8 01       	movw	r24, r16
     f10:	b5 01       	movw	r22, r10
     f12:	0e 94 82 38 	call	0x7104	; 0x7104 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     f16:	a0 2f       	mov	r26, r16
     f18:	b1 2f       	mov	r27, r17
     f1a:	fd 01       	movw	r30, r26
     f1c:	01 90       	ld	r0, Z+
     f1e:	00 20       	and	r0, r0
     f20:	e9 f7       	brne	.-6      	; 0xf1c <DeciToString+0xb2>
     f22:	31 97       	sbiw	r30, 0x01	; 1
     f24:	ea 1b       	sub	r30, r26
     f26:	fb 0b       	sbc	r31, r27
     f28:	e0 0f       	add	r30, r16
     f2a:	f1 1f       	adc	r31, r17
     f2c:	8a e0       	ldi	r24, 0x0A	; 10
     f2e:	90 e0       	ldi	r25, 0x00	; 0
     f30:	80 83       	st	Z, r24
     f32:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     f34:	08 94       	sec
     f36:	c1 1c       	adc	r12, r1
     f38:	d1 1c       	adc	r13, r1
     f3a:	e1 1c       	adc	r14, r1
     f3c:	f1 1c       	adc	r15, r1
     f3e:	c4 14       	cp	r12, r4
     f40:	d5 04       	cpc	r13, r5
     f42:	e6 04       	cpc	r14, r6
     f44:	f7 04       	cpc	r15, r7
     f46:	11 f6       	brne	.-124    	; 0xecc <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     f48:	64 96       	adiw	r28, 0x14	; 20
     f4a:	cd bf       	out	0x3d, r28	; 61
     f4c:	de bf       	out	0x3e, r29	; 62
     f4e:	df 91       	pop	r29
     f50:	cf 91       	pop	r28
     f52:	1f 91       	pop	r17
     f54:	0f 91       	pop	r16
     f56:	ff 90       	pop	r15
     f58:	ef 90       	pop	r14
     f5a:	df 90       	pop	r13
     f5c:	cf 90       	pop	r12
     f5e:	bf 90       	pop	r11
     f60:	af 90       	pop	r10
     f62:	9f 90       	pop	r9
     f64:	8f 90       	pop	r8
     f66:	7f 90       	pop	r7
     f68:	6f 90       	pop	r6
     f6a:	5f 90       	pop	r5
     f6c:	4f 90       	pop	r4
     f6e:	3f 90       	pop	r3
     f70:	2f 90       	pop	r2
     f72:	08 95       	ret

00000f74 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     f74:	e0 ec       	ldi	r30, 0xC0	; 192
     f76:	f8 e0       	ldi	r31, 0x08	; 8
     f78:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     f7a:	82 81       	ldd	r24, Z+2	; 0x02
     f7c:	88 23       	and	r24, r24
     f7e:	ec f7       	brge	.-6      	; 0xf7a <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     f80:	e0 ec       	ldi	r30, 0xC0	; 192
     f82:	f8 e0       	ldi	r31, 0x08	; 8
     f84:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     f86:	08 95       	ret

00000f88 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     f88:	0f 93       	push	r16
     f8a:	1f 93       	push	r17
     f8c:	cf 93       	push	r28
     f8e:	8c 01       	movw	r16, r24
	moteID = 1;
     f90:	c1 e0       	ldi	r28, 0x01	; 1
     f92:	c0 93 46 3e 	sts	0x3E46, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     f96:	83 e0       	ldi	r24, 0x03	; 3
     f98:	80 93 20 3e 	sts	0x3E20, r24
	chb_init();
     f9c:	0e 94 8d 18 	call	0x311a	; 0x311a <chb_init>
	chb_set_short_addr(moteID);
     fa0:	80 91 46 3e 	lds	r24, 0x3E46
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	0e 94 b0 1a 	call	0x3560	; 0x3560 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     faa:	88 ec       	ldi	r24, 0xC8	; 200
     fac:	e0 e8       	ldi	r30, 0x80	; 128
     fae:	f1 e0       	ldi	r31, 0x01	; 1
     fb0:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     fb2:	e0 e4       	ldi	r30, 0x40	; 64
     fb4:	f9 e0       	ldi	r31, 0x09	; 9
     fb6:	89 e0       	ldi	r24, 0x09	; 9
     fb8:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     fba:	82 e0       	ldi	r24, 0x02	; 2
     fbc:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     fbe:	24 ef       	ldi	r18, 0xF4	; 244
     fc0:	31 e0       	ldi	r19, 0x01	; 1
     fc2:	02 9f       	mul	r16, r18
     fc4:	c0 01       	movw	r24, r0
     fc6:	03 9f       	mul	r16, r19
     fc8:	90 0d       	add	r25, r0
     fca:	12 9f       	mul	r17, r18
     fcc:	90 0d       	add	r25, r0
     fce:	11 24       	eor	r1, r1
     fd0:	86 a3       	lds	r24, 0x56
     fd2:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     fd4:	e0 e4       	ldi	r30, 0x40	; 64
     fd6:	f8 e0       	ldi	r31, 0x08	; 8
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	9a ef       	ldi	r25, 0xFA	; 250
     fdc:	86 a3       	lds	r24, 0x56
     fde:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     fe0:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     fe2:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     fe4:	e0 ea       	ldi	r30, 0xA0	; 160
     fe6:	f0 e0       	ldi	r31, 0x00	; 0
     fe8:	82 81       	ldd	r24, Z+2	; 0x02
     fea:	87 60       	ori	r24, 0x07	; 7
     fec:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     fee:	78 94       	sei
}
     ff0:	cf 91       	pop	r28
     ff2:	1f 91       	pop	r17
     ff4:	0f 91       	pop	r16
     ff6:	08 95       	ret

00000ff8 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     ff8:	78 94       	sei
     ffa:	1f 92       	push	r1
     ffc:	0f 92       	push	r0
     ffe:	0f b6       	in	r0, 0x3f	; 63
    1000:	0f 92       	push	r0
    1002:	0b b6       	in	r0, 0x3b	; 59
    1004:	0f 92       	push	r0
    1006:	11 24       	eor	r1, r1
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	2f 93       	push	r18
    1012:	3f 93       	push	r19
    1014:	4f 93       	push	r20
    1016:	5f 93       	push	r21
    1018:	6f 93       	push	r22
    101a:	7f 93       	push	r23
    101c:	8f 93       	push	r24
    101e:	9f 93       	push	r25
    1020:	af 93       	push	r26
    1022:	bf 93       	push	r27
    1024:	ef 93       	push	r30
    1026:	ff 93       	push	r31
    1028:	cf 93       	push	r28
    102a:	df 93       	push	r29
    102c:	cd b7       	in	r28, 0x3d	; 61
    102e:	de b7       	in	r29, 0x3e	; 62
    1030:	28 97       	sbiw	r28, 0x08	; 8
    1032:	cd bf       	out	0x3d, r28	; 61
    1034:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    1036:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    103a:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    103e:	82 e0       	ldi	r24, 0x02	; 2
    1040:	80 93 20 3e 	sts	0x3E20, r24
	char message[8];
	strcpy(message,"reset");
    1044:	de 01       	movw	r26, r28
    1046:	11 96       	adiw	r26, 0x01	; 1
    1048:	e4 e0       	ldi	r30, 0x04	; 4
    104a:	f0 e2       	ldi	r31, 0x20	; 32
    104c:	86 e0       	ldi	r24, 0x06	; 6
    104e:	01 90       	ld	r0, Z+
    1050:	0d 92       	st	X+, r0
    1052:	81 50       	subi	r24, 0x01	; 1
    1054:	e1 f7       	brne	.-8      	; 0x104e <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    1056:	0a ea       	ldi	r16, 0xAA	; 170
    1058:	10 e5       	ldi	r17, 0x50	; 80
    105a:	80 91 46 3e 	lds	r24, 0x3E46
    105e:	90 e0       	ldi	r25, 0x00	; 0
    1060:	b8 01       	movw	r22, r16
    1062:	4a e0       	ldi	r20, 0x0A	; 10
    1064:	50 e0       	ldi	r21, 0x00	; 0
    1066:	0e 94 8d 38 	call	0x711a	; 0x711a <itoa>
	strcat(message,buff);
    106a:	7e 01       	movw	r14, r28
    106c:	08 94       	sec
    106e:	e1 1c       	adc	r14, r1
    1070:	f1 1c       	adc	r15, r1
    1072:	c7 01       	movw	r24, r14
    1074:	b8 01       	movw	r22, r16
    1076:	0e 94 82 38 	call	0x7104	; 0x7104 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    107a:	0e 94 80 0b 	call	0x1700	; 0x1700 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    107e:	f7 01       	movw	r30, r14
    1080:	01 90       	ld	r0, Z+
    1082:	00 20       	and	r0, r0
    1084:	e9 f7       	brne	.-6      	; 0x1080 <__vector_83+0x88>
    1086:	31 97       	sbiw	r30, 0x01	; 1
    1088:	ee 19       	sub	r30, r14
    108a:	ff 09       	sbc	r31, r15
    108c:	9f 01       	movw	r18, r30
    108e:	40 e0       	ldi	r20, 0x00	; 0
    1090:	50 e0       	ldi	r21, 0x00	; 0
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	b7 01       	movw	r22, r14
    1098:	0e 94 b1 18 	call	0x3162	; 0x3162 <chb_write>
}	
    109c:	28 96       	adiw	r28, 0x08	; 8
    109e:	cd bf       	out	0x3d, r28	; 61
    10a0:	de bf       	out	0x3e, r29	; 62
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	ff 91       	pop	r31
    10a8:	ef 91       	pop	r30
    10aa:	bf 91       	pop	r27
    10ac:	af 91       	pop	r26
    10ae:	9f 91       	pop	r25
    10b0:	8f 91       	pop	r24
    10b2:	7f 91       	pop	r23
    10b4:	6f 91       	pop	r22
    10b6:	5f 91       	pop	r21
    10b8:	4f 91       	pop	r20
    10ba:	3f 91       	pop	r19
    10bc:	2f 91       	pop	r18
    10be:	1f 91       	pop	r17
    10c0:	0f 91       	pop	r16
    10c2:	ff 90       	pop	r15
    10c4:	ef 90       	pop	r14
    10c6:	0f 90       	pop	r0
    10c8:	0b be       	out	0x3b, r0	; 59
    10ca:	0f 90       	pop	r0
    10cc:	0f be       	out	0x3f, r0	; 63
    10ce:	0f 90       	pop	r0
    10d0:	1f 90       	pop	r1
    10d2:	18 95       	reti

000010d4 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    10d4:	4f 92       	push	r4
    10d6:	5f 92       	push	r5
    10d8:	6f 92       	push	r6
    10da:	7f 92       	push	r7
    10dc:	8f 92       	push	r8
    10de:	9f 92       	push	r9
    10e0:	af 92       	push	r10
    10e2:	bf 92       	push	r11
    10e4:	ef 92       	push	r14
    10e6:	ff 92       	push	r15
    10e8:	0f 93       	push	r16
    10ea:	1f 93       	push	r17
    10ec:	cf 93       	push	r28
    10ee:	df 93       	push	r29
    10f0:	cd b7       	in	r28, 0x3d	; 61
    10f2:	de b7       	in	r29, 0x3e	; 62
    10f4:	2b 97       	sbiw	r28, 0x0b	; 11
    10f6:	cd bf       	out	0x3d, r28	; 61
    10f8:	de bf       	out	0x3e, r29	; 62
    10fa:	8e 83       	std	Y+6, r24	; 0x06
    10fc:	9f 83       	std	Y+7, r25	; 0x07
    10fe:	68 87       	std	Y+8, r22	; 0x08
    1100:	79 87       	std	Y+9, r23	; 0x09
    1102:	4a 87       	std	Y+10, r20	; 0x0a
    1104:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    110c:	80 e0       	ldi	r24, 0x00	; 0
    110e:	92 e0       	ldi	r25, 0x02	; 2
    1110:	0e 94 70 18 	call	0x30e0	; 0x30e0 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    1114:	00 e0       	ldi	r16, 0x00	; 0
    1116:	12 e0       	ldi	r17, 0x02	; 2
    1118:	d8 01       	movw	r26, r16
    111a:	11 96       	adiw	r26, 0x01	; 1
    111c:	8c 91       	ld	r24, X
    111e:	11 97       	sbiw	r26, 0x01	; 1
    1120:	89 7e       	andi	r24, 0xE9	; 233
    1122:	11 96       	adiw	r26, 0x01	; 1
    1124:	8c 93       	st	X, r24
    1126:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    1128:	14 96       	adiw	r26, 0x04	; 4
    112a:	8c 91       	ld	r24, X
    112c:	14 97       	sbiw	r26, 0x04	; 4
    112e:	88 7f       	andi	r24, 0xF8	; 248
    1130:	83 60       	ori	r24, 0x03	; 3
    1132:	14 96       	adiw	r26, 0x04	; 4
    1134:	8c 93       	st	X, r24
    1136:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    1138:	12 96       	adiw	r26, 0x02	; 2
    113a:	8c 91       	ld	r24, X
    113c:	12 97       	sbiw	r26, 0x02	; 2
    113e:	8f 7c       	andi	r24, 0xCF	; 207
    1140:	12 96       	adiw	r26, 0x02	; 2
    1142:	8c 93       	st	X, r24
    1144:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    1146:	0f 2e       	mov	r0, r31
    1148:	f0 e2       	ldi	r31, 0x20	; 32
    114a:	ef 2e       	mov	r14, r31
    114c:	f2 e0       	ldi	r31, 0x02	; 2
    114e:	ff 2e       	mov	r15, r31
    1150:	f0 2d       	mov	r31, r0
    1152:	f7 01       	movw	r30, r14
    1154:	80 81       	ld	r24, Z
    1156:	80 7e       	andi	r24, 0xE0	; 224
    1158:	81 60       	ori	r24, 0x01	; 1
    115a:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    115c:	89 e0       	ldi	r24, 0x09	; 9
    115e:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    1160:	8c 91       	ld	r24, X
    1162:	81 60       	ori	r24, 0x01	; 1
    1164:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1166:	80 e0       	ldi	r24, 0x00	; 0
    1168:	92 e0       	ldi	r25, 0x02	; 2
    116a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	92 e0       	ldi	r25, 0x02	; 2
    1172:	60 e2       	ldi	r22, 0x20	; 32
    1174:	72 e0       	ldi	r23, 0x02	; 2
    1176:	40 e0       	ldi	r20, 0x00	; 0
    1178:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <ADC_Offset_Get_Unsigned>
    117c:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    117e:	d8 01       	movw	r26, r16
    1180:	8c 91       	ld	r24, X
    1182:	8e 7f       	andi	r24, 0xFE	; 254
    1184:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1186:	f7 01       	movw	r30, r14
    1188:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    118a:	13 96       	adiw	r26, 0x03	; 3
    118c:	8c 91       	ld	r24, X
    118e:	13 97       	sbiw	r26, 0x03	; 3
    1190:	8f 73       	andi	r24, 0x3F	; 63
    1192:	13 96       	adiw	r26, 0x03	; 3
    1194:	8c 93       	st	X, r24
    1196:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    1198:	8c 91       	ld	r24, X
    119a:	81 60       	ori	r24, 0x01	; 1
    119c:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    119e:	80 e0       	ldi	r24, 0x00	; 0
    11a0:	92 e0       	ldi	r25, 0x02	; 2
    11a2:	0e 94 f5 17 	call	0x2fea	; 0x2fea <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    11a6:	d8 01       	movw	r26, r16
    11a8:	11 96       	adiw	r26, 0x01	; 1
    11aa:	8c 91       	ld	r24, X
    11ac:	11 97       	sbiw	r26, 0x01	; 1
    11ae:	88 60       	ori	r24, 0x08	; 8
    11b0:	11 96       	adiw	r26, 0x01	; 1
    11b2:	8c 93       	st	X, r24
    11b4:	ee 24       	eor	r14, r14
    11b6:	ff 24       	eor	r15, r15
    11b8:	68 94       	set
    11ba:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    11bc:	44 24       	eor	r4, r4
    11be:	55 24       	eor	r5, r5
    11c0:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    11c2:	20 e0       	ldi	r18, 0x00	; 0
    11c4:	30 e1       	ldi	r19, 0x10	; 16
    11c6:	40 e0       	ldi	r20, 0x00	; 0
    11c8:	50 e0       	ldi	r21, 0x00	; 0
    11ca:	2a 83       	std	Y+2, r18	; 0x02
    11cc:	3b 83       	std	Y+3, r19	; 0x03
    11ce:	4c 83       	std	Y+4, r20	; 0x04
    11d0:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    11d2:	88 24       	eor	r8, r8
    11d4:	99 24       	eor	r9, r9
    11d6:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    11d8:	00 e2       	ldi	r16, 0x20	; 32
    11da:	12 e0       	ldi	r17, 0x02	; 2
    11dc:	d8 01       	movw	r26, r16
    11de:	13 96       	adiw	r26, 0x03	; 3
    11e0:	8c 91       	ld	r24, X
    11e2:	13 97       	sbiw	r26, 0x03	; 3
    11e4:	80 ff       	sbrs	r24, 0
    11e6:	fa cf       	rjmp	.-12     	; 0x11dc <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    11e8:	69 81       	ldd	r22, Y+1	; 0x01
    11ea:	c8 01       	movw	r24, r16
    11ec:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    11f0:	a0 e0       	ldi	r26, 0x00	; 0
    11f2:	b0 e0       	ldi	r27, 0x00	; 0
    11f4:	88 0e       	add	r8, r24
    11f6:	99 1e       	adc	r9, r25
    11f8:	aa 1e       	adc	r10, r26
    11fa:	bb 1e       	adc	r11, r27
    11fc:	48 16       	cp	r4, r24
    11fe:	59 06       	cpc	r5, r25
    1200:	6a 06       	cpc	r6, r26
    1202:	7b 06       	cpc	r7, r27
    1204:	10 f4       	brcc	.+4      	; 0x120a <CO_collectTemp+0x136>
    1206:	2c 01       	movw	r4, r24
    1208:	3d 01       	movw	r6, r26
    120a:	2a 81       	ldd	r18, Y+2	; 0x02
    120c:	3b 81       	ldd	r19, Y+3	; 0x03
    120e:	4c 81       	ldd	r20, Y+4	; 0x04
    1210:	5d 81       	ldd	r21, Y+5	; 0x05
    1212:	82 17       	cp	r24, r18
    1214:	93 07       	cpc	r25, r19
    1216:	a4 07       	cpc	r26, r20
    1218:	b5 07       	cpc	r27, r21
    121a:	20 f4       	brcc	.+8      	; 0x1224 <CO_collectTemp+0x150>
    121c:	8a 83       	std	Y+2, r24	; 0x02
    121e:	9b 83       	std	Y+3, r25	; 0x03
    1220:	ac 83       	std	Y+4, r26	; 0x04
    1222:	bd 83       	std	Y+5, r27	; 0x05
    1224:	08 94       	sec
    1226:	e1 08       	sbc	r14, r1
    1228:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    122a:	e1 14       	cp	r14, r1
    122c:	f1 04       	cpc	r15, r1
    122e:	b1 f6       	brne	.-84     	; 0x11dc <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    1230:	e0 e0       	ldi	r30, 0x00	; 0
    1232:	f2 e0       	ldi	r31, 0x02	; 2
    1234:	81 81       	ldd	r24, Z+1	; 0x01
    1236:	87 7f       	andi	r24, 0xF7	; 247
    1238:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    123a:	80 81       	ld	r24, Z
    123c:	82 60       	ori	r24, 0x02	; 2
    123e:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    1240:	80 81       	ld	r24, Z
    1242:	8e 7f       	andi	r24, 0xFE	; 254
    1244:	80 83       	st	Z, r24

	ADCPower(FALSE);
    1246:	80 e0       	ldi	r24, 0x00	; 0
    1248:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>

	average = sum / NUM_SAMPLES;
    124c:	c5 01       	movw	r24, r10
    124e:	b4 01       	movw	r22, r8
    1250:	05 2e       	mov	r0, r21
    1252:	5a e0       	ldi	r21, 0x0A	; 10
    1254:	96 95       	lsr	r25
    1256:	87 95       	ror	r24
    1258:	77 95       	ror	r23
    125a:	67 95       	ror	r22
    125c:	5a 95       	dec	r21
    125e:	d1 f7       	brne	.-12     	; 0x1254 <CO_collectTemp+0x180>
    1260:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1262:	28 ee       	ldi	r18, 0xE8	; 232
    1264:	33 e0       	ldi	r19, 0x03	; 3
    1266:	40 e0       	ldi	r20, 0x00	; 0
    1268:	50 e0       	ldi	r21, 0x00	; 0
    126a:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    126e:	0f 2e       	mov	r0, r31
    1270:	ff ef       	ldi	r31, 0xFF	; 255
    1272:	8f 2e       	mov	r8, r31
    1274:	ff e0       	ldi	r31, 0x0F	; 15
    1276:	9f 2e       	mov	r9, r31
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	af 2e       	mov	r10, r31
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	bf 2e       	mov	r11, r31
    1280:	f0 2d       	mov	r31, r0
    1282:	a5 01       	movw	r20, r10
    1284:	94 01       	movw	r18, r8
    1286:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    128a:	c9 01       	movw	r24, r18
    128c:	c2 97       	sbiw	r24, 0x32	; 50
    128e:	ae 81       	ldd	r26, Y+6	; 0x06
    1290:	bf 81       	ldd	r27, Y+7	; 0x07
    1292:	8d 93       	st	X+, r24
    1294:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1296:	c3 01       	movw	r24, r6
    1298:	b2 01       	movw	r22, r4
    129a:	28 ee       	ldi	r18, 0xE8	; 232
    129c:	33 e0       	ldi	r19, 0x03	; 3
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	50 e0       	ldi	r21, 0x00	; 0
    12a2:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    12a6:	a5 01       	movw	r20, r10
    12a8:	94 01       	movw	r18, r8
    12aa:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    12ae:	c9 01       	movw	r24, r18
    12b0:	c2 97       	sbiw	r24, 0x32	; 50
    12b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    12b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    12b6:	80 83       	st	Z, r24
    12b8:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    12ba:	6a 81       	ldd	r22, Y+2	; 0x02
    12bc:	7b 81       	ldd	r23, Y+3	; 0x03
    12be:	8c 81       	ldd	r24, Y+4	; 0x04
    12c0:	9d 81       	ldd	r25, Y+5	; 0x05
    12c2:	28 ee       	ldi	r18, 0xE8	; 232
    12c4:	33 e0       	ldi	r19, 0x03	; 3
    12c6:	40 e0       	ldi	r20, 0x00	; 0
    12c8:	50 e0       	ldi	r21, 0x00	; 0
    12ca:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    12ce:	a5 01       	movw	r20, r10
    12d0:	94 01       	movw	r18, r8
    12d2:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    12d6:	22 53       	subi	r18, 0x32	; 50
    12d8:	30 40       	sbci	r19, 0x00	; 0
    12da:	a8 85       	ldd	r26, Y+8	; 0x08
    12dc:	b9 85       	ldd	r27, Y+9	; 0x09
    12de:	2d 93       	st	X+, r18
    12e0:	3c 93       	st	X, r19
    12e2:	11 97       	sbiw	r26, 0x01	; 1
}
    12e4:	2b 96       	adiw	r28, 0x0b	; 11
    12e6:	cd bf       	out	0x3d, r28	; 61
    12e8:	de bf       	out	0x3e, r29	; 62
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	1f 91       	pop	r17
    12f0:	0f 91       	pop	r16
    12f2:	ff 90       	pop	r15
    12f4:	ef 90       	pop	r14
    12f6:	bf 90       	pop	r11
    12f8:	af 90       	pop	r10
    12fa:	9f 90       	pop	r9
    12fc:	8f 90       	pop	r8
    12fe:	7f 90       	pop	r7
    1300:	6f 90       	pop	r6
    1302:	5f 90       	pop	r5
    1304:	4f 90       	pop	r4
    1306:	08 95       	ret

00001308 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    1308:	4f 92       	push	r4
    130a:	5f 92       	push	r5
    130c:	6f 92       	push	r6
    130e:	7f 92       	push	r7
    1310:	8f 92       	push	r8
    1312:	9f 92       	push	r9
    1314:	af 92       	push	r10
    1316:	bf 92       	push	r11
    1318:	ef 92       	push	r14
    131a:	ff 92       	push	r15
    131c:	0f 93       	push	r16
    131e:	1f 93       	push	r17
    1320:	cf 93       	push	r28
    1322:	df 93       	push	r29
    1324:	cd b7       	in	r28, 0x3d	; 61
    1326:	de b7       	in	r29, 0x3e	; 62
    1328:	2b 97       	sbiw	r28, 0x0b	; 11
    132a:	cd bf       	out	0x3d, r28	; 61
    132c:	de bf       	out	0x3e, r29	; 62
    132e:	8e 83       	std	Y+6, r24	; 0x06
    1330:	9f 83       	std	Y+7, r25	; 0x07
    1332:	68 87       	std	Y+8, r22	; 0x08
    1334:	79 87       	std	Y+9, r23	; 0x09
    1336:	4a 87       	std	Y+10, r20	; 0x0a
    1338:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    133a:	81 e0       	ldi	r24, 0x01	; 1
    133c:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    1340:	84 e0       	ldi	r24, 0x04	; 4
    1342:	60 e0       	ldi	r22, 0x00	; 0
    1344:	0e 94 4d 06 	call	0xc9a	; 0xc9a <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    1348:	84 e0       	ldi	r24, 0x04	; 4
    134a:	60 e0       	ldi	r22, 0x00	; 0
    134c:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
    1350:	2f ef       	ldi	r18, 0xFF	; 255
    1352:	33 ec       	ldi	r19, 0xC3	; 195
    1354:	49 e0       	ldi	r20, 0x09	; 9
    1356:	21 50       	subi	r18, 0x01	; 1
    1358:	30 40       	sbci	r19, 0x00	; 0
    135a:	40 40       	sbci	r20, 0x00	; 0
    135c:	e1 f7       	brne	.-8      	; 0x1356 <CO_collectBatt+0x4e>
    135e:	00 c0       	rjmp	.+0      	; 0x1360 <CO_collectBatt+0x58>
    1360:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    1362:	80 e4       	ldi	r24, 0x40	; 64
    1364:	92 e0       	ldi	r25, 0x02	; 2
    1366:	0e 94 70 18 	call	0x30e0	; 0x30e0 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    136a:	00 e4       	ldi	r16, 0x40	; 64
    136c:	12 e0       	ldi	r17, 0x02	; 2
    136e:	d8 01       	movw	r26, r16
    1370:	11 96       	adiw	r26, 0x01	; 1
    1372:	8c 91       	ld	r24, X
    1374:	11 97       	sbiw	r26, 0x01	; 1
    1376:	89 7e       	andi	r24, 0xE9	; 233
    1378:	11 96       	adiw	r26, 0x01	; 1
    137a:	8c 93       	st	X, r24
    137c:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    137e:	14 96       	adiw	r26, 0x04	; 4
    1380:	8c 91       	ld	r24, X
    1382:	14 97       	sbiw	r26, 0x04	; 4
    1384:	88 7f       	andi	r24, 0xF8	; 248
    1386:	83 60       	ori	r24, 0x03	; 3
    1388:	14 96       	adiw	r26, 0x04	; 4
    138a:	8c 93       	st	X, r24
    138c:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    138e:	12 96       	adiw	r26, 0x02	; 2
    1390:	8c 91       	ld	r24, X
    1392:	12 97       	sbiw	r26, 0x02	; 2
    1394:	8f 7c       	andi	r24, 0xCF	; 207
    1396:	12 96       	adiw	r26, 0x02	; 2
    1398:	8c 93       	st	X, r24
    139a:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    139c:	0f 2e       	mov	r0, r31
    139e:	f0 e6       	ldi	r31, 0x60	; 96
    13a0:	ef 2e       	mov	r14, r31
    13a2:	f2 e0       	ldi	r31, 0x02	; 2
    13a4:	ff 2e       	mov	r15, r31
    13a6:	f0 2d       	mov	r31, r0
    13a8:	f7 01       	movw	r30, r14
    13aa:	80 81       	ld	r24, Z
    13ac:	80 7e       	andi	r24, 0xE0	; 224
    13ae:	81 60       	ori	r24, 0x01	; 1
    13b0:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    13b2:	89 e0       	ldi	r24, 0x09	; 9
    13b4:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    13b6:	8c 91       	ld	r24, X
    13b8:	81 60       	ori	r24, 0x01	; 1
    13ba:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    13bc:	80 e4       	ldi	r24, 0x40	; 64
    13be:	92 e0       	ldi	r25, 0x02	; 2
    13c0:	0e 94 f5 17 	call	0x2fea	; 0x2fea <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    13c4:	80 e4       	ldi	r24, 0x40	; 64
    13c6:	92 e0       	ldi	r25, 0x02	; 2
    13c8:	60 e6       	ldi	r22, 0x60	; 96
    13ca:	72 e0       	ldi	r23, 0x02	; 2
    13cc:	40 e0       	ldi	r20, 0x00	; 0
    13ce:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <ADC_Offset_Get_Unsigned>
    13d2:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    13d4:	d8 01       	movw	r26, r16
    13d6:	8c 91       	ld	r24, X
    13d8:	8e 7f       	andi	r24, 0xFE	; 254
    13da:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    13dc:	f7 01       	movw	r30, r14
    13de:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    13e0:	13 96       	adiw	r26, 0x03	; 3
    13e2:	8c 91       	ld	r24, X
    13e4:	13 97       	sbiw	r26, 0x03	; 3
    13e6:	8f 73       	andi	r24, 0x3F	; 63
    13e8:	13 96       	adiw	r26, 0x03	; 3
    13ea:	8c 93       	st	X, r24
    13ec:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    13ee:	8c 91       	ld	r24, X
    13f0:	81 60       	ori	r24, 0x01	; 1
    13f2:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    13f4:	80 e4       	ldi	r24, 0x40	; 64
    13f6:	92 e0       	ldi	r25, 0x02	; 2
    13f8:	0e 94 f5 17 	call	0x2fea	; 0x2fea <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    13fc:	d8 01       	movw	r26, r16
    13fe:	11 96       	adiw	r26, 0x01	; 1
    1400:	8c 91       	ld	r24, X
    1402:	11 97       	sbiw	r26, 0x01	; 1
    1404:	88 60       	ori	r24, 0x08	; 8
    1406:	11 96       	adiw	r26, 0x01	; 1
    1408:	8c 93       	st	X, r24
    140a:	ee 24       	eor	r14, r14
    140c:	ff 24       	eor	r15, r15
    140e:	68 94       	set
    1410:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    1412:	44 24       	eor	r4, r4
    1414:	55 24       	eor	r5, r5
    1416:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    1418:	20 e0       	ldi	r18, 0x00	; 0
    141a:	30 e1       	ldi	r19, 0x10	; 16
    141c:	40 e0       	ldi	r20, 0x00	; 0
    141e:	50 e0       	ldi	r21, 0x00	; 0
    1420:	2a 83       	std	Y+2, r18	; 0x02
    1422:	3b 83       	std	Y+3, r19	; 0x03
    1424:	4c 83       	std	Y+4, r20	; 0x04
    1426:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    1428:	88 24       	eor	r8, r8
    142a:	99 24       	eor	r9, r9
    142c:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    142e:	00 e6       	ldi	r16, 0x60	; 96
    1430:	12 e0       	ldi	r17, 0x02	; 2
    1432:	d8 01       	movw	r26, r16
    1434:	13 96       	adiw	r26, 0x03	; 3
    1436:	8c 91       	ld	r24, X
    1438:	13 97       	sbiw	r26, 0x03	; 3
    143a:	80 ff       	sbrs	r24, 0
    143c:	fa cf       	rjmp	.-12     	; 0x1432 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    143e:	69 81       	ldd	r22, Y+1	; 0x01
    1440:	c8 01       	movw	r24, r16
    1442:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    1446:	a0 e0       	ldi	r26, 0x00	; 0
    1448:	b0 e0       	ldi	r27, 0x00	; 0
    144a:	88 0e       	add	r8, r24
    144c:	99 1e       	adc	r9, r25
    144e:	aa 1e       	adc	r10, r26
    1450:	bb 1e       	adc	r11, r27
    1452:	48 16       	cp	r4, r24
    1454:	59 06       	cpc	r5, r25
    1456:	6a 06       	cpc	r6, r26
    1458:	7b 06       	cpc	r7, r27
    145a:	10 f4       	brcc	.+4      	; 0x1460 <CO_collectBatt+0x158>
    145c:	2c 01       	movw	r4, r24
    145e:	3d 01       	movw	r6, r26
    1460:	2a 81       	ldd	r18, Y+2	; 0x02
    1462:	3b 81       	ldd	r19, Y+3	; 0x03
    1464:	4c 81       	ldd	r20, Y+4	; 0x04
    1466:	5d 81       	ldd	r21, Y+5	; 0x05
    1468:	82 17       	cp	r24, r18
    146a:	93 07       	cpc	r25, r19
    146c:	a4 07       	cpc	r26, r20
    146e:	b5 07       	cpc	r27, r21
    1470:	20 f4       	brcc	.+8      	; 0x147a <CO_collectBatt+0x172>
    1472:	8a 83       	std	Y+2, r24	; 0x02
    1474:	9b 83       	std	Y+3, r25	; 0x03
    1476:	ac 83       	std	Y+4, r26	; 0x04
    1478:	bd 83       	std	Y+5, r27	; 0x05
    147a:	08 94       	sec
    147c:	e1 08       	sbc	r14, r1
    147e:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1480:	e1 14       	cp	r14, r1
    1482:	f1 04       	cpc	r15, r1
    1484:	b1 f6       	brne	.-84     	; 0x1432 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    1486:	e0 e4       	ldi	r30, 0x40	; 64
    1488:	f2 e0       	ldi	r31, 0x02	; 2
    148a:	81 81       	ldd	r24, Z+1	; 0x01
    148c:	87 7f       	andi	r24, 0xF7	; 247
    148e:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    1490:	80 81       	ld	r24, Z
    1492:	8e 7f       	andi	r24, 0xFE	; 254
    1494:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    1496:	84 e0       	ldi	r24, 0x04	; 4
    1498:	60 e0       	ldi	r22, 0x00	; 0
    149a:	0e 94 f5 05 	call	0xbea	; 0xbea <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    149e:	80 e0       	ldi	r24, 0x00	; 0
    14a0:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    14a4:	c5 01       	movw	r24, r10
    14a6:	b4 01       	movw	r22, r8
    14a8:	05 2e       	mov	r0, r21
    14aa:	5a e0       	ldi	r21, 0x0A	; 10
    14ac:	96 95       	lsr	r25
    14ae:	87 95       	ror	r24
    14b0:	77 95       	ror	r23
    14b2:	67 95       	ror	r22
    14b4:	5a 95       	dec	r21
    14b6:	d1 f7       	brne	.-12     	; 0x14ac <CO_collectBatt+0x1a4>
    14b8:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    14ba:	28 ee       	ldi	r18, 0xE8	; 232
    14bc:	33 e0       	ldi	r19, 0x03	; 3
    14be:	40 e0       	ldi	r20, 0x00	; 0
    14c0:	50 e0       	ldi	r21, 0x00	; 0
    14c2:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    14c6:	0f 2e       	mov	r0, r31
    14c8:	ff ef       	ldi	r31, 0xFF	; 255
    14ca:	8f 2e       	mov	r8, r31
    14cc:	ff e0       	ldi	r31, 0x0F	; 15
    14ce:	9f 2e       	mov	r9, r31
    14d0:	f0 e0       	ldi	r31, 0x00	; 0
    14d2:	af 2e       	mov	r10, r31
    14d4:	f0 e0       	ldi	r31, 0x00	; 0
    14d6:	bf 2e       	mov	r11, r31
    14d8:	f0 2d       	mov	r31, r0
    14da:	a5 01       	movw	r20, r10
    14dc:	94 01       	movw	r18, r8
    14de:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    14e2:	c9 01       	movw	r24, r18
    14e4:	c2 97       	sbiw	r24, 0x32	; 50
    14e6:	ae 81       	ldd	r26, Y+6	; 0x06
    14e8:	bf 81       	ldd	r27, Y+7	; 0x07
    14ea:	8d 93       	st	X+, r24
    14ec:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    14ee:	c3 01       	movw	r24, r6
    14f0:	b2 01       	movw	r22, r4
    14f2:	28 ee       	ldi	r18, 0xE8	; 232
    14f4:	33 e0       	ldi	r19, 0x03	; 3
    14f6:	40 e0       	ldi	r20, 0x00	; 0
    14f8:	50 e0       	ldi	r21, 0x00	; 0
    14fa:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    14fe:	a5 01       	movw	r20, r10
    1500:	94 01       	movw	r18, r8
    1502:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    1506:	c9 01       	movw	r24, r18
    1508:	c2 97       	sbiw	r24, 0x32	; 50
    150a:	ea 85       	ldd	r30, Y+10	; 0x0a
    150c:	fb 85       	ldd	r31, Y+11	; 0x0b
    150e:	80 83       	st	Z, r24
    1510:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    1512:	6a 81       	ldd	r22, Y+2	; 0x02
    1514:	7b 81       	ldd	r23, Y+3	; 0x03
    1516:	8c 81       	ldd	r24, Y+4	; 0x04
    1518:	9d 81       	ldd	r25, Y+5	; 0x05
    151a:	28 ee       	ldi	r18, 0xE8	; 232
    151c:	33 e0       	ldi	r19, 0x03	; 3
    151e:	40 e0       	ldi	r20, 0x00	; 0
    1520:	50 e0       	ldi	r21, 0x00	; 0
    1522:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    1526:	a5 01       	movw	r20, r10
    1528:	94 01       	movw	r18, r8
    152a:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    152e:	22 53       	subi	r18, 0x32	; 50
    1530:	30 40       	sbci	r19, 0x00	; 0
    1532:	a8 85       	ldd	r26, Y+8	; 0x08
    1534:	b9 85       	ldd	r27, Y+9	; 0x09
    1536:	2d 93       	st	X+, r18
    1538:	3c 93       	st	X, r19
    153a:	11 97       	sbiw	r26, 0x01	; 1
}
    153c:	2b 96       	adiw	r28, 0x0b	; 11
    153e:	cd bf       	out	0x3d, r28	; 61
    1540:	de bf       	out	0x3e, r29	; 62
    1542:	df 91       	pop	r29
    1544:	cf 91       	pop	r28
    1546:	1f 91       	pop	r17
    1548:	0f 91       	pop	r16
    154a:	ff 90       	pop	r15
    154c:	ef 90       	pop	r14
    154e:	bf 90       	pop	r11
    1550:	af 90       	pop	r10
    1552:	9f 90       	pop	r9
    1554:	8f 90       	pop	r8
    1556:	7f 90       	pop	r7
    1558:	6f 90       	pop	r6
    155a:	5f 90       	pop	r5
    155c:	4f 90       	pop	r4
    155e:	08 95       	ret

00001560 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    1560:	cf 93       	push	r28
    1562:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    1564:	21 e0       	ldi	r18, 0x01	; 1
    1566:	30 e0       	ldi	r19, 0x00	; 0
    1568:	a9 01       	movw	r20, r18
    156a:	02 c0       	rjmp	.+4      	; 0x1570 <set_ampGain+0x10>
    156c:	44 0f       	add	r20, r20
    156e:	55 1f       	adc	r21, r21
    1570:	8a 95       	dec	r24
    1572:	e2 f7       	brpl	.-8      	; 0x156c <set_ampGain+0xc>
    1574:	ca 01       	movw	r24, r20
    1576:	61 e0       	ldi	r22, 0x01	; 1
    1578:	0e 94 49 05 	call	0xa92	; 0xa92 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    157c:	c0 ff       	sbrs	r28, 0
    157e:	05 c0       	rjmp	.+10     	; 0x158a <set_ampGain+0x2a>
    1580:	80 e4       	ldi	r24, 0x40	; 64
    1582:	e0 e0       	ldi	r30, 0x00	; 0
    1584:	f6 e0       	ldi	r31, 0x06	; 6
    1586:	85 83       	std	Z+5, r24	; 0x05
    1588:	04 c0       	rjmp	.+8      	; 0x1592 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    158a:	80 e4       	ldi	r24, 0x40	; 64
    158c:	e0 e0       	ldi	r30, 0x00	; 0
    158e:	f6 e0       	ldi	r31, 0x06	; 6
    1590:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1592:	c1 ff       	sbrs	r28, 1
    1594:	05 c0       	rjmp	.+10     	; 0x15a0 <set_ampGain+0x40>
    1596:	82 e0       	ldi	r24, 0x02	; 2
    1598:	e0 e2       	ldi	r30, 0x20	; 32
    159a:	f6 e0       	ldi	r31, 0x06	; 6
    159c:	85 83       	std	Z+5, r24	; 0x05
    159e:	04 c0       	rjmp	.+8      	; 0x15a8 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    15a0:	82 e0       	ldi	r24, 0x02	; 2
    15a2:	e0 e2       	ldi	r30, 0x20	; 32
    15a4:	f6 e0       	ldi	r31, 0x06	; 6
    15a6:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    15a8:	c2 ff       	sbrs	r28, 2
    15aa:	05 c0       	rjmp	.+10     	; 0x15b6 <set_ampGain+0x56>
    15ac:	84 e0       	ldi	r24, 0x04	; 4
    15ae:	e0 e2       	ldi	r30, 0x20	; 32
    15b0:	f6 e0       	ldi	r31, 0x06	; 6
    15b2:	85 83       	std	Z+5, r24	; 0x05
    15b4:	04 c0       	rjmp	.+8      	; 0x15be <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    15b6:	84 e0       	ldi	r24, 0x04	; 4
    15b8:	e0 e2       	ldi	r30, 0x20	; 32
    15ba:	f6 e0       	ldi	r31, 0x06	; 6
    15bc:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    15be:	5a e0       	ldi	r21, 0x0A	; 10
    15c0:	5a 95       	dec	r21
    15c2:	f1 f7       	brne	.-4      	; 0x15c0 <set_ampGain+0x60>
    15c4:	00 c0       	rjmp	.+0      	; 0x15c6 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    15c6:	8f ef       	ldi	r24, 0xFF	; 255
    15c8:	61 e0       	ldi	r22, 0x01	; 1
    15ca:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    15ce:	cf 91       	pop	r28
    15d0:	08 95       	ret

000015d2 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    15d2:	88 23       	and	r24, r24
    15d4:	31 f0       	breq	.+12     	; 0x15e2 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    15d6:	e0 e0       	ldi	r30, 0x00	; 0
    15d8:	f6 e0       	ldi	r31, 0x06	; 6
    15da:	80 e2       	ldi	r24, 0x20	; 32
    15dc:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    15de:	85 83       	std	Z+5, r24	; 0x05
    15e0:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    15e2:	e0 e0       	ldi	r30, 0x00	; 0
    15e4:	f6 e0       	ldi	r31, 0x06	; 6
    15e6:	80 e2       	ldi	r24, 0x20	; 32
    15e8:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    15ea:	82 83       	std	Z+2, r24	; 0x02
    15ec:	08 95       	ret

000015ee <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    15ee:	1f 92       	push	r1
    15f0:	0f 92       	push	r0
    15f2:	0f b6       	in	r0, 0x3f	; 63
    15f4:	0f 92       	push	r0
    15f6:	0b b6       	in	r0, 0x3b	; 59
    15f8:	0f 92       	push	r0
    15fa:	11 24       	eor	r1, r1
    15fc:	2f 93       	push	r18
    15fe:	3f 93       	push	r19
    1600:	4f 93       	push	r20
    1602:	5f 93       	push	r21
    1604:	6f 93       	push	r22
    1606:	7f 93       	push	r23
    1608:	8f 93       	push	r24
    160a:	9f 93       	push	r25
    160c:	af 93       	push	r26
    160e:	bf 93       	push	r27
    1610:	ef 93       	push	r30
    1612:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1614:	e0 e4       	ldi	r30, 0x40	; 64
    1616:	fa e0       	ldi	r31, 0x0A	; 10
    1618:	80 81       	ld	r24, Z
    161a:	80 7f       	andi	r24, 0xF0	; 240
    161c:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    161e:	a0 e0       	ldi	r26, 0x00	; 0
    1620:	b8 e0       	ldi	r27, 0x08	; 8
    1622:	8c 91       	ld	r24, X
    1624:	80 7f       	andi	r24, 0xF0	; 240
    1626:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1628:	a0 e0       	ldi	r26, 0x00	; 0
    162a:	b9 e0       	ldi	r27, 0x09	; 9
    162c:	8c 91       	ld	r24, X
    162e:	80 7f       	andi	r24, 0xF0	; 240
    1630:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1632:	80 81       	ld	r24, Z
    1634:	80 7f       	andi	r24, 0xF0	; 240
    1636:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    163a:	80 e0       	ldi	r24, 0x00	; 0
    163c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    1640:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	enableADCMUX(FALSE);
    1644:	80 e0       	ldi	r24, 0x00	; 0
    1646:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    164a:	81 e0       	ldi	r24, 0x01	; 1
    164c:	80 93 a7 50 	sts	0x50A7, r24
	DataAvailable = 1;
    1650:	80 93 48 3e 	sts	0x3E48, r24
}
    1654:	ff 91       	pop	r31
    1656:	ef 91       	pop	r30
    1658:	bf 91       	pop	r27
    165a:	af 91       	pop	r26
    165c:	9f 91       	pop	r25
    165e:	8f 91       	pop	r24
    1660:	7f 91       	pop	r23
    1662:	6f 91       	pop	r22
    1664:	5f 91       	pop	r21
    1666:	4f 91       	pop	r20
    1668:	3f 91       	pop	r19
    166a:	2f 91       	pop	r18
    166c:	0f 90       	pop	r0
    166e:	0b be       	out	0x3b, r0	; 59
    1670:	0f 90       	pop	r0
    1672:	0f be       	out	0x3f, r0	; 63
    1674:	0f 90       	pop	r0
    1676:	1f 90       	pop	r1
    1678:	18 95       	reti

0000167a <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    167a:	e0 e4       	ldi	r30, 0x40	; 64
    167c:	fa e0       	ldi	r31, 0x0A	; 10
    167e:	80 81       	ld	r24, Z
    1680:	80 7f       	andi	r24, 0xF0	; 240
    1682:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1684:	a0 e0       	ldi	r26, 0x00	; 0
    1686:	b8 e0       	ldi	r27, 0x08	; 8
    1688:	8c 91       	ld	r24, X
    168a:	80 7f       	andi	r24, 0xF0	; 240
    168c:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    168e:	a0 e0       	ldi	r26, 0x00	; 0
    1690:	b9 e0       	ldi	r27, 0x09	; 9
    1692:	8c 91       	ld	r24, X
    1694:	80 7f       	andi	r24, 0xF0	; 240
    1696:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1698:	80 81       	ld	r24, Z
    169a:	80 7f       	andi	r24, 0xF0	; 240
    169c:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    16a0:	80 e0       	ldi	r24, 0x00	; 0
    16a2:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    16a6:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	enableADCMUX(FALSE);
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	80 93 a7 50 	sts	0x50A7, r24
	DataAvailable = 1;
    16b6:	80 93 48 3e 	sts	0x3E48, r24
}
    16ba:	08 95       	ret

000016bc <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    16bc:	cf 93       	push	r28
    16be:	df 93       	push	r29
    16c0:	0f 92       	push	r0
    16c2:	0f 92       	push	r0
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    16c8:	80 91 a7 50 	lds	r24, 0x50A7
    16cc:	88 23       	and	r24, r24
    16ce:	89 f0       	breq	.+34     	; 0x16f2 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    16d0:	e0 e4       	ldi	r30, 0x40	; 64
    16d2:	f8 e0       	ldi	r31, 0x08	; 8
    16d4:	80 a1       	lds	r24, 0x40
    16d6:	91 a1       	lds	r25, 0x41
    16d8:	89 83       	std	Y+1, r24	; 0x01
    16da:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    16dc:	89 81       	ldd	r24, Y+1	; 0x01
    16de:	9a 81       	ldd	r25, Y+2	; 0x02
    16e0:	00 97       	sbiw	r24, 0x00	; 0
    16e2:	21 f4       	brne	.+8      	; 0x16ec <ADC_Get_Num_Samples+0x30>
    16e4:	86 a1       	lds	r24, 0x46
    16e6:	97 a1       	lds	r25, 0x47
    16e8:	89 83       	std	Y+1, r24	; 0x01
    16ea:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    16ec:	89 81       	ldd	r24, Y+1	; 0x01
    16ee:	9a 81       	ldd	r25, Y+2	; 0x02
    16f0:	02 c0       	rjmp	.+4      	; 0x16f6 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    16f2:	80 e0       	ldi	r24, 0x00	; 0
    16f4:	90 e0       	ldi	r25, 0x00	; 0
}
    16f6:	0f 90       	pop	r0
    16f8:	0f 90       	pop	r0
    16fa:	df 91       	pop	r29
    16fc:	cf 91       	pop	r28
    16fe:	08 95       	ret

00001700 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1700:	e0 ea       	ldi	r30, 0xA0	; 160
    1702:	f6 e0       	ldi	r31, 0x06	; 6
    1704:	13 86       	std	Z+11, r1	; 0x0b
}
    1706:	08 95       	ret

00001708 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1708:	81 e0       	ldi	r24, 0x01	; 1
    170a:	e0 ea       	ldi	r30, 0xA0	; 160
    170c:	f6 e0       	ldi	r31, 0x06	; 6
    170e:	83 87       	std	Z+11, r24	; 0x0b
}	
    1710:	08 95       	ret

00001712 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    1712:	1f 92       	push	r1
    1714:	0f 92       	push	r0
    1716:	0f b6       	in	r0, 0x3f	; 63
    1718:	0f 92       	push	r0
    171a:	0b b6       	in	r0, 0x3b	; 59
    171c:	0f 92       	push	r0
    171e:	11 24       	eor	r1, r1
    1720:	6f 92       	push	r6
    1722:	7f 92       	push	r7
    1724:	8f 92       	push	r8
    1726:	9f 92       	push	r9
    1728:	af 92       	push	r10
    172a:	bf 92       	push	r11
    172c:	cf 92       	push	r12
    172e:	df 92       	push	r13
    1730:	ef 92       	push	r14
    1732:	ff 92       	push	r15
    1734:	0f 93       	push	r16
    1736:	1f 93       	push	r17
    1738:	2f 93       	push	r18
    173a:	3f 93       	push	r19
    173c:	4f 93       	push	r20
    173e:	5f 93       	push	r21
    1740:	6f 93       	push	r22
    1742:	7f 93       	push	r23
    1744:	8f 93       	push	r24
    1746:	9f 93       	push	r25
    1748:	af 93       	push	r26
    174a:	bf 93       	push	r27
    174c:	ef 93       	push	r30
    174e:	ff 93       	push	r31
    1750:	cf 93       	push	r28
    1752:	df 93       	push	r29
    1754:	cd b7       	in	r28, 0x3d	; 61
    1756:	de b7       	in	r29, 0x3e	; 62
    1758:	2c 97       	sbiw	r28, 0x0c	; 12
    175a:	cd bf       	out	0x3d, r28	; 61
    175c:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    175e:	80 91 5d 40 	lds	r24, 0x405D
    1762:	88 23       	and	r24, r24
    1764:	8c f0       	brlt	.+34     	; 0x1788 <__vector_104+0x76>
		discardCount++;
    1766:	80 91 5d 40 	lds	r24, 0x405D
    176a:	8f 5f       	subi	r24, 0xFF	; 255
    176c:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
    1770:	80 91 5d 40 	lds	r24, 0x405D
    1774:	80 38       	cpi	r24, 0x80	; 128
    1776:	09 f0       	breq	.+2      	; 0x177a <__vector_104+0x68>
    1778:	e9 c0       	rjmp	.+466    	; 0x194c <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    177a:	e0 e4       	ldi	r30, 0x40	; 64
    177c:	f8 e0       	ldi	r31, 0x08	; 8
    177e:	80 81       	ld	r24, Z
    1780:	80 7f       	andi	r24, 0xF0	; 240
    1782:	89 60       	ori	r24, 0x09	; 9
    1784:	80 83       	st	Z, r24
    1786:	e2 c0       	rjmp	.+452    	; 0x194c <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    178e:	82 e0       	ldi	r24, 0x02	; 2
    1790:	e0 ea       	ldi	r30, 0xA0	; 160
    1792:	f6 e0       	ldi	r31, 0x06	; 6
    1794:	86 83       	std	Z+6, r24	; 0x06
    1796:	80 e0       	ldi	r24, 0x00	; 0
    1798:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    179a:	e0 ec       	ldi	r30, 0xC0	; 192
    179c:	f8 e0       	ldi	r31, 0x08	; 8
    179e:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    17a0:	21 e2       	ldi	r18, 0x21	; 33
    17a2:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    17a4:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    17a6:	42 81       	ldd	r20, Z+2	; 0x02
    17a8:	44 23       	and	r20, r20
    17aa:	ec f7       	brge	.-6      	; 0x17a6 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    17ac:	43 81       	ldd	r20, Z+3	; 0x03
    17ae:	d9 01       	movw	r26, r18
    17b0:	a8 0f       	add	r26, r24
    17b2:	b9 1f       	adc	r27, r25
    17b4:	4c 93       	st	X, r20
    17b6:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    17b8:	83 30       	cpi	r24, 0x03	; 3
    17ba:	91 05       	cpc	r25, r1
    17bc:	99 f7       	brne	.-26     	; 0x17a4 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    17be:	82 e0       	ldi	r24, 0x02	; 2
    17c0:	e0 ea       	ldi	r30, 0xA0	; 160
    17c2:	f6 e0       	ldi	r31, 0x06	; 6
    17c4:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    17cc:	80 91 21 3e 	lds	r24, 0x3E21
    17d0:	88 23       	and	r24, r24
    17d2:	1c f4       	brge	.+6      	; 0x17da <__vector_104+0xc8>
    17d4:	8f ef       	ldi	r24, 0xFF	; 255
    17d6:	8c 83       	std	Y+4, r24	; 0x04
    17d8:	01 c0       	rjmp	.+2      	; 0x17dc <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    17da:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    17dc:	80 91 21 3e 	lds	r24, 0x3E21
    17e0:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    17e2:	80 91 22 3e 	lds	r24, 0x3E22
    17e6:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    17e8:	80 91 23 3e 	lds	r24, 0x3E23
    17ec:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    17ee:	89 81       	ldd	r24, Y+1	; 0x01
    17f0:	9a 81       	ldd	r25, Y+2	; 0x02
    17f2:	ab 81       	ldd	r26, Y+3	; 0x03
    17f4:	bc 81       	ldd	r27, Y+4	; 0x04
    17f6:	ac 01       	movw	r20, r24
    17f8:	bd 01       	movw	r22, r26
    17fa:	77 0f       	add	r23, r23
    17fc:	44 0b       	sbc	r20, r20
    17fe:	54 2f       	mov	r21, r20
    1800:	ba 01       	movw	r22, r20
    1802:	8d 83       	std	Y+5, r24	; 0x05
    1804:	9e 83       	std	Y+6, r25	; 0x06
    1806:	af 83       	std	Y+7, r26	; 0x07
    1808:	b8 87       	std	Y+8, r27	; 0x08
    180a:	49 87       	std	Y+9, r20	; 0x09
    180c:	4a 87       	std	Y+10, r20	; 0x0a
    180e:	4b 87       	std	Y+11, r20	; 0x0b
    1810:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1812:	60 91 66 50 	lds	r22, 0x5066
    1816:	70 91 67 50 	lds	r23, 0x5067
    181a:	80 91 68 50 	lds	r24, 0x5068
    181e:	90 91 69 50 	lds	r25, 0x5069
    1822:	8d 80       	ldd	r8, Y+5	; 0x05
    1824:	1e 81       	ldd	r17, Y+6	; 0x06
    1826:	0f 81       	ldd	r16, Y+7	; 0x07
    1828:	f8 84       	ldd	r15, Y+8	; 0x08
    182a:	e9 84       	ldd	r14, Y+9	; 0x09
    182c:	da 84       	ldd	r13, Y+10	; 0x0a
    182e:	cb 84       	ldd	r12, Y+11	; 0x0b
    1830:	bc 84       	ldd	r11, Y+12	; 0x0c
    1832:	20 91 a8 50 	lds	r18, 0x50A8
    1836:	30 91 a9 50 	lds	r19, 0x50A9
    183a:	40 e0       	ldi	r20, 0x00	; 0
    183c:	50 e0       	ldi	r21, 0x00	; 0
    183e:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    1842:	66 0f       	add	r22, r22
    1844:	77 1f       	adc	r23, r23
    1846:	66 0f       	add	r22, r22
    1848:	77 1f       	adc	r23, r23
    184a:	80 91 64 50 	lds	r24, 0x5064
    184e:	90 91 65 50 	lds	r25, 0x5065
    1852:	3c 01       	movw	r6, r24
    1854:	66 0e       	add	r6, r22
    1856:	77 1e       	adc	r7, r23
    1858:	28 2d       	mov	r18, r8
    185a:	31 2f       	mov	r19, r17
    185c:	40 2f       	mov	r20, r16
    185e:	5f 2d       	mov	r21, r15
    1860:	6e 2d       	mov	r22, r14
    1862:	7d 2d       	mov	r23, r13
    1864:	8c 2d       	mov	r24, r12
    1866:	9b 2d       	mov	r25, r11
    1868:	0f 2e       	mov	r0, r31
    186a:	f0 ea       	ldi	r31, 0xA0	; 160
    186c:	af 2e       	mov	r10, r31
    186e:	f0 2d       	mov	r31, r0
    1870:	0f 2e       	mov	r0, r31
    1872:	f5 e2       	ldi	r31, 0x25	; 37
    1874:	bf 2e       	mov	r11, r31
    1876:	f0 2d       	mov	r31, r0
    1878:	0f 2e       	mov	r0, r31
    187a:	f6 e2       	ldi	r31, 0x26	; 38
    187c:	cf 2e       	mov	r12, r31
    187e:	f0 2d       	mov	r31, r0
    1880:	dd 24       	eor	r13, r13
    1882:	ee 24       	eor	r14, r14
    1884:	ff 24       	eor	r15, r15
    1886:	00 e0       	ldi	r16, 0x00	; 0
    1888:	10 e0       	ldi	r17, 0x00	; 0
    188a:	0e 94 9b 2c 	call	0x5936	; 0x5936 <__muldi3>
    188e:	aa 24       	eor	r10, r10
    1890:	aa 94       	dec	r10
    1892:	bb 24       	eor	r11, r11
    1894:	ba 94       	dec	r11
    1896:	0f 2e       	mov	r0, r31
    1898:	ff e7       	ldi	r31, 0x7F	; 127
    189a:	cf 2e       	mov	r12, r31
    189c:	f0 2d       	mov	r31, r0
    189e:	0e 94 4a 2e 	call	0x5c94	; 0x5c94 <__divdi3>
    18a2:	01 e0       	ldi	r16, 0x01	; 1
    18a4:	0e 94 6e 2d 	call	0x5adc	; 0x5adc <__ashldi3>
    18a8:	0f 2e       	mov	r0, r31
    18aa:	f3 e0       	ldi	r31, 0x03	; 3
    18ac:	af 2e       	mov	r10, r31
    18ae:	f0 2d       	mov	r31, r0
    18b0:	bb 24       	eor	r11, r11
    18b2:	cc 24       	eor	r12, r12
    18b4:	00 e0       	ldi	r16, 0x00	; 0
    18b6:	0e 94 4a 2e 	call	0x5c94	; 0x5c94 <__divdi3>
    18ba:	82 2e       	mov	r8, r18
    18bc:	93 2e       	mov	r9, r19
    18be:	a4 2e       	mov	r10, r20
    18c0:	b5 2e       	mov	r11, r21
    18c2:	b0 94       	com	r11
    18c4:	a0 94       	com	r10
    18c6:	90 94       	com	r9
    18c8:	80 94       	com	r8
    18ca:	81 1c       	adc	r8, r1
    18cc:	91 1c       	adc	r9, r1
    18ce:	a1 1c       	adc	r10, r1
    18d0:	b1 1c       	adc	r11, r1
    18d2:	f3 01       	movw	r30, r6
    18d4:	80 82       	st	Z, r8
    18d6:	91 82       	std	Z+1, r9	; 0x01
    18d8:	a2 82       	std	Z+2, r10	; 0x02
    18da:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    18dc:	80 91 49 40 	lds	r24, 0x4049
    18e0:	88 23       	and	r24, r24
    18e2:	09 f1       	breq	.+66     	; 0x1926 <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    18e4:	60 91 66 50 	lds	r22, 0x5066
    18e8:	70 91 67 50 	lds	r23, 0x5067
    18ec:	80 91 68 50 	lds	r24, 0x5068
    18f0:	90 91 69 50 	lds	r25, 0x5069
    18f4:	20 91 a8 50 	lds	r18, 0x50A8
    18f8:	30 91 a9 50 	lds	r19, 0x50A9
    18fc:	40 e0       	ldi	r20, 0x00	; 0
    18fe:	50 e0       	ldi	r21, 0x00	; 0
    1900:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    1904:	dc 01       	movw	r26, r24
    1906:	cb 01       	movw	r24, r22
    1908:	9c 01       	movw	r18, r24
    190a:	22 0f       	add	r18, r18
    190c:	33 1f       	adc	r19, r19
    190e:	22 0f       	add	r18, r18
    1910:	33 1f       	adc	r19, r19
    1912:	80 91 64 50 	lds	r24, 0x5064
    1916:	90 91 65 50 	lds	r25, 0x5065
    191a:	82 0f       	add	r24, r18
    191c:	93 1f       	adc	r25, r19
    191e:	64 e0       	ldi	r22, 0x04	; 4
    1920:	70 e0       	ldi	r23, 0x00	; 0
    1922:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    1926:	80 91 66 50 	lds	r24, 0x5066
    192a:	90 91 67 50 	lds	r25, 0x5067
    192e:	a0 91 68 50 	lds	r26, 0x5068
    1932:	b0 91 69 50 	lds	r27, 0x5069
    1936:	01 96       	adiw	r24, 0x01	; 1
    1938:	a1 1d       	adc	r26, r1
    193a:	b1 1d       	adc	r27, r1
    193c:	80 93 66 50 	sts	0x5066, r24
    1940:	90 93 67 50 	sts	0x5067, r25
    1944:	a0 93 68 50 	sts	0x5068, r26
    1948:	b0 93 69 50 	sts	0x5069, r27
	}
}
    194c:	2c 96       	adiw	r28, 0x0c	; 12
    194e:	cd bf       	out	0x3d, r28	; 61
    1950:	de bf       	out	0x3e, r29	; 62
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
    1956:	ff 91       	pop	r31
    1958:	ef 91       	pop	r30
    195a:	bf 91       	pop	r27
    195c:	af 91       	pop	r26
    195e:	9f 91       	pop	r25
    1960:	8f 91       	pop	r24
    1962:	7f 91       	pop	r23
    1964:	6f 91       	pop	r22
    1966:	5f 91       	pop	r21
    1968:	4f 91       	pop	r20
    196a:	3f 91       	pop	r19
    196c:	2f 91       	pop	r18
    196e:	1f 91       	pop	r17
    1970:	0f 91       	pop	r16
    1972:	ff 90       	pop	r15
    1974:	ef 90       	pop	r14
    1976:	df 90       	pop	r13
    1978:	cf 90       	pop	r12
    197a:	bf 90       	pop	r11
    197c:	af 90       	pop	r10
    197e:	9f 90       	pop	r9
    1980:	8f 90       	pop	r8
    1982:	7f 90       	pop	r7
    1984:	6f 90       	pop	r6
    1986:	0f 90       	pop	r0
    1988:	0b be       	out	0x3b, r0	; 59
    198a:	0f 90       	pop	r0
    198c:	0f be       	out	0x3f, r0	; 63
    198e:	0f 90       	pop	r0
    1990:	1f 90       	pop	r1
    1992:	18 95       	reti

00001994 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1994:	88 23       	and	r24, r24
    1996:	49 f0       	breq	.+18     	; 0x19aa <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1998:	80 e2       	ldi	r24, 0x20	; 32
    199a:	60 e0       	ldi	r22, 0x00	; 0
    199c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    19a0:	80 e2       	ldi	r24, 0x20	; 32
    19a2:	60 e0       	ldi	r22, 0x00	; 0
    19a4:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
    19a8:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    19aa:	80 e2       	ldi	r24, 0x20	; 32
    19ac:	60 e0       	ldi	r22, 0x00	; 0
    19ae:	0e 94 f5 05 	call	0xbea	; 0xbea <PortEx_DIRCLR>
    19b2:	08 95       	ret

000019b4 <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    19b4:	1f 92       	push	r1
    19b6:	0f 92       	push	r0
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	0f 92       	push	r0
    19bc:	0b b6       	in	r0, 0x3b	; 59
    19be:	0f 92       	push	r0
    19c0:	11 24       	eor	r1, r1
    19c2:	6f 92       	push	r6
    19c4:	7f 92       	push	r7
    19c6:	8f 92       	push	r8
    19c8:	9f 92       	push	r9
    19ca:	af 92       	push	r10
    19cc:	bf 92       	push	r11
    19ce:	cf 92       	push	r12
    19d0:	df 92       	push	r13
    19d2:	ef 92       	push	r14
    19d4:	ff 92       	push	r15
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	2f 93       	push	r18
    19dc:	3f 93       	push	r19
    19de:	4f 93       	push	r20
    19e0:	5f 93       	push	r21
    19e2:	6f 93       	push	r22
    19e4:	7f 93       	push	r23
    19e6:	8f 93       	push	r24
    19e8:	9f 93       	push	r25
    19ea:	af 93       	push	r26
    19ec:	bf 93       	push	r27
    19ee:	ef 93       	push	r30
    19f0:	ff 93       	push	r31
    19f2:	cf 93       	push	r28
    19f4:	df 93       	push	r29
    19f6:	cd b7       	in	r28, 0x3d	; 61
    19f8:	de b7       	in	r29, 0x3e	; 62
    19fa:	2c 97       	sbiw	r28, 0x0c	; 12
    19fc:	cd bf       	out	0x3d, r28	; 61
    19fe:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1a00:	19 82       	std	Y+1, r1	; 0x01
    1a02:	1a 82       	std	Y+2, r1	; 0x02
    1a04:	1b 82       	std	Y+3, r1	; 0x03
    1a06:	1c 82       	std	Y+4, r1	; 0x04
    1a08:	1d 82       	std	Y+5, r1	; 0x05
    1a0a:	1e 82       	std	Y+6, r1	; 0x06
    1a0c:	1f 82       	std	Y+7, r1	; 0x07
    1a0e:	18 86       	std	Y+8, r1	; 0x08
    1a10:	80 e0       	ldi	r24, 0x00	; 0
    1a12:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1a14:	21 e2       	ldi	r18, 0x21	; 33
    1a16:	3e e3       	ldi	r19, 0x3E	; 62
    1a18:	88 24       	eor	r8, r8
    1a1a:	8a 94       	dec	r8
    1a1c:	ac 01       	movw	r20, r24
    1a1e:	f9 01       	movw	r30, r18
    1a20:	e8 0f       	add	r30, r24
    1a22:	f9 1f       	adc	r31, r25
    1a24:	60 81       	ld	r22, Z
    1a26:	66 23       	and	r22, r22
    1a28:	14 f4       	brge	.+4      	; 0x1a2e <__vector_14+0x7a>
    1a2a:	8c 86       	std	Y+12, r8	; 0x0c
    1a2c:	01 c0       	rjmp	.+2      	; 0x1a30 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1a2e:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1a30:	42 0f       	add	r20, r18
    1a32:	53 1f       	adc	r21, r19
    1a34:	fa 01       	movw	r30, r20
    1a36:	40 81       	ld	r20, Z
    1a38:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1a3a:	fc 01       	movw	r30, r24
    1a3c:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1a3e:	e2 0f       	add	r30, r18
    1a40:	f3 1f       	adc	r31, r19
    1a42:	40 81       	ld	r20, Z
    1a44:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1a46:	fc 01       	movw	r30, r24
    1a48:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1a4a:	e2 0f       	add	r30, r18
    1a4c:	f3 1f       	adc	r31, r19
    1a4e:	40 81       	ld	r20, Z
    1a50:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1a52:	49 85       	ldd	r20, Y+9	; 0x09
    1a54:	5a 85       	ldd	r21, Y+10	; 0x0a
    1a56:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a58:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a5a:	a9 80       	ldd	r10, Y+1	; 0x01
    1a5c:	ba 80       	ldd	r11, Y+2	; 0x02
    1a5e:	cb 80       	ldd	r12, Y+3	; 0x03
    1a60:	dc 80       	ldd	r13, Y+4	; 0x04
    1a62:	ed 80       	ldd	r14, Y+5	; 0x05
    1a64:	fe 80       	ldd	r15, Y+6	; 0x06
    1a66:	0f 81       	ldd	r16, Y+7	; 0x07
    1a68:	18 85       	ldd	r17, Y+8	; 0x08
    1a6a:	b4 2f       	mov	r27, r20
    1a6c:	a5 2f       	mov	r26, r21
    1a6e:	f6 2f       	mov	r31, r22
    1a70:	e7 2f       	mov	r30, r23
    1a72:	77 0f       	add	r23, r23
    1a74:	44 0b       	sbc	r20, r20
    1a76:	54 2f       	mov	r21, r20
    1a78:	ba 01       	movw	r22, r20
    1a7a:	64 2e       	mov	r6, r20
    1a7c:	74 2e       	mov	r7, r20
    1a7e:	94 2e       	mov	r9, r20
    1a80:	ab 0e       	add	r10, r27
    1a82:	61 e0       	ldi	r22, 0x01	; 1
    1a84:	ab 16       	cp	r10, r27
    1a86:	08 f0       	brcs	.+2      	; 0x1a8a <__vector_14+0xd6>
    1a88:	60 e0       	ldi	r22, 0x00	; 0
    1a8a:	ba 0e       	add	r11, r26
    1a8c:	51 e0       	ldi	r21, 0x01	; 1
    1a8e:	ba 16       	cp	r11, r26
    1a90:	08 f0       	brcs	.+2      	; 0x1a94 <__vector_14+0xe0>
    1a92:	50 e0       	ldi	r21, 0x00	; 0
    1a94:	a6 2f       	mov	r26, r22
    1a96:	ab 0d       	add	r26, r11
    1a98:	61 e0       	ldi	r22, 0x01	; 1
    1a9a:	ab 15       	cp	r26, r11
    1a9c:	08 f0       	brcs	.+2      	; 0x1aa0 <__vector_14+0xec>
    1a9e:	60 e0       	ldi	r22, 0x00	; 0
    1aa0:	56 2b       	or	r21, r22
    1aa2:	cf 0e       	add	r12, r31
    1aa4:	61 e0       	ldi	r22, 0x01	; 1
    1aa6:	cf 16       	cp	r12, r31
    1aa8:	08 f0       	brcs	.+2      	; 0x1aac <__vector_14+0xf8>
    1aaa:	60 e0       	ldi	r22, 0x00	; 0
    1aac:	f5 2f       	mov	r31, r21
    1aae:	fc 0d       	add	r31, r12
    1ab0:	51 e0       	ldi	r21, 0x01	; 1
    1ab2:	fc 15       	cp	r31, r12
    1ab4:	08 f0       	brcs	.+2      	; 0x1ab8 <__vector_14+0x104>
    1ab6:	50 e0       	ldi	r21, 0x00	; 0
    1ab8:	65 2b       	or	r22, r21
    1aba:	de 0e       	add	r13, r30
    1abc:	51 e0       	ldi	r21, 0x01	; 1
    1abe:	de 16       	cp	r13, r30
    1ac0:	08 f0       	brcs	.+2      	; 0x1ac4 <__vector_14+0x110>
    1ac2:	50 e0       	ldi	r21, 0x00	; 0
    1ac4:	e6 2f       	mov	r30, r22
    1ac6:	ed 0d       	add	r30, r13
    1ac8:	61 e0       	ldi	r22, 0x01	; 1
    1aca:	ed 15       	cp	r30, r13
    1acc:	08 f0       	brcs	.+2      	; 0x1ad0 <__vector_14+0x11c>
    1ace:	60 e0       	ldi	r22, 0x00	; 0
    1ad0:	56 2b       	or	r21, r22
    1ad2:	e6 0c       	add	r14, r6
    1ad4:	71 e0       	ldi	r23, 0x01	; 1
    1ad6:	e6 14       	cp	r14, r6
    1ad8:	08 f0       	brcs	.+2      	; 0x1adc <__vector_14+0x128>
    1ada:	70 e0       	ldi	r23, 0x00	; 0
    1adc:	b5 2f       	mov	r27, r21
    1ade:	be 0d       	add	r27, r14
    1ae0:	51 e0       	ldi	r21, 0x01	; 1
    1ae2:	be 15       	cp	r27, r14
    1ae4:	08 f0       	brcs	.+2      	; 0x1ae8 <__vector_14+0x134>
    1ae6:	50 e0       	ldi	r21, 0x00	; 0
    1ae8:	75 2b       	or	r23, r21
    1aea:	f7 0c       	add	r15, r7
    1aec:	61 e0       	ldi	r22, 0x01	; 1
    1aee:	f7 14       	cp	r15, r7
    1af0:	08 f0       	brcs	.+2      	; 0x1af4 <__vector_14+0x140>
    1af2:	60 e0       	ldi	r22, 0x00	; 0
    1af4:	7f 0d       	add	r23, r15
    1af6:	51 e0       	ldi	r21, 0x01	; 1
    1af8:	7f 15       	cp	r23, r15
    1afa:	08 f0       	brcs	.+2      	; 0x1afe <__vector_14+0x14a>
    1afc:	50 e0       	ldi	r21, 0x00	; 0
    1afe:	65 2b       	or	r22, r21
    1b00:	09 0d       	add	r16, r9
    1b02:	51 e0       	ldi	r21, 0x01	; 1
    1b04:	09 15       	cp	r16, r9
    1b06:	08 f0       	brcs	.+2      	; 0x1b0a <__vector_14+0x156>
    1b08:	50 e0       	ldi	r21, 0x00	; 0
    1b0a:	60 0f       	add	r22, r16
    1b0c:	ff 24       	eor	r15, r15
    1b0e:	f3 94       	inc	r15
    1b10:	60 17       	cp	r22, r16
    1b12:	08 f0       	brcs	.+2      	; 0x1b16 <__vector_14+0x162>
    1b14:	ff 24       	eor	r15, r15
    1b16:	5f 29       	or	r21, r15
    1b18:	41 0f       	add	r20, r17
    1b1a:	54 0f       	add	r21, r20
    1b1c:	a9 82       	std	Y+1, r10	; 0x01
    1b1e:	aa 83       	std	Y+2, r26	; 0x02
    1b20:	fb 83       	std	Y+3, r31	; 0x03
    1b22:	ec 83       	std	Y+4, r30	; 0x04
    1b24:	bd 83       	std	Y+5, r27	; 0x05
    1b26:	7e 83       	std	Y+6, r23	; 0x06
    1b28:	6f 83       	std	Y+7, r22	; 0x07
    1b2a:	58 87       	std	Y+8, r21	; 0x08
    1b2c:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1b2e:	8c 30       	cpi	r24, 0x0C	; 12
    1b30:	91 05       	cpc	r25, r1
    1b32:	09 f0       	breq	.+2      	; 0x1b36 <__vector_14+0x182>
    1b34:	73 cf       	rjmp	.-282    	; 0x1a1c <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1b36:	e9 80       	ldd	r14, Y+1	; 0x01
    1b38:	fa 80       	ldd	r15, Y+2	; 0x02
    1b3a:	0b 81       	ldd	r16, Y+3	; 0x03
    1b3c:	1c 81       	ldd	r17, Y+4	; 0x04
    1b3e:	bd 81       	ldd	r27, Y+5	; 0x05
    1b40:	ae 81       	ldd	r26, Y+6	; 0x06
    1b42:	ff 81       	ldd	r31, Y+7	; 0x07
    1b44:	e8 85       	ldd	r30, Y+8	; 0x08
    1b46:	2e 2d       	mov	r18, r14
    1b48:	3f 2d       	mov	r19, r15
    1b4a:	40 2f       	mov	r20, r16
    1b4c:	51 2f       	mov	r21, r17
    1b4e:	6b 2f       	mov	r22, r27
    1b50:	7a 2f       	mov	r23, r26
    1b52:	8f 2f       	mov	r24, r31
    1b54:	9e 2f       	mov	r25, r30
    1b56:	ee 23       	and	r30, r30
    1b58:	0c f0       	brlt	.+2      	; 0x1b5c <__vector_14+0x1a8>
    1b5a:	4a c0       	rjmp	.+148    	; 0x1bf0 <__vector_14+0x23c>
    1b5c:	93 e0       	ldi	r25, 0x03	; 3
    1b5e:	e9 0e       	add	r14, r25
    1b60:	91 e0       	ldi	r25, 0x01	; 1
    1b62:	e2 16       	cp	r14, r18
    1b64:	08 f0       	brcs	.+2      	; 0x1b68 <__vector_14+0x1b4>
    1b66:	90 e0       	ldi	r25, 0x00	; 0
    1b68:	21 e0       	ldi	r18, 0x01	; 1
    1b6a:	f3 16       	cp	r15, r19
    1b6c:	08 f0       	brcs	.+2      	; 0x1b70 <__vector_14+0x1bc>
    1b6e:	20 e0       	ldi	r18, 0x00	; 0
    1b70:	39 2f       	mov	r19, r25
    1b72:	3f 0d       	add	r19, r15
    1b74:	91 e0       	ldi	r25, 0x01	; 1
    1b76:	3f 15       	cp	r19, r15
    1b78:	08 f0       	brcs	.+2      	; 0x1b7c <__vector_14+0x1c8>
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	29 2b       	or	r18, r25
    1b7e:	91 e0       	ldi	r25, 0x01	; 1
    1b80:	04 17       	cp	r16, r20
    1b82:	08 f0       	brcs	.+2      	; 0x1b86 <__vector_14+0x1d2>
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	42 2f       	mov	r20, r18
    1b88:	40 0f       	add	r20, r16
    1b8a:	21 e0       	ldi	r18, 0x01	; 1
    1b8c:	40 17       	cp	r20, r16
    1b8e:	08 f0       	brcs	.+2      	; 0x1b92 <__vector_14+0x1de>
    1b90:	20 e0       	ldi	r18, 0x00	; 0
    1b92:	92 2b       	or	r25, r18
    1b94:	21 e0       	ldi	r18, 0x01	; 1
    1b96:	15 17       	cp	r17, r21
    1b98:	08 f0       	brcs	.+2      	; 0x1b9c <__vector_14+0x1e8>
    1b9a:	20 e0       	ldi	r18, 0x00	; 0
    1b9c:	59 2f       	mov	r21, r25
    1b9e:	51 0f       	add	r21, r17
    1ba0:	91 e0       	ldi	r25, 0x01	; 1
    1ba2:	51 17       	cp	r21, r17
    1ba4:	08 f0       	brcs	.+2      	; 0x1ba8 <__vector_14+0x1f4>
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	29 2b       	or	r18, r25
    1baa:	91 e0       	ldi	r25, 0x01	; 1
    1bac:	b6 17       	cp	r27, r22
    1bae:	08 f0       	brcs	.+2      	; 0x1bb2 <__vector_14+0x1fe>
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	62 2f       	mov	r22, r18
    1bb4:	6b 0f       	add	r22, r27
    1bb6:	21 e0       	ldi	r18, 0x01	; 1
    1bb8:	6b 17       	cp	r22, r27
    1bba:	08 f0       	brcs	.+2      	; 0x1bbe <__vector_14+0x20a>
    1bbc:	20 e0       	ldi	r18, 0x00	; 0
    1bbe:	92 2b       	or	r25, r18
    1bc0:	21 e0       	ldi	r18, 0x01	; 1
    1bc2:	a7 17       	cp	r26, r23
    1bc4:	08 f0       	brcs	.+2      	; 0x1bc8 <__vector_14+0x214>
    1bc6:	20 e0       	ldi	r18, 0x00	; 0
    1bc8:	79 2f       	mov	r23, r25
    1bca:	7a 0f       	add	r23, r26
    1bcc:	91 e0       	ldi	r25, 0x01	; 1
    1bce:	7a 17       	cp	r23, r26
    1bd0:	08 f0       	brcs	.+2      	; 0x1bd4 <__vector_14+0x220>
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	29 2b       	or	r18, r25
    1bd6:	91 e0       	ldi	r25, 0x01	; 1
    1bd8:	f8 17       	cp	r31, r24
    1bda:	08 f0       	brcs	.+2      	; 0x1bde <__vector_14+0x22a>
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	82 2f       	mov	r24, r18
    1be0:	8f 0f       	add	r24, r31
    1be2:	21 e0       	ldi	r18, 0x01	; 1
    1be4:	8f 17       	cp	r24, r31
    1be6:	08 f0       	brcs	.+2      	; 0x1bea <__vector_14+0x236>
    1be8:	20 e0       	ldi	r18, 0x00	; 0
    1bea:	92 2b       	or	r25, r18
    1bec:	2e 2d       	mov	r18, r14
    1bee:	9e 0f       	add	r25, r30
    1bf0:	02 e0       	ldi	r16, 0x02	; 2
    1bf2:	0e 94 e2 2d 	call	0x5bc4	; 0x5bc4 <__ashrdi3>
    1bf6:	29 83       	std	Y+1, r18	; 0x01
    1bf8:	3a 83       	std	Y+2, r19	; 0x02
    1bfa:	4b 83       	std	Y+3, r20	; 0x03
    1bfc:	5c 83       	std	Y+4, r21	; 0x04
    1bfe:	6d 83       	std	Y+5, r22	; 0x05
    1c00:	7e 83       	std	Y+6, r23	; 0x06
    1c02:	8f 83       	std	Y+7, r24	; 0x07
    1c04:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1c06:	60 91 66 50 	lds	r22, 0x5066
    1c0a:	70 91 67 50 	lds	r23, 0x5067
    1c0e:	80 91 68 50 	lds	r24, 0x5068
    1c12:	90 91 69 50 	lds	r25, 0x5069
    1c16:	19 81       	ldd	r17, Y+1	; 0x01
    1c18:	0a 81       	ldd	r16, Y+2	; 0x02
    1c1a:	fb 80       	ldd	r15, Y+3	; 0x03
    1c1c:	ec 80       	ldd	r14, Y+4	; 0x04
    1c1e:	dd 80       	ldd	r13, Y+5	; 0x05
    1c20:	ce 80       	ldd	r12, Y+6	; 0x06
    1c22:	bf 80       	ldd	r11, Y+7	; 0x07
    1c24:	a8 84       	ldd	r10, Y+8	; 0x08
    1c26:	20 91 a8 50 	lds	r18, 0x50A8
    1c2a:	30 91 a9 50 	lds	r19, 0x50A9
    1c2e:	40 e0       	ldi	r20, 0x00	; 0
    1c30:	50 e0       	ldi	r21, 0x00	; 0
    1c32:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    1c36:	dc 01       	movw	r26, r24
    1c38:	cb 01       	movw	r24, r22
    1c3a:	88 0f       	add	r24, r24
    1c3c:	99 1f       	adc	r25, r25
    1c3e:	88 0f       	add	r24, r24
    1c40:	99 1f       	adc	r25, r25
    1c42:	80 90 64 50 	lds	r8, 0x5064
    1c46:	90 90 65 50 	lds	r9, 0x5065
    1c4a:	88 0e       	add	r8, r24
    1c4c:	99 1e       	adc	r9, r25
    1c4e:	21 2f       	mov	r18, r17
    1c50:	30 2f       	mov	r19, r16
    1c52:	4f 2d       	mov	r20, r15
    1c54:	5e 2d       	mov	r21, r14
    1c56:	6d 2d       	mov	r22, r13
    1c58:	7c 2d       	mov	r23, r12
    1c5a:	8b 2d       	mov	r24, r11
    1c5c:	9a 2d       	mov	r25, r10
    1c5e:	0f 2e       	mov	r0, r31
    1c60:	f0 ea       	ldi	r31, 0xA0	; 160
    1c62:	af 2e       	mov	r10, r31
    1c64:	f0 2d       	mov	r31, r0
    1c66:	0f 2e       	mov	r0, r31
    1c68:	f5 e2       	ldi	r31, 0x25	; 37
    1c6a:	bf 2e       	mov	r11, r31
    1c6c:	f0 2d       	mov	r31, r0
    1c6e:	0f 2e       	mov	r0, r31
    1c70:	f6 e2       	ldi	r31, 0x26	; 38
    1c72:	cf 2e       	mov	r12, r31
    1c74:	f0 2d       	mov	r31, r0
    1c76:	dd 24       	eor	r13, r13
    1c78:	ee 24       	eor	r14, r14
    1c7a:	ff 24       	eor	r15, r15
    1c7c:	00 e0       	ldi	r16, 0x00	; 0
    1c7e:	10 e0       	ldi	r17, 0x00	; 0
    1c80:	0e 94 9b 2c 	call	0x5936	; 0x5936 <__muldi3>
    1c84:	aa 24       	eor	r10, r10
    1c86:	aa 94       	dec	r10
    1c88:	bb 24       	eor	r11, r11
    1c8a:	ba 94       	dec	r11
    1c8c:	0f 2e       	mov	r0, r31
    1c8e:	ff e7       	ldi	r31, 0x7F	; 127
    1c90:	cf 2e       	mov	r12, r31
    1c92:	f0 2d       	mov	r31, r0
    1c94:	0e 94 4a 2e 	call	0x5c94	; 0x5c94 <__divdi3>
    1c98:	01 e0       	ldi	r16, 0x01	; 1
    1c9a:	0e 94 6e 2d 	call	0x5adc	; 0x5adc <__ashldi3>
    1c9e:	0f 2e       	mov	r0, r31
    1ca0:	f3 e0       	ldi	r31, 0x03	; 3
    1ca2:	af 2e       	mov	r10, r31
    1ca4:	f0 2d       	mov	r31, r0
    1ca6:	bb 24       	eor	r11, r11
    1ca8:	cc 24       	eor	r12, r12
    1caa:	00 e0       	ldi	r16, 0x00	; 0
    1cac:	0e 94 4a 2e 	call	0x5c94	; 0x5c94 <__divdi3>
    1cb0:	f4 01       	movw	r30, r8
    1cb2:	20 83       	st	Z, r18
    1cb4:	31 83       	std	Z+1, r19	; 0x01
    1cb6:	42 83       	std	Z+2, r20	; 0x02
    1cb8:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    1cba:	80 91 49 40 	lds	r24, 0x4049
    1cbe:	88 23       	and	r24, r24
    1cc0:	09 f1       	breq	.+66     	; 0x1d04 <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1cc2:	60 91 66 50 	lds	r22, 0x5066
    1cc6:	70 91 67 50 	lds	r23, 0x5067
    1cca:	80 91 68 50 	lds	r24, 0x5068
    1cce:	90 91 69 50 	lds	r25, 0x5069
    1cd2:	20 91 a8 50 	lds	r18, 0x50A8
    1cd6:	30 91 a9 50 	lds	r19, 0x50A9
    1cda:	40 e0       	ldi	r20, 0x00	; 0
    1cdc:	50 e0       	ldi	r21, 0x00	; 0
    1cde:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    1ce2:	dc 01       	movw	r26, r24
    1ce4:	cb 01       	movw	r24, r22
    1ce6:	9c 01       	movw	r18, r24
    1ce8:	22 0f       	add	r18, r18
    1cea:	33 1f       	adc	r19, r19
    1cec:	22 0f       	add	r18, r18
    1cee:	33 1f       	adc	r19, r19
    1cf0:	80 91 64 50 	lds	r24, 0x5064
    1cf4:	90 91 65 50 	lds	r25, 0x5065
    1cf8:	82 0f       	add	r24, r18
    1cfa:	93 1f       	adc	r25, r19
    1cfc:	64 e0       	ldi	r22, 0x04	; 4
    1cfe:	70 e0       	ldi	r23, 0x00	; 0
    1d00:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    1d04:	80 91 66 50 	lds	r24, 0x5066
    1d08:	90 91 67 50 	lds	r25, 0x5067
    1d0c:	a0 91 68 50 	lds	r26, 0x5068
    1d10:	b0 91 69 50 	lds	r27, 0x5069
    1d14:	01 96       	adiw	r24, 0x01	; 1
    1d16:	a1 1d       	adc	r26, r1
    1d18:	b1 1d       	adc	r27, r1
    1d1a:	80 93 66 50 	sts	0x5066, r24
    1d1e:	90 93 67 50 	sts	0x5067, r25
    1d22:	a0 93 68 50 	sts	0x5068, r26
    1d26:	b0 93 69 50 	sts	0x5069, r27

}
    1d2a:	2c 96       	adiw	r28, 0x0c	; 12
    1d2c:	cd bf       	out	0x3d, r28	; 61
    1d2e:	de bf       	out	0x3e, r29	; 62
    1d30:	df 91       	pop	r29
    1d32:	cf 91       	pop	r28
    1d34:	ff 91       	pop	r31
    1d36:	ef 91       	pop	r30
    1d38:	bf 91       	pop	r27
    1d3a:	af 91       	pop	r26
    1d3c:	9f 91       	pop	r25
    1d3e:	8f 91       	pop	r24
    1d40:	7f 91       	pop	r23
    1d42:	6f 91       	pop	r22
    1d44:	5f 91       	pop	r21
    1d46:	4f 91       	pop	r20
    1d48:	3f 91       	pop	r19
    1d4a:	2f 91       	pop	r18
    1d4c:	1f 91       	pop	r17
    1d4e:	0f 91       	pop	r16
    1d50:	ff 90       	pop	r15
    1d52:	ef 90       	pop	r14
    1d54:	df 90       	pop	r13
    1d56:	cf 90       	pop	r12
    1d58:	bf 90       	pop	r11
    1d5a:	af 90       	pop	r10
    1d5c:	9f 90       	pop	r9
    1d5e:	8f 90       	pop	r8
    1d60:	7f 90       	pop	r7
    1d62:	6f 90       	pop	r6
    1d64:	0f 90       	pop	r0
    1d66:	0b be       	out	0x3b, r0	; 59
    1d68:	0f 90       	pop	r0
    1d6a:	0f be       	out	0x3f, r0	; 63
    1d6c:	0f 90       	pop	r0
    1d6e:	1f 90       	pop	r1
    1d70:	18 95       	reti

00001d72 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1d72:	1f 92       	push	r1
    1d74:	0f 92       	push	r0
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	0f 92       	push	r0
    1d7a:	0b b6       	in	r0, 0x3b	; 59
    1d7c:	0f 92       	push	r0
    1d7e:	11 24       	eor	r1, r1
    1d80:	6f 92       	push	r6
    1d82:	7f 92       	push	r7
    1d84:	8f 92       	push	r8
    1d86:	9f 92       	push	r9
    1d88:	af 92       	push	r10
    1d8a:	bf 92       	push	r11
    1d8c:	cf 92       	push	r12
    1d8e:	df 92       	push	r13
    1d90:	ef 92       	push	r14
    1d92:	ff 92       	push	r15
    1d94:	0f 93       	push	r16
    1d96:	1f 93       	push	r17
    1d98:	2f 93       	push	r18
    1d9a:	3f 93       	push	r19
    1d9c:	4f 93       	push	r20
    1d9e:	5f 93       	push	r21
    1da0:	6f 93       	push	r22
    1da2:	7f 93       	push	r23
    1da4:	8f 93       	push	r24
    1da6:	9f 93       	push	r25
    1da8:	af 93       	push	r26
    1daa:	bf 93       	push	r27
    1dac:	ef 93       	push	r30
    1dae:	ff 93       	push	r31
    1db0:	cf 93       	push	r28
    1db2:	df 93       	push	r29
    1db4:	cd b7       	in	r28, 0x3d	; 61
    1db6:	de b7       	in	r29, 0x3e	; 62
    1db8:	2c 97       	sbiw	r28, 0x0c	; 12
    1dba:	cd bf       	out	0x3d, r28	; 61
    1dbc:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    1dbe:	19 82       	std	Y+1, r1	; 0x01
    1dc0:	1a 82       	std	Y+2, r1	; 0x02
    1dc2:	1b 82       	std	Y+3, r1	; 0x03
    1dc4:	1c 82       	std	Y+4, r1	; 0x04
    1dc6:	1d 82       	std	Y+5, r1	; 0x05
    1dc8:	1e 82       	std	Y+6, r1	; 0x06
    1dca:	1f 82       	std	Y+7, r1	; 0x07
    1dcc:	18 86       	std	Y+8, r1	; 0x08
    1dce:	80 e0       	ldi	r24, 0x00	; 0
    1dd0:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1dd2:	21 e2       	ldi	r18, 0x21	; 33
    1dd4:	3e e3       	ldi	r19, 0x3E	; 62
    1dd6:	88 24       	eor	r8, r8
    1dd8:	8a 94       	dec	r8
    1dda:	ac 01       	movw	r20, r24
    1ddc:	f9 01       	movw	r30, r18
    1dde:	e8 0f       	add	r30, r24
    1de0:	f9 1f       	adc	r31, r25
    1de2:	60 81       	ld	r22, Z
    1de4:	66 23       	and	r22, r22
    1de6:	14 f4       	brge	.+4      	; 0x1dec <__vector_77+0x7a>
    1de8:	8c 86       	std	Y+12, r8	; 0x0c
    1dea:	01 c0       	rjmp	.+2      	; 0x1dee <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1dec:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1dee:	42 0f       	add	r20, r18
    1df0:	53 1f       	adc	r21, r19
    1df2:	fa 01       	movw	r30, r20
    1df4:	40 81       	ld	r20, Z
    1df6:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1df8:	fc 01       	movw	r30, r24
    1dfa:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1dfc:	e2 0f       	add	r30, r18
    1dfe:	f3 1f       	adc	r31, r19
    1e00:	40 81       	ld	r20, Z
    1e02:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1e04:	fc 01       	movw	r30, r24
    1e06:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1e08:	e2 0f       	add	r30, r18
    1e0a:	f3 1f       	adc	r31, r19
    1e0c:	40 81       	ld	r20, Z
    1e0e:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1e10:	49 85       	ldd	r20, Y+9	; 0x09
    1e12:	5a 85       	ldd	r21, Y+10	; 0x0a
    1e14:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e16:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e18:	a9 80       	ldd	r10, Y+1	; 0x01
    1e1a:	ba 80       	ldd	r11, Y+2	; 0x02
    1e1c:	cb 80       	ldd	r12, Y+3	; 0x03
    1e1e:	dc 80       	ldd	r13, Y+4	; 0x04
    1e20:	ed 80       	ldd	r14, Y+5	; 0x05
    1e22:	fe 80       	ldd	r15, Y+6	; 0x06
    1e24:	0f 81       	ldd	r16, Y+7	; 0x07
    1e26:	18 85       	ldd	r17, Y+8	; 0x08
    1e28:	b4 2f       	mov	r27, r20
    1e2a:	a5 2f       	mov	r26, r21
    1e2c:	f6 2f       	mov	r31, r22
    1e2e:	e7 2f       	mov	r30, r23
    1e30:	77 0f       	add	r23, r23
    1e32:	44 0b       	sbc	r20, r20
    1e34:	54 2f       	mov	r21, r20
    1e36:	ba 01       	movw	r22, r20
    1e38:	64 2e       	mov	r6, r20
    1e3a:	74 2e       	mov	r7, r20
    1e3c:	94 2e       	mov	r9, r20
    1e3e:	ab 0e       	add	r10, r27
    1e40:	61 e0       	ldi	r22, 0x01	; 1
    1e42:	ab 16       	cp	r10, r27
    1e44:	08 f0       	brcs	.+2      	; 0x1e48 <__vector_77+0xd6>
    1e46:	60 e0       	ldi	r22, 0x00	; 0
    1e48:	ba 0e       	add	r11, r26
    1e4a:	51 e0       	ldi	r21, 0x01	; 1
    1e4c:	ba 16       	cp	r11, r26
    1e4e:	08 f0       	brcs	.+2      	; 0x1e52 <__vector_77+0xe0>
    1e50:	50 e0       	ldi	r21, 0x00	; 0
    1e52:	a6 2f       	mov	r26, r22
    1e54:	ab 0d       	add	r26, r11
    1e56:	61 e0       	ldi	r22, 0x01	; 1
    1e58:	ab 15       	cp	r26, r11
    1e5a:	08 f0       	brcs	.+2      	; 0x1e5e <__vector_77+0xec>
    1e5c:	60 e0       	ldi	r22, 0x00	; 0
    1e5e:	56 2b       	or	r21, r22
    1e60:	cf 0e       	add	r12, r31
    1e62:	61 e0       	ldi	r22, 0x01	; 1
    1e64:	cf 16       	cp	r12, r31
    1e66:	08 f0       	brcs	.+2      	; 0x1e6a <__vector_77+0xf8>
    1e68:	60 e0       	ldi	r22, 0x00	; 0
    1e6a:	f5 2f       	mov	r31, r21
    1e6c:	fc 0d       	add	r31, r12
    1e6e:	51 e0       	ldi	r21, 0x01	; 1
    1e70:	fc 15       	cp	r31, r12
    1e72:	08 f0       	brcs	.+2      	; 0x1e76 <__vector_77+0x104>
    1e74:	50 e0       	ldi	r21, 0x00	; 0
    1e76:	65 2b       	or	r22, r21
    1e78:	de 0e       	add	r13, r30
    1e7a:	51 e0       	ldi	r21, 0x01	; 1
    1e7c:	de 16       	cp	r13, r30
    1e7e:	08 f0       	brcs	.+2      	; 0x1e82 <__vector_77+0x110>
    1e80:	50 e0       	ldi	r21, 0x00	; 0
    1e82:	e6 2f       	mov	r30, r22
    1e84:	ed 0d       	add	r30, r13
    1e86:	61 e0       	ldi	r22, 0x01	; 1
    1e88:	ed 15       	cp	r30, r13
    1e8a:	08 f0       	brcs	.+2      	; 0x1e8e <__vector_77+0x11c>
    1e8c:	60 e0       	ldi	r22, 0x00	; 0
    1e8e:	56 2b       	or	r21, r22
    1e90:	e6 0c       	add	r14, r6
    1e92:	71 e0       	ldi	r23, 0x01	; 1
    1e94:	e6 14       	cp	r14, r6
    1e96:	08 f0       	brcs	.+2      	; 0x1e9a <__vector_77+0x128>
    1e98:	70 e0       	ldi	r23, 0x00	; 0
    1e9a:	b5 2f       	mov	r27, r21
    1e9c:	be 0d       	add	r27, r14
    1e9e:	51 e0       	ldi	r21, 0x01	; 1
    1ea0:	be 15       	cp	r27, r14
    1ea2:	08 f0       	brcs	.+2      	; 0x1ea6 <__vector_77+0x134>
    1ea4:	50 e0       	ldi	r21, 0x00	; 0
    1ea6:	75 2b       	or	r23, r21
    1ea8:	f7 0c       	add	r15, r7
    1eaa:	61 e0       	ldi	r22, 0x01	; 1
    1eac:	f7 14       	cp	r15, r7
    1eae:	08 f0       	brcs	.+2      	; 0x1eb2 <__vector_77+0x140>
    1eb0:	60 e0       	ldi	r22, 0x00	; 0
    1eb2:	7f 0d       	add	r23, r15
    1eb4:	51 e0       	ldi	r21, 0x01	; 1
    1eb6:	7f 15       	cp	r23, r15
    1eb8:	08 f0       	brcs	.+2      	; 0x1ebc <__vector_77+0x14a>
    1eba:	50 e0       	ldi	r21, 0x00	; 0
    1ebc:	65 2b       	or	r22, r21
    1ebe:	09 0d       	add	r16, r9
    1ec0:	51 e0       	ldi	r21, 0x01	; 1
    1ec2:	09 15       	cp	r16, r9
    1ec4:	08 f0       	brcs	.+2      	; 0x1ec8 <__vector_77+0x156>
    1ec6:	50 e0       	ldi	r21, 0x00	; 0
    1ec8:	60 0f       	add	r22, r16
    1eca:	ff 24       	eor	r15, r15
    1ecc:	f3 94       	inc	r15
    1ece:	60 17       	cp	r22, r16
    1ed0:	08 f0       	brcs	.+2      	; 0x1ed4 <__vector_77+0x162>
    1ed2:	ff 24       	eor	r15, r15
    1ed4:	5f 29       	or	r21, r15
    1ed6:	41 0f       	add	r20, r17
    1ed8:	54 0f       	add	r21, r20
    1eda:	a9 82       	std	Y+1, r10	; 0x01
    1edc:	aa 83       	std	Y+2, r26	; 0x02
    1ede:	fb 83       	std	Y+3, r31	; 0x03
    1ee0:	ec 83       	std	Y+4, r30	; 0x04
    1ee2:	bd 83       	std	Y+5, r27	; 0x05
    1ee4:	7e 83       	std	Y+6, r23	; 0x06
    1ee6:	6f 83       	std	Y+7, r22	; 0x07
    1ee8:	58 87       	std	Y+8, r21	; 0x08
    1eea:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1eec:	8c 30       	cpi	r24, 0x0C	; 12
    1eee:	91 05       	cpc	r25, r1
    1ef0:	09 f0       	breq	.+2      	; 0x1ef4 <__vector_77+0x182>
    1ef2:	73 cf       	rjmp	.-282    	; 0x1dda <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1ef4:	e9 80       	ldd	r14, Y+1	; 0x01
    1ef6:	fa 80       	ldd	r15, Y+2	; 0x02
    1ef8:	0b 81       	ldd	r16, Y+3	; 0x03
    1efa:	1c 81       	ldd	r17, Y+4	; 0x04
    1efc:	bd 81       	ldd	r27, Y+5	; 0x05
    1efe:	ae 81       	ldd	r26, Y+6	; 0x06
    1f00:	ff 81       	ldd	r31, Y+7	; 0x07
    1f02:	e8 85       	ldd	r30, Y+8	; 0x08
    1f04:	2e 2d       	mov	r18, r14
    1f06:	3f 2d       	mov	r19, r15
    1f08:	40 2f       	mov	r20, r16
    1f0a:	51 2f       	mov	r21, r17
    1f0c:	6b 2f       	mov	r22, r27
    1f0e:	7a 2f       	mov	r23, r26
    1f10:	8f 2f       	mov	r24, r31
    1f12:	9e 2f       	mov	r25, r30
    1f14:	ee 23       	and	r30, r30
    1f16:	0c f0       	brlt	.+2      	; 0x1f1a <__vector_77+0x1a8>
    1f18:	4a c0       	rjmp	.+148    	; 0x1fae <__vector_77+0x23c>
    1f1a:	93 e0       	ldi	r25, 0x03	; 3
    1f1c:	e9 0e       	add	r14, r25
    1f1e:	91 e0       	ldi	r25, 0x01	; 1
    1f20:	e2 16       	cp	r14, r18
    1f22:	08 f0       	brcs	.+2      	; 0x1f26 <__vector_77+0x1b4>
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	21 e0       	ldi	r18, 0x01	; 1
    1f28:	f3 16       	cp	r15, r19
    1f2a:	08 f0       	brcs	.+2      	; 0x1f2e <__vector_77+0x1bc>
    1f2c:	20 e0       	ldi	r18, 0x00	; 0
    1f2e:	39 2f       	mov	r19, r25
    1f30:	3f 0d       	add	r19, r15
    1f32:	91 e0       	ldi	r25, 0x01	; 1
    1f34:	3f 15       	cp	r19, r15
    1f36:	08 f0       	brcs	.+2      	; 0x1f3a <__vector_77+0x1c8>
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	29 2b       	or	r18, r25
    1f3c:	91 e0       	ldi	r25, 0x01	; 1
    1f3e:	04 17       	cp	r16, r20
    1f40:	08 f0       	brcs	.+2      	; 0x1f44 <__vector_77+0x1d2>
    1f42:	90 e0       	ldi	r25, 0x00	; 0
    1f44:	42 2f       	mov	r20, r18
    1f46:	40 0f       	add	r20, r16
    1f48:	21 e0       	ldi	r18, 0x01	; 1
    1f4a:	40 17       	cp	r20, r16
    1f4c:	08 f0       	brcs	.+2      	; 0x1f50 <__vector_77+0x1de>
    1f4e:	20 e0       	ldi	r18, 0x00	; 0
    1f50:	92 2b       	or	r25, r18
    1f52:	21 e0       	ldi	r18, 0x01	; 1
    1f54:	15 17       	cp	r17, r21
    1f56:	08 f0       	brcs	.+2      	; 0x1f5a <__vector_77+0x1e8>
    1f58:	20 e0       	ldi	r18, 0x00	; 0
    1f5a:	59 2f       	mov	r21, r25
    1f5c:	51 0f       	add	r21, r17
    1f5e:	91 e0       	ldi	r25, 0x01	; 1
    1f60:	51 17       	cp	r21, r17
    1f62:	08 f0       	brcs	.+2      	; 0x1f66 <__vector_77+0x1f4>
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	29 2b       	or	r18, r25
    1f68:	91 e0       	ldi	r25, 0x01	; 1
    1f6a:	b6 17       	cp	r27, r22
    1f6c:	08 f0       	brcs	.+2      	; 0x1f70 <__vector_77+0x1fe>
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	62 2f       	mov	r22, r18
    1f72:	6b 0f       	add	r22, r27
    1f74:	21 e0       	ldi	r18, 0x01	; 1
    1f76:	6b 17       	cp	r22, r27
    1f78:	08 f0       	brcs	.+2      	; 0x1f7c <__vector_77+0x20a>
    1f7a:	20 e0       	ldi	r18, 0x00	; 0
    1f7c:	92 2b       	or	r25, r18
    1f7e:	21 e0       	ldi	r18, 0x01	; 1
    1f80:	a7 17       	cp	r26, r23
    1f82:	08 f0       	brcs	.+2      	; 0x1f86 <__vector_77+0x214>
    1f84:	20 e0       	ldi	r18, 0x00	; 0
    1f86:	79 2f       	mov	r23, r25
    1f88:	7a 0f       	add	r23, r26
    1f8a:	91 e0       	ldi	r25, 0x01	; 1
    1f8c:	7a 17       	cp	r23, r26
    1f8e:	08 f0       	brcs	.+2      	; 0x1f92 <__vector_77+0x220>
    1f90:	90 e0       	ldi	r25, 0x00	; 0
    1f92:	29 2b       	or	r18, r25
    1f94:	91 e0       	ldi	r25, 0x01	; 1
    1f96:	f8 17       	cp	r31, r24
    1f98:	08 f0       	brcs	.+2      	; 0x1f9c <__vector_77+0x22a>
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	82 2f       	mov	r24, r18
    1f9e:	8f 0f       	add	r24, r31
    1fa0:	21 e0       	ldi	r18, 0x01	; 1
    1fa2:	8f 17       	cp	r24, r31
    1fa4:	08 f0       	brcs	.+2      	; 0x1fa8 <__vector_77+0x236>
    1fa6:	20 e0       	ldi	r18, 0x00	; 0
    1fa8:	92 2b       	or	r25, r18
    1faa:	2e 2d       	mov	r18, r14
    1fac:	9e 0f       	add	r25, r30
    1fae:	02 e0       	ldi	r16, 0x02	; 2
    1fb0:	0e 94 e2 2d 	call	0x5bc4	; 0x5bc4 <__ashrdi3>
    1fb4:	29 83       	std	Y+1, r18	; 0x01
    1fb6:	3a 83       	std	Y+2, r19	; 0x02
    1fb8:	4b 83       	std	Y+3, r20	; 0x03
    1fba:	5c 83       	std	Y+4, r21	; 0x04
    1fbc:	6d 83       	std	Y+5, r22	; 0x05
    1fbe:	7e 83       	std	Y+6, r23	; 0x06
    1fc0:	8f 83       	std	Y+7, r24	; 0x07
    1fc2:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1fc4:	60 91 66 50 	lds	r22, 0x5066
    1fc8:	70 91 67 50 	lds	r23, 0x5067
    1fcc:	80 91 68 50 	lds	r24, 0x5068
    1fd0:	90 91 69 50 	lds	r25, 0x5069
    1fd4:	19 81       	ldd	r17, Y+1	; 0x01
    1fd6:	0a 81       	ldd	r16, Y+2	; 0x02
    1fd8:	fb 80       	ldd	r15, Y+3	; 0x03
    1fda:	ec 80       	ldd	r14, Y+4	; 0x04
    1fdc:	dd 80       	ldd	r13, Y+5	; 0x05
    1fde:	ce 80       	ldd	r12, Y+6	; 0x06
    1fe0:	bf 80       	ldd	r11, Y+7	; 0x07
    1fe2:	a8 84       	ldd	r10, Y+8	; 0x08
    1fe4:	20 91 a8 50 	lds	r18, 0x50A8
    1fe8:	30 91 a9 50 	lds	r19, 0x50A9
    1fec:	40 e0       	ldi	r20, 0x00	; 0
    1fee:	50 e0       	ldi	r21, 0x00	; 0
    1ff0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    1ff4:	dc 01       	movw	r26, r24
    1ff6:	cb 01       	movw	r24, r22
    1ff8:	88 0f       	add	r24, r24
    1ffa:	99 1f       	adc	r25, r25
    1ffc:	88 0f       	add	r24, r24
    1ffe:	99 1f       	adc	r25, r25
    2000:	80 90 64 50 	lds	r8, 0x5064
    2004:	90 90 65 50 	lds	r9, 0x5065
    2008:	88 0e       	add	r8, r24
    200a:	99 1e       	adc	r9, r25
    200c:	21 2f       	mov	r18, r17
    200e:	30 2f       	mov	r19, r16
    2010:	4f 2d       	mov	r20, r15
    2012:	5e 2d       	mov	r21, r14
    2014:	6d 2d       	mov	r22, r13
    2016:	7c 2d       	mov	r23, r12
    2018:	8b 2d       	mov	r24, r11
    201a:	9a 2d       	mov	r25, r10
    201c:	0f 2e       	mov	r0, r31
    201e:	f0 ea       	ldi	r31, 0xA0	; 160
    2020:	af 2e       	mov	r10, r31
    2022:	f0 2d       	mov	r31, r0
    2024:	0f 2e       	mov	r0, r31
    2026:	f5 e2       	ldi	r31, 0x25	; 37
    2028:	bf 2e       	mov	r11, r31
    202a:	f0 2d       	mov	r31, r0
    202c:	0f 2e       	mov	r0, r31
    202e:	f6 e2       	ldi	r31, 0x26	; 38
    2030:	cf 2e       	mov	r12, r31
    2032:	f0 2d       	mov	r31, r0
    2034:	dd 24       	eor	r13, r13
    2036:	ee 24       	eor	r14, r14
    2038:	ff 24       	eor	r15, r15
    203a:	00 e0       	ldi	r16, 0x00	; 0
    203c:	10 e0       	ldi	r17, 0x00	; 0
    203e:	0e 94 9b 2c 	call	0x5936	; 0x5936 <__muldi3>
    2042:	aa 24       	eor	r10, r10
    2044:	aa 94       	dec	r10
    2046:	bb 24       	eor	r11, r11
    2048:	ba 94       	dec	r11
    204a:	0f 2e       	mov	r0, r31
    204c:	ff e7       	ldi	r31, 0x7F	; 127
    204e:	cf 2e       	mov	r12, r31
    2050:	f0 2d       	mov	r31, r0
    2052:	0e 94 4a 2e 	call	0x5c94	; 0x5c94 <__divdi3>
    2056:	01 e0       	ldi	r16, 0x01	; 1
    2058:	0e 94 6e 2d 	call	0x5adc	; 0x5adc <__ashldi3>
    205c:	0f 2e       	mov	r0, r31
    205e:	f3 e0       	ldi	r31, 0x03	; 3
    2060:	af 2e       	mov	r10, r31
    2062:	f0 2d       	mov	r31, r0
    2064:	bb 24       	eor	r11, r11
    2066:	cc 24       	eor	r12, r12
    2068:	00 e0       	ldi	r16, 0x00	; 0
    206a:	0e 94 4a 2e 	call	0x5c94	; 0x5c94 <__divdi3>
    206e:	f4 01       	movw	r30, r8
    2070:	20 83       	st	Z, r18
    2072:	31 83       	std	Z+1, r19	; 0x01
    2074:	42 83       	std	Z+2, r20	; 0x02
    2076:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    2078:	80 91 49 40 	lds	r24, 0x4049
    207c:	88 23       	and	r24, r24
    207e:	09 f1       	breq	.+66     	; 0x20c2 <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    2080:	60 91 66 50 	lds	r22, 0x5066
    2084:	70 91 67 50 	lds	r23, 0x5067
    2088:	80 91 68 50 	lds	r24, 0x5068
    208c:	90 91 69 50 	lds	r25, 0x5069
    2090:	20 91 a8 50 	lds	r18, 0x50A8
    2094:	30 91 a9 50 	lds	r19, 0x50A9
    2098:	40 e0       	ldi	r20, 0x00	; 0
    209a:	50 e0       	ldi	r21, 0x00	; 0
    209c:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    20a0:	dc 01       	movw	r26, r24
    20a2:	cb 01       	movw	r24, r22
    20a4:	9c 01       	movw	r18, r24
    20a6:	22 0f       	add	r18, r18
    20a8:	33 1f       	adc	r19, r19
    20aa:	22 0f       	add	r18, r18
    20ac:	33 1f       	adc	r19, r19
    20ae:	80 91 64 50 	lds	r24, 0x5064
    20b2:	90 91 65 50 	lds	r25, 0x5065
    20b6:	82 0f       	add	r24, r18
    20b8:	93 1f       	adc	r25, r19
    20ba:	64 e0       	ldi	r22, 0x04	; 4
    20bc:	70 e0       	ldi	r23, 0x00	; 0
    20be:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    20c2:	80 91 66 50 	lds	r24, 0x5066
    20c6:	90 91 67 50 	lds	r25, 0x5067
    20ca:	a0 91 68 50 	lds	r26, 0x5068
    20ce:	b0 91 69 50 	lds	r27, 0x5069
    20d2:	01 96       	adiw	r24, 0x01	; 1
    20d4:	a1 1d       	adc	r26, r1
    20d6:	b1 1d       	adc	r27, r1
    20d8:	80 93 66 50 	sts	0x5066, r24
    20dc:	90 93 67 50 	sts	0x5067, r25
    20e0:	a0 93 68 50 	sts	0x5068, r26
    20e4:	b0 93 69 50 	sts	0x5069, r27
}
    20e8:	2c 96       	adiw	r28, 0x0c	; 12
    20ea:	cd bf       	out	0x3d, r28	; 61
    20ec:	de bf       	out	0x3e, r29	; 62
    20ee:	df 91       	pop	r29
    20f0:	cf 91       	pop	r28
    20f2:	ff 91       	pop	r31
    20f4:	ef 91       	pop	r30
    20f6:	bf 91       	pop	r27
    20f8:	af 91       	pop	r26
    20fa:	9f 91       	pop	r25
    20fc:	8f 91       	pop	r24
    20fe:	7f 91       	pop	r23
    2100:	6f 91       	pop	r22
    2102:	5f 91       	pop	r21
    2104:	4f 91       	pop	r20
    2106:	3f 91       	pop	r19
    2108:	2f 91       	pop	r18
    210a:	1f 91       	pop	r17
    210c:	0f 91       	pop	r16
    210e:	ff 90       	pop	r15
    2110:	ef 90       	pop	r14
    2112:	df 90       	pop	r13
    2114:	cf 90       	pop	r12
    2116:	bf 90       	pop	r11
    2118:	af 90       	pop	r10
    211a:	9f 90       	pop	r9
    211c:	8f 90       	pop	r8
    211e:	7f 90       	pop	r7
    2120:	6f 90       	pop	r6
    2122:	0f 90       	pop	r0
    2124:	0b be       	out	0x3b, r0	; 59
    2126:	0f 90       	pop	r0
    2128:	0f be       	out	0x3f, r0	; 63
    212a:	0f 90       	pop	r0
    212c:	1f 90       	pop	r1
    212e:	18 95       	reti

00002130 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	SPICS(TRUE);
    2130:	81 e0       	ldi	r24, 0x01	; 1
    2132:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2136:	82 e0       	ldi	r24, 0x02	; 2
    2138:	e0 ea       	ldi	r30, 0xA0	; 160
    213a:	f6 e0       	ldi	r31, 0x06	; 6
    213c:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    213e:	8a ea       	ldi	r24, 0xAA	; 170
    2140:	e0 ec       	ldi	r30, 0xC0	; 192
    2142:	f8 e0       	ldi	r31, 0x08	; 8
    2144:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2146:	82 81       	ldd	r24, Z+2	; 0x02
    2148:	88 23       	and	r24, r24
    214a:	ec f7       	brge	.-6      	; 0x2146 <sampleCurrentChannel+0x16>
	SPIBuffer[SPICount] = SPIC.DATA;
    214c:	90 91 a1 50 	lds	r25, 0x50A1
    2150:	e0 ec       	ldi	r30, 0xC0	; 192
    2152:	f8 e0       	ldi	r31, 0x08	; 8
    2154:	83 81       	ldd	r24, Z+3	; 0x03
    2156:	a1 e2       	ldi	r26, 0x21	; 33
    2158:	be e3       	ldi	r27, 0x3E	; 62
    215a:	a9 0f       	add	r26, r25
    215c:	b1 1d       	adc	r27, r1
    215e:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2160:	8a ea       	ldi	r24, 0xAA	; 170
    2162:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2164:	82 81       	ldd	r24, Z+2	; 0x02
    2166:	88 23       	and	r24, r24
    2168:	ec f7       	brge	.-6      	; 0x2164 <sampleCurrentChannel+0x34>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    216a:	a0 91 a1 50 	lds	r26, 0x50A1
    216e:	b0 e0       	ldi	r27, 0x00	; 0
    2170:	e0 ec       	ldi	r30, 0xC0	; 192
    2172:	f8 e0       	ldi	r31, 0x08	; 8
    2174:	83 81       	ldd	r24, Z+3	; 0x03
    2176:	ae 5d       	subi	r26, 0xDE	; 222
    2178:	b1 4c       	sbci	r27, 0xC1	; 193
    217a:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    217c:	8a ea       	ldi	r24, 0xAA	; 170
    217e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2180:	82 81       	ldd	r24, Z+2	; 0x02
    2182:	88 23       	and	r24, r24
    2184:	ec f7       	brge	.-6      	; 0x2180 <sampleCurrentChannel+0x50>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2186:	e0 91 a1 50 	lds	r30, 0x50A1
    218a:	f0 e0       	ldi	r31, 0x00	; 0
    218c:	a0 ec       	ldi	r26, 0xC0	; 192
    218e:	b8 e0       	ldi	r27, 0x08	; 8
    2190:	13 96       	adiw	r26, 0x03	; 3
    2192:	8c 91       	ld	r24, X
    2194:	ed 5d       	subi	r30, 0xDD	; 221
    2196:	f1 4c       	sbci	r31, 0xC1	; 193
    2198:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    219a:	82 e0       	ldi	r24, 0x02	; 2
    219c:	e0 ea       	ldi	r30, 0xA0	; 160
    219e:	f6 e0       	ldi	r31, 0x06	; 6
    21a0:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    21a2:	80 91 a1 50 	lds	r24, 0x50A1
    21a6:	8d 5f       	subi	r24, 0xFD	; 253
    21a8:	80 93 a1 50 	sts	0x50A1, r24
	SPICS(FALSE);
    21ac:	80 e0       	ldi	r24, 0x00	; 0
    21ae:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
}
    21b2:	08 95       	ret

000021b4 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    21b4:	1f 92       	push	r1
    21b6:	0f 92       	push	r0
    21b8:	0f b6       	in	r0, 0x3f	; 63
    21ba:	0f 92       	push	r0
    21bc:	0b b6       	in	r0, 0x3b	; 59
    21be:	0f 92       	push	r0
    21c0:	11 24       	eor	r1, r1
    21c2:	2f 93       	push	r18
    21c4:	3f 93       	push	r19
    21c6:	4f 93       	push	r20
    21c8:	5f 93       	push	r21
    21ca:	6f 93       	push	r22
    21cc:	7f 93       	push	r23
    21ce:	8f 93       	push	r24
    21d0:	9f 93       	push	r25
    21d2:	af 93       	push	r26
    21d4:	bf 93       	push	r27
    21d6:	ef 93       	push	r30
    21d8:	ff 93       	push	r31
	sampleCurrentChannel();
    21da:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
	SPICount = 0;
    21de:	10 92 a1 50 	sts	0x50A1, r1
}
    21e2:	ff 91       	pop	r31
    21e4:	ef 91       	pop	r30
    21e6:	bf 91       	pop	r27
    21e8:	af 91       	pop	r26
    21ea:	9f 91       	pop	r25
    21ec:	8f 91       	pop	r24
    21ee:	7f 91       	pop	r23
    21f0:	6f 91       	pop	r22
    21f2:	5f 91       	pop	r21
    21f4:	4f 91       	pop	r20
    21f6:	3f 91       	pop	r19
    21f8:	2f 91       	pop	r18
    21fa:	0f 90       	pop	r0
    21fc:	0b be       	out	0x3b, r0	; 59
    21fe:	0f 90       	pop	r0
    2200:	0f be       	out	0x3f, r0	; 63
    2202:	0f 90       	pop	r0
    2204:	1f 90       	pop	r1
    2206:	18 95       	reti

00002208 <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    2208:	1f 92       	push	r1
    220a:	0f 92       	push	r0
    220c:	0f b6       	in	r0, 0x3f	; 63
    220e:	0f 92       	push	r0
    2210:	0b b6       	in	r0, 0x3b	; 59
    2212:	0f 92       	push	r0
    2214:	11 24       	eor	r1, r1
    2216:	2f 93       	push	r18
    2218:	3f 93       	push	r19
    221a:	4f 93       	push	r20
    221c:	5f 93       	push	r21
    221e:	6f 93       	push	r22
    2220:	7f 93       	push	r23
    2222:	8f 93       	push	r24
    2224:	9f 93       	push	r25
    2226:	af 93       	push	r26
    2228:	bf 93       	push	r27
    222a:	ef 93       	push	r30
    222c:	ff 93       	push	r31
	sampleCurrentChannel();
    222e:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
}
    2232:	ff 91       	pop	r31
    2234:	ef 91       	pop	r30
    2236:	bf 91       	pop	r27
    2238:	af 91       	pop	r26
    223a:	9f 91       	pop	r25
    223c:	8f 91       	pop	r24
    223e:	7f 91       	pop	r23
    2240:	6f 91       	pop	r22
    2242:	5f 91       	pop	r21
    2244:	4f 91       	pop	r20
    2246:	3f 91       	pop	r19
    2248:	2f 91       	pop	r18
    224a:	0f 90       	pop	r0
    224c:	0b be       	out	0x3b, r0	; 59
    224e:	0f 90       	pop	r0
    2250:	0f be       	out	0x3f, r0	; 63
    2252:	0f 90       	pop	r0
    2254:	1f 90       	pop	r1
    2256:	18 95       	reti

00002258 <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    2258:	1f 92       	push	r1
    225a:	0f 92       	push	r0
    225c:	0f b6       	in	r0, 0x3f	; 63
    225e:	0f 92       	push	r0
    2260:	0b b6       	in	r0, 0x3b	; 59
    2262:	0f 92       	push	r0
    2264:	11 24       	eor	r1, r1
    2266:	2f 93       	push	r18
    2268:	3f 93       	push	r19
    226a:	4f 93       	push	r20
    226c:	5f 93       	push	r21
    226e:	6f 93       	push	r22
    2270:	7f 93       	push	r23
    2272:	8f 93       	push	r24
    2274:	9f 93       	push	r25
    2276:	af 93       	push	r26
    2278:	bf 93       	push	r27
    227a:	ef 93       	push	r30
    227c:	ff 93       	push	r31
	sampleCurrentChannel();
    227e:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
}
    2282:	ff 91       	pop	r31
    2284:	ef 91       	pop	r30
    2286:	bf 91       	pop	r27
    2288:	af 91       	pop	r26
    228a:	9f 91       	pop	r25
    228c:	8f 91       	pop	r24
    228e:	7f 91       	pop	r23
    2290:	6f 91       	pop	r22
    2292:	5f 91       	pop	r21
    2294:	4f 91       	pop	r20
    2296:	3f 91       	pop	r19
    2298:	2f 91       	pop	r18
    229a:	0f 90       	pop	r0
    229c:	0b be       	out	0x3b, r0	; 59
    229e:	0f 90       	pop	r0
    22a0:	0f be       	out	0x3f, r0	; 63
    22a2:	0f 90       	pop	r0
    22a4:	1f 90       	pop	r1
    22a6:	18 95       	reti

000022a8 <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    22a8:	1f 92       	push	r1
    22aa:	0f 92       	push	r0
    22ac:	0f b6       	in	r0, 0x3f	; 63
    22ae:	0f 92       	push	r0
    22b0:	0b b6       	in	r0, 0x3b	; 59
    22b2:	0f 92       	push	r0
    22b4:	11 24       	eor	r1, r1
    22b6:	2f 93       	push	r18
    22b8:	3f 93       	push	r19
    22ba:	4f 93       	push	r20
    22bc:	5f 93       	push	r21
    22be:	6f 93       	push	r22
    22c0:	7f 93       	push	r23
    22c2:	8f 93       	push	r24
    22c4:	9f 93       	push	r25
    22c6:	af 93       	push	r26
    22c8:	bf 93       	push	r27
    22ca:	ef 93       	push	r30
    22cc:	ff 93       	push	r31
	sampleCurrentChannel();
    22ce:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
}
    22d2:	ff 91       	pop	r31
    22d4:	ef 91       	pop	r30
    22d6:	bf 91       	pop	r27
    22d8:	af 91       	pop	r26
    22da:	9f 91       	pop	r25
    22dc:	8f 91       	pop	r24
    22de:	7f 91       	pop	r23
    22e0:	6f 91       	pop	r22
    22e2:	5f 91       	pop	r21
    22e4:	4f 91       	pop	r20
    22e6:	3f 91       	pop	r19
    22e8:	2f 91       	pop	r18
    22ea:	0f 90       	pop	r0
    22ec:	0b be       	out	0x3b, r0	; 59
    22ee:	0f 90       	pop	r0
    22f0:	0f be       	out	0x3f, r0	; 63
    22f2:	0f 90       	pop	r0
    22f4:	1f 90       	pop	r1
    22f6:	18 95       	reti

000022f8 <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    22f8:	1f 92       	push	r1
    22fa:	0f 92       	push	r0
    22fc:	0f b6       	in	r0, 0x3f	; 63
    22fe:	0f 92       	push	r0
    2300:	0b b6       	in	r0, 0x3b	; 59
    2302:	0f 92       	push	r0
    2304:	11 24       	eor	r1, r1
    2306:	2f 93       	push	r18
    2308:	3f 93       	push	r19
    230a:	4f 93       	push	r20
    230c:	5f 93       	push	r21
    230e:	6f 93       	push	r22
    2310:	7f 93       	push	r23
    2312:	8f 93       	push	r24
    2314:	9f 93       	push	r25
    2316:	af 93       	push	r26
    2318:	bf 93       	push	r27
    231a:	ef 93       	push	r30
    231c:	ff 93       	push	r31
	sampleCurrentChannel();
    231e:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
	SPICount = 0;
    2322:	10 92 a1 50 	sts	0x50A1, r1
	if(PORTB.OUT & PIN1_bm) {
    2326:	e0 e2       	ldi	r30, 0x20	; 32
    2328:	f6 e0       	ldi	r31, 0x06	; 6
    232a:	84 81       	ldd	r24, Z+4	; 0x04
    232c:	81 ff       	sbrs	r24, 1
    232e:	0f c0       	rjmp	.+30     	; 0x234e <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2330:	e0 e0       	ldi	r30, 0x00	; 0
    2332:	f6 e0       	ldi	r31, 0x06	; 6
    2334:	84 81       	ldd	r24, Z+4	; 0x04
    2336:	86 ff       	sbrs	r24, 6
    2338:	05 c0       	rjmp	.+10     	; 0x2344 <__vector_19+0x4c>
    233a:	82 e0       	ldi	r24, 0x02	; 2
    233c:	e0 e2       	ldi	r30, 0x20	; 32
    233e:	f6 e0       	ldi	r31, 0x06	; 6
    2340:	87 83       	std	Z+7, r24	; 0x07
    2342:	0d c0       	rjmp	.+26     	; 0x235e <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    2344:	80 e4       	ldi	r24, 0x40	; 64
    2346:	e0 e0       	ldi	r30, 0x00	; 0
    2348:	f6 e0       	ldi	r31, 0x06	; 6
    234a:	87 83       	std	Z+7, r24	; 0x07
    234c:	08 c0       	rjmp	.+16     	; 0x235e <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    234e:	80 e4       	ldi	r24, 0x40	; 64
    2350:	e0 e0       	ldi	r30, 0x00	; 0
    2352:	f6 e0       	ldi	r31, 0x06	; 6
    2354:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2356:	82 e0       	ldi	r24, 0x02	; 2
    2358:	e0 e2       	ldi	r30, 0x20	; 32
    235a:	f6 e0       	ldi	r31, 0x06	; 6
    235c:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    235e:	ff 91       	pop	r31
    2360:	ef 91       	pop	r30
    2362:	bf 91       	pop	r27
    2364:	af 91       	pop	r26
    2366:	9f 91       	pop	r25
    2368:	8f 91       	pop	r24
    236a:	7f 91       	pop	r23
    236c:	6f 91       	pop	r22
    236e:	5f 91       	pop	r21
    2370:	4f 91       	pop	r20
    2372:	3f 91       	pop	r19
    2374:	2f 91       	pop	r18
    2376:	0f 90       	pop	r0
    2378:	0b be       	out	0x3b, r0	; 59
    237a:	0f 90       	pop	r0
    237c:	0f be       	out	0x3f, r0	; 63
    237e:	0f 90       	pop	r0
    2380:	1f 90       	pop	r1
    2382:	18 95       	reti

00002384 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    2384:	1f 92       	push	r1
    2386:	0f 92       	push	r0
    2388:	0f b6       	in	r0, 0x3f	; 63
    238a:	0f 92       	push	r0
    238c:	0b b6       	in	r0, 0x3b	; 59
    238e:	0f 92       	push	r0
    2390:	11 24       	eor	r1, r1
    2392:	2f 93       	push	r18
    2394:	3f 93       	push	r19
    2396:	4f 93       	push	r20
    2398:	5f 93       	push	r21
    239a:	6f 93       	push	r22
    239c:	7f 93       	push	r23
    239e:	8f 93       	push	r24
    23a0:	9f 93       	push	r25
    23a2:	af 93       	push	r26
    23a4:	bf 93       	push	r27
    23a6:	ef 93       	push	r30
    23a8:	ff 93       	push	r31
	sampleCurrentChannel();
    23aa:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
}
    23ae:	ff 91       	pop	r31
    23b0:	ef 91       	pop	r30
    23b2:	bf 91       	pop	r27
    23b4:	af 91       	pop	r26
    23b6:	9f 91       	pop	r25
    23b8:	8f 91       	pop	r24
    23ba:	7f 91       	pop	r23
    23bc:	6f 91       	pop	r22
    23be:	5f 91       	pop	r21
    23c0:	4f 91       	pop	r20
    23c2:	3f 91       	pop	r19
    23c4:	2f 91       	pop	r18
    23c6:	0f 90       	pop	r0
    23c8:	0b be       	out	0x3b, r0	; 59
    23ca:	0f 90       	pop	r0
    23cc:	0f be       	out	0x3f, r0	; 63
    23ce:	0f 90       	pop	r0
    23d0:	1f 90       	pop	r1
    23d2:	18 95       	reti

000023d4 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    23d4:	1f 92       	push	r1
    23d6:	0f 92       	push	r0
    23d8:	0f b6       	in	r0, 0x3f	; 63
    23da:	0f 92       	push	r0
    23dc:	0b b6       	in	r0, 0x3b	; 59
    23de:	0f 92       	push	r0
    23e0:	11 24       	eor	r1, r1
    23e2:	2f 93       	push	r18
    23e4:	3f 93       	push	r19
    23e6:	4f 93       	push	r20
    23e8:	5f 93       	push	r21
    23ea:	6f 93       	push	r22
    23ec:	7f 93       	push	r23
    23ee:	8f 93       	push	r24
    23f0:	9f 93       	push	r25
    23f2:	af 93       	push	r26
    23f4:	bf 93       	push	r27
    23f6:	ef 93       	push	r30
    23f8:	ff 93       	push	r31
	sampleCurrentChannel();
    23fa:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
}
    23fe:	ff 91       	pop	r31
    2400:	ef 91       	pop	r30
    2402:	bf 91       	pop	r27
    2404:	af 91       	pop	r26
    2406:	9f 91       	pop	r25
    2408:	8f 91       	pop	r24
    240a:	7f 91       	pop	r23
    240c:	6f 91       	pop	r22
    240e:	5f 91       	pop	r21
    2410:	4f 91       	pop	r20
    2412:	3f 91       	pop	r19
    2414:	2f 91       	pop	r18
    2416:	0f 90       	pop	r0
    2418:	0b be       	out	0x3b, r0	; 59
    241a:	0f 90       	pop	r0
    241c:	0f be       	out	0x3f, r0	; 63
    241e:	0f 90       	pop	r0
    2420:	1f 90       	pop	r1
    2422:	18 95       	reti

00002424 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    2424:	1f 92       	push	r1
    2426:	0f 92       	push	r0
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	0f 92       	push	r0
    242c:	0b b6       	in	r0, 0x3b	; 59
    242e:	0f 92       	push	r0
    2430:	11 24       	eor	r1, r1
    2432:	2f 93       	push	r18
    2434:	3f 93       	push	r19
    2436:	4f 93       	push	r20
    2438:	5f 93       	push	r21
    243a:	6f 93       	push	r22
    243c:	7f 93       	push	r23
    243e:	8f 93       	push	r24
    2440:	9f 93       	push	r25
    2442:	af 93       	push	r26
    2444:	bf 93       	push	r27
    2446:	ef 93       	push	r30
    2448:	ff 93       	push	r31
	sampleCurrentChannel();
    244a:	0e 94 98 10 	call	0x2130	; 0x2130 <sampleCurrentChannel>
}
    244e:	ff 91       	pop	r31
    2450:	ef 91       	pop	r30
    2452:	bf 91       	pop	r27
    2454:	af 91       	pop	r26
    2456:	9f 91       	pop	r25
    2458:	8f 91       	pop	r24
    245a:	7f 91       	pop	r23
    245c:	6f 91       	pop	r22
    245e:	5f 91       	pop	r21
    2460:	4f 91       	pop	r20
    2462:	3f 91       	pop	r19
    2464:	2f 91       	pop	r18
    2466:	0f 90       	pop	r0
    2468:	0b be       	out	0x3b, r0	; 59
    246a:	0f 90       	pop	r0
    246c:	0f be       	out	0x3f, r0	; 63
    246e:	0f 90       	pop	r0
    2470:	1f 90       	pop	r1
    2472:	18 95       	reti

00002474 <writeSE2FRAM>:
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2474:	ff 92       	push	r15
    2476:	0f 93       	push	r16
    2478:	1f 93       	push	r17
    247a:	cf 93       	push	r28
    247c:	df 93       	push	r29
    247e:	cd b7       	in	r28, 0x3d	; 61
    2480:	de b7       	in	r29, 0x3e	; 62
    2482:	28 97       	sbiw	r28, 0x08	; 8
    2484:	cd bf       	out	0x3d, r28	; 61
    2486:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    2488:	19 82       	std	Y+1, r1	; 0x01
    248a:	1a 82       	std	Y+2, r1	; 0x02
    248c:	1b 82       	std	Y+3, r1	; 0x03
    248e:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2490:	80 91 66 50 	lds	r24, 0x5066
    2494:	90 91 67 50 	lds	r25, 0x5067
    2498:	a0 91 68 50 	lds	r26, 0x5068
    249c:	b0 91 69 50 	lds	r27, 0x5069
    24a0:	01 96       	adiw	r24, 0x01	; 1
    24a2:	a1 1d       	adc	r26, r1
    24a4:	b1 1d       	adc	r27, r1
    24a6:	80 93 66 50 	sts	0x5066, r24
    24aa:	90 93 67 50 	sts	0x5067, r25
    24ae:	a0 93 68 50 	sts	0x5068, r26
    24b2:	b0 93 69 50 	sts	0x5069, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    24b6:	80 ed       	ldi	r24, 0xD0	; 208
    24b8:	80 93 c0 08 	sts	0x08C0, r24
    24bc:	20 e0       	ldi	r18, 0x00	; 0
    24be:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    24c0:	01 e2       	ldi	r16, 0x21	; 33
    24c2:	1e e3       	ldi	r17, 0x3E	; 62
    24c4:	ff 24       	eor	r15, r15
    24c6:	fa 94       	dec	r15
    24c8:	c9 01       	movw	r24, r18
    24ca:	f8 01       	movw	r30, r16
    24cc:	e2 0f       	add	r30, r18
    24ce:	f3 1f       	adc	r31, r19
    24d0:	40 81       	ld	r20, Z
    24d2:	44 23       	and	r20, r20
    24d4:	14 f4       	brge	.+4      	; 0x24da <writeSE2FRAM+0x66>
    24d6:	f8 86       	std	Y+8, r15	; 0x08
    24d8:	01 c0       	rjmp	.+2      	; 0x24dc <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    24da:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    24dc:	80 0f       	add	r24, r16
    24de:	91 1f       	adc	r25, r17
    24e0:	fc 01       	movw	r30, r24
    24e2:	80 81       	ld	r24, Z
    24e4:	8f 83       	std	Y+7, r24	; 0x07
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    24e6:	f9 01       	movw	r30, r18
    24e8:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    24ea:	e0 0f       	add	r30, r16
    24ec:	f1 1f       	adc	r31, r17
    24ee:	80 81       	ld	r24, Z
    24f0:	8e 83       	std	Y+6, r24	; 0x06
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    24f2:	f9 01       	movw	r30, r18
    24f4:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    24f6:	e0 0f       	add	r30, r16
    24f8:	f1 1f       	adc	r31, r17
    24fa:	80 81       	ld	r24, Z
    24fc:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    24fe:	49 81       	ldd	r20, Y+1	; 0x01
    2500:	5a 81       	ldd	r21, Y+2	; 0x02
    2502:	6b 81       	ldd	r22, Y+3	; 0x03
    2504:	7c 81       	ldd	r23, Y+4	; 0x04
    2506:	8d 81       	ldd	r24, Y+5	; 0x05
    2508:	9e 81       	ldd	r25, Y+6	; 0x06
    250a:	af 81       	ldd	r26, Y+7	; 0x07
    250c:	b8 85       	ldd	r27, Y+8	; 0x08
    250e:	84 0f       	add	r24, r20
    2510:	95 1f       	adc	r25, r21
    2512:	a6 1f       	adc	r26, r22
    2514:	b7 1f       	adc	r27, r23
    2516:	89 83       	std	Y+1, r24	; 0x01
    2518:	9a 83       	std	Y+2, r25	; 0x02
    251a:	ab 83       	std	Y+3, r26	; 0x03
    251c:	bc 83       	std	Y+4, r27	; 0x04
    251e:	2d 5f       	subi	r18, 0xFD	; 253
    2520:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2522:	2c 30       	cpi	r18, 0x0C	; 12
    2524:	31 05       	cpc	r19, r1
    2526:	81 f6       	brne	.-96     	; 0x24c8 <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2528:	69 81       	ldd	r22, Y+1	; 0x01
    252a:	7a 81       	ldd	r23, Y+2	; 0x02
    252c:	8b 81       	ldd	r24, Y+3	; 0x03
    252e:	9c 81       	ldd	r25, Y+4	; 0x04
    2530:	24 e0       	ldi	r18, 0x04	; 4
    2532:	30 e0       	ldi	r19, 0x00	; 0
    2534:	40 e0       	ldi	r20, 0x00	; 0
    2536:	50 e0       	ldi	r21, 0x00	; 0
    2538:	0e 94 09 38 	call	0x7012	; 0x7012 <__divmodsi4>
    253c:	29 83       	std	Y+1, r18	; 0x01
    253e:	3a 83       	std	Y+2, r19	; 0x02
    2540:	4b 83       	std	Y+3, r20	; 0x03
    2542:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2544:	29 81       	ldd	r18, Y+1	; 0x01
    2546:	83 e2       	ldi	r24, 0x23	; 35
    2548:	9e e3       	ldi	r25, 0x3E	; 62
    254a:	20 93 23 3e 	sts	0x3E23, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    254e:	2a 81       	ldd	r18, Y+2	; 0x02
    2550:	fc 01       	movw	r30, r24
    2552:	31 97       	sbiw	r30, 0x01	; 1
    2554:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2556:	2b 81       	ldd	r18, Y+3	; 0x03
    2558:	02 97       	sbiw	r24, 0x02	; 2
    255a:	fc 01       	movw	r30, r24
    255c:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    255e:	80 e1       	ldi	r24, 0x10	; 16
    2560:	e0 e4       	ldi	r30, 0x40	; 64
    2562:	f6 e0       	ldi	r31, 0x06	; 6
    2564:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2566:	88 e0       	ldi	r24, 0x08	; 8
    2568:	e0 e2       	ldi	r30, 0x20	; 32
    256a:	f6 e0       	ldi	r31, 0x06	; 6
    256c:	86 83       	std	Z+6, r24	; 0x06
	nop();
    256e:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2570:	86 e0       	ldi	r24, 0x06	; 6
    2572:	e0 ec       	ldi	r30, 0xC0	; 192
    2574:	f8 e0       	ldi	r31, 0x08	; 8
    2576:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2578:	82 81       	ldd	r24, Z+2	; 0x02
    257a:	88 23       	and	r24, r24
    257c:	ec f7       	brge	.-6      	; 0x2578 <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    257e:	e0 ec       	ldi	r30, 0xC0	; 192
    2580:	f8 e0       	ldi	r31, 0x08	; 8
    2582:	83 81       	ldd	r24, Z+3	; 0x03
    2584:	80 93 2d 3e 	sts	0x3E2D, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2588:	a0 e2       	ldi	r26, 0x20	; 32
    258a:	b6 e0       	ldi	r27, 0x06	; 6
    258c:	88 e0       	ldi	r24, 0x08	; 8
    258e:	15 96       	adiw	r26, 0x05	; 5
    2590:	8c 93       	st	X, r24
    2592:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    2594:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2596:	16 96       	adiw	r26, 0x06	; 6
    2598:	8c 93       	st	X, r24
    259a:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    259c:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    259e:	82 e0       	ldi	r24, 0x02	; 2
    25a0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25a2:	82 81       	ldd	r24, Z+2	; 0x02
    25a4:	88 23       	and	r24, r24
    25a6:	ec f7       	brge	.-6      	; 0x25a2 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    25a8:	e0 ec       	ldi	r30, 0xC0	; 192
    25aa:	f8 e0       	ldi	r31, 0x08	; 8
    25ac:	83 81       	ldd	r24, Z+3	; 0x03
    25ae:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    25b2:	80 91 1f 3e 	lds	r24, 0x3E1F
    25b6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25b8:	82 81       	ldd	r24, Z+2	; 0x02
    25ba:	88 23       	and	r24, r24
    25bc:	ec f7       	brge	.-6      	; 0x25b8 <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    25be:	e0 ec       	ldi	r30, 0xC0	; 192
    25c0:	f8 e0       	ldi	r31, 0x08	; 8
    25c2:	83 81       	ldd	r24, Z+3	; 0x03
    25c4:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    25c8:	80 91 1e 3e 	lds	r24, 0x3E1E
    25cc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25ce:	82 81       	ldd	r24, Z+2	; 0x02
    25d0:	88 23       	and	r24, r24
    25d2:	ec f7       	brge	.-6      	; 0x25ce <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    25d4:	e0 ec       	ldi	r30, 0xC0	; 192
    25d6:	f8 e0       	ldi	r31, 0x08	; 8
    25d8:	83 81       	ldd	r24, Z+3	; 0x03
    25da:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[0];
    25de:	80 91 21 3e 	lds	r24, 0x3E21
    25e2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25e4:	82 81       	ldd	r24, Z+2	; 0x02
    25e6:	88 23       	and	r24, r24
    25e8:	ec f7       	brge	.-6      	; 0x25e4 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    25ea:	e0 ec       	ldi	r30, 0xC0	; 192
    25ec:	f8 e0       	ldi	r31, 0x08	; 8
    25ee:	83 81       	ldd	r24, Z+3	; 0x03
    25f0:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[1];
    25f4:	80 91 22 3e 	lds	r24, 0x3E22
    25f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    25fa:	82 81       	ldd	r24, Z+2	; 0x02
    25fc:	88 23       	and	r24, r24
    25fe:	ec f7       	brge	.-6      	; 0x25fa <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    2600:	e0 ec       	ldi	r30, 0xC0	; 192
    2602:	f8 e0       	ldi	r31, 0x08	; 8
    2604:	83 81       	ldd	r24, Z+3	; 0x03
    2606:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[2];
    260a:	80 91 23 3e 	lds	r24, 0x3E23
    260e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2610:	82 81       	ldd	r24, Z+2	; 0x02
    2612:	88 23       	and	r24, r24
    2614:	ec f7       	brge	.-6      	; 0x2610 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    2616:	a0 ec       	ldi	r26, 0xC0	; 192
    2618:	b8 e0       	ldi	r27, 0x08	; 8
    261a:	13 96       	adiw	r26, 0x03	; 3
    261c:	8c 91       	ld	r24, X
    261e:	13 97       	sbiw	r26, 0x03	; 3
    2620:	80 93 2d 3e 	sts	0x3E2D, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2624:	88 e0       	ldi	r24, 0x08	; 8
    2626:	e0 e2       	ldi	r30, 0x20	; 32
    2628:	f6 e0       	ldi	r31, 0x06	; 6
    262a:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    262c:	e0 e4       	ldi	r30, 0x40	; 64
    262e:	f6 e0       	ldi	r31, 0x06	; 6
    2630:	80 e1       	ldi	r24, 0x10	; 16
    2632:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2634:	94 e5       	ldi	r25, 0x54	; 84
    2636:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2638:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    263a:	80 91 1e 3e 	lds	r24, 0x3E1E
    263e:	90 91 1f 3e 	lds	r25, 0x3E1F
    2642:	03 96       	adiw	r24, 0x03	; 3
    2644:	80 93 1e 3e 	sts	0x3E1E, r24
    2648:	90 93 1f 3e 	sts	0x3E1F, r25
	checksumADC[0] += SPIBuffer[0];
    264c:	80 91 12 21 	lds	r24, 0x2112
    2650:	e1 e2       	ldi	r30, 0x21	; 33
    2652:	fe e3       	ldi	r31, 0x3E	; 62
    2654:	90 81       	ld	r25, Z
    2656:	89 0f       	add	r24, r25
    2658:	80 93 12 21 	sts	0x2112, r24
	checksumADC[1] += SPIBuffer[1];
    265c:	80 91 13 21 	lds	r24, 0x2113
    2660:	91 81       	ldd	r25, Z+1	; 0x01
    2662:	89 0f       	add	r24, r25
    2664:	80 93 13 21 	sts	0x2113, r24
	checksumADC[2] += SPIBuffer[2];
    2668:	80 91 14 21 	lds	r24, 0x2114
    266c:	92 81       	ldd	r25, Z+2	; 0x02
    266e:	89 0f       	add	r24, r25
    2670:	80 93 14 21 	sts	0x2114, r24
}
    2674:	28 96       	adiw	r28, 0x08	; 8
    2676:	cd bf       	out	0x3d, r28	; 61
    2678:	de bf       	out	0x3e, r29	; 62
    267a:	df 91       	pop	r29
    267c:	cf 91       	pop	r28
    267e:	1f 91       	pop	r17
    2680:	0f 91       	pop	r16
    2682:	ff 90       	pop	r15
    2684:	08 95       	ret

00002686 <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    2686:	2f 92       	push	r2
    2688:	3f 92       	push	r3
    268a:	4f 92       	push	r4
    268c:	5f 92       	push	r5
    268e:	6f 92       	push	r6
    2690:	7f 92       	push	r7
    2692:	8f 92       	push	r8
    2694:	9f 92       	push	r9
    2696:	af 92       	push	r10
    2698:	bf 92       	push	r11
    269a:	cf 92       	push	r12
    269c:	df 92       	push	r13
    269e:	ef 92       	push	r14
    26a0:	ff 92       	push	r15
    26a2:	0f 93       	push	r16
    26a4:	1f 93       	push	r17
    26a6:	cf 93       	push	r28
    26a8:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    26aa:	10 92 1e 3e 	sts	0x3E1E, r1
    26ae:	10 92 1f 3e 	sts	0x3E1F, r1
	sampleCount = 0;
    26b2:	10 92 66 50 	sts	0x5066, r1
    26b6:	10 92 67 50 	sts	0x5067, r1
    26ba:	10 92 68 50 	sts	0x5068, r1
    26be:	10 92 69 50 	sts	0x5069, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    26c2:	84 e1       	ldi	r24, 0x14	; 20
    26c4:	91 e2       	ldi	r25, 0x21	; 33
    26c6:	10 92 14 21 	sts	0x2114, r1
    26ca:	fc 01       	movw	r30, r24
    26cc:	31 97       	sbiw	r30, 0x01	; 1
    26ce:	10 82       	st	Z, r1
    26d0:	02 97       	sbiw	r24, 0x02	; 2
    26d2:	dc 01       	movw	r26, r24
    26d4:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    26d6:	81 e0       	ldi	r24, 0x01	; 1
    26d8:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    26dc:	84 e0       	ldi	r24, 0x04	; 4
    26de:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    26e2:	80 ed       	ldi	r24, 0xD0	; 208
    26e4:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    26e8:	8d e0       	ldi	r24, 0x0D	; 13
    26ea:	80 93 21 3e 	sts	0x3E21, r24
	SPIBuffer[1] = 0xF3;
    26ee:	83 ef       	ldi	r24, 0xF3	; 243
    26f0:	80 93 22 3e 	sts	0x3E22, r24
	SPIBuffer[2] = 0x57;
    26f4:	87 e5       	ldi	r24, 0x57	; 87
    26f6:	80 93 23 3e 	sts	0x3E23, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    26fa:	80 91 66 50 	lds	r24, 0x5066
    26fe:	90 91 67 50 	lds	r25, 0x5067
    2702:	a0 91 68 50 	lds	r26, 0x5068
    2706:	b0 91 69 50 	lds	r27, 0x5069
    270a:	83 35       	cpi	r24, 0x53	; 83
    270c:	e5 e5       	ldi	r30, 0x55	; 85
    270e:	9e 07       	cpc	r25, r30
    2710:	e0 e0       	ldi	r30, 0x00	; 0
    2712:	ae 07       	cpc	r26, r30
    2714:	e0 e0       	ldi	r30, 0x00	; 0
    2716:	be 07       	cpc	r27, r30
    2718:	08 f0       	brcs	.+2      	; 0x271c <FRAMWriteKnowns+0x96>
    271a:	cc c0       	rjmp	.+408    	; 0x28b4 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    271c:	0f 2e       	mov	r0, r31
    271e:	f0 e4       	ldi	r31, 0x40	; 64
    2720:	ef 2e       	mov	r14, r31
    2722:	f6 e0       	ldi	r31, 0x06	; 6
    2724:	ff 2e       	mov	r15, r31
    2726:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2728:	40 e2       	ldi	r20, 0x20	; 32
    272a:	56 e0       	ldi	r21, 0x06	; 6
    272c:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    272e:	e0 ec       	ldi	r30, 0xC0	; 192
    2730:	f8 e0       	ldi	r31, 0x08	; 8
    2732:	0f 2e       	mov	r0, r31
    2734:	f6 e0       	ldi	r31, 0x06	; 6
    2736:	7f 2e       	mov	r7, r31
    2738:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    273a:	cd e2       	ldi	r28, 0x2D	; 45
    273c:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    273e:	66 24       	eor	r6, r6
    2740:	68 94       	set
    2742:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2744:	0f 2e       	mov	r0, r31
    2746:	fe e1       	ldi	r31, 0x1E	; 30
    2748:	cf 2e       	mov	r12, r31
    274a:	fe e3       	ldi	r31, 0x3E	; 62
    274c:	df 2e       	mov	r13, r31
    274e:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2750:	8e 01       	movw	r16, r28
    2752:	0c 50       	subi	r16, 0x0C	; 12
    2754:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2756:	0f 2e       	mov	r0, r31
    2758:	f5 ef       	ldi	r31, 0xF5	; 245
    275a:	4f 2e       	mov	r4, r31
    275c:	ff ef       	ldi	r31, 0xFF	; 255
    275e:	5f 2e       	mov	r5, r31
    2760:	f0 2d       	mov	r31, r0
    2762:	4c 0e       	add	r4, r28
    2764:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2766:	0f 2e       	mov	r0, r31
    2768:	f6 ef       	ldi	r31, 0xF6	; 246
    276a:	2f 2e       	mov	r2, r31
    276c:	ff ef       	ldi	r31, 0xFF	; 255
    276e:	3f 2e       	mov	r3, r31
    2770:	f0 2d       	mov	r31, r0
    2772:	2c 0e       	add	r2, r28
    2774:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2776:	62 e1       	ldi	r22, 0x12	; 18
    2778:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    277a:	5b 01       	movw	r10, r22
    277c:	08 94       	sec
    277e:	a1 1c       	adc	r10, r1
    2780:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2782:	88 24       	eor	r8, r8
    2784:	99 24       	eor	r9, r9
    2786:	68 94       	set
    2788:	81 f8       	bld	r8, 1
    278a:	86 0e       	add	r8, r22
    278c:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    278e:	30 e1       	ldi	r19, 0x10	; 16
    2790:	d7 01       	movw	r26, r14
    2792:	16 96       	adiw	r26, 0x06	; 6
    2794:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2796:	da 01       	movw	r26, r20
    2798:	16 96       	adiw	r26, 0x06	; 6
    279a:	2c 93       	st	X, r18
    279c:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    279e:	00 00       	nop
		SPIC.DATA = FR_WREN;
    27a0:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27a2:	82 81       	ldd	r24, Z+2	; 0x02
    27a4:	88 23       	and	r24, r24
    27a6:	ec f7       	brge	.-6      	; 0x27a2 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    27a8:	83 81       	ldd	r24, Z+3	; 0x03
    27aa:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    27ac:	da 01       	movw	r26, r20
    27ae:	15 96       	adiw	r26, 0x05	; 5
    27b0:	2c 93       	st	X, r18
    27b2:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    27b4:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    27b6:	16 96       	adiw	r26, 0x06	; 6
    27b8:	2c 93       	st	X, r18
    27ba:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    27bc:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    27be:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27c0:	82 81       	ldd	r24, Z+2	; 0x02
    27c2:	88 23       	and	r24, r24
    27c4:	ec f7       	brge	.-6      	; 0x27c0 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    27c6:	83 81       	ldd	r24, Z+3	; 0x03
    27c8:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    27ca:	d6 01       	movw	r26, r12
    27cc:	11 96       	adiw	r26, 0x01	; 1
    27ce:	8c 91       	ld	r24, X
    27d0:	11 97       	sbiw	r26, 0x01	; 1
    27d2:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27d4:	82 81       	ldd	r24, Z+2	; 0x02
    27d6:	88 23       	and	r24, r24
    27d8:	ec f7       	brge	.-6      	; 0x27d4 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    27da:	83 81       	ldd	r24, Z+3	; 0x03
    27dc:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    27de:	d6 01       	movw	r26, r12
    27e0:	8c 91       	ld	r24, X
    27e2:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27e4:	82 81       	ldd	r24, Z+2	; 0x02
    27e6:	88 23       	and	r24, r24
    27e8:	ec f7       	brge	.-6      	; 0x27e4 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    27ea:	83 81       	ldd	r24, Z+3	; 0x03
    27ec:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    27ee:	d8 01       	movw	r26, r16
    27f0:	8c 91       	ld	r24, X
    27f2:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    27f4:	82 81       	ldd	r24, Z+2	; 0x02
    27f6:	88 23       	and	r24, r24
    27f8:	ec f7       	brge	.-6      	; 0x27f4 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    27fa:	83 81       	ldd	r24, Z+3	; 0x03
    27fc:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    27fe:	d2 01       	movw	r26, r4
    2800:	8c 91       	ld	r24, X
    2802:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2804:	82 81       	ldd	r24, Z+2	; 0x02
    2806:	88 23       	and	r24, r24
    2808:	ec f7       	brge	.-6      	; 0x2804 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    280a:	83 81       	ldd	r24, Z+3	; 0x03
    280c:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    280e:	d1 01       	movw	r26, r2
    2810:	8c 91       	ld	r24, X
    2812:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2814:	82 81       	ldd	r24, Z+2	; 0x02
    2816:	88 23       	and	r24, r24
    2818:	ec f7       	brge	.-6      	; 0x2814 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    281a:	83 81       	ldd	r24, Z+3	; 0x03
    281c:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    281e:	da 01       	movw	r26, r20
    2820:	15 96       	adiw	r26, 0x05	; 5
    2822:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2824:	30 e1       	ldi	r19, 0x10	; 16
    2826:	d7 01       	movw	r26, r14
    2828:	15 96       	adiw	r26, 0x05	; 5
    282a:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    282c:	80 91 1e 3e 	lds	r24, 0x3E1E
    2830:	90 91 1f 3e 	lds	r25, 0x3E1F
    2834:	03 96       	adiw	r24, 0x03	; 3
    2836:	80 93 1e 3e 	sts	0x3E1E, r24
    283a:	90 93 1f 3e 	sts	0x3E1F, r25
		checksumADC[0] += SPIBuffer[0];
    283e:	db 01       	movw	r26, r22
    2840:	8c 91       	ld	r24, X
    2842:	d8 01       	movw	r26, r16
    2844:	9c 91       	ld	r25, X
    2846:	89 0f       	add	r24, r25
    2848:	db 01       	movw	r26, r22
    284a:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    284c:	d5 01       	movw	r26, r10
    284e:	8c 91       	ld	r24, X
    2850:	a2 e2       	ldi	r26, 0x22	; 34
    2852:	be e3       	ldi	r27, 0x3E	; 62
    2854:	9c 91       	ld	r25, X
    2856:	89 0f       	add	r24, r25
    2858:	d5 01       	movw	r26, r10
    285a:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    285c:	d4 01       	movw	r26, r8
    285e:	8c 91       	ld	r24, X
    2860:	a3 e2       	ldi	r26, 0x23	; 35
    2862:	be e3       	ldi	r27, 0x3E	; 62
    2864:	9c 91       	ld	r25, X
    2866:	89 0f       	add	r24, r25
    2868:	d4 01       	movw	r26, r8
    286a:	8c 93       	st	X, r24
		
		sampleCount++;
    286c:	80 91 66 50 	lds	r24, 0x5066
    2870:	90 91 67 50 	lds	r25, 0x5067
    2874:	a0 91 68 50 	lds	r26, 0x5068
    2878:	b0 91 69 50 	lds	r27, 0x5069
    287c:	01 96       	adiw	r24, 0x01	; 1
    287e:	a1 1d       	adc	r26, r1
    2880:	b1 1d       	adc	r27, r1
    2882:	80 93 66 50 	sts	0x5066, r24
    2886:	90 93 67 50 	sts	0x5067, r25
    288a:	a0 93 68 50 	sts	0x5068, r26
    288e:	b0 93 69 50 	sts	0x5069, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2892:	80 91 66 50 	lds	r24, 0x5066
    2896:	90 91 67 50 	lds	r25, 0x5067
    289a:	a0 91 68 50 	lds	r26, 0x5068
    289e:	b0 91 69 50 	lds	r27, 0x5069
    28a2:	83 35       	cpi	r24, 0x53	; 83
    28a4:	35 e5       	ldi	r19, 0x55	; 85
    28a6:	93 07       	cpc	r25, r19
    28a8:	30 e0       	ldi	r19, 0x00	; 0
    28aa:	a3 07       	cpc	r26, r19
    28ac:	30 e0       	ldi	r19, 0x00	; 0
    28ae:	b3 07       	cpc	r27, r19
    28b0:	08 f4       	brcc	.+2      	; 0x28b4 <FRAMWriteKnowns+0x22e>
    28b2:	6d cf       	rjmp	.-294    	; 0x278e <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    28b4:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	ADCPower(FALSE);
    28b8:	80 e0       	ldi	r24, 0x00	; 0
    28ba:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
}
    28be:	df 91       	pop	r29
    28c0:	cf 91       	pop	r28
    28c2:	1f 91       	pop	r17
    28c4:	0f 91       	pop	r16
    28c6:	ff 90       	pop	r15
    28c8:	ef 90       	pop	r14
    28ca:	df 90       	pop	r13
    28cc:	cf 90       	pop	r12
    28ce:	bf 90       	pop	r11
    28d0:	af 90       	pop	r10
    28d2:	9f 90       	pop	r9
    28d4:	8f 90       	pop	r8
    28d6:	7f 90       	pop	r7
    28d8:	6f 90       	pop	r6
    28da:	5f 90       	pop	r5
    28dc:	4f 90       	pop	r4
    28de:	3f 90       	pop	r3
    28e0:	2f 90       	pop	r2
    28e2:	08 95       	ret

000028e4 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    28e4:	80 ff       	sbrs	r24, 0
    28e6:	05 c0       	rjmp	.+10     	; 0x28f2 <setADCInput+0xe>
    28e8:	20 e4       	ldi	r18, 0x40	; 64
    28ea:	e0 e0       	ldi	r30, 0x00	; 0
    28ec:	f6 e0       	ldi	r31, 0x06	; 6
    28ee:	25 83       	std	Z+5, r18	; 0x05
    28f0:	04 c0       	rjmp	.+8      	; 0x28fa <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    28f2:	20 e4       	ldi	r18, 0x40	; 64
    28f4:	e0 e0       	ldi	r30, 0x00	; 0
    28f6:	f6 e0       	ldi	r31, 0x06	; 6
    28f8:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    28fa:	81 ff       	sbrs	r24, 1
    28fc:	05 c0       	rjmp	.+10     	; 0x2908 <setADCInput+0x24>
    28fe:	22 e0       	ldi	r18, 0x02	; 2
    2900:	e0 e2       	ldi	r30, 0x20	; 32
    2902:	f6 e0       	ldi	r31, 0x06	; 6
    2904:	25 83       	std	Z+5, r18	; 0x05
    2906:	04 c0       	rjmp	.+8      	; 0x2910 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2908:	22 e0       	ldi	r18, 0x02	; 2
    290a:	e0 e2       	ldi	r30, 0x20	; 32
    290c:	f6 e0       	ldi	r31, 0x06	; 6
    290e:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2910:	82 ff       	sbrs	r24, 2
    2912:	05 c0       	rjmp	.+10     	; 0x291e <setADCInput+0x3a>
    2914:	84 e0       	ldi	r24, 0x04	; 4
    2916:	e0 e2       	ldi	r30, 0x20	; 32
    2918:	f6 e0       	ldi	r31, 0x06	; 6
    291a:	85 83       	std	Z+5, r24	; 0x05
    291c:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    291e:	84 e0       	ldi	r24, 0x04	; 4
    2920:	e0 e2       	ldi	r30, 0x20	; 32
    2922:	f6 e0       	ldi	r31, 0x06	; 6
    2924:	86 83       	std	Z+6, r24	; 0x06
    2926:	08 95       	ret

00002928 <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2928:	2f 92       	push	r2
    292a:	3f 92       	push	r3
    292c:	4f 92       	push	r4
    292e:	5f 92       	push	r5
    2930:	7f 92       	push	r7
    2932:	8f 92       	push	r8
    2934:	9f 92       	push	r9
    2936:	af 92       	push	r10
    2938:	bf 92       	push	r11
    293a:	cf 92       	push	r12
    293c:	df 92       	push	r13
    293e:	ef 92       	push	r14
    2940:	ff 92       	push	r15
    2942:	0f 93       	push	r16
    2944:	1f 93       	push	r17
    2946:	cf 93       	push	r28
    2948:	df 93       	push	r29
    294a:	cd b7       	in	r28, 0x3d	; 61
    294c:	de b7       	in	r29, 0x3e	; 62
    294e:	18 2f       	mov	r17, r24
    2950:	76 2e       	mov	r7, r22
    2952:	f4 2e       	mov	r15, r20
    2954:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    2956:	89 8d       	ldd	r24, Y+25	; 0x19
    2958:	9a 8d       	ldd	r25, Y+26	; 0x1a
    295a:	80 93 64 50 	sts	0x5064, r24
    295e:	90 93 65 50 	sts	0x5065, r25
	ADC_Sampling_Finished = 0;
    2962:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    2966:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2968:	9c 8d       	ldd	r25, Y+28	; 0x1c
    296a:	80 93 a8 50 	sts	0x50A8, r24
    296e:	90 93 a9 50 	sts	0x50A9, r25
	if(use_FRAM){
    2972:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2974:	88 23       	and	r24, r24
    2976:	21 f0       	breq	.+8      	; 0x2980 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    2978:	81 e0       	ldi	r24, 0x01	; 1
    297a:	80 93 49 40 	sts	0x4049, r24
    297e:	02 c0       	rjmp	.+4      	; 0x2984 <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2980:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    298a:	81 2f       	mov	r24, r17
    298c:	6f 2d       	mov	r22, r15
    298e:	0e 94 b0 0a 	call	0x1560	; 0x1560 <set_ampGain>
	set_filter(filterConfig);
    2992:	87 2d       	mov	r24, r7
    2994:	0e 94 e6 04 	call	0x9cc	; 0x9cc <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2998:	8e 2d       	mov	r24, r14
    299a:	0e 94 ca 0c 	call	0x1994	; 0x1994 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    299e:	84 e0       	ldi	r24, 0x04	; 4
    29a0:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    29a4:	84 e5       	ldi	r24, 0x54	; 84
    29a6:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    29aa:	81 e0       	ldi	r24, 0x01	; 1
    29ac:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <enableADCMUX>
	setADCInput(channel);
    29b0:	81 2f       	mov	r24, r17
    29b2:	0e 94 72 14 	call	0x28e4	; 0x28e4 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    29b6:	e0 ea       	ldi	r30, 0xA0	; 160
    29b8:	f6 e0       	ldi	r31, 0x06	; 6
    29ba:	22 e0       	ldi	r18, 0x02	; 2
    29bc:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    29be:	77 24       	eor	r7, r7
    29c0:	73 94       	inc	r7
    29c2:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    29c4:	0f 2e       	mov	r0, r31
    29c6:	f0 e8       	ldi	r31, 0x80	; 128
    29c8:	4f 2e       	mov	r4, r31
    29ca:	f1 e0       	ldi	r31, 0x01	; 1
    29cc:	5f 2e       	mov	r5, r31
    29ce:	f0 2d       	mov	r31, r0
    29d0:	88 e7       	ldi	r24, 0x78	; 120
    29d2:	d2 01       	movw	r26, r4
    29d4:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    29d6:	e0 e0       	ldi	r30, 0x00	; 0
    29d8:	f9 e0       	ldi	r31, 0x09	; 9
    29da:	80 ef       	ldi	r24, 0xF0	; 240
    29dc:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    29de:	c0 a6       	lds	r28, 0xb0
    29e0:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    29e2:	a2 a6       	lds	r26, 0xb2
    29e4:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    29e6:	84 a6       	lds	r24, 0xb4
    29e8:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    29ea:	8d 89       	ldd	r24, Y+21	; 0x15
    29ec:	9e 89       	ldd	r25, Y+22	; 0x16
    29ee:	86 a7       	lds	r24, 0x76
    29f0:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    29f2:	80 2f       	mov	r24, r16
    29f4:	90 e0       	ldi	r25, 0x00	; 0
    29f6:	01 97       	sbiw	r24, 0x01	; 1
    29f8:	86 a3       	lds	r24, 0x56
    29fa:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    29fc:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    29fe:	8f ef       	ldi	r24, 0xFF	; 255
    2a00:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2a02:	80 81       	ld	r24, Z
    2a04:	80 7f       	andi	r24, 0xF0	; 240
    2a06:	88 60       	ori	r24, 0x08	; 8
    2a08:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2a0a:	10 92 66 50 	sts	0x5066, r1
    2a0e:	10 92 67 50 	sts	0x5067, r1
    2a12:	10 92 68 50 	sts	0x5068, r1
    2a16:	10 92 69 50 	sts	0x5069, r1
	SPICount = 0;
    2a1a:	10 92 a1 50 	sts	0x50A1, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2a1e:	80 e2       	ldi	r24, 0x20	; 32
    2a20:	e0 e8       	ldi	r30, 0x80	; 128
    2a22:	f6 e0       	ldi	r31, 0x06	; 6
    2a24:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a26:	00 e4       	ldi	r16, 0x40	; 64
    2a28:	1a e0       	ldi	r17, 0x0A	; 10
    2a2a:	83 e2       	ldi	r24, 0x23	; 35
    2a2c:	f8 01       	movw	r30, r16
    2a2e:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2a30:	61 01       	movw	r12, r2
    2a32:	ee 24       	eor	r14, r14
    2a34:	ff 24       	eor	r15, r15
    2a36:	60 e8       	ldi	r22, 0x80	; 128
    2a38:	74 e8       	ldi	r23, 0x84	; 132
    2a3a:	8e e1       	ldi	r24, 0x1E	; 30
    2a3c:	90 e0       	ldi	r25, 0x00	; 0
    2a3e:	a7 01       	movw	r20, r14
    2a40:	96 01       	movw	r18, r12
    2a42:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    2a46:	d8 01       	movw	r26, r16
    2a48:	96 96       	adiw	r26, 0x26	; 38
    2a4a:	2d 93       	st	X+, r18
    2a4c:	3c 93       	st	X, r19
    2a4e:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2a50:	60 e4       	ldi	r22, 0x40	; 64
    2a52:	72 e4       	ldi	r23, 0x42	; 66
    2a54:	8f e0       	ldi	r24, 0x0F	; 15
    2a56:	90 e0       	ldi	r25, 0x00	; 0
    2a58:	a7 01       	movw	r20, r14
    2a5a:	96 01       	movw	r18, r12
    2a5c:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    2a60:	f8 01       	movw	r30, r16
    2a62:	22 af       	sts	0x72, r18
    2a64:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2a66:	e0 e4       	ldi	r30, 0x40	; 64
    2a68:	f8 e0       	ldi	r31, 0x08	; 8
    2a6a:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2a6c:	8c e0       	ldi	r24, 0x0C	; 12
    2a6e:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2a70:	8f 89       	ldd	r24, Y+23	; 0x17
    2a72:	98 8d       	ldd	r25, Y+24	; 0x18
    2a74:	86 a3       	lds	r24, 0x56
    2a76:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2a78:	80 ed       	ldi	r24, 0xD0	; 208
    2a7a:	d2 01       	movw	r26, r4
    2a7c:	11 96       	adiw	r26, 0x01	; 1
    2a7e:	8c 93       	st	X, r24
    2a80:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2a82:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2a84:	80 81       	ld	r24, Z
    2a86:	80 7f       	andi	r24, 0xF0	; 240
    2a88:	89 60       	ori	r24, 0x09	; 9
    2a8a:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2a8c:	f8 01       	movw	r30, r16
    2a8e:	80 81       	ld	r24, Z
    2a90:	80 7f       	andi	r24, 0xF0	; 240
    2a92:	81 60       	ori	r24, 0x01	; 1
    2a94:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2a96:	e0 ea       	ldi	r30, 0xA0	; 160
    2a98:	f0 e0       	ldi	r31, 0x00	; 0
    2a9a:	82 81       	ldd	r24, Z+2	; 0x02
    2a9c:	87 60       	ori	r24, 0x07	; 7
    2a9e:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2aa0:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2aa2:	df 91       	pop	r29
    2aa4:	cf 91       	pop	r28
    2aa6:	1f 91       	pop	r17
    2aa8:	0f 91       	pop	r16
    2aaa:	ff 90       	pop	r15
    2aac:	ef 90       	pop	r14
    2aae:	df 90       	pop	r13
    2ab0:	cf 90       	pop	r12
    2ab2:	bf 90       	pop	r11
    2ab4:	af 90       	pop	r10
    2ab6:	9f 90       	pop	r9
    2ab8:	8f 90       	pop	r8
    2aba:	7f 90       	pop	r7
    2abc:	5f 90       	pop	r5
    2abe:	4f 90       	pop	r4
    2ac0:	3f 90       	pop	r3
    2ac2:	2f 90       	pop	r2
    2ac4:	08 95       	ret

00002ac6 <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2ac6:	2f 92       	push	r2
    2ac8:	3f 92       	push	r3
    2aca:	4f 92       	push	r4
    2acc:	5f 92       	push	r5
    2ace:	6f 92       	push	r6
    2ad0:	7f 92       	push	r7
    2ad2:	8f 92       	push	r8
    2ad4:	9f 92       	push	r9
    2ad6:	af 92       	push	r10
    2ad8:	bf 92       	push	r11
    2ada:	cf 92       	push	r12
    2adc:	df 92       	push	r13
    2ade:	ef 92       	push	r14
    2ae0:	ff 92       	push	r15
    2ae2:	0f 93       	push	r16
    2ae4:	cf 93       	push	r28
    2ae6:	df 93       	push	r29
    2ae8:	0f 92       	push	r0
    2aea:	0f 92       	push	r0
    2aec:	cd b7       	in	r28, 0x3d	; 61
    2aee:	de b7       	in	r29, 0x3e	; 62
    2af0:	96 2f       	mov	r25, r22
    2af2:	49 83       	std	Y+1, r20	; 0x01
    2af4:	5a 83       	std	Y+2, r21	; 0x02
    2af6:	52 2f       	mov	r21, r18
    2af8:	70 2f       	mov	r23, r16
    2afa:	37 01       	movw	r6, r14
    2afc:	26 01       	movw	r4, r12
    2afe:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2b00:	2d b7       	in	r18, 0x3d	; 61
    2b02:	3e b7       	in	r19, 0x3e	; 62
    2b04:	29 50       	subi	r18, 0x09	; 9
    2b06:	30 40       	sbci	r19, 0x00	; 0
    2b08:	2d bf       	out	0x3d, r18	; 61
    2b0a:	3e bf       	out	0x3e, r19	; 62
    2b0c:	ed b7       	in	r30, 0x3d	; 61
    2b0e:	fe b7       	in	r31, 0x3e	; 62
    2b10:	31 96       	adiw	r30, 0x01	; 1
    2b12:	ad b7       	in	r26, 0x3d	; 61
    2b14:	be b7       	in	r27, 0x3e	; 62
    2b16:	11 96       	adiw	r26, 0x01	; 1
    2b18:	8d 92       	st	X+, r8
    2b1a:	9c 92       	st	X, r9
    2b1c:	12 97       	sbiw	r26, 0x02	; 2
    2b1e:	2f 89       	ldd	r18, Y+23	; 0x17
    2b20:	38 8d       	ldd	r19, Y+24	; 0x18
    2b22:	22 83       	std	Z+2, r18	; 0x02
    2b24:	33 83       	std	Z+3, r19	; 0x03
    2b26:	29 8d       	ldd	r18, Y+25	; 0x19
    2b28:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2b2a:	24 83       	std	Z+4, r18	; 0x04
    2b2c:	35 83       	std	Z+5, r19	; 0x05
    2b2e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2b30:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2b32:	26 83       	std	Z+6, r18	; 0x06
    2b34:	37 83       	std	Z+7, r19	; 0x07
    2b36:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2b38:	20 87       	std	Z+8, r18	; 0x08
    2b3a:	64 ec       	ldi	r22, 0xC4	; 196
    2b3c:	49 2f       	mov	r20, r25
    2b3e:	29 81       	ldd	r18, Y+1	; 0x01
    2b40:	3a 81       	ldd	r19, Y+2	; 0x02
    2b42:	05 2f       	mov	r16, r21
    2b44:	e7 2e       	mov	r14, r23
    2b46:	63 01       	movw	r12, r6
    2b48:	52 01       	movw	r10, r4
    2b4a:	41 01       	movw	r8, r2
    2b4c:	0e 94 94 14 	call	0x2928	; 0x2928 <CO_collectSeismic1Channel_ext>
    2b50:	2d b7       	in	r18, 0x3d	; 61
    2b52:	3e b7       	in	r19, 0x3e	; 62
    2b54:	27 5f       	subi	r18, 0xF7	; 247
    2b56:	3f 4f       	sbci	r19, 0xFF	; 255
    2b58:	2d bf       	out	0x3d, r18	; 61
    2b5a:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2b5c:	0f 90       	pop	r0
    2b5e:	0f 90       	pop	r0
    2b60:	df 91       	pop	r29
    2b62:	cf 91       	pop	r28
    2b64:	0f 91       	pop	r16
    2b66:	ff 90       	pop	r15
    2b68:	ef 90       	pop	r14
    2b6a:	df 90       	pop	r13
    2b6c:	cf 90       	pop	r12
    2b6e:	bf 90       	pop	r11
    2b70:	af 90       	pop	r10
    2b72:	9f 90       	pop	r9
    2b74:	8f 90       	pop	r8
    2b76:	7f 90       	pop	r7
    2b78:	6f 90       	pop	r6
    2b7a:	5f 90       	pop	r5
    2b7c:	4f 90       	pop	r4
    2b7e:	3f 90       	pop	r3
    2b80:	2f 90       	pop	r2
    2b82:	08 95       	ret

00002b84 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2b84:	2f 92       	push	r2
    2b86:	3f 92       	push	r3
    2b88:	5f 92       	push	r5
    2b8a:	6f 92       	push	r6
    2b8c:	7f 92       	push	r7
    2b8e:	8f 92       	push	r8
    2b90:	9f 92       	push	r9
    2b92:	af 92       	push	r10
    2b94:	bf 92       	push	r11
    2b96:	cf 92       	push	r12
    2b98:	df 92       	push	r13
    2b9a:	ef 92       	push	r14
    2b9c:	ff 92       	push	r15
    2b9e:	0f 93       	push	r16
    2ba0:	1f 93       	push	r17
    2ba2:	cf 93       	push	r28
    2ba4:	df 93       	push	r29
    2ba6:	0f 92       	push	r0
    2ba8:	0f 92       	push	r0
    2baa:	cd b7       	in	r28, 0x3d	; 61
    2bac:	de b7       	in	r29, 0x3e	; 62
    2bae:	18 2f       	mov	r17, r24
    2bb0:	3b 01       	movw	r6, r22
    2bb2:	49 83       	std	Y+1, r20	; 0x01
    2bb4:	5a 83       	std	Y+2, r21	; 0x02
    2bb6:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2bb8:	89 8d       	ldd	r24, Y+25	; 0x19
    2bba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2bbc:	80 93 64 50 	sts	0x5064, r24
    2bc0:	90 93 65 50 	sts	0x5065, r25
	ADC_Sampling_Finished = 0;
    2bc4:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    2bc8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2bca:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2bcc:	80 93 a8 50 	sts	0x50A8, r24
    2bd0:	90 93 a9 50 	sts	0x50A9, r25
	if(use_FRAM){
    2bd4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2bd6:	88 23       	and	r24, r24
    2bd8:	21 f0       	breq	.+8      	; 0x2be2 <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2bda:	81 e0       	ldi	r24, 0x01	; 1
    2bdc:	80 93 49 40 	sts	0x4049, r24
    2be0:	02 c0       	rjmp	.+4      	; 0x2be6 <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2be2:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2be6:	81 e0       	ldi	r24, 0x01	; 1
    2be8:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2bec:	85 e0       	ldi	r24, 0x05	; 5
    2bee:	d3 01       	movw	r26, r6
    2bf0:	6c 91       	ld	r22, X
    2bf2:	0e 94 b0 0a 	call	0x1560	; 0x1560 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2bf6:	86 e0       	ldi	r24, 0x06	; 6
    2bf8:	f3 01       	movw	r30, r6
    2bfa:	61 81       	ldd	r22, Z+1	; 0x01
    2bfc:	0e 94 b0 0a 	call	0x1560	; 0x1560 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2c00:	87 e0       	ldi	r24, 0x07	; 7
    2c02:	d3 01       	movw	r26, r6
    2c04:	12 96       	adiw	r26, 0x02	; 2
    2c06:	6c 91       	ld	r22, X
    2c08:	0e 94 b0 0a 	call	0x1560	; 0x1560 <set_ampGain>
	set_filter(filterConfig);
    2c0c:	81 2f       	mov	r24, r17
    2c0e:	0e 94 e6 04 	call	0x9cc	; 0x9cc <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2c12:	80 2f       	mov	r24, r16
    2c14:	0e 94 ca 0c 	call	0x1994	; 0x1994 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2c18:	84 e0       	ldi	r24, 0x04	; 4
    2c1a:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2c1e:	84 e5       	ldi	r24, 0x54	; 84
    2c20:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2c24:	81 e0       	ldi	r24, 0x01	; 1
    2c26:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2c2a:	85 e0       	ldi	r24, 0x05	; 5
    2c2c:	0e 94 72 14 	call	0x28e4	; 0x28e4 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2c30:	e0 ea       	ldi	r30, 0xA0	; 160
    2c32:	f6 e0       	ldi	r31, 0x06	; 6
    2c34:	22 e0       	ldi	r18, 0x02	; 2
    2c36:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2c38:	66 24       	eor	r6, r6
    2c3a:	63 94       	inc	r6
    2c3c:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2c3e:	0f 2e       	mov	r0, r31
    2c40:	f0 e8       	ldi	r31, 0x80	; 128
    2c42:	2f 2e       	mov	r2, r31
    2c44:	f1 e0       	ldi	r31, 0x01	; 1
    2c46:	3f 2e       	mov	r3, r31
    2c48:	f0 2d       	mov	r31, r0
    2c4a:	88 e7       	ldi	r24, 0x78	; 120
    2c4c:	f1 01       	movw	r30, r2
    2c4e:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2c50:	e0 e0       	ldi	r30, 0x00	; 0
    2c52:	f8 e0       	ldi	r31, 0x08	; 8
    2c54:	80 ef       	ldi	r24, 0xF0	; 240
    2c56:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2c58:	e0 a6       	lds	r30, 0xb0
    2c5a:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2c5c:	c2 a6       	lds	r28, 0xb2
    2c5e:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2c60:	a4 a6       	lds	r26, 0xb4
    2c62:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2c64:	86 a6       	lds	r24, 0xb6
    2c66:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2c68:	85 2d       	mov	r24, r5
    2c6a:	90 e0       	ldi	r25, 0x00	; 0
    2c6c:	01 97       	sbiw	r24, 0x01	; 1
    2c6e:	86 a3       	lds	r24, 0x56
    2c70:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2c72:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2c74:	8f ef       	ldi	r24, 0xFF	; 255
    2c76:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2c78:	80 81       	ld	r24, Z
    2c7a:	80 7f       	andi	r24, 0xF0	; 240
    2c7c:	88 60       	ori	r24, 0x08	; 8
    2c7e:	80 83       	st	Z, r24

	sampleCount = 0;
    2c80:	10 92 66 50 	sts	0x5066, r1
    2c84:	10 92 67 50 	sts	0x5067, r1
    2c88:	10 92 68 50 	sts	0x5068, r1
    2c8c:	10 92 69 50 	sts	0x5069, r1
	SPICount = 0;
    2c90:	10 92 a1 50 	sts	0x50A1, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2c94:	84 e1       	ldi	r24, 0x14	; 20
    2c96:	91 e2       	ldi	r25, 0x21	; 33
    2c98:	10 92 14 21 	sts	0x2114, r1
    2c9c:	fc 01       	movw	r30, r24
    2c9e:	31 97       	sbiw	r30, 0x01	; 1
    2ca0:	10 82       	st	Z, r1
    2ca2:	02 97       	sbiw	r24, 0x02	; 2
    2ca4:	dc 01       	movw	r26, r24
    2ca6:	1c 92       	st	X, r1

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2ca8:	80 e2       	ldi	r24, 0x20	; 32
    2caa:	e0 e8       	ldi	r30, 0x80	; 128
    2cac:	f6 e0       	ldi	r31, 0x06	; 6
    2cae:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2cb0:	00 e4       	ldi	r16, 0x40	; 64
    2cb2:	1a e0       	ldi	r17, 0x0A	; 10
    2cb4:	83 e2       	ldi	r24, 0x23	; 35
    2cb6:	f8 01       	movw	r30, r16
    2cb8:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2cba:	89 81       	ldd	r24, Y+1	; 0x01
    2cbc:	9a 81       	ldd	r25, Y+2	; 0x02
    2cbe:	6c 01       	movw	r12, r24
    2cc0:	ee 24       	eor	r14, r14
    2cc2:	ff 24       	eor	r15, r15
    2cc4:	60 e8       	ldi	r22, 0x80	; 128
    2cc6:	74 e8       	ldi	r23, 0x84	; 132
    2cc8:	8e e1       	ldi	r24, 0x1E	; 30
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	a7 01       	movw	r20, r14
    2cce:	96 01       	movw	r18, r12
    2cd0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    2cd4:	d8 01       	movw	r26, r16
    2cd6:	96 96       	adiw	r26, 0x26	; 38
    2cd8:	2d 93       	st	X+, r18
    2cda:	3c 93       	st	X, r19
    2cdc:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2cde:	60 e4       	ldi	r22, 0x40	; 64
    2ce0:	72 e4       	ldi	r23, 0x42	; 66
    2ce2:	8f e0       	ldi	r24, 0x0F	; 15
    2ce4:	90 e0       	ldi	r25, 0x00	; 0
    2ce6:	a7 01       	movw	r20, r14
    2ce8:	96 01       	movw	r18, r12
    2cea:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    2cee:	f8 01       	movw	r30, r16
    2cf0:	22 af       	sts	0x72, r18
    2cf2:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2cf4:	e0 e4       	ldi	r30, 0x40	; 64
    2cf6:	f8 e0       	ldi	r31, 0x08	; 8
    2cf8:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2cfa:	8c e0       	ldi	r24, 0x0C	; 12
    2cfc:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2cfe:	8f 89       	ldd	r24, Y+23	; 0x17
    2d00:	98 8d       	ldd	r25, Y+24	; 0x18
    2d02:	86 a3       	lds	r24, 0x56
    2d04:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2d06:	80 ec       	ldi	r24, 0xC0	; 192
    2d08:	d1 01       	movw	r26, r2
    2d0a:	11 96       	adiw	r26, 0x01	; 1
    2d0c:	8c 93       	st	X, r24
    2d0e:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2d10:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2d12:	80 81       	ld	r24, Z
    2d14:	80 7f       	andi	r24, 0xF0	; 240
    2d16:	89 60       	ori	r24, 0x09	; 9
    2d18:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2d1a:	f8 01       	movw	r30, r16
    2d1c:	80 81       	ld	r24, Z
    2d1e:	80 7f       	andi	r24, 0xF0	; 240
    2d20:	81 60       	ori	r24, 0x01	; 1
    2d22:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    2d24:	e0 ea       	ldi	r30, 0xA0	; 160
    2d26:	f0 e0       	ldi	r31, 0x00	; 0
    2d28:	82 81       	ldd	r24, Z+2	; 0x02
    2d2a:	87 60       	ori	r24, 0x07	; 7
    2d2c:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2d2e:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2d30:	0f 90       	pop	r0
    2d32:	0f 90       	pop	r0
    2d34:	df 91       	pop	r29
    2d36:	cf 91       	pop	r28
    2d38:	1f 91       	pop	r17
    2d3a:	0f 91       	pop	r16
    2d3c:	ff 90       	pop	r15
    2d3e:	ef 90       	pop	r14
    2d40:	df 90       	pop	r13
    2d42:	cf 90       	pop	r12
    2d44:	bf 90       	pop	r11
    2d46:	af 90       	pop	r10
    2d48:	9f 90       	pop	r9
    2d4a:	8f 90       	pop	r8
    2d4c:	7f 90       	pop	r7
    2d4e:	6f 90       	pop	r6
    2d50:	5f 90       	pop	r5
    2d52:	3f 90       	pop	r3
    2d54:	2f 90       	pop	r2
    2d56:	08 95       	ret

00002d58 <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2d58:	2f 92       	push	r2
    2d5a:	3f 92       	push	r3
    2d5c:	4f 92       	push	r4
    2d5e:	5f 92       	push	r5
    2d60:	6f 92       	push	r6
    2d62:	7f 92       	push	r7
    2d64:	8f 92       	push	r8
    2d66:	9f 92       	push	r9
    2d68:	af 92       	push	r10
    2d6a:	bf 92       	push	r11
    2d6c:	cf 92       	push	r12
    2d6e:	df 92       	push	r13
    2d70:	ef 92       	push	r14
    2d72:	ff 92       	push	r15
    2d74:	0f 93       	push	r16
    2d76:	1f 93       	push	r17
    2d78:	cf 93       	push	r28
    2d7a:	df 93       	push	r29
    2d7c:	00 d0       	rcall	.+0      	; 0x2d7e <CO_collectSeismic3Axises+0x26>
    2d7e:	0f 92       	push	r0
    2d80:	cd b7       	in	r28, 0x3d	; 61
    2d82:	de b7       	in	r29, 0x3e	; 62
    2d84:	dc 01       	movw	r26, r24
    2d86:	3b 01       	movw	r6, r22
    2d88:	94 2f       	mov	r25, r20
    2d8a:	32 2f       	mov	r19, r18
    2d8c:	28 01       	movw	r4, r16
    2d8e:	17 01       	movw	r2, r14
    2d90:	c9 82       	std	Y+1, r12	; 0x01
    2d92:	da 82       	std	Y+2, r13	; 0x02
    2d94:	ab 82       	std	Y+3, r10	; 0x03
    2d96:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    2d98:	4d b7       	in	r20, 0x3d	; 61
    2d9a:	5e b7       	in	r21, 0x3e	; 62
    2d9c:	47 50       	subi	r20, 0x07	; 7
    2d9e:	50 40       	sbci	r21, 0x00	; 0
    2da0:	4d bf       	out	0x3d, r20	; 61
    2da2:	5e bf       	out	0x3e, r21	; 62
    2da4:	6d b7       	in	r22, 0x3d	; 61
    2da6:	7e b7       	in	r23, 0x3e	; 62
    2da8:	6f 5f       	subi	r22, 0xFF	; 255
    2daa:	7f 4f       	sbci	r23, 0xFF	; 255
    2dac:	ed b7       	in	r30, 0x3d	; 61
    2dae:	fe b7       	in	r31, 0x3e	; 62
    2db0:	81 82       	std	Z+1, r8	; 0x01
    2db2:	92 82       	std	Z+2, r9	; 0x02
    2db4:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2db6:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2db8:	fb 01       	movw	r30, r22
    2dba:	42 83       	std	Z+2, r20	; 0x02
    2dbc:	53 83       	std	Z+3, r21	; 0x03
    2dbe:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2dc0:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2dc2:	44 83       	std	Z+4, r20	; 0x04
    2dc4:	55 83       	std	Z+5, r21	; 0x05
    2dc6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2dc8:	86 83       	std	Z+6, r24	; 0x06
    2dca:	84 ec       	ldi	r24, 0xC4	; 196
    2dcc:	bd 01       	movw	r22, r26
    2dce:	a3 01       	movw	r20, r6
    2dd0:	29 2f       	mov	r18, r25
    2dd2:	03 2f       	mov	r16, r19
    2dd4:	72 01       	movw	r14, r4
    2dd6:	61 01       	movw	r12, r2
    2dd8:	a9 80       	ldd	r10, Y+1	; 0x01
    2dda:	ba 80       	ldd	r11, Y+2	; 0x02
    2ddc:	8b 80       	ldd	r8, Y+3	; 0x03
    2dde:	9c 80       	ldd	r9, Y+4	; 0x04
    2de0:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <CO_collectSeismic3Axises_ext>
    2de4:	4d b7       	in	r20, 0x3d	; 61
    2de6:	5e b7       	in	r21, 0x3e	; 62
    2de8:	49 5f       	subi	r20, 0xF9	; 249
    2dea:	5f 4f       	sbci	r21, 0xFF	; 255
    2dec:	4d bf       	out	0x3d, r20	; 61
    2dee:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    2df0:	24 96       	adiw	r28, 0x04	; 4
    2df2:	cd bf       	out	0x3d, r28	; 61
    2df4:	de bf       	out	0x3e, r29	; 62
    2df6:	df 91       	pop	r29
    2df8:	cf 91       	pop	r28
    2dfa:	1f 91       	pop	r17
    2dfc:	0f 91       	pop	r16
    2dfe:	ff 90       	pop	r15
    2e00:	ef 90       	pop	r14
    2e02:	df 90       	pop	r13
    2e04:	cf 90       	pop	r12
    2e06:	bf 90       	pop	r11
    2e08:	af 90       	pop	r10
    2e0a:	9f 90       	pop	r9
    2e0c:	8f 90       	pop	r8
    2e0e:	7f 90       	pop	r7
    2e10:	6f 90       	pop	r6
    2e12:	5f 90       	pop	r5
    2e14:	4f 90       	pop	r4
    2e16:	3f 90       	pop	r3
    2e18:	2f 90       	pop	r2
    2e1a:	08 95       	ret

00002e1c <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2e1c:	6f 92       	push	r6
    2e1e:	7f 92       	push	r7
    2e20:	8f 92       	push	r8
    2e22:	9f 92       	push	r9
    2e24:	af 92       	push	r10
    2e26:	bf 92       	push	r11
    2e28:	cf 92       	push	r12
    2e2a:	df 92       	push	r13
    2e2c:	ef 92       	push	r14
    2e2e:	ff 92       	push	r15
    2e30:	0f 93       	push	r16
    2e32:	1f 93       	push	r17
    2e34:	cf 93       	push	r28
    2e36:	df 93       	push	r29
    2e38:	c8 2f       	mov	r28, r24
    2e3a:	b6 2e       	mov	r11, r22
    2e3c:	d4 2f       	mov	r29, r20
    2e3e:	49 01       	movw	r8, r18
    2e40:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    2e42:	e0 92 64 50 	sts	0x5064, r14
    2e46:	f0 92 65 50 	sts	0x5065, r15
	ADC_Sampling_Finished = 0;
    2e4a:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    2e4e:	c0 92 a8 50 	sts	0x50A8, r12
    2e52:	d0 92 a9 50 	sts	0x50A9, r13
	if(use_FRAM){
    2e56:	aa 20       	and	r10, r10
    2e58:	21 f0       	breq	.+8      	; 0x2e62 <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	80 93 49 40 	sts	0x4049, r24
    2e60:	02 c0       	rjmp	.+4      	; 0x2e66 <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    2e62:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2e66:	81 e0       	ldi	r24, 0x01	; 1
    2e68:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    2e6c:	8c 2f       	mov	r24, r28
    2e6e:	6d 2f       	mov	r22, r29
    2e70:	0e 94 b0 0a 	call	0x1560	; 0x1560 <set_ampGain>
	set_filter(filterConfig);
    2e74:	8b 2d       	mov	r24, r11
    2e76:	0e 94 e6 04 	call	0x9cc	; 0x9cc <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    2e7a:	8c 2f       	mov	r24, r28
    2e7c:	85 50       	subi	r24, 0x05	; 5
    2e7e:	83 30       	cpi	r24, 0x03	; 3
    2e80:	18 f4       	brcc	.+6      	; 0x2e88 <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2e82:	81 e0       	ldi	r24, 0x01	; 1
    2e84:	0e 94 ca 0c 	call	0x1994	; 0x1994 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2e88:	81 e0       	ldi	r24, 0x01	; 1
    2e8a:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <enableADCMUX>
	setADCInput(channel);
    2e8e:	8c 2f       	mov	r24, r28
    2e90:	0e 94 72 14 	call	0x28e4	; 0x28e4 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2e94:	84 e0       	ldi	r24, 0x04	; 4
    2e96:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2e9a:	84 e5       	ldi	r24, 0x54	; 84
    2e9c:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2ea0:	e0 ea       	ldi	r30, 0xA0	; 160
    2ea2:	f6 e0       	ldi	r31, 0x06	; 6
    2ea4:	ee 24       	eor	r14, r14
    2ea6:	e3 94       	inc	r14
    2ea8:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2eaa:	82 e0       	ldi	r24, 0x02	; 2
    2eac:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    2eae:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2eb0:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2eb2:	80 e2       	ldi	r24, 0x20	; 32
    2eb4:	e0 e8       	ldi	r30, 0x80	; 128
    2eb6:	f6 e0       	ldi	r31, 0x06	; 6
    2eb8:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2eba:	c0 e4       	ldi	r28, 0x40	; 64
    2ebc:	da e0       	ldi	r29, 0x0A	; 10
    2ebe:	83 e2       	ldi	r24, 0x23	; 35
    2ec0:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2ec2:	94 01       	movw	r18, r8
    2ec4:	40 e0       	ldi	r20, 0x00	; 0
    2ec6:	50 e0       	ldi	r21, 0x00	; 0
    2ec8:	60 e8       	ldi	r22, 0x80	; 128
    2eca:	74 e8       	ldi	r23, 0x84	; 132
    2ecc:	8e e1       	ldi	r24, 0x1E	; 30
    2ece:	90 e0       	ldi	r25, 0x00	; 0
    2ed0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    2ed4:	89 01       	movw	r16, r18
    2ed6:	9a 01       	movw	r18, r20
    2ed8:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    2eda:	0e a3       	lds	r16, 0x5e
    2edc:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    2ede:	96 95       	lsr	r25
    2ee0:	87 95       	ror	r24
    2ee2:	8a af       	sts	0x7a, r24
    2ee4:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2ee6:	e0 e4       	ldi	r30, 0x40	; 64
    2ee8:	f8 e0       	ldi	r31, 0x08	; 8
    2eea:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    2eec:	8c e0       	ldi	r24, 0x0C	; 12
    2eee:	81 87       	std	Z+9, r24	; 0x09
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    2ef0:	66 a2       	lds	r22, 0x96
    2ef2:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2ef4:	88 e7       	ldi	r24, 0x78	; 120
    2ef6:	a0 e8       	ldi	r26, 0x80	; 128
    2ef8:	b1 e0       	ldi	r27, 0x01	; 1
    2efa:	11 96       	adiw	r26, 0x01	; 1
    2efc:	8c 93       	st	X, r24
    2efe:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2f00:	e6 82       	std	Z+6, r14	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2f02:	88 81       	ld	r24, Y
    2f04:	80 7f       	andi	r24, 0xF0	; 240
    2f06:	81 60       	ori	r24, 0x01	; 1
    2f08:	88 83       	st	Y, r24
	
	sampleCount = 0;
    2f0a:	10 92 66 50 	sts	0x5066, r1
    2f0e:	10 92 67 50 	sts	0x5067, r1
    2f12:	10 92 68 50 	sts	0x5068, r1
    2f16:	10 92 69 50 	sts	0x5069, r1
	discardCount = 0;
    2f1a:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2f1e:	e0 ea       	ldi	r30, 0xA0	; 160
    2f20:	f0 e0       	ldi	r31, 0x00	; 0
    2f22:	82 81       	ldd	r24, Z+2	; 0x02
    2f24:	83 60       	ori	r24, 0x03	; 3
    2f26:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2f28:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2f2a:	df 91       	pop	r29
    2f2c:	cf 91       	pop	r28
    2f2e:	1f 91       	pop	r17
    2f30:	0f 91       	pop	r16
    2f32:	ff 90       	pop	r15
    2f34:	ef 90       	pop	r14
    2f36:	df 90       	pop	r13
    2f38:	cf 90       	pop	r12
    2f3a:	bf 90       	pop	r11
    2f3c:	af 90       	pop	r10
    2f3e:	9f 90       	pop	r9
    2f40:	8f 90       	pop	r8
    2f42:	7f 90       	pop	r7
    2f44:	6f 90       	pop	r6
    2f46:	08 95       	ret

00002f48 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2f48:	8f 92       	push	r8
    2f4a:	9f 92       	push	r9
    2f4c:	af 92       	push	r10
    2f4e:	cf 92       	push	r12
    2f50:	df 92       	push	r13
    2f52:	ef 92       	push	r14
    2f54:	ff 92       	push	r15
    2f56:	0f 93       	push	r16
    2f58:	1f 93       	push	r17
    2f5a:	cf 93       	push	r28
    2f5c:	df 93       	push	r29
    2f5e:	96 2f       	mov	r25, r22
    2f60:	fa 01       	movw	r30, r20
    2f62:	d9 01       	movw	r26, r18
    2f64:	e8 01       	movw	r28, r16
    2f66:	47 01       	movw	r8, r14
    2f68:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    2f6a:	61 ec       	ldi	r22, 0xC1	; 193
    2f6c:	49 2f       	mov	r20, r25
    2f6e:	9f 01       	movw	r18, r30
    2f70:	8d 01       	movw	r16, r26
    2f72:	7e 01       	movw	r14, r28
    2f74:	64 01       	movw	r12, r8
    2f76:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <CO_collectADC_ext>
}
    2f7a:	df 91       	pop	r29
    2f7c:	cf 91       	pop	r28
    2f7e:	1f 91       	pop	r17
    2f80:	0f 91       	pop	r16
    2f82:	ff 90       	pop	r15
    2f84:	ef 90       	pop	r14
    2f86:	df 90       	pop	r13
    2f88:	cf 90       	pop	r12
    2f8a:	af 90       	pop	r10
    2f8c:	9f 90       	pop	r9
    2f8e:	8f 90       	pop	r8
    2f90:	08 95       	ret

00002f92 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2f92:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2f94:	81 e0       	ldi	r24, 0x01	; 1
    2f96:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2f98:	84 81       	ldd	r24, Z+4	; 0x04
    2f9a:	95 81       	ldd	r25, Z+5	; 0x05
    2f9c:	86 1b       	sub	r24, r22
    2f9e:	91 09       	sbc	r25, r1

	return answer;
}
    2fa0:	08 95       	ret

00002fa2 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2fa2:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2fa4:	81 e0       	ldi	r24, 0x01	; 1
    2fa6:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2fa8:	84 81       	ldd	r24, Z+4	; 0x04
    2faa:	95 81       	ldd	r25, Z+5	; 0x05
    2fac:	77 27       	eor	r23, r23
    2fae:	67 fd       	sbrc	r22, 7
    2fb0:	70 95       	com	r23
    2fb2:	86 1b       	sub	r24, r22
    2fb4:	97 0b       	sbc	r25, r23

	return answer;
}
    2fb6:	08 95       	ret

00002fb8 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2fb8:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2fba:	81 e0       	ldi	r24, 0x01	; 1
    2fbc:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    2fbe:	84 81       	ldd	r24, Z+4	; 0x04
    2fc0:	95 81       	ldd	r25, Z+5	; 0x05
}
    2fc2:	08 95       	ret

00002fc4 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2fc4:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2fc6:	81 e0       	ldi	r24, 0x01	; 1
    2fc8:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2fca:	84 81       	ldd	r24, Z+4	; 0x04
}
    2fcc:	08 95       	ret

00002fce <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    2fce:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2fd0:	81 e0       	ldi	r24, 0x01	; 1
    2fd2:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2fd4:	85 81       	ldd	r24, Z+5	; 0x05
}
    2fd6:	08 95       	ret

00002fd8 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2fd8:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2fda:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    2fdc:	14 82       	std	Z+4, r1	; 0x04
    2fde:	9a e2       	ldi	r25, 0x2A	; 42
    2fe0:	9a 95       	dec	r25
    2fe2:	f1 f7       	brne	.-4      	; 0x2fe0 <ADC_Wait_8MHz+0x8>
    2fe4:	00 c0       	rjmp	.+0      	; 0x2fe6 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2fe6:	84 83       	std	Z+4, r24	; 0x04
}
    2fe8:	08 95       	ret

00002fea <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2fea:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2fec:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    2fee:	91 e0       	ldi	r25, 0x01	; 1
    2ff0:	94 83       	std	Z+4, r25	; 0x04
    2ff2:	95 e5       	ldi	r25, 0x55	; 85
    2ff4:	9a 95       	dec	r25
    2ff6:	f1 f7       	brne	.-4      	; 0x2ff4 <ADC_Wait_32MHz+0xa>
    2ff8:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2ffa:	84 83       	std	Z+4, r24	; 0x04
}
    2ffc:	08 95       	ret

00002ffe <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2ffe:	ef 92       	push	r14
    3000:	ff 92       	push	r15
    3002:	0f 93       	push	r16
    3004:	1f 93       	push	r17
    3006:	cf 93       	push	r28
    3008:	df 93       	push	r29
    300a:	eb 01       	movw	r28, r22
    if (oversampling)
    300c:	44 23       	and	r20, r20
    300e:	c9 f0       	breq	.+50     	; 0x3042 <ADC_Offset_Get_Unsigned+0x44>
    3010:	04 e0       	ldi	r16, 0x04	; 4
    3012:	10 e0       	ldi	r17, 0x00	; 0
    3014:	ee 24       	eor	r14, r14
    3016:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3018:	88 81       	ld	r24, Y
    301a:	80 68       	ori	r24, 0x80	; 128
    301c:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    301e:	8b 81       	ldd	r24, Y+3	; 0x03
    3020:	80 ff       	sbrs	r24, 0
    3022:	fd cf       	rjmp	.-6      	; 0x301e <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3024:	ce 01       	movw	r24, r28
    3026:	60 e0       	ldi	r22, 0x00	; 0
    3028:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <ADC_ResultCh_GetWord_Unsigned>
    302c:	e8 0e       	add	r14, r24
    302e:	f9 1e       	adc	r15, r25
    3030:	01 50       	subi	r16, 0x01	; 1
    3032:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3034:	89 f7       	brne	.-30     	; 0x3018 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3036:	c7 01       	movw	r24, r14
    3038:	96 95       	lsr	r25
    303a:	87 95       	ror	r24
    303c:	96 95       	lsr	r25
    303e:	87 95       	ror	r24
    3040:	09 c0       	rjmp	.+18     	; 0x3054 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3042:	88 81       	ld	r24, Y
    3044:	80 68       	ori	r24, 0x80	; 128
    3046:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3048:	8b 81       	ldd	r24, Y+3	; 0x03
    304a:	80 ff       	sbrs	r24, 0
    304c:	fd cf       	rjmp	.-6      	; 0x3048 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    304e:	ce 01       	movw	r24, r28
    3050:	0e 94 dc 17 	call	0x2fb8	; 0x2fb8 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    3054:	df 91       	pop	r29
    3056:	cf 91       	pop	r28
    3058:	1f 91       	pop	r17
    305a:	0f 91       	pop	r16
    305c:	ff 90       	pop	r15
    305e:	ef 90       	pop	r14
    3060:	08 95       	ret

00003062 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3062:	ef 92       	push	r14
    3064:	ff 92       	push	r15
    3066:	0f 93       	push	r16
    3068:	1f 93       	push	r17
    306a:	cf 93       	push	r28
    306c:	df 93       	push	r29
    306e:	eb 01       	movw	r28, r22
    if (oversampling)
    3070:	44 23       	and	r20, r20
    3072:	e1 f0       	breq	.+56     	; 0x30ac <ADC_Offset_Get_Signed+0x4a>
    3074:	04 e0       	ldi	r16, 0x04	; 4
    3076:	10 e0       	ldi	r17, 0x00	; 0
    3078:	ee 24       	eor	r14, r14
    307a:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    307c:	88 81       	ld	r24, Y
    307e:	80 68       	ori	r24, 0x80	; 128
    3080:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3082:	8b 81       	ldd	r24, Y+3	; 0x03
    3084:	80 ff       	sbrs	r24, 0
    3086:	fd cf       	rjmp	.-6      	; 0x3082 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3088:	ce 01       	movw	r24, r28
    308a:	60 e0       	ldi	r22, 0x00	; 0
    308c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <ADC_ResultCh_GetWord_Signed>
    3090:	e8 0e       	add	r14, r24
    3092:	f9 1e       	adc	r15, r25
    3094:	01 50       	subi	r16, 0x01	; 1
    3096:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3098:	89 f7       	brne	.-30     	; 0x307c <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    309a:	c7 01       	movw	r24, r14
    309c:	99 23       	and	r25, r25
    309e:	0c f4       	brge	.+2      	; 0x30a2 <ADC_Offset_Get_Signed+0x40>
    30a0:	03 96       	adiw	r24, 0x03	; 3
    30a2:	95 95       	asr	r25
    30a4:	87 95       	ror	r24
    30a6:	95 95       	asr	r25
    30a8:	87 95       	ror	r24
    30aa:	0a c0       	rjmp	.+20     	; 0x30c0 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    30ac:	88 81       	ld	r24, Y
    30ae:	80 68       	ori	r24, 0x80	; 128
    30b0:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    30b2:	8b 81       	ldd	r24, Y+3	; 0x03
    30b4:	80 ff       	sbrs	r24, 0
    30b6:	fd cf       	rjmp	.-6      	; 0x30b2 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    30b8:	ce 01       	movw	r24, r28
    30ba:	60 e0       	ldi	r22, 0x00	; 0
    30bc:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	1f 91       	pop	r17
    30c6:	0f 91       	pop	r16
    30c8:	ff 90       	pop	r15
    30ca:	ef 90       	pop	r14
    30cc:	08 95       	ret

000030ce <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    30ce:	aa ec       	ldi	r26, 0xCA	; 202
    30d0:	b1 e0       	ldi	r27, 0x01	; 1
    30d2:	92 e0       	ldi	r25, 0x02	; 2
    30d4:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    30d6:	e8 2f       	mov	r30, r24
    30d8:	f0 e0       	ldi	r31, 0x00	; 0
    30da:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    30dc:	1c 92       	st	X, r1

	return result;
}
    30de:	08 95       	ret

000030e0 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    30e0:	cf 93       	push	r28
    30e2:	df 93       	push	r29
    30e4:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    30e6:	82 e0       	ldi	r24, 0x02	; 2
    30e8:	c0 30       	cpi	r28, 0x00	; 0
    30ea:	d8 07       	cpc	r29, r24
    30ec:	59 f4       	brne	.+22     	; 0x3104 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    30ee:	80 e2       	ldi	r24, 0x20	; 32
    30f0:	0e 94 67 18 	call	0x30ce	; 0x30ce <SP_ReadCalibrationByte>
    30f4:	c0 e0       	ldi	r28, 0x00	; 0
    30f6:	d2 e0       	ldi	r29, 0x02	; 2
    30f8:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    30fa:	81 e2       	ldi	r24, 0x21	; 33
    30fc:	0e 94 67 18 	call	0x30ce	; 0x30ce <SP_ReadCalibrationByte>
    3100:	8d 87       	std	Y+13, r24	; 0x0d
    3102:	08 c0       	rjmp	.+16     	; 0x3114 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3104:	84 e2       	ldi	r24, 0x24	; 36
    3106:	0e 94 67 18 	call	0x30ce	; 0x30ce <SP_ReadCalibrationByte>
    310a:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    310c:	85 e2       	ldi	r24, 0x25	; 37
    310e:	0e 94 67 18 	call	0x30ce	; 0x30ce <SP_ReadCalibrationByte>
    3112:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    3114:	df 91       	pop	r29
    3116:	cf 91       	pop	r28
    3118:	08 95       	ret

0000311a <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    311a:	84 e1       	ldi	r24, 0x14	; 20
    311c:	e5 e1       	ldi	r30, 0x15	; 21
    311e:	f1 e2       	ldi	r31, 0x21	; 33
    3120:	df 01       	movw	r26, r30
    3122:	1d 92       	st	X+, r1
    3124:	8a 95       	dec	r24
    3126:	e9 f7       	brne	.-6      	; 0x3122 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    3128:	0e 94 ee 19 	call	0x33dc	; 0x33dc <chb_get_short_addr>
    312c:	80 93 15 21 	sts	0x2115, r24
    3130:	90 93 16 21 	sts	0x2116, r25
    chb_drvr_init();
    3134:	0e 94 40 1c 	call	0x3880	; 0x3880 <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    3138:	08 95       	ret

0000313a <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    313a:	e0 e8       	ldi	r30, 0x80	; 128
    313c:	f6 e0       	ldi	r31, 0x06	; 6
    313e:	84 e0       	ldi	r24, 0x04	; 4
    3140:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3142:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3144:	92 e0       	ldi	r25, 0x02	; 2
    3146:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3148:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    314a:	83 e0       	ldi	r24, 0x03	; 3
    314c:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    314e:	e0 ea       	ldi	r30, 0xA0	; 160
    3150:	f0 e0       	ldi	r31, 0x00	; 0
    3152:	82 81       	ldd	r24, Z+2	; 0x02
    3154:	84 60       	ori	r24, 0x04	; 4
    3156:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3158:	78 94       	sei
}
    315a:	08 95       	ret

0000315c <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    315c:	85 e1       	ldi	r24, 0x15	; 21
    315e:	91 e2       	ldi	r25, 0x21	; 33
    3160:	08 95       	ret

00003162 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3162:	2f 92       	push	r2
    3164:	3f 92       	push	r3
    3166:	4f 92       	push	r4
    3168:	5f 92       	push	r5
    316a:	6f 92       	push	r6
    316c:	7f 92       	push	r7
    316e:	8f 92       	push	r8
    3170:	9f 92       	push	r9
    3172:	af 92       	push	r10
    3174:	bf 92       	push	r11
    3176:	cf 92       	push	r12
    3178:	df 92       	push	r13
    317a:	ef 92       	push	r14
    317c:	ff 92       	push	r15
    317e:	0f 93       	push	r16
    3180:	1f 93       	push	r17
    3182:	cf 93       	push	r28
    3184:	df 93       	push	r29
    3186:	cd b7       	in	r28, 0x3d	; 61
    3188:	de b7       	in	r29, 0x3e	; 62
    318a:	2a 97       	sbiw	r28, 0x0a	; 10
    318c:	cd bf       	out	0x3d, r28	; 61
    318e:	de bf       	out	0x3e, r29	; 62
    3190:	2c 01       	movw	r4, r24
    3192:	1b 01       	movw	r2, r22
    3194:	69 01       	movw	r12, r18
    3196:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3198:	21 15       	cp	r18, r1
    319a:	31 05       	cpc	r19, r1
    319c:	41 05       	cpc	r20, r1
    319e:	51 05       	cpc	r21, r1
    31a0:	09 f4       	brne	.+2      	; 0x31a4 <chb_write+0x42>
    31a2:	68 c0       	rjmp	.+208    	; 0x3274 <chb_write+0x112>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    31a4:	88 24       	eor	r8, r8
    31a6:	99 24       	eor	r9, r9
    31a8:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    31aa:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    31ac:	0f 2e       	mov	r0, r31
    31ae:	f7 e1       	ldi	r31, 0x17	; 23
    31b0:	6f 2e       	mov	r6, r31
    31b2:	f1 e2       	ldi	r31, 0x21	; 33
    31b4:	7f 2e       	mov	r7, r31
    31b6:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    31b8:	1c 2d       	mov	r17, r12
    31ba:	85 e6       	ldi	r24, 0x65	; 101
    31bc:	c8 16       	cp	r12, r24
    31be:	d1 04       	cpc	r13, r1
    31c0:	e1 04       	cpc	r14, r1
    31c2:	f1 04       	cpc	r15, r1
    31c4:	08 f0       	brcs	.+2      	; 0x31c8 <chb_write+0x66>
    31c6:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    31c8:	81 2f       	mov	r24, r17
    31ca:	85 5f       	subi	r24, 0xF5	; 245
    31cc:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    31ce:	9f ef       	ldi	r25, 0xFF	; 255
    31d0:	49 16       	cp	r4, r25
    31d2:	9f ef       	ldi	r25, 0xFF	; 255
    31d4:	59 06       	cpc	r5, r25
    31d6:	11 f0       	breq	.+4      	; 0x31dc <chb_write+0x7a>
    31d8:	81 e6       	ldi	r24, 0x61	; 97
    31da:	01 c0       	rjmp	.+2      	; 0x31de <chb_write+0x7c>
    31dc:	81 e4       	ldi	r24, 0x41	; 65
    31de:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    31e0:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    31e2:	f3 01       	movw	r30, r6
    31e4:	80 81       	ld	r24, Z
    31e6:	8c 83       	std	Y+4, r24	; 0x04
    31e8:	8f 5f       	subi	r24, 0xFF	; 255
    31ea:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    31ec:	84 e3       	ldi	r24, 0x34	; 52
    31ee:	92 e1       	ldi	r25, 0x12	; 18
    31f0:	8d 83       	std	Y+5, r24	; 0x05
    31f2:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    31f4:	4f 82       	std	Y+7, r4	; 0x07
    31f6:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    31f8:	e5 e1       	ldi	r30, 0x15	; 21
    31fa:	f1 e2       	ldi	r31, 0x21	; 33
    31fc:	80 81       	ld	r24, Z
    31fe:	91 81       	ldd	r25, Z+1	; 0x01
    3200:	89 87       	std	Y+9, r24	; 0x09
    3202:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3204:	b1 01       	movw	r22, r2
    3206:	68 0d       	add	r22, r8
    3208:	79 1d       	adc	r23, r9
    320a:	ce 01       	movw	r24, r28
    320c:	01 96       	adiw	r24, 0x01	; 1
    320e:	41 2f       	mov	r20, r17
    3210:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <chb_tx>

             switch (status)
    3214:	83 30       	cpi	r24, 0x03	; 3
    3216:	c9 f0       	breq	.+50     	; 0x324a <chb_write+0xe8>
    3218:	84 30       	cpi	r24, 0x04	; 4
    321a:	18 f4       	brcc	.+6      	; 0x3222 <chb_write+0xc0>
    321c:	81 30       	cpi	r24, 0x01	; 1
    321e:	e1 f4       	brne	.+56     	; 0x3258 <chb_write+0xf6>
    3220:	04 c0       	rjmp	.+8      	; 0x322a <chb_write+0xc8>
    3222:	85 30       	cpi	r24, 0x05	; 5
    3224:	51 f0       	breq	.+20     	; 0x323a <chb_write+0xd8>
    3226:	80 34       	cpi	r24, 0x40	; 64
    3228:	b9 f4       	brne	.+46     	; 0x3258 <chb_write+0xf6>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    322a:	ec e1       	ldi	r30, 0x1C	; 28
    322c:	f1 e2       	ldi	r31, 0x21	; 33
    322e:	80 81       	ld	r24, Z
    3230:	91 81       	ldd	r25, Z+1	; 0x01
    3232:	01 96       	adiw	r24, 0x01	; 1
    3234:	80 83       	st	Z, r24
    3236:	91 83       	std	Z+1, r25	; 0x01
                 break;
    3238:	0f c0       	rjmp	.+30     	; 0x3258 <chb_write+0xf6>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    323a:	ee e1       	ldi	r30, 0x1E	; 30
    323c:	f1 e2       	ldi	r31, 0x21	; 33
    323e:	80 81       	ld	r24, Z
    3240:	91 81       	ldd	r25, Z+1	; 0x01
    3242:	01 96       	adiw	r24, 0x01	; 1
    3244:	80 83       	st	Z, r24
    3246:	91 83       	std	Z+1, r25	; 0x01
				 //rtry++;
                 break;
    3248:	07 c0       	rjmp	.+14     	; 0x3258 <chb_write+0xf6>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    324a:	e0 e2       	ldi	r30, 0x20	; 32
    324c:	f1 e2       	ldi	r31, 0x21	; 33
    324e:	80 81       	ld	r24, Z
    3250:	91 81       	ldd	r25, Z+1	; 0x01
    3252:	01 96       	adiw	r24, 0x01	; 1
    3254:	80 83       	st	Z, r24
    3256:	91 83       	std	Z+1, r25	; 0x01
             }
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    3258:	81 2f       	mov	r24, r17
    325a:	90 e0       	ldi	r25, 0x00	; 0
    325c:	a0 e0       	ldi	r26, 0x00	; 0
    325e:	b0 e0       	ldi	r27, 0x00	; 0
    3260:	88 0e       	add	r8, r24
    3262:	99 1e       	adc	r9, r25
    3264:	aa 1e       	adc	r10, r26
    3266:	bb 1e       	adc	r11, r27
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    3268:	c8 1a       	sub	r12, r24
    326a:	d9 0a       	sbc	r13, r25
    326c:	ea 0a       	sbc	r14, r26
    326e:	fb 0a       	sbc	r15, r27
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3270:	09 f0       	breq	.+2      	; 0x3274 <chb_write+0x112>
    3272:	a2 cf       	rjmp	.-188    	; 0x31b8 <chb_write+0x56>
		frm_offset += frm_len;
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
    return CHB_SUCCESS;
}
    3274:	80 e0       	ldi	r24, 0x00	; 0
    3276:	2a 96       	adiw	r28, 0x0a	; 10
    3278:	cd bf       	out	0x3d, r28	; 61
    327a:	de bf       	out	0x3e, r29	; 62
    327c:	df 91       	pop	r29
    327e:	cf 91       	pop	r28
    3280:	1f 91       	pop	r17
    3282:	0f 91       	pop	r16
    3284:	ff 90       	pop	r15
    3286:	ef 90       	pop	r14
    3288:	df 90       	pop	r13
    328a:	cf 90       	pop	r12
    328c:	bf 90       	pop	r11
    328e:	af 90       	pop	r10
    3290:	9f 90       	pop	r9
    3292:	8f 90       	pop	r8
    3294:	7f 90       	pop	r7
    3296:	6f 90       	pop	r6
    3298:	5f 90       	pop	r5
    329a:	4f 90       	pop	r4
    329c:	3f 90       	pop	r3
    329e:	2f 90       	pop	r2
    32a0:	08 95       	ret

000032a2 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    32a2:	df 92       	push	r13
    32a4:	ef 92       	push	r14
    32a6:	ff 92       	push	r15
    32a8:	0f 93       	push	r16
    32aa:	1f 93       	push	r17
    32ac:	cf 93       	push	r28
    32ae:	df 93       	push	r29
    32b0:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    32b2:	0e 94 cc 19 	call	0x3398	; 0x3398 <chb_buf_read>
    32b6:	d8 2e       	mov	r13, r24
    32b8:	88 23       	and	r24, r24
    32ba:	0c f4       	brge	.+2      	; 0x32be <chb_read+0x1c>
    32bc:	46 c0       	rjmp	.+140    	; 0x334a <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    32be:	f7 01       	movw	r30, r14
    32c0:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    32c2:	88 23       	and	r24, r24
    32c4:	71 f0       	breq	.+28     	; 0x32e2 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    32c6:	e7 01       	movw	r28, r14
    32c8:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    32ca:	87 01       	movw	r16, r14
    32cc:	09 5f       	subi	r16, 0xF9	; 249
    32ce:	1f 4f       	sbci	r17, 0xFF	; 255
    32d0:	81 50       	subi	r24, 0x01	; 1
    32d2:	08 0f       	add	r16, r24
    32d4:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    32d6:	0e 94 cc 19 	call	0x3398	; 0x3398 <chb_buf_read>
    32da:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    32dc:	c0 17       	cp	r28, r16
    32de:	d1 07       	cpc	r29, r17
    32e0:	d1 f7       	brne	.-12     	; 0x32d6 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    32e2:	f7 01       	movw	r30, r14
    32e4:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    32e6:	83 85       	ldd	r24, Z+11	; 0x0b
    32e8:	94 85       	ldd	r25, Z+12	; 0x0c
    32ea:	83 83       	std	Z+3, r24	; 0x03
    32ec:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    32ee:	85 85       	ldd	r24, Z+13	; 0x0d
    32f0:	96 85       	ldd	r25, Z+14	; 0x0e
    32f2:	81 83       	std	Z+1, r24	; 0x01
    32f4:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    32f6:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <chb_buf_get_len>
    32fa:	88 23       	and	r24, r24
    32fc:	11 f4       	brne	.+4      	; 0x3302 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    32fe:	10 92 18 21 	sts	0x2118, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    3302:	80 91 0a 20 	lds	r24, 0x200A
    3306:	c8 17       	cp	r28, r24
    3308:	51 f4       	brne	.+20     	; 0x331e <chb_read+0x7c>
    330a:	f7 01       	movw	r30, r14
    330c:	21 81       	ldd	r18, Z+1	; 0x01
    330e:	32 81       	ldd	r19, Z+2	; 0x02
    3310:	80 91 0b 20 	lds	r24, 0x200B
    3314:	90 91 0c 20 	lds	r25, 0x200C
    3318:	28 17       	cp	r18, r24
    331a:	39 07       	cpc	r19, r25
    331c:	c1 f0       	breq	.+48     	; 0x334e <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    331e:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    3322:	f7 01       	movw	r30, r14
    3324:	81 81       	ldd	r24, Z+1	; 0x01
    3326:	92 81       	ldd	r25, Z+2	; 0x02
    3328:	80 93 0b 20 	sts	0x200B, r24
    332c:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    3330:	b7 01       	movw	r22, r14
    3332:	61 5f       	subi	r22, 0xF1	; 241
    3334:	7f 4f       	sbci	r23, 0xFF	; 255
    3336:	4d 2d       	mov	r20, r13
    3338:	50 e0       	ldi	r21, 0x00	; 0
    333a:	49 50       	subi	r20, 0x09	; 9
    333c:	50 40       	sbci	r21, 0x00	; 0
    333e:	c7 01       	movw	r24, r14
    3340:	0e 94 70 38 	call	0x70e0	; 0x70e0 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    3344:	8d 2d       	mov	r24, r13
    3346:	8b 50       	subi	r24, 0x0B	; 11
    3348:	03 c0       	rjmp	.+6      	; 0x3350 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    334a:	80 e0       	ldi	r24, 0x00	; 0
    334c:	01 c0       	rjmp	.+2      	; 0x3350 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    334e:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    3350:	df 91       	pop	r29
    3352:	cf 91       	pop	r28
    3354:	1f 91       	pop	r17
    3356:	0f 91       	pop	r16
    3358:	ff 90       	pop	r15
    335a:	ef 90       	pop	r14
    335c:	df 90       	pop	r13
    335e:	08 95       	ret

00003360 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    3360:	10 92 29 21 	sts	0x2129, r1
    wr_ptr = 0;
    3364:	10 92 2a 21 	sts	0x212A, r1
    len = 0;
    3368:	10 92 2b 21 	sts	0x212B, r1
}
    336c:	08 95       	ret

0000336e <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    336e:	20 91 2a 21 	lds	r18, 0x212A
    3372:	30 e0       	ldi	r19, 0x00	; 0
    3374:	f9 01       	movw	r30, r18
    3376:	e4 5d       	subi	r30, 0xD4	; 212
    3378:	fe 4d       	sbci	r31, 0xDE	; 222
    337a:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    337c:	c9 01       	movw	r24, r18
    337e:	01 96       	adiw	r24, 0x01	; 1
    3380:	60 e8       	ldi	r22, 0x80	; 128
    3382:	70 e0       	ldi	r23, 0x00	; 0
    3384:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    3388:	80 93 2a 21 	sts	0x212A, r24
    len++;
    338c:	80 91 2b 21 	lds	r24, 0x212B
    3390:	8f 5f       	subi	r24, 0xFF	; 255
    3392:	80 93 2b 21 	sts	0x212B, r24
}
    3396:	08 95       	ret

00003398 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    3398:	20 91 29 21 	lds	r18, 0x2129
    339c:	30 e0       	ldi	r19, 0x00	; 0
    339e:	f9 01       	movw	r30, r18
    33a0:	e4 5d       	subi	r30, 0xD4	; 212
    33a2:	fe 4d       	sbci	r31, 0xDE	; 222
    33a4:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    33a6:	2f 5f       	subi	r18, 0xFF	; 255
    33a8:	3f 4f       	sbci	r19, 0xFF	; 255
    33aa:	c9 01       	movw	r24, r18
    33ac:	60 e8       	ldi	r22, 0x80	; 128
    33ae:	70 e0       	ldi	r23, 0x00	; 0
    33b0:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    33b4:	80 93 29 21 	sts	0x2129, r24
    len--;
    33b8:	80 91 2b 21 	lds	r24, 0x212B
    33bc:	81 50       	subi	r24, 0x01	; 1
    33be:	80 93 2b 21 	sts	0x212B, r24
    return data;
}
    33c2:	84 2f       	mov	r24, r20
    33c4:	08 95       	ret

000033c6 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    33c6:	80 91 2b 21 	lds	r24, 0x212B
    33ca:	08 95       	ret

000033cc <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    33cc:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    33ce:	80 e0       	ldi	r24, 0x00	; 0
    33d0:	90 e0       	ldi	r25, 0x00	; 0
    33d2:	48 e0       	ldi	r20, 0x08	; 8
    33d4:	50 e0       	ldi	r21, 0x00	; 0
    33d6:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <chb_eeprom_read>
}
    33da:	08 95       	ret

000033dc <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    33dc:	cf 93       	push	r28
    33de:	df 93       	push	r29
    33e0:	0f 92       	push	r0
    33e2:	0f 92       	push	r0
    33e4:	cd b7       	in	r28, 0x3d	; 61
    33e6:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    33e8:	89 e0       	ldi	r24, 0x09	; 9
    33ea:	90 e0       	ldi	r25, 0x00	; 0
    33ec:	be 01       	movw	r22, r28
    33ee:	6f 5f       	subi	r22, 0xFF	; 255
    33f0:	7f 4f       	sbci	r23, 0xFF	; 255
    33f2:	42 e0       	ldi	r20, 0x02	; 2
    33f4:	50 e0       	ldi	r21, 0x00	; 0
    33f6:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <chb_eeprom_read>
    return *(U16 *)addr;
}
    33fa:	89 81       	ldd	r24, Y+1	; 0x01
    33fc:	9a 81       	ldd	r25, Y+2	; 0x02
    33fe:	0f 90       	pop	r0
    3400:	0f 90       	pop	r0
    3402:	df 91       	pop	r29
    3404:	cf 91       	pop	r28
    3406:	08 95       	ret

00003408 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    3408:	88 23       	and	r24, r24
    340a:	29 f0       	breq	.+10     	; 0x3416 <RadioCS+0xe>
    340c:	80 e1       	ldi	r24, 0x10	; 16
    340e:	e0 e6       	ldi	r30, 0x60	; 96
    3410:	f6 e0       	ldi	r31, 0x06	; 6
    3412:	86 83       	std	Z+6, r24	; 0x06
    3414:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    3416:	80 e1       	ldi	r24, 0x10	; 16
    3418:	e0 e6       	ldi	r30, 0x60	; 96
    341a:	f6 e0       	ldi	r31, 0x06	; 6
    341c:	85 83       	std	Z+5, r24	; 0x05
    341e:	08 95       	ret

00003420 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    3420:	df 92       	push	r13
    3422:	ef 92       	push	r14
    3424:	ff 92       	push	r15
    3426:	0f 93       	push	r16
    3428:	1f 93       	push	r17
    342a:	cf 93       	push	r28
    342c:	df 93       	push	r29
    342e:	8c 01       	movw	r16, r24
    3430:	c6 2f       	mov	r28, r22
    3432:	7a 01       	movw	r14, r20
    3434:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    3436:	82 2f       	mov	r24, r18
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	86 0f       	add	r24, r22
    343c:	91 1d       	adc	r25, r1
    343e:	80 38       	cpi	r24, 0x80	; 128
    3440:	91 05       	cpc	r25, r1
    3442:	8c f5       	brge	.+98     	; 0x34a6 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3444:	8f b7       	in	r24, 0x3f	; 63
    3446:	80 93 58 40 	sts	0x4058, r24
    344a:	f8 94       	cli
    RadioCS(TRUE); 
    344c:	81 e0       	ldi	r24, 0x01	; 1
    344e:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    3452:	80 e6       	ldi	r24, 0x60	; 96
    3454:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3458:	cc 23       	and	r28, r28
    345a:	79 f0       	breq	.+30     	; 0x347a <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    345c:	c8 01       	movw	r24, r16
    345e:	01 96       	adiw	r24, 0x01	; 1
    3460:	c1 50       	subi	r28, 0x01	; 1
    3462:	9c 01       	movw	r18, r24
    3464:	2c 0f       	add	r18, r28
    3466:	31 1d       	adc	r19, r1
    3468:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    346a:	f8 01       	movw	r30, r16
    346c:	81 91       	ld	r24, Z+
    346e:	8f 01       	movw	r16, r30
    3470:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3474:	0c 17       	cp	r16, r28
    3476:	1d 07       	cpc	r17, r29
    3478:	c1 f7       	brne	.-16     	; 0x346a <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    347a:	dd 20       	and	r13, r13
    347c:	69 f0       	breq	.+26     	; 0x3498 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    347e:	e7 01       	movw	r28, r14
    3480:	21 96       	adiw	r28, 0x01	; 1
    3482:	da 94       	dec	r13
    3484:	cd 0d       	add	r28, r13
    3486:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    3488:	f7 01       	movw	r30, r14
    348a:	81 91       	ld	r24, Z+
    348c:	7f 01       	movw	r14, r30
    348e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3492:	ec 16       	cp	r14, r28
    3494:	fd 06       	cpc	r15, r29
    3496:	c1 f7       	brne	.-16     	; 0x3488 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    3498:	80 e0       	ldi	r24, 0x00	; 0
    349a:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>
    CHB_LEAVE_CRIT();
    349e:	80 91 58 40 	lds	r24, 0x4058
    34a2:	8f bf       	out	0x3f, r24	; 63
    34a4:	78 94       	sei
}
    34a6:	df 91       	pop	r29
    34a8:	cf 91       	pop	r28
    34aa:	1f 91       	pop	r17
    34ac:	0f 91       	pop	r16
    34ae:	ff 90       	pop	r15
    34b0:	ef 90       	pop	r14
    34b2:	df 90       	pop	r13
    34b4:	08 95       	ret

000034b6 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    34b6:	cf 93       	push	r28
    34b8:	df 93       	push	r29
    34ba:	d8 2f       	mov	r29, r24
    34bc:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    34be:	8f b7       	in	r24, 0x3f	; 63
    34c0:	80 93 58 40 	sts	0x4058, r24
    34c4:	f8 94       	cli
    RadioCS(TRUE);
    34c6:	81 e0       	ldi	r24, 0x01	; 1
    34c8:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    34cc:	8d 2f       	mov	r24, r29
    34ce:	80 6c       	ori	r24, 0xC0	; 192
    34d0:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    34d4:	8c 2f       	mov	r24, r28
    34d6:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>

    RadioCS(FALSE);
    34da:	80 e0       	ldi	r24, 0x00	; 0
    34dc:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>
    CHB_LEAVE_CRIT();
    34e0:	80 91 58 40 	lds	r24, 0x4058
    34e4:	8f bf       	out	0x3f, r24	; 63
    34e6:	78 94       	sei
}
    34e8:	df 91       	pop	r29
    34ea:	cf 91       	pop	r28
    34ec:	08 95       	ret

000034ee <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    34ee:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    34f0:	85 e0       	ldi	r24, 0x05	; 5
    34f2:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <chb_reg_write>
}
    34f6:	08 95       	ret

000034f8 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    34f8:	0f 93       	push	r16
    34fa:	1f 93       	push	r17
    34fc:	cf 93       	push	r28
    34fe:	df 93       	push	r29
    3500:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    3502:	c6 2f       	mov	r28, r22
    3504:	d7 2f       	mov	r29, r23
    3506:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    3508:	69 91       	ld	r22, Y+
    350a:	81 2f       	mov	r24, r17
    350c:	80 0f       	add	r24, r16
    350e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    3512:	1f 5f       	subi	r17, 0xFF	; 255
    3514:	18 30       	cpi	r17, 0x08	; 8
    3516:	c1 f7       	brne	.-16     	; 0x3508 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    3518:	df 91       	pop	r29
    351a:	cf 91       	pop	r28
    351c:	1f 91       	pop	r17
    351e:	0f 91       	pop	r16
    3520:	08 95       	ret

00003522 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3522:	cf 93       	push	r28
    3524:	df 93       	push	r29
    3526:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    3528:	80 e0       	ldi	r24, 0x00	; 0
    352a:	90 e0       	ldi	r25, 0x00	; 0
    352c:	be 01       	movw	r22, r28
    352e:	48 e0       	ldi	r20, 0x08	; 8
    3530:	50 e0       	ldi	r21, 0x00	; 0
    3532:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    3536:	84 e2       	ldi	r24, 0x24	; 36
    3538:	be 01       	movw	r22, r28
    353a:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <chb_reg_write64>
}
    353e:	df 91       	pop	r29
    3540:	cf 91       	pop	r28
    3542:	08 95       	ret

00003544 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3544:	cf 93       	push	r28
    3546:	df 93       	push	r29
    3548:	c8 2f       	mov	r28, r24
    354a:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    354c:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <chb_reg_write>
    3550:	8c 2f       	mov	r24, r28
    3552:	8f 5f       	subi	r24, 0xFF	; 255
    3554:	6d 2f       	mov	r22, r29
    3556:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <chb_reg_write>
    }
}
    355a:	df 91       	pop	r29
    355c:	cf 91       	pop	r28
    355e:	08 95       	ret

00003560 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    3560:	0f 93       	push	r16
    3562:	1f 93       	push	r17
    3564:	cf 93       	push	r28
    3566:	df 93       	push	r29
    3568:	0f 92       	push	r0
    356a:	0f 92       	push	r0
    356c:	cd b7       	in	r28, 0x3d	; 61
    356e:	de b7       	in	r29, 0x3e	; 62
    3570:	89 83       	std	Y+1, r24	; 0x01
    3572:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3574:	0e 94 ae 18 	call	0x315c	; 0x315c <chb_get_pcb>
    3578:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    357a:	89 e0       	ldi	r24, 0x09	; 9
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	be 01       	movw	r22, r28
    3580:	6f 5f       	subi	r22, 0xFF	; 255
    3582:	7f 4f       	sbci	r23, 0xFF	; 255
    3584:	42 e0       	ldi	r20, 0x02	; 2
    3586:	50 e0       	ldi	r21, 0x00	; 0
    3588:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    358c:	69 81       	ldd	r22, Y+1	; 0x01
    358e:	7a 81       	ldd	r23, Y+2	; 0x02
    3590:	80 e2       	ldi	r24, 0x20	; 32
    3592:	0e 94 a2 1a 	call	0x3544	; 0x3544 <chb_reg_write16>
    pcb->src_addr = addr;
    3596:	89 81       	ldd	r24, Y+1	; 0x01
    3598:	9a 81       	ldd	r25, Y+2	; 0x02
    359a:	f8 01       	movw	r30, r16
    359c:	80 83       	st	Z, r24
    359e:	91 83       	std	Z+1, r25	; 0x01
}
    35a0:	0f 90       	pop	r0
    35a2:	0f 90       	pop	r0
    35a4:	df 91       	pop	r29
    35a6:	cf 91       	pop	r28
    35a8:	1f 91       	pop	r17
    35aa:	0f 91       	pop	r16
    35ac:	08 95       	ret

000035ae <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    35ae:	cf 93       	push	r28
    35b0:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    35b2:	8f b7       	in	r24, 0x3f	; 63
    35b4:	80 93 58 40 	sts	0x4058, r24
    35b8:	f8 94       	cli
    RadioCS(TRUE);
    35ba:	81 e0       	ldi	r24, 0x01	; 1
    35bc:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    35c0:	8c 2f       	mov	r24, r28
    35c2:	80 68       	ori	r24, 0x80	; 128
    35c4:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    val = SPID_write(val);
    35c8:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    35cc:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    35ce:	80 e0       	ldi	r24, 0x00	; 0
    35d0:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>
    CHB_LEAVE_CRIT();
    35d4:	80 91 58 40 	lds	r24, 0x4058
    35d8:	8f bf       	out	0x3f, r24	; 63
    35da:	78 94       	sei

    return val;
}
    35dc:	8c 2f       	mov	r24, r28
    35de:	cf 91       	pop	r28
    35e0:	08 95       	ret

000035e2 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    35e2:	81 e0       	ldi	r24, 0x01	; 1
    35e4:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
}
    35e8:	8f 71       	andi	r24, 0x1F	; 31
    35ea:	08 95       	ret

000035ec <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    35ec:	1f 93       	push	r17
    35ee:	cf 93       	push	r28
    35f0:	df 93       	push	r29
    35f2:	c8 2f       	mov	r28, r24
    35f4:	16 2f       	mov	r17, r22
    35f6:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    35f8:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    35fc:	6d 2f       	mov	r22, r29
    35fe:	60 95       	com	r22
    3600:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    3602:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3604:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    3606:	8c 2f       	mov	r24, r28
    3608:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <chb_reg_write>
}
    360c:	df 91       	pop	r29
    360e:	cf 91       	pop	r28
    3610:	1f 91       	pop	r17
    3612:	08 95       	ret

00003614 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3614:	cf 93       	push	r28
    3616:	df 93       	push	r29
    3618:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    361a:	80 91 64 06 	lds	r24, 0x0664
    361e:	81 fd       	sbrc	r24, 1
    3620:	4b c0       	rjmp	.+150    	; 0x36b8 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3622:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <chb_get_state>
    3626:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    3628:	81 51       	subi	r24, 0x11	; 17
    362a:	82 30       	cpi	r24, 0x02	; 2
    362c:	20 f0       	brcs	.+8      	; 0x3636 <chb_set_state+0x22>
    362e:	c1 30       	cpi	r28, 0x01	; 1
    3630:	11 f0       	breq	.+4      	; 0x3636 <chb_set_state+0x22>
    3632:	c2 30       	cpi	r28, 0x02	; 2
    3634:	21 f4       	brne	.+8      	; 0x363e <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    3636:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <chb_get_state>
    363a:	8c 17       	cp	r24, r28
    363c:	e1 f3       	breq	.-8      	; 0x3636 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    363e:	d6 31       	cpi	r29, 0x16	; 22
    3640:	f9 f0       	breq	.+62     	; 0x3680 <chb_set_state+0x6c>
    3642:	d9 31       	cpi	r29, 0x19	; 25
    3644:	89 f0       	breq	.+34     	; 0x3668 <chb_set_state+0x54>
    3646:	d8 30       	cpi	r29, 0x08	; 8
    3648:	31 f5       	brne	.+76     	; 0x3696 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    364a:	e4 e6       	ldi	r30, 0x64	; 100
    364c:	f6 e0       	ldi	r31, 0x06	; 6
    364e:	80 81       	ld	r24, Z
    3650:	8d 7f       	andi	r24, 0xFD	; 253
    3652:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3654:	82 e0       	ldi	r24, 0x02	; 2
    3656:	63 e0       	ldi	r22, 0x03	; 3
    3658:	4f e1       	ldi	r20, 0x1F	; 31
    365a:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
    365e:	8a e0       	ldi	r24, 0x0A	; 10
    3660:	8a 95       	dec	r24
    3662:	f1 f7       	brne	.-4      	; 0x3660 <chb_set_state+0x4c>
    3664:	00 c0       	rjmp	.+0      	; 0x3666 <chb_set_state+0x52>
    3666:	17 c0       	rjmp	.+46     	; 0x3696 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3668:	c6 31       	cpi	r28, 0x16	; 22
    366a:	a9 f4       	brne	.+42     	; 0x3696 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    366c:	82 e0       	ldi	r24, 0x02	; 2
    366e:	69 e0       	ldi	r22, 0x09	; 9
    3670:	4f e1       	ldi	r20, 0x1F	; 31
    3672:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
    3676:	9a e0       	ldi	r25, 0x0A	; 10
    3678:	9a 95       	dec	r25
    367a:	f1 f7       	brne	.-4      	; 0x3678 <chb_set_state+0x64>
    367c:	00 c0       	rjmp	.+0      	; 0x367e <chb_set_state+0x6a>
    367e:	0b c0       	rjmp	.+22     	; 0x3696 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    3680:	c9 31       	cpi	r28, 0x19	; 25
    3682:	49 f4       	brne	.+18     	; 0x3696 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3684:	82 e0       	ldi	r24, 0x02	; 2
    3686:	69 e0       	ldi	r22, 0x09	; 9
    3688:	4f e1       	ldi	r20, 0x1F	; 31
    368a:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
    368e:	8a e0       	ldi	r24, 0x0A	; 10
    3690:	8a 95       	dec	r24
    3692:	f1 f7       	brne	.-4      	; 0x3690 <chb_set_state+0x7c>
    3694:	00 c0       	rjmp	.+0      	; 0x3696 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3696:	82 e0       	ldi	r24, 0x02	; 2
    3698:	6d 2f       	mov	r22, r29
    369a:	4f e1       	ldi	r20, 0x1F	; 31
    369c:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
    36a0:	8f e6       	ldi	r24, 0x6F	; 111
    36a2:	93 e0       	ldi	r25, 0x03	; 3
    36a4:	01 97       	sbiw	r24, 0x01	; 1
    36a6:	f1 f7       	brne	.-4      	; 0x36a4 <chb_set_state+0x90>
    36a8:	00 c0       	rjmp	.+0      	; 0x36aa <chb_set_state+0x96>
    36aa:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    36ac:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <chb_get_state>
    36b0:	8d 17       	cp	r24, r29
    36b2:	21 f4       	brne	.+8      	; 0x36bc <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    36b4:	80 e4       	ldi	r24, 0x40	; 64
    36b6:	03 c0       	rjmp	.+6      	; 0x36be <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    36b8:	84 e4       	ldi	r24, 0x44	; 68
    36ba:	01 c0       	rjmp	.+2      	; 0x36be <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    36bc:	83 e4       	ldi	r24, 0x43	; 67
}
    36be:	df 91       	pop	r29
    36c0:	cf 91       	pop	r28
    36c2:	08 95       	ret

000036c4 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    36c4:	88 23       	and	r24, r24
    36c6:	49 f0       	breq	.+18     	; 0x36da <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    36c8:	88 e0       	ldi	r24, 0x08	; 8
    36ca:	0e 94 0a 1b 	call	0x3614	; 0x3614 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    36ce:	e4 e6       	ldi	r30, 0x64	; 100
    36d0:	f6 e0       	ldi	r31, 0x06	; 6
    36d2:	80 81       	ld	r24, Z
    36d4:	82 60       	ori	r24, 0x02	; 2
    36d6:	80 83       	st	Z, r24
    36d8:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    36da:	e4 e6       	ldi	r30, 0x64	; 100
    36dc:	f6 e0       	ldi	r31, 0x06	; 6
    36de:	80 81       	ld	r24, Z
    36e0:	8d 7f       	andi	r24, 0xFD	; 253
    36e2:	80 83       	st	Z, r24
    36e4:	8f e7       	ldi	r24, 0x7F	; 127
    36e6:	97 e0       	ldi	r25, 0x07	; 7
    36e8:	01 97       	sbiw	r24, 0x01	; 1
    36ea:	f1 f7       	brne	.-4      	; 0x36e8 <chb_sleep+0x24>
    36ec:	00 c0       	rjmp	.+0      	; 0x36ee <chb_sleep+0x2a>
    36ee:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    36f0:	86 e1       	ldi	r24, 0x16	; 22
    36f2:	0e 94 0a 1b 	call	0x3614	; 0x3614 <chb_set_state>
    36f6:	08 95       	ret

000036f8 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    36f8:	cf 92       	push	r12
    36fa:	df 92       	push	r13
    36fc:	ef 92       	push	r14
    36fe:	ff 92       	push	r15
    3700:	0f 93       	push	r16
    3702:	1f 93       	push	r17
    3704:	cf 93       	push	r28
    3706:	df 93       	push	r29
    3708:	7c 01       	movw	r14, r24
    370a:	6b 01       	movw	r12, r22
    370c:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    370e:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <chb_get_state>
    3712:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3714:	0e 94 ae 18 	call	0x315c	; 0x315c <chb_get_pcb>
    3718:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    371a:	12 30       	cpi	r17, 0x02	; 2
    371c:	f1 f0       	breq	.+60     	; 0x375a <chb_tx+0x62>
    371e:	12 31       	cpi	r17, 0x12	; 18
    3720:	f1 f0       	breq	.+60     	; 0x375e <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    3722:	88 e0       	ldi	r24, 0x08	; 8
    3724:	0e 94 0a 1b 	call	0x3614	; 0x3614 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    3728:	89 e1       	ldi	r24, 0x19	; 25
    372a:	0e 94 0a 1b 	call	0x3614	; 0x3614 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    372e:	c7 01       	movw	r24, r14
    3730:	6a e0       	ldi	r22, 0x0A	; 10
    3732:	a6 01       	movw	r20, r12
    3734:	20 2f       	mov	r18, r16
    3736:	0e 94 10 1a 	call	0x3420	; 0x3420 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    373a:	82 e0       	ldi	r24, 0x02	; 2
    373c:	62 e0       	ldi	r22, 0x02	; 2
    373e:	4f e1       	ldi	r20, 0x1F	; 31
    3740:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3744:	8c 81       	ldd	r24, Y+4	; 0x04
    3746:	88 23       	and	r24, r24
    3748:	e9 f3       	breq	.-6      	; 0x3744 <chb_tx+0x4c>
    pcb->tx_end = false;
    374a:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    374c:	82 e0       	ldi	r24, 0x02	; 2
    374e:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    3752:	82 95       	swap	r24
    3754:	86 95       	lsr	r24
    3756:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3758:	03 c0       	rjmp	.+6      	; 0x3760 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    375a:	84 e4       	ldi	r24, 0x44	; 68
    375c:	01 c0       	rjmp	.+2      	; 0x3760 <chb_tx+0x68>
    375e:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3760:	df 91       	pop	r29
    3762:	cf 91       	pop	r28
    3764:	1f 91       	pop	r17
    3766:	0f 91       	pop	r16
    3768:	ff 90       	pop	r15
    376a:	ef 90       	pop	r14
    376c:	df 90       	pop	r13
    376e:	cf 90       	pop	r12
    3770:	08 95       	ret

00003772 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3772:	81 30       	cpi	r24, 0x01	; 1
    3774:	91 f0       	breq	.+36     	; 0x379a <chb_set_mode+0x28>
    3776:	81 30       	cpi	r24, 0x01	; 1
    3778:	28 f0       	brcs	.+10     	; 0x3784 <chb_set_mode+0x12>
    377a:	82 30       	cpi	r24, 0x02	; 2
    377c:	c9 f0       	breq	.+50     	; 0x37b0 <chb_set_mode+0x3e>
    377e:	83 30       	cpi	r24, 0x03	; 3
    3780:	61 f5       	brne	.+88     	; 0x37da <chb_set_mode+0x68>
    3782:	21 c0       	rjmp	.+66     	; 0x37c6 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3784:	8c e0       	ldi	r24, 0x0C	; 12
    3786:	68 e0       	ldi	r22, 0x08	; 8
    3788:	4f e3       	ldi	r20, 0x3F	; 63
    378a:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    378e:	86 e1       	ldi	r24, 0x16	; 22
    3790:	62 e0       	ldi	r22, 0x02	; 2
    3792:	43 e0       	ldi	r20, 0x03	; 3
    3794:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
        break;
    3798:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    379a:	8c e0       	ldi	r24, 0x0C	; 12
    379c:	6c e0       	ldi	r22, 0x0C	; 12
    379e:	4f e3       	ldi	r20, 0x3F	; 63
    37a0:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    37a4:	86 e1       	ldi	r24, 0x16	; 22
    37a6:	62 e0       	ldi	r22, 0x02	; 2
    37a8:	43 e0       	ldi	r20, 0x03	; 3
    37aa:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
        break;
    37ae:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    37b0:	8c e0       	ldi	r24, 0x0C	; 12
    37b2:	6c e1       	ldi	r22, 0x1C	; 28
    37b4:	4f e3       	ldi	r20, 0x3F	; 63
    37b6:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    37ba:	86 e1       	ldi	r24, 0x16	; 22
    37bc:	62 e0       	ldi	r22, 0x02	; 2
    37be:	43 e0       	ldi	r20, 0x03	; 3
    37c0:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
        break;
    37c4:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    37c6:	8c e0       	ldi	r24, 0x0C	; 12
    37c8:	60 e0       	ldi	r22, 0x00	; 0
    37ca:	4f e3       	ldi	r20, 0x3F	; 63
    37cc:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    37d0:	86 e1       	ldi	r24, 0x16	; 22
    37d2:	63 e0       	ldi	r22, 0x03	; 3
    37d4:	43 e0       	ldi	r20, 0x03	; 3
    37d6:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
    37da:	08 95       	ret

000037dc <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    37dc:	cf 93       	push	r28
    37de:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    37e0:	88 e0       	ldi	r24, 0x08	; 8
    37e2:	6c 2f       	mov	r22, r28
    37e4:	4f e1       	ldi	r20, 0x1F	; 31
    37e6:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    37ea:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    37ee:	86 30       	cpi	r24, 0x06	; 6
    37f0:	11 f0       	breq	.+4      	; 0x37f6 <chb_set_channel+0x1a>
    37f2:	89 30       	cpi	r24, 0x09	; 9
    37f4:	31 f4       	brne	.+12     	; 0x3802 <chb_set_channel+0x26>
    37f6:	8f e6       	ldi	r24, 0x6F	; 111
    37f8:	93 e0       	ldi	r25, 0x03	; 3
    37fa:	01 97       	sbiw	r24, 0x01	; 1
    37fc:	f1 f7       	brne	.-4      	; 0x37fa <chb_set_channel+0x1e>
    37fe:	00 c0       	rjmp	.+0      	; 0x3800 <chb_set_channel+0x24>
    3800:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3802:	88 e0       	ldi	r24, 0x08	; 8
    3804:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    3808:	90 e0       	ldi	r25, 0x00	; 0
    380a:	8f 71       	andi	r24, 0x1F	; 31
    380c:	90 70       	andi	r25, 0x00	; 0
    380e:	6c 2f       	mov	r22, r28
    3810:	70 e0       	ldi	r23, 0x00	; 0
    3812:	86 17       	cp	r24, r22
    3814:	97 07       	cpc	r25, r23
    3816:	11 f4       	brne	.+4      	; 0x381c <chb_set_channel+0x40>
    3818:	80 e4       	ldi	r24, 0x40	; 64
    381a:	01 c0       	rjmp	.+2      	; 0x381e <chb_set_channel+0x42>
    381c:	83 e4       	ldi	r24, 0x43	; 67
}
    381e:	cf 91       	pop	r28
    3820:	08 95       	ret

00003822 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3822:	cf 93       	push	r28
    3824:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3826:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    382a:	8c 2b       	or	r24, r28
    382c:	8f 5f       	subi	r24, 0xFF	; 255
    382e:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    }
    return val;
}
    3832:	80 e0       	ldi	r24, 0x00	; 0
    3834:	90 e0       	ldi	r25, 0x00	; 0
    3836:	cf 91       	pop	r28
    3838:	08 95       	ret

0000383a <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    383a:	e4 e6       	ldi	r30, 0x64	; 100
    383c:	f6 e0       	ldi	r31, 0x06	; 6
    383e:	80 81       	ld	r24, Z
    3840:	81 60       	ori	r24, 0x01	; 1
    3842:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3844:	80 81       	ld	r24, Z
    3846:	8d 7f       	andi	r24, 0xFD	; 253
    3848:	80 83       	st	Z, r24
    384a:	8f ed       	ldi	r24, 0xDF	; 223
    384c:	9b e0       	ldi	r25, 0x0B	; 11
    384e:	01 97       	sbiw	r24, 0x01	; 1
    3850:	f1 f7       	brne	.-4      	; 0x384e <chb_reset+0x14>
    3852:	00 c0       	rjmp	.+0      	; 0x3854 <chb_reset+0x1a>
    3854:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3856:	80 81       	ld	r24, Z
    3858:	8e 7f       	andi	r24, 0xFE	; 254
    385a:	80 83       	st	Z, r24
    385c:	9a e0       	ldi	r25, 0x0A	; 10
    385e:	9a 95       	dec	r25
    3860:	f1 f7       	brne	.-4      	; 0x385e <chb_reset+0x24>
    3862:	00 c0       	rjmp	.+0      	; 0x3864 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3864:	80 81       	ld	r24, Z
    3866:	81 60       	ori	r24, 0x01	; 1
    3868:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    386a:	8d e1       	ldi	r24, 0x1D	; 29
    386c:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    3870:	81 30       	cpi	r24, 0x01	; 1
    3872:	d9 f7       	brne	.-10     	; 0x386a <chb_reset+0x30>
    3874:	8c e1       	ldi	r24, 0x1C	; 28
    3876:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    387a:	87 30       	cpi	r24, 0x07	; 7
    387c:	b1 f7       	brne	.-20     	; 0x386a <chb_reset+0x30>
            break;
        }
    }
	

}
    387e:	08 95       	ret

00003880 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3880:	0f 93       	push	r16
    3882:	1f 93       	push	r17
    3884:	cf 93       	push	r28
    3886:	df 93       	push	r29
    3888:	cd b7       	in	r28, 0x3d	; 61
    388a:	de b7       	in	r29, 0x3e	; 62
    388c:	ea 97       	sbiw	r28, 0x3a	; 58
    388e:	cd bf       	out	0x3d, r28	; 61
    3890:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3892:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3896:	e0 e6       	ldi	r30, 0x60	; 96
    3898:	f6 e0       	ldi	r31, 0x06	; 6
    389a:	80 81       	ld	r24, Z
    389c:	82 60       	ori	r24, 0x02	; 2
    389e:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    38a0:	80 81       	ld	r24, Z
    38a2:	81 60       	ori	r24, 0x01	; 1
    38a4:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    38a6:	0e 94 1d 1c 	call	0x383a	; 0x383a <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    38aa:	8e e0       	ldi	r24, 0x0E	; 14
    38ac:	60 e0       	ldi	r22, 0x00	; 0
    38ae:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    38b2:	82 e0       	ldi	r24, 0x02	; 2
    38b4:	63 e0       	ldi	r22, 0x03	; 3
    38b6:	4f e1       	ldi	r20, 0x1F	; 31
    38b8:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    38bc:	81 e0       	ldi	r24, 0x01	; 1
    38be:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    38c2:	8f 71       	andi	r24, 0x1F	; 31
    38c4:	88 30       	cpi	r24, 0x08	; 8
    38c6:	d1 f7       	brne	.-12     	; 0x38bc <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    38c8:	8e e2       	ldi	r24, 0x2E	; 46
    38ca:	60 e4       	ldi	r22, 0x40	; 64
    38cc:	40 ec       	ldi	r20, 0xC0	; 192
    38ce:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    38d2:	8e e0       	ldi	r24, 0x0E	; 14
    38d4:	6c e0       	ldi	r22, 0x0C	; 12
    38d6:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    38da:	84 e0       	ldi	r24, 0x04	; 4
    38dc:	60 e2       	ldi	r22, 0x20	; 32
    38de:	40 e2       	ldi	r20, 0x20	; 32
    38e0:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	0e 94 b9 1b 	call	0x3772	; 0x3772 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    38ea:	81 e0       	ldi	r24, 0x01	; 1
    38ec:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    38f0:	86 e1       	ldi	r24, 0x16	; 22
    38f2:	0e 94 0a 1b 	call	0x3614	; 0x3614 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    38f6:	82 e2       	ldi	r24, 0x22	; 34
    38f8:	64 e3       	ldi	r22, 0x34	; 52
    38fa:	72 e1       	ldi	r23, 0x12	; 18
    38fc:	0e 94 a2 1a 	call	0x3544	; 0x3544 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3900:	0e 94 ee 19 	call	0x33dc	; 0x33dc <chb_get_short_addr>
    3904:	bc 01       	movw	r22, r24
    3906:	80 e2       	ldi	r24, 0x20	; 32
    3908:	0e 94 a2 1a 	call	0x3544	; 0x3544 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    390c:	ce 01       	movw	r24, r28
    390e:	01 96       	adiw	r24, 0x01	; 1
    3910:	0e 94 e6 19 	call	0x33cc	; 0x33cc <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3914:	84 e2       	ldi	r24, 0x24	; 36
    3916:	be 01       	movw	r22, r28
    3918:	6f 5f       	subi	r22, 0xFF	; 255
    391a:	7f 4f       	sbci	r23, 0xFF	; 255
    391c:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3920:	e2 e7       	ldi	r30, 0x72	; 114
    3922:	f6 e0       	ldi	r31, 0x06	; 6
    3924:	80 81       	ld	r24, Z
    3926:	81 60       	ori	r24, 0x01	; 1
    3928:	80 83       	st	Z, r24
    392a:	e9 e6       	ldi	r30, 0x69	; 105
    392c:	f6 e0       	ldi	r31, 0x06	; 6
    392e:	80 81       	ld	r24, Z
    3930:	83 60       	ori	r24, 0x03	; 3
    3932:	80 83       	st	Z, r24
    3934:	ea e6       	ldi	r30, 0x6A	; 106
    3936:	f6 e0       	ldi	r31, 0x06	; 6
    3938:	80 81       	ld	r24, Z
    393a:	84 60       	ori	r24, 0x04	; 4
    393c:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    393e:	e0 ea       	ldi	r30, 0xA0	; 160
    3940:	f0 e0       	ldi	r31, 0x00	; 0
    3942:	82 81       	ldd	r24, Z+2	; 0x02
    3944:	87 60       	ori	r24, 0x07	; 7
    3946:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3948:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <chb_get_state>
    394c:	86 31       	cpi	r24, 0x16	; 22
    394e:	91 f0       	breq	.+36     	; 0x3974 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3950:	8e 01       	movw	r16, r28
    3952:	07 5f       	subi	r16, 0xF7	; 247
    3954:	1f 4f       	sbci	r17, 0xFF	; 255
    3956:	c8 01       	movw	r24, r16
    3958:	68 ee       	ldi	r22, 0xE8	; 232
    395a:	71 e0       	ldi	r23, 0x01	; 1
    395c:	0e 94 69 38 	call	0x70d2	; 0x70d2 <strcpy_P>
        printf(buf);
    3960:	0f 92       	push	r0
    3962:	0f 92       	push	r0
    3964:	ed b7       	in	r30, 0x3d	; 61
    3966:	fe b7       	in	r31, 0x3e	; 62
    3968:	01 83       	std	Z+1, r16	; 0x01
    396a:	12 83       	std	Z+2, r17	; 0x02
    396c:	0e 94 ae 38 	call	0x715c	; 0x715c <printf>
    3970:	0f 90       	pop	r0
    3972:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3974:	ea 96       	adiw	r28, 0x3a	; 58
    3976:	cd bf       	out	0x3d, r28	; 61
    3978:	de bf       	out	0x3e, r29	; 62
    397a:	df 91       	pop	r29
    397c:	cf 91       	pop	r28
    397e:	1f 91       	pop	r17
    3980:	0f 91       	pop	r16
    3982:	08 95       	ret

00003984 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3984:	1f 92       	push	r1
    3986:	0f 92       	push	r0
    3988:	0f b6       	in	r0, 0x3f	; 63
    398a:	0f 92       	push	r0
    398c:	0b b6       	in	r0, 0x3b	; 59
    398e:	0f 92       	push	r0
    3990:	11 24       	eor	r1, r1
    3992:	6f 92       	push	r6
    3994:	7f 92       	push	r7
    3996:	8f 92       	push	r8
    3998:	9f 92       	push	r9
    399a:	af 92       	push	r10
    399c:	bf 92       	push	r11
    399e:	df 92       	push	r13
    39a0:	ef 92       	push	r14
    39a2:	ff 92       	push	r15
    39a4:	0f 93       	push	r16
    39a6:	1f 93       	push	r17
    39a8:	2f 93       	push	r18
    39aa:	3f 93       	push	r19
    39ac:	4f 93       	push	r20
    39ae:	5f 93       	push	r21
    39b0:	6f 93       	push	r22
    39b2:	7f 93       	push	r23
    39b4:	8f 93       	push	r24
    39b6:	9f 93       	push	r25
    39b8:	af 93       	push	r26
    39ba:	bf 93       	push	r27
    39bc:	ef 93       	push	r30
    39be:	ff 93       	push	r31
    39c0:	cf 93       	push	r28
    39c2:	df 93       	push	r29
    39c4:	cd b7       	in	r28, 0x3d	; 61
    39c6:	de b7       	in	r29, 0x3e	; 62
    39c8:	e2 97       	sbiw	r28, 0x32	; 50
    39ca:	cd bf       	out	0x3d, r28	; 61
    39cc:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    39ce:	0e 94 ae 18 	call	0x315c	; 0x315c <chb_get_pcb>
    39d2:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    39d4:	8f b7       	in	r24, 0x3f	; 63
    39d6:	80 93 58 40 	sts	0x4058, r24
    39da:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    39dc:	81 e0       	ldi	r24, 0x01	; 1
    39de:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    39e2:	8f e8       	ldi	r24, 0x8F	; 143
    39e4:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    intp_src = SPID_write(0);
    39e8:	80 e0       	ldi	r24, 0x00	; 0
    39ea:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    39ee:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    39f0:	80 e0       	ldi	r24, 0x00	; 0
    39f2:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>

    while (intp_src)
    39f6:	11 23       	and	r17, r17
    39f8:	09 f4       	brne	.+2      	; 0x39fc <__vector_64+0x78>
    39fa:	ae c0       	rjmp	.+348    	; 0x3b58 <__vector_64+0x1d4>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    39fc:	aa 24       	eor	r10, r10
    39fe:	bb 24       	eor	r11, r11
    3a00:	68 94       	set
    3a02:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3a04:	0f 2e       	mov	r0, r31
    3a06:	f8 e0       	ldi	r31, 0x08	; 8
    3a08:	8f 2e       	mov	r8, r31
    3a0a:	f2 e0       	ldi	r31, 0x02	; 2
    3a0c:	9f 2e       	mov	r9, r31
    3a0e:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3a10:	12 ff       	sbrs	r17, 2
    3a12:	02 c0       	rjmp	.+4      	; 0x3a18 <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3a14:	1b 7f       	andi	r17, 0xFB	; 251
    3a16:	9d c0       	rjmp	.+314    	; 0x3b52 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3a18:	13 ff       	sbrs	r17, 3
    3a1a:	82 c0       	rjmp	.+260    	; 0x3b20 <__vector_64+0x19c>
        {
            state = chb_get_state();
    3a1c:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3a20:	86 30       	cpi	r24, 0x06	; 6
    3a22:	29 f0       	breq	.+10     	; 0x3a2e <__vector_64+0xaa>
    3a24:	86 31       	cpi	r24, 0x16	; 22
    3a26:	19 f0       	breq	.+6      	; 0x3a2e <__vector_64+0xaa>
    3a28:	81 31       	cpi	r24, 0x11	; 17
    3a2a:	09 f0       	breq	.+2      	; 0x3a2e <__vector_64+0xaa>
    3a2c:	6f c0       	rjmp	.+222    	; 0x3b0c <__vector_64+0x188>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				//chb_set_state(CHB_TRX_OFF);
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3a2e:	87 e0       	ldi	r24, 0x07	; 7
    3a30:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    3a34:	f7 01       	movw	r30, r14
    3a36:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3a38:	86 e0       	ldi	r24, 0x06	; 6
    3a3a:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
    3a3e:	88 1f       	adc	r24, r24
    3a40:	88 27       	eor	r24, r24
    3a42:	88 1f       	adc	r24, r24
    3a44:	f7 01       	movw	r30, r14
    3a46:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3a48:	88 23       	and	r24, r24
    3a4a:	09 f4       	brne	.+2      	; 0x3a4e <__vector_64+0xca>
    3a4c:	62 c0       	rjmp	.+196    	; 0x3b12 <__vector_64+0x18e>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3a4e:	8f b7       	in	r24, 0x3f	; 63
    3a50:	80 93 58 40 	sts	0x4058, r24
    3a54:	f8 94       	cli
    RadioCS(TRUE);
    3a56:	81 e0       	ldi	r24, 0x01	; 1
    3a58:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3a5c:	80 e2       	ldi	r24, 0x20	; 32
    3a5e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    len = SPID_write(0);
    3a62:	80 e0       	ldi	r24, 0x00	; 0
    3a64:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
    3a68:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3a6a:	83 50       	subi	r24, 0x03	; 3
    3a6c:	8d 37       	cpi	r24, 0x7D	; 125
    3a6e:	f0 f5       	brcc	.+124    	; 0x3aec <__vector_64+0x168>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3a70:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <chb_buf_get_len>
    3a74:	2d 2d       	mov	r18, r13
    3a76:	30 e0       	ldi	r19, 0x00	; 0
    3a78:	a5 01       	movw	r20, r10
    3a7a:	48 1b       	sub	r20, r24
    3a7c:	51 09       	sbc	r21, r1
    3a7e:	24 17       	cp	r18, r20
    3a80:	35 07       	cpc	r19, r21
    3a82:	7c f4       	brge	.+30     	; 0x3aa2 <__vector_64+0x11e>
        {
            chb_buf_write(len);
    3a84:	8d 2d       	mov	r24, r13
    3a86:	0e 94 b7 19 	call	0x336e	; 0x336e <chb_buf_write>
            
            for (i=0; i<len; i++)
    3a8a:	dd 20       	and	r13, r13
    3a8c:	79 f1       	breq	.+94     	; 0x3aec <__vector_64+0x168>
    3a8e:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3a90:	80 e0       	ldi	r24, 0x00	; 0
    3a92:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
                chb_buf_write(data);
    3a96:	0e 94 b7 19 	call	0x336e	; 0x336e <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3a9a:	0f 5f       	subi	r16, 0xFF	; 255
    3a9c:	0d 15       	cp	r16, r13
    3a9e:	c1 f7       	brne	.-16     	; 0x3a90 <__vector_64+0x10c>
    3aa0:	25 c0       	rjmp	.+74     	; 0x3aec <__vector_64+0x168>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3aa2:	0e 94 ae 18 	call	0x315c	; 0x315c <chb_get_pcb>
    3aa6:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3aa8:	dd 20       	and	r13, r13
    3aaa:	39 f0       	breq	.+14     	; 0x3aba <__vector_64+0x136>
    3aac:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3aae:	80 e0       	ldi	r24, 0x00	; 0
    3ab0:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3ab4:	0f 5f       	subi	r16, 0xFF	; 255
    3ab6:	0d 15       	cp	r16, r13
    3ab8:	d1 f7       	brne	.-12     	; 0x3aae <__vector_64+0x12a>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3aba:	f3 01       	movw	r30, r6
    3abc:	85 85       	ldd	r24, Z+13	; 0x0d
    3abe:	96 85       	ldd	r25, Z+14	; 0x0e
    3ac0:	01 96       	adiw	r24, 0x01	; 1
    3ac2:	85 87       	std	Z+13, r24	; 0x0d
    3ac4:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3ac6:	ce 01       	movw	r24, r28
    3ac8:	01 96       	adiw	r24, 0x01	; 1
    3aca:	b4 01       	movw	r22, r8
    3acc:	0e 94 69 38 	call	0x70d2	; 0x70d2 <strcpy_P>
            printf(buf);
    3ad0:	0f 92       	push	r0
    3ad2:	0f 92       	push	r0
    3ad4:	41 e0       	ldi	r20, 0x01	; 1
    3ad6:	50 e0       	ldi	r21, 0x00	; 0
    3ad8:	4c 0f       	add	r20, r28
    3ada:	5d 1f       	adc	r21, r29
    3adc:	ed b7       	in	r30, 0x3d	; 61
    3ade:	fe b7       	in	r31, 0x3e	; 62
    3ae0:	41 83       	std	Z+1, r20	; 0x01
    3ae2:	52 83       	std	Z+2, r21	; 0x02
    3ae4:	0e 94 ae 38 	call	0x715c	; 0x715c <printf>
    3ae8:	0f 90       	pop	r0
    3aea:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3aec:	80 e0       	ldi	r24, 0x00	; 0
    3aee:	0e 94 04 1a 	call	0x3408	; 0x3408 <RadioCS>
    CHB_LEAVE_CRIT();
    3af2:	80 91 58 40 	lds	r24, 0x4058
    3af6:	8f bf       	out	0x3f, r24	; 63
    3af8:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3afa:	f7 01       	movw	r30, r14
    3afc:	85 81       	ldd	r24, Z+5	; 0x05
    3afe:	96 81       	ldd	r25, Z+6	; 0x06
    3b00:	01 96       	adiw	r24, 0x01	; 1
    3b02:	85 83       	std	Z+5, r24	; 0x05
    3b04:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3b06:	81 e0       	ldi	r24, 0x01	; 1
    3b08:	83 83       	std	Z+3, r24	; 0x03
    3b0a:	03 c0       	rjmp	.+6      	; 0x3b12 <__vector_64+0x18e>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    3b0c:	81 e0       	ldi	r24, 0x01	; 1
    3b0e:	f7 01       	movw	r30, r14
    3b10:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3b12:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3b14:	86 e1       	ldi	r24, 0x16	; 22
    3b16:	0e 94 0a 1b 	call	0x3614	; 0x3614 <chb_set_state>
    3b1a:	80 34       	cpi	r24, 0x40	; 64
    3b1c:	d9 f7       	brne	.-10     	; 0x3b14 <__vector_64+0x190>
    3b1e:	19 c0       	rjmp	.+50     	; 0x3b52 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3b20:	16 ff       	sbrs	r17, 6
    3b22:	08 c0       	rjmp	.+16     	; 0x3b34 <__vector_64+0x1b0>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3b24:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3b26:	f7 01       	movw	r30, r14
    3b28:	87 85       	ldd	r24, Z+15	; 0x0f
    3b2a:	90 89       	ldd	r25, Z+16	; 0x10
    3b2c:	01 96       	adiw	r24, 0x01	; 1
    3b2e:	87 87       	std	Z+15, r24	; 0x0f
    3b30:	90 8b       	std	Z+16, r25	; 0x10
    3b32:	0f c0       	rjmp	.+30     	; 0x3b52 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3b34:	11 ff       	sbrs	r17, 1
    3b36:	02 c0       	rjmp	.+4      	; 0x3b3c <__vector_64+0x1b8>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3b38:	1d 7f       	andi	r17, 0xFD	; 253
    3b3a:	0b c0       	rjmp	.+22     	; 0x3b52 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3b3c:	10 ff       	sbrs	r17, 0
    3b3e:	02 c0       	rjmp	.+4      	; 0x3b44 <__vector_64+0x1c0>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3b40:	1e 7f       	andi	r17, 0xFE	; 254
    3b42:	07 c0       	rjmp	.+14     	; 0x3b52 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3b44:	11 23       	and	r17, r17
    3b46:	2c f4       	brge	.+10     	; 0x3b52 <__vector_64+0x1ce>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3b48:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    3b4a:	f7 01       	movw	r30, r14
    3b4c:	81 89       	ldd	r24, Z+17	; 0x11
    3b4e:	8f 5f       	subi	r24, 0xFF	; 255
    3b50:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3b52:	11 23       	and	r17, r17
    3b54:	09 f0       	breq	.+2      	; 0x3b58 <__vector_64+0x1d4>
    3b56:	5c cf       	rjmp	.-328    	; 0x3a10 <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3b58:	80 91 58 40 	lds	r24, 0x4058
    3b5c:	8f bf       	out	0x3f, r24	; 63
    3b5e:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3b60:	8f e0       	ldi	r24, 0x0F	; 15
    3b62:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <chb_reg_read>
}
    3b66:	e2 96       	adiw	r28, 0x32	; 50
    3b68:	cd bf       	out	0x3d, r28	; 61
    3b6a:	de bf       	out	0x3e, r29	; 62
    3b6c:	df 91       	pop	r29
    3b6e:	cf 91       	pop	r28
    3b70:	ff 91       	pop	r31
    3b72:	ef 91       	pop	r30
    3b74:	bf 91       	pop	r27
    3b76:	af 91       	pop	r26
    3b78:	9f 91       	pop	r25
    3b7a:	8f 91       	pop	r24
    3b7c:	7f 91       	pop	r23
    3b7e:	6f 91       	pop	r22
    3b80:	5f 91       	pop	r21
    3b82:	4f 91       	pop	r20
    3b84:	3f 91       	pop	r19
    3b86:	2f 91       	pop	r18
    3b88:	1f 91       	pop	r17
    3b8a:	0f 91       	pop	r16
    3b8c:	ff 90       	pop	r15
    3b8e:	ef 90       	pop	r14
    3b90:	df 90       	pop	r13
    3b92:	bf 90       	pop	r11
    3b94:	af 90       	pop	r10
    3b96:	9f 90       	pop	r9
    3b98:	8f 90       	pop	r8
    3b9a:	7f 90       	pop	r7
    3b9c:	6f 90       	pop	r6
    3b9e:	0f 90       	pop	r0
    3ba0:	0b be       	out	0x3b, r0	; 59
    3ba2:	0f 90       	pop	r0
    3ba4:	0f be       	out	0x3f, r0	; 63
    3ba6:	0f 90       	pop	r0
    3ba8:	1f 90       	pop	r1
    3baa:	18 95       	reti

00003bac <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3bac:	0f 93       	push	r16
    3bae:	1f 93       	push	r17
    3bb0:	cf 93       	push	r28
    3bb2:	df 93       	push	r29
    3bb4:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3bb6:	e0 ec       	ldi	r30, 0xC0	; 192
    3bb8:	f1 e0       	ldi	r31, 0x01	; 1
    3bba:	84 85       	ldd	r24, Z+12	; 0x0c
    3bbc:	87 7f       	andi	r24, 0xF7	; 247
    3bbe:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3bc0:	41 15       	cp	r20, r1
    3bc2:	51 05       	cpc	r21, r1
    3bc4:	09 f4       	brne	.+2      	; 0x3bc8 <chb_eeprom_write+0x1c>
    3bc6:	50 c0       	rjmp	.+160    	; 0x3c68 <chb_eeprom_write+0xbc>
    3bc8:	e0 e0       	ldi	r30, 0x00	; 0
    3bca:	f0 e0       	ldi	r31, 0x00	; 0
    3bcc:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3bce:	a0 ec       	ldi	r26, 0xC0	; 192
    3bd0:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3bd2:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3bd4:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3bd6:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3bd8:	cf 01       	movw	r24, r30
    3bda:	80 0f       	add	r24, r16
    3bdc:	91 1f       	adc	r25, r17
    3bde:	e6 0f       	add	r30, r22
    3be0:	f7 1f       	adc	r31, r23
    3be2:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3be4:	1f 96       	adiw	r26, 0x0f	; 15
    3be6:	ec 91       	ld	r30, X
    3be8:	1f 97       	sbiw	r26, 0x0f	; 15
    3bea:	ee 23       	and	r30, r30
    3bec:	dc f3       	brlt	.-10     	; 0x3be4 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3bee:	1f 96       	adiw	r26, 0x0f	; 15
    3bf0:	ec 91       	ld	r30, X
    3bf2:	1f 97       	sbiw	r26, 0x0f	; 15
    3bf4:	e1 ff       	sbrs	r30, 1
    3bf6:	11 c0       	rjmp	.+34     	; 0x3c1a <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3bf8:	1a 96       	adiw	r26, 0x0a	; 10
    3bfa:	dc 93       	st	X, r29
    3bfc:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3bfe:	ef 93       	push	r30
    3c00:	ff 93       	push	r31
    3c02:	0f 93       	push	r16
    3c04:	2f 93       	push	r18
    3c06:	eb ec       	ldi	r30, 0xCB	; 203
    3c08:	f1 e0       	ldi	r31, 0x01	; 1
    3c0a:	08 ed       	ldi	r16, 0xD8	; 216
    3c0c:	21 e0       	ldi	r18, 0x01	; 1
    3c0e:	04 bf       	out	0x34, r16	; 52
    3c10:	20 83       	st	Z, r18
    3c12:	2f 91       	pop	r18
    3c14:	0f 91       	pop	r16
    3c16:	ff 91       	pop	r31
    3c18:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3c1a:	1a 96       	adiw	r26, 0x0a	; 10
    3c1c:	cc 93       	st	X, r28
    3c1e:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3c20:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3c22:	89 2f       	mov	r24, r25
    3c24:	8f 71       	andi	r24, 0x1F	; 31
    3c26:	11 96       	adiw	r26, 0x01	; 1
    3c28:	8c 93       	st	X, r24
    3c2a:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3c2c:	12 96       	adiw	r26, 0x02	; 2
    3c2e:	1c 92       	st	X, r1
    3c30:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3c32:	14 96       	adiw	r26, 0x04	; 4
    3c34:	fc 93       	st	X, r31
    3c36:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3c38:	1a 96       	adiw	r26, 0x0a	; 10
    3c3a:	3c 93       	st	X, r19
    3c3c:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3c3e:	ef 93       	push	r30
    3c40:	ff 93       	push	r31
    3c42:	0f 93       	push	r16
    3c44:	2f 93       	push	r18
    3c46:	eb ec       	ldi	r30, 0xCB	; 203
    3c48:	f1 e0       	ldi	r31, 0x01	; 1
    3c4a:	08 ed       	ldi	r16, 0xD8	; 216
    3c4c:	21 e0       	ldi	r18, 0x01	; 1
    3c4e:	04 bf       	out	0x34, r16	; 52
    3c50:	20 83       	st	Z, r18
    3c52:	2f 91       	pop	r18
    3c54:	0f 91       	pop	r16
    3c56:	ff 91       	pop	r31
    3c58:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3c5a:	2f 5f       	subi	r18, 0xFF	; 255
    3c5c:	e2 2f       	mov	r30, r18
    3c5e:	f0 e0       	ldi	r31, 0x00	; 0
    3c60:	e4 17       	cp	r30, r20
    3c62:	f5 07       	cpc	r31, r21
    3c64:	08 f4       	brcc	.+2      	; 0x3c68 <chb_eeprom_write+0xbc>
    3c66:	b8 cf       	rjmp	.-144    	; 0x3bd8 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3c68:	df 91       	pop	r29
    3c6a:	cf 91       	pop	r28
    3c6c:	1f 91       	pop	r17
    3c6e:	0f 91       	pop	r16
    3c70:	08 95       	ret

00003c72 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3c72:	1f 93       	push	r17
    3c74:	cf 93       	push	r28
    3c76:	df 93       	push	r29
    3c78:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3c7a:	e0 ec       	ldi	r30, 0xC0	; 192
    3c7c:	f1 e0       	ldi	r31, 0x01	; 1
    3c7e:	84 85       	ldd	r24, Z+12	; 0x0c
    3c80:	87 7f       	andi	r24, 0xF7	; 247
    3c82:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3c84:	41 15       	cp	r20, r1
    3c86:	51 05       	cpc	r21, r1
    3c88:	41 f1       	breq	.+80     	; 0x3cda <chb_eeprom_read+0x68>
    3c8a:	80 e0       	ldi	r24, 0x00	; 0
    3c8c:	90 e0       	ldi	r25, 0x00	; 0
    3c8e:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3c90:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3c92:	db 01       	movw	r26, r22
    3c94:	a8 0f       	add	r26, r24
    3c96:	b9 1f       	adc	r27, r25
    3c98:	82 0f       	add	r24, r18
    3c9a:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3c9c:	17 85       	ldd	r17, Z+15	; 0x0f
    3c9e:	11 23       	and	r17, r17
    3ca0:	ec f3       	brlt	.-6      	; 0x3c9c <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3ca2:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3ca4:	89 2f       	mov	r24, r25
    3ca6:	8f 71       	andi	r24, 0x1F	; 31
    3ca8:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3caa:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3cac:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3cae:	ef 93       	push	r30
    3cb0:	ff 93       	push	r31
    3cb2:	0f 93       	push	r16
    3cb4:	2f 93       	push	r18
    3cb6:	eb ec       	ldi	r30, 0xCB	; 203
    3cb8:	f1 e0       	ldi	r31, 0x01	; 1
    3cba:	08 ed       	ldi	r16, 0xD8	; 216
    3cbc:	21 e0       	ldi	r18, 0x01	; 1
    3cbe:	04 bf       	out	0x34, r16	; 52
    3cc0:	20 83       	st	Z, r18
    3cc2:	2f 91       	pop	r18
    3cc4:	0f 91       	pop	r16
    3cc6:	ff 91       	pop	r31
    3cc8:	ef 91       	pop	r30

    return NVM.DATA0;
    3cca:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3ccc:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3cce:	cf 5f       	subi	r28, 0xFF	; 255
    3cd0:	8c 2f       	mov	r24, r28
    3cd2:	90 e0       	ldi	r25, 0x00	; 0
    3cd4:	84 17       	cp	r24, r20
    3cd6:	95 07       	cpc	r25, r21
    3cd8:	e0 f2       	brcs	.-72     	; 0x3c92 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3cda:	df 91       	pop	r29
    3cdc:	cf 91       	pop	r28
    3cde:	1f 91       	pop	r17
    3ce0:	08 95       	ret

00003ce2 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3ce2:	e0 e6       	ldi	r30, 0x60	; 96
    3ce4:	f6 e0       	ldi	r31, 0x06	; 6
    3ce6:	80 81       	ld	r24, Z
    3ce8:	80 6b       	ori	r24, 0xB0	; 176
    3cea:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3cec:	e4 e6       	ldi	r30, 0x64	; 100
    3cee:	f6 e0       	ldi	r31, 0x06	; 6
    3cf0:	80 81       	ld	r24, Z
    3cf2:	80 61       	ori	r24, 0x10	; 16
    3cf4:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3cf6:	a0 ec       	ldi	r26, 0xC0	; 192
    3cf8:	b9 e0       	ldi	r27, 0x09	; 9
    3cfa:	8c 91       	ld	r24, X
    3cfc:	81 65       	ori	r24, 0x51	; 81
    3cfe:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3d00:	80 81       	ld	r24, Z
    3d02:	80 61       	ori	r24, 0x10	; 16
    3d04:	80 83       	st	Z, r24
}
    3d06:	08 95       	ret

00003d08 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3d08:	e0 ec       	ldi	r30, 0xC0	; 192
    3d0a:	f9 e0       	ldi	r31, 0x09	; 9
    3d0c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3d0e:	82 81       	ldd	r24, Z+2	; 0x02
    3d10:	88 23       	and	r24, r24
    3d12:	ec f7       	brge	.-6      	; 0x3d0e <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3d14:	e0 ec       	ldi	r30, 0xC0	; 192
    3d16:	f9 e0       	ldi	r31, 0x09	; 9
    3d18:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3d1a:	08 95       	ret

00003d1c <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3d1c:	0f 93       	push	r16
    3d1e:	cf 93       	push	r28
    3d20:	df 93       	push	r29
    3d22:	0f 92       	push	r0
    3d24:	cd b7       	in	r28, 0x3d	; 61
    3d26:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    3d28:	2f b7       	in	r18, 0x3f	; 63
    3d2a:	29 83       	std	Y+1, r18	; 0x01
    3d2c:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3d2e:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3d30:	fc 01       	movw	r30, r24
    3d32:	08 ed       	ldi	r16, 0xD8	; 216
    3d34:	04 bf       	out	0x34, r16	; 52
    3d36:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    3d38:	89 81       	ldd	r24, Y+1	; 0x01
    3d3a:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3d3c:	0f 90       	pop	r0
    3d3e:	df 91       	pop	r29
    3d40:	cf 91       	pop	r28
    3d42:	0f 91       	pop	r16
    3d44:	08 95       	ret

00003d46 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    3d46:	66 23       	and	r22, r22
    3d48:	11 f0       	breq	.+4      	; 0x3d4e <CLKSYS_XOSC_Config+0x8>
    3d4a:	90 e2       	ldi	r25, 0x20	; 32
    3d4c:	01 c0       	rjmp	.+2      	; 0x3d50 <CLKSYS_XOSC_Config+0xa>
    3d4e:	90 e0       	ldi	r25, 0x00	; 0
    3d50:	84 2b       	or	r24, r20
    3d52:	89 2b       	or	r24, r25
    3d54:	e0 e5       	ldi	r30, 0x50	; 80
    3d56:	f0 e0       	ldi	r31, 0x00	; 0
    3d58:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3d5a:	08 95       	ret

00003d5c <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3d5c:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3d5e:	86 2b       	or	r24, r22
    3d60:	e0 e5       	ldi	r30, 0x50	; 80
    3d62:	f0 e0       	ldi	r31, 0x00	; 0
    3d64:	85 83       	std	Z+5, r24	; 0x05
}
    3d66:	08 95       	ret

00003d68 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    3d68:	e0 e5       	ldi	r30, 0x50	; 80
    3d6a:	f0 e0       	ldi	r31, 0x00	; 0
    3d6c:	90 81       	ld	r25, Z
    3d6e:	28 2f       	mov	r18, r24
    3d70:	20 95       	com	r18
    3d72:	92 23       	and	r25, r18
    3d74:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    3d76:	90 81       	ld	r25, Z
	return clkEnabled;
}
    3d78:	89 23       	and	r24, r25
    3d7a:	08 95       	ret

00003d7c <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    3d7c:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    3d7e:	81 e4       	ldi	r24, 0x41	; 65
    3d80:	90 e0       	ldi	r25, 0x00	; 0
    3d82:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <CCPWrite>
}
    3d86:	08 95       	ret

00003d88 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    3d88:	1f 93       	push	r17
    3d8a:	cf 93       	push	r28
    3d8c:	df 93       	push	r29
    3d8e:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    3d90:	c0 e4       	ldi	r28, 0x40	; 64
    3d92:	d0 e0       	ldi	r29, 0x00	; 0
    3d94:	68 81       	ld	r22, Y
    3d96:	68 7f       	andi	r22, 0xF8	; 248
    3d98:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    3d9a:	80 e4       	ldi	r24, 0x40	; 64
    3d9c:	90 e0       	ldi	r25, 0x00	; 0
    3d9e:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    3da2:	88 81       	ld	r24, Y
	return clkCtrl;
}
    3da4:	81 23       	and	r24, r17
    3da6:	df 91       	pop	r29
    3da8:	cf 91       	pop	r28
    3daa:	1f 91       	pop	r17
    3dac:	08 95       	ret

00003dae <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    3dae:	e0 e4       	ldi	r30, 0x40	; 64
    3db0:	f0 e0       	ldi	r31, 0x00	; 0
    3db2:	93 81       	ldd	r25, Z+3	; 0x03
    3db4:	91 7f       	andi	r25, 0xF1	; 241
    3db6:	91 60       	ori	r25, 0x01	; 1
    3db8:	89 2b       	or	r24, r25
    3dba:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    3dbc:	08 95       	ret

00003dbe <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    3dbe:	e0 e5       	ldi	r30, 0x50	; 80
    3dc0:	f0 e0       	ldi	r31, 0x00	; 0
    3dc2:	26 81       	ldd	r18, Z+6	; 0x06
    3dc4:	98 2f       	mov	r25, r24
    3dc6:	38 2f       	mov	r19, r24
    3dc8:	30 95       	com	r19
    3dca:	23 23       	and	r18, r19
    3dcc:	66 23       	and	r22, r22
    3dce:	09 f4       	brne	.+2      	; 0x3dd2 <CLKSYS_AutoCalibration_Enable+0x14>
    3dd0:	90 e0       	ldi	r25, 0x00	; 0
    3dd2:	92 2b       	or	r25, r18
    3dd4:	e0 e5       	ldi	r30, 0x50	; 80
    3dd6:	f0 e0       	ldi	r31, 0x00	; 0
    3dd8:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3dda:	81 30       	cpi	r24, 0x01	; 1
    3ddc:	31 f4       	brne	.+12     	; 0x3dea <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3dde:	e8 e6       	ldi	r30, 0x68	; 104
    3de0:	f0 e0       	ldi	r31, 0x00	; 0
    3de2:	80 81       	ld	r24, Z
    3de4:	81 60       	ori	r24, 0x01	; 1
    3de6:	80 83       	st	Z, r24
    3de8:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3dea:	82 30       	cpi	r24, 0x02	; 2
    3dec:	29 f4       	brne	.+10     	; 0x3df8 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3dee:	e0 e6       	ldi	r30, 0x60	; 96
    3df0:	f0 e0       	ldi	r31, 0x00	; 0
    3df2:	80 81       	ld	r24, Z
    3df4:	81 60       	ori	r24, 0x01	; 1
    3df6:	80 83       	st	Z, r24
    3df8:	08 95       	ret

00003dfa <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3dfa:	83 e5       	ldi	r24, 0x53	; 83
    3dfc:	90 e0       	ldi	r25, 0x00	; 0
    3dfe:	63 e0       	ldi	r22, 0x03	; 3
    3e00:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <CCPWrite>
}
    3e04:	08 95       	ret

00003e06 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    3e06:	82 e4       	ldi	r24, 0x42	; 66
    3e08:	90 e0       	ldi	r25, 0x00	; 0
    3e0a:	61 e0       	ldi	r22, 0x01	; 1
    3e0c:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <CCPWrite>
}
    3e10:	08 95       	ret

00003e12 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    3e12:	cf 92       	push	r12
    3e14:	df 92       	push	r13
    3e16:	ef 92       	push	r14
    3e18:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3e1a:	20 91 6a 50 	lds	r18, 0x506A
    3e1e:	30 91 6b 50 	lds	r19, 0x506B
    3e22:	c0 90 4e 40 	lds	r12, 0x404E
    3e26:	d0 90 4f 40 	lds	r13, 0x404F
    3e2a:	e0 90 50 40 	lds	r14, 0x4050
    3e2e:	f0 90 51 40 	lds	r15, 0x4051
    3e32:	62 50       	subi	r22, 0x02	; 2
    3e34:	70 40       	sbci	r23, 0x00	; 0
    3e36:	80 40       	sbci	r24, 0x00	; 0
    3e38:	90 40       	sbci	r25, 0x00	; 0
    3e3a:	40 e0       	ldi	r20, 0x00	; 0
    3e3c:	50 e0       	ldi	r21, 0x00	; 0
    3e3e:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    3e42:	dc 01       	movw	r26, r24
    3e44:	cb 01       	movw	r24, r22
    3e46:	c8 0e       	add	r12, r24
    3e48:	d9 1e       	adc	r13, r25
    3e4a:	ea 1e       	adc	r14, r26
    3e4c:	fb 1e       	adc	r15, r27
}
    3e4e:	6c 2d       	mov	r22, r12
    3e50:	7d 2d       	mov	r23, r13
    3e52:	8e 2d       	mov	r24, r14
    3e54:	9f 2d       	mov	r25, r15
    3e56:	ff 90       	pop	r15
    3e58:	ef 90       	pop	r14
    3e5a:	df 90       	pop	r13
    3e5c:	cf 90       	pop	r12
    3e5e:	08 95       	ret

00003e60 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    3e60:	3f 92       	push	r3
    3e62:	4f 92       	push	r4
    3e64:	5f 92       	push	r5
    3e66:	6f 92       	push	r6
    3e68:	7f 92       	push	r7
    3e6a:	8f 92       	push	r8
    3e6c:	9f 92       	push	r9
    3e6e:	af 92       	push	r10
    3e70:	bf 92       	push	r11
    3e72:	cf 92       	push	r12
    3e74:	df 92       	push	r13
    3e76:	ef 92       	push	r14
    3e78:	ff 92       	push	r15
    3e7a:	0f 93       	push	r16
    3e7c:	1f 93       	push	r17
    3e7e:	cf 93       	push	r28
    3e80:	df 93       	push	r29
    3e82:	00 d0       	rcall	.+0      	; 0x3e84 <getSetNextCluster+0x24>
    3e84:	0f 92       	push	r0
    3e86:	cd b7       	in	r28, 0x3d	; 61
    3e88:	de b7       	in	r29, 0x3e	; 62
    3e8a:	dc 01       	movw	r26, r24
    3e8c:	cb 01       	movw	r24, r22
    3e8e:	34 2e       	mov	r3, r20
    3e90:	09 83       	std	Y+1, r16	; 0x01
    3e92:	1a 83       	std	Y+2, r17	; 0x02
    3e94:	2b 83       	std	Y+3, r18	; 0x03
    3e96:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    3e98:	80 90 70 50 	lds	r8, 0x5070
    3e9c:	90 90 71 50 	lds	r9, 0x5071
    3ea0:	2c 01       	movw	r4, r24
    3ea2:	3d 01       	movw	r6, r26
    3ea4:	44 0c       	add	r4, r4
    3ea6:	55 1c       	adc	r5, r5
    3ea8:	66 1c       	adc	r6, r6
    3eaa:	77 1c       	adc	r7, r7
    3eac:	44 0c       	add	r4, r4
    3eae:	55 1c       	adc	r5, r5
    3eb0:	66 1c       	adc	r6, r6
    3eb2:	77 1c       	adc	r7, r7
    3eb4:	20 91 56 40 	lds	r18, 0x4056
    3eb8:	30 91 57 40 	lds	r19, 0x4057
    3ebc:	aa 24       	eor	r10, r10
    3ebe:	bb 24       	eor	r11, r11
    3ec0:	80 91 6c 50 	lds	r24, 0x506C
    3ec4:	90 91 6d 50 	lds	r25, 0x506D
    3ec8:	a0 91 6e 50 	lds	r26, 0x506E
    3ecc:	b0 91 6f 50 	lds	r27, 0x506F
    3ed0:	88 0e       	add	r8, r24
    3ed2:	99 1e       	adc	r9, r25
    3ed4:	aa 1e       	adc	r10, r26
    3ed6:	bb 1e       	adc	r11, r27
    3ed8:	40 e0       	ldi	r20, 0x00	; 0
    3eda:	50 e0       	ldi	r21, 0x00	; 0
    3edc:	c3 01       	movw	r24, r6
    3ede:	b2 01       	movw	r22, r4
    3ee0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    3ee4:	69 01       	movw	r12, r18
    3ee6:	7a 01       	movw	r14, r20
    3ee8:	c8 0c       	add	r12, r8
    3eea:	d9 1c       	adc	r13, r9
    3eec:	ea 1c       	adc	r14, r10
    3eee:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3ef0:	00 91 56 40 	lds	r16, 0x4056
    3ef4:	10 91 57 40 	lds	r17, 0x4057

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    3ef8:	c7 01       	movw	r24, r14
    3efa:	b6 01       	movw	r22, r12
    3efc:	49 e4       	ldi	r20, 0x49	; 73
    3efe:	5e e3       	ldi	r21, 0x3E	; 62
    3f00:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3f04:	98 01       	movw	r18, r16
    3f06:	40 e0       	ldi	r20, 0x00	; 0
    3f08:	50 e0       	ldi	r21, 0x00	; 0
    3f0a:	c3 01       	movw	r24, r6
    3f0c:	b2 01       	movw	r22, r4
    3f0e:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    3f12:	67 5b       	subi	r22, 0xB7	; 183
    3f14:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    3f16:	33 20       	and	r3, r3
    3f18:	41 f4       	brne	.+16     	; 0x3f2a <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    3f1a:	db 01       	movw	r26, r22
    3f1c:	0d 91       	ld	r16, X+
    3f1e:	1d 91       	ld	r17, X+
    3f20:	2d 91       	ld	r18, X+
    3f22:	3c 91       	ld	r19, X
    3f24:	13 97       	sbiw	r26, 0x03	; 3
    3f26:	3f 70       	andi	r19, 0x0F	; 15
    3f28:	14 c0       	rjmp	.+40     	; 0x3f52 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    3f2a:	89 81       	ldd	r24, Y+1	; 0x01
    3f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f2e:	ab 81       	ldd	r26, Y+3	; 0x03
    3f30:	bc 81       	ldd	r27, Y+4	; 0x04
    3f32:	fb 01       	movw	r30, r22
    3f34:	80 83       	st	Z, r24
    3f36:	91 83       	std	Z+1, r25	; 0x01
    3f38:	a2 83       	std	Z+2, r26	; 0x02
    3f3a:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    3f3c:	c7 01       	movw	r24, r14
    3f3e:	b6 01       	movw	r22, r12
    3f40:	49 e4       	ldi	r20, 0x49	; 73
    3f42:	5e e3       	ldi	r21, 0x3E	; 62
    3f44:	20 e0       	ldi	r18, 0x00	; 0
    3f46:	32 e0       	ldi	r19, 0x02	; 2
    3f48:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <SD_write_block>

return (0);
    3f4c:	00 e0       	ldi	r16, 0x00	; 0
    3f4e:	10 e0       	ldi	r17, 0x00	; 0
    3f50:	98 01       	movw	r18, r16
}
    3f52:	60 2f       	mov	r22, r16
    3f54:	71 2f       	mov	r23, r17
    3f56:	82 2f       	mov	r24, r18
    3f58:	93 2f       	mov	r25, r19
    3f5a:	24 96       	adiw	r28, 0x04	; 4
    3f5c:	cd bf       	out	0x3d, r28	; 61
    3f5e:	de bf       	out	0x3e, r29	; 62
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	1f 91       	pop	r17
    3f66:	0f 91       	pop	r16
    3f68:	ff 90       	pop	r15
    3f6a:	ef 90       	pop	r14
    3f6c:	df 90       	pop	r13
    3f6e:	cf 90       	pop	r12
    3f70:	bf 90       	pop	r11
    3f72:	af 90       	pop	r10
    3f74:	9f 90       	pop	r9
    3f76:	8f 90       	pop	r8
    3f78:	7f 90       	pop	r7
    3f7a:	6f 90       	pop	r6
    3f7c:	5f 90       	pop	r5
    3f7e:	4f 90       	pop	r4
    3f80:	3f 90       	pop	r3
    3f82:	08 95       	ret

00003f84 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    3f84:	cf 92       	push	r12
    3f86:	df 92       	push	r13
    3f88:	ef 92       	push	r14
    3f8a:	ff 92       	push	r15
    3f8c:	0f 93       	push	r16
    3f8e:	1f 93       	push	r17
    3f90:	cf 93       	push	r28
    3f92:	c8 2f       	mov	r28, r24
    3f94:	06 2f       	mov	r16, r22
    3f96:	69 01       	movw	r12, r18
    3f98:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    3f9a:	80 91 6c 50 	lds	r24, 0x506C
    3f9e:	90 91 6d 50 	lds	r25, 0x506D
    3fa2:	a0 91 6e 50 	lds	r26, 0x506E
    3fa6:	b0 91 6f 50 	lds	r27, 0x506F
    3faa:	bc 01       	movw	r22, r24
    3fac:	cd 01       	movw	r24, r26
    3fae:	6f 5f       	subi	r22, 0xFF	; 255
    3fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    3fb2:	8f 4f       	sbci	r24, 0xFF	; 255
    3fb4:	9f 4f       	sbci	r25, 0xFF	; 255
    3fb6:	49 e4       	ldi	r20, 0x49	; 73
    3fb8:	5e e3       	ldi	r21, 0x3E	; 62
    3fba:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    3fbe:	80 91 49 3e 	lds	r24, 0x3E49
    3fc2:	90 91 4a 3e 	lds	r25, 0x3E4A
    3fc6:	a0 91 4b 3e 	lds	r26, 0x3E4B
    3fca:	b0 91 4c 3e 	lds	r27, 0x3E4C
    3fce:	82 35       	cpi	r24, 0x52	; 82
    3fd0:	22 e5       	ldi	r18, 0x52	; 82
    3fd2:	92 07       	cpc	r25, r18
    3fd4:	21 e6       	ldi	r18, 0x61	; 97
    3fd6:	a2 07       	cpc	r26, r18
    3fd8:	21 e4       	ldi	r18, 0x41	; 65
    3fda:	b2 07       	cpc	r27, r18
    3fdc:	09 f0       	breq	.+2      	; 0x3fe0 <getSetFreeCluster+0x5c>
    3fde:	63 c0       	rjmp	.+198    	; 0x40a6 <getSetFreeCluster+0x122>
    3fe0:	80 91 2d 40 	lds	r24, 0x402D
    3fe4:	90 91 2e 40 	lds	r25, 0x402E
    3fe8:	a0 91 2f 40 	lds	r26, 0x402F
    3fec:	b0 91 30 40 	lds	r27, 0x4030
    3ff0:	82 37       	cpi	r24, 0x72	; 114
    3ff2:	22 e7       	ldi	r18, 0x72	; 114
    3ff4:	92 07       	cpc	r25, r18
    3ff6:	21 e4       	ldi	r18, 0x41	; 65
    3ff8:	a2 07       	cpc	r26, r18
    3ffa:	21 e6       	ldi	r18, 0x61	; 97
    3ffc:	b2 07       	cpc	r27, r18
    3ffe:	09 f0       	breq	.+2      	; 0x4002 <getSetFreeCluster+0x7e>
    4000:	56 c0       	rjmp	.+172    	; 0x40ae <getSetFreeCluster+0x12a>
    4002:	80 91 45 40 	lds	r24, 0x4045
    4006:	90 91 46 40 	lds	r25, 0x4046
    400a:	a0 91 47 40 	lds	r26, 0x4047
    400e:	b0 91 48 40 	lds	r27, 0x4048
    4012:	80 30       	cpi	r24, 0x00	; 0
    4014:	20 e0       	ldi	r18, 0x00	; 0
    4016:	92 07       	cpc	r25, r18
    4018:	25 e5       	ldi	r18, 0x55	; 85
    401a:	a2 07       	cpc	r26, r18
    401c:	2a ea       	ldi	r18, 0xAA	; 170
    401e:	b2 07       	cpc	r27, r18
    4020:	09 f0       	breq	.+2      	; 0x4024 <getSetFreeCluster+0xa0>
    4022:	49 c0       	rjmp	.+146    	; 0x40b6 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4024:	00 23       	and	r16, r16
    4026:	a1 f4       	brne	.+40     	; 0x4050 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4028:	c1 30       	cpi	r28, 0x01	; 1
    402a:	49 f4       	brne	.+18     	; 0x403e <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    402c:	00 91 31 40 	lds	r16, 0x4031
    4030:	10 91 32 40 	lds	r17, 0x4032
    4034:	20 91 33 40 	lds	r18, 0x4033
    4038:	30 91 34 40 	lds	r19, 0x4034
    403c:	3f c0       	rjmp	.+126    	; 0x40bc <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    403e:	00 91 35 40 	lds	r16, 0x4035
    4042:	10 91 36 40 	lds	r17, 0x4036
    4046:	20 91 37 40 	lds	r18, 0x4037
    404a:	30 91 38 40 	lds	r19, 0x4038
    404e:	36 c0       	rjmp	.+108    	; 0x40bc <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4050:	c1 30       	cpi	r28, 0x01	; 1
    4052:	49 f4       	brne	.+18     	; 0x4066 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    4054:	c0 92 31 40 	sts	0x4031, r12
    4058:	d0 92 32 40 	sts	0x4032, r13
    405c:	e0 92 33 40 	sts	0x4033, r14
    4060:	f0 92 34 40 	sts	0x4034, r15
    4064:	08 c0       	rjmp	.+16     	; 0x4076 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    4066:	c0 92 35 40 	sts	0x4035, r12
    406a:	d0 92 36 40 	sts	0x4036, r13
    406e:	e0 92 37 40 	sts	0x4037, r14
    4072:	f0 92 38 40 	sts	0x4038, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4076:	80 91 6c 50 	lds	r24, 0x506C
    407a:	90 91 6d 50 	lds	r25, 0x506D
    407e:	a0 91 6e 50 	lds	r26, 0x506E
    4082:	b0 91 6f 50 	lds	r27, 0x506F
    4086:	bc 01       	movw	r22, r24
    4088:	cd 01       	movw	r24, r26
    408a:	6f 5f       	subi	r22, 0xFF	; 255
    408c:	7f 4f       	sbci	r23, 0xFF	; 255
    408e:	8f 4f       	sbci	r24, 0xFF	; 255
    4090:	9f 4f       	sbci	r25, 0xFF	; 255
    4092:	49 e4       	ldi	r20, 0x49	; 73
    4094:	5e e3       	ldi	r21, 0x3E	; 62
    4096:	20 e0       	ldi	r18, 0x00	; 0
    4098:	32 e0       	ldi	r19, 0x02	; 2
    409a:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <SD_write_block>
 }
 return 0xffffffff;
    409e:	0f ef       	ldi	r16, 0xFF	; 255
    40a0:	1f ef       	ldi	r17, 0xFF	; 255
    40a2:	98 01       	movw	r18, r16
    40a4:	0b c0       	rjmp	.+22     	; 0x40bc <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    40a6:	0f ef       	ldi	r16, 0xFF	; 255
    40a8:	1f ef       	ldi	r17, 0xFF	; 255
    40aa:	98 01       	movw	r18, r16
    40ac:	07 c0       	rjmp	.+14     	; 0x40bc <getSetFreeCluster+0x138>
    40ae:	0f ef       	ldi	r16, 0xFF	; 255
    40b0:	1f ef       	ldi	r17, 0xFF	; 255
    40b2:	98 01       	movw	r18, r16
    40b4:	03 c0       	rjmp	.+6      	; 0x40bc <getSetFreeCluster+0x138>
    40b6:	0f ef       	ldi	r16, 0xFF	; 255
    40b8:	1f ef       	ldi	r17, 0xFF	; 255
    40ba:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    40bc:	60 2f       	mov	r22, r16
    40be:	71 2f       	mov	r23, r17
    40c0:	82 2f       	mov	r24, r18
    40c2:	93 2f       	mov	r25, r19
    40c4:	cf 91       	pop	r28
    40c6:	1f 91       	pop	r17
    40c8:	0f 91       	pop	r16
    40ca:	ff 90       	pop	r15
    40cc:	ef 90       	pop	r14
    40ce:	df 90       	pop	r13
    40d0:	cf 90       	pop	r12
    40d2:	08 95       	ret

000040d4 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    40d4:	ef 92       	push	r14
    40d6:	ff 92       	push	r15
    40d8:	0f 93       	push	r16
    40da:	1f 93       	push	r17
    40dc:	cf 93       	push	r28
    40de:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    40e0:	10 92 6c 50 	sts	0x506C, r1
    40e4:	10 92 6d 50 	sts	0x506D, r1
    40e8:	10 92 6e 50 	sts	0x506E, r1
    40ec:	10 92 6f 50 	sts	0x506F, r1

SD_read_block(0,SDBuffer);
    40f0:	60 e0       	ldi	r22, 0x00	; 0
    40f2:	70 e0       	ldi	r23, 0x00	; 0
    40f4:	cb 01       	movw	r24, r22
    40f6:	49 e4       	ldi	r20, 0x49	; 73
    40f8:	5e e3       	ldi	r21, 0x3E	; 62
    40fa:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    40fe:	80 91 49 3e 	lds	r24, 0x3E49
    4102:	89 3e       	cpi	r24, 0xE9	; 233
    4104:	31 f1       	breq	.+76     	; 0x4152 <getBootSectorData+0x7e>
    4106:	8b 3e       	cpi	r24, 0xEB	; 235
    4108:	21 f1       	breq	.+72     	; 0x4152 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    410a:	80 91 47 40 	lds	r24, 0x4047
    410e:	90 91 48 40 	lds	r25, 0x4048
    4112:	2a ea       	ldi	r18, 0xAA	; 170
    4114:	85 35       	cpi	r24, 0x55	; 85
    4116:	92 07       	cpc	r25, r18
    4118:	09 f0       	breq	.+2      	; 0x411c <getBootSectorData+0x48>
    411a:	b7 c0       	rjmp	.+366    	; 0x428a <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    411c:	60 91 0f 40 	lds	r22, 0x400F
    4120:	70 91 10 40 	lds	r23, 0x4010
    4124:	80 91 11 40 	lds	r24, 0x4011
    4128:	90 91 12 40 	lds	r25, 0x4012
    412c:	60 93 6c 50 	sts	0x506C, r22
    4130:	70 93 6d 50 	sts	0x506D, r23
    4134:	80 93 6e 50 	sts	0x506E, r24
    4138:	90 93 6f 50 	sts	0x506F, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    413c:	49 e4       	ldi	r20, 0x49	; 73
    413e:	5e e3       	ldi	r21, 0x3E	; 62
    4140:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4144:	80 91 49 3e 	lds	r24, 0x3E49
    4148:	89 3e       	cpi	r24, 0xE9	; 233
    414a:	19 f0       	breq	.+6      	; 0x4152 <getBootSectorData+0x7e>
    414c:	8b 3e       	cpi	r24, 0xEB	; 235
    414e:	09 f0       	breq	.+2      	; 0x4152 <getBootSectorData+0x7e>
    4150:	9e c0       	rjmp	.+316    	; 0x428e <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4152:	80 91 54 3e 	lds	r24, 0x3E54
    4156:	90 91 55 3e 	lds	r25, 0x3E55
    415a:	80 93 56 40 	sts	0x4056, r24
    415e:	90 93 57 40 	sts	0x4057, r25
sectorPerCluster = bpb->sectorPerCluster;
    4162:	80 91 56 3e 	lds	r24, 0x3E56
    4166:	90 e0       	ldi	r25, 0x00	; 0
    4168:	80 93 6a 50 	sts	0x506A, r24
    416c:	90 93 6b 50 	sts	0x506B, r25
reservedSectorCount = bpb->reservedSectorCount;
    4170:	e0 90 57 3e 	lds	r14, 0x3E57
    4174:	f0 90 58 3e 	lds	r15, 0x3E58
    4178:	e0 92 70 50 	sts	0x5070, r14
    417c:	f0 92 71 50 	sts	0x5071, r15
rootCluster = bpb->rootCluster;
    4180:	80 91 75 3e 	lds	r24, 0x3E75
    4184:	90 91 76 3e 	lds	r25, 0x3E76
    4188:	a0 91 77 3e 	lds	r26, 0x3E77
    418c:	b0 91 78 3e 	lds	r27, 0x3E78
    4190:	80 93 5e 40 	sts	0x405E, r24
    4194:	90 93 5f 40 	sts	0x405F, r25
    4198:	a0 93 60 40 	sts	0x4060, r26
    419c:	b0 93 61 40 	sts	0x4061, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    41a0:	c0 91 70 50 	lds	r28, 0x5070
    41a4:	d0 91 71 50 	lds	r29, 0x5071
    41a8:	60 91 59 3e 	lds	r22, 0x3E59
    41ac:	70 e0       	ldi	r23, 0x00	; 0
    41ae:	80 e0       	ldi	r24, 0x00	; 0
    41b0:	90 e0       	ldi	r25, 0x00	; 0
    41b2:	20 91 6d 3e 	lds	r18, 0x3E6D
    41b6:	30 91 6e 3e 	lds	r19, 0x3E6E
    41ba:	40 91 6f 3e 	lds	r20, 0x3E6F
    41be:	50 91 70 3e 	lds	r21, 0x3E70
    41c2:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    41c6:	8b 01       	movw	r16, r22
    41c8:	9c 01       	movw	r18, r24
    41ca:	ae 01       	movw	r20, r28
    41cc:	60 e0       	ldi	r22, 0x00	; 0
    41ce:	70 e0       	ldi	r23, 0x00	; 0
    41d0:	80 91 65 3e 	lds	r24, 0x3E65
    41d4:	90 91 66 3e 	lds	r25, 0x3E66
    41d8:	a0 91 67 3e 	lds	r26, 0x3E67
    41dc:	b0 91 68 3e 	lds	r27, 0x3E68
    41e0:	84 0f       	add	r24, r20
    41e2:	95 1f       	adc	r25, r21
    41e4:	a6 1f       	adc	r26, r22
    41e6:	b7 1f       	adc	r27, r23
    41e8:	80 0f       	add	r24, r16
    41ea:	91 1f       	adc	r25, r17
    41ec:	a2 1f       	adc	r26, r18
    41ee:	b3 1f       	adc	r27, r19
    41f0:	80 93 4e 40 	sts	0x404E, r24
    41f4:	90 93 4f 40 	sts	0x404F, r25
    41f8:	a0 93 50 40 	sts	0x4050, r26
    41fc:	b0 93 51 40 	sts	0x4051, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4200:	e0 91 6a 50 	lds	r30, 0x506A
    4204:	f0 91 6b 50 	lds	r31, 0x506B
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4208:	c7 01       	movw	r24, r14
    420a:	a0 e0       	ldi	r26, 0x00	; 0
    420c:	b0 e0       	ldi	r27, 0x00	; 0
    420e:	40 91 69 3e 	lds	r20, 0x3E69
    4212:	50 91 6a 3e 	lds	r21, 0x3E6A
    4216:	60 91 6b 3e 	lds	r22, 0x3E6B
    421a:	70 91 6c 3e 	lds	r23, 0x3E6C
    421e:	48 1b       	sub	r20, r24
    4220:	59 0b       	sbc	r21, r25
    4222:	6a 0b       	sbc	r22, r26
    4224:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4226:	cb 01       	movw	r24, r22
    4228:	ba 01       	movw	r22, r20
    422a:	60 1b       	sub	r22, r16
    422c:	71 0b       	sbc	r23, r17
    422e:	82 0b       	sbc	r24, r18
    4230:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4232:	9f 01       	movw	r18, r30
    4234:	40 e0       	ldi	r20, 0x00	; 0
    4236:	50 e0       	ldi	r21, 0x00	; 0
    4238:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    423c:	20 93 59 40 	sts	0x4059, r18
    4240:	30 93 5a 40 	sts	0x405A, r19
    4244:	40 93 5b 40 	sts	0x405B, r20
    4248:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    424c:	81 e0       	ldi	r24, 0x01	; 1
    424e:	60 e0       	ldi	r22, 0x00	; 0
    4250:	20 e0       	ldi	r18, 0x00	; 0
    4252:	30 e0       	ldi	r19, 0x00	; 0
    4254:	a9 01       	movw	r20, r18
    4256:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <getSetFreeCluster>
    425a:	ab 01       	movw	r20, r22
    425c:	bc 01       	movw	r22, r24
    425e:	80 91 59 40 	lds	r24, 0x4059
    4262:	90 91 5a 40 	lds	r25, 0x405A
    4266:	a0 91 5b 40 	lds	r26, 0x405B
    426a:	b0 91 5c 40 	lds	r27, 0x405C
    426e:	84 17       	cp	r24, r20
    4270:	95 07       	cpc	r25, r21
    4272:	a6 07       	cpc	r26, r22
    4274:	b7 07       	cpc	r27, r23
    4276:	20 f4       	brcc	.+8      	; 0x4280 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4278:	10 92 a2 50 	sts	0x50A2, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    427c:	80 e0       	ldi	r24, 0x00	; 0
    427e:	08 c0       	rjmp	.+16     	; 0x4290 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4280:	81 e0       	ldi	r24, 0x01	; 1
    4282:	80 93 a2 50 	sts	0x50A2, r24
return 0;
    4286:	80 e0       	ldi	r24, 0x00	; 0
    4288:	03 c0       	rjmp	.+6      	; 0x4290 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    428a:	81 e0       	ldi	r24, 0x01	; 1
    428c:	01 c0       	rjmp	.+2      	; 0x4290 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    428e:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4290:	df 91       	pop	r29
    4292:	cf 91       	pop	r28
    4294:	1f 91       	pop	r17
    4296:	0f 91       	pop	r16
    4298:	ff 90       	pop	r15
    429a:	ef 90       	pop	r14
    429c:	08 95       	ret

0000429e <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    429e:	0f 93       	push	r16
    42a0:	1f 93       	push	r17
    42a2:	cf 93       	push	r28
    42a4:	df 93       	push	r29
    42a6:	cd b7       	in	r28, 0x3d	; 61
    42a8:	de b7       	in	r29, 0x3e	; 62
    42aa:	2b 97       	sbiw	r28, 0x0b	; 11
    42ac:	cd bf       	out	0x3d, r28	; 61
    42ae:	de bf       	out	0x3e, r29	; 62
    42b0:	78 2f       	mov	r23, r24
    42b2:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    42b4:	e8 2f       	mov	r30, r24
    42b6:	f9 2f       	mov	r31, r25
    42b8:	df 01       	movw	r26, r30
    42ba:	0d 90       	ld	r0, X+
    42bc:	00 20       	and	r0, r0
    42be:	e9 f7       	brne	.-6      	; 0x42ba <convertFileName+0x1c>
    42c0:	11 97       	sbiw	r26, 0x01	; 1
    42c2:	ae 1b       	sub	r26, r30
    42c4:	bf 0b       	sbc	r27, r31
    42c6:	a0 31       	cpi	r26, 0x10	; 16
    42c8:	b1 05       	cpc	r27, r1
    42ca:	08 f0       	brcs	.+2      	; 0x42ce <convertFileName+0x30>
    42cc:	9c c0       	rjmp	.+312    	; 0x4406 <convertFileName+0x168>
    42ce:	28 2f       	mov	r18, r24
    42d0:	39 2f       	mov	r19, r25
    42d2:	02 e9       	ldi	r16, 0x92	; 146
    42d4:	10 e5       	ldi	r17, 0x50	; 80
    42d6:	a8 01       	movw	r20, r16
    42d8:	80 e0       	ldi	r24, 0x00	; 0
    42da:	90 e0       	ldi	r25, 0x00	; 0
    42dc:	07 c0       	rjmp	.+14     	; 0x42ec <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    42de:	d9 01       	movw	r26, r18
    42e0:	ed 91       	ld	r30, X+
    42e2:	9d 01       	movw	r18, r26
    42e4:	da 01       	movw	r26, r20
    42e6:	ed 93       	st	X+, r30
    42e8:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    42ea:	01 96       	adiw	r24, 0x01	; 1
    42ec:	a7 2f       	mov	r26, r23
    42ee:	b6 2f       	mov	r27, r22
    42f0:	fd 01       	movw	r30, r26
    42f2:	01 90       	ld	r0, Z+
    42f4:	00 20       	and	r0, r0
    42f6:	e9 f7       	brne	.-6      	; 0x42f2 <convertFileName+0x54>
    42f8:	31 97       	sbiw	r30, 0x01	; 1
    42fa:	ea 1b       	sub	r30, r26
    42fc:	fb 0b       	sbc	r31, r27
    42fe:	8e 17       	cp	r24, r30
    4300:	9f 07       	cpc	r25, r31
    4302:	68 f3       	brcs	.-38     	; 0x42de <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4304:	8f 30       	cpi	r24, 0x0F	; 15
    4306:	91 05       	cpc	r25, r1
    4308:	54 f4       	brge	.+20     	; 0x431e <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    430a:	fc 01       	movw	r30, r24
    430c:	ee 56       	subi	r30, 0x6E	; 110
    430e:	ff 4a       	sbci	r31, 0xAF	; 175
    4310:	81 ea       	ldi	r24, 0xA1	; 161
    4312:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4314:	20 e2       	ldi	r18, 0x20	; 32
    4316:	21 93       	st	Z+, r18
    4318:	e8 17       	cp	r30, r24
    431a:	f9 07       	cpc	r31, r25
    431c:	e1 f7       	brne	.-8      	; 0x4316 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    431e:	80 91 92 50 	lds	r24, 0x5092
    4322:	8e 32       	cpi	r24, 0x2E	; 46
    4324:	91 f0       	breq	.+36     	; 0x434a <convertFileName+0xac>
    4326:	e3 e9       	ldi	r30, 0x93	; 147
    4328:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    432a:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    432c:	81 91       	ld	r24, Z+
    432e:	8e 32       	cpi	r24, 0x2E	; 46
    4330:	21 f0       	breq	.+8      	; 0x433a <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4332:	2f 5f       	subi	r18, 0xFF	; 255
    4334:	2c 30       	cpi	r18, 0x0C	; 12
    4336:	d1 f7       	brne	.-12     	; 0x432c <convertFileName+0x8e>
    4338:	05 c0       	rjmp	.+10     	; 0x4344 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    433a:	82 2f       	mov	r24, r18
    433c:	89 50       	subi	r24, 0x09	; 9
    433e:	83 30       	cpi	r24, 0x03	; 3
    4340:	08 f4       	brcc	.+2      	; 0x4344 <convertFileName+0xa6>
    4342:	63 c0       	rjmp	.+198    	; 0x440a <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4344:	22 23       	and	r18, r18
    4346:	29 f4       	brne	.+10     	; 0x4352 <convertFileName+0xb4>
    4348:	01 c0       	rjmp	.+2      	; 0x434c <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    434a:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    434c:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    434e:	90 e2       	ldi	r25, 0x20	; 32
    4350:	10 c0       	rjmp	.+32     	; 0x4372 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4352:	de 01       	movw	r26, r28
    4354:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4356:	82 2f       	mov	r24, r18
    4358:	81 50       	subi	r24, 0x01	; 1
    435a:	90 e0       	ldi	r25, 0x00	; 0
    435c:	8d 56       	subi	r24, 0x6D	; 109
    435e:	9f 4a       	sbci	r25, 0xAF	; 175
    4360:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    4362:	31 91       	ld	r19, Z+
    4364:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4366:	e8 17       	cp	r30, r24
    4368:	f9 07       	cpc	r31, r25
    436a:	d9 f7       	brne	.-10     	; 0x4362 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    436c:	28 30       	cpi	r18, 0x08	; 8
    436e:	70 f3       	brcs	.-36     	; 0x434c <convertFileName+0xae>
    4370:	0a c0       	rjmp	.+20     	; 0x4386 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    4372:	e1 e0       	ldi	r30, 0x01	; 1
    4374:	f0 e0       	ldi	r31, 0x00	; 0
    4376:	ec 0f       	add	r30, r28
    4378:	fd 1f       	adc	r31, r29
    437a:	e8 0f       	add	r30, r24
    437c:	f1 1d       	adc	r31, r1
    437e:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4380:	8f 5f       	subi	r24, 0xFF	; 255
    4382:	88 30       	cpi	r24, 0x08	; 8
    4384:	b0 f3       	brcs	.-20     	; 0x4372 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4386:	2c 30       	cpi	r18, 0x0C	; 12
    4388:	09 f0       	breq	.+2      	; 0x438c <convertFileName+0xee>
    438a:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    438c:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    438e:	82 e9       	ldi	r24, 0x92	; 146
    4390:	90 e5       	ldi	r25, 0x50	; 80
    4392:	fc 01       	movw	r30, r24
    4394:	e2 0f       	add	r30, r18
    4396:	f1 1d       	adc	r31, r1
    4398:	40 81       	ld	r20, Z
    439a:	44 23       	and	r20, r20
    439c:	19 f4       	brne	.+6      	; 0x43a4 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    439e:	3b 30       	cpi	r19, 0x0B	; 11
    43a0:	50 f0       	brcs	.+20     	; 0x43b6 <convertFileName+0x118>
    43a2:	15 c0       	rjmp	.+42     	; 0x43ce <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    43a4:	e1 e0       	ldi	r30, 0x01	; 1
    43a6:	f0 e0       	ldi	r31, 0x00	; 0
    43a8:	ec 0f       	add	r30, r28
    43aa:	fd 1f       	adc	r31, r29
    43ac:	e3 0f       	add	r30, r19
    43ae:	f1 1d       	adc	r31, r1
    43b0:	40 83       	st	Z, r20
    43b2:	2f 5f       	subi	r18, 0xFF	; 255
    43b4:	0c c0       	rjmp	.+24     	; 0x43ce <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    43b6:	80 e2       	ldi	r24, 0x20	; 32
    43b8:	e1 e0       	ldi	r30, 0x01	; 1
    43ba:	f0 e0       	ldi	r31, 0x00	; 0
    43bc:	ec 0f       	add	r30, r28
    43be:	fd 1f       	adc	r31, r29
    43c0:	e3 0f       	add	r30, r19
    43c2:	f1 1d       	adc	r31, r1
    43c4:	80 83       	st	Z, r24
    43c6:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    43c8:	3b 30       	cpi	r19, 0x0B	; 11
    43ca:	b1 f7       	brne	.-20     	; 0x43b8 <convertFileName+0x11a>
    43cc:	03 c0       	rjmp	.+6      	; 0x43d4 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    43ce:	3f 5f       	subi	r19, 0xFF	; 255
    43d0:	3b 30       	cpi	r19, 0x0B	; 11
    43d2:	f8 f2       	brcs	.-66     	; 0x4392 <convertFileName+0xf4>
    43d4:	de 01       	movw	r26, r28
    43d6:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    43d8:	ce 01       	movw	r24, r28
    43da:	0c 96       	adiw	r24, 0x0c	; 12
    43dc:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    43de:	20 81       	ld	r18, Z
    43e0:	32 2f       	mov	r19, r18
    43e2:	31 56       	subi	r19, 0x61	; 97
    43e4:	3a 31       	cpi	r19, 0x1A	; 26
    43e6:	10 f4       	brcc	.+4      	; 0x43ec <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    43e8:	20 52       	subi	r18, 0x20	; 32
    43ea:	20 83       	st	Z, r18
    43ec:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    43ee:	e8 17       	cp	r30, r24
    43f0:	f9 07       	cpc	r31, r25
    43f2:	a9 f7       	brne	.-22     	; 0x43de <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    43f4:	2d 91       	ld	r18, X+
    43f6:	f8 01       	movw	r30, r16
    43f8:	21 93       	st	Z+, r18
    43fa:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    43fc:	a8 17       	cp	r26, r24
    43fe:	b9 07       	cpc	r27, r25
    4400:	c9 f7       	brne	.-14     	; 0x43f4 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    4402:	80 e0       	ldi	r24, 0x00	; 0
    4404:	03 c0       	rjmp	.+6      	; 0x440c <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4406:	81 e0       	ldi	r24, 0x01	; 1
    4408:	01 c0       	rjmp	.+2      	; 0x440c <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    440a:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    440c:	2b 96       	adiw	r28, 0x0b	; 11
    440e:	cd bf       	out	0x3d, r28	; 61
    4410:	de bf       	out	0x3e, r29	; 62
    4412:	df 91       	pop	r29
    4414:	cf 91       	pop	r28
    4416:	1f 91       	pop	r17
    4418:	0f 91       	pop	r16
    441a:	08 95       	ret

0000441c <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    441c:	4f 92       	push	r4
    441e:	5f 92       	push	r5
    4420:	6f 92       	push	r6
    4422:	7f 92       	push	r7
    4424:	8f 92       	push	r8
    4426:	9f 92       	push	r9
    4428:	af 92       	push	r10
    442a:	bf 92       	push	r11
    442c:	cf 92       	push	r12
    442e:	df 92       	push	r13
    4430:	ef 92       	push	r14
    4432:	ff 92       	push	r15
    4434:	cf 93       	push	r28
    4436:	df 93       	push	r29
    4438:	2b 01       	movw	r4, r22
    443a:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    443c:	20 e8       	ldi	r18, 0x80	; 128
    443e:	3f ef       	ldi	r19, 0xFF	; 255
    4440:	4f ef       	ldi	r20, 0xFF	; 255
    4442:	5f ef       	ldi	r21, 0xFF	; 255
    4444:	42 22       	and	r4, r18
    4446:	53 22       	and	r5, r19
    4448:	64 22       	and	r6, r20
    444a:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    444c:	80 91 59 40 	lds	r24, 0x4059
    4450:	90 91 5a 40 	lds	r25, 0x405A
    4454:	a0 91 5b 40 	lds	r26, 0x405B
    4458:	b0 91 5c 40 	lds	r27, 0x405C
    445c:	48 16       	cp	r4, r24
    445e:	59 06       	cpc	r5, r25
    4460:	6a 06       	cpc	r6, r26
    4462:	7b 06       	cpc	r7, r27
    4464:	08 f0       	brcs	.+2      	; 0x4468 <searchNextFreeCluster+0x4c>
    4466:	77 c0       	rjmp	.+238    	; 0x4556 <searchNextFreeCluster+0x13a>
    4468:	53 01       	movw	r10, r6
    446a:	42 01       	movw	r8, r4
    446c:	88 0c       	add	r8, r8
    446e:	99 1c       	adc	r9, r9
    4470:	aa 1c       	adc	r10, r10
    4472:	bb 1c       	adc	r11, r11
    4474:	88 0c       	add	r8, r8
    4476:	99 1c       	adc	r9, r9
    4478:	aa 1c       	adc	r10, r10
    447a:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    447c:	c9 e4       	ldi	r28, 0x49	; 73
    447e:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4480:	c0 90 70 50 	lds	r12, 0x5070
    4484:	d0 90 71 50 	lds	r13, 0x5071
    4488:	20 91 56 40 	lds	r18, 0x4056
    448c:	30 91 57 40 	lds	r19, 0x4057
    4490:	ee 24       	eor	r14, r14
    4492:	ff 24       	eor	r15, r15
    4494:	80 91 6c 50 	lds	r24, 0x506C
    4498:	90 91 6d 50 	lds	r25, 0x506D
    449c:	a0 91 6e 50 	lds	r26, 0x506E
    44a0:	b0 91 6f 50 	lds	r27, 0x506F
    44a4:	c8 0e       	add	r12, r24
    44a6:	d9 1e       	adc	r13, r25
    44a8:	ea 1e       	adc	r14, r26
    44aa:	fb 1e       	adc	r15, r27
    44ac:	40 e0       	ldi	r20, 0x00	; 0
    44ae:	50 e0       	ldi	r21, 0x00	; 0
    44b0:	c5 01       	movw	r24, r10
    44b2:	b4 01       	movw	r22, r8
    44b4:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    44b8:	c7 01       	movw	r24, r14
    44ba:	b6 01       	movw	r22, r12
    44bc:	62 0f       	add	r22, r18
    44be:	73 1f       	adc	r23, r19
    44c0:	84 1f       	adc	r24, r20
    44c2:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    44c4:	ae 01       	movw	r20, r28
    44c6:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    44ca:	88 81       	ld	r24, Y
    44cc:	99 81       	ldd	r25, Y+1	; 0x01
    44ce:	aa 81       	ldd	r26, Y+2	; 0x02
    44d0:	bb 81       	ldd	r27, Y+3	; 0x03
    44d2:	bf 70       	andi	r27, 0x0F	; 15
    44d4:	00 97       	sbiw	r24, 0x00	; 0
    44d6:	a1 05       	cpc	r26, r1
    44d8:	b1 05       	cpc	r27, r1
    44da:	99 f0       	breq	.+38     	; 0x4502 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    44dc:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    44de:	e2 2f       	mov	r30, r18
    44e0:	f0 e0       	ldi	r31, 0x00	; 0
    44e2:	ee 0f       	add	r30, r30
    44e4:	ff 1f       	adc	r31, r31
    44e6:	ee 0f       	add	r30, r30
    44e8:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    44ea:	e7 5b       	subi	r30, 0xB7	; 183
    44ec:	f1 4c       	sbci	r31, 0xC1	; 193
    44ee:	80 81       	ld	r24, Z
    44f0:	91 81       	ldd	r25, Z+1	; 0x01
    44f2:	a2 81       	ldd	r26, Z+2	; 0x02
    44f4:	b3 81       	ldd	r27, Z+3	; 0x03
    44f6:	bf 70       	andi	r27, 0x0F	; 15
    44f8:	00 97       	sbiw	r24, 0x00	; 0
    44fa:	a1 05       	cpc	r26, r1
    44fc:	b1 05       	cpc	r27, r1
    44fe:	39 f4       	brne	.+14     	; 0x450e <searchNextFreeCluster+0xf2>
    4500:	01 c0       	rjmp	.+2      	; 0x4504 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4502:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4504:	42 0e       	add	r4, r18
    4506:	51 1c       	adc	r5, r1
    4508:	61 1c       	adc	r6, r1
    450a:	71 1c       	adc	r7, r1
    450c:	27 c0       	rjmp	.+78     	; 0x455c <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    450e:	2f 5f       	subi	r18, 0xFF	; 255
    4510:	32 f7       	brpl	.-52     	; 0x44de <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4512:	80 e8       	ldi	r24, 0x80	; 128
    4514:	90 e0       	ldi	r25, 0x00	; 0
    4516:	a0 e0       	ldi	r26, 0x00	; 0
    4518:	b0 e0       	ldi	r27, 0x00	; 0
    451a:	48 0e       	add	r4, r24
    451c:	59 1e       	adc	r5, r25
    451e:	6a 1e       	adc	r6, r26
    4520:	7b 1e       	adc	r7, r27
    4522:	80 91 59 40 	lds	r24, 0x4059
    4526:	90 91 5a 40 	lds	r25, 0x405A
    452a:	a0 91 5b 40 	lds	r26, 0x405B
    452e:	b0 91 5c 40 	lds	r27, 0x405C
    4532:	20 e0       	ldi	r18, 0x00	; 0
    4534:	32 e0       	ldi	r19, 0x02	; 2
    4536:	40 e0       	ldi	r20, 0x00	; 0
    4538:	50 e0       	ldi	r21, 0x00	; 0
    453a:	82 0e       	add	r8, r18
    453c:	93 1e       	adc	r9, r19
    453e:	a4 1e       	adc	r10, r20
    4540:	b5 1e       	adc	r11, r21
    4542:	48 16       	cp	r4, r24
    4544:	59 06       	cpc	r5, r25
    4546:	6a 06       	cpc	r6, r26
    4548:	7b 06       	cpc	r7, r27
    454a:	08 f4       	brcc	.+2      	; 0x454e <searchNextFreeCluster+0x132>
    454c:	99 cf       	rjmp	.-206    	; 0x4480 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    454e:	44 24       	eor	r4, r4
    4550:	55 24       	eor	r5, r5
    4552:	32 01       	movw	r6, r4
    4554:	03 c0       	rjmp	.+6      	; 0x455c <searchNextFreeCluster+0x140>
    4556:	44 24       	eor	r4, r4
    4558:	55 24       	eor	r5, r5
    455a:	32 01       	movw	r6, r4
}
    455c:	64 2d       	mov	r22, r4
    455e:	75 2d       	mov	r23, r5
    4560:	86 2d       	mov	r24, r6
    4562:	97 2d       	mov	r25, r7
    4564:	df 91       	pop	r29
    4566:	cf 91       	pop	r28
    4568:	ff 90       	pop	r15
    456a:	ef 90       	pop	r14
    456c:	df 90       	pop	r13
    456e:	cf 90       	pop	r12
    4570:	bf 90       	pop	r11
    4572:	af 90       	pop	r10
    4574:	9f 90       	pop	r9
    4576:	8f 90       	pop	r8
    4578:	7f 90       	pop	r7
    457a:	6f 90       	pop	r6
    457c:	5f 90       	pop	r5
    457e:	4f 90       	pop	r4
    4580:	08 95       	ret

00004582 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4582:	cf 92       	push	r12
    4584:	df 92       	push	r13
    4586:	ef 92       	push	r14
    4588:	ff 92       	push	r15
    458a:	cf 93       	push	r28
    458c:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    458e:	db 01       	movw	r26, r22
    4590:	ca 01       	movw	r24, r20
    4592:	91 70       	andi	r25, 0x01	; 1
    4594:	a0 70       	andi	r26, 0x00	; 0
    4596:	b0 70       	andi	r27, 0x00	; 0
    4598:	00 97       	sbiw	r24, 0x00	; 0
    459a:	a1 05       	cpc	r26, r1
    459c:	b1 05       	cpc	r27, r1
    459e:	51 f4       	brne	.+20     	; 0x45b4 <freeMemoryUpdate+0x32>
    45a0:	03 2e       	mov	r0, r19
    45a2:	39 e0       	ldi	r19, 0x09	; 9
    45a4:	76 95       	lsr	r23
    45a6:	67 95       	ror	r22
    45a8:	57 95       	ror	r21
    45aa:	47 95       	ror	r20
    45ac:	3a 95       	dec	r19
    45ae:	d1 f7       	brne	.-12     	; 0x45a4 <freeMemoryUpdate+0x22>
    45b0:	30 2d       	mov	r19, r0
    45b2:	0d c0       	rjmp	.+26     	; 0x45ce <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    45b4:	03 2e       	mov	r0, r19
    45b6:	39 e0       	ldi	r19, 0x09	; 9
    45b8:	76 95       	lsr	r23
    45ba:	67 95       	ror	r22
    45bc:	57 95       	ror	r21
    45be:	47 95       	ror	r20
    45c0:	3a 95       	dec	r19
    45c2:	d1 f7       	brne	.-12     	; 0x45b8 <freeMemoryUpdate+0x36>
    45c4:	30 2d       	mov	r19, r0
    45c6:	4f 5f       	subi	r20, 0xFF	; 255
    45c8:	5f 4f       	sbci	r21, 0xFF	; 255
    45ca:	6f 4f       	sbci	r22, 0xFF	; 255
    45cc:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    45ce:	db 01       	movw	r26, r22
    45d0:	ca 01       	movw	r24, r20
    45d2:	87 70       	andi	r24, 0x07	; 7
    45d4:	90 70       	andi	r25, 0x00	; 0
    45d6:	a0 70       	andi	r26, 0x00	; 0
    45d8:	b0 70       	andi	r27, 0x00	; 0
    45da:	00 97       	sbiw	r24, 0x00	; 0
    45dc:	a1 05       	cpc	r26, r1
    45de:	b1 05       	cpc	r27, r1
    45e0:	59 f4       	brne	.+22     	; 0x45f8 <freeMemoryUpdate+0x76>
    45e2:	6a 01       	movw	r12, r20
    45e4:	7b 01       	movw	r14, r22
    45e6:	68 94       	set
    45e8:	12 f8       	bld	r1, 2
    45ea:	f6 94       	lsr	r15
    45ec:	e7 94       	ror	r14
    45ee:	d7 94       	ror	r13
    45f0:	c7 94       	ror	r12
    45f2:	16 94       	lsr	r1
    45f4:	d1 f7       	brne	.-12     	; 0x45ea <freeMemoryUpdate+0x68>
    45f6:	0f c0       	rjmp	.+30     	; 0x4616 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    45f8:	6a 01       	movw	r12, r20
    45fa:	7b 01       	movw	r14, r22
    45fc:	68 94       	set
    45fe:	12 f8       	bld	r1, 2
    4600:	f6 94       	lsr	r15
    4602:	e7 94       	ror	r14
    4604:	d7 94       	ror	r13
    4606:	c7 94       	ror	r12
    4608:	16 94       	lsr	r1
    460a:	d1 f7       	brne	.-12     	; 0x4600 <freeMemoryUpdate+0x7e>
    460c:	08 94       	sec
    460e:	c1 1c       	adc	r12, r1
    4610:	d1 1c       	adc	r13, r1
    4612:	e1 1c       	adc	r14, r1
    4614:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4616:	80 91 a2 50 	lds	r24, 0x50A2
    461a:	88 23       	and	r24, r24
    461c:	d1 f0       	breq	.+52     	; 0x4652 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    461e:	81 e0       	ldi	r24, 0x01	; 1
    4620:	60 e0       	ldi	r22, 0x00	; 0
    4622:	20 e0       	ldi	r18, 0x00	; 0
    4624:	30 e0       	ldi	r19, 0x00	; 0
    4626:	a9 01       	movw	r20, r18
    4628:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <getSetFreeCluster>
	if(flag == ADD)
    462c:	cc 23       	and	r28, r28
    462e:	39 f4       	brne	.+14     	; 0x463e <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4630:	9b 01       	movw	r18, r22
    4632:	ac 01       	movw	r20, r24
    4634:	2c 0d       	add	r18, r12
    4636:	3d 1d       	adc	r19, r13
    4638:	4e 1d       	adc	r20, r14
    463a:	5f 1d       	adc	r21, r15
    463c:	06 c0       	rjmp	.+12     	; 0x464a <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    463e:	9b 01       	movw	r18, r22
    4640:	ac 01       	movw	r20, r24
    4642:	2c 19       	sub	r18, r12
    4644:	3d 09       	sbc	r19, r13
    4646:	4e 09       	sbc	r20, r14
    4648:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    464a:	81 e0       	ldi	r24, 0x01	; 1
    464c:	61 e0       	ldi	r22, 0x01	; 1
    464e:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <getSetFreeCluster>
  }
}
    4652:	cf 91       	pop	r28
    4654:	ff 90       	pop	r15
    4656:	ef 90       	pop	r14
    4658:	df 90       	pop	r13
    465a:	cf 90       	pop	r12
    465c:	08 95       	ret

0000465e <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    465e:	2f 92       	push	r2
    4660:	3f 92       	push	r3
    4662:	4f 92       	push	r4
    4664:	5f 92       	push	r5
    4666:	6f 92       	push	r6
    4668:	7f 92       	push	r7
    466a:	8f 92       	push	r8
    466c:	9f 92       	push	r9
    466e:	af 92       	push	r10
    4670:	bf 92       	push	r11
    4672:	cf 92       	push	r12
    4674:	df 92       	push	r13
    4676:	ef 92       	push	r14
    4678:	ff 92       	push	r15
    467a:	0f 93       	push	r16
    467c:	1f 93       	push	r17
    467e:	cf 93       	push	r28
    4680:	df 93       	push	r29
    4682:	cd b7       	in	r28, 0x3d	; 61
    4684:	de b7       	in	r29, 0x3e	; 62
    4686:	2c 97       	sbiw	r28, 0x0c	; 12
    4688:	cd bf       	out	0x3d, r28	; 61
    468a:	de bf       	out	0x3e, r29	; 62
    468c:	88 2e       	mov	r8, r24
    468e:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4690:	80 91 5e 40 	lds	r24, 0x405E
    4694:	90 91 5f 40 	lds	r25, 0x405F
    4698:	a0 91 60 40 	lds	r26, 0x4060
    469c:	b0 91 61 40 	lds	r27, 0x4061
    46a0:	89 87       	std	Y+9, r24	; 0x09
    46a2:	9a 87       	std	Y+10, r25	; 0x0a
    46a4:	ab 87       	std	Y+11, r26	; 0x0b
    46a6:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    46a8:	0f 2e       	mov	r0, r31
    46aa:	f9 e4       	ldi	r31, 0x49	; 73
    46ac:	2f 2e       	mov	r2, r31
    46ae:	fe e3       	ldi	r31, 0x3E	; 62
    46b0:	3f 2e       	mov	r3, r31
    46b2:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    46b4:	c8 2c       	mov	r12, r8
    46b6:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    46b8:	d2 2c       	mov	r13, r2
    46ba:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    46bc:	5b 01       	movw	r10, r22
    46be:	08 94       	sec
    46c0:	a1 1c       	adc	r10, r1
    46c2:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    46c4:	69 85       	ldd	r22, Y+9	; 0x09
    46c6:	7a 85       	ldd	r23, Y+10	; 0x0a
    46c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    46ca:	9c 85       	ldd	r25, Y+12	; 0x0c
    46cc:	0e 94 09 1f 	call	0x3e12	; 0x3e12 <getFirstSector>
    46d0:	6d 83       	std	Y+5, r22	; 0x05
    46d2:	7e 83       	std	Y+6, r23	; 0x06
    46d4:	8f 83       	std	Y+7, r24	; 0x07
    46d6:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    46d8:	80 91 6a 50 	lds	r24, 0x506A
    46dc:	90 91 6b 50 	lds	r25, 0x506B
    46e0:	00 97       	sbiw	r24, 0x00	; 0
    46e2:	09 f4       	brne	.+2      	; 0x46e6 <findFiles+0x88>
    46e4:	13 c1       	rjmp	.+550    	; 0x490c <findFiles+0x2ae>
    46e6:	44 24       	eor	r4, r4
    46e8:	55 24       	eor	r5, r5
    46ea:	32 01       	movw	r6, r4
    46ec:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    46ee:	8d 81       	ldd	r24, Y+5	; 0x05
    46f0:	9e 81       	ldd	r25, Y+6	; 0x06
    46f2:	af 81       	ldd	r26, Y+7	; 0x07
    46f4:	b8 85       	ldd	r27, Y+8	; 0x08
    46f6:	84 0d       	add	r24, r4
    46f8:	95 1d       	adc	r25, r5
    46fa:	a6 1d       	adc	r26, r6
    46fc:	b7 1d       	adc	r27, r7
    46fe:	89 83       	std	Y+1, r24	; 0x01
    4700:	9a 83       	std	Y+2, r25	; 0x02
    4702:	ab 83       	std	Y+3, r26	; 0x03
    4704:	bc 83       	std	Y+4, r27	; 0x04
    4706:	bc 01       	movw	r22, r24
    4708:	cd 01       	movw	r24, r26
    470a:	4d 2d       	mov	r20, r13
    470c:	59 2d       	mov	r21, r9
    470e:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4712:	80 91 56 40 	lds	r24, 0x4056
    4716:	90 91 57 40 	lds	r25, 0x4057
    471a:	00 97       	sbiw	r24, 0x00	; 0
    471c:	09 f4       	brne	.+2      	; 0x4720 <findFiles+0xc2>
    471e:	e4 c0       	rjmp	.+456    	; 0x48e8 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4720:	d1 01       	movw	r26, r2
    4722:	8c 91       	ld	r24, X
    4724:	88 23       	and	r24, r24
    4726:	09 f4       	brne	.+2      	; 0x472a <findFiles+0xcc>
    4728:	10 c1       	rjmp	.+544    	; 0x494a <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    472a:	4d 2d       	mov	r20, r13
    472c:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    472e:	20 e0       	ldi	r18, 0x00	; 0
    4730:	30 e0       	ldi	r19, 0x00	; 0
    4732:	08 c0       	rjmp	.+16     	; 0x4744 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4734:	a9 01       	movw	r20, r18
    4736:	47 5b       	subi	r20, 0xB7	; 183
    4738:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    473a:	fa 01       	movw	r30, r20
    473c:	80 81       	ld	r24, Z
    473e:	88 23       	and	r24, r24
    4740:	09 f4       	brne	.+2      	; 0x4744 <findFiles+0xe6>
    4742:	06 c1       	rjmp	.+524    	; 0x4950 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4744:	85 3e       	cpi	r24, 0xE5	; 229
    4746:	09 f4       	brne	.+2      	; 0x474a <findFiles+0xec>
    4748:	c5 c0       	rjmp	.+394    	; 0x48d4 <findFiles+0x276>
    474a:	da 01       	movw	r26, r20
    474c:	1b 96       	adiw	r26, 0x0b	; 11
    474e:	8c 91       	ld	r24, X
    4750:	1b 97       	sbiw	r26, 0x0b	; 11
    4752:	8f 30       	cpi	r24, 0x0F	; 15
    4754:	09 f4       	brne	.+2      	; 0x4758 <findFiles+0xfa>
    4756:	be c0       	rjmp	.+380    	; 0x48d4 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4758:	12 30       	cpi	r17, 0x02	; 2
    475a:	08 f0       	brcs	.+2      	; 0x475e <findFiles+0x100>
    475c:	fc c0       	rjmp	.+504    	; 0x4956 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    475e:	9c 91       	ld	r25, X
    4760:	f7 01       	movw	r30, r14
    4762:	80 81       	ld	r24, Z
    4764:	98 17       	cp	r25, r24
    4766:	09 f0       	breq	.+2      	; 0x476a <findFiles+0x10c>
    4768:	b5 c0       	rjmp	.+362    	; 0x48d4 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    476a:	fa 01       	movw	r30, r20
    476c:	31 96       	adiw	r30, 0x01	; 1
    476e:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4770:	81 e0       	ldi	r24, 0x01	; 1
    4772:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4774:	41 91       	ld	r20, Z+
    4776:	9d 91       	ld	r25, X+
    4778:	49 17       	cp	r20, r25
    477a:	31 f4       	brne	.+12     	; 0x4788 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    477c:	8f 5f       	subi	r24, 0xFF	; 255
    477e:	8b 30       	cpi	r24, 0x0B	; 11
    4780:	c9 f7       	brne	.-14     	; 0x4774 <findFiles+0x116>
    4782:	8b 01       	movw	r16, r22
    4784:	6b 01       	movw	r12, r22
    4786:	05 c0       	rjmp	.+10     	; 0x4792 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4788:	8b 30       	cpi	r24, 0x0B	; 11
    478a:	09 f0       	breq	.+2      	; 0x478e <findFiles+0x130>
    478c:	a3 c0       	rjmp	.+326    	; 0x48d4 <findFiles+0x276>
    478e:	8b 01       	movw	r16, r22
    4790:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4792:	f1 e0       	ldi	r31, 0x01	; 1
    4794:	8f 16       	cp	r8, r31
    4796:	09 f0       	breq	.+2      	; 0x479a <findFiles+0x13c>
    4798:	41 c0       	rjmp	.+130    	; 0x481c <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    479a:	89 81       	ldd	r24, Y+1	; 0x01
    479c:	9a 81       	ldd	r25, Y+2	; 0x02
    479e:	ab 81       	ldd	r26, Y+3	; 0x03
    47a0:	bc 81       	ldd	r27, Y+4	; 0x04
    47a2:	80 93 a3 50 	sts	0x50A3, r24
    47a6:	90 93 a4 50 	sts	0x50A4, r25
    47aa:	a0 93 a5 50 	sts	0x50A5, r26
    47ae:	b0 93 a6 50 	sts	0x50A6, r27
				appendFileLocation = i;
    47b2:	c9 01       	movw	r24, r18
    47b4:	a0 e0       	ldi	r26, 0x00	; 0
    47b6:	b0 e0       	ldi	r27, 0x00	; 0
    47b8:	80 93 4a 40 	sts	0x404A, r24
    47bc:	90 93 4b 40 	sts	0x404B, r25
    47c0:	a0 93 4c 40 	sts	0x404C, r26
    47c4:	b0 93 4d 40 	sts	0x404D, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    47c8:	d6 01       	movw	r26, r12
    47ca:	54 96       	adiw	r26, 0x14	; 20
    47cc:	4d 91       	ld	r20, X+
    47ce:	5c 91       	ld	r21, X
    47d0:	55 97       	sbiw	r26, 0x15	; 21
    47d2:	60 e0       	ldi	r22, 0x00	; 0
    47d4:	70 e0       	ldi	r23, 0x00	; 0
    47d6:	ba 01       	movw	r22, r20
    47d8:	55 27       	eor	r21, r21
    47da:	44 27       	eor	r20, r20
    47dc:	5a 96       	adiw	r26, 0x1a	; 26
    47de:	8d 91       	ld	r24, X+
    47e0:	9c 91       	ld	r25, X
    47e2:	5b 97       	sbiw	r26, 0x1b	; 27
    47e4:	a0 e0       	ldi	r26, 0x00	; 0
    47e6:	b0 e0       	ldi	r27, 0x00	; 0
    47e8:	84 2b       	or	r24, r20
    47ea:	95 2b       	or	r25, r21
    47ec:	a6 2b       	or	r26, r22
    47ee:	b7 2b       	or	r27, r23
    47f0:	80 93 74 50 	sts	0x5074, r24
    47f4:	90 93 75 50 	sts	0x5075, r25
    47f8:	a0 93 76 50 	sts	0x5076, r26
    47fc:	b0 93 77 50 	sts	0x5077, r27
				fileSize = dir->fileSize;
    4800:	f6 01       	movw	r30, r12
    4802:	84 8d       	ldd	r24, Z+28	; 0x1c
    4804:	95 8d       	ldd	r25, Z+29	; 0x1d
    4806:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4808:	b7 8d       	ldd	r27, Z+31	; 0x1f
    480a:	80 93 52 40 	sts	0x4052, r24
    480e:	90 93 53 40 	sts	0x4053, r25
    4812:	a0 93 54 40 	sts	0x4054, r26
    4816:	b0 93 55 40 	sts	0x4055, r27
			    return (dir);
    481a:	a5 c0       	rjmp	.+330    	; 0x4966 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    481c:	d6 01       	movw	r26, r12
    481e:	54 96       	adiw	r26, 0x14	; 20
    4820:	8d 91       	ld	r24, X+
    4822:	9c 91       	ld	r25, X
    4824:	55 97       	sbiw	r26, 0x15	; 21
    4826:	a0 e0       	ldi	r26, 0x00	; 0
    4828:	b0 e0       	ldi	r27, 0x00	; 0
    482a:	3c 01       	movw	r6, r24
    482c:	55 24       	eor	r5, r5
    482e:	44 24       	eor	r4, r4
    4830:	f6 01       	movw	r30, r12
    4832:	82 8d       	ldd	r24, Z+26	; 0x1a
    4834:	93 8d       	ldd	r25, Z+27	; 0x1b
    4836:	a0 e0       	ldi	r26, 0x00	; 0
    4838:	b0 e0       	ldi	r27, 0x00	; 0
    483a:	48 2a       	or	r4, r24
    483c:	59 2a       	or	r5, r25
    483e:	6a 2a       	or	r6, r26
    4840:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4842:	85 ee       	ldi	r24, 0xE5	; 229
    4844:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4846:	69 81       	ldd	r22, Y+1	; 0x01
    4848:	7a 81       	ldd	r23, Y+2	; 0x02
    484a:	8b 81       	ldd	r24, Y+3	; 0x03
    484c:	9c 81       	ldd	r25, Y+4	; 0x04
    484e:	49 e4       	ldi	r20, 0x49	; 73
    4850:	5e e3       	ldi	r21, 0x3E	; 62
    4852:	20 e0       	ldi	r18, 0x00	; 0
    4854:	32 e0       	ldi	r19, 0x02	; 2
    4856:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    485a:	d6 01       	movw	r26, r12
    485c:	5c 96       	adiw	r26, 0x1c	; 28
    485e:	4d 91       	ld	r20, X+
    4860:	5d 91       	ld	r21, X+
    4862:	6d 91       	ld	r22, X+
    4864:	7c 91       	ld	r23, X
    4866:	5f 97       	sbiw	r26, 0x1f	; 31
    4868:	80 e0       	ldi	r24, 0x00	; 0
    486a:	0e 94 c1 22 	call	0x4582	; 0x4582 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    486e:	82 e0       	ldi	r24, 0x02	; 2
    4870:	60 e0       	ldi	r22, 0x00	; 0
    4872:	20 e0       	ldi	r18, 0x00	; 0
    4874:	30 e0       	ldi	r19, 0x00	; 0
    4876:	a9 01       	movw	r20, r18
    4878:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <getSetFreeCluster>
    487c:	dc 01       	movw	r26, r24
    487e:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4880:	48 16       	cp	r4, r24
    4882:	59 06       	cpc	r5, r25
    4884:	6a 06       	cpc	r6, r26
    4886:	7b 06       	cpc	r7, r27
    4888:	30 f4       	brcc	.+12     	; 0x4896 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    488a:	82 e0       	ldi	r24, 0x02	; 2
    488c:	61 e0       	ldi	r22, 0x01	; 1
    488e:	a3 01       	movw	r20, r6
    4890:	92 01       	movw	r18, r4
    4892:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4896:	c3 01       	movw	r24, r6
    4898:	b2 01       	movw	r22, r4
    489a:	40 e0       	ldi	r20, 0x00	; 0
    489c:	00 e0       	ldi	r16, 0x00	; 0
    489e:	10 e0       	ldi	r17, 0x00	; 0
    48a0:	98 01       	movw	r18, r16
    48a2:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
    48a6:	6b 01       	movw	r12, r22
    48a8:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    48aa:	c3 01       	movw	r24, r6
    48ac:	b2 01       	movw	r22, r4
    48ae:	41 e0       	ldi	r20, 0x01	; 1
    48b0:	00 e0       	ldi	r16, 0x00	; 0
    48b2:	10 e0       	ldi	r17, 0x00	; 0
    48b4:	98 01       	movw	r18, r16
    48b6:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    48ba:	b7 ef       	ldi	r27, 0xF7	; 247
    48bc:	cb 16       	cp	r12, r27
    48be:	bf ef       	ldi	r27, 0xFF	; 255
    48c0:	db 06       	cpc	r13, r27
    48c2:	bf ef       	ldi	r27, 0xFF	; 255
    48c4:	eb 06       	cpc	r14, r27
    48c6:	bf e0       	ldi	r27, 0x0F	; 15
    48c8:	fb 06       	cpc	r15, r27
    48ca:	08 f0       	brcs	.+2      	; 0x48ce <findFiles+0x270>
    48cc:	47 c0       	rjmp	.+142    	; 0x495c <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    48ce:	26 01       	movw	r4, r12
    48d0:	37 01       	movw	r6, r14
    48d2:	e1 cf       	rjmp	.-62     	; 0x4896 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    48d4:	20 5e       	subi	r18, 0xE0	; 224
    48d6:	3f 4f       	sbci	r19, 0xFF	; 255
    48d8:	80 91 56 40 	lds	r24, 0x4056
    48dc:	90 91 57 40 	lds	r25, 0x4057
    48e0:	28 17       	cp	r18, r24
    48e2:	39 07       	cpc	r19, r25
    48e4:	08 f4       	brcc	.+2      	; 0x48e8 <findFiles+0x28a>
    48e6:	26 cf       	rjmp	.-436    	; 0x4734 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    48e8:	08 94       	sec
    48ea:	41 1c       	adc	r4, r1
    48ec:	51 1c       	adc	r5, r1
    48ee:	61 1c       	adc	r6, r1
    48f0:	71 1c       	adc	r7, r1
    48f2:	80 91 6a 50 	lds	r24, 0x506A
    48f6:	90 91 6b 50 	lds	r25, 0x506B
    48fa:	a0 e0       	ldi	r26, 0x00	; 0
    48fc:	b0 e0       	ldi	r27, 0x00	; 0
    48fe:	48 16       	cp	r4, r24
    4900:	59 06       	cpc	r5, r25
    4902:	6a 06       	cpc	r6, r26
    4904:	7b 06       	cpc	r7, r27
    4906:	08 f4       	brcc	.+2      	; 0x490a <findFiles+0x2ac>
    4908:	f2 ce       	rjmp	.-540    	; 0x46ee <findFiles+0x90>
    490a:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    490c:	69 85       	ldd	r22, Y+9	; 0x09
    490e:	7a 85       	ldd	r23, Y+10	; 0x0a
    4910:	8b 85       	ldd	r24, Y+11	; 0x0b
    4912:	9c 85       	ldd	r25, Y+12	; 0x0c
    4914:	40 e0       	ldi	r20, 0x00	; 0
    4916:	00 e0       	ldi	r16, 0x00	; 0
    4918:	10 e0       	ldi	r17, 0x00	; 0
    491a:	98 01       	movw	r18, r16
    491c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
    4920:	69 87       	std	Y+9, r22	; 0x09
    4922:	7a 87       	std	Y+10, r23	; 0x0a
    4924:	8b 87       	std	Y+11, r24	; 0x0b
    4926:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4928:	67 3f       	cpi	r22, 0xF7	; 247
    492a:	ef ef       	ldi	r30, 0xFF	; 255
    492c:	7e 07       	cpc	r23, r30
    492e:	ef ef       	ldi	r30, 0xFF	; 255
    4930:	8e 07       	cpc	r24, r30
    4932:	ef e0       	ldi	r30, 0x0F	; 15
    4934:	9e 07       	cpc	r25, r30
    4936:	a8 f4       	brcc	.+42     	; 0x4962 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4938:	61 15       	cp	r22, r1
    493a:	71 05       	cpc	r23, r1
    493c:	81 05       	cpc	r24, r1
    493e:	91 05       	cpc	r25, r1
    4940:	09 f0       	breq	.+2      	; 0x4944 <findFiles+0x2e6>
    4942:	c0 ce       	rjmp	.-640    	; 0x46c4 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4944:	00 e0       	ldi	r16, 0x00	; 0
    4946:	10 e0       	ldi	r17, 0x00	; 0
    4948:	0e c0       	rjmp	.+28     	; 0x4966 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    494a:	00 e0       	ldi	r16, 0x00	; 0
    494c:	10 e0       	ldi	r17, 0x00	; 0
    494e:	0b c0       	rjmp	.+22     	; 0x4966 <findFiles+0x308>
    4950:	00 e0       	ldi	r16, 0x00	; 0
    4952:	10 e0       	ldi	r17, 0x00	; 0
    4954:	08 c0       	rjmp	.+16     	; 0x4966 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4956:	00 e0       	ldi	r16, 0x00	; 0
    4958:	10 e0       	ldi	r17, 0x00	; 0
    495a:	05 c0       	rjmp	.+10     	; 0x4966 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    495c:	00 e0       	ldi	r16, 0x00	; 0
    495e:	10 e0       	ldi	r17, 0x00	; 0
    4960:	02 c0       	rjmp	.+4      	; 0x4966 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4962:	00 e0       	ldi	r16, 0x00	; 0
    4964:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4966:	80 2f       	mov	r24, r16
    4968:	91 2f       	mov	r25, r17
    496a:	2c 96       	adiw	r28, 0x0c	; 12
    496c:	cd bf       	out	0x3d, r28	; 61
    496e:	de bf       	out	0x3e, r29	; 62
    4970:	df 91       	pop	r29
    4972:	cf 91       	pop	r28
    4974:	1f 91       	pop	r17
    4976:	0f 91       	pop	r16
    4978:	ff 90       	pop	r15
    497a:	ef 90       	pop	r14
    497c:	df 90       	pop	r13
    497e:	cf 90       	pop	r12
    4980:	bf 90       	pop	r11
    4982:	af 90       	pop	r10
    4984:	9f 90       	pop	r9
    4986:	8f 90       	pop	r8
    4988:	7f 90       	pop	r7
    498a:	6f 90       	pop	r6
    498c:	5f 90       	pop	r5
    498e:	4f 90       	pop	r4
    4990:	3f 90       	pop	r3
    4992:	2f 90       	pop	r2
    4994:	08 95       	ret

00004996 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4996:	0e 94 4f 21 	call	0x429e	; 0x429e <convertFileName>
  if(error) return;
    499a:	88 23       	and	r24, r24
    499c:	29 f4       	brne	.+10     	; 0x49a8 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    499e:	82 e0       	ldi	r24, 0x02	; 2
    49a0:	62 e9       	ldi	r22, 0x92	; 146
    49a2:	70 e5       	ldi	r23, 0x50	; 80
    49a4:	0e 94 2f 23 	call	0x465e	; 0x465e <findFiles>
    49a8:	08 95       	ret

000049aa <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    49aa:	4f 92       	push	r4
    49ac:	5f 92       	push	r5
    49ae:	6f 92       	push	r6
    49b0:	7f 92       	push	r7
    49b2:	af 92       	push	r10
    49b4:	bf 92       	push	r11
    49b6:	cf 92       	push	r12
    49b8:	df 92       	push	r13
    49ba:	ef 92       	push	r14
    49bc:	ff 92       	push	r15
    49be:	0f 93       	push	r16
    49c0:	1f 93       	push	r17
    49c2:	cf 93       	push	r28
    49c4:	c8 2f       	mov	r28, r24
    49c6:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    49c8:	0e 94 4f 21 	call	0x429e	; 0x429e <convertFileName>
if(error) return 2;
    49cc:	88 23       	and	r24, r24
    49ce:	09 f0       	breq	.+2      	; 0x49d2 <readFile+0x28>
    49d0:	57 c0       	rjmp	.+174    	; 0x4a80 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    49d2:	81 e0       	ldi	r24, 0x01	; 1
    49d4:	62 e9       	ldi	r22, 0x92	; 146
    49d6:	70 e5       	ldi	r23, 0x50	; 80
    49d8:	0e 94 2f 23 	call	0x465e	; 0x465e <findFiles>
    49dc:	fc 01       	movw	r30, r24
if(dir == 0) 
    49de:	00 97       	sbiw	r24, 0x00	; 0
    49e0:	31 f4       	brne	.+12     	; 0x49ee <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    49e2:	81 e0       	ldi	r24, 0x01	; 1
    49e4:	cc 23       	and	r28, r28
    49e6:	09 f4       	brne	.+2      	; 0x49ea <readFile+0x40>
    49e8:	4e c0       	rjmp	.+156    	; 0x4a86 <readFile+0xdc>
    49ea:	80 e0       	ldi	r24, 0x00	; 0
    49ec:	4c c0       	rjmp	.+152    	; 0x4a86 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    49ee:	c1 30       	cpi	r28, 0x01	; 1
    49f0:	09 f4       	brne	.+2      	; 0x49f4 <readFile+0x4a>
    49f2:	48 c0       	rjmp	.+144    	; 0x4a84 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    49f4:	44 88       	ldd	r4, Z+20	; 0x14
    49f6:	55 88       	ldd	r5, Z+21	; 0x15
    49f8:	66 24       	eor	r6, r6
    49fa:	77 24       	eor	r7, r7
    49fc:	32 01       	movw	r6, r4
    49fe:	55 24       	eor	r5, r5
    4a00:	44 24       	eor	r4, r4
    4a02:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a04:	93 8d       	ldd	r25, Z+27	; 0x1b
    4a06:	a0 e0       	ldi	r26, 0x00	; 0
    4a08:	b0 e0       	ldi	r27, 0x00	; 0
    4a0a:	48 2a       	or	r4, r24
    4a0c:	59 2a       	or	r5, r25
    4a0e:	6a 2a       	or	r6, r26
    4a10:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4a12:	0f 2e       	mov	r0, r31
    4a14:	fd ea       	ldi	r31, 0xAD	; 173
    4a16:	af 2e       	mov	r10, r31
    4a18:	f1 e2       	ldi	r31, 0x21	; 33
    4a1a:	bf 2e       	mov	r11, r31
    4a1c:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4a1e:	c3 01       	movw	r24, r6
    4a20:	b2 01       	movw	r22, r4
    4a22:	0e 94 09 1f 	call	0x3e12	; 0x3e12 <getFirstSector>
    4a26:	6b 01       	movw	r12, r22
    4a28:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4a2a:	80 91 6a 50 	lds	r24, 0x506A
    4a2e:	90 91 6b 50 	lds	r25, 0x506B
    4a32:	00 97       	sbiw	r24, 0x00	; 0
    4a34:	a1 f0       	breq	.+40     	; 0x4a5e <readFile+0xb4>
    4a36:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4a38:	c7 01       	movw	r24, r14
    4a3a:	b6 01       	movw	r22, r12
    4a3c:	6c 0f       	add	r22, r28
    4a3e:	71 1d       	adc	r23, r1
    4a40:	81 1d       	adc	r24, r1
    4a42:	91 1d       	adc	r25, r1
    4a44:	a5 01       	movw	r20, r10
    4a46:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4a4a:	cf 5f       	subi	r28, 0xFF	; 255
    4a4c:	80 91 6a 50 	lds	r24, 0x506A
    4a50:	90 91 6b 50 	lds	r25, 0x506B
    4a54:	2c 2f       	mov	r18, r28
    4a56:	30 e0       	ldi	r19, 0x00	; 0
    4a58:	28 17       	cp	r18, r24
    4a5a:	39 07       	cpc	r19, r25
    4a5c:	68 f3       	brcs	.-38     	; 0x4a38 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4a5e:	c3 01       	movw	r24, r6
    4a60:	b2 01       	movw	r22, r4
    4a62:	40 e0       	ldi	r20, 0x00	; 0
    4a64:	00 e0       	ldi	r16, 0x00	; 0
    4a66:	10 e0       	ldi	r17, 0x00	; 0
    4a68:	98 01       	movw	r18, r16
    4a6a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
    4a6e:	2b 01       	movw	r4, r22
    4a70:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4a72:	61 15       	cp	r22, r1
    4a74:	71 05       	cpc	r23, r1
    4a76:	81 05       	cpc	r24, r1
    4a78:	91 05       	cpc	r25, r1
    4a7a:	89 f6       	brne	.-94     	; 0x4a1e <readFile+0x74>
	  return 0;}
    4a7c:	80 e0       	ldi	r24, 0x00	; 0
    4a7e:	03 c0       	rjmp	.+6      	; 0x4a86 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4a80:	82 e0       	ldi	r24, 0x02	; 2
    4a82:	01 c0       	rjmp	.+2      	; 0x4a86 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4a84:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4a86:	cf 91       	pop	r28
    4a88:	1f 91       	pop	r17
    4a8a:	0f 91       	pop	r16
    4a8c:	ff 90       	pop	r15
    4a8e:	ef 90       	pop	r14
    4a90:	df 90       	pop	r13
    4a92:	cf 90       	pop	r12
    4a94:	bf 90       	pop	r11
    4a96:	af 90       	pop	r10
    4a98:	7f 90       	pop	r7
    4a9a:	6f 90       	pop	r6
    4a9c:	5f 90       	pop	r5
    4a9e:	4f 90       	pop	r4
    4aa0:	08 95       	ret

00004aa2 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4aa2:	2f 92       	push	r2
    4aa4:	3f 92       	push	r3
    4aa6:	4f 92       	push	r4
    4aa8:	5f 92       	push	r5
    4aaa:	6f 92       	push	r6
    4aac:	7f 92       	push	r7
    4aae:	8f 92       	push	r8
    4ab0:	9f 92       	push	r9
    4ab2:	af 92       	push	r10
    4ab4:	bf 92       	push	r11
    4ab6:	cf 92       	push	r12
    4ab8:	df 92       	push	r13
    4aba:	ef 92       	push	r14
    4abc:	ff 92       	push	r15
    4abe:	0f 93       	push	r16
    4ac0:	1f 93       	push	r17
    4ac2:	cf 93       	push	r28
    4ac4:	df 93       	push	r29
    4ac6:	cd b7       	in	r28, 0x3d	; 61
    4ac8:	de b7       	in	r29, 0x3e	; 62
    4aca:	60 97       	sbiw	r28, 0x10	; 16
    4acc:	cd bf       	out	0x3d, r28	; 61
    4ace:	de bf       	out	0x3e, r29	; 62
    4ad0:	fc 01       	movw	r30, r24
    4ad2:	6d 83       	std	Y+5, r22	; 0x05
    4ad4:	7e 83       	std	Y+6, r23	; 0x06
    4ad6:	49 01       	movw	r8, r18
    4ad8:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4ada:	81 e0       	ldi	r24, 0x01	; 1
    4adc:	bf 01       	movw	r22, r30
    4ade:	0e 94 d5 24 	call	0x49aa	; 0x49aa <readFile>

if(j == 1) 
    4ae2:	81 30       	cpi	r24, 0x01	; 1
    4ae4:	09 f0       	breq	.+2      	; 0x4ae8 <writeFile+0x46>
    4ae6:	7b c0       	rjmp	.+246    	; 0x4bde <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4ae8:	00 91 74 50 	lds	r16, 0x5074
    4aec:	10 91 75 50 	lds	r17, 0x5075
    4af0:	20 91 76 50 	lds	r18, 0x5076
    4af4:	30 91 77 50 	lds	r19, 0x5077
    4af8:	09 83       	std	Y+1, r16	; 0x01
    4afa:	1a 83       	std	Y+2, r17	; 0x02
    4afc:	2b 83       	std	Y+3, r18	; 0x03
    4afe:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4b00:	cc 24       	eor	r12, r12
    4b02:	dd 24       	eor	r13, r13
    4b04:	76 01       	movw	r14, r12
    4b06:	24 01       	movw	r4, r8
    4b08:	35 01       	movw	r6, r10
    4b0a:	48 01       	movw	r8, r16
    4b0c:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4b0e:	c5 01       	movw	r24, r10
    4b10:	b4 01       	movw	r22, r8
    4b12:	40 e0       	ldi	r20, 0x00	; 0
    4b14:	00 e0       	ldi	r16, 0x00	; 0
    4b16:	10 e0       	ldi	r17, 0x00	; 0
    4b18:	98 01       	movw	r18, r16
    4b1a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
    4b1e:	dc 01       	movw	r26, r24
    4b20:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4b22:	8f 3f       	cpi	r24, 0xFF	; 255
    4b24:	1f ef       	ldi	r17, 0xFF	; 255
    4b26:	91 07       	cpc	r25, r17
    4b28:	1f ef       	ldi	r17, 0xFF	; 255
    4b2a:	a1 07       	cpc	r26, r17
    4b2c:	1f ef       	ldi	r17, 0xFF	; 255
    4b2e:	b1 07       	cpc	r27, r17
    4b30:	41 f0       	breq	.+16     	; 0x4b42 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4b32:	08 94       	sec
    4b34:	c1 1c       	adc	r12, r1
    4b36:	d1 1c       	adc	r13, r1
    4b38:	e1 1c       	adc	r14, r1
    4b3a:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4b3c:	4c 01       	movw	r8, r24
    4b3e:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4b40:	e6 cf       	rjmp	.-52     	; 0x4b0e <writeFile+0x6c>
    4b42:	89 82       	std	Y+1, r8	; 0x01
    4b44:	9a 82       	std	Y+2, r9	; 0x02
    4b46:	ab 82       	std	Y+3, r10	; 0x03
    4b48:	bc 82       	std	Y+4, r11	; 0x04
    4b4a:	53 01       	movw	r10, r6
    4b4c:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4b4e:	20 91 6a 50 	lds	r18, 0x506A
    4b52:	30 91 6b 50 	lds	r19, 0x506B
    4b56:	80 91 56 40 	lds	r24, 0x4056
    4b5a:	90 91 57 40 	lds	r25, 0x4057
    4b5e:	60 90 56 40 	lds	r6, 0x4056
    4b62:	70 90 57 40 	lds	r7, 0x4057
    4b66:	bc 01       	movw	r22, r24
    4b68:	80 e0       	ldi	r24, 0x00	; 0
    4b6a:	90 e0       	ldi	r25, 0x00	; 0
    4b6c:	40 e0       	ldi	r20, 0x00	; 0
    4b6e:	50 e0       	ldi	r21, 0x00	; 0
    4b70:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    4b74:	a7 01       	movw	r20, r14
    4b76:	96 01       	movw	r18, r12
    4b78:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    4b7c:	dc 01       	movw	r26, r24
    4b7e:	cb 01       	movw	r24, r22
    4b80:	40 91 52 40 	lds	r20, 0x4052
    4b84:	50 91 53 40 	lds	r21, 0x4053
    4b88:	60 91 54 40 	lds	r22, 0x4054
    4b8c:	70 91 55 40 	lds	r23, 0x4055
    4b90:	8a 01       	movw	r16, r20
    4b92:	9b 01       	movw	r18, r22
    4b94:	08 1b       	sub	r16, r24
    4b96:	19 0b       	sbc	r17, r25
    4b98:	2a 0b       	sbc	r18, r26
    4b9a:	3b 0b       	sbc	r19, r27
    4b9c:	c9 01       	movw	r24, r18
    4b9e:	b8 01       	movw	r22, r16
    4ba0:	93 01       	movw	r18, r6
    4ba2:	40 e0       	ldi	r20, 0x00	; 0
    4ba4:	50 e0       	ldi	r21, 0x00	; 0
    4ba6:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    4baa:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4bac:	69 81       	ldd	r22, Y+1	; 0x01
    4bae:	7a 81       	ldd	r23, Y+2	; 0x02
    4bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb2:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb4:	0e 94 09 1f 	call	0x3e12	; 0x3e12 <getFirstSector>
    4bb8:	dc 01       	movw	r26, r24
    4bba:	cb 01       	movw	r24, r22
    4bbc:	20 2e       	mov	r2, r16
    4bbe:	33 24       	eor	r3, r3
    4bc0:	28 0e       	add	r2, r24
    4bc2:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4bc4:	b1 01       	movw	r22, r2
    4bc6:	80 e0       	ldi	r24, 0x00	; 0
    4bc8:	90 e0       	ldi	r25, 0x00	; 0
    4bca:	49 e4       	ldi	r20, 0x49	; 73
    4bcc:	5e e3       	ldi	r21, 0x3E	; 62
    4bce:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4bd2:	1f 86       	std	Y+15, r1	; 0x0f
    4bd4:	18 8a       	std	Y+16, r1	; 0x10
    4bd6:	19 86       	std	Y+9, r1	; 0x09
    4bd8:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4bda:	11 e0       	ldi	r17, 0x01	; 1
    4bdc:	4c c0       	rjmp	.+152    	; 0x4c76 <writeFile+0x1d4>
}
else if(j == 2) 
    4bde:	82 30       	cpi	r24, 0x02	; 2
    4be0:	09 f4       	brne	.+2      	; 0x4be4 <writeFile+0x142>
    4be2:	0c c2       	rjmp	.+1048   	; 0x4ffc <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4be4:	82 e0       	ldi	r24, 0x02	; 2
    4be6:	60 e0       	ldi	r22, 0x00	; 0
    4be8:	20 e0       	ldi	r18, 0x00	; 0
    4bea:	30 e0       	ldi	r19, 0x00	; 0
    4bec:	a9 01       	movw	r20, r18
    4bee:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <getSetFreeCluster>
  if(cluster > totalClusters)
    4bf2:	00 91 59 40 	lds	r16, 0x4059
    4bf6:	10 91 5a 40 	lds	r17, 0x405A
    4bfa:	20 91 5b 40 	lds	r18, 0x405B
    4bfe:	30 91 5c 40 	lds	r19, 0x405C
    4c02:	06 17       	cp	r16, r22
    4c04:	17 07       	cpc	r17, r23
    4c06:	28 07       	cpc	r18, r24
    4c08:	39 07       	cpc	r19, r25
    4c0a:	40 f4       	brcc	.+16     	; 0x4c1c <writeFile+0x17a>
     cluster = rootCluster;
    4c0c:	60 91 5e 40 	lds	r22, 0x405E
    4c10:	70 91 5f 40 	lds	r23, 0x405F
    4c14:	80 91 60 40 	lds	r24, 0x4060
    4c18:	90 91 61 40 	lds	r25, 0x4061

  cluster = searchNextFreeCluster(cluster);
    4c1c:	0e 94 0e 22 	call	0x441c	; 0x441c <searchNextFreeCluster>
    4c20:	69 83       	std	Y+1, r22	; 0x01
    4c22:	7a 83       	std	Y+2, r23	; 0x02
    4c24:	8b 83       	std	Y+3, r24	; 0x03
    4c26:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4c28:	61 15       	cp	r22, r1
    4c2a:	71 05       	cpc	r23, r1
    4c2c:	81 05       	cpc	r24, r1
    4c2e:	91 05       	cpc	r25, r1
    4c30:	09 f4       	brne	.+2      	; 0x4c34 <writeFile+0x192>
    4c32:	e6 c1       	rjmp	.+972    	; 0x5000 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4c34:	41 e0       	ldi	r20, 0x01	; 1
    4c36:	0f ef       	ldi	r16, 0xFF	; 255
    4c38:	1f ef       	ldi	r17, 0xFF	; 255
    4c3a:	98 01       	movw	r18, r16
    4c3c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4c40:	2b 81       	ldd	r18, Y+3	; 0x03
    4c42:	3c 81       	ldd	r19, Y+4	; 0x04
    4c44:	29 87       	std	Y+9, r18	; 0x09
    4c46:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4c48:	89 81       	ldd	r24, Y+1	; 0x01
    4c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c4c:	8f 87       	std	Y+15, r24	; 0x0f
    4c4e:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4c50:	10 92 52 40 	sts	0x4052, r1
    4c54:	10 92 53 40 	sts	0x4053, r1
    4c58:	10 92 54 40 	sts	0x4054, r1
    4c5c:	10 92 55 40 	sts	0x4055, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4c60:	69 81       	ldd	r22, Y+1	; 0x01
    4c62:	7a 81       	ldd	r23, Y+2	; 0x02
    4c64:	8b 81       	ldd	r24, Y+3	; 0x03
    4c66:	9c 81       	ldd	r25, Y+4	; 0x04
    4c68:	0e 94 09 1f 	call	0x3e12	; 0x3e12 <getFirstSector>
    4c6c:	dc 01       	movw	r26, r24
    4c6e:	cb 01       	movw	r24, r22
    4c70:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4c72:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4c74:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4c76:	81 14       	cp	r8, r1
    4c78:	91 04       	cpc	r9, r1
    4c7a:	a1 04       	cpc	r10, r1
    4c7c:	b1 04       	cpc	r11, r1
    4c7e:	09 f4       	brne	.+2      	; 0x4c82 <writeFile+0x1e0>
    4c80:	8d c0       	rjmp	.+282    	; 0x4d9c <writeFile+0x2fa>
    4c82:	44 24       	eor	r4, r4
    4c84:	55 24       	eor	r5, r5
    4c86:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4c88:	c0 2e       	mov	r12, r16
    4c8a:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4c8c:	90 e0       	ldi	r25, 0x00	; 0
    4c8e:	89 16       	cp	r8, r25
    4c90:	92 e0       	ldi	r25, 0x02	; 2
    4c92:	99 06       	cpc	r9, r25
    4c94:	90 e0       	ldi	r25, 0x00	; 0
    4c96:	a9 06       	cpc	r10, r25
    4c98:	90 e0       	ldi	r25, 0x00	; 0
    4c9a:	b9 06       	cpc	r11, r25
    4c9c:	88 f0       	brcs	.+34     	; 0x4cc0 <writeFile+0x21e>
		 writtenData += 512;
    4c9e:	00 e0       	ldi	r16, 0x00	; 0
    4ca0:	12 e0       	ldi	r17, 0x02	; 2
    4ca2:	20 e0       	ldi	r18, 0x00	; 0
    4ca4:	30 e0       	ldi	r19, 0x00	; 0
    4ca6:	40 0e       	add	r4, r16
    4ca8:	51 1e       	adc	r5, r17
    4caa:	62 1e       	adc	r6, r18
    4cac:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4cae:	80 e0       	ldi	r24, 0x00	; 0
    4cb0:	9e ef       	ldi	r25, 0xFE	; 254
    4cb2:	af ef       	ldi	r26, 0xFF	; 255
    4cb4:	bf ef       	ldi	r27, 0xFF	; 255
    4cb6:	88 0e       	add	r8, r24
    4cb8:	99 1e       	adc	r9, r25
    4cba:	aa 1e       	adc	r10, r26
    4cbc:	bb 1e       	adc	r11, r27
    4cbe:	0c c0       	rjmp	.+24     	; 0x4cd8 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4cc0:	48 0c       	add	r4, r8
    4cc2:	59 1c       	adc	r5, r9
    4cc4:	6a 1c       	adc	r6, r10
    4cc6:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4cc8:	95 01       	movw	r18, r10
    4cca:	84 01       	movw	r16, r8
    4ccc:	11 70       	andi	r17, 0x01	; 1
    4cce:	20 70       	andi	r18, 0x00	; 0
    4cd0:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4cd2:	88 24       	eor	r8, r8
    4cd4:	99 24       	eor	r9, r9
    4cd6:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4cd8:	80 91 52 40 	lds	r24, 0x4052
    4cdc:	90 91 53 40 	lds	r25, 0x4053
    4ce0:	a0 91 54 40 	lds	r26, 0x4054
    4ce4:	b0 91 55 40 	lds	r27, 0x4055
    4ce8:	80 50       	subi	r24, 0x00	; 0
    4cea:	9e 4f       	sbci	r25, 0xFE	; 254
    4cec:	af 4f       	sbci	r26, 0xFF	; 255
    4cee:	bf 4f       	sbci	r27, 0xFF	; 255
    4cf0:	80 93 52 40 	sts	0x4052, r24
    4cf4:	90 93 53 40 	sts	0x4053, r25
    4cf8:	a0 93 54 40 	sts	0x4054, r26
    4cfc:	b0 93 55 40 	sts	0x4055, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4d00:	b1 01       	movw	r22, r2
    4d02:	80 e0       	ldi	r24, 0x00	; 0
    4d04:	90 e0       	ldi	r25, 0x00	; 0
    4d06:	a2 01       	movw	r20, r4
    4d08:	40 1b       	sub	r20, r16
    4d0a:	51 0b       	sbc	r21, r17
    4d0c:	ad 81       	ldd	r26, Y+5	; 0x05
    4d0e:	be 81       	ldd	r27, Y+6	; 0x06
    4d10:	4a 0f       	add	r20, r26
    4d12:	5b 1f       	adc	r21, r27
    4d14:	98 01       	movw	r18, r16
    4d16:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <SD_write_block>
	j++;
    4d1a:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4d1c:	20 91 6a 50 	lds	r18, 0x506A
    4d20:	30 91 6b 50 	lds	r19, 0x506B
    4d24:	8c 2d       	mov	r24, r12
    4d26:	90 e0       	ldi	r25, 0x00	; 0
    4d28:	82 17       	cp	r24, r18
    4d2a:	93 07       	cpc	r25, r19
    4d2c:	29 f5       	brne	.+74     	; 0x4d78 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4d2e:	69 81       	ldd	r22, Y+1	; 0x01
    4d30:	7a 81       	ldd	r23, Y+2	; 0x02
    4d32:	8b 81       	ldd	r24, Y+3	; 0x03
    4d34:	9c 81       	ldd	r25, Y+4	; 0x04
    4d36:	0e 94 0e 22 	call	0x441c	; 0x441c <searchNextFreeCluster>
    4d3a:	6b 01       	movw	r12, r22
    4d3c:	7c 01       	movw	r14, r24
		if(cluster == 0){
    4d3e:	61 15       	cp	r22, r1
    4d40:	71 05       	cpc	r23, r1
    4d42:	81 05       	cpc	r24, r1
    4d44:	91 05       	cpc	r25, r1
    4d46:	09 f4       	brne	.+2      	; 0x4d4a <writeFile+0x2a8>
    4d48:	5d c1       	rjmp	.+698    	; 0x5004 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    4d4a:	69 81       	ldd	r22, Y+1	; 0x01
    4d4c:	7a 81       	ldd	r23, Y+2	; 0x02
    4d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    4d50:	9c 81       	ldd	r25, Y+4	; 0x04
    4d52:	41 e0       	ldi	r20, 0x01	; 1
    4d54:	97 01       	movw	r18, r14
    4d56:	86 01       	movw	r16, r12
    4d58:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    4d5c:	c7 01       	movw	r24, r14
    4d5e:	b6 01       	movw	r22, r12
    4d60:	41 e0       	ldi	r20, 0x01	; 1
    4d62:	0f ef       	ldi	r16, 0xFF	; 255
    4d64:	1f ef       	ldi	r17, 0xFF	; 255
    4d66:	98 01       	movw	r18, r16
    4d68:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4d6c:	c9 82       	std	Y+1, r12	; 0x01
    4d6e:	da 82       	std	Y+2, r13	; 0x02
    4d70:	eb 82       	std	Y+3, r14	; 0x03
    4d72:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    4d74:	cc 24       	eor	r12, r12
    4d76:	03 c0       	rjmp	.+6      	; 0x4d7e <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    4d78:	08 94       	sec
    4d7a:	21 1c       	adc	r2, r1
    4d7c:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    4d7e:	82 e0       	ldi	r24, 0x02	; 2
    4d80:	61 e0       	ldi	r22, 0x01	; 1
    4d82:	29 81       	ldd	r18, Y+1	; 0x01
    4d84:	3a 81       	ldd	r19, Y+2	; 0x02
    4d86:	4b 81       	ldd	r20, Y+3	; 0x03
    4d88:	5c 81       	ldd	r21, Y+4	; 0x04
    4d8a:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4d8e:	81 14       	cp	r8, r1
    4d90:	91 04       	cpc	r9, r1
    4d92:	a1 04       	cpc	r10, r1
    4d94:	b1 04       	cpc	r11, r1
    4d96:	09 f0       	breq	.+2      	; 0x4d9a <writeFile+0x2f8>
    4d98:	79 cf       	rjmp	.-270    	; 0x4c8c <writeFile+0x1ea>
    4d9a:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    4d9c:	11 23       	and	r17, r17
    4d9e:	09 f4       	brne	.+2      	; 0x4da2 <writeFile+0x300>
    4da0:	3f c0       	rjmp	.+126    	; 0x4e20 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    4da2:	60 91 a3 50 	lds	r22, 0x50A3
    4da6:	70 91 a4 50 	lds	r23, 0x50A4
    4daa:	80 91 a5 50 	lds	r24, 0x50A5
    4dae:	90 91 a6 50 	lds	r25, 0x50A6
    4db2:	09 e4       	ldi	r16, 0x49	; 73
    4db4:	1e e3       	ldi	r17, 0x3E	; 62
    4db6:	a8 01       	movw	r20, r16
    4db8:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4dbc:	e0 91 4a 40 	lds	r30, 0x404A
    4dc0:	f0 91 4b 40 	lds	r31, 0x404B
    4dc4:	e0 0f       	add	r30, r16
    4dc6:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4dc8:	12 8a       	std	Z+18, r1	; 0x12
    4dca:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4dcc:	80 91 52 40 	lds	r24, 0x4052
    4dd0:	90 91 53 40 	lds	r25, 0x4053
    4dd4:	a0 91 54 40 	lds	r26, 0x4054
    4dd8:	b0 91 55 40 	lds	r27, 0x4055
    4ddc:	44 8d       	ldd	r20, Z+28	; 0x1c
    4dde:	55 8d       	ldd	r21, Z+29	; 0x1d
    4de0:	66 8d       	ldd	r22, Z+30	; 0x1e
    4de2:	77 8d       	ldd	r23, Z+31	; 0x1f
    4de4:	6c 01       	movw	r12, r24
    4de6:	7d 01       	movw	r14, r26
    4de8:	c4 1a       	sub	r12, r20
    4dea:	d5 0a       	sbc	r13, r21
    4dec:	e6 0a       	sbc	r14, r22
    4dee:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4df0:	84 8f       	std	Z+28, r24	; 0x1c
    4df2:	95 8f       	std	Z+29, r25	; 0x1d
    4df4:	a6 8f       	std	Z+30, r26	; 0x1e
    4df6:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4df8:	60 91 a3 50 	lds	r22, 0x50A3
    4dfc:	70 91 a4 50 	lds	r23, 0x50A4
    4e00:	80 91 a5 50 	lds	r24, 0x50A5
    4e04:	90 91 a6 50 	lds	r25, 0x50A6
    4e08:	a8 01       	movw	r20, r16
    4e0a:	20 e0       	ldi	r18, 0x00	; 0
    4e0c:	32 e0       	ldi	r19, 0x02	; 2
    4e0e:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    4e12:	81 e0       	ldi	r24, 0x01	; 1
    4e14:	b7 01       	movw	r22, r14
    4e16:	a6 01       	movw	r20, r12
    4e18:	0e 94 c1 22 	call	0x4582	; 0x4582 <freeMemoryUpdate>

 //File appended!
  return 0;
    4e1c:	80 e0       	ldi	r24, 0x00	; 0
    4e1e:	f9 c0       	rjmp	.+498    	; 0x5012 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    4e20:	00 91 5e 40 	lds	r16, 0x405E
    4e24:	10 91 5f 40 	lds	r17, 0x405F
    4e28:	20 91 60 40 	lds	r18, 0x4060
    4e2c:	30 91 61 40 	lds	r19, 0x4061
    4e30:	0b 87       	std	Y+11, r16	; 0x0b
    4e32:	1c 87       	std	Y+12, r17	; 0x0c
    4e34:	2d 87       	std	Y+13, r18	; 0x0d
    4e36:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4e38:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4e3a:	82 e9       	ldi	r24, 0x92	; 146
    4e3c:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4e3e:	0f 2e       	mov	r0, r31
    4e40:	fb e0       	ldi	r31, 0x0B	; 11
    4e42:	af 2e       	mov	r10, r31
    4e44:	bb 24       	eor	r11, r11
    4e46:	f0 2d       	mov	r31, r0
    4e48:	a8 0e       	add	r10, r24
    4e4a:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4e4c:	88 24       	eor	r8, r8
    4e4e:	68 94       	set
    4e50:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4e52:	0f 2e       	mov	r0, r31
    4e54:	f9 e4       	ldi	r31, 0x49	; 73
    4e56:	4f 2e       	mov	r4, r31
    4e58:	fe e3       	ldi	r31, 0x3E	; 62
    4e5a:	5f 2e       	mov	r5, r31
    4e5c:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4e5e:	28 2e       	mov	r2, r24
    4e60:	99 2e       	mov	r9, r25
    4e62:	37 2c       	mov	r3, r7
    4e64:	6f 84       	ldd	r6, Y+15	; 0x0f
    4e66:	78 88       	ldd	r7, Y+16	; 0x10
    4e68:	04 c0       	rjmp	.+8      	; 0x4e72 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    4e6a:	cb 86       	std	Y+11, r12	; 0x0b
    4e6c:	dc 86       	std	Y+12, r13	; 0x0c
    4e6e:	ed 86       	std	Y+13, r14	; 0x0d
    4e70:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    4e72:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e74:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e76:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e78:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e7a:	0e 94 09 1f 	call	0x3e12	; 0x3e12 <getFirstSector>
    4e7e:	6d 83       	std	Y+5, r22	; 0x05
    4e80:	7e 83       	std	Y+6, r23	; 0x06
    4e82:	8f 83       	std	Y+7, r24	; 0x07
    4e84:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4e86:	80 91 6a 50 	lds	r24, 0x506A
    4e8a:	90 91 6b 50 	lds	r25, 0x506B
    4e8e:	00 97       	sbiw	r24, 0x00	; 0
    4e90:	09 f4       	brne	.+2      	; 0x4e94 <writeFile+0x3f2>
    4e92:	77 c0       	rjmp	.+238    	; 0x4f82 <writeFile+0x4e0>
    4e94:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4e96:	cd 80       	ldd	r12, Y+5	; 0x05
    4e98:	de 80       	ldd	r13, Y+6	; 0x06
    4e9a:	ef 80       	ldd	r14, Y+7	; 0x07
    4e9c:	f8 84       	ldd	r15, Y+8	; 0x08
    4e9e:	19 81       	ldd	r17, Y+1	; 0x01
    4ea0:	c1 0e       	add	r12, r17
    4ea2:	d1 1c       	adc	r13, r1
    4ea4:	e1 1c       	adc	r14, r1
    4ea6:	f1 1c       	adc	r15, r1
    4ea8:	c7 01       	movw	r24, r14
    4eaa:	b6 01       	movw	r22, r12
    4eac:	a2 01       	movw	r20, r4
    4eae:	0e 94 0f 2a 	call	0x541e	; 0x541e <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    4eb2:	80 91 56 40 	lds	r24, 0x4056
    4eb6:	90 91 57 40 	lds	r25, 0x4057
    4eba:	00 97       	sbiw	r24, 0x00	; 0
    4ebc:	09 f4       	brne	.+2      	; 0x4ec0 <writeFile+0x41e>
    4ebe:	54 c0       	rjmp	.+168    	; 0x4f68 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4ec0:	33 20       	and	r3, r3
    4ec2:	09 f0       	breq	.+2      	; 0x4ec6 <writeFile+0x424>
    4ec4:	a1 c0       	rjmp	.+322    	; 0x5008 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4ec6:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4ec8:	00 e0       	ldi	r16, 0x00	; 0
    4eca:	10 e0       	ldi	r17, 0x00	; 0
    4ecc:	06 c0       	rjmp	.+12     	; 0x4eda <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4ece:	a8 01       	movw	r20, r16
    4ed0:	47 5b       	subi	r20, 0xB7	; 183
    4ed2:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4ed4:	22 23       	and	r18, r18
    4ed6:	09 f0       	breq	.+2      	; 0x4eda <writeFile+0x438>
    4ed8:	99 c0       	rjmp	.+306    	; 0x500c <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4eda:	da 01       	movw	r26, r20
    4edc:	8c 91       	ld	r24, X
    4ede:	88 23       	and	r24, r24
    4ee0:	21 f4       	brne	.+8      	; 0x4eea <writeFile+0x448>
    4ee2:	e2 2d       	mov	r30, r2
    4ee4:	f9 2d       	mov	r31, r9
    4ee6:	da 01       	movw	r26, r20
    4ee8:	04 c0       	rjmp	.+8      	; 0x4ef2 <writeFile+0x450>
    4eea:	85 3e       	cpi	r24, 0xE5	; 229
    4eec:	d1 f3       	breq	.-12     	; 0x4ee2 <writeFile+0x440>
    4eee:	23 2d       	mov	r18, r3
    4ef0:	30 c0       	rjmp	.+96     	; 0x4f52 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    4ef2:	81 91       	ld	r24, Z+
    4ef4:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    4ef6:	ea 15       	cp	r30, r10
    4ef8:	fb 05       	cpc	r31, r11
    4efa:	d9 f7       	brne	.-10     	; 0x4ef2 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4efc:	fa 01       	movw	r30, r20
    4efe:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    4f00:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    4f02:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    4f04:	12 8a       	std	Z+18, r1	; 0x12
    4f06:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    4f08:	29 85       	ldd	r18, Y+9	; 0x09
    4f0a:	3a 85       	ldd	r19, Y+10	; 0x0a
    4f0c:	24 8b       	std	Z+20, r18	; 0x14
    4f0e:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    4f10:	62 8e       	std	Z+26, r6	; 0x1a
    4f12:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    4f14:	80 91 52 40 	lds	r24, 0x4052
    4f18:	90 91 53 40 	lds	r25, 0x4053
    4f1c:	a0 91 54 40 	lds	r26, 0x4054
    4f20:	b0 91 55 40 	lds	r27, 0x4055
    4f24:	84 8f       	std	Z+28, r24	; 0x1c
    4f26:	95 8f       	std	Z+29, r25	; 0x1d
    4f28:	a6 8f       	std	Z+30, r26	; 0x1e
    4f2a:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    4f2c:	c7 01       	movw	r24, r14
    4f2e:	b6 01       	movw	r22, r12
    4f30:	a2 01       	movw	r20, r4
    4f32:	20 e0       	ldi	r18, 0x00	; 0
    4f34:	32 e0       	ldi	r19, 0x02	; 2
    4f36:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    4f3a:	40 91 52 40 	lds	r20, 0x4052
    4f3e:	50 91 53 40 	lds	r21, 0x4053
    4f42:	60 91 54 40 	lds	r22, 0x4054
    4f46:	70 91 55 40 	lds	r23, 0x4055
    4f4a:	81 e0       	ldi	r24, 0x01	; 1
    4f4c:	0e 94 c1 22 	call	0x4582	; 0x4582 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    4f50:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4f52:	00 5e       	subi	r16, 0xE0	; 224
    4f54:	1f 4f       	sbci	r17, 0xFF	; 255
    4f56:	80 91 56 40 	lds	r24, 0x4056
    4f5a:	90 91 57 40 	lds	r25, 0x4057
    4f5e:	08 17       	cp	r16, r24
    4f60:	19 07       	cpc	r17, r25
    4f62:	08 f4       	brcc	.+2      	; 0x4f66 <writeFile+0x4c4>
    4f64:	b4 cf       	rjmp	.-152    	; 0x4ece <writeFile+0x42c>
    4f66:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4f68:	09 81       	ldd	r16, Y+1	; 0x01
    4f6a:	0f 5f       	subi	r16, 0xFF	; 255
    4f6c:	09 83       	std	Y+1, r16	; 0x01
    4f6e:	20 91 6a 50 	lds	r18, 0x506A
    4f72:	30 91 6b 50 	lds	r19, 0x506B
    4f76:	80 2f       	mov	r24, r16
    4f78:	90 e0       	ldi	r25, 0x00	; 0
    4f7a:	82 17       	cp	r24, r18
    4f7c:	93 07       	cpc	r25, r19
    4f7e:	08 f4       	brcc	.+2      	; 0x4f82 <writeFile+0x4e0>
    4f80:	8a cf       	rjmp	.-236    	; 0x4e96 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    4f82:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f84:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f86:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f88:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f8a:	40 e0       	ldi	r20, 0x00	; 0
    4f8c:	00 e0       	ldi	r16, 0x00	; 0
    4f8e:	10 e0       	ldi	r17, 0x00	; 0
    4f90:	98 01       	movw	r18, r16
    4f92:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
    4f96:	6b 01       	movw	r12, r22
    4f98:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    4f9a:	67 3f       	cpi	r22, 0xF7	; 247
    4f9c:	1f ef       	ldi	r17, 0xFF	; 255
    4f9e:	71 07       	cpc	r23, r17
    4fa0:	1f ef       	ldi	r17, 0xFF	; 255
    4fa2:	81 07       	cpc	r24, r17
    4fa4:	1f e0       	ldi	r17, 0x0F	; 15
    4fa6:	91 07       	cpc	r25, r17
    4fa8:	08 f1       	brcs	.+66     	; 0x4fec <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    4faa:	6f 3f       	cpi	r22, 0xFF	; 255
    4fac:	2f ef       	ldi	r18, 0xFF	; 255
    4fae:	72 07       	cpc	r23, r18
    4fb0:	2f ef       	ldi	r18, 0xFF	; 255
    4fb2:	82 07       	cpc	r24, r18
    4fb4:	2f ef       	ldi	r18, 0xFF	; 255
    4fb6:	92 07       	cpc	r25, r18
    4fb8:	59 f5       	brne	.+86     	; 0x5010 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    4fba:	6b 85       	ldd	r22, Y+11	; 0x0b
    4fbc:	7c 85       	ldd	r23, Y+12	; 0x0c
    4fbe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fc0:	9e 85       	ldd	r25, Y+14	; 0x0e
    4fc2:	0e 94 0e 22 	call	0x441c	; 0x441c <searchNextFreeCluster>
    4fc6:	6b 01       	movw	r12, r22
    4fc8:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    4fca:	6b 85       	ldd	r22, Y+11	; 0x0b
    4fcc:	7c 85       	ldd	r23, Y+12	; 0x0c
    4fce:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fd0:	9e 85       	ldd	r25, Y+14	; 0x0e
    4fd2:	41 e0       	ldi	r20, 0x01	; 1
    4fd4:	97 01       	movw	r18, r14
    4fd6:	86 01       	movw	r16, r12
    4fd8:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    4fdc:	c7 01       	movw	r24, r14
    4fde:	b6 01       	movw	r22, r12
    4fe0:	41 e0       	ldi	r20, 0x01	; 1
    4fe2:	0f ef       	ldi	r16, 0xFF	; 255
    4fe4:	1f ef       	ldi	r17, 0xFF	; 255
    4fe6:	98 01       	movw	r18, r16
    4fe8:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    4fec:	c1 14       	cp	r12, r1
    4fee:	d1 04       	cpc	r13, r1
    4ff0:	e1 04       	cpc	r14, r1
    4ff2:	f1 04       	cpc	r15, r1
    4ff4:	09 f0       	breq	.+2      	; 0x4ff8 <writeFile+0x556>
    4ff6:	39 cf       	rjmp	.-398    	; 0x4e6a <writeFile+0x3c8>
	   return 4;
    4ff8:	84 e0       	ldi	r24, 0x04	; 4
    4ffa:	0b c0       	rjmp	.+22     	; 0x5012 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    4ffc:	81 e0       	ldi	r24, 0x01	; 1
    4ffe:	09 c0       	rjmp	.+18     	; 0x5012 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    5000:	82 e0       	ldi	r24, 0x02	; 2
    5002:	07 c0       	rjmp	.+14     	; 0x5012 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    5004:	82 e0       	ldi	r24, 0x02	; 2
    5006:	05 c0       	rjmp	.+10     	; 0x5012 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    5008:	80 e0       	ldi	r24, 0x00	; 0
    500a:	03 c0       	rjmp	.+6      	; 0x5012 <writeFile+0x570>
    500c:	80 e0       	ldi	r24, 0x00	; 0
    500e:	01 c0       	rjmp	.+2      	; 0x5012 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    5010:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    5012:	60 96       	adiw	r28, 0x10	; 16
    5014:	cd bf       	out	0x3d, r28	; 61
    5016:	de bf       	out	0x3e, r29	; 62
    5018:	df 91       	pop	r29
    501a:	cf 91       	pop	r28
    501c:	1f 91       	pop	r17
    501e:	0f 91       	pop	r16
    5020:	ff 90       	pop	r15
    5022:	ef 90       	pop	r14
    5024:	df 90       	pop	r13
    5026:	cf 90       	pop	r12
    5028:	bf 90       	pop	r11
    502a:	af 90       	pop	r10
    502c:	9f 90       	pop	r9
    502e:	8f 90       	pop	r8
    5030:	7f 90       	pop	r7
    5032:	6f 90       	pop	r6
    5034:	5f 90       	pop	r5
    5036:	4f 90       	pop	r4
    5038:	3f 90       	pop	r3
    503a:	2f 90       	pop	r2
    503c:	08 95       	ret

0000503e <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    503e:	8f 92       	push	r8
    5040:	9f 92       	push	r9
    5042:	af 92       	push	r10
    5044:	bf 92       	push	r11
    5046:	cf 92       	push	r12
    5048:	df 92       	push	r13
    504a:	ef 92       	push	r14
    504c:	ff 92       	push	r15
    504e:	0f 93       	push	r16
    5050:	1f 93       	push	r17
    5052:	cf 93       	push	r28
    5054:	df 93       	push	r29
    5056:	84 2e       	mov	r8, r20
    5058:	a5 2e       	mov	r10, r21
    505a:	c6 2e       	mov	r12, r22
    505c:	c7 2f       	mov	r28, r23
    505e:	d2 2f       	mov	r29, r18
    5060:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    5062:	80 64       	ori	r24, 0x40	; 64
    5064:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5068:	8c 2f       	mov	r24, r28
    506a:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    506e:	8c 2d       	mov	r24, r12
    5070:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    5074:	8a 2d       	mov	r24, r10
    5076:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    507a:	88 2d       	mov	r24, r8
    507c:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
	SPI_write(crc);
    5080:	8d 2f       	mov	r24, r29
    5082:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
	
	for(int i=0; i<read; i++){
    5086:	10 16       	cp	r1, r16
    5088:	11 06       	cpc	r1, r17
    508a:	64 f5       	brge	.+88     	; 0x50e4 <SD_command+0xa6>
    508c:	00 e0       	ldi	r16, 0x00	; 0
    508e:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    5090:	0f 2e       	mov	r0, r31
    5092:	fd e0       	ldi	r31, 0x0D	; 13
    5094:	cf 2e       	mov	r12, r31
    5096:	dd 24       	eor	r13, r13
    5098:	f0 2d       	mov	r31, r0
    509a:	0f 2e       	mov	r0, r31
    509c:	f5 e3       	ldi	r31, 0x35	; 53
    509e:	af 2e       	mov	r10, r31
    50a0:	fe e3       	ldi	r31, 0x3E	; 62
    50a2:	bf 2e       	mov	r11, r31
    50a4:	f0 2d       	mov	r31, r0
    50a6:	c8 01       	movw	r24, r16
    50a8:	b6 01       	movw	r22, r12
    50aa:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    50ae:	ec 01       	movw	r28, r24
    50b0:	8f ef       	ldi	r24, 0xFF	; 255
    50b2:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    50b6:	f5 01       	movw	r30, r10
    50b8:	ec 0f       	add	r30, r28
    50ba:	fd 1f       	adc	r31, r29
    50bc:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    50be:	80 81       	ld	r24, Z
    50c0:	8f 3f       	cpi	r24, 0xFF	; 255
    50c2:	49 f0       	breq	.+18     	; 0x50d6 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    50c4:	fe 01       	movw	r30, r28
    50c6:	eb 5c       	subi	r30, 0xCB	; 203
    50c8:	f1 4c       	sbci	r31, 0xC1	; 193
    50ca:	80 81       	ld	r24, Z
    50cc:	80 93 36 3e 	sts	0x3E36, r24
			return Buffer[1];
    50d0:	80 91 36 3e 	lds	r24, 0x3E36
    50d4:	08 c0       	rjmp	.+16     	; 0x50e6 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    50d6:	0f 5f       	subi	r16, 0xFF	; 255
    50d8:	1f 4f       	sbci	r17, 0xFF	; 255
    50da:	0e 15       	cp	r16, r14
    50dc:	1f 05       	cpc	r17, r15
    50de:	19 f7       	brne	.-58     	; 0x50a6 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    50e0:	8f ef       	ldi	r24, 0xFF	; 255
    50e2:	01 c0       	rjmp	.+2      	; 0x50e6 <SD_command+0xa8>
    50e4:	8f ef       	ldi	r24, 0xFF	; 255
}
    50e6:	df 91       	pop	r29
    50e8:	cf 91       	pop	r28
    50ea:	1f 91       	pop	r17
    50ec:	0f 91       	pop	r16
    50ee:	ff 90       	pop	r15
    50f0:	ef 90       	pop	r14
    50f2:	df 90       	pop	r13
    50f4:	cf 90       	pop	r12
    50f6:	bf 90       	pop	r11
    50f8:	af 90       	pop	r10
    50fa:	9f 90       	pop	r9
    50fc:	8f 90       	pop	r8
    50fe:	08 95       	ret

00005100 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    5100:	ff 92       	push	r15
    5102:	0f 93       	push	r16
    5104:	1f 93       	push	r17
    5106:	cf 93       	push	r28
    5108:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    510a:	81 e0       	ldi	r24, 0x01	; 1
    510c:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    5110:	81 e0       	ldi	r24, 0x01	; 1
    5112:	0e 94 4a 04 	call	0x894	; 0x894 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5116:	8f ef       	ldi	r24, 0xFF	; 255
    5118:	93 ec       	ldi	r25, 0xC3	; 195
    511a:	a9 e0       	ldi	r26, 0x09	; 9
    511c:	81 50       	subi	r24, 0x01	; 1
    511e:	90 40       	sbci	r25, 0x00	; 0
    5120:	a0 40       	sbci	r26, 0x00	; 0
    5122:	e1 f7       	brne	.-8      	; 0x511c <SD_init+0x1c>
    5124:	00 c0       	rjmp	.+0      	; 0x5126 <SD_init+0x26>
    5126:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    5128:	88 e0       	ldi	r24, 0x08	; 8
    512a:	60 e0       	ldi	r22, 0x00	; 0
    512c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    5130:	88 e0       	ldi	r24, 0x08	; 8
    5132:	60 e0       	ldi	r22, 0x00	; 0
    5134:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5138:	80 e0       	ldi	r24, 0x00	; 0
    513a:	63 e0       	ldi	r22, 0x03	; 3
    513c:	0e 94 be 04 	call	0x97c	; 0x97c <SPIInit2>
	SPICS(TRUE);
    5140:	81 e0       	ldi	r24, 0x01	; 1
    5142:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
    5146:	8a e0       	ldi	r24, 0x0A	; 10
    5148:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    514a:	e0 ec       	ldi	r30, 0xC0	; 192
    514c:	f8 e0       	ldi	r31, 0x08	; 8
    514e:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    5150:	a1 e4       	ldi	r26, 0x41	; 65
    5152:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5154:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    5156:	22 81       	ldd	r18, Z+2	; 0x02
    5158:	22 23       	and	r18, r18
    515a:	ec f7       	brge	.-6      	; 0x5156 <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    515c:	23 81       	ldd	r18, Z+3	; 0x03
    515e:	2c 93       	st	X, r18
    5160:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    5162:	c1 f7       	brne	.-16     	; 0x5154 <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    5164:	80 e0       	ldi	r24, 0x00	; 0
    5166:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    516a:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    516e:	88 e0       	ldi	r24, 0x08	; 8
    5170:	60 e0       	ldi	r22, 0x00	; 0
    5172:	0e 94 49 05 	call	0xa92	; 0xa92 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5176:	80 e0       	ldi	r24, 0x00	; 0
    5178:	63 e0       	ldi	r22, 0x03	; 3
    517a:	0e 94 be 04 	call	0x97c	; 0x97c <SPIInit2>
	SPICS(TRUE);
    517e:	81 e0       	ldi	r24, 0x01	; 1
    5180:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    5184:	cb e0       	ldi	r28, 0x0B	; 11
    5186:	d0 e0       	ldi	r29, 0x00	; 0
    5188:	02 c0       	rjmp	.+4      	; 0x518e <SD_init+0x8e>
    518a:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    518c:	69 f0       	breq	.+26     	; 0x51a8 <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    518e:	80 e0       	ldi	r24, 0x00	; 0
    5190:	40 e0       	ldi	r20, 0x00	; 0
    5192:	50 e0       	ldi	r21, 0x00	; 0
    5194:	ba 01       	movw	r22, r20
    5196:	25 e9       	ldi	r18, 0x95	; 149
    5198:	08 e0       	ldi	r16, 0x08	; 8
    519a:	10 e0       	ldi	r17, 0x00	; 0
    519c:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
    51a0:	81 30       	cpi	r24, 0x01	; 1
    51a2:	99 f7       	brne	.-26     	; 0x518a <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    51a4:	ff 24       	eor	r15, r15
    51a6:	02 c0       	rjmp	.+4      	; 0x51ac <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    51a8:	ff 24       	eor	r15, r15
    51aa:	f3 94       	inc	r15
    51ac:	8f ef       	ldi	r24, 0xFF	; 255
    51ae:	93 ec       	ldi	r25, 0xC3	; 195
    51b0:	a9 e0       	ldi	r26, 0x09	; 9
    51b2:	81 50       	subi	r24, 0x01	; 1
    51b4:	90 40       	sbci	r25, 0x00	; 0
    51b6:	a0 40       	sbci	r26, 0x00	; 0
    51b8:	e1 f7       	brne	.-8      	; 0x51b2 <SD_init+0xb2>
    51ba:	00 c0       	rjmp	.+0      	; 0x51bc <SD_init+0xbc>
    51bc:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    51be:	cb e0       	ldi	r28, 0x0B	; 11
    51c0:	d0 e0       	ldi	r29, 0x00	; 0
    51c2:	02 c0       	rjmp	.+4      	; 0x51c8 <SD_init+0xc8>
    51c4:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    51c6:	69 f0       	breq	.+26     	; 0x51e2 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    51c8:	88 e0       	ldi	r24, 0x08	; 8
    51ca:	4a ea       	ldi	r20, 0xAA	; 170
    51cc:	51 e0       	ldi	r21, 0x01	; 1
    51ce:	60 e0       	ldi	r22, 0x00	; 0
    51d0:	70 e0       	ldi	r23, 0x00	; 0
    51d2:	27 e8       	ldi	r18, 0x87	; 135
    51d4:	08 e0       	ldi	r16, 0x08	; 8
    51d6:	10 e0       	ldi	r17, 0x00	; 0
    51d8:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
    51dc:	81 30       	cpi	r24, 0x01	; 1
    51de:	91 f7       	brne	.-28     	; 0x51c4 <SD_init+0xc4>
    51e0:	02 c0       	rjmp	.+4      	; 0x51e6 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    51e2:	ff 24       	eor	r15, r15
    51e4:	f3 94       	inc	r15
    51e6:	c2 e0       	ldi	r28, 0x02	; 2
    51e8:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    51ea:	05 e3       	ldi	r16, 0x35	; 53
    51ec:	1e e3       	ldi	r17, 0x3E	; 62
    51ee:	8f ef       	ldi	r24, 0xFF	; 255
    51f0:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    51f4:	f8 01       	movw	r30, r16
    51f6:	ec 0f       	add	r30, r28
    51f8:	fd 1f       	adc	r31, r29
    51fa:	80 83       	st	Z, r24
    51fc:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    51fe:	c6 30       	cpi	r28, 0x06	; 6
    5200:	d1 05       	cpc	r29, r1
    5202:	a9 f7       	brne	.-22     	; 0x51ee <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    5204:	80 91 39 3e 	lds	r24, 0x3E39
    5208:	81 30       	cpi	r24, 0x01	; 1
    520a:	29 f4       	brne	.+10     	; 0x5216 <SD_init+0x116>
    520c:	80 91 3a 3e 	lds	r24, 0x3E3A
    5210:	8a 3a       	cpi	r24, 0xAA	; 170
    5212:	21 f4       	brne	.+8      	; 0x521c <SD_init+0x11c>
    5214:	05 c0       	rjmp	.+10     	; 0x5220 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    5216:	ff 24       	eor	r15, r15
    5218:	f3 94       	inc	r15
    521a:	02 c0       	rjmp	.+4      	; 0x5220 <SD_init+0x120>
    521c:	ff 24       	eor	r15, r15
    521e:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    5220:	c6 e3       	ldi	r28, 0x36	; 54
    5222:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    5224:	87 e3       	ldi	r24, 0x37	; 55
    5226:	40 e0       	ldi	r20, 0x00	; 0
    5228:	50 e0       	ldi	r21, 0x00	; 0
    522a:	ba 01       	movw	r22, r20
    522c:	2f ef       	ldi	r18, 0xFF	; 255
    522e:	08 e0       	ldi	r16, 0x08	; 8
    5230:	10 e0       	ldi	r17, 0x00	; 0
    5232:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    5236:	81 e0       	ldi	r24, 0x01	; 1
    5238:	40 e0       	ldi	r20, 0x00	; 0
    523a:	50 e0       	ldi	r21, 0x00	; 0
    523c:	60 e0       	ldi	r22, 0x00	; 0
    523e:	70 e4       	ldi	r23, 0x40	; 64
    5240:	2f ef       	ldi	r18, 0xFF	; 255
    5242:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
	} while(Buffer[1]!= 0x00);	
    5246:	88 81       	ld	r24, Y
    5248:	88 23       	and	r24, r24
    524a:	61 f7       	brne	.-40     	; 0x5224 <SD_init+0x124>
    524c:	cb e0       	ldi	r28, 0x0B	; 11
    524e:	d0 e0       	ldi	r29, 0x00	; 0
    5250:	02 c0       	rjmp	.+4      	; 0x5256 <SD_init+0x156>
    5252:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    5254:	61 f0       	breq	.+24     	; 0x526e <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    5256:	8a e3       	ldi	r24, 0x3A	; 58
    5258:	40 e0       	ldi	r20, 0x00	; 0
    525a:	50 e0       	ldi	r21, 0x00	; 0
    525c:	ba 01       	movw	r22, r20
    525e:	2f ef       	ldi	r18, 0xFF	; 255
    5260:	08 e0       	ldi	r16, 0x08	; 8
    5262:	10 e0       	ldi	r17, 0x00	; 0
    5264:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
    5268:	88 23       	and	r24, r24
    526a:	99 f7       	brne	.-26     	; 0x5252 <SD_init+0x152>
    526c:	02 c0       	rjmp	.+4      	; 0x5272 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    526e:	ff 24       	eor	r15, r15
    5270:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5272:	c0 e0       	ldi	r28, 0x00	; 0
    5274:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5276:	05 e3       	ldi	r16, 0x35	; 53
    5278:	1e e3       	ldi	r17, 0x3E	; 62
    527a:	8f ef       	ldi	r24, 0xFF	; 255
    527c:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5280:	f8 01       	movw	r30, r16
    5282:	ec 0f       	add	r30, r28
    5284:	fd 1f       	adc	r31, r29
    5286:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5288:	21 96       	adiw	r28, 0x01	; 1
    528a:	c4 30       	cpi	r28, 0x04	; 4
    528c:	d1 05       	cpc	r29, r1
    528e:	a9 f7       	brne	.-22     	; 0x527a <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5290:	80 91 35 3e 	lds	r24, 0x3E35
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    5294:	80 e0       	ldi	r24, 0x00	; 0
    5296:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    529a:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    529e:	88 e0       	ldi	r24, 0x08	; 8
    52a0:	60 e0       	ldi	r22, 0x00	; 0
    52a2:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
	
	return errorCode;					
}
    52a6:	8f 2d       	mov	r24, r15
    52a8:	df 91       	pop	r29
    52aa:	cf 91       	pop	r28
    52ac:	1f 91       	pop	r17
    52ae:	0f 91       	pop	r16
    52b0:	ff 90       	pop	r15
    52b2:	08 95       	ret

000052b4 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    52b4:	6f 92       	push	r6
    52b6:	7f 92       	push	r7
    52b8:	8f 92       	push	r8
    52ba:	9f 92       	push	r9
    52bc:	af 92       	push	r10
    52be:	bf 92       	push	r11
    52c0:	cf 92       	push	r12
    52c2:	df 92       	push	r13
    52c4:	ef 92       	push	r14
    52c6:	ff 92       	push	r15
    52c8:	0f 93       	push	r16
    52ca:	1f 93       	push	r17
    52cc:	cf 93       	push	r28
    52ce:	df 93       	push	r29
    52d0:	4b 01       	movw	r8, r22
    52d2:	5c 01       	movw	r10, r24
    52d4:	74 2e       	mov	r7, r20
    52d6:	65 2e       	mov	r6, r21
    52d8:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    52da:	88 e0       	ldi	r24, 0x08	; 8
    52dc:	60 e0       	ldi	r22, 0x00	; 0
    52de:	0e 94 49 05 	call	0xa92	; 0xa92 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    52e2:	80 e0       	ldi	r24, 0x00	; 0
    52e4:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
    52e8:	81 e0       	ldi	r24, 0x01	; 1
    52ea:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    52ee:	80 e0       	ldi	r24, 0x00	; 0
    52f0:	92 e0       	ldi	r25, 0x02	; 2
    52f2:	7c 01       	movw	r14, r24
    52f4:	ec 18       	sub	r14, r12
    52f6:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    52f8:	80 e0       	ldi	r24, 0x00	; 0
    52fa:	e8 16       	cp	r14, r24
    52fc:	82 e0       	ldi	r24, 0x02	; 2
    52fe:	f8 06       	cpc	r15, r24
    5300:	11 f4       	brne	.+4      	; 0x5306 <SD_write_block+0x52>
    5302:	ee 24       	eor	r14, r14
    5304:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5306:	cb e0       	ldi	r28, 0x0B	; 11
    5308:	d0 e0       	ldi	r29, 0x00	; 0
    530a:	03 c0       	rjmp	.+6      	; 0x5312 <SD_write_block+0x5e>
    530c:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    530e:	09 f4       	brne	.+2      	; 0x5312 <SD_write_block+0x5e>
    5310:	ff cf       	rjmp	.-2      	; 0x5310 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5312:	88 e1       	ldi	r24, 0x18	; 24
    5314:	b5 01       	movw	r22, r10
    5316:	a4 01       	movw	r20, r8
    5318:	2f ef       	ldi	r18, 0xFF	; 255
    531a:	08 e0       	ldi	r16, 0x08	; 8
    531c:	10 e0       	ldi	r17, 0x00	; 0
    531e:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
    5322:	88 23       	and	r24, r24
    5324:	99 f7       	brne	.-26     	; 0x530c <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    5326:	8f ef       	ldi	r24, 0xFF	; 255
    5328:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    532c:	80 93 35 3e 	sts	0x3E35, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    5330:	8e ef       	ldi	r24, 0xFE	; 254
    5332:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5336:	1c 14       	cp	r1, r12
    5338:	1d 04       	cpc	r1, r13
    533a:	bc f4       	brge	.+46     	; 0x536a <SD_write_block+0xb6>
    533c:	87 2c       	mov	r8, r7
    533e:	96 2c       	mov	r9, r6
    5340:	00 e0       	ldi	r16, 0x00	; 0
    5342:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    5344:	c8 01       	movw	r24, r16
    5346:	6d e0       	ldi	r22, 0x0D	; 13
    5348:	70 e0       	ldi	r23, 0x00	; 0
    534a:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    534e:	ec 01       	movw	r28, r24
    5350:	f4 01       	movw	r30, r8
    5352:	81 91       	ld	r24, Z+
    5354:	4f 01       	movw	r8, r30
    5356:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    535a:	cb 5c       	subi	r28, 0xCB	; 203
    535c:	d1 4c       	sbci	r29, 0xC1	; 193
    535e:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5360:	0f 5f       	subi	r16, 0xFF	; 255
    5362:	1f 4f       	sbci	r17, 0xFF	; 255
    5364:	0c 15       	cp	r16, r12
    5366:	1d 05       	cpc	r17, r13
    5368:	69 f7       	brne	.-38     	; 0x5344 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    536a:	1e 14       	cp	r1, r14
    536c:	1f 04       	cpc	r1, r15
    536e:	ec f4       	brge	.+58     	; 0x53aa <SD_write_block+0xf6>
    5370:	00 e0       	ldi	r16, 0x00	; 0
    5372:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    5374:	0f 2e       	mov	r0, r31
    5376:	fd e0       	ldi	r31, 0x0D	; 13
    5378:	cf 2e       	mov	r12, r31
    537a:	dd 24       	eor	r13, r13
    537c:	f0 2d       	mov	r31, r0
    537e:	0f 2e       	mov	r0, r31
    5380:	f5 e3       	ldi	r31, 0x35	; 53
    5382:	8f 2e       	mov	r8, r31
    5384:	fe e3       	ldi	r31, 0x3E	; 62
    5386:	9f 2e       	mov	r9, r31
    5388:	f0 2d       	mov	r31, r0
    538a:	c8 01       	movw	r24, r16
    538c:	b6 01       	movw	r22, r12
    538e:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    5392:	ec 01       	movw	r28, r24
    5394:	80 e0       	ldi	r24, 0x00	; 0
    5396:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    539a:	c8 0d       	add	r28, r8
    539c:	d9 1d       	adc	r29, r9
    539e:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    53a0:	0f 5f       	subi	r16, 0xFF	; 255
    53a2:	1f 4f       	sbci	r17, 0xFF	; 255
    53a4:	0e 15       	cp	r16, r14
    53a6:	1f 05       	cpc	r17, r15
    53a8:	81 f7       	brne	.-32     	; 0x538a <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    53aa:	8f ef       	ldi	r24, 0xFF	; 255
    53ac:	80 93 35 3e 	sts	0x3E35, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    53b0:	c0 e0       	ldi	r28, 0x00	; 0
    53b2:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    53b4:	05 e3       	ldi	r16, 0x35	; 53
    53b6:	1e e3       	ldi	r17, 0x3E	; 62
    53b8:	8f ef       	ldi	r24, 0xFF	; 255
    53ba:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    53be:	f8 01       	movw	r30, r16
    53c0:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    53c2:	21 96       	adiw	r28, 0x01	; 1
    53c4:	c2 30       	cpi	r28, 0x02	; 2
    53c6:	d1 05       	cpc	r29, r1
    53c8:	bc f3       	brlt	.-18     	; 0x53b8 <SD_write_block+0x104>
    53ca:	80 81       	ld	r24, Z
    53cc:	8f 3f       	cpi	r24, 0xFF	; 255
    53ce:	a1 f3       	breq	.-24     	; 0x53b8 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    53d0:	80 91 35 3e 	lds	r24, 0x3E35
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    53d4:	80 91 35 3e 	lds	r24, 0x3E35
    53d8:	8f 3f       	cpi	r24, 0xFF	; 255
    53da:	49 f0       	breq	.+18     	; 0x53ee <SD_write_block+0x13a>
    53dc:	c5 e3       	ldi	r28, 0x35	; 53
    53de:	de e3       	ldi	r29, 0x3E	; 62
    53e0:	8f ef       	ldi	r24, 0xFF	; 255
    53e2:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    53e6:	88 83       	st	Y, r24
    53e8:	88 81       	ld	r24, Y
    53ea:	8f 3f       	cpi	r24, 0xFF	; 255
    53ec:	c9 f7       	brne	.-14     	; 0x53e0 <SD_write_block+0x12c>
	SPICS(FALSE);
    53ee:	80 e0       	ldi	r24, 0x00	; 0
    53f0:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    53f4:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    53f8:	88 e0       	ldi	r24, 0x08	; 8
    53fa:	60 e0       	ldi	r22, 0x00	; 0
    53fc:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
}
    5400:	df 91       	pop	r29
    5402:	cf 91       	pop	r28
    5404:	1f 91       	pop	r17
    5406:	0f 91       	pop	r16
    5408:	ff 90       	pop	r15
    540a:	ef 90       	pop	r14
    540c:	df 90       	pop	r13
    540e:	cf 90       	pop	r12
    5410:	bf 90       	pop	r11
    5412:	af 90       	pop	r10
    5414:	9f 90       	pop	r9
    5416:	8f 90       	pop	r8
    5418:	7f 90       	pop	r7
    541a:	6f 90       	pop	r6
    541c:	08 95       	ret

0000541e <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    541e:	af 92       	push	r10
    5420:	bf 92       	push	r11
    5422:	cf 92       	push	r12
    5424:	df 92       	push	r13
    5426:	ef 92       	push	r14
    5428:	ff 92       	push	r15
    542a:	0f 93       	push	r16
    542c:	1f 93       	push	r17
    542e:	cf 93       	push	r28
    5430:	df 93       	push	r29
    5432:	6b 01       	movw	r12, r22
    5434:	7c 01       	movw	r14, r24
    5436:	b4 2e       	mov	r11, r20
    5438:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    543a:	88 e0       	ldi	r24, 0x08	; 8
    543c:	60 e0       	ldi	r22, 0x00	; 0
    543e:	0e 94 49 05 	call	0xa92	; 0xa92 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5442:	80 e0       	ldi	r24, 0x00	; 0
    5444:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
    5448:	81 e0       	ldi	r24, 0x01	; 1
    544a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    544e:	cb e0       	ldi	r28, 0x0B	; 11
    5450:	d0 e0       	ldi	r29, 0x00	; 0
    5452:	03 c0       	rjmp	.+6      	; 0x545a <SD_read_block+0x3c>
    5454:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5456:	09 f4       	brne	.+2      	; 0x545a <SD_read_block+0x3c>
    5458:	ff cf       	rjmp	.-2      	; 0x5458 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    545a:	81 e1       	ldi	r24, 0x11	; 17
    545c:	b7 01       	movw	r22, r14
    545e:	a6 01       	movw	r20, r12
    5460:	2f ef       	ldi	r18, 0xFF	; 255
    5462:	08 e0       	ldi	r16, 0x08	; 8
    5464:	10 e0       	ldi	r17, 0x00	; 0
    5466:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
    546a:	88 23       	and	r24, r24
    546c:	99 f7       	brne	.-26     	; 0x5454 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    546e:	80 91 35 3e 	lds	r24, 0x3E35
    5472:	8e 3f       	cpi	r24, 0xFE	; 254
    5474:	49 f0       	breq	.+18     	; 0x5488 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5476:	c5 e3       	ldi	r28, 0x35	; 53
    5478:	de e3       	ldi	r29, 0x3E	; 62
    547a:	8f ef       	ldi	r24, 0xFF	; 255
    547c:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5480:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5482:	88 81       	ld	r24, Y
    5484:	8e 3f       	cpi	r24, 0xFE	; 254
    5486:	c9 f7       	brne	.-14     	; 0x547a <SD_read_block+0x5c>
    5488:	0b 2d       	mov	r16, r11
    548a:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    548c:	c0 e0       	ldi	r28, 0x00	; 0
    548e:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5490:	8f ef       	ldi	r24, 0xFF	; 255
    5492:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5496:	f8 01       	movw	r30, r16
    5498:	81 93       	st	Z+, r24
    549a:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    549c:	21 96       	adiw	r28, 0x01	; 1
    549e:	f2 e0       	ldi	r31, 0x02	; 2
    54a0:	c0 30       	cpi	r28, 0x00	; 0
    54a2:	df 07       	cpc	r29, r31
    54a4:	a9 f7       	brne	.-22     	; 0x5490 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    54a6:	10 92 41 3e 	sts	0x3E41, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    54aa:	80 91 41 3e 	lds	r24, 0x3E41
    54ae:	8f 3f       	cpi	r24, 0xFF	; 255
    54b0:	49 f0       	breq	.+18     	; 0x54c4 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    54b2:	c1 e4       	ldi	r28, 0x41	; 65
    54b4:	de e3       	ldi	r29, 0x3E	; 62
    54b6:	8f ef       	ldi	r24, 0xFF	; 255
    54b8:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    54bc:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    54be:	88 81       	ld	r24, Y
    54c0:	8f 3f       	cpi	r24, 0xFF	; 255
    54c2:	c9 f7       	brne	.-14     	; 0x54b6 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    54c4:	80 e0       	ldi	r24, 0x00	; 0
    54c6:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    54ca:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    54ce:	88 e0       	ldi	r24, 0x08	; 8
    54d0:	60 e0       	ldi	r22, 0x00	; 0
    54d2:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
}
    54d6:	df 91       	pop	r29
    54d8:	cf 91       	pop	r28
    54da:	1f 91       	pop	r17
    54dc:	0f 91       	pop	r16
    54de:	ff 90       	pop	r15
    54e0:	ef 90       	pop	r14
    54e2:	df 90       	pop	r13
    54e4:	cf 90       	pop	r12
    54e6:	bf 90       	pop	r11
    54e8:	af 90       	pop	r10
    54ea:	08 95       	ret

000054ec <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    54ec:	2f 92       	push	r2
    54ee:	3f 92       	push	r3
    54f0:	4f 92       	push	r4
    54f2:	5f 92       	push	r5
    54f4:	6f 92       	push	r6
    54f6:	7f 92       	push	r7
    54f8:	8f 92       	push	r8
    54fa:	9f 92       	push	r9
    54fc:	af 92       	push	r10
    54fe:	bf 92       	push	r11
    5500:	cf 92       	push	r12
    5502:	df 92       	push	r13
    5504:	ef 92       	push	r14
    5506:	ff 92       	push	r15
    5508:	0f 93       	push	r16
    550a:	1f 93       	push	r17
    550c:	cf 93       	push	r28
    550e:	df 93       	push	r29
    5510:	cd b7       	in	r28, 0x3d	; 61
    5512:	de b7       	in	r29, 0x3e	; 62
    5514:	2a 97       	sbiw	r28, 0x0a	; 10
    5516:	cd bf       	out	0x3d, r28	; 61
    5518:	de bf       	out	0x3e, r29	; 62
    551a:	6b 01       	movw	r12, r22
    551c:	7c 01       	movw	r14, r24
    551e:	4f 83       	std	Y+7, r20	; 0x07
    5520:	58 87       	std	Y+8, r21	; 0x08
    5522:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5524:	88 e0       	ldi	r24, 0x08	; 8
    5526:	60 e0       	ldi	r22, 0x00	; 0
    5528:	0e 94 49 05 	call	0xa92	; 0xa92 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    552c:	80 e0       	ldi	r24, 0x00	; 0
    552e:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
    5532:	81 e0       	ldi	r24, 0x01	; 1
    5534:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5538:	c8 01       	movw	r24, r16
    553a:	11 23       	and	r17, r17
    553c:	14 f4       	brge	.+4      	; 0x5542 <SD_write_multiple_blocks+0x56>
    553e:	81 50       	subi	r24, 0x01	; 1
    5540:	9e 4f       	sbci	r25, 0xFE	; 254
    5542:	9c 01       	movw	r18, r24
    5544:	23 2f       	mov	r18, r19
    5546:	33 0f       	add	r19, r19
    5548:	33 0b       	sbc	r19, r19
    554a:	25 95       	asr	r18
    554c:	2b 83       	std	Y+3, r18	; 0x03
    554e:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5550:	20 e0       	ldi	r18, 0x00	; 0
    5552:	32 e0       	ldi	r19, 0x02	; 2
    5554:	c8 01       	movw	r24, r16
    5556:	b9 01       	movw	r22, r18
    5558:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    555c:	29 01       	movw	r4, r18
    555e:	48 1a       	sub	r4, r24
    5560:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5562:	30 e0       	ldi	r19, 0x00	; 0
    5564:	43 16       	cp	r4, r19
    5566:	32 e0       	ldi	r19, 0x02	; 2
    5568:	53 06       	cpc	r5, r19
    556a:	31 f0       	breq	.+12     	; 0x5578 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    556c:	8b 81       	ldd	r24, Y+3	; 0x03
    556e:	9c 81       	ldd	r25, Y+4	; 0x04
    5570:	01 96       	adiw	r24, 0x01	; 1
    5572:	8b 83       	std	Y+3, r24	; 0x03
    5574:	9c 83       	std	Y+4, r25	; 0x04
    5576:	02 c0       	rjmp	.+4      	; 0x557c <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5578:	44 24       	eor	r4, r4
    557a:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    557c:	89 e1       	ldi	r24, 0x19	; 25
    557e:	b7 01       	movw	r22, r14
    5580:	a6 01       	movw	r20, r12
    5582:	2f ef       	ldi	r18, 0xFF	; 255
    5584:	08 e0       	ldi	r16, 0x08	; 8
    5586:	10 e0       	ldi	r17, 0x00	; 0
    5588:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
    558c:	88 23       	and	r24, r24
    558e:	b1 f7       	brne	.-20     	; 0x557c <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5590:	eb 81       	ldd	r30, Y+3	; 0x03
    5592:	fc 81       	ldd	r31, Y+4	; 0x04
    5594:	1e 16       	cp	r1, r30
    5596:	1f 06       	cpc	r1, r31
    5598:	0c f0       	brlt	.+2      	; 0x559c <SD_write_multiple_blocks+0xb0>
    559a:	ac c0       	rjmp	.+344    	; 0x56f4 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    559c:	31 97       	sbiw	r30, 0x01	; 1
    559e:	ed 83       	std	Y+5, r30	; 0x05
    55a0:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    55a2:	9f 01       	movw	r18, r30
    55a4:	32 2f       	mov	r19, r18
    55a6:	22 27       	eor	r18, r18
    55a8:	33 0f       	add	r19, r19
    55aa:	8f 81       	ldd	r24, Y+7	; 0x07
    55ac:	98 85       	ldd	r25, Y+8	; 0x08
    55ae:	89 83       	std	Y+1, r24	; 0x01
    55b0:	9a 83       	std	Y+2, r25	; 0x02
    55b2:	66 24       	eor	r6, r6
    55b4:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    55b6:	0f 2e       	mov	r0, r31
    55b8:	f6 e3       	ldi	r31, 0x36	; 54
    55ba:	8f 2e       	mov	r8, r31
    55bc:	fe e3       	ldi	r31, 0x3E	; 62
    55be:	9f 2e       	mov	r9, r31
    55c0:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    55c2:	0f 2e       	mov	r0, r31
    55c4:	fc e0       	ldi	r31, 0x0C	; 12
    55c6:	cf 2e       	mov	r12, r31
    55c8:	dd 24       	eor	r13, r13
    55ca:	f0 2d       	mov	r31, r0
    55cc:	0f 2e       	mov	r0, r31
    55ce:	f5 e3       	ldi	r31, 0x35	; 53
    55d0:	af 2e       	mov	r10, r31
    55d2:	fe e3       	ldi	r31, 0x3E	; 62
    55d4:	bf 2e       	mov	r11, r31
    55d6:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    55d8:	80 e0       	ldi	r24, 0x00	; 0
    55da:	92 e0       	ldi	r25, 0x02	; 2
    55dc:	1c 01       	movw	r2, r24
    55de:	24 18       	sub	r2, r4
    55e0:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    55e2:	ef 81       	ldd	r30, Y+7	; 0x07
    55e4:	f8 85       	ldd	r31, Y+8	; 0x08
    55e6:	e2 0f       	add	r30, r18
    55e8:	f3 1f       	adc	r31, r19
    55ea:	ef 83       	std	Y+7, r30	; 0x07
    55ec:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    55ee:	8f ef       	ldi	r24, 0xFF	; 255
    55f0:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    55f4:	f4 01       	movw	r30, r8
    55f6:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    55f8:	8c ef       	ldi	r24, 0xFC	; 252
    55fa:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    55fe:	f4 01       	movw	r30, r8
    5600:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    5602:	2d 81       	ldd	r18, Y+5	; 0x05
    5604:	3e 81       	ldd	r19, Y+6	; 0x06
    5606:	26 15       	cp	r18, r6
    5608:	37 05       	cpc	r19, r7
    560a:	09 f0       	breq	.+2      	; 0x560e <SD_write_multiple_blocks+0x122>
    560c:	41 c0       	rjmp	.+130    	; 0x5690 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    560e:	12 14       	cp	r1, r2
    5610:	13 04       	cpc	r1, r3
    5612:	cc f4       	brge	.+50     	; 0x5646 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5614:	ef 80       	ldd	r14, Y+7	; 0x07
    5616:	f8 84       	ldd	r15, Y+8	; 0x08
    5618:	00 e0       	ldi	r16, 0x00	; 0
    561a:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    561c:	c8 01       	movw	r24, r16
    561e:	b6 01       	movw	r22, r12
    5620:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    5624:	89 87       	std	Y+9, r24	; 0x09
    5626:	9a 87       	std	Y+10, r25	; 0x0a
    5628:	f7 01       	movw	r30, r14
    562a:	81 91       	ld	r24, Z+
    562c:	7f 01       	movw	r14, r30
    562e:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5632:	e9 85       	ldd	r30, Y+9	; 0x09
    5634:	fa 85       	ldd	r31, Y+10	; 0x0a
    5636:	ea 0d       	add	r30, r10
    5638:	fb 1d       	adc	r31, r11
    563a:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    563c:	0f 5f       	subi	r16, 0xFF	; 255
    563e:	1f 4f       	sbci	r17, 0xFF	; 255
    5640:	02 15       	cp	r16, r2
    5642:	13 05       	cpc	r17, r3
    5644:	59 f7       	brne	.-42     	; 0x561c <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5646:	14 14       	cp	r1, r4
    5648:	15 04       	cpc	r1, r5
    564a:	9c f4       	brge	.+38     	; 0x5672 <SD_write_multiple_blocks+0x186>
    564c:	00 e0       	ldi	r16, 0x00	; 0
    564e:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5650:	c8 01       	movw	r24, r16
    5652:	b6 01       	movw	r22, r12
    5654:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    5658:	7c 01       	movw	r14, r24
    565a:	80 e0       	ldi	r24, 0x00	; 0
    565c:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5660:	f5 01       	movw	r30, r10
    5662:	ee 0d       	add	r30, r14
    5664:	ff 1d       	adc	r31, r15
    5666:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5668:	0f 5f       	subi	r16, 0xFF	; 255
    566a:	1f 4f       	sbci	r17, 0xFF	; 255
    566c:	04 15       	cp	r16, r4
    566e:	15 05       	cpc	r17, r5
    5670:	79 f7       	brne	.-34     	; 0x5650 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5672:	8f ef       	ldi	r24, 0xFF	; 255
    5674:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5678:	f4 01       	movw	r30, r8
    567a:	80 83       	st	Z, r24
    567c:	8f ef       	ldi	r24, 0xFF	; 255
    567e:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5682:	f4 01       	movw	r30, r8
    5684:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5686:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5688:	80 81       	ld	r24, Z
    568a:	8f 3f       	cpi	r24, 0xFF	; 255
    568c:	e1 f4       	brne	.+56     	; 0x56c6 <SD_write_multiple_blocks+0x1da>
    568e:	23 c0       	rjmp	.+70     	; 0x56d6 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5690:	e9 80       	ldd	r14, Y+1	; 0x01
    5692:	fa 80       	ldd	r15, Y+2	; 0x02
    5694:	00 e0       	ldi	r16, 0x00	; 0
    5696:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5698:	c8 01       	movw	r24, r16
    569a:	b6 01       	movw	r22, r12
    569c:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <__divmodhi4>
    56a0:	89 87       	std	Y+9, r24	; 0x09
    56a2:	9a 87       	std	Y+10, r25	; 0x0a
    56a4:	f7 01       	movw	r30, r14
    56a6:	81 91       	ld	r24, Z+
    56a8:	7f 01       	movw	r14, r30
    56aa:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    56ae:	e9 85       	ldd	r30, Y+9	; 0x09
    56b0:	fa 85       	ldd	r31, Y+10	; 0x0a
    56b2:	ea 0d       	add	r30, r10
    56b4:	fb 1d       	adc	r31, r11
    56b6:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    56b8:	0f 5f       	subi	r16, 0xFF	; 255
    56ba:	1f 4f       	sbci	r17, 0xFF	; 255
    56bc:	f2 e0       	ldi	r31, 0x02	; 2
    56be:	00 30       	cpi	r16, 0x00	; 0
    56c0:	1f 07       	cpc	r17, r31
    56c2:	51 f7       	brne	.-44     	; 0x5698 <SD_write_multiple_blocks+0x1ac>
    56c4:	d6 cf       	rjmp	.-84     	; 0x5672 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    56c6:	8f ef       	ldi	r24, 0xFF	; 255
    56c8:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    56cc:	f4 01       	movw	r30, r8
    56ce:	80 83       	st	Z, r24
    56d0:	80 81       	ld	r24, Z
    56d2:	8f 3f       	cpi	r24, 0xFF	; 255
    56d4:	c1 f7       	brne	.-16     	; 0x56c6 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    56d6:	08 94       	sec
    56d8:	61 1c       	adc	r6, r1
    56da:	71 1c       	adc	r7, r1
    56dc:	29 81       	ldd	r18, Y+1	; 0x01
    56de:	3a 81       	ldd	r19, Y+2	; 0x02
    56e0:	20 50       	subi	r18, 0x00	; 0
    56e2:	3e 4f       	sbci	r19, 0xFE	; 254
    56e4:	29 83       	std	Y+1, r18	; 0x01
    56e6:	3a 83       	std	Y+2, r19	; 0x02
    56e8:	8b 81       	ldd	r24, Y+3	; 0x03
    56ea:	9c 81       	ldd	r25, Y+4	; 0x04
    56ec:	68 16       	cp	r6, r24
    56ee:	79 06       	cpc	r7, r25
    56f0:	09 f0       	breq	.+2      	; 0x56f4 <SD_write_multiple_blocks+0x208>
    56f2:	7d cf       	rjmp	.-262    	; 0x55ee <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    56f4:	ee 24       	eor	r14, r14
    56f6:	ff 24       	eor	r15, r15
    56f8:	68 94       	set
    56fa:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    56fc:	06 e3       	ldi	r16, 0x36	; 54
    56fe:	1e e3       	ldi	r17, 0x3E	; 62
    5700:	8f ef       	ldi	r24, 0xFF	; 255
    5702:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5706:	f8 01       	movw	r30, r16
    5708:	80 83       	st	Z, r24
    570a:	08 94       	sec
    570c:	e1 08       	sbc	r14, r1
    570e:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5710:	e1 14       	cp	r14, r1
    5712:	f1 04       	cpc	r15, r1
    5714:	a9 f7       	brne	.-22     	; 0x5700 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5716:	8d ef       	ldi	r24, 0xFD	; 253
    5718:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    571c:	80 93 36 3e 	sts	0x3E36, r24
    5720:	ee 24       	eor	r14, r14
    5722:	ff 24       	eor	r15, r15
    5724:	68 94       	set
    5726:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5728:	06 e3       	ldi	r16, 0x36	; 54
    572a:	1e e3       	ldi	r17, 0x3E	; 62
    572c:	8f ef       	ldi	r24, 0xFF	; 255
    572e:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5732:	f8 01       	movw	r30, r16
    5734:	80 83       	st	Z, r24
    5736:	08 94       	sec
    5738:	e1 08       	sbc	r14, r1
    573a:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    573c:	e1 14       	cp	r14, r1
    573e:	f1 04       	cpc	r15, r1
    5740:	a9 f7       	brne	.-22     	; 0x572c <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5742:	10 92 36 3e 	sts	0x3E36, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5746:	80 91 36 3e 	lds	r24, 0x3E36
    574a:	8f 3f       	cpi	r24, 0xFF	; 255
    574c:	51 f0       	breq	.+20     	; 0x5762 <SD_write_multiple_blocks+0x276>
    574e:	06 e3       	ldi	r16, 0x36	; 54
    5750:	1e e3       	ldi	r17, 0x3E	; 62
    5752:	8f ef       	ldi	r24, 0xFF	; 255
    5754:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5758:	f8 01       	movw	r30, r16
    575a:	80 83       	st	Z, r24
    575c:	80 81       	ld	r24, Z
    575e:	8f 3f       	cpi	r24, 0xFF	; 255
    5760:	c1 f7       	brne	.-16     	; 0x5752 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5762:	80 e0       	ldi	r24, 0x00	; 0
    5764:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    5768:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    576c:	88 e0       	ldi	r24, 0x08	; 8
    576e:	60 e0       	ldi	r22, 0x00	; 0
    5770:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
}
    5774:	2a 96       	adiw	r28, 0x0a	; 10
    5776:	cd bf       	out	0x3d, r28	; 61
    5778:	de bf       	out	0x3e, r29	; 62
    577a:	df 91       	pop	r29
    577c:	cf 91       	pop	r28
    577e:	1f 91       	pop	r17
    5780:	0f 91       	pop	r16
    5782:	ff 90       	pop	r15
    5784:	ef 90       	pop	r14
    5786:	df 90       	pop	r13
    5788:	cf 90       	pop	r12
    578a:	bf 90       	pop	r11
    578c:	af 90       	pop	r10
    578e:	9f 90       	pop	r9
    5790:	8f 90       	pop	r8
    5792:	7f 90       	pop	r7
    5794:	6f 90       	pop	r6
    5796:	5f 90       	pop	r5
    5798:	4f 90       	pop	r4
    579a:	3f 90       	pop	r3
    579c:	2f 90       	pop	r2
    579e:	08 95       	ret

000057a0 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    57a0:	2f 92       	push	r2
    57a2:	3f 92       	push	r3
    57a4:	4f 92       	push	r4
    57a6:	5f 92       	push	r5
    57a8:	6f 92       	push	r6
    57aa:	7f 92       	push	r7
    57ac:	8f 92       	push	r8
    57ae:	9f 92       	push	r9
    57b0:	af 92       	push	r10
    57b2:	bf 92       	push	r11
    57b4:	cf 92       	push	r12
    57b6:	df 92       	push	r13
    57b8:	ef 92       	push	r14
    57ba:	ff 92       	push	r15
    57bc:	0f 93       	push	r16
    57be:	1f 93       	push	r17
    57c0:	cf 93       	push	r28
    57c2:	df 93       	push	r29
    57c4:	6b 01       	movw	r12, r22
    57c6:	7c 01       	movw	r14, r24
    57c8:	c4 2f       	mov	r28, r20
    57ca:	85 2e       	mov	r8, r21
    57cc:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    57ce:	88 e0       	ldi	r24, 0x08	; 8
    57d0:	60 e0       	ldi	r22, 0x00	; 0
    57d2:	0e 94 49 05 	call	0xa92	; 0xa92 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    57d6:	80 e0       	ldi	r24, 0x00	; 0
    57d8:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
    57dc:	81 e0       	ldi	r24, 0x01	; 1
    57de:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    57e2:	82 e1       	ldi	r24, 0x12	; 18
    57e4:	b7 01       	movw	r22, r14
    57e6:	a6 01       	movw	r20, r12
    57e8:	2f ef       	ldi	r18, 0xFF	; 255
    57ea:	08 e0       	ldi	r16, 0x08	; 8
    57ec:	10 e0       	ldi	r17, 0x00	; 0
    57ee:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
    57f2:	88 23       	and	r24, r24
    57f4:	b1 f7       	brne	.-20     	; 0x57e2 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    57f6:	16 14       	cp	r1, r6
    57f8:	17 04       	cpc	r1, r7
    57fa:	0c f0       	brlt	.+2      	; 0x57fe <SD_read_multiple_blocks+0x5e>
    57fc:	46 c0       	rjmp	.+140    	; 0x588a <SD_read_multiple_blocks+0xea>
    57fe:	ac 2e       	mov	r10, r28
    5800:	b8 2c       	mov	r11, r8
    5802:	88 24       	eor	r8, r8
    5804:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5806:	0f 2e       	mov	r0, r31
    5808:	f6 e3       	ldi	r31, 0x36	; 54
    580a:	cf 2e       	mov	r12, r31
    580c:	fe e3       	ldi	r31, 0x3E	; 62
    580e:	df 2e       	mov	r13, r31
    5810:	f0 2d       	mov	r31, r0
    5812:	ff 24       	eor	r15, r15
    5814:	fa 94       	dec	r15
    5816:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5818:	0f 2e       	mov	r0, r31
    581a:	f5 e3       	ldi	r31, 0x35	; 53
    581c:	4f 2e       	mov	r4, r31
    581e:	fe e3       	ldi	r31, 0x3E	; 62
    5820:	5f 2e       	mov	r5, r31
    5822:	f0 2d       	mov	r31, r0
    5824:	12 01       	movw	r2, r4
    5826:	08 94       	sec
    5828:	21 1c       	adc	r2, r1
    582a:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    582c:	f6 01       	movw	r30, r12
    582e:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5830:	80 81       	ld	r24, Z
    5832:	8e 3f       	cpi	r24, 0xFE	; 254
    5834:	41 f0       	breq	.+16     	; 0x5846 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5836:	8f 2d       	mov	r24, r15
    5838:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    583c:	f6 01       	movw	r30, r12
    583e:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5840:	80 81       	ld	r24, Z
    5842:	8e 3f       	cpi	r24, 0xFE	; 254
    5844:	c1 f7       	brne	.-16     	; 0x5836 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5846:	85 01       	movw	r16, r10
    5848:	c0 e0       	ldi	r28, 0x00	; 0
    584a:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    584c:	8f 2d       	mov	r24, r15
    584e:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5852:	f8 01       	movw	r30, r16
    5854:	81 93       	st	Z+, r24
    5856:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5858:	21 96       	adiw	r28, 0x01	; 1
    585a:	f2 e0       	ldi	r31, 0x02	; 2
    585c:	c0 30       	cpi	r28, 0x00	; 0
    585e:	df 07       	cpc	r29, r31
    5860:	a9 f7       	brne	.-22     	; 0x584c <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5862:	8f 2d       	mov	r24, r15
    5864:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5868:	f2 01       	movw	r30, r4
    586a:	80 83       	st	Z, r24
    586c:	8f 2d       	mov	r24, r15
    586e:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    5872:	f1 01       	movw	r30, r2
    5874:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5876:	08 94       	sec
    5878:	81 1c       	adc	r8, r1
    587a:	91 1c       	adc	r9, r1
    587c:	80 e0       	ldi	r24, 0x00	; 0
    587e:	92 e0       	ldi	r25, 0x02	; 2
    5880:	a8 0e       	add	r10, r24
    5882:	b9 1e       	adc	r11, r25
    5884:	86 14       	cp	r8, r6
    5886:	97 04       	cpc	r9, r7
    5888:	89 f6       	brne	.-94     	; 0x582c <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    588a:	8c e0       	ldi	r24, 0x0C	; 12
    588c:	40 e0       	ldi	r20, 0x00	; 0
    588e:	50 e0       	ldi	r21, 0x00	; 0
    5890:	ba 01       	movw	r22, r20
    5892:	2f ef       	ldi	r18, 0xFF	; 255
    5894:	08 e0       	ldi	r16, 0x08	; 8
    5896:	10 e0       	ldi	r17, 0x00	; 0
    5898:	0e 94 1f 28 	call	0x503e	; 0x503e <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    589c:	8f ef       	ldi	r24, 0xFF	; 255
    589e:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    58a2:	80 93 35 3e 	sts	0x3E35, r24
	Buffer[1] = FILLER_BYTE;
    58a6:	10 92 36 3e 	sts	0x3E36, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    58aa:	80 91 36 3e 	lds	r24, 0x3E36
    58ae:	8f 3f       	cpi	r24, 0xFF	; 255
    58b0:	49 f0       	breq	.+18     	; 0x58c4 <SD_read_multiple_blocks+0x124>
    58b2:	c6 e3       	ldi	r28, 0x36	; 54
    58b4:	de e3       	ldi	r29, 0x3E	; 62
    58b6:	8f ef       	ldi	r24, 0xFF	; 255
    58b8:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
    58bc:	88 83       	st	Y, r24
    58be:	88 81       	ld	r24, Y
    58c0:	8f 3f       	cpi	r24, 0xFF	; 255
    58c2:	c9 f7       	brne	.-14     	; 0x58b6 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    58c4:	80 e0       	ldi	r24, 0x00	; 0
    58c6:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    58ca:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    58ce:	88 e0       	ldi	r24, 0x08	; 8
    58d0:	60 e0       	ldi	r22, 0x00	; 0
    58d2:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
}
    58d6:	df 91       	pop	r29
    58d8:	cf 91       	pop	r28
    58da:	1f 91       	pop	r17
    58dc:	0f 91       	pop	r16
    58de:	ff 90       	pop	r15
    58e0:	ef 90       	pop	r14
    58e2:	df 90       	pop	r13
    58e4:	cf 90       	pop	r12
    58e6:	bf 90       	pop	r11
    58e8:	af 90       	pop	r10
    58ea:	9f 90       	pop	r9
    58ec:	8f 90       	pop	r8
    58ee:	7f 90       	pop	r7
    58f0:	6f 90       	pop	r6
    58f2:	5f 90       	pop	r5
    58f4:	4f 90       	pop	r4
    58f6:	3f 90       	pop	r3
    58f8:	2f 90       	pop	r2
    58fa:	08 95       	ret

000058fc <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    58fc:	88 e0       	ldi	r24, 0x08	; 8
    58fe:	60 e0       	ldi	r22, 0x00	; 0
    5900:	0e 94 4d 06 	call	0xc9a	; 0xc9a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5904:	88 e0       	ldi	r24, 0x08	; 8
    5906:	60 e0       	ldi	r22, 0x00	; 0
    5908:	0e 94 a0 05 	call	0xb40	; 0xb40 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    590c:	80 e0       	ldi	r24, 0x00	; 0
    590e:	0e 94 ad 04 	call	0x95a	; 0x95a <SPIInit>
	SPICS(TRUE);
    5912:	81 e0       	ldi	r24, 0x01	; 1
    5914:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5918:	8f ef       	ldi	r24, 0xFF	; 255
    591a:	0e 94 ba 07 	call	0xf74	; 0xf74 <SPI_write>
	SPICS(FALSE);	//stop spi
    591e:	80 e0       	ldi	r24, 0x00	; 0
    5920:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <SPICS>
	SPIDisable();
    5924:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5928:	80 e0       	ldi	r24, 0x00	; 0
    592a:	0e 94 a3 06 	call	0xd46	; 0xd46 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    592e:	80 e0       	ldi	r24, 0x00	; 0
    5930:	0e 94 4a 04 	call	0x894	; 0x894 <Ext1Power>
}
    5934:	08 95       	ret

00005936 <__muldi3>:
    5936:	a0 e3       	ldi	r26, 0x30	; 48
    5938:	b0 e0       	ldi	r27, 0x00	; 0
    593a:	e1 ea       	ldi	r30, 0xA1	; 161
    593c:	fc e2       	ldi	r31, 0x2C	; 44
    593e:	0c 94 3a 38 	jmp	0x7074	; 0x7074 <__prologue_saves__+0x4>
    5942:	29 8f       	std	Y+25, r18	; 0x19
    5944:	3a 8f       	std	Y+26, r19	; 0x1a
    5946:	4b 8f       	std	Y+27, r20	; 0x1b
    5948:	5c 8f       	std	Y+28, r21	; 0x1c
    594a:	6d 8f       	std	Y+29, r22	; 0x1d
    594c:	7e 8f       	std	Y+30, r23	; 0x1e
    594e:	8f 8f       	std	Y+31, r24	; 0x1f
    5950:	98 a3       	lds	r25, 0x58
    5952:	a9 8a       	std	Y+17, r10	; 0x11
    5954:	ba 8a       	std	Y+18, r11	; 0x12
    5956:	cb 8a       	std	Y+19, r12	; 0x13
    5958:	dc 8a       	std	Y+20, r13	; 0x14
    595a:	ed 8a       	std	Y+21, r14	; 0x15
    595c:	fe 8a       	std	Y+22, r15	; 0x16
    595e:	0f 8b       	std	Y+23, r16	; 0x17
    5960:	18 8f       	std	Y+24, r17	; 0x18
    5962:	09 8d       	ldd	r16, Y+25	; 0x19
    5964:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5966:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5968:	3c 8d       	ldd	r19, Y+28	; 0x1c
    596a:	09 a3       	lds	r16, 0x59
    596c:	1a a3       	lds	r17, 0x5a
    596e:	2b a3       	lds	r18, 0x5b
    5970:	3c a3       	lds	r19, 0x5c
    5972:	68 01       	movw	r12, r16
    5974:	79 01       	movw	r14, r18
    5976:	8f ef       	ldi	r24, 0xFF	; 255
    5978:	9f ef       	ldi	r25, 0xFF	; 255
    597a:	a0 e0       	ldi	r26, 0x00	; 0
    597c:	b0 e0       	ldi	r27, 0x00	; 0
    597e:	c8 22       	and	r12, r24
    5980:	d9 22       	and	r13, r25
    5982:	ea 22       	and	r14, r26
    5984:	fb 22       	and	r15, r27
    5986:	89 01       	movw	r16, r18
    5988:	22 27       	eor	r18, r18
    598a:	33 27       	eor	r19, r19
    598c:	09 a7       	lds	r16, 0x79
    598e:	1a a7       	lds	r17, 0x7a
    5990:	2b a7       	lds	r18, 0x7b
    5992:	3c a7       	lds	r19, 0x7c
    5994:	09 89       	ldd	r16, Y+17	; 0x11
    5996:	1a 89       	ldd	r17, Y+18	; 0x12
    5998:	2b 89       	ldd	r18, Y+19	; 0x13
    599a:	3c 89       	ldd	r19, Y+20	; 0x14
    599c:	0d a3       	lds	r16, 0x5d
    599e:	1e a3       	lds	r17, 0x5e
    59a0:	2f a3       	lds	r18, 0x5f
    59a2:	38 a7       	lds	r19, 0x78
    59a4:	48 01       	movw	r8, r16
    59a6:	59 01       	movw	r10, r18
    59a8:	88 22       	and	r8, r24
    59aa:	99 22       	and	r9, r25
    59ac:	aa 22       	and	r10, r26
    59ae:	bb 22       	and	r11, r27
    59b0:	29 01       	movw	r4, r18
    59b2:	66 24       	eor	r6, r6
    59b4:	77 24       	eor	r7, r7
    59b6:	c5 01       	movw	r24, r10
    59b8:	b4 01       	movw	r22, r8
    59ba:	a7 01       	movw	r20, r14
    59bc:	96 01       	movw	r18, r12
    59be:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    59c2:	6d a7       	lds	r22, 0x7d
    59c4:	7e a7       	lds	r23, 0x7e
    59c6:	8f a7       	lds	r24, 0x7f
    59c8:	98 ab       	sts	0x58, r25
    59ca:	c3 01       	movw	r24, r6
    59cc:	b2 01       	movw	r22, r4
    59ce:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    59d2:	6b 01       	movw	r12, r22
    59d4:	7c 01       	movw	r14, r24
    59d6:	c5 01       	movw	r24, r10
    59d8:	b4 01       	movw	r22, r8
    59da:	29 a5       	lds	r18, 0x69
    59dc:	3a a5       	lds	r19, 0x6a
    59de:	4b a5       	lds	r20, 0x6b
    59e0:	5c a5       	lds	r21, 0x6c
    59e2:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    59e6:	4b 01       	movw	r8, r22
    59e8:	5c 01       	movw	r10, r24
    59ea:	c3 01       	movw	r24, r6
    59ec:	b2 01       	movw	r22, r4
    59ee:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    59f2:	ab 01       	movw	r20, r22
    59f4:	bc 01       	movw	r22, r24
    59f6:	c8 0c       	add	r12, r8
    59f8:	d9 1c       	adc	r13, r9
    59fa:	ea 1c       	adc	r14, r10
    59fc:	fb 1c       	adc	r15, r11
    59fe:	0d a5       	lds	r16, 0x6d
    5a00:	1e a5       	lds	r17, 0x6e
    5a02:	2f a5       	lds	r18, 0x6f
    5a04:	38 a9       	sts	0x48, r19
    5a06:	c9 01       	movw	r24, r18
    5a08:	aa 27       	eor	r26, r26
    5a0a:	bb 27       	eor	r27, r27
    5a0c:	c8 0e       	add	r12, r24
    5a0e:	d9 1e       	adc	r13, r25
    5a10:	ea 1e       	adc	r14, r26
    5a12:	fb 1e       	adc	r15, r27
    5a14:	c8 14       	cp	r12, r8
    5a16:	d9 04       	cpc	r13, r9
    5a18:	ea 04       	cpc	r14, r10
    5a1a:	fb 04       	cpc	r15, r11
    5a1c:	20 f4       	brcc	.+8      	; 0x5a26 <__muldi3+0xf0>
    5a1e:	40 50       	subi	r20, 0x00	; 0
    5a20:	50 40       	sbci	r21, 0x00	; 0
    5a22:	6f 4f       	sbci	r22, 0xFF	; 255
    5a24:	7f 4f       	sbci	r23, 0xFF	; 255
    5a26:	c7 01       	movw	r24, r14
    5a28:	aa 27       	eor	r26, r26
    5a2a:	bb 27       	eor	r27, r27
    5a2c:	84 0f       	add	r24, r20
    5a2e:	95 1f       	adc	r25, r21
    5a30:	a6 1f       	adc	r26, r22
    5a32:	b7 1f       	adc	r27, r23
    5a34:	8d 83       	std	Y+5, r24	; 0x05
    5a36:	9e 83       	std	Y+6, r25	; 0x06
    5a38:	af 83       	std	Y+7, r26	; 0x07
    5a3a:	b8 87       	std	Y+8, r27	; 0x08
    5a3c:	76 01       	movw	r14, r12
    5a3e:	dd 24       	eor	r13, r13
    5a40:	cc 24       	eor	r12, r12
    5a42:	4d a5       	lds	r20, 0x6d
    5a44:	5e a5       	lds	r21, 0x6e
    5a46:	6f a5       	lds	r22, 0x6f
    5a48:	78 a9       	sts	0x48, r23
    5a4a:	60 70       	andi	r22, 0x00	; 0
    5a4c:	70 70       	andi	r23, 0x00	; 0
    5a4e:	c4 0e       	add	r12, r20
    5a50:	d5 1e       	adc	r13, r21
    5a52:	e6 1e       	adc	r14, r22
    5a54:	f7 1e       	adc	r15, r23
    5a56:	c9 82       	std	Y+1, r12	; 0x01
    5a58:	da 82       	std	Y+2, r13	; 0x02
    5a5a:	eb 82       	std	Y+3, r14	; 0x03
    5a5c:	fc 82       	std	Y+4, r15	; 0x04
    5a5e:	1c 2d       	mov	r17, r12
    5a60:	0a 81       	ldd	r16, Y+2	; 0x02
    5a62:	8b 80       	ldd	r8, Y+3	; 0x03
    5a64:	4c 80       	ldd	r4, Y+4	; 0x04
    5a66:	8d 87       	std	Y+13, r24	; 0x0d
    5a68:	8e 81       	ldd	r24, Y+6	; 0x06
    5a6a:	8e 87       	std	Y+14, r24	; 0x0e
    5a6c:	8f 81       	ldd	r24, Y+7	; 0x07
    5a6e:	8f 87       	std	Y+15, r24	; 0x0f
    5a70:	88 85       	ldd	r24, Y+8	; 0x08
    5a72:	88 8b       	std	Y+16, r24	; 0x10
    5a74:	2d 89       	ldd	r18, Y+21	; 0x15
    5a76:	3e 89       	ldd	r19, Y+22	; 0x16
    5a78:	4f 89       	ldd	r20, Y+23	; 0x17
    5a7a:	58 8d       	ldd	r21, Y+24	; 0x18
    5a7c:	69 a1       	lds	r22, 0x49
    5a7e:	7a a1       	lds	r23, 0x4a
    5a80:	8b a1       	lds	r24, 0x4b
    5a82:	9c a1       	lds	r25, 0x4c
    5a84:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    5a88:	6b 01       	movw	r12, r22
    5a8a:	7c 01       	movw	r14, r24
    5a8c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5a8e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5a90:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5a92:	58 a1       	lds	r21, 0x48
    5a94:	6d a1       	lds	r22, 0x4d
    5a96:	7e a1       	lds	r23, 0x4e
    5a98:	8f a1       	lds	r24, 0x4f
    5a9a:	98 a5       	lds	r25, 0x68
    5a9c:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    5aa0:	dc 01       	movw	r26, r24
    5aa2:	cb 01       	movw	r24, r22
    5aa4:	c8 0e       	add	r12, r24
    5aa6:	d9 1e       	adc	r13, r25
    5aa8:	ea 1e       	adc	r14, r26
    5aaa:	fb 1e       	adc	r15, r27
    5aac:	8d 85       	ldd	r24, Y+13	; 0x0d
    5aae:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ab0:	af 85       	ldd	r26, Y+15	; 0x0f
    5ab2:	b8 89       	ldd	r27, Y+16	; 0x10
    5ab4:	8c 0d       	add	r24, r12
    5ab6:	9d 1d       	adc	r25, r13
    5ab8:	ae 1d       	adc	r26, r14
    5aba:	bf 1d       	adc	r27, r15
    5abc:	8d 87       	std	Y+13, r24	; 0x0d
    5abe:	9e 87       	std	Y+14, r25	; 0x0e
    5ac0:	af 87       	std	Y+15, r26	; 0x0f
    5ac2:	b8 8b       	std	Y+16, r27	; 0x10
    5ac4:	68 2f       	mov	r22, r24
    5ac6:	7e 85       	ldd	r23, Y+14	; 0x0e
    5ac8:	21 2f       	mov	r18, r17
    5aca:	30 2f       	mov	r19, r16
    5acc:	48 2d       	mov	r20, r8
    5ace:	54 2d       	mov	r21, r4
    5ad0:	8f 85       	ldd	r24, Y+15	; 0x0f
    5ad2:	98 89       	ldd	r25, Y+16	; 0x10
    5ad4:	e0 96       	adiw	r28, 0x30	; 48
    5ad6:	e0 e1       	ldi	r30, 0x10	; 16
    5ad8:	0c 94 53 38 	jmp	0x70a6	; 0x70a6 <__epilogue_restores__+0x4>

00005adc <__ashldi3>:
    5adc:	cf 92       	push	r12
    5ade:	df 92       	push	r13
    5ae0:	ef 92       	push	r14
    5ae2:	ff 92       	push	r15
    5ae4:	0f 93       	push	r16
    5ae6:	cf 93       	push	r28
    5ae8:	df 93       	push	r29
    5aea:	cd b7       	in	r28, 0x3d	; 61
    5aec:	de b7       	in	r29, 0x3e	; 62
    5aee:	60 97       	sbiw	r28, 0x10	; 16
    5af0:	cd bf       	out	0x3d, r28	; 61
    5af2:	de bf       	out	0x3e, r29	; 62
    5af4:	00 23       	and	r16, r16
    5af6:	09 f4       	brne	.+2      	; 0x5afa <__ashldi3+0x1e>
    5af8:	5a c0       	rjmp	.+180    	; 0x5bae <__ashldi3+0xd2>
    5afa:	29 87       	std	Y+9, r18	; 0x09
    5afc:	3a 87       	std	Y+10, r19	; 0x0a
    5afe:	4b 87       	std	Y+11, r20	; 0x0b
    5b00:	5c 87       	std	Y+12, r21	; 0x0c
    5b02:	6d 87       	std	Y+13, r22	; 0x0d
    5b04:	7e 87       	std	Y+14, r23	; 0x0e
    5b06:	8f 87       	std	Y+15, r24	; 0x0f
    5b08:	98 8b       	std	Y+16, r25	; 0x10
    5b0a:	80 e2       	ldi	r24, 0x20	; 32
    5b0c:	80 1b       	sub	r24, r16
    5b0e:	49 85       	ldd	r20, Y+9	; 0x09
    5b10:	5a 85       	ldd	r21, Y+10	; 0x0a
    5b12:	6b 85       	ldd	r22, Y+11	; 0x0b
    5b14:	7c 85       	ldd	r23, Y+12	; 0x0c
    5b16:	18 16       	cp	r1, r24
    5b18:	b4 f0       	brlt	.+44     	; 0x5b46 <__ashldi3+0x6a>
    5b1a:	19 82       	std	Y+1, r1	; 0x01
    5b1c:	1a 82       	std	Y+2, r1	; 0x02
    5b1e:	1b 82       	std	Y+3, r1	; 0x03
    5b20:	1c 82       	std	Y+4, r1	; 0x04
    5b22:	99 27       	eor	r25, r25
    5b24:	87 fd       	sbrc	r24, 7
    5b26:	90 95       	com	r25
    5b28:	90 95       	com	r25
    5b2a:	81 95       	neg	r24
    5b2c:	9f 4f       	sbci	r25, 0xFF	; 255
    5b2e:	04 c0       	rjmp	.+8      	; 0x5b38 <__ashldi3+0x5c>
    5b30:	44 0f       	add	r20, r20
    5b32:	55 1f       	adc	r21, r21
    5b34:	66 1f       	adc	r22, r22
    5b36:	77 1f       	adc	r23, r23
    5b38:	8a 95       	dec	r24
    5b3a:	d2 f7       	brpl	.-12     	; 0x5b30 <__ashldi3+0x54>
    5b3c:	4d 83       	std	Y+5, r20	; 0x05
    5b3e:	5e 83       	std	Y+6, r21	; 0x06
    5b40:	6f 83       	std	Y+7, r22	; 0x07
    5b42:	78 87       	std	Y+8, r23	; 0x08
    5b44:	2c c0       	rjmp	.+88     	; 0x5b9e <__ashldi3+0xc2>
    5b46:	6a 01       	movw	r12, r20
    5b48:	7b 01       	movw	r14, r22
    5b4a:	00 2e       	mov	r0, r16
    5b4c:	04 c0       	rjmp	.+8      	; 0x5b56 <__ashldi3+0x7a>
    5b4e:	cc 0c       	add	r12, r12
    5b50:	dd 1c       	adc	r13, r13
    5b52:	ee 1c       	adc	r14, r14
    5b54:	ff 1c       	adc	r15, r15
    5b56:	0a 94       	dec	r0
    5b58:	d2 f7       	brpl	.-12     	; 0x5b4e <__ashldi3+0x72>
    5b5a:	c9 82       	std	Y+1, r12	; 0x01
    5b5c:	da 82       	std	Y+2, r13	; 0x02
    5b5e:	eb 82       	std	Y+3, r14	; 0x03
    5b60:	fc 82       	std	Y+4, r15	; 0x04
    5b62:	6a 01       	movw	r12, r20
    5b64:	7b 01       	movw	r14, r22
    5b66:	04 c0       	rjmp	.+8      	; 0x5b70 <__ashldi3+0x94>
    5b68:	f6 94       	lsr	r15
    5b6a:	e7 94       	ror	r14
    5b6c:	d7 94       	ror	r13
    5b6e:	c7 94       	ror	r12
    5b70:	8a 95       	dec	r24
    5b72:	d2 f7       	brpl	.-12     	; 0x5b68 <__ashldi3+0x8c>
    5b74:	d7 01       	movw	r26, r14
    5b76:	c6 01       	movw	r24, r12
    5b78:	4d 85       	ldd	r20, Y+13	; 0x0d
    5b7a:	5e 85       	ldd	r21, Y+14	; 0x0e
    5b7c:	6f 85       	ldd	r22, Y+15	; 0x0f
    5b7e:	78 89       	ldd	r23, Y+16	; 0x10
    5b80:	04 c0       	rjmp	.+8      	; 0x5b8a <__ashldi3+0xae>
    5b82:	44 0f       	add	r20, r20
    5b84:	55 1f       	adc	r21, r21
    5b86:	66 1f       	adc	r22, r22
    5b88:	77 1f       	adc	r23, r23
    5b8a:	0a 95       	dec	r16
    5b8c:	d2 f7       	brpl	.-12     	; 0x5b82 <__ashldi3+0xa6>
    5b8e:	84 2b       	or	r24, r20
    5b90:	95 2b       	or	r25, r21
    5b92:	a6 2b       	or	r26, r22
    5b94:	b7 2b       	or	r27, r23
    5b96:	8d 83       	std	Y+5, r24	; 0x05
    5b98:	9e 83       	std	Y+6, r25	; 0x06
    5b9a:	af 83       	std	Y+7, r26	; 0x07
    5b9c:	b8 87       	std	Y+8, r27	; 0x08
    5b9e:	29 81       	ldd	r18, Y+1	; 0x01
    5ba0:	3a 81       	ldd	r19, Y+2	; 0x02
    5ba2:	4b 81       	ldd	r20, Y+3	; 0x03
    5ba4:	5c 81       	ldd	r21, Y+4	; 0x04
    5ba6:	6d 81       	ldd	r22, Y+5	; 0x05
    5ba8:	7e 81       	ldd	r23, Y+6	; 0x06
    5baa:	8f 81       	ldd	r24, Y+7	; 0x07
    5bac:	98 85       	ldd	r25, Y+8	; 0x08
    5bae:	60 96       	adiw	r28, 0x10	; 16
    5bb0:	cd bf       	out	0x3d, r28	; 61
    5bb2:	de bf       	out	0x3e, r29	; 62
    5bb4:	df 91       	pop	r29
    5bb6:	cf 91       	pop	r28
    5bb8:	0f 91       	pop	r16
    5bba:	ff 90       	pop	r15
    5bbc:	ef 90       	pop	r14
    5bbe:	df 90       	pop	r13
    5bc0:	cf 90       	pop	r12
    5bc2:	08 95       	ret

00005bc4 <__ashrdi3>:
    5bc4:	0f 93       	push	r16
    5bc6:	cf 93       	push	r28
    5bc8:	df 93       	push	r29
    5bca:	cd b7       	in	r28, 0x3d	; 61
    5bcc:	de b7       	in	r29, 0x3e	; 62
    5bce:	60 97       	sbiw	r28, 0x10	; 16
    5bd0:	cd bf       	out	0x3d, r28	; 61
    5bd2:	de bf       	out	0x3e, r29	; 62
    5bd4:	00 23       	and	r16, r16
    5bd6:	09 f4       	brne	.+2      	; 0x5bda <__ashrdi3+0x16>
    5bd8:	56 c0       	rjmp	.+172    	; 0x5c86 <__ashrdi3+0xc2>
    5bda:	29 87       	std	Y+9, r18	; 0x09
    5bdc:	3a 87       	std	Y+10, r19	; 0x0a
    5bde:	4b 87       	std	Y+11, r20	; 0x0b
    5be0:	5c 87       	std	Y+12, r21	; 0x0c
    5be2:	6d 87       	std	Y+13, r22	; 0x0d
    5be4:	7e 87       	std	Y+14, r23	; 0x0e
    5be6:	8f 87       	std	Y+15, r24	; 0x0f
    5be8:	98 8b       	std	Y+16, r25	; 0x10
    5bea:	20 e2       	ldi	r18, 0x20	; 32
    5bec:	20 1b       	sub	r18, r16
    5bee:	8d 85       	ldd	r24, Y+13	; 0x0d
    5bf0:	9e 85       	ldd	r25, Y+14	; 0x0e
    5bf2:	af 85       	ldd	r26, Y+15	; 0x0f
    5bf4:	b8 89       	ldd	r27, Y+16	; 0x10
    5bf6:	ac 01       	movw	r20, r24
    5bf8:	bd 01       	movw	r22, r26
    5bfa:	12 16       	cp	r1, r18
    5bfc:	b4 f0       	brlt	.+44     	; 0x5c2a <__ashrdi3+0x66>
    5bfe:	77 0f       	add	r23, r23
    5c00:	44 0b       	sbc	r20, r20
    5c02:	54 2f       	mov	r21, r20
    5c04:	ba 01       	movw	r22, r20
    5c06:	4d 83       	std	Y+5, r20	; 0x05
    5c08:	5e 83       	std	Y+6, r21	; 0x06
    5c0a:	6f 83       	std	Y+7, r22	; 0x07
    5c0c:	78 87       	std	Y+8, r23	; 0x08
    5c0e:	33 27       	eor	r19, r19
    5c10:	27 fd       	sbrc	r18, 7
    5c12:	30 95       	com	r19
    5c14:	30 95       	com	r19
    5c16:	21 95       	neg	r18
    5c18:	3f 4f       	sbci	r19, 0xFF	; 255
    5c1a:	04 c0       	rjmp	.+8      	; 0x5c24 <__ashrdi3+0x60>
    5c1c:	b5 95       	asr	r27
    5c1e:	a7 95       	ror	r26
    5c20:	97 95       	ror	r25
    5c22:	87 95       	ror	r24
    5c24:	2a 95       	dec	r18
    5c26:	d2 f7       	brpl	.-12     	; 0x5c1c <__ashrdi3+0x58>
    5c28:	22 c0       	rjmp	.+68     	; 0x5c6e <__ashrdi3+0xaa>
    5c2a:	00 2e       	mov	r0, r16
    5c2c:	04 c0       	rjmp	.+8      	; 0x5c36 <__ashrdi3+0x72>
    5c2e:	75 95       	asr	r23
    5c30:	67 95       	ror	r22
    5c32:	57 95       	ror	r21
    5c34:	47 95       	ror	r20
    5c36:	0a 94       	dec	r0
    5c38:	d2 f7       	brpl	.-12     	; 0x5c2e <__ashrdi3+0x6a>
    5c3a:	4d 83       	std	Y+5, r20	; 0x05
    5c3c:	5e 83       	std	Y+6, r21	; 0x06
    5c3e:	6f 83       	std	Y+7, r22	; 0x07
    5c40:	78 87       	std	Y+8, r23	; 0x08
    5c42:	04 c0       	rjmp	.+8      	; 0x5c4c <__ashrdi3+0x88>
    5c44:	88 0f       	add	r24, r24
    5c46:	99 1f       	adc	r25, r25
    5c48:	aa 1f       	adc	r26, r26
    5c4a:	bb 1f       	adc	r27, r27
    5c4c:	2a 95       	dec	r18
    5c4e:	d2 f7       	brpl	.-12     	; 0x5c44 <__ashrdi3+0x80>
    5c50:	49 85       	ldd	r20, Y+9	; 0x09
    5c52:	5a 85       	ldd	r21, Y+10	; 0x0a
    5c54:	6b 85       	ldd	r22, Y+11	; 0x0b
    5c56:	7c 85       	ldd	r23, Y+12	; 0x0c
    5c58:	04 c0       	rjmp	.+8      	; 0x5c62 <__ashrdi3+0x9e>
    5c5a:	76 95       	lsr	r23
    5c5c:	67 95       	ror	r22
    5c5e:	57 95       	ror	r21
    5c60:	47 95       	ror	r20
    5c62:	0a 95       	dec	r16
    5c64:	d2 f7       	brpl	.-12     	; 0x5c5a <__ashrdi3+0x96>
    5c66:	84 2b       	or	r24, r20
    5c68:	95 2b       	or	r25, r21
    5c6a:	a6 2b       	or	r26, r22
    5c6c:	b7 2b       	or	r27, r23
    5c6e:	89 83       	std	Y+1, r24	; 0x01
    5c70:	9a 83       	std	Y+2, r25	; 0x02
    5c72:	ab 83       	std	Y+3, r26	; 0x03
    5c74:	bc 83       	std	Y+4, r27	; 0x04
    5c76:	29 81       	ldd	r18, Y+1	; 0x01
    5c78:	3a 81       	ldd	r19, Y+2	; 0x02
    5c7a:	4b 81       	ldd	r20, Y+3	; 0x03
    5c7c:	5c 81       	ldd	r21, Y+4	; 0x04
    5c7e:	6d 81       	ldd	r22, Y+5	; 0x05
    5c80:	7e 81       	ldd	r23, Y+6	; 0x06
    5c82:	8f 81       	ldd	r24, Y+7	; 0x07
    5c84:	98 85       	ldd	r25, Y+8	; 0x08
    5c86:	60 96       	adiw	r28, 0x10	; 16
    5c88:	cd bf       	out	0x3d, r28	; 61
    5c8a:	de bf       	out	0x3e, r29	; 62
    5c8c:	df 91       	pop	r29
    5c8e:	cf 91       	pop	r28
    5c90:	0f 91       	pop	r16
    5c92:	08 95       	ret

00005c94 <__divdi3>:
    5c94:	a8 e4       	ldi	r26, 0x48	; 72
    5c96:	b0 e0       	ldi	r27, 0x00	; 0
    5c98:	e0 e5       	ldi	r30, 0x50	; 80
    5c9a:	fe e2       	ldi	r31, 0x2E	; 46
    5c9c:	0c 94 39 38 	jmp	0x7072	; 0x7072 <__prologue_saves__+0x2>
    5ca0:	f5 01       	movw	r30, r10
    5ca2:	29 a3       	lds	r18, 0x59
    5ca4:	3a a3       	lds	r19, 0x5a
    5ca6:	4b a3       	lds	r20, 0x5b
    5ca8:	5c a3       	lds	r21, 0x5c
    5caa:	6d a3       	lds	r22, 0x5d
    5cac:	7e a3       	lds	r23, 0x5e
    5cae:	8f a3       	lds	r24, 0x5f
    5cb0:	98 a7       	lds	r25, 0x78
    5cb2:	a9 8e       	std	Y+25, r10	; 0x19
    5cb4:	fa 8f       	std	Y+26, r31	; 0x1a
    5cb6:	cb 8e       	std	Y+27, r12	; 0x1b
    5cb8:	dc 8e       	std	Y+28, r13	; 0x1c
    5cba:	ed 8e       	std	Y+29, r14	; 0x1d
    5cbc:	fe 8e       	std	Y+30, r15	; 0x1e
    5cbe:	0f 8f       	std	Y+31, r16	; 0x1f
    5cc0:	18 a3       	lds	r17, 0x58
    5cc2:	8d a0       	lds	r24, 0x8d
    5cc4:	9e a0       	lds	r25, 0x8e
    5cc6:	af a0       	lds	r26, 0x8f
    5cc8:	b8 a4       	lds	r27, 0xa8
    5cca:	b7 fe       	sbrs	r11, 7
    5ccc:	67 c0       	rjmp	.+206    	; 0x5d9c <__divdi3+0x108>
    5cce:	21 95       	neg	r18
    5cd0:	b1 e0       	ldi	r27, 0x01	; 1
    5cd2:	12 16       	cp	r1, r18
    5cd4:	08 f0       	brcs	.+2      	; 0x5cd8 <__divdi3+0x44>
    5cd6:	b0 e0       	ldi	r27, 0x00	; 0
    5cd8:	31 95       	neg	r19
    5cda:	a1 e0       	ldi	r26, 0x01	; 1
    5cdc:	13 16       	cp	r1, r19
    5cde:	08 f0       	brcs	.+2      	; 0x5ce2 <__divdi3+0x4e>
    5ce0:	a0 e0       	ldi	r26, 0x00	; 0
    5ce2:	b3 2e       	mov	r11, r19
    5ce4:	bb 1a       	sub	r11, r27
    5ce6:	bb 2d       	mov	r27, r11
    5ce8:	88 24       	eor	r8, r8
    5cea:	83 94       	inc	r8
    5cec:	3b 15       	cp	r19, r11
    5cee:	08 f0       	brcs	.+2      	; 0x5cf2 <__divdi3+0x5e>
    5cf0:	88 24       	eor	r8, r8
    5cf2:	a8 29       	or	r26, r8
    5cf4:	41 95       	neg	r20
    5cf6:	31 e0       	ldi	r19, 0x01	; 1
    5cf8:	14 16       	cp	r1, r20
    5cfa:	08 f0       	brcs	.+2      	; 0x5cfe <__divdi3+0x6a>
    5cfc:	30 e0       	ldi	r19, 0x00	; 0
    5cfe:	b4 2e       	mov	r11, r20
    5d00:	ba 1a       	sub	r11, r26
    5d02:	ab 2d       	mov	r26, r11
    5d04:	88 24       	eor	r8, r8
    5d06:	83 94       	inc	r8
    5d08:	4b 15       	cp	r20, r11
    5d0a:	08 f0       	brcs	.+2      	; 0x5d0e <__divdi3+0x7a>
    5d0c:	88 24       	eor	r8, r8
    5d0e:	38 29       	or	r19, r8
    5d10:	51 95       	neg	r21
    5d12:	41 e0       	ldi	r20, 0x01	; 1
    5d14:	15 16       	cp	r1, r21
    5d16:	08 f0       	brcs	.+2      	; 0x5d1a <__divdi3+0x86>
    5d18:	40 e0       	ldi	r20, 0x00	; 0
    5d1a:	45 2e       	mov	r4, r21
    5d1c:	43 1a       	sub	r4, r19
    5d1e:	31 e0       	ldi	r19, 0x01	; 1
    5d20:	54 15       	cp	r21, r4
    5d22:	08 f0       	brcs	.+2      	; 0x5d26 <__divdi3+0x92>
    5d24:	30 e0       	ldi	r19, 0x00	; 0
    5d26:	43 2b       	or	r20, r19
    5d28:	61 95       	neg	r22
    5d2a:	31 e0       	ldi	r19, 0x01	; 1
    5d2c:	16 16       	cp	r1, r22
    5d2e:	08 f0       	brcs	.+2      	; 0x5d32 <__divdi3+0x9e>
    5d30:	30 e0       	ldi	r19, 0x00	; 0
    5d32:	86 2e       	mov	r8, r22
    5d34:	84 1a       	sub	r8, r20
    5d36:	41 e0       	ldi	r20, 0x01	; 1
    5d38:	68 15       	cp	r22, r8
    5d3a:	08 f0       	brcs	.+2      	; 0x5d3e <__divdi3+0xaa>
    5d3c:	40 e0       	ldi	r20, 0x00	; 0
    5d3e:	34 2b       	or	r19, r20
    5d40:	71 95       	neg	r23
    5d42:	41 e0       	ldi	r20, 0x01	; 1
    5d44:	17 16       	cp	r1, r23
    5d46:	08 f0       	brcs	.+2      	; 0x5d4a <__divdi3+0xb6>
    5d48:	40 e0       	ldi	r20, 0x00	; 0
    5d4a:	57 2f       	mov	r21, r23
    5d4c:	53 1b       	sub	r21, r19
    5d4e:	31 e0       	ldi	r19, 0x01	; 1
    5d50:	75 17       	cp	r23, r21
    5d52:	08 f0       	brcs	.+2      	; 0x5d56 <__divdi3+0xc2>
    5d54:	30 e0       	ldi	r19, 0x00	; 0
    5d56:	43 2b       	or	r20, r19
    5d58:	81 95       	neg	r24
    5d5a:	31 e0       	ldi	r19, 0x01	; 1
    5d5c:	18 16       	cp	r1, r24
    5d5e:	08 f0       	brcs	.+2      	; 0x5d62 <__divdi3+0xce>
    5d60:	30 e0       	ldi	r19, 0x00	; 0
    5d62:	68 2f       	mov	r22, r24
    5d64:	64 1b       	sub	r22, r20
    5d66:	46 2f       	mov	r20, r22
    5d68:	61 e0       	ldi	r22, 0x01	; 1
    5d6a:	84 17       	cp	r24, r20
    5d6c:	08 f0       	brcs	.+2      	; 0x5d70 <__divdi3+0xdc>
    5d6e:	60 e0       	ldi	r22, 0x00	; 0
    5d70:	36 2b       	or	r19, r22
    5d72:	91 95       	neg	r25
    5d74:	93 1b       	sub	r25, r19
    5d76:	29 a3       	lds	r18, 0x59
    5d78:	ba a3       	lds	r27, 0x5a
    5d7a:	ab a3       	lds	r26, 0x5b
    5d7c:	4c a2       	lds	r20, 0x9c
    5d7e:	8d a2       	lds	r24, 0x9d
    5d80:	5e a3       	lds	r21, 0x5e
    5d82:	4f a3       	lds	r20, 0x5f
    5d84:	98 a7       	lds	r25, 0x78
    5d86:	8f ef       	ldi	r24, 0xFF	; 255
    5d88:	9f ef       	ldi	r25, 0xFF	; 255
    5d8a:	af ef       	ldi	r26, 0xFF	; 255
    5d8c:	bf ef       	ldi	r27, 0xFF	; 255
    5d8e:	25 96       	adiw	r28, 0x05	; 5
    5d90:	8c af       	sts	0x7c, r24
    5d92:	9d af       	sts	0x7d, r25
    5d94:	ae af       	sts	0x7e, r26
    5d96:	bf af       	sts	0x7f, r27
    5d98:	25 97       	sbiw	r28, 0x05	; 5
    5d9a:	06 c0       	rjmp	.+12     	; 0x5da8 <__divdi3+0x114>
    5d9c:	25 96       	adiw	r28, 0x05	; 5
    5d9e:	1c ae       	sts	0xbc, r17
    5da0:	1d ae       	sts	0xbd, r17
    5da2:	1e ae       	sts	0xbe, r17
    5da4:	1f ae       	sts	0xbf, r17
    5da6:	25 97       	sbiw	r28, 0x05	; 5
    5da8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5daa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5dac:	af 8d       	ldd	r26, Y+31	; 0x1f
    5dae:	b8 a1       	lds	r27, 0x48
    5db0:	b7 ff       	sbrs	r27, 7
    5db2:	68 c0       	rjmp	.+208    	; 0x5e84 <__divdi3+0x1f0>
    5db4:	25 96       	adiw	r28, 0x05	; 5
    5db6:	2c ad       	sts	0x6c, r18
    5db8:	3d ad       	sts	0x6d, r19
    5dba:	4e ad       	sts	0x6e, r20
    5dbc:	5f ad       	sts	0x6f, r21
    5dbe:	25 97       	sbiw	r28, 0x05	; 5
    5dc0:	20 95       	com	r18
    5dc2:	30 95       	com	r19
    5dc4:	40 95       	com	r20
    5dc6:	50 95       	com	r21
    5dc8:	25 96       	adiw	r28, 0x05	; 5
    5dca:	2c af       	sts	0x7c, r18
    5dcc:	3d af       	sts	0x7d, r19
    5dce:	4e af       	sts	0x7e, r20
    5dd0:	5f af       	sts	0x7f, r21
    5dd2:	25 97       	sbiw	r28, 0x05	; 5
    5dd4:	e1 95       	neg	r30
    5dd6:	81 e0       	ldi	r24, 0x01	; 1
    5dd8:	1e 16       	cp	r1, r30
    5dda:	08 f0       	brcs	.+2      	; 0x5dde <__divdi3+0x14a>
    5ddc:	80 e0       	ldi	r24, 0x00	; 0
    5dde:	f1 95       	neg	r31
    5de0:	91 e0       	ldi	r25, 0x01	; 1
    5de2:	1f 16       	cp	r1, r31
    5de4:	08 f0       	brcs	.+2      	; 0x5de8 <__divdi3+0x154>
    5de6:	90 e0       	ldi	r25, 0x00	; 0
    5de8:	4f 2f       	mov	r20, r31
    5dea:	48 1b       	sub	r20, r24
    5dec:	81 e0       	ldi	r24, 0x01	; 1
    5dee:	f4 17       	cp	r31, r20
    5df0:	08 f0       	brcs	.+2      	; 0x5df4 <__divdi3+0x160>
    5df2:	80 e0       	ldi	r24, 0x00	; 0
    5df4:	98 2b       	or	r25, r24
    5df6:	c1 94       	neg	r12
    5df8:	81 e0       	ldi	r24, 0x01	; 1
    5dfa:	1c 14       	cp	r1, r12
    5dfc:	08 f0       	brcs	.+2      	; 0x5e00 <__divdi3+0x16c>
    5dfe:	80 e0       	ldi	r24, 0x00	; 0
    5e00:	6c 2d       	mov	r22, r12
    5e02:	69 1b       	sub	r22, r25
    5e04:	91 e0       	ldi	r25, 0x01	; 1
    5e06:	c6 16       	cp	r12, r22
    5e08:	08 f0       	brcs	.+2      	; 0x5e0c <__divdi3+0x178>
    5e0a:	90 e0       	ldi	r25, 0x00	; 0
    5e0c:	89 2b       	or	r24, r25
    5e0e:	d1 94       	neg	r13
    5e10:	91 e0       	ldi	r25, 0x01	; 1
    5e12:	1d 14       	cp	r1, r13
    5e14:	08 f0       	brcs	.+2      	; 0x5e18 <__divdi3+0x184>
    5e16:	90 e0       	ldi	r25, 0x00	; 0
    5e18:	5d 2d       	mov	r21, r13
    5e1a:	58 1b       	sub	r21, r24
    5e1c:	81 e0       	ldi	r24, 0x01	; 1
    5e1e:	d5 16       	cp	r13, r21
    5e20:	08 f0       	brcs	.+2      	; 0x5e24 <__divdi3+0x190>
    5e22:	80 e0       	ldi	r24, 0x00	; 0
    5e24:	98 2b       	or	r25, r24
    5e26:	e1 94       	neg	r14
    5e28:	81 e0       	ldi	r24, 0x01	; 1
    5e2a:	1e 14       	cp	r1, r14
    5e2c:	08 f0       	brcs	.+2      	; 0x5e30 <__divdi3+0x19c>
    5e2e:	80 e0       	ldi	r24, 0x00	; 0
    5e30:	3e 2d       	mov	r19, r14
    5e32:	39 1b       	sub	r19, r25
    5e34:	91 e0       	ldi	r25, 0x01	; 1
    5e36:	e3 16       	cp	r14, r19
    5e38:	08 f0       	brcs	.+2      	; 0x5e3c <__divdi3+0x1a8>
    5e3a:	90 e0       	ldi	r25, 0x00	; 0
    5e3c:	89 2b       	or	r24, r25
    5e3e:	f1 94       	neg	r15
    5e40:	91 e0       	ldi	r25, 0x01	; 1
    5e42:	1f 14       	cp	r1, r15
    5e44:	08 f0       	brcs	.+2      	; 0x5e48 <__divdi3+0x1b4>
    5e46:	90 e0       	ldi	r25, 0x00	; 0
    5e48:	2f 2d       	mov	r18, r15
    5e4a:	28 1b       	sub	r18, r24
    5e4c:	81 e0       	ldi	r24, 0x01	; 1
    5e4e:	f2 16       	cp	r15, r18
    5e50:	08 f0       	brcs	.+2      	; 0x5e54 <__divdi3+0x1c0>
    5e52:	80 e0       	ldi	r24, 0x00	; 0
    5e54:	98 2b       	or	r25, r24
    5e56:	01 95       	neg	r16
    5e58:	81 e0       	ldi	r24, 0x01	; 1
    5e5a:	10 16       	cp	r1, r16
    5e5c:	08 f0       	brcs	.+2      	; 0x5e60 <__divdi3+0x1cc>
    5e5e:	80 e0       	ldi	r24, 0x00	; 0
    5e60:	70 2f       	mov	r23, r16
    5e62:	79 1b       	sub	r23, r25
    5e64:	97 2f       	mov	r25, r23
    5e66:	71 e0       	ldi	r23, 0x01	; 1
    5e68:	09 17       	cp	r16, r25
    5e6a:	08 f0       	brcs	.+2      	; 0x5e6e <__divdi3+0x1da>
    5e6c:	70 e0       	ldi	r23, 0x00	; 0
    5e6e:	87 2b       	or	r24, r23
    5e70:	11 95       	neg	r17
    5e72:	18 1b       	sub	r17, r24
    5e74:	e9 8f       	std	Y+25, r30	; 0x19
    5e76:	4a 8f       	std	Y+26, r20	; 0x1a
    5e78:	6b 8f       	std	Y+27, r22	; 0x1b
    5e7a:	5c 8f       	std	Y+28, r21	; 0x1c
    5e7c:	3d 8f       	std	Y+29, r19	; 0x1d
    5e7e:	2e 8f       	std	Y+30, r18	; 0x1e
    5e80:	9f 8f       	std	Y+31, r25	; 0x1f
    5e82:	18 a3       	lds	r17, 0x58
    5e84:	79 8d       	ldd	r23, Y+25	; 0x19
    5e86:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5e88:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5e8a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5e8c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5e8e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5e90:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5e92:	88 a1       	lds	r24, 0x48
    5e94:	e9 a1       	lds	r30, 0x49
    5e96:	e9 8b       	std	Y+17, r30	; 0x11
    5e98:	ea a1       	lds	r30, 0x4a
    5e9a:	ea 8b       	std	Y+18, r30	; 0x12
    5e9c:	eb a1       	lds	r30, 0x4b
    5e9e:	eb 8b       	std	Y+19, r30	; 0x13
    5ea0:	ec a1       	lds	r30, 0x4c
    5ea2:	ec 8b       	std	Y+20, r30	; 0x14
    5ea4:	ed a1       	lds	r30, 0x4d
    5ea6:	ed 8b       	std	Y+21, r30	; 0x15
    5ea8:	ee a1       	lds	r30, 0x4e
    5eaa:	ee 8b       	std	Y+22, r30	; 0x16
    5eac:	ef a1       	lds	r30, 0x4f
    5eae:	ef 8b       	std	Y+23, r30	; 0x17
    5eb0:	e8 a5       	lds	r30, 0x68
    5eb2:	e8 8f       	std	Y+24, r30	; 0x18
    5eb4:	79 87       	std	Y+9, r23	; 0x09
    5eb6:	6a 87       	std	Y+10, r22	; 0x0a
    5eb8:	5b 87       	std	Y+11, r21	; 0x0b
    5eba:	4c 87       	std	Y+12, r20	; 0x0c
    5ebc:	3d 87       	std	Y+13, r19	; 0x0d
    5ebe:	2e 87       	std	Y+14, r18	; 0x0e
    5ec0:	9f 87       	std	Y+15, r25	; 0x0f
    5ec2:	88 8b       	std	Y+16, r24	; 0x10
    5ec4:	89 84       	ldd	r8, Y+9	; 0x09
    5ec6:	9a 84       	ldd	r9, Y+10	; 0x0a
    5ec8:	ab 84       	ldd	r10, Y+11	; 0x0b
    5eca:	bc 84       	ldd	r11, Y+12	; 0x0c
    5ecc:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ece:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ed0:	af 85       	ldd	r26, Y+15	; 0x0f
    5ed2:	b8 89       	ldd	r27, Y+16	; 0x10
    5ed4:	e9 88       	ldd	r14, Y+17	; 0x11
    5ed6:	fa 88       	ldd	r15, Y+18	; 0x12
    5ed8:	0b 89       	ldd	r16, Y+19	; 0x13
    5eda:	1c 89       	ldd	r17, Y+20	; 0x14
    5edc:	ed aa       	sts	0x9d, r30
    5ede:	fe aa       	sts	0x9e, r31
    5ee0:	0f ab       	sts	0x5f, r16
    5ee2:	18 af       	sts	0x78, r17
    5ee4:	cd 88       	ldd	r12, Y+21	; 0x15
    5ee6:	de 88       	ldd	r13, Y+22	; 0x16
    5ee8:	ef 88       	ldd	r14, Y+23	; 0x17
    5eea:	f8 8c       	ldd	r15, Y+24	; 0x18
    5eec:	00 97       	sbiw	r24, 0x00	; 0
    5eee:	a1 05       	cpc	r26, r1
    5ef0:	b1 05       	cpc	r27, r1
    5ef2:	09 f0       	breq	.+2      	; 0x5ef6 <__divdi3+0x262>
    5ef4:	bd c3       	rjmp	.+1914   	; 0x6670 <__stack+0x671>
    5ef6:	c8 14       	cp	r12, r8
    5ef8:	d9 04       	cpc	r13, r9
    5efa:	ea 04       	cpc	r14, r10
    5efc:	fb 04       	cpc	r15, r11
    5efe:	08 f0       	brcs	.+2      	; 0x5f02 <__divdi3+0x26e>
    5f00:	4d c1       	rjmp	.+666    	; 0x619c <__stack+0x19d>
    5f02:	00 e0       	ldi	r16, 0x00	; 0
    5f04:	80 16       	cp	r8, r16
    5f06:	00 e0       	ldi	r16, 0x00	; 0
    5f08:	90 06       	cpc	r9, r16
    5f0a:	01 e0       	ldi	r16, 0x01	; 1
    5f0c:	a0 06       	cpc	r10, r16
    5f0e:	00 e0       	ldi	r16, 0x00	; 0
    5f10:	b0 06       	cpc	r11, r16
    5f12:	58 f4       	brcc	.+22     	; 0x5f2a <__divdi3+0x296>
    5f14:	1f ef       	ldi	r17, 0xFF	; 255
    5f16:	81 16       	cp	r8, r17
    5f18:	91 04       	cpc	r9, r1
    5f1a:	a1 04       	cpc	r10, r1
    5f1c:	b1 04       	cpc	r11, r1
    5f1e:	09 f0       	breq	.+2      	; 0x5f22 <__divdi3+0x28e>
    5f20:	90 f4       	brcc	.+36     	; 0x5f46 <__divdi3+0x2b2>
    5f22:	80 e0       	ldi	r24, 0x00	; 0
    5f24:	90 e0       	ldi	r25, 0x00	; 0
    5f26:	dc 01       	movw	r26, r24
    5f28:	17 c0       	rjmp	.+46     	; 0x5f58 <__divdi3+0x2c4>
    5f2a:	20 e0       	ldi	r18, 0x00	; 0
    5f2c:	82 16       	cp	r8, r18
    5f2e:	20 e0       	ldi	r18, 0x00	; 0
    5f30:	92 06       	cpc	r9, r18
    5f32:	20 e0       	ldi	r18, 0x00	; 0
    5f34:	a2 06       	cpc	r10, r18
    5f36:	21 e0       	ldi	r18, 0x01	; 1
    5f38:	b2 06       	cpc	r11, r18
    5f3a:	50 f4       	brcc	.+20     	; 0x5f50 <__divdi3+0x2bc>
    5f3c:	80 e1       	ldi	r24, 0x10	; 16
    5f3e:	90 e0       	ldi	r25, 0x00	; 0
    5f40:	a0 e0       	ldi	r26, 0x00	; 0
    5f42:	b0 e0       	ldi	r27, 0x00	; 0
    5f44:	09 c0       	rjmp	.+18     	; 0x5f58 <__divdi3+0x2c4>
    5f46:	88 e0       	ldi	r24, 0x08	; 8
    5f48:	90 e0       	ldi	r25, 0x00	; 0
    5f4a:	a0 e0       	ldi	r26, 0x00	; 0
    5f4c:	b0 e0       	ldi	r27, 0x00	; 0
    5f4e:	04 c0       	rjmp	.+8      	; 0x5f58 <__divdi3+0x2c4>
    5f50:	88 e1       	ldi	r24, 0x18	; 24
    5f52:	90 e0       	ldi	r25, 0x00	; 0
    5f54:	a0 e0       	ldi	r26, 0x00	; 0
    5f56:	b0 e0       	ldi	r27, 0x00	; 0
    5f58:	b5 01       	movw	r22, r10
    5f5a:	a4 01       	movw	r20, r8
    5f5c:	08 2e       	mov	r0, r24
    5f5e:	04 c0       	rjmp	.+8      	; 0x5f68 <__divdi3+0x2d4>
    5f60:	76 95       	lsr	r23
    5f62:	67 95       	ror	r22
    5f64:	57 95       	ror	r21
    5f66:	47 95       	ror	r20
    5f68:	0a 94       	dec	r0
    5f6a:	d2 f7       	brpl	.-12     	; 0x5f60 <__divdi3+0x2cc>
    5f6c:	fa 01       	movw	r30, r20
    5f6e:	e3 5f       	subi	r30, 0xF3	; 243
    5f70:	ff 4d       	sbci	r31, 0xDF	; 223
    5f72:	20 81       	ld	r18, Z
    5f74:	40 e2       	ldi	r20, 0x20	; 32
    5f76:	50 e0       	ldi	r21, 0x00	; 0
    5f78:	60 e0       	ldi	r22, 0x00	; 0
    5f7a:	70 e0       	ldi	r23, 0x00	; 0
    5f7c:	48 1b       	sub	r20, r24
    5f7e:	59 0b       	sbc	r21, r25
    5f80:	6a 0b       	sbc	r22, r26
    5f82:	7b 0b       	sbc	r23, r27
    5f84:	42 1b       	sub	r20, r18
    5f86:	51 09       	sbc	r21, r1
    5f88:	61 09       	sbc	r22, r1
    5f8a:	71 09       	sbc	r23, r1
    5f8c:	41 15       	cp	r20, r1
    5f8e:	51 05       	cpc	r21, r1
    5f90:	61 05       	cpc	r22, r1
    5f92:	71 05       	cpc	r23, r1
    5f94:	a1 f1       	breq	.+104    	; 0x5ffe <__divdi3+0x36a>
    5f96:	04 2e       	mov	r0, r20
    5f98:	04 c0       	rjmp	.+8      	; 0x5fa2 <__divdi3+0x30e>
    5f9a:	88 0c       	add	r8, r8
    5f9c:	99 1c       	adc	r9, r9
    5f9e:	aa 1c       	adc	r10, r10
    5fa0:	bb 1c       	adc	r11, r11
    5fa2:	0a 94       	dec	r0
    5fa4:	d2 f7       	brpl	.-12     	; 0x5f9a <__divdi3+0x306>
    5fa6:	97 01       	movw	r18, r14
    5fa8:	86 01       	movw	r16, r12
    5faa:	04 2e       	mov	r0, r20
    5fac:	04 c0       	rjmp	.+8      	; 0x5fb6 <__divdi3+0x322>
    5fae:	00 0f       	add	r16, r16
    5fb0:	11 1f       	adc	r17, r17
    5fb2:	22 1f       	adc	r18, r18
    5fb4:	33 1f       	adc	r19, r19
    5fb6:	0a 94       	dec	r0
    5fb8:	d2 f7       	brpl	.-12     	; 0x5fae <__divdi3+0x31a>
    5fba:	80 e2       	ldi	r24, 0x20	; 32
    5fbc:	90 e0       	ldi	r25, 0x00	; 0
    5fbe:	84 1b       	sub	r24, r20
    5fc0:	95 0b       	sbc	r25, r21
    5fc2:	cd a8       	sts	0x8d, r28
    5fc4:	de a8       	sts	0x8e, r29
    5fc6:	ef a8       	sts	0x8f, r30
    5fc8:	f8 ac       	sts	0xa8, r31
    5fca:	04 c0       	rjmp	.+8      	; 0x5fd4 <__divdi3+0x340>
    5fcc:	f6 94       	lsr	r15
    5fce:	e7 94       	ror	r14
    5fd0:	d7 94       	ror	r13
    5fd2:	c7 94       	ror	r12
    5fd4:	8a 95       	dec	r24
    5fd6:	d2 f7       	brpl	.-12     	; 0x5fcc <__divdi3+0x338>
    5fd8:	c0 2a       	or	r12, r16
    5fda:	d1 2a       	or	r13, r17
    5fdc:	e2 2a       	or	r14, r18
    5fde:	f3 2a       	or	r15, r19
    5fe0:	0d a9       	sts	0x4d, r16
    5fe2:	1e a9       	sts	0x4e, r17
    5fe4:	2f a9       	sts	0x4f, r18
    5fe6:	38 ad       	sts	0x68, r19
    5fe8:	04 c0       	rjmp	.+8      	; 0x5ff2 <__divdi3+0x35e>
    5fea:	00 0f       	add	r16, r16
    5fec:	11 1f       	adc	r17, r17
    5fee:	22 1f       	adc	r18, r18
    5ff0:	33 1f       	adc	r19, r19
    5ff2:	4a 95       	dec	r20
    5ff4:	d2 f7       	brpl	.-12     	; 0x5fea <__divdi3+0x356>
    5ff6:	0d ab       	sts	0x5d, r16
    5ff8:	1e ab       	sts	0x5e, r17
    5ffa:	2f ab       	sts	0x5f, r18
    5ffc:	38 af       	sts	0x78, r19
    5ffe:	25 01       	movw	r4, r10
    6000:	66 24       	eor	r6, r6
    6002:	77 24       	eor	r7, r7
    6004:	95 01       	movw	r18, r10
    6006:	84 01       	movw	r16, r8
    6008:	20 70       	andi	r18, 0x00	; 0
    600a:	30 70       	andi	r19, 0x00	; 0
    600c:	09 ab       	sts	0x59, r16
    600e:	1a ab       	sts	0x5a, r17
    6010:	2b ab       	sts	0x5b, r18
    6012:	3c ab       	sts	0x5c, r19
    6014:	c7 01       	movw	r24, r14
    6016:	b6 01       	movw	r22, r12
    6018:	a3 01       	movw	r20, r6
    601a:	92 01       	movw	r18, r4
    601c:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    6020:	2d a7       	lds	r18, 0x7d
    6022:	3e a7       	lds	r19, 0x7e
    6024:	4f a7       	lds	r20, 0x7f
    6026:	58 ab       	sts	0x58, r21
    6028:	69 a7       	lds	r22, 0x79
    602a:	7a a7       	lds	r23, 0x7a
    602c:	8b a7       	lds	r24, 0x7b
    602e:	9c a7       	lds	r25, 0x7c
    6030:	c7 01       	movw	r24, r14
    6032:	b6 01       	movw	r22, r12
    6034:	a3 01       	movw	r20, r6
    6036:	92 01       	movw	r18, r4
    6038:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    603c:	ca 01       	movw	r24, r20
    603e:	b9 01       	movw	r22, r18
    6040:	29 a9       	sts	0x49, r18
    6042:	3a a9       	sts	0x4a, r19
    6044:	4b a9       	sts	0x4b, r20
    6046:	5c a9       	sts	0x4c, r21
    6048:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    604c:	ab 01       	movw	r20, r22
    604e:	bc 01       	movw	r22, r24
    6050:	09 a5       	lds	r16, 0x69
    6052:	1a a5       	lds	r17, 0x6a
    6054:	2b a5       	lds	r18, 0x6b
    6056:	3c a5       	lds	r19, 0x6c
    6058:	78 01       	movw	r14, r16
    605a:	dd 24       	eor	r13, r13
    605c:	cc 24       	eor	r12, r12
    605e:	0d a9       	sts	0x4d, r16
    6060:	1e a9       	sts	0x4e, r17
    6062:	2f a9       	sts	0x4f, r18
    6064:	38 ad       	sts	0x68, r19
    6066:	c9 01       	movw	r24, r18
    6068:	aa 27       	eor	r26, r26
    606a:	bb 27       	eor	r27, r27
    606c:	c8 2a       	or	r12, r24
    606e:	d9 2a       	or	r13, r25
    6070:	ea 2a       	or	r14, r26
    6072:	fb 2a       	or	r15, r27
    6074:	0d a5       	lds	r16, 0x6d
    6076:	1e a5       	lds	r17, 0x6e
    6078:	2f a5       	lds	r18, 0x6f
    607a:	38 a9       	sts	0x48, r19
    607c:	c4 16       	cp	r12, r20
    607e:	d5 06       	cpc	r13, r21
    6080:	e6 06       	cpc	r14, r22
    6082:	f7 06       	cpc	r15, r23
    6084:	38 f5       	brcc	.+78     	; 0x60d4 <__stack+0xd5>
    6086:	01 50       	subi	r16, 0x01	; 1
    6088:	10 40       	sbci	r17, 0x00	; 0
    608a:	20 40       	sbci	r18, 0x00	; 0
    608c:	30 40       	sbci	r19, 0x00	; 0
    608e:	09 a7       	lds	r16, 0x79
    6090:	1a a7       	lds	r17, 0x7a
    6092:	2b a7       	lds	r18, 0x7b
    6094:	3c a7       	lds	r19, 0x7c
    6096:	c8 0c       	add	r12, r8
    6098:	d9 1c       	adc	r13, r9
    609a:	ea 1c       	adc	r14, r10
    609c:	fb 1c       	adc	r15, r11
    609e:	c8 14       	cp	r12, r8
    60a0:	d9 04       	cpc	r13, r9
    60a2:	ea 04       	cpc	r14, r10
    60a4:	fb 04       	cpc	r15, r11
    60a6:	d0 f0       	brcs	.+52     	; 0x60dc <__stack+0xdd>
    60a8:	c4 16       	cp	r12, r20
    60aa:	d5 06       	cpc	r13, r21
    60ac:	e6 06       	cpc	r14, r22
    60ae:	f7 06       	cpc	r15, r23
    60b0:	a8 f4       	brcc	.+42     	; 0x60dc <__stack+0xdd>
    60b2:	0d a5       	lds	r16, 0x6d
    60b4:	1e a5       	lds	r17, 0x6e
    60b6:	2f a5       	lds	r18, 0x6f
    60b8:	38 a9       	sts	0x48, r19
    60ba:	02 50       	subi	r16, 0x02	; 2
    60bc:	10 40       	sbci	r17, 0x00	; 0
    60be:	20 40       	sbci	r18, 0x00	; 0
    60c0:	30 40       	sbci	r19, 0x00	; 0
    60c2:	09 a7       	lds	r16, 0x79
    60c4:	1a a7       	lds	r17, 0x7a
    60c6:	2b a7       	lds	r18, 0x7b
    60c8:	3c a7       	lds	r19, 0x7c
    60ca:	c8 0c       	add	r12, r8
    60cc:	d9 1c       	adc	r13, r9
    60ce:	ea 1c       	adc	r14, r10
    60d0:	fb 1c       	adc	r15, r11
    60d2:	04 c0       	rjmp	.+8      	; 0x60dc <__stack+0xdd>
    60d4:	09 a7       	lds	r16, 0x79
    60d6:	1a a7       	lds	r17, 0x7a
    60d8:	2b a7       	lds	r18, 0x7b
    60da:	3c a7       	lds	r19, 0x7c
    60dc:	c4 1a       	sub	r12, r20
    60de:	d5 0a       	sbc	r13, r21
    60e0:	e6 0a       	sbc	r14, r22
    60e2:	f7 0a       	sbc	r15, r23
    60e4:	c7 01       	movw	r24, r14
    60e6:	b6 01       	movw	r22, r12
    60e8:	a3 01       	movw	r20, r6
    60ea:	92 01       	movw	r18, r4
    60ec:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    60f0:	2d a7       	lds	r18, 0x7d
    60f2:	3e a7       	lds	r19, 0x7e
    60f4:	4f a7       	lds	r20, 0x7f
    60f6:	58 ab       	sts	0x58, r21
    60f8:	69 af       	sts	0x79, r22
    60fa:	7a af       	sts	0x7a, r23
    60fc:	8b af       	sts	0x7b, r24
    60fe:	9c af       	sts	0x7c, r25
    6100:	c7 01       	movw	r24, r14
    6102:	b6 01       	movw	r22, r12
    6104:	a3 01       	movw	r20, r6
    6106:	92 01       	movw	r18, r4
    6108:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    610c:	ca 01       	movw	r24, r20
    610e:	b9 01       	movw	r22, r18
    6110:	29 a9       	sts	0x49, r18
    6112:	3a a9       	sts	0x4a, r19
    6114:	4b a9       	sts	0x4b, r20
    6116:	5c a9       	sts	0x4c, r21
    6118:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    611c:	6b 01       	movw	r12, r22
    611e:	7c 01       	movw	r14, r24
    6120:	49 ad       	sts	0x69, r20
    6122:	5a ad       	sts	0x6a, r21
    6124:	6b ad       	sts	0x6b, r22
    6126:	7c ad       	sts	0x6c, r23
    6128:	9a 01       	movw	r18, r20
    612a:	11 27       	eor	r17, r17
    612c:	00 27       	eor	r16, r16
    612e:	4d a9       	sts	0x4d, r20
    6130:	5e a9       	sts	0x4e, r21
    6132:	6f a9       	sts	0x4f, r22
    6134:	78 ad       	sts	0x68, r23
    6136:	60 70       	andi	r22, 0x00	; 0
    6138:	70 70       	andi	r23, 0x00	; 0
    613a:	04 2b       	or	r16, r20
    613c:	15 2b       	or	r17, r21
    613e:	26 2b       	or	r18, r22
    6140:	37 2b       	or	r19, r23
    6142:	8d a5       	lds	r24, 0x6d
    6144:	9e a5       	lds	r25, 0x6e
    6146:	af a5       	lds	r26, 0x6f
    6148:	b8 a9       	sts	0x48, r27
    614a:	0c 15       	cp	r16, r12
    614c:	1d 05       	cpc	r17, r13
    614e:	2e 05       	cpc	r18, r14
    6150:	3f 05       	cpc	r19, r15
    6152:	c0 f4       	brcc	.+48     	; 0x6184 <__stack+0x185>
    6154:	01 97       	sbiw	r24, 0x01	; 1
    6156:	a1 09       	sbc	r26, r1
    6158:	b1 09       	sbc	r27, r1
    615a:	08 0d       	add	r16, r8
    615c:	19 1d       	adc	r17, r9
    615e:	2a 1d       	adc	r18, r10
    6160:	3b 1d       	adc	r19, r11
    6162:	08 15       	cp	r16, r8
    6164:	19 05       	cpc	r17, r9
    6166:	2a 05       	cpc	r18, r10
    6168:	3b 05       	cpc	r19, r11
    616a:	60 f0       	brcs	.+24     	; 0x6184 <__stack+0x185>
    616c:	0c 15       	cp	r16, r12
    616e:	1d 05       	cpc	r17, r13
    6170:	2e 05       	cpc	r18, r14
    6172:	3f 05       	cpc	r19, r15
    6174:	38 f4       	brcc	.+14     	; 0x6184 <__stack+0x185>
    6176:	8d a5       	lds	r24, 0x6d
    6178:	9e a5       	lds	r25, 0x6e
    617a:	af a5       	lds	r26, 0x6f
    617c:	b8 a9       	sts	0x48, r27
    617e:	02 97       	sbiw	r24, 0x02	; 2
    6180:	a1 09       	sbc	r26, r1
    6182:	b1 09       	sbc	r27, r1
    6184:	09 a5       	lds	r16, 0x69
    6186:	1a a5       	lds	r17, 0x6a
    6188:	2b a5       	lds	r18, 0x6b
    618a:	3c a5       	lds	r19, 0x6c
    618c:	78 01       	movw	r14, r16
    618e:	dd 24       	eor	r13, r13
    6190:	cc 24       	eor	r12, r12
    6192:	c8 2a       	or	r12, r24
    6194:	d9 2a       	or	r13, r25
    6196:	ea 2a       	or	r14, r26
    6198:	fb 2a       	or	r15, r27
    619a:	b7 c4       	rjmp	.+2414   	; 0x6b0a <__stack+0xb0b>
    619c:	81 14       	cp	r8, r1
    619e:	91 04       	cpc	r9, r1
    61a0:	a1 04       	cpc	r10, r1
    61a2:	b1 04       	cpc	r11, r1
    61a4:	51 f4       	brne	.+20     	; 0x61ba <__stack+0x1bb>
    61a6:	61 e0       	ldi	r22, 0x01	; 1
    61a8:	70 e0       	ldi	r23, 0x00	; 0
    61aa:	80 e0       	ldi	r24, 0x00	; 0
    61ac:	90 e0       	ldi	r25, 0x00	; 0
    61ae:	a5 01       	movw	r20, r10
    61b0:	94 01       	movw	r18, r8
    61b2:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    61b6:	49 01       	movw	r8, r18
    61b8:	5a 01       	movw	r10, r20
    61ba:	10 e0       	ldi	r17, 0x00	; 0
    61bc:	81 16       	cp	r8, r17
    61be:	10 e0       	ldi	r17, 0x00	; 0
    61c0:	91 06       	cpc	r9, r17
    61c2:	11 e0       	ldi	r17, 0x01	; 1
    61c4:	a1 06       	cpc	r10, r17
    61c6:	10 e0       	ldi	r17, 0x00	; 0
    61c8:	b1 06       	cpc	r11, r17
    61ca:	58 f4       	brcc	.+22     	; 0x61e2 <__stack+0x1e3>
    61cc:	2f ef       	ldi	r18, 0xFF	; 255
    61ce:	82 16       	cp	r8, r18
    61d0:	91 04       	cpc	r9, r1
    61d2:	a1 04       	cpc	r10, r1
    61d4:	b1 04       	cpc	r11, r1
    61d6:	09 f0       	breq	.+2      	; 0x61da <__stack+0x1db>
    61d8:	90 f4       	brcc	.+36     	; 0x61fe <__stack+0x1ff>
    61da:	80 e0       	ldi	r24, 0x00	; 0
    61dc:	90 e0       	ldi	r25, 0x00	; 0
    61de:	dc 01       	movw	r26, r24
    61e0:	17 c0       	rjmp	.+46     	; 0x6210 <__stack+0x211>
    61e2:	30 e0       	ldi	r19, 0x00	; 0
    61e4:	83 16       	cp	r8, r19
    61e6:	30 e0       	ldi	r19, 0x00	; 0
    61e8:	93 06       	cpc	r9, r19
    61ea:	30 e0       	ldi	r19, 0x00	; 0
    61ec:	a3 06       	cpc	r10, r19
    61ee:	31 e0       	ldi	r19, 0x01	; 1
    61f0:	b3 06       	cpc	r11, r19
    61f2:	50 f4       	brcc	.+20     	; 0x6208 <__stack+0x209>
    61f4:	80 e1       	ldi	r24, 0x10	; 16
    61f6:	90 e0       	ldi	r25, 0x00	; 0
    61f8:	a0 e0       	ldi	r26, 0x00	; 0
    61fa:	b0 e0       	ldi	r27, 0x00	; 0
    61fc:	09 c0       	rjmp	.+18     	; 0x6210 <__stack+0x211>
    61fe:	88 e0       	ldi	r24, 0x08	; 8
    6200:	90 e0       	ldi	r25, 0x00	; 0
    6202:	a0 e0       	ldi	r26, 0x00	; 0
    6204:	b0 e0       	ldi	r27, 0x00	; 0
    6206:	04 c0       	rjmp	.+8      	; 0x6210 <__stack+0x211>
    6208:	88 e1       	ldi	r24, 0x18	; 24
    620a:	90 e0       	ldi	r25, 0x00	; 0
    620c:	a0 e0       	ldi	r26, 0x00	; 0
    620e:	b0 e0       	ldi	r27, 0x00	; 0
    6210:	b5 01       	movw	r22, r10
    6212:	a4 01       	movw	r20, r8
    6214:	08 2e       	mov	r0, r24
    6216:	04 c0       	rjmp	.+8      	; 0x6220 <__stack+0x221>
    6218:	76 95       	lsr	r23
    621a:	67 95       	ror	r22
    621c:	57 95       	ror	r21
    621e:	47 95       	ror	r20
    6220:	0a 94       	dec	r0
    6222:	d2 f7       	brpl	.-12     	; 0x6218 <__stack+0x219>
    6224:	fa 01       	movw	r30, r20
    6226:	e3 5f       	subi	r30, 0xF3	; 243
    6228:	ff 4d       	sbci	r31, 0xDF	; 223
    622a:	20 81       	ld	r18, Z
    622c:	ac 01       	movw	r20, r24
    622e:	bd 01       	movw	r22, r26
    6230:	42 0f       	add	r20, r18
    6232:	51 1d       	adc	r21, r1
    6234:	61 1d       	adc	r22, r1
    6236:	71 1d       	adc	r23, r1
    6238:	80 e2       	ldi	r24, 0x20	; 32
    623a:	90 e0       	ldi	r25, 0x00	; 0
    623c:	a0 e0       	ldi	r26, 0x00	; 0
    623e:	b0 e0       	ldi	r27, 0x00	; 0
    6240:	84 1b       	sub	r24, r20
    6242:	95 0b       	sbc	r25, r21
    6244:	a6 0b       	sbc	r26, r22
    6246:	b7 0b       	sbc	r27, r23
    6248:	51 f4       	brne	.+20     	; 0x625e <__stack+0x25f>
    624a:	c8 18       	sub	r12, r8
    624c:	d9 08       	sbc	r13, r9
    624e:	ea 08       	sbc	r14, r10
    6250:	fb 08       	sbc	r15, r11
    6252:	f1 e0       	ldi	r31, 0x01	; 1
    6254:	4f 2e       	mov	r4, r31
    6256:	51 2c       	mov	r5, r1
    6258:	61 2c       	mov	r6, r1
    625a:	71 2c       	mov	r7, r1
    625c:	28 c1       	rjmp	.+592    	; 0x64ae <__stack+0x4af>
    625e:	08 2e       	mov	r0, r24
    6260:	04 c0       	rjmp	.+8      	; 0x626a <__stack+0x26b>
    6262:	88 0c       	add	r8, r8
    6264:	99 1c       	adc	r9, r9
    6266:	aa 1c       	adc	r10, r10
    6268:	bb 1c       	adc	r11, r11
    626a:	0a 94       	dec	r0
    626c:	d2 f7       	brpl	.-12     	; 0x6262 <__stack+0x263>
    626e:	97 01       	movw	r18, r14
    6270:	86 01       	movw	r16, r12
    6272:	04 2e       	mov	r0, r20
    6274:	04 c0       	rjmp	.+8      	; 0x627e <__stack+0x27f>
    6276:	36 95       	lsr	r19
    6278:	27 95       	ror	r18
    627a:	17 95       	ror	r17
    627c:	07 95       	ror	r16
    627e:	0a 94       	dec	r0
    6280:	d2 f7       	brpl	.-12     	; 0x6276 <__stack+0x277>
    6282:	09 ab       	sts	0x59, r16
    6284:	1a ab       	sts	0x5a, r17
    6286:	2b ab       	sts	0x5b, r18
    6288:	3c ab       	sts	0x5c, r19
    628a:	97 01       	movw	r18, r14
    628c:	86 01       	movw	r16, r12
    628e:	08 2e       	mov	r0, r24
    6290:	04 c0       	rjmp	.+8      	; 0x629a <__stack+0x29b>
    6292:	00 0f       	add	r16, r16
    6294:	11 1f       	adc	r17, r17
    6296:	22 1f       	adc	r18, r18
    6298:	33 1f       	adc	r19, r19
    629a:	0a 94       	dec	r0
    629c:	d2 f7       	brpl	.-12     	; 0x6292 <__stack+0x293>
    629e:	0d a7       	lds	r16, 0x7d
    62a0:	1e a7       	lds	r17, 0x7e
    62a2:	2f a7       	lds	r18, 0x7f
    62a4:	38 ab       	sts	0x58, r19
    62a6:	ed a8       	sts	0x8d, r30
    62a8:	fe a8       	sts	0x8e, r31
    62aa:	0f a9       	sts	0x4f, r16
    62ac:	18 ad       	sts	0x68, r17
    62ae:	04 c0       	rjmp	.+8      	; 0x62b8 <__stack+0x2b9>
    62b0:	16 95       	lsr	r17
    62b2:	07 95       	ror	r16
    62b4:	f7 94       	ror	r15
    62b6:	e7 94       	ror	r14
    62b8:	4a 95       	dec	r20
    62ba:	d2 f7       	brpl	.-12     	; 0x62b0 <__stack+0x2b1>
    62bc:	b8 01       	movw	r22, r16
    62be:	a7 01       	movw	r20, r14
    62c0:	0d a5       	lds	r16, 0x6d
    62c2:	1e a5       	lds	r17, 0x6e
    62c4:	2f a5       	lds	r18, 0x6f
    62c6:	38 a9       	sts	0x48, r19
    62c8:	04 2b       	or	r16, r20
    62ca:	15 2b       	or	r17, r21
    62cc:	26 2b       	or	r18, r22
    62ce:	37 2b       	or	r19, r23
    62d0:	0d a7       	lds	r16, 0x7d
    62d2:	1e a7       	lds	r17, 0x7e
    62d4:	2f a7       	lds	r18, 0x7f
    62d6:	38 ab       	sts	0x58, r19
    62d8:	ed a8       	sts	0x8d, r30
    62da:	fe a8       	sts	0x8e, r31
    62dc:	0f a9       	sts	0x4f, r16
    62de:	18 ad       	sts	0x68, r17
    62e0:	04 c0       	rjmp	.+8      	; 0x62ea <__stack+0x2eb>
    62e2:	ee 0c       	add	r14, r14
    62e4:	ff 1c       	adc	r15, r15
    62e6:	00 1f       	adc	r16, r16
    62e8:	11 1f       	adc	r17, r17
    62ea:	8a 95       	dec	r24
    62ec:	d2 f7       	brpl	.-12     	; 0x62e2 <__stack+0x2e3>
    62ee:	ed aa       	sts	0x9d, r30
    62f0:	fe aa       	sts	0x9e, r31
    62f2:	0f ab       	sts	0x5f, r16
    62f4:	18 af       	sts	0x78, r17
    62f6:	25 01       	movw	r4, r10
    62f8:	66 24       	eor	r6, r6
    62fa:	77 24       	eor	r7, r7
    62fc:	95 01       	movw	r18, r10
    62fe:	84 01       	movw	r16, r8
    6300:	20 70       	andi	r18, 0x00	; 0
    6302:	30 70       	andi	r19, 0x00	; 0
    6304:	09 af       	sts	0x79, r16
    6306:	1a af       	sts	0x7a, r17
    6308:	2b af       	sts	0x7b, r18
    630a:	3c af       	sts	0x7c, r19
    630c:	69 a9       	sts	0x49, r22
    630e:	7a a9       	sts	0x4a, r23
    6310:	8b a9       	sts	0x4b, r24
    6312:	9c a9       	sts	0x4c, r25
    6314:	a3 01       	movw	r20, r6
    6316:	92 01       	movw	r18, r4
    6318:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    631c:	29 a7       	lds	r18, 0x79
    631e:	3a a7       	lds	r19, 0x7a
    6320:	4b a7       	lds	r20, 0x7b
    6322:	5c a7       	lds	r21, 0x7c
    6324:	6b 01       	movw	r12, r22
    6326:	7c 01       	movw	r14, r24
    6328:	69 a9       	sts	0x49, r22
    632a:	7a a9       	sts	0x4a, r23
    632c:	8b a9       	sts	0x4b, r24
    632e:	9c a9       	sts	0x4c, r25
    6330:	a3 01       	movw	r20, r6
    6332:	92 01       	movw	r18, r4
    6334:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    6338:	ca 01       	movw	r24, r20
    633a:	b9 01       	movw	r22, r18
    633c:	29 ad       	sts	0x69, r18
    633e:	3a ad       	sts	0x6a, r19
    6340:	4b ad       	sts	0x6b, r20
    6342:	5c ad       	sts	0x6c, r21
    6344:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6348:	ab 01       	movw	r20, r22
    634a:	bc 01       	movw	r22, r24
    634c:	76 01       	movw	r14, r12
    634e:	dd 24       	eor	r13, r13
    6350:	cc 24       	eor	r12, r12
    6352:	0d a5       	lds	r16, 0x6d
    6354:	1e a5       	lds	r17, 0x6e
    6356:	2f a5       	lds	r18, 0x6f
    6358:	38 a9       	sts	0x48, r19
    635a:	c9 01       	movw	r24, r18
    635c:	aa 27       	eor	r26, r26
    635e:	bb 27       	eor	r27, r27
    6360:	c8 2a       	or	r12, r24
    6362:	d9 2a       	or	r13, r25
    6364:	ea 2a       	or	r14, r26
    6366:	fb 2a       	or	r15, r27
    6368:	09 a5       	lds	r16, 0x69
    636a:	1a a5       	lds	r17, 0x6a
    636c:	2b a5       	lds	r18, 0x6b
    636e:	3c a5       	lds	r19, 0x6c
    6370:	c4 16       	cp	r12, r20
    6372:	d5 06       	cpc	r13, r21
    6374:	e6 06       	cpc	r14, r22
    6376:	f7 06       	cpc	r15, r23
    6378:	38 f5       	brcc	.+78     	; 0x63c8 <__stack+0x3c9>
    637a:	01 50       	subi	r16, 0x01	; 1
    637c:	10 40       	sbci	r17, 0x00	; 0
    637e:	20 40       	sbci	r18, 0x00	; 0
    6380:	30 40       	sbci	r19, 0x00	; 0
    6382:	09 ab       	sts	0x59, r16
    6384:	1a ab       	sts	0x5a, r17
    6386:	2b ab       	sts	0x5b, r18
    6388:	3c ab       	sts	0x5c, r19
    638a:	c8 0c       	add	r12, r8
    638c:	d9 1c       	adc	r13, r9
    638e:	ea 1c       	adc	r14, r10
    6390:	fb 1c       	adc	r15, r11
    6392:	c8 14       	cp	r12, r8
    6394:	d9 04       	cpc	r13, r9
    6396:	ea 04       	cpc	r14, r10
    6398:	fb 04       	cpc	r15, r11
    639a:	d0 f0       	brcs	.+52     	; 0x63d0 <__stack+0x3d1>
    639c:	c4 16       	cp	r12, r20
    639e:	d5 06       	cpc	r13, r21
    63a0:	e6 06       	cpc	r14, r22
    63a2:	f7 06       	cpc	r15, r23
    63a4:	a8 f4       	brcc	.+42     	; 0x63d0 <__stack+0x3d1>
    63a6:	09 a5       	lds	r16, 0x69
    63a8:	1a a5       	lds	r17, 0x6a
    63aa:	2b a5       	lds	r18, 0x6b
    63ac:	3c a5       	lds	r19, 0x6c
    63ae:	02 50       	subi	r16, 0x02	; 2
    63b0:	10 40       	sbci	r17, 0x00	; 0
    63b2:	20 40       	sbci	r18, 0x00	; 0
    63b4:	30 40       	sbci	r19, 0x00	; 0
    63b6:	09 ab       	sts	0x59, r16
    63b8:	1a ab       	sts	0x5a, r17
    63ba:	2b ab       	sts	0x5b, r18
    63bc:	3c ab       	sts	0x5c, r19
    63be:	c8 0c       	add	r12, r8
    63c0:	d9 1c       	adc	r13, r9
    63c2:	ea 1c       	adc	r14, r10
    63c4:	fb 1c       	adc	r15, r11
    63c6:	04 c0       	rjmp	.+8      	; 0x63d0 <__stack+0x3d1>
    63c8:	09 ab       	sts	0x59, r16
    63ca:	1a ab       	sts	0x5a, r17
    63cc:	2b ab       	sts	0x5b, r18
    63ce:	3c ab       	sts	0x5c, r19
    63d0:	c4 1a       	sub	r12, r20
    63d2:	d5 0a       	sbc	r13, r21
    63d4:	e6 0a       	sbc	r14, r22
    63d6:	f7 0a       	sbc	r15, r23
    63d8:	c7 01       	movw	r24, r14
    63da:	b6 01       	movw	r22, r12
    63dc:	a3 01       	movw	r20, r6
    63de:	92 01       	movw	r18, r4
    63e0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    63e4:	29 a7       	lds	r18, 0x79
    63e6:	3a a7       	lds	r19, 0x7a
    63e8:	4b a7       	lds	r20, 0x7b
    63ea:	5c a7       	lds	r21, 0x7c
    63ec:	21 96       	adiw	r28, 0x01	; 1
    63ee:	6c af       	sts	0x7c, r22
    63f0:	7d af       	sts	0x7d, r23
    63f2:	8e af       	sts	0x7e, r24
    63f4:	9f af       	sts	0x7f, r25
    63f6:	21 97       	sbiw	r28, 0x01	; 1
    63f8:	c7 01       	movw	r24, r14
    63fa:	b6 01       	movw	r22, r12
    63fc:	a3 01       	movw	r20, r6
    63fe:	92 01       	movw	r18, r4
    6400:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    6404:	ca 01       	movw	r24, r20
    6406:	b9 01       	movw	r22, r18
    6408:	29 ad       	sts	0x69, r18
    640a:	3a ad       	sts	0x6a, r19
    640c:	4b ad       	sts	0x6b, r20
    640e:	5c ad       	sts	0x6c, r21
    6410:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6414:	8b 01       	movw	r16, r22
    6416:	9c 01       	movw	r18, r24
    6418:	21 96       	adiw	r28, 0x01	; 1
    641a:	4c ad       	sts	0x6c, r20
    641c:	5d ad       	sts	0x6d, r21
    641e:	6e ad       	sts	0x6e, r22
    6420:	7f ad       	sts	0x6f, r23
    6422:	21 97       	sbiw	r28, 0x01	; 1
    6424:	da 01       	movw	r26, r20
    6426:	99 27       	eor	r25, r25
    6428:	88 27       	eor	r24, r24
    642a:	4d a5       	lds	r20, 0x6d
    642c:	5e a5       	lds	r21, 0x6e
    642e:	6f a5       	lds	r22, 0x6f
    6430:	78 a9       	sts	0x48, r23
    6432:	60 70       	andi	r22, 0x00	; 0
    6434:	70 70       	andi	r23, 0x00	; 0
    6436:	84 2b       	or	r24, r20
    6438:	95 2b       	or	r25, r21
    643a:	a6 2b       	or	r26, r22
    643c:	b7 2b       	or	r27, r23
    643e:	49 a5       	lds	r20, 0x69
    6440:	5a a5       	lds	r21, 0x6a
    6442:	6b a5       	lds	r22, 0x6b
    6444:	7c a5       	lds	r23, 0x6c
    6446:	80 17       	cp	r24, r16
    6448:	91 07       	cpc	r25, r17
    644a:	a2 07       	cpc	r26, r18
    644c:	b3 07       	cpc	r27, r19
    644e:	f0 f4       	brcc	.+60     	; 0x648c <__stack+0x48d>
    6450:	41 50       	subi	r20, 0x01	; 1
    6452:	50 40       	sbci	r21, 0x00	; 0
    6454:	60 40       	sbci	r22, 0x00	; 0
    6456:	70 40       	sbci	r23, 0x00	; 0
    6458:	88 0d       	add	r24, r8
    645a:	99 1d       	adc	r25, r9
    645c:	aa 1d       	adc	r26, r10
    645e:	bb 1d       	adc	r27, r11
    6460:	88 15       	cp	r24, r8
    6462:	99 05       	cpc	r25, r9
    6464:	aa 05       	cpc	r26, r10
    6466:	bb 05       	cpc	r27, r11
    6468:	88 f0       	brcs	.+34     	; 0x648c <__stack+0x48d>
    646a:	80 17       	cp	r24, r16
    646c:	91 07       	cpc	r25, r17
    646e:	a2 07       	cpc	r26, r18
    6470:	b3 07       	cpc	r27, r19
    6472:	60 f4       	brcc	.+24     	; 0x648c <__stack+0x48d>
    6474:	49 a5       	lds	r20, 0x69
    6476:	5a a5       	lds	r21, 0x6a
    6478:	6b a5       	lds	r22, 0x6b
    647a:	7c a5       	lds	r23, 0x6c
    647c:	42 50       	subi	r20, 0x02	; 2
    647e:	50 40       	sbci	r21, 0x00	; 0
    6480:	60 40       	sbci	r22, 0x00	; 0
    6482:	70 40       	sbci	r23, 0x00	; 0
    6484:	88 0d       	add	r24, r8
    6486:	99 1d       	adc	r25, r9
    6488:	aa 1d       	adc	r26, r10
    648a:	bb 1d       	adc	r27, r11
    648c:	6c 01       	movw	r12, r24
    648e:	7d 01       	movw	r14, r26
    6490:	c0 1a       	sub	r12, r16
    6492:	d1 0a       	sbc	r13, r17
    6494:	e2 0a       	sbc	r14, r18
    6496:	f3 0a       	sbc	r15, r19
    6498:	09 a9       	sts	0x49, r16
    649a:	1a a9       	sts	0x4a, r17
    649c:	2b a9       	sts	0x4b, r18
    649e:	3c a9       	sts	0x4c, r19
    64a0:	38 01       	movw	r6, r16
    64a2:	55 24       	eor	r5, r5
    64a4:	44 24       	eor	r4, r4
    64a6:	44 2a       	or	r4, r20
    64a8:	55 2a       	or	r5, r21
    64aa:	66 2a       	or	r6, r22
    64ac:	77 2a       	or	r7, r23
    64ae:	85 01       	movw	r16, r10
    64b0:	22 27       	eor	r18, r18
    64b2:	33 27       	eor	r19, r19
    64b4:	0d a7       	lds	r16, 0x7d
    64b6:	1e a7       	lds	r17, 0x7e
    64b8:	2f a7       	lds	r18, 0x7f
    64ba:	38 ab       	sts	0x58, r19
    64bc:	95 01       	movw	r18, r10
    64be:	84 01       	movw	r16, r8
    64c0:	20 70       	andi	r18, 0x00	; 0
    64c2:	30 70       	andi	r19, 0x00	; 0
    64c4:	09 af       	sts	0x79, r16
    64c6:	1a af       	sts	0x7a, r17
    64c8:	2b af       	sts	0x7b, r18
    64ca:	3c af       	sts	0x7c, r19
    64cc:	c7 01       	movw	r24, r14
    64ce:	b6 01       	movw	r22, r12
    64d0:	2d a5       	lds	r18, 0x6d
    64d2:	3e a5       	lds	r19, 0x6e
    64d4:	4f a5       	lds	r20, 0x6f
    64d6:	58 a9       	sts	0x48, r21
    64d8:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    64dc:	29 a7       	lds	r18, 0x79
    64de:	3a a7       	lds	r19, 0x7a
    64e0:	4b a7       	lds	r20, 0x7b
    64e2:	5c a7       	lds	r21, 0x7c
    64e4:	69 ab       	sts	0x59, r22
    64e6:	7a ab       	sts	0x5a, r23
    64e8:	8b ab       	sts	0x5b, r24
    64ea:	9c ab       	sts	0x5c, r25
    64ec:	c7 01       	movw	r24, r14
    64ee:	b6 01       	movw	r22, r12
    64f0:	2d a5       	lds	r18, 0x6d
    64f2:	3e a5       	lds	r19, 0x6e
    64f4:	4f a5       	lds	r20, 0x6f
    64f6:	58 a9       	sts	0x48, r21
    64f8:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    64fc:	ca 01       	movw	r24, r20
    64fe:	b9 01       	movw	r22, r18
    6500:	29 ad       	sts	0x69, r18
    6502:	3a ad       	sts	0x6a, r19
    6504:	4b ad       	sts	0x6b, r20
    6506:	5c ad       	sts	0x6c, r21
    6508:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    650c:	ab 01       	movw	r20, r22
    650e:	bc 01       	movw	r22, r24
    6510:	09 a9       	sts	0x49, r16
    6512:	1a a9       	sts	0x4a, r17
    6514:	2b a9       	sts	0x4b, r18
    6516:	3c a9       	sts	0x4c, r19
    6518:	78 01       	movw	r14, r16
    651a:	dd 24       	eor	r13, r13
    651c:	cc 24       	eor	r12, r12
    651e:	0d a9       	sts	0x4d, r16
    6520:	1e a9       	sts	0x4e, r17
    6522:	2f a9       	sts	0x4f, r18
    6524:	38 ad       	sts	0x68, r19
    6526:	c9 01       	movw	r24, r18
    6528:	aa 27       	eor	r26, r26
    652a:	bb 27       	eor	r27, r27
    652c:	c8 2a       	or	r12, r24
    652e:	d9 2a       	or	r13, r25
    6530:	ea 2a       	or	r14, r26
    6532:	fb 2a       	or	r15, r27
    6534:	09 a5       	lds	r16, 0x69
    6536:	1a a5       	lds	r17, 0x6a
    6538:	2b a5       	lds	r18, 0x6b
    653a:	3c a5       	lds	r19, 0x6c
    653c:	c4 16       	cp	r12, r20
    653e:	d5 06       	cpc	r13, r21
    6540:	e6 06       	cpc	r14, r22
    6542:	f7 06       	cpc	r15, r23
    6544:	38 f5       	brcc	.+78     	; 0x6594 <__stack+0x595>
    6546:	01 50       	subi	r16, 0x01	; 1
    6548:	10 40       	sbci	r17, 0x00	; 0
    654a:	20 40       	sbci	r18, 0x00	; 0
    654c:	30 40       	sbci	r19, 0x00	; 0
    654e:	09 ab       	sts	0x59, r16
    6550:	1a ab       	sts	0x5a, r17
    6552:	2b ab       	sts	0x5b, r18
    6554:	3c ab       	sts	0x5c, r19
    6556:	c8 0c       	add	r12, r8
    6558:	d9 1c       	adc	r13, r9
    655a:	ea 1c       	adc	r14, r10
    655c:	fb 1c       	adc	r15, r11
    655e:	c8 14       	cp	r12, r8
    6560:	d9 04       	cpc	r13, r9
    6562:	ea 04       	cpc	r14, r10
    6564:	fb 04       	cpc	r15, r11
    6566:	d0 f0       	brcs	.+52     	; 0x659c <__stack+0x59d>
    6568:	c4 16       	cp	r12, r20
    656a:	d5 06       	cpc	r13, r21
    656c:	e6 06       	cpc	r14, r22
    656e:	f7 06       	cpc	r15, r23
    6570:	a8 f4       	brcc	.+42     	; 0x659c <__stack+0x59d>
    6572:	09 a5       	lds	r16, 0x69
    6574:	1a a5       	lds	r17, 0x6a
    6576:	2b a5       	lds	r18, 0x6b
    6578:	3c a5       	lds	r19, 0x6c
    657a:	02 50       	subi	r16, 0x02	; 2
    657c:	10 40       	sbci	r17, 0x00	; 0
    657e:	20 40       	sbci	r18, 0x00	; 0
    6580:	30 40       	sbci	r19, 0x00	; 0
    6582:	09 ab       	sts	0x59, r16
    6584:	1a ab       	sts	0x5a, r17
    6586:	2b ab       	sts	0x5b, r18
    6588:	3c ab       	sts	0x5c, r19
    658a:	c8 0c       	add	r12, r8
    658c:	d9 1c       	adc	r13, r9
    658e:	ea 1c       	adc	r14, r10
    6590:	fb 1c       	adc	r15, r11
    6592:	04 c0       	rjmp	.+8      	; 0x659c <__stack+0x59d>
    6594:	09 ab       	sts	0x59, r16
    6596:	1a ab       	sts	0x5a, r17
    6598:	2b ab       	sts	0x5b, r18
    659a:	3c ab       	sts	0x5c, r19
    659c:	c4 1a       	sub	r12, r20
    659e:	d5 0a       	sbc	r13, r21
    65a0:	e6 0a       	sbc	r14, r22
    65a2:	f7 0a       	sbc	r15, r23
    65a4:	c7 01       	movw	r24, r14
    65a6:	b6 01       	movw	r22, r12
    65a8:	2d a5       	lds	r18, 0x6d
    65aa:	3e a5       	lds	r19, 0x6e
    65ac:	4f a5       	lds	r20, 0x6f
    65ae:	58 a9       	sts	0x48, r21
    65b0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    65b4:	29 a7       	lds	r18, 0x79
    65b6:	3a a7       	lds	r19, 0x7a
    65b8:	4b a7       	lds	r20, 0x7b
    65ba:	5c a7       	lds	r21, 0x7c
    65bc:	21 96       	adiw	r28, 0x01	; 1
    65be:	6c af       	sts	0x7c, r22
    65c0:	7d af       	sts	0x7d, r23
    65c2:	8e af       	sts	0x7e, r24
    65c4:	9f af       	sts	0x7f, r25
    65c6:	21 97       	sbiw	r28, 0x01	; 1
    65c8:	c7 01       	movw	r24, r14
    65ca:	b6 01       	movw	r22, r12
    65cc:	2d a5       	lds	r18, 0x6d
    65ce:	3e a5       	lds	r19, 0x6e
    65d0:	4f a5       	lds	r20, 0x6f
    65d2:	58 a9       	sts	0x48, r21
    65d4:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    65d8:	ca 01       	movw	r24, r20
    65da:	b9 01       	movw	r22, r18
    65dc:	29 ad       	sts	0x69, r18
    65de:	3a ad       	sts	0x6a, r19
    65e0:	4b ad       	sts	0x6b, r20
    65e2:	5c ad       	sts	0x6c, r21
    65e4:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    65e8:	8b 01       	movw	r16, r22
    65ea:	9c 01       	movw	r18, r24
    65ec:	21 96       	adiw	r28, 0x01	; 1
    65ee:	4c ad       	sts	0x6c, r20
    65f0:	5d ad       	sts	0x6d, r21
    65f2:	6e ad       	sts	0x6e, r22
    65f4:	7f ad       	sts	0x6f, r23
    65f6:	21 97       	sbiw	r28, 0x01	; 1
    65f8:	da 01       	movw	r26, r20
    65fa:	99 27       	eor	r25, r25
    65fc:	88 27       	eor	r24, r24
    65fe:	4d a9       	sts	0x4d, r20
    6600:	5e a9       	sts	0x4e, r21
    6602:	6f a9       	sts	0x4f, r22
    6604:	78 ad       	sts	0x68, r23
    6606:	60 70       	andi	r22, 0x00	; 0
    6608:	70 70       	andi	r23, 0x00	; 0
    660a:	84 2b       	or	r24, r20
    660c:	95 2b       	or	r25, r21
    660e:	a6 2b       	or	r26, r22
    6610:	b7 2b       	or	r27, r23
    6612:	49 a5       	lds	r20, 0x69
    6614:	5a a5       	lds	r21, 0x6a
    6616:	6b a5       	lds	r22, 0x6b
    6618:	7c a5       	lds	r23, 0x6c
    661a:	80 17       	cp	r24, r16
    661c:	91 07       	cpc	r25, r17
    661e:	a2 07       	cpc	r26, r18
    6620:	b3 07       	cpc	r27, r19
    6622:	d0 f4       	brcc	.+52     	; 0x6658 <__stack+0x659>
    6624:	41 50       	subi	r20, 0x01	; 1
    6626:	50 40       	sbci	r21, 0x00	; 0
    6628:	60 40       	sbci	r22, 0x00	; 0
    662a:	70 40       	sbci	r23, 0x00	; 0
    662c:	88 0d       	add	r24, r8
    662e:	99 1d       	adc	r25, r9
    6630:	aa 1d       	adc	r26, r10
    6632:	bb 1d       	adc	r27, r11
    6634:	88 15       	cp	r24, r8
    6636:	99 05       	cpc	r25, r9
    6638:	aa 05       	cpc	r26, r10
    663a:	bb 05       	cpc	r27, r11
    663c:	68 f0       	brcs	.+26     	; 0x6658 <__stack+0x659>
    663e:	80 17       	cp	r24, r16
    6640:	91 07       	cpc	r25, r17
    6642:	a2 07       	cpc	r26, r18
    6644:	b3 07       	cpc	r27, r19
    6646:	40 f4       	brcc	.+16     	; 0x6658 <__stack+0x659>
    6648:	49 a5       	lds	r20, 0x69
    664a:	5a a5       	lds	r21, 0x6a
    664c:	6b a5       	lds	r22, 0x6b
    664e:	7c a5       	lds	r23, 0x6c
    6650:	42 50       	subi	r20, 0x02	; 2
    6652:	50 40       	sbci	r21, 0x00	; 0
    6654:	60 40       	sbci	r22, 0x00	; 0
    6656:	70 40       	sbci	r23, 0x00	; 0
    6658:	09 a9       	sts	0x49, r16
    665a:	1a a9       	sts	0x4a, r17
    665c:	2b a9       	sts	0x4b, r18
    665e:	3c a9       	sts	0x4c, r19
    6660:	78 01       	movw	r14, r16
    6662:	dd 24       	eor	r13, r13
    6664:	cc 24       	eor	r12, r12
    6666:	c4 2a       	or	r12, r20
    6668:	d5 2a       	or	r13, r21
    666a:	e6 2a       	or	r14, r22
    666c:	f7 2a       	or	r15, r23
    666e:	50 c2       	rjmp	.+1184   	; 0x6b10 <__stack+0xb11>
    6670:	c8 16       	cp	r12, r24
    6672:	d9 06       	cpc	r13, r25
    6674:	ea 06       	cpc	r14, r26
    6676:	fb 06       	cpc	r15, r27
    6678:	08 f4       	brcc	.+2      	; 0x667c <__stack+0x67d>
    667a:	37 c2       	rjmp	.+1134   	; 0x6aea <__stack+0xaeb>
    667c:	80 30       	cpi	r24, 0x00	; 0
    667e:	10 e0       	ldi	r17, 0x00	; 0
    6680:	91 07       	cpc	r25, r17
    6682:	11 e0       	ldi	r17, 0x01	; 1
    6684:	a1 07       	cpc	r26, r17
    6686:	10 e0       	ldi	r17, 0x00	; 0
    6688:	b1 07       	cpc	r27, r17
    668a:	50 f4       	brcc	.+20     	; 0x66a0 <__stack+0x6a1>
    668c:	8f 3f       	cpi	r24, 0xFF	; 255
    668e:	91 05       	cpc	r25, r1
    6690:	a1 05       	cpc	r26, r1
    6692:	b1 05       	cpc	r27, r1
    6694:	09 f0       	breq	.+2      	; 0x6698 <__stack+0x699>
    6696:	88 f4       	brcc	.+34     	; 0x66ba <__stack+0x6bb>
    6698:	00 e0       	ldi	r16, 0x00	; 0
    669a:	10 e0       	ldi	r17, 0x00	; 0
    669c:	98 01       	movw	r18, r16
    669e:	16 c0       	rjmp	.+44     	; 0x66cc <__stack+0x6cd>
    66a0:	80 30       	cpi	r24, 0x00	; 0
    66a2:	20 e0       	ldi	r18, 0x00	; 0
    66a4:	92 07       	cpc	r25, r18
    66a6:	20 e0       	ldi	r18, 0x00	; 0
    66a8:	a2 07       	cpc	r26, r18
    66aa:	21 e0       	ldi	r18, 0x01	; 1
    66ac:	b2 07       	cpc	r27, r18
    66ae:	50 f4       	brcc	.+20     	; 0x66c4 <__stack+0x6c5>
    66b0:	00 e1       	ldi	r16, 0x10	; 16
    66b2:	10 e0       	ldi	r17, 0x00	; 0
    66b4:	20 e0       	ldi	r18, 0x00	; 0
    66b6:	30 e0       	ldi	r19, 0x00	; 0
    66b8:	09 c0       	rjmp	.+18     	; 0x66cc <__stack+0x6cd>
    66ba:	08 e0       	ldi	r16, 0x08	; 8
    66bc:	10 e0       	ldi	r17, 0x00	; 0
    66be:	20 e0       	ldi	r18, 0x00	; 0
    66c0:	30 e0       	ldi	r19, 0x00	; 0
    66c2:	04 c0       	rjmp	.+8      	; 0x66cc <__stack+0x6cd>
    66c4:	08 e1       	ldi	r16, 0x18	; 24
    66c6:	10 e0       	ldi	r17, 0x00	; 0
    66c8:	20 e0       	ldi	r18, 0x00	; 0
    66ca:	30 e0       	ldi	r19, 0x00	; 0
    66cc:	ac 01       	movw	r20, r24
    66ce:	bd 01       	movw	r22, r26
    66d0:	00 2e       	mov	r0, r16
    66d2:	04 c0       	rjmp	.+8      	; 0x66dc <__stack+0x6dd>
    66d4:	76 95       	lsr	r23
    66d6:	67 95       	ror	r22
    66d8:	57 95       	ror	r21
    66da:	47 95       	ror	r20
    66dc:	0a 94       	dec	r0
    66de:	d2 f7       	brpl	.-12     	; 0x66d4 <__stack+0x6d5>
    66e0:	fa 01       	movw	r30, r20
    66e2:	e3 5f       	subi	r30, 0xF3	; 243
    66e4:	ff 4d       	sbci	r31, 0xDF	; 223
    66e6:	40 81       	ld	r20, Z
    66e8:	04 0f       	add	r16, r20
    66ea:	11 1d       	adc	r17, r1
    66ec:	21 1d       	adc	r18, r1
    66ee:	31 1d       	adc	r19, r1
    66f0:	40 e2       	ldi	r20, 0x20	; 32
    66f2:	50 e0       	ldi	r21, 0x00	; 0
    66f4:	60 e0       	ldi	r22, 0x00	; 0
    66f6:	70 e0       	ldi	r23, 0x00	; 0
    66f8:	40 1b       	sub	r20, r16
    66fa:	51 0b       	sbc	r21, r17
    66fc:	62 0b       	sbc	r22, r18
    66fe:	73 0b       	sbc	r23, r19
    6700:	a1 f4       	brne	.+40     	; 0x672a <__stack+0x72b>
    6702:	8c 15       	cp	r24, r12
    6704:	9d 05       	cpc	r25, r13
    6706:	ae 05       	cpc	r26, r14
    6708:	bf 05       	cpc	r27, r15
    670a:	08 f4       	brcc	.+2      	; 0x670e <__stack+0x70f>
    670c:	f5 c1       	rjmp	.+1002   	; 0x6af8 <__stack+0xaf9>
    670e:	ed a8       	sts	0x8d, r30
    6710:	fe a8       	sts	0x8e, r31
    6712:	0f a9       	sts	0x4f, r16
    6714:	18 ad       	sts	0x68, r17
    6716:	44 24       	eor	r4, r4
    6718:	55 24       	eor	r5, r5
    671a:	32 01       	movw	r6, r4
    671c:	e8 14       	cp	r14, r8
    671e:	f9 04       	cpc	r15, r9
    6720:	0a 05       	cpc	r16, r10
    6722:	1b 05       	cpc	r17, r11
    6724:	08 f0       	brcs	.+2      	; 0x6728 <__stack+0x729>
    6726:	eb c1       	rjmp	.+982    	; 0x6afe <__stack+0xaff>
    6728:	e3 c1       	rjmp	.+966    	; 0x6af0 <__stack+0xaf1>
    672a:	34 2e       	mov	r3, r20
    672c:	2c 01       	movw	r4, r24
    672e:	3d 01       	movw	r6, r26
    6730:	04 c0       	rjmp	.+8      	; 0x673a <__stack+0x73b>
    6732:	44 0c       	add	r4, r4
    6734:	55 1c       	adc	r5, r5
    6736:	66 1c       	adc	r6, r6
    6738:	77 1c       	adc	r7, r7
    673a:	4a 95       	dec	r20
    673c:	d2 f7       	brpl	.-12     	; 0x6732 <__stack+0x733>
    673e:	d5 01       	movw	r26, r10
    6740:	c4 01       	movw	r24, r8
    6742:	00 2e       	mov	r0, r16
    6744:	04 c0       	rjmp	.+8      	; 0x674e <__stack+0x74f>
    6746:	b6 95       	lsr	r27
    6748:	a7 95       	ror	r26
    674a:	97 95       	ror	r25
    674c:	87 95       	ror	r24
    674e:	0a 94       	dec	r0
    6750:	d2 f7       	brpl	.-12     	; 0x6746 <__stack+0x747>
    6752:	48 2a       	or	r4, r24
    6754:	59 2a       	or	r5, r25
    6756:	6a 2a       	or	r6, r26
    6758:	7b 2a       	or	r7, r27
    675a:	a5 01       	movw	r20, r10
    675c:	94 01       	movw	r18, r8
    675e:	03 2c       	mov	r0, r3
    6760:	04 c0       	rjmp	.+8      	; 0x676a <__stack+0x76b>
    6762:	22 0f       	add	r18, r18
    6764:	33 1f       	adc	r19, r19
    6766:	44 1f       	adc	r20, r20
    6768:	55 1f       	adc	r21, r21
    676a:	0a 94       	dec	r0
    676c:	d2 f7       	brpl	.-12     	; 0x6762 <__stack+0x763>
    676e:	29 af       	sts	0x79, r18
    6770:	3a af       	sts	0x7a, r19
    6772:	4b af       	sts	0x7b, r20
    6774:	5c af       	sts	0x7c, r21
    6776:	b7 01       	movw	r22, r14
    6778:	a6 01       	movw	r20, r12
    677a:	00 2e       	mov	r0, r16
    677c:	04 c0       	rjmp	.+8      	; 0x6786 <__stack+0x787>
    677e:	76 95       	lsr	r23
    6780:	67 95       	ror	r22
    6782:	57 95       	ror	r21
    6784:	47 95       	ror	r20
    6786:	0a 94       	dec	r0
    6788:	d2 f7       	brpl	.-12     	; 0x677e <__stack+0x77f>
    678a:	49 ab       	sts	0x59, r20
    678c:	5a ab       	sts	0x5a, r21
    678e:	6b ab       	sts	0x5b, r22
    6790:	7c ab       	sts	0x5c, r23
    6792:	c7 01       	movw	r24, r14
    6794:	b6 01       	movw	r22, r12
    6796:	03 2c       	mov	r0, r3
    6798:	04 c0       	rjmp	.+8      	; 0x67a2 <__stack+0x7a3>
    679a:	66 0f       	add	r22, r22
    679c:	77 1f       	adc	r23, r23
    679e:	88 1f       	adc	r24, r24
    67a0:	99 1f       	adc	r25, r25
    67a2:	0a 94       	dec	r0
    67a4:	d2 f7       	brpl	.-12     	; 0x679a <__stack+0x79b>
    67a6:	6d a7       	lds	r22, 0x7d
    67a8:	7e a7       	lds	r23, 0x7e
    67aa:	8f a7       	lds	r24, 0x7f
    67ac:	98 ab       	sts	0x58, r25
    67ae:	8d a9       	sts	0x4d, r24
    67b0:	9e a9       	sts	0x4e, r25
    67b2:	af a9       	sts	0x4f, r26
    67b4:	b8 ad       	sts	0x68, r27
    67b6:	04 c0       	rjmp	.+8      	; 0x67c0 <__stack+0x7c1>
    67b8:	b6 95       	lsr	r27
    67ba:	a7 95       	ror	r26
    67bc:	97 95       	ror	r25
    67be:	87 95       	ror	r24
    67c0:	0a 95       	dec	r16
    67c2:	d2 f7       	brpl	.-12     	; 0x67b8 <__stack+0x7b9>
    67c4:	4d a5       	lds	r20, 0x6d
    67c6:	5e a5       	lds	r21, 0x6e
    67c8:	6f a5       	lds	r22, 0x6f
    67ca:	78 a9       	sts	0x48, r23
    67cc:	48 2b       	or	r20, r24
    67ce:	59 2b       	or	r21, r25
    67d0:	6a 2b       	or	r22, r26
    67d2:	7b 2b       	or	r23, r27
    67d4:	4d a7       	lds	r20, 0x7d
    67d6:	5e a7       	lds	r21, 0x7e
    67d8:	6f a7       	lds	r22, 0x7f
    67da:	78 ab       	sts	0x58, r23
    67dc:	43 01       	movw	r8, r6
    67de:	aa 24       	eor	r10, r10
    67e0:	bb 24       	eor	r11, r11
    67e2:	93 01       	movw	r18, r6
    67e4:	82 01       	movw	r16, r4
    67e6:	20 70       	andi	r18, 0x00	; 0
    67e8:	30 70       	andi	r19, 0x00	; 0
    67ea:	21 96       	adiw	r28, 0x01	; 1
    67ec:	0c af       	sts	0x7c, r16
    67ee:	1d af       	sts	0x7d, r17
    67f0:	2e af       	sts	0x7e, r18
    67f2:	3f af       	sts	0x7f, r19
    67f4:	21 97       	sbiw	r28, 0x01	; 1
    67f6:	69 a9       	sts	0x49, r22
    67f8:	7a a9       	sts	0x4a, r23
    67fa:	8b a9       	sts	0x4b, r24
    67fc:	9c a9       	sts	0x4c, r25
    67fe:	a5 01       	movw	r20, r10
    6800:	94 01       	movw	r18, r8
    6802:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    6806:	29 a7       	lds	r18, 0x79
    6808:	3a a7       	lds	r19, 0x7a
    680a:	4b a7       	lds	r20, 0x7b
    680c:	5c a7       	lds	r21, 0x7c
    680e:	6b 01       	movw	r12, r22
    6810:	7c 01       	movw	r14, r24
    6812:	69 a9       	sts	0x49, r22
    6814:	7a a9       	sts	0x4a, r23
    6816:	8b a9       	sts	0x4b, r24
    6818:	9c a9       	sts	0x4c, r25
    681a:	a5 01       	movw	r20, r10
    681c:	94 01       	movw	r18, r8
    681e:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    6822:	ca 01       	movw	r24, r20
    6824:	b9 01       	movw	r22, r18
    6826:	21 96       	adiw	r28, 0x01	; 1
    6828:	2c ad       	sts	0x6c, r18
    682a:	3d ad       	sts	0x6d, r19
    682c:	4e ad       	sts	0x6e, r20
    682e:	5f ad       	sts	0x6f, r21
    6830:	21 97       	sbiw	r28, 0x01	; 1
    6832:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6836:	dc 01       	movw	r26, r24
    6838:	cb 01       	movw	r24, r22
    683a:	76 01       	movw	r14, r12
    683c:	dd 24       	eor	r13, r13
    683e:	cc 24       	eor	r12, r12
    6840:	0d a5       	lds	r16, 0x6d
    6842:	1e a5       	lds	r17, 0x6e
    6844:	2f a5       	lds	r18, 0x6f
    6846:	38 a9       	sts	0x48, r19
    6848:	a9 01       	movw	r20, r18
    684a:	66 27       	eor	r22, r22
    684c:	77 27       	eor	r23, r23
    684e:	c4 2a       	or	r12, r20
    6850:	d5 2a       	or	r13, r21
    6852:	e6 2a       	or	r14, r22
    6854:	f7 2a       	or	r15, r23
    6856:	09 a5       	lds	r16, 0x69
    6858:	1a a5       	lds	r17, 0x6a
    685a:	2b a5       	lds	r18, 0x6b
    685c:	3c a5       	lds	r19, 0x6c
    685e:	c8 16       	cp	r12, r24
    6860:	d9 06       	cpc	r13, r25
    6862:	ea 06       	cpc	r14, r26
    6864:	fb 06       	cpc	r15, r27
    6866:	38 f5       	brcc	.+78     	; 0x68b6 <__stack+0x8b7>
    6868:	01 50       	subi	r16, 0x01	; 1
    686a:	10 40       	sbci	r17, 0x00	; 0
    686c:	20 40       	sbci	r18, 0x00	; 0
    686e:	30 40       	sbci	r19, 0x00	; 0
    6870:	09 ab       	sts	0x59, r16
    6872:	1a ab       	sts	0x5a, r17
    6874:	2b ab       	sts	0x5b, r18
    6876:	3c ab       	sts	0x5c, r19
    6878:	c4 0c       	add	r12, r4
    687a:	d5 1c       	adc	r13, r5
    687c:	e6 1c       	adc	r14, r6
    687e:	f7 1c       	adc	r15, r7
    6880:	c4 14       	cp	r12, r4
    6882:	d5 04       	cpc	r13, r5
    6884:	e6 04       	cpc	r14, r6
    6886:	f7 04       	cpc	r15, r7
    6888:	d0 f0       	brcs	.+52     	; 0x68be <__stack+0x8bf>
    688a:	c8 16       	cp	r12, r24
    688c:	d9 06       	cpc	r13, r25
    688e:	ea 06       	cpc	r14, r26
    6890:	fb 06       	cpc	r15, r27
    6892:	a8 f4       	brcc	.+42     	; 0x68be <__stack+0x8bf>
    6894:	09 a5       	lds	r16, 0x69
    6896:	1a a5       	lds	r17, 0x6a
    6898:	2b a5       	lds	r18, 0x6b
    689a:	3c a5       	lds	r19, 0x6c
    689c:	02 50       	subi	r16, 0x02	; 2
    689e:	10 40       	sbci	r17, 0x00	; 0
    68a0:	20 40       	sbci	r18, 0x00	; 0
    68a2:	30 40       	sbci	r19, 0x00	; 0
    68a4:	09 ab       	sts	0x59, r16
    68a6:	1a ab       	sts	0x5a, r17
    68a8:	2b ab       	sts	0x5b, r18
    68aa:	3c ab       	sts	0x5c, r19
    68ac:	c4 0c       	add	r12, r4
    68ae:	d5 1c       	adc	r13, r5
    68b0:	e6 1c       	adc	r14, r6
    68b2:	f7 1c       	adc	r15, r7
    68b4:	04 c0       	rjmp	.+8      	; 0x68be <__stack+0x8bf>
    68b6:	09 ab       	sts	0x59, r16
    68b8:	1a ab       	sts	0x5a, r17
    68ba:	2b ab       	sts	0x5b, r18
    68bc:	3c ab       	sts	0x5c, r19
    68be:	c8 1a       	sub	r12, r24
    68c0:	d9 0a       	sbc	r13, r25
    68c2:	ea 0a       	sbc	r14, r26
    68c4:	fb 0a       	sbc	r15, r27
    68c6:	c7 01       	movw	r24, r14
    68c8:	b6 01       	movw	r22, r12
    68ca:	a5 01       	movw	r20, r10
    68cc:	94 01       	movw	r18, r8
    68ce:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    68d2:	29 a7       	lds	r18, 0x79
    68d4:	3a a7       	lds	r19, 0x7a
    68d6:	4b a7       	lds	r20, 0x7b
    68d8:	5c a7       	lds	r21, 0x7c
    68da:	29 96       	adiw	r28, 0x09	; 9
    68dc:	6c af       	sts	0x7c, r22
    68de:	7d af       	sts	0x7d, r23
    68e0:	8e af       	sts	0x7e, r24
    68e2:	9f af       	sts	0x7f, r25
    68e4:	29 97       	sbiw	r28, 0x09	; 9
    68e6:	c7 01       	movw	r24, r14
    68e8:	b6 01       	movw	r22, r12
    68ea:	a5 01       	movw	r20, r10
    68ec:	94 01       	movw	r18, r8
    68ee:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodsi4>
    68f2:	ca 01       	movw	r24, r20
    68f4:	b9 01       	movw	r22, r18
    68f6:	21 96       	adiw	r28, 0x01	; 1
    68f8:	2c ad       	sts	0x6c, r18
    68fa:	3d ad       	sts	0x6d, r19
    68fc:	4e ad       	sts	0x6e, r20
    68fe:	5f ad       	sts	0x6f, r21
    6900:	21 97       	sbiw	r28, 0x01	; 1
    6902:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6906:	4b 01       	movw	r8, r22
    6908:	5c 01       	movw	r10, r24
    690a:	29 96       	adiw	r28, 0x09	; 9
    690c:	4c ad       	sts	0x6c, r20
    690e:	5d ad       	sts	0x6d, r21
    6910:	6e ad       	sts	0x6e, r22
    6912:	7f ad       	sts	0x6f, r23
    6914:	29 97       	sbiw	r28, 0x09	; 9
    6916:	9a 01       	movw	r18, r20
    6918:	11 27       	eor	r17, r17
    691a:	00 27       	eor	r16, r16
    691c:	8d a5       	lds	r24, 0x6d
    691e:	9e a5       	lds	r25, 0x6e
    6920:	af a5       	lds	r26, 0x6f
    6922:	b8 a9       	sts	0x48, r27
    6924:	a0 70       	andi	r26, 0x00	; 0
    6926:	b0 70       	andi	r27, 0x00	; 0
    6928:	08 2b       	or	r16, r24
    692a:	19 2b       	or	r17, r25
    692c:	2a 2b       	or	r18, r26
    692e:	3b 2b       	or	r19, r27
    6930:	89 a5       	lds	r24, 0x69
    6932:	9a a5       	lds	r25, 0x6a
    6934:	ab a5       	lds	r26, 0x6b
    6936:	bc a5       	lds	r27, 0x6c
    6938:	08 15       	cp	r16, r8
    693a:	19 05       	cpc	r17, r9
    693c:	2a 05       	cpc	r18, r10
    693e:	3b 05       	cpc	r19, r11
    6940:	e0 f4       	brcc	.+56     	; 0x697a <__stack+0x97b>
    6942:	01 97       	sbiw	r24, 0x01	; 1
    6944:	a1 09       	sbc	r26, r1
    6946:	b1 09       	sbc	r27, r1
    6948:	04 0d       	add	r16, r4
    694a:	15 1d       	adc	r17, r5
    694c:	26 1d       	adc	r18, r6
    694e:	37 1d       	adc	r19, r7
    6950:	04 15       	cp	r16, r4
    6952:	15 05       	cpc	r17, r5
    6954:	26 05       	cpc	r18, r6
    6956:	37 05       	cpc	r19, r7
    6958:	80 f0       	brcs	.+32     	; 0x697a <__stack+0x97b>
    695a:	08 15       	cp	r16, r8
    695c:	19 05       	cpc	r17, r9
    695e:	2a 05       	cpc	r18, r10
    6960:	3b 05       	cpc	r19, r11
    6962:	58 f4       	brcc	.+22     	; 0x697a <__stack+0x97b>
    6964:	89 a5       	lds	r24, 0x69
    6966:	9a a5       	lds	r25, 0x6a
    6968:	ab a5       	lds	r26, 0x6b
    696a:	bc a5       	lds	r27, 0x6c
    696c:	02 97       	sbiw	r24, 0x02	; 2
    696e:	a1 09       	sbc	r26, r1
    6970:	b1 09       	sbc	r27, r1
    6972:	04 0d       	add	r16, r4
    6974:	15 1d       	adc	r17, r5
    6976:	26 1d       	adc	r18, r6
    6978:	37 1d       	adc	r19, r7
    697a:	b9 01       	movw	r22, r18
    697c:	a8 01       	movw	r20, r16
    697e:	48 19       	sub	r20, r8
    6980:	59 09       	sbc	r21, r9
    6982:	6a 09       	sbc	r22, r10
    6984:	7b 09       	sbc	r23, r11
    6986:	4d a7       	lds	r20, 0x7d
    6988:	5e a7       	lds	r21, 0x7e
    698a:	6f a7       	lds	r22, 0x7f
    698c:	78 ab       	sts	0x58, r23
    698e:	09 a9       	sts	0x49, r16
    6990:	1a a9       	sts	0x4a, r17
    6992:	2b a9       	sts	0x4b, r18
    6994:	3c a9       	sts	0x4c, r19
    6996:	78 01       	movw	r14, r16
    6998:	dd 24       	eor	r13, r13
    699a:	cc 24       	eor	r12, r12
    699c:	c8 2a       	or	r12, r24
    699e:	d9 2a       	or	r13, r25
    69a0:	ea 2a       	or	r14, r26
    69a2:	fb 2a       	or	r15, r27
    69a4:	ff ef       	ldi	r31, 0xFF	; 255
    69a6:	8f 2e       	mov	r8, r31
    69a8:	ff ef       	ldi	r31, 0xFF	; 255
    69aa:	9f 2e       	mov	r9, r31
    69ac:	a1 2c       	mov	r10, r1
    69ae:	b1 2c       	mov	r11, r1
    69b0:	8c 20       	and	r8, r12
    69b2:	9d 20       	and	r9, r13
    69b4:	ae 20       	and	r10, r14
    69b6:	bf 20       	and	r11, r15
    69b8:	87 01       	movw	r16, r14
    69ba:	22 27       	eor	r18, r18
    69bc:	33 27       	eor	r19, r19
    69be:	09 a7       	lds	r16, 0x79
    69c0:	1a a7       	lds	r17, 0x7a
    69c2:	2b a7       	lds	r18, 0x7b
    69c4:	3c a7       	lds	r19, 0x7c
    69c6:	49 ac       	sts	0xa9, r20
    69c8:	5a ac       	sts	0xaa, r21
    69ca:	6b ac       	sts	0xab, r22
    69cc:	7c ac       	sts	0xac, r23
    69ce:	2f ef       	ldi	r18, 0xFF	; 255
    69d0:	3f ef       	ldi	r19, 0xFF	; 255
    69d2:	40 e0       	ldi	r20, 0x00	; 0
    69d4:	50 e0       	ldi	r21, 0x00	; 0
    69d6:	42 22       	and	r4, r18
    69d8:	53 22       	and	r5, r19
    69da:	64 22       	and	r6, r20
    69dc:	75 22       	and	r7, r21
    69de:	29 ad       	sts	0x69, r18
    69e0:	3a ad       	sts	0x6a, r19
    69e2:	4b ad       	sts	0x6b, r20
    69e4:	5c ad       	sts	0x6c, r21
    69e6:	8a 01       	movw	r16, r20
    69e8:	22 27       	eor	r18, r18
    69ea:	33 27       	eor	r19, r19
    69ec:	09 ab       	sts	0x59, r16
    69ee:	1a ab       	sts	0x5a, r17
    69f0:	2b ab       	sts	0x5b, r18
    69f2:	3c ab       	sts	0x5c, r19
    69f4:	c5 01       	movw	r24, r10
    69f6:	b4 01       	movw	r22, r8
    69f8:	a3 01       	movw	r20, r6
    69fa:	92 01       	movw	r18, r4
    69fc:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6a00:	69 af       	sts	0x79, r22
    6a02:	7a af       	sts	0x7a, r23
    6a04:	8b af       	sts	0x7b, r24
    6a06:	9c af       	sts	0x7c, r25
    6a08:	c5 01       	movw	r24, r10
    6a0a:	b4 01       	movw	r22, r8
    6a0c:	29 a9       	sts	0x49, r18
    6a0e:	3a a9       	sts	0x4a, r19
    6a10:	4b a9       	sts	0x4b, r20
    6a12:	5c a9       	sts	0x4c, r21
    6a14:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6a18:	4b 01       	movw	r8, r22
    6a1a:	5c 01       	movw	r10, r24
    6a1c:	69 a5       	lds	r22, 0x69
    6a1e:	7a a5       	lds	r23, 0x6a
    6a20:	8b a5       	lds	r24, 0x6b
    6a22:	9c a5       	lds	r25, 0x6c
    6a24:	a3 01       	movw	r20, r6
    6a26:	92 01       	movw	r18, r4
    6a28:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6a2c:	2b 01       	movw	r4, r22
    6a2e:	3c 01       	movw	r6, r24
    6a30:	69 a5       	lds	r22, 0x69
    6a32:	7a a5       	lds	r23, 0x6a
    6a34:	8b a5       	lds	r24, 0x6b
    6a36:	9c a5       	lds	r25, 0x6c
    6a38:	29 a9       	sts	0x49, r18
    6a3a:	3a a9       	sts	0x4a, r19
    6a3c:	4b a9       	sts	0x4b, r20
    6a3e:	5c a9       	sts	0x4c, r21
    6a40:	0e 94 b5 37 	call	0x6f6a	; 0x6f6a <__mulsi3>
    6a44:	ab 01       	movw	r20, r22
    6a46:	bc 01       	movw	r22, r24
    6a48:	84 0c       	add	r8, r4
    6a4a:	95 1c       	adc	r9, r5
    6a4c:	a6 1c       	adc	r10, r6
    6a4e:	b7 1c       	adc	r11, r7
    6a50:	09 ad       	sts	0x69, r16
    6a52:	1a ad       	sts	0x6a, r17
    6a54:	2b ad       	sts	0x6b, r18
    6a56:	3c ad       	sts	0x6c, r19
    6a58:	c9 01       	movw	r24, r18
    6a5a:	aa 27       	eor	r26, r26
    6a5c:	bb 27       	eor	r27, r27
    6a5e:	88 0e       	add	r8, r24
    6a60:	99 1e       	adc	r9, r25
    6a62:	aa 1e       	adc	r10, r26
    6a64:	bb 1e       	adc	r11, r27
    6a66:	84 14       	cp	r8, r4
    6a68:	95 04       	cpc	r9, r5
    6a6a:	a6 04       	cpc	r10, r6
    6a6c:	b7 04       	cpc	r11, r7
    6a6e:	20 f4       	brcc	.+8      	; 0x6a78 <__stack+0xa79>
    6a70:	40 50       	subi	r20, 0x00	; 0
    6a72:	50 40       	sbci	r21, 0x00	; 0
    6a74:	6f 4f       	sbci	r22, 0xFF	; 255
    6a76:	7f 4f       	sbci	r23, 0xFF	; 255
    6a78:	c5 01       	movw	r24, r10
    6a7a:	aa 27       	eor	r26, r26
    6a7c:	bb 27       	eor	r27, r27
    6a7e:	84 0f       	add	r24, r20
    6a80:	95 1f       	adc	r25, r21
    6a82:	a6 1f       	adc	r26, r22
    6a84:	b7 1f       	adc	r27, r23
    6a86:	0d a5       	lds	r16, 0x6d
    6a88:	1e a5       	lds	r17, 0x6e
    6a8a:	2f a5       	lds	r18, 0x6f
    6a8c:	38 a9       	sts	0x48, r19
    6a8e:	08 17       	cp	r16, r24
    6a90:	19 07       	cpc	r17, r25
    6a92:	2a 07       	cpc	r18, r26
    6a94:	3b 07       	cpc	r19, r27
    6a96:	18 f1       	brcs	.+70     	; 0x6ade <__stack+0xadf>
    6a98:	80 17       	cp	r24, r16
    6a9a:	91 07       	cpc	r25, r17
    6a9c:	a2 07       	cpc	r26, r18
    6a9e:	b3 07       	cpc	r27, r19
    6aa0:	a1 f5       	brne	.+104    	; 0x6b0a <__stack+0xb0b>
    6aa2:	54 01       	movw	r10, r8
    6aa4:	99 24       	eor	r9, r9
    6aa6:	88 24       	eor	r8, r8
    6aa8:	89 ad       	sts	0x69, r24
    6aaa:	9a ad       	sts	0x6a, r25
    6aac:	ab ad       	sts	0x6b, r26
    6aae:	bc ad       	sts	0x6c, r27
    6ab0:	a0 70       	andi	r26, 0x00	; 0
    6ab2:	b0 70       	andi	r27, 0x00	; 0
    6ab4:	88 0e       	add	r8, r24
    6ab6:	99 1e       	adc	r9, r25
    6ab8:	aa 1e       	adc	r10, r26
    6aba:	bb 1e       	adc	r11, r27
    6abc:	4d a9       	sts	0x4d, r20
    6abe:	5e a9       	sts	0x4e, r21
    6ac0:	6f a9       	sts	0x4f, r22
    6ac2:	78 ad       	sts	0x68, r23
    6ac4:	03 2c       	mov	r0, r3
    6ac6:	04 c0       	rjmp	.+8      	; 0x6ad0 <__stack+0xad1>
    6ac8:	44 0f       	add	r20, r20
    6aca:	55 1f       	adc	r21, r21
    6acc:	66 1f       	adc	r22, r22
    6ace:	77 1f       	adc	r23, r23
    6ad0:	0a 94       	dec	r0
    6ad2:	d2 f7       	brpl	.-12     	; 0x6ac8 <__stack+0xac9>
    6ad4:	48 15       	cp	r20, r8
    6ad6:	59 05       	cpc	r21, r9
    6ad8:	6a 05       	cpc	r22, r10
    6ada:	7b 05       	cpc	r23, r11
    6adc:	b0 f4       	brcc	.+44     	; 0x6b0a <__stack+0xb0b>
    6ade:	08 94       	sec
    6ae0:	c1 08       	sbc	r12, r1
    6ae2:	d1 08       	sbc	r13, r1
    6ae4:	e1 08       	sbc	r14, r1
    6ae6:	f1 08       	sbc	r15, r1
    6ae8:	10 c0       	rjmp	.+32     	; 0x6b0a <__stack+0xb0b>
    6aea:	44 24       	eor	r4, r4
    6aec:	55 24       	eor	r5, r5
    6aee:	32 01       	movw	r6, r4
    6af0:	cc 24       	eor	r12, r12
    6af2:	dd 24       	eor	r13, r13
    6af4:	76 01       	movw	r14, r12
    6af6:	0c c0       	rjmp	.+24     	; 0x6b10 <__stack+0xb11>
    6af8:	44 24       	eor	r4, r4
    6afa:	55 24       	eor	r5, r5
    6afc:	32 01       	movw	r6, r4
    6afe:	81 e0       	ldi	r24, 0x01	; 1
    6b00:	c8 2e       	mov	r12, r24
    6b02:	d1 2c       	mov	r13, r1
    6b04:	e1 2c       	mov	r14, r1
    6b06:	f1 2c       	mov	r15, r1
    6b08:	03 c0       	rjmp	.+6      	; 0x6b10 <__stack+0xb11>
    6b0a:	44 24       	eor	r4, r4
    6b0c:	55 24       	eor	r5, r5
    6b0e:	32 01       	movw	r6, r4
    6b10:	fe 01       	movw	r30, r28
    6b12:	31 96       	adiw	r30, 0x01	; 1
    6b14:	88 e0       	ldi	r24, 0x08	; 8
    6b16:	df 01       	movw	r26, r30
    6b18:	1d 92       	st	X+, r1
    6b1a:	8a 95       	dec	r24
    6b1c:	e9 f7       	brne	.-6      	; 0x6b18 <__stack+0xb19>
    6b1e:	c9 82       	std	Y+1, r12	; 0x01
    6b20:	da 82       	std	Y+2, r13	; 0x02
    6b22:	eb 82       	std	Y+3, r14	; 0x03
    6b24:	fc 82       	std	Y+4, r15	; 0x04
    6b26:	4d 82       	std	Y+5, r4	; 0x05
    6b28:	5e 82       	std	Y+6, r5	; 0x06
    6b2a:	6f 82       	std	Y+7, r6	; 0x07
    6b2c:	78 86       	std	Y+8, r7	; 0x08
    6b2e:	2c 2d       	mov	r18, r12
    6b30:	3a 81       	ldd	r19, Y+2	; 0x02
    6b32:	4b 81       	ldd	r20, Y+3	; 0x03
    6b34:	5c 81       	ldd	r21, Y+4	; 0x04
    6b36:	64 2d       	mov	r22, r4
    6b38:	7e 81       	ldd	r23, Y+6	; 0x06
    6b3a:	8f 81       	ldd	r24, Y+7	; 0x07
    6b3c:	98 85       	ldd	r25, Y+8	; 0x08
    6b3e:	25 96       	adiw	r28, 0x05	; 5
    6b40:	ec ac       	sts	0xac, r30
    6b42:	fd ac       	sts	0xad, r31
    6b44:	0e ad       	sts	0x6e, r16
    6b46:	1f ad       	sts	0x6f, r17
    6b48:	25 97       	sbiw	r28, 0x05	; 5
    6b4a:	e1 14       	cp	r14, r1
    6b4c:	f1 04       	cpc	r15, r1
    6b4e:	01 05       	cpc	r16, r1
    6b50:	11 05       	cpc	r17, r1
    6b52:	09 f4       	brne	.+2      	; 0x6b56 <__stack+0xb57>
    6b54:	56 c0       	rjmp	.+172    	; 0x6c02 <__stack+0xc03>
    6b56:	21 95       	neg	r18
    6b58:	e1 e0       	ldi	r30, 0x01	; 1
    6b5a:	12 16       	cp	r1, r18
    6b5c:	08 f0       	brcs	.+2      	; 0x6b60 <__stack+0xb61>
    6b5e:	e0 e0       	ldi	r30, 0x00	; 0
    6b60:	31 95       	neg	r19
    6b62:	f1 e0       	ldi	r31, 0x01	; 1
    6b64:	13 16       	cp	r1, r19
    6b66:	08 f0       	brcs	.+2      	; 0x6b6a <__stack+0xb6b>
    6b68:	f0 e0       	ldi	r31, 0x00	; 0
    6b6a:	03 2f       	mov	r16, r19
    6b6c:	0e 1b       	sub	r16, r30
    6b6e:	e1 e0       	ldi	r30, 0x01	; 1
    6b70:	30 17       	cp	r19, r16
    6b72:	08 f0       	brcs	.+2      	; 0x6b76 <__stack+0xb77>
    6b74:	e0 e0       	ldi	r30, 0x00	; 0
    6b76:	fe 2b       	or	r31, r30
    6b78:	41 95       	neg	r20
    6b7a:	e1 e0       	ldi	r30, 0x01	; 1
    6b7c:	14 16       	cp	r1, r20
    6b7e:	08 f0       	brcs	.+2      	; 0x6b82 <__stack+0xb83>
    6b80:	e0 e0       	ldi	r30, 0x00	; 0
    6b82:	14 2f       	mov	r17, r20
    6b84:	1f 1b       	sub	r17, r31
    6b86:	31 e0       	ldi	r19, 0x01	; 1
    6b88:	41 17       	cp	r20, r17
    6b8a:	08 f0       	brcs	.+2      	; 0x6b8e <__stack+0xb8f>
    6b8c:	30 e0       	ldi	r19, 0x00	; 0
    6b8e:	e3 2b       	or	r30, r19
    6b90:	51 95       	neg	r21
    6b92:	f1 e0       	ldi	r31, 0x01	; 1
    6b94:	15 16       	cp	r1, r21
    6b96:	08 f0       	brcs	.+2      	; 0x6b9a <__stack+0xb9b>
    6b98:	f0 e0       	ldi	r31, 0x00	; 0
    6b9a:	b5 2f       	mov	r27, r21
    6b9c:	be 1b       	sub	r27, r30
    6b9e:	31 e0       	ldi	r19, 0x01	; 1
    6ba0:	5b 17       	cp	r21, r27
    6ba2:	08 f0       	brcs	.+2      	; 0x6ba6 <__stack+0xba7>
    6ba4:	30 e0       	ldi	r19, 0x00	; 0
    6ba6:	f3 2b       	or	r31, r19
    6ba8:	61 95       	neg	r22
    6baa:	e1 e0       	ldi	r30, 0x01	; 1
    6bac:	16 16       	cp	r1, r22
    6bae:	08 f0       	brcs	.+2      	; 0x6bb2 <__stack+0xbb3>
    6bb0:	e0 e0       	ldi	r30, 0x00	; 0
    6bb2:	46 2e       	mov	r4, r22
    6bb4:	4f 1a       	sub	r4, r31
    6bb6:	31 e0       	ldi	r19, 0x01	; 1
    6bb8:	64 15       	cp	r22, r4
    6bba:	08 f0       	brcs	.+2      	; 0x6bbe <__stack+0xbbf>
    6bbc:	30 e0       	ldi	r19, 0x00	; 0
    6bbe:	e3 2b       	or	r30, r19
    6bc0:	71 95       	neg	r23
    6bc2:	f1 e0       	ldi	r31, 0x01	; 1
    6bc4:	17 16       	cp	r1, r23
    6bc6:	08 f0       	brcs	.+2      	; 0x6bca <__stack+0xbcb>
    6bc8:	f0 e0       	ldi	r31, 0x00	; 0
    6bca:	a7 2f       	mov	r26, r23
    6bcc:	ae 1b       	sub	r26, r30
    6bce:	31 e0       	ldi	r19, 0x01	; 1
    6bd0:	7a 17       	cp	r23, r26
    6bd2:	08 f0       	brcs	.+2      	; 0x6bd6 <__stack+0xbd7>
    6bd4:	30 e0       	ldi	r19, 0x00	; 0
    6bd6:	f3 2b       	or	r31, r19
    6bd8:	81 95       	neg	r24
    6bda:	e1 e0       	ldi	r30, 0x01	; 1
    6bdc:	18 16       	cp	r1, r24
    6bde:	08 f0       	brcs	.+2      	; 0x6be2 <__stack+0xbe3>
    6be0:	e0 e0       	ldi	r30, 0x00	; 0
    6be2:	f8 2e       	mov	r15, r24
    6be4:	ff 1a       	sub	r15, r31
    6be6:	ff 2d       	mov	r31, r15
    6be8:	31 e0       	ldi	r19, 0x01	; 1
    6bea:	8f 15       	cp	r24, r15
    6bec:	08 f0       	brcs	.+2      	; 0x6bf0 <__stack+0xbf1>
    6bee:	30 e0       	ldi	r19, 0x00	; 0
    6bf0:	e3 2b       	or	r30, r19
    6bf2:	91 95       	neg	r25
    6bf4:	30 2f       	mov	r19, r16
    6bf6:	41 2f       	mov	r20, r17
    6bf8:	5b 2f       	mov	r21, r27
    6bfa:	64 2d       	mov	r22, r4
    6bfc:	7a 2f       	mov	r23, r26
    6bfe:	8f 2f       	mov	r24, r31
    6c00:	9e 1b       	sub	r25, r30
    6c02:	c8 5b       	subi	r28, 0xB8	; 184
    6c04:	df 4f       	sbci	r29, 0xFF	; 255
    6c06:	e1 e1       	ldi	r30, 0x11	; 17
    6c08:	0c 94 52 38 	jmp	0x70a4	; 0x70a4 <__epilogue_restores__+0x2>

00006c0c <__subsf3>:
    6c0c:	50 58       	subi	r21, 0x80	; 128

00006c0e <__addsf3>:
    6c0e:	bb 27       	eor	r27, r27
    6c10:	aa 27       	eor	r26, r26
    6c12:	0e d0       	rcall	.+28     	; 0x6c30 <__addsf3x>
    6c14:	48 c1       	rjmp	.+656    	; 0x6ea6 <__fp_round>
    6c16:	39 d1       	rcall	.+626    	; 0x6e8a <__fp_pscA>
    6c18:	30 f0       	brcs	.+12     	; 0x6c26 <__addsf3+0x18>
    6c1a:	3e d1       	rcall	.+636    	; 0x6e98 <__fp_pscB>
    6c1c:	20 f0       	brcs	.+8      	; 0x6c26 <__addsf3+0x18>
    6c1e:	31 f4       	brne	.+12     	; 0x6c2c <__addsf3+0x1e>
    6c20:	9f 3f       	cpi	r25, 0xFF	; 255
    6c22:	11 f4       	brne	.+4      	; 0x6c28 <__addsf3+0x1a>
    6c24:	1e f4       	brtc	.+6      	; 0x6c2c <__addsf3+0x1e>
    6c26:	2e c1       	rjmp	.+604    	; 0x6e84 <__fp_nan>
    6c28:	0e f4       	brtc	.+2      	; 0x6c2c <__addsf3+0x1e>
    6c2a:	e0 95       	com	r30
    6c2c:	e7 fb       	bst	r30, 7
    6c2e:	24 c1       	rjmp	.+584    	; 0x6e78 <__fp_inf>

00006c30 <__addsf3x>:
    6c30:	e9 2f       	mov	r30, r25
    6c32:	4a d1       	rcall	.+660    	; 0x6ec8 <__fp_split3>
    6c34:	80 f3       	brcs	.-32     	; 0x6c16 <__addsf3+0x8>
    6c36:	ba 17       	cp	r27, r26
    6c38:	62 07       	cpc	r22, r18
    6c3a:	73 07       	cpc	r23, r19
    6c3c:	84 07       	cpc	r24, r20
    6c3e:	95 07       	cpc	r25, r21
    6c40:	18 f0       	brcs	.+6      	; 0x6c48 <__addsf3x+0x18>
    6c42:	71 f4       	brne	.+28     	; 0x6c60 <__addsf3x+0x30>
    6c44:	9e f5       	brtc	.+102    	; 0x6cac <__addsf3x+0x7c>
    6c46:	62 c1       	rjmp	.+708    	; 0x6f0c <__fp_zero>
    6c48:	0e f4       	brtc	.+2      	; 0x6c4c <__addsf3x+0x1c>
    6c4a:	e0 95       	com	r30
    6c4c:	0b 2e       	mov	r0, r27
    6c4e:	ba 2f       	mov	r27, r26
    6c50:	a0 2d       	mov	r26, r0
    6c52:	0b 01       	movw	r0, r22
    6c54:	b9 01       	movw	r22, r18
    6c56:	90 01       	movw	r18, r0
    6c58:	0c 01       	movw	r0, r24
    6c5a:	ca 01       	movw	r24, r20
    6c5c:	a0 01       	movw	r20, r0
    6c5e:	11 24       	eor	r1, r1
    6c60:	ff 27       	eor	r31, r31
    6c62:	59 1b       	sub	r21, r25
    6c64:	99 f0       	breq	.+38     	; 0x6c8c <__addsf3x+0x5c>
    6c66:	59 3f       	cpi	r21, 0xF9	; 249
    6c68:	50 f4       	brcc	.+20     	; 0x6c7e <__addsf3x+0x4e>
    6c6a:	50 3e       	cpi	r21, 0xE0	; 224
    6c6c:	68 f1       	brcs	.+90     	; 0x6cc8 <__addsf3x+0x98>
    6c6e:	1a 16       	cp	r1, r26
    6c70:	f0 40       	sbci	r31, 0x00	; 0
    6c72:	a2 2f       	mov	r26, r18
    6c74:	23 2f       	mov	r18, r19
    6c76:	34 2f       	mov	r19, r20
    6c78:	44 27       	eor	r20, r20
    6c7a:	58 5f       	subi	r21, 0xF8	; 248
    6c7c:	f3 cf       	rjmp	.-26     	; 0x6c64 <__addsf3x+0x34>
    6c7e:	46 95       	lsr	r20
    6c80:	37 95       	ror	r19
    6c82:	27 95       	ror	r18
    6c84:	a7 95       	ror	r26
    6c86:	f0 40       	sbci	r31, 0x00	; 0
    6c88:	53 95       	inc	r21
    6c8a:	c9 f7       	brne	.-14     	; 0x6c7e <__addsf3x+0x4e>
    6c8c:	7e f4       	brtc	.+30     	; 0x6cac <__addsf3x+0x7c>
    6c8e:	1f 16       	cp	r1, r31
    6c90:	ba 0b       	sbc	r27, r26
    6c92:	62 0b       	sbc	r22, r18
    6c94:	73 0b       	sbc	r23, r19
    6c96:	84 0b       	sbc	r24, r20
    6c98:	ba f0       	brmi	.+46     	; 0x6cc8 <__addsf3x+0x98>
    6c9a:	91 50       	subi	r25, 0x01	; 1
    6c9c:	a1 f0       	breq	.+40     	; 0x6cc6 <__addsf3x+0x96>
    6c9e:	ff 0f       	add	r31, r31
    6ca0:	bb 1f       	adc	r27, r27
    6ca2:	66 1f       	adc	r22, r22
    6ca4:	77 1f       	adc	r23, r23
    6ca6:	88 1f       	adc	r24, r24
    6ca8:	c2 f7       	brpl	.-16     	; 0x6c9a <__addsf3x+0x6a>
    6caa:	0e c0       	rjmp	.+28     	; 0x6cc8 <__addsf3x+0x98>
    6cac:	ba 0f       	add	r27, r26
    6cae:	62 1f       	adc	r22, r18
    6cb0:	73 1f       	adc	r23, r19
    6cb2:	84 1f       	adc	r24, r20
    6cb4:	48 f4       	brcc	.+18     	; 0x6cc8 <__addsf3x+0x98>
    6cb6:	87 95       	ror	r24
    6cb8:	77 95       	ror	r23
    6cba:	67 95       	ror	r22
    6cbc:	b7 95       	ror	r27
    6cbe:	f7 95       	ror	r31
    6cc0:	9e 3f       	cpi	r25, 0xFE	; 254
    6cc2:	08 f0       	brcs	.+2      	; 0x6cc6 <__addsf3x+0x96>
    6cc4:	b3 cf       	rjmp	.-154    	; 0x6c2c <__addsf3+0x1e>
    6cc6:	93 95       	inc	r25
    6cc8:	88 0f       	add	r24, r24
    6cca:	08 f0       	brcs	.+2      	; 0x6cce <__addsf3x+0x9e>
    6ccc:	99 27       	eor	r25, r25
    6cce:	ee 0f       	add	r30, r30
    6cd0:	97 95       	ror	r25
    6cd2:	87 95       	ror	r24
    6cd4:	08 95       	ret

00006cd6 <__divsf3>:
    6cd6:	0c d0       	rcall	.+24     	; 0x6cf0 <__divsf3x>
    6cd8:	e6 c0       	rjmp	.+460    	; 0x6ea6 <__fp_round>
    6cda:	de d0       	rcall	.+444    	; 0x6e98 <__fp_pscB>
    6cdc:	40 f0       	brcs	.+16     	; 0x6cee <__divsf3+0x18>
    6cde:	d5 d0       	rcall	.+426    	; 0x6e8a <__fp_pscA>
    6ce0:	30 f0       	brcs	.+12     	; 0x6cee <__divsf3+0x18>
    6ce2:	21 f4       	brne	.+8      	; 0x6cec <__divsf3+0x16>
    6ce4:	5f 3f       	cpi	r21, 0xFF	; 255
    6ce6:	19 f0       	breq	.+6      	; 0x6cee <__divsf3+0x18>
    6ce8:	c7 c0       	rjmp	.+398    	; 0x6e78 <__fp_inf>
    6cea:	51 11       	cpse	r21, r1
    6cec:	10 c1       	rjmp	.+544    	; 0x6f0e <__fp_szero>
    6cee:	ca c0       	rjmp	.+404    	; 0x6e84 <__fp_nan>

00006cf0 <__divsf3x>:
    6cf0:	eb d0       	rcall	.+470    	; 0x6ec8 <__fp_split3>
    6cf2:	98 f3       	brcs	.-26     	; 0x6cda <__divsf3+0x4>

00006cf4 <__divsf3_pse>:
    6cf4:	99 23       	and	r25, r25
    6cf6:	c9 f3       	breq	.-14     	; 0x6cea <__divsf3+0x14>
    6cf8:	55 23       	and	r21, r21
    6cfa:	b1 f3       	breq	.-20     	; 0x6ce8 <__divsf3+0x12>
    6cfc:	95 1b       	sub	r25, r21
    6cfe:	55 0b       	sbc	r21, r21
    6d00:	bb 27       	eor	r27, r27
    6d02:	aa 27       	eor	r26, r26
    6d04:	62 17       	cp	r22, r18
    6d06:	73 07       	cpc	r23, r19
    6d08:	84 07       	cpc	r24, r20
    6d0a:	38 f0       	brcs	.+14     	; 0x6d1a <__divsf3_pse+0x26>
    6d0c:	9f 5f       	subi	r25, 0xFF	; 255
    6d0e:	5f 4f       	sbci	r21, 0xFF	; 255
    6d10:	22 0f       	add	r18, r18
    6d12:	33 1f       	adc	r19, r19
    6d14:	44 1f       	adc	r20, r20
    6d16:	aa 1f       	adc	r26, r26
    6d18:	a9 f3       	breq	.-22     	; 0x6d04 <__divsf3_pse+0x10>
    6d1a:	33 d0       	rcall	.+102    	; 0x6d82 <__divsf3_pse+0x8e>
    6d1c:	0e 2e       	mov	r0, r30
    6d1e:	3a f0       	brmi	.+14     	; 0x6d2e <__divsf3_pse+0x3a>
    6d20:	e0 e8       	ldi	r30, 0x80	; 128
    6d22:	30 d0       	rcall	.+96     	; 0x6d84 <__divsf3_pse+0x90>
    6d24:	91 50       	subi	r25, 0x01	; 1
    6d26:	50 40       	sbci	r21, 0x00	; 0
    6d28:	e6 95       	lsr	r30
    6d2a:	00 1c       	adc	r0, r0
    6d2c:	ca f7       	brpl	.-14     	; 0x6d20 <__divsf3_pse+0x2c>
    6d2e:	29 d0       	rcall	.+82     	; 0x6d82 <__divsf3_pse+0x8e>
    6d30:	fe 2f       	mov	r31, r30
    6d32:	27 d0       	rcall	.+78     	; 0x6d82 <__divsf3_pse+0x8e>
    6d34:	66 0f       	add	r22, r22
    6d36:	77 1f       	adc	r23, r23
    6d38:	88 1f       	adc	r24, r24
    6d3a:	bb 1f       	adc	r27, r27
    6d3c:	26 17       	cp	r18, r22
    6d3e:	37 07       	cpc	r19, r23
    6d40:	48 07       	cpc	r20, r24
    6d42:	ab 07       	cpc	r26, r27
    6d44:	b0 e8       	ldi	r27, 0x80	; 128
    6d46:	09 f0       	breq	.+2      	; 0x6d4a <__divsf3_pse+0x56>
    6d48:	bb 0b       	sbc	r27, r27
    6d4a:	80 2d       	mov	r24, r0
    6d4c:	bf 01       	movw	r22, r30
    6d4e:	ff 27       	eor	r31, r31
    6d50:	93 58       	subi	r25, 0x83	; 131
    6d52:	5f 4f       	sbci	r21, 0xFF	; 255
    6d54:	2a f0       	brmi	.+10     	; 0x6d60 <__divsf3_pse+0x6c>
    6d56:	9e 3f       	cpi	r25, 0xFE	; 254
    6d58:	51 05       	cpc	r21, r1
    6d5a:	68 f0       	brcs	.+26     	; 0x6d76 <__divsf3_pse+0x82>
    6d5c:	8d c0       	rjmp	.+282    	; 0x6e78 <__fp_inf>
    6d5e:	d7 c0       	rjmp	.+430    	; 0x6f0e <__fp_szero>
    6d60:	5f 3f       	cpi	r21, 0xFF	; 255
    6d62:	ec f3       	brlt	.-6      	; 0x6d5e <__divsf3_pse+0x6a>
    6d64:	98 3e       	cpi	r25, 0xE8	; 232
    6d66:	dc f3       	brlt	.-10     	; 0x6d5e <__divsf3_pse+0x6a>
    6d68:	86 95       	lsr	r24
    6d6a:	77 95       	ror	r23
    6d6c:	67 95       	ror	r22
    6d6e:	b7 95       	ror	r27
    6d70:	f7 95       	ror	r31
    6d72:	9f 5f       	subi	r25, 0xFF	; 255
    6d74:	c9 f7       	brne	.-14     	; 0x6d68 <__divsf3_pse+0x74>
    6d76:	88 0f       	add	r24, r24
    6d78:	91 1d       	adc	r25, r1
    6d7a:	96 95       	lsr	r25
    6d7c:	87 95       	ror	r24
    6d7e:	97 f9       	bld	r25, 7
    6d80:	08 95       	ret
    6d82:	e1 e0       	ldi	r30, 0x01	; 1
    6d84:	66 0f       	add	r22, r22
    6d86:	77 1f       	adc	r23, r23
    6d88:	88 1f       	adc	r24, r24
    6d8a:	bb 1f       	adc	r27, r27
    6d8c:	62 17       	cp	r22, r18
    6d8e:	73 07       	cpc	r23, r19
    6d90:	84 07       	cpc	r24, r20
    6d92:	ba 07       	cpc	r27, r26
    6d94:	20 f0       	brcs	.+8      	; 0x6d9e <__divsf3_pse+0xaa>
    6d96:	62 1b       	sub	r22, r18
    6d98:	73 0b       	sbc	r23, r19
    6d9a:	84 0b       	sbc	r24, r20
    6d9c:	ba 0b       	sbc	r27, r26
    6d9e:	ee 1f       	adc	r30, r30
    6da0:	88 f7       	brcc	.-30     	; 0x6d84 <__divsf3_pse+0x90>
    6da2:	e0 95       	com	r30
    6da4:	08 95       	ret

00006da6 <__fixunssfsi>:
    6da6:	98 d0       	rcall	.+304    	; 0x6ed8 <__fp_splitA>
    6da8:	88 f0       	brcs	.+34     	; 0x6dcc <__fixunssfsi+0x26>
    6daa:	9f 57       	subi	r25, 0x7F	; 127
    6dac:	90 f0       	brcs	.+36     	; 0x6dd2 <__fixunssfsi+0x2c>
    6dae:	b9 2f       	mov	r27, r25
    6db0:	99 27       	eor	r25, r25
    6db2:	b7 51       	subi	r27, 0x17	; 23
    6db4:	a0 f0       	brcs	.+40     	; 0x6dde <__fixunssfsi+0x38>
    6db6:	d1 f0       	breq	.+52     	; 0x6dec <__fixunssfsi+0x46>
    6db8:	66 0f       	add	r22, r22
    6dba:	77 1f       	adc	r23, r23
    6dbc:	88 1f       	adc	r24, r24
    6dbe:	99 1f       	adc	r25, r25
    6dc0:	1a f0       	brmi	.+6      	; 0x6dc8 <__fixunssfsi+0x22>
    6dc2:	ba 95       	dec	r27
    6dc4:	c9 f7       	brne	.-14     	; 0x6db8 <__fixunssfsi+0x12>
    6dc6:	12 c0       	rjmp	.+36     	; 0x6dec <__fixunssfsi+0x46>
    6dc8:	b1 30       	cpi	r27, 0x01	; 1
    6dca:	81 f0       	breq	.+32     	; 0x6dec <__fixunssfsi+0x46>
    6dcc:	9f d0       	rcall	.+318    	; 0x6f0c <__fp_zero>
    6dce:	b1 e0       	ldi	r27, 0x01	; 1
    6dd0:	08 95       	ret
    6dd2:	9c c0       	rjmp	.+312    	; 0x6f0c <__fp_zero>
    6dd4:	67 2f       	mov	r22, r23
    6dd6:	78 2f       	mov	r23, r24
    6dd8:	88 27       	eor	r24, r24
    6dda:	b8 5f       	subi	r27, 0xF8	; 248
    6ddc:	39 f0       	breq	.+14     	; 0x6dec <__fixunssfsi+0x46>
    6dde:	b9 3f       	cpi	r27, 0xF9	; 249
    6de0:	cc f3       	brlt	.-14     	; 0x6dd4 <__fixunssfsi+0x2e>
    6de2:	86 95       	lsr	r24
    6de4:	77 95       	ror	r23
    6de6:	67 95       	ror	r22
    6de8:	b3 95       	inc	r27
    6dea:	d9 f7       	brne	.-10     	; 0x6de2 <__fixunssfsi+0x3c>
    6dec:	3e f4       	brtc	.+14     	; 0x6dfc <__fixunssfsi+0x56>
    6dee:	90 95       	com	r25
    6df0:	80 95       	com	r24
    6df2:	70 95       	com	r23
    6df4:	61 95       	neg	r22
    6df6:	7f 4f       	sbci	r23, 0xFF	; 255
    6df8:	8f 4f       	sbci	r24, 0xFF	; 255
    6dfa:	9f 4f       	sbci	r25, 0xFF	; 255
    6dfc:	08 95       	ret

00006dfe <__floatunsisf>:
    6dfe:	e8 94       	clt
    6e00:	09 c0       	rjmp	.+18     	; 0x6e14 <__floatsisf+0x12>

00006e02 <__floatsisf>:
    6e02:	97 fb       	bst	r25, 7
    6e04:	3e f4       	brtc	.+14     	; 0x6e14 <__floatsisf+0x12>
    6e06:	90 95       	com	r25
    6e08:	80 95       	com	r24
    6e0a:	70 95       	com	r23
    6e0c:	61 95       	neg	r22
    6e0e:	7f 4f       	sbci	r23, 0xFF	; 255
    6e10:	8f 4f       	sbci	r24, 0xFF	; 255
    6e12:	9f 4f       	sbci	r25, 0xFF	; 255
    6e14:	99 23       	and	r25, r25
    6e16:	a9 f0       	breq	.+42     	; 0x6e42 <__floatsisf+0x40>
    6e18:	f9 2f       	mov	r31, r25
    6e1a:	96 e9       	ldi	r25, 0x96	; 150
    6e1c:	bb 27       	eor	r27, r27
    6e1e:	93 95       	inc	r25
    6e20:	f6 95       	lsr	r31
    6e22:	87 95       	ror	r24
    6e24:	77 95       	ror	r23
    6e26:	67 95       	ror	r22
    6e28:	b7 95       	ror	r27
    6e2a:	f1 11       	cpse	r31, r1
    6e2c:	f8 cf       	rjmp	.-16     	; 0x6e1e <__floatsisf+0x1c>
    6e2e:	fa f4       	brpl	.+62     	; 0x6e6e <__floatsisf+0x6c>
    6e30:	bb 0f       	add	r27, r27
    6e32:	11 f4       	brne	.+4      	; 0x6e38 <__floatsisf+0x36>
    6e34:	60 ff       	sbrs	r22, 0
    6e36:	1b c0       	rjmp	.+54     	; 0x6e6e <__floatsisf+0x6c>
    6e38:	6f 5f       	subi	r22, 0xFF	; 255
    6e3a:	7f 4f       	sbci	r23, 0xFF	; 255
    6e3c:	8f 4f       	sbci	r24, 0xFF	; 255
    6e3e:	9f 4f       	sbci	r25, 0xFF	; 255
    6e40:	16 c0       	rjmp	.+44     	; 0x6e6e <__floatsisf+0x6c>
    6e42:	88 23       	and	r24, r24
    6e44:	11 f0       	breq	.+4      	; 0x6e4a <__floatsisf+0x48>
    6e46:	96 e9       	ldi	r25, 0x96	; 150
    6e48:	11 c0       	rjmp	.+34     	; 0x6e6c <__floatsisf+0x6a>
    6e4a:	77 23       	and	r23, r23
    6e4c:	21 f0       	breq	.+8      	; 0x6e56 <__floatsisf+0x54>
    6e4e:	9e e8       	ldi	r25, 0x8E	; 142
    6e50:	87 2f       	mov	r24, r23
    6e52:	76 2f       	mov	r23, r22
    6e54:	05 c0       	rjmp	.+10     	; 0x6e60 <__floatsisf+0x5e>
    6e56:	66 23       	and	r22, r22
    6e58:	71 f0       	breq	.+28     	; 0x6e76 <__floatsisf+0x74>
    6e5a:	96 e8       	ldi	r25, 0x86	; 134
    6e5c:	86 2f       	mov	r24, r22
    6e5e:	70 e0       	ldi	r23, 0x00	; 0
    6e60:	60 e0       	ldi	r22, 0x00	; 0
    6e62:	2a f0       	brmi	.+10     	; 0x6e6e <__floatsisf+0x6c>
    6e64:	9a 95       	dec	r25
    6e66:	66 0f       	add	r22, r22
    6e68:	77 1f       	adc	r23, r23
    6e6a:	88 1f       	adc	r24, r24
    6e6c:	da f7       	brpl	.-10     	; 0x6e64 <__floatsisf+0x62>
    6e6e:	88 0f       	add	r24, r24
    6e70:	96 95       	lsr	r25
    6e72:	87 95       	ror	r24
    6e74:	97 f9       	bld	r25, 7
    6e76:	08 95       	ret

00006e78 <__fp_inf>:
    6e78:	97 f9       	bld	r25, 7
    6e7a:	9f 67       	ori	r25, 0x7F	; 127
    6e7c:	80 e8       	ldi	r24, 0x80	; 128
    6e7e:	70 e0       	ldi	r23, 0x00	; 0
    6e80:	60 e0       	ldi	r22, 0x00	; 0
    6e82:	08 95       	ret

00006e84 <__fp_nan>:
    6e84:	9f ef       	ldi	r25, 0xFF	; 255
    6e86:	80 ec       	ldi	r24, 0xC0	; 192
    6e88:	08 95       	ret

00006e8a <__fp_pscA>:
    6e8a:	00 24       	eor	r0, r0
    6e8c:	0a 94       	dec	r0
    6e8e:	16 16       	cp	r1, r22
    6e90:	17 06       	cpc	r1, r23
    6e92:	18 06       	cpc	r1, r24
    6e94:	09 06       	cpc	r0, r25
    6e96:	08 95       	ret

00006e98 <__fp_pscB>:
    6e98:	00 24       	eor	r0, r0
    6e9a:	0a 94       	dec	r0
    6e9c:	12 16       	cp	r1, r18
    6e9e:	13 06       	cpc	r1, r19
    6ea0:	14 06       	cpc	r1, r20
    6ea2:	05 06       	cpc	r0, r21
    6ea4:	08 95       	ret

00006ea6 <__fp_round>:
    6ea6:	09 2e       	mov	r0, r25
    6ea8:	03 94       	inc	r0
    6eaa:	00 0c       	add	r0, r0
    6eac:	11 f4       	brne	.+4      	; 0x6eb2 <__fp_round+0xc>
    6eae:	88 23       	and	r24, r24
    6eb0:	52 f0       	brmi	.+20     	; 0x6ec6 <__fp_round+0x20>
    6eb2:	bb 0f       	add	r27, r27
    6eb4:	40 f4       	brcc	.+16     	; 0x6ec6 <__fp_round+0x20>
    6eb6:	bf 2b       	or	r27, r31
    6eb8:	11 f4       	brne	.+4      	; 0x6ebe <__fp_round+0x18>
    6eba:	60 ff       	sbrs	r22, 0
    6ebc:	04 c0       	rjmp	.+8      	; 0x6ec6 <__fp_round+0x20>
    6ebe:	6f 5f       	subi	r22, 0xFF	; 255
    6ec0:	7f 4f       	sbci	r23, 0xFF	; 255
    6ec2:	8f 4f       	sbci	r24, 0xFF	; 255
    6ec4:	9f 4f       	sbci	r25, 0xFF	; 255
    6ec6:	08 95       	ret

00006ec8 <__fp_split3>:
    6ec8:	57 fd       	sbrc	r21, 7
    6eca:	90 58       	subi	r25, 0x80	; 128
    6ecc:	44 0f       	add	r20, r20
    6ece:	55 1f       	adc	r21, r21
    6ed0:	59 f0       	breq	.+22     	; 0x6ee8 <__fp_splitA+0x10>
    6ed2:	5f 3f       	cpi	r21, 0xFF	; 255
    6ed4:	71 f0       	breq	.+28     	; 0x6ef2 <__fp_splitA+0x1a>
    6ed6:	47 95       	ror	r20

00006ed8 <__fp_splitA>:
    6ed8:	88 0f       	add	r24, r24
    6eda:	97 fb       	bst	r25, 7
    6edc:	99 1f       	adc	r25, r25
    6ede:	61 f0       	breq	.+24     	; 0x6ef8 <__fp_splitA+0x20>
    6ee0:	9f 3f       	cpi	r25, 0xFF	; 255
    6ee2:	79 f0       	breq	.+30     	; 0x6f02 <__fp_splitA+0x2a>
    6ee4:	87 95       	ror	r24
    6ee6:	08 95       	ret
    6ee8:	12 16       	cp	r1, r18
    6eea:	13 06       	cpc	r1, r19
    6eec:	14 06       	cpc	r1, r20
    6eee:	55 1f       	adc	r21, r21
    6ef0:	f2 cf       	rjmp	.-28     	; 0x6ed6 <__fp_split3+0xe>
    6ef2:	46 95       	lsr	r20
    6ef4:	f1 df       	rcall	.-30     	; 0x6ed8 <__fp_splitA>
    6ef6:	08 c0       	rjmp	.+16     	; 0x6f08 <__fp_splitA+0x30>
    6ef8:	16 16       	cp	r1, r22
    6efa:	17 06       	cpc	r1, r23
    6efc:	18 06       	cpc	r1, r24
    6efe:	99 1f       	adc	r25, r25
    6f00:	f1 cf       	rjmp	.-30     	; 0x6ee4 <__fp_splitA+0xc>
    6f02:	86 95       	lsr	r24
    6f04:	71 05       	cpc	r23, r1
    6f06:	61 05       	cpc	r22, r1
    6f08:	08 94       	sec
    6f0a:	08 95       	ret

00006f0c <__fp_zero>:
    6f0c:	e8 94       	clt

00006f0e <__fp_szero>:
    6f0e:	bb 27       	eor	r27, r27
    6f10:	66 27       	eor	r22, r22
    6f12:	77 27       	eor	r23, r23
    6f14:	cb 01       	movw	r24, r22
    6f16:	97 f9       	bld	r25, 7
    6f18:	08 95       	ret

00006f1a <__gesf2>:
    6f1a:	03 d0       	rcall	.+6      	; 0x6f22 <__fp_cmp>
    6f1c:	08 f4       	brcc	.+2      	; 0x6f20 <__gesf2+0x6>
    6f1e:	8f ef       	ldi	r24, 0xFF	; 255
    6f20:	08 95       	ret

00006f22 <__fp_cmp>:
    6f22:	99 0f       	add	r25, r25
    6f24:	00 08       	sbc	r0, r0
    6f26:	55 0f       	add	r21, r21
    6f28:	aa 0b       	sbc	r26, r26
    6f2a:	e0 e8       	ldi	r30, 0x80	; 128
    6f2c:	fe ef       	ldi	r31, 0xFE	; 254
    6f2e:	16 16       	cp	r1, r22
    6f30:	17 06       	cpc	r1, r23
    6f32:	e8 07       	cpc	r30, r24
    6f34:	f9 07       	cpc	r31, r25
    6f36:	c0 f0       	brcs	.+48     	; 0x6f68 <__fp_cmp+0x46>
    6f38:	12 16       	cp	r1, r18
    6f3a:	13 06       	cpc	r1, r19
    6f3c:	e4 07       	cpc	r30, r20
    6f3e:	f5 07       	cpc	r31, r21
    6f40:	98 f0       	brcs	.+38     	; 0x6f68 <__fp_cmp+0x46>
    6f42:	62 1b       	sub	r22, r18
    6f44:	73 0b       	sbc	r23, r19
    6f46:	84 0b       	sbc	r24, r20
    6f48:	95 0b       	sbc	r25, r21
    6f4a:	39 f4       	brne	.+14     	; 0x6f5a <__fp_cmp+0x38>
    6f4c:	0a 26       	eor	r0, r26
    6f4e:	61 f0       	breq	.+24     	; 0x6f68 <__fp_cmp+0x46>
    6f50:	23 2b       	or	r18, r19
    6f52:	24 2b       	or	r18, r20
    6f54:	25 2b       	or	r18, r21
    6f56:	21 f4       	brne	.+8      	; 0x6f60 <__fp_cmp+0x3e>
    6f58:	08 95       	ret
    6f5a:	0a 26       	eor	r0, r26
    6f5c:	09 f4       	brne	.+2      	; 0x6f60 <__fp_cmp+0x3e>
    6f5e:	a1 40       	sbci	r26, 0x01	; 1
    6f60:	a6 95       	lsr	r26
    6f62:	8f ef       	ldi	r24, 0xFF	; 255
    6f64:	81 1d       	adc	r24, r1
    6f66:	81 1d       	adc	r24, r1
    6f68:	08 95       	ret

00006f6a <__mulsi3>:
    6f6a:	62 9f       	mul	r22, r18
    6f6c:	d0 01       	movw	r26, r0
    6f6e:	73 9f       	mul	r23, r19
    6f70:	f0 01       	movw	r30, r0
    6f72:	82 9f       	mul	r24, r18
    6f74:	e0 0d       	add	r30, r0
    6f76:	f1 1d       	adc	r31, r1
    6f78:	64 9f       	mul	r22, r20
    6f7a:	e0 0d       	add	r30, r0
    6f7c:	f1 1d       	adc	r31, r1
    6f7e:	92 9f       	mul	r25, r18
    6f80:	f0 0d       	add	r31, r0
    6f82:	83 9f       	mul	r24, r19
    6f84:	f0 0d       	add	r31, r0
    6f86:	74 9f       	mul	r23, r20
    6f88:	f0 0d       	add	r31, r0
    6f8a:	65 9f       	mul	r22, r21
    6f8c:	f0 0d       	add	r31, r0
    6f8e:	99 27       	eor	r25, r25
    6f90:	72 9f       	mul	r23, r18
    6f92:	b0 0d       	add	r27, r0
    6f94:	e1 1d       	adc	r30, r1
    6f96:	f9 1f       	adc	r31, r25
    6f98:	63 9f       	mul	r22, r19
    6f9a:	b0 0d       	add	r27, r0
    6f9c:	e1 1d       	adc	r30, r1
    6f9e:	f9 1f       	adc	r31, r25
    6fa0:	bd 01       	movw	r22, r26
    6fa2:	cf 01       	movw	r24, r30
    6fa4:	11 24       	eor	r1, r1
    6fa6:	08 95       	ret

00006fa8 <__divmodhi4>:
    6fa8:	97 fb       	bst	r25, 7
    6faa:	09 2e       	mov	r0, r25
    6fac:	07 26       	eor	r0, r23
    6fae:	0a d0       	rcall	.+20     	; 0x6fc4 <__divmodhi4_neg1>
    6fb0:	77 fd       	sbrc	r23, 7
    6fb2:	04 d0       	rcall	.+8      	; 0x6fbc <__divmodhi4_neg2>
    6fb4:	49 d0       	rcall	.+146    	; 0x7048 <__udivmodhi4>
    6fb6:	06 d0       	rcall	.+12     	; 0x6fc4 <__divmodhi4_neg1>
    6fb8:	00 20       	and	r0, r0
    6fba:	1a f4       	brpl	.+6      	; 0x6fc2 <__divmodhi4_exit>

00006fbc <__divmodhi4_neg2>:
    6fbc:	70 95       	com	r23
    6fbe:	61 95       	neg	r22
    6fc0:	7f 4f       	sbci	r23, 0xFF	; 255

00006fc2 <__divmodhi4_exit>:
    6fc2:	08 95       	ret

00006fc4 <__divmodhi4_neg1>:
    6fc4:	f6 f7       	brtc	.-4      	; 0x6fc2 <__divmodhi4_exit>
    6fc6:	90 95       	com	r25
    6fc8:	81 95       	neg	r24
    6fca:	9f 4f       	sbci	r25, 0xFF	; 255
    6fcc:	08 95       	ret

00006fce <__udivmodsi4>:
    6fce:	a1 e2       	ldi	r26, 0x21	; 33
    6fd0:	1a 2e       	mov	r1, r26
    6fd2:	aa 1b       	sub	r26, r26
    6fd4:	bb 1b       	sub	r27, r27
    6fd6:	fd 01       	movw	r30, r26
    6fd8:	0d c0       	rjmp	.+26     	; 0x6ff4 <__udivmodsi4_ep>

00006fda <__udivmodsi4_loop>:
    6fda:	aa 1f       	adc	r26, r26
    6fdc:	bb 1f       	adc	r27, r27
    6fde:	ee 1f       	adc	r30, r30
    6fe0:	ff 1f       	adc	r31, r31
    6fe2:	a2 17       	cp	r26, r18
    6fe4:	b3 07       	cpc	r27, r19
    6fe6:	e4 07       	cpc	r30, r20
    6fe8:	f5 07       	cpc	r31, r21
    6fea:	20 f0       	brcs	.+8      	; 0x6ff4 <__udivmodsi4_ep>
    6fec:	a2 1b       	sub	r26, r18
    6fee:	b3 0b       	sbc	r27, r19
    6ff0:	e4 0b       	sbc	r30, r20
    6ff2:	f5 0b       	sbc	r31, r21

00006ff4 <__udivmodsi4_ep>:
    6ff4:	66 1f       	adc	r22, r22
    6ff6:	77 1f       	adc	r23, r23
    6ff8:	88 1f       	adc	r24, r24
    6ffa:	99 1f       	adc	r25, r25
    6ffc:	1a 94       	dec	r1
    6ffe:	69 f7       	brne	.-38     	; 0x6fda <__udivmodsi4_loop>
    7000:	60 95       	com	r22
    7002:	70 95       	com	r23
    7004:	80 95       	com	r24
    7006:	90 95       	com	r25
    7008:	9b 01       	movw	r18, r22
    700a:	ac 01       	movw	r20, r24
    700c:	bd 01       	movw	r22, r26
    700e:	cf 01       	movw	r24, r30
    7010:	08 95       	ret

00007012 <__divmodsi4>:
    7012:	97 fb       	bst	r25, 7
    7014:	09 2e       	mov	r0, r25
    7016:	05 26       	eor	r0, r21
    7018:	0e d0       	rcall	.+28     	; 0x7036 <__divmodsi4_neg1>
    701a:	57 fd       	sbrc	r21, 7
    701c:	04 d0       	rcall	.+8      	; 0x7026 <__divmodsi4_neg2>
    701e:	d7 df       	rcall	.-82     	; 0x6fce <__udivmodsi4>
    7020:	0a d0       	rcall	.+20     	; 0x7036 <__divmodsi4_neg1>
    7022:	00 1c       	adc	r0, r0
    7024:	38 f4       	brcc	.+14     	; 0x7034 <__divmodsi4_exit>

00007026 <__divmodsi4_neg2>:
    7026:	50 95       	com	r21
    7028:	40 95       	com	r20
    702a:	30 95       	com	r19
    702c:	21 95       	neg	r18
    702e:	3f 4f       	sbci	r19, 0xFF	; 255
    7030:	4f 4f       	sbci	r20, 0xFF	; 255
    7032:	5f 4f       	sbci	r21, 0xFF	; 255

00007034 <__divmodsi4_exit>:
    7034:	08 95       	ret

00007036 <__divmodsi4_neg1>:
    7036:	f6 f7       	brtc	.-4      	; 0x7034 <__divmodsi4_exit>
    7038:	90 95       	com	r25
    703a:	80 95       	com	r24
    703c:	70 95       	com	r23
    703e:	61 95       	neg	r22
    7040:	7f 4f       	sbci	r23, 0xFF	; 255
    7042:	8f 4f       	sbci	r24, 0xFF	; 255
    7044:	9f 4f       	sbci	r25, 0xFF	; 255
    7046:	08 95       	ret

00007048 <__udivmodhi4>:
    7048:	aa 1b       	sub	r26, r26
    704a:	bb 1b       	sub	r27, r27
    704c:	51 e1       	ldi	r21, 0x11	; 17
    704e:	07 c0       	rjmp	.+14     	; 0x705e <__udivmodhi4_ep>

00007050 <__udivmodhi4_loop>:
    7050:	aa 1f       	adc	r26, r26
    7052:	bb 1f       	adc	r27, r27
    7054:	a6 17       	cp	r26, r22
    7056:	b7 07       	cpc	r27, r23
    7058:	10 f0       	brcs	.+4      	; 0x705e <__udivmodhi4_ep>
    705a:	a6 1b       	sub	r26, r22
    705c:	b7 0b       	sbc	r27, r23

0000705e <__udivmodhi4_ep>:
    705e:	88 1f       	adc	r24, r24
    7060:	99 1f       	adc	r25, r25
    7062:	5a 95       	dec	r21
    7064:	a9 f7       	brne	.-22     	; 0x7050 <__udivmodhi4_loop>
    7066:	80 95       	com	r24
    7068:	90 95       	com	r25
    706a:	bc 01       	movw	r22, r24
    706c:	cd 01       	movw	r24, r26
    706e:	08 95       	ret

00007070 <__prologue_saves__>:
    7070:	2f 92       	push	r2
    7072:	3f 92       	push	r3
    7074:	4f 92       	push	r4
    7076:	5f 92       	push	r5
    7078:	6f 92       	push	r6
    707a:	7f 92       	push	r7
    707c:	8f 92       	push	r8
    707e:	9f 92       	push	r9
    7080:	af 92       	push	r10
    7082:	bf 92       	push	r11
    7084:	cf 92       	push	r12
    7086:	df 92       	push	r13
    7088:	ef 92       	push	r14
    708a:	ff 92       	push	r15
    708c:	0f 93       	push	r16
    708e:	1f 93       	push	r17
    7090:	cf 93       	push	r28
    7092:	df 93       	push	r29
    7094:	cd b7       	in	r28, 0x3d	; 61
    7096:	de b7       	in	r29, 0x3e	; 62
    7098:	ca 1b       	sub	r28, r26
    709a:	db 0b       	sbc	r29, r27
    709c:	cd bf       	out	0x3d, r28	; 61
    709e:	de bf       	out	0x3e, r29	; 62
    70a0:	19 94       	eijmp

000070a2 <__epilogue_restores__>:
    70a2:	2a 88       	ldd	r2, Y+18	; 0x12
    70a4:	39 88       	ldd	r3, Y+17	; 0x11
    70a6:	48 88       	ldd	r4, Y+16	; 0x10
    70a8:	5f 84       	ldd	r5, Y+15	; 0x0f
    70aa:	6e 84       	ldd	r6, Y+14	; 0x0e
    70ac:	7d 84       	ldd	r7, Y+13	; 0x0d
    70ae:	8c 84       	ldd	r8, Y+12	; 0x0c
    70b0:	9b 84       	ldd	r9, Y+11	; 0x0b
    70b2:	aa 84       	ldd	r10, Y+10	; 0x0a
    70b4:	b9 84       	ldd	r11, Y+9	; 0x09
    70b6:	c8 84       	ldd	r12, Y+8	; 0x08
    70b8:	df 80       	ldd	r13, Y+7	; 0x07
    70ba:	ee 80       	ldd	r14, Y+6	; 0x06
    70bc:	fd 80       	ldd	r15, Y+5	; 0x05
    70be:	0c 81       	ldd	r16, Y+4	; 0x04
    70c0:	1b 81       	ldd	r17, Y+3	; 0x03
    70c2:	aa 81       	ldd	r26, Y+2	; 0x02
    70c4:	b9 81       	ldd	r27, Y+1	; 0x01
    70c6:	ce 0f       	add	r28, r30
    70c8:	d1 1d       	adc	r29, r1
    70ca:	cd bf       	out	0x3d, r28	; 61
    70cc:	de bf       	out	0x3e, r29	; 62
    70ce:	ed 01       	movw	r28, r26
    70d0:	08 95       	ret

000070d2 <strcpy_P>:
    70d2:	fb 01       	movw	r30, r22
    70d4:	dc 01       	movw	r26, r24
    70d6:	05 90       	lpm	r0, Z+
    70d8:	0d 92       	st	X+, r0
    70da:	00 20       	and	r0, r0
    70dc:	e1 f7       	brne	.-8      	; 0x70d6 <strcpy_P+0x4>
    70de:	08 95       	ret

000070e0 <memmove>:
    70e0:	68 17       	cp	r22, r24
    70e2:	79 07       	cpc	r23, r25
    70e4:	68 f4       	brcc	.+26     	; 0x7100 <memmove+0x20>
    70e6:	fb 01       	movw	r30, r22
    70e8:	dc 01       	movw	r26, r24
    70ea:	e4 0f       	add	r30, r20
    70ec:	f5 1f       	adc	r31, r21
    70ee:	a4 0f       	add	r26, r20
    70f0:	b5 1f       	adc	r27, r21
    70f2:	02 c0       	rjmp	.+4      	; 0x70f8 <memmove+0x18>
    70f4:	02 90       	ld	r0, -Z
    70f6:	0e 92       	st	-X, r0
    70f8:	41 50       	subi	r20, 0x01	; 1
    70fa:	50 40       	sbci	r21, 0x00	; 0
    70fc:	d8 f7       	brcc	.-10     	; 0x70f4 <memmove+0x14>
    70fe:	08 95       	ret
    7100:	0c 94 f5 3a 	jmp	0x75ea	; 0x75ea <memcpy>

00007104 <strcat>:
    7104:	fb 01       	movw	r30, r22
    7106:	dc 01       	movw	r26, r24
    7108:	0d 90       	ld	r0, X+
    710a:	00 20       	and	r0, r0
    710c:	e9 f7       	brne	.-6      	; 0x7108 <strcat+0x4>
    710e:	11 97       	sbiw	r26, 0x01	; 1
    7110:	01 90       	ld	r0, Z+
    7112:	0d 92       	st	X+, r0
    7114:	00 20       	and	r0, r0
    7116:	e1 f7       	brne	.-8      	; 0x7110 <strcat+0xc>
    7118:	08 95       	ret

0000711a <itoa>:
    711a:	fb 01       	movw	r30, r22
    711c:	9f 01       	movw	r18, r30
    711e:	e8 94       	clt
    7120:	42 30       	cpi	r20, 0x02	; 2
    7122:	c4 f0       	brlt	.+48     	; 0x7154 <itoa+0x3a>
    7124:	45 32       	cpi	r20, 0x25	; 37
    7126:	b4 f4       	brge	.+44     	; 0x7154 <itoa+0x3a>
    7128:	4a 30       	cpi	r20, 0x0A	; 10
    712a:	29 f4       	brne	.+10     	; 0x7136 <itoa+0x1c>
    712c:	97 fb       	bst	r25, 7
    712e:	1e f4       	brtc	.+6      	; 0x7136 <itoa+0x1c>
    7130:	90 95       	com	r25
    7132:	81 95       	neg	r24
    7134:	9f 4f       	sbci	r25, 0xFF	; 255
    7136:	64 2f       	mov	r22, r20
    7138:	77 27       	eor	r23, r23
    713a:	0e 94 24 38 	call	0x7048	; 0x7048 <__udivmodhi4>
    713e:	80 5d       	subi	r24, 0xD0	; 208
    7140:	8a 33       	cpi	r24, 0x3A	; 58
    7142:	0c f0       	brlt	.+2      	; 0x7146 <itoa+0x2c>
    7144:	89 5d       	subi	r24, 0xD9	; 217
    7146:	81 93       	st	Z+, r24
    7148:	cb 01       	movw	r24, r22
    714a:	00 97       	sbiw	r24, 0x00	; 0
    714c:	a1 f7       	brne	.-24     	; 0x7136 <itoa+0x1c>
    714e:	16 f4       	brtc	.+4      	; 0x7154 <itoa+0x3a>
    7150:	5d e2       	ldi	r21, 0x2D	; 45
    7152:	51 93       	st	Z+, r21
    7154:	10 82       	st	Z, r1
    7156:	c9 01       	movw	r24, r18
    7158:	0c 94 09 3b 	jmp	0x7612	; 0x7612 <strrev>

0000715c <printf>:
    715c:	cf 93       	push	r28
    715e:	df 93       	push	r29
    7160:	cd b7       	in	r28, 0x3d	; 61
    7162:	de b7       	in	r29, 0x3e	; 62
    7164:	fe 01       	movw	r30, r28
    7166:	36 96       	adiw	r30, 0x06	; 6
    7168:	61 91       	ld	r22, Z+
    716a:	71 91       	ld	r23, Z+
    716c:	80 91 b4 50 	lds	r24, 0x50B4
    7170:	90 91 b5 50 	lds	r25, 0x50B5
    7174:	af 01       	movw	r20, r30
    7176:	0e 94 e9 38 	call	0x71d2	; 0x71d2 <vfprintf>
    717a:	df 91       	pop	r29
    717c:	cf 91       	pop	r28
    717e:	08 95       	ret

00007180 <sprintf>:
    7180:	0f 93       	push	r16
    7182:	1f 93       	push	r17
    7184:	cf 93       	push	r28
    7186:	df 93       	push	r29
    7188:	cd b7       	in	r28, 0x3d	; 61
    718a:	de b7       	in	r29, 0x3e	; 62
    718c:	2e 97       	sbiw	r28, 0x0e	; 14
    718e:	cd bf       	out	0x3d, r28	; 61
    7190:	de bf       	out	0x3e, r29	; 62
    7192:	0e 89       	ldd	r16, Y+22	; 0x16
    7194:	1f 89       	ldd	r17, Y+23	; 0x17
    7196:	86 e0       	ldi	r24, 0x06	; 6
    7198:	8c 83       	std	Y+4, r24	; 0x04
    719a:	09 83       	std	Y+1, r16	; 0x01
    719c:	1a 83       	std	Y+2, r17	; 0x02
    719e:	8f ef       	ldi	r24, 0xFF	; 255
    71a0:	9f e7       	ldi	r25, 0x7F	; 127
    71a2:	8d 83       	std	Y+5, r24	; 0x05
    71a4:	9e 83       	std	Y+6, r25	; 0x06
    71a6:	ae 01       	movw	r20, r28
    71a8:	46 5e       	subi	r20, 0xE6	; 230
    71aa:	5f 4f       	sbci	r21, 0xFF	; 255
    71ac:	ce 01       	movw	r24, r28
    71ae:	01 96       	adiw	r24, 0x01	; 1
    71b0:	68 8d       	ldd	r22, Y+24	; 0x18
    71b2:	79 8d       	ldd	r23, Y+25	; 0x19
    71b4:	0e 94 e9 38 	call	0x71d2	; 0x71d2 <vfprintf>
    71b8:	ef 81       	ldd	r30, Y+7	; 0x07
    71ba:	f8 85       	ldd	r31, Y+8	; 0x08
    71bc:	e0 0f       	add	r30, r16
    71be:	f1 1f       	adc	r31, r17
    71c0:	10 82       	st	Z, r1
    71c2:	2e 96       	adiw	r28, 0x0e	; 14
    71c4:	cd bf       	out	0x3d, r28	; 61
    71c6:	de bf       	out	0x3e, r29	; 62
    71c8:	df 91       	pop	r29
    71ca:	cf 91       	pop	r28
    71cc:	1f 91       	pop	r17
    71ce:	0f 91       	pop	r16
    71d0:	08 95       	ret

000071d2 <vfprintf>:
    71d2:	2f 92       	push	r2
    71d4:	3f 92       	push	r3
    71d6:	4f 92       	push	r4
    71d8:	5f 92       	push	r5
    71da:	6f 92       	push	r6
    71dc:	7f 92       	push	r7
    71de:	8f 92       	push	r8
    71e0:	9f 92       	push	r9
    71e2:	af 92       	push	r10
    71e4:	bf 92       	push	r11
    71e6:	cf 92       	push	r12
    71e8:	df 92       	push	r13
    71ea:	ef 92       	push	r14
    71ec:	ff 92       	push	r15
    71ee:	0f 93       	push	r16
    71f0:	1f 93       	push	r17
    71f2:	cf 93       	push	r28
    71f4:	df 93       	push	r29
    71f6:	cd b7       	in	r28, 0x3d	; 61
    71f8:	de b7       	in	r29, 0x3e	; 62
    71fa:	2d 97       	sbiw	r28, 0x0d	; 13
    71fc:	cd bf       	out	0x3d, r28	; 61
    71fe:	de bf       	out	0x3e, r29	; 62
    7200:	3c 01       	movw	r6, r24
    7202:	6c 87       	std	Y+12, r22	; 0x0c
    7204:	7d 87       	std	Y+13, r23	; 0x0d
    7206:	5a 01       	movw	r10, r20
    7208:	fc 01       	movw	r30, r24
    720a:	16 82       	std	Z+6, r1	; 0x06
    720c:	17 82       	std	Z+7, r1	; 0x07
    720e:	83 81       	ldd	r24, Z+3	; 0x03
    7210:	81 ff       	sbrs	r24, 1
    7212:	c8 c1       	rjmp	.+912    	; 0x75a4 <vfprintf+0x3d2>
    7214:	2e 01       	movw	r4, r28
    7216:	08 94       	sec
    7218:	41 1c       	adc	r4, r1
    721a:	51 1c       	adc	r5, r1
    721c:	f3 01       	movw	r30, r6
    721e:	93 81       	ldd	r25, Z+3	; 0x03
    7220:	ec 85       	ldd	r30, Y+12	; 0x0c
    7222:	fd 85       	ldd	r31, Y+13	; 0x0d
    7224:	93 fd       	sbrc	r25, 3
    7226:	85 91       	lpm	r24, Z+
    7228:	93 ff       	sbrs	r25, 3
    722a:	81 91       	ld	r24, Z+
    722c:	ec 87       	std	Y+12, r30	; 0x0c
    722e:	fd 87       	std	Y+13, r31	; 0x0d
    7230:	88 23       	and	r24, r24
    7232:	09 f4       	brne	.+2      	; 0x7236 <vfprintf+0x64>
    7234:	b3 c1       	rjmp	.+870    	; 0x759c <vfprintf+0x3ca>
    7236:	85 32       	cpi	r24, 0x25	; 37
    7238:	41 f4       	brne	.+16     	; 0x724a <vfprintf+0x78>
    723a:	93 fd       	sbrc	r25, 3
    723c:	85 91       	lpm	r24, Z+
    723e:	93 ff       	sbrs	r25, 3
    7240:	81 91       	ld	r24, Z+
    7242:	ec 87       	std	Y+12, r30	; 0x0c
    7244:	fd 87       	std	Y+13, r31	; 0x0d
    7246:	85 32       	cpi	r24, 0x25	; 37
    7248:	29 f4       	brne	.+10     	; 0x7254 <vfprintf+0x82>
    724a:	90 e0       	ldi	r25, 0x00	; 0
    724c:	b3 01       	movw	r22, r6
    724e:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    7252:	e4 cf       	rjmp	.-56     	; 0x721c <vfprintf+0x4a>
    7254:	ff 24       	eor	r15, r15
    7256:	ee 24       	eor	r14, r14
    7258:	10 e0       	ldi	r17, 0x00	; 0
    725a:	10 32       	cpi	r17, 0x20	; 32
    725c:	b0 f4       	brcc	.+44     	; 0x728a <vfprintf+0xb8>
    725e:	8b 32       	cpi	r24, 0x2B	; 43
    7260:	69 f0       	breq	.+26     	; 0x727c <vfprintf+0xaa>
    7262:	8c 32       	cpi	r24, 0x2C	; 44
    7264:	28 f4       	brcc	.+10     	; 0x7270 <vfprintf+0x9e>
    7266:	80 32       	cpi	r24, 0x20	; 32
    7268:	51 f0       	breq	.+20     	; 0x727e <vfprintf+0xac>
    726a:	83 32       	cpi	r24, 0x23	; 35
    726c:	71 f4       	brne	.+28     	; 0x728a <vfprintf+0xb8>
    726e:	0b c0       	rjmp	.+22     	; 0x7286 <vfprintf+0xb4>
    7270:	8d 32       	cpi	r24, 0x2D	; 45
    7272:	39 f0       	breq	.+14     	; 0x7282 <vfprintf+0xb0>
    7274:	80 33       	cpi	r24, 0x30	; 48
    7276:	49 f4       	brne	.+18     	; 0x728a <vfprintf+0xb8>
    7278:	11 60       	ori	r17, 0x01	; 1
    727a:	2c c0       	rjmp	.+88     	; 0x72d4 <vfprintf+0x102>
    727c:	12 60       	ori	r17, 0x02	; 2
    727e:	14 60       	ori	r17, 0x04	; 4
    7280:	29 c0       	rjmp	.+82     	; 0x72d4 <vfprintf+0x102>
    7282:	18 60       	ori	r17, 0x08	; 8
    7284:	27 c0       	rjmp	.+78     	; 0x72d4 <vfprintf+0x102>
    7286:	10 61       	ori	r17, 0x10	; 16
    7288:	25 c0       	rjmp	.+74     	; 0x72d4 <vfprintf+0x102>
    728a:	17 fd       	sbrc	r17, 7
    728c:	2e c0       	rjmp	.+92     	; 0x72ea <vfprintf+0x118>
    728e:	28 2f       	mov	r18, r24
    7290:	20 53       	subi	r18, 0x30	; 48
    7292:	2a 30       	cpi	r18, 0x0A	; 10
    7294:	98 f4       	brcc	.+38     	; 0x72bc <vfprintf+0xea>
    7296:	16 ff       	sbrs	r17, 6
    7298:	08 c0       	rjmp	.+16     	; 0x72aa <vfprintf+0xd8>
    729a:	8f 2d       	mov	r24, r15
    729c:	88 0f       	add	r24, r24
    729e:	f8 2e       	mov	r15, r24
    72a0:	ff 0c       	add	r15, r15
    72a2:	ff 0c       	add	r15, r15
    72a4:	f8 0e       	add	r15, r24
    72a6:	f2 0e       	add	r15, r18
    72a8:	15 c0       	rjmp	.+42     	; 0x72d4 <vfprintf+0x102>
    72aa:	8e 2d       	mov	r24, r14
    72ac:	88 0f       	add	r24, r24
    72ae:	e8 2e       	mov	r14, r24
    72b0:	ee 0c       	add	r14, r14
    72b2:	ee 0c       	add	r14, r14
    72b4:	e8 0e       	add	r14, r24
    72b6:	e2 0e       	add	r14, r18
    72b8:	10 62       	ori	r17, 0x20	; 32
    72ba:	0c c0       	rjmp	.+24     	; 0x72d4 <vfprintf+0x102>
    72bc:	8e 32       	cpi	r24, 0x2E	; 46
    72be:	21 f4       	brne	.+8      	; 0x72c8 <vfprintf+0xf6>
    72c0:	16 fd       	sbrc	r17, 6
    72c2:	6c c1       	rjmp	.+728    	; 0x759c <vfprintf+0x3ca>
    72c4:	10 64       	ori	r17, 0x40	; 64
    72c6:	06 c0       	rjmp	.+12     	; 0x72d4 <vfprintf+0x102>
    72c8:	8c 36       	cpi	r24, 0x6C	; 108
    72ca:	11 f4       	brne	.+4      	; 0x72d0 <vfprintf+0xfe>
    72cc:	10 68       	ori	r17, 0x80	; 128
    72ce:	02 c0       	rjmp	.+4      	; 0x72d4 <vfprintf+0x102>
    72d0:	88 36       	cpi	r24, 0x68	; 104
    72d2:	59 f4       	brne	.+22     	; 0x72ea <vfprintf+0x118>
    72d4:	ec 85       	ldd	r30, Y+12	; 0x0c
    72d6:	fd 85       	ldd	r31, Y+13	; 0x0d
    72d8:	93 fd       	sbrc	r25, 3
    72da:	85 91       	lpm	r24, Z+
    72dc:	93 ff       	sbrs	r25, 3
    72de:	81 91       	ld	r24, Z+
    72e0:	ec 87       	std	Y+12, r30	; 0x0c
    72e2:	fd 87       	std	Y+13, r31	; 0x0d
    72e4:	88 23       	and	r24, r24
    72e6:	09 f0       	breq	.+2      	; 0x72ea <vfprintf+0x118>
    72e8:	b8 cf       	rjmp	.-144    	; 0x725a <vfprintf+0x88>
    72ea:	98 2f       	mov	r25, r24
    72ec:	95 54       	subi	r25, 0x45	; 69
    72ee:	93 30       	cpi	r25, 0x03	; 3
    72f0:	18 f0       	brcs	.+6      	; 0x72f8 <vfprintf+0x126>
    72f2:	90 52       	subi	r25, 0x20	; 32
    72f4:	93 30       	cpi	r25, 0x03	; 3
    72f6:	38 f4       	brcc	.+14     	; 0x7306 <vfprintf+0x134>
    72f8:	24 e0       	ldi	r18, 0x04	; 4
    72fa:	30 e0       	ldi	r19, 0x00	; 0
    72fc:	a2 0e       	add	r10, r18
    72fe:	b3 1e       	adc	r11, r19
    7300:	3f e3       	ldi	r19, 0x3F	; 63
    7302:	39 83       	std	Y+1, r19	; 0x01
    7304:	0f c0       	rjmp	.+30     	; 0x7324 <vfprintf+0x152>
    7306:	83 36       	cpi	r24, 0x63	; 99
    7308:	31 f0       	breq	.+12     	; 0x7316 <vfprintf+0x144>
    730a:	83 37       	cpi	r24, 0x73	; 115
    730c:	81 f0       	breq	.+32     	; 0x732e <vfprintf+0x15c>
    730e:	83 35       	cpi	r24, 0x53	; 83
    7310:	09 f0       	breq	.+2      	; 0x7314 <vfprintf+0x142>
    7312:	5a c0       	rjmp	.+180    	; 0x73c8 <vfprintf+0x1f6>
    7314:	22 c0       	rjmp	.+68     	; 0x735a <vfprintf+0x188>
    7316:	f5 01       	movw	r30, r10
    7318:	80 81       	ld	r24, Z
    731a:	89 83       	std	Y+1, r24	; 0x01
    731c:	22 e0       	ldi	r18, 0x02	; 2
    731e:	30 e0       	ldi	r19, 0x00	; 0
    7320:	a2 0e       	add	r10, r18
    7322:	b3 1e       	adc	r11, r19
    7324:	21 e0       	ldi	r18, 0x01	; 1
    7326:	c2 2e       	mov	r12, r18
    7328:	d1 2c       	mov	r13, r1
    732a:	42 01       	movw	r8, r4
    732c:	14 c0       	rjmp	.+40     	; 0x7356 <vfprintf+0x184>
    732e:	92 e0       	ldi	r25, 0x02	; 2
    7330:	29 2e       	mov	r2, r25
    7332:	31 2c       	mov	r3, r1
    7334:	2a 0c       	add	r2, r10
    7336:	3b 1c       	adc	r3, r11
    7338:	f5 01       	movw	r30, r10
    733a:	80 80       	ld	r8, Z
    733c:	91 80       	ldd	r9, Z+1	; 0x01
    733e:	16 ff       	sbrs	r17, 6
    7340:	03 c0       	rjmp	.+6      	; 0x7348 <vfprintf+0x176>
    7342:	6f 2d       	mov	r22, r15
    7344:	70 e0       	ldi	r23, 0x00	; 0
    7346:	02 c0       	rjmp	.+4      	; 0x734c <vfprintf+0x17a>
    7348:	6f ef       	ldi	r22, 0xFF	; 255
    734a:	7f ef       	ldi	r23, 0xFF	; 255
    734c:	c4 01       	movw	r24, r8
    734e:	0e 94 fe 3a 	call	0x75fc	; 0x75fc <strnlen>
    7352:	6c 01       	movw	r12, r24
    7354:	51 01       	movw	r10, r2
    7356:	1f 77       	andi	r17, 0x7F	; 127
    7358:	15 c0       	rjmp	.+42     	; 0x7384 <vfprintf+0x1b2>
    735a:	82 e0       	ldi	r24, 0x02	; 2
    735c:	28 2e       	mov	r2, r24
    735e:	31 2c       	mov	r3, r1
    7360:	2a 0c       	add	r2, r10
    7362:	3b 1c       	adc	r3, r11
    7364:	f5 01       	movw	r30, r10
    7366:	80 80       	ld	r8, Z
    7368:	91 80       	ldd	r9, Z+1	; 0x01
    736a:	16 ff       	sbrs	r17, 6
    736c:	03 c0       	rjmp	.+6      	; 0x7374 <vfprintf+0x1a2>
    736e:	6f 2d       	mov	r22, r15
    7370:	70 e0       	ldi	r23, 0x00	; 0
    7372:	02 c0       	rjmp	.+4      	; 0x7378 <vfprintf+0x1a6>
    7374:	6f ef       	ldi	r22, 0xFF	; 255
    7376:	7f ef       	ldi	r23, 0xFF	; 255
    7378:	c4 01       	movw	r24, r8
    737a:	0e 94 ea 3a 	call	0x75d4	; 0x75d4 <strnlen_P>
    737e:	6c 01       	movw	r12, r24
    7380:	10 68       	ori	r17, 0x80	; 128
    7382:	51 01       	movw	r10, r2
    7384:	13 fd       	sbrc	r17, 3
    7386:	1c c0       	rjmp	.+56     	; 0x73c0 <vfprintf+0x1ee>
    7388:	06 c0       	rjmp	.+12     	; 0x7396 <vfprintf+0x1c4>
    738a:	80 e2       	ldi	r24, 0x20	; 32
    738c:	90 e0       	ldi	r25, 0x00	; 0
    738e:	b3 01       	movw	r22, r6
    7390:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    7394:	ea 94       	dec	r14
    7396:	8e 2d       	mov	r24, r14
    7398:	90 e0       	ldi	r25, 0x00	; 0
    739a:	c8 16       	cp	r12, r24
    739c:	d9 06       	cpc	r13, r25
    739e:	a8 f3       	brcs	.-22     	; 0x738a <vfprintf+0x1b8>
    73a0:	0f c0       	rjmp	.+30     	; 0x73c0 <vfprintf+0x1ee>
    73a2:	f4 01       	movw	r30, r8
    73a4:	17 fd       	sbrc	r17, 7
    73a6:	85 91       	lpm	r24, Z+
    73a8:	17 ff       	sbrs	r17, 7
    73aa:	81 91       	ld	r24, Z+
    73ac:	4f 01       	movw	r8, r30
    73ae:	90 e0       	ldi	r25, 0x00	; 0
    73b0:	b3 01       	movw	r22, r6
    73b2:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    73b6:	e1 10       	cpse	r14, r1
    73b8:	ea 94       	dec	r14
    73ba:	08 94       	sec
    73bc:	c1 08       	sbc	r12, r1
    73be:	d1 08       	sbc	r13, r1
    73c0:	c1 14       	cp	r12, r1
    73c2:	d1 04       	cpc	r13, r1
    73c4:	71 f7       	brne	.-36     	; 0x73a2 <vfprintf+0x1d0>
    73c6:	e7 c0       	rjmp	.+462    	; 0x7596 <vfprintf+0x3c4>
    73c8:	84 36       	cpi	r24, 0x64	; 100
    73ca:	11 f0       	breq	.+4      	; 0x73d0 <vfprintf+0x1fe>
    73cc:	89 36       	cpi	r24, 0x69	; 105
    73ce:	51 f5       	brne	.+84     	; 0x7424 <vfprintf+0x252>
    73d0:	f5 01       	movw	r30, r10
    73d2:	17 ff       	sbrs	r17, 7
    73d4:	07 c0       	rjmp	.+14     	; 0x73e4 <vfprintf+0x212>
    73d6:	80 81       	ld	r24, Z
    73d8:	91 81       	ldd	r25, Z+1	; 0x01
    73da:	a2 81       	ldd	r26, Z+2	; 0x02
    73dc:	b3 81       	ldd	r27, Z+3	; 0x03
    73de:	24 e0       	ldi	r18, 0x04	; 4
    73e0:	30 e0       	ldi	r19, 0x00	; 0
    73e2:	08 c0       	rjmp	.+16     	; 0x73f4 <vfprintf+0x222>
    73e4:	80 81       	ld	r24, Z
    73e6:	91 81       	ldd	r25, Z+1	; 0x01
    73e8:	aa 27       	eor	r26, r26
    73ea:	97 fd       	sbrc	r25, 7
    73ec:	a0 95       	com	r26
    73ee:	ba 2f       	mov	r27, r26
    73f0:	22 e0       	ldi	r18, 0x02	; 2
    73f2:	30 e0       	ldi	r19, 0x00	; 0
    73f4:	a2 0e       	add	r10, r18
    73f6:	b3 1e       	adc	r11, r19
    73f8:	01 2f       	mov	r16, r17
    73fa:	0f 76       	andi	r16, 0x6F	; 111
    73fc:	b7 ff       	sbrs	r27, 7
    73fe:	08 c0       	rjmp	.+16     	; 0x7410 <vfprintf+0x23e>
    7400:	b0 95       	com	r27
    7402:	a0 95       	com	r26
    7404:	90 95       	com	r25
    7406:	81 95       	neg	r24
    7408:	9f 4f       	sbci	r25, 0xFF	; 255
    740a:	af 4f       	sbci	r26, 0xFF	; 255
    740c:	bf 4f       	sbci	r27, 0xFF	; 255
    740e:	00 68       	ori	r16, 0x80	; 128
    7410:	bc 01       	movw	r22, r24
    7412:	cd 01       	movw	r24, r26
    7414:	a2 01       	movw	r20, r4
    7416:	2a e0       	ldi	r18, 0x0A	; 10
    7418:	30 e0       	ldi	r19, 0x00	; 0
    741a:	0e 94 45 3b 	call	0x768a	; 0x768a <__ultoa_invert>
    741e:	d8 2e       	mov	r13, r24
    7420:	d4 18       	sub	r13, r4
    7422:	3f c0       	rjmp	.+126    	; 0x74a2 <vfprintf+0x2d0>
    7424:	85 37       	cpi	r24, 0x75	; 117
    7426:	21 f4       	brne	.+8      	; 0x7430 <vfprintf+0x25e>
    7428:	1f 7e       	andi	r17, 0xEF	; 239
    742a:	2a e0       	ldi	r18, 0x0A	; 10
    742c:	30 e0       	ldi	r19, 0x00	; 0
    742e:	20 c0       	rjmp	.+64     	; 0x7470 <vfprintf+0x29e>
    7430:	19 7f       	andi	r17, 0xF9	; 249
    7432:	8f 36       	cpi	r24, 0x6F	; 111
    7434:	a9 f0       	breq	.+42     	; 0x7460 <vfprintf+0x28e>
    7436:	80 37       	cpi	r24, 0x70	; 112
    7438:	20 f4       	brcc	.+8      	; 0x7442 <vfprintf+0x270>
    743a:	88 35       	cpi	r24, 0x58	; 88
    743c:	09 f0       	breq	.+2      	; 0x7440 <vfprintf+0x26e>
    743e:	ae c0       	rjmp	.+348    	; 0x759c <vfprintf+0x3ca>
    7440:	0b c0       	rjmp	.+22     	; 0x7458 <vfprintf+0x286>
    7442:	80 37       	cpi	r24, 0x70	; 112
    7444:	21 f0       	breq	.+8      	; 0x744e <vfprintf+0x27c>
    7446:	88 37       	cpi	r24, 0x78	; 120
    7448:	09 f0       	breq	.+2      	; 0x744c <vfprintf+0x27a>
    744a:	a8 c0       	rjmp	.+336    	; 0x759c <vfprintf+0x3ca>
    744c:	01 c0       	rjmp	.+2      	; 0x7450 <vfprintf+0x27e>
    744e:	10 61       	ori	r17, 0x10	; 16
    7450:	14 ff       	sbrs	r17, 4
    7452:	09 c0       	rjmp	.+18     	; 0x7466 <vfprintf+0x294>
    7454:	14 60       	ori	r17, 0x04	; 4
    7456:	07 c0       	rjmp	.+14     	; 0x7466 <vfprintf+0x294>
    7458:	14 ff       	sbrs	r17, 4
    745a:	08 c0       	rjmp	.+16     	; 0x746c <vfprintf+0x29a>
    745c:	16 60       	ori	r17, 0x06	; 6
    745e:	06 c0       	rjmp	.+12     	; 0x746c <vfprintf+0x29a>
    7460:	28 e0       	ldi	r18, 0x08	; 8
    7462:	30 e0       	ldi	r19, 0x00	; 0
    7464:	05 c0       	rjmp	.+10     	; 0x7470 <vfprintf+0x29e>
    7466:	20 e1       	ldi	r18, 0x10	; 16
    7468:	30 e0       	ldi	r19, 0x00	; 0
    746a:	02 c0       	rjmp	.+4      	; 0x7470 <vfprintf+0x29e>
    746c:	20 e1       	ldi	r18, 0x10	; 16
    746e:	32 e0       	ldi	r19, 0x02	; 2
    7470:	f5 01       	movw	r30, r10
    7472:	17 ff       	sbrs	r17, 7
    7474:	07 c0       	rjmp	.+14     	; 0x7484 <vfprintf+0x2b2>
    7476:	60 81       	ld	r22, Z
    7478:	71 81       	ldd	r23, Z+1	; 0x01
    747a:	82 81       	ldd	r24, Z+2	; 0x02
    747c:	93 81       	ldd	r25, Z+3	; 0x03
    747e:	44 e0       	ldi	r20, 0x04	; 4
    7480:	50 e0       	ldi	r21, 0x00	; 0
    7482:	06 c0       	rjmp	.+12     	; 0x7490 <vfprintf+0x2be>
    7484:	60 81       	ld	r22, Z
    7486:	71 81       	ldd	r23, Z+1	; 0x01
    7488:	80 e0       	ldi	r24, 0x00	; 0
    748a:	90 e0       	ldi	r25, 0x00	; 0
    748c:	42 e0       	ldi	r20, 0x02	; 2
    748e:	50 e0       	ldi	r21, 0x00	; 0
    7490:	a4 0e       	add	r10, r20
    7492:	b5 1e       	adc	r11, r21
    7494:	a2 01       	movw	r20, r4
    7496:	0e 94 45 3b 	call	0x768a	; 0x768a <__ultoa_invert>
    749a:	d8 2e       	mov	r13, r24
    749c:	d4 18       	sub	r13, r4
    749e:	01 2f       	mov	r16, r17
    74a0:	0f 77       	andi	r16, 0x7F	; 127
    74a2:	06 ff       	sbrs	r16, 6
    74a4:	09 c0       	rjmp	.+18     	; 0x74b8 <vfprintf+0x2e6>
    74a6:	0e 7f       	andi	r16, 0xFE	; 254
    74a8:	df 14       	cp	r13, r15
    74aa:	30 f4       	brcc	.+12     	; 0x74b8 <vfprintf+0x2e6>
    74ac:	04 ff       	sbrs	r16, 4
    74ae:	06 c0       	rjmp	.+12     	; 0x74bc <vfprintf+0x2ea>
    74b0:	02 fd       	sbrc	r16, 2
    74b2:	04 c0       	rjmp	.+8      	; 0x74bc <vfprintf+0x2ea>
    74b4:	0f 7e       	andi	r16, 0xEF	; 239
    74b6:	02 c0       	rjmp	.+4      	; 0x74bc <vfprintf+0x2ea>
    74b8:	1d 2d       	mov	r17, r13
    74ba:	01 c0       	rjmp	.+2      	; 0x74be <vfprintf+0x2ec>
    74bc:	1f 2d       	mov	r17, r15
    74be:	80 2f       	mov	r24, r16
    74c0:	90 e0       	ldi	r25, 0x00	; 0
    74c2:	04 ff       	sbrs	r16, 4
    74c4:	0c c0       	rjmp	.+24     	; 0x74de <vfprintf+0x30c>
    74c6:	fe 01       	movw	r30, r28
    74c8:	ed 0d       	add	r30, r13
    74ca:	f1 1d       	adc	r31, r1
    74cc:	20 81       	ld	r18, Z
    74ce:	20 33       	cpi	r18, 0x30	; 48
    74d0:	11 f4       	brne	.+4      	; 0x74d6 <vfprintf+0x304>
    74d2:	09 7e       	andi	r16, 0xE9	; 233
    74d4:	09 c0       	rjmp	.+18     	; 0x74e8 <vfprintf+0x316>
    74d6:	02 ff       	sbrs	r16, 2
    74d8:	06 c0       	rjmp	.+12     	; 0x74e6 <vfprintf+0x314>
    74da:	1e 5f       	subi	r17, 0xFE	; 254
    74dc:	05 c0       	rjmp	.+10     	; 0x74e8 <vfprintf+0x316>
    74de:	86 78       	andi	r24, 0x86	; 134
    74e0:	90 70       	andi	r25, 0x00	; 0
    74e2:	00 97       	sbiw	r24, 0x00	; 0
    74e4:	09 f0       	breq	.+2      	; 0x74e8 <vfprintf+0x316>
    74e6:	1f 5f       	subi	r17, 0xFF	; 255
    74e8:	80 2e       	mov	r8, r16
    74ea:	99 24       	eor	r9, r9
    74ec:	03 fd       	sbrc	r16, 3
    74ee:	12 c0       	rjmp	.+36     	; 0x7514 <vfprintf+0x342>
    74f0:	00 ff       	sbrs	r16, 0
    74f2:	0d c0       	rjmp	.+26     	; 0x750e <vfprintf+0x33c>
    74f4:	fd 2c       	mov	r15, r13
    74f6:	1e 15       	cp	r17, r14
    74f8:	50 f4       	brcc	.+20     	; 0x750e <vfprintf+0x33c>
    74fa:	fe 0c       	add	r15, r14
    74fc:	f1 1a       	sub	r15, r17
    74fe:	1e 2d       	mov	r17, r14
    7500:	06 c0       	rjmp	.+12     	; 0x750e <vfprintf+0x33c>
    7502:	80 e2       	ldi	r24, 0x20	; 32
    7504:	90 e0       	ldi	r25, 0x00	; 0
    7506:	b3 01       	movw	r22, r6
    7508:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    750c:	1f 5f       	subi	r17, 0xFF	; 255
    750e:	1e 15       	cp	r17, r14
    7510:	c0 f3       	brcs	.-16     	; 0x7502 <vfprintf+0x330>
    7512:	04 c0       	rjmp	.+8      	; 0x751c <vfprintf+0x34a>
    7514:	1e 15       	cp	r17, r14
    7516:	10 f4       	brcc	.+4      	; 0x751c <vfprintf+0x34a>
    7518:	e1 1a       	sub	r14, r17
    751a:	01 c0       	rjmp	.+2      	; 0x751e <vfprintf+0x34c>
    751c:	ee 24       	eor	r14, r14
    751e:	84 fe       	sbrs	r8, 4
    7520:	0f c0       	rjmp	.+30     	; 0x7540 <vfprintf+0x36e>
    7522:	80 e3       	ldi	r24, 0x30	; 48
    7524:	90 e0       	ldi	r25, 0x00	; 0
    7526:	b3 01       	movw	r22, r6
    7528:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    752c:	82 fe       	sbrs	r8, 2
    752e:	1f c0       	rjmp	.+62     	; 0x756e <vfprintf+0x39c>
    7530:	81 fe       	sbrs	r8, 1
    7532:	03 c0       	rjmp	.+6      	; 0x753a <vfprintf+0x368>
    7534:	88 e5       	ldi	r24, 0x58	; 88
    7536:	90 e0       	ldi	r25, 0x00	; 0
    7538:	10 c0       	rjmp	.+32     	; 0x755a <vfprintf+0x388>
    753a:	88 e7       	ldi	r24, 0x78	; 120
    753c:	90 e0       	ldi	r25, 0x00	; 0
    753e:	0d c0       	rjmp	.+26     	; 0x755a <vfprintf+0x388>
    7540:	c4 01       	movw	r24, r8
    7542:	86 78       	andi	r24, 0x86	; 134
    7544:	90 70       	andi	r25, 0x00	; 0
    7546:	00 97       	sbiw	r24, 0x00	; 0
    7548:	91 f0       	breq	.+36     	; 0x756e <vfprintf+0x39c>
    754a:	81 fc       	sbrc	r8, 1
    754c:	02 c0       	rjmp	.+4      	; 0x7552 <vfprintf+0x380>
    754e:	80 e2       	ldi	r24, 0x20	; 32
    7550:	01 c0       	rjmp	.+2      	; 0x7554 <vfprintf+0x382>
    7552:	8b e2       	ldi	r24, 0x2B	; 43
    7554:	07 fd       	sbrc	r16, 7
    7556:	8d e2       	ldi	r24, 0x2D	; 45
    7558:	90 e0       	ldi	r25, 0x00	; 0
    755a:	b3 01       	movw	r22, r6
    755c:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    7560:	06 c0       	rjmp	.+12     	; 0x756e <vfprintf+0x39c>
    7562:	80 e3       	ldi	r24, 0x30	; 48
    7564:	90 e0       	ldi	r25, 0x00	; 0
    7566:	b3 01       	movw	r22, r6
    7568:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    756c:	fa 94       	dec	r15
    756e:	df 14       	cp	r13, r15
    7570:	c0 f3       	brcs	.-16     	; 0x7562 <vfprintf+0x390>
    7572:	da 94       	dec	r13
    7574:	f2 01       	movw	r30, r4
    7576:	ed 0d       	add	r30, r13
    7578:	f1 1d       	adc	r31, r1
    757a:	80 81       	ld	r24, Z
    757c:	90 e0       	ldi	r25, 0x00	; 0
    757e:	b3 01       	movw	r22, r6
    7580:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    7584:	dd 20       	and	r13, r13
    7586:	a9 f7       	brne	.-22     	; 0x7572 <vfprintf+0x3a0>
    7588:	06 c0       	rjmp	.+12     	; 0x7596 <vfprintf+0x3c4>
    758a:	80 e2       	ldi	r24, 0x20	; 32
    758c:	90 e0       	ldi	r25, 0x00	; 0
    758e:	b3 01       	movw	r22, r6
    7590:	0e 94 19 3b 	call	0x7632	; 0x7632 <fputc>
    7594:	ea 94       	dec	r14
    7596:	ee 20       	and	r14, r14
    7598:	c1 f7       	brne	.-16     	; 0x758a <vfprintf+0x3b8>
    759a:	40 ce       	rjmp	.-896    	; 0x721c <vfprintf+0x4a>
    759c:	f3 01       	movw	r30, r6
    759e:	86 81       	ldd	r24, Z+6	; 0x06
    75a0:	97 81       	ldd	r25, Z+7	; 0x07
    75a2:	02 c0       	rjmp	.+4      	; 0x75a8 <vfprintf+0x3d6>
    75a4:	8f ef       	ldi	r24, 0xFF	; 255
    75a6:	9f ef       	ldi	r25, 0xFF	; 255
    75a8:	2d 96       	adiw	r28, 0x0d	; 13
    75aa:	cd bf       	out	0x3d, r28	; 61
    75ac:	de bf       	out	0x3e, r29	; 62
    75ae:	df 91       	pop	r29
    75b0:	cf 91       	pop	r28
    75b2:	1f 91       	pop	r17
    75b4:	0f 91       	pop	r16
    75b6:	ff 90       	pop	r15
    75b8:	ef 90       	pop	r14
    75ba:	df 90       	pop	r13
    75bc:	cf 90       	pop	r12
    75be:	bf 90       	pop	r11
    75c0:	af 90       	pop	r10
    75c2:	9f 90       	pop	r9
    75c4:	8f 90       	pop	r8
    75c6:	7f 90       	pop	r7
    75c8:	6f 90       	pop	r6
    75ca:	5f 90       	pop	r5
    75cc:	4f 90       	pop	r4
    75ce:	3f 90       	pop	r3
    75d0:	2f 90       	pop	r2
    75d2:	08 95       	ret

000075d4 <strnlen_P>:
    75d4:	fc 01       	movw	r30, r24
    75d6:	05 90       	lpm	r0, Z+
    75d8:	61 50       	subi	r22, 0x01	; 1
    75da:	70 40       	sbci	r23, 0x00	; 0
    75dc:	01 10       	cpse	r0, r1
    75de:	d8 f7       	brcc	.-10     	; 0x75d6 <strnlen_P+0x2>
    75e0:	80 95       	com	r24
    75e2:	90 95       	com	r25
    75e4:	8e 0f       	add	r24, r30
    75e6:	9f 1f       	adc	r25, r31
    75e8:	08 95       	ret

000075ea <memcpy>:
    75ea:	fb 01       	movw	r30, r22
    75ec:	dc 01       	movw	r26, r24
    75ee:	02 c0       	rjmp	.+4      	; 0x75f4 <memcpy+0xa>
    75f0:	01 90       	ld	r0, Z+
    75f2:	0d 92       	st	X+, r0
    75f4:	41 50       	subi	r20, 0x01	; 1
    75f6:	50 40       	sbci	r21, 0x00	; 0
    75f8:	d8 f7       	brcc	.-10     	; 0x75f0 <memcpy+0x6>
    75fa:	08 95       	ret

000075fc <strnlen>:
    75fc:	fc 01       	movw	r30, r24
    75fe:	61 50       	subi	r22, 0x01	; 1
    7600:	70 40       	sbci	r23, 0x00	; 0
    7602:	01 90       	ld	r0, Z+
    7604:	01 10       	cpse	r0, r1
    7606:	d8 f7       	brcc	.-10     	; 0x75fe <strnlen+0x2>
    7608:	80 95       	com	r24
    760a:	90 95       	com	r25
    760c:	8e 0f       	add	r24, r30
    760e:	9f 1f       	adc	r25, r31
    7610:	08 95       	ret

00007612 <strrev>:
    7612:	dc 01       	movw	r26, r24
    7614:	fc 01       	movw	r30, r24
    7616:	67 2f       	mov	r22, r23
    7618:	71 91       	ld	r23, Z+
    761a:	77 23       	and	r23, r23
    761c:	e1 f7       	brne	.-8      	; 0x7616 <strrev+0x4>
    761e:	32 97       	sbiw	r30, 0x02	; 2
    7620:	04 c0       	rjmp	.+8      	; 0x762a <strrev+0x18>
    7622:	7c 91       	ld	r23, X
    7624:	6d 93       	st	X+, r22
    7626:	70 83       	st	Z, r23
    7628:	62 91       	ld	r22, -Z
    762a:	ae 17       	cp	r26, r30
    762c:	bf 07       	cpc	r27, r31
    762e:	c8 f3       	brcs	.-14     	; 0x7622 <strrev+0x10>
    7630:	08 95       	ret

00007632 <fputc>:
    7632:	0f 93       	push	r16
    7634:	1f 93       	push	r17
    7636:	cf 93       	push	r28
    7638:	df 93       	push	r29
    763a:	8c 01       	movw	r16, r24
    763c:	eb 01       	movw	r28, r22
    763e:	8b 81       	ldd	r24, Y+3	; 0x03
    7640:	81 ff       	sbrs	r24, 1
    7642:	1b c0       	rjmp	.+54     	; 0x767a <fputc+0x48>
    7644:	82 ff       	sbrs	r24, 2
    7646:	0d c0       	rjmp	.+26     	; 0x7662 <fputc+0x30>
    7648:	2e 81       	ldd	r18, Y+6	; 0x06
    764a:	3f 81       	ldd	r19, Y+7	; 0x07
    764c:	8c 81       	ldd	r24, Y+4	; 0x04
    764e:	9d 81       	ldd	r25, Y+5	; 0x05
    7650:	28 17       	cp	r18, r24
    7652:	39 07       	cpc	r19, r25
    7654:	64 f4       	brge	.+24     	; 0x766e <fputc+0x3c>
    7656:	e8 81       	ld	r30, Y
    7658:	f9 81       	ldd	r31, Y+1	; 0x01
    765a:	01 93       	st	Z+, r16
    765c:	e8 83       	st	Y, r30
    765e:	f9 83       	std	Y+1, r31	; 0x01
    7660:	06 c0       	rjmp	.+12     	; 0x766e <fputc+0x3c>
    7662:	e8 85       	ldd	r30, Y+8	; 0x08
    7664:	f9 85       	ldd	r31, Y+9	; 0x09
    7666:	80 2f       	mov	r24, r16
    7668:	19 95       	eicall
    766a:	00 97       	sbiw	r24, 0x00	; 0
    766c:	31 f4       	brne	.+12     	; 0x767a <fputc+0x48>
    766e:	8e 81       	ldd	r24, Y+6	; 0x06
    7670:	9f 81       	ldd	r25, Y+7	; 0x07
    7672:	01 96       	adiw	r24, 0x01	; 1
    7674:	8e 83       	std	Y+6, r24	; 0x06
    7676:	9f 83       	std	Y+7, r25	; 0x07
    7678:	02 c0       	rjmp	.+4      	; 0x767e <fputc+0x4c>
    767a:	0f ef       	ldi	r16, 0xFF	; 255
    767c:	1f ef       	ldi	r17, 0xFF	; 255
    767e:	c8 01       	movw	r24, r16
    7680:	df 91       	pop	r29
    7682:	cf 91       	pop	r28
    7684:	1f 91       	pop	r17
    7686:	0f 91       	pop	r16
    7688:	08 95       	ret

0000768a <__ultoa_invert>:
    768a:	fa 01       	movw	r30, r20
    768c:	aa 27       	eor	r26, r26
    768e:	28 30       	cpi	r18, 0x08	; 8
    7690:	51 f1       	breq	.+84     	; 0x76e6 <__ultoa_invert+0x5c>
    7692:	20 31       	cpi	r18, 0x10	; 16
    7694:	81 f1       	breq	.+96     	; 0x76f6 <__ultoa_invert+0x6c>
    7696:	e8 94       	clt
    7698:	6f 93       	push	r22
    769a:	6e 7f       	andi	r22, 0xFE	; 254
    769c:	6e 5f       	subi	r22, 0xFE	; 254
    769e:	7f 4f       	sbci	r23, 0xFF	; 255
    76a0:	8f 4f       	sbci	r24, 0xFF	; 255
    76a2:	9f 4f       	sbci	r25, 0xFF	; 255
    76a4:	af 4f       	sbci	r26, 0xFF	; 255
    76a6:	b1 e0       	ldi	r27, 0x01	; 1
    76a8:	3e d0       	rcall	.+124    	; 0x7726 <__ultoa_invert+0x9c>
    76aa:	b4 e0       	ldi	r27, 0x04	; 4
    76ac:	3c d0       	rcall	.+120    	; 0x7726 <__ultoa_invert+0x9c>
    76ae:	67 0f       	add	r22, r23
    76b0:	78 1f       	adc	r23, r24
    76b2:	89 1f       	adc	r24, r25
    76b4:	9a 1f       	adc	r25, r26
    76b6:	a1 1d       	adc	r26, r1
    76b8:	68 0f       	add	r22, r24
    76ba:	79 1f       	adc	r23, r25
    76bc:	8a 1f       	adc	r24, r26
    76be:	91 1d       	adc	r25, r1
    76c0:	a1 1d       	adc	r26, r1
    76c2:	6a 0f       	add	r22, r26
    76c4:	71 1d       	adc	r23, r1
    76c6:	81 1d       	adc	r24, r1
    76c8:	91 1d       	adc	r25, r1
    76ca:	a1 1d       	adc	r26, r1
    76cc:	20 d0       	rcall	.+64     	; 0x770e <__ultoa_invert+0x84>
    76ce:	09 f4       	brne	.+2      	; 0x76d2 <__ultoa_invert+0x48>
    76d0:	68 94       	set
    76d2:	3f 91       	pop	r19
    76d4:	2a e0       	ldi	r18, 0x0A	; 10
    76d6:	26 9f       	mul	r18, r22
    76d8:	11 24       	eor	r1, r1
    76da:	30 19       	sub	r19, r0
    76dc:	30 5d       	subi	r19, 0xD0	; 208
    76de:	31 93       	st	Z+, r19
    76e0:	de f6       	brtc	.-74     	; 0x7698 <__ultoa_invert+0xe>
    76e2:	cf 01       	movw	r24, r30
    76e4:	08 95       	ret
    76e6:	46 2f       	mov	r20, r22
    76e8:	47 70       	andi	r20, 0x07	; 7
    76ea:	40 5d       	subi	r20, 0xD0	; 208
    76ec:	41 93       	st	Z+, r20
    76ee:	b3 e0       	ldi	r27, 0x03	; 3
    76f0:	0f d0       	rcall	.+30     	; 0x7710 <__ultoa_invert+0x86>
    76f2:	c9 f7       	brne	.-14     	; 0x76e6 <__ultoa_invert+0x5c>
    76f4:	f6 cf       	rjmp	.-20     	; 0x76e2 <__ultoa_invert+0x58>
    76f6:	46 2f       	mov	r20, r22
    76f8:	4f 70       	andi	r20, 0x0F	; 15
    76fa:	40 5d       	subi	r20, 0xD0	; 208
    76fc:	4a 33       	cpi	r20, 0x3A	; 58
    76fe:	18 f0       	brcs	.+6      	; 0x7706 <__ultoa_invert+0x7c>
    7700:	49 5d       	subi	r20, 0xD9	; 217
    7702:	31 fd       	sbrc	r19, 1
    7704:	40 52       	subi	r20, 0x20	; 32
    7706:	41 93       	st	Z+, r20
    7708:	02 d0       	rcall	.+4      	; 0x770e <__ultoa_invert+0x84>
    770a:	a9 f7       	brne	.-22     	; 0x76f6 <__ultoa_invert+0x6c>
    770c:	ea cf       	rjmp	.-44     	; 0x76e2 <__ultoa_invert+0x58>
    770e:	b4 e0       	ldi	r27, 0x04	; 4
    7710:	a6 95       	lsr	r26
    7712:	97 95       	ror	r25
    7714:	87 95       	ror	r24
    7716:	77 95       	ror	r23
    7718:	67 95       	ror	r22
    771a:	ba 95       	dec	r27
    771c:	c9 f7       	brne	.-14     	; 0x7710 <__ultoa_invert+0x86>
    771e:	00 97       	sbiw	r24, 0x00	; 0
    7720:	61 05       	cpc	r22, r1
    7722:	71 05       	cpc	r23, r1
    7724:	08 95       	ret
    7726:	9b 01       	movw	r18, r22
    7728:	ac 01       	movw	r20, r24
    772a:	0a 2e       	mov	r0, r26
    772c:	06 94       	lsr	r0
    772e:	57 95       	ror	r21
    7730:	47 95       	ror	r20
    7732:	37 95       	ror	r19
    7734:	27 95       	ror	r18
    7736:	ba 95       	dec	r27
    7738:	c9 f7       	brne	.-14     	; 0x772c <__ultoa_invert+0xa2>
    773a:	62 0f       	add	r22, r18
    773c:	73 1f       	adc	r23, r19
    773e:	84 1f       	adc	r24, r20
    7740:	95 1f       	adc	r25, r21
    7742:	a0 1d       	adc	r26, r0
    7744:	08 95       	ret

00007746 <_exit>:
    7746:	f8 94       	cli

00007748 <__stop_program>:
    7748:	ff cf       	rjmp	.-2      	; 0x7748 <__stop_program>
