
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000700e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000122  00802000  0000700e  000070a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002f86  00802122  00802122  000071c4  2**0
                  ALLOC
  3 .stab         00000e70  00000000  00000000  000071c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000002e1  00000000  00000000  00008034  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000360  00000000  00000000  00008318  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008f7c  00000000  00000000  00008678  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001c99  00000000  00000000  000115f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e86  00000000  00000000  0001328d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001884  00000000  00000000  00016114  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004437  00000000  00000000  00017998  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007526  00000000  00000000  0001bdcf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  000232f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 ab 17 	jmp	0x2f56	; 0x2f56 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 5c 16 	jmp	0x2cb8	; 0x2cb8 <__vector_16>
      44:	0c 94 34 16 	jmp	0x2c68	; 0x2c68 <__vector_17>
      48:	0c 94 0c 16 	jmp	0x2c18	; 0x2c18 <__vector_18>
      4c:	0c 94 c6 15 	jmp	0x2b8c	; 0x2b8c <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 83 17 	jmp	0x2f06	; 0x2f06 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 9e 15 	jmp	0x2b3c	; 0x2b3c <__vector_79>
     140:	0c 94 76 15 	jmp	0x2aec	; 0x2aec <__vector_80>
     144:	0c 94 4e 15 	jmp	0x2a9c	; 0x2a9c <__vector_81>
     148:	0c 94 24 15 	jmp	0x2a48	; 0x2a48 <__vector_82>
     14c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 92 0e 	jmp	0x1d24	; 0x1d24 <__vector_104>
     1a4:	0c 94 f2 20 	jmp	0x41e4	; 0x41e4 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ee e0       	ldi	r30, 0x0E	; 14
     244:	f0 e7       	ldi	r31, 0x70	; 112
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a2 32       	cpi	r26, 0x22	; 34
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a2 e2       	ldi	r26, 0x22	; 34
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a8 3a       	cpi	r26, 0xA8	; 168
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 0d 2b 	call	0x561a	; 0x561a <main>
     26a:	0c 94 05 38 	jmp	0x700a	; 0x700a <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
     272:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
     274:	81 e0       	ldi	r24, 0x01	; 1
     276:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
     278:	84 81       	ldd	r24, Z+4	; 0x04
     27a:	95 81       	ldd	r25, Z+5	; 0x05
     27c:	86 1b       	sub	r24, r22
     27e:	91 09       	sbc	r25, r1

	return answer;
}
     280:	08 95       	ret

00000282 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
     282:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
     288:	84 81       	ldd	r24, Z+4	; 0x04
     28a:	95 81       	ldd	r25, Z+5	; 0x05
     28c:	77 27       	eor	r23, r23
     28e:	67 fd       	sbrc	r22, 7
     290:	70 95       	com	r23
     292:	86 1b       	sub	r24, r22
     294:	97 0b       	sbc	r25, r23

	return answer;
}
     296:	08 95       	ret

00000298 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
     298:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
     29a:	81 e0       	ldi	r24, 0x01	; 1
     29c:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
     29e:	84 81       	ldd	r24, Z+4	; 0x04
     2a0:	95 81       	ldd	r25, Z+5	; 0x05
}
     2a2:	08 95       	ret

000002a4 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
     2a4:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
     2a6:	81 e0       	ldi	r24, 0x01	; 1
     2a8:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
     2aa:	84 81       	ldd	r24, Z+4	; 0x04
}
     2ac:	08 95       	ret

000002ae <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
     2ae:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
     2b0:	81 e0       	ldi	r24, 0x01	; 1
     2b2:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
     2b4:	85 81       	ldd	r24, Z+5	; 0x05
}
     2b6:	08 95       	ret

000002b8 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
     2b8:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
     2ba:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
     2bc:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2be:	9a e2       	ldi	r25, 0x2A	; 42
     2c0:	9a 95       	dec	r25
     2c2:	f1 f7       	brne	.-4      	; 0x2c0 <ADC_Wait_8MHz+0x8>
     2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
     2c6:	84 83       	std	Z+4, r24	; 0x04
}
     2c8:	08 95       	ret

000002ca <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
     2ca:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
     2cc:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
     2ce:	91 e0       	ldi	r25, 0x01	; 1
     2d0:	94 83       	std	Z+4, r25	; 0x04
     2d2:	95 e5       	ldi	r25, 0x55	; 85
     2d4:	9a 95       	dec	r25
     2d6:	f1 f7       	brne	.-4      	; 0x2d4 <ADC_Wait_32MHz+0xa>
     2d8:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
     2da:	84 83       	std	Z+4, r24	; 0x04
}
     2dc:	08 95       	ret

000002de <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
     2de:	ef 92       	push	r14
     2e0:	ff 92       	push	r15
     2e2:	0f 93       	push	r16
     2e4:	1f 93       	push	r17
     2e6:	cf 93       	push	r28
     2e8:	df 93       	push	r29
     2ea:	eb 01       	movw	r28, r22
    if (oversampling)
     2ec:	44 23       	and	r20, r20
     2ee:	c9 f0       	breq	.+50     	; 0x322 <ADC_Offset_Get_Unsigned+0x44>
     2f0:	04 e0       	ldi	r16, 0x04	; 4
     2f2:	10 e0       	ldi	r17, 0x00	; 0
     2f4:	ee 24       	eor	r14, r14
     2f6:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
     2f8:	88 81       	ld	r24, Y
     2fa:	80 68       	ori	r24, 0x80	; 128
     2fc:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
     2fe:	8b 81       	ldd	r24, Y+3	; 0x03
     300:	80 ff       	sbrs	r24, 0
     302:	fd cf       	rjmp	.-6      	; 0x2fe <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
     304:	ce 01       	movw	r24, r28
     306:	60 e0       	ldi	r22, 0x00	; 0
     308:	0e 94 39 01 	call	0x272	; 0x272 <ADC_ResultCh_GetWord_Unsigned>
     30c:	e8 0e       	add	r14, r24
     30e:	f9 1e       	adc	r15, r25
     310:	01 50       	subi	r16, 0x01	; 1
     312:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
     314:	89 f7       	brne	.-30     	; 0x2f8 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
     316:	c7 01       	movw	r24, r14
     318:	96 95       	lsr	r25
     31a:	87 95       	ror	r24
     31c:	96 95       	lsr	r25
     31e:	87 95       	ror	r24
     320:	09 c0       	rjmp	.+18     	; 0x334 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
     322:	88 81       	ld	r24, Y
     324:	80 68       	ori	r24, 0x80	; 128
     326:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
     328:	8b 81       	ldd	r24, Y+3	; 0x03
     32a:	80 ff       	sbrs	r24, 0
     32c:	fd cf       	rjmp	.-6      	; 0x328 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
     32e:	ce 01       	movw	r24, r28
     330:	0e 94 4c 01 	call	0x298	; 0x298 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
     334:	df 91       	pop	r29
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	08 95       	ret

00000342 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
     342:	ef 92       	push	r14
     344:	ff 92       	push	r15
     346:	0f 93       	push	r16
     348:	1f 93       	push	r17
     34a:	cf 93       	push	r28
     34c:	df 93       	push	r29
     34e:	eb 01       	movw	r28, r22
    if (oversampling)
     350:	44 23       	and	r20, r20
     352:	e1 f0       	breq	.+56     	; 0x38c <ADC_Offset_Get_Signed+0x4a>
     354:	04 e0       	ldi	r16, 0x04	; 4
     356:	10 e0       	ldi	r17, 0x00	; 0
     358:	ee 24       	eor	r14, r14
     35a:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
     35c:	88 81       	ld	r24, Y
     35e:	80 68       	ori	r24, 0x80	; 128
     360:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
     362:	8b 81       	ldd	r24, Y+3	; 0x03
     364:	80 ff       	sbrs	r24, 0
     366:	fd cf       	rjmp	.-6      	; 0x362 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
     368:	ce 01       	movw	r24, r28
     36a:	60 e0       	ldi	r22, 0x00	; 0
     36c:	0e 94 41 01 	call	0x282	; 0x282 <ADC_ResultCh_GetWord_Signed>
     370:	e8 0e       	add	r14, r24
     372:	f9 1e       	adc	r15, r25
     374:	01 50       	subi	r16, 0x01	; 1
     376:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
     378:	89 f7       	brne	.-30     	; 0x35c <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
     37a:	c7 01       	movw	r24, r14
     37c:	99 23       	and	r25, r25
     37e:	0c f4       	brge	.+2      	; 0x382 <ADC_Offset_Get_Signed+0x40>
     380:	03 96       	adiw	r24, 0x03	; 3
     382:	95 95       	asr	r25
     384:	87 95       	ror	r24
     386:	95 95       	asr	r25
     388:	87 95       	ror	r24
     38a:	0a c0       	rjmp	.+20     	; 0x3a0 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
     38c:	88 81       	ld	r24, Y
     38e:	80 68       	ori	r24, 0x80	; 128
     390:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
     392:	8b 81       	ldd	r24, Y+3	; 0x03
     394:	80 ff       	sbrs	r24, 0
     396:	fd cf       	rjmp	.-6      	; 0x392 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
     398:	ce 01       	movw	r24, r28
     39a:	60 e0       	ldi	r22, 0x00	; 0
     39c:	0e 94 41 01 	call	0x282	; 0x282 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
     3a0:	df 91       	pop	r29
     3a2:	cf 91       	pop	r28
     3a4:	1f 91       	pop	r17
     3a6:	0f 91       	pop	r16
     3a8:	ff 90       	pop	r15
     3aa:	ef 90       	pop	r14
     3ac:	08 95       	ret

000003ae <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
     3ae:	aa ec       	ldi	r26, 0xCA	; 202
     3b0:	b1 e0       	ldi	r27, 0x01	; 1
     3b2:	92 e0       	ldi	r25, 0x02	; 2
     3b4:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
     3b6:	e8 2f       	mov	r30, r24
     3b8:	f0 e0       	ldi	r31, 0x00	; 0
     3ba:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
     3bc:	1c 92       	st	X, r1

	return result;
}
     3be:	08 95       	ret

000003c0 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
     3c0:	cf 93       	push	r28
     3c2:	df 93       	push	r29
     3c4:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
     3c6:	82 e0       	ldi	r24, 0x02	; 2
     3c8:	c0 30       	cpi	r28, 0x00	; 0
     3ca:	d8 07       	cpc	r29, r24
     3cc:	59 f4       	brne	.+22     	; 0x3e4 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
     3ce:	80 e2       	ldi	r24, 0x20	; 32
     3d0:	0e 94 d7 01 	call	0x3ae	; 0x3ae <SP_ReadCalibrationByte>
     3d4:	c0 e0       	ldi	r28, 0x00	; 0
     3d6:	d2 e0       	ldi	r29, 0x02	; 2
     3d8:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
     3da:	81 e2       	ldi	r24, 0x21	; 33
     3dc:	0e 94 d7 01 	call	0x3ae	; 0x3ae <SP_ReadCalibrationByte>
     3e0:	8d 87       	std	Y+13, r24	; 0x0d
     3e2:	08 c0       	rjmp	.+16     	; 0x3f4 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
     3e4:	84 e2       	ldi	r24, 0x24	; 36
     3e6:	0e 94 d7 01 	call	0x3ae	; 0x3ae <SP_ReadCalibrationByte>
     3ea:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
     3ec:	85 e2       	ldi	r24, 0x25	; 37
     3ee:	0e 94 d7 01 	call	0x3ae	; 0x3ae <SP_ReadCalibrationByte>
     3f2:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	08 95       	ret

000003fa <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
     3fa:	84 e1       	ldi	r24, 0x14	; 20
     3fc:	e2 e2       	ldi	r30, 0x22	; 34
     3fe:	f1 e2       	ldi	r31, 0x21	; 33
     400:	df 01       	movw	r26, r30
     402:	1d 92       	st	X+, r1
     404:	8a 95       	dec	r24
     406:	e9 f7       	brne	.-6      	; 0x402 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
     408:	0e 94 34 05 	call	0xa68	; 0xa68 <chb_get_short_addr>
     40c:	80 93 22 21 	sts	0x2122, r24
     410:	90 93 23 21 	sts	0x2123, r25
    chb_drvr_init();
     414:	0e 94 9e 05 	call	0xb3c	; 0xb3c <chb_drvr_init>
}
     418:	08 95       	ret

0000041a <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
     41a:	82 e2       	ldi	r24, 0x22	; 34
     41c:	91 e2       	ldi	r25, 0x21	; 33
     41e:	08 95       	ret

00000420 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
     420:	2f 92       	push	r2
     422:	3f 92       	push	r3
     424:	4f 92       	push	r4
     426:	5f 92       	push	r5
     428:	6f 92       	push	r6
     42a:	7f 92       	push	r7
     42c:	8f 92       	push	r8
     42e:	9f 92       	push	r9
     430:	af 92       	push	r10
     432:	bf 92       	push	r11
     434:	cf 92       	push	r12
     436:	df 92       	push	r13
     438:	ef 92       	push	r14
     43a:	ff 92       	push	r15
     43c:	0f 93       	push	r16
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
     444:	cd b7       	in	r28, 0x3d	; 61
     446:	de b7       	in	r29, 0x3e	; 62
     448:	2e 97       	sbiw	r28, 0x0e	; 14
     44a:	cd bf       	out	0x3d, r28	; 61
     44c:	de bf       	out	0x3e, r29	; 62
     44e:	8b 87       	std	Y+11, r24	; 0x0b
     450:	9c 87       	std	Y+12, r25	; 0x0c
     452:	6d 87       	std	Y+13, r22	; 0x0d
     454:	7e 87       	std	Y+14, r23	; 0x0e
     456:	49 01       	movw	r8, r18
     458:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
     45a:	21 15       	cp	r18, r1
     45c:	31 05       	cpc	r19, r1
     45e:	41 05       	cpc	r20, r1
     460:	51 05       	cpc	r21, r1
     462:	09 f4       	brne	.+2      	; 0x466 <chb_write+0x46>
     464:	85 c0       	rjmp	.+266    	; 0x570 <chb_write+0x150>
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
     466:	ee 24       	eor	r14, r14
             case CHB_NO_ACK:
                 pcb.txd_noack++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
     468:	0f 2e       	mov	r0, r31
     46a:	fd e2       	ldi	r31, 0x2D	; 45
     46c:	6f 2e       	mov	r6, r31
     46e:	f1 e2       	ldi	r31, 0x21	; 33
     470:	7f 2e       	mov	r7, r31
     472:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
     474:	0f 2e       	mov	r0, r31
     476:	f9 e2       	ldi	r31, 0x29	; 41
     478:	4f 2e       	mov	r4, r31
     47a:	f1 e2       	ldi	r31, 0x21	; 33
     47c:	5f 2e       	mov	r5, r31
     47e:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
     480:	0f 2e       	mov	r0, r31
     482:	fb e2       	ldi	r31, 0x2B	; 43
     484:	2f 2e       	mov	r2, r31
     486:	f1 e2       	ldi	r31, 0x21	; 33
     488:	3f 2e       	mov	r3, r31
     48a:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
     48c:	f8 2c       	mov	r15, r8
     48e:	25 e6       	ldi	r18, 0x65	; 101
     490:	82 16       	cp	r8, r18
     492:	91 04       	cpc	r9, r1
     494:	a1 04       	cpc	r10, r1
     496:	b1 04       	cpc	r11, r1
     498:	20 f0       	brcs	.+8      	; 0x4a2 <chb_write+0x82>
     49a:	0f 2e       	mov	r0, r31
     49c:	f4 e6       	ldi	r31, 0x64	; 100
     49e:	ff 2e       	mov	r15, r31
     4a0:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
     4a2:	8f 2d       	mov	r24, r15
     4a4:	85 5f       	subi	r24, 0xF5	; 245
     4a6:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
     4a8:	8b 85       	ldd	r24, Y+11	; 0x0b
     4aa:	9c 85       	ldd	r25, Y+12	; 0x0c
     4ac:	ef ef       	ldi	r30, 0xFF	; 255
     4ae:	8f 3f       	cpi	r24, 0xFF	; 255
     4b0:	9e 07       	cpc	r25, r30
     4b2:	11 f0       	breq	.+4      	; 0x4b8 <chb_write+0x98>
     4b4:	81 e6       	ldi	r24, 0x61	; 97
     4b6:	01 c0       	rjmp	.+2      	; 0x4ba <chb_write+0x9a>
     4b8:	81 e4       	ldi	r24, 0x41	; 65
     4ba:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
     4bc:	88 e9       	ldi	r24, 0x98	; 152
     4be:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
     4c0:	e4 e2       	ldi	r30, 0x24	; 36
     4c2:	f1 e2       	ldi	r31, 0x21	; 33
     4c4:	80 81       	ld	r24, Z
     4c6:	8c 83       	std	Y+4, r24	; 0x04
     4c8:	8f 5f       	subi	r24, 0xFF	; 255
     4ca:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
     4cc:	84 e3       	ldi	r24, 0x34	; 52
     4ce:	92 e1       	ldi	r25, 0x12	; 18
     4d0:	8d 83       	std	Y+5, r24	; 0x05
     4d2:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
     4d4:	8b 85       	ldd	r24, Y+11	; 0x0b
     4d6:	9c 85       	ldd	r25, Y+12	; 0x0c
     4d8:	8f 83       	std	Y+7, r24	; 0x07
     4da:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
     4dc:	32 97       	sbiw	r30, 0x02	; 2
     4de:	80 81       	ld	r24, Z
     4e0:	91 81       	ldd	r25, Z+1	; 0x01
     4e2:	89 87       	std	Y+9, r24	; 0x09
     4e4:	9a 87       	std	Y+10, r25	; 0x0a

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
     4e6:	00 e0       	ldi	r16, 0x00	; 0
     4e8:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
     4ea:	cd 84       	ldd	r12, Y+13	; 0x0d
     4ec:	de 84       	ldd	r13, Y+14	; 0x0e
     4ee:	ce 0c       	add	r12, r14
     4f0:	d1 1c       	adc	r13, r1
     4f2:	ce 01       	movw	r24, r28
     4f4:	01 96       	adiw	r24, 0x01	; 1
     4f6:	b6 01       	movw	r22, r12
     4f8:	4f 2d       	mov	r20, r15
     4fa:	0e 94 4a 05 	call	0xa94	; 0xa94 <chb_tx>
     4fe:	28 2f       	mov	r18, r24

             switch (status)
     500:	83 30       	cpi	r24, 0x03	; 3
     502:	b9 f0       	breq	.+46     	; 0x532 <chb_write+0x112>
     504:	84 30       	cpi	r24, 0x04	; 4
     506:	18 f4       	brcc	.+6      	; 0x50e <chb_write+0xee>
     508:	81 30       	cpi	r24, 0x01	; 1
     50a:	c9 f4       	brne	.+50     	; 0x53e <chb_write+0x11e>
     50c:	04 c0       	rjmp	.+8      	; 0x516 <chb_write+0xf6>
     50e:	85 30       	cpi	r24, 0x05	; 5
     510:	49 f0       	breq	.+18     	; 0x524 <chb_write+0x104>
     512:	80 34       	cpi	r24, 0x40	; 64
     514:	a1 f4       	brne	.+40     	; 0x53e <chb_write+0x11e>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
     516:	f2 01       	movw	r30, r4
     518:	80 81       	ld	r24, Z
     51a:	91 81       	ldd	r25, Z+1	; 0x01
     51c:	01 96       	adiw	r24, 0x01	; 1
     51e:	80 83       	st	Z, r24
     520:	91 83       	std	Z+1, r25	; 0x01
                 break;
     522:	0d c0       	rjmp	.+26     	; 0x53e <chb_write+0x11e>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
     524:	f1 01       	movw	r30, r2
     526:	80 81       	ld	r24, Z
     528:	91 81       	ldd	r25, Z+1	; 0x01
     52a:	01 96       	adiw	r24, 0x01	; 1
     52c:	80 83       	st	Z, r24
     52e:	91 83       	std	Z+1, r25	; 0x01
                 break;
     530:	06 c0       	rjmp	.+12     	; 0x53e <chb_write+0x11e>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
     532:	f3 01       	movw	r30, r6
     534:	80 81       	ld	r24, Z
     536:	91 81       	ldd	r25, Z+1	; 0x01
     538:	01 96       	adiw	r24, 0x01	; 1
     53a:	80 83       	st	Z, r24
     53c:	91 83       	std	Z+1, r25	; 0x01
                 break;
 
             default:
                 break;
             }
			if(rtry>=0) _delay_us(100);		//if not successfully sent the first time, wait some time and try again
     53e:	11 23       	and	r17, r17
     540:	24 f0       	brlt	.+8      	; 0x54a <chb_write+0x12a>
     542:	f1 e2       	ldi	r31, 0x21	; 33
     544:	fa 95       	dec	r31
     546:	f1 f7       	brne	.-4      	; 0x544 <chb_write+0x124>
     548:	00 00       	nop
			if(rtry==20) return status;;		//after 20 tries give up on sending the message
     54a:	04 31       	cpi	r16, 0x14	; 20
     54c:	11 05       	cpc	r17, r1
     54e:	89 f0       	breq	.+34     	; 0x572 <chb_write+0x152>
			rtry++;	
     550:	0f 5f       	subi	r16, 0xFF	; 255
     552:	1f 4f       	sbci	r17, 0xFF	; 255
		} while(status != CHB_SUCCESS);			
     554:	22 23       	and	r18, r18
     556:	69 f6       	brne	.-102    	; 0x4f2 <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
     558:	ef 0c       	add	r14, r15
        len = len - frm_len;
     55a:	8f 18       	sub	r8, r15
     55c:	91 08       	sbc	r9, r1
     55e:	a1 08       	sbc	r10, r1
     560:	b1 08       	sbc	r11, r1
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
     562:	81 14       	cp	r8, r1
     564:	91 04       	cpc	r9, r1
     566:	a1 04       	cpc	r10, r1
     568:	b1 04       	cpc	r11, r1
     56a:	09 f0       	breq	.+2      	; 0x56e <chb_write+0x14e>
     56c:	8f cf       	rjmp	.-226    	; 0x48c <chb_write+0x6c>
     56e:	01 c0       	rjmp	.+2      	; 0x572 <chb_write+0x152>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
     570:	20 e0       	ldi	r18, 0x00	; 0
}
     572:	82 2f       	mov	r24, r18
     574:	2e 96       	adiw	r28, 0x0e	; 14
     576:	cd bf       	out	0x3d, r28	; 61
     578:	de bf       	out	0x3e, r29	; 62
     57a:	df 91       	pop	r29
     57c:	cf 91       	pop	r28
     57e:	1f 91       	pop	r17
     580:	0f 91       	pop	r16
     582:	ff 90       	pop	r15
     584:	ef 90       	pop	r14
     586:	df 90       	pop	r13
     588:	cf 90       	pop	r12
     58a:	bf 90       	pop	r11
     58c:	af 90       	pop	r10
     58e:	9f 90       	pop	r9
     590:	8f 90       	pop	r8
     592:	7f 90       	pop	r7
     594:	6f 90       	pop	r6
     596:	5f 90       	pop	r5
     598:	4f 90       	pop	r4
     59a:	3f 90       	pop	r3
     59c:	2f 90       	pop	r2
     59e:	08 95       	ret

000005a0 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	0f 93       	push	r16
     5a8:	1f 93       	push	r17
     5aa:	cf 93       	push	r28
     5ac:	df 93       	push	r29
     5ae:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
     5b0:	0e 94 4b 03 	call	0x696	; 0x696 <chb_buf_read>
     5b4:	d8 2e       	mov	r13, r24
     5b6:	88 23       	and	r24, r24
     5b8:	0c f4       	brge	.+2      	; 0x5bc <chb_read+0x1c>
     5ba:	46 c0       	rjmp	.+140    	; 0x648 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
     5bc:	f7 01       	movw	r30, r14
     5be:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
     5c0:	88 23       	and	r24, r24
     5c2:	71 f0       	breq	.+28     	; 0x5e0 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
     5c4:	e7 01       	movw	r28, r14
     5c6:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
     5c8:	87 01       	movw	r16, r14
     5ca:	09 5f       	subi	r16, 0xF9	; 249
     5cc:	1f 4f       	sbci	r17, 0xFF	; 255
     5ce:	81 50       	subi	r24, 0x01	; 1
     5d0:	08 0f       	add	r16, r24
     5d2:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
     5d4:	0e 94 4b 03 	call	0x696	; 0x696 <chb_buf_read>
     5d8:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
     5da:	c0 17       	cp	r28, r16
     5dc:	d1 07       	cpc	r29, r17
     5de:	d1 f7       	brne	.-12     	; 0x5d4 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
     5e0:	f7 01       	movw	r30, r14
     5e2:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
     5e4:	83 85       	ldd	r24, Z+11	; 0x0b
     5e6:	94 85       	ldd	r25, Z+12	; 0x0c
     5e8:	83 83       	std	Z+3, r24	; 0x03
     5ea:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
     5ec:	85 85       	ldd	r24, Z+13	; 0x0d
     5ee:	96 85       	ldd	r25, Z+14	; 0x0e
     5f0:	81 83       	std	Z+1, r24	; 0x01
     5f2:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
     5f4:	0e 94 62 03 	call	0x6c4	; 0x6c4 <chb_buf_get_len>
     5f8:	88 23       	and	r24, r24
     5fa:	11 f4       	brne	.+4      	; 0x600 <chb_read+0x60>
    {
        pcb.data_rcv = false;
     5fc:	10 92 25 21 	sts	0x2125, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
     600:	80 91 00 20 	lds	r24, 0x2000
     604:	c8 17       	cp	r28, r24
     606:	51 f4       	brne	.+20     	; 0x61c <chb_read+0x7c>
     608:	f7 01       	movw	r30, r14
     60a:	21 81       	ldd	r18, Z+1	; 0x01
     60c:	32 81       	ldd	r19, Z+2	; 0x02
     60e:	80 91 01 20 	lds	r24, 0x2001
     612:	90 91 02 20 	lds	r25, 0x2002
     616:	28 17       	cp	r18, r24
     618:	39 07       	cpc	r19, r25
     61a:	c1 f0       	breq	.+48     	; 0x64c <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
     61c:	c0 93 00 20 	sts	0x2000, r28
        prev_src_addr = rx->src_addr;
     620:	f7 01       	movw	r30, r14
     622:	81 81       	ldd	r24, Z+1	; 0x01
     624:	92 81       	ldd	r25, Z+2	; 0x02
     626:	80 93 01 20 	sts	0x2001, r24
     62a:	90 93 02 20 	sts	0x2002, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
     62e:	b7 01       	movw	r22, r14
     630:	61 5f       	subi	r22, 0xF1	; 241
     632:	7f 4f       	sbci	r23, 0xFF	; 255
     634:	4d 2d       	mov	r20, r13
     636:	50 e0       	ldi	r21, 0x00	; 0
     638:	49 50       	subi	r20, 0x09	; 9
     63a:	50 40       	sbci	r21, 0x00	; 0
     63c:	c7 01       	movw	r24, r14
     63e:	0e 94 37 35 	call	0x6a6e	; 0x6a6e <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
     642:	8d 2d       	mov	r24, r13
     644:	8b 50       	subi	r24, 0x0B	; 11
     646:	03 c0       	rjmp	.+6      	; 0x64e <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
     648:	80 e0       	ldi	r24, 0x00	; 0
     64a:	01 c0       	rjmp	.+2      	; 0x64e <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
     64c:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
     64e:	df 91       	pop	r29
     650:	cf 91       	pop	r28
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	08 95       	ret

0000065e <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
     65e:	10 92 36 21 	sts	0x2136, r1
    wr_ptr = 0;
     662:	10 92 37 21 	sts	0x2137, r1
    len = 0;
     666:	10 92 38 21 	sts	0x2138, r1
}
     66a:	08 95       	ret

0000066c <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
     66c:	20 91 37 21 	lds	r18, 0x2137
     670:	30 e0       	ldi	r19, 0x00	; 0
     672:	f9 01       	movw	r30, r18
     674:	e7 5c       	subi	r30, 0xC7	; 199
     676:	fe 4d       	sbci	r31, 0xDE	; 222
     678:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
     67a:	c9 01       	movw	r24, r18
     67c:	01 96       	adiw	r24, 0x01	; 1
     67e:	60 e8       	ldi	r22, 0x80	; 128
     680:	70 e0       	ldi	r23, 0x00	; 0
     682:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
     686:	80 93 37 21 	sts	0x2137, r24
    len++;
     68a:	80 91 38 21 	lds	r24, 0x2138
     68e:	8f 5f       	subi	r24, 0xFF	; 255
     690:	80 93 38 21 	sts	0x2138, r24
}
     694:	08 95       	ret

00000696 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
     696:	20 91 36 21 	lds	r18, 0x2136
     69a:	30 e0       	ldi	r19, 0x00	; 0
     69c:	f9 01       	movw	r30, r18
     69e:	e7 5c       	subi	r30, 0xC7	; 199
     6a0:	fe 4d       	sbci	r31, 0xDE	; 222
     6a2:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
     6a4:	2f 5f       	subi	r18, 0xFF	; 255
     6a6:	3f 4f       	sbci	r19, 0xFF	; 255
     6a8:	c9 01       	movw	r24, r18
     6aa:	60 e8       	ldi	r22, 0x80	; 128
     6ac:	70 e0       	ldi	r23, 0x00	; 0
     6ae:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
     6b2:	80 93 36 21 	sts	0x2136, r24
    len--;
     6b6:	80 91 38 21 	lds	r24, 0x2138
     6ba:	81 50       	subi	r24, 0x01	; 1
     6bc:	80 93 38 21 	sts	0x2138, r24
    return data;
}
     6c0:	84 2f       	mov	r24, r20
     6c2:	08 95       	ret

000006c4 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
     6c4:	80 91 38 21 	lds	r24, 0x2138
     6c8:	08 95       	ret

000006ca <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
     6ca:	cf 93       	push	r28
     6cc:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
     6ce:	8f b7       	in	r24, 0x3f	; 63
     6d0:	80 93 bf 21 	sts	0x21BF, r24
     6d4:	f8 94       	cli
    RadioCS(TRUE);
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
     6dc:	8c 2f       	mov	r24, r28
     6de:	80 68       	ori	r24, 0x80	; 128
     6e0:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
    val = SPID_write(val);
     6e4:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
     6e8:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
     6ea:	80 e0       	ldi	r24, 0x00	; 0
     6ec:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>
    CHB_LEAVE_CRIT();
     6f0:	80 91 bf 21 	lds	r24, 0x21BF
     6f4:	8f bf       	out	0x3f, r24	; 63
     6f6:	78 94       	sei

    return val;
}
     6f8:	8c 2f       	mov	r24, r28
     6fa:	cf 91       	pop	r28
     6fc:	08 95       	ret

000006fe <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
}
     704:	8f 71       	andi	r24, 0x1F	; 31
     706:	08 95       	ret

00000708 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
     708:	e4 e6       	ldi	r30, 0x64	; 100
     70a:	f6 e0       	ldi	r31, 0x06	; 6
     70c:	80 81       	ld	r24, Z
     70e:	81 60       	ori	r24, 0x01	; 1
     710:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
     712:	80 81       	ld	r24, Z
     714:	8d 7f       	andi	r24, 0xFD	; 253
     716:	80 83       	st	Z, r24
     718:	8e e7       	ldi	r24, 0x7E	; 126
     71a:	8a 95       	dec	r24
     71c:	f1 f7       	brne	.-4      	; 0x71a <chb_reset+0x12>
     71e:	00 c0       	rjmp	.+0      	; 0x720 <chb_reset+0x18>

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
     720:	80 81       	ld	r24, Z
     722:	8e 7f       	andi	r24, 0xFE	; 254
     724:	80 83       	st	Z, r24
     726:	00 00       	nop
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
     728:	80 81       	ld	r24, Z
     72a:	81 60       	ori	r24, 0x01	; 1
     72c:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
     72e:	8d e1       	ldi	r24, 0x1D	; 29
     730:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     734:	81 30       	cpi	r24, 0x01	; 1
     736:	d9 f7       	brne	.-10     	; 0x72e <chb_reset+0x26>
     738:	8c e1       	ldi	r24, 0x1C	; 28
     73a:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     73e:	87 30       	cpi	r24, 0x07	; 7
     740:	b1 f7       	brne	.-20     	; 0x72e <chb_reset+0x26>
            break;
        }
    }
	

}
     742:	08 95       	ret

00000744 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
     744:	cf 93       	push	r28
     746:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
     748:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     74c:	8c 2b       	or	r24, r28
     74e:	8f 5f       	subi	r24, 0xFF	; 255
     750:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
    }
    return val;
}
     754:	80 e0       	ldi	r24, 0x00	; 0
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	cf 91       	pop	r28
     75a:	08 95       	ret

0000075c <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	d8 2f       	mov	r29, r24
     762:	c6 2f       	mov	r28, r22
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
     764:	8f b7       	in	r24, 0x3f	; 63
     766:	80 93 bf 21 	sts	0x21BF, r24
     76a:	f8 94       	cli
    RadioCS(TRUE);
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
     772:	8d 2f       	mov	r24, r29
     774:	80 6c       	ori	r24, 0xC0	; 192
     776:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
    dummy = SPID_write(val);
     77a:	8c 2f       	mov	r24, r28
     77c:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>

    RadioCS(FALSE);
     780:	80 e0       	ldi	r24, 0x00	; 0
     782:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>
    CHB_LEAVE_CRIT();
     786:	80 91 bf 21 	lds	r24, 0x21BF
     78a:	8f bf       	out	0x3f, r24	; 63
     78c:	78 94       	sei
}
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	08 95       	ret

00000794 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	c8 2f       	mov	r28, r24
     79a:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
     79c:	0e 94 ae 03 	call	0x75c	; 0x75c <chb_reg_write>
     7a0:	8c 2f       	mov	r24, r28
     7a2:	8f 5f       	subi	r24, 0xFF	; 255
     7a4:	6d 2f       	mov	r22, r29
     7a6:	0e 94 ae 03 	call	0x75c	; 0x75c <chb_reg_write>
    }
}
     7aa:	df 91       	pop	r29
     7ac:	cf 91       	pop	r28
     7ae:	08 95       	ret

000007b0 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
     7b0:	0f 93       	push	r16
     7b2:	1f 93       	push	r17
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
     7ba:	c6 2f       	mov	r28, r22
     7bc:	d7 2f       	mov	r29, r23
     7be:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
     7c0:	69 91       	ld	r22, Y+
     7c2:	81 2f       	mov	r24, r17
     7c4:	80 0f       	add	r24, r16
     7c6:	0e 94 ae 03 	call	0x75c	; 0x75c <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
     7ca:	1f 5f       	subi	r17, 0xFF	; 255
     7cc:	18 30       	cpi	r17, 0x08	; 8
     7ce:	c1 f7       	brne	.-16     	; 0x7c0 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	1f 91       	pop	r17
     7d6:	0f 91       	pop	r16
     7d8:	08 95       	ret

000007da <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
     7da:	1f 93       	push	r17
     7dc:	cf 93       	push	r28
     7de:	df 93       	push	r29
     7e0:	c8 2f       	mov	r28, r24
     7e2:	16 2f       	mov	r17, r22
     7e4:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
     7e6:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
     7ea:	6d 2f       	mov	r22, r29
     7ec:	60 95       	com	r22
     7ee:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
     7f0:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
     7f2:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
     7f4:	8c 2f       	mov	r24, r28
     7f6:	0e 94 ae 03 	call	0x75c	; 0x75c <chb_reg_write>
}
     7fa:	df 91       	pop	r29
     7fc:	cf 91       	pop	r28
     7fe:	1f 91       	pop	r17
     800:	08 95       	ret

00000802 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
     802:	df 92       	push	r13
     804:	ef 92       	push	r14
     806:	ff 92       	push	r15
     808:	0f 93       	push	r16
     80a:	1f 93       	push	r17
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
     810:	8c 01       	movw	r16, r24
     812:	c6 2f       	mov	r28, r22
     814:	7a 01       	movw	r14, r20
     816:	d2 2e       	mov	r13, r18
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
     818:	82 2f       	mov	r24, r18
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	86 0f       	add	r24, r22
     81e:	91 1d       	adc	r25, r1
     820:	80 38       	cpi	r24, 0x80	; 128
     822:	91 05       	cpc	r25, r1
     824:	8c f5       	brge	.+98     	; 0x888 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
     826:	8f b7       	in	r24, 0x3f	; 63
     828:	80 93 bf 21 	sts	0x21BF, r24
     82c:	f8 94       	cli
    RadioCS(TRUE); 
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
     834:	80 e6       	ldi	r24, 0x60	; 96
     836:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
     83a:	cc 23       	and	r28, r28
     83c:	79 f0       	breq	.+30     	; 0x85c <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
     83e:	c8 01       	movw	r24, r16
     840:	01 96       	adiw	r24, 0x01	; 1
     842:	c1 50       	subi	r28, 0x01	; 1
     844:	9c 01       	movw	r18, r24
     846:	2c 0f       	add	r18, r28
     848:	31 1d       	adc	r19, r1
     84a:	e9 01       	movw	r28, r18
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        dummy = SPID_write(*hdr++);
     84c:	f8 01       	movw	r30, r16
     84e:	81 91       	ld	r24, Z+
     850:	8f 01       	movw	r16, r30
     852:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
     856:	0c 17       	cp	r16, r28
     858:	1d 07       	cpc	r17, r29
     85a:	c1 f7       	brne	.-16     	; 0x84c <chb_frame_write+0x4a>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
     85c:	dd 20       	and	r13, r13
     85e:	69 f0       	breq	.+26     	; 0x87a <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
     860:	e7 01       	movw	r28, r14
     862:	21 96       	adiw	r28, 0x01	; 1
     864:	da 94       	dec	r13
     866:	cd 0d       	add	r28, r13
     868:	d1 1d       	adc	r29, r1
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        dummy = SPID_write(*data++);
     86a:	f7 01       	movw	r30, r14
     86c:	81 91       	ld	r24, Z+
     86e:	7f 01       	movw	r14, r30
     870:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
     874:	ec 16       	cp	r14, r28
     876:	fd 06       	cpc	r15, r29
     878:	c1 f7       	brne	.-16     	; 0x86a <chb_frame_write+0x68>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
     87a:	80 e0       	ldi	r24, 0x00	; 0
     87c:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>
    CHB_LEAVE_CRIT();
     880:	80 91 bf 21 	lds	r24, 0x21BF
     884:	8f bf       	out	0x3f, r24	; 63
     886:	78 94       	sei
}
     888:	df 91       	pop	r29
     88a:	cf 91       	pop	r28
     88c:	1f 91       	pop	r17
     88e:	0f 91       	pop	r16
     890:	ff 90       	pop	r15
     892:	ef 90       	pop	r14
     894:	df 90       	pop	r13
     896:	08 95       	ret

00000898 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
     898:	81 30       	cpi	r24, 0x01	; 1
     89a:	91 f0       	breq	.+36     	; 0x8c0 <chb_set_mode+0x28>
     89c:	81 30       	cpi	r24, 0x01	; 1
     89e:	28 f0       	brcs	.+10     	; 0x8aa <chb_set_mode+0x12>
     8a0:	82 30       	cpi	r24, 0x02	; 2
     8a2:	c9 f0       	breq	.+50     	; 0x8d6 <chb_set_mode+0x3e>
     8a4:	83 30       	cpi	r24, 0x03	; 3
     8a6:	61 f5       	brne	.+88     	; 0x900 <chb_set_mode+0x68>
     8a8:	21 c0       	rjmp	.+66     	; 0x8ec <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
     8aa:	8c e0       	ldi	r24, 0x0C	; 12
     8ac:	68 e0       	ldi	r22, 0x08	; 8
     8ae:	4f e3       	ldi	r20, 0x3F	; 63
     8b0:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
     8b4:	86 e1       	ldi	r24, 0x16	; 22
     8b6:	62 e0       	ldi	r22, 0x02	; 2
     8b8:	43 e0       	ldi	r20, 0x03	; 3
     8ba:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
        break;
     8be:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
     8c0:	8c e0       	ldi	r24, 0x0C	; 12
     8c2:	6c e0       	ldi	r22, 0x0C	; 12
     8c4:	4f e3       	ldi	r20, 0x3F	; 63
     8c6:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
     8ca:	86 e1       	ldi	r24, 0x16	; 22
     8cc:	62 e0       	ldi	r22, 0x02	; 2
     8ce:	43 e0       	ldi	r20, 0x03	; 3
     8d0:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
        break;
     8d4:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
     8d6:	8c e0       	ldi	r24, 0x0C	; 12
     8d8:	6c e1       	ldi	r22, 0x1C	; 28
     8da:	4f e3       	ldi	r20, 0x3F	; 63
     8dc:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
     8e0:	86 e1       	ldi	r24, 0x16	; 22
     8e2:	62 e0       	ldi	r22, 0x02	; 2
     8e4:	43 e0       	ldi	r20, 0x03	; 3
     8e6:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
        break;
     8ea:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
     8ec:	8c e0       	ldi	r24, 0x0C	; 12
     8ee:	60 e0       	ldi	r22, 0x00	; 0
     8f0:	4f e3       	ldi	r20, 0x3F	; 63
     8f2:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
     8f6:	86 e1       	ldi	r24, 0x16	; 22
     8f8:	63 e0       	ldi	r22, 0x03	; 3
     8fa:	43 e0       	ldi	r20, 0x03	; 3
     8fc:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
     900:	08 95       	ret

00000902 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
     902:	cf 93       	push	r28
     904:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
     906:	88 e0       	ldi	r24, 0x08	; 8
     908:	6c 2f       	mov	r22, r28
     90a:	4f e1       	ldi	r20, 0x1F	; 31
     90c:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
     910:	0e 94 7f 03 	call	0x6fe	; 0x6fe <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
     914:	86 30       	cpi	r24, 0x06	; 6
     916:	11 f0       	breq	.+4      	; 0x91c <chb_set_channel+0x1a>
     918:	89 30       	cpi	r24, 0x09	; 9
     91a:	21 f4       	brne	.+8      	; 0x924 <chb_set_channel+0x22>
     91c:	84 e2       	ldi	r24, 0x24	; 36
     91e:	8a 95       	dec	r24
     920:	f1 f7       	brne	.-4      	; 0x91e <chb_set_channel+0x1c>
     922:	00 c0       	rjmp	.+0      	; 0x924 <chb_set_channel+0x22>
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
     924:	88 e0       	ldi	r24, 0x08	; 8
     926:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     92a:	90 e0       	ldi	r25, 0x00	; 0
     92c:	8f 71       	andi	r24, 0x1F	; 31
     92e:	90 70       	andi	r25, 0x00	; 0
     930:	6c 2f       	mov	r22, r28
     932:	70 e0       	ldi	r23, 0x00	; 0
     934:	86 17       	cp	r24, r22
     936:	97 07       	cpc	r25, r23
     938:	11 f4       	brne	.+4      	; 0x93e <chb_set_channel+0x3c>
     93a:	80 e4       	ldi	r24, 0x40	; 64
     93c:	01 c0       	rjmp	.+2      	; 0x940 <chb_set_channel+0x3e>
     93e:	83 e4       	ldi	r24, 0x43	; 67
}
     940:	cf 91       	pop	r28
     942:	08 95       	ret

00000944 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
     944:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
     946:	85 e0       	ldi	r24, 0x05	; 5
     948:	0e 94 ae 03 	call	0x75c	; 0x75c <chb_reg_write>
}
     94c:	08 95       	ret

0000094e <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
     94e:	cf 93       	push	r28
     950:	df 93       	push	r29
     952:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
     954:	80 91 64 06 	lds	r24, 0x0664
     958:	81 fd       	sbrc	r24, 1
     95a:	40 c0       	rjmp	.+128    	; 0x9dc <chb_set_state+0x8e>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
     95c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <chb_get_state>
     960:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
     962:	81 51       	subi	r24, 0x11	; 17
     964:	82 30       	cpi	r24, 0x02	; 2
     966:	20 f0       	brcs	.+8      	; 0x970 <chb_set_state+0x22>
     968:	c1 30       	cpi	r28, 0x01	; 1
     96a:	11 f0       	breq	.+4      	; 0x970 <chb_set_state+0x22>
     96c:	c2 30       	cpi	r28, 0x02	; 2
     96e:	21 f4       	brne	.+8      	; 0x978 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
     970:	0e 94 7f 03 	call	0x6fe	; 0x6fe <chb_get_state>
     974:	8c 17       	cp	r24, r28
     976:	e1 f3       	breq	.-8      	; 0x970 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
     978:	d6 31       	cpi	r29, 0x16	; 22
     97a:	c9 f0       	breq	.+50     	; 0x9ae <chb_set_state+0x60>
     97c:	d9 31       	cpi	r29, 0x19	; 25
     97e:	71 f0       	breq	.+28     	; 0x99c <chb_set_state+0x4e>
     980:	d8 30       	cpi	r29, 0x08	; 8
     982:	e9 f4       	brne	.+58     	; 0x9be <chb_set_state+0x70>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
     984:	e4 e6       	ldi	r30, 0x64	; 100
     986:	f6 e0       	ldi	r31, 0x06	; 6
     988:	80 81       	ld	r24, Z
     98a:	8d 7f       	andi	r24, 0xFD	; 253
     98c:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
     98e:	82 e0       	ldi	r24, 0x02	; 2
     990:	63 e0       	ldi	r22, 0x03	; 3
     992:	4f e1       	ldi	r20, 0x1F	; 31
     994:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
     998:	00 00       	nop
     99a:	11 c0       	rjmp	.+34     	; 0x9be <chb_set_state+0x70>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
     99c:	c6 31       	cpi	r28, 0x16	; 22
     99e:	79 f4       	brne	.+30     	; 0x9be <chb_set_state+0x70>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
     9a0:	82 e0       	ldi	r24, 0x02	; 2
     9a2:	69 e0       	ldi	r22, 0x09	; 9
     9a4:	4f e1       	ldi	r20, 0x1F	; 31
     9a6:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
     9aa:	00 00       	nop
     9ac:	08 c0       	rjmp	.+16     	; 0x9be <chb_set_state+0x70>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
     9ae:	c9 31       	cpi	r28, 0x19	; 25
     9b0:	31 f4       	brne	.+12     	; 0x9be <chb_set_state+0x70>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
     9b2:	82 e0       	ldi	r24, 0x02	; 2
     9b4:	69 e0       	ldi	r22, 0x09	; 9
     9b6:	4f e1       	ldi	r20, 0x1F	; 31
     9b8:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
     9bc:	00 00       	nop
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
     9be:	82 e0       	ldi	r24, 0x02	; 2
     9c0:	6d 2f       	mov	r22, r29
     9c2:	4f e1       	ldi	r20, 0x1F	; 31
     9c4:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
     9c8:	84 e2       	ldi	r24, 0x24	; 36
     9ca:	8a 95       	dec	r24
     9cc:	f1 f7       	brne	.-4      	; 0x9ca <chb_set_state+0x7c>
     9ce:	00 c0       	rjmp	.+0      	; 0x9d0 <chb_set_state+0x82>

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
     9d0:	0e 94 7f 03 	call	0x6fe	; 0x6fe <chb_get_state>
     9d4:	8d 17       	cp	r24, r29
     9d6:	21 f4       	brne	.+8      	; 0x9e0 <chb_set_state+0x92>
    {
        return RADIO_SUCCESS;
     9d8:	80 e4       	ldi	r24, 0x40	; 64
     9da:	03 c0       	rjmp	.+6      	; 0x9e2 <chb_set_state+0x94>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
     9dc:	84 e4       	ldi	r24, 0x44	; 68
     9de:	01 c0       	rjmp	.+2      	; 0x9e2 <chb_set_state+0x94>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
     9e0:	83 e4       	ldi	r24, 0x43	; 67
}
     9e2:	df 91       	pop	r29
     9e4:	cf 91       	pop	r28
     9e6:	08 95       	ret

000009e8 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
     9e8:	cf 93       	push	r28
     9ea:	df 93       	push	r29
     9ec:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
     9ee:	80 e0       	ldi	r24, 0x00	; 0
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	be 01       	movw	r22, r28
     9f4:	48 e0       	ldi	r20, 0x08	; 8
     9f6:	50 e0       	ldi	r21, 0x00	; 0
     9f8:	0e 94 7a 07 	call	0xef4	; 0xef4 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
     9fc:	84 e2       	ldi	r24, 0x24	; 36
     9fe:	be 01       	movw	r22, r28
     a00:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <chb_reg_write64>
}
     a04:	df 91       	pop	r29
     a06:	cf 91       	pop	r28
     a08:	08 95       	ret

00000a0a <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
     a0a:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
     a0c:	80 e0       	ldi	r24, 0x00	; 0
     a0e:	90 e0       	ldi	r25, 0x00	; 0
     a10:	48 e0       	ldi	r20, 0x08	; 8
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	0e 94 dd 07 	call	0xfba	; 0xfba <chb_eeprom_read>
}
     a18:	08 95       	ret

00000a1a <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
     a1a:	0f 93       	push	r16
     a1c:	1f 93       	push	r17
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	0f 92       	push	r0
     a24:	0f 92       	push	r0
     a26:	cd b7       	in	r28, 0x3d	; 61
     a28:	de b7       	in	r29, 0x3e	; 62
     a2a:	89 83       	std	Y+1, r24	; 0x01
     a2c:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
     a2e:	0e 94 0d 02 	call	0x41a	; 0x41a <chb_get_pcb>
     a32:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
     a34:	89 e0       	ldi	r24, 0x09	; 9
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	be 01       	movw	r22, r28
     a3a:	6f 5f       	subi	r22, 0xFF	; 255
     a3c:	7f 4f       	sbci	r23, 0xFF	; 255
     a3e:	42 e0       	ldi	r20, 0x02	; 2
     a40:	50 e0       	ldi	r21, 0x00	; 0
     a42:	0e 94 7a 07 	call	0xef4	; 0xef4 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
     a46:	69 81       	ldd	r22, Y+1	; 0x01
     a48:	7a 81       	ldd	r23, Y+2	; 0x02
     a4a:	80 e2       	ldi	r24, 0x20	; 32
     a4c:	0e 94 ca 03 	call	0x794	; 0x794 <chb_reg_write16>
    pcb->src_addr = addr;
     a50:	89 81       	ldd	r24, Y+1	; 0x01
     a52:	9a 81       	ldd	r25, Y+2	; 0x02
     a54:	f8 01       	movw	r30, r16
     a56:	80 83       	st	Z, r24
     a58:	91 83       	std	Z+1, r25	; 0x01
}
     a5a:	0f 90       	pop	r0
     a5c:	0f 90       	pop	r0
     a5e:	df 91       	pop	r29
     a60:	cf 91       	pop	r28
     a62:	1f 91       	pop	r17
     a64:	0f 91       	pop	r16
     a66:	08 95       	ret

00000a68 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	0f 92       	push	r0
     a6e:	0f 92       	push	r0
     a70:	cd b7       	in	r28, 0x3d	; 61
     a72:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
     a74:	89 e0       	ldi	r24, 0x09	; 9
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	be 01       	movw	r22, r28
     a7a:	6f 5f       	subi	r22, 0xFF	; 255
     a7c:	7f 4f       	sbci	r23, 0xFF	; 255
     a7e:	42 e0       	ldi	r20, 0x02	; 2
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	0e 94 dd 07 	call	0xfba	; 0xfba <chb_eeprom_read>
    return *(U16 *)addr;
}
     a86:	89 81       	ldd	r24, Y+1	; 0x01
     a88:	9a 81       	ldd	r25, Y+2	; 0x02
     a8a:	0f 90       	pop	r0
     a8c:	0f 90       	pop	r0
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	08 95       	ret

00000a94 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
     a94:	cf 92       	push	r12
     a96:	df 92       	push	r13
     a98:	ef 92       	push	r14
     a9a:	ff 92       	push	r15
     a9c:	0f 93       	push	r16
     a9e:	1f 93       	push	r17
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
     aa4:	7c 01       	movw	r14, r24
     aa6:	6b 01       	movw	r12, r22
     aa8:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
     aaa:	0e 94 7f 03 	call	0x6fe	; 0x6fe <chb_get_state>
     aae:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
     ab0:	0e 94 0d 02 	call	0x41a	; 0x41a <chb_get_pcb>
     ab4:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
     ab6:	12 30       	cpi	r17, 0x02	; 2
     ab8:	f1 f0       	breq	.+60     	; 0xaf6 <chb_tx+0x62>
     aba:	12 31       	cpi	r17, 0x12	; 18
     abc:	f1 f0       	breq	.+60     	; 0xafa <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
     abe:	88 e0       	ldi	r24, 0x08	; 8
     ac0:	0e 94 a7 04 	call	0x94e	; 0x94e <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
     ac4:	89 e1       	ldi	r24, 0x19	; 25
     ac6:	0e 94 a7 04 	call	0x94e	; 0x94e <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
     aca:	c7 01       	movw	r24, r14
     acc:	6a e0       	ldi	r22, 0x0A	; 10
     ace:	a6 01       	movw	r20, r12
     ad0:	20 2f       	mov	r18, r16
     ad2:	0e 94 01 04 	call	0x802	; 0x802 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
     ad6:	82 e0       	ldi	r24, 0x02	; 2
     ad8:	62 e0       	ldi	r22, 0x02	; 2
     ada:	4f e1       	ldi	r20, 0x1F	; 31
     adc:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>

    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
     ae0:	8c 81       	ldd	r24, Y+4	; 0x04
     ae2:	88 23       	and	r24, r24
     ae4:	e9 f3       	breq	.-6      	; 0xae0 <chb_tx+0x4c>
    pcb->tx_end = false;
     ae6:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
     ae8:	82 e0       	ldi	r24, 0x02	; 2
     aea:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     aee:	82 95       	swap	r24
     af0:	86 95       	lsr	r24
     af2:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
     af4:	03 c0       	rjmp	.+6      	; 0xafc <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
     af6:	84 e4       	ldi	r24, 0x44	; 68
     af8:	01 c0       	rjmp	.+2      	; 0xafc <chb_tx+0x68>
     afa:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
     afc:	df 91       	pop	r29
     afe:	cf 91       	pop	r28
     b00:	1f 91       	pop	r17
     b02:	0f 91       	pop	r16
     b04:	ff 90       	pop	r15
     b06:	ef 90       	pop	r14
     b08:	df 90       	pop	r13
     b0a:	cf 90       	pop	r12
     b0c:	08 95       	ret

00000b0e <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
     b0e:	88 23       	and	r24, r24
     b10:	49 f0       	breq	.+18     	; 0xb24 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
     b12:	88 e0       	ldi	r24, 0x08	; 8
     b14:	0e 94 a7 04 	call	0x94e	; 0x94e <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
     b18:	e4 e6       	ldi	r30, 0x64	; 100
     b1a:	f6 e0       	ldi	r31, 0x06	; 6
     b1c:	80 81       	ld	r24, Z
     b1e:	82 60       	ori	r24, 0x02	; 2
     b20:	80 83       	st	Z, r24
     b22:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
     b24:	e4 e6       	ldi	r30, 0x64	; 100
     b26:	f6 e0       	ldi	r31, 0x06	; 6
     b28:	80 81       	ld	r24, Z
     b2a:	8d 7f       	andi	r24, 0xFD	; 253
     b2c:	80 83       	st	Z, r24
     b2e:	80 e5       	ldi	r24, 0x50	; 80
     b30:	8a 95       	dec	r24
     b32:	f1 f7       	brne	.-4      	; 0xb30 <chb_sleep+0x22>

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
     b34:	86 e1       	ldi	r24, 0x16	; 22
     b36:	0e 94 a7 04 	call	0x94e	; 0x94e <chb_set_state>
     b3a:	08 95       	ret

00000b3c <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
     b3c:	0f 93       	push	r16
     b3e:	1f 93       	push	r17
     b40:	cf 93       	push	r28
     b42:	df 93       	push	r29
     b44:	cd b7       	in	r28, 0x3d	; 61
     b46:	de b7       	in	r29, 0x3e	; 62
     b48:	ea 97       	sbiw	r28, 0x3a	; 58
     b4a:	cd bf       	out	0x3d, r28	; 61
     b4c:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
     b4e:	0e 94 15 08 	call	0x102a	; 0x102a <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
     b52:	e0 e6       	ldi	r30, 0x60	; 96
     b54:	f6 e0       	ldi	r31, 0x06	; 6
     b56:	80 81       	ld	r24, Z
     b58:	82 60       	ori	r24, 0x02	; 2
     b5a:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
     b5c:	80 81       	ld	r24, Z
     b5e:	81 60       	ori	r24, 0x01	; 1
     b60:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
     b62:	0e 94 84 03 	call	0x708	; 0x708 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
     b66:	8e e0       	ldi	r24, 0x0E	; 14
     b68:	60 e0       	ldi	r22, 0x00	; 0
     b6a:	0e 94 ae 03 	call	0x75c	; 0x75c <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
     b6e:	82 e0       	ldi	r24, 0x02	; 2
     b70:	63 e0       	ldi	r22, 0x03	; 3
     b72:	4f e1       	ldi	r20, 0x1F	; 31
     b74:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     b7e:	8f 71       	andi	r24, 0x1F	; 31
     b80:	88 30       	cpi	r24, 0x08	; 8
     b82:	d1 f7       	brne	.-12     	; 0xb78 <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
     b84:	8e e2       	ldi	r24, 0x2E	; 46
     b86:	60 e4       	ldi	r22, 0x40	; 64
     b88:	40 ec       	ldi	r20, 0xC0	; 192
     b8a:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
     b8e:	8e e0       	ldi	r24, 0x0E	; 14
     b90:	6c e0       	ldi	r22, 0x0C	; 12
     b92:	0e 94 ae 03 	call	0x75c	; 0x75c <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
     b96:	84 e0       	ldi	r24, 0x04	; 4
     b98:	60 e2       	ldi	r22, 0x20	; 32
     b9a:	40 e2       	ldi	r20, 0x20	; 32
     b9c:	0e 94 ed 03 	call	0x7da	; 0x7da <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
     ba0:	81 e0       	ldi	r24, 0x01	; 1
     ba2:	0e 94 4c 04 	call	0x898	; 0x898 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	0e 94 81 04 	call	0x902	; 0x902 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
     bac:	86 e1       	ldi	r24, 0x16	; 22
     bae:	0e 94 a7 04 	call	0x94e	; 0x94e <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
     bb2:	82 e2       	ldi	r24, 0x22	; 34
     bb4:	64 e3       	ldi	r22, 0x34	; 52
     bb6:	72 e1       	ldi	r23, 0x12	; 18
     bb8:	0e 94 ca 03 	call	0x794	; 0x794 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
     bbc:	0e 94 34 05 	call	0xa68	; 0xa68 <chb_get_short_addr>
     bc0:	bc 01       	movw	r22, r24
     bc2:	80 e2       	ldi	r24, 0x20	; 32
     bc4:	0e 94 ca 03 	call	0x794	; 0x794 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
     bc8:	ce 01       	movw	r24, r28
     bca:	01 96       	adiw	r24, 0x01	; 1
     bcc:	0e 94 05 05 	call	0xa0a	; 0xa0a <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
     bd0:	84 e2       	ldi	r24, 0x24	; 36
     bd2:	be 01       	movw	r22, r28
     bd4:	6f 5f       	subi	r22, 0xFF	; 255
     bd6:	7f 4f       	sbci	r23, 0xFF	; 255
     bd8:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
     bdc:	e2 e7       	ldi	r30, 0x72	; 114
     bde:	f6 e0       	ldi	r31, 0x06	; 6
     be0:	80 81       	ld	r24, Z
     be2:	81 60       	ori	r24, 0x01	; 1
     be4:	80 83       	st	Z, r24
     be6:	e9 e6       	ldi	r30, 0x69	; 105
     be8:	f6 e0       	ldi	r31, 0x06	; 6
     bea:	80 81       	ld	r24, Z
     bec:	82 60       	ori	r24, 0x02	; 2
     bee:	80 83       	st	Z, r24
     bf0:	ea e6       	ldi	r30, 0x6A	; 106
     bf2:	f6 e0       	ldi	r31, 0x06	; 6
     bf4:	80 81       	ld	r24, Z
     bf6:	84 60       	ori	r24, 0x04	; 4
     bf8:	80 83       	st	Z, r24
	PMIC.CTRL = 0x07;	//enable interrupts on MCU
     bfa:	87 e0       	ldi	r24, 0x07	; 7
     bfc:	e0 ea       	ldi	r30, 0xA0	; 160
     bfe:	f0 e0       	ldi	r31, 0x00	; 0
     c00:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
     c02:	0e 94 7f 03 	call	0x6fe	; 0x6fe <chb_get_state>
     c06:	86 31       	cpi	r24, 0x16	; 22
     c08:	91 f0       	breq	.+36     	; 0xc2e <chb_drvr_init+0xf2>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
     c0a:	8e 01       	movw	r16, r28
     c0c:	07 5f       	subi	r16, 0xF7	; 247
     c0e:	1f 4f       	sbci	r17, 0xFF	; 255
     c10:	c8 01       	movw	r24, r16
     c12:	68 ee       	ldi	r22, 0xE8	; 232
     c14:	71 e0       	ldi	r23, 0x01	; 1
     c16:	0e 94 30 35 	call	0x6a60	; 0x6a60 <strcpy_P>
        printf(buf);
     c1a:	0f 92       	push	r0
     c1c:	0f 92       	push	r0
     c1e:	ed b7       	in	r30, 0x3d	; 61
     c20:	fe b7       	in	r31, 0x3e	; 62
     c22:	01 83       	std	Z+1, r16	; 0x01
     c24:	12 83       	std	Z+2, r17	; 0x02
     c26:	0e 94 49 35 	call	0x6a92	; 0x6a92 <printf>
     c2a:	0f 90       	pop	r0
     c2c:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
     c2e:	10 92 5a 40 	sts	0x405A, r1
     c32:	10 92 5b 40 	sts	0x405B, r1
     c36:	10 92 5c 40 	sts	0x405C, r1
     c3a:	10 92 5d 40 	sts	0x405D, r1
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
     c3e:	ea 96       	adiw	r28, 0x3a	; 58
     c40:	cd bf       	out	0x3d, r28	; 61
     c42:	de bf       	out	0x3e, r29	; 62
     c44:	df 91       	pop	r29
     c46:	cf 91       	pop	r28
     c48:	1f 91       	pop	r17
     c4a:	0f 91       	pop	r16
     c4c:	08 95       	ret

00000c4e <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
     c4e:	1f 92       	push	r1
     c50:	0f 92       	push	r0
     c52:	0f b6       	in	r0, 0x3f	; 63
     c54:	0f 92       	push	r0
     c56:	0b b6       	in	r0, 0x3b	; 59
     c58:	0f 92       	push	r0
     c5a:	11 24       	eor	r1, r1
     c5c:	6f 92       	push	r6
     c5e:	7f 92       	push	r7
     c60:	8f 92       	push	r8
     c62:	9f 92       	push	r9
     c64:	af 92       	push	r10
     c66:	bf 92       	push	r11
     c68:	df 92       	push	r13
     c6a:	ef 92       	push	r14
     c6c:	ff 92       	push	r15
     c6e:	0f 93       	push	r16
     c70:	1f 93       	push	r17
     c72:	2f 93       	push	r18
     c74:	3f 93       	push	r19
     c76:	4f 93       	push	r20
     c78:	5f 93       	push	r21
     c7a:	6f 93       	push	r22
     c7c:	7f 93       	push	r23
     c7e:	8f 93       	push	r24
     c80:	9f 93       	push	r25
     c82:	af 93       	push	r26
     c84:	bf 93       	push	r27
     c86:	ef 93       	push	r30
     c88:	ff 93       	push	r31
     c8a:	cf 93       	push	r28
     c8c:	df 93       	push	r29
     c8e:	cd b7       	in	r28, 0x3d	; 61
     c90:	de b7       	in	r29, 0x3e	; 62
     c92:	e2 97       	sbiw	r28, 0x32	; 50
     c94:	cd bf       	out	0x3d, r28	; 61
     c96:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    pcb_t *pcb = chb_get_pcb();
     c98:	0e 94 0d 02 	call	0x41a	; 0x41a <chb_get_pcb>
     c9c:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
     c9e:	8f b7       	in	r24, 0x3f	; 63
     ca0:	80 93 bf 21 	sts	0x21BF, r24
     ca4:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
     cac:	8f e8       	ldi	r24, 0x8F	; 143
     cae:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
    intp_src = SPID_write(0);
     cb2:	80 e0       	ldi	r24, 0x00	; 0
     cb4:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
     cb8:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
     cba:	80 e0       	ldi	r24, 0x00	; 0
     cbc:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>

    while (intp_src)
     cc0:	11 23       	and	r17, r17
     cc2:	09 f4       	brne	.+2      	; 0xcc6 <__vector_64+0x78>
     cc4:	ed c0       	rjmp	.+474    	; 0xea0 <__vector_64+0x252>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
     cc6:	aa 24       	eor	r10, r10
     cc8:	bb 24       	eor	r11, r11
     cca:	68 94       	set
     ccc:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
     cce:	0f 2e       	mov	r0, r31
     cd0:	f8 e0       	ldi	r31, 0x08	; 8
     cd2:	8f 2e       	mov	r8, r31
     cd4:	f2 e0       	ldi	r31, 0x02	; 2
     cd6:	9f 2e       	mov	r9, r31
     cd8:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
     cda:	12 ff       	sbrs	r17, 2
     cdc:	02 c0       	rjmp	.+4      	; 0xce2 <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
     cde:	1b 7f       	andi	r17, 0xFB	; 251
     ce0:	dc c0       	rjmp	.+440    	; 0xe9a <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
     ce2:	13 ff       	sbrs	r17, 3
     ce4:	c1 c0       	rjmp	.+386    	; 0xe68 <__vector_64+0x21a>
        {
            state = chb_get_state();
     ce6:	0e 94 7f 03 	call	0x6fe	; 0x6fe <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
     cea:	86 30       	cpi	r24, 0x06	; 6
     cec:	29 f0       	breq	.+10     	; 0xcf8 <__vector_64+0xaa>
     cee:	86 31       	cpi	r24, 0x16	; 22
     cf0:	19 f0       	breq	.+6      	; 0xcf8 <__vector_64+0xaa>
     cf2:	81 31       	cpi	r24, 0x11	; 17
     cf4:	09 f0       	breq	.+2      	; 0xcf8 <__vector_64+0xaa>
     cf6:	ae c0       	rjmp	.+348    	; 0xe54 <__vector_64+0x206>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
     cf8:	88 e0       	ldi	r24, 0x08	; 8
     cfa:	0e 94 a7 04 	call	0x94e	; 0x94e <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
     cfe:	87 e0       	ldi	r24, 0x07	; 7
     d00:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     d04:	f7 01       	movw	r30, r14
     d06:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
     d08:	86 e0       	ldi	r24, 0x06	; 6
     d0a:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
     d0e:	88 1f       	adc	r24, r24
     d10:	88 27       	eor	r24, r24
     d12:	88 1f       	adc	r24, r24
     d14:	f7 01       	movw	r30, r14
     d16:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
     d18:	88 23       	and	r24, r24
     d1a:	09 f4       	brne	.+2      	; 0xd1e <__vector_64+0xd0>
     d1c:	9e c0       	rjmp	.+316    	; 0xe5a <__vector_64+0x20c>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
     d1e:	8f b7       	in	r24, 0x3f	; 63
     d20:	80 93 bf 21 	sts	0x21BF, r24
     d24:	f8 94       	cli
    RadioCS(TRUE);
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
     d2c:	80 e2       	ldi	r24, 0x20	; 32
     d2e:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
    len = SPID_write(0);
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
     d38:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
     d3a:	83 50       	subi	r24, 0x03	; 3
     d3c:	8d 37       	cpi	r24, 0x7D	; 125
     d3e:	f0 f5       	brcc	.+124    	; 0xdbc <__vector_64+0x16e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
     d40:	0e 94 62 03 	call	0x6c4	; 0x6c4 <chb_buf_get_len>
     d44:	2d 2d       	mov	r18, r13
     d46:	30 e0       	ldi	r19, 0x00	; 0
     d48:	a5 01       	movw	r20, r10
     d4a:	48 1b       	sub	r20, r24
     d4c:	51 09       	sbc	r21, r1
     d4e:	24 17       	cp	r18, r20
     d50:	35 07       	cpc	r19, r21
     d52:	7c f4       	brge	.+30     	; 0xd72 <__vector_64+0x124>
        {
            chb_buf_write(len);
     d54:	8d 2d       	mov	r24, r13
     d56:	0e 94 36 03 	call	0x66c	; 0x66c <chb_buf_write>
            
            for (i=0; i<len; i++)
     d5a:	dd 20       	and	r13, r13
     d5c:	79 f1       	breq	.+94     	; 0xdbc <__vector_64+0x16e>
     d5e:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
     d60:	80 e0       	ldi	r24, 0x00	; 0
     d62:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
                chb_buf_write(data);
     d66:	0e 94 36 03 	call	0x66c	; 0x66c <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
     d6a:	0f 5f       	subi	r16, 0xFF	; 255
     d6c:	0d 15       	cp	r16, r13
     d6e:	c1 f7       	brne	.-16     	; 0xd60 <__vector_64+0x112>
     d70:	25 c0       	rjmp	.+74     	; 0xdbc <__vector_64+0x16e>
            }
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
     d72:	0e 94 0d 02 	call	0x41a	; 0x41a <chb_get_pcb>
     d76:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
     d78:	dd 20       	and	r13, r13
     d7a:	39 f0       	breq	.+14     	; 0xd8a <__vector_64+0x13c>
     d7c:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	0e 94 60 22 	call	0x44c0	; 0x44c0 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
     d84:	0f 5f       	subi	r16, 0xFF	; 255
     d86:	0d 15       	cp	r16, r13
     d88:	d1 f7       	brne	.-12     	; 0xd7e <__vector_64+0x130>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
     d8a:	f3 01       	movw	r30, r6
     d8c:	85 85       	ldd	r24, Z+13	; 0x0d
     d8e:	96 85       	ldd	r25, Z+14	; 0x0e
     d90:	01 96       	adiw	r24, 0x01	; 1
     d92:	85 87       	std	Z+13, r24	; 0x0d
     d94:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
     d96:	ce 01       	movw	r24, r28
     d98:	01 96       	adiw	r24, 0x01	; 1
     d9a:	b4 01       	movw	r22, r8
     d9c:	0e 94 30 35 	call	0x6a60	; 0x6a60 <strcpy_P>
            printf(buf);
     da0:	0f 92       	push	r0
     da2:	0f 92       	push	r0
     da4:	41 e0       	ldi	r20, 0x01	; 1
     da6:	50 e0       	ldi	r21, 0x00	; 0
     da8:	4c 0f       	add	r20, r28
     daa:	5d 1f       	adc	r21, r29
     dac:	ed b7       	in	r30, 0x3d	; 61
     dae:	fe b7       	in	r31, 0x3e	; 62
     db0:	41 83       	std	Z+1, r20	; 0x01
     db2:	52 83       	std	Z+2, r21	; 0x02
     db4:	0e 94 49 35 	call	0x6a92	; 0x6a92 <printf>
     db8:	0f 90       	pop	r0
     dba:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	0e 94 54 22 	call	0x44a8	; 0x44a8 <RadioCS>
    CHB_LEAVE_CRIT();
     dc2:	80 91 bf 21 	lds	r24, 0x21BF
     dc6:	8f bf       	out	0x3f, r24	; 63
     dc8:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
     dca:	f7 01       	movw	r30, r14
     dcc:	85 81       	ldd	r24, Z+5	; 0x05
     dce:	96 81       	ldd	r25, Z+6	; 0x06
     dd0:	01 96       	adiw	r24, 0x01	; 1
     dd2:	85 83       	std	Z+5, r24	; 0x05
     dd4:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	83 83       	std	Z+3, r24	; 0x03
					StartOfFreeSpace += chb_read(FRAMReadBuffer+StartOfFreeSpace);	//read the data into the FRAM buffer right away --vlad
     dda:	80 91 5a 40 	lds	r24, 0x405A
     dde:	90 91 5b 40 	lds	r25, 0x405B
     de2:	a0 91 5c 40 	lds	r26, 0x405C
     de6:	b0 91 5d 40 	lds	r27, 0x405D
     dea:	88 53       	subi	r24, 0x38	; 56
     dec:	9c 4d       	sbci	r25, 0xDC	; 220
     dee:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <chb_read>
     df2:	40 91 5a 40 	lds	r20, 0x405A
     df6:	50 91 5b 40 	lds	r21, 0x405B
     dfa:	60 91 5c 40 	lds	r22, 0x405C
     dfe:	70 91 5d 40 	lds	r23, 0x405D
     e02:	48 0f       	add	r20, r24
     e04:	51 1d       	adc	r21, r1
     e06:	61 1d       	adc	r22, r1
     e08:	71 1d       	adc	r23, r1
     e0a:	40 93 5a 40 	sts	0x405A, r20
     e0e:	50 93 5b 40 	sts	0x405B, r21
     e12:	60 93 5c 40 	sts	0x405C, r22
     e16:	70 93 5d 40 	sts	0x405D, r23
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).			
     e1a:	80 91 5a 40 	lds	r24, 0x405A
     e1e:	90 91 5b 40 	lds	r25, 0x405B
     e22:	a0 91 5c 40 	lds	r26, 0x405C
     e26:	b0 91 5d 40 	lds	r27, 0x405D
     e2a:	80 58       	subi	r24, 0x80	; 128
     e2c:	9f 4f       	sbci	r25, 0xFF	; 255
     e2e:	af 4f       	sbci	r26, 0xFF	; 255
     e30:	bf 4f       	sbci	r27, 0xFF	; 255
     e32:	81 37       	cpi	r24, 0x71	; 113
     e34:	fc e1       	ldi	r31, 0x1C	; 28
     e36:	9f 07       	cpc	r25, r31
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	af 07       	cpc	r26, r31
     e3c:	f0 e0       	ldi	r31, 0x00	; 0
     e3e:	bf 07       	cpc	r27, r31
     e40:	60 f0       	brcs	.+24     	; 0xe5a <__vector_64+0x20c>
     e42:	10 92 5a 40 	sts	0x405A, r1
     e46:	10 92 5b 40 	sts	0x405B, r1
     e4a:	10 92 5c 40 	sts	0x405C, r1
     e4e:	10 92 5d 40 	sts	0x405D, r1
     e52:	03 c0       	rjmp	.+6      	; 0xe5a <__vector_64+0x20c>
                }
            }
            else{
                pcb->tx_end = true;
     e54:	81 e0       	ldi	r24, 0x01	; 1
     e56:	f7 01       	movw	r30, r14
     e58:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
     e5a:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
     e5c:	86 e1       	ldi	r24, 0x16	; 22
     e5e:	0e 94 a7 04 	call	0x94e	; 0x94e <chb_set_state>
     e62:	80 34       	cpi	r24, 0x40	; 64
     e64:	d9 f7       	brne	.-10     	; 0xe5c <__vector_64+0x20e>
     e66:	19 c0       	rjmp	.+50     	; 0xe9a <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
     e68:	16 ff       	sbrs	r17, 6
     e6a:	08 c0       	rjmp	.+16     	; 0xe7c <__vector_64+0x22e>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
     e6c:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
     e6e:	f7 01       	movw	r30, r14
     e70:	87 85       	ldd	r24, Z+15	; 0x0f
     e72:	90 89       	ldd	r25, Z+16	; 0x10
     e74:	01 96       	adiw	r24, 0x01	; 1
     e76:	87 87       	std	Z+15, r24	; 0x0f
     e78:	90 8b       	std	Z+16, r25	; 0x10
     e7a:	0f c0       	rjmp	.+30     	; 0xe9a <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
     e7c:	11 ff       	sbrs	r17, 1
     e7e:	02 c0       	rjmp	.+4      	; 0xe84 <__vector_64+0x236>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
     e80:	1d 7f       	andi	r17, 0xFD	; 253
     e82:	0b c0       	rjmp	.+22     	; 0xe9a <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
     e84:	10 ff       	sbrs	r17, 0
     e86:	02 c0       	rjmp	.+4      	; 0xe8c <__vector_64+0x23e>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
     e88:	1e 7f       	andi	r17, 0xFE	; 254
     e8a:	07 c0       	rjmp	.+14     	; 0xe9a <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
     e8c:	11 23       	and	r17, r17
     e8e:	2c f4       	brge	.+10     	; 0xe9a <__vector_64+0x24c>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
     e90:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
     e92:	f7 01       	movw	r30, r14
     e94:	81 89       	ldd	r24, Z+17	; 0x11
     e96:	8f 5f       	subi	r24, 0xFF	; 255
     e98:	81 8b       	std	Z+17, r24	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
     e9a:	11 23       	and	r17, r17
     e9c:	09 f0       	breq	.+2      	; 0xea0 <__vector_64+0x252>
     e9e:	1d cf       	rjmp	.-454    	; 0xcda <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
     ea0:	80 91 bf 21 	lds	r24, 0x21BF
     ea4:	8f bf       	out	0x3f, r24	; 63
     ea6:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
     ea8:	8f e0       	ldi	r24, 0x0F	; 15
     eaa:	0e 94 65 03 	call	0x6ca	; 0x6ca <chb_reg_read>
}
     eae:	e2 96       	adiw	r28, 0x32	; 50
     eb0:	cd bf       	out	0x3d, r28	; 61
     eb2:	de bf       	out	0x3e, r29	; 62
     eb4:	df 91       	pop	r29
     eb6:	cf 91       	pop	r28
     eb8:	ff 91       	pop	r31
     eba:	ef 91       	pop	r30
     ebc:	bf 91       	pop	r27
     ebe:	af 91       	pop	r26
     ec0:	9f 91       	pop	r25
     ec2:	8f 91       	pop	r24
     ec4:	7f 91       	pop	r23
     ec6:	6f 91       	pop	r22
     ec8:	5f 91       	pop	r21
     eca:	4f 91       	pop	r20
     ecc:	3f 91       	pop	r19
     ece:	2f 91       	pop	r18
     ed0:	1f 91       	pop	r17
     ed2:	0f 91       	pop	r16
     ed4:	ff 90       	pop	r15
     ed6:	ef 90       	pop	r14
     ed8:	df 90       	pop	r13
     eda:	bf 90       	pop	r11
     edc:	af 90       	pop	r10
     ede:	9f 90       	pop	r9
     ee0:	8f 90       	pop	r8
     ee2:	7f 90       	pop	r7
     ee4:	6f 90       	pop	r6
     ee6:	0f 90       	pop	r0
     ee8:	0b be       	out	0x3b, r0	; 59
     eea:	0f 90       	pop	r0
     eec:	0f be       	out	0x3f, r0	; 63
     eee:	0f 90       	pop	r0
     ef0:	1f 90       	pop	r1
     ef2:	18 95       	reti

00000ef4 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
     ef4:	0f 93       	push	r16
     ef6:	1f 93       	push	r17
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
     efe:	e0 ec       	ldi	r30, 0xC0	; 192
     f00:	f1 e0       	ldi	r31, 0x01	; 1
     f02:	84 85       	ldd	r24, Z+12	; 0x0c
     f04:	87 7f       	andi	r24, 0xF7	; 247
     f06:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
     f08:	41 15       	cp	r20, r1
     f0a:	51 05       	cpc	r21, r1
     f0c:	09 f4       	brne	.+2      	; 0xf10 <chb_eeprom_write+0x1c>
     f0e:	50 c0       	rjmp	.+160    	; 0xfb0 <chb_eeprom_write+0xbc>
     f10:	e0 e0       	ldi	r30, 0x00	; 0
     f12:	f0 e0       	ldi	r31, 0x00	; 0
     f14:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
     f16:	a0 ec       	ldi	r26, 0xC0	; 192
     f18:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
     f1a:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
     f1c:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
     f1e:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
     f20:	cf 01       	movw	r24, r30
     f22:	80 0f       	add	r24, r16
     f24:	91 1f       	adc	r25, r17
     f26:	e6 0f       	add	r30, r22
     f28:	f7 1f       	adc	r31, r23
     f2a:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
     f2c:	1f 96       	adiw	r26, 0x0f	; 15
     f2e:	ec 91       	ld	r30, X
     f30:	1f 97       	sbiw	r26, 0x0f	; 15
     f32:	ee 23       	and	r30, r30
     f34:	dc f3       	brlt	.-10     	; 0xf2c <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
     f36:	1f 96       	adiw	r26, 0x0f	; 15
     f38:	ec 91       	ld	r30, X
     f3a:	1f 97       	sbiw	r26, 0x0f	; 15
     f3c:	e1 ff       	sbrs	r30, 1
     f3e:	11 c0       	rjmp	.+34     	; 0xf62 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
     f40:	1a 96       	adiw	r26, 0x0a	; 10
     f42:	dc 93       	st	X, r29
     f44:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
     f46:	ef 93       	push	r30
     f48:	ff 93       	push	r31
     f4a:	0f 93       	push	r16
     f4c:	2f 93       	push	r18
     f4e:	eb ec       	ldi	r30, 0xCB	; 203
     f50:	f1 e0       	ldi	r31, 0x01	; 1
     f52:	08 ed       	ldi	r16, 0xD8	; 216
     f54:	21 e0       	ldi	r18, 0x01	; 1
     f56:	04 bf       	out	0x34, r16	; 52
     f58:	20 83       	st	Z, r18
     f5a:	2f 91       	pop	r18
     f5c:	0f 91       	pop	r16
     f5e:	ff 91       	pop	r31
     f60:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
     f62:	1a 96       	adiw	r26, 0x0a	; 10
     f64:	cc 93       	st	X, r28
     f66:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
     f68:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
     f6a:	89 2f       	mov	r24, r25
     f6c:	8f 71       	andi	r24, 0x1F	; 31
     f6e:	11 96       	adiw	r26, 0x01	; 1
     f70:	8c 93       	st	X, r24
     f72:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
     f74:	12 96       	adiw	r26, 0x02	; 2
     f76:	1c 92       	st	X, r1
     f78:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
     f7a:	14 96       	adiw	r26, 0x04	; 4
     f7c:	fc 93       	st	X, r31
     f7e:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
     f80:	1a 96       	adiw	r26, 0x0a	; 10
     f82:	3c 93       	st	X, r19
     f84:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
     f86:	ef 93       	push	r30
     f88:	ff 93       	push	r31
     f8a:	0f 93       	push	r16
     f8c:	2f 93       	push	r18
     f8e:	eb ec       	ldi	r30, 0xCB	; 203
     f90:	f1 e0       	ldi	r31, 0x01	; 1
     f92:	08 ed       	ldi	r16, 0xD8	; 216
     f94:	21 e0       	ldi	r18, 0x01	; 1
     f96:	04 bf       	out	0x34, r16	; 52
     f98:	20 83       	st	Z, r18
     f9a:	2f 91       	pop	r18
     f9c:	0f 91       	pop	r16
     f9e:	ff 91       	pop	r31
     fa0:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
     fa2:	2f 5f       	subi	r18, 0xFF	; 255
     fa4:	e2 2f       	mov	r30, r18
     fa6:	f0 e0       	ldi	r31, 0x00	; 0
     fa8:	e4 17       	cp	r30, r20
     faa:	f5 07       	cpc	r31, r21
     fac:	08 f4       	brcc	.+2      	; 0xfb0 <chb_eeprom_write+0xbc>
     fae:	b8 cf       	rjmp	.-144    	; 0xf20 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
     fb0:	df 91       	pop	r29
     fb2:	cf 91       	pop	r28
     fb4:	1f 91       	pop	r17
     fb6:	0f 91       	pop	r16
     fb8:	08 95       	ret

00000fba <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
     fba:	1f 93       	push	r17
     fbc:	cf 93       	push	r28
     fbe:	df 93       	push	r29
     fc0:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
     fc2:	e0 ec       	ldi	r30, 0xC0	; 192
     fc4:	f1 e0       	ldi	r31, 0x01	; 1
     fc6:	84 85       	ldd	r24, Z+12	; 0x0c
     fc8:	87 7f       	andi	r24, 0xF7	; 247
     fca:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
     fcc:	41 15       	cp	r20, r1
     fce:	51 05       	cpc	r21, r1
     fd0:	41 f1       	breq	.+80     	; 0x1022 <chb_eeprom_read+0x68>
     fd2:	80 e0       	ldi	r24, 0x00	; 0
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
     fd8:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
     fda:	db 01       	movw	r26, r22
     fdc:	a8 0f       	add	r26, r24
     fde:	b9 1f       	adc	r27, r25
     fe0:	82 0f       	add	r24, r18
     fe2:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
     fe4:	17 85       	ldd	r17, Z+15	; 0x0f
     fe6:	11 23       	and	r17, r17
     fe8:	ec f3       	brlt	.-6      	; 0xfe4 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
     fea:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
     fec:	89 2f       	mov	r24, r25
     fee:	8f 71       	andi	r24, 0x1F	; 31
     ff0:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
     ff2:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
     ff4:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
     ff6:	ef 93       	push	r30
     ff8:	ff 93       	push	r31
     ffa:	0f 93       	push	r16
     ffc:	2f 93       	push	r18
     ffe:	eb ec       	ldi	r30, 0xCB	; 203
    1000:	f1 e0       	ldi	r31, 0x01	; 1
    1002:	08 ed       	ldi	r16, 0xD8	; 216
    1004:	21 e0       	ldi	r18, 0x01	; 1
    1006:	04 bf       	out	0x34, r16	; 52
    1008:	20 83       	st	Z, r18
    100a:	2f 91       	pop	r18
    100c:	0f 91       	pop	r16
    100e:	ff 91       	pop	r31
    1010:	ef 91       	pop	r30

    return NVM.DATA0;
    1012:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    1014:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    1016:	cf 5f       	subi	r28, 0xFF	; 255
    1018:	8c 2f       	mov	r24, r28
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	84 17       	cp	r24, r20
    101e:	95 07       	cpc	r25, r21
    1020:	e0 f2       	brcs	.-72     	; 0xfda <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	08 95       	ret

0000102a <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    102a:	e0 e6       	ldi	r30, 0x60	; 96
    102c:	f6 e0       	ldi	r31, 0x06	; 6
    102e:	80 81       	ld	r24, Z
    1030:	80 6b       	ori	r24, 0xB0	; 176
    1032:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    1034:	e4 e6       	ldi	r30, 0x64	; 100
    1036:	f6 e0       	ldi	r31, 0x06	; 6
    1038:	80 81       	ld	r24, Z
    103a:	80 61       	ori	r24, 0x10	; 16
    103c:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    103e:	a0 ec       	ldi	r26, 0xC0	; 192
    1040:	b9 e0       	ldi	r27, 0x09	; 9
    1042:	8c 91       	ld	r24, X
    1044:	81 65       	ori	r24, 0x51	; 81
    1046:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    1048:	80 81       	ld	r24, Z
    104a:	80 61       	ori	r24, 0x10	; 16
    104c:	80 83       	st	Z, r24
}
    104e:	08 95       	ret

00001050 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    1050:	0f 93       	push	r16
    1052:	cf 93       	push	r28
    1054:	df 93       	push	r29
    1056:	0f 92       	push	r0
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    105c:	2f b7       	in	r18, 0x3f	; 63
    105e:	29 83       	std	Y+1, r18	; 0x01
    1060:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    1062:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    1064:	fc 01       	movw	r30, r24
    1066:	08 ed       	ldi	r16, 0xD8	; 216
    1068:	04 bf       	out	0x34, r16	; 52
    106a:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    106c:	89 81       	ldd	r24, Y+1	; 0x01
    106e:	8f bf       	out	0x3f, r24	; 63
#endif
}
    1070:	0f 90       	pop	r0
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	0f 91       	pop	r16
    1078:	08 95       	ret

0000107a <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    107a:	66 23       	and	r22, r22
    107c:	11 f0       	breq	.+4      	; 0x1082 <CLKSYS_XOSC_Config+0x8>
    107e:	90 e2       	ldi	r25, 0x20	; 32
    1080:	01 c0       	rjmp	.+2      	; 0x1084 <CLKSYS_XOSC_Config+0xa>
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	84 2b       	or	r24, r20
    1086:	89 2b       	or	r24, r25
    1088:	e0 e5       	ldi	r30, 0x50	; 80
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    108e:	08 95       	ret

00001090 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    1090:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    1092:	86 2b       	or	r24, r22
    1094:	e0 e5       	ldi	r30, 0x50	; 80
    1096:	f0 e0       	ldi	r31, 0x00	; 0
    1098:	85 83       	std	Z+5, r24	; 0x05
}
    109a:	08 95       	ret

0000109c <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    109c:	e0 e5       	ldi	r30, 0x50	; 80
    109e:	f0 e0       	ldi	r31, 0x00	; 0
    10a0:	90 81       	ld	r25, Z
    10a2:	28 2f       	mov	r18, r24
    10a4:	20 95       	com	r18
    10a6:	92 23       	and	r25, r18
    10a8:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    10aa:	90 81       	ld	r25, Z
	return clkEnabled;
}
    10ac:	89 23       	and	r24, r25
    10ae:	08 95       	ret

000010b0 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    10b0:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    10b2:	81 e4       	ldi	r24, 0x41	; 65
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	0e 94 28 08 	call	0x1050	; 0x1050 <CCPWrite>
}
    10ba:	08 95       	ret

000010bc <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    10bc:	1f 93       	push	r17
    10be:	cf 93       	push	r28
    10c0:	df 93       	push	r29
    10c2:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    10c4:	c0 e4       	ldi	r28, 0x40	; 64
    10c6:	d0 e0       	ldi	r29, 0x00	; 0
    10c8:	68 81       	ld	r22, Y
    10ca:	68 7f       	andi	r22, 0xF8	; 248
    10cc:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    10ce:	80 e4       	ldi	r24, 0x40	; 64
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	0e 94 28 08 	call	0x1050	; 0x1050 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    10d6:	88 81       	ld	r24, Y
	return clkCtrl;
}
    10d8:	81 23       	and	r24, r17
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	1f 91       	pop	r17
    10e0:	08 95       	ret

000010e2 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    10e2:	e0 e4       	ldi	r30, 0x40	; 64
    10e4:	f0 e0       	ldi	r31, 0x00	; 0
    10e6:	93 81       	ldd	r25, Z+3	; 0x03
    10e8:	91 7f       	andi	r25, 0xF1	; 241
    10ea:	91 60       	ori	r25, 0x01	; 1
    10ec:	89 2b       	or	r24, r25
    10ee:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    10f0:	08 95       	ret

000010f2 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    10f2:	e0 e5       	ldi	r30, 0x50	; 80
    10f4:	f0 e0       	ldi	r31, 0x00	; 0
    10f6:	26 81       	ldd	r18, Z+6	; 0x06
    10f8:	98 2f       	mov	r25, r24
    10fa:	38 2f       	mov	r19, r24
    10fc:	30 95       	com	r19
    10fe:	23 23       	and	r18, r19
    1100:	66 23       	and	r22, r22
    1102:	09 f4       	brne	.+2      	; 0x1106 <CLKSYS_AutoCalibration_Enable+0x14>
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	92 2b       	or	r25, r18
    1108:	e0 e5       	ldi	r30, 0x50	; 80
    110a:	f0 e0       	ldi	r31, 0x00	; 0
    110c:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    110e:	81 30       	cpi	r24, 0x01	; 1
    1110:	31 f4       	brne	.+12     	; 0x111e <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    1112:	e8 e6       	ldi	r30, 0x68	; 104
    1114:	f0 e0       	ldi	r31, 0x00	; 0
    1116:	80 81       	ld	r24, Z
    1118:	81 60       	ori	r24, 0x01	; 1
    111a:	80 83       	st	Z, r24
    111c:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    111e:	82 30       	cpi	r24, 0x02	; 2
    1120:	29 f4       	brne	.+10     	; 0x112c <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    1122:	e0 e6       	ldi	r30, 0x60	; 96
    1124:	f0 e0       	ldi	r31, 0x00	; 0
    1126:	80 81       	ld	r24, Z
    1128:	81 60       	ori	r24, 0x01	; 1
    112a:	80 83       	st	Z, r24
    112c:	08 95       	ret

0000112e <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    112e:	83 e5       	ldi	r24, 0x53	; 83
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	63 e0       	ldi	r22, 0x03	; 3
    1134:	0e 94 28 08 	call	0x1050	; 0x1050 <CCPWrite>
}
    1138:	08 95       	ret

0000113a <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    113a:	82 e4       	ldi	r24, 0x42	; 66
    113c:	90 e0       	ldi	r25, 0x00	; 0
    113e:	61 e0       	ldi	r22, 0x01	; 1
    1140:	0e 94 28 08 	call	0x1050	; 0x1050 <CCPWrite>
}
    1144:	08 95       	ret

00001146 <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    1146:	80 ec       	ldi	r24, 0xC0	; 192
    1148:	60 e0       	ldi	r22, 0x00	; 0
    114a:	4b e0       	ldi	r20, 0x0B	; 11
    114c:	0e 94 3d 08 	call	0x107a	; 0x107a <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    1150:	e0 e5       	ldi	r30, 0x50	; 80
    1152:	f0 e0       	ldi	r31, 0x00	; 0
    1154:	80 81       	ld	r24, Z
    1156:	88 60       	ori	r24, 0x08	; 8
    1158:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    115a:	81 81       	ldd	r24, Z+1	; 0x01
    115c:	83 ff       	sbrs	r24, 3
    115e:	fd cf       	rjmp	.-6      	; 0x115a <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    1160:	80 ec       	ldi	r24, 0xC0	; 192
    1162:	62 e0       	ldi	r22, 0x02	; 2
    1164:	0e 94 48 08 	call	0x1090	; 0x1090 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    1168:	e0 e5       	ldi	r30, 0x50	; 80
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	80 81       	ld	r24, Z
    116e:	80 61       	ori	r24, 0x10	; 16
    1170:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    1172:	81 81       	ldd	r24, Z+1	; 0x01
    1174:	84 ff       	sbrs	r24, 4
    1176:	fd cf       	rjmp	.-6      	; 0x1172 <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    1178:	84 e0       	ldi	r24, 0x04	; 4
    117a:	0e 94 5e 08 	call	0x10bc	; 0x10bc <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	0e 94 4e 08 	call	0x109c	; 0x109c <CLKSYS_Disable>
}
    1184:	08 95       	ret

00001186 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    1186:	e0 e5       	ldi	r30, 0x50	; 80
    1188:	f0 e0       	ldi	r31, 0x00	; 0
    118a:	80 81       	ld	r24, Z
    118c:	82 60       	ori	r24, 0x02	; 2
    118e:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    1190:	80 e0       	ldi	r24, 0x00	; 0
    1192:	61 e0       	ldi	r22, 0x01	; 1
    1194:	0e 94 58 08 	call	0x10b0	; 0x10b0 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    1198:	e0 e5       	ldi	r30, 0x50	; 80
    119a:	f0 e0       	ldi	r31, 0x00	; 0
    119c:	81 81       	ldd	r24, Z+1	; 0x01
    119e:	81 ff       	sbrs	r24, 1
    11a0:	fd cf       	rjmp	.-6      	; 0x119c <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	0e 94 5e 08 	call	0x10bc	; 0x10bc <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    11a8:	81 e0       	ldi	r24, 0x01	; 1
    11aa:	0e 94 4e 08 	call	0x109c	; 0x109c <CLKSYS_Disable>
	
}
    11ae:	08 95       	ret

000011b0 <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    11b0:	e0 e5       	ldi	r30, 0x50	; 80
    11b2:	f0 e0       	ldi	r31, 0x00	; 0
    11b4:	80 81       	ld	r24, Z
    11b6:	82 60       	ori	r24, 0x02	; 2
    11b8:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    11ba:	80 e0       	ldi	r24, 0x00	; 0
    11bc:	60 e0       	ldi	r22, 0x00	; 0
    11be:	0e 94 58 08 	call	0x10b0	; 0x10b0 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    11c2:	e0 e5       	ldi	r30, 0x50	; 80
    11c4:	f0 e0       	ldi	r31, 0x00	; 0
    11c6:	81 81       	ldd	r24, Z+1	; 0x01
    11c8:	81 ff       	sbrs	r24, 1
    11ca:	fd cf       	rjmp	.-6      	; 0x11c6 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	0e 94 5e 08 	call	0x10bc	; 0x10bc <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	0e 94 4e 08 	call	0x109c	; 0x109c <CLKSYS_Disable>
	
}
    11d8:	08 95       	ret

000011da <portExCS>:
}



void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    11da:	88 23       	and	r24, r24
    11dc:	29 f0       	breq	.+10     	; 0x11e8 <portExCS+0xe>
    11de:	88 e0       	ldi	r24, 0x08	; 8
    11e0:	e0 e0       	ldi	r30, 0x00	; 0
    11e2:	f6 e0       	ldi	r31, 0x06	; 6
    11e4:	86 83       	std	Z+6, r24	; 0x06
    11e6:	04 c0       	rjmp	.+8      	; 0x11f0 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    11e8:	88 e0       	ldi	r24, 0x08	; 8
    11ea:	e0 e0       	ldi	r30, 0x00	; 0
    11ec:	f6 e0       	ldi	r31, 0x06	; 6
    11ee:	85 83       	std	Z+5, r24	; 0x05
    11f0:	8a e6       	ldi	r24, 0x6A	; 106
    11f2:	8a 95       	dec	r24
    11f4:	f1 f7       	brne	.-4      	; 0x11f2 <portExCS+0x18>
    11f6:	00 c0       	rjmp	.+0      	; 0x11f8 <portExCS+0x1e>
	}
	_delay_us(10);
}
    11f8:	08 95       	ret

000011fa <Ext1Power>:
		
	}
}

void Ext1Power(uint8_t on) {
	if (on) {
    11fa:	88 23       	and	r24, r24
    11fc:	79 f0       	breq	.+30     	; 0x121c <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    11fe:	e0 ea       	ldi	r30, 0xA0	; 160
    1200:	f6 e0       	ldi	r31, 0x06	; 6
    1202:	80 e2       	ldi	r24, 0x20	; 32
    1204:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    1206:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1208:	8f ef       	ldi	r24, 0xFF	; 255
    120a:	93 ec       	ldi	r25, 0xC3	; 195
    120c:	a9 e0       	ldi	r26, 0x09	; 9
    120e:	81 50       	subi	r24, 0x01	; 1
    1210:	90 40       	sbci	r25, 0x00	; 0
    1212:	a0 40       	sbci	r26, 0x00	; 0
    1214:	e1 f7       	brne	.-8      	; 0x120e <Ext1Power+0x14>
    1216:	00 c0       	rjmp	.+0      	; 0x1218 <Ext1Power+0x1e>
    1218:	00 00       	nop
    121a:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    121c:	e0 ea       	ldi	r30, 0xA0	; 160
    121e:	f6 e0       	ldi	r31, 0x06	; 6
    1220:	80 e2       	ldi	r24, 0x20	; 32
    1222:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    1224:	82 83       	std	Z+2, r24	; 0x02
    1226:	08 95       	ret

00001228 <Ext2Power>:
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}

void Ext2Power(uint8_t on) {
	if (on) {
    1228:	88 23       	and	r24, r24
    122a:	79 f0       	breq	.+30     	; 0x124a <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    122c:	e0 ea       	ldi	r30, 0xA0	; 160
    122e:	f6 e0       	ldi	r31, 0x06	; 6
    1230:	80 e4       	ldi	r24, 0x40	; 64
    1232:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    1234:	85 83       	std	Z+5, r24	; 0x05
    1236:	8f ef       	ldi	r24, 0xFF	; 255
    1238:	93 ec       	ldi	r25, 0xC3	; 195
    123a:	a9 e0       	ldi	r26, 0x09	; 9
    123c:	81 50       	subi	r24, 0x01	; 1
    123e:	90 40       	sbci	r25, 0x00	; 0
    1240:	a0 40       	sbci	r26, 0x00	; 0
    1242:	e1 f7       	brne	.-8      	; 0x123c <Ext2Power+0x14>
    1244:	00 c0       	rjmp	.+0      	; 0x1246 <Ext2Power+0x1e>
    1246:	00 00       	nop
    1248:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    124a:	e0 ea       	ldi	r30, 0xA0	; 160
    124c:	f6 e0       	ldi	r31, 0x06	; 6
    124e:	80 e4       	ldi	r24, 0x40	; 64
    1250:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    1252:	82 83       	std	Z+2, r24	; 0x02
    1254:	08 95       	ret

00001256 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	if (on) {
    1256:	88 23       	and	r24, r24
    1258:	79 f0       	breq	.+30     	; 0x1278 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    125a:	e0 ea       	ldi	r30, 0xA0	; 160
    125c:	f6 e0       	ldi	r31, 0x06	; 6
    125e:	80 e8       	ldi	r24, 0x80	; 128
    1260:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    1262:	85 83       	std	Z+5, r24	; 0x05
    1264:	8f ef       	ldi	r24, 0xFF	; 255
    1266:	93 ec       	ldi	r25, 0xC3	; 195
    1268:	a9 e0       	ldi	r26, 0x09	; 9
    126a:	81 50       	subi	r24, 0x01	; 1
    126c:	90 40       	sbci	r25, 0x00	; 0
    126e:	a0 40       	sbci	r26, 0x00	; 0
    1270:	e1 f7       	brne	.-8      	; 0x126a <HVPower+0x14>
    1272:	00 c0       	rjmp	.+0      	; 0x1274 <HVPower+0x1e>
    1274:	00 00       	nop
    1276:	05 c0       	rjmp	.+10     	; 0x1282 <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    1278:	e0 ea       	ldi	r30, 0xA0	; 160
    127a:	f6 e0       	ldi	r31, 0x06	; 6
    127c:	80 e8       	ldi	r24, 0x80	; 128
    127e:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    1280:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1282:	af e3       	ldi	r26, 0x3F	; 63
    1284:	bf e1       	ldi	r27, 0x1F	; 31
    1286:	11 97       	sbiw	r26, 0x01	; 1
    1288:	f1 f7       	brne	.-4      	; 0x1286 <HVPower+0x30>
    128a:	00 c0       	rjmp	.+0      	; 0x128c <HVPower+0x36>
    128c:	00 00       	nop
	}
	_delay_us(1000);
}
    128e:	08 95       	ret

00001290 <enableADCMUX>:
	if (upperCS) upperMuxCS(FALSE);
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	if(on) {
    1290:	88 23       	and	r24, r24
    1292:	31 f0       	breq	.+12     	; 0x12a0 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    1294:	e0 e0       	ldi	r30, 0x00	; 0
    1296:	f6 e0       	ldi	r31, 0x06	; 6
    1298:	80 e2       	ldi	r24, 0x20	; 32
    129a:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    129c:	85 83       	std	Z+5, r24	; 0x05
    129e:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    12a0:	e0 e0       	ldi	r30, 0x00	; 0
    12a2:	f6 e0       	ldi	r31, 0x06	; 6
    12a4:	80 e2       	ldi	r24, 0x20	; 32
    12a6:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    12a8:	82 83       	std	Z+2, r24	; 0x02
    12aa:	08 95       	ret

000012ac <lowerMuxCS>:
	}
}

void lowerMuxCS(uint8_t write) {
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    12ac:	88 23       	and	r24, r24
    12ae:	29 f0       	breq	.+10     	; 0x12ba <lowerMuxCS+0xe>
    12b0:	80 e1       	ldi	r24, 0x10	; 16
    12b2:	e0 e8       	ldi	r30, 0x80	; 128
    12b4:	f6 e0       	ldi	r31, 0x06	; 6
    12b6:	86 83       	std	Z+6, r24	; 0x06
    12b8:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    12ba:	80 e1       	ldi	r24, 0x10	; 16
    12bc:	e0 e8       	ldi	r30, 0x80	; 128
    12be:	f6 e0       	ldi	r31, 0x06	; 6
    12c0:	85 83       	std	Z+5, r24	; 0x05
    12c2:	08 95       	ret

000012c4 <upperMuxCS>:
}
void upperMuxCS(uint8_t write) {
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    12c4:	88 23       	and	r24, r24
    12c6:	29 f0       	breq	.+10     	; 0x12d2 <upperMuxCS+0xe>
    12c8:	82 e0       	ldi	r24, 0x02	; 2
    12ca:	e0 e4       	ldi	r30, 0x40	; 64
    12cc:	f6 e0       	ldi	r31, 0x06	; 6
    12ce:	86 83       	std	Z+6, r24	; 0x06
    12d0:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    12d2:	82 e0       	ldi	r24, 0x02	; 2
    12d4:	e0 e4       	ldi	r30, 0x40	; 64
    12d6:	f6 e0       	ldi	r31, 0x06	; 6
    12d8:	85 83       	std	Z+5, r24	; 0x05
    12da:	08 95       	ret

000012dc <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    12dc:	80 ff       	sbrs	r24, 0
    12de:	05 c0       	rjmp	.+10     	; 0x12ea <setADCInput+0xe>
    12e0:	20 e4       	ldi	r18, 0x40	; 64
    12e2:	e0 e0       	ldi	r30, 0x00	; 0
    12e4:	f6 e0       	ldi	r31, 0x06	; 6
    12e6:	25 83       	std	Z+5, r18	; 0x05
    12e8:	04 c0       	rjmp	.+8      	; 0x12f2 <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    12ea:	20 e4       	ldi	r18, 0x40	; 64
    12ec:	e0 e0       	ldi	r30, 0x00	; 0
    12ee:	f6 e0       	ldi	r31, 0x06	; 6
    12f0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    12f2:	81 ff       	sbrs	r24, 1
    12f4:	05 c0       	rjmp	.+10     	; 0x1300 <setADCInput+0x24>
    12f6:	22 e0       	ldi	r18, 0x02	; 2
    12f8:	e0 e2       	ldi	r30, 0x20	; 32
    12fa:	f6 e0       	ldi	r31, 0x06	; 6
    12fc:	25 83       	std	Z+5, r18	; 0x05
    12fe:	04 c0       	rjmp	.+8      	; 0x1308 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    1300:	22 e0       	ldi	r18, 0x02	; 2
    1302:	e0 e2       	ldi	r30, 0x20	; 32
    1304:	f6 e0       	ldi	r31, 0x06	; 6
    1306:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    1308:	82 ff       	sbrs	r24, 2
    130a:	05 c0       	rjmp	.+10     	; 0x1316 <setADCInput+0x3a>
    130c:	84 e0       	ldi	r24, 0x04	; 4
    130e:	e0 e2       	ldi	r30, 0x20	; 32
    1310:	f6 e0       	ldi	r31, 0x06	; 6
    1312:	85 83       	std	Z+5, r24	; 0x05
    1314:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    1316:	84 e0       	ldi	r24, 0x04	; 4
    1318:	e0 e2       	ldi	r30, 0x20	; 32
    131a:	f6 e0       	ldi	r31, 0x06	; 6
    131c:	86 83       	std	Z+6, r24	; 0x06
    131e:	08 95       	ret

00001320 <SPIInit>:
}


void SPIInit(uint8_t mode) {
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    1320:	e0 e4       	ldi	r30, 0x40	; 64
    1322:	f6 e0       	ldi	r31, 0x06	; 6
    1324:	90 e1       	ldi	r25, 0x10	; 16
    1326:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    1328:	28 e3       	ldi	r18, 0x38	; 56
    132a:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    132c:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    132e:	81 65       	ori	r24, 0x51	; 81
    1330:	a0 ec       	ldi	r26, 0xC0	; 192
    1332:	b8 e0       	ldi	r27, 0x08	; 8
    1334:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    1336:	11 96       	adiw	r26, 0x01	; 1
    1338:	1c 92       	st	X, r1
    133a:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    133c:	80 ea       	ldi	r24, 0xA0	; 160
    133e:	81 83       	std	Z+1, r24	; 0x01

	
}
    1340:	08 95       	ret

00001342 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    1342:	e0 e4       	ldi	r30, 0x40	; 64
    1344:	f6 e0       	ldi	r31, 0x06	; 6
    1346:	90 e1       	ldi	r25, 0x10	; 16
    1348:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    134a:	28 e3       	ldi	r18, 0x38	; 56
    134c:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    134e:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    1350:	80 65       	ori	r24, 0x50	; 80
    1352:	68 2b       	or	r22, r24
    1354:	a0 ec       	ldi	r26, 0xC0	; 192
    1356:	b8 e0       	ldi	r27, 0x08	; 8
    1358:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    135a:	11 96       	adiw	r26, 0x01	; 1
    135c:	1c 92       	st	X, r1
    135e:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    1360:	80 ea       	ldi	r24, 0xA0	; 160
    1362:	81 83       	std	Z+1, r24	; 0x01
}
    1364:	08 95       	ret

00001366 <SPICS>:

void SPICS(uint8_t enable) {
	if (enable) PORTC.OUTCLR = PIN4_bm;
    1366:	88 23       	and	r24, r24
    1368:	29 f0       	breq	.+10     	; 0x1374 <SPICS+0xe>
    136a:	80 e1       	ldi	r24, 0x10	; 16
    136c:	e0 e4       	ldi	r30, 0x40	; 64
    136e:	f6 e0       	ldi	r31, 0x06	; 6
    1370:	86 83       	std	Z+6, r24	; 0x06
    1372:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    1374:	80 e1       	ldi	r24, 0x10	; 16
    1376:	e0 e4       	ldi	r30, 0x40	; 64
    1378:	f6 e0       	ldi	r31, 0x06	; 6
    137a:	85 83       	std	Z+5, r24	; 0x05
    137c:	08 95       	ret

0000137e <SPIDisable>:
	}	
}

void SPIDisable() {
	PORTC.OUTSET = PIN4_bm;
    137e:	e0 e4       	ldi	r30, 0x40	; 64
    1380:	f6 e0       	ldi	r31, 0x06	; 6
    1382:	80 e1       	ldi	r24, 0x10	; 16
    1384:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    1386:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    138a:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    138c:	80 eb       	ldi	r24, 0xB0	; 176
    138e:	82 83       	std	Z+2, r24	; 0x02

}
    1390:	08 95       	ret

00001392 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    1396:	c8 2f       	mov	r28, r24
    1398:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
    139a:	d8 2f       	mov	r29, r24
    139c:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    139e:	28 2f       	mov	r18, r24
    13a0:	30 e0       	ldi	r19, 0x00	; 0
    13a2:	a9 01       	movw	r20, r18
    13a4:	45 70       	andi	r20, 0x05	; 5
    13a6:	50 70       	andi	r21, 0x00	; 0
    13a8:	41 15       	cp	r20, r1
    13aa:	51 05       	cpc	r21, r1
    13ac:	49 f0       	breq	.+18     	; 0x13c0 <set_filter+0x2e>
    13ae:	90 91 75 50 	lds	r25, 0x5075
    13b2:	48 2f       	mov	r20, r24
    13b4:	42 95       	swap	r20
    13b6:	4f 70       	andi	r20, 0x0F	; 15
    13b8:	90 7f       	andi	r25, 0xF0	; 240
    13ba:	94 2b       	or	r25, r20
    13bc:	90 93 75 50 	sts	0x5075, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    13c0:	2a 70       	andi	r18, 0x0A	; 10
    13c2:	30 70       	andi	r19, 0x00	; 0
    13c4:	21 15       	cp	r18, r1
    13c6:	31 05       	cpc	r19, r1
    13c8:	39 f0       	breq	.+14     	; 0x13d8 <set_filter+0x46>
    13ca:	90 91 75 50 	lds	r25, 0x5075
    13ce:	80 7f       	andi	r24, 0xF0	; 240
    13d0:	9f 70       	andi	r25, 0x0F	; 15
    13d2:	89 2b       	or	r24, r25
    13d4:	80 93 75 50 	sts	0x5075, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    13d8:	84 e0       	ldi	r24, 0x04	; 4
    13da:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    13de:	80 91 75 50 	lds	r24, 0x5075
    13e2:	80 93 67 50 	sts	0x5067, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    13e6:	cc 23       	and	r28, r28
    13e8:	19 f0       	breq	.+6      	; 0x13f0 <set_filter+0x5e>
    13ea:	81 e0       	ldi	r24, 0x01	; 1
    13ec:	0e 94 56 09 	call	0x12ac	; 0x12ac <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    13f0:	dd 23       	and	r29, r29
    13f2:	19 f0       	breq	.+6      	; 0x13fa <set_filter+0x68>
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	0e 94 62 09 	call	0x12c4	; 0x12c4 <upperMuxCS>

	SPICS(TRUE);
    13fa:	81 e0       	ldi	r24, 0x01	; 1
    13fc:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    1400:	8f ef       	ldi	r24, 0xFF	; 255
    1402:	e0 ec       	ldi	r30, 0xC0	; 192
    1404:	f8 e0       	ldi	r31, 0x08	; 8
    1406:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1408:	82 81       	ldd	r24, Z+2	; 0x02
    140a:	88 23       	and	r24, r24
    140c:	ec f7       	brge	.-6      	; 0x1408 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
    140e:	e0 ec       	ldi	r30, 0xC0	; 192
    1410:	f8 e0       	ldi	r31, 0x08	; 8
    1412:	83 81       	ldd	r24, Z+3	; 0x03
    1414:	80 93 73 50 	sts	0x5073, r24

	nop();
    1418:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    141a:	a3 e7       	ldi	r26, 0x73	; 115
    141c:	b0 e5       	ldi	r27, 0x50	; 80
    141e:	1c 97       	sbiw	r26, 0x0c	; 12
    1420:	8c 91       	ld	r24, X
    1422:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1424:	82 81       	ldd	r24, Z+2	; 0x02
    1426:	88 23       	and	r24, r24
    1428:	ec f7       	brge	.-6      	; 0x1424 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    142a:	e0 ec       	ldi	r30, 0xC0	; 192
    142c:	f8 e0       	ldi	r31, 0x08	; 8
    142e:	83 81       	ldd	r24, Z+3	; 0x03
    1430:	80 93 73 50 	sts	0x5073, r24
	SPICS(FALSE);
    1434:	80 e0       	ldi	r24, 0x00	; 0
    1436:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    143a:	cc 23       	and	r28, r28
    143c:	19 f0       	breq	.+6      	; 0x1444 <set_filter+0xb2>
    143e:	80 e0       	ldi	r24, 0x00	; 0
    1440:	0e 94 56 09 	call	0x12ac	; 0x12ac <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    1444:	dd 23       	and	r29, r29
    1446:	19 f0       	breq	.+6      	; 0x144e <set_filter+0xbc>
    1448:	80 e0       	ldi	r24, 0x00	; 0
    144a:	0e 94 62 09 	call	0x12c4	; 0x12c4 <upperMuxCS>
	SPIDisable();
    144e:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
}
    1452:	df 91       	pop	r29
    1454:	cf 91       	pop	r28
    1456:	08 95       	ret

00001458 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	c8 2f       	mov	r28, r24
    145e:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    1460:	80 e0       	ldi	r24, 0x00	; 0
    1462:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	portExCS(TRUE);
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    1472:	dd 23       	and	r29, r29
    1474:	89 f0       	breq	.+34     	; 0x1498 <PortEx_OUTCLR+0x40>
    1476:	80 91 63 40 	lds	r24, 0x4063
    147a:	c0 95       	com	r28
    147c:	c8 23       	and	r28, r24
    147e:	c0 93 63 40 	sts	0x4063, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    1482:	80 e4       	ldi	r24, 0x40	; 64
    1484:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    1488:	84 e1       	ldi	r24, 0x14	; 20
    148a:	80 93 68 50 	sts	0x5068, r24
		SPIBuffer[2] = bankA_OUT;
    148e:	80 91 63 40 	lds	r24, 0x4063
    1492:	80 93 69 50 	sts	0x5069, r24
    1496:	10 c0       	rjmp	.+32     	; 0x14b8 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    1498:	80 91 76 50 	lds	r24, 0x5076
    149c:	c0 95       	com	r28
    149e:	c8 23       	and	r28, r24
    14a0:	c0 93 76 50 	sts	0x5076, r28
	
	SPIBuffer[0] = PS_WRITE;
    14a4:	80 e4       	ldi	r24, 0x40	; 64
    14a6:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    14aa:	85 e1       	ldi	r24, 0x15	; 21
    14ac:	80 93 68 50 	sts	0x5068, r24
		SPIBuffer[2] = bankB_OUT; 
    14b0:	80 91 76 50 	lds	r24, 0x5076
    14b4:	80 93 69 50 	sts	0x5069, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    14b8:	80 e0       	ldi	r24, 0x00	; 0
    14ba:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    14bc:	27 e6       	ldi	r18, 0x67	; 103
    14be:	30 e5       	ldi	r19, 0x50	; 80
    14c0:	a0 ec       	ldi	r26, 0xC0	; 192
    14c2:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    14c4:	c3 e7       	ldi	r28, 0x73	; 115
    14c6:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    14c8:	f9 01       	movw	r30, r18
    14ca:	e8 0f       	add	r30, r24
    14cc:	f9 1f       	adc	r31, r25
    14ce:	40 81       	ld	r20, Z
    14d0:	13 96       	adiw	r26, 0x03	; 3
    14d2:	4c 93       	st	X, r20
    14d4:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    14d6:	12 96       	adiw	r26, 0x02	; 2
    14d8:	4c 91       	ld	r20, X
    14da:	12 97       	sbiw	r26, 0x02	; 2
    14dc:	44 23       	and	r20, r20
    14de:	dc f7       	brge	.-10     	; 0x14d6 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    14e0:	13 96       	adiw	r26, 0x03	; 3
    14e2:	4c 91       	ld	r20, X
    14e4:	13 97       	sbiw	r26, 0x03	; 3
    14e6:	48 83       	st	Y, r20
    14e8:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    14ea:	83 30       	cpi	r24, 0x03	; 3
    14ec:	91 05       	cpc	r25, r1
    14ee:	61 f7       	brne	.-40     	; 0x14c8 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    14f0:	80 e0       	ldi	r24, 0x00	; 0
    14f2:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	portExCS(FALSE);
    14f6:	80 e0       	ldi	r24, 0x00	; 0
    14f8:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>
	SPIDisable();
    14fc:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
}
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	08 95       	ret

00001506 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    1506:	cf 93       	push	r28
    1508:	df 93       	push	r29
    150a:	c8 2f       	mov	r28, r24
    150c:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    1514:	81 e0       	ldi	r24, 0x01	; 1
    1516:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	portExCS(TRUE);
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    1520:	dd 23       	and	r29, r29
    1522:	81 f0       	breq	.+32     	; 0x1544 <PortEx_OUTSET+0x3e>
    1524:	80 91 63 40 	lds	r24, 0x4063
    1528:	c8 2b       	or	r28, r24
    152a:	c0 93 63 40 	sts	0x4063, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    152e:	80 e4       	ldi	r24, 0x40	; 64
    1530:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    1534:	84 e1       	ldi	r24, 0x14	; 20
    1536:	80 93 68 50 	sts	0x5068, r24
		SPIBuffer[2] = bankA_OUT;
    153a:	80 91 63 40 	lds	r24, 0x4063
    153e:	80 93 69 50 	sts	0x5069, r24
    1542:	0f c0       	rjmp	.+30     	; 0x1562 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    1544:	80 91 76 50 	lds	r24, 0x5076
    1548:	c8 2b       	or	r28, r24
    154a:	c0 93 76 50 	sts	0x5076, r28
	
	SPIBuffer[0] = PS_WRITE;
    154e:	80 e4       	ldi	r24, 0x40	; 64
    1550:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    1554:	85 e1       	ldi	r24, 0x15	; 21
    1556:	80 93 68 50 	sts	0x5068, r24
		SPIBuffer[2] = bankB_OUT; 
    155a:	80 91 76 50 	lds	r24, 0x5076
    155e:	80 93 69 50 	sts	0x5069, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    1562:	80 e0       	ldi	r24, 0x00	; 0
    1564:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    1566:	27 e6       	ldi	r18, 0x67	; 103
    1568:	30 e5       	ldi	r19, 0x50	; 80
    156a:	a0 ec       	ldi	r26, 0xC0	; 192
    156c:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    156e:	c3 e7       	ldi	r28, 0x73	; 115
    1570:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    1572:	f9 01       	movw	r30, r18
    1574:	e8 0f       	add	r30, r24
    1576:	f9 1f       	adc	r31, r25
    1578:	40 81       	ld	r20, Z
    157a:	13 96       	adiw	r26, 0x03	; 3
    157c:	4c 93       	st	X, r20
    157e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    1580:	12 96       	adiw	r26, 0x02	; 2
    1582:	4c 91       	ld	r20, X
    1584:	12 97       	sbiw	r26, 0x02	; 2
    1586:	44 23       	and	r20, r20
    1588:	dc f7       	brge	.-10     	; 0x1580 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    158a:	13 96       	adiw	r26, 0x03	; 3
    158c:	4c 91       	ld	r20, X
    158e:	13 97       	sbiw	r26, 0x03	; 3
    1590:	48 83       	st	Y, r20
    1592:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1594:	83 30       	cpi	r24, 0x03	; 3
    1596:	91 05       	cpc	r25, r1
    1598:	61 f7       	brne	.-40     	; 0x1572 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    159a:	80 e0       	ldi	r24, 0x00	; 0
    159c:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	portExCS(FALSE);
    15a0:	80 e0       	ldi	r24, 0x00	; 0
    15a2:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>
	SPIDisable();
    15a6:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
}
    15aa:	df 91       	pop	r29
    15ac:	cf 91       	pop	r28
    15ae:	08 95       	ret

000015b0 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    15b0:	cf 93       	push	r28
    15b2:	c6 2f       	mov	r28, r22
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    15b4:	21 e0       	ldi	r18, 0x01	; 1
    15b6:	30 e0       	ldi	r19, 0x00	; 0
    15b8:	a9 01       	movw	r20, r18
    15ba:	02 c0       	rjmp	.+4      	; 0x15c0 <set_ampGain+0x10>
    15bc:	44 0f       	add	r20, r20
    15be:	55 1f       	adc	r21, r21
    15c0:	8a 95       	dec	r24
    15c2:	e2 f7       	brpl	.-8      	; 0x15bc <set_ampGain+0xc>
    15c4:	ca 01       	movw	r24, r20
    15c6:	61 e0       	ldi	r22, 0x01	; 1
    15c8:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    15cc:	c0 ff       	sbrs	r28, 0
    15ce:	05 c0       	rjmp	.+10     	; 0x15da <set_ampGain+0x2a>
    15d0:	80 e4       	ldi	r24, 0x40	; 64
    15d2:	e0 e0       	ldi	r30, 0x00	; 0
    15d4:	f6 e0       	ldi	r31, 0x06	; 6
    15d6:	85 83       	std	Z+5, r24	; 0x05
    15d8:	04 c0       	rjmp	.+8      	; 0x15e2 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    15da:	80 e4       	ldi	r24, 0x40	; 64
    15dc:	e0 e0       	ldi	r30, 0x00	; 0
    15de:	f6 e0       	ldi	r31, 0x06	; 6
    15e0:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    15e2:	c1 ff       	sbrs	r28, 1
    15e4:	05 c0       	rjmp	.+10     	; 0x15f0 <set_ampGain+0x40>
    15e6:	82 e0       	ldi	r24, 0x02	; 2
    15e8:	e0 e2       	ldi	r30, 0x20	; 32
    15ea:	f6 e0       	ldi	r31, 0x06	; 6
    15ec:	85 83       	std	Z+5, r24	; 0x05
    15ee:	04 c0       	rjmp	.+8      	; 0x15f8 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    15f0:	82 e0       	ldi	r24, 0x02	; 2
    15f2:	e0 e2       	ldi	r30, 0x20	; 32
    15f4:	f6 e0       	ldi	r31, 0x06	; 6
    15f6:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    15f8:	c2 ff       	sbrs	r28, 2
    15fa:	05 c0       	rjmp	.+10     	; 0x1606 <set_ampGain+0x56>
    15fc:	84 e0       	ldi	r24, 0x04	; 4
    15fe:	e0 e2       	ldi	r30, 0x20	; 32
    1600:	f6 e0       	ldi	r31, 0x06	; 6
    1602:	85 83       	std	Z+5, r24	; 0x05
    1604:	04 c0       	rjmp	.+8      	; 0x160e <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    1606:	84 e0       	ldi	r24, 0x04	; 4
    1608:	e0 e2       	ldi	r30, 0x20	; 32
    160a:	f6 e0       	ldi	r31, 0x06	; 6
    160c:	86 83       	std	Z+6, r24	; 0x06
    160e:	5a e0       	ldi	r21, 0x0A	; 10
    1610:	5a 95       	dec	r21
    1612:	f1 f7       	brne	.-4      	; 0x1610 <set_ampGain+0x60>
    1614:	00 c0       	rjmp	.+0      	; 0x1616 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    1616:	8f ef       	ldi	r24, 0xFF	; 255
    1618:	61 e0       	ldi	r22, 0x01	; 1
    161a:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    161e:	cf 91       	pop	r28
    1620:	08 95       	ret

00001622 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    1622:	cf 93       	push	r28
    1624:	df 93       	push	r29
    1626:	c8 2f       	mov	r28, r24
    1628:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	portExCS(TRUE);
    1636:	81 e0       	ldi	r24, 0x01	; 1
    1638:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    163c:	dd 23       	and	r29, r29
    163e:	89 f0       	breq	.+34     	; 0x1662 <PortEx_DIRCLR+0x40>
    1640:	80 91 74 50 	lds	r24, 0x5074
    1644:	80 95       	com	r24
    1646:	c8 23       	and	r28, r24
    1648:	c0 93 74 50 	sts	0x5074, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    164c:	80 e4       	ldi	r24, 0x40	; 64
    164e:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    1652:	10 92 68 50 	sts	0x5068, r1
		SPIBuffer[2] = ~bankA_DIR; 
    1656:	80 91 74 50 	lds	r24, 0x5074
    165a:	80 95       	com	r24
    165c:	80 93 69 50 	sts	0x5069, r24
    1660:	11 c0       	rjmp	.+34     	; 0x1684 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    1662:	80 91 9f 50 	lds	r24, 0x509F
    1666:	80 95       	com	r24
    1668:	c8 23       	and	r28, r24
    166a:	c0 93 9f 50 	sts	0x509F, r28
	
	SPIBuffer[0] = PS_WRITE;
    166e:	80 e4       	ldi	r24, 0x40	; 64
    1670:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    1674:	81 e0       	ldi	r24, 0x01	; 1
    1676:	80 93 68 50 	sts	0x5068, r24
		SPIBuffer[2] = ~bankB_DIR;
    167a:	80 91 9f 50 	lds	r24, 0x509F
    167e:	80 95       	com	r24
    1680:	80 93 69 50 	sts	0x5069, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    1684:	80 e0       	ldi	r24, 0x00	; 0
    1686:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    1688:	27 e6       	ldi	r18, 0x67	; 103
    168a:	30 e5       	ldi	r19, 0x50	; 80
    168c:	a0 ec       	ldi	r26, 0xC0	; 192
    168e:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    1690:	c3 e7       	ldi	r28, 0x73	; 115
    1692:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    1694:	f9 01       	movw	r30, r18
    1696:	e8 0f       	add	r30, r24
    1698:	f9 1f       	adc	r31, r25
    169a:	40 81       	ld	r20, Z
    169c:	13 96       	adiw	r26, 0x03	; 3
    169e:	4c 93       	st	X, r20
    16a0:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    16a2:	12 96       	adiw	r26, 0x02	; 2
    16a4:	4c 91       	ld	r20, X
    16a6:	12 97       	sbiw	r26, 0x02	; 2
    16a8:	44 23       	and	r20, r20
    16aa:	dc f7       	brge	.-10     	; 0x16a2 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    16ac:	13 96       	adiw	r26, 0x03	; 3
    16ae:	4c 91       	ld	r20, X
    16b0:	13 97       	sbiw	r26, 0x03	; 3
    16b2:	48 83       	st	Y, r20
    16b4:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    16b6:	83 30       	cpi	r24, 0x03	; 3
    16b8:	91 05       	cpc	r25, r1
    16ba:	61 f7       	brne	.-40     	; 0x1694 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    16bc:	80 e0       	ldi	r24, 0x00	; 0
    16be:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	portExCS(FALSE);
    16c2:	80 e0       	ldi	r24, 0x00	; 0
    16c4:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>
	SPIDisable();
    16c8:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
}
    16cc:	df 91       	pop	r29
    16ce:	cf 91       	pop	r28
    16d0:	08 95       	ret

000016d2 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	c8 2f       	mov	r28, r24
    16d8:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    16da:	80 e0       	ldi	r24, 0x00	; 0
    16dc:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    16e0:	81 e0       	ldi	r24, 0x01	; 1
    16e2:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	portExCS(TRUE);
    16e6:	81 e0       	ldi	r24, 0x01	; 1
    16e8:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    16ec:	dd 23       	and	r29, r29
    16ee:	81 f0       	breq	.+32     	; 0x1710 <PortEx_DIRSET+0x3e>
    16f0:	80 91 74 50 	lds	r24, 0x5074
    16f4:	c8 2b       	or	r28, r24
    16f6:	c0 93 74 50 	sts	0x5074, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    16fa:	80 e4       	ldi	r24, 0x40	; 64
    16fc:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    1700:	10 92 68 50 	sts	0x5068, r1
		SPIBuffer[2] = ~bankA_DIR; 
    1704:	80 91 74 50 	lds	r24, 0x5074
    1708:	80 95       	com	r24
    170a:	80 93 69 50 	sts	0x5069, r24
    170e:	10 c0       	rjmp	.+32     	; 0x1730 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    1710:	80 91 9f 50 	lds	r24, 0x509F
    1714:	c8 2b       	or	r28, r24
    1716:	c0 93 9f 50 	sts	0x509F, r28
	
	SPIBuffer[0] = PS_WRITE;
    171a:	80 e4       	ldi	r24, 0x40	; 64
    171c:	80 93 67 50 	sts	0x5067, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	80 93 68 50 	sts	0x5068, r24
		SPIBuffer[2] = ~bankB_DIR;
    1726:	80 91 9f 50 	lds	r24, 0x509F
    172a:	80 95       	com	r24
    172c:	80 93 69 50 	sts	0x5069, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    1734:	27 e6       	ldi	r18, 0x67	; 103
    1736:	30 e5       	ldi	r19, 0x50	; 80
    1738:	a0 ec       	ldi	r26, 0xC0	; 192
    173a:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    173c:	c3 e7       	ldi	r28, 0x73	; 115
    173e:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    1740:	f9 01       	movw	r30, r18
    1742:	e8 0f       	add	r30, r24
    1744:	f9 1f       	adc	r31, r25
    1746:	40 81       	ld	r20, Z
    1748:	13 96       	adiw	r26, 0x03	; 3
    174a:	4c 93       	st	X, r20
    174c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    174e:	12 96       	adiw	r26, 0x02	; 2
    1750:	4c 91       	ld	r20, X
    1752:	12 97       	sbiw	r26, 0x02	; 2
    1754:	44 23       	and	r20, r20
    1756:	dc f7       	brge	.-10     	; 0x174e <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    1758:	13 96       	adiw	r26, 0x03	; 3
    175a:	4c 91       	ld	r20, X
    175c:	13 97       	sbiw	r26, 0x03	; 3
    175e:	48 83       	st	Y, r20
    1760:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1762:	83 30       	cpi	r24, 0x03	; 3
    1764:	91 05       	cpc	r25, r1
    1766:	61 f7       	brne	.-40     	; 0x1740 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    1768:	80 e0       	ldi	r24, 0x00	; 0
    176a:	0e 94 ed 08 	call	0x11da	; 0x11da <portExCS>
	SPICS(FALSE);
    176e:	80 e0       	ldi	r24, 0x00	; 0
    1770:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    1774:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>


}
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	08 95       	ret

0000177e <ADCPower>:
	portExCS(FALSE);	
	SPIDisable();
}
*/

void ADCPower(uint8_t on) {
    177e:	0f 93       	push	r16
    1780:	1f 93       	push	r17
    1782:	cf 93       	push	r28
    1784:	df 93       	push	r29
	if (on) {
    1786:	88 23       	and	r24, r24
    1788:	09 f4       	brne	.+2      	; 0x178c <ADCPower+0xe>
    178a:	46 c0       	rjmp	.+140    	; 0x1818 <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
    178c:	00 e0       	ldi	r16, 0x00	; 0
    178e:	16 e0       	ldi	r17, 0x06	; 6
    1790:	8e ed       	ldi	r24, 0xDE	; 222
    1792:	d8 01       	movw	r26, r16
    1794:	11 96       	adiw	r26, 0x01	; 1
    1796:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
    1798:	c0 e2       	ldi	r28, 0x20	; 32
    179a:	d6 e0       	ldi	r29, 0x06	; 6
    179c:	4e e0       	ldi	r20, 0x0E	; 14
    179e:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
    17a0:	e0 e4       	ldi	r30, 0x40	; 64
    17a2:	f6 e0       	ldi	r31, 0x06	; 6
    17a4:	63 e0       	ldi	r22, 0x03	; 3
    17a6:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
    17a8:	80 e8       	ldi	r24, 0x80	; 128
    17aa:	96 e0       	ldi	r25, 0x06	; 6
    17ac:	50 e1       	ldi	r21, 0x10	; 16
    17ae:	dc 01       	movw	r26, r24
    17b0:	11 96       	adiw	r26, 0x01	; 1
    17b2:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
    17b4:	20 ea       	ldi	r18, 0xA0	; 160
    17b6:	36 e0       	ldi	r19, 0x06	; 6
    17b8:	d9 01       	movw	r26, r18
    17ba:	11 96       	adiw	r26, 0x01	; 1
    17bc:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
    17be:	7e e9       	ldi	r23, 0x9E	; 158
    17c0:	d8 01       	movw	r26, r16
    17c2:	15 96       	adiw	r26, 0x05	; 5
    17c4:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
    17c6:	78 e0       	ldi	r23, 0x08	; 8
    17c8:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
    17ca:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
    17cc:	ec 01       	movw	r28, r24
    17ce:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
    17d0:	d9 01       	movw	r26, r18
    17d2:	15 96       	adiw	r26, 0x05	; 5
    17d4:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
    17d6:	10 92 75 50 	sts	0x5075, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17da:	8f ef       	ldi	r24, 0xFF	; 255
    17dc:	93 ec       	ldi	r25, 0xC3	; 195
    17de:	a9 e0       	ldi	r26, 0x09	; 9
    17e0:	81 50       	subi	r24, 0x01	; 1
    17e2:	90 40       	sbci	r25, 0x00	; 0
    17e4:	a0 40       	sbci	r26, 0x00	; 0
    17e6:	e1 f7       	brne	.-8      	; 0x17e0 <ADCPower+0x62>
    17e8:	00 c0       	rjmp	.+0      	; 0x17ea <ADCPower+0x6c>
    17ea:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
    17ec:	80 e4       	ldi	r24, 0x40	; 64
    17ee:	82 83       	std	Z+2, r24	; 0x02
				
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
    17f0:	10 92 76 50 	sts	0x5076, r1
    17f4:	10 92 9f 50 	sts	0x509F, r1
    17f8:	10 92 63 40 	sts	0x4063, r1
    17fc:	10 92 74 50 	sts	0x5074, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
    1800:	8f ef       	ldi	r24, 0xFF	; 255
    1802:	61 e0       	ldi	r22, 0x01	; 1
    1804:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
    1808:	8f ef       	ldi	r24, 0xFF	; 255
    180a:	61 e0       	ldi	r22, 0x01	; 1
    180c:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
    1810:	8f ef       	ldi	r24, 0xFF	; 255
    1812:	0e 94 c9 09 	call	0x1392	; 0x1392 <set_filter>
    1816:	32 c0       	rjmp	.+100    	; 0x187c <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
    1818:	00 e0       	ldi	r16, 0x00	; 0
    181a:	16 e0       	ldi	r17, 0x06	; 6
    181c:	7e ed       	ldi	r23, 0xDE	; 222
    181e:	d8 01       	movw	r26, r16
    1820:	16 96       	adiw	r26, 0x06	; 6
    1822:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
    1824:	a0 e2       	ldi	r26, 0x20	; 32
    1826:	b6 e0       	ldi	r27, 0x06	; 6
    1828:	4e e0       	ldi	r20, 0x0E	; 14
    182a:	16 96       	adiw	r26, 0x06	; 6
    182c:	4c 93       	st	X, r20
    182e:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
    1830:	20 e4       	ldi	r18, 0x40	; 64
    1832:	36 e0       	ldi	r19, 0x06	; 6
    1834:	63 e0       	ldi	r22, 0x03	; 3
    1836:	e9 01       	movw	r28, r18
    1838:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
    183a:	c0 e8       	ldi	r28, 0x80	; 128
    183c:	d6 e0       	ldi	r29, 0x06	; 6
    183e:	50 e1       	ldi	r21, 0x10	; 16
    1840:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
    1842:	80 ea       	ldi	r24, 0xA0	; 160
    1844:	96 e0       	ldi	r25, 0x06	; 6
    1846:	fc 01       	movw	r30, r24
    1848:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
    184a:	f8 01       	movw	r30, r16
    184c:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
    184e:	12 96       	adiw	r26, 0x02	; 2
    1850:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
    1852:	d9 01       	movw	r26, r18
    1854:	12 96       	adiw	r26, 0x02	; 2
    1856:	6c 93       	st	X, r22
    1858:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
    185a:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
    185c:	ec 01       	movw	r28, r24
    185e:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
    1860:	80 e4       	ldi	r24, 0x40	; 64
    1862:	12 96       	adiw	r26, 0x02	; 2
    1864:	8c 93       	st	X, r24
    1866:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
    1868:	10 92 76 50 	sts	0x5076, r1
    186c:	10 92 9f 50 	sts	0x509F, r1
    1870:	10 92 63 40 	sts	0x4063, r1
    1874:	10 92 74 50 	sts	0x5074, r1
		channelStatus = 0x00;
    1878:	10 92 75 50 	sts	0x5075, r1
		
	}
}
    187c:	df 91       	pop	r29
    187e:	cf 91       	pop	r28
    1880:	1f 91       	pop	r17
    1882:	0f 91       	pop	r16
    1884:	08 95       	ret

00001886 <CO_collectTemp>:
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
	CLKSYS_Disable( OSC_RC2MEN_bm );
	
}

void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    1886:	4f 92       	push	r4
    1888:	5f 92       	push	r5
    188a:	6f 92       	push	r6
    188c:	7f 92       	push	r7
    188e:	8f 92       	push	r8
    1890:	9f 92       	push	r9
    1892:	af 92       	push	r10
    1894:	bf 92       	push	r11
    1896:	ef 92       	push	r14
    1898:	ff 92       	push	r15
    189a:	0f 93       	push	r16
    189c:	1f 93       	push	r17
    189e:	cf 93       	push	r28
    18a0:	df 93       	push	r29
    18a2:	cd b7       	in	r28, 0x3d	; 61
    18a4:	de b7       	in	r29, 0x3e	; 62
    18a6:	2b 97       	sbiw	r28, 0x0b	; 11
    18a8:	cd bf       	out	0x3d, r28	; 61
    18aa:	de bf       	out	0x3e, r29	; 62
    18ac:	8e 83       	std	Y+6, r24	; 0x06
    18ae:	9f 83       	std	Y+7, r25	; 0x07
    18b0:	68 87       	std	Y+8, r22	; 0x08
    18b2:	79 87       	std	Y+9, r23	; 0x09
    18b4:	4a 87       	std	Y+10, r20	; 0x0a
    18b6:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    18be:	80 e0       	ldi	r24, 0x00	; 0
    18c0:	92 e0       	ldi	r25, 0x02	; 2
    18c2:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    18c6:	00 e0       	ldi	r16, 0x00	; 0
    18c8:	12 e0       	ldi	r17, 0x02	; 2
    18ca:	d8 01       	movw	r26, r16
    18cc:	11 96       	adiw	r26, 0x01	; 1
    18ce:	8c 91       	ld	r24, X
    18d0:	11 97       	sbiw	r26, 0x01	; 1
    18d2:	89 7e       	andi	r24, 0xE9	; 233
    18d4:	11 96       	adiw	r26, 0x01	; 1
    18d6:	8c 93       	st	X, r24
    18d8:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    18da:	14 96       	adiw	r26, 0x04	; 4
    18dc:	8c 91       	ld	r24, X
    18de:	14 97       	sbiw	r26, 0x04	; 4
    18e0:	88 7f       	andi	r24, 0xF8	; 248
    18e2:	83 60       	ori	r24, 0x03	; 3
    18e4:	14 96       	adiw	r26, 0x04	; 4
    18e6:	8c 93       	st	X, r24
    18e8:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    18ea:	12 96       	adiw	r26, 0x02	; 2
    18ec:	8c 91       	ld	r24, X
    18ee:	12 97       	sbiw	r26, 0x02	; 2
    18f0:	8f 7c       	andi	r24, 0xCF	; 207
    18f2:	12 96       	adiw	r26, 0x02	; 2
    18f4:	8c 93       	st	X, r24
    18f6:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    18f8:	0f 2e       	mov	r0, r31
    18fa:	f0 e2       	ldi	r31, 0x20	; 32
    18fc:	ef 2e       	mov	r14, r31
    18fe:	f2 e0       	ldi	r31, 0x02	; 2
    1900:	ff 2e       	mov	r15, r31
    1902:	f0 2d       	mov	r31, r0
    1904:	f7 01       	movw	r30, r14
    1906:	80 81       	ld	r24, Z
    1908:	80 7e       	andi	r24, 0xE0	; 224
    190a:	81 60       	ori	r24, 0x01	; 1
    190c:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    190e:	89 e0       	ldi	r24, 0x09	; 9
    1910:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    1912:	8c 91       	ld	r24, X
    1914:	81 60       	ori	r24, 0x01	; 1
    1916:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1918:	80 e0       	ldi	r24, 0x00	; 0
    191a:	92 e0       	ldi	r25, 0x02	; 2
    191c:	0e 94 65 01 	call	0x2ca	; 0x2ca <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    1920:	80 e0       	ldi	r24, 0x00	; 0
    1922:	92 e0       	ldi	r25, 0x02	; 2
    1924:	60 e2       	ldi	r22, 0x20	; 32
    1926:	72 e0       	ldi	r23, 0x02	; 2
    1928:	40 e0       	ldi	r20, 0x00	; 0
    192a:	0e 94 6f 01 	call	0x2de	; 0x2de <ADC_Offset_Get_Unsigned>
    192e:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    1930:	d8 01       	movw	r26, r16
    1932:	8c 91       	ld	r24, X
    1934:	8e 7f       	andi	r24, 0xFE	; 254
    1936:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1938:	f7 01       	movw	r30, r14
    193a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    193c:	13 96       	adiw	r26, 0x03	; 3
    193e:	8c 91       	ld	r24, X
    1940:	13 97       	sbiw	r26, 0x03	; 3
    1942:	8f 73       	andi	r24, 0x3F	; 63
    1944:	13 96       	adiw	r26, 0x03	; 3
    1946:	8c 93       	st	X, r24
    1948:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    194a:	8c 91       	ld	r24, X
    194c:	81 60       	ori	r24, 0x01	; 1
    194e:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1950:	80 e0       	ldi	r24, 0x00	; 0
    1952:	92 e0       	ldi	r25, 0x02	; 2
    1954:	0e 94 65 01 	call	0x2ca	; 0x2ca <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    1958:	d8 01       	movw	r26, r16
    195a:	11 96       	adiw	r26, 0x01	; 1
    195c:	8c 91       	ld	r24, X
    195e:	11 97       	sbiw	r26, 0x01	; 1
    1960:	88 60       	ori	r24, 0x08	; 8
    1962:	11 96       	adiw	r26, 0x01	; 1
    1964:	8c 93       	st	X, r24
    1966:	ee 24       	eor	r14, r14
    1968:	ff 24       	eor	r15, r15
    196a:	68 94       	set
    196c:	f2 f8       	bld	r15, 2
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    196e:	44 24       	eor	r4, r4
    1970:	55 24       	eor	r5, r5
    1972:	32 01       	movw	r6, r4

void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    1974:	20 e0       	ldi	r18, 0x00	; 0
    1976:	30 e1       	ldi	r19, 0x10	; 16
    1978:	40 e0       	ldi	r20, 0x00	; 0
    197a:	50 e0       	ldi	r21, 0x00	; 0
    197c:	2a 83       	std	Y+2, r18	; 0x02
    197e:	3b 83       	std	Y+3, r19	; 0x03
    1980:	4c 83       	std	Y+4, r20	; 0x04
    1982:	5d 83       	std	Y+5, r21	; 0x05
	CLKSYS_Disable( OSC_RC2MEN_bm );
	
}

void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
    1984:	88 24       	eor	r8, r8
    1986:	99 24       	eor	r9, r9
    1988:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    198a:	00 e2       	ldi	r16, 0x20	; 32
    198c:	12 e0       	ldi	r17, 0x02	; 2
    198e:	d8 01       	movw	r26, r16
    1990:	13 96       	adiw	r26, 0x03	; 3
    1992:	8c 91       	ld	r24, X
    1994:	13 97       	sbiw	r26, 0x03	; 3
    1996:	80 ff       	sbrs	r24, 0
    1998:	fa cf       	rjmp	.-12     	; 0x198e <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    199a:	69 81       	ldd	r22, Y+1	; 0x01
    199c:	c8 01       	movw	r24, r16
    199e:	0e 94 41 01 	call	0x282	; 0x282 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    19a2:	a0 e0       	ldi	r26, 0x00	; 0
    19a4:	b0 e0       	ldi	r27, 0x00	; 0
    19a6:	88 0e       	add	r8, r24
    19a8:	99 1e       	adc	r9, r25
    19aa:	aa 1e       	adc	r10, r26
    19ac:	bb 1e       	adc	r11, r27
    19ae:	48 16       	cp	r4, r24
    19b0:	59 06       	cpc	r5, r25
    19b2:	6a 06       	cpc	r6, r26
    19b4:	7b 06       	cpc	r7, r27
    19b6:	10 f4       	brcc	.+4      	; 0x19bc <CO_collectTemp+0x136>
    19b8:	2c 01       	movw	r4, r24
    19ba:	3d 01       	movw	r6, r26
    19bc:	2a 81       	ldd	r18, Y+2	; 0x02
    19be:	3b 81       	ldd	r19, Y+3	; 0x03
    19c0:	4c 81       	ldd	r20, Y+4	; 0x04
    19c2:	5d 81       	ldd	r21, Y+5	; 0x05
    19c4:	82 17       	cp	r24, r18
    19c6:	93 07       	cpc	r25, r19
    19c8:	a4 07       	cpc	r26, r20
    19ca:	b5 07       	cpc	r27, r21
    19cc:	20 f4       	brcc	.+8      	; 0x19d6 <CO_collectTemp+0x150>
    19ce:	8a 83       	std	Y+2, r24	; 0x02
    19d0:	9b 83       	std	Y+3, r25	; 0x03
    19d2:	ac 83       	std	Y+4, r26	; 0x04
    19d4:	bd 83       	std	Y+5, r27	; 0x05
    19d6:	08 94       	sec
    19d8:	e1 08       	sbc	r14, r1
    19da:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    19dc:	e1 14       	cp	r14, r1
    19de:	f1 04       	cpc	r15, r1
    19e0:	b1 f6       	brne	.-84     	; 0x198e <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    19e2:	e0 e0       	ldi	r30, 0x00	; 0
    19e4:	f2 e0       	ldi	r31, 0x02	; 2
    19e6:	81 81       	ldd	r24, Z+1	; 0x01
    19e8:	87 7f       	andi	r24, 0xF7	; 247
    19ea:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    19ec:	80 81       	ld	r24, Z
    19ee:	82 60       	ori	r24, 0x02	; 2
    19f0:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    19f2:	80 81       	ld	r24, Z
    19f4:	8e 7f       	andi	r24, 0xFE	; 254
    19f6:	80 83       	st	Z, r24

	ADCPower(FALSE);
    19f8:	80 e0       	ldi	r24, 0x00	; 0
    19fa:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>

	average = sum / NUM_SAMPLES;
    19fe:	c5 01       	movw	r24, r10
    1a00:	b4 01       	movw	r22, r8
    1a02:	05 2e       	mov	r0, r21
    1a04:	5a e0       	ldi	r21, 0x0A	; 10
    1a06:	96 95       	lsr	r25
    1a08:	87 95       	ror	r24
    1a0a:	77 95       	ror	r23
    1a0c:	67 95       	ror	r22
    1a0e:	5a 95       	dec	r21
    1a10:	d1 f7       	brne	.-12     	; 0x1a06 <CO_collectTemp+0x180>
    1a12:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1a14:	28 ee       	ldi	r18, 0xE8	; 232
    1a16:	33 e0       	ldi	r19, 0x03	; 3
    1a18:	40 e0       	ldi	r20, 0x00	; 0
    1a1a:	50 e0       	ldi	r21, 0x00	; 0
    1a1c:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    1a20:	0f 2e       	mov	r0, r31
    1a22:	ff ef       	ldi	r31, 0xFF	; 255
    1a24:	8f 2e       	mov	r8, r31
    1a26:	ff e0       	ldi	r31, 0x0F	; 15
    1a28:	9f 2e       	mov	r9, r31
    1a2a:	f0 e0       	ldi	r31, 0x00	; 0
    1a2c:	af 2e       	mov	r10, r31
    1a2e:	f0 e0       	ldi	r31, 0x00	; 0
    1a30:	bf 2e       	mov	r11, r31
    1a32:	f0 2d       	mov	r31, r0
    1a34:	a5 01       	movw	r20, r10
    1a36:	94 01       	movw	r18, r8
    1a38:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    1a3c:	c9 01       	movw	r24, r18
    1a3e:	c2 97       	sbiw	r24, 0x32	; 50
    1a40:	ae 81       	ldd	r26, Y+6	; 0x06
    1a42:	bf 81       	ldd	r27, Y+7	; 0x07
    1a44:	8d 93       	st	X+, r24
    1a46:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1a48:	c3 01       	movw	r24, r6
    1a4a:	b2 01       	movw	r22, r4
    1a4c:	28 ee       	ldi	r18, 0xE8	; 232
    1a4e:	33 e0       	ldi	r19, 0x03	; 3
    1a50:	40 e0       	ldi	r20, 0x00	; 0
    1a52:	50 e0       	ldi	r21, 0x00	; 0
    1a54:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    1a58:	a5 01       	movw	r20, r10
    1a5a:	94 01       	movw	r18, r8
    1a5c:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    1a60:	c9 01       	movw	r24, r18
    1a62:	c2 97       	sbiw	r24, 0x32	; 50
    1a64:	ea 85       	ldd	r30, Y+10	; 0x0a
    1a66:	fb 85       	ldd	r31, Y+11	; 0x0b
    1a68:	80 83       	st	Z, r24
    1a6a:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    1a6c:	6a 81       	ldd	r22, Y+2	; 0x02
    1a6e:	7b 81       	ldd	r23, Y+3	; 0x03
    1a70:	8c 81       	ldd	r24, Y+4	; 0x04
    1a72:	9d 81       	ldd	r25, Y+5	; 0x05
    1a74:	28 ee       	ldi	r18, 0xE8	; 232
    1a76:	33 e0       	ldi	r19, 0x03	; 3
    1a78:	40 e0       	ldi	r20, 0x00	; 0
    1a7a:	50 e0       	ldi	r21, 0x00	; 0
    1a7c:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    1a80:	a5 01       	movw	r20, r10
    1a82:	94 01       	movw	r18, r8
    1a84:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    1a88:	22 53       	subi	r18, 0x32	; 50
    1a8a:	30 40       	sbci	r19, 0x00	; 0
    1a8c:	a8 85       	ldd	r26, Y+8	; 0x08
    1a8e:	b9 85       	ldd	r27, Y+9	; 0x09
    1a90:	2d 93       	st	X+, r18
    1a92:	3c 93       	st	X, r19
    1a94:	11 97       	sbiw	r26, 0x01	; 1
}
    1a96:	2b 96       	adiw	r28, 0x0b	; 11
    1a98:	cd bf       	out	0x3d, r28	; 61
    1a9a:	de bf       	out	0x3e, r29	; 62
    1a9c:	df 91       	pop	r29
    1a9e:	cf 91       	pop	r28
    1aa0:	1f 91       	pop	r17
    1aa2:	0f 91       	pop	r16
    1aa4:	ff 90       	pop	r15
    1aa6:	ef 90       	pop	r14
    1aa8:	bf 90       	pop	r11
    1aaa:	af 90       	pop	r10
    1aac:	9f 90       	pop	r9
    1aae:	8f 90       	pop	r8
    1ab0:	7f 90       	pop	r7
    1ab2:	6f 90       	pop	r6
    1ab4:	5f 90       	pop	r5
    1ab6:	4f 90       	pop	r4
    1ab8:	08 95       	ret

00001aba <CO_collectBatt>:


void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    1aba:	4f 92       	push	r4
    1abc:	5f 92       	push	r5
    1abe:	6f 92       	push	r6
    1ac0:	7f 92       	push	r7
    1ac2:	8f 92       	push	r8
    1ac4:	9f 92       	push	r9
    1ac6:	af 92       	push	r10
    1ac8:	bf 92       	push	r11
    1aca:	ef 92       	push	r14
    1acc:	ff 92       	push	r15
    1ace:	0f 93       	push	r16
    1ad0:	1f 93       	push	r17
    1ad2:	cf 93       	push	r28
    1ad4:	df 93       	push	r29
    1ad6:	cd b7       	in	r28, 0x3d	; 61
    1ad8:	de b7       	in	r29, 0x3e	; 62
    1ada:	2b 97       	sbiw	r28, 0x0b	; 11
    1adc:	cd bf       	out	0x3d, r28	; 61
    1ade:	de bf       	out	0x3e, r29	; 62
    1ae0:	8e 83       	std	Y+6, r24	; 0x06
    1ae2:	9f 83       	std	Y+7, r25	; 0x07
    1ae4:	68 87       	std	Y+8, r22	; 0x08
    1ae6:	79 87       	std	Y+9, r23	; 0x09
    1ae8:	4a 87       	std	Y+10, r20	; 0x0a
    1aea:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    1af2:	84 e0       	ldi	r24, 0x04	; 4
    1af4:	60 e0       	ldi	r22, 0x00	; 0
    1af6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    1afa:	84 e0       	ldi	r24, 0x04	; 4
    1afc:	60 e0       	ldi	r22, 0x00	; 0
    1afe:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
    1b02:	2f ef       	ldi	r18, 0xFF	; 255
    1b04:	33 ec       	ldi	r19, 0xC3	; 195
    1b06:	49 e0       	ldi	r20, 0x09	; 9
    1b08:	21 50       	subi	r18, 0x01	; 1
    1b0a:	30 40       	sbci	r19, 0x00	; 0
    1b0c:	40 40       	sbci	r20, 0x00	; 0
    1b0e:	e1 f7       	brne	.-8      	; 0x1b08 <CO_collectBatt+0x4e>
    1b10:	00 c0       	rjmp	.+0      	; 0x1b12 <CO_collectBatt+0x58>
    1b12:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    1b14:	80 e4       	ldi	r24, 0x40	; 64
    1b16:	92 e0       	ldi	r25, 0x02	; 2
    1b18:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    1b1c:	00 e4       	ldi	r16, 0x40	; 64
    1b1e:	12 e0       	ldi	r17, 0x02	; 2
    1b20:	d8 01       	movw	r26, r16
    1b22:	11 96       	adiw	r26, 0x01	; 1
    1b24:	8c 91       	ld	r24, X
    1b26:	11 97       	sbiw	r26, 0x01	; 1
    1b28:	89 7e       	andi	r24, 0xE9	; 233
    1b2a:	11 96       	adiw	r26, 0x01	; 1
    1b2c:	8c 93       	st	X, r24
    1b2e:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    1b30:	14 96       	adiw	r26, 0x04	; 4
    1b32:	8c 91       	ld	r24, X
    1b34:	14 97       	sbiw	r26, 0x04	; 4
    1b36:	88 7f       	andi	r24, 0xF8	; 248
    1b38:	83 60       	ori	r24, 0x03	; 3
    1b3a:	14 96       	adiw	r26, 0x04	; 4
    1b3c:	8c 93       	st	X, r24
    1b3e:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    1b40:	12 96       	adiw	r26, 0x02	; 2
    1b42:	8c 91       	ld	r24, X
    1b44:	12 97       	sbiw	r26, 0x02	; 2
    1b46:	8f 7c       	andi	r24, 0xCF	; 207
    1b48:	12 96       	adiw	r26, 0x02	; 2
    1b4a:	8c 93       	st	X, r24
    1b4c:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    1b4e:	0f 2e       	mov	r0, r31
    1b50:	f0 e6       	ldi	r31, 0x60	; 96
    1b52:	ef 2e       	mov	r14, r31
    1b54:	f2 e0       	ldi	r31, 0x02	; 2
    1b56:	ff 2e       	mov	r15, r31
    1b58:	f0 2d       	mov	r31, r0
    1b5a:	f7 01       	movw	r30, r14
    1b5c:	80 81       	ld	r24, Z
    1b5e:	80 7e       	andi	r24, 0xE0	; 224
    1b60:	81 60       	ori	r24, 0x01	; 1
    1b62:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1b64:	89 e0       	ldi	r24, 0x09	; 9
    1b66:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    1b68:	8c 91       	ld	r24, X
    1b6a:	81 60       	ori	r24, 0x01	; 1
    1b6c:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    1b6e:	80 e4       	ldi	r24, 0x40	; 64
    1b70:	92 e0       	ldi	r25, 0x02	; 2
    1b72:	0e 94 65 01 	call	0x2ca	; 0x2ca <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    1b76:	80 e4       	ldi	r24, 0x40	; 64
    1b78:	92 e0       	ldi	r25, 0x02	; 2
    1b7a:	60 e6       	ldi	r22, 0x60	; 96
    1b7c:	72 e0       	ldi	r23, 0x02	; 2
    1b7e:	40 e0       	ldi	r20, 0x00	; 0
    1b80:	0e 94 6f 01 	call	0x2de	; 0x2de <ADC_Offset_Get_Unsigned>
    1b84:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    1b86:	d8 01       	movw	r26, r16
    1b88:	8c 91       	ld	r24, X
    1b8a:	8e 7f       	andi	r24, 0xFE	; 254
    1b8c:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1b8e:	f7 01       	movw	r30, r14
    1b90:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    1b92:	13 96       	adiw	r26, 0x03	; 3
    1b94:	8c 91       	ld	r24, X
    1b96:	13 97       	sbiw	r26, 0x03	; 3
    1b98:	8f 73       	andi	r24, 0x3F	; 63
    1b9a:	13 96       	adiw	r26, 0x03	; 3
    1b9c:	8c 93       	st	X, r24
    1b9e:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    1ba0:	8c 91       	ld	r24, X
    1ba2:	81 60       	ori	r24, 0x01	; 1
    1ba4:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    1ba6:	80 e4       	ldi	r24, 0x40	; 64
    1ba8:	92 e0       	ldi	r25, 0x02	; 2
    1baa:	0e 94 65 01 	call	0x2ca	; 0x2ca <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    1bae:	d8 01       	movw	r26, r16
    1bb0:	11 96       	adiw	r26, 0x01	; 1
    1bb2:	8c 91       	ld	r24, X
    1bb4:	11 97       	sbiw	r26, 0x01	; 1
    1bb6:	88 60       	ori	r24, 0x08	; 8
    1bb8:	11 96       	adiw	r26, 0x01	; 1
    1bba:	8c 93       	st	X, r24
    1bbc:	ee 24       	eor	r14, r14
    1bbe:	ff 24       	eor	r15, r15
    1bc0:	68 94       	set
    1bc2:	f2 f8       	bld	r15, 2
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    1bc4:	44 24       	eor	r4, r4
    1bc6:	55 24       	eor	r5, r5
    1bc8:	32 01       	movw	r6, r4

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    1bca:	20 e0       	ldi	r18, 0x00	; 0
    1bcc:	30 e1       	ldi	r19, 0x10	; 16
    1bce:	40 e0       	ldi	r20, 0x00	; 0
    1bd0:	50 e0       	ldi	r21, 0x00	; 0
    1bd2:	2a 83       	std	Y+2, r18	; 0x02
    1bd4:	3b 83       	std	Y+3, r19	; 0x03
    1bd6:	4c 83       	std	Y+4, r20	; 0x04
    1bd8:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}


void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
    1bda:	88 24       	eor	r8, r8
    1bdc:	99 24       	eor	r9, r9
    1bde:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    1be0:	00 e6       	ldi	r16, 0x60	; 96
    1be2:	12 e0       	ldi	r17, 0x02	; 2
    1be4:	d8 01       	movw	r26, r16
    1be6:	13 96       	adiw	r26, 0x03	; 3
    1be8:	8c 91       	ld	r24, X
    1bea:	13 97       	sbiw	r26, 0x03	; 3
    1bec:	80 ff       	sbrs	r24, 0
    1bee:	fa cf       	rjmp	.-12     	; 0x1be4 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    1bf0:	69 81       	ldd	r22, Y+1	; 0x01
    1bf2:	c8 01       	movw	r24, r16
    1bf4:	0e 94 41 01 	call	0x282	; 0x282 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    1bf8:	a0 e0       	ldi	r26, 0x00	; 0
    1bfa:	b0 e0       	ldi	r27, 0x00	; 0
    1bfc:	88 0e       	add	r8, r24
    1bfe:	99 1e       	adc	r9, r25
    1c00:	aa 1e       	adc	r10, r26
    1c02:	bb 1e       	adc	r11, r27
    1c04:	48 16       	cp	r4, r24
    1c06:	59 06       	cpc	r5, r25
    1c08:	6a 06       	cpc	r6, r26
    1c0a:	7b 06       	cpc	r7, r27
    1c0c:	10 f4       	brcc	.+4      	; 0x1c12 <CO_collectBatt+0x158>
    1c0e:	2c 01       	movw	r4, r24
    1c10:	3d 01       	movw	r6, r26
    1c12:	2a 81       	ldd	r18, Y+2	; 0x02
    1c14:	3b 81       	ldd	r19, Y+3	; 0x03
    1c16:	4c 81       	ldd	r20, Y+4	; 0x04
    1c18:	5d 81       	ldd	r21, Y+5	; 0x05
    1c1a:	82 17       	cp	r24, r18
    1c1c:	93 07       	cpc	r25, r19
    1c1e:	a4 07       	cpc	r26, r20
    1c20:	b5 07       	cpc	r27, r21
    1c22:	20 f4       	brcc	.+8      	; 0x1c2c <CO_collectBatt+0x172>
    1c24:	8a 83       	std	Y+2, r24	; 0x02
    1c26:	9b 83       	std	Y+3, r25	; 0x03
    1c28:	ac 83       	std	Y+4, r26	; 0x04
    1c2a:	bd 83       	std	Y+5, r27	; 0x05
    1c2c:	08 94       	sec
    1c2e:	e1 08       	sbc	r14, r1
    1c30:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1c32:	e1 14       	cp	r14, r1
    1c34:	f1 04       	cpc	r15, r1
    1c36:	b1 f6       	brne	.-84     	; 0x1be4 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    1c38:	e0 e4       	ldi	r30, 0x40	; 64
    1c3a:	f2 e0       	ldi	r31, 0x02	; 2
    1c3c:	81 81       	ldd	r24, Z+1	; 0x01
    1c3e:	87 7f       	andi	r24, 0xF7	; 247
    1c40:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    1c42:	80 81       	ld	r24, Z
    1c44:	8e 7f       	andi	r24, 0xFE	; 254
    1c46:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    1c48:	84 e0       	ldi	r24, 0x04	; 4
    1c4a:	60 e0       	ldi	r22, 0x00	; 0
    1c4c:	0e 94 11 0b 	call	0x1622	; 0x1622 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    1c50:	80 e0       	ldi	r24, 0x00	; 0
    1c52:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    1c56:	c5 01       	movw	r24, r10
    1c58:	b4 01       	movw	r22, r8
    1c5a:	05 2e       	mov	r0, r21
    1c5c:	5a e0       	ldi	r21, 0x0A	; 10
    1c5e:	96 95       	lsr	r25
    1c60:	87 95       	ror	r24
    1c62:	77 95       	ror	r23
    1c64:	67 95       	ror	r22
    1c66:	5a 95       	dec	r21
    1c68:	d1 f7       	brne	.-12     	; 0x1c5e <CO_collectBatt+0x1a4>
    1c6a:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1c6c:	28 ee       	ldi	r18, 0xE8	; 232
    1c6e:	33 e0       	ldi	r19, 0x03	; 3
    1c70:	40 e0       	ldi	r20, 0x00	; 0
    1c72:	50 e0       	ldi	r21, 0x00	; 0
    1c74:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    1c78:	0f 2e       	mov	r0, r31
    1c7a:	ff ef       	ldi	r31, 0xFF	; 255
    1c7c:	8f 2e       	mov	r8, r31
    1c7e:	ff e0       	ldi	r31, 0x0F	; 15
    1c80:	9f 2e       	mov	r9, r31
    1c82:	f0 e0       	ldi	r31, 0x00	; 0
    1c84:	af 2e       	mov	r10, r31
    1c86:	f0 e0       	ldi	r31, 0x00	; 0
    1c88:	bf 2e       	mov	r11, r31
    1c8a:	f0 2d       	mov	r31, r0
    1c8c:	a5 01       	movw	r20, r10
    1c8e:	94 01       	movw	r18, r8
    1c90:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    1c94:	c9 01       	movw	r24, r18
    1c96:	c2 97       	sbiw	r24, 0x32	; 50
    1c98:	ae 81       	ldd	r26, Y+6	; 0x06
    1c9a:	bf 81       	ldd	r27, Y+7	; 0x07
    1c9c:	8d 93       	st	X+, r24
    1c9e:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1ca0:	c3 01       	movw	r24, r6
    1ca2:	b2 01       	movw	r22, r4
    1ca4:	28 ee       	ldi	r18, 0xE8	; 232
    1ca6:	33 e0       	ldi	r19, 0x03	; 3
    1ca8:	40 e0       	ldi	r20, 0x00	; 0
    1caa:	50 e0       	ldi	r21, 0x00	; 0
    1cac:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    1cb0:	a5 01       	movw	r20, r10
    1cb2:	94 01       	movw	r18, r8
    1cb4:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    1cb8:	c9 01       	movw	r24, r18
    1cba:	c2 97       	sbiw	r24, 0x32	; 50
    1cbc:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cbe:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cc0:	80 83       	st	Z, r24
    1cc2:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    1cc4:	6a 81       	ldd	r22, Y+2	; 0x02
    1cc6:	7b 81       	ldd	r23, Y+3	; 0x03
    1cc8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cca:	9d 81       	ldd	r25, Y+5	; 0x05
    1ccc:	28 ee       	ldi	r18, 0xE8	; 232
    1cce:	33 e0       	ldi	r19, 0x03	; 3
    1cd0:	40 e0       	ldi	r20, 0x00	; 0
    1cd2:	50 e0       	ldi	r21, 0x00	; 0
    1cd4:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    1cd8:	a5 01       	movw	r20, r10
    1cda:	94 01       	movw	r18, r8
    1cdc:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    1ce0:	22 53       	subi	r18, 0x32	; 50
    1ce2:	30 40       	sbci	r19, 0x00	; 0
    1ce4:	a8 85       	ldd	r26, Y+8	; 0x08
    1ce6:	b9 85       	ldd	r27, Y+9	; 0x09
    1ce8:	2d 93       	st	X+, r18
    1cea:	3c 93       	st	X, r19
    1cec:	11 97       	sbiw	r26, 0x01	; 1
}
    1cee:	2b 96       	adiw	r28, 0x0b	; 11
    1cf0:	cd bf       	out	0x3d, r28	; 61
    1cf2:	de bf       	out	0x3e, r29	; 62
    1cf4:	df 91       	pop	r29
    1cf6:	cf 91       	pop	r28
    1cf8:	1f 91       	pop	r17
    1cfa:	0f 91       	pop	r16
    1cfc:	ff 90       	pop	r15
    1cfe:	ef 90       	pop	r14
    1d00:	bf 90       	pop	r11
    1d02:	af 90       	pop	r10
    1d04:	9f 90       	pop	r9
    1d06:	8f 90       	pop	r8
    1d08:	7f 90       	pop	r7
    1d0a:	6f 90       	pop	r6
    1d0c:	5f 90       	pop	r5
    1d0e:	4f 90       	pop	r4
    1d10:	08 95       	ret

00001d12 <ADC_Stop_Sampling>:
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
*/
}

void ADC_Stop_Sampling(){
		PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS high
    1d12:	88 e0       	ldi	r24, 0x08	; 8
    1d14:	60 e0       	ldi	r22, 0x00	; 0
    1d16:	0e 94 11 0b 	call	0x1622	; 0x1622 <PortEx_DIRCLR>
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);
    1d1a:	88 e0       	ldi	r24, 0x08	; 8
    1d1c:	60 e0       	ldi	r22, 0x00	; 0
    1d1e:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
	
}
    1d22:	08 95       	ret

00001d24 <__vector_104>:
		TotalSampleCount++;
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
	}
}

ISR(PORTF_INT0_vect) {
    1d24:	1f 92       	push	r1
    1d26:	0f 92       	push	r0
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	0f 92       	push	r0
    1d2c:	0b b6       	in	r0, 0x3b	; 59
    1d2e:	0f 92       	push	r0
    1d30:	11 24       	eor	r1, r1
    1d32:	2f 93       	push	r18
    1d34:	3f 93       	push	r19
    1d36:	4f 93       	push	r20
    1d38:	5f 93       	push	r21
    1d3a:	6f 93       	push	r22
    1d3c:	7f 93       	push	r23
    1d3e:	8f 93       	push	r24
    1d40:	9f 93       	push	r25
    1d42:	af 93       	push	r26
    1d44:	bf 93       	push	r27
    1d46:	ef 93       	push	r30
    1d48:	ff 93       	push	r31
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1d4a:	80 91 64 40 	lds	r24, 0x4064
    1d4e:	88 23       	and	r24, r24
    1d50:	34 f0       	brlt	.+12     	; 0x1d5e <__vector_104+0x3a>
		discardCount++;
    1d52:	80 91 64 40 	lds	r24, 0x4064
    1d56:	8f 5f       	subi	r24, 0xFF	; 255
    1d58:	80 93 64 40 	sts	0x4064, r24
    1d5c:	6e c0       	rjmp	.+220    	; 0x1e3a <__vector_104+0x116>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1d64:	82 e0       	ldi	r24, 0x02	; 2
    1d66:	e0 ea       	ldi	r30, 0xA0	; 160
    1d68:	f6 e0       	ldi	r31, 0x06	; 6
    1d6a:	86 83       	std	Z+6, r24	; 0x06
    1d6c:	80 e0       	ldi	r24, 0x00	; 0
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1d70:	e0 ec       	ldi	r30, 0xC0	; 192
    1d72:	f8 e0       	ldi	r31, 0x08	; 8
    1d74:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1d76:	27 e6       	ldi	r18, 0x67	; 103
    1d78:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1d7a:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1d7c:	42 81       	ldd	r20, Z+2	; 0x02
    1d7e:	44 23       	and	r20, r20
    1d80:	ec f7       	brge	.-6      	; 0x1d7c <__vector_104+0x58>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1d82:	43 81       	ldd	r20, Z+3	; 0x03
    1d84:	d9 01       	movw	r26, r18
    1d86:	a8 0f       	add	r26, r24
    1d88:	b9 1f       	adc	r27, r25
    1d8a:	4c 93       	st	X, r20
    1d8c:	01 96       	adiw	r24, 0x01	; 1
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1d8e:	83 30       	cpi	r24, 0x03	; 3
    1d90:	91 05       	cpc	r25, r1
    1d92:	99 f7       	brne	.-26     	; 0x1d7a <__vector_104+0x56>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1d94:	82 e0       	ldi	r24, 0x02	; 2
    1d96:	e0 ea       	ldi	r30, 0xA0	; 160
    1d98:	f6 e0       	ldi	r31, 0x06	; 6
    1d9a:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1d9c:	80 e0       	ldi	r24, 0x00	; 0
    1d9e:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    1da2:	80 91 67 50 	lds	r24, 0x5067
    1da6:	88 23       	and	r24, r24
    1da8:	6c f4       	brge	.+26     	; 0x1dc4 <__vector_104+0xa0>
    1daa:	e0 91 49 40 	lds	r30, 0x4049
    1dae:	f0 91 4a 40 	lds	r31, 0x404A
    1db2:	ee 0f       	add	r30, r30
    1db4:	ff 1f       	adc	r31, r31
    1db6:	ee 0f       	add	r30, r30
    1db8:	ff 1f       	adc	r31, r31
    1dba:	e8 59       	subi	r30, 0x98	; 152
    1dbc:	ff 4b       	sbci	r31, 0xBF	; 191
    1dbe:	8f ef       	ldi	r24, 0xFF	; 255
    1dc0:	80 83       	st	Z, r24
    1dc2:	0b c0       	rjmp	.+22     	; 0x1dda <__vector_104+0xb6>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    1dc4:	e0 91 49 40 	lds	r30, 0x4049
    1dc8:	f0 91 4a 40 	lds	r31, 0x404A
    1dcc:	ee 0f       	add	r30, r30
    1dce:	ff 1f       	adc	r31, r31
    1dd0:	ee 0f       	add	r30, r30
    1dd2:	ff 1f       	adc	r31, r31
    1dd4:	e8 59       	subi	r30, 0x98	; 152
    1dd6:	ff 4b       	sbci	r31, 0xBF	; 191
    1dd8:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    1dda:	e0 91 49 40 	lds	r30, 0x4049
    1dde:	f0 91 4a 40 	lds	r31, 0x404A
    1de2:	80 91 67 50 	lds	r24, 0x5067
    1de6:	ee 0f       	add	r30, r30
    1de8:	ff 1f       	adc	r31, r31
    1dea:	ee 0f       	add	r30, r30
    1dec:	ff 1f       	adc	r31, r31
    1dee:	e9 59       	subi	r30, 0x99	; 153
    1df0:	ff 4b       	sbci	r31, 0xBF	; 191
    1df2:	80 83       	st	Z, r24
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    1df4:	e0 91 49 40 	lds	r30, 0x4049
    1df8:	f0 91 4a 40 	lds	r31, 0x404A
    1dfc:	80 91 68 50 	lds	r24, 0x5068
    1e00:	ee 0f       	add	r30, r30
    1e02:	ff 1f       	adc	r31, r31
    1e04:	ee 0f       	add	r30, r30
    1e06:	ff 1f       	adc	r31, r31
    1e08:	ea 59       	subi	r30, 0x9A	; 154
    1e0a:	ff 4b       	sbci	r31, 0xBF	; 191
    1e0c:	80 83       	st	Z, r24
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    1e0e:	e0 91 49 40 	lds	r30, 0x4049
    1e12:	f0 91 4a 40 	lds	r31, 0x404A
    1e16:	ee 0f       	add	r30, r30
    1e18:	ff 1f       	adc	r31, r31
    1e1a:	ee 0f       	add	r30, r30
    1e1c:	ff 1f       	adc	r31, r31
    1e1e:	eb 59       	subi	r30, 0x9B	; 155
    1e20:	ff 4b       	sbci	r31, 0xBF	; 191
    1e22:	80 91 69 50 	lds	r24, 0x5069
    1e26:	80 83       	st	Z, r24

		sampleCount++;
    1e28:	80 91 49 40 	lds	r24, 0x4049
    1e2c:	90 91 4a 40 	lds	r25, 0x404A
    1e30:	01 96       	adiw	r24, 0x01	; 1
    1e32:	80 93 49 40 	sts	0x4049, r24
    1e36:	90 93 4a 40 	sts	0x404A, r25
	}
}
    1e3a:	ff 91       	pop	r31
    1e3c:	ef 91       	pop	r30
    1e3e:	bf 91       	pop	r27
    1e40:	af 91       	pop	r26
    1e42:	9f 91       	pop	r25
    1e44:	8f 91       	pop	r24
    1e46:	7f 91       	pop	r23
    1e48:	6f 91       	pop	r22
    1e4a:	5f 91       	pop	r21
    1e4c:	4f 91       	pop	r20
    1e4e:	3f 91       	pop	r19
    1e50:	2f 91       	pop	r18
    1e52:	0f 90       	pop	r0
    1e54:	0b be       	out	0x3b, r0	; 59
    1e56:	0f 90       	pop	r0
    1e58:	0f be       	out	0x3f, r0	; 63
    1e5a:	0f 90       	pop	r0
    1e5c:	1f 90       	pop	r1
    1e5e:	18 95       	reti

00001e60 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1e60:	88 23       	and	r24, r24
    1e62:	49 f0       	breq	.+18     	; 0x1e76 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1e64:	80 e2       	ldi	r24, 0x20	; 32
    1e66:	60 e0       	ldi	r22, 0x00	; 0
    1e68:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1e6c:	80 e2       	ldi	r24, 0x20	; 32
    1e6e:	60 e0       	ldi	r22, 0x00	; 0
    1e70:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
    1e74:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1e76:	80 e2       	ldi	r24, 0x20	; 32
    1e78:	60 e0       	ldi	r22, 0x00	; 0
    1e7a:	0e 94 11 0b 	call	0x1622	; 0x1622 <PortEx_DIRCLR>
    1e7e:	08 95       	ret

00001e80 <CO_collectADC_cont>:
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);

}

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1e80:	0f 93       	push	r16
    1e82:	1f 93       	push	r17
    1e84:	cf 93       	push	r28
    1e86:	df 93       	push	r29
    1e88:	d8 2f       	mov	r29, r24
    1e8a:	16 2f       	mov	r17, r22
    1e8c:	04 2f       	mov	r16, r20
    1e8e:	c2 2f       	mov	r28, r18
int64_t min = ADC_MAX;
int64_t max = -ADC_MAX;
uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1e90:	81 e0       	ldi	r24, 0x01	; 1
    1e92:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>

// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1e96:	8d 2f       	mov	r24, r29
    1e98:	60 2f       	mov	r22, r16
    1e9a:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
set_filter(filterConfig);
    1e9e:	81 2f       	mov	r24, r17
    1ea0:	0e 94 c9 09 	call	0x1392	; 0x1392 <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1ea4:	8d 2f       	mov	r24, r29
    1ea6:	85 50       	subi	r24, 0x05	; 5
    1ea8:	83 30       	cpi	r24, 0x03	; 3
    1eaa:	18 f4       	brcc	.+6      	; 0x1eb2 <CO_collectADC_cont+0x32>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1eb2:	81 e0       	ldi	r24, 0x01	; 1
    1eb4:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
setADCInput(channel);
    1eb8:	8d 2f       	mov	r24, r29
    1eba:	0e 94 6e 09 	call	0x12dc	; 0x12dc <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1ebe:	84 e0       	ldi	r24, 0x04	; 4
    1ec0:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1ec4:	84 e5       	ldi	r24, 0x54	; 84
    1ec6:	80 93 c0 08 	sts	0x08C0, r24

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1eca:	e0 ea       	ldi	r30, 0xA0	; 160
    1ecc:	f6 e0       	ldi	r31, 0x06	; 6
    1ece:	81 e0       	ldi	r24, 0x01	; 1
    1ed0:	82 83       	std	Z+2, r24	; 0x02
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
    1ed2:	9a e1       	ldi	r25, 0x1A	; 26
    1ed4:	90 8b       	std	Z+16, r25	; 0x10
PORTF.INT1MASK = PIN0_bm;
    1ed6:	83 87       	std	Z+11, r24	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_LO_gc;
    1ed8:	84 e0       	ldi	r24, 0x04	; 4
    1eda:	81 87       	std	Z+9, r24	; 0x09

// Configure clock for AD7767 MCLK for desired sample frequency
//f_samples = f_MCLK / 16
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    1edc:	80 e2       	ldi	r24, 0x20	; 32
    1ede:	e0 e8       	ldi	r30, 0x80	; 128
    1ee0:	f6 e0       	ldi	r31, 0x06	; 6
    1ee2:	81 83       	std	Z+1, r24	; 0x01
// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1ee4:	e0 e4       	ldi	r30, 0x40	; 64
    1ee6:	fa e0       	ldi	r31, 0x0A	; 10
    1ee8:	83 e2       	ldi	r24, 0x23	; 35
    1eea:	81 83       	std	Z+1, r24	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1eec:	25 e1       	ldi	r18, 0x15	; 21
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	2c 1b       	sub	r18, r28
    1ef2:	31 09       	sbc	r19, r1
    1ef4:	81 e0       	ldi	r24, 0x01	; 1
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	02 c0       	rjmp	.+4      	; 0x1efe <CO_collectADC_cont+0x7e>
    1efa:	88 0f       	add	r24, r24
    1efc:	99 1f       	adc	r25, r25
    1efe:	2a 95       	dec	r18
    1f00:	e2 f7       	brpl	.-8      	; 0x1efa <CO_collectADC_cont+0x7a>
    1f02:	01 97       	sbiw	r24, 0x01	; 1
TCE1.PER = period;
    1f04:	86 a3       	lds	r24, 0x56
    1f06:	97 a3       	lds	r25, 0x57
TCE1.CCBBUF = period / 2;
    1f08:	96 95       	lsr	r25
    1f0a:	87 95       	ror	r24
    1f0c:	82 af       	sts	0x72, r24
    1f0e:	93 af       	sts	0x73, r25
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1f10:	80 81       	ld	r24, Z
    1f12:	80 7f       	andi	r24, 0xF0	; 240
    1f14:	81 60       	ori	r24, 0x01	; 1
    1f16:	80 83       	st	Z, r24

// Enable interrupts.
PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1f18:	e0 ea       	ldi	r30, 0xA0	; 160
    1f1a:	f0 e0       	ldi	r31, 0x00	; 0
    1f1c:	82 81       	ldd	r24, Z+2	; 0x02
    1f1e:	81 60       	ori	r24, 0x01	; 1
    1f20:	82 83       	std	Z+2, r24	; 0x02
sei();
    1f22:	78 94       	sei

sampleCount = 0;
    1f24:	10 92 49 40 	sts	0x4049, r1
    1f28:	10 92 4a 40 	sts	0x404A, r1
TotalSampleCount = 0;
    1f2c:	10 92 58 40 	sts	0x4058, r1
    1f30:	10 92 59 40 	sts	0x4059, r1
discardCount = 0;
    1f34:	10 92 64 40 	sts	0x4064, r1
	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
*/
}
    1f38:	df 91       	pop	r29
    1f3a:	cf 91       	pop	r28
    1f3c:	1f 91       	pop	r17
    1f3e:	0f 91       	pop	r16
    1f40:	08 95       	ret

00001f42 <CO_collectADC>:
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV,
		int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {
    1f42:	2f 92       	push	r2
    1f44:	3f 92       	push	r3
    1f46:	4f 92       	push	r4
    1f48:	5f 92       	push	r5
    1f4a:	6f 92       	push	r6
    1f4c:	7f 92       	push	r7
    1f4e:	8f 92       	push	r8
    1f50:	9f 92       	push	r9
    1f52:	af 92       	push	r10
    1f54:	bf 92       	push	r11
    1f56:	cf 92       	push	r12
    1f58:	df 92       	push	r13
    1f5a:	ef 92       	push	r14
    1f5c:	ff 92       	push	r15
    1f5e:	0f 93       	push	r16
    1f60:	1f 93       	push	r17
    1f62:	cf 93       	push	r28
    1f64:	df 93       	push	r29
    1f66:	cd b7       	in	r28, 0x3d	; 61
    1f68:	de b7       	in	r29, 0x3e	; 62
    1f6a:	62 97       	sbiw	r28, 0x12	; 18
    1f6c:	cd bf       	out	0x3d, r28	; 61
    1f6e:	de bf       	out	0x3e, r29	; 62
    1f70:	f8 2e       	mov	r15, r24
    1f72:	d6 2e       	mov	r13, r22
    1f74:	4b 87       	std	Y+11, r20	; 0x0b
    1f76:	5c 87       	std	Y+12, r21	; 0x0c
    1f78:	2d 87       	std	Y+13, r18	; 0x0d
    1f7a:	3e 87       	std	Y+14, r19	; 0x0e
    1f7c:	0f 87       	std	Y+15, r16	; 0x0f
    1f7e:	18 8b       	std	Y+16, r17	; 0x10
	int64_t min = ADC_MAX;
	int64_t max = -ADC_MAX;
	uint16_t period;
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1f80:	81 e0       	ldi	r24, 0x01	; 1
    1f82:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    1f86:	8f 2d       	mov	r24, r15
    1f88:	6e 2d       	mov	r22, r14
    1f8a:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_filter(filterConfig);
    1f8e:	8d 2d       	mov	r24, r13
    1f90:	0e 94 c9 09 	call	0x1392	; 0x1392 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    1f94:	8f 2d       	mov	r24, r15
    1f96:	85 50       	subi	r24, 0x05	; 5
    1f98:	83 30       	cpi	r24, 0x03	; 3
    1f9a:	18 f4       	brcc	.+6      	; 0x1fa2 <CO_collectADC+0x60>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1f9c:	81 e0       	ldi	r24, 0x01	; 1
    1f9e:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
	setADCInput(channel);
    1fa8:	8f 2d       	mov	r24, r15
    1faa:	0e 94 6e 09 	call	0x12dc	; 0x12dc <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    1fae:	84 e0       	ldi	r24, 0x04	; 4
    1fb0:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1fb4:	84 e5       	ldi	r24, 0x54	; 84
    1fb6:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    1fba:	e0 ea       	ldi	r30, 0xA0	; 160
    1fbc:	f6 e0       	ldi	r31, 0x06	; 6
    1fbe:	81 e0       	ldi	r24, 0x01	; 1
    1fc0:	82 83       	std	Z+2, r24	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1fc2:	92 e0       	ldi	r25, 0x02	; 2
    1fc4:	90 8b       	std	Z+16, r25	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    1fc6:	82 87       	std	Z+10, r24	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    1fc8:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    1fca:	80 e2       	ldi	r24, 0x20	; 32
    1fcc:	e0 e8       	ldi	r30, 0x80	; 128
    1fce:	f6 e0       	ldi	r31, 0x06	; 6
    1fd0:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1fd2:	e0 e4       	ldi	r30, 0x40	; 64
    1fd4:	fa e0       	ldi	r31, 0x0A	; 10
    1fd6:	83 e2       	ldi	r24, 0x23	; 35
    1fd8:	81 83       	std	Z+1, r24	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    1fda:	85 e1       	ldi	r24, 0x15	; 21
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	9c 01       	movw	r18, r24
    1fe0:	2c 19       	sub	r18, r12
    1fe2:	31 09       	sbc	r19, r1
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
    1fe8:	02 c0       	rjmp	.+4      	; 0x1fee <CO_collectADC+0xac>
    1fea:	88 0f       	add	r24, r24
    1fec:	99 1f       	adc	r25, r25
    1fee:	2a 95       	dec	r18
    1ff0:	e2 f7       	brpl	.-8      	; 0x1fea <CO_collectADC+0xa8>
    1ff2:	01 97       	sbiw	r24, 0x01	; 1
	TCE1.PER = period;
    1ff4:	86 a3       	lds	r24, 0x56
    1ff6:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = period / 2;
    1ff8:	96 95       	lsr	r25
    1ffa:	87 95       	ror	r24
    1ffc:	82 af       	sts	0x72, r24
    1ffe:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2000:	80 81       	ld	r24, Z
    2002:	80 7f       	andi	r24, 0xF0	; 240
    2004:	81 60       	ori	r24, 0x01	; 1
    2006:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2008:	e0 ea       	ldi	r30, 0xA0	; 160
    200a:	f0 e0       	ldi	r31, 0x00	; 0
    200c:	82 81       	ldd	r24, Z+2	; 0x02
    200e:	81 60       	ori	r24, 0x01	; 1
    2010:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2012:	78 94       	sei

	sampleCount = 0;
    2014:	10 92 49 40 	sts	0x4049, r1
    2018:	10 92 4a 40 	sts	0x404A, r1
	discardCount = 0;
    201c:	10 92 64 40 	sts	0x4064, r1
	
	// wait for ADC to collect samples
	while(sampleCount < NUM_SAMPLES);
    2020:	80 91 49 40 	lds	r24, 0x4049
    2024:	90 91 4a 40 	lds	r25, 0x404A
    2028:	24 e0       	ldi	r18, 0x04	; 4
    202a:	80 30       	cpi	r24, 0x00	; 0
    202c:	92 07       	cpc	r25, r18
    202e:	c0 f3       	brcs	.-16     	; 0x2020 <CO_collectADC+0xde>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2030:	e0 e4       	ldi	r30, 0x40	; 64
    2032:	fa e0       	ldi	r31, 0x0A	; 10
    2034:	80 81       	ld	r24, Z
    2036:	80 7f       	andi	r24, 0xF0	; 240
    2038:	80 83       	st	Z, r24
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    203a:	e0 ea       	ldi	r30, 0xA0	; 160
    203c:	f0 e0       	ldi	r31, 0x00	; 0
    203e:	82 81       	ldd	r24, Z+2	; 0x02
    2040:	8e 7f       	andi	r24, 0xFE	; 254
    2042:	82 83       	std	Z+2, r24	; 0x02
	cli();
    2044:	f8 94       	cli

	SPIDisable();	
    2046:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	enableADCMUX(FALSE);
    204a:	80 e0       	ldi	r24, 0x00	; 0
    204c:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
	ADCPower(FALSE);
    2050:	80 e0       	ldi	r24, 0x00	; 0
    2052:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    2056:	10 92 49 40 	sts	0x4049, r1
    205a:	10 92 4a 40 	sts	0x404A, r1
    205e:	80 91 49 40 	lds	r24, 0x4049
    2062:	90 91 4a 40 	lds	r25, 0x404A
    2066:	54 e0       	ldi	r21, 0x04	; 4
    2068:	80 30       	cpi	r24, 0x00	; 0
    206a:	95 07       	cpc	r25, r21
    206c:	08 f0       	brcs	.+2      	; 0x2070 <CO_collectADC+0x12e>
    206e:	55 c1       	rjmp	.+682    	; 0x231a <CO_collectADC+0x3d8>
		int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
	int64_t max = -ADC_MAX;
    2070:	61 e0       	ldi	r22, 0x01	; 1
    2072:	6a 87       	std	Y+10, r22	; 0x0a
    2074:	1f 82       	std	Y+7, r1	; 0x07
    2076:	80 e8       	ldi	r24, 0x80	; 128
    2078:	88 87       	std	Y+8, r24	; 0x08
    207a:	9f ef       	ldi	r25, 0xFF	; 255
    207c:	9c 83       	std	Y+4, r25	; 0x04
    207e:	ef ef       	ldi	r30, 0xFF	; 255
    2080:	ea 83       	std	Y+2, r30	; 0x02
    2082:	33 24       	eor	r3, r3
    2084:	3a 94       	dec	r3
    2086:	55 24       	eor	r5, r5
    2088:	5a 94       	dec	r5
    208a:	77 24       	eor	r7, r7
    208c:	7a 94       	dec	r7
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV,
		int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
    208e:	ff ef       	ldi	r31, 0xFF	; 255
    2090:	f9 87       	std	Y+9, r31	; 0x09
    2092:	2f ef       	ldi	r18, 0xFF	; 255
    2094:	2d 83       	std	Y+5, r18	; 0x05
    2096:	5f e7       	ldi	r21, 0x7F	; 127
    2098:	5e 83       	std	Y+6, r21	; 0x06
    209a:	1b 82       	std	Y+3, r1	; 0x03
    209c:	19 82       	std	Y+1, r1	; 0x01
    209e:	22 24       	eor	r2, r2
    20a0:	44 24       	eor	r4, r4
    20a2:	66 24       	eor	r6, r6
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV,
		int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
    20a4:	e0 e0       	ldi	r30, 0x00	; 0
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	40 e0       	ldi	r20, 0x00	; 0
    20aa:	10 e0       	ldi	r17, 0x00	; 0
    20ac:	00 e0       	ldi	r16, 0x00	; 0
    20ae:	88 24       	eor	r8, r8
    20b0:	ff 24       	eor	r15, r15
    20b2:	99 24       	eor	r9, r9
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
		sum += data24Bit[sampleCount];
    20b4:	0f 2e       	mov	r0, r31
    20b6:	f5 e6       	ldi	r31, 0x65	; 101
    20b8:	af 2e       	mov	r10, r31
    20ba:	f0 e4       	ldi	r31, 0x40	; 64
    20bc:	bf 2e       	mov	r11, r31
    20be:	f0 2d       	mov	r31, r0
    20c0:	e9 8b       	std	Y+17, r30	; 0x11
    20c2:	4a 8b       	std	Y+18, r20	; 0x12
    20c4:	e0 91 49 40 	lds	r30, 0x4049
    20c8:	f0 91 4a 40 	lds	r31, 0x404A
    20cc:	ee 0f       	add	r30, r30
    20ce:	ff 1f       	adc	r31, r31
    20d0:	ee 0f       	add	r30, r30
    20d2:	ff 1f       	adc	r31, r31
    20d4:	ea 0d       	add	r30, r10
    20d6:	fb 1d       	adc	r31, r11
    20d8:	40 81       	ld	r20, Z
    20da:	51 81       	ldd	r21, Z+1	; 0x01
    20dc:	62 81       	ldd	r22, Z+2	; 0x02
    20de:	73 81       	ldd	r23, Z+3	; 0x03
    20e0:	c5 2e       	mov	r12, r21
    20e2:	d6 2e       	mov	r13, r22
    20e4:	e7 2e       	mov	r14, r23
    20e6:	db 01       	movw	r26, r22
    20e8:	ca 01       	movw	r24, r20
    20ea:	bb 0f       	add	r27, r27
    20ec:	88 0b       	sbc	r24, r24
    20ee:	98 2f       	mov	r25, r24
    20f0:	dc 01       	movw	r26, r24
    20f2:	f8 2f       	mov	r31, r24
    20f4:	e8 2f       	mov	r30, r24
    20f6:	28 2f       	mov	r18, r24
    20f8:	99 89       	ldd	r25, Y+17	; 0x11
    20fa:	49 0f       	add	r20, r25
    20fc:	91 e0       	ldi	r25, 0x01	; 1
    20fe:	59 89       	ldd	r21, Y+17	; 0x11
    2100:	45 17       	cp	r20, r21
    2102:	08 f0       	brcs	.+2      	; 0x2106 <CO_collectADC+0x1c4>
    2104:	90 e0       	ldi	r25, 0x00	; 0
    2106:	c3 0e       	add	r12, r19
    2108:	51 e0       	ldi	r21, 0x01	; 1
    210a:	c3 16       	cp	r12, r19
    210c:	08 f0       	brcs	.+2      	; 0x2110 <CO_collectADC+0x1ce>
    210e:	50 e0       	ldi	r21, 0x00	; 0
    2110:	39 2f       	mov	r19, r25
    2112:	3c 0d       	add	r19, r12
    2114:	91 e0       	ldi	r25, 0x01	; 1
    2116:	3c 15       	cp	r19, r12
    2118:	08 f0       	brcs	.+2      	; 0x211c <CO_collectADC+0x1da>
    211a:	90 e0       	ldi	r25, 0x00	; 0
    211c:	59 2b       	or	r21, r25
    211e:	6a 89       	ldd	r22, Y+18	; 0x12
    2120:	d6 0e       	add	r13, r22
    2122:	91 e0       	ldi	r25, 0x01	; 1
    2124:	d6 16       	cp	r13, r22
    2126:	08 f0       	brcs	.+2      	; 0x212a <CO_collectADC+0x1e8>
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	75 2f       	mov	r23, r21
    212c:	7d 0d       	add	r23, r13
    212e:	51 e0       	ldi	r21, 0x01	; 1
    2130:	7d 15       	cp	r23, r13
    2132:	08 f0       	brcs	.+2      	; 0x2136 <CO_collectADC+0x1f4>
    2134:	50 e0       	ldi	r21, 0x00	; 0
    2136:	95 2b       	or	r25, r21
    2138:	e1 0e       	add	r14, r17
    213a:	51 e0       	ldi	r21, 0x01	; 1
    213c:	e1 16       	cp	r14, r17
    213e:	08 f0       	brcs	.+2      	; 0x2142 <CO_collectADC+0x200>
    2140:	50 e0       	ldi	r21, 0x00	; 0
    2142:	19 2f       	mov	r17, r25
    2144:	1e 0d       	add	r17, r14
    2146:	91 e0       	ldi	r25, 0x01	; 1
    2148:	1e 15       	cp	r17, r14
    214a:	08 f0       	brcs	.+2      	; 0x214e <CO_collectADC+0x20c>
    214c:	90 e0       	ldi	r25, 0x00	; 0
    214e:	59 2b       	or	r21, r25
    2150:	f0 0f       	add	r31, r16
    2152:	91 e0       	ldi	r25, 0x01	; 1
    2154:	f0 17       	cp	r31, r16
    2156:	08 f0       	brcs	.+2      	; 0x215a <CO_collectADC+0x218>
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	05 2f       	mov	r16, r21
    215c:	0f 0f       	add	r16, r31
    215e:	51 e0       	ldi	r21, 0x01	; 1
    2160:	0f 17       	cp	r16, r31
    2162:	08 f0       	brcs	.+2      	; 0x2166 <CO_collectADC+0x224>
    2164:	50 e0       	ldi	r21, 0x00	; 0
    2166:	95 2b       	or	r25, r21
    2168:	e8 0d       	add	r30, r8
    216a:	61 e0       	ldi	r22, 0x01	; 1
    216c:	e8 15       	cp	r30, r8
    216e:	08 f0       	brcs	.+2      	; 0x2172 <CO_collectADC+0x230>
    2170:	60 e0       	ldi	r22, 0x00	; 0
    2172:	89 2e       	mov	r8, r25
    2174:	8e 0e       	add	r8, r30
    2176:	91 e0       	ldi	r25, 0x01	; 1
    2178:	8e 16       	cp	r8, r30
    217a:	08 f0       	brcs	.+2      	; 0x217e <CO_collectADC+0x23c>
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	69 2b       	or	r22, r25
    2180:	2f 0d       	add	r18, r15
    2182:	51 e0       	ldi	r21, 0x01	; 1
    2184:	2f 15       	cp	r18, r15
    2186:	08 f0       	brcs	.+2      	; 0x218a <CO_collectADC+0x248>
    2188:	50 e0       	ldi	r21, 0x00	; 0
    218a:	f6 2e       	mov	r15, r22
    218c:	f2 0e       	add	r15, r18
    218e:	91 e0       	ldi	r25, 0x01	; 1
    2190:	f2 16       	cp	r15, r18
    2192:	08 f0       	brcs	.+2      	; 0x2196 <CO_collectADC+0x254>
    2194:	90 e0       	ldi	r25, 0x00	; 0
    2196:	59 2b       	or	r21, r25
    2198:	98 0e       	add	r9, r24
    219a:	49 8b       	std	Y+17, r20	; 0x11
    219c:	7a 8b       	std	Y+18, r23	; 0x12
    219e:	95 0e       	add	r9, r21
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
    21a0:	e0 91 49 40 	lds	r30, 0x4049
    21a4:	f0 91 4a 40 	lds	r31, 0x404A
    21a8:	ee 0f       	add	r30, r30
    21aa:	ff 1f       	adc	r31, r31
    21ac:	ee 0f       	add	r30, r30
    21ae:	ff 1f       	adc	r31, r31
    21b0:	ea 0d       	add	r30, r10
    21b2:	fb 1d       	adc	r31, r11
    21b4:	80 81       	ld	r24, Z
    21b6:	91 81       	ldd	r25, Z+1	; 0x01
    21b8:	a2 81       	ldd	r26, Z+2	; 0x02
    21ba:	b3 81       	ldd	r27, Z+3	; 0x03
    21bc:	68 2f       	mov	r22, r24
    21be:	49 2f       	mov	r20, r25
    21c0:	5a 2f       	mov	r21, r26
    21c2:	2b 2f       	mov	r18, r27
    21c4:	bb 0f       	add	r27, r27
    21c6:	88 0b       	sbc	r24, r24
    21c8:	98 2f       	mov	r25, r24
    21ca:	dc 01       	movw	r26, r24
    21cc:	78 2f       	mov	r23, r24
    21ce:	78 16       	cp	r7, r24
    21d0:	0c f1       	brlt	.+66     	; 0x2214 <CO_collectADC+0x2d2>
    21d2:	87 15       	cp	r24, r7
    21d4:	c9 f5       	brne	.+114    	; 0x2248 <CO_collectADC+0x306>
    21d6:	58 16       	cp	r5, r24
    21d8:	e8 f0       	brcs	.+58     	; 0x2214 <CO_collectADC+0x2d2>
    21da:	85 15       	cp	r24, r5
    21dc:	a9 f5       	brne	.+106    	; 0x2248 <CO_collectADC+0x306>
    21de:	38 16       	cp	r3, r24
    21e0:	c8 f0       	brcs	.+50     	; 0x2214 <CO_collectADC+0x2d2>
    21e2:	83 15       	cp	r24, r3
    21e4:	89 f5       	brne	.+98     	; 0x2248 <CO_collectADC+0x306>
    21e6:	8a 81       	ldd	r24, Y+2	; 0x02
    21e8:	87 17       	cp	r24, r23
    21ea:	a0 f0       	brcs	.+40     	; 0x2214 <CO_collectADC+0x2d2>
    21ec:	78 17       	cp	r23, r24
    21ee:	61 f5       	brne	.+88     	; 0x2248 <CO_collectADC+0x306>
    21f0:	9c 81       	ldd	r25, Y+4	; 0x04
    21f2:	92 17       	cp	r25, r18
    21f4:	78 f0       	brcs	.+30     	; 0x2214 <CO_collectADC+0x2d2>
    21f6:	29 17       	cp	r18, r25
    21f8:	39 f5       	brne	.+78     	; 0x2248 <CO_collectADC+0x306>
    21fa:	e8 85       	ldd	r30, Y+8	; 0x08
    21fc:	e5 17       	cp	r30, r21
    21fe:	50 f0       	brcs	.+20     	; 0x2214 <CO_collectADC+0x2d2>
    2200:	5e 17       	cp	r21, r30
    2202:	11 f5       	brne	.+68     	; 0x2248 <CO_collectADC+0x306>
    2204:	ff 81       	ldd	r31, Y+7	; 0x07
    2206:	f4 17       	cp	r31, r20
    2208:	28 f0       	brcs	.+10     	; 0x2214 <CO_collectADC+0x2d2>
    220a:	4f 17       	cp	r20, r31
    220c:	e9 f4       	brne	.+58     	; 0x2248 <CO_collectADC+0x306>
    220e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2210:	26 17       	cp	r18, r22
    2212:	d0 f4       	brcc	.+52     	; 0x2248 <CO_collectADC+0x306>
    2214:	e0 91 49 40 	lds	r30, 0x4049
    2218:	f0 91 4a 40 	lds	r31, 0x404A
    221c:	ee 0f       	add	r30, r30
    221e:	ff 1f       	adc	r31, r31
    2220:	ee 0f       	add	r30, r30
    2222:	ff 1f       	adc	r31, r31
    2224:	ea 0d       	add	r30, r10
    2226:	fb 1d       	adc	r31, r11
    2228:	80 81       	ld	r24, Z
    222a:	91 81       	ldd	r25, Z+1	; 0x01
    222c:	a2 81       	ldd	r26, Z+2	; 0x02
    222e:	b3 81       	ldd	r27, Z+3	; 0x03
    2230:	8a 87       	std	Y+10, r24	; 0x0a
    2232:	9f 83       	std	Y+7, r25	; 0x07
    2234:	a8 87       	std	Y+8, r26	; 0x08
    2236:	bc 83       	std	Y+4, r27	; 0x04
    2238:	bb 0f       	add	r27, r27
    223a:	88 0b       	sbc	r24, r24
    223c:	98 2f       	mov	r25, r24
    223e:	dc 01       	movw	r26, r24
    2240:	8a 83       	std	Y+2, r24	; 0x02
    2242:	38 2e       	mov	r3, r24
    2244:	58 2e       	mov	r5, r24
    2246:	78 2e       	mov	r7, r24
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
    2248:	e0 91 49 40 	lds	r30, 0x4049
    224c:	f0 91 4a 40 	lds	r31, 0x404A
    2250:	ee 0f       	add	r30, r30
    2252:	ff 1f       	adc	r31, r31
    2254:	ee 0f       	add	r30, r30
    2256:	ff 1f       	adc	r31, r31
    2258:	ea 0d       	add	r30, r10
    225a:	fb 1d       	adc	r31, r11
    225c:	80 81       	ld	r24, Z
    225e:	91 81       	ldd	r25, Z+1	; 0x01
    2260:	a2 81       	ldd	r26, Z+2	; 0x02
    2262:	b3 81       	ldd	r27, Z+3	; 0x03
    2264:	68 2f       	mov	r22, r24
    2266:	49 2f       	mov	r20, r25
    2268:	5a 2f       	mov	r21, r26
    226a:	2b 2f       	mov	r18, r27
    226c:	bb 0f       	add	r27, r27
    226e:	88 0b       	sbc	r24, r24
    2270:	98 2f       	mov	r25, r24
    2272:	dc 01       	movw	r26, r24
    2274:	78 2f       	mov	r23, r24
    2276:	86 15       	cp	r24, r6
    2278:	0c f1       	brlt	.+66     	; 0x22bc <CO_collectADC+0x37a>
    227a:	68 16       	cp	r6, r24
    227c:	c9 f5       	brne	.+114    	; 0x22f0 <CO_collectADC+0x3ae>
    227e:	84 15       	cp	r24, r4
    2280:	e8 f0       	brcs	.+58     	; 0x22bc <CO_collectADC+0x37a>
    2282:	48 16       	cp	r4, r24
    2284:	a9 f5       	brne	.+106    	; 0x22f0 <CO_collectADC+0x3ae>
    2286:	82 15       	cp	r24, r2
    2288:	c8 f0       	brcs	.+50     	; 0x22bc <CO_collectADC+0x37a>
    228a:	28 16       	cp	r2, r24
    228c:	89 f5       	brne	.+98     	; 0x22f0 <CO_collectADC+0x3ae>
    228e:	89 81       	ldd	r24, Y+1	; 0x01
    2290:	78 17       	cp	r23, r24
    2292:	a0 f0       	brcs	.+40     	; 0x22bc <CO_collectADC+0x37a>
    2294:	87 17       	cp	r24, r23
    2296:	61 f5       	brne	.+88     	; 0x22f0 <CO_collectADC+0x3ae>
    2298:	9b 81       	ldd	r25, Y+3	; 0x03
    229a:	29 17       	cp	r18, r25
    229c:	78 f0       	brcs	.+30     	; 0x22bc <CO_collectADC+0x37a>
    229e:	92 17       	cp	r25, r18
    22a0:	39 f5       	brne	.+78     	; 0x22f0 <CO_collectADC+0x3ae>
    22a2:	ee 81       	ldd	r30, Y+6	; 0x06
    22a4:	5e 17       	cp	r21, r30
    22a6:	50 f0       	brcs	.+20     	; 0x22bc <CO_collectADC+0x37a>
    22a8:	e5 17       	cp	r30, r21
    22aa:	11 f5       	brne	.+68     	; 0x22f0 <CO_collectADC+0x3ae>
    22ac:	fd 81       	ldd	r31, Y+5	; 0x05
    22ae:	4f 17       	cp	r20, r31
    22b0:	28 f0       	brcs	.+10     	; 0x22bc <CO_collectADC+0x37a>
    22b2:	f4 17       	cp	r31, r20
    22b4:	e9 f4       	brne	.+58     	; 0x22f0 <CO_collectADC+0x3ae>
    22b6:	29 85       	ldd	r18, Y+9	; 0x09
    22b8:	62 17       	cp	r22, r18
    22ba:	d0 f4       	brcc	.+52     	; 0x22f0 <CO_collectADC+0x3ae>
    22bc:	e0 91 49 40 	lds	r30, 0x4049
    22c0:	f0 91 4a 40 	lds	r31, 0x404A
    22c4:	ee 0f       	add	r30, r30
    22c6:	ff 1f       	adc	r31, r31
    22c8:	ee 0f       	add	r30, r30
    22ca:	ff 1f       	adc	r31, r31
    22cc:	ea 0d       	add	r30, r10
    22ce:	fb 1d       	adc	r31, r11
    22d0:	80 81       	ld	r24, Z
    22d2:	91 81       	ldd	r25, Z+1	; 0x01
    22d4:	a2 81       	ldd	r26, Z+2	; 0x02
    22d6:	b3 81       	ldd	r27, Z+3	; 0x03
    22d8:	89 87       	std	Y+9, r24	; 0x09
    22da:	9d 83       	std	Y+5, r25	; 0x05
    22dc:	ae 83       	std	Y+6, r26	; 0x06
    22de:	bb 83       	std	Y+3, r27	; 0x03
    22e0:	bb 0f       	add	r27, r27
    22e2:	88 0b       	sbc	r24, r24
    22e4:	98 2f       	mov	r25, r24
    22e6:	dc 01       	movw	r26, r24
    22e8:	89 83       	std	Y+1, r24	; 0x01
    22ea:	28 2e       	mov	r2, r24
    22ec:	48 2e       	mov	r4, r24
    22ee:	68 2e       	mov	r6, r24
	SPIDisable();	
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    22f0:	80 91 49 40 	lds	r24, 0x4049
    22f4:	90 91 4a 40 	lds	r25, 0x404A
    22f8:	01 96       	adiw	r24, 0x01	; 1
    22fa:	80 93 49 40 	sts	0x4049, r24
    22fe:	90 93 4a 40 	sts	0x404A, r25
    2302:	80 91 49 40 	lds	r24, 0x4049
    2306:	90 91 4a 40 	lds	r25, 0x404A
    230a:	54 e0       	ldi	r21, 0x04	; 4
    230c:	80 30       	cpi	r24, 0x00	; 0
    230e:	95 07       	cpc	r25, r21
    2310:	08 f4       	brcc	.+2      	; 0x2314 <CO_collectADC+0x3d2>
    2312:	d8 ce       	rjmp	.-592    	; 0x20c4 <CO_collectADC+0x182>
    2314:	e9 89       	ldd	r30, Y+17	; 0x11
    2316:	4a 89       	ldd	r20, Y+18	; 0x12
    2318:	22 c0       	rjmp	.+68     	; 0x235e <CO_collectADC+0x41c>
		int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
	int64_t max = -ADC_MAX;
    231a:	61 e0       	ldi	r22, 0x01	; 1
    231c:	6a 87       	std	Y+10, r22	; 0x0a
    231e:	1f 82       	std	Y+7, r1	; 0x07
    2320:	80 e8       	ldi	r24, 0x80	; 128
    2322:	88 87       	std	Y+8, r24	; 0x08
    2324:	9f ef       	ldi	r25, 0xFF	; 255
    2326:	9c 83       	std	Y+4, r25	; 0x04
    2328:	ef ef       	ldi	r30, 0xFF	; 255
    232a:	ea 83       	std	Y+2, r30	; 0x02
    232c:	33 24       	eor	r3, r3
    232e:	3a 94       	dec	r3
    2330:	55 24       	eor	r5, r5
    2332:	5a 94       	dec	r5
    2334:	77 24       	eor	r7, r7
    2336:	7a 94       	dec	r7
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV,
		int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
    2338:	ff ef       	ldi	r31, 0xFF	; 255
    233a:	f9 87       	std	Y+9, r31	; 0x09
    233c:	2f ef       	ldi	r18, 0xFF	; 255
    233e:	2d 83       	std	Y+5, r18	; 0x05
    2340:	5f e7       	ldi	r21, 0x7F	; 127
    2342:	5e 83       	std	Y+6, r21	; 0x06
    2344:	1b 82       	std	Y+3, r1	; 0x03
    2346:	19 82       	std	Y+1, r1	; 0x01
    2348:	22 24       	eor	r2, r2
    234a:	44 24       	eor	r4, r4
    234c:	66 24       	eor	r6, r6
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV,
		int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
    234e:	e0 e0       	ldi	r30, 0x00	; 0
    2350:	30 e0       	ldi	r19, 0x00	; 0
    2352:	40 e0       	ldi	r20, 0x00	; 0
    2354:	10 e0       	ldi	r17, 0x00	; 0
    2356:	00 e0       	ldi	r16, 0x00	; 0
    2358:	88 24       	eor	r8, r8
    235a:	ff 24       	eor	r15, r15
    235c:	99 24       	eor	r9, r9
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
		sum += data24Bit[sampleCount];
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
	}
	average = sum / NUM_SAMPLES;
    235e:	2e 2f       	mov	r18, r30
    2360:	51 2f       	mov	r21, r17
    2362:	60 2f       	mov	r22, r16
    2364:	78 2d       	mov	r23, r8
    2366:	8f 2d       	mov	r24, r15
    2368:	99 2d       	mov	r25, r9
    236a:	99 20       	and	r9, r9
    236c:	0c f0       	brlt	.+2      	; 0x2370 <CO_collectADC+0x42e>
    236e:	42 c0       	rjmp	.+132    	; 0x23f4 <CO_collectADC+0x4b2>
    2370:	ae 2f       	mov	r26, r30
    2372:	a1 50       	subi	r26, 0x01	; 1
    2374:	f1 e0       	ldi	r31, 0x01	; 1
    2376:	ae 17       	cp	r26, r30
    2378:	08 f0       	brcs	.+2      	; 0x237c <CO_collectADC+0x43a>
    237a:	f0 e0       	ldi	r31, 0x00	; 0
    237c:	e3 2f       	mov	r30, r19
    237e:	ed 5f       	subi	r30, 0xFD	; 253
    2380:	21 e0       	ldi	r18, 0x01	; 1
    2382:	e3 17       	cp	r30, r19
    2384:	08 f0       	brcs	.+2      	; 0x2388 <CO_collectADC+0x446>
    2386:	20 e0       	ldi	r18, 0x00	; 0
    2388:	fe 0f       	add	r31, r30
    238a:	31 e0       	ldi	r19, 0x01	; 1
    238c:	fe 17       	cp	r31, r30
    238e:	08 f0       	brcs	.+2      	; 0x2392 <CO_collectADC+0x450>
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	23 2b       	or	r18, r19
    2394:	30 e0       	ldi	r19, 0x00	; 0
    2396:	b2 2f       	mov	r27, r18
    2398:	b4 0f       	add	r27, r20
    239a:	21 e0       	ldi	r18, 0x01	; 1
    239c:	b4 17       	cp	r27, r20
    239e:	08 f0       	brcs	.+2      	; 0x23a2 <CO_collectADC+0x460>
    23a0:	20 e0       	ldi	r18, 0x00	; 0
    23a2:	32 2b       	or	r19, r18
    23a4:	20 e0       	ldi	r18, 0x00	; 0
    23a6:	13 2f       	mov	r17, r19
    23a8:	15 0f       	add	r17, r21
    23aa:	31 e0       	ldi	r19, 0x01	; 1
    23ac:	15 17       	cp	r17, r21
    23ae:	08 f0       	brcs	.+2      	; 0x23b2 <CO_collectADC+0x470>
    23b0:	30 e0       	ldi	r19, 0x00	; 0
    23b2:	23 2b       	or	r18, r19
    23b4:	30 e0       	ldi	r19, 0x00	; 0
    23b6:	02 2f       	mov	r16, r18
    23b8:	06 0f       	add	r16, r22
    23ba:	21 e0       	ldi	r18, 0x01	; 1
    23bc:	06 17       	cp	r16, r22
    23be:	08 f0       	brcs	.+2      	; 0x23c2 <CO_collectADC+0x480>
    23c0:	20 e0       	ldi	r18, 0x00	; 0
    23c2:	32 2b       	or	r19, r18
    23c4:	20 e0       	ldi	r18, 0x00	; 0
    23c6:	83 2e       	mov	r8, r19
    23c8:	87 0e       	add	r8, r23
    23ca:	31 e0       	ldi	r19, 0x01	; 1
    23cc:	87 16       	cp	r8, r23
    23ce:	08 f0       	brcs	.+2      	; 0x23d2 <CO_collectADC+0x490>
    23d0:	30 e0       	ldi	r19, 0x00	; 0
    23d2:	23 2b       	or	r18, r19
    23d4:	f8 2e       	mov	r15, r24
    23d6:	e0 e0       	ldi	r30, 0x00	; 0
    23d8:	82 2f       	mov	r24, r18
    23da:	8f 0d       	add	r24, r15
    23dc:	21 e0       	ldi	r18, 0x01	; 1
    23de:	8f 15       	cp	r24, r15
    23e0:	08 f0       	brcs	.+2      	; 0x23e4 <CO_collectADC+0x4a2>
    23e2:	20 e0       	ldi	r18, 0x00	; 0
    23e4:	e2 2b       	or	r30, r18
    23e6:	2a 2f       	mov	r18, r26
    23e8:	3f 2f       	mov	r19, r31
    23ea:	4b 2f       	mov	r20, r27
    23ec:	51 2f       	mov	r21, r17
    23ee:	60 2f       	mov	r22, r16
    23f0:	78 2d       	mov	r23, r8
    23f2:	9e 0f       	add	r25, r30
    23f4:	0a e0       	ldi	r16, 0x0A	; 10
    23f6:	0e 94 58 2c 	call	0x58b0	; 0x58b0 <__ashrdi3>

	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    23fa:	0f 2e       	mov	r0, r31
    23fc:	f0 ea       	ldi	r31, 0xA0	; 160
    23fe:	af 2e       	mov	r10, r31
    2400:	f0 2d       	mov	r31, r0
    2402:	0f 2e       	mov	r0, r31
    2404:	f5 e2       	ldi	r31, 0x25	; 37
    2406:	bf 2e       	mov	r11, r31
    2408:	f0 2d       	mov	r31, r0
    240a:	0f 2e       	mov	r0, r31
    240c:	f6 e2       	ldi	r31, 0x26	; 38
    240e:	cf 2e       	mov	r12, r31
    2410:	f0 2d       	mov	r31, r0
    2412:	dd 24       	eor	r13, r13
    2414:	ee 24       	eor	r14, r14
    2416:	ff 24       	eor	r15, r15
    2418:	00 e0       	ldi	r16, 0x00	; 0
    241a:	10 e0       	ldi	r17, 0x00	; 0
    241c:	0e 94 11 2b 	call	0x5622	; 0x5622 <__muldi3>
    2420:	aa 24       	eor	r10, r10
    2422:	aa 94       	dec	r10
    2424:	bb 24       	eor	r11, r11
    2426:	ba 94       	dec	r11
    2428:	0f 2e       	mov	r0, r31
    242a:	ff e7       	ldi	r31, 0x7F	; 127
    242c:	cf 2e       	mov	r12, r31
    242e:	f0 2d       	mov	r31, r0
    2430:	0e 94 c0 2c 	call	0x5980	; 0x5980 <__divdi3>
    2434:	01 e0       	ldi	r16, 0x01	; 1
    2436:	0e 94 e4 2b 	call	0x57c8	; 0x57c8 <__ashldi3>
    243a:	0f 2e       	mov	r0, r31
    243c:	f3 e0       	ldi	r31, 0x03	; 3
    243e:	af 2e       	mov	r10, r31
    2440:	f0 2d       	mov	r31, r0
    2442:	bb 24       	eor	r11, r11
    2444:	cc 24       	eor	r12, r12
    2446:	00 e0       	ldi	r16, 0x00	; 0
    2448:	0e 94 c0 2c 	call	0x5980	; 0x5980 <__divdi3>
    244c:	82 2e       	mov	r8, r18
    244e:	93 2e       	mov	r9, r19
    2450:	a4 2e       	mov	r10, r20
    2452:	b5 2e       	mov	r11, r21
    2454:	b0 94       	com	r11
    2456:	a0 94       	com	r10
    2458:	90 94       	com	r9
    245a:	80 94       	com	r8
    245c:	81 1c       	adc	r8, r1
    245e:	91 1c       	adc	r9, r1
    2460:	a1 1c       	adc	r10, r1
    2462:	b1 1c       	adc	r11, r1
    2464:	eb 85       	ldd	r30, Y+11	; 0x0b
    2466:	fc 85       	ldd	r31, Y+12	; 0x0c
    2468:	80 82       	st	Z, r8
    246a:	91 82       	std	Z+1, r9	; 0x01
    246c:	a2 82       	std	Z+2, r10	; 0x02
    246e:	b3 82       	std	Z+3, r11	; 0x03
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    2470:	2a 85       	ldd	r18, Y+10	; 0x0a
    2472:	3f 81       	ldd	r19, Y+7	; 0x07
    2474:	48 85       	ldd	r20, Y+8	; 0x08
    2476:	5c 81       	ldd	r21, Y+4	; 0x04
    2478:	6a 81       	ldd	r22, Y+2	; 0x02
    247a:	73 2d       	mov	r23, r3
    247c:	85 2d       	mov	r24, r5
    247e:	97 2d       	mov	r25, r7
    2480:	0f 2e       	mov	r0, r31
    2482:	f0 ea       	ldi	r31, 0xA0	; 160
    2484:	af 2e       	mov	r10, r31
    2486:	f0 2d       	mov	r31, r0
    2488:	0f 2e       	mov	r0, r31
    248a:	f5 e2       	ldi	r31, 0x25	; 37
    248c:	bf 2e       	mov	r11, r31
    248e:	f0 2d       	mov	r31, r0
    2490:	0f 2e       	mov	r0, r31
    2492:	f6 e2       	ldi	r31, 0x26	; 38
    2494:	cf 2e       	mov	r12, r31
    2496:	f0 2d       	mov	r31, r0
    2498:	dd 24       	eor	r13, r13
    249a:	ee 24       	eor	r14, r14
    249c:	ff 24       	eor	r15, r15
    249e:	0e 94 11 2b 	call	0x5622	; 0x5622 <__muldi3>
    24a2:	aa 24       	eor	r10, r10
    24a4:	aa 94       	dec	r10
    24a6:	bb 24       	eor	r11, r11
    24a8:	ba 94       	dec	r11
    24aa:	0f 2e       	mov	r0, r31
    24ac:	ff e7       	ldi	r31, 0x7F	; 127
    24ae:	cf 2e       	mov	r12, r31
    24b0:	f0 2d       	mov	r31, r0
    24b2:	0e 94 c0 2c 	call	0x5980	; 0x5980 <__divdi3>
    24b6:	01 e0       	ldi	r16, 0x01	; 1
    24b8:	0e 94 e4 2b 	call	0x57c8	; 0x57c8 <__ashldi3>
    24bc:	0f 2e       	mov	r0, r31
    24be:	f3 e0       	ldi	r31, 0x03	; 3
    24c0:	af 2e       	mov	r10, r31
    24c2:	f0 2d       	mov	r31, r0
    24c4:	bb 24       	eor	r11, r11
    24c6:	cc 24       	eor	r12, r12
    24c8:	00 e0       	ldi	r16, 0x00	; 0
    24ca:	0e 94 c0 2c 	call	0x5980	; 0x5980 <__divdi3>
    24ce:	82 2e       	mov	r8, r18
    24d0:	93 2e       	mov	r9, r19
    24d2:	a4 2e       	mov	r10, r20
    24d4:	b5 2e       	mov	r11, r21
    24d6:	b0 94       	com	r11
    24d8:	a0 94       	com	r10
    24da:	90 94       	com	r9
    24dc:	80 94       	com	r8
    24de:	81 1c       	adc	r8, r1
    24e0:	91 1c       	adc	r9, r1
    24e2:	a1 1c       	adc	r10, r1
    24e4:	b1 1c       	adc	r11, r1
    24e6:	ef 85       	ldd	r30, Y+15	; 0x0f
    24e8:	f8 89       	ldd	r31, Y+16	; 0x10
    24ea:	80 82       	st	Z, r8
    24ec:	91 82       	std	Z+1, r9	; 0x01
    24ee:	a2 82       	std	Z+2, r10	; 0x02
    24f0:	b3 82       	std	Z+3, r11	; 0x03
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    24f2:	29 85       	ldd	r18, Y+9	; 0x09
    24f4:	3d 81       	ldd	r19, Y+5	; 0x05
    24f6:	4e 81       	ldd	r20, Y+6	; 0x06
    24f8:	5b 81       	ldd	r21, Y+3	; 0x03
    24fa:	69 81       	ldd	r22, Y+1	; 0x01
    24fc:	72 2d       	mov	r23, r2
    24fe:	84 2d       	mov	r24, r4
    2500:	96 2d       	mov	r25, r6
    2502:	0f 2e       	mov	r0, r31
    2504:	f0 ea       	ldi	r31, 0xA0	; 160
    2506:	af 2e       	mov	r10, r31
    2508:	f0 2d       	mov	r31, r0
    250a:	0f 2e       	mov	r0, r31
    250c:	f5 e2       	ldi	r31, 0x25	; 37
    250e:	bf 2e       	mov	r11, r31
    2510:	f0 2d       	mov	r31, r0
    2512:	0f 2e       	mov	r0, r31
    2514:	f6 e2       	ldi	r31, 0x26	; 38
    2516:	cf 2e       	mov	r12, r31
    2518:	f0 2d       	mov	r31, r0
    251a:	dd 24       	eor	r13, r13
    251c:	ee 24       	eor	r14, r14
    251e:	ff 24       	eor	r15, r15
    2520:	0e 94 11 2b 	call	0x5622	; 0x5622 <__muldi3>
    2524:	aa 24       	eor	r10, r10
    2526:	aa 94       	dec	r10
    2528:	bb 24       	eor	r11, r11
    252a:	ba 94       	dec	r11
    252c:	0f 2e       	mov	r0, r31
    252e:	ff e7       	ldi	r31, 0x7F	; 127
    2530:	cf 2e       	mov	r12, r31
    2532:	f0 2d       	mov	r31, r0
    2534:	0e 94 c0 2c 	call	0x5980	; 0x5980 <__divdi3>
    2538:	01 e0       	ldi	r16, 0x01	; 1
    253a:	0e 94 e4 2b 	call	0x57c8	; 0x57c8 <__ashldi3>
    253e:	0f 2e       	mov	r0, r31
    2540:	f3 e0       	ldi	r31, 0x03	; 3
    2542:	af 2e       	mov	r10, r31
    2544:	f0 2d       	mov	r31, r0
    2546:	bb 24       	eor	r11, r11
    2548:	cc 24       	eor	r12, r12
    254a:	00 e0       	ldi	r16, 0x00	; 0
    254c:	0e 94 c0 2c 	call	0x5980	; 0x5980 <__divdi3>
    2550:	82 2e       	mov	r8, r18
    2552:	93 2e       	mov	r9, r19
    2554:	a4 2e       	mov	r10, r20
    2556:	b5 2e       	mov	r11, r21
    2558:	b0 94       	com	r11
    255a:	a0 94       	com	r10
    255c:	90 94       	com	r9
    255e:	80 94       	com	r8
    2560:	81 1c       	adc	r8, r1
    2562:	91 1c       	adc	r9, r1
    2564:	a1 1c       	adc	r10, r1
    2566:	b1 1c       	adc	r11, r1
    2568:	ed 85       	ldd	r30, Y+13	; 0x0d
    256a:	fe 85       	ldd	r31, Y+14	; 0x0e
    256c:	80 82       	st	Z, r8
    256e:	91 82       	std	Z+1, r9	; 0x01
    2570:	a2 82       	std	Z+2, r10	; 0x02
    2572:	b3 82       	std	Z+3, r11	; 0x03

}
    2574:	62 96       	adiw	r28, 0x12	; 18
    2576:	cd bf       	out	0x3d, r28	; 61
    2578:	de bf       	out	0x3e, r29	; 62
    257a:	df 91       	pop	r29
    257c:	cf 91       	pop	r28
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	ff 90       	pop	r15
    2584:	ef 90       	pop	r14
    2586:	df 90       	pop	r13
    2588:	cf 90       	pop	r12
    258a:	bf 90       	pop	r11
    258c:	af 90       	pop	r10
    258e:	9f 90       	pop	r9
    2590:	8f 90       	pop	r8
    2592:	7f 90       	pop	r7
    2594:	6f 90       	pop	r6
    2596:	5f 90       	pop	r5
    2598:	4f 90       	pop	r4
    259a:	3f 90       	pop	r3
    259c:	2f 90       	pop	r2
    259e:	08 95       	ret

000025a0 <CO_collectSeismic3Channel>:
	}
}

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
	uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
	uint16_t averagingPtC, uint16_t averagingPtD) {
    25a0:	4f 92       	push	r4
    25a2:	5f 92       	push	r5
    25a4:	6f 92       	push	r6
    25a6:	7f 92       	push	r7
    25a8:	8f 92       	push	r8
    25aa:	9f 92       	push	r9
    25ac:	af 92       	push	r10
    25ae:	bf 92       	push	r11
    25b0:	cf 92       	push	r12
    25b2:	df 92       	push	r13
    25b4:	ef 92       	push	r14
    25b6:	ff 92       	push	r15
    25b8:	0f 93       	push	r16
    25ba:	1f 93       	push	r17
    25bc:	cf 93       	push	r28
    25be:	df 93       	push	r29
    25c0:	cd b7       	in	r28, 0x3d	; 61
    25c2:	de b7       	in	r29, 0x3e	; 62
    25c4:	18 2f       	mov	r17, r24
    25c6:	3b 01       	movw	r6, r22
    25c8:	54 2e       	mov	r5, r20
    25ca:	42 2e       	mov	r4, r18
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	
	// Set gains, filters, and input channel	
	set_ampGain(ADC_CH_6_gc, gain[0]);
    25d2:	85 e0       	ldi	r24, 0x05	; 5
    25d4:	f3 01       	movw	r30, r6
    25d6:	60 81       	ld	r22, Z
    25d8:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    25dc:	86 e0       	ldi	r24, 0x06	; 6
    25de:	f3 01       	movw	r30, r6
    25e0:	61 81       	ldd	r22, Z+1	; 0x01
    25e2:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    25e6:	87 e0       	ldi	r24, 0x07	; 7
    25e8:	f3 01       	movw	r30, r6
    25ea:	62 81       	ldd	r22, Z+2	; 0x02
    25ec:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_filter(filterConfig);
    25f0:	81 2f       	mov	r24, r17
    25f2:	0e 94 c9 09 	call	0x1392	; 0x1392 <set_filter>
	ACC_DCPassEnable(DCPassEnable);	
    25f6:	80 2f       	mov	r24, r16
    25f8:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    25fc:	84 e0       	ldi	r24, 0x04	; 4
    25fe:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2602:	84 e5       	ldi	r24, 0x54	; 84
    2604:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2608:	81 e0       	ldi	r24, 0x01	; 1
    260a:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    260e:	85 e0       	ldi	r24, 0x05	; 5
    2610:	0e 94 6e 09 	call	0x12dc	; 0x12dc <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2614:	e0 ea       	ldi	r30, 0xA0	; 160
    2616:	f6 e0       	ldi	r31, 0x06	; 6
    2618:	82 e0       	ldi	r24, 0x02	; 2
    261a:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    261c:	91 e0       	ldi	r25, 0x01	; 1
    261e:	92 83       	std	Z+2, r25	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2620:	98 e7       	ldi	r25, 0x78	; 120
    2622:	90 93 80 01 	sts	0x0180, r25

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2626:	e0 e0       	ldi	r30, 0x00	; 0
    2628:	f8 e0       	ldi	r31, 0x08	; 8
    262a:	90 ef       	ldi	r25, 0xF0	; 240
    262c:	91 83       	std	Z+1, r25	; 0x01
	TCC0.CCA = averagingPtA;
    262e:	e0 a6       	lds	r30, 0xb0
    2630:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2632:	c2 a6       	lds	r28, 0xb2
    2634:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2636:	a4 a6       	lds	r26, 0xb4
    2638:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    263a:	86 a6       	lds	r24, 0xb6
    263c:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    263e:	24 2d       	mov	r18, r4
    2640:	30 e0       	ldi	r19, 0x00	; 0
    2642:	21 50       	subi	r18, 0x01	; 1
    2644:	30 40       	sbci	r19, 0x00	; 0
    2646:	26 a3       	lds	r18, 0x56
    2648:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    264a:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    264c:	8f ef       	ldi	r24, 0xFF	; 255
    264e:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2650:	80 81       	ld	r24, Z
    2652:	80 7f       	andi	r24, 0xF0	; 240
    2654:	88 60       	ori	r24, 0x08	; 8
    2656:	80 83       	st	Z, r24

	FRAMAddress = FR_BASEADD;
    2658:	10 92 3f 40 	sts	0x403F, r1
    265c:	10 92 40 40 	sts	0x4040, r1
	sampleCount = 0;
    2660:	10 92 49 40 	sts	0x4049, r1
    2664:	10 92 4a 40 	sts	0x404A, r1
	SPICount = 0;
    2668:	10 92 9e 50 	sts	0x509E, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    266c:	8e eb       	ldi	r24, 0xBE	; 190
    266e:	91 e2       	ldi	r25, 0x21	; 33
    2670:	10 92 be 21 	sts	0x21BE, r1
    2674:	fc 01       	movw	r30, r24
    2676:	31 97       	sbiw	r30, 0x01	; 1
    2678:	10 82       	st	Z, r1
    267a:	02 97       	sbiw	r24, 0x02	; 2
    267c:	fc 01       	movw	r30, r24
    267e:	10 82       	st	Z, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2680:	e0 ea       	ldi	r30, 0xA0	; 160
    2682:	f0 e0       	ldi	r31, 0x00	; 0
    2684:	82 81       	ldd	r24, Z+2	; 0x02
    2686:	86 60       	ori	r24, 0x06	; 6
    2688:	82 83       	std	Z+2, r24	; 0x02
	sei();
    268a:	78 94       	sei

	SPICS(TRUE);
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2692:	80 e2       	ldi	r24, 0x20	; 32
    2694:	e0 e8       	ldi	r30, 0x80	; 128
    2696:	f6 e0       	ldi	r31, 0x06	; 6
    2698:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    269a:	e0 e4       	ldi	r30, 0x40	; 64
    269c:	fa e0       	ldi	r31, 0x0A	; 10
    269e:	83 e2       	ldi	r24, 0x23	; 35
    26a0:	81 83       	std	Z+1, r24	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    26a2:	80 e2       	ldi	r24, 0x20	; 32
    26a4:	90 e0       	ldi	r25, 0x00	; 0
    26a6:	05 2c       	mov	r0, r5
    26a8:	02 c0       	rjmp	.+4      	; 0x26ae <CO_collectSeismic3Channel+0x10e>
    26aa:	88 0f       	add	r24, r24
    26ac:	99 1f       	adc	r25, r25
    26ae:	0a 94       	dec	r0
    26b0:	e2 f7       	brpl	.-8      	; 0x26aa <CO_collectSeismic3Channel+0x10a>
    26b2:	86 a3       	lds	r24, 0x56
    26b4:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    26b6:	80 e1       	ldi	r24, 0x10	; 16
    26b8:	90 e0       	ldi	r25, 0x00	; 0
    26ba:	02 c0       	rjmp	.+4      	; 0x26c0 <CO_collectSeismic3Channel+0x120>
    26bc:	88 0f       	add	r24, r24
    26be:	99 1f       	adc	r25, r25
    26c0:	5a 94       	dec	r5
    26c2:	e2 f7       	brpl	.-8      	; 0x26bc <CO_collectSeismic3Channel+0x11c>
    26c4:	82 af       	sts	0x72, r24
    26c6:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    26c8:	80 81       	ld	r24, Z
    26ca:	80 7f       	andi	r24, 0xF0	; 240
    26cc:	81 60       	ori	r24, 0x01	; 1
    26ce:	80 83       	st	Z, r24
			
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);	
    26d0:	80 91 49 40 	lds	r24, 0x4049
    26d4:	90 91 4a 40 	lds	r25, 0x404A
    26d8:	f5 e5       	ldi	r31, 0x55	; 85
    26da:	83 35       	cpi	r24, 0x53	; 83
    26dc:	9f 07       	cpc	r25, r31
    26de:	c0 f3       	brcs	.-16     	; 0x26d0 <CO_collectSeismic3Channel+0x130>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    26e0:	e0 e0       	ldi	r30, 0x00	; 0
    26e2:	f8 e0       	ldi	r31, 0x08	; 8
    26e4:	80 81       	ld	r24, Z
    26e6:	80 7f       	andi	r24, 0xF0	; 240
    26e8:	80 83       	st	Z, r24
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    26ea:	e0 e4       	ldi	r30, 0x40	; 64
    26ec:	fa e0       	ldi	r31, 0x0A	; 10
    26ee:	80 81       	ld	r24, Z
    26f0:	80 7f       	andi	r24, 0xF0	; 240
    26f2:	80 83       	st	Z, r24
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);	
    26f4:	e0 ea       	ldi	r30, 0xA0	; 160
    26f6:	f0 e0       	ldi	r31, 0x00	; 0
    26f8:	82 81       	ldd	r24, Z+2	; 0x02
    26fa:	89 7f       	andi	r24, 0xF9	; 249
    26fc:	82 83       	std	Z+2, r24	; 0x02
	cli();
    26fe:	f8 94       	cli

	SPICS(FALSE);
    2700:	80 e0       	ldi	r24, 0x00	; 0
    2702:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    2706:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	enableADCMUX(FALSE);
    270a:	80 e0       	ldi	r24, 0x00	; 0
    270c:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
	ADCPower(FALSE);
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	
}
    2716:	df 91       	pop	r29
    2718:	cf 91       	pop	r28
    271a:	1f 91       	pop	r17
    271c:	0f 91       	pop	r16
    271e:	ff 90       	pop	r15
    2720:	ef 90       	pop	r14
    2722:	df 90       	pop	r13
    2724:	cf 90       	pop	r12
    2726:	bf 90       	pop	r11
    2728:	af 90       	pop	r10
    272a:	9f 90       	pop	r9
    272c:	8f 90       	pop	r8
    272e:	7f 90       	pop	r7
    2730:	6f 90       	pop	r6
    2732:	5f 90       	pop	r5
    2734:	4f 90       	pop	r4
    2736:	08 95       	ret

00002738 <CO_collectSeismic3Channel_continuous>:

void CO_collectSeismic3Channel_continuous(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    2738:	cf 93       	push	r28
    273a:	df 93       	push	r29
    273c:	cd b7       	in	r28, 0x3d	; 61
    273e:	de b7       	in	r29, 0x3e	; 62
    2740:	18 2f       	mov	r17, r24
    2742:	3b 01       	movw	r6, r22
    2744:	54 2e       	mov	r5, r20
    2746:	42 2e       	mov	r4, r18
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2748:	81 e0       	ldi	r24, 0x01	; 1
    274a:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    274e:	85 e0       	ldi	r24, 0x05	; 5
    2750:	f3 01       	movw	r30, r6
    2752:	60 81       	ld	r22, Z
    2754:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2758:	86 e0       	ldi	r24, 0x06	; 6
    275a:	f3 01       	movw	r30, r6
    275c:	61 81       	ldd	r22, Z+1	; 0x01
    275e:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2762:	87 e0       	ldi	r24, 0x07	; 7
    2764:	f3 01       	movw	r30, r6
    2766:	62 81       	ldd	r22, Z+2	; 0x02
    2768:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_filter(filterConfig);
    276c:	81 2f       	mov	r24, r17
    276e:	0e 94 c9 09 	call	0x1392	; 0x1392 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2772:	80 2f       	mov	r24, r16
    2774:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2778:	84 e0       	ldi	r24, 0x04	; 4
    277a:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    277e:	84 e5       	ldi	r24, 0x54	; 84
    2780:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2784:	81 e0       	ldi	r24, 0x01	; 1
    2786:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    278a:	85 e0       	ldi	r24, 0x05	; 5
    278c:	0e 94 6e 09 	call	0x12dc	; 0x12dc <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2790:	e0 ea       	ldi	r30, 0xA0	; 160
    2792:	f6 e0       	ldi	r31, 0x06	; 6
    2794:	82 e0       	ldi	r24, 0x02	; 2
    2796:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2798:	91 e0       	ldi	r25, 0x01	; 1
    279a:	92 83       	std	Z+2, r25	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    279c:	98 e7       	ldi	r25, 0x78	; 120
    279e:	90 93 80 01 	sts	0x0180, r25

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    27a2:	e0 e0       	ldi	r30, 0x00	; 0
    27a4:	f8 e0       	ldi	r31, 0x08	; 8
    27a6:	90 ef       	ldi	r25, 0xF0	; 240
    27a8:	91 83       	std	Z+1, r25	; 0x01
	TCC0.CCA = averagingPtA;
    27aa:	e0 a6       	lds	r30, 0xb0
    27ac:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    27ae:	c2 a6       	lds	r28, 0xb2
    27b0:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    27b2:	a4 a6       	lds	r26, 0xb4
    27b4:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    27b6:	86 a6       	lds	r24, 0xb6
    27b8:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    27ba:	24 2d       	mov	r18, r4
    27bc:	30 e0       	ldi	r19, 0x00	; 0
    27be:	21 50       	subi	r18, 0x01	; 1
    27c0:	30 40       	sbci	r19, 0x00	; 0
    27c2:	26 a3       	lds	r18, 0x56
    27c4:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    27c6:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    27c8:	8f ef       	ldi	r24, 0xFF	; 255
    27ca:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    27cc:	80 81       	ld	r24, Z
    27ce:	80 7f       	andi	r24, 0xF0	; 240
    27d0:	88 60       	ori	r24, 0x08	; 8
    27d2:	80 83       	st	Z, r24

	FRAMAddress = FR_BASEADD;
    27d4:	10 92 3f 40 	sts	0x403F, r1
    27d8:	10 92 40 40 	sts	0x4040, r1
	sampleCount = 0;
    27dc:	10 92 49 40 	sts	0x4049, r1
    27e0:	10 92 4a 40 	sts	0x404A, r1
	SPICount = 0;
    27e4:	10 92 9e 50 	sts	0x509E, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    27e8:	8e eb       	ldi	r24, 0xBE	; 190
    27ea:	91 e2       	ldi	r25, 0x21	; 33
    27ec:	10 92 be 21 	sts	0x21BE, r1
    27f0:	fc 01       	movw	r30, r24
    27f2:	31 97       	sbiw	r30, 0x01	; 1
    27f4:	10 82       	st	Z, r1
    27f6:	02 97       	sbiw	r24, 0x02	; 2
    27f8:	fc 01       	movw	r30, r24
    27fa:	10 82       	st	Z, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    27fc:	e0 ea       	ldi	r30, 0xA0	; 160
    27fe:	f0 e0       	ldi	r31, 0x00	; 0
    2800:	82 81       	ldd	r24, Z+2	; 0x02
    2802:	86 60       	ori	r24, 0x06	; 6
    2804:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2806:	78 94       	sei

	SPICS(TRUE);
    2808:	81 e0       	ldi	r24, 0x01	; 1
    280a:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    280e:	80 e2       	ldi	r24, 0x20	; 32
    2810:	e0 e8       	ldi	r30, 0x80	; 128
    2812:	f6 e0       	ldi	r31, 0x06	; 6
    2814:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2816:	e0 e4       	ldi	r30, 0x40	; 64
    2818:	fa e0       	ldi	r31, 0x0A	; 10
    281a:	83 e2       	ldi	r24, 0x23	; 35
    281c:	81 83       	std	Z+1, r24	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    281e:	80 e2       	ldi	r24, 0x20	; 32
    2820:	90 e0       	ldi	r25, 0x00	; 0
    2822:	05 2c       	mov	r0, r5
    2824:	02 c0       	rjmp	.+4      	; 0x282a <CO_collectSeismic3Channel_continuous+0xf2>
    2826:	88 0f       	add	r24, r24
    2828:	99 1f       	adc	r25, r25
    282a:	0a 94       	dec	r0
    282c:	e2 f7       	brpl	.-8      	; 0x2826 <CO_collectSeismic3Channel_continuous+0xee>
    282e:	86 a3       	lds	r24, 0x56
    2830:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2832:	80 e1       	ldi	r24, 0x10	; 16
    2834:	90 e0       	ldi	r25, 0x00	; 0
    2836:	02 c0       	rjmp	.+4      	; 0x283c <CO_collectSeismic3Channel_continuous+0x104>
    2838:	88 0f       	add	r24, r24
    283a:	99 1f       	adc	r25, r25
    283c:	5a 94       	dec	r5
    283e:	e2 f7       	brpl	.-8      	; 0x2838 <CO_collectSeismic3Channel_continuous+0x100>
    2840:	82 af       	sts	0x72, r24
    2842:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2844:	80 81       	ld	r24, Z
    2846:	80 7f       	andi	r24, 0xF0	; 240
    2848:	81 60       	ori	r24, 0x01	; 1
    284a:	80 83       	st	Z, r24
	
	// collect samples from ADC continuously 
	while(1){
	nop();
    284c:	00 00       	nop
    284e:	fe cf       	rjmp	.-4      	; 0x284c <CO_collectSeismic3Channel_continuous+0x114>

00002850 <CO_collectSeismic1Channel>:
}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain,
	uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable,
	uint16_t averagingPtA, uint16_t averagingPtB, uint16_t averagingPtC,
	uint16_t averagingPtD) {
    2850:	6f 92       	push	r6
    2852:	7f 92       	push	r7
    2854:	8f 92       	push	r8
    2856:	9f 92       	push	r9
    2858:	af 92       	push	r10
    285a:	bf 92       	push	r11
    285c:	cf 92       	push	r12
    285e:	df 92       	push	r13
    2860:	ef 92       	push	r14
    2862:	ff 92       	push	r15
    2864:	0f 93       	push	r16
    2866:	1f 93       	push	r17
    2868:	cf 93       	push	r28
    286a:	df 93       	push	r29
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	18 2f       	mov	r17, r24
    2872:	76 2e       	mov	r7, r22
    2874:	f4 2e       	mov	r15, r20
    2876:	62 2e       	mov	r6, r18
				
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2878:	81 e0       	ldi	r24, 0x01	; 1
    287a:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	
	// Set gains, filters, and input channel	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    287e:	81 2f       	mov	r24, r17
    2880:	6f 2d       	mov	r22, r15
    2882:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <set_ampGain>
	set_filter(filterConfig);
    2886:	87 2d       	mov	r24, r7
    2888:	0e 94 c9 09 	call	0x1392	; 0x1392 <set_filter>
	ACC_DCPassEnable(DCPassEnable);	
    288c:	8e 2d       	mov	r24, r14
    288e:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2892:	84 e0       	ldi	r24, 0x04	; 4
    2894:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2898:	84 e5       	ldi	r24, 0x54	; 84
    289a:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    289e:	81 e0       	ldi	r24, 0x01	; 1
    28a0:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
	setADCInput(channel);
    28a4:	81 2f       	mov	r24, r17
    28a6:	0e 94 6e 09 	call	0x12dc	; 0x12dc <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    28aa:	e0 ea       	ldi	r30, 0xA0	; 160
    28ac:	f6 e0       	ldi	r31, 0x06	; 6
    28ae:	82 e0       	ldi	r24, 0x02	; 2
    28b0:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    28b2:	91 e0       	ldi	r25, 0x01	; 1
    28b4:	92 83       	std	Z+2, r25	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    28b6:	98 e7       	ldi	r25, 0x78	; 120
    28b8:	90 93 80 01 	sts	0x0180, r25

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    28bc:	e0 e0       	ldi	r30, 0x00	; 0
    28be:	f9 e0       	ldi	r31, 0x09	; 9
    28c0:	90 ef       	ldi	r25, 0xF0	; 240
    28c2:	91 83       	std	Z+1, r25	; 0x01
	TCD0.CCA = averagingPtA;
    28c4:	c0 a6       	lds	r28, 0xb0
    28c6:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    28c8:	a2 a6       	lds	r26, 0xb2
    28ca:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    28cc:	84 a6       	lds	r24, 0xb4
    28ce:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    28d0:	2a 89       	ldd	r18, Y+18	; 0x12
    28d2:	3b 89       	ldd	r19, Y+19	; 0x13
    28d4:	26 a7       	lds	r18, 0x76
    28d6:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    28d8:	10 e0       	ldi	r17, 0x00	; 0
    28da:	01 50       	subi	r16, 0x01	; 1
    28dc:	10 40       	sbci	r17, 0x00	; 0
    28de:	06 a3       	lds	r16, 0x56
    28e0:	17 a3       	lds	r17, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    28e2:	86 83       	std	Z+6, r24	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    28e4:	8f ef       	ldi	r24, 0xFF	; 255
    28e6:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    28e8:	80 81       	ld	r24, Z
    28ea:	80 7f       	andi	r24, 0xF0	; 240
    28ec:	88 60       	ori	r24, 0x08	; 8
    28ee:	80 83       	st	Z, r24

	FRAMAddress = FR_BASEADD;
    28f0:	10 92 3f 40 	sts	0x403F, r1
    28f4:	10 92 40 40 	sts	0x4040, r1
	sampleCount = 0;
    28f8:	10 92 49 40 	sts	0x4049, r1
    28fc:	10 92 4a 40 	sts	0x404A, r1
	SPICount = 0;
    2900:	10 92 9e 50 	sts	0x509E, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;	
    2904:	8e eb       	ldi	r24, 0xBE	; 190
    2906:	91 e2       	ldi	r25, 0x21	; 33
    2908:	10 92 be 21 	sts	0x21BE, r1
    290c:	fc 01       	movw	r30, r24
    290e:	31 97       	sbiw	r30, 0x01	; 1
    2910:	10 82       	st	Z, r1
    2912:	02 97       	sbiw	r24, 0x02	; 2
    2914:	fc 01       	movw	r30, r24
    2916:	10 82       	st	Z, r1
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2918:	e0 ea       	ldi	r30, 0xA0	; 160
    291a:	f0 e0       	ldi	r31, 0x00	; 0
    291c:	82 81       	ldd	r24, Z+2	; 0x02
    291e:	86 60       	ori	r24, 0x06	; 6
    2920:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2922:	78 94       	sei

	SPICS(TRUE);
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    292a:	80 e2       	ldi	r24, 0x20	; 32
    292c:	e0 e8       	ldi	r30, 0x80	; 128
    292e:	f6 e0       	ldi	r31, 0x06	; 6
    2930:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2932:	e0 e4       	ldi	r30, 0x40	; 64
    2934:	fa e0       	ldi	r31, 0x0A	; 10
    2936:	83 e2       	ldi	r24, 0x23	; 35
    2938:	81 83       	std	Z+1, r24	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    293a:	80 e2       	ldi	r24, 0x20	; 32
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	06 2c       	mov	r0, r6
    2940:	02 c0       	rjmp	.+4      	; 0x2946 <CO_collectSeismic1Channel+0xf6>
    2942:	88 0f       	add	r24, r24
    2944:	99 1f       	adc	r25, r25
    2946:	0a 94       	dec	r0
    2948:	e2 f7       	brpl	.-8      	; 0x2942 <CO_collectSeismic1Channel+0xf2>
    294a:	86 a3       	lds	r24, 0x56
    294c:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    294e:	80 e1       	ldi	r24, 0x10	; 16
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	9c 01       	movw	r18, r24
    2954:	02 c0       	rjmp	.+4      	; 0x295a <CO_collectSeismic1Channel+0x10a>
    2956:	22 0f       	add	r18, r18
    2958:	33 1f       	adc	r19, r19
    295a:	6a 94       	dec	r6
    295c:	e2 f7       	brpl	.-8      	; 0x2956 <CO_collectSeismic1Channel+0x106>
    295e:	22 af       	sts	0x72, r18
    2960:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2962:	80 81       	ld	r24, Z
    2964:	80 7f       	andi	r24, 0xF0	; 240
    2966:	81 60       	ori	r24, 0x01	; 1
    2968:	80 83       	st	Z, r24
			
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);	
    296a:	80 91 49 40 	lds	r24, 0x4049
    296e:	90 91 4a 40 	lds	r25, 0x404A
    2972:	35 e5       	ldi	r19, 0x55	; 85
    2974:	83 35       	cpi	r24, 0x53	; 83
    2976:	93 07       	cpc	r25, r19
    2978:	c0 f3       	brcs	.-16     	; 0x296a <CO_collectSeismic1Channel+0x11a>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    297a:	e0 e0       	ldi	r30, 0x00	; 0
    297c:	f9 e0       	ldi	r31, 0x09	; 9
    297e:	80 81       	ld	r24, Z
    2980:	80 7f       	andi	r24, 0xF0	; 240
    2982:	80 83       	st	Z, r24
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2984:	e0 e4       	ldi	r30, 0x40	; 64
    2986:	fa e0       	ldi	r31, 0x0A	; 10
    2988:	80 81       	ld	r24, Z
    298a:	80 7f       	andi	r24, 0xF0	; 240
    298c:	80 83       	st	Z, r24
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);	
    298e:	e0 ea       	ldi	r30, 0xA0	; 160
    2990:	f0 e0       	ldi	r31, 0x00	; 0
    2992:	82 81       	ldd	r24, Z+2	; 0x02
    2994:	89 7f       	andi	r24, 0xF9	; 249
    2996:	82 83       	std	Z+2, r24	; 0x02
	cli();
    2998:	f8 94       	cli

	SPICS(FALSE);
    299a:	80 e0       	ldi	r24, 0x00	; 0
    299c:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    29a0:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	enableADCMUX(FALSE);
    29a4:	80 e0       	ldi	r24, 0x00	; 0
    29a6:	0e 94 48 09 	call	0x1290	; 0x1290 <enableADCMUX>
	ADCPower(FALSE);
    29aa:	80 e0       	ldi	r24, 0x00	; 0
    29ac:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	
}
    29b0:	df 91       	pop	r29
    29b2:	cf 91       	pop	r28
    29b4:	1f 91       	pop	r17
    29b6:	0f 91       	pop	r16
    29b8:	ff 90       	pop	r15
    29ba:	ef 90       	pop	r14
    29bc:	df 90       	pop	r13
    29be:	cf 90       	pop	r12
    29c0:	bf 90       	pop	r11
    29c2:	af 90       	pop	r10
    29c4:	9f 90       	pop	r9
    29c6:	8f 90       	pop	r8
    29c8:	7f 90       	pop	r7
    29ca:	6f 90       	pop	r6
    29cc:	08 95       	ret

000029ce <sampleCurrentChannel>:
ISR(TCD0_OVF_vect) {
	writeSE2FRAM();
}

void sampleCurrentChannel() {
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    29ce:	82 e0       	ldi	r24, 0x02	; 2
    29d0:	e0 ea       	ldi	r30, 0xA0	; 160
    29d2:	f6 e0       	ldi	r31, 0x06	; 6
    29d4:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    29d6:	8a ea       	ldi	r24, 0xAA	; 170
    29d8:	e0 ec       	ldi	r30, 0xC0	; 192
    29da:	f8 e0       	ldi	r31, 0x08	; 8
    29dc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29de:	82 81       	ldd	r24, Z+2	; 0x02
    29e0:	88 23       	and	r24, r24
    29e2:	ec f7       	brge	.-6      	; 0x29de <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    29e4:	90 91 9e 50 	lds	r25, 0x509E
    29e8:	e0 ec       	ldi	r30, 0xC0	; 192
    29ea:	f8 e0       	ldi	r31, 0x08	; 8
    29ec:	83 81       	ldd	r24, Z+3	; 0x03
    29ee:	a7 e6       	ldi	r26, 0x67	; 103
    29f0:	b0 e5       	ldi	r27, 0x50	; 80
    29f2:	a9 0f       	add	r26, r25
    29f4:	b1 1d       	adc	r27, r1
    29f6:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    29f8:	8a ea       	ldi	r24, 0xAA	; 170
    29fa:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29fc:	82 81       	ldd	r24, Z+2	; 0x02
    29fe:	88 23       	and	r24, r24
    2a00:	ec f7       	brge	.-6      	; 0x29fc <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2a02:	a0 91 9e 50 	lds	r26, 0x509E
    2a06:	b0 e0       	ldi	r27, 0x00	; 0
    2a08:	e0 ec       	ldi	r30, 0xC0	; 192
    2a0a:	f8 e0       	ldi	r31, 0x08	; 8
    2a0c:	83 81       	ldd	r24, Z+3	; 0x03
    2a0e:	a8 59       	subi	r26, 0x98	; 152
    2a10:	bf 4a       	sbci	r27, 0xAF	; 175
    2a12:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2a14:	8a ea       	ldi	r24, 0xAA	; 170
    2a16:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a18:	82 81       	ldd	r24, Z+2	; 0x02
    2a1a:	88 23       	and	r24, r24
    2a1c:	ec f7       	brge	.-6      	; 0x2a18 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2a1e:	e0 91 9e 50 	lds	r30, 0x509E
    2a22:	f0 e0       	ldi	r31, 0x00	; 0
    2a24:	a0 ec       	ldi	r26, 0xC0	; 192
    2a26:	b8 e0       	ldi	r27, 0x08	; 8
    2a28:	13 96       	adiw	r26, 0x03	; 3
    2a2a:	8c 91       	ld	r24, X
    2a2c:	13 97       	sbiw	r26, 0x03	; 3
    2a2e:	e7 59       	subi	r30, 0x97	; 151
    2a30:	ff 4a       	sbci	r31, 0xAF	; 175
    2a32:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2a34:	82 e0       	ldi	r24, 0x02	; 2
    2a36:	e0 ea       	ldi	r30, 0xA0	; 160
    2a38:	f6 e0       	ldi	r31, 0x06	; 6
    2a3a:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    2a3c:	80 91 9e 50 	lds	r24, 0x509E
    2a40:	8d 5f       	subi	r24, 0xFD	; 253
    2a42:	80 93 9e 50 	sts	0x509E, r24
}
    2a46:	08 95       	ret

00002a48 <__vector_82>:

ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

ISR(TCD0_CCD_vect) {
    2a48:	1f 92       	push	r1
    2a4a:	0f 92       	push	r0
    2a4c:	0f b6       	in	r0, 0x3f	; 63
    2a4e:	0f 92       	push	r0
    2a50:	0b b6       	in	r0, 0x3b	; 59
    2a52:	0f 92       	push	r0
    2a54:	11 24       	eor	r1, r1
    2a56:	2f 93       	push	r18
    2a58:	3f 93       	push	r19
    2a5a:	4f 93       	push	r20
    2a5c:	5f 93       	push	r21
    2a5e:	6f 93       	push	r22
    2a60:	7f 93       	push	r23
    2a62:	8f 93       	push	r24
    2a64:	9f 93       	push	r25
    2a66:	af 93       	push	r26
    2a68:	bf 93       	push	r27
    2a6a:	ef 93       	push	r30
    2a6c:	ff 93       	push	r31
	sampleCurrentChannel();
    2a6e:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
	SPICount = 0;		
    2a72:	10 92 9e 50 	sts	0x509E, r1
}
    2a76:	ff 91       	pop	r31
    2a78:	ef 91       	pop	r30
    2a7a:	bf 91       	pop	r27
    2a7c:	af 91       	pop	r26
    2a7e:	9f 91       	pop	r25
    2a80:	8f 91       	pop	r24
    2a82:	7f 91       	pop	r23
    2a84:	6f 91       	pop	r22
    2a86:	5f 91       	pop	r21
    2a88:	4f 91       	pop	r20
    2a8a:	3f 91       	pop	r19
    2a8c:	2f 91       	pop	r18
    2a8e:	0f 90       	pop	r0
    2a90:	0b be       	out	0x3b, r0	; 59
    2a92:	0f 90       	pop	r0
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	0f 90       	pop	r0
    2a98:	1f 90       	pop	r1
    2a9a:	18 95       	reti

00002a9c <__vector_81>:

ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

ISR(TCD0_CCC_vect) {
    2a9c:	1f 92       	push	r1
    2a9e:	0f 92       	push	r0
    2aa0:	0f b6       	in	r0, 0x3f	; 63
    2aa2:	0f 92       	push	r0
    2aa4:	0b b6       	in	r0, 0x3b	; 59
    2aa6:	0f 92       	push	r0
    2aa8:	11 24       	eor	r1, r1
    2aaa:	2f 93       	push	r18
    2aac:	3f 93       	push	r19
    2aae:	4f 93       	push	r20
    2ab0:	5f 93       	push	r21
    2ab2:	6f 93       	push	r22
    2ab4:	7f 93       	push	r23
    2ab6:	8f 93       	push	r24
    2ab8:	9f 93       	push	r25
    2aba:	af 93       	push	r26
    2abc:	bf 93       	push	r27
    2abe:	ef 93       	push	r30
    2ac0:	ff 93       	push	r31
	sampleCurrentChannel();
    2ac2:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
}
    2ac6:	ff 91       	pop	r31
    2ac8:	ef 91       	pop	r30
    2aca:	bf 91       	pop	r27
    2acc:	af 91       	pop	r26
    2ace:	9f 91       	pop	r25
    2ad0:	8f 91       	pop	r24
    2ad2:	7f 91       	pop	r23
    2ad4:	6f 91       	pop	r22
    2ad6:	5f 91       	pop	r21
    2ad8:	4f 91       	pop	r20
    2ada:	3f 91       	pop	r19
    2adc:	2f 91       	pop	r18
    2ade:	0f 90       	pop	r0
    2ae0:	0b be       	out	0x3b, r0	; 59
    2ae2:	0f 90       	pop	r0
    2ae4:	0f be       	out	0x3f, r0	; 63
    2ae6:	0f 90       	pop	r0
    2ae8:	1f 90       	pop	r1
    2aea:	18 95       	reti

00002aec <__vector_80>:

ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}

ISR(TCD0_CCB_vect) {
    2aec:	1f 92       	push	r1
    2aee:	0f 92       	push	r0
    2af0:	0f b6       	in	r0, 0x3f	; 63
    2af2:	0f 92       	push	r0
    2af4:	0b b6       	in	r0, 0x3b	; 59
    2af6:	0f 92       	push	r0
    2af8:	11 24       	eor	r1, r1
    2afa:	2f 93       	push	r18
    2afc:	3f 93       	push	r19
    2afe:	4f 93       	push	r20
    2b00:	5f 93       	push	r21
    2b02:	6f 93       	push	r22
    2b04:	7f 93       	push	r23
    2b06:	8f 93       	push	r24
    2b08:	9f 93       	push	r25
    2b0a:	af 93       	push	r26
    2b0c:	bf 93       	push	r27
    2b0e:	ef 93       	push	r30
    2b10:	ff 93       	push	r31
	sampleCurrentChannel();
    2b12:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
}
    2b16:	ff 91       	pop	r31
    2b18:	ef 91       	pop	r30
    2b1a:	bf 91       	pop	r27
    2b1c:	af 91       	pop	r26
    2b1e:	9f 91       	pop	r25
    2b20:	8f 91       	pop	r24
    2b22:	7f 91       	pop	r23
    2b24:	6f 91       	pop	r22
    2b26:	5f 91       	pop	r21
    2b28:	4f 91       	pop	r20
    2b2a:	3f 91       	pop	r19
    2b2c:	2f 91       	pop	r18
    2b2e:	0f 90       	pop	r0
    2b30:	0b be       	out	0x3b, r0	; 59
    2b32:	0f 90       	pop	r0
    2b34:	0f be       	out	0x3f, r0	; 63
    2b36:	0f 90       	pop	r0
    2b38:	1f 90       	pop	r1
    2b3a:	18 95       	reti

00002b3c <__vector_79>:
	enableADCMUX(FALSE);
	ADCPower(FALSE);
	
}

ISR(TCD0_CCA_vect) {
    2b3c:	1f 92       	push	r1
    2b3e:	0f 92       	push	r0
    2b40:	0f b6       	in	r0, 0x3f	; 63
    2b42:	0f 92       	push	r0
    2b44:	0b b6       	in	r0, 0x3b	; 59
    2b46:	0f 92       	push	r0
    2b48:	11 24       	eor	r1, r1
    2b4a:	2f 93       	push	r18
    2b4c:	3f 93       	push	r19
    2b4e:	4f 93       	push	r20
    2b50:	5f 93       	push	r21
    2b52:	6f 93       	push	r22
    2b54:	7f 93       	push	r23
    2b56:	8f 93       	push	r24
    2b58:	9f 93       	push	r25
    2b5a:	af 93       	push	r26
    2b5c:	bf 93       	push	r27
    2b5e:	ef 93       	push	r30
    2b60:	ff 93       	push	r31
	sampleCurrentChannel();
    2b62:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
}
    2b66:	ff 91       	pop	r31
    2b68:	ef 91       	pop	r30
    2b6a:	bf 91       	pop	r27
    2b6c:	af 91       	pop	r26
    2b6e:	9f 91       	pop	r25
    2b70:	8f 91       	pop	r24
    2b72:	7f 91       	pop	r23
    2b74:	6f 91       	pop	r22
    2b76:	5f 91       	pop	r21
    2b78:	4f 91       	pop	r20
    2b7a:	3f 91       	pop	r19
    2b7c:	2f 91       	pop	r18
    2b7e:	0f 90       	pop	r0
    2b80:	0b be       	out	0x3b, r0	; 59
    2b82:	0f 90       	pop	r0
    2b84:	0f be       	out	0x3f, r0	; 63
    2b86:	0f 90       	pop	r0
    2b88:	1f 90       	pop	r1
    2b8a:	18 95       	reti

00002b8c <__vector_19>:

ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

ISR(TCC0_CCD_vect) {
    2b8c:	1f 92       	push	r1
    2b8e:	0f 92       	push	r0
    2b90:	0f b6       	in	r0, 0x3f	; 63
    2b92:	0f 92       	push	r0
    2b94:	0b b6       	in	r0, 0x3b	; 59
    2b96:	0f 92       	push	r0
    2b98:	11 24       	eor	r1, r1
    2b9a:	2f 93       	push	r18
    2b9c:	3f 93       	push	r19
    2b9e:	4f 93       	push	r20
    2ba0:	5f 93       	push	r21
    2ba2:	6f 93       	push	r22
    2ba4:	7f 93       	push	r23
    2ba6:	8f 93       	push	r24
    2ba8:	9f 93       	push	r25
    2baa:	af 93       	push	r26
    2bac:	bf 93       	push	r27
    2bae:	ef 93       	push	r30
    2bb0:	ff 93       	push	r31
	sampleCurrentChannel();
    2bb2:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
	SPICount = 0;
    2bb6:	10 92 9e 50 	sts	0x509E, r1
	if(PORTB.OUT & PIN1_bm) {
    2bba:	e0 e2       	ldi	r30, 0x20	; 32
    2bbc:	f6 e0       	ldi	r31, 0x06	; 6
    2bbe:	84 81       	ldd	r24, Z+4	; 0x04
    2bc0:	81 ff       	sbrs	r24, 1
    2bc2:	0f c0       	rjmp	.+30     	; 0x2be2 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2bc4:	e0 e0       	ldi	r30, 0x00	; 0
    2bc6:	f6 e0       	ldi	r31, 0x06	; 6
    2bc8:	84 81       	ldd	r24, Z+4	; 0x04
    2bca:	86 ff       	sbrs	r24, 6
    2bcc:	05 c0       	rjmp	.+10     	; 0x2bd8 <__vector_19+0x4c>
    2bce:	82 e0       	ldi	r24, 0x02	; 2
    2bd0:	e0 e2       	ldi	r30, 0x20	; 32
    2bd2:	f6 e0       	ldi	r31, 0x06	; 6
    2bd4:	87 83       	std	Z+7, r24	; 0x07
    2bd6:	0d c0       	rjmp	.+26     	; 0x2bf2 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    2bd8:	80 e4       	ldi	r24, 0x40	; 64
    2bda:	e0 e0       	ldi	r30, 0x00	; 0
    2bdc:	f6 e0       	ldi	r31, 0x06	; 6
    2bde:	87 83       	std	Z+7, r24	; 0x07
    2be0:	08 c0       	rjmp	.+16     	; 0x2bf2 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2be2:	80 e4       	ldi	r24, 0x40	; 64
    2be4:	e0 e0       	ldi	r30, 0x00	; 0
    2be6:	f6 e0       	ldi	r31, 0x06	; 6
    2be8:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2bea:	82 e0       	ldi	r24, 0x02	; 2
    2bec:	e0 e2       	ldi	r30, 0x20	; 32
    2bee:	f6 e0       	ldi	r31, 0x06	; 6
    2bf0:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    2bf2:	ff 91       	pop	r31
    2bf4:	ef 91       	pop	r30
    2bf6:	bf 91       	pop	r27
    2bf8:	af 91       	pop	r26
    2bfa:	9f 91       	pop	r25
    2bfc:	8f 91       	pop	r24
    2bfe:	7f 91       	pop	r23
    2c00:	6f 91       	pop	r22
    2c02:	5f 91       	pop	r21
    2c04:	4f 91       	pop	r20
    2c06:	3f 91       	pop	r19
    2c08:	2f 91       	pop	r18
    2c0a:	0f 90       	pop	r0
    2c0c:	0b be       	out	0x3b, r0	; 59
    2c0e:	0f 90       	pop	r0
    2c10:	0f be       	out	0x3f, r0	; 63
    2c12:	0f 90       	pop	r0
    2c14:	1f 90       	pop	r1
    2c16:	18 95       	reti

00002c18 <__vector_18>:

ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

ISR(TCC0_CCC_vect) {
    2c18:	1f 92       	push	r1
    2c1a:	0f 92       	push	r0
    2c1c:	0f b6       	in	r0, 0x3f	; 63
    2c1e:	0f 92       	push	r0
    2c20:	0b b6       	in	r0, 0x3b	; 59
    2c22:	0f 92       	push	r0
    2c24:	11 24       	eor	r1, r1
    2c26:	2f 93       	push	r18
    2c28:	3f 93       	push	r19
    2c2a:	4f 93       	push	r20
    2c2c:	5f 93       	push	r21
    2c2e:	6f 93       	push	r22
    2c30:	7f 93       	push	r23
    2c32:	8f 93       	push	r24
    2c34:	9f 93       	push	r25
    2c36:	af 93       	push	r26
    2c38:	bf 93       	push	r27
    2c3a:	ef 93       	push	r30
    2c3c:	ff 93       	push	r31
	sampleCurrentChannel();
    2c3e:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
}
    2c42:	ff 91       	pop	r31
    2c44:	ef 91       	pop	r30
    2c46:	bf 91       	pop	r27
    2c48:	af 91       	pop	r26
    2c4a:	9f 91       	pop	r25
    2c4c:	8f 91       	pop	r24
    2c4e:	7f 91       	pop	r23
    2c50:	6f 91       	pop	r22
    2c52:	5f 91       	pop	r21
    2c54:	4f 91       	pop	r20
    2c56:	3f 91       	pop	r19
    2c58:	2f 91       	pop	r18
    2c5a:	0f 90       	pop	r0
    2c5c:	0b be       	out	0x3b, r0	; 59
    2c5e:	0f 90       	pop	r0
    2c60:	0f be       	out	0x3f, r0	; 63
    2c62:	0f 90       	pop	r0
    2c64:	1f 90       	pop	r1
    2c66:	18 95       	reti

00002c68 <__vector_17>:

ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

ISR(TCC0_CCB_vect) {
    2c68:	1f 92       	push	r1
    2c6a:	0f 92       	push	r0
    2c6c:	0f b6       	in	r0, 0x3f	; 63
    2c6e:	0f 92       	push	r0
    2c70:	0b b6       	in	r0, 0x3b	; 59
    2c72:	0f 92       	push	r0
    2c74:	11 24       	eor	r1, r1
    2c76:	2f 93       	push	r18
    2c78:	3f 93       	push	r19
    2c7a:	4f 93       	push	r20
    2c7c:	5f 93       	push	r21
    2c7e:	6f 93       	push	r22
    2c80:	7f 93       	push	r23
    2c82:	8f 93       	push	r24
    2c84:	9f 93       	push	r25
    2c86:	af 93       	push	r26
    2c88:	bf 93       	push	r27
    2c8a:	ef 93       	push	r30
    2c8c:	ff 93       	push	r31
	sampleCurrentChannel();
    2c8e:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
}
    2c92:	ff 91       	pop	r31
    2c94:	ef 91       	pop	r30
    2c96:	bf 91       	pop	r27
    2c98:	af 91       	pop	r26
    2c9a:	9f 91       	pop	r25
    2c9c:	8f 91       	pop	r24
    2c9e:	7f 91       	pop	r23
    2ca0:	6f 91       	pop	r22
    2ca2:	5f 91       	pop	r21
    2ca4:	4f 91       	pop	r20
    2ca6:	3f 91       	pop	r19
    2ca8:	2f 91       	pop	r18
    2caa:	0f 90       	pop	r0
    2cac:	0b be       	out	0x3b, r0	; 59
    2cae:	0f 90       	pop	r0
    2cb0:	0f be       	out	0x3f, r0	; 63
    2cb2:	0f 90       	pop	r0
    2cb4:	1f 90       	pop	r1
    2cb6:	18 95       	reti

00002cb8 <__vector_16>:
	nop();
	}	
}


ISR(TCC0_CCA_vect) {
    2cb8:	1f 92       	push	r1
    2cba:	0f 92       	push	r0
    2cbc:	0f b6       	in	r0, 0x3f	; 63
    2cbe:	0f 92       	push	r0
    2cc0:	0b b6       	in	r0, 0x3b	; 59
    2cc2:	0f 92       	push	r0
    2cc4:	11 24       	eor	r1, r1
    2cc6:	2f 93       	push	r18
    2cc8:	3f 93       	push	r19
    2cca:	4f 93       	push	r20
    2ccc:	5f 93       	push	r21
    2cce:	6f 93       	push	r22
    2cd0:	7f 93       	push	r23
    2cd2:	8f 93       	push	r24
    2cd4:	9f 93       	push	r25
    2cd6:	af 93       	push	r26
    2cd8:	bf 93       	push	r27
    2cda:	ef 93       	push	r30
    2cdc:	ff 93       	push	r31
	sampleCurrentChannel();
    2cde:	0e 94 e7 14 	call	0x29ce	; 0x29ce <sampleCurrentChannel>
}
    2ce2:	ff 91       	pop	r31
    2ce4:	ef 91       	pop	r30
    2ce6:	bf 91       	pop	r27
    2ce8:	af 91       	pop	r26
    2cea:	9f 91       	pop	r25
    2cec:	8f 91       	pop	r24
    2cee:	7f 91       	pop	r23
    2cf0:	6f 91       	pop	r22
    2cf2:	5f 91       	pop	r21
    2cf4:	4f 91       	pop	r20
    2cf6:	3f 91       	pop	r19
    2cf8:	2f 91       	pop	r18
    2cfa:	0f 90       	pop	r0
    2cfc:	0b be       	out	0x3b, r0	; 59
    2cfe:	0f 90       	pop	r0
    2d00:	0f be       	out	0x3f, r0	; 63
    2d02:	0f 90       	pop	r0
    2d04:	1f 90       	pop	r1
    2d06:	18 95       	reti

00002d08 <writeSE2FRAM>:
	SPIBuffer[SPICount+2] = SPIC.DATA;
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

void writeSE2FRAM() {
    2d08:	ff 92       	push	r15
    2d0a:	0f 93       	push	r16
    2d0c:	1f 93       	push	r17
    2d0e:	cf 93       	push	r28
    2d10:	df 93       	push	r29
    2d12:	cd b7       	in	r28, 0x3d	; 61
    2d14:	de b7       	in	r29, 0x3e	; 62
    2d16:	28 97       	sbiw	r28, 0x08	; 8
    2d18:	cd bf       	out	0x3d, r28	; 61
    2d1a:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2d1c:	19 82       	std	Y+1, r1	; 0x01
    2d1e:	1a 82       	std	Y+2, r1	; 0x02
    2d20:	1b 82       	std	Y+3, r1	; 0x03
    2d22:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2d24:	80 91 49 40 	lds	r24, 0x4049
    2d28:	90 91 4a 40 	lds	r25, 0x404A
    2d2c:	01 96       	adiw	r24, 0x01	; 1
    2d2e:	80 93 49 40 	sts	0x4049, r24
    2d32:	90 93 4a 40 	sts	0x404A, r25
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2d36:	80 ed       	ldi	r24, 0xD0	; 208
    2d38:	80 93 c0 08 	sts	0x08C0, r24
    2d3c:	20 e0       	ldi	r18, 0x00	; 0
    2d3e:	30 e0       	ldi	r19, 0x00	; 0
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2d40:	07 e6       	ldi	r16, 0x67	; 103
    2d42:	10 e5       	ldi	r17, 0x50	; 80
    2d44:	ff 24       	eor	r15, r15
    2d46:	fa 94       	dec	r15
    2d48:	c9 01       	movw	r24, r18
    2d4a:	f8 01       	movw	r30, r16
    2d4c:	e2 0f       	add	r30, r18
    2d4e:	f3 1f       	adc	r31, r19
    2d50:	40 81       	ld	r20, Z
    2d52:	44 23       	and	r20, r20
    2d54:	14 f4       	brge	.+4      	; 0x2d5a <writeSE2FRAM+0x52>
    2d56:	f8 86       	std	Y+8, r15	; 0x08
    2d58:	01 c0       	rjmp	.+2      	; 0x2d5c <writeSE2FRAM+0x54>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2d5a:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2d5c:	80 0f       	add	r24, r16
    2d5e:	91 1f       	adc	r25, r17
    2d60:	fc 01       	movw	r30, r24
    2d62:	80 81       	ld	r24, Z
    2d64:	8f 83       	std	Y+7, r24	; 0x07
	SPIBuffer[SPICount+2] = SPIC.DATA;
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

void writeSE2FRAM() {
    2d66:	f9 01       	movw	r30, r18
    2d68:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2d6a:	e0 0f       	add	r30, r16
    2d6c:	f1 1f       	adc	r31, r17
    2d6e:	80 81       	ld	r24, Z
    2d70:	8e 83       	std	Y+6, r24	; 0x06
	SPIBuffer[SPICount+2] = SPIC.DATA;
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

void writeSE2FRAM() {
    2d72:	f9 01       	movw	r30, r18
    2d74:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2d76:	e0 0f       	add	r30, r16
    2d78:	f1 1f       	adc	r31, r17
    2d7a:	80 81       	ld	r24, Z
    2d7c:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    2d7e:	49 81       	ldd	r20, Y+1	; 0x01
    2d80:	5a 81       	ldd	r21, Y+2	; 0x02
    2d82:	6b 81       	ldd	r22, Y+3	; 0x03
    2d84:	7c 81       	ldd	r23, Y+4	; 0x04
    2d86:	8d 81       	ldd	r24, Y+5	; 0x05
    2d88:	9e 81       	ldd	r25, Y+6	; 0x06
    2d8a:	af 81       	ldd	r26, Y+7	; 0x07
    2d8c:	b8 85       	ldd	r27, Y+8	; 0x08
    2d8e:	84 0f       	add	r24, r20
    2d90:	95 1f       	adc	r25, r21
    2d92:	a6 1f       	adc	r26, r22
    2d94:	b7 1f       	adc	r27, r23
    2d96:	89 83       	std	Y+1, r24	; 0x01
    2d98:	9a 83       	std	Y+2, r25	; 0x02
    2d9a:	ab 83       	std	Y+3, r26	; 0x03
    2d9c:	bc 83       	std	Y+4, r27	; 0x04
    2d9e:	2d 5f       	subi	r18, 0xFD	; 253
    2da0:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2da2:	2c 30       	cpi	r18, 0x0C	; 12
    2da4:	31 05       	cpc	r19, r1
    2da6:	81 f6       	brne	.-96     	; 0x2d48 <writeSE2FRAM+0x40>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2da8:	69 81       	ldd	r22, Y+1	; 0x01
    2daa:	7a 81       	ldd	r23, Y+2	; 0x02
    2dac:	8b 81       	ldd	r24, Y+3	; 0x03
    2dae:	9c 81       	ldd	r25, Y+4	; 0x04
    2db0:	24 e0       	ldi	r18, 0x04	; 4
    2db2:	30 e0       	ldi	r19, 0x00	; 0
    2db4:	40 e0       	ldi	r20, 0x00	; 0
    2db6:	50 e0       	ldi	r21, 0x00	; 0
    2db8:	0e 94 e4 34 	call	0x69c8	; 0x69c8 <__divmodsi4>
    2dbc:	29 83       	std	Y+1, r18	; 0x01
    2dbe:	3a 83       	std	Y+2, r19	; 0x02
    2dc0:	4b 83       	std	Y+3, r20	; 0x03
    2dc2:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2dc4:	29 81       	ldd	r18, Y+1	; 0x01
    2dc6:	89 e6       	ldi	r24, 0x69	; 105
    2dc8:	90 e5       	ldi	r25, 0x50	; 80
    2dca:	20 93 69 50 	sts	0x5069, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2dce:	2a 81       	ldd	r18, Y+2	; 0x02
    2dd0:	fc 01       	movw	r30, r24
    2dd2:	31 97       	sbiw	r30, 0x01	; 1
    2dd4:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);	
    2dd6:	2b 81       	ldd	r18, Y+3	; 0x03
    2dd8:	02 97       	sbiw	r24, 0x02	; 2
    2dda:	fc 01       	movw	r30, r24
    2ddc:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2dde:	80 e1       	ldi	r24, 0x10	; 16
    2de0:	e0 e4       	ldi	r30, 0x40	; 64
    2de2:	f6 e0       	ldi	r31, 0x06	; 6
    2de4:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2de6:	88 e0       	ldi	r24, 0x08	; 8
    2de8:	e0 e2       	ldi	r30, 0x20	; 32
    2dea:	f6 e0       	ldi	r31, 0x06	; 6
    2dec:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2dee:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2df0:	86 e0       	ldi	r24, 0x06	; 6
    2df2:	e0 ec       	ldi	r30, 0xC0	; 192
    2df4:	f8 e0       	ldi	r31, 0x08	; 8
    2df6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2df8:	82 81       	ldd	r24, Z+2	; 0x02
    2dfa:	88 23       	and	r24, r24
    2dfc:	ec f7       	brge	.-6      	; 0x2df8 <writeSE2FRAM+0xf0>
	SPIBuffer[12] = SPIC.DATA;
    2dfe:	e0 ec       	ldi	r30, 0xC0	; 192
    2e00:	f8 e0       	ldi	r31, 0x08	; 8
    2e02:	83 81       	ldd	r24, Z+3	; 0x03
    2e04:	80 93 73 50 	sts	0x5073, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2e08:	a0 e2       	ldi	r26, 0x20	; 32
    2e0a:	b6 e0       	ldi	r27, 0x06	; 6
    2e0c:	88 e0       	ldi	r24, 0x08	; 8
    2e0e:	15 96       	adiw	r26, 0x05	; 5
    2e10:	8c 93       	st	X, r24
    2e12:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    2e14:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2e16:	16 96       	adiw	r26, 0x06	; 6
    2e18:	8c 93       	st	X, r24
    2e1a:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    2e1c:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2e1e:	82 e0       	ldi	r24, 0x02	; 2
    2e20:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2e22:	82 81       	ldd	r24, Z+2	; 0x02
    2e24:	88 23       	and	r24, r24
    2e26:	ec f7       	brge	.-6      	; 0x2e22 <writeSE2FRAM+0x11a>
	SPIBuffer[12] = SPIC.DATA;
    2e28:	e0 ec       	ldi	r30, 0xC0	; 192
    2e2a:	f8 e0       	ldi	r31, 0x08	; 8
    2e2c:	83 81       	ldd	r24, Z+3	; 0x03
    2e2e:	80 93 73 50 	sts	0x5073, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2e32:	80 91 40 40 	lds	r24, 0x4040
    2e36:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2e38:	82 81       	ldd	r24, Z+2	; 0x02
    2e3a:	88 23       	and	r24, r24
    2e3c:	ec f7       	brge	.-6      	; 0x2e38 <writeSE2FRAM+0x130>
	SPIBuffer[12] = SPIC.DATA;
    2e3e:	e0 ec       	ldi	r30, 0xC0	; 192
    2e40:	f8 e0       	ldi	r31, 0x08	; 8
    2e42:	83 81       	ldd	r24, Z+3	; 0x03
    2e44:	80 93 73 50 	sts	0x5073, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2e48:	80 91 3f 40 	lds	r24, 0x403F
    2e4c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2e4e:	82 81       	ldd	r24, Z+2	; 0x02
    2e50:	88 23       	and	r24, r24
    2e52:	ec f7       	brge	.-6      	; 0x2e4e <writeSE2FRAM+0x146>
	SPIBuffer[12] = SPIC.DATA;
    2e54:	e0 ec       	ldi	r30, 0xC0	; 192
    2e56:	f8 e0       	ldi	r31, 0x08	; 8
    2e58:	83 81       	ldd	r24, Z+3	; 0x03
    2e5a:	80 93 73 50 	sts	0x5073, r24
	SPIC.DATA = SPIBuffer[0];
    2e5e:	80 91 67 50 	lds	r24, 0x5067
    2e62:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2e64:	82 81       	ldd	r24, Z+2	; 0x02
    2e66:	88 23       	and	r24, r24
    2e68:	ec f7       	brge	.-6      	; 0x2e64 <writeSE2FRAM+0x15c>
	SPIBuffer[12] = SPIC.DATA;
    2e6a:	e0 ec       	ldi	r30, 0xC0	; 192
    2e6c:	f8 e0       	ldi	r31, 0x08	; 8
    2e6e:	83 81       	ldd	r24, Z+3	; 0x03
    2e70:	80 93 73 50 	sts	0x5073, r24
	SPIC.DATA = SPIBuffer[1];
    2e74:	80 91 68 50 	lds	r24, 0x5068
    2e78:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2e7a:	82 81       	ldd	r24, Z+2	; 0x02
    2e7c:	88 23       	and	r24, r24
    2e7e:	ec f7       	brge	.-6      	; 0x2e7a <writeSE2FRAM+0x172>
	SPIBuffer[12] = SPIC.DATA;
    2e80:	e0 ec       	ldi	r30, 0xC0	; 192
    2e82:	f8 e0       	ldi	r31, 0x08	; 8
    2e84:	83 81       	ldd	r24, Z+3	; 0x03
    2e86:	80 93 73 50 	sts	0x5073, r24
	SPIC.DATA = SPIBuffer[2];
    2e8a:	80 91 69 50 	lds	r24, 0x5069
    2e8e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2e90:	82 81       	ldd	r24, Z+2	; 0x02
    2e92:	88 23       	and	r24, r24
    2e94:	ec f7       	brge	.-6      	; 0x2e90 <writeSE2FRAM+0x188>
	SPIBuffer[12] = SPIC.DATA;
    2e96:	a0 ec       	ldi	r26, 0xC0	; 192
    2e98:	b8 e0       	ldi	r27, 0x08	; 8
    2e9a:	13 96       	adiw	r26, 0x03	; 3
    2e9c:	8c 91       	ld	r24, X
    2e9e:	13 97       	sbiw	r26, 0x03	; 3
    2ea0:	80 93 73 50 	sts	0x5073, r24
		
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2ea4:	88 e0       	ldi	r24, 0x08	; 8
    2ea6:	e0 e2       	ldi	r30, 0x20	; 32
    2ea8:	f6 e0       	ldi	r31, 0x06	; 6
    2eaa:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2eac:	e0 e4       	ldi	r30, 0x40	; 64
    2eae:	f6 e0       	ldi	r31, 0x06	; 6
    2eb0:	80 e1       	ldi	r24, 0x10	; 16
    2eb2:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2eb4:	94 e5       	ldi	r25, 0x54	; 84
    2eb6:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2eb8:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    2eba:	80 91 3f 40 	lds	r24, 0x403F
    2ebe:	90 91 40 40 	lds	r25, 0x4040
    2ec2:	03 96       	adiw	r24, 0x03	; 3
    2ec4:	80 93 3f 40 	sts	0x403F, r24
    2ec8:	90 93 40 40 	sts	0x4040, r25
	checksumADC[0] += SPIBuffer[0];
    2ecc:	80 91 bc 21 	lds	r24, 0x21BC
    2ed0:	e7 e6       	ldi	r30, 0x67	; 103
    2ed2:	f0 e5       	ldi	r31, 0x50	; 80
    2ed4:	90 81       	ld	r25, Z
    2ed6:	89 0f       	add	r24, r25
    2ed8:	80 93 bc 21 	sts	0x21BC, r24
	checksumADC[1] += SPIBuffer[1];
    2edc:	80 91 bd 21 	lds	r24, 0x21BD
    2ee0:	91 81       	ldd	r25, Z+1	; 0x01
    2ee2:	89 0f       	add	r24, r25
    2ee4:	80 93 bd 21 	sts	0x21BD, r24
	checksumADC[2] += SPIBuffer[2];	
    2ee8:	80 91 be 21 	lds	r24, 0x21BE
    2eec:	92 81       	ldd	r25, Z+2	; 0x02
    2eee:	89 0f       	add	r24, r25
    2ef0:	80 93 be 21 	sts	0x21BE, r24
}
    2ef4:	28 96       	adiw	r28, 0x08	; 8
    2ef6:	cd bf       	out	0x3d, r28	; 61
    2ef8:	de bf       	out	0x3e, r29	; 62
    2efa:	df 91       	pop	r29
    2efc:	cf 91       	pop	r28
    2efe:	1f 91       	pop	r17
    2f00:	0f 91       	pop	r16
    2f02:	ff 90       	pop	r15
    2f04:	08 95       	ret

00002f06 <__vector_77>:
ISR(TCD0_CCD_vect) {
	sampleCurrentChannel();
	SPICount = 0;		
}

ISR(TCD0_OVF_vect) {
    2f06:	1f 92       	push	r1
    2f08:	0f 92       	push	r0
    2f0a:	0f b6       	in	r0, 0x3f	; 63
    2f0c:	0f 92       	push	r0
    2f0e:	0b b6       	in	r0, 0x3b	; 59
    2f10:	0f 92       	push	r0
    2f12:	11 24       	eor	r1, r1
    2f14:	2f 93       	push	r18
    2f16:	3f 93       	push	r19
    2f18:	4f 93       	push	r20
    2f1a:	5f 93       	push	r21
    2f1c:	6f 93       	push	r22
    2f1e:	7f 93       	push	r23
    2f20:	8f 93       	push	r24
    2f22:	9f 93       	push	r25
    2f24:	af 93       	push	r26
    2f26:	bf 93       	push	r27
    2f28:	ef 93       	push	r30
    2f2a:	ff 93       	push	r31
	writeSE2FRAM();
    2f2c:	0e 94 84 16 	call	0x2d08	; 0x2d08 <writeSE2FRAM>
}
    2f30:	ff 91       	pop	r31
    2f32:	ef 91       	pop	r30
    2f34:	bf 91       	pop	r27
    2f36:	af 91       	pop	r26
    2f38:	9f 91       	pop	r25
    2f3a:	8f 91       	pop	r24
    2f3c:	7f 91       	pop	r23
    2f3e:	6f 91       	pop	r22
    2f40:	5f 91       	pop	r21
    2f42:	4f 91       	pop	r20
    2f44:	3f 91       	pop	r19
    2f46:	2f 91       	pop	r18
    2f48:	0f 90       	pop	r0
    2f4a:	0b be       	out	0x3b, r0	; 59
    2f4c:	0f 90       	pop	r0
    2f4e:	0f be       	out	0x3f, r0	; 63
    2f50:	0f 90       	pop	r0
    2f52:	1f 90       	pop	r1
    2f54:	18 95       	reti

00002f56 <__vector_14>:
		PORTB.OUTSET = PIN1_bm;
	}
	
}

ISR(TCC0_OVF_vect) {
    2f56:	1f 92       	push	r1
    2f58:	0f 92       	push	r0
    2f5a:	0f b6       	in	r0, 0x3f	; 63
    2f5c:	0f 92       	push	r0
    2f5e:	0b b6       	in	r0, 0x3b	; 59
    2f60:	0f 92       	push	r0
    2f62:	11 24       	eor	r1, r1
    2f64:	2f 93       	push	r18
    2f66:	3f 93       	push	r19
    2f68:	4f 93       	push	r20
    2f6a:	5f 93       	push	r21
    2f6c:	6f 93       	push	r22
    2f6e:	7f 93       	push	r23
    2f70:	8f 93       	push	r24
    2f72:	9f 93       	push	r25
    2f74:	af 93       	push	r26
    2f76:	bf 93       	push	r27
    2f78:	ef 93       	push	r30
    2f7a:	ff 93       	push	r31
	writeSE2FRAM();
    2f7c:	0e 94 84 16 	call	0x2d08	; 0x2d08 <writeSE2FRAM>
}
    2f80:	ff 91       	pop	r31
    2f82:	ef 91       	pop	r30
    2f84:	bf 91       	pop	r27
    2f86:	af 91       	pop	r26
    2f88:	9f 91       	pop	r25
    2f8a:	8f 91       	pop	r24
    2f8c:	7f 91       	pop	r23
    2f8e:	6f 91       	pop	r22
    2f90:	5f 91       	pop	r21
    2f92:	4f 91       	pop	r20
    2f94:	3f 91       	pop	r19
    2f96:	2f 91       	pop	r18
    2f98:	0f 90       	pop	r0
    2f9a:	0b be       	out	0x3b, r0	; 59
    2f9c:	0f 90       	pop	r0
    2f9e:	0f be       	out	0x3f, r0	; 63
    2fa0:	0f 90       	pop	r0
    2fa2:	1f 90       	pop	r1
    2fa4:	18 95       	reti

00002fa6 <readFRAM>:
	checksumADC[2] += SPIBuffer[2];	
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    2fa6:	0f 93       	push	r16
    2fa8:	1f 93       	push	r17
    2faa:	cf 93       	push	r28
    2fac:	df 93       	push	r29
    2fae:	ec 01       	movw	r28, r24
	SPIInit(SPI_MODE_0_gc);
    2fb0:	80 e0       	ldi	r24, 0x00	; 0
    2fb2:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2fb6:	00 ec       	ldi	r16, 0xC0	; 192
    2fb8:	18 e0       	ldi	r17, 0x08	; 8
    2fba:	80 ed       	ldi	r24, 0xD0	; 208
    2fbc:	f8 01       	movw	r30, r16
    2fbe:	80 83       	st	Z, r24
	SPICS(TRUE);
    2fc0:	81 e0       	ldi	r24, 0x01	; 1
    2fc2:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2fc6:	88 e0       	ldi	r24, 0x08	; 8
    2fc8:	e0 e2       	ldi	r30, 0x20	; 32
    2fca:	f6 e0       	ldi	r31, 0x06	; 6
    2fcc:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2fce:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    2fd0:	83 e0       	ldi	r24, 0x03	; 3
    2fd2:	f8 01       	movw	r30, r16
    2fd4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fd6:	82 81       	ldd	r24, Z+2	; 0x02
    2fd8:	88 23       	and	r24, r24
    2fda:	ec f7       	brge	.-6      	; 0x2fd6 <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    2fdc:	e0 ec       	ldi	r30, 0xC0	; 192
    2fde:	f8 e0       	ldi	r31, 0x08	; 8
    2fe0:	83 81       	ldd	r24, Z+3	; 0x03
    2fe2:	80 93 73 50 	sts	0x5073, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    2fe6:	80 91 40 40 	lds	r24, 0x4040
    2fea:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fec:	82 81       	ldd	r24, Z+2	; 0x02
    2fee:	88 23       	and	r24, r24
    2ff0:	ec f7       	brge	.-6      	; 0x2fec <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    2ff2:	e0 ec       	ldi	r30, 0xC0	; 192
    2ff4:	f8 e0       	ldi	r31, 0x08	; 8
    2ff6:	83 81       	ldd	r24, Z+3	; 0x03
    2ff8:	80 93 73 50 	sts	0x5073, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    2ffc:	80 91 3f 40 	lds	r24, 0x403F
    3000:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3002:	82 81       	ldd	r24, Z+2	; 0x02
    3004:	88 23       	and	r24, r24
    3006:	ec f7       	brge	.-6      	; 0x3002 <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3008:	e0 ec       	ldi	r30, 0xC0	; 192
    300a:	f8 e0       	ldi	r31, 0x08	; 8
    300c:	83 81       	ldd	r24, Z+3	; 0x03
    300e:	80 93 73 50 	sts	0x5073, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3012:	20 97       	sbiw	r28, 0x00	; 0
    3014:	d1 f0       	breq	.+52     	; 0x304a <readFRAM+0xa4>
    3016:	80 e0       	ldi	r24, 0x00	; 0
    3018:	90 e0       	ldi	r25, 0x00	; 0
		SPIC.DATA = 0xAA;
    301a:	a0 ec       	ldi	r26, 0xC0	; 192
    301c:	b8 e0       	ldi	r27, 0x08	; 8
    301e:	5a ea       	ldi	r21, 0xAA	; 170
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
    3020:	28 ec       	ldi	r18, 0xC8	; 200
    3022:	33 e2       	ldi	r19, 0x23	; 35
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    3024:	13 96       	adiw	r26, 0x03	; 3
    3026:	5c 93       	st	X, r21
    3028:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    302a:	12 96       	adiw	r26, 0x02	; 2
    302c:	4c 91       	ld	r20, X
    302e:	12 97       	sbiw	r26, 0x02	; 2
    3030:	44 23       	and	r20, r20
    3032:	dc f7       	brge	.-10     	; 0x302a <readFRAM+0x84>
		FRAMReadBuffer[i] = SPIC.DATA;
    3034:	13 96       	adiw	r26, 0x03	; 3
    3036:	4c 91       	ld	r20, X
    3038:	13 97       	sbiw	r26, 0x03	; 3
    303a:	f9 01       	movw	r30, r18
    303c:	e8 0f       	add	r30, r24
    303e:	f9 1f       	adc	r31, r25
    3040:	40 83       	st	Z, r20
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3042:	01 96       	adiw	r24, 0x01	; 1
    3044:	8c 17       	cp	r24, r28
    3046:	9d 07       	cpc	r25, r29
    3048:	69 f7       	brne	.-38     	; 0x3024 <readFRAM+0x7e>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    304a:	88 e0       	ldi	r24, 0x08	; 8
    304c:	e0 e2       	ldi	r30, 0x20	; 32
    304e:	f6 e0       	ldi	r31, 0x06	; 6
    3050:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    3052:	80 e0       	ldi	r24, 0x00	; 0
    3054:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    3058:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>

}
    305c:	df 91       	pop	r29
    305e:	cf 91       	pop	r28
    3060:	1f 91       	pop	r17
    3062:	0f 91       	pop	r16
    3064:	08 95       	ret

00003066 <calcChecksumFRAM>:

	ADCPower(FALSE);

}

void calcChecksumFRAM() {
    3066:	2f 92       	push	r2
    3068:	3f 92       	push	r3
    306a:	4f 92       	push	r4
    306c:	5f 92       	push	r5
    306e:	6f 92       	push	r6
    3070:	7f 92       	push	r7
    3072:	8f 92       	push	r8
    3074:	9f 92       	push	r9
    3076:	af 92       	push	r10
    3078:	bf 92       	push	r11
    307a:	cf 92       	push	r12
    307c:	df 92       	push	r13
    307e:	ef 92       	push	r14
    3080:	ff 92       	push	r15
    3082:	0f 93       	push	r16
    3084:	1f 93       	push	r17
    3086:	cf 93       	push	r28
    3088:	df 93       	push	r29
    308a:	00 d0       	rcall	.+0      	; 0x308c <calcChecksumFRAM+0x26>
    308c:	00 d0       	rcall	.+0      	; 0x308e <calcChecksumFRAM+0x28>
    308e:	cd b7       	in	r28, 0x3d	; 61
    3090:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    3092:	e9 e8       	ldi	r30, 0x89	; 137
    3094:	f0 e5       	ldi	r31, 0x50	; 80
    3096:	10 92 89 50 	sts	0x5089, r1
    309a:	10 92 8a 50 	sts	0x508A, r1
    309e:	10 92 8b 50 	sts	0x508B, r1
    30a2:	10 92 8c 50 	sts	0x508C, r1
    30a6:	10 92 8d 50 	sts	0x508D, r1
    30aa:	10 92 8e 50 	sts	0x508E, r1
    30ae:	10 92 8f 50 	sts	0x508F, r1
    30b2:	10 92 90 50 	sts	0x5090, r1
    30b6:	df 01       	movw	r26, r30
    30b8:	18 97       	sbiw	r26, 0x08	; 8
    30ba:	1c 92       	st	X, r1
    30bc:	11 96       	adiw	r26, 0x01	; 1
    30be:	1c 92       	st	X, r1
    30c0:	11 97       	sbiw	r26, 0x01	; 1
    30c2:	12 96       	adiw	r26, 0x02	; 2
    30c4:	1c 92       	st	X, r1
    30c6:	12 97       	sbiw	r26, 0x02	; 2
    30c8:	13 96       	adiw	r26, 0x03	; 3
    30ca:	1c 92       	st	X, r1
    30cc:	13 97       	sbiw	r26, 0x03	; 3
    30ce:	14 96       	adiw	r26, 0x04	; 4
    30d0:	1c 92       	st	X, r1
    30d2:	14 97       	sbiw	r26, 0x04	; 4
    30d4:	15 96       	adiw	r26, 0x05	; 5
    30d6:	1c 92       	st	X, r1
    30d8:	15 97       	sbiw	r26, 0x05	; 5
    30da:	16 96       	adiw	r26, 0x06	; 6
    30dc:	1c 92       	st	X, r1
    30de:	16 97       	sbiw	r26, 0x06	; 6
    30e0:	17 96       	adiw	r26, 0x07	; 7
    30e2:	1c 92       	st	X, r1
    30e4:	70 97       	sbiw	r30, 0x10	; 16
    30e6:	10 82       	st	Z, r1
    30e8:	11 82       	std	Z+1, r1	; 0x01
    30ea:	12 82       	std	Z+2, r1	; 0x02
    30ec:	13 82       	std	Z+3, r1	; 0x03
    30ee:	14 82       	std	Z+4, r1	; 0x04
    30f0:	15 82       	std	Z+5, r1	; 0x05
    30f2:	16 82       	std	Z+6, r1	; 0x06
    30f4:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    30f6:	8b eb       	ldi	r24, 0xBB	; 187
    30f8:	91 e2       	ldi	r25, 0x21	; 33
    30fa:	10 92 bb 21 	sts	0x21BB, r1
    30fe:	fc 01       	movw	r30, r24
    3100:	31 97       	sbiw	r30, 0x01	; 1
    3102:	10 82       	st	Z, r1
    3104:	02 97       	sbiw	r24, 0x02	; 2
    3106:	dc 01       	movw	r26, r24
    3108:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    310a:	10 92 3f 40 	sts	0x403F, r1
    310e:	10 92 40 40 	sts	0x4040, r1
    3112:	e9 e0       	ldi	r30, 0x09	; 9
    3114:	f0 e0       	ldi	r31, 0x00	; 0
    3116:	e9 83       	std	Y+1, r30	; 0x01
    3118:	fa 83       	std	Y+2, r31	; 0x02
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    311a:	0f 2e       	mov	r0, r31
    311c:	f8 ec       	ldi	r31, 0xC8	; 200
    311e:	8f 2e       	mov	r8, r31
    3120:	f3 e2       	ldi	r31, 0x23	; 35
    3122:	9f 2e       	mov	r9, r31
    3124:	f0 2d       	mov	r31, r0
		
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {			
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    3126:	44 24       	eor	r4, r4
    3128:	4a 94       	dec	r4
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    312a:	09 e8       	ldi	r16, 0x89	; 137
    312c:	10 e5       	ldi	r17, 0x50	; 80
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    312e:	0f 2e       	mov	r0, r31
    3130:	f1 e8       	ldi	r31, 0x81	; 129
    3132:	ef 2e       	mov	r14, r31
    3134:	f0 e5       	ldi	r31, 0x50	; 80
    3136:	ff 2e       	mov	r15, r31
    3138:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    313a:	0f 2e       	mov	r0, r31
    313c:	f9 e7       	ldi	r31, 0x79	; 121
    313e:	cf 2e       	mov	r12, r31
    3140:	f0 e5       	ldi	r31, 0x50	; 80
    3142:	df 2e       	mov	r13, r31
    3144:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    3146:	81 e7       	ldi	r24, 0x71	; 113
    3148:	9c e1       	ldi	r25, 0x1C	; 28
    314a:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    314e:	80 91 3f 40 	lds	r24, 0x403F
    3152:	90 91 40 40 	lds	r25, 0x4040
    3156:	8f 58       	subi	r24, 0x8F	; 143
    3158:	93 4e       	sbci	r25, 0xE3	; 227
    315a:	80 93 3f 40 	sts	0x403F, r24
    315e:	90 93 40 40 	sts	0x4040, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3162:	20 e0       	ldi	r18, 0x00	; 0
    3164:	30 e0       	ldi	r19, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    3166:	0f 2e       	mov	r0, r31
    3168:	f9 e0       	ldi	r31, 0x09	; 9
    316a:	2f 2e       	mov	r2, r31
    316c:	33 24       	eor	r3, r3
    316e:	f0 2d       	mov	r31, r0
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    3170:	c9 01       	movw	r24, r18
    3172:	63 e0       	ldi	r22, 0x03	; 3
    3174:	70 e0       	ldi	r23, 0x00	; 0
    3176:	0e 94 9b 34 	call	0x6936	; 0x6936 <__udivmodhi4>
    317a:	ac 01       	movw	r20, r24
    317c:	a9 eb       	ldi	r26, 0xB9	; 185
    317e:	b1 e2       	ldi	r27, 0x21	; 33
    3180:	a8 0f       	add	r26, r24
    3182:	b9 1f       	adc	r27, r25
    3184:	8c 91       	ld	r24, X
    3186:	f4 01       	movw	r30, r8
    3188:	e2 0f       	add	r30, r18
    318a:	f3 1f       	adc	r31, r19
    318c:	90 81       	ld	r25, Z
    318e:	89 0f       	add	r24, r25
    3190:	8c 93       	st	X, r24
		
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {			
    3192:	41 15       	cp	r20, r1
    3194:	51 05       	cpc	r21, r1
    3196:	49 f5       	brne	.+82     	; 0x31ea <calcChecksumFRAM+0x184>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    3198:	f4 01       	movw	r30, r8
    319a:	e2 0f       	add	r30, r18
    319c:	f3 1f       	adc	r31, r19
    319e:	80 81       	ld	r24, Z
    31a0:	88 23       	and	r24, r24
    31a2:	6c f4       	brge	.+26     	; 0x31be <calcChecksumFRAM+0x158>
    31a4:	e0 91 65 50 	lds	r30, 0x5065
    31a8:	f0 91 66 50 	lds	r31, 0x5066
    31ac:	10 82       	st	Z, r1
    31ae:	11 82       	std	Z+1, r1	; 0x01
    31b0:	12 82       	std	Z+2, r1	; 0x02
    31b2:	43 82       	std	Z+3, r4	; 0x03
    31b4:	44 82       	std	Z+4, r4	; 0x04
    31b6:	45 82       	std	Z+5, r4	; 0x05
    31b8:	46 82       	std	Z+6, r4	; 0x06
    31ba:	47 82       	std	Z+7, r4	; 0x07
    31bc:	0c c0       	rjmp	.+24     	; 0x31d6 <calcChecksumFRAM+0x170>
				else *temp64 = 0x0000000000000000;
    31be:	e0 91 65 50 	lds	r30, 0x5065
    31c2:	f0 91 66 50 	lds	r31, 0x5066
    31c6:	10 82       	st	Z, r1
    31c8:	11 82       	std	Z+1, r1	; 0x01
    31ca:	12 82       	std	Z+2, r1	; 0x02
    31cc:	13 82       	std	Z+3, r1	; 0x03
    31ce:	14 82       	std	Z+4, r1	; 0x04
    31d0:	15 82       	std	Z+5, r1	; 0x05
    31d2:	16 82       	std	Z+6, r1	; 0x06
    31d4:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    31d6:	f4 01       	movw	r30, r8
    31d8:	e2 0f       	add	r30, r18
    31da:	f3 1f       	adc	r31, r19
    31dc:	80 81       	ld	r24, Z
    31de:	e0 91 65 50 	lds	r30, 0x5065
    31e2:	f0 91 66 50 	lds	r31, 0x5066
    31e6:	82 83       	std	Z+2, r24	; 0x02
    31e8:	18 c0       	rjmp	.+48     	; 0x321a <calcChecksumFRAM+0x1b4>
			} else if(k%3 == 1) {
    31ea:	41 30       	cpi	r20, 0x01	; 1
    31ec:	51 05       	cpc	r21, r1
    31ee:	61 f4       	brne	.+24     	; 0x3208 <calcChecksumFRAM+0x1a2>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    31f0:	a0 91 65 50 	lds	r26, 0x5065
    31f4:	b0 91 66 50 	lds	r27, 0x5066
    31f8:	f4 01       	movw	r30, r8
    31fa:	e2 0f       	add	r30, r18
    31fc:	f3 1f       	adc	r31, r19
    31fe:	80 81       	ld	r24, Z
    3200:	11 96       	adiw	r26, 0x01	; 1
    3202:	8c 93       	st	X, r24
    3204:	11 97       	sbiw	r26, 0x01	; 1
    3206:	09 c0       	rjmp	.+18     	; 0x321a <calcChecksumFRAM+0x1b4>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    3208:	a0 91 65 50 	lds	r26, 0x5065
    320c:	b0 91 66 50 	lds	r27, 0x5066
    3210:	f4 01       	movw	r30, r8
    3212:	e2 0f       	add	r30, r18
    3214:	f3 1f       	adc	r31, r19
    3216:	80 81       	ld	r24, Z
    3218:	8c 93       	st	X, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    321a:	c9 01       	movw	r24, r18
    321c:	b1 01       	movw	r22, r2
    321e:	0e 94 9b 34 	call	0x6936	; 0x6936 <__udivmodhi4>
    3222:	82 30       	cpi	r24, 0x02	; 2
    3224:	91 05       	cpc	r25, r1
    3226:	09 f0       	breq	.+2      	; 0x322a <calcChecksumFRAM+0x1c4>
    3228:	74 c0       	rjmp	.+232    	; 0x3312 <calcChecksumFRAM+0x2ac>
    322a:	f6 01       	movw	r30, r12
    322c:	a0 81       	ld	r26, Z
    322e:	71 81       	ldd	r23, Z+1	; 0x01
    3230:	62 81       	ldd	r22, Z+2	; 0x02
    3232:	53 81       	ldd	r21, Z+3	; 0x03
    3234:	44 81       	ldd	r20, Z+4	; 0x04
    3236:	95 81       	ldd	r25, Z+5	; 0x05
    3238:	86 81       	ldd	r24, Z+6	; 0x06
    323a:	f7 81       	ldd	r31, Z+7	; 0x07
    323c:	fd 83       	std	Y+5, r31	; 0x05
    323e:	e0 91 65 50 	lds	r30, 0x5065
    3242:	f0 91 66 50 	lds	r31, 0x5066
    3246:	50 80       	ld	r5, Z
    3248:	b1 81       	ldd	r27, Z+1	; 0x01
    324a:	bb 83       	std	Y+3, r27	; 0x03
    324c:	b2 81       	ldd	r27, Z+2	; 0x02
    324e:	b3 80       	ldd	r11, Z+3	; 0x03
    3250:	a4 80       	ldd	r10, Z+4	; 0x04
    3252:	75 80       	ldd	r7, Z+5	; 0x05
    3254:	66 80       	ldd	r6, Z+6	; 0x06
    3256:	e7 81       	ldd	r30, Z+7	; 0x07
    3258:	5a 0e       	add	r5, r26
    325a:	5e 82       	std	Y+6, r5	; 0x06
    325c:	f1 e0       	ldi	r31, 0x01	; 1
    325e:	5a 16       	cp	r5, r26
    3260:	08 f0       	brcs	.+2      	; 0x3264 <calcChecksumFRAM+0x1fe>
    3262:	f0 e0       	ldi	r31, 0x00	; 0
    3264:	5b 80       	ldd	r5, Y+3	; 0x03
    3266:	57 0e       	add	r5, r23
    3268:	5c 82       	std	Y+4, r5	; 0x04
    326a:	a1 e0       	ldi	r26, 0x01	; 1
    326c:	57 16       	cp	r5, r23
    326e:	08 f0       	brcs	.+2      	; 0x3272 <calcChecksumFRAM+0x20c>
    3270:	a0 e0       	ldi	r26, 0x00	; 0
    3272:	7c 81       	ldd	r23, Y+4	; 0x04
    3274:	7f 0f       	add	r23, r31
    3276:	7b 83       	std	Y+3, r23	; 0x03
    3278:	71 e0       	ldi	r23, 0x01	; 1
    327a:	fb 81       	ldd	r31, Y+3	; 0x03
    327c:	5c 80       	ldd	r5, Y+4	; 0x04
    327e:	f5 15       	cp	r31, r5
    3280:	08 f0       	brcs	.+2      	; 0x3284 <calcChecksumFRAM+0x21e>
    3282:	70 e0       	ldi	r23, 0x00	; 0
    3284:	a7 2b       	or	r26, r23
    3286:	b6 0f       	add	r27, r22
    3288:	71 e0       	ldi	r23, 0x01	; 1
    328a:	b6 17       	cp	r27, r22
    328c:	08 f0       	brcs	.+2      	; 0x3290 <calcChecksumFRAM+0x22a>
    328e:	70 e0       	ldi	r23, 0x00	; 0
    3290:	ab 0f       	add	r26, r27
    3292:	61 e0       	ldi	r22, 0x01	; 1
    3294:	ab 17       	cp	r26, r27
    3296:	08 f0       	brcs	.+2      	; 0x329a <calcChecksumFRAM+0x234>
    3298:	60 e0       	ldi	r22, 0x00	; 0
    329a:	76 2b       	or	r23, r22
    329c:	b5 0e       	add	r11, r21
    329e:	61 e0       	ldi	r22, 0x01	; 1
    32a0:	b5 16       	cp	r11, r21
    32a2:	08 f0       	brcs	.+2      	; 0x32a6 <calcChecksumFRAM+0x240>
    32a4:	60 e0       	ldi	r22, 0x00	; 0
    32a6:	7b 0d       	add	r23, r11
    32a8:	51 e0       	ldi	r21, 0x01	; 1
    32aa:	7b 15       	cp	r23, r11
    32ac:	08 f0       	brcs	.+2      	; 0x32b0 <calcChecksumFRAM+0x24a>
    32ae:	50 e0       	ldi	r21, 0x00	; 0
    32b0:	65 2b       	or	r22, r21
    32b2:	a4 0e       	add	r10, r20
    32b4:	51 e0       	ldi	r21, 0x01	; 1
    32b6:	a4 16       	cp	r10, r20
    32b8:	08 f0       	brcs	.+2      	; 0x32bc <calcChecksumFRAM+0x256>
    32ba:	50 e0       	ldi	r21, 0x00	; 0
    32bc:	6a 0d       	add	r22, r10
    32be:	41 e0       	ldi	r20, 0x01	; 1
    32c0:	6a 15       	cp	r22, r10
    32c2:	08 f0       	brcs	.+2      	; 0x32c6 <calcChecksumFRAM+0x260>
    32c4:	40 e0       	ldi	r20, 0x00	; 0
    32c6:	54 2b       	or	r21, r20
    32c8:	79 0e       	add	r7, r25
    32ca:	41 e0       	ldi	r20, 0x01	; 1
    32cc:	79 16       	cp	r7, r25
    32ce:	08 f0       	brcs	.+2      	; 0x32d2 <calcChecksumFRAM+0x26c>
    32d0:	40 e0       	ldi	r20, 0x00	; 0
    32d2:	57 0d       	add	r21, r7
    32d4:	91 e0       	ldi	r25, 0x01	; 1
    32d6:	57 15       	cp	r21, r7
    32d8:	08 f0       	brcs	.+2      	; 0x32dc <calcChecksumFRAM+0x276>
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	49 2b       	or	r20, r25
    32de:	68 0e       	add	r6, r24
    32e0:	91 e0       	ldi	r25, 0x01	; 1
    32e2:	68 16       	cp	r6, r24
    32e4:	08 f0       	brcs	.+2      	; 0x32e8 <calcChecksumFRAM+0x282>
    32e6:	90 e0       	ldi	r25, 0x00	; 0
    32e8:	46 0d       	add	r20, r6
    32ea:	81 e0       	ldi	r24, 0x01	; 1
    32ec:	46 15       	cp	r20, r6
    32ee:	08 f0       	brcs	.+2      	; 0x32f2 <calcChecksumFRAM+0x28c>
    32f0:	80 e0       	ldi	r24, 0x00	; 0
    32f2:	98 2b       	or	r25, r24
    32f4:	8d 81       	ldd	r24, Y+5	; 0x05
    32f6:	e8 0f       	add	r30, r24
    32f8:	9e 0f       	add	r25, r30
    32fa:	5e 80       	ldd	r5, Y+6	; 0x06
    32fc:	f6 01       	movw	r30, r12
    32fe:	50 82       	st	Z, r5
    3300:	8b 81       	ldd	r24, Y+3	; 0x03
    3302:	81 83       	std	Z+1, r24	; 0x01
    3304:	a2 83       	std	Z+2, r26	; 0x02
    3306:	73 83       	std	Z+3, r23	; 0x03
    3308:	64 83       	std	Z+4, r22	; 0x04
    330a:	55 83       	std	Z+5, r21	; 0x05
    330c:	46 83       	std	Z+6, r20	; 0x06
    330e:	97 83       	std	Z+7, r25	; 0x07
    3310:	ef c0       	rjmp	.+478    	; 0x34f0 <calcChecksumFRAM+0x48a>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    3312:	85 30       	cpi	r24, 0x05	; 5
    3314:	91 05       	cpc	r25, r1
    3316:	09 f0       	breq	.+2      	; 0x331a <calcChecksumFRAM+0x2b4>
    3318:	74 c0       	rjmp	.+232    	; 0x3402 <calcChecksumFRAM+0x39c>
    331a:	f7 01       	movw	r30, r14
    331c:	a0 81       	ld	r26, Z
    331e:	71 81       	ldd	r23, Z+1	; 0x01
    3320:	62 81       	ldd	r22, Z+2	; 0x02
    3322:	53 81       	ldd	r21, Z+3	; 0x03
    3324:	44 81       	ldd	r20, Z+4	; 0x04
    3326:	95 81       	ldd	r25, Z+5	; 0x05
    3328:	86 81       	ldd	r24, Z+6	; 0x06
    332a:	f7 81       	ldd	r31, Z+7	; 0x07
    332c:	fd 83       	std	Y+5, r31	; 0x05
    332e:	e0 91 65 50 	lds	r30, 0x5065
    3332:	f0 91 66 50 	lds	r31, 0x5066
    3336:	50 80       	ld	r5, Z
    3338:	b1 81       	ldd	r27, Z+1	; 0x01
    333a:	bb 83       	std	Y+3, r27	; 0x03
    333c:	b2 81       	ldd	r27, Z+2	; 0x02
    333e:	b3 80       	ldd	r11, Z+3	; 0x03
    3340:	a4 80       	ldd	r10, Z+4	; 0x04
    3342:	75 80       	ldd	r7, Z+5	; 0x05
    3344:	66 80       	ldd	r6, Z+6	; 0x06
    3346:	e7 81       	ldd	r30, Z+7	; 0x07
    3348:	5a 0e       	add	r5, r26
    334a:	5e 82       	std	Y+6, r5	; 0x06
    334c:	f1 e0       	ldi	r31, 0x01	; 1
    334e:	5a 16       	cp	r5, r26
    3350:	08 f0       	brcs	.+2      	; 0x3354 <calcChecksumFRAM+0x2ee>
    3352:	f0 e0       	ldi	r31, 0x00	; 0
    3354:	5b 80       	ldd	r5, Y+3	; 0x03
    3356:	57 0e       	add	r5, r23
    3358:	5c 82       	std	Y+4, r5	; 0x04
    335a:	a1 e0       	ldi	r26, 0x01	; 1
    335c:	57 16       	cp	r5, r23
    335e:	08 f0       	brcs	.+2      	; 0x3362 <calcChecksumFRAM+0x2fc>
    3360:	a0 e0       	ldi	r26, 0x00	; 0
    3362:	7c 81       	ldd	r23, Y+4	; 0x04
    3364:	7f 0f       	add	r23, r31
    3366:	7b 83       	std	Y+3, r23	; 0x03
    3368:	71 e0       	ldi	r23, 0x01	; 1
    336a:	fb 81       	ldd	r31, Y+3	; 0x03
    336c:	5c 80       	ldd	r5, Y+4	; 0x04
    336e:	f5 15       	cp	r31, r5
    3370:	08 f0       	brcs	.+2      	; 0x3374 <calcChecksumFRAM+0x30e>
    3372:	70 e0       	ldi	r23, 0x00	; 0
    3374:	a7 2b       	or	r26, r23
    3376:	b6 0f       	add	r27, r22
    3378:	71 e0       	ldi	r23, 0x01	; 1
    337a:	b6 17       	cp	r27, r22
    337c:	08 f0       	brcs	.+2      	; 0x3380 <calcChecksumFRAM+0x31a>
    337e:	70 e0       	ldi	r23, 0x00	; 0
    3380:	ab 0f       	add	r26, r27
    3382:	61 e0       	ldi	r22, 0x01	; 1
    3384:	ab 17       	cp	r26, r27
    3386:	08 f0       	brcs	.+2      	; 0x338a <calcChecksumFRAM+0x324>
    3388:	60 e0       	ldi	r22, 0x00	; 0
    338a:	76 2b       	or	r23, r22
    338c:	b5 0e       	add	r11, r21
    338e:	61 e0       	ldi	r22, 0x01	; 1
    3390:	b5 16       	cp	r11, r21
    3392:	08 f0       	brcs	.+2      	; 0x3396 <calcChecksumFRAM+0x330>
    3394:	60 e0       	ldi	r22, 0x00	; 0
    3396:	7b 0d       	add	r23, r11
    3398:	51 e0       	ldi	r21, 0x01	; 1
    339a:	7b 15       	cp	r23, r11
    339c:	08 f0       	brcs	.+2      	; 0x33a0 <calcChecksumFRAM+0x33a>
    339e:	50 e0       	ldi	r21, 0x00	; 0
    33a0:	65 2b       	or	r22, r21
    33a2:	a4 0e       	add	r10, r20
    33a4:	51 e0       	ldi	r21, 0x01	; 1
    33a6:	a4 16       	cp	r10, r20
    33a8:	08 f0       	brcs	.+2      	; 0x33ac <calcChecksumFRAM+0x346>
    33aa:	50 e0       	ldi	r21, 0x00	; 0
    33ac:	6a 0d       	add	r22, r10
    33ae:	41 e0       	ldi	r20, 0x01	; 1
    33b0:	6a 15       	cp	r22, r10
    33b2:	08 f0       	brcs	.+2      	; 0x33b6 <calcChecksumFRAM+0x350>
    33b4:	40 e0       	ldi	r20, 0x00	; 0
    33b6:	54 2b       	or	r21, r20
    33b8:	79 0e       	add	r7, r25
    33ba:	41 e0       	ldi	r20, 0x01	; 1
    33bc:	79 16       	cp	r7, r25
    33be:	08 f0       	brcs	.+2      	; 0x33c2 <calcChecksumFRAM+0x35c>
    33c0:	40 e0       	ldi	r20, 0x00	; 0
    33c2:	57 0d       	add	r21, r7
    33c4:	91 e0       	ldi	r25, 0x01	; 1
    33c6:	57 15       	cp	r21, r7
    33c8:	08 f0       	brcs	.+2      	; 0x33cc <calcChecksumFRAM+0x366>
    33ca:	90 e0       	ldi	r25, 0x00	; 0
    33cc:	49 2b       	or	r20, r25
    33ce:	68 0e       	add	r6, r24
    33d0:	91 e0       	ldi	r25, 0x01	; 1
    33d2:	68 16       	cp	r6, r24
    33d4:	08 f0       	brcs	.+2      	; 0x33d8 <calcChecksumFRAM+0x372>
    33d6:	90 e0       	ldi	r25, 0x00	; 0
    33d8:	46 0d       	add	r20, r6
    33da:	81 e0       	ldi	r24, 0x01	; 1
    33dc:	46 15       	cp	r20, r6
    33de:	08 f0       	brcs	.+2      	; 0x33e2 <calcChecksumFRAM+0x37c>
    33e0:	80 e0       	ldi	r24, 0x00	; 0
    33e2:	98 2b       	or	r25, r24
    33e4:	8d 81       	ldd	r24, Y+5	; 0x05
    33e6:	e8 0f       	add	r30, r24
    33e8:	9e 0f       	add	r25, r30
    33ea:	5e 80       	ldd	r5, Y+6	; 0x06
    33ec:	f7 01       	movw	r30, r14
    33ee:	50 82       	st	Z, r5
    33f0:	8b 81       	ldd	r24, Y+3	; 0x03
    33f2:	81 83       	std	Z+1, r24	; 0x01
    33f4:	a2 83       	std	Z+2, r26	; 0x02
    33f6:	73 83       	std	Z+3, r23	; 0x03
    33f8:	64 83       	std	Z+4, r22	; 0x04
    33fa:	55 83       	std	Z+5, r21	; 0x05
    33fc:	46 83       	std	Z+6, r20	; 0x06
    33fe:	97 83       	std	Z+7, r25	; 0x07
    3400:	77 c0       	rjmp	.+238    	; 0x34f0 <calcChecksumFRAM+0x48a>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    3402:	88 30       	cpi	r24, 0x08	; 8
    3404:	91 05       	cpc	r25, r1
    3406:	09 f0       	breq	.+2      	; 0x340a <calcChecksumFRAM+0x3a4>
    3408:	73 c0       	rjmp	.+230    	; 0x34f0 <calcChecksumFRAM+0x48a>
    340a:	f8 01       	movw	r30, r16
    340c:	a0 81       	ld	r26, Z
    340e:	71 81       	ldd	r23, Z+1	; 0x01
    3410:	62 81       	ldd	r22, Z+2	; 0x02
    3412:	53 81       	ldd	r21, Z+3	; 0x03
    3414:	44 81       	ldd	r20, Z+4	; 0x04
    3416:	95 81       	ldd	r25, Z+5	; 0x05
    3418:	86 81       	ldd	r24, Z+6	; 0x06
    341a:	f7 81       	ldd	r31, Z+7	; 0x07
    341c:	fd 83       	std	Y+5, r31	; 0x05
    341e:	e0 91 65 50 	lds	r30, 0x5065
    3422:	f0 91 66 50 	lds	r31, 0x5066
    3426:	50 80       	ld	r5, Z
    3428:	b1 81       	ldd	r27, Z+1	; 0x01
    342a:	bb 83       	std	Y+3, r27	; 0x03
    342c:	b2 81       	ldd	r27, Z+2	; 0x02
    342e:	b3 80       	ldd	r11, Z+3	; 0x03
    3430:	a4 80       	ldd	r10, Z+4	; 0x04
    3432:	75 80       	ldd	r7, Z+5	; 0x05
    3434:	66 80       	ldd	r6, Z+6	; 0x06
    3436:	e7 81       	ldd	r30, Z+7	; 0x07
    3438:	5a 0e       	add	r5, r26
    343a:	5e 82       	std	Y+6, r5	; 0x06
    343c:	f1 e0       	ldi	r31, 0x01	; 1
    343e:	5a 16       	cp	r5, r26
    3440:	08 f0       	brcs	.+2      	; 0x3444 <calcChecksumFRAM+0x3de>
    3442:	f0 e0       	ldi	r31, 0x00	; 0
    3444:	5b 80       	ldd	r5, Y+3	; 0x03
    3446:	57 0e       	add	r5, r23
    3448:	5c 82       	std	Y+4, r5	; 0x04
    344a:	a1 e0       	ldi	r26, 0x01	; 1
    344c:	57 16       	cp	r5, r23
    344e:	08 f0       	brcs	.+2      	; 0x3452 <calcChecksumFRAM+0x3ec>
    3450:	a0 e0       	ldi	r26, 0x00	; 0
    3452:	7c 81       	ldd	r23, Y+4	; 0x04
    3454:	7f 0f       	add	r23, r31
    3456:	7b 83       	std	Y+3, r23	; 0x03
    3458:	71 e0       	ldi	r23, 0x01	; 1
    345a:	fb 81       	ldd	r31, Y+3	; 0x03
    345c:	5c 80       	ldd	r5, Y+4	; 0x04
    345e:	f5 15       	cp	r31, r5
    3460:	08 f0       	brcs	.+2      	; 0x3464 <calcChecksumFRAM+0x3fe>
    3462:	70 e0       	ldi	r23, 0x00	; 0
    3464:	a7 2b       	or	r26, r23
    3466:	b6 0f       	add	r27, r22
    3468:	71 e0       	ldi	r23, 0x01	; 1
    346a:	b6 17       	cp	r27, r22
    346c:	08 f0       	brcs	.+2      	; 0x3470 <calcChecksumFRAM+0x40a>
    346e:	70 e0       	ldi	r23, 0x00	; 0
    3470:	ab 0f       	add	r26, r27
    3472:	61 e0       	ldi	r22, 0x01	; 1
    3474:	ab 17       	cp	r26, r27
    3476:	08 f0       	brcs	.+2      	; 0x347a <calcChecksumFRAM+0x414>
    3478:	60 e0       	ldi	r22, 0x00	; 0
    347a:	76 2b       	or	r23, r22
    347c:	b5 0e       	add	r11, r21
    347e:	61 e0       	ldi	r22, 0x01	; 1
    3480:	b5 16       	cp	r11, r21
    3482:	08 f0       	brcs	.+2      	; 0x3486 <calcChecksumFRAM+0x420>
    3484:	60 e0       	ldi	r22, 0x00	; 0
    3486:	7b 0d       	add	r23, r11
    3488:	51 e0       	ldi	r21, 0x01	; 1
    348a:	7b 15       	cp	r23, r11
    348c:	08 f0       	brcs	.+2      	; 0x3490 <calcChecksumFRAM+0x42a>
    348e:	50 e0       	ldi	r21, 0x00	; 0
    3490:	65 2b       	or	r22, r21
    3492:	a4 0e       	add	r10, r20
    3494:	51 e0       	ldi	r21, 0x01	; 1
    3496:	a4 16       	cp	r10, r20
    3498:	08 f0       	brcs	.+2      	; 0x349c <calcChecksumFRAM+0x436>
    349a:	50 e0       	ldi	r21, 0x00	; 0
    349c:	6a 0d       	add	r22, r10
    349e:	41 e0       	ldi	r20, 0x01	; 1
    34a0:	6a 15       	cp	r22, r10
    34a2:	08 f0       	brcs	.+2      	; 0x34a6 <calcChecksumFRAM+0x440>
    34a4:	40 e0       	ldi	r20, 0x00	; 0
    34a6:	54 2b       	or	r21, r20
    34a8:	79 0e       	add	r7, r25
    34aa:	41 e0       	ldi	r20, 0x01	; 1
    34ac:	79 16       	cp	r7, r25
    34ae:	08 f0       	brcs	.+2      	; 0x34b2 <calcChecksumFRAM+0x44c>
    34b0:	40 e0       	ldi	r20, 0x00	; 0
    34b2:	57 0d       	add	r21, r7
    34b4:	91 e0       	ldi	r25, 0x01	; 1
    34b6:	57 15       	cp	r21, r7
    34b8:	08 f0       	brcs	.+2      	; 0x34bc <calcChecksumFRAM+0x456>
    34ba:	90 e0       	ldi	r25, 0x00	; 0
    34bc:	49 2b       	or	r20, r25
    34be:	68 0e       	add	r6, r24
    34c0:	91 e0       	ldi	r25, 0x01	; 1
    34c2:	68 16       	cp	r6, r24
    34c4:	08 f0       	brcs	.+2      	; 0x34c8 <calcChecksumFRAM+0x462>
    34c6:	90 e0       	ldi	r25, 0x00	; 0
    34c8:	46 0d       	add	r20, r6
    34ca:	81 e0       	ldi	r24, 0x01	; 1
    34cc:	46 15       	cp	r20, r6
    34ce:	08 f0       	brcs	.+2      	; 0x34d2 <calcChecksumFRAM+0x46c>
    34d0:	80 e0       	ldi	r24, 0x00	; 0
    34d2:	98 2b       	or	r25, r24
    34d4:	8d 81       	ldd	r24, Y+5	; 0x05
    34d6:	e8 0f       	add	r30, r24
    34d8:	9e 0f       	add	r25, r30
    34da:	5e 80       	ldd	r5, Y+6	; 0x06
    34dc:	f8 01       	movw	r30, r16
    34de:	50 82       	st	Z, r5
    34e0:	8b 81       	ldd	r24, Y+3	; 0x03
    34e2:	81 83       	std	Z+1, r24	; 0x01
    34e4:	a2 83       	std	Z+2, r26	; 0x02
    34e6:	73 83       	std	Z+3, r23	; 0x03
    34e8:	64 83       	std	Z+4, r22	; 0x04
    34ea:	55 83       	std	Z+5, r21	; 0x05
    34ec:	46 83       	std	Z+6, r20	; 0x06
    34ee:	97 83       	std	Z+7, r25	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    34f0:	2f 5f       	subi	r18, 0xFF	; 255
    34f2:	3f 4f       	sbci	r19, 0xFF	; 255
    34f4:	9c e1       	ldi	r25, 0x1C	; 28
    34f6:	21 37       	cpi	r18, 0x71	; 113
    34f8:	39 07       	cpc	r19, r25
    34fa:	09 f0       	breq	.+2      	; 0x34fe <calcChecksumFRAM+0x498>
    34fc:	39 ce       	rjmp	.-910    	; 0x3170 <calcChecksumFRAM+0x10a>
    34fe:	a9 81       	ldd	r26, Y+1	; 0x01
    3500:	ba 81       	ldd	r27, Y+2	; 0x02
    3502:	11 97       	sbiw	r26, 0x01	; 1
    3504:	a9 83       	std	Y+1, r26	; 0x01
    3506:	ba 83       	std	Y+2, r27	; 0x02

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3508:	10 97       	sbiw	r26, 0x00	; 0
    350a:	09 f0       	breq	.+2      	; 0x350e <calcChecksumFRAM+0x4a8>
    350c:	1c ce       	rjmp	.-968    	; 0x3146 <calcChecksumFRAM+0xe0>
			
		}	
		
	}
	
}
    350e:	26 96       	adiw	r28, 0x06	; 6
    3510:	cd bf       	out	0x3d, r28	; 61
    3512:	de bf       	out	0x3e, r29	; 62
    3514:	df 91       	pop	r29
    3516:	cf 91       	pop	r28
    3518:	1f 91       	pop	r17
    351a:	0f 91       	pop	r16
    351c:	ff 90       	pop	r15
    351e:	ef 90       	pop	r14
    3520:	df 90       	pop	r13
    3522:	cf 90       	pop	r12
    3524:	bf 90       	pop	r11
    3526:	af 90       	pop	r10
    3528:	9f 90       	pop	r9
    352a:	8f 90       	pop	r8
    352c:	7f 90       	pop	r7
    352e:	6f 90       	pop	r6
    3530:	5f 90       	pop	r5
    3532:	4f 90       	pop	r4
    3534:	3f 90       	pop	r3
    3536:	2f 90       	pop	r2
    3538:	08 95       	ret

0000353a <FRAMTest1Channel>:

	ADCPower(FALSE);
	
}

void FRAMTest1Channel(void) {
    353a:	8f 92       	push	r8
    353c:	9f 92       	push	r9
    353e:	af 92       	push	r10
    3540:	bf 92       	push	r11
    3542:	cf 92       	push	r12
    3544:	df 92       	push	r13
    3546:	ef 92       	push	r14
    3548:	0f 93       	push	r16

	CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
    354a:	0f 92       	push	r0
    354c:	0f 92       	push	r0
    354e:	80 e1       	ldi	r24, 0x10	; 16
    3550:	90 e0       	ldi	r25, 0x00	; 0
    3552:	ed b7       	in	r30, 0x3d	; 61
    3554:	fe b7       	in	r31, 0x3e	; 62
    3556:	81 83       	std	Z+1, r24	; 0x01
    3558:	92 83       	std	Z+2, r25	; 0x02
    355a:	87 e0       	ldi	r24, 0x07	; 7
    355c:	68 ec       	ldi	r22, 0xC8	; 200
    355e:	40 e0       	ldi	r20, 0x00	; 0
    3560:	20 e0       	ldi	r18, 0x00	; 0
    3562:	05 e1       	ldi	r16, 0x15	; 21
    3564:	ee 24       	eor	r14, r14
    3566:	e3 94       	inc	r14
    3568:	0f 2e       	mov	r0, r31
    356a:	fd e0       	ldi	r31, 0x0D	; 13
    356c:	cf 2e       	mov	r12, r31
    356e:	dd 24       	eor	r13, r13
    3570:	f0 2d       	mov	r31, r0
    3572:	0f 2e       	mov	r0, r31
    3574:	fe e0       	ldi	r31, 0x0E	; 14
    3576:	af 2e       	mov	r10, r31
    3578:	bb 24       	eor	r11, r11
    357a:	f0 2d       	mov	r31, r0
    357c:	0f 2e       	mov	r0, r31
    357e:	ff e0       	ldi	r31, 0x0F	; 15
    3580:	8f 2e       	mov	r8, r31
    3582:	99 24       	eor	r9, r9
    3584:	f0 2d       	mov	r31, r0
    3586:	0e 94 28 14 	call	0x2850	; 0x2850 <CO_collectSeismic1Channel>
	GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    358a:	0f 90       	pop	r0
    358c:	0f 90       	pop	r0
    358e:	81 e0       	ldi	r24, 0x01	; 1
    3590:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3594:	8f ec       	ldi	r24, 0xCF	; 207
    3596:	97 e0       	ldi	r25, 0x07	; 7
    3598:	01 97       	sbiw	r24, 0x01	; 1
    359a:	f1 f7       	brne	.-4      	; 0x3598 <FRAMTest1Channel+0x5e>
    359c:	00 c0       	rjmp	.+0      	; 0x359e <FRAMTest1Channel+0x64>
    359e:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    35a0:	0e 94 33 18 	call	0x3066	; 0x3066 <calcChecksumFRAM>

	ADCPower(FALSE);
    35a4:	80 e0       	ldi	r24, 0x00	; 0
    35a6:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>

}
    35aa:	0f 91       	pop	r16
    35ac:	ef 90       	pop	r14
    35ae:	df 90       	pop	r13
    35b0:	cf 90       	pop	r12
    35b2:	bf 90       	pop	r11
    35b4:	af 90       	pop	r10
    35b6:	9f 90       	pop	r9
    35b8:	8f 90       	pop	r8
    35ba:	08 95       	ret

000035bc <FRAMTest3Channel>:
	SPICS(FALSE);
	SPIDisable();

}

void FRAMTest3Channel(void) {
    35bc:	8f 92       	push	r8
    35be:	9f 92       	push	r9
    35c0:	af 92       	push	r10
    35c2:	bf 92       	push	r11
    35c4:	cf 92       	push	r12
    35c6:	df 92       	push	r13
    35c8:	ef 92       	push	r14
    35ca:	ff 92       	push	r15
    35cc:	0f 93       	push	r16
    35ce:	cf 93       	push	r28
    35d0:	df 93       	push	r29
    35d2:	00 d0       	rcall	.+0      	; 0x35d4 <FRAMTest3Channel+0x18>
    35d4:	cd b7       	in	r28, 0x3d	; 61
    35d6:	de b7       	in	r29, 0x3e	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    35d8:	19 82       	std	Y+1, r1	; 0x01
    35da:	1a 82       	std	Y+2, r1	; 0x02
    35dc:	1b 82       	std	Y+3, r1	; 0x03
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    35de:	8e ec       	ldi	r24, 0xCE	; 206
    35e0:	be 01       	movw	r22, r28
    35e2:	6f 5f       	subi	r22, 0xFF	; 255
    35e4:	7f 4f       	sbci	r23, 0xFF	; 255
    35e6:	40 e0       	ldi	r20, 0x00	; 0
    35e8:	25 e1       	ldi	r18, 0x15	; 21
    35ea:	01 e0       	ldi	r16, 0x01	; 1
    35ec:	0f 2e       	mov	r0, r31
    35ee:	fd e0       	ldi	r31, 0x0D	; 13
    35f0:	ef 2e       	mov	r14, r31
    35f2:	ff 24       	eor	r15, r15
    35f4:	f0 2d       	mov	r31, r0
    35f6:	0f 2e       	mov	r0, r31
    35f8:	fe e0       	ldi	r31, 0x0E	; 14
    35fa:	cf 2e       	mov	r12, r31
    35fc:	dd 24       	eor	r13, r13
    35fe:	f0 2d       	mov	r31, r0
    3600:	0f 2e       	mov	r0, r31
    3602:	ff e0       	ldi	r31, 0x0F	; 15
    3604:	af 2e       	mov	r10, r31
    3606:	bb 24       	eor	r11, r11
    3608:	f0 2d       	mov	r31, r0
    360a:	88 24       	eor	r8, r8
    360c:	99 24       	eor	r9, r9
    360e:	68 94       	set
    3610:	84 f8       	bld	r8, 4
    3612:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3616:	81 e0       	ldi	r24, 0x01	; 1
    3618:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
    361c:	8f ec       	ldi	r24, 0xCF	; 207
    361e:	97 e0       	ldi	r25, 0x07	; 7
    3620:	01 97       	sbiw	r24, 0x01	; 1
    3622:	f1 f7       	brne	.-4      	; 0x3620 <FRAMTest3Channel+0x64>
    3624:	00 c0       	rjmp	.+0      	; 0x3626 <FRAMTest3Channel+0x6a>
    3626:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3628:	0e 94 33 18 	call	0x3066	; 0x3066 <calcChecksumFRAM>

	ADCPower(FALSE);
    362c:	80 e0       	ldi	r24, 0x00	; 0
    362e:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	
}
    3632:	23 96       	adiw	r28, 0x03	; 3
    3634:	cd bf       	out	0x3d, r28	; 61
    3636:	de bf       	out	0x3e, r29	; 62
    3638:	df 91       	pop	r29
    363a:	cf 91       	pop	r28
    363c:	0f 91       	pop	r16
    363e:	ff 90       	pop	r15
    3640:	ef 90       	pop	r14
    3642:	df 90       	pop	r13
    3644:	cf 90       	pop	r12
    3646:	bf 90       	pop	r11
    3648:	af 90       	pop	r10
    364a:	9f 90       	pop	r9
    364c:	8f 90       	pop	r8
    364e:	08 95       	ret

00003650 <FRAMWriteKnowns>:

	ADCPower(FALSE);

}

void FRAMWriteKnowns() {
    3650:	2f 92       	push	r2
    3652:	3f 92       	push	r3
    3654:	4f 92       	push	r4
    3656:	5f 92       	push	r5
    3658:	6f 92       	push	r6
    365a:	7f 92       	push	r7
    365c:	8f 92       	push	r8
    365e:	9f 92       	push	r9
    3660:	af 92       	push	r10
    3662:	bf 92       	push	r11
    3664:	cf 92       	push	r12
    3666:	df 92       	push	r13
    3668:	ef 92       	push	r14
    366a:	ff 92       	push	r15
    366c:	0f 93       	push	r16
    366e:	1f 93       	push	r17
    3670:	cf 93       	push	r28
    3672:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    3674:	10 92 3f 40 	sts	0x403F, r1
    3678:	10 92 40 40 	sts	0x4040, r1
	sampleCount = 0;
    367c:	10 92 49 40 	sts	0x4049, r1
    3680:	10 92 4a 40 	sts	0x404A, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3684:	8e eb       	ldi	r24, 0xBE	; 190
    3686:	91 e2       	ldi	r25, 0x21	; 33
    3688:	10 92 be 21 	sts	0x21BE, r1
    368c:	fc 01       	movw	r30, r24
    368e:	31 97       	sbiw	r30, 0x01	; 1
    3690:	10 82       	st	Z, r1
    3692:	02 97       	sbiw	r24, 0x02	; 2
    3694:	ec 01       	movw	r28, r24
    3696:	18 82       	st	Y, r1
	
	ADCPower(TRUE);
    3698:	81 e0       	ldi	r24, 0x01	; 1
    369a:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    369e:	84 e0       	ldi	r24, 0x04	; 4
    36a0:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    36a4:	80 ed       	ldi	r24, 0xD0	; 208
    36a6:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    36aa:	8d e0       	ldi	r24, 0x0D	; 13
    36ac:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[1] = 0xF3;
    36b0:	83 ef       	ldi	r24, 0xF3	; 243
    36b2:	80 93 68 50 	sts	0x5068, r24
	SPIBuffer[2] = 0x57;
    36b6:	87 e5       	ldi	r24, 0x57	; 87
    36b8:	80 93 69 50 	sts	0x5069, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    36bc:	80 91 49 40 	lds	r24, 0x4049
    36c0:	90 91 4a 40 	lds	r25, 0x404A
    36c4:	d5 e5       	ldi	r29, 0x55	; 85
    36c6:	83 35       	cpi	r24, 0x53	; 83
    36c8:	9d 07       	cpc	r25, r29
    36ca:	08 f0       	brcs	.+2      	; 0x36ce <FRAMWriteKnowns+0x7e>
    36cc:	ac c0       	rjmp	.+344    	; 0x3826 <FRAMWriteKnowns+0x1d6>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    36ce:	00 e4       	ldi	r16, 0x40	; 64
    36d0:	16 e0       	ldi	r17, 0x06	; 6
    36d2:	30 e1       	ldi	r19, 0x10	; 16
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    36d4:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    36d6:	e0 ec       	ldi	r30, 0xC0	; 192
    36d8:	f8 e0       	ldi	r31, 0x08	; 8
    36da:	0f 2e       	mov	r0, r31
    36dc:	f6 e0       	ldi	r31, 0x06	; 6
    36de:	9f 2e       	mov	r9, r31
    36e0:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    36e2:	a3 e7       	ldi	r26, 0x73	; 115
    36e4:	b0 e5       	ldi	r27, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    36e6:	88 24       	eor	r8, r8
    36e8:	68 94       	set
    36ea:	81 f8       	bld	r8, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    36ec:	0f 2e       	mov	r0, r31
    36ee:	ff e3       	ldi	r31, 0x3F	; 63
    36f0:	ef 2e       	mov	r14, r31
    36f2:	f0 e4       	ldi	r31, 0x40	; 64
    36f4:	ff 2e       	mov	r15, r31
    36f6:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    36f8:	bd 01       	movw	r22, r26
    36fa:	6c 50       	subi	r22, 0x0C	; 12
    36fc:	70 40       	sbci	r23, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    36fe:	0f 2e       	mov	r0, r31
    3700:	f5 ef       	ldi	r31, 0xF5	; 245
    3702:	6f 2e       	mov	r6, r31
    3704:	ff ef       	ldi	r31, 0xFF	; 255
    3706:	7f 2e       	mov	r7, r31
    3708:	f0 2d       	mov	r31, r0
    370a:	6a 0e       	add	r6, r26
    370c:	7b 1e       	adc	r7, r27
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    370e:	0f 2e       	mov	r0, r31
    3710:	f6 ef       	ldi	r31, 0xF6	; 246
    3712:	4f 2e       	mov	r4, r31
    3714:	ff ef       	ldi	r31, 0xFF	; 255
    3716:	5f 2e       	mov	r5, r31
    3718:	f0 2d       	mov	r31, r0
    371a:	4a 0e       	add	r4, r26
    371c:	5b 1e       	adc	r5, r27
			
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    371e:	4c eb       	ldi	r20, 0xBC	; 188
    3720:	51 e2       	ldi	r21, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    3722:	6a 01       	movw	r12, r20
    3724:	08 94       	sec
    3726:	c1 1c       	adc	r12, r1
    3728:	d1 1c       	adc	r13, r1
    372a:	1b 01       	movw	r2, r22
    372c:	08 94       	sec
    372e:	21 1c       	adc	r2, r1
    3730:	31 1c       	adc	r3, r1
		checksumADC[2] += SPIBuffer[2];
    3732:	aa 24       	eor	r10, r10
    3734:	bb 24       	eor	r11, r11
    3736:	68 94       	set
    3738:	a1 f8       	bld	r10, 1
    373a:	a4 0e       	add	r10, r20
    373c:	b5 1e       	adc	r11, r21
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    373e:	e8 01       	movw	r28, r16
    3740:	3e 83       	std	Y+6, r19	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3742:	20 93 26 06 	sts	0x0626, r18
		nop();
    3746:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3748:	93 82       	std	Z+3, r9	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    374a:	82 81       	ldd	r24, Z+2	; 0x02
    374c:	88 23       	and	r24, r24
    374e:	ec f7       	brge	.-6      	; 0x374a <FRAMWriteKnowns+0xfa>
		SPIBuffer[12] = SPIC.DATA;
    3750:	83 81       	ldd	r24, Z+3	; 0x03
    3752:	8c 93       	st	X, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3754:	20 93 25 06 	sts	0x0625, r18
		nop(); // time for CS_FRAM to accept high signal
    3758:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    375a:	20 93 26 06 	sts	0x0626, r18
		nop();
    375e:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    3760:	83 82       	std	Z+3, r8	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3762:	82 81       	ldd	r24, Z+2	; 0x02
    3764:	88 23       	and	r24, r24
    3766:	ec f7       	brge	.-6      	; 0x3762 <FRAMWriteKnowns+0x112>
		SPIBuffer[12] = SPIC.DATA;
    3768:	83 81       	ldd	r24, Z+3	; 0x03
    376a:	8c 93       	st	X, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    376c:	e7 01       	movw	r28, r14
    376e:	89 81       	ldd	r24, Y+1	; 0x01
    3770:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3772:	82 81       	ldd	r24, Z+2	; 0x02
    3774:	88 23       	and	r24, r24
    3776:	ec f7       	brge	.-6      	; 0x3772 <FRAMWriteKnowns+0x122>
		SPIBuffer[12] = SPIC.DATA;
    3778:	83 81       	ldd	r24, Z+3	; 0x03
    377a:	8c 93       	st	X, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    377c:	e7 01       	movw	r28, r14
    377e:	88 81       	ld	r24, Y
    3780:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3782:	82 81       	ldd	r24, Z+2	; 0x02
    3784:	88 23       	and	r24, r24
    3786:	ec f7       	brge	.-6      	; 0x3782 <FRAMWriteKnowns+0x132>
		SPIBuffer[12] = SPIC.DATA;
    3788:	83 81       	ldd	r24, Z+3	; 0x03
    378a:	8c 93       	st	X, r24
		SPIC.DATA = SPIBuffer[0];
    378c:	eb 01       	movw	r28, r22
    378e:	88 81       	ld	r24, Y
    3790:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3792:	82 81       	ldd	r24, Z+2	; 0x02
    3794:	88 23       	and	r24, r24
    3796:	ec f7       	brge	.-6      	; 0x3792 <FRAMWriteKnowns+0x142>
		SPIBuffer[12] = SPIC.DATA;
    3798:	83 81       	ldd	r24, Z+3	; 0x03
    379a:	8c 93       	st	X, r24
		SPIC.DATA = SPIBuffer[1];
    379c:	e3 01       	movw	r28, r6
    379e:	88 81       	ld	r24, Y
    37a0:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37a2:	82 81       	ldd	r24, Z+2	; 0x02
    37a4:	88 23       	and	r24, r24
    37a6:	ec f7       	brge	.-6      	; 0x37a2 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    37a8:	83 81       	ldd	r24, Z+3	; 0x03
    37aa:	8c 93       	st	X, r24
		SPIC.DATA = SPIBuffer[2];
    37ac:	e2 01       	movw	r28, r4
    37ae:	88 81       	ld	r24, Y
    37b0:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37b2:	82 81       	ldd	r24, Z+2	; 0x02
    37b4:	88 23       	and	r24, r24
    37b6:	ec f7       	brge	.-6      	; 0x37b2 <FRAMWriteKnowns+0x162>
		SPIBuffer[12] = SPIC.DATA;
    37b8:	83 81       	ldd	r24, Z+3	; 0x03
    37ba:	8c 93       	st	X, r24
			
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    37bc:	20 93 25 06 	sts	0x0625, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    37c0:	e8 01       	movw	r28, r16
    37c2:	3d 83       	std	Y+5, r19	; 0x05
		
		FRAMAddress +=3;
    37c4:	80 91 3f 40 	lds	r24, 0x403F
    37c8:	90 91 40 40 	lds	r25, 0x4040
    37cc:	03 96       	adiw	r24, 0x03	; 3
    37ce:	80 93 3f 40 	sts	0x403F, r24
    37d2:	90 93 40 40 	sts	0x4040, r25
		checksumADC[0] += SPIBuffer[0];
    37d6:	ea 01       	movw	r28, r20
    37d8:	88 81       	ld	r24, Y
    37da:	eb 01       	movw	r28, r22
    37dc:	98 81       	ld	r25, Y
    37de:	89 0f       	add	r24, r25
    37e0:	ea 01       	movw	r28, r20
    37e2:	88 83       	st	Y, r24
		checksumADC[1] += SPIBuffer[1];
    37e4:	e6 01       	movw	r28, r12
    37e6:	88 81       	ld	r24, Y
    37e8:	e1 01       	movw	r28, r2
    37ea:	98 81       	ld	r25, Y
    37ec:	89 0f       	add	r24, r25
    37ee:	e6 01       	movw	r28, r12
    37f0:	88 83       	st	Y, r24
		checksumADC[2] += SPIBuffer[2];
    37f2:	e5 01       	movw	r28, r10
    37f4:	88 81       	ld	r24, Y
    37f6:	c9 e6       	ldi	r28, 0x69	; 105
    37f8:	d0 e5       	ldi	r29, 0x50	; 80
    37fa:	98 81       	ld	r25, Y
    37fc:	89 0f       	add	r24, r25
    37fe:	e5 01       	movw	r28, r10
    3800:	88 83       	st	Y, r24
		
		sampleCount++;
    3802:	80 91 49 40 	lds	r24, 0x4049
    3806:	90 91 4a 40 	lds	r25, 0x404A
    380a:	01 96       	adiw	r24, 0x01	; 1
    380c:	80 93 49 40 	sts	0x4049, r24
    3810:	90 93 4a 40 	sts	0x404A, r25
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3814:	80 91 49 40 	lds	r24, 0x4049
    3818:	90 91 4a 40 	lds	r25, 0x404A
    381c:	d5 e5       	ldi	r29, 0x55	; 85
    381e:	83 35       	cpi	r24, 0x53	; 83
    3820:	9d 07       	cpc	r25, r29
    3822:	08 f4       	brcc	.+2      	; 0x3826 <FRAMWriteKnowns+0x1d6>
    3824:	8c cf       	rjmp	.-232    	; 0x373e <FRAMWriteKnowns+0xee>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    3826:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	ADCPower(FALSE);
    382a:	80 e0       	ldi	r24, 0x00	; 0
    382c:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
}
    3830:	df 91       	pop	r29
    3832:	cf 91       	pop	r28
    3834:	1f 91       	pop	r17
    3836:	0f 91       	pop	r16
    3838:	ff 90       	pop	r15
    383a:	ef 90       	pop	r14
    383c:	df 90       	pop	r13
    383e:	cf 90       	pop	r12
    3840:	bf 90       	pop	r11
    3842:	af 90       	pop	r10
    3844:	9f 90       	pop	r9
    3846:	8f 90       	pop	r8
    3848:	7f 90       	pop	r7
    384a:	6f 90       	pop	r6
    384c:	5f 90       	pop	r5
    384e:	4f 90       	pop	r4
    3850:	3f 90       	pop	r3
    3852:	2f 90       	pop	r2
    3854:	08 95       	ret

00003856 <FRAMWriteKnownsCheck>:
	
}


void FRAMWriteKnownsCheck() {
	FRAMWriteKnowns();
    3856:	0e 94 28 1b 	call	0x3650	; 0x3650 <FRAMWriteKnowns>
	ADCPower(TRUE);
    385a:	81 e0       	ldi	r24, 0x01	; 1
    385c:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
    3860:	8f ec       	ldi	r24, 0xCF	; 207
    3862:	97 e0       	ldi	r25, 0x07	; 7
    3864:	01 97       	sbiw	r24, 0x01	; 1
    3866:	f1 f7       	brne	.-4      	; 0x3864 <FRAMWriteKnownsCheck+0xe>
    3868:	00 c0       	rjmp	.+0      	; 0x386a <FRAMWriteKnownsCheck+0x14>
    386a:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    386c:	0e 94 33 18 	call	0x3066	; 0x3066 <calcChecksumFRAM>

	ADCPower(FALSE);
    3870:	80 e0       	ldi	r24, 0x00	; 0
    3872:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>

}
    3876:	08 95       	ret

00003878 <SPI_write>:
}

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    3878:	e0 ec       	ldi	r30, 0xC0	; 192
    387a:	f8 e0       	ldi	r31, 0x08	; 8
    387c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    387e:	82 81       	ldd	r24, Z+2	; 0x02
    3880:	88 23       	and	r24, r24
    3882:	ec f7       	brge	.-6      	; 0x387e <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    3884:	e0 ec       	ldi	r30, 0xC0	; 192
    3886:	f8 e0       	ldi	r31, 0x08	; 8
    3888:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    388a:	08 95       	ret

0000388c <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    388c:	8f 92       	push	r8
    388e:	9f 92       	push	r9
    3890:	af 92       	push	r10
    3892:	bf 92       	push	r11
    3894:	cf 92       	push	r12
    3896:	df 92       	push	r13
    3898:	ef 92       	push	r14
    389a:	ff 92       	push	r15
    389c:	0f 93       	push	r16
    389e:	1f 93       	push	r17
    38a0:	cf 93       	push	r28
    38a2:	df 93       	push	r29
    38a4:	84 2e       	mov	r8, r20
    38a6:	a5 2e       	mov	r10, r21
    38a8:	c6 2e       	mov	r12, r22
    38aa:	c7 2f       	mov	r28, r23
    38ac:	d2 2f       	mov	r29, r18
    38ae:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    38b0:	80 64       	ori	r24, 0x40	; 64
    38b2:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    38b6:	8c 2f       	mov	r24, r28
    38b8:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    38bc:	8c 2d       	mov	r24, r12
    38be:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    38c2:	8a 2d       	mov	r24, r10
    38c4:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    38c8:	88 2d       	mov	r24, r8
    38ca:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	SPI_write(crc);
    38ce:	8d 2f       	mov	r24, r29
    38d0:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	
	for(int i=0; i<read; i++){
    38d4:	10 16       	cp	r1, r16
    38d6:	11 06       	cpc	r1, r17
    38d8:	64 f5       	brge	.+88     	; 0x3932 <SD_command+0xa6>
    38da:	00 e0       	ldi	r16, 0x00	; 0
    38dc:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    38de:	0f 2e       	mov	r0, r31
    38e0:	fd e0       	ldi	r31, 0x0D	; 13
    38e2:	cf 2e       	mov	r12, r31
    38e4:	dd 24       	eor	r13, r13
    38e6:	f0 2d       	mov	r31, r0
    38e8:	0f 2e       	mov	r0, r31
    38ea:	f1 e9       	ldi	r31, 0x91	; 145
    38ec:	af 2e       	mov	r10, r31
    38ee:	f0 e5       	ldi	r31, 0x50	; 80
    38f0:	bf 2e       	mov	r11, r31
    38f2:	f0 2d       	mov	r31, r0
    38f4:	c8 01       	movw	r24, r16
    38f6:	b6 01       	movw	r22, r12
    38f8:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    38fc:	ec 01       	movw	r28, r24
    38fe:	8f ef       	ldi	r24, 0xFF	; 255
    3900:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3904:	f5 01       	movw	r30, r10
    3906:	ec 0f       	add	r30, r28
    3908:	fd 1f       	adc	r31, r29
    390a:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    390c:	80 81       	ld	r24, Z
    390e:	8f 3f       	cpi	r24, 0xFF	; 255
    3910:	49 f0       	breq	.+18     	; 0x3924 <SD_command+0x98>
			 Buffer[1] = Buffer[i%13];
    3912:	fe 01       	movw	r30, r28
    3914:	ef 56       	subi	r30, 0x6F	; 111
    3916:	ff 4a       	sbci	r31, 0xAF	; 175
    3918:	80 81       	ld	r24, Z
    391a:	80 93 92 50 	sts	0x5092, r24
			 return Buffer[1];
    391e:	80 91 92 50 	lds	r24, 0x5092
    3922:	08 c0       	rjmp	.+16     	; 0x3934 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    3924:	0f 5f       	subi	r16, 0xFF	; 255
    3926:	1f 4f       	sbci	r17, 0xFF	; 255
    3928:	0e 15       	cp	r16, r14
    392a:	1f 05       	cpc	r17, r15
    392c:	19 f7       	brne	.-58     	; 0x38f4 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			 Buffer[1] = Buffer[i%13];
			 return Buffer[1];
		}			
	}
	return SDHC_DUMMY_BYTE;	
    392e:	8f ef       	ldi	r24, 0xFF	; 255
    3930:	01 c0       	rjmp	.+2      	; 0x3934 <SD_command+0xa8>
    3932:	8f ef       	ldi	r24, 0xFF	; 255
}
    3934:	df 91       	pop	r29
    3936:	cf 91       	pop	r28
    3938:	1f 91       	pop	r17
    393a:	0f 91       	pop	r16
    393c:	ff 90       	pop	r15
    393e:	ef 90       	pop	r14
    3940:	df 90       	pop	r13
    3942:	cf 90       	pop	r12
    3944:	bf 90       	pop	r11
    3946:	af 90       	pop	r10
    3948:	9f 90       	pop	r9
    394a:	8f 90       	pop	r8
    394c:	08 95       	ret

0000394e <SD_write_block>:
//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    394e:	6f 92       	push	r6
    3950:	7f 92       	push	r7
    3952:	8f 92       	push	r8
    3954:	9f 92       	push	r9
    3956:	af 92       	push	r10
    3958:	bf 92       	push	r11
    395a:	cf 92       	push	r12
    395c:	df 92       	push	r13
    395e:	ef 92       	push	r14
    3960:	ff 92       	push	r15
    3962:	0f 93       	push	r16
    3964:	1f 93       	push	r17
    3966:	cf 93       	push	r28
    3968:	df 93       	push	r29
    396a:	4b 01       	movw	r8, r22
    396c:	5c 01       	movw	r10, r24
    396e:	74 2e       	mov	r7, r20
    3970:	65 2e       	mov	r6, r21
    3972:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3974:	88 e0       	ldi	r24, 0x08	; 8
    3976:	60 e0       	ldi	r22, 0x00	; 0
    3978:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    397c:	80 e0       	ldi	r24, 0x00	; 0
    397e:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    3982:	81 e0       	ldi	r24, 0x01	; 1
    3984:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    3988:	80 e0       	ldi	r24, 0x00	; 0
    398a:	92 e0       	ldi	r25, 0x02	; 2
    398c:	7c 01       	movw	r14, r24
    398e:	ec 18       	sub	r14, r12
    3990:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    3992:	80 e0       	ldi	r24, 0x00	; 0
    3994:	e8 16       	cp	r14, r24
    3996:	82 e0       	ldi	r24, 0x02	; 2
    3998:	f8 06       	cpc	r15, r24
    399a:	11 f4       	brne	.+4      	; 0x39a0 <SD_write_block+0x52>
    399c:	ee 24       	eor	r14, r14
    399e:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    39a0:	cb e0       	ldi	r28, 0x0B	; 11
    39a2:	d0 e0       	ldi	r29, 0x00	; 0
    39a4:	03 c0       	rjmp	.+6      	; 0x39ac <SD_write_block+0x5e>
    39a6:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    39a8:	09 f4       	brne	.+2      	; 0x39ac <SD_write_block+0x5e>
    39aa:	ff cf       	rjmp	.-2      	; 0x39aa <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    39ac:	88 e1       	ldi	r24, 0x18	; 24
    39ae:	b5 01       	movw	r22, r10
    39b0:	a4 01       	movw	r20, r8
    39b2:	2f ef       	ldi	r18, 0xFF	; 255
    39b4:	08 e0       	ldi	r16, 0x08	; 8
    39b6:	10 e0       	ldi	r17, 0x00	; 0
    39b8:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
    39bc:	88 23       	and	r24, r24
    39be:	99 f7       	brne	.-26     	; 0x39a6 <SD_write_block+0x58>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    39c0:	8f ef       	ldi	r24, 0xFF	; 255
    39c2:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    39c6:	80 93 91 50 	sts	0x5091, r24
	SPI_write(SDHC_DATA_TOKEN);	//send data token
    39ca:	8e ef       	ldi	r24, 0xFE	; 254
    39cc:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    39d0:	1c 14       	cp	r1, r12
    39d2:	1d 04       	cpc	r1, r13
    39d4:	bc f4       	brge	.+46     	; 0x3a04 <SD_write_block+0xb6>
    39d6:	87 2c       	mov	r8, r7
    39d8:	96 2c       	mov	r9, r6
    39da:	00 e0       	ldi	r16, 0x00	; 0
    39dc:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(data[i]);
    39de:	c8 01       	movw	r24, r16
    39e0:	6d e0       	ldi	r22, 0x0D	; 13
    39e2:	70 e0       	ldi	r23, 0x00	; 0
    39e4:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    39e8:	ec 01       	movw	r28, r24
    39ea:	f4 01       	movw	r30, r8
    39ec:	81 91       	ld	r24, Z+
    39ee:	4f 01       	movw	r8, r30
    39f0:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    39f4:	cf 56       	subi	r28, 0x6F	; 111
    39f6:	df 4a       	sbci	r29, 0xAF	; 175
    39f8:	88 83       	st	Y, r24
			while(1);
		}
	}
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
	SPI_write(SDHC_DATA_TOKEN);	//send data token
	for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    39fa:	0f 5f       	subi	r16, 0xFF	; 255
    39fc:	1f 4f       	sbci	r17, 0xFF	; 255
    39fe:	0c 15       	cp	r16, r12
    3a00:	1d 05       	cpc	r17, r13
    3a02:	69 f7       	brne	.-38     	; 0x39de <SD_write_block+0x90>
		Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    3a04:	1e 14       	cp	r1, r14
    3a06:	1f 04       	cpc	r1, r15
    3a08:	ec f4       	brge	.+58     	; 0x3a44 <SD_write_block+0xf6>
    3a0a:	00 e0       	ldi	r16, 0x00	; 0
    3a0c:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    3a0e:	0f 2e       	mov	r0, r31
    3a10:	fd e0       	ldi	r31, 0x0D	; 13
    3a12:	cf 2e       	mov	r12, r31
    3a14:	dd 24       	eor	r13, r13
    3a16:	f0 2d       	mov	r31, r0
    3a18:	0f 2e       	mov	r0, r31
    3a1a:	f1 e9       	ldi	r31, 0x91	; 145
    3a1c:	8f 2e       	mov	r8, r31
    3a1e:	f0 e5       	ldi	r31, 0x50	; 80
    3a20:	9f 2e       	mov	r9, r31
    3a22:	f0 2d       	mov	r31, r0
    3a24:	c8 01       	movw	r24, r16
    3a26:	b6 01       	movw	r22, r12
    3a28:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    3a2c:	ec 01       	movw	r28, r24
    3a2e:	80 e0       	ldi	r24, 0x00	; 0
    3a30:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3a34:	c8 0d       	add	r28, r8
    3a36:	d9 1d       	adc	r29, r9
    3a38:	88 83       	st	Y, r24
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
	SPI_write(SDHC_DATA_TOKEN);	//send data token
	for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
		Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    3a3a:	0f 5f       	subi	r16, 0xFF	; 255
    3a3c:	1f 4f       	sbci	r17, 0xFF	; 255
    3a3e:	0e 15       	cp	r16, r14
    3a40:	1f 05       	cpc	r17, r15
    3a42:	81 f7       	brne	.-32     	; 0x3a24 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    3a44:	8f ef       	ldi	r24, 0xFF	; 255
    3a46:	80 93 91 50 	sts	0x5091, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    3a4a:	c0 e0       	ldi	r28, 0x00	; 0
    3a4c:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    3a4e:	01 e9       	ldi	r16, 0x91	; 145
    3a50:	10 e5       	ldi	r17, 0x50	; 80
    3a52:	8f ef       	ldi	r24, 0xFF	; 255
    3a54:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3a58:	f8 01       	movw	r30, r16
    3a5a:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    3a5c:	21 96       	adiw	r28, 0x01	; 1
    3a5e:	c2 30       	cpi	r28, 0x02	; 2
    3a60:	d1 05       	cpc	r29, r1
    3a62:	bc f3       	brlt	.-18     	; 0x3a52 <SD_write_block+0x104>
    3a64:	80 81       	ld	r24, Z
    3a66:	8f 3f       	cpi	r24, 0xFF	; 255
    3a68:	a1 f3       	breq	.-24     	; 0x3a52 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    3a6a:	80 91 91 50 	lds	r24, 0x5091
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    3a6e:	80 91 91 50 	lds	r24, 0x5091
    3a72:	8f 3f       	cpi	r24, 0xFF	; 255
    3a74:	49 f0       	breq	.+18     	; 0x3a88 <SD_write_block+0x13a>
    3a76:	c1 e9       	ldi	r28, 0x91	; 145
    3a78:	d0 e5       	ldi	r29, 0x50	; 80
    3a7a:	8f ef       	ldi	r24, 0xFF	; 255
    3a7c:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3a80:	88 83       	st	Y, r24
    3a82:	88 81       	ld	r24, Y
    3a84:	8f 3f       	cpi	r24, 0xFF	; 255
    3a86:	c9 f7       	brne	.-14     	; 0x3a7a <SD_write_block+0x12c>
	SPICS(FALSE);
    3a88:	80 e0       	ldi	r24, 0x00	; 0
    3a8a:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    3a8e:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    3a92:	88 e0       	ldi	r24, 0x08	; 8
    3a94:	60 e0       	ldi	r22, 0x00	; 0
    3a96:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
}
    3a9a:	df 91       	pop	r29
    3a9c:	cf 91       	pop	r28
    3a9e:	1f 91       	pop	r17
    3aa0:	0f 91       	pop	r16
    3aa2:	ff 90       	pop	r15
    3aa4:	ef 90       	pop	r14
    3aa6:	df 90       	pop	r13
    3aa8:	cf 90       	pop	r12
    3aaa:	bf 90       	pop	r11
    3aac:	af 90       	pop	r10
    3aae:	9f 90       	pop	r9
    3ab0:	8f 90       	pop	r8
    3ab2:	7f 90       	pop	r7
    3ab4:	6f 90       	pop	r6
    3ab6:	08 95       	ret

00003ab8 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    3ab8:	af 92       	push	r10
    3aba:	bf 92       	push	r11
    3abc:	cf 92       	push	r12
    3abe:	df 92       	push	r13
    3ac0:	ef 92       	push	r14
    3ac2:	ff 92       	push	r15
    3ac4:	0f 93       	push	r16
    3ac6:	1f 93       	push	r17
    3ac8:	cf 93       	push	r28
    3aca:	df 93       	push	r29
    3acc:	6b 01       	movw	r12, r22
    3ace:	7c 01       	movw	r14, r24
    3ad0:	b4 2e       	mov	r11, r20
    3ad2:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3ad4:	88 e0       	ldi	r24, 0x08	; 8
    3ad6:	60 e0       	ldi	r22, 0x00	; 0
    3ad8:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    3adc:	80 e0       	ldi	r24, 0x00	; 0
    3ade:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    3ae2:	81 e0       	ldi	r24, 0x01	; 1
    3ae4:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    3ae8:	cb e0       	ldi	r28, 0x0B	; 11
    3aea:	d0 e0       	ldi	r29, 0x00	; 0
    3aec:	03 c0       	rjmp	.+6      	; 0x3af4 <SD_read_block+0x3c>
    3aee:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    3af0:	09 f4       	brne	.+2      	; 0x3af4 <SD_read_block+0x3c>
    3af2:	ff cf       	rjmp	.-2      	; 0x3af2 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    3af4:	81 e1       	ldi	r24, 0x11	; 17
    3af6:	b7 01       	movw	r22, r14
    3af8:	a6 01       	movw	r20, r12
    3afa:	2f ef       	ldi	r18, 0xFF	; 255
    3afc:	08 e0       	ldi	r16, 0x08	; 8
    3afe:	10 e0       	ldi	r17, 0x00	; 0
    3b00:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
    3b04:	88 23       	and	r24, r24
    3b06:	99 f7       	brne	.-26     	; 0x3aee <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    3b08:	80 91 91 50 	lds	r24, 0x5091
    3b0c:	8e 3f       	cpi	r24, 0xFE	; 254
    3b0e:	49 f0       	breq	.+18     	; 0x3b22 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    3b10:	c1 e9       	ldi	r28, 0x91	; 145
    3b12:	d0 e5       	ldi	r29, 0x50	; 80
    3b14:	8f ef       	ldi	r24, 0xFF	; 255
    3b16:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3b1a:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    3b1c:	88 81       	ld	r24, Y
    3b1e:	8e 3f       	cpi	r24, 0xFE	; 254
    3b20:	c9 f7       	brne	.-14     	; 0x3b14 <SD_read_block+0x5c>
    3b22:	0b 2d       	mov	r16, r11
    3b24:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    3b26:	c0 e0       	ldi	r28, 0x00	; 0
    3b28:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    3b2a:	8f ef       	ldi	r24, 0xFF	; 255
    3b2c:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3b30:	f8 01       	movw	r30, r16
    3b32:	81 93       	st	Z+, r24
    3b34:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    3b36:	21 96       	adiw	r28, 0x01	; 1
    3b38:	f2 e0       	ldi	r31, 0x02	; 2
    3b3a:	c0 30       	cpi	r28, 0x00	; 0
    3b3c:	df 07       	cpc	r29, r31
    3b3e:	a9 f7       	brne	.-22     	; 0x3b2a <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    3b40:	10 92 9d 50 	sts	0x509D, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    3b44:	80 91 9d 50 	lds	r24, 0x509D
    3b48:	8f 3f       	cpi	r24, 0xFF	; 255
    3b4a:	49 f0       	breq	.+18     	; 0x3b5e <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    3b4c:	cd e9       	ldi	r28, 0x9D	; 157
    3b4e:	d0 e5       	ldi	r29, 0x50	; 80
    3b50:	8f ef       	ldi	r24, 0xFF	; 255
    3b52:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3b56:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    3b58:	88 81       	ld	r24, Y
    3b5a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b5c:	c9 f7       	brne	.-14     	; 0x3b50 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    3b5e:	80 e0       	ldi	r24, 0x00	; 0
    3b60:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    3b64:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3b68:	88 e0       	ldi	r24, 0x08	; 8
    3b6a:	60 e0       	ldi	r22, 0x00	; 0
    3b6c:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
}
    3b70:	df 91       	pop	r29
    3b72:	cf 91       	pop	r28
    3b74:	1f 91       	pop	r17
    3b76:	0f 91       	pop	r16
    3b78:	ff 90       	pop	r15
    3b7a:	ef 90       	pop	r14
    3b7c:	df 90       	pop	r13
    3b7e:	cf 90       	pop	r12
    3b80:	bf 90       	pop	r11
    3b82:	af 90       	pop	r10
    3b84:	08 95       	ret

00003b86 <checkMote>:

//random function for testing stuff	
void checkMote(){
	ADCPower(TRUE);
    3b86:	81 e0       	ldi	r24, 0x01	; 1
    3b88:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	Ext1Power(TRUE);
    3b8c:	81 e0       	ldi	r24, 0x01	; 1
    3b8e:	0e 94 fd 08 	call	0x11fa	; 0x11fa <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3b92:	8f ef       	ldi	r24, 0xFF	; 255
    3b94:	93 ec       	ldi	r25, 0xC3	; 195
    3b96:	a9 e0       	ldi	r26, 0x09	; 9
    3b98:	81 50       	subi	r24, 0x01	; 1
    3b9a:	90 40       	sbci	r25, 0x00	; 0
    3b9c:	a0 40       	sbci	r26, 0x00	; 0
    3b9e:	e1 f7       	brne	.-8      	; 0x3b98 <checkMote+0x12>
    3ba0:	00 c0       	rjmp	.+0      	; 0x3ba2 <checkMote+0x1c>
    3ba2:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3ba4:	88 e0       	ldi	r24, 0x08	; 8
    3ba6:	60 e0       	ldi	r22, 0x00	; 0
    3ba8:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3bac:	88 e0       	ldi	r24, 0x08	; 8
    3bae:	60 e0       	ldi	r22, 0x00	; 0
    3bb0:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
    3bb4:	8a ea       	ldi	r24, 0xAA	; 170
    3bb6:	96 ee       	ldi	r25, 0xE6	; 230
    3bb8:	a6 e9       	ldi	r26, 0x96	; 150
    3bba:	b1 e0       	ldi	r27, 0x01	; 1
    3bbc:	81 50       	subi	r24, 0x01	; 1
    3bbe:	90 40       	sbci	r25, 0x00	; 0
    3bc0:	a0 40       	sbci	r26, 0x00	; 0
    3bc2:	b0 40       	sbci	r27, 0x00	; 0
    3bc4:	d9 f7       	brne	.-10     	; 0x3bbc <checkMote+0x36>
    3bc6:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3bc8:	88 e0       	ldi	r24, 0x08	; 8
    3bca:	60 e0       	ldi	r22, 0x00	; 0
    3bcc:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
    3bd0:	8a ea       	ldi	r24, 0xAA	; 170
    3bd2:	96 ee       	ldi	r25, 0xE6	; 230
    3bd4:	a6 e9       	ldi	r26, 0x96	; 150
    3bd6:	b1 e0       	ldi	r27, 0x01	; 1
    3bd8:	81 50       	subi	r24, 0x01	; 1
    3bda:	90 40       	sbci	r25, 0x00	; 0
    3bdc:	a0 40       	sbci	r26, 0x00	; 0
    3bde:	b0 40       	sbci	r27, 0x00	; 0
    3be0:	d9 f7       	brne	.-10     	; 0x3bd8 <checkMote+0x52>
    3be2:	00 00       	nop
    3be4:	e3 cf       	rjmp	.-58     	; 0x3bac <checkMote+0x26>

00003be6 <SD_init>:
	}
}

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    3be6:	ff 92       	push	r15
    3be8:	0f 93       	push	r16
    3bea:	1f 93       	push	r17
    3bec:	cf 93       	push	r28
    3bee:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    3bf0:	81 e0       	ldi	r24, 0x01	; 1
    3bf2:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    3bf6:	81 e0       	ldi	r24, 0x01	; 1
    3bf8:	0e 94 fd 08 	call	0x11fa	; 0x11fa <Ext1Power>
    3bfc:	8f ef       	ldi	r24, 0xFF	; 255
    3bfe:	93 ec       	ldi	r25, 0xC3	; 195
    3c00:	a9 e0       	ldi	r26, 0x09	; 9
    3c02:	81 50       	subi	r24, 0x01	; 1
    3c04:	90 40       	sbci	r25, 0x00	; 0
    3c06:	a0 40       	sbci	r26, 0x00	; 0
    3c08:	e1 f7       	brne	.-8      	; 0x3c02 <SD_init+0x1c>
    3c0a:	00 c0       	rjmp	.+0      	; 0x3c0c <SD_init+0x26>
    3c0c:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3c0e:	88 e0       	ldi	r24, 0x08	; 8
    3c10:	60 e0       	ldi	r22, 0x00	; 0
    3c12:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3c16:	88 e0       	ldi	r24, 0x08	; 8
    3c18:	60 e0       	ldi	r22, 0x00	; 0
    3c1a:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    3c1e:	80 e0       	ldi	r24, 0x00	; 0
    3c20:	63 e0       	ldi	r22, 0x03	; 3
    3c22:	0e 94 a1 09 	call	0x1342	; 0x1342 <SPIInit2>
	SPICS(TRUE);
    3c26:	81 e0       	ldi	r24, 0x01	; 1
    3c28:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
    3c2c:	8a e0       	ldi	r24, 0x0A	; 10
    3c2e:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){ // idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    3c30:	e0 ec       	ldi	r30, 0xC0	; 192
    3c32:	f8 e0       	ldi	r31, 0x08	; 8
    3c34:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    3c36:	ad e9       	ldi	r26, 0x9D	; 157
    3c38:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){ // idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    3c3a:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3c3c:	22 81       	ldd	r18, Z+2	; 0x02
    3c3e:	22 23       	and	r18, r18
    3c40:	ec f7       	brge	.-6      	; 0x3c3c <SD_init+0x56>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    3c42:	23 81       	ldd	r18, Z+3	; 0x03
    3c44:	2c 93       	st	X, r18
    3c46:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){ // idle for 10 bytes / 80 clocks
    3c48:	c1 f7       	brne	.-16     	; 0x3c3a <SD_init+0x54>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    3c4a:	80 e0       	ldi	r24, 0x00	; 0
    3c4c:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    3c50:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3c54:	88 e0       	ldi	r24, 0x08	; 8
    3c56:	60 e0       	ldi	r22, 0x00	; 0
    3c58:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    3c5c:	80 e0       	ldi	r24, 0x00	; 0
    3c5e:	63 e0       	ldi	r22, 0x03	; 3
    3c60:	0e 94 a1 09 	call	0x1342	; 0x1342 <SPIInit2>
	SPICS(TRUE);
    3c64:	81 e0       	ldi	r24, 0x01	; 1
    3c66:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    3c6a:	cb e0       	ldi	r28, 0x0B	; 11
    3c6c:	d0 e0       	ldi	r29, 0x00	; 0
    3c6e:	02 c0       	rjmp	.+4      	; 0x3c74 <SD_init+0x8e>
    3c70:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    3c72:	69 f0       	breq	.+26     	; 0x3c8e <SD_init+0xa8>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    3c74:	80 e0       	ldi	r24, 0x00	; 0
    3c76:	40 e0       	ldi	r20, 0x00	; 0
    3c78:	50 e0       	ldi	r21, 0x00	; 0
    3c7a:	ba 01       	movw	r22, r20
    3c7c:	25 e9       	ldi	r18, 0x95	; 149
    3c7e:	08 e0       	ldi	r16, 0x08	; 8
    3c80:	10 e0       	ldi	r17, 0x00	; 0
    3c82:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
    3c86:	81 30       	cpi	r24, 0x01	; 1
    3c88:	99 f7       	brne	.-26     	; 0x3c70 <SD_init+0x8a>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    3c8a:	ff 24       	eor	r15, r15
    3c8c:	02 c0       	rjmp	.+4      	; 0x3c92 <SD_init+0xac>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    3c8e:	ff 24       	eor	r15, r15
    3c90:	f3 94       	inc	r15
    3c92:	8f ef       	ldi	r24, 0xFF	; 255
    3c94:	93 ec       	ldi	r25, 0xC3	; 195
    3c96:	a9 e0       	ldi	r26, 0x09	; 9
    3c98:	81 50       	subi	r24, 0x01	; 1
    3c9a:	90 40       	sbci	r25, 0x00	; 0
    3c9c:	a0 40       	sbci	r26, 0x00	; 0
    3c9e:	e1 f7       	brne	.-8      	; 0x3c98 <SD_init+0xb2>
    3ca0:	00 c0       	rjmp	.+0      	; 0x3ca2 <SD_init+0xbc>
    3ca2:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    3ca4:	cb e0       	ldi	r28, 0x0B	; 11
    3ca6:	d0 e0       	ldi	r29, 0x00	; 0
    3ca8:	02 c0       	rjmp	.+4      	; 0x3cae <SD_init+0xc8>
    3caa:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    3cac:	69 f0       	breq	.+26     	; 0x3cc8 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    3cae:	88 e0       	ldi	r24, 0x08	; 8
    3cb0:	4a ea       	ldi	r20, 0xAA	; 170
    3cb2:	51 e0       	ldi	r21, 0x01	; 1
    3cb4:	60 e0       	ldi	r22, 0x00	; 0
    3cb6:	70 e0       	ldi	r23, 0x00	; 0
    3cb8:	27 e8       	ldi	r18, 0x87	; 135
    3cba:	08 e0       	ldi	r16, 0x08	; 8
    3cbc:	10 e0       	ldi	r17, 0x00	; 0
    3cbe:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
    3cc2:	81 30       	cpi	r24, 0x01	; 1
    3cc4:	91 f7       	brne	.-28     	; 0x3caa <SD_init+0xc4>
    3cc6:	02 c0       	rjmp	.+4      	; 0x3ccc <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    3cc8:	ff 24       	eor	r15, r15
    3cca:	f3 94       	inc	r15
    3ccc:	c2 e0       	ldi	r28, 0x02	; 2
    3cce:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    3cd0:	01 e9       	ldi	r16, 0x91	; 145
    3cd2:	10 e5       	ldi	r17, 0x50	; 80
    3cd4:	8f ef       	ldi	r24, 0xFF	; 255
    3cd6:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3cda:	f8 01       	movw	r30, r16
    3cdc:	ec 0f       	add	r30, r28
    3cde:	fd 1f       	adc	r31, r29
    3ce0:	80 83       	st	Z, r24
    3ce2:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    3ce4:	c6 30       	cpi	r28, 0x06	; 6
    3ce6:	d1 05       	cpc	r29, r1
    3ce8:	a9 f7       	brne	.-22     	; 0x3cd4 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    3cea:	80 91 95 50 	lds	r24, 0x5095
    3cee:	81 30       	cpi	r24, 0x01	; 1
    3cf0:	29 f4       	brne	.+10     	; 0x3cfc <SD_init+0x116>
    3cf2:	80 91 96 50 	lds	r24, 0x5096
    3cf6:	8a 3a       	cpi	r24, 0xAA	; 170
    3cf8:	21 f4       	brne	.+8      	; 0x3d02 <SD_init+0x11c>
    3cfa:	05 c0       	rjmp	.+10     	; 0x3d06 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    3cfc:	ff 24       	eor	r15, r15
    3cfe:	f3 94       	inc	r15
    3d00:	02 c0       	rjmp	.+4      	; 0x3d06 <SD_init+0x120>
    3d02:	ff 24       	eor	r15, r15
    3d04:	f3 94       	inc	r15
	*/
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    3d06:	c2 e9       	ldi	r28, 0x92	; 146
    3d08:	d0 e5       	ldi	r29, 0x50	; 80
		
	}
	*/
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    3d0a:	87 e3       	ldi	r24, 0x37	; 55
    3d0c:	40 e0       	ldi	r20, 0x00	; 0
    3d0e:	50 e0       	ldi	r21, 0x00	; 0
    3d10:	ba 01       	movw	r22, r20
    3d12:	2f ef       	ldi	r18, 0xFF	; 255
    3d14:	08 e0       	ldi	r16, 0x08	; 8
    3d16:	10 e0       	ldi	r17, 0x00	; 0
    3d18:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    3d1c:	81 e0       	ldi	r24, 0x01	; 1
    3d1e:	40 e0       	ldi	r20, 0x00	; 0
    3d20:	50 e0       	ldi	r21, 0x00	; 0
    3d22:	60 e0       	ldi	r22, 0x00	; 0
    3d24:	70 e4       	ldi	r23, 0x40	; 64
    3d26:	2f ef       	ldi	r18, 0xFF	; 255
    3d28:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
	} while(Buffer[1]!= 0x00);
    3d2c:	88 81       	ld	r24, Y
    3d2e:	88 23       	and	r24, r24
    3d30:	61 f7       	brne	.-40     	; 0x3d0a <SD_init+0x124>
    3d32:	cb e0       	ldi	r28, 0x0B	; 11
    3d34:	d0 e0       	ldi	r29, 0x00	; 0
    3d36:	02 c0       	rjmp	.+4      	; 0x3d3c <SD_init+0x156>
    3d38:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    3d3a:	61 f0       	breq	.+24     	; 0x3d54 <SD_init+0x16e>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    3d3c:	8a e3       	ldi	r24, 0x3A	; 58
    3d3e:	40 e0       	ldi	r20, 0x00	; 0
    3d40:	50 e0       	ldi	r21, 0x00	; 0
    3d42:	ba 01       	movw	r22, r20
    3d44:	2f ef       	ldi	r18, 0xFF	; 255
    3d46:	08 e0       	ldi	r16, 0x08	; 8
    3d48:	10 e0       	ldi	r17, 0x00	; 0
    3d4a:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
    3d4e:	88 23       	and	r24, r24
    3d50:	99 f7       	brne	.-26     	; 0x3d38 <SD_init+0x152>
    3d52:	02 c0       	rjmp	.+4      	; 0x3d58 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    3d54:	ff 24       	eor	r15, r15
    3d56:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    3d58:	c0 e0       	ldi	r28, 0x00	; 0
    3d5a:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    3d5c:	01 e9       	ldi	r16, 0x91	; 145
    3d5e:	10 e5       	ldi	r17, 0x50	; 80
    3d60:	8f ef       	ldi	r24, 0xFF	; 255
    3d62:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3d66:	f8 01       	movw	r30, r16
    3d68:	ec 0f       	add	r30, r28
    3d6a:	fd 1f       	adc	r31, r29
    3d6c:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    3d6e:	21 96       	adiw	r28, 0x01	; 1
    3d70:	c4 30       	cpi	r28, 0x04	; 4
    3d72:	d1 05       	cpc	r29, r1
    3d74:	a9 f7       	brne	.-22     	; 0x3d60 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    3d76:	80 91 91 50 	lds	r24, 0x5091
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    3d7a:	80 e0       	ldi	r24, 0x00	; 0
    3d7c:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    3d80:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3d84:	88 e0       	ldi	r24, 0x08	; 8
    3d86:	60 e0       	ldi	r22, 0x00	; 0
    3d88:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
	return errorCode;	
}	
    3d8c:	8f 2d       	mov	r24, r15
    3d8e:	df 91       	pop	r29
    3d90:	cf 91       	pop	r28
    3d92:	1f 91       	pop	r17
    3d94:	0f 91       	pop	r16
    3d96:	ff 90       	pop	r15
    3d98:	08 95       	ret

00003d9a <SD_write_multiple_blocks>:
//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    3d9a:	2f 92       	push	r2
    3d9c:	3f 92       	push	r3
    3d9e:	4f 92       	push	r4
    3da0:	5f 92       	push	r5
    3da2:	6f 92       	push	r6
    3da4:	7f 92       	push	r7
    3da6:	8f 92       	push	r8
    3da8:	9f 92       	push	r9
    3daa:	af 92       	push	r10
    3dac:	bf 92       	push	r11
    3dae:	cf 92       	push	r12
    3db0:	df 92       	push	r13
    3db2:	ef 92       	push	r14
    3db4:	ff 92       	push	r15
    3db6:	0f 93       	push	r16
    3db8:	1f 93       	push	r17
    3dba:	cf 93       	push	r28
    3dbc:	df 93       	push	r29
    3dbe:	cd b7       	in	r28, 0x3d	; 61
    3dc0:	de b7       	in	r29, 0x3e	; 62
    3dc2:	2a 97       	sbiw	r28, 0x0a	; 10
    3dc4:	cd bf       	out	0x3d, r28	; 61
    3dc6:	de bf       	out	0x3e, r29	; 62
    3dc8:	6b 01       	movw	r12, r22
    3dca:	7c 01       	movw	r14, r24
    3dcc:	4f 83       	std	Y+7, r20	; 0x07
    3dce:	58 87       	std	Y+8, r21	; 0x08
    3dd0:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3dd2:	88 e0       	ldi	r24, 0x08	; 8
    3dd4:	60 e0       	ldi	r22, 0x00	; 0
    3dd6:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    3dda:	80 e0       	ldi	r24, 0x00	; 0
    3ddc:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    3de0:	81 e0       	ldi	r24, 0x01	; 1
    3de2:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    3de6:	c8 01       	movw	r24, r16
    3de8:	11 23       	and	r17, r17
    3dea:	14 f4       	brge	.+4      	; 0x3df0 <SD_write_multiple_blocks+0x56>
    3dec:	81 50       	subi	r24, 0x01	; 1
    3dee:	9e 4f       	sbci	r25, 0xFE	; 254
    3df0:	9c 01       	movw	r18, r24
    3df2:	23 2f       	mov	r18, r19
    3df4:	33 0f       	add	r19, r19
    3df6:	33 0b       	sbc	r19, r19
    3df8:	25 95       	asr	r18
    3dfa:	2b 83       	std	Y+3, r18	; 0x03
    3dfc:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    3dfe:	20 e0       	ldi	r18, 0x00	; 0
    3e00:	32 e0       	ldi	r19, 0x02	; 2
    3e02:	c8 01       	movw	r24, r16
    3e04:	b9 01       	movw	r22, r18
    3e06:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    3e0a:	29 01       	movw	r4, r18
    3e0c:	48 1a       	sub	r4, r24
    3e0e:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    3e10:	30 e0       	ldi	r19, 0x00	; 0
    3e12:	43 16       	cp	r4, r19
    3e14:	32 e0       	ldi	r19, 0x02	; 2
    3e16:	53 06       	cpc	r5, r19
    3e18:	31 f0       	breq	.+12     	; 0x3e26 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    3e1a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e1c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e1e:	01 96       	adiw	r24, 0x01	; 1
    3e20:	8b 83       	std	Y+3, r24	; 0x03
    3e22:	9c 83       	std	Y+4, r25	; 0x04
    3e24:	02 c0       	rjmp	.+4      	; 0x3e2a <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    3e26:	44 24       	eor	r4, r4
    3e28:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    3e2a:	89 e1       	ldi	r24, 0x19	; 25
    3e2c:	b7 01       	movw	r22, r14
    3e2e:	a6 01       	movw	r20, r12
    3e30:	2f ef       	ldi	r18, 0xFF	; 255
    3e32:	08 e0       	ldi	r16, 0x08	; 8
    3e34:	10 e0       	ldi	r17, 0x00	; 0
    3e36:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
    3e3a:	88 23       	and	r24, r24
    3e3c:	b1 f7       	brne	.-20     	; 0x3e2a <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    3e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e40:	fc 81       	ldd	r31, Y+4	; 0x04
    3e42:	1e 16       	cp	r1, r30
    3e44:	1f 06       	cpc	r1, r31
    3e46:	0c f0       	brlt	.+2      	; 0x3e4a <SD_write_multiple_blocks+0xb0>
    3e48:	ac c0       	rjmp	.+344    	; 0x3fa2 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    3e4a:	31 97       	sbiw	r30, 0x01	; 1
    3e4c:	ed 83       	std	Y+5, r30	; 0x05
    3e4e:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    3e50:	9f 01       	movw	r18, r30
    3e52:	32 2f       	mov	r19, r18
    3e54:	22 27       	eor	r18, r18
    3e56:	33 0f       	add	r19, r19
    3e58:	8f 81       	ldd	r24, Y+7	; 0x07
    3e5a:	98 85       	ldd	r25, Y+8	; 0x08
    3e5c:	89 83       	std	Y+1, r24	; 0x01
    3e5e:	9a 83       	std	Y+2, r25	; 0x02
    3e60:	66 24       	eor	r6, r6
    3e62:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    3e64:	0f 2e       	mov	r0, r31
    3e66:	f2 e9       	ldi	r31, 0x92	; 146
    3e68:	8f 2e       	mov	r8, r31
    3e6a:	f0 e5       	ldi	r31, 0x50	; 80
    3e6c:	9f 2e       	mov	r9, r31
    3e6e:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    3e70:	0f 2e       	mov	r0, r31
    3e72:	fc e0       	ldi	r31, 0x0C	; 12
    3e74:	cf 2e       	mov	r12, r31
    3e76:	dd 24       	eor	r13, r13
    3e78:	f0 2d       	mov	r31, r0
    3e7a:	0f 2e       	mov	r0, r31
    3e7c:	f1 e9       	ldi	r31, 0x91	; 145
    3e7e:	af 2e       	mov	r10, r31
    3e80:	f0 e5       	ldi	r31, 0x50	; 80
    3e82:	bf 2e       	mov	r11, r31
    3e84:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    3e86:	80 e0       	ldi	r24, 0x00	; 0
    3e88:	92 e0       	ldi	r25, 0x02	; 2
    3e8a:	1c 01       	movw	r2, r24
    3e8c:	24 18       	sub	r2, r4
    3e8e:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
	return errorCode;	
}	
//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    3e90:	ef 81       	ldd	r30, Y+7	; 0x07
    3e92:	f8 85       	ldd	r31, Y+8	; 0x08
    3e94:	e2 0f       	add	r30, r18
    3e96:	f3 1f       	adc	r31, r19
    3e98:	ef 83       	std	Y+7, r30	; 0x07
    3e9a:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    3e9c:	8f ef       	ldi	r24, 0xFF	; 255
    3e9e:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3ea2:	f4 01       	movw	r30, r8
    3ea4:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    3ea6:	8c ef       	ldi	r24, 0xFC	; 252
    3ea8:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3eac:	f4 01       	movw	r30, r8
    3eae:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    3eb0:	2d 81       	ldd	r18, Y+5	; 0x05
    3eb2:	3e 81       	ldd	r19, Y+6	; 0x06
    3eb4:	26 15       	cp	r18, r6
    3eb6:	37 05       	cpc	r19, r7
    3eb8:	09 f0       	breq	.+2      	; 0x3ebc <SD_write_multiple_blocks+0x122>
    3eba:	41 c0       	rjmp	.+130    	; 0x3f3e <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    3ebc:	12 14       	cp	r1, r2
    3ebe:	13 04       	cpc	r1, r3
    3ec0:	cc f4       	brge	.+50     	; 0x3ef4 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
	return errorCode;	
}	
//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    3ec2:	ef 80       	ldd	r14, Y+7	; 0x07
    3ec4:	f8 84       	ldd	r15, Y+8	; 0x08
    3ec6:	00 e0       	ldi	r16, 0x00	; 0
    3ec8:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    3eca:	c8 01       	movw	r24, r16
    3ecc:	b6 01       	movw	r22, r12
    3ece:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    3ed2:	89 87       	std	Y+9, r24	; 0x09
    3ed4:	9a 87       	std	Y+10, r25	; 0x0a
    3ed6:	f7 01       	movw	r30, r14
    3ed8:	81 91       	ld	r24, Z+
    3eda:	7f 01       	movw	r14, r30
    3edc:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3ee0:	e9 85       	ldd	r30, Y+9	; 0x09
    3ee2:	fa 85       	ldd	r31, Y+10	; 0x0a
    3ee4:	ea 0d       	add	r30, r10
    3ee6:	fb 1d       	adc	r31, r11
    3ee8:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    3eea:	0f 5f       	subi	r16, 0xFF	; 255
    3eec:	1f 4f       	sbci	r17, 0xFF	; 255
    3eee:	02 15       	cp	r16, r2
    3ef0:	13 05       	cpc	r17, r3
    3ef2:	59 f7       	brne	.-42     	; 0x3eca <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    3ef4:	14 14       	cp	r1, r4
    3ef6:	15 04       	cpc	r1, r5
    3ef8:	9c f4       	brge	.+38     	; 0x3f20 <SD_write_multiple_blocks+0x186>
    3efa:	00 e0       	ldi	r16, 0x00	; 0
    3efc:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    3efe:	c8 01       	movw	r24, r16
    3f00:	b6 01       	movw	r22, r12
    3f02:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    3f06:	7c 01       	movw	r14, r24
    3f08:	80 e0       	ldi	r24, 0x00	; 0
    3f0a:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3f0e:	f5 01       	movw	r30, r10
    3f10:	ee 0d       	add	r30, r14
    3f12:	ff 1d       	adc	r31, r15
    3f14:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    3f16:	0f 5f       	subi	r16, 0xFF	; 255
    3f18:	1f 4f       	sbci	r17, 0xFF	; 255
    3f1a:	04 15       	cp	r16, r4
    3f1c:	15 05       	cpc	r17, r5
    3f1e:	79 f7       	brne	.-34     	; 0x3efe <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    3f20:	8f ef       	ldi	r24, 0xFF	; 255
    3f22:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3f26:	f4 01       	movw	r30, r8
    3f28:	80 83       	st	Z, r24
    3f2a:	8f ef       	ldi	r24, 0xFF	; 255
    3f2c:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3f30:	f4 01       	movw	r30, r8
    3f32:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    3f34:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received		
    3f36:	80 81       	ld	r24, Z
    3f38:	8f 3f       	cpi	r24, 0xFF	; 255
    3f3a:	e1 f4       	brne	.+56     	; 0x3f74 <SD_write_multiple_blocks+0x1da>
    3f3c:	23 c0       	rjmp	.+70     	; 0x3f84 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    3f3e:	e9 80       	ldd	r14, Y+1	; 0x01
    3f40:	fa 80       	ldd	r15, Y+2	; 0x02
    3f42:	00 e0       	ldi	r16, 0x00	; 0
    3f44:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    3f46:	c8 01       	movw	r24, r16
    3f48:	b6 01       	movw	r22, r12
    3f4a:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    3f4e:	89 87       	std	Y+9, r24	; 0x09
    3f50:	9a 87       	std	Y+10, r25	; 0x0a
    3f52:	f7 01       	movw	r30, r14
    3f54:	81 91       	ld	r24, Z+
    3f56:	7f 01       	movw	r14, r30
    3f58:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3f5c:	e9 85       	ldd	r30, Y+9	; 0x09
    3f5e:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f60:	ea 0d       	add	r30, r10
    3f62:	fb 1d       	adc	r31, r11
    3f64:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    3f66:	0f 5f       	subi	r16, 0xFF	; 255
    3f68:	1f 4f       	sbci	r17, 0xFF	; 255
    3f6a:	f2 e0       	ldi	r31, 0x02	; 2
    3f6c:	00 30       	cpi	r16, 0x00	; 0
    3f6e:	1f 07       	cpc	r17, r31
    3f70:	51 f7       	brne	.-44     	; 0x3f46 <SD_write_multiple_blocks+0x1ac>
    3f72:	d6 cf       	rjmp	.-84     	; 0x3f20 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received		
    3f74:	8f ef       	ldi	r24, 0xFF	; 255
    3f76:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3f7a:	f4 01       	movw	r30, r8
    3f7c:	80 83       	st	Z, r24
    3f7e:	80 81       	ld	r24, Z
    3f80:	8f 3f       	cpi	r24, 0xFF	; 255
    3f82:	c1 f7       	brne	.-16     	; 0x3f74 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    3f84:	08 94       	sec
    3f86:	61 1c       	adc	r6, r1
    3f88:	71 1c       	adc	r7, r1
    3f8a:	29 81       	ldd	r18, Y+1	; 0x01
    3f8c:	3a 81       	ldd	r19, Y+2	; 0x02
    3f8e:	20 50       	subi	r18, 0x00	; 0
    3f90:	3e 4f       	sbci	r19, 0xFE	; 254
    3f92:	29 83       	std	Y+1, r18	; 0x01
    3f94:	3a 83       	std	Y+2, r19	; 0x02
    3f96:	8b 81       	ldd	r24, Y+3	; 0x03
    3f98:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9a:	68 16       	cp	r6, r24
    3f9c:	79 06       	cpc	r7, r25
    3f9e:	09 f0       	breq	.+2      	; 0x3fa2 <SD_write_multiple_blocks+0x208>
    3fa0:	7d cf       	rjmp	.-262    	; 0x3e9c <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    3fa2:	ee 24       	eor	r14, r14
    3fa4:	ff 24       	eor	r15, r15
    3fa6:	68 94       	set
    3fa8:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received		
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    3faa:	02 e9       	ldi	r16, 0x92	; 146
    3fac:	10 e5       	ldi	r17, 0x50	; 80
    3fae:	8f ef       	ldi	r24, 0xFF	; 255
    3fb0:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3fb4:	f8 01       	movw	r30, r16
    3fb6:	80 83       	st	Z, r24
    3fb8:	08 94       	sec
    3fba:	e1 08       	sbc	r14, r1
    3fbc:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received		
	}
	for(int i=0;i<4;i++){
    3fbe:	e1 14       	cp	r14, r1
    3fc0:	f1 04       	cpc	r15, r1
    3fc2:	a9 f7       	brne	.-22     	; 0x3fae <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}		
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    3fc4:	8d ef       	ldi	r24, 0xFD	; 253
    3fc6:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3fca:	80 93 92 50 	sts	0x5092, r24
    3fce:	ee 24       	eor	r14, r14
    3fd0:	ff 24       	eor	r15, r15
    3fd2:	68 94       	set
    3fd4:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
	Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    3fd6:	02 e9       	ldi	r16, 0x92	; 146
    3fd8:	10 e5       	ldi	r17, 0x50	; 80
    3fda:	8f ef       	ldi	r24, 0xFF	; 255
    3fdc:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    3fe0:	f8 01       	movw	r30, r16
    3fe2:	80 83       	st	Z, r24
    3fe4:	08 94       	sec
    3fe6:	e1 08       	sbc	r14, r1
    3fe8:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}		
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    3fea:	e1 14       	cp	r14, r1
    3fec:	f1 04       	cpc	r15, r1
    3fee:	a9 f7       	brne	.-22     	; 0x3fda <SD_write_multiple_blocks+0x240>
	Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}	
	Buffer[1] = FILLER_BYTE;
    3ff0:	10 92 92 50 	sts	0x5092, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    3ff4:	80 91 92 50 	lds	r24, 0x5092
    3ff8:	8f 3f       	cpi	r24, 0xFF	; 255
    3ffa:	51 f0       	breq	.+20     	; 0x4010 <SD_write_multiple_blocks+0x276>
    3ffc:	02 e9       	ldi	r16, 0x92	; 146
    3ffe:	10 e5       	ldi	r17, 0x50	; 80
    4000:	8f ef       	ldi	r24, 0xFF	; 255
    4002:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    4006:	f8 01       	movw	r30, r16
    4008:	80 83       	st	Z, r24
    400a:	80 81       	ld	r24, Z
    400c:	8f 3f       	cpi	r24, 0xFF	; 255
    400e:	c1 f7       	brne	.-16     	; 0x4000 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    4010:	80 e0       	ldi	r24, 0x00	; 0
    4012:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    4016:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high		
    401a:	88 e0       	ldi	r24, 0x08	; 8
    401c:	60 e0       	ldi	r22, 0x00	; 0
    401e:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
}
    4022:	2a 96       	adiw	r28, 0x0a	; 10
    4024:	cd bf       	out	0x3d, r28	; 61
    4026:	de bf       	out	0x3e, r29	; 62
    4028:	df 91       	pop	r29
    402a:	cf 91       	pop	r28
    402c:	1f 91       	pop	r17
    402e:	0f 91       	pop	r16
    4030:	ff 90       	pop	r15
    4032:	ef 90       	pop	r14
    4034:	df 90       	pop	r13
    4036:	cf 90       	pop	r12
    4038:	bf 90       	pop	r11
    403a:	af 90       	pop	r10
    403c:	9f 90       	pop	r9
    403e:	8f 90       	pop	r8
    4040:	7f 90       	pop	r7
    4042:	6f 90       	pop	r6
    4044:	5f 90       	pop	r5
    4046:	4f 90       	pop	r4
    4048:	3f 90       	pop	r3
    404a:	2f 90       	pop	r2
    404c:	08 95       	ret

0000404e <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    404e:	2f 92       	push	r2
    4050:	3f 92       	push	r3
    4052:	4f 92       	push	r4
    4054:	5f 92       	push	r5
    4056:	6f 92       	push	r6
    4058:	7f 92       	push	r7
    405a:	8f 92       	push	r8
    405c:	9f 92       	push	r9
    405e:	af 92       	push	r10
    4060:	bf 92       	push	r11
    4062:	cf 92       	push	r12
    4064:	df 92       	push	r13
    4066:	ef 92       	push	r14
    4068:	ff 92       	push	r15
    406a:	0f 93       	push	r16
    406c:	1f 93       	push	r17
    406e:	cf 93       	push	r28
    4070:	df 93       	push	r29
    4072:	6b 01       	movw	r12, r22
    4074:	7c 01       	movw	r14, r24
    4076:	c4 2f       	mov	r28, r20
    4078:	85 2e       	mov	r8, r21
    407a:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    407c:	88 e0       	ldi	r24, 0x08	; 8
    407e:	60 e0       	ldi	r22, 0x00	; 0
    4080:	0e 94 2c 0a 	call	0x1458	; 0x1458 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    4084:	80 e0       	ldi	r24, 0x00	; 0
    4086:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    408a:	81 e0       	ldi	r24, 0x01	; 1
    408c:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    4090:	82 e1       	ldi	r24, 0x12	; 18
    4092:	b7 01       	movw	r22, r14
    4094:	a6 01       	movw	r20, r12
    4096:	2f ef       	ldi	r18, 0xFF	; 255
    4098:	08 e0       	ldi	r16, 0x08	; 8
    409a:	10 e0       	ldi	r17, 0x00	; 0
    409c:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
    40a0:	88 23       	and	r24, r24
    40a2:	b1 f7       	brne	.-20     	; 0x4090 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in		
	for (int j=0;j<numOfBlocks;j++){
    40a4:	16 14       	cp	r1, r6
    40a6:	17 04       	cpc	r1, r7
    40a8:	0c f0       	brlt	.+2      	; 0x40ac <SD_read_multiple_blocks+0x5e>
    40aa:	46 c0       	rjmp	.+140    	; 0x4138 <SD_read_multiple_blocks+0xea>
    40ac:	ac 2e       	mov	r10, r28
    40ae:	b8 2c       	mov	r11, r8
    40b0:	88 24       	eor	r8, r8
    40b2:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    40b4:	0f 2e       	mov	r0, r31
    40b6:	f2 e9       	ldi	r31, 0x92	; 146
    40b8:	cf 2e       	mov	r12, r31
    40ba:	f0 e5       	ldi	r31, 0x50	; 80
    40bc:	df 2e       	mov	r13, r31
    40be:	f0 2d       	mov	r31, r0
    40c0:	ff 24       	eor	r15, r15
    40c2:	fa 94       	dec	r15
    40c4:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
	
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    40c6:	0f 2e       	mov	r0, r31
    40c8:	f1 e9       	ldi	r31, 0x91	; 145
    40ca:	4f 2e       	mov	r4, r31
    40cc:	f0 e5       	ldi	r31, 0x50	; 80
    40ce:	5f 2e       	mov	r5, r31
    40d0:	f0 2d       	mov	r31, r0
    40d2:	12 01       	movw	r2, r4
    40d4:	08 94       	sec
    40d6:	21 1c       	adc	r2, r1
    40d8:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in		
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    40da:	f6 01       	movw	r30, r12
    40dc:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){ 
    40de:	80 81       	ld	r24, Z
    40e0:	8e 3f       	cpi	r24, 0xFE	; 254
    40e2:	41 f0       	breq	.+16     	; 0x40f4 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    40e4:	8f 2d       	mov	r24, r15
    40e6:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    40ea:	f6 01       	movw	r30, r12
    40ec:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in		
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){ 
    40ee:	80 81       	ld	r24, Z
    40f0:	8e 3f       	cpi	r24, 0xFE	; 254
    40f2:	c1 f7       	brne	.-16     	; 0x40e4 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in		
	for (int j=0;j<numOfBlocks;j++){
    40f4:	85 01       	movw	r16, r10
    40f6:	c0 e0       	ldi	r28, 0x00	; 0
    40f8:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){ 
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}			
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    40fa:	8f 2d       	mov	r24, r15
    40fc:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    4100:	f8 01       	movw	r30, r16
    4102:	81 93       	st	Z+, r24
    4104:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){ 
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}			
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    4106:	21 96       	adiw	r28, 0x01	; 1
    4108:	f2 e0       	ldi	r31, 0x02	; 2
    410a:	c0 30       	cpi	r28, 0x00	; 0
    410c:	df 07       	cpc	r29, r31
    410e:	a9 f7       	brne	.-22     	; 0x40fa <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
	
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    4110:	8f 2d       	mov	r24, r15
    4112:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    4116:	f2 01       	movw	r30, r4
    4118:	80 83       	st	Z, r24
    411a:	8f 2d       	mov	r24, r15
    411c:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    4120:	f1 01       	movw	r30, r2
    4122:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in		
	for (int j=0;j<numOfBlocks;j++){
    4124:	08 94       	sec
    4126:	81 1c       	adc	r8, r1
    4128:	91 1c       	adc	r9, r1
    412a:	80 e0       	ldi	r24, 0x00	; 0
    412c:	92 e0       	ldi	r25, 0x02	; 2
    412e:	a8 0e       	add	r10, r24
    4130:	b9 1e       	adc	r11, r25
    4132:	86 14       	cp	r8, r6
    4134:	97 04       	cpc	r9, r7
    4136:	89 f6       	brne	.-94     	; 0x40da <SD_read_multiple_blocks+0x8c>
	
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}	
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    4138:	8c e0       	ldi	r24, 0x0C	; 12
    413a:	40 e0       	ldi	r20, 0x00	; 0
    413c:	50 e0       	ldi	r21, 0x00	; 0
    413e:	ba 01       	movw	r22, r20
    4140:	2f ef       	ldi	r18, 0xFF	; 255
    4142:	08 e0       	ldi	r16, 0x08	; 8
    4144:	10 e0       	ldi	r17, 0x00	; 0
    4146:	0e 94 46 1c 	call	0x388c	; 0x388c <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    414a:	8f ef       	ldi	r24, 0xFF	; 255
    414c:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    4150:	80 93 91 50 	sts	0x5091, r24
	Buffer[1] = FILLER_BYTE;
    4154:	10 92 92 50 	sts	0x5092, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    4158:	80 91 92 50 	lds	r24, 0x5092
    415c:	8f 3f       	cpi	r24, 0xFF	; 255
    415e:	49 f0       	breq	.+18     	; 0x4172 <SD_read_multiple_blocks+0x124>
    4160:	c2 e9       	ldi	r28, 0x92	; 146
    4162:	d0 e5       	ldi	r29, 0x50	; 80
    4164:	8f ef       	ldi	r24, 0xFF	; 255
    4166:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
    416a:	88 83       	st	Y, r24
    416c:	88 81       	ld	r24, Y
    416e:	8f 3f       	cpi	r24, 0xFF	; 255
    4170:	c9 f7       	brne	.-14     	; 0x4164 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    4172:	80 e0       	ldi	r24, 0x00	; 0
    4174:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    4178:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    417c:	88 e0       	ldi	r24, 0x08	; 8
    417e:	60 e0       	ldi	r22, 0x00	; 0
    4180:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
}
    4184:	df 91       	pop	r29
    4186:	cf 91       	pop	r28
    4188:	1f 91       	pop	r17
    418a:	0f 91       	pop	r16
    418c:	ff 90       	pop	r15
    418e:	ef 90       	pop	r14
    4190:	df 90       	pop	r13
    4192:	cf 90       	pop	r12
    4194:	bf 90       	pop	r11
    4196:	af 90       	pop	r10
    4198:	9f 90       	pop	r9
    419a:	8f 90       	pop	r8
    419c:	7f 90       	pop	r7
    419e:	6f 90       	pop	r6
    41a0:	5f 90       	pop	r5
    41a2:	4f 90       	pop	r4
    41a4:	3f 90       	pop	r3
    41a6:	2f 90       	pop	r2
    41a8:	08 95       	ret

000041aa <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    41aa:	88 e0       	ldi	r24, 0x08	; 8
    41ac:	60 e0       	ldi	r22, 0x00	; 0
    41ae:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    41b2:	88 e0       	ldi	r24, 0x08	; 8
    41b4:	60 e0       	ldi	r22, 0x00	; 0
    41b6:	0e 94 83 0a 	call	0x1506	; 0x1506 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    41ba:	80 e0       	ldi	r24, 0x00	; 0
    41bc:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
	SPICS(TRUE);
    41c0:	81 e0       	ldi	r24, 0x01	; 1
    41c2:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    41c6:	8f ef       	ldi	r24, 0xFF	; 255
    41c8:	0e 94 3c 1c 	call	0x3878	; 0x3878 <SPI_write>
	SPICS(FALSE);	//stop spi
    41cc:	80 e0       	ldi	r24, 0x00	; 0
    41ce:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
	SPIDisable();
    41d2:	0e 94 bf 09 	call	0x137e	; 0x137e <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    41d6:	80 e0       	ldi	r24, 0x00	; 0
    41d8:	0e 94 bf 0b 	call	0x177e	; 0x177e <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    41dc:	80 e0       	ldi	r24, 0x00	; 0
    41de:	0e 94 fd 08 	call	0x11fa	; 0x11fa <Ext1Power>
}
    41e2:	08 95       	ret

000041e4 <__vector_105>:
void ADC_Stop_Sampling(){
		PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS high
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);
	
}
ISR(PORTF_INT1_vect) {
    41e4:	1f 92       	push	r1
    41e6:	0f 92       	push	r0
    41e8:	0f b6       	in	r0, 0x3f	; 63
    41ea:	0f 92       	push	r0
    41ec:	0b b6       	in	r0, 0x3b	; 59
    41ee:	0f 92       	push	r0
    41f0:	11 24       	eor	r1, r1
    41f2:	2f 93       	push	r18
    41f4:	3f 93       	push	r19
    41f6:	4f 93       	push	r20
    41f8:	5f 93       	push	r21
    41fa:	6f 93       	push	r22
    41fc:	7f 93       	push	r23
    41fe:	8f 93       	push	r24
    4200:	9f 93       	push	r25
    4202:	af 93       	push	r26
    4204:	bf 93       	push	r27
    4206:	ef 93       	push	r30
    4208:	ff 93       	push	r31
	// skip first samples because cannot perform recommended reset
	if(TotalSampleCount>=10){
    420a:	80 91 58 40 	lds	r24, 0x4058
    420e:	90 91 59 40 	lds	r25, 0x4059
    4212:	8a 30       	cpi	r24, 0x0A	; 10
    4214:	91 05       	cpc	r25, r1
    4216:	20 f0       	brcs	.+8      	; 0x4220 <__vector_105+0x3c>
		SD_disable();
    4218:	0e 94 d5 20 	call	0x41aa	; 0x41aa <SD_disable>
		while(1){
			nop();
    421c:	00 00       	nop
    421e:	fe cf       	rjmp	.-4      	; 0x421c <__vector_105+0x38>
		}		
	}		
	if (discardCount < ADC_DISCARD) {
    4220:	80 91 64 40 	lds	r24, 0x4064
    4224:	88 23       	and	r24, r24
    4226:	34 f0       	brlt	.+12     	; 0x4234 <__vector_105+0x50>
		discardCount++;
    4228:	80 91 64 40 	lds	r24, 0x4064
    422c:	8f 5f       	subi	r24, 0xFF	; 255
    422e:	80 93 64 40 	sts	0x4064, r24
    4232:	7f c0       	rjmp	.+254    	; 0x4332 <__vector_105+0x14e>
	} else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    4234:	84 e0       	ldi	r24, 0x04	; 4
    4236:	0e 94 90 09 	call	0x1320	; 0x1320 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    423a:	84 e5       	ldi	r24, 0x54	; 84
    423c:	80 93 c0 08 	sts	0x08C0, r24
		SPICS(TRUE); // CS SPI-SS
    4240:	81 e0       	ldi	r24, 0x01	; 1
    4242:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    4246:	82 e0       	ldi	r24, 0x02	; 2
    4248:	e0 ea       	ldi	r30, 0xA0	; 160
    424a:	f6 e0       	ldi	r31, 0x06	; 6
    424c:	86 83       	std	Z+6, r24	; 0x06
    424e:	80 e0       	ldi	r24, 0x00	; 0
    4250:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    4252:	a0 ec       	ldi	r26, 0xC0	; 192
    4254:	b8 e0       	ldi	r27, 0x08	; 8
    4256:	4a ea       	ldi	r20, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    4258:	27 e6       	ldi	r18, 0x67	; 103
    425a:	30 e5       	ldi	r19, 0x50	; 80
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    425c:	13 96       	adiw	r26, 0x03	; 3
    425e:	4c 93       	st	X, r20
    4260:	13 97       	sbiw	r26, 0x03	; 3
			while(!(SPIC.STATUS & SPI_IF_bm));
    4262:	12 96       	adiw	r26, 0x02	; 2
    4264:	5c 91       	ld	r21, X
    4266:	12 97       	sbiw	r26, 0x02	; 2
    4268:	55 23       	and	r21, r21
    426a:	dc f7       	brge	.-10     	; 0x4262 <__vector_105+0x7e>
			SPIBuffer[bufIndex] = SPIC.DATA;
    426c:	13 96       	adiw	r26, 0x03	; 3
    426e:	5c 91       	ld	r21, X
    4270:	13 97       	sbiw	r26, 0x03	; 3
    4272:	f9 01       	movw	r30, r18
    4274:	e8 0f       	add	r30, r24
    4276:	f9 1f       	adc	r31, r25
    4278:	50 83       	st	Z, r21
    427a:	01 96       	adiw	r24, 0x01	; 1
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    427c:	83 30       	cpi	r24, 0x03	; 3
    427e:	91 05       	cpc	r25, r1
    4280:	69 f7       	brne	.-38     	; 0x425c <__vector_105+0x78>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    4282:	82 e0       	ldi	r24, 0x02	; 2
    4284:	e0 ea       	ldi	r30, 0xA0	; 160
    4286:	f6 e0       	ldi	r31, 0x06	; 6
    4288:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    428a:	80 e0       	ldi	r24, 0x00	; 0
    428c:	0e 94 b3 09 	call	0x1366	; 0x1366 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) FRAMReadBuffer[(sampleCount*4)+3] = 0xFF; // sign extension if negative
    4290:	80 91 67 50 	lds	r24, 0x5067
    4294:	88 23       	and	r24, r24
    4296:	6c f4       	brge	.+26     	; 0x42b2 <__vector_105+0xce>
    4298:	e0 91 49 40 	lds	r30, 0x4049
    429c:	f0 91 4a 40 	lds	r31, 0x404A
    42a0:	ee 0f       	add	r30, r30
    42a2:	ff 1f       	adc	r31, r31
    42a4:	ee 0f       	add	r30, r30
    42a6:	ff 1f       	adc	r31, r31
    42a8:	e5 53       	subi	r30, 0x35	; 53
    42aa:	fc 4d       	sbci	r31, 0xDC	; 220
    42ac:	8f ef       	ldi	r24, 0xFF	; 255
    42ae:	80 83       	st	Z, r24
    42b0:	0b c0       	rjmp	.+22     	; 0x42c8 <__vector_105+0xe4>
		else FRAMReadBuffer[(sampleCount*4)+3] = 0x00;
    42b2:	e0 91 49 40 	lds	r30, 0x4049
    42b6:	f0 91 4a 40 	lds	r31, 0x404A
    42ba:	ee 0f       	add	r30, r30
    42bc:	ff 1f       	adc	r31, r31
    42be:	ee 0f       	add	r30, r30
    42c0:	ff 1f       	adc	r31, r31
    42c2:	e5 53       	subi	r30, 0x35	; 53
    42c4:	fc 4d       	sbci	r31, 0xDC	; 220
    42c6:	10 82       	st	Z, r1
		
		FRAMReadBuffer[(sampleCount*4)+2]  = SPIBuffer[0];
    42c8:	e0 91 49 40 	lds	r30, 0x4049
    42cc:	f0 91 4a 40 	lds	r31, 0x404A
    42d0:	ee 0f       	add	r30, r30
    42d2:	ff 1f       	adc	r31, r31
    42d4:	ee 0f       	add	r30, r30
    42d6:	ff 1f       	adc	r31, r31
    42d8:	32 96       	adiw	r30, 0x02	; 2
    42da:	20 91 67 50 	lds	r18, 0x5067
    42de:	88 ec       	ldi	r24, 0xC8	; 200
    42e0:	93 e2       	ldi	r25, 0x23	; 35
    42e2:	e8 0f       	add	r30, r24
    42e4:	f9 1f       	adc	r31, r25
    42e6:	20 83       	st	Z, r18
		FRAMReadBuffer[(sampleCount*4)+1]  = SPIBuffer[1];
    42e8:	e0 91 49 40 	lds	r30, 0x4049
    42ec:	f0 91 4a 40 	lds	r31, 0x404A
    42f0:	ee 0f       	add	r30, r30
    42f2:	ff 1f       	adc	r31, r31
    42f4:	ee 0f       	add	r30, r30
    42f6:	ff 1f       	adc	r31, r31
    42f8:	31 96       	adiw	r30, 0x01	; 1
    42fa:	20 91 68 50 	lds	r18, 0x5068
    42fe:	e8 0f       	add	r30, r24
    4300:	f9 1f       	adc	r31, r25
    4302:	20 83       	st	Z, r18
		FRAMReadBuffer[(sampleCount*4)+0]  = SPIBuffer[2];
    4304:	20 91 49 40 	lds	r18, 0x4049
    4308:	30 91 4a 40 	lds	r19, 0x404A
    430c:	22 0f       	add	r18, r18
    430e:	33 1f       	adc	r19, r19
    4310:	22 0f       	add	r18, r18
    4312:	33 1f       	adc	r19, r19
    4314:	40 91 69 50 	lds	r20, 0x5069
    4318:	82 0f       	add	r24, r18
    431a:	93 1f       	adc	r25, r19
    431c:	fc 01       	movw	r30, r24
    431e:	40 83       	st	Z, r20

		sampleCount++;
    4320:	80 91 49 40 	lds	r24, 0x4049
    4324:	90 91 4a 40 	lds	r25, 0x404A
    4328:	01 96       	adiw	r24, 0x01	; 1
    432a:	80 93 49 40 	sts	0x4049, r24
    432e:	90 93 4a 40 	sts	0x404A, r25
	}
	//after 3 samples, send the data via radio and reset the sample buffer
	if (sampleCount >= 128) { //maybe make it 220, check the writeFile function to see if it writes full buffer 
    4332:	80 91 49 40 	lds	r24, 0x4049
    4336:	90 91 4a 40 	lds	r25, 0x404A
    433a:	80 38       	cpi	r24, 0x80	; 128
    433c:	91 05       	cpc	r25, r1
    433e:	98 f0       	brcs	.+38     	; 0x4366 <__vector_105+0x182>
		//PORTF.OUTCLR = PIN1_bm;	//set ADC cs to high
		//SPIInit(SPI_MODE_0_gc);
		//SPICS(TRUE);
		//PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS low
		//PortEx_OUTCLR(BIT3_bm, PS_BANKB);
		getBootSectorData();
    4340:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <getBootSectorData>
		writeFile(newFile);
    4344:	82 e1       	ldi	r24, 0x12	; 18
    4346:	90 e2       	ldi	r25, 0x20	; 32
    4348:	0e 94 aa 28 	call	0x5154	; 0x5154 <writeFile>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    434c:	10 92 49 40 	sts	0x4049, r1
    4350:	10 92 4a 40 	sts	0x404A, r1
		TotalSampleCount++;
    4354:	80 91 58 40 	lds	r24, 0x4058
    4358:	90 91 59 40 	lds	r25, 0x4059
    435c:	01 96       	adiw	r24, 0x01	; 1
    435e:	80 93 58 40 	sts	0x4058, r24
    4362:	90 93 59 40 	sts	0x4059, r25
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
	}
}
    4366:	ff 91       	pop	r31
    4368:	ef 91       	pop	r30
    436a:	bf 91       	pop	r27
    436c:	af 91       	pop	r26
    436e:	9f 91       	pop	r25
    4370:	8f 91       	pop	r24
    4372:	7f 91       	pop	r23
    4374:	6f 91       	pop	r22
    4376:	5f 91       	pop	r21
    4378:	4f 91       	pop	r20
    437a:	3f 91       	pop	r19
    437c:	2f 91       	pop	r18
    437e:	0f 90       	pop	r0
    4380:	0b be       	out	0x3b, r0	; 59
    4382:	0f 90       	pop	r0
    4384:	0f be       	out	0x3f, r0	; 63
    4386:	0f 90       	pop	r0
    4388:	1f 90       	pop	r1
    438a:	18 95       	reti

0000438c <SD_write_and_read_knowns>:
	
	ADCPower(FALSE);		//turn off portEX power
	Ext1Power(FALSE);			//power down SD card
}
//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    438c:	0f 93       	push	r16
    438e:	1f 93       	push	r17
    4390:	cf 93       	push	r28
    4392:	df 93       	push	r29
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    4394:	80 e0       	ldi	r24, 0x00	; 0
    4396:	90 e0       	ldi	r25, 0x00	; 0
    4398:	28 ec       	ldi	r18, 0xC8	; 200
    439a:	33 e2       	ldi	r19, 0x23	; 35
    439c:	f9 01       	movw	r30, r18
    439e:	e8 0f       	add	r30, r24
    43a0:	f9 1f       	adc	r31, r25
    43a2:	80 83       	st	Z, r24
    43a4:	01 96       	adiw	r24, 0x01	; 1
    43a6:	88 31       	cpi	r24, 0x18	; 24
    43a8:	91 05       	cpc	r25, r1
    43aa:	c1 f7       	brne	.-16     	; 0x439c <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    43ac:	64 e1       	ldi	r22, 0x14	; 20
    43ae:	70 e0       	ldi	r23, 0x00	; 0
    43b0:	80 e0       	ldi	r24, 0x00	; 0
    43b2:	90 e0       	ldi	r25, 0x00	; 0
    43b4:	48 ec       	ldi	r20, 0xC8	; 200
    43b6:	53 e2       	ldi	r21, 0x23	; 35
    43b8:	28 e1       	ldi	r18, 0x18	; 24
    43ba:	30 e0       	ldi	r19, 0x00	; 0
    43bc:	0e 94 a7 1c 	call	0x394e	; 0x394e <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    43c0:	80 e0       	ldi	r24, 0x00	; 0
    43c2:	90 e0       	ldi	r25, 0x00	; 0
    43c4:	28 ec       	ldi	r18, 0xC8	; 200
    43c6:	33 e2       	ldi	r19, 0x23	; 35
    43c8:	f9 01       	movw	r30, r18
    43ca:	e8 0f       	add	r30, r24
    43cc:	f9 1f       	adc	r31, r25
    43ce:	10 82       	st	Z, r1
    43d0:	01 96       	adiw	r24, 0x01	; 1
    43d2:	88 31       	cpi	r24, 0x18	; 24
    43d4:	91 05       	cpc	r25, r1
    43d6:	c1 f7       	brne	.-16     	; 0x43c8 <SD_write_and_read_knowns+0x3c>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    43d8:	64 e1       	ldi	r22, 0x14	; 20
    43da:	70 e0       	ldi	r23, 0x00	; 0
    43dc:	80 e0       	ldi	r24, 0x00	; 0
    43de:	90 e0       	ldi	r25, 0x00	; 0
    43e0:	48 ec       	ldi	r20, 0xC8	; 200
    43e2:	53 e2       	ldi	r21, 0x23	; 35
    43e4:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    43e8:	20 e0       	ldi	r18, 0x00	; 0
    43ea:	30 e0       	ldi	r19, 0x00	; 0
    43ec:	c4 e6       	ldi	r28, 0x64	; 100
    43ee:	d0 e0       	ldi	r29, 0x00	; 0
    43f0:	08 ec       	ldi	r16, 0xC8	; 200
    43f2:	13 e2       	ldi	r17, 0x23	; 35
    43f4:	c9 01       	movw	r24, r18
    43f6:	be 01       	movw	r22, r28
    43f8:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    43fc:	f8 01       	movw	r30, r16
    43fe:	e2 0f       	add	r30, r18
    4400:	f3 1f       	adc	r31, r19
    4402:	80 83       	st	Z, r24
    4404:	2f 5f       	subi	r18, 0xFF	; 255
    4406:	3f 4f       	sbci	r19, 0xFF	; 255
    4408:	44 e0       	ldi	r20, 0x04	; 4
    440a:	22 3e       	cpi	r18, 0xE2	; 226
    440c:	34 07       	cpc	r19, r20
    440e:	91 f7       	brne	.-28     	; 0x43f4 <SD_write_and_read_knowns+0x68>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    4410:	60 e5       	ldi	r22, 0x50	; 80
    4412:	70 e0       	ldi	r23, 0x00	; 0
    4414:	80 e0       	ldi	r24, 0x00	; 0
    4416:	90 e0       	ldi	r25, 0x00	; 0
    4418:	48 ec       	ldi	r20, 0xC8	; 200
    441a:	53 e2       	ldi	r21, 0x23	; 35
    441c:	22 ee       	ldi	r18, 0xE2	; 226
    441e:	34 e0       	ldi	r19, 0x04	; 4
    4420:	0e 94 cd 1e 	call	0x3d9a	; 0x3d9a <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    4424:	80 e0       	ldi	r24, 0x00	; 0
    4426:	90 e0       	ldi	r25, 0x00	; 0
    4428:	28 ec       	ldi	r18, 0xC8	; 200
    442a:	33 e2       	ldi	r19, 0x23	; 35
    442c:	f9 01       	movw	r30, r18
    442e:	e8 0f       	add	r30, r24
    4430:	f9 1f       	adc	r31, r25
    4432:	10 82       	st	Z, r1
    4434:	01 96       	adiw	r24, 0x01	; 1
    4436:	44 e0       	ldi	r20, 0x04	; 4
    4438:	82 3e       	cpi	r24, 0xE2	; 226
    443a:	94 07       	cpc	r25, r20
    443c:	b9 f7       	brne	.-18     	; 0x442c <SD_write_and_read_knowns+0xa0>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    443e:	60 e5       	ldi	r22, 0x50	; 80
    4440:	70 e0       	ldi	r23, 0x00	; 0
    4442:	80 e0       	ldi	r24, 0x00	; 0
    4444:	90 e0       	ldi	r25, 0x00	; 0
    4446:	48 ec       	ldi	r20, 0xC8	; 200
    4448:	53 e2       	ldi	r21, 0x23	; 35
    444a:	23 e0       	ldi	r18, 0x03	; 3
    444c:	30 e0       	ldi	r19, 0x00	; 0
    444e:	0e 94 27 20 	call	0x404e	; 0x404e <SD_read_multiple_blocks>
}
    4452:	df 91       	pop	r29
    4454:	cf 91       	pop	r28
    4456:	1f 91       	pop	r17
    4458:	0f 91       	pop	r16
    445a:	08 95       	ret

0000445c <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    445c:	80 e0       	ldi	r24, 0x00	; 0
    445e:	90 e0       	ldi	r25, 0x00	; 0
    4460:	28 ec       	ldi	r18, 0xC8	; 200
    4462:	33 e2       	ldi	r19, 0x23	; 35
    4464:	f9 01       	movw	r30, r18
    4466:	e8 0f       	add	r30, r24
    4468:	f9 1f       	adc	r31, r25
    446a:	80 83       	st	Z, r24
    446c:	01 96       	adiw	r24, 0x01	; 1
    446e:	88 31       	cpi	r24, 0x18	; 24
    4470:	91 05       	cpc	r25, r1
    4472:	c1 f7       	brne	.-16     	; 0x4464 <SD_write_and_read_knowns_FAT+0x8>
	error = writeFile(newFile);
    4474:	82 e1       	ldi	r24, 0x12	; 18
    4476:	90 e2       	ldi	r25, 0x20	; 32
    4478:	0e 94 aa 28 	call	0x5154	; 0x5154 <writeFile>
    447c:	80 93 57 40 	sts	0x4057, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    4480:	80 e0       	ldi	r24, 0x00	; 0
    4482:	90 e0       	ldi	r25, 0x00	; 0
    4484:	28 ec       	ldi	r18, 0xC8	; 200
    4486:	33 e2       	ldi	r19, 0x23	; 35
    4488:	f9 01       	movw	r30, r18
    448a:	e8 0f       	add	r30, r24
    448c:	f9 1f       	adc	r31, r25
    448e:	10 82       	st	Z, r1
    4490:	01 96       	adiw	r24, 0x01	; 1
    4492:	88 31       	cpi	r24, 0x18	; 24
    4494:	91 05       	cpc	r25, r1
    4496:	c1 f7       	brne	.-16     	; 0x4488 <SD_write_and_read_knowns_FAT+0x2c>
	error = readFile(READ,newFileR);		//read the data into the buffer from file
    4498:	80 e0       	ldi	r24, 0x00	; 0
    449a:	63 e0       	ldi	r22, 0x03	; 3
    449c:	70 e2       	ldi	r23, 0x20	; 32
    449e:	0e 94 2c 28 	call	0x5058	; 0x5058 <readFile>
    44a2:	80 93 57 40 	sts	0x4057, r24
}
    44a6:	08 95       	ret

000044a8 <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    44a8:	88 23       	and	r24, r24
    44aa:	29 f0       	breq	.+10     	; 0x44b6 <RadioCS+0xe>
    44ac:	80 e1       	ldi	r24, 0x10	; 16
    44ae:	e0 e6       	ldi	r30, 0x60	; 96
    44b0:	f6 e0       	ldi	r31, 0x06	; 6
    44b2:	86 83       	std	Z+6, r24	; 0x06
    44b4:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    44b6:	80 e1       	ldi	r24, 0x10	; 16
    44b8:	e0 e6       	ldi	r30, 0x60	; 96
    44ba:	f6 e0       	ldi	r31, 0x06	; 6
    44bc:	85 83       	std	Z+5, r24	; 0x05
    44be:	08 95       	ret

000044c0 <SPID_write>:
}

//write a byte of data over SPI port D (for the radio) and read a byte of data simultaneously
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    44c0:	e0 ec       	ldi	r30, 0xC0	; 192
    44c2:	f9 e0       	ldi	r31, 0x09	; 9
    44c4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    44c6:	82 81       	ldd	r24, Z+2	; 0x02
    44c8:	88 23       	and	r24, r24
    44ca:	ec f7       	brge	.-6      	; 0x44c6 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    44cc:	e0 ec       	ldi	r30, 0xC0	; 192
    44ce:	f9 e0       	ldi	r31, 0x09	; 9
    44d0:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    44d2:	08 95       	ret

000044d4 <chibi_test_radio>:
}
*/
//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    44d4:	0e 94 fd 01 	call	0x3fa	; 0x3fa <chb_init>
	chb_set_short_addr(0x0002);
    44d8:	82 e0       	ldi	r24, 0x02	; 2
    44da:	90 e0       	ldi	r25, 0x00	; 0
    44dc:	0e 94 0d 05 	call	0xa1a	; 0xa1a <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    44e0:	00 00       	nop
    44e2:	fe cf       	rjmp	.-4      	; 0x44e0 <chibi_test_radio+0xc>

000044e4 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    44e4:	ef 92       	push	r14
    44e6:	ff 92       	push	r15
    44e8:	0f 93       	push	r16
    44ea:	1f 93       	push	r17
    44ec:	cf 93       	push	r28
    44ee:	df 93       	push	r29
	SD_init();
    44f0:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <SD_init>
	getBootSectorData();
    44f4:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    44f8:	20 e0       	ldi	r18, 0x00	; 0
    44fa:	30 e0       	ldi	r19, 0x00	; 0
    44fc:	c9 e7       	ldi	r28, 0x79	; 121
    44fe:	d0 e0       	ldi	r29, 0x00	; 0
    4500:	08 ec       	ldi	r16, 0xC8	; 200
    4502:	13 e2       	ldi	r17, 0x23	; 35
    4504:	c9 01       	movw	r24, r18
    4506:	be 01       	movw	r22, r28
    4508:	0e 94 af 34 	call	0x695e	; 0x695e <__divmodhi4>
    450c:	f8 01       	movw	r30, r16
    450e:	e2 0f       	add	r30, r18
    4510:	f3 1f       	adc	r31, r19
    4512:	80 83       	st	Z, r24
    4514:	2f 5f       	subi	r18, 0xFF	; 255
    4516:	3f 4f       	sbci	r19, 0xFF	; 255
    4518:	82 e0       	ldi	r24, 0x02	; 2
    451a:	20 30       	cpi	r18, 0x00	; 0
    451c:	38 07       	cpc	r19, r24
    451e:	91 f7       	brne	.-28     	; 0x4504 <TestCard+0x20>
    4520:	c0 e0       	ldi	r28, 0x00	; 0
for (int i=0;i<55;i++) {FRAMReadBuffer[0] = i; writeFile(newFile);}
    4522:	08 ec       	ldi	r16, 0xC8	; 200
    4524:	13 e2       	ldi	r17, 0x23	; 35
    4526:	0f 2e       	mov	r0, r31
    4528:	f2 e1       	ldi	r31, 0x12	; 18
    452a:	ef 2e       	mov	r14, r31
    452c:	f0 e2       	ldi	r31, 0x20	; 32
    452e:	ff 2e       	mov	r15, r31
    4530:	f0 2d       	mov	r31, r0
    4532:	f8 01       	movw	r30, r16
    4534:	c0 83       	st	Z, r28
    4536:	c7 01       	movw	r24, r14
    4538:	0e 94 aa 28 	call	0x5154	; 0x5154 <writeFile>
    453c:	cf 5f       	subi	r28, 0xFF	; 255
    453e:	c7 33       	cpi	r28, 0x37	; 55
    4540:	c1 f7       	brne	.-16     	; 0x4532 <TestCard+0x4e>
    4542:	df 91       	pop	r29
    4544:	cf 91       	pop	r28
    4546:	1f 91       	pop	r17
    4548:	0f 91       	pop	r16
    454a:	ff 90       	pop	r15
    454c:	ef 90       	pop	r14
    454e:	08 95       	ret

00004550 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    4550:	cf 92       	push	r12
    4552:	df 92       	push	r13
    4554:	ef 92       	push	r14
    4556:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    4558:	20 91 4b 40 	lds	r18, 0x404B
    455c:	30 91 4c 40 	lds	r19, 0x404C
    4560:	c0 90 c4 23 	lds	r12, 0x23C4
    4564:	d0 90 c5 23 	lds	r13, 0x23C5
    4568:	e0 90 c6 23 	lds	r14, 0x23C6
    456c:	f0 90 c7 23 	lds	r15, 0x23C7
    4570:	62 50       	subi	r22, 0x02	; 2
    4572:	70 40       	sbci	r23, 0x00	; 0
    4574:	80 40       	sbci	r24, 0x00	; 0
    4576:	90 40       	sbci	r25, 0x00	; 0
    4578:	40 e0       	ldi	r20, 0x00	; 0
    457a:	50 e0       	ldi	r21, 0x00	; 0
    457c:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    4580:	dc 01       	movw	r26, r24
    4582:	cb 01       	movw	r24, r22
    4584:	c8 0e       	add	r12, r24
    4586:	d9 1e       	adc	r13, r25
    4588:	ea 1e       	adc	r14, r26
    458a:	fb 1e       	adc	r15, r27
}
    458c:	6c 2d       	mov	r22, r12
    458e:	7d 2d       	mov	r23, r13
    4590:	8e 2d       	mov	r24, r14
    4592:	9f 2d       	mov	r25, r15
    4594:	ff 90       	pop	r15
    4596:	ef 90       	pop	r14
    4598:	df 90       	pop	r13
    459a:	cf 90       	pop	r12
    459c:	08 95       	ret

0000459e <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    459e:	2f 92       	push	r2
    45a0:	3f 92       	push	r3
    45a2:	4f 92       	push	r4
    45a4:	5f 92       	push	r5
    45a6:	7f 92       	push	r7
    45a8:	8f 92       	push	r8
    45aa:	9f 92       	push	r9
    45ac:	af 92       	push	r10
    45ae:	bf 92       	push	r11
    45b0:	cf 92       	push	r12
    45b2:	df 92       	push	r13
    45b4:	ef 92       	push	r14
    45b6:	ff 92       	push	r15
    45b8:	0f 93       	push	r16
    45ba:	1f 93       	push	r17
    45bc:	cf 93       	push	r28
    45be:	df 93       	push	r29
    45c0:	dc 01       	movw	r26, r24
    45c2:	cb 01       	movw	r24, r22
    45c4:	74 2e       	mov	r7, r20
    45c6:	18 01       	movw	r2, r16
    45c8:	29 01       	movw	r4, r18
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    45ca:	c0 90 51 40 	lds	r12, 0x4051
    45ce:	d0 90 52 40 	lds	r13, 0x4052
    45d2:	4c 01       	movw	r8, r24
    45d4:	5d 01       	movw	r10, r26
    45d6:	88 0c       	add	r8, r8
    45d8:	99 1c       	adc	r9, r9
    45da:	aa 1c       	adc	r10, r10
    45dc:	bb 1c       	adc	r11, r11
    45de:	88 0c       	add	r8, r8
    45e0:	99 1c       	adc	r9, r9
    45e2:	aa 1c       	adc	r10, r10
    45e4:	bb 1c       	adc	r11, r11
    45e6:	20 91 3d 40 	lds	r18, 0x403D
    45ea:	30 91 3e 40 	lds	r19, 0x403E
    45ee:	ee 24       	eor	r14, r14
    45f0:	ff 24       	eor	r15, r15
    45f2:	80 91 4d 40 	lds	r24, 0x404D
    45f6:	90 91 4e 40 	lds	r25, 0x404E
    45fa:	a0 91 4f 40 	lds	r26, 0x404F
    45fe:	b0 91 50 40 	lds	r27, 0x4050
    4602:	c8 0e       	add	r12, r24
    4604:	d9 1e       	adc	r13, r25
    4606:	ea 1e       	adc	r14, r26
    4608:	fb 1e       	adc	r15, r27
    460a:	40 e0       	ldi	r20, 0x00	; 0
    460c:	50 e0       	ldi	r21, 0x00	; 0
    460e:	c5 01       	movw	r24, r10
    4610:	b4 01       	movw	r22, r8
    4612:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    4616:	c2 0e       	add	r12, r18
    4618:	d3 1e       	adc	r13, r19
    461a:	e4 1e       	adc	r14, r20
    461c:	f5 1e       	adc	r15, r21

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    461e:	20 91 3d 40 	lds	r18, 0x403D
    4622:	30 91 3e 40 	lds	r19, 0x403E
    4626:	40 e0       	ldi	r20, 0x00	; 0
    4628:	50 e0       	ldi	r21, 0x00	; 0
    462a:	c5 01       	movw	r24, r10
    462c:	b4 01       	movw	r22, r8
    462e:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    4632:	dc 01       	movw	r26, r24
    4634:	cb 01       	movw	r24, r22
    4636:	ec 01       	movw	r28, r24

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    4638:	c7 01       	movw	r24, r14
    463a:	b6 01       	movw	r22, r12
    463c:	40 ec       	ldi	r20, 0xC0	; 192
    463e:	51 e2       	ldi	r21, 0x21	; 33
    4640:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    4644:	c0 54       	subi	r28, 0x40	; 64
    4646:	de 4d       	sbci	r29, 0xDE	; 222

if(get_set == GET)
    4648:	77 20       	and	r7, r7
    464a:	31 f4       	brne	.+12     	; 0x4658 <getSetNextCluster+0xba>
  return ((*FATEntryValue) & 0x0fffffff);
    464c:	08 81       	ld	r16, Y
    464e:	19 81       	ldd	r17, Y+1	; 0x01
    4650:	2a 81       	ldd	r18, Y+2	; 0x02
    4652:	3b 81       	ldd	r19, Y+3	; 0x03
    4654:	3f 70       	andi	r19, 0x0F	; 15
    4656:	0f c0       	rjmp	.+30     	; 0x4676 <getSetNextCluster+0xd8>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4658:	28 82       	st	Y, r2
    465a:	39 82       	std	Y+1, r3	; 0x01
    465c:	4a 82       	std	Y+2, r4	; 0x02
    465e:	5b 82       	std	Y+3, r5	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    4660:	c7 01       	movw	r24, r14
    4662:	b6 01       	movw	r22, r12
    4664:	40 ec       	ldi	r20, 0xC0	; 192
    4666:	51 e2       	ldi	r21, 0x21	; 33
    4668:	20 e0       	ldi	r18, 0x00	; 0
    466a:	32 e0       	ldi	r19, 0x02	; 2
    466c:	0e 94 a7 1c 	call	0x394e	; 0x394e <SD_write_block>

return (0);
    4670:	00 e0       	ldi	r16, 0x00	; 0
    4672:	10 e0       	ldi	r17, 0x00	; 0
    4674:	98 01       	movw	r18, r16
}
    4676:	60 2f       	mov	r22, r16
    4678:	71 2f       	mov	r23, r17
    467a:	82 2f       	mov	r24, r18
    467c:	93 2f       	mov	r25, r19
    467e:	df 91       	pop	r29
    4680:	cf 91       	pop	r28
    4682:	1f 91       	pop	r17
    4684:	0f 91       	pop	r16
    4686:	ff 90       	pop	r15
    4688:	ef 90       	pop	r14
    468a:	df 90       	pop	r13
    468c:	cf 90       	pop	r12
    468e:	bf 90       	pop	r11
    4690:	af 90       	pop	r10
    4692:	9f 90       	pop	r9
    4694:	8f 90       	pop	r8
    4696:	7f 90       	pop	r7
    4698:	5f 90       	pop	r5
    469a:	4f 90       	pop	r4
    469c:	3f 90       	pop	r3
    469e:	2f 90       	pop	r2
    46a0:	08 95       	ret

000046a2 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    46a2:	cf 92       	push	r12
    46a4:	df 92       	push	r13
    46a6:	ef 92       	push	r14
    46a8:	ff 92       	push	r15
    46aa:	0f 93       	push	r16
    46ac:	1f 93       	push	r17
    46ae:	cf 93       	push	r28
    46b0:	c8 2f       	mov	r28, r24
    46b2:	06 2f       	mov	r16, r22
    46b4:	69 01       	movw	r12, r18
    46b6:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    46b8:	80 91 4d 40 	lds	r24, 0x404D
    46bc:	90 91 4e 40 	lds	r25, 0x404E
    46c0:	a0 91 4f 40 	lds	r26, 0x404F
    46c4:	b0 91 50 40 	lds	r27, 0x4050
    46c8:	bc 01       	movw	r22, r24
    46ca:	cd 01       	movw	r24, r26
    46cc:	6f 5f       	subi	r22, 0xFF	; 255
    46ce:	7f 4f       	sbci	r23, 0xFF	; 255
    46d0:	8f 4f       	sbci	r24, 0xFF	; 255
    46d2:	9f 4f       	sbci	r25, 0xFF	; 255
    46d4:	40 ec       	ldi	r20, 0xC0	; 192
    46d6:	51 e2       	ldi	r21, 0x21	; 33
    46d8:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    46dc:	80 91 c0 21 	lds	r24, 0x21C0
    46e0:	90 91 c1 21 	lds	r25, 0x21C1
    46e4:	a0 91 c2 21 	lds	r26, 0x21C2
    46e8:	b0 91 c3 21 	lds	r27, 0x21C3
    46ec:	82 35       	cpi	r24, 0x52	; 82
    46ee:	22 e5       	ldi	r18, 0x52	; 82
    46f0:	92 07       	cpc	r25, r18
    46f2:	21 e6       	ldi	r18, 0x61	; 97
    46f4:	a2 07       	cpc	r26, r18
    46f6:	21 e4       	ldi	r18, 0x41	; 65
    46f8:	b2 07       	cpc	r27, r18
    46fa:	09 f0       	breq	.+2      	; 0x46fe <getSetFreeCluster+0x5c>
    46fc:	63 c0       	rjmp	.+198    	; 0x47c4 <getSetFreeCluster+0x122>
    46fe:	80 91 a4 23 	lds	r24, 0x23A4
    4702:	90 91 a5 23 	lds	r25, 0x23A5
    4706:	a0 91 a6 23 	lds	r26, 0x23A6
    470a:	b0 91 a7 23 	lds	r27, 0x23A7
    470e:	82 37       	cpi	r24, 0x72	; 114
    4710:	22 e7       	ldi	r18, 0x72	; 114
    4712:	92 07       	cpc	r25, r18
    4714:	21 e4       	ldi	r18, 0x41	; 65
    4716:	a2 07       	cpc	r26, r18
    4718:	21 e6       	ldi	r18, 0x61	; 97
    471a:	b2 07       	cpc	r27, r18
    471c:	09 f0       	breq	.+2      	; 0x4720 <getSetFreeCluster+0x7e>
    471e:	56 c0       	rjmp	.+172    	; 0x47cc <getSetFreeCluster+0x12a>
    4720:	80 91 bc 23 	lds	r24, 0x23BC
    4724:	90 91 bd 23 	lds	r25, 0x23BD
    4728:	a0 91 be 23 	lds	r26, 0x23BE
    472c:	b0 91 bf 23 	lds	r27, 0x23BF
    4730:	80 30       	cpi	r24, 0x00	; 0
    4732:	20 e0       	ldi	r18, 0x00	; 0
    4734:	92 07       	cpc	r25, r18
    4736:	25 e5       	ldi	r18, 0x55	; 85
    4738:	a2 07       	cpc	r26, r18
    473a:	2a ea       	ldi	r18, 0xAA	; 170
    473c:	b2 07       	cpc	r27, r18
    473e:	09 f0       	breq	.+2      	; 0x4742 <getSetFreeCluster+0xa0>
    4740:	49 c0       	rjmp	.+146    	; 0x47d4 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4742:	00 23       	and	r16, r16
    4744:	a1 f4       	brne	.+40     	; 0x476e <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4746:	c1 30       	cpi	r28, 0x01	; 1
    4748:	49 f4       	brne	.+18     	; 0x475c <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    474a:	00 91 a8 23 	lds	r16, 0x23A8
    474e:	10 91 a9 23 	lds	r17, 0x23A9
    4752:	20 91 aa 23 	lds	r18, 0x23AA
    4756:	30 91 ab 23 	lds	r19, 0x23AB
    475a:	3f c0       	rjmp	.+126    	; 0x47da <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    475c:	00 91 ac 23 	lds	r16, 0x23AC
    4760:	10 91 ad 23 	lds	r17, 0x23AD
    4764:	20 91 ae 23 	lds	r18, 0x23AE
    4768:	30 91 af 23 	lds	r19, 0x23AF
    476c:	36 c0       	rjmp	.+108    	; 0x47da <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    476e:	c1 30       	cpi	r28, 0x01	; 1
    4770:	49 f4       	brne	.+18     	; 0x4784 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    4772:	c0 92 a8 23 	sts	0x23A8, r12
    4776:	d0 92 a9 23 	sts	0x23A9, r13
    477a:	e0 92 aa 23 	sts	0x23AA, r14
    477e:	f0 92 ab 23 	sts	0x23AB, r15
    4782:	08 c0       	rjmp	.+16     	; 0x4794 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    4784:	c0 92 ac 23 	sts	0x23AC, r12
    4788:	d0 92 ad 23 	sts	0x23AD, r13
    478c:	e0 92 ae 23 	sts	0x23AE, r14
    4790:	f0 92 af 23 	sts	0x23AF, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4794:	80 91 4d 40 	lds	r24, 0x404D
    4798:	90 91 4e 40 	lds	r25, 0x404E
    479c:	a0 91 4f 40 	lds	r26, 0x404F
    47a0:	b0 91 50 40 	lds	r27, 0x4050
    47a4:	bc 01       	movw	r22, r24
    47a6:	cd 01       	movw	r24, r26
    47a8:	6f 5f       	subi	r22, 0xFF	; 255
    47aa:	7f 4f       	sbci	r23, 0xFF	; 255
    47ac:	8f 4f       	sbci	r24, 0xFF	; 255
    47ae:	9f 4f       	sbci	r25, 0xFF	; 255
    47b0:	40 ec       	ldi	r20, 0xC0	; 192
    47b2:	51 e2       	ldi	r21, 0x21	; 33
    47b4:	20 e0       	ldi	r18, 0x00	; 0
    47b6:	32 e0       	ldi	r19, 0x02	; 2
    47b8:	0e 94 a7 1c 	call	0x394e	; 0x394e <SD_write_block>
 }
 return 0xffffffff;
    47bc:	0f ef       	ldi	r16, 0xFF	; 255
    47be:	1f ef       	ldi	r17, 0xFF	; 255
    47c0:	98 01       	movw	r18, r16
    47c2:	0b c0       	rjmp	.+22     	; 0x47da <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    47c4:	0f ef       	ldi	r16, 0xFF	; 255
    47c6:	1f ef       	ldi	r17, 0xFF	; 255
    47c8:	98 01       	movw	r18, r16
    47ca:	07 c0       	rjmp	.+14     	; 0x47da <getSetFreeCluster+0x138>
    47cc:	0f ef       	ldi	r16, 0xFF	; 255
    47ce:	1f ef       	ldi	r17, 0xFF	; 255
    47d0:	98 01       	movw	r18, r16
    47d2:	03 c0       	rjmp	.+6      	; 0x47da <getSetFreeCluster+0x138>
    47d4:	0f ef       	ldi	r16, 0xFF	; 255
    47d6:	1f ef       	ldi	r17, 0xFF	; 255
    47d8:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    47da:	60 2f       	mov	r22, r16
    47dc:	71 2f       	mov	r23, r17
    47de:	82 2f       	mov	r24, r18
    47e0:	93 2f       	mov	r25, r19
    47e2:	cf 91       	pop	r28
    47e4:	1f 91       	pop	r17
    47e6:	0f 91       	pop	r16
    47e8:	ff 90       	pop	r15
    47ea:	ef 90       	pop	r14
    47ec:	df 90       	pop	r13
    47ee:	cf 90       	pop	r12
    47f0:	08 95       	ret

000047f2 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    47f2:	ef 92       	push	r14
    47f4:	ff 92       	push	r15
    47f6:	0f 93       	push	r16
    47f8:	1f 93       	push	r17
    47fa:	cf 93       	push	r28
    47fc:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    47fe:	10 92 4d 40 	sts	0x404D, r1
    4802:	10 92 4e 40 	sts	0x404E, r1
    4806:	10 92 4f 40 	sts	0x404F, r1
    480a:	10 92 50 40 	sts	0x4050, r1

SD_read_block(0,SDBuffer);
    480e:	60 e0       	ldi	r22, 0x00	; 0
    4810:	70 e0       	ldi	r23, 0x00	; 0
    4812:	cb 01       	movw	r24, r22
    4814:	40 ec       	ldi	r20, 0xC0	; 192
    4816:	51 e2       	ldi	r21, 0x21	; 33
    4818:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    481c:	80 91 c0 21 	lds	r24, 0x21C0
    4820:	89 3e       	cpi	r24, 0xE9	; 233
    4822:	31 f1       	breq	.+76     	; 0x4870 <getBootSectorData+0x7e>
    4824:	8b 3e       	cpi	r24, 0xEB	; 235
    4826:	21 f1       	breq	.+72     	; 0x4870 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4828:	80 91 be 23 	lds	r24, 0x23BE
    482c:	90 91 bf 23 	lds	r25, 0x23BF
    4830:	2a ea       	ldi	r18, 0xAA	; 170
    4832:	85 35       	cpi	r24, 0x55	; 85
    4834:	92 07       	cpc	r25, r18
    4836:	09 f0       	breq	.+2      	; 0x483a <getBootSectorData+0x48>
    4838:	b7 c0       	rjmp	.+366    	; 0x49a8 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    483a:	60 91 86 23 	lds	r22, 0x2386
    483e:	70 91 87 23 	lds	r23, 0x2387
    4842:	80 91 88 23 	lds	r24, 0x2388
    4846:	90 91 89 23 	lds	r25, 0x2389
    484a:	60 93 4d 40 	sts	0x404D, r22
    484e:	70 93 4e 40 	sts	0x404E, r23
    4852:	80 93 4f 40 	sts	0x404F, r24
    4856:	90 93 50 40 	sts	0x4050, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    485a:	40 ec       	ldi	r20, 0xC0	; 192
    485c:	51 e2       	ldi	r21, 0x21	; 33
    485e:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4862:	80 91 c0 21 	lds	r24, 0x21C0
    4866:	89 3e       	cpi	r24, 0xE9	; 233
    4868:	19 f0       	breq	.+6      	; 0x4870 <getBootSectorData+0x7e>
    486a:	8b 3e       	cpi	r24, 0xEB	; 235
    486c:	09 f0       	breq	.+2      	; 0x4870 <getBootSectorData+0x7e>
    486e:	9e c0       	rjmp	.+316    	; 0x49ac <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4870:	80 91 cb 21 	lds	r24, 0x21CB
    4874:	90 91 cc 21 	lds	r25, 0x21CC
    4878:	80 93 3d 40 	sts	0x403D, r24
    487c:	90 93 3e 40 	sts	0x403E, r25
sectorPerCluster = bpb->sectorPerCluster;
    4880:	80 91 cd 21 	lds	r24, 0x21CD
    4884:	90 e0       	ldi	r25, 0x00	; 0
    4886:	80 93 4b 40 	sts	0x404B, r24
    488a:	90 93 4c 40 	sts	0x404C, r25
reservedSectorCount = bpb->reservedSectorCount;
    488e:	e0 90 ce 21 	lds	r14, 0x21CE
    4892:	f0 90 cf 21 	lds	r15, 0x21CF
    4896:	e0 92 51 40 	sts	0x4051, r14
    489a:	f0 92 52 40 	sts	0x4052, r15
rootCluster = bpb->rootCluster;
    489e:	80 91 ec 21 	lds	r24, 0x21EC
    48a2:	90 91 ed 21 	lds	r25, 0x21ED
    48a6:	a0 91 ee 21 	lds	r26, 0x21EE
    48aa:	b0 91 ef 21 	lds	r27, 0x21EF
    48ae:	80 93 45 40 	sts	0x4045, r24
    48b2:	90 93 46 40 	sts	0x4046, r25
    48b6:	a0 93 47 40 	sts	0x4047, r26
    48ba:	b0 93 48 40 	sts	0x4048, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    48be:	c0 91 51 40 	lds	r28, 0x4051
    48c2:	d0 91 52 40 	lds	r29, 0x4052
    48c6:	60 91 d0 21 	lds	r22, 0x21D0
    48ca:	70 e0       	ldi	r23, 0x00	; 0
    48cc:	80 e0       	ldi	r24, 0x00	; 0
    48ce:	90 e0       	ldi	r25, 0x00	; 0
    48d0:	20 91 e4 21 	lds	r18, 0x21E4
    48d4:	30 91 e5 21 	lds	r19, 0x21E5
    48d8:	40 91 e6 21 	lds	r20, 0x21E6
    48dc:	50 91 e7 21 	lds	r21, 0x21E7
    48e0:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    48e4:	8b 01       	movw	r16, r22
    48e6:	9c 01       	movw	r18, r24
    48e8:	ae 01       	movw	r20, r28
    48ea:	60 e0       	ldi	r22, 0x00	; 0
    48ec:	70 e0       	ldi	r23, 0x00	; 0
    48ee:	80 91 dc 21 	lds	r24, 0x21DC
    48f2:	90 91 dd 21 	lds	r25, 0x21DD
    48f6:	a0 91 de 21 	lds	r26, 0x21DE
    48fa:	b0 91 df 21 	lds	r27, 0x21DF
    48fe:	84 0f       	add	r24, r20
    4900:	95 1f       	adc	r25, r21
    4902:	a6 1f       	adc	r26, r22
    4904:	b7 1f       	adc	r27, r23
    4906:	80 0f       	add	r24, r16
    4908:	91 1f       	adc	r25, r17
    490a:	a2 1f       	adc	r26, r18
    490c:	b3 1f       	adc	r27, r19
    490e:	80 93 c4 23 	sts	0x23C4, r24
    4912:	90 93 c5 23 	sts	0x23C5, r25
    4916:	a0 93 c6 23 	sts	0x23C6, r26
    491a:	b0 93 c7 23 	sts	0x23C7, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    491e:	e0 91 4b 40 	lds	r30, 0x404B
    4922:	f0 91 4c 40 	lds	r31, 0x404C
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4926:	c7 01       	movw	r24, r14
    4928:	a0 e0       	ldi	r26, 0x00	; 0
    492a:	b0 e0       	ldi	r27, 0x00	; 0
    492c:	40 91 e0 21 	lds	r20, 0x21E0
    4930:	50 91 e1 21 	lds	r21, 0x21E1
    4934:	60 91 e2 21 	lds	r22, 0x21E2
    4938:	70 91 e3 21 	lds	r23, 0x21E3
    493c:	48 1b       	sub	r20, r24
    493e:	59 0b       	sbc	r21, r25
    4940:	6a 0b       	sbc	r22, r26
    4942:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4944:	cb 01       	movw	r24, r22
    4946:	ba 01       	movw	r22, r20
    4948:	60 1b       	sub	r22, r16
    494a:	71 0b       	sbc	r23, r17
    494c:	82 0b       	sbc	r24, r18
    494e:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4950:	9f 01       	movw	r18, r30
    4952:	40 e0       	ldi	r20, 0x00	; 0
    4954:	50 e0       	ldi	r21, 0x00	; 0
    4956:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    495a:	20 93 41 40 	sts	0x4041, r18
    495e:	30 93 42 40 	sts	0x4042, r19
    4962:	40 93 43 40 	sts	0x4043, r20
    4966:	50 93 44 40 	sts	0x4044, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    496a:	81 e0       	ldi	r24, 0x01	; 1
    496c:	60 e0       	ldi	r22, 0x00	; 0
    496e:	20 e0       	ldi	r18, 0x00	; 0
    4970:	30 e0       	ldi	r19, 0x00	; 0
    4972:	a9 01       	movw	r20, r18
    4974:	0e 94 51 23 	call	0x46a2	; 0x46a2 <getSetFreeCluster>
    4978:	ab 01       	movw	r20, r22
    497a:	bc 01       	movw	r22, r24
    497c:	80 91 41 40 	lds	r24, 0x4041
    4980:	90 91 42 40 	lds	r25, 0x4042
    4984:	a0 91 43 40 	lds	r26, 0x4043
    4988:	b0 91 44 40 	lds	r27, 0x4044
    498c:	84 17       	cp	r24, r20
    498e:	95 07       	cpc	r25, r21
    4990:	a6 07       	cpc	r26, r22
    4992:	b7 07       	cpc	r27, r23
    4994:	20 f4       	brcc	.+8      	; 0x499e <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4996:	10 92 5e 40 	sts	0x405E, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    499a:	80 e0       	ldi	r24, 0x00	; 0
    499c:	08 c0       	rjmp	.+16     	; 0x49ae <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    499e:	81 e0       	ldi	r24, 0x01	; 1
    49a0:	80 93 5e 40 	sts	0x405E, r24
return 0;
    49a4:	80 e0       	ldi	r24, 0x00	; 0
    49a6:	03 c0       	rjmp	.+6      	; 0x49ae <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    49a8:	81 e0       	ldi	r24, 0x01	; 1
    49aa:	01 c0       	rjmp	.+2      	; 0x49ae <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    49ac:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    49ae:	df 91       	pop	r29
    49b0:	cf 91       	pop	r28
    49b2:	1f 91       	pop	r17
    49b4:	0f 91       	pop	r16
    49b6:	ff 90       	pop	r15
    49b8:	ef 90       	pop	r14
    49ba:	08 95       	ret

000049bc <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    49bc:	cf 93       	push	r28
    49be:	df 93       	push	r29
    49c0:	cd b7       	in	r28, 0x3d	; 61
    49c2:	de b7       	in	r29, 0x3e	; 62
    49c4:	2b 97       	sbiw	r28, 0x0b	; 11
    49c6:	cd bf       	out	0x3d, r28	; 61
    49c8:	de bf       	out	0x3e, r29	; 62
    49ca:	9c 01       	movw	r18, r24
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
if(fileName[j] == '.') break;
    49cc:	fc 01       	movw	r30, r24
    49ce:	80 81       	ld	r24, Z
    49d0:	8e 32       	cpi	r24, 0x2E	; 46
    49d2:	89 f0       	breq	.+34     	; 0x49f6 <convertFileName+0x3a>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    49d4:	31 96       	adiw	r30, 0x01	; 1
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    49d6:	41 e0       	ldi	r20, 0x01	; 1
if(fileName[j] == '.') break;
    49d8:	81 91       	ld	r24, Z+
    49da:	8e 32       	cpi	r24, 0x2E	; 46
    49dc:	21 f0       	breq	.+8      	; 0x49e6 <convertFileName+0x2a>
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    49de:	4f 5f       	subi	r20, 0xFF	; 255
    49e0:	4c 30       	cpi	r20, 0x0C	; 12
    49e2:	d1 f7       	brne	.-12     	; 0x49d8 <convertFileName+0x1c>
    49e4:	05 c0       	rjmp	.+10     	; 0x49f0 <convertFileName+0x34>
if(fileName[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    49e6:	84 2f       	mov	r24, r20
    49e8:	89 50       	subi	r24, 0x09	; 9
    49ea:	83 30       	cpi	r24, 0x03	; 3
    49ec:	08 f4       	brcc	.+2      	; 0x49f0 <convertFileName+0x34>
    49ee:	62 c0       	rjmp	.+196    	; 0x4ab4 <convertFileName+0xf8>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    49f0:	44 23       	and	r20, r20
    49f2:	29 f4       	brne	.+10     	; 0x49fe <convertFileName+0x42>
    49f4:	01 c0       	rjmp	.+2      	; 0x49f8 <convertFileName+0x3c>
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    49f6:	40 e0       	ldi	r20, 0x00	; 0
    49f8:	84 2f       	mov	r24, r20

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = fileName[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    49fa:	90 e2       	ldi	r25, 0x20	; 32
    49fc:	14 c0       	rjmp	.+40     	; 0x4a26 <convertFileName+0x6a>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    49fe:	d9 01       	movw	r26, r18
    4a00:	fe 01       	movw	r30, r28
    4a02:	31 96       	adiw	r30, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4a04:	84 2f       	mov	r24, r20
    4a06:	81 50       	subi	r24, 0x01	; 1
    4a08:	62 e0       	ldi	r22, 0x02	; 2
    4a0a:	70 e0       	ldi	r23, 0x00	; 0
    4a0c:	6c 0f       	add	r22, r28
    4a0e:	7d 1f       	adc	r23, r29
    4a10:	68 0f       	add	r22, r24
    4a12:	71 1d       	adc	r23, r1
    4a14:	cb 01       	movw	r24, r22
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = fileName[k];
    4a16:	5d 91       	ld	r21, X+
    4a18:	51 93       	st	Z+, r21

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4a1a:	e8 17       	cp	r30, r24
    4a1c:	f9 07       	cpc	r31, r25
    4a1e:	d9 f7       	brne	.-10     	; 0x4a16 <convertFileName+0x5a>
  fileNameFAT[k] = fileName[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4a20:	48 30       	cpi	r20, 0x08	; 8
    4a22:	50 f3       	brcs	.-44     	; 0x49f8 <convertFileName+0x3c>
    4a24:	0a c0       	rjmp	.+20     	; 0x4a3a <convertFileName+0x7e>
  fileNameFAT[k] = ' ';
    4a26:	e1 e0       	ldi	r30, 0x01	; 1
    4a28:	f0 e0       	ldi	r31, 0x00	; 0
    4a2a:	ec 0f       	add	r30, r28
    4a2c:	fd 1f       	adc	r31, r29
    4a2e:	e8 0f       	add	r30, r24
    4a30:	f1 1d       	adc	r31, r1
    4a32:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = fileName[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4a34:	8f 5f       	subi	r24, 0xFF	; 255
    4a36:	88 30       	cpi	r24, 0x08	; 8
    4a38:	b0 f3       	brcs	.-20     	; 0x4a26 <convertFileName+0x6a>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4a3a:	4c 30       	cpi	r20, 0x0C	; 12
    4a3c:	09 f0       	breq	.+2      	; 0x4a40 <convertFileName+0x84>
    4a3e:	4f 5f       	subi	r20, 0xFF	; 255
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    4a40:	88 e0       	ldi	r24, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(fileName[j] != 0)
    4a42:	f9 01       	movw	r30, r18
    4a44:	e4 0f       	add	r30, r20
    4a46:	f1 1d       	adc	r31, r1
    4a48:	90 81       	ld	r25, Z
    4a4a:	99 23       	and	r25, r25
    4a4c:	19 f4       	brne	.+6      	; 0x4a54 <convertFileName+0x98>
    fileNameFAT[k] = fileName[j++];
  else //filling extension trail with blanks
    while(k<11)
    4a4e:	8b 30       	cpi	r24, 0x0B	; 11
    4a50:	50 f0       	brcs	.+20     	; 0x4a66 <convertFileName+0xaa>
    4a52:	15 c0       	rjmp	.+42     	; 0x4a7e <convertFileName+0xc2>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(fileName[j] != 0)
    fileNameFAT[k] = fileName[j++];
    4a54:	e1 e0       	ldi	r30, 0x01	; 1
    4a56:	f0 e0       	ldi	r31, 0x00	; 0
    4a58:	ec 0f       	add	r30, r28
    4a5a:	fd 1f       	adc	r31, r29
    4a5c:	e8 0f       	add	r30, r24
    4a5e:	f1 1d       	adc	r31, r1
    4a60:	90 83       	st	Z, r25
    4a62:	4f 5f       	subi	r20, 0xFF	; 255
    4a64:	0c c0       	rjmp	.+24     	; 0x4a7e <convertFileName+0xc2>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4a66:	90 e2       	ldi	r25, 0x20	; 32
    4a68:	e1 e0       	ldi	r30, 0x01	; 1
    4a6a:	f0 e0       	ldi	r31, 0x00	; 0
    4a6c:	ec 0f       	add	r30, r28
    4a6e:	fd 1f       	adc	r31, r29
    4a70:	e8 0f       	add	r30, r24
    4a72:	f1 1d       	adc	r31, r1
    4a74:	90 83       	st	Z, r25
    4a76:	8f 5f       	subi	r24, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(fileName[j] != 0)
    fileNameFAT[k] = fileName[j++];
  else //filling extension trail with blanks
    while(k<11)
    4a78:	8b 30       	cpi	r24, 0x0B	; 11
    4a7a:	b1 f7       	brne	.-20     	; 0x4a68 <convertFileName+0xac>
    4a7c:	03 c0       	rjmp	.+6      	; 0x4a84 <convertFileName+0xc8>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    4a7e:	8f 5f       	subi	r24, 0xFF	; 255
    4a80:	8b 30       	cpi	r24, 0x0B	; 11
    4a82:	f8 f2       	brcs	.-66     	; 0x4a42 <convertFileName+0x86>
    4a84:	fe 01       	movw	r30, r28
    4a86:	31 96       	adiw	r30, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4a88:	ce 01       	movw	r24, r28
    4a8a:	0c 96       	adiw	r24, 0x0c	; 12
    4a8c:	df 01       	movw	r26, r30
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    4a8e:	4c 91       	ld	r20, X
    4a90:	54 2f       	mov	r21, r20
    4a92:	51 56       	subi	r21, 0x61	; 97
    4a94:	5a 31       	cpi	r21, 0x1A	; 26
    4a96:	10 f4       	brcc	.+4      	; 0x4a9c <convertFileName+0xe0>
    fileNameFAT[j] -= 0x20;
    4a98:	40 52       	subi	r20, 0x20	; 32
    4a9a:	4c 93       	st	X, r20
    4a9c:	11 96       	adiw	r26, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    4a9e:	a8 17       	cp	r26, r24
    4aa0:	b9 07       	cpc	r27, r25
    4aa2:	a9 f7       	brne	.-22     	; 0x4a8e <convertFileName+0xd2>
    4aa4:	d9 01       	movw	r26, r18
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  fileName[j] = fileNameFAT[j];
    4aa6:	21 91       	ld	r18, Z+
    4aa8:	2d 93       	st	X+, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    4aaa:	e8 17       	cp	r30, r24
    4aac:	f9 07       	cpc	r31, r25
    4aae:	d9 f7       	brne	.-10     	; 0x4aa6 <convertFileName+0xea>
  fileName[j] = fileNameFAT[j];

return 0;
    4ab0:	80 e0       	ldi	r24, 0x00	; 0
    4ab2:	01 c0       	rjmp	.+2      	; 0x4ab6 <convertFileName+0xfa>

for(j=0; j<12; j++)
if(fileName[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4ab4:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  fileName[j] = fileNameFAT[j];

return 0;
}
    4ab6:	2b 96       	adiw	r28, 0x0b	; 11
    4ab8:	cd bf       	out	0x3d, r28	; 61
    4aba:	de bf       	out	0x3e, r29	; 62
    4abc:	df 91       	pop	r29
    4abe:	cf 91       	pop	r28
    4ac0:	08 95       	ret

00004ac2 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4ac2:	4f 92       	push	r4
    4ac4:	5f 92       	push	r5
    4ac6:	6f 92       	push	r6
    4ac8:	7f 92       	push	r7
    4aca:	8f 92       	push	r8
    4acc:	9f 92       	push	r9
    4ace:	af 92       	push	r10
    4ad0:	bf 92       	push	r11
    4ad2:	cf 92       	push	r12
    4ad4:	df 92       	push	r13
    4ad6:	ef 92       	push	r14
    4ad8:	ff 92       	push	r15
    4ada:	cf 93       	push	r28
    4adc:	df 93       	push	r29
    4ade:	2b 01       	movw	r4, r22
    4ae0:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4ae2:	20 e8       	ldi	r18, 0x80	; 128
    4ae4:	3f ef       	ldi	r19, 0xFF	; 255
    4ae6:	4f ef       	ldi	r20, 0xFF	; 255
    4ae8:	5f ef       	ldi	r21, 0xFF	; 255
    4aea:	42 22       	and	r4, r18
    4aec:	53 22       	and	r5, r19
    4aee:	64 22       	and	r6, r20
    4af0:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4af2:	80 91 41 40 	lds	r24, 0x4041
    4af6:	90 91 42 40 	lds	r25, 0x4042
    4afa:	a0 91 43 40 	lds	r26, 0x4043
    4afe:	b0 91 44 40 	lds	r27, 0x4044
    4b02:	48 16       	cp	r4, r24
    4b04:	59 06       	cpc	r5, r25
    4b06:	6a 06       	cpc	r6, r26
    4b08:	7b 06       	cpc	r7, r27
    4b0a:	08 f0       	brcs	.+2      	; 0x4b0e <searchNextFreeCluster+0x4c>
    4b0c:	77 c0       	rjmp	.+238    	; 0x4bfc <searchNextFreeCluster+0x13a>
    4b0e:	53 01       	movw	r10, r6
    4b10:	42 01       	movw	r8, r4
    4b12:	88 0c       	add	r8, r8
    4b14:	99 1c       	adc	r9, r9
    4b16:	aa 1c       	adc	r10, r10
    4b18:	bb 1c       	adc	r11, r11
    4b1a:	88 0c       	add	r8, r8
    4b1c:	99 1c       	adc	r9, r9
    4b1e:	aa 1c       	adc	r10, r10
    4b20:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4b22:	c0 ec       	ldi	r28, 0xC0	; 192
    4b24:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4b26:	c0 90 51 40 	lds	r12, 0x4051
    4b2a:	d0 90 52 40 	lds	r13, 0x4052
    4b2e:	20 91 3d 40 	lds	r18, 0x403D
    4b32:	30 91 3e 40 	lds	r19, 0x403E
    4b36:	ee 24       	eor	r14, r14
    4b38:	ff 24       	eor	r15, r15
    4b3a:	80 91 4d 40 	lds	r24, 0x404D
    4b3e:	90 91 4e 40 	lds	r25, 0x404E
    4b42:	a0 91 4f 40 	lds	r26, 0x404F
    4b46:	b0 91 50 40 	lds	r27, 0x4050
    4b4a:	c8 0e       	add	r12, r24
    4b4c:	d9 1e       	adc	r13, r25
    4b4e:	ea 1e       	adc	r14, r26
    4b50:	fb 1e       	adc	r15, r27
    4b52:	40 e0       	ldi	r20, 0x00	; 0
    4b54:	50 e0       	ldi	r21, 0x00	; 0
    4b56:	c5 01       	movw	r24, r10
    4b58:	b4 01       	movw	r22, r8
    4b5a:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    4b5e:	c7 01       	movw	r24, r14
    4b60:	b6 01       	movw	r22, r12
    4b62:	62 0f       	add	r22, r18
    4b64:	73 1f       	adc	r23, r19
    4b66:	84 1f       	adc	r24, r20
    4b68:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    4b6a:	ae 01       	movw	r20, r28
    4b6c:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    4b70:	88 81       	ld	r24, Y
    4b72:	99 81       	ldd	r25, Y+1	; 0x01
    4b74:	aa 81       	ldd	r26, Y+2	; 0x02
    4b76:	bb 81       	ldd	r27, Y+3	; 0x03
    4b78:	bf 70       	andi	r27, 0x0F	; 15
    4b7a:	00 97       	sbiw	r24, 0x00	; 0
    4b7c:	a1 05       	cpc	r26, r1
    4b7e:	b1 05       	cpc	r27, r1
    4b80:	99 f0       	breq	.+38     	; 0x4ba8 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4b82:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    4b84:	e2 2f       	mov	r30, r18
    4b86:	f0 e0       	ldi	r31, 0x00	; 0
    4b88:	ee 0f       	add	r30, r30
    4b8a:	ff 1f       	adc	r31, r31
    4b8c:	ee 0f       	add	r30, r30
    4b8e:	ff 1f       	adc	r31, r31
    4b90:	e0 54       	subi	r30, 0x40	; 64
    4b92:	fe 4d       	sbci	r31, 0xDE	; 222
         if(((*value) & 0x0fffffff) == 0)
    4b94:	80 81       	ld	r24, Z
    4b96:	91 81       	ldd	r25, Z+1	; 0x01
    4b98:	a2 81       	ldd	r26, Z+2	; 0x02
    4b9a:	b3 81       	ldd	r27, Z+3	; 0x03
    4b9c:	bf 70       	andi	r27, 0x0F	; 15
    4b9e:	00 97       	sbiw	r24, 0x00	; 0
    4ba0:	a1 05       	cpc	r26, r1
    4ba2:	b1 05       	cpc	r27, r1
    4ba4:	39 f4       	brne	.+14     	; 0x4bb4 <searchNextFreeCluster+0xf2>
    4ba6:	01 c0       	rjmp	.+2      	; 0x4baa <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4ba8:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4baa:	42 0e       	add	r4, r18
    4bac:	51 1c       	adc	r5, r1
    4bae:	61 1c       	adc	r6, r1
    4bb0:	71 1c       	adc	r7, r1
    4bb2:	27 c0       	rjmp	.+78     	; 0x4c02 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4bb4:	2f 5f       	subi	r18, 0xFF	; 255
    4bb6:	32 f7       	brpl	.-52     	; 0x4b84 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4bb8:	80 e8       	ldi	r24, 0x80	; 128
    4bba:	90 e0       	ldi	r25, 0x00	; 0
    4bbc:	a0 e0       	ldi	r26, 0x00	; 0
    4bbe:	b0 e0       	ldi	r27, 0x00	; 0
    4bc0:	48 0e       	add	r4, r24
    4bc2:	59 1e       	adc	r5, r25
    4bc4:	6a 1e       	adc	r6, r26
    4bc6:	7b 1e       	adc	r7, r27
    4bc8:	80 91 41 40 	lds	r24, 0x4041
    4bcc:	90 91 42 40 	lds	r25, 0x4042
    4bd0:	a0 91 43 40 	lds	r26, 0x4043
    4bd4:	b0 91 44 40 	lds	r27, 0x4044
    4bd8:	20 e0       	ldi	r18, 0x00	; 0
    4bda:	32 e0       	ldi	r19, 0x02	; 2
    4bdc:	40 e0       	ldi	r20, 0x00	; 0
    4bde:	50 e0       	ldi	r21, 0x00	; 0
    4be0:	82 0e       	add	r8, r18
    4be2:	93 1e       	adc	r9, r19
    4be4:	a4 1e       	adc	r10, r20
    4be6:	b5 1e       	adc	r11, r21
    4be8:	48 16       	cp	r4, r24
    4bea:	59 06       	cpc	r5, r25
    4bec:	6a 06       	cpc	r6, r26
    4bee:	7b 06       	cpc	r7, r27
    4bf0:	08 f4       	brcc	.+2      	; 0x4bf4 <searchNextFreeCluster+0x132>
    4bf2:	99 cf       	rjmp	.-206    	; 0x4b26 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4bf4:	44 24       	eor	r4, r4
    4bf6:	55 24       	eor	r5, r5
    4bf8:	32 01       	movw	r6, r4
    4bfa:	03 c0       	rjmp	.+6      	; 0x4c02 <searchNextFreeCluster+0x140>
    4bfc:	44 24       	eor	r4, r4
    4bfe:	55 24       	eor	r5, r5
    4c00:	32 01       	movw	r6, r4
}
    4c02:	64 2d       	mov	r22, r4
    4c04:	75 2d       	mov	r23, r5
    4c06:	86 2d       	mov	r24, r6
    4c08:	97 2d       	mov	r25, r7
    4c0a:	df 91       	pop	r29
    4c0c:	cf 91       	pop	r28
    4c0e:	ff 90       	pop	r15
    4c10:	ef 90       	pop	r14
    4c12:	df 90       	pop	r13
    4c14:	cf 90       	pop	r12
    4c16:	bf 90       	pop	r11
    4c18:	af 90       	pop	r10
    4c1a:	9f 90       	pop	r9
    4c1c:	8f 90       	pop	r8
    4c1e:	7f 90       	pop	r7
    4c20:	6f 90       	pop	r6
    4c22:	5f 90       	pop	r5
    4c24:	4f 90       	pop	r4
    4c26:	08 95       	ret

00004c28 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4c28:	cf 92       	push	r12
    4c2a:	df 92       	push	r13
    4c2c:	ef 92       	push	r14
    4c2e:	ff 92       	push	r15
    4c30:	cf 93       	push	r28
    4c32:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4c34:	db 01       	movw	r26, r22
    4c36:	ca 01       	movw	r24, r20
    4c38:	91 70       	andi	r25, 0x01	; 1
    4c3a:	a0 70       	andi	r26, 0x00	; 0
    4c3c:	b0 70       	andi	r27, 0x00	; 0
    4c3e:	00 97       	sbiw	r24, 0x00	; 0
    4c40:	a1 05       	cpc	r26, r1
    4c42:	b1 05       	cpc	r27, r1
    4c44:	51 f4       	brne	.+20     	; 0x4c5a <freeMemoryUpdate+0x32>
    4c46:	03 2e       	mov	r0, r19
    4c48:	39 e0       	ldi	r19, 0x09	; 9
    4c4a:	76 95       	lsr	r23
    4c4c:	67 95       	ror	r22
    4c4e:	57 95       	ror	r21
    4c50:	47 95       	ror	r20
    4c52:	3a 95       	dec	r19
    4c54:	d1 f7       	brne	.-12     	; 0x4c4a <freeMemoryUpdate+0x22>
    4c56:	30 2d       	mov	r19, r0
    4c58:	0d c0       	rjmp	.+26     	; 0x4c74 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4c5a:	03 2e       	mov	r0, r19
    4c5c:	39 e0       	ldi	r19, 0x09	; 9
    4c5e:	76 95       	lsr	r23
    4c60:	67 95       	ror	r22
    4c62:	57 95       	ror	r21
    4c64:	47 95       	ror	r20
    4c66:	3a 95       	dec	r19
    4c68:	d1 f7       	brne	.-12     	; 0x4c5e <freeMemoryUpdate+0x36>
    4c6a:	30 2d       	mov	r19, r0
    4c6c:	4f 5f       	subi	r20, 0xFF	; 255
    4c6e:	5f 4f       	sbci	r21, 0xFF	; 255
    4c70:	6f 4f       	sbci	r22, 0xFF	; 255
    4c72:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4c74:	db 01       	movw	r26, r22
    4c76:	ca 01       	movw	r24, r20
    4c78:	87 70       	andi	r24, 0x07	; 7
    4c7a:	90 70       	andi	r25, 0x00	; 0
    4c7c:	a0 70       	andi	r26, 0x00	; 0
    4c7e:	b0 70       	andi	r27, 0x00	; 0
    4c80:	00 97       	sbiw	r24, 0x00	; 0
    4c82:	a1 05       	cpc	r26, r1
    4c84:	b1 05       	cpc	r27, r1
    4c86:	59 f4       	brne	.+22     	; 0x4c9e <freeMemoryUpdate+0x76>
    4c88:	6a 01       	movw	r12, r20
    4c8a:	7b 01       	movw	r14, r22
    4c8c:	68 94       	set
    4c8e:	12 f8       	bld	r1, 2
    4c90:	f6 94       	lsr	r15
    4c92:	e7 94       	ror	r14
    4c94:	d7 94       	ror	r13
    4c96:	c7 94       	ror	r12
    4c98:	16 94       	lsr	r1
    4c9a:	d1 f7       	brne	.-12     	; 0x4c90 <freeMemoryUpdate+0x68>
    4c9c:	0f c0       	rjmp	.+30     	; 0x4cbc <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    4c9e:	6a 01       	movw	r12, r20
    4ca0:	7b 01       	movw	r14, r22
    4ca2:	68 94       	set
    4ca4:	12 f8       	bld	r1, 2
    4ca6:	f6 94       	lsr	r15
    4ca8:	e7 94       	ror	r14
    4caa:	d7 94       	ror	r13
    4cac:	c7 94       	ror	r12
    4cae:	16 94       	lsr	r1
    4cb0:	d1 f7       	brne	.-12     	; 0x4ca6 <freeMemoryUpdate+0x7e>
    4cb2:	08 94       	sec
    4cb4:	c1 1c       	adc	r12, r1
    4cb6:	d1 1c       	adc	r13, r1
    4cb8:	e1 1c       	adc	r14, r1
    4cba:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4cbc:	80 91 5e 40 	lds	r24, 0x405E
    4cc0:	88 23       	and	r24, r24
    4cc2:	d1 f0       	breq	.+52     	; 0x4cf8 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4cc4:	81 e0       	ldi	r24, 0x01	; 1
    4cc6:	60 e0       	ldi	r22, 0x00	; 0
    4cc8:	20 e0       	ldi	r18, 0x00	; 0
    4cca:	30 e0       	ldi	r19, 0x00	; 0
    4ccc:	a9 01       	movw	r20, r18
    4cce:	0e 94 51 23 	call	0x46a2	; 0x46a2 <getSetFreeCluster>
	if(flag == ADD)
    4cd2:	cc 23       	and	r28, r28
    4cd4:	39 f4       	brne	.+14     	; 0x4ce4 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4cd6:	9b 01       	movw	r18, r22
    4cd8:	ac 01       	movw	r20, r24
    4cda:	2c 0d       	add	r18, r12
    4cdc:	3d 1d       	adc	r19, r13
    4cde:	4e 1d       	adc	r20, r14
    4ce0:	5f 1d       	adc	r21, r15
    4ce2:	06 c0       	rjmp	.+12     	; 0x4cf0 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4ce4:	9b 01       	movw	r18, r22
    4ce6:	ac 01       	movw	r20, r24
    4ce8:	2c 19       	sub	r18, r12
    4cea:	3d 09       	sbc	r19, r13
    4cec:	4e 09       	sbc	r20, r14
    4cee:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4cf0:	81 e0       	ldi	r24, 0x01	; 1
    4cf2:	61 e0       	ldi	r22, 0x01	; 1
    4cf4:	0e 94 51 23 	call	0x46a2	; 0x46a2 <getSetFreeCluster>
  }
}
    4cf8:	cf 91       	pop	r28
    4cfa:	ff 90       	pop	r15
    4cfc:	ef 90       	pop	r14
    4cfe:	df 90       	pop	r13
    4d00:	cf 90       	pop	r12
    4d02:	08 95       	ret

00004d04 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4d04:	2f 92       	push	r2
    4d06:	3f 92       	push	r3
    4d08:	4f 92       	push	r4
    4d0a:	5f 92       	push	r5
    4d0c:	6f 92       	push	r6
    4d0e:	7f 92       	push	r7
    4d10:	8f 92       	push	r8
    4d12:	9f 92       	push	r9
    4d14:	af 92       	push	r10
    4d16:	bf 92       	push	r11
    4d18:	cf 92       	push	r12
    4d1a:	df 92       	push	r13
    4d1c:	ef 92       	push	r14
    4d1e:	ff 92       	push	r15
    4d20:	0f 93       	push	r16
    4d22:	1f 93       	push	r17
    4d24:	cf 93       	push	r28
    4d26:	df 93       	push	r29
    4d28:	cd b7       	in	r28, 0x3d	; 61
    4d2a:	de b7       	in	r29, 0x3e	; 62
    4d2c:	2c 97       	sbiw	r28, 0x0c	; 12
    4d2e:	cd bf       	out	0x3d, r28	; 61
    4d30:	de bf       	out	0x3e, r29	; 62
    4d32:	88 2e       	mov	r8, r24
    4d34:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4d36:	80 91 45 40 	lds	r24, 0x4045
    4d3a:	90 91 46 40 	lds	r25, 0x4046
    4d3e:	a0 91 47 40 	lds	r26, 0x4047
    4d42:	b0 91 48 40 	lds	r27, 0x4048
    4d46:	89 87       	std	Y+9, r24	; 0x09
    4d48:	9a 87       	std	Y+10, r25	; 0x0a
    4d4a:	ab 87       	std	Y+11, r26	; 0x0b
    4d4c:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4d4e:	0f 2e       	mov	r0, r31
    4d50:	f0 ec       	ldi	r31, 0xC0	; 192
    4d52:	2f 2e       	mov	r2, r31
    4d54:	f1 e2       	ldi	r31, 0x21	; 33
    4d56:	3f 2e       	mov	r3, r31
    4d58:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4d5a:	c8 2c       	mov	r12, r8
    4d5c:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4d5e:	d2 2c       	mov	r13, r2
    4d60:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4d62:	5b 01       	movw	r10, r22
    4d64:	08 94       	sec
    4d66:	a1 1c       	adc	r10, r1
    4d68:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4d6a:	69 85       	ldd	r22, Y+9	; 0x09
    4d6c:	7a 85       	ldd	r23, Y+10	; 0x0a
    4d6e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d70:	9c 85       	ldd	r25, Y+12	; 0x0c
    4d72:	0e 94 a8 22 	call	0x4550	; 0x4550 <getFirstSector>
    4d76:	6d 83       	std	Y+5, r22	; 0x05
    4d78:	7e 83       	std	Y+6, r23	; 0x06
    4d7a:	8f 83       	std	Y+7, r24	; 0x07
    4d7c:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4d7e:	80 91 4b 40 	lds	r24, 0x404B
    4d82:	90 91 4c 40 	lds	r25, 0x404C
    4d86:	00 97       	sbiw	r24, 0x00	; 0
    4d88:	09 f4       	brne	.+2      	; 0x4d8c <findFiles+0x88>
    4d8a:	13 c1       	rjmp	.+550    	; 0x4fb2 <findFiles+0x2ae>
    4d8c:	44 24       	eor	r4, r4
    4d8e:	55 24       	eor	r5, r5
    4d90:	32 01       	movw	r6, r4
    4d92:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4d94:	8d 81       	ldd	r24, Y+5	; 0x05
    4d96:	9e 81       	ldd	r25, Y+6	; 0x06
    4d98:	af 81       	ldd	r26, Y+7	; 0x07
    4d9a:	b8 85       	ldd	r27, Y+8	; 0x08
    4d9c:	84 0d       	add	r24, r4
    4d9e:	95 1d       	adc	r25, r5
    4da0:	a6 1d       	adc	r26, r6
    4da2:	b7 1d       	adc	r27, r7
    4da4:	89 83       	std	Y+1, r24	; 0x01
    4da6:	9a 83       	std	Y+2, r25	; 0x02
    4da8:	ab 83       	std	Y+3, r26	; 0x03
    4daa:	bc 83       	std	Y+4, r27	; 0x04
    4dac:	bc 01       	movw	r22, r24
    4dae:	cd 01       	movw	r24, r26
    4db0:	4d 2d       	mov	r20, r13
    4db2:	59 2d       	mov	r21, r9
    4db4:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4db8:	80 91 3d 40 	lds	r24, 0x403D
    4dbc:	90 91 3e 40 	lds	r25, 0x403E
    4dc0:	00 97       	sbiw	r24, 0x00	; 0
    4dc2:	09 f4       	brne	.+2      	; 0x4dc6 <findFiles+0xc2>
    4dc4:	e4 c0       	rjmp	.+456    	; 0x4f8e <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4dc6:	d1 01       	movw	r26, r2
    4dc8:	8c 91       	ld	r24, X
    4dca:	88 23       	and	r24, r24
    4dcc:	09 f4       	brne	.+2      	; 0x4dd0 <findFiles+0xcc>
    4dce:	10 c1       	rjmp	.+544    	; 0x4ff0 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4dd0:	4d 2d       	mov	r20, r13
    4dd2:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4dd4:	20 e0       	ldi	r18, 0x00	; 0
    4dd6:	30 e0       	ldi	r19, 0x00	; 0
    4dd8:	08 c0       	rjmp	.+16     	; 0x4dea <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4dda:	a9 01       	movw	r20, r18
    4ddc:	40 54       	subi	r20, 0x40	; 64
    4dde:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4de0:	fa 01       	movw	r30, r20
    4de2:	80 81       	ld	r24, Z
    4de4:	88 23       	and	r24, r24
    4de6:	09 f4       	brne	.+2      	; 0x4dea <findFiles+0xe6>
    4de8:	06 c1       	rjmp	.+524    	; 0x4ff6 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4dea:	85 3e       	cpi	r24, 0xE5	; 229
    4dec:	09 f4       	brne	.+2      	; 0x4df0 <findFiles+0xec>
    4dee:	c5 c0       	rjmp	.+394    	; 0x4f7a <findFiles+0x276>
    4df0:	da 01       	movw	r26, r20
    4df2:	1b 96       	adiw	r26, 0x0b	; 11
    4df4:	8c 91       	ld	r24, X
    4df6:	1b 97       	sbiw	r26, 0x0b	; 11
    4df8:	8f 30       	cpi	r24, 0x0F	; 15
    4dfa:	09 f4       	brne	.+2      	; 0x4dfe <findFiles+0xfa>
    4dfc:	be c0       	rjmp	.+380    	; 0x4f7a <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4dfe:	12 30       	cpi	r17, 0x02	; 2
    4e00:	08 f0       	brcs	.+2      	; 0x4e04 <findFiles+0x100>
    4e02:	fc c0       	rjmp	.+504    	; 0x4ffc <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4e04:	9c 91       	ld	r25, X
    4e06:	f7 01       	movw	r30, r14
    4e08:	80 81       	ld	r24, Z
    4e0a:	98 17       	cp	r25, r24
    4e0c:	09 f0       	breq	.+2      	; 0x4e10 <findFiles+0x10c>
    4e0e:	b5 c0       	rjmp	.+362    	; 0x4f7a <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4e10:	fa 01       	movw	r30, r20
    4e12:	31 96       	adiw	r30, 0x01	; 1
    4e14:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4e16:	81 e0       	ldi	r24, 0x01	; 1
    4e18:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4e1a:	41 91       	ld	r20, Z+
    4e1c:	9d 91       	ld	r25, X+
    4e1e:	49 17       	cp	r20, r25
    4e20:	31 f4       	brne	.+12     	; 0x4e2e <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4e22:	8f 5f       	subi	r24, 0xFF	; 255
    4e24:	8b 30       	cpi	r24, 0x0B	; 11
    4e26:	c9 f7       	brne	.-14     	; 0x4e1a <findFiles+0x116>
    4e28:	8b 01       	movw	r16, r22
    4e2a:	6b 01       	movw	r12, r22
    4e2c:	05 c0       	rjmp	.+10     	; 0x4e38 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4e2e:	8b 30       	cpi	r24, 0x0B	; 11
    4e30:	09 f0       	breq	.+2      	; 0x4e34 <findFiles+0x130>
    4e32:	a3 c0       	rjmp	.+326    	; 0x4f7a <findFiles+0x276>
    4e34:	8b 01       	movw	r16, r22
    4e36:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4e38:	f1 e0       	ldi	r31, 0x01	; 1
    4e3a:	8f 16       	cp	r8, r31
    4e3c:	09 f0       	breq	.+2      	; 0x4e40 <findFiles+0x13c>
    4e3e:	41 c0       	rjmp	.+130    	; 0x4ec2 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4e40:	89 81       	ldd	r24, Y+1	; 0x01
    4e42:	9a 81       	ldd	r25, Y+2	; 0x02
    4e44:	ab 81       	ldd	r26, Y+3	; 0x03
    4e46:	bc 81       	ldd	r27, Y+4	; 0x04
    4e48:	80 93 5f 40 	sts	0x405F, r24
    4e4c:	90 93 60 40 	sts	0x4060, r25
    4e50:	a0 93 61 40 	sts	0x4061, r26
    4e54:	b0 93 62 40 	sts	0x4062, r27
				appendFileLocation = i;
    4e58:	c9 01       	movw	r24, r18
    4e5a:	a0 e0       	ldi	r26, 0x00	; 0
    4e5c:	b0 e0       	ldi	r27, 0x00	; 0
    4e5e:	80 93 c0 23 	sts	0x23C0, r24
    4e62:	90 93 c1 23 	sts	0x23C1, r25
    4e66:	a0 93 c2 23 	sts	0x23C2, r26
    4e6a:	b0 93 c3 23 	sts	0x23C3, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4e6e:	d6 01       	movw	r26, r12
    4e70:	54 96       	adiw	r26, 0x14	; 20
    4e72:	4d 91       	ld	r20, X+
    4e74:	5c 91       	ld	r21, X
    4e76:	55 97       	sbiw	r26, 0x15	; 21
    4e78:	60 e0       	ldi	r22, 0x00	; 0
    4e7a:	70 e0       	ldi	r23, 0x00	; 0
    4e7c:	ba 01       	movw	r22, r20
    4e7e:	55 27       	eor	r21, r21
    4e80:	44 27       	eor	r20, r20
    4e82:	5a 96       	adiw	r26, 0x1a	; 26
    4e84:	8d 91       	ld	r24, X+
    4e86:	9c 91       	ld	r25, X
    4e88:	5b 97       	sbiw	r26, 0x1b	; 27
    4e8a:	a0 e0       	ldi	r26, 0x00	; 0
    4e8c:	b0 e0       	ldi	r27, 0x00	; 0
    4e8e:	84 2b       	or	r24, r20
    4e90:	95 2b       	or	r25, r21
    4e92:	a6 2b       	or	r26, r22
    4e94:	b7 2b       	or	r27, r23
    4e96:	80 93 53 40 	sts	0x4053, r24
    4e9a:	90 93 54 40 	sts	0x4054, r25
    4e9e:	a0 93 55 40 	sts	0x4055, r26
    4ea2:	b0 93 56 40 	sts	0x4056, r27
				fileSize = dir->fileSize;
    4ea6:	f6 01       	movw	r30, r12
    4ea8:	84 8d       	ldd	r24, Z+28	; 0x1c
    4eaa:	95 8d       	ldd	r25, Z+29	; 0x1d
    4eac:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4eae:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4eb0:	80 93 39 40 	sts	0x4039, r24
    4eb4:	90 93 3a 40 	sts	0x403A, r25
    4eb8:	a0 93 3b 40 	sts	0x403B, r26
    4ebc:	b0 93 3c 40 	sts	0x403C, r27
			    return (dir);
    4ec0:	a5 c0       	rjmp	.+330    	; 0x500c <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4ec2:	d6 01       	movw	r26, r12
    4ec4:	54 96       	adiw	r26, 0x14	; 20
    4ec6:	8d 91       	ld	r24, X+
    4ec8:	9c 91       	ld	r25, X
    4eca:	55 97       	sbiw	r26, 0x15	; 21
    4ecc:	a0 e0       	ldi	r26, 0x00	; 0
    4ece:	b0 e0       	ldi	r27, 0x00	; 0
    4ed0:	3c 01       	movw	r6, r24
    4ed2:	55 24       	eor	r5, r5
    4ed4:	44 24       	eor	r4, r4
    4ed6:	f6 01       	movw	r30, r12
    4ed8:	82 8d       	ldd	r24, Z+26	; 0x1a
    4eda:	93 8d       	ldd	r25, Z+27	; 0x1b
    4edc:	a0 e0       	ldi	r26, 0x00	; 0
    4ede:	b0 e0       	ldi	r27, 0x00	; 0
    4ee0:	48 2a       	or	r4, r24
    4ee2:	59 2a       	or	r5, r25
    4ee4:	6a 2a       	or	r6, r26
    4ee6:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4ee8:	85 ee       	ldi	r24, 0xE5	; 229
    4eea:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4eec:	69 81       	ldd	r22, Y+1	; 0x01
    4eee:	7a 81       	ldd	r23, Y+2	; 0x02
    4ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ef4:	40 ec       	ldi	r20, 0xC0	; 192
    4ef6:	51 e2       	ldi	r21, 0x21	; 33
    4ef8:	20 e0       	ldi	r18, 0x00	; 0
    4efa:	32 e0       	ldi	r19, 0x02	; 2
    4efc:	0e 94 a7 1c 	call	0x394e	; 0x394e <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4f00:	d6 01       	movw	r26, r12
    4f02:	5c 96       	adiw	r26, 0x1c	; 28
    4f04:	4d 91       	ld	r20, X+
    4f06:	5d 91       	ld	r21, X+
    4f08:	6d 91       	ld	r22, X+
    4f0a:	7c 91       	ld	r23, X
    4f0c:	5f 97       	sbiw	r26, 0x1f	; 31
    4f0e:	80 e0       	ldi	r24, 0x00	; 0
    4f10:	0e 94 14 26 	call	0x4c28	; 0x4c28 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4f14:	82 e0       	ldi	r24, 0x02	; 2
    4f16:	60 e0       	ldi	r22, 0x00	; 0
    4f18:	20 e0       	ldi	r18, 0x00	; 0
    4f1a:	30 e0       	ldi	r19, 0x00	; 0
    4f1c:	a9 01       	movw	r20, r18
    4f1e:	0e 94 51 23 	call	0x46a2	; 0x46a2 <getSetFreeCluster>
    4f22:	dc 01       	movw	r26, r24
    4f24:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4f26:	48 16       	cp	r4, r24
    4f28:	59 06       	cpc	r5, r25
    4f2a:	6a 06       	cpc	r6, r26
    4f2c:	7b 06       	cpc	r7, r27
    4f2e:	30 f4       	brcc	.+12     	; 0x4f3c <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4f30:	82 e0       	ldi	r24, 0x02	; 2
    4f32:	61 e0       	ldi	r22, 0x01	; 1
    4f34:	a3 01       	movw	r20, r6
    4f36:	92 01       	movw	r18, r4
    4f38:	0e 94 51 23 	call	0x46a2	; 0x46a2 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4f3c:	c3 01       	movw	r24, r6
    4f3e:	b2 01       	movw	r22, r4
    4f40:	40 e0       	ldi	r20, 0x00	; 0
    4f42:	00 e0       	ldi	r16, 0x00	; 0
    4f44:	10 e0       	ldi	r17, 0x00	; 0
    4f46:	98 01       	movw	r18, r16
    4f48:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
    4f4c:	6b 01       	movw	r12, r22
    4f4e:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4f50:	c3 01       	movw	r24, r6
    4f52:	b2 01       	movw	r22, r4
    4f54:	41 e0       	ldi	r20, 0x01	; 1
    4f56:	00 e0       	ldi	r16, 0x00	; 0
    4f58:	10 e0       	ldi	r17, 0x00	; 0
    4f5a:	98 01       	movw	r18, r16
    4f5c:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4f60:	b7 ef       	ldi	r27, 0xF7	; 247
    4f62:	cb 16       	cp	r12, r27
    4f64:	bf ef       	ldi	r27, 0xFF	; 255
    4f66:	db 06       	cpc	r13, r27
    4f68:	bf ef       	ldi	r27, 0xFF	; 255
    4f6a:	eb 06       	cpc	r14, r27
    4f6c:	bf e0       	ldi	r27, 0x0F	; 15
    4f6e:	fb 06       	cpc	r15, r27
    4f70:	08 f0       	brcs	.+2      	; 0x4f74 <findFiles+0x270>
    4f72:	47 c0       	rjmp	.+142    	; 0x5002 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4f74:	26 01       	movw	r4, r12
    4f76:	37 01       	movw	r6, r14
    4f78:	e1 cf       	rjmp	.-62     	; 0x4f3c <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4f7a:	20 5e       	subi	r18, 0xE0	; 224
    4f7c:	3f 4f       	sbci	r19, 0xFF	; 255
    4f7e:	80 91 3d 40 	lds	r24, 0x403D
    4f82:	90 91 3e 40 	lds	r25, 0x403E
    4f86:	28 17       	cp	r18, r24
    4f88:	39 07       	cpc	r19, r25
    4f8a:	08 f4       	brcc	.+2      	; 0x4f8e <findFiles+0x28a>
    4f8c:	26 cf       	rjmp	.-436    	; 0x4dda <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4f8e:	08 94       	sec
    4f90:	41 1c       	adc	r4, r1
    4f92:	51 1c       	adc	r5, r1
    4f94:	61 1c       	adc	r6, r1
    4f96:	71 1c       	adc	r7, r1
    4f98:	80 91 4b 40 	lds	r24, 0x404B
    4f9c:	90 91 4c 40 	lds	r25, 0x404C
    4fa0:	a0 e0       	ldi	r26, 0x00	; 0
    4fa2:	b0 e0       	ldi	r27, 0x00	; 0
    4fa4:	48 16       	cp	r4, r24
    4fa6:	59 06       	cpc	r5, r25
    4fa8:	6a 06       	cpc	r6, r26
    4faa:	7b 06       	cpc	r7, r27
    4fac:	08 f4       	brcc	.+2      	; 0x4fb0 <findFiles+0x2ac>
    4fae:	f2 ce       	rjmp	.-540    	; 0x4d94 <findFiles+0x90>
    4fb0:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4fb2:	69 85       	ldd	r22, Y+9	; 0x09
    4fb4:	7a 85       	ldd	r23, Y+10	; 0x0a
    4fb6:	8b 85       	ldd	r24, Y+11	; 0x0b
    4fb8:	9c 85       	ldd	r25, Y+12	; 0x0c
    4fba:	40 e0       	ldi	r20, 0x00	; 0
    4fbc:	00 e0       	ldi	r16, 0x00	; 0
    4fbe:	10 e0       	ldi	r17, 0x00	; 0
    4fc0:	98 01       	movw	r18, r16
    4fc2:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
    4fc6:	69 87       	std	Y+9, r22	; 0x09
    4fc8:	7a 87       	std	Y+10, r23	; 0x0a
    4fca:	8b 87       	std	Y+11, r24	; 0x0b
    4fcc:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4fce:	67 3f       	cpi	r22, 0xF7	; 247
    4fd0:	ef ef       	ldi	r30, 0xFF	; 255
    4fd2:	7e 07       	cpc	r23, r30
    4fd4:	ef ef       	ldi	r30, 0xFF	; 255
    4fd6:	8e 07       	cpc	r24, r30
    4fd8:	ef e0       	ldi	r30, 0x0F	; 15
    4fda:	9e 07       	cpc	r25, r30
    4fdc:	a8 f4       	brcc	.+42     	; 0x5008 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4fde:	61 15       	cp	r22, r1
    4fe0:	71 05       	cpc	r23, r1
    4fe2:	81 05       	cpc	r24, r1
    4fe4:	91 05       	cpc	r25, r1
    4fe6:	09 f0       	breq	.+2      	; 0x4fea <findFiles+0x2e6>
    4fe8:	c0 ce       	rjmp	.-640    	; 0x4d6a <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4fea:	00 e0       	ldi	r16, 0x00	; 0
    4fec:	10 e0       	ldi	r17, 0x00	; 0
    4fee:	0e c0       	rjmp	.+28     	; 0x500c <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4ff0:	00 e0       	ldi	r16, 0x00	; 0
    4ff2:	10 e0       	ldi	r17, 0x00	; 0
    4ff4:	0b c0       	rjmp	.+22     	; 0x500c <findFiles+0x308>
    4ff6:	00 e0       	ldi	r16, 0x00	; 0
    4ff8:	10 e0       	ldi	r17, 0x00	; 0
    4ffa:	08 c0       	rjmp	.+16     	; 0x500c <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4ffc:	00 e0       	ldi	r16, 0x00	; 0
    4ffe:	10 e0       	ldi	r17, 0x00	; 0
    5000:	05 c0       	rjmp	.+10     	; 0x500c <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    5002:	00 e0       	ldi	r16, 0x00	; 0
    5004:	10 e0       	ldi	r17, 0x00	; 0
    5006:	02 c0       	rjmp	.+4      	; 0x500c <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    5008:	00 e0       	ldi	r16, 0x00	; 0
    500a:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    500c:	80 2f       	mov	r24, r16
    500e:	91 2f       	mov	r25, r17
    5010:	2c 96       	adiw	r28, 0x0c	; 12
    5012:	cd bf       	out	0x3d, r28	; 61
    5014:	de bf       	out	0x3e, r29	; 62
    5016:	df 91       	pop	r29
    5018:	cf 91       	pop	r28
    501a:	1f 91       	pop	r17
    501c:	0f 91       	pop	r16
    501e:	ff 90       	pop	r15
    5020:	ef 90       	pop	r14
    5022:	df 90       	pop	r13
    5024:	cf 90       	pop	r12
    5026:	bf 90       	pop	r11
    5028:	af 90       	pop	r10
    502a:	9f 90       	pop	r9
    502c:	8f 90       	pop	r8
    502e:	7f 90       	pop	r7
    5030:	6f 90       	pop	r6
    5032:	5f 90       	pop	r5
    5034:	4f 90       	pop	r4
    5036:	3f 90       	pop	r3
    5038:	2f 90       	pop	r2
    503a:	08 95       	ret

0000503c <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    503c:	cf 93       	push	r28
    503e:	df 93       	push	r29
    5040:	ec 01       	movw	r28, r24
  unsigned char error;

  error = convertFileName (fileName);
    5042:	0e 94 de 24 	call	0x49bc	; 0x49bc <convertFileName>
  if(error) return;
    5046:	88 23       	and	r24, r24
    5048:	21 f4       	brne	.+8      	; 0x5052 <deleteFile+0x16>

  findFiles (DELETE, fileName);
    504a:	82 e0       	ldi	r24, 0x02	; 2
    504c:	be 01       	movw	r22, r28
    504e:	0e 94 82 26 	call	0x4d04	; 0x4d04 <findFiles>
}
    5052:	df 91       	pop	r29
    5054:	cf 91       	pop	r28
    5056:	08 95       	ret

00005058 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    5058:	4f 92       	push	r4
    505a:	5f 92       	push	r5
    505c:	6f 92       	push	r6
    505e:	7f 92       	push	r7
    5060:	af 92       	push	r10
    5062:	bf 92       	push	r11
    5064:	cf 92       	push	r12
    5066:	df 92       	push	r13
    5068:	ef 92       	push	r14
    506a:	ff 92       	push	r15
    506c:	0f 93       	push	r16
    506e:	1f 93       	push	r17
    5070:	cf 93       	push	r28
    5072:	df 93       	push	r29
    5074:	18 2f       	mov	r17, r24
    5076:	eb 01       	movw	r28, r22
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    5078:	cb 01       	movw	r24, r22
    507a:	0e 94 de 24 	call	0x49bc	; 0x49bc <convertFileName>
if(error) return 2;
    507e:	88 23       	and	r24, r24
    5080:	09 f0       	breq	.+2      	; 0x5084 <readFile+0x2c>
    5082:	56 c0       	rjmp	.+172    	; 0x5130 <readFile+0xd8>

dir = findFiles (GET_FILE, fileName); //get the file location
    5084:	81 e0       	ldi	r24, 0x01	; 1
    5086:	be 01       	movw	r22, r28
    5088:	0e 94 82 26 	call	0x4d04	; 0x4d04 <findFiles>
    508c:	fc 01       	movw	r30, r24
if(dir == 0) 
    508e:	00 97       	sbiw	r24, 0x00	; 0
    5090:	31 f4       	brne	.+12     	; 0x509e <readFile+0x46>
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    5092:	81 e0       	ldi	r24, 0x01	; 1
    5094:	11 23       	and	r17, r17
    5096:	09 f4       	brne	.+2      	; 0x509a <readFile+0x42>
    5098:	4e c0       	rjmp	.+156    	; 0x5136 <readFile+0xde>
    509a:	80 e0       	ldi	r24, 0x00	; 0
    509c:	4c c0       	rjmp	.+152    	; 0x5136 <readFile+0xde>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    509e:	11 30       	cpi	r17, 0x01	; 1
    50a0:	09 f4       	brne	.+2      	; 0x50a4 <readFile+0x4c>
    50a2:	48 c0       	rjmp	.+144    	; 0x5134 <readFile+0xdc>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    50a4:	44 88       	ldd	r4, Z+20	; 0x14
    50a6:	55 88       	ldd	r5, Z+21	; 0x15
    50a8:	66 24       	eor	r6, r6
    50aa:	77 24       	eor	r7, r7
    50ac:	32 01       	movw	r6, r4
    50ae:	55 24       	eor	r5, r5
    50b0:	44 24       	eor	r4, r4
    50b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    50b4:	93 8d       	ldd	r25, Z+27	; 0x1b
    50b6:	a0 e0       	ldi	r26, 0x00	; 0
    50b8:	b0 e0       	ldi	r27, 0x00	; 0
    50ba:	48 2a       	or	r4, r24
    50bc:	59 2a       	or	r5, r25
    50be:	6a 2a       	or	r6, r26
    50c0:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    50c2:	0f 2e       	mov	r0, r31
    50c4:	f8 ec       	ldi	r31, 0xC8	; 200
    50c6:	af 2e       	mov	r10, r31
    50c8:	f3 e2       	ldi	r31, 0x23	; 35
    50ca:	bf 2e       	mov	r11, r31
    50cc:	f0 2d       	mov	r31, r0
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    50ce:	c3 01       	movw	r24, r6
    50d0:	b2 01       	movw	r22, r4
    50d2:	0e 94 a8 22 	call	0x4550	; 0x4550 <getFirstSector>
    50d6:	6b 01       	movw	r12, r22
    50d8:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    50da:	80 91 4b 40 	lds	r24, 0x404B
    50de:	90 91 4c 40 	lds	r25, 0x404C
    50e2:	00 97       	sbiw	r24, 0x00	; 0
    50e4:	a1 f0       	breq	.+40     	; 0x510e <readFile+0xb6>
    50e6:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    50e8:	c7 01       	movw	r24, r14
    50ea:	b6 01       	movw	r22, r12
    50ec:	6c 0f       	add	r22, r28
    50ee:	71 1d       	adc	r23, r1
    50f0:	81 1d       	adc	r24, r1
    50f2:	91 1d       	adc	r25, r1
    50f4:	a5 01       	movw	r20, r10
    50f6:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    50fa:	cf 5f       	subi	r28, 0xFF	; 255
    50fc:	80 91 4b 40 	lds	r24, 0x404B
    5100:	90 91 4c 40 	lds	r25, 0x404C
    5104:	2c 2f       	mov	r18, r28
    5106:	30 e0       	ldi	r19, 0x00	; 0
    5108:	28 17       	cp	r18, r24
    510a:	39 07       	cpc	r19, r25
    510c:	68 f3       	brcs	.-38     	; 0x50e8 <readFile+0x90>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    510e:	c3 01       	movw	r24, r6
    5110:	b2 01       	movw	r22, r4
    5112:	40 e0       	ldi	r20, 0x00	; 0
    5114:	00 e0       	ldi	r16, 0x00	; 0
    5116:	10 e0       	ldi	r17, 0x00	; 0
    5118:	98 01       	movw	r18, r16
    511a:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
    511e:	2b 01       	movw	r4, r22
    5120:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    5122:	61 15       	cp	r22, r1
    5124:	71 05       	cpc	r23, r1
    5126:	81 05       	cpc	r24, r1
    5128:	91 05       	cpc	r25, r1
    512a:	89 f6       	brne	.-94     	; 0x50ce <readFile+0x76>
	  return 0;}
    512c:	80 e0       	ldi	r24, 0x00	; 0
    512e:	03 c0       	rjmp	.+6      	; 0x5136 <readFile+0xde>
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    5130:	82 e0       	ldi	r24, 0x02	; 2
    5132:	01 c0       	rjmp	.+2      	; 0x5136 <readFile+0xde>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    5134:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    5136:	df 91       	pop	r29
    5138:	cf 91       	pop	r28
    513a:	1f 91       	pop	r17
    513c:	0f 91       	pop	r16
    513e:	ff 90       	pop	r15
    5140:	ef 90       	pop	r14
    5142:	df 90       	pop	r13
    5144:	cf 90       	pop	r12
    5146:	bf 90       	pop	r11
    5148:	af 90       	pop	r10
    514a:	7f 90       	pop	r7
    514c:	6f 90       	pop	r6
    514e:	5f 90       	pop	r5
    5150:	4f 90       	pop	r4
    5152:	08 95       	ret

00005154 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char *fileName){
    5154:	2f 92       	push	r2
    5156:	3f 92       	push	r3
    5158:	4f 92       	push	r4
    515a:	5f 92       	push	r5
    515c:	6f 92       	push	r6
    515e:	7f 92       	push	r7
    5160:	8f 92       	push	r8
    5162:	9f 92       	push	r9
    5164:	af 92       	push	r10
    5166:	bf 92       	push	r11
    5168:	cf 92       	push	r12
    516a:	df 92       	push	r13
    516c:	ef 92       	push	r14
    516e:	ff 92       	push	r15
    5170:	0f 93       	push	r16
    5172:	1f 93       	push	r17
    5174:	cf 93       	push	r28
    5176:	df 93       	push	r29
    5178:	cd b7       	in	r28, 0x3d	; 61
    517a:	de b7       	in	r29, 0x3e	; 62
    517c:	29 97       	sbiw	r28, 0x09	; 9
    517e:	cd bf       	out	0x3d, r28	; 61
    5180:	de bf       	out	0x3e, r29	; 62
    5182:	89 83       	std	Y+1, r24	; 0x01
    5184:	9a 83       	std	Y+2, r25	; 0x02
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;

j = readFile (VERIFY, fileName);
    5186:	81 e0       	ldi	r24, 0x01	; 1
    5188:	69 81       	ldd	r22, Y+1	; 0x01
    518a:	79 2f       	mov	r23, r25
    518c:	0e 94 2c 28 	call	0x5058	; 0x5058 <readFile>

if(j == 1) 
    5190:	81 30       	cpi	r24, 0x01	; 1
    5192:	09 f0       	breq	.+2      	; 0x5196 <writeFile+0x42>
    5194:	6f c0       	rjmp	.+222    	; 0x5274 <writeFile+0x120>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    5196:	80 90 53 40 	lds	r8, 0x4053
    519a:	90 90 54 40 	lds	r9, 0x4054
    519e:	a0 90 55 40 	lds	r10, 0x4055
    51a2:	b0 90 56 40 	lds	r11, 0x4056
  clusterCount=0;
    51a6:	cc 24       	eor	r12, r12
    51a8:	dd 24       	eor	r13, r13
    51aa:	76 01       	movw	r14, r12
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    51ac:	c5 01       	movw	r24, r10
    51ae:	b4 01       	movw	r22, r8
    51b0:	40 e0       	ldi	r20, 0x00	; 0
    51b2:	00 e0       	ldi	r16, 0x00	; 0
    51b4:	10 e0       	ldi	r17, 0x00	; 0
    51b6:	98 01       	movw	r18, r16
    51b8:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
    51bc:	dc 01       	movw	r26, r24
    51be:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    51c0:	8f 3f       	cpi	r24, 0xFF	; 255
    51c2:	0f ef       	ldi	r16, 0xFF	; 255
    51c4:	90 07       	cpc	r25, r16
    51c6:	0f ef       	ldi	r16, 0xFF	; 255
    51c8:	a0 07       	cpc	r26, r16
    51ca:	0f e0       	ldi	r16, 0x0F	; 15
    51cc:	b0 07       	cpc	r27, r16
    51ce:	41 f0       	breq	.+16     	; 0x51e0 <writeFile+0x8c>
	cluster = nextCluster;
	clusterCount++;
    51d0:	08 94       	sec
    51d2:	c1 1c       	adc	r12, r1
    51d4:	d1 1c       	adc	r13, r1
    51d6:	e1 1c       	adc	r14, r1
    51d8:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    51da:	4c 01       	movw	r8, r24
    51dc:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    51de:	e6 cf       	rjmp	.-52     	; 0x51ac <writeFile+0x58>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    51e0:	20 91 4b 40 	lds	r18, 0x404B
    51e4:	30 91 4c 40 	lds	r19, 0x404C
    51e8:	80 91 3d 40 	lds	r24, 0x403D
    51ec:	90 91 3e 40 	lds	r25, 0x403E
    51f0:	60 90 3d 40 	lds	r6, 0x403D
    51f4:	70 90 3e 40 	lds	r7, 0x403E
    51f8:	bc 01       	movw	r22, r24
    51fa:	80 e0       	ldi	r24, 0x00	; 0
    51fc:	90 e0       	ldi	r25, 0x00	; 0
    51fe:	40 e0       	ldi	r20, 0x00	; 0
    5200:	50 e0       	ldi	r21, 0x00	; 0
    5202:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    5206:	a7 01       	movw	r20, r14
    5208:	96 01       	movw	r18, r12
    520a:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    520e:	dc 01       	movw	r26, r24
    5210:	cb 01       	movw	r24, r22
    5212:	40 91 39 40 	lds	r20, 0x4039
    5216:	50 91 3a 40 	lds	r21, 0x403A
    521a:	60 91 3b 40 	lds	r22, 0x403B
    521e:	70 91 3c 40 	lds	r23, 0x403C
    5222:	8a 01       	movw	r16, r20
    5224:	9b 01       	movw	r18, r22
    5226:	08 1b       	sub	r16, r24
    5228:	19 0b       	sbc	r17, r25
    522a:	2a 0b       	sbc	r18, r26
    522c:	3b 0b       	sbc	r19, r27
    522e:	c9 01       	movw	r24, r18
    5230:	b8 01       	movw	r22, r16
    5232:	93 01       	movw	r18, r6
    5234:	40 e0       	ldi	r20, 0x00	; 0
    5236:	50 e0       	ldi	r21, 0x00	; 0
    5238:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    523c:	02 2f       	mov	r16, r18
}

//start writing data here
if(start){
      start = 0;
	  startBlock = getFirstSector (cluster) + sector;
    523e:	68 2d       	mov	r22, r8
    5240:	79 2d       	mov	r23, r9
    5242:	8a 2d       	mov	r24, r10
    5244:	9b 2d       	mov	r25, r11
    5246:	0e 94 a8 22 	call	0x4550	; 0x4550 <getFirstSector>
    524a:	ab 01       	movw	r20, r22
    524c:	bc 01       	movw	r22, r24
    524e:	80 2f       	mov	r24, r16
    5250:	90 e0       	ldi	r25, 0x00	; 0
    5252:	6c 01       	movw	r12, r24
    5254:	c4 0e       	add	r12, r20
    5256:	d5 1e       	adc	r13, r21
	  SD_read_block (startBlock,SDBuffer);
    5258:	b6 01       	movw	r22, r12
    525a:	80 e0       	ldi	r24, 0x00	; 0
    525c:	90 e0       	ldi	r25, 0x00	; 0
    525e:	40 ec       	ldi	r20, 0xC0	; 192
    5260:	51 e2       	ldi	r21, 0x21	; 33
    5262:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char *fileName){
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    5266:	44 24       	eor	r4, r4
    5268:	55 24       	eor	r5, r5
    526a:	22 24       	eor	r2, r2
    526c:	33 24       	eor	r3, r3
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    526e:	66 24       	eor	r6, r6
    5270:	63 94       	inc	r6
    5272:	43 c0       	rjmp	.+134    	; 0x52fa <writeFile+0x1a6>
}
else if(j == 2) 
    5274:	82 30       	cpi	r24, 0x02	; 2
    5276:	09 f4       	brne	.+2      	; 0x527a <writeFile+0x126>
    5278:	af c1       	rjmp	.+862    	; 0x55d8 <writeFile+0x484>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    527a:	82 e0       	ldi	r24, 0x02	; 2
    527c:	60 e0       	ldi	r22, 0x00	; 0
    527e:	20 e0       	ldi	r18, 0x00	; 0
    5280:	30 e0       	ldi	r19, 0x00	; 0
    5282:	a9 01       	movw	r20, r18
    5284:	0e 94 51 23 	call	0x46a2	; 0x46a2 <getSetFreeCluster>
  if(cluster > totalClusters)
    5288:	00 91 41 40 	lds	r16, 0x4041
    528c:	10 91 42 40 	lds	r17, 0x4042
    5290:	20 91 43 40 	lds	r18, 0x4043
    5294:	30 91 44 40 	lds	r19, 0x4044
    5298:	06 17       	cp	r16, r22
    529a:	17 07       	cpc	r17, r23
    529c:	28 07       	cpc	r18, r24
    529e:	39 07       	cpc	r19, r25
    52a0:	40 f4       	brcc	.+16     	; 0x52b2 <writeFile+0x15e>
     cluster = rootCluster;
    52a2:	60 91 45 40 	lds	r22, 0x4045
    52a6:	70 91 46 40 	lds	r23, 0x4046
    52aa:	80 91 47 40 	lds	r24, 0x4047
    52ae:	90 91 48 40 	lds	r25, 0x4048

  cluster = searchNextFreeCluster(cluster);
    52b2:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <searchNextFreeCluster>
    52b6:	4b 01       	movw	r8, r22
    52b8:	5c 01       	movw	r10, r24
   if(cluster == 0)
    52ba:	61 15       	cp	r22, r1
    52bc:	71 05       	cpc	r23, r1
    52be:	81 05       	cpc	r24, r1
    52c0:	91 05       	cpc	r25, r1
    52c2:	09 f4       	brne	.+2      	; 0x52c6 <writeFile+0x172>
    52c4:	8b c1       	rjmp	.+790    	; 0x55dc <writeFile+0x488>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    52c6:	41 e0       	ldi	r20, 0x01	; 1
    52c8:	0f ef       	ldi	r16, 0xFF	; 255
    52ca:	1f ef       	ldi	r17, 0xFF	; 255
    52cc:	2f ef       	ldi	r18, 0xFF	; 255
    52ce:	3f e0       	ldi	r19, 0x0F	; 15
    52d0:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    52d4:	15 01       	movw	r2, r10
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    52d6:	24 01       	movw	r4, r8
  fileSize = 0;
    52d8:	10 92 39 40 	sts	0x4039, r1
    52dc:	10 92 3a 40 	sts	0x403A, r1
    52e0:	10 92 3b 40 	sts	0x403B, r1
    52e4:	10 92 3c 40 	sts	0x403C, r1
	  startBlock = getFirstSector (cluster) + sector;
	  SD_read_block (startBlock,SDBuffer);
	  j = sector;
   }
   else{
      startBlock = getFirstSector (cluster);
    52e8:	c5 01       	movw	r24, r10
    52ea:	b4 01       	movw	r22, r8
    52ec:	0e 94 a8 22 	call	0x4550	; 0x4550 <getFirstSector>
    52f0:	dc 01       	movw	r26, r24
    52f2:	cb 01       	movw	r24, r22
    52f4:	6c 01       	movw	r12, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char *fileName){
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    52f6:	66 24       	eor	r6, r6
	  SD_read_block (startBlock,SDBuffer);
	  j = sector;
   }
   else{
      startBlock = getFirstSector (cluster);
	  j=0;
    52f8:	00 e0       	ldi	r16, 0x00	; 0
   }
//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes   
fileSize += 512;
    52fa:	80 91 39 40 	lds	r24, 0x4039
    52fe:	90 91 3a 40 	lds	r25, 0x403A
    5302:	a0 91 3b 40 	lds	r26, 0x403B
    5306:	b0 91 3c 40 	lds	r27, 0x403C
    530a:	80 50       	subi	r24, 0x00	; 0
    530c:	9e 4f       	sbci	r25, 0xFE	; 254
    530e:	af 4f       	sbci	r26, 0xFF	; 255
    5310:	bf 4f       	sbci	r27, 0xFF	; 255
    5312:	80 93 39 40 	sts	0x4039, r24
    5316:	90 93 3a 40 	sts	0x403A, r25
    531a:	a0 93 3b 40 	sts	0x403B, r26
    531e:	b0 93 3c 40 	sts	0x403C, r27
SD_write_block (startBlock,FRAMReadBuffer,512);
    5322:	b6 01       	movw	r22, r12
    5324:	80 e0       	ldi	r24, 0x00	; 0
    5326:	90 e0       	ldi	r25, 0x00	; 0
    5328:	48 ec       	ldi	r20, 0xC8	; 200
    532a:	53 e2       	ldi	r21, 0x23	; 35
    532c:	20 e0       	ldi	r18, 0x00	; 0
    532e:	32 e0       	ldi	r19, 0x02	; 2
    5330:	0e 94 a7 1c 	call	0x394e	; 0x394e <SD_write_block>
j++;
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
    5334:	20 91 4b 40 	lds	r18, 0x404B
    5338:	30 91 4c 40 	lds	r19, 0x404C
	  j=0;
   }
//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes   
fileSize += 512;
SD_write_block (startBlock,FRAMReadBuffer,512);
j++;
    533c:	0f 5f       	subi	r16, 0xFF	; 255
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
    533e:	80 2f       	mov	r24, r16
    5340:	90 e0       	ldi	r25, 0x00	; 0
    5342:	82 17       	cp	r24, r18
    5344:	93 07       	cpc	r25, r19
    5346:	f1 f4       	brne	.+60     	; 0x5384 <writeFile+0x230>
	j = 0; 
 
	prevCluster = cluster;
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5348:	c5 01       	movw	r24, r10
    534a:	b4 01       	movw	r22, r8
    534c:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <searchNextFreeCluster>
    5350:	6b 01       	movw	r12, r22
    5352:	7c 01       	movw	r14, r24
	if(cluster == 0){
    5354:	61 15       	cp	r22, r1
    5356:	71 05       	cpc	r23, r1
    5358:	81 05       	cpc	r24, r1
    535a:	91 05       	cpc	r25, r1
    535c:	09 f4       	brne	.+2      	; 0x5360 <writeFile+0x20c>
    535e:	40 c1       	rjmp	.+640    	; 0x55e0 <writeFile+0x48c>
      //No free cluster!
	  return 2;
   }
	getSetNextCluster(prevCluster, SET, cluster);
    5360:	c5 01       	movw	r24, r10
    5362:	b4 01       	movw	r22, r8
    5364:	41 e0       	ldi	r20, 0x01	; 1
    5366:	97 01       	movw	r18, r14
    5368:	86 01       	movw	r16, r12
    536a:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
	getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    536e:	c7 01       	movw	r24, r14
    5370:	b6 01       	movw	r22, r12
    5372:	41 e0       	ldi	r20, 0x01	; 1
    5374:	0f ef       	ldi	r16, 0xFF	; 255
    5376:	1f ef       	ldi	r17, 0xFF	; 255
    5378:	2f ef       	ldi	r18, 0xFF	; 255
    537a:	3f e0       	ldi	r19, 0x0F	; 15
    537c:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
	j = 0; 
 
	prevCluster = cluster;
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5380:	46 01       	movw	r8, r12
    5382:	57 01       	movw	r10, r14
	getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
}
//otherwise increment the sector offset 
else startBlock++;       

getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    5384:	82 e0       	ldi	r24, 0x02	; 2
    5386:	61 e0       	ldi	r22, 0x01	; 1
    5388:	a5 01       	movw	r20, r10
    538a:	94 01       	movw	r18, r8
    538c:	0e 94 51 23 	call	0x46a2	; 0x46a2 <getSetFreeCluster>

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    5390:	66 20       	and	r6, r6
    5392:	09 f4       	brne	.+2      	; 0x5396 <writeFile+0x242>
    5394:	3f c0       	rjmp	.+126    	; 0x5414 <writeFile+0x2c0>
{
  SD_read_block (appendFileSector,SDBuffer);    
    5396:	60 91 5f 40 	lds	r22, 0x405F
    539a:	70 91 60 40 	lds	r23, 0x4060
    539e:	80 91 61 40 	lds	r24, 0x4061
    53a2:	90 91 62 40 	lds	r25, 0x4062
    53a6:	00 ec       	ldi	r16, 0xC0	; 192
    53a8:	11 e2       	ldi	r17, 0x21	; 33
    53aa:	a8 01       	movw	r20, r16
    53ac:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    53b0:	e0 91 c0 23 	lds	r30, 0x23C0
    53b4:	f0 91 c1 23 	lds	r31, 0x23C1
    53b8:	e0 0f       	add	r30, r16
    53ba:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    53bc:	12 8a       	std	Z+18, r1	; 0x12
    53be:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    53c0:	80 91 39 40 	lds	r24, 0x4039
    53c4:	90 91 3a 40 	lds	r25, 0x403A
    53c8:	a0 91 3b 40 	lds	r26, 0x403B
    53cc:	b0 91 3c 40 	lds	r27, 0x403C
    53d0:	44 8d       	ldd	r20, Z+28	; 0x1c
    53d2:	55 8d       	ldd	r21, Z+29	; 0x1d
    53d4:	66 8d       	ldd	r22, Z+30	; 0x1e
    53d6:	77 8d       	ldd	r23, Z+31	; 0x1f
    53d8:	6c 01       	movw	r12, r24
    53da:	7d 01       	movw	r14, r26
    53dc:	c4 1a       	sub	r12, r20
    53de:	d5 0a       	sbc	r13, r21
    53e0:	e6 0a       	sbc	r14, r22
    53e2:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    53e4:	84 8f       	std	Z+28, r24	; 0x1c
    53e6:	95 8f       	std	Z+29, r25	; 0x1d
    53e8:	a6 8f       	std	Z+30, r26	; 0x1e
    53ea:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    53ec:	60 91 5f 40 	lds	r22, 0x405F
    53f0:	70 91 60 40 	lds	r23, 0x4060
    53f4:	80 91 61 40 	lds	r24, 0x4061
    53f8:	90 91 62 40 	lds	r25, 0x4062
    53fc:	a8 01       	movw	r20, r16
    53fe:	20 e0       	ldi	r18, 0x00	; 0
    5400:	32 e0       	ldi	r19, 0x02	; 2
    5402:	0e 94 a7 1c 	call	0x394e	; 0x394e <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    5406:	81 e0       	ldi	r24, 0x01	; 1
    5408:	b7 01       	movw	r22, r14
    540a:	a6 01       	movw	r20, r12
    540c:	0e 94 14 26 	call	0x4c28	; 0x4c28 <freeMemoryUpdate>

 //File appended!
  return 0;
    5410:	80 e0       	ldi	r24, 0x00	; 0
    5412:	ed c0       	rjmp	.+474    	; 0x55ee <writeFile+0x49a>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    5414:	80 91 45 40 	lds	r24, 0x4045
    5418:	90 91 46 40 	lds	r25, 0x4046
    541c:	a0 91 47 40 	lds	r26, 0x4047
    5420:	b0 91 48 40 	lds	r27, 0x4048
    5424:	8e 83       	std	Y+6, r24	; 0x06
    5426:	9f 83       	std	Y+7, r25	; 0x07
    5428:	a8 87       	std	Y+8, r26	; 0x08
    542a:	b9 87       	std	Y+9, r27	; 0x09
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char *fileName){
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    542c:	bb 24       	eor	r11, r11

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = fileName[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    542e:	88 24       	eor	r8, r8
    5430:	68 94       	set
    5432:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5434:	0f 2e       	mov	r0, r31
    5436:	f0 ec       	ldi	r31, 0xC0	; 192
    5438:	6f 2e       	mov	r6, r31
    543a:	f1 e2       	ldi	r31, 0x21	; 33
    543c:	7f 2e       	mov	r7, r31
    543e:	f0 2d       	mov	r31, r0
    5440:	99 80       	ldd	r9, Y+1	; 0x01
    5442:	aa 80       	ldd	r10, Y+2	; 0x02
    5444:	04 c0       	rjmp	.+8      	; 0x544e <writeFile+0x2fa>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    5446:	ce 82       	std	Y+6, r12	; 0x06
    5448:	df 82       	std	Y+7, r13	; 0x07
    544a:	e8 86       	std	Y+8, r14	; 0x08
    544c:	f9 86       	std	Y+9, r15	; 0x09

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    544e:	6e 81       	ldd	r22, Y+6	; 0x06
    5450:	7f 81       	ldd	r23, Y+7	; 0x07
    5452:	88 85       	ldd	r24, Y+8	; 0x08
    5454:	99 85       	ldd	r25, Y+9	; 0x09
    5456:	0e 94 a8 22 	call	0x4550	; 0x4550 <getFirstSector>
    545a:	6a 83       	std	Y+2, r22	; 0x02
    545c:	7b 83       	std	Y+3, r23	; 0x03
    545e:	8c 83       	std	Y+4, r24	; 0x04
    5460:	9d 83       	std	Y+5, r25	; 0x05

   for(sector = 0; sector < sectorPerCluster; sector++)
    5462:	80 91 4b 40 	lds	r24, 0x404B
    5466:	90 91 4c 40 	lds	r25, 0x404C
    546a:	00 97       	sbiw	r24, 0x00	; 0
    546c:	09 f4       	brne	.+2      	; 0x5470 <writeFile+0x31c>
    546e:	76 c0       	rjmp	.+236    	; 0x555c <writeFile+0x408>
    5470:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5472:	ca 80       	ldd	r12, Y+2	; 0x02
    5474:	db 80       	ldd	r13, Y+3	; 0x03
    5476:	ec 80       	ldd	r14, Y+4	; 0x04
    5478:	fd 80       	ldd	r15, Y+5	; 0x05
    547a:	09 81       	ldd	r16, Y+1	; 0x01
    547c:	c0 0e       	add	r12, r16
    547e:	d1 1c       	adc	r13, r1
    5480:	e1 1c       	adc	r14, r1
    5482:	f1 1c       	adc	r15, r1
    5484:	c7 01       	movw	r24, r14
    5486:	b6 01       	movw	r22, r12
    5488:	a3 01       	movw	r20, r6
    548a:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    548e:	80 91 3d 40 	lds	r24, 0x403D
    5492:	90 91 3e 40 	lds	r25, 0x403E
    5496:	00 97       	sbiw	r24, 0x00	; 0
    5498:	09 f4       	brne	.+2      	; 0x549c <writeFile+0x348>
    549a:	53 c0       	rjmp	.+166    	; 0x5542 <writeFile+0x3ee>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    549c:	a3 01       	movw	r20, r6
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    549e:	bb 20       	and	r11, r11
    54a0:	09 f0       	breq	.+2      	; 0x54a4 <writeFile+0x350>
    54a2:	a0 c0       	rjmp	.+320    	; 0x55e4 <writeFile+0x490>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    54a4:	00 e0       	ldi	r16, 0x00	; 0
    54a6:	10 e0       	ldi	r17, 0x00	; 0
    54a8:	2b 2d       	mov	r18, r11
    54aa:	06 c0       	rjmp	.+12     	; 0x54b8 <writeFile+0x364>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    54ac:	a8 01       	movw	r20, r16
    54ae:	40 54       	subi	r20, 0x40	; 64
    54b0:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    54b2:	22 23       	and	r18, r18
    54b4:	09 f0       	breq	.+2      	; 0x54b8 <writeFile+0x364>
    54b6:	98 c0       	rjmp	.+304    	; 0x55e8 <writeFile+0x494>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    54b8:	da 01       	movw	r26, r20
    54ba:	8c 91       	ld	r24, X
    54bc:	88 23       	and	r24, r24
    54be:	29 f4       	brne	.+10     	; 0x54ca <writeFile+0x376>
    54c0:	e9 2d       	mov	r30, r9
    54c2:	fa 2d       	mov	r31, r10
    54c4:	da 01       	movw	r26, r20
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    54c6:	80 e0       	ldi	r24, 0x00	; 0
    54c8:	03 c0       	rjmp	.+6      	; 0x54d0 <writeFile+0x37c>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    54ca:	85 3e       	cpi	r24, 0xE5	; 229
    54cc:	79 f5       	brne	.+94     	; 0x552c <writeFile+0x3d8>
    54ce:	f8 cf       	rjmp	.-16     	; 0x54c0 <writeFile+0x36c>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = fileName[j];
    54d0:	91 91       	ld	r25, Z+
    54d2:	9d 93       	st	X+, r25
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    54d4:	8f 5f       	subi	r24, 0xFF	; 255
    54d6:	8b 30       	cpi	r24, 0x0B	; 11
    54d8:	d9 f7       	brne	.-10     	; 0x54d0 <writeFile+0x37c>
  			dir->name[j] = fileName[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    54da:	fa 01       	movw	r30, r20
    54dc:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    54de:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    54e0:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    54e2:	12 8a       	std	Z+18, r1	; 0x12
    54e4:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    54e6:	24 8a       	std	Z+20, r2	; 0x14
    54e8:	35 8a       	std	Z+21, r3	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    54ea:	42 8e       	std	Z+26, r4	; 0x1a
    54ec:	53 8e       	std	Z+27, r5	; 0x1b
		  dir->fileSize = fileSize;
    54ee:	80 91 39 40 	lds	r24, 0x4039
    54f2:	90 91 3a 40 	lds	r25, 0x403A
    54f6:	a0 91 3b 40 	lds	r26, 0x403B
    54fa:	b0 91 3c 40 	lds	r27, 0x403C
    54fe:	84 8f       	std	Z+28, r24	; 0x1c
    5500:	95 8f       	std	Z+29, r25	; 0x1d
    5502:	a6 8f       	std	Z+30, r26	; 0x1e
    5504:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    5506:	c7 01       	movw	r24, r14
    5508:	b6 01       	movw	r22, r12
    550a:	a3 01       	movw	r20, r6
    550c:	20 e0       	ldi	r18, 0x00	; 0
    550e:	32 e0       	ldi	r19, 0x02	; 2
    5510:	0e 94 a7 1c 	call	0x394e	; 0x394e <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    5514:	40 91 39 40 	lds	r20, 0x4039
    5518:	50 91 3a 40 	lds	r21, 0x403A
    551c:	60 91 3b 40 	lds	r22, 0x403B
    5520:	70 91 3c 40 	lds	r23, 0x403C
    5524:	81 e0       	ldi	r24, 0x01	; 1
    5526:	0e 94 14 26 	call	0x4c28	; 0x4c28 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    552a:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    552c:	00 5e       	subi	r16, 0xE0	; 224
    552e:	1f 4f       	sbci	r17, 0xFF	; 255
    5530:	80 91 3d 40 	lds	r24, 0x403D
    5534:	90 91 3e 40 	lds	r25, 0x403E
    5538:	08 17       	cp	r16, r24
    553a:	19 07       	cpc	r17, r25
    553c:	08 f4       	brcc	.+2      	; 0x5540 <writeFile+0x3ec>
    553e:	b6 cf       	rjmp	.-148    	; 0x54ac <writeFile+0x358>
    5540:	b2 2e       	mov	r11, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    5542:	09 81       	ldd	r16, Y+1	; 0x01
    5544:	0f 5f       	subi	r16, 0xFF	; 255
    5546:	09 83       	std	Y+1, r16	; 0x01
    5548:	20 91 4b 40 	lds	r18, 0x404B
    554c:	30 91 4c 40 	lds	r19, 0x404C
    5550:	80 2f       	mov	r24, r16
    5552:	90 e0       	ldi	r25, 0x00	; 0
    5554:	82 17       	cp	r24, r18
    5556:	93 07       	cpc	r25, r19
    5558:	08 f4       	brcc	.+2      	; 0x555c <writeFile+0x408>
    555a:	8b cf       	rjmp	.-234    	; 0x5472 <writeFile+0x31e>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    555c:	6e 81       	ldd	r22, Y+6	; 0x06
    555e:	7f 81       	ldd	r23, Y+7	; 0x07
    5560:	88 85       	ldd	r24, Y+8	; 0x08
    5562:	99 85       	ldd	r25, Y+9	; 0x09
    5564:	40 e0       	ldi	r20, 0x00	; 0
    5566:	00 e0       	ldi	r16, 0x00	; 0
    5568:	10 e0       	ldi	r17, 0x00	; 0
    556a:	98 01       	movw	r18, r16
    556c:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
    5570:	6b 01       	movw	r12, r22
    5572:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5574:	67 3f       	cpi	r22, 0xF7	; 247
    5576:	1f ef       	ldi	r17, 0xFF	; 255
    5578:	71 07       	cpc	r23, r17
    557a:	1f ef       	ldi	r17, 0xFF	; 255
    557c:	81 07       	cpc	r24, r17
    557e:	1f e0       	ldi	r17, 0x0F	; 15
    5580:	91 07       	cpc	r25, r17
    5582:	10 f1       	brcs	.+68     	; 0x55c8 <writeFile+0x474>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    5584:	6f 3f       	cpi	r22, 0xFF	; 255
    5586:	2f ef       	ldi	r18, 0xFF	; 255
    5588:	72 07       	cpc	r23, r18
    558a:	2f ef       	ldi	r18, 0xFF	; 255
    558c:	82 07       	cpc	r24, r18
    558e:	2f e0       	ldi	r18, 0x0F	; 15
    5590:	92 07       	cpc	r25, r18
    5592:	61 f5       	brne	.+88     	; 0x55ec <writeFile+0x498>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    5594:	6e 81       	ldd	r22, Y+6	; 0x06
    5596:	7f 81       	ldd	r23, Y+7	; 0x07
    5598:	88 85       	ldd	r24, Y+8	; 0x08
    559a:	99 85       	ldd	r25, Y+9	; 0x09
    559c:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <searchNextFreeCluster>
    55a0:	6b 01       	movw	r12, r22
    55a2:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    55a4:	6e 81       	ldd	r22, Y+6	; 0x06
    55a6:	7f 81       	ldd	r23, Y+7	; 0x07
    55a8:	88 85       	ldd	r24, Y+8	; 0x08
    55aa:	99 85       	ldd	r25, Y+9	; 0x09
    55ac:	41 e0       	ldi	r20, 0x01	; 1
    55ae:	97 01       	movw	r18, r14
    55b0:	86 01       	movw	r16, r12
    55b2:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    55b6:	c7 01       	movw	r24, r14
    55b8:	b6 01       	movw	r22, r12
    55ba:	41 e0       	ldi	r20, 0x01	; 1
    55bc:	0f ef       	ldi	r16, 0xFF	; 255
    55be:	1f ef       	ldi	r17, 0xFF	; 255
    55c0:	2f ef       	ldi	r18, 0xFF	; 255
    55c2:	3f e0       	ldi	r19, 0x0F	; 15
    55c4:	0e 94 cf 22 	call	0x459e	; 0x459e <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    55c8:	c1 14       	cp	r12, r1
    55ca:	d1 04       	cpc	r13, r1
    55cc:	e1 04       	cpc	r14, r1
    55ce:	f1 04       	cpc	r15, r1
    55d0:	09 f0       	breq	.+2      	; 0x55d4 <writeFile+0x480>
    55d2:	39 cf       	rjmp	.-398    	; 0x5446 <writeFile+0x2f2>
	   return 4;
    55d4:	84 e0       	ldi	r24, 0x04	; 4
    55d6:	0b c0       	rjmp	.+22     	; 0x55ee <writeFile+0x49a>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    55d8:	81 e0       	ldi	r24, 0x01	; 1
    55da:	09 c0       	rjmp	.+18     	; 0x55ee <writeFile+0x49a>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    55dc:	82 e0       	ldi	r24, 0x02	; 2
    55de:	07 c0       	rjmp	.+14     	; 0x55ee <writeFile+0x49a>
 
	prevCluster = cluster;
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
	if(cluster == 0){
      //No free cluster!
	  return 2;
    55e0:	82 e0       	ldi	r24, 0x02	; 2
    55e2:	05 c0       	rjmp	.+10     	; 0x55ee <writeFile+0x49a>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    55e4:	80 e0       	ldi	r24, 0x00	; 0
    55e6:	03 c0       	rjmp	.+6      	; 0x55ee <writeFile+0x49a>
    55e8:	80 e0       	ldi	r24, 0x00	; 0
    55ea:	01 c0       	rjmp	.+2      	; 0x55ee <writeFile+0x49a>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    55ec:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    55ee:	29 96       	adiw	r28, 0x09	; 9
    55f0:	cd bf       	out	0x3d, r28	; 61
    55f2:	de bf       	out	0x3e, r29	; 62
    55f4:	df 91       	pop	r29
    55f6:	cf 91       	pop	r28
    55f8:	1f 91       	pop	r17
    55fa:	0f 91       	pop	r16
    55fc:	ff 90       	pop	r15
    55fe:	ef 90       	pop	r14
    5600:	df 90       	pop	r13
    5602:	cf 90       	pop	r12
    5604:	bf 90       	pop	r11
    5606:	af 90       	pop	r10
    5608:	9f 90       	pop	r9
    560a:	8f 90       	pop	r8
    560c:	7f 90       	pop	r7
    560e:	6f 90       	pop	r6
    5610:	5f 90       	pop	r5
    5612:	4f 90       	pop	r4
    5614:	3f 90       	pop	r3
    5616:	2f 90       	pop	r2
    5618:	08 95       	ret

0000561a <main>:

volatile int numOfSamples;

int main(void) {
	
	TestCard();
    561a:	0e 94 72 22 	call	0x44e4	; 0x44e4 <TestCard>
	_delay_ms(1000);
	numOfSamples++;
	//sei();
	*/
	while(1){
		nop();
    561e:	00 00       	nop
    5620:	fe cf       	rjmp	.-4      	; 0x561e <main+0x4>

00005622 <__muldi3>:
    5622:	a0 e3       	ldi	r26, 0x30	; 48
    5624:	b0 e0       	ldi	r27, 0x00	; 0
    5626:	e7 e1       	ldi	r30, 0x17	; 23
    5628:	fb e2       	ldi	r31, 0x2B	; 43
    562a:	0c 94 01 35 	jmp	0x6a02	; 0x6a02 <__prologue_saves__+0x4>
    562e:	29 8f       	std	Y+25, r18	; 0x19
    5630:	3a 8f       	std	Y+26, r19	; 0x1a
    5632:	4b 8f       	std	Y+27, r20	; 0x1b
    5634:	5c 8f       	std	Y+28, r21	; 0x1c
    5636:	6d 8f       	std	Y+29, r22	; 0x1d
    5638:	7e 8f       	std	Y+30, r23	; 0x1e
    563a:	8f 8f       	std	Y+31, r24	; 0x1f
    563c:	98 a3       	lds	r25, 0x58
    563e:	a9 8a       	std	Y+17, r10	; 0x11
    5640:	ba 8a       	std	Y+18, r11	; 0x12
    5642:	cb 8a       	std	Y+19, r12	; 0x13
    5644:	dc 8a       	std	Y+20, r13	; 0x14
    5646:	ed 8a       	std	Y+21, r14	; 0x15
    5648:	fe 8a       	std	Y+22, r15	; 0x16
    564a:	0f 8b       	std	Y+23, r16	; 0x17
    564c:	18 8f       	std	Y+24, r17	; 0x18
    564e:	09 8d       	ldd	r16, Y+25	; 0x19
    5650:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5652:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5654:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5656:	09 a3       	lds	r16, 0x59
    5658:	1a a3       	lds	r17, 0x5a
    565a:	2b a3       	lds	r18, 0x5b
    565c:	3c a3       	lds	r19, 0x5c
    565e:	68 01       	movw	r12, r16
    5660:	79 01       	movw	r14, r18
    5662:	8f ef       	ldi	r24, 0xFF	; 255
    5664:	9f ef       	ldi	r25, 0xFF	; 255
    5666:	a0 e0       	ldi	r26, 0x00	; 0
    5668:	b0 e0       	ldi	r27, 0x00	; 0
    566a:	c8 22       	and	r12, r24
    566c:	d9 22       	and	r13, r25
    566e:	ea 22       	and	r14, r26
    5670:	fb 22       	and	r15, r27
    5672:	89 01       	movw	r16, r18
    5674:	22 27       	eor	r18, r18
    5676:	33 27       	eor	r19, r19
    5678:	09 a7       	lds	r16, 0x79
    567a:	1a a7       	lds	r17, 0x7a
    567c:	2b a7       	lds	r18, 0x7b
    567e:	3c a7       	lds	r19, 0x7c
    5680:	09 89       	ldd	r16, Y+17	; 0x11
    5682:	1a 89       	ldd	r17, Y+18	; 0x12
    5684:	2b 89       	ldd	r18, Y+19	; 0x13
    5686:	3c 89       	ldd	r19, Y+20	; 0x14
    5688:	0d a3       	lds	r16, 0x5d
    568a:	1e a3       	lds	r17, 0x5e
    568c:	2f a3       	lds	r18, 0x5f
    568e:	38 a7       	lds	r19, 0x78
    5690:	48 01       	movw	r8, r16
    5692:	59 01       	movw	r10, r18
    5694:	88 22       	and	r8, r24
    5696:	99 22       	and	r9, r25
    5698:	aa 22       	and	r10, r26
    569a:	bb 22       	and	r11, r27
    569c:	29 01       	movw	r4, r18
    569e:	66 24       	eor	r6, r6
    56a0:	77 24       	eor	r7, r7
    56a2:	c5 01       	movw	r24, r10
    56a4:	b4 01       	movw	r22, r8
    56a6:	a7 01       	movw	r20, r14
    56a8:	96 01       	movw	r18, r12
    56aa:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    56ae:	6d a7       	lds	r22, 0x7d
    56b0:	7e a7       	lds	r23, 0x7e
    56b2:	8f a7       	lds	r24, 0x7f
    56b4:	98 ab       	sts	0x58, r25
    56b6:	c3 01       	movw	r24, r6
    56b8:	b2 01       	movw	r22, r4
    56ba:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    56be:	6b 01       	movw	r12, r22
    56c0:	7c 01       	movw	r14, r24
    56c2:	c5 01       	movw	r24, r10
    56c4:	b4 01       	movw	r22, r8
    56c6:	29 a5       	lds	r18, 0x69
    56c8:	3a a5       	lds	r19, 0x6a
    56ca:	4b a5       	lds	r20, 0x6b
    56cc:	5c a5       	lds	r21, 0x6c
    56ce:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    56d2:	4b 01       	movw	r8, r22
    56d4:	5c 01       	movw	r10, r24
    56d6:	c3 01       	movw	r24, r6
    56d8:	b2 01       	movw	r22, r4
    56da:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    56de:	ab 01       	movw	r20, r22
    56e0:	bc 01       	movw	r22, r24
    56e2:	c8 0c       	add	r12, r8
    56e4:	d9 1c       	adc	r13, r9
    56e6:	ea 1c       	adc	r14, r10
    56e8:	fb 1c       	adc	r15, r11
    56ea:	0d a5       	lds	r16, 0x6d
    56ec:	1e a5       	lds	r17, 0x6e
    56ee:	2f a5       	lds	r18, 0x6f
    56f0:	38 a9       	sts	0x48, r19
    56f2:	c9 01       	movw	r24, r18
    56f4:	aa 27       	eor	r26, r26
    56f6:	bb 27       	eor	r27, r27
    56f8:	c8 0e       	add	r12, r24
    56fa:	d9 1e       	adc	r13, r25
    56fc:	ea 1e       	adc	r14, r26
    56fe:	fb 1e       	adc	r15, r27
    5700:	c8 14       	cp	r12, r8
    5702:	d9 04       	cpc	r13, r9
    5704:	ea 04       	cpc	r14, r10
    5706:	fb 04       	cpc	r15, r11
    5708:	20 f4       	brcc	.+8      	; 0x5712 <__muldi3+0xf0>
    570a:	40 50       	subi	r20, 0x00	; 0
    570c:	50 40       	sbci	r21, 0x00	; 0
    570e:	6f 4f       	sbci	r22, 0xFF	; 255
    5710:	7f 4f       	sbci	r23, 0xFF	; 255
    5712:	c7 01       	movw	r24, r14
    5714:	aa 27       	eor	r26, r26
    5716:	bb 27       	eor	r27, r27
    5718:	84 0f       	add	r24, r20
    571a:	95 1f       	adc	r25, r21
    571c:	a6 1f       	adc	r26, r22
    571e:	b7 1f       	adc	r27, r23
    5720:	8d 83       	std	Y+5, r24	; 0x05
    5722:	9e 83       	std	Y+6, r25	; 0x06
    5724:	af 83       	std	Y+7, r26	; 0x07
    5726:	b8 87       	std	Y+8, r27	; 0x08
    5728:	76 01       	movw	r14, r12
    572a:	dd 24       	eor	r13, r13
    572c:	cc 24       	eor	r12, r12
    572e:	4d a5       	lds	r20, 0x6d
    5730:	5e a5       	lds	r21, 0x6e
    5732:	6f a5       	lds	r22, 0x6f
    5734:	78 a9       	sts	0x48, r23
    5736:	60 70       	andi	r22, 0x00	; 0
    5738:	70 70       	andi	r23, 0x00	; 0
    573a:	c4 0e       	add	r12, r20
    573c:	d5 1e       	adc	r13, r21
    573e:	e6 1e       	adc	r14, r22
    5740:	f7 1e       	adc	r15, r23
    5742:	c9 82       	std	Y+1, r12	; 0x01
    5744:	da 82       	std	Y+2, r13	; 0x02
    5746:	eb 82       	std	Y+3, r14	; 0x03
    5748:	fc 82       	std	Y+4, r15	; 0x04
    574a:	1c 2d       	mov	r17, r12
    574c:	0a 81       	ldd	r16, Y+2	; 0x02
    574e:	8b 80       	ldd	r8, Y+3	; 0x03
    5750:	4c 80       	ldd	r4, Y+4	; 0x04
    5752:	8d 87       	std	Y+13, r24	; 0x0d
    5754:	8e 81       	ldd	r24, Y+6	; 0x06
    5756:	8e 87       	std	Y+14, r24	; 0x0e
    5758:	8f 81       	ldd	r24, Y+7	; 0x07
    575a:	8f 87       	std	Y+15, r24	; 0x0f
    575c:	88 85       	ldd	r24, Y+8	; 0x08
    575e:	88 8b       	std	Y+16, r24	; 0x10
    5760:	2d 89       	ldd	r18, Y+21	; 0x15
    5762:	3e 89       	ldd	r19, Y+22	; 0x16
    5764:	4f 89       	ldd	r20, Y+23	; 0x17
    5766:	58 8d       	ldd	r21, Y+24	; 0x18
    5768:	69 a1       	lds	r22, 0x49
    576a:	7a a1       	lds	r23, 0x4a
    576c:	8b a1       	lds	r24, 0x4b
    576e:	9c a1       	lds	r25, 0x4c
    5770:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    5774:	6b 01       	movw	r12, r22
    5776:	7c 01       	movw	r14, r24
    5778:	2d 8d       	ldd	r18, Y+29	; 0x1d
    577a:	3e 8d       	ldd	r19, Y+30	; 0x1e
    577c:	4f 8d       	ldd	r20, Y+31	; 0x1f
    577e:	58 a1       	lds	r21, 0x48
    5780:	6d a1       	lds	r22, 0x4d
    5782:	7e a1       	lds	r23, 0x4e
    5784:	8f a1       	lds	r24, 0x4f
    5786:	98 a5       	lds	r25, 0x68
    5788:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    578c:	dc 01       	movw	r26, r24
    578e:	cb 01       	movw	r24, r22
    5790:	c8 0e       	add	r12, r24
    5792:	d9 1e       	adc	r13, r25
    5794:	ea 1e       	adc	r14, r26
    5796:	fb 1e       	adc	r15, r27
    5798:	8d 85       	ldd	r24, Y+13	; 0x0d
    579a:	9e 85       	ldd	r25, Y+14	; 0x0e
    579c:	af 85       	ldd	r26, Y+15	; 0x0f
    579e:	b8 89       	ldd	r27, Y+16	; 0x10
    57a0:	8c 0d       	add	r24, r12
    57a2:	9d 1d       	adc	r25, r13
    57a4:	ae 1d       	adc	r26, r14
    57a6:	bf 1d       	adc	r27, r15
    57a8:	8d 87       	std	Y+13, r24	; 0x0d
    57aa:	9e 87       	std	Y+14, r25	; 0x0e
    57ac:	af 87       	std	Y+15, r26	; 0x0f
    57ae:	b8 8b       	std	Y+16, r27	; 0x10
    57b0:	68 2f       	mov	r22, r24
    57b2:	7e 85       	ldd	r23, Y+14	; 0x0e
    57b4:	21 2f       	mov	r18, r17
    57b6:	30 2f       	mov	r19, r16
    57b8:	48 2d       	mov	r20, r8
    57ba:	54 2d       	mov	r21, r4
    57bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    57be:	98 89       	ldd	r25, Y+16	; 0x10
    57c0:	e0 96       	adiw	r28, 0x30	; 48
    57c2:	e0 e1       	ldi	r30, 0x10	; 16
    57c4:	0c 94 1a 35 	jmp	0x6a34	; 0x6a34 <__epilogue_restores__+0x4>

000057c8 <__ashldi3>:
    57c8:	cf 92       	push	r12
    57ca:	df 92       	push	r13
    57cc:	ef 92       	push	r14
    57ce:	ff 92       	push	r15
    57d0:	0f 93       	push	r16
    57d2:	cf 93       	push	r28
    57d4:	df 93       	push	r29
    57d6:	cd b7       	in	r28, 0x3d	; 61
    57d8:	de b7       	in	r29, 0x3e	; 62
    57da:	60 97       	sbiw	r28, 0x10	; 16
    57dc:	cd bf       	out	0x3d, r28	; 61
    57de:	de bf       	out	0x3e, r29	; 62
    57e0:	00 23       	and	r16, r16
    57e2:	09 f4       	brne	.+2      	; 0x57e6 <__ashldi3+0x1e>
    57e4:	5a c0       	rjmp	.+180    	; 0x589a <__ashldi3+0xd2>
    57e6:	29 87       	std	Y+9, r18	; 0x09
    57e8:	3a 87       	std	Y+10, r19	; 0x0a
    57ea:	4b 87       	std	Y+11, r20	; 0x0b
    57ec:	5c 87       	std	Y+12, r21	; 0x0c
    57ee:	6d 87       	std	Y+13, r22	; 0x0d
    57f0:	7e 87       	std	Y+14, r23	; 0x0e
    57f2:	8f 87       	std	Y+15, r24	; 0x0f
    57f4:	98 8b       	std	Y+16, r25	; 0x10
    57f6:	80 e2       	ldi	r24, 0x20	; 32
    57f8:	80 1b       	sub	r24, r16
    57fa:	49 85       	ldd	r20, Y+9	; 0x09
    57fc:	5a 85       	ldd	r21, Y+10	; 0x0a
    57fe:	6b 85       	ldd	r22, Y+11	; 0x0b
    5800:	7c 85       	ldd	r23, Y+12	; 0x0c
    5802:	18 16       	cp	r1, r24
    5804:	b4 f0       	brlt	.+44     	; 0x5832 <__ashldi3+0x6a>
    5806:	19 82       	std	Y+1, r1	; 0x01
    5808:	1a 82       	std	Y+2, r1	; 0x02
    580a:	1b 82       	std	Y+3, r1	; 0x03
    580c:	1c 82       	std	Y+4, r1	; 0x04
    580e:	99 27       	eor	r25, r25
    5810:	87 fd       	sbrc	r24, 7
    5812:	90 95       	com	r25
    5814:	90 95       	com	r25
    5816:	81 95       	neg	r24
    5818:	9f 4f       	sbci	r25, 0xFF	; 255
    581a:	04 c0       	rjmp	.+8      	; 0x5824 <__ashldi3+0x5c>
    581c:	44 0f       	add	r20, r20
    581e:	55 1f       	adc	r21, r21
    5820:	66 1f       	adc	r22, r22
    5822:	77 1f       	adc	r23, r23
    5824:	8a 95       	dec	r24
    5826:	d2 f7       	brpl	.-12     	; 0x581c <__ashldi3+0x54>
    5828:	4d 83       	std	Y+5, r20	; 0x05
    582a:	5e 83       	std	Y+6, r21	; 0x06
    582c:	6f 83       	std	Y+7, r22	; 0x07
    582e:	78 87       	std	Y+8, r23	; 0x08
    5830:	2c c0       	rjmp	.+88     	; 0x588a <__ashldi3+0xc2>
    5832:	6a 01       	movw	r12, r20
    5834:	7b 01       	movw	r14, r22
    5836:	00 2e       	mov	r0, r16
    5838:	04 c0       	rjmp	.+8      	; 0x5842 <__ashldi3+0x7a>
    583a:	cc 0c       	add	r12, r12
    583c:	dd 1c       	adc	r13, r13
    583e:	ee 1c       	adc	r14, r14
    5840:	ff 1c       	adc	r15, r15
    5842:	0a 94       	dec	r0
    5844:	d2 f7       	brpl	.-12     	; 0x583a <__ashldi3+0x72>
    5846:	c9 82       	std	Y+1, r12	; 0x01
    5848:	da 82       	std	Y+2, r13	; 0x02
    584a:	eb 82       	std	Y+3, r14	; 0x03
    584c:	fc 82       	std	Y+4, r15	; 0x04
    584e:	6a 01       	movw	r12, r20
    5850:	7b 01       	movw	r14, r22
    5852:	04 c0       	rjmp	.+8      	; 0x585c <__ashldi3+0x94>
    5854:	f6 94       	lsr	r15
    5856:	e7 94       	ror	r14
    5858:	d7 94       	ror	r13
    585a:	c7 94       	ror	r12
    585c:	8a 95       	dec	r24
    585e:	d2 f7       	brpl	.-12     	; 0x5854 <__ashldi3+0x8c>
    5860:	d7 01       	movw	r26, r14
    5862:	c6 01       	movw	r24, r12
    5864:	4d 85       	ldd	r20, Y+13	; 0x0d
    5866:	5e 85       	ldd	r21, Y+14	; 0x0e
    5868:	6f 85       	ldd	r22, Y+15	; 0x0f
    586a:	78 89       	ldd	r23, Y+16	; 0x10
    586c:	04 c0       	rjmp	.+8      	; 0x5876 <__ashldi3+0xae>
    586e:	44 0f       	add	r20, r20
    5870:	55 1f       	adc	r21, r21
    5872:	66 1f       	adc	r22, r22
    5874:	77 1f       	adc	r23, r23
    5876:	0a 95       	dec	r16
    5878:	d2 f7       	brpl	.-12     	; 0x586e <__ashldi3+0xa6>
    587a:	84 2b       	or	r24, r20
    587c:	95 2b       	or	r25, r21
    587e:	a6 2b       	or	r26, r22
    5880:	b7 2b       	or	r27, r23
    5882:	8d 83       	std	Y+5, r24	; 0x05
    5884:	9e 83       	std	Y+6, r25	; 0x06
    5886:	af 83       	std	Y+7, r26	; 0x07
    5888:	b8 87       	std	Y+8, r27	; 0x08
    588a:	29 81       	ldd	r18, Y+1	; 0x01
    588c:	3a 81       	ldd	r19, Y+2	; 0x02
    588e:	4b 81       	ldd	r20, Y+3	; 0x03
    5890:	5c 81       	ldd	r21, Y+4	; 0x04
    5892:	6d 81       	ldd	r22, Y+5	; 0x05
    5894:	7e 81       	ldd	r23, Y+6	; 0x06
    5896:	8f 81       	ldd	r24, Y+7	; 0x07
    5898:	98 85       	ldd	r25, Y+8	; 0x08
    589a:	60 96       	adiw	r28, 0x10	; 16
    589c:	cd bf       	out	0x3d, r28	; 61
    589e:	de bf       	out	0x3e, r29	; 62
    58a0:	df 91       	pop	r29
    58a2:	cf 91       	pop	r28
    58a4:	0f 91       	pop	r16
    58a6:	ff 90       	pop	r15
    58a8:	ef 90       	pop	r14
    58aa:	df 90       	pop	r13
    58ac:	cf 90       	pop	r12
    58ae:	08 95       	ret

000058b0 <__ashrdi3>:
    58b0:	0f 93       	push	r16
    58b2:	cf 93       	push	r28
    58b4:	df 93       	push	r29
    58b6:	cd b7       	in	r28, 0x3d	; 61
    58b8:	de b7       	in	r29, 0x3e	; 62
    58ba:	60 97       	sbiw	r28, 0x10	; 16
    58bc:	cd bf       	out	0x3d, r28	; 61
    58be:	de bf       	out	0x3e, r29	; 62
    58c0:	00 23       	and	r16, r16
    58c2:	09 f4       	brne	.+2      	; 0x58c6 <__ashrdi3+0x16>
    58c4:	56 c0       	rjmp	.+172    	; 0x5972 <__ashrdi3+0xc2>
    58c6:	29 87       	std	Y+9, r18	; 0x09
    58c8:	3a 87       	std	Y+10, r19	; 0x0a
    58ca:	4b 87       	std	Y+11, r20	; 0x0b
    58cc:	5c 87       	std	Y+12, r21	; 0x0c
    58ce:	6d 87       	std	Y+13, r22	; 0x0d
    58d0:	7e 87       	std	Y+14, r23	; 0x0e
    58d2:	8f 87       	std	Y+15, r24	; 0x0f
    58d4:	98 8b       	std	Y+16, r25	; 0x10
    58d6:	20 e2       	ldi	r18, 0x20	; 32
    58d8:	20 1b       	sub	r18, r16
    58da:	8d 85       	ldd	r24, Y+13	; 0x0d
    58dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    58de:	af 85       	ldd	r26, Y+15	; 0x0f
    58e0:	b8 89       	ldd	r27, Y+16	; 0x10
    58e2:	ac 01       	movw	r20, r24
    58e4:	bd 01       	movw	r22, r26
    58e6:	12 16       	cp	r1, r18
    58e8:	b4 f0       	brlt	.+44     	; 0x5916 <__ashrdi3+0x66>
    58ea:	77 0f       	add	r23, r23
    58ec:	44 0b       	sbc	r20, r20
    58ee:	54 2f       	mov	r21, r20
    58f0:	ba 01       	movw	r22, r20
    58f2:	4d 83       	std	Y+5, r20	; 0x05
    58f4:	5e 83       	std	Y+6, r21	; 0x06
    58f6:	6f 83       	std	Y+7, r22	; 0x07
    58f8:	78 87       	std	Y+8, r23	; 0x08
    58fa:	33 27       	eor	r19, r19
    58fc:	27 fd       	sbrc	r18, 7
    58fe:	30 95       	com	r19
    5900:	30 95       	com	r19
    5902:	21 95       	neg	r18
    5904:	3f 4f       	sbci	r19, 0xFF	; 255
    5906:	04 c0       	rjmp	.+8      	; 0x5910 <__ashrdi3+0x60>
    5908:	b5 95       	asr	r27
    590a:	a7 95       	ror	r26
    590c:	97 95       	ror	r25
    590e:	87 95       	ror	r24
    5910:	2a 95       	dec	r18
    5912:	d2 f7       	brpl	.-12     	; 0x5908 <__ashrdi3+0x58>
    5914:	22 c0       	rjmp	.+68     	; 0x595a <__ashrdi3+0xaa>
    5916:	00 2e       	mov	r0, r16
    5918:	04 c0       	rjmp	.+8      	; 0x5922 <__ashrdi3+0x72>
    591a:	75 95       	asr	r23
    591c:	67 95       	ror	r22
    591e:	57 95       	ror	r21
    5920:	47 95       	ror	r20
    5922:	0a 94       	dec	r0
    5924:	d2 f7       	brpl	.-12     	; 0x591a <__ashrdi3+0x6a>
    5926:	4d 83       	std	Y+5, r20	; 0x05
    5928:	5e 83       	std	Y+6, r21	; 0x06
    592a:	6f 83       	std	Y+7, r22	; 0x07
    592c:	78 87       	std	Y+8, r23	; 0x08
    592e:	04 c0       	rjmp	.+8      	; 0x5938 <__ashrdi3+0x88>
    5930:	88 0f       	add	r24, r24
    5932:	99 1f       	adc	r25, r25
    5934:	aa 1f       	adc	r26, r26
    5936:	bb 1f       	adc	r27, r27
    5938:	2a 95       	dec	r18
    593a:	d2 f7       	brpl	.-12     	; 0x5930 <__ashrdi3+0x80>
    593c:	49 85       	ldd	r20, Y+9	; 0x09
    593e:	5a 85       	ldd	r21, Y+10	; 0x0a
    5940:	6b 85       	ldd	r22, Y+11	; 0x0b
    5942:	7c 85       	ldd	r23, Y+12	; 0x0c
    5944:	04 c0       	rjmp	.+8      	; 0x594e <__ashrdi3+0x9e>
    5946:	76 95       	lsr	r23
    5948:	67 95       	ror	r22
    594a:	57 95       	ror	r21
    594c:	47 95       	ror	r20
    594e:	0a 95       	dec	r16
    5950:	d2 f7       	brpl	.-12     	; 0x5946 <__ashrdi3+0x96>
    5952:	84 2b       	or	r24, r20
    5954:	95 2b       	or	r25, r21
    5956:	a6 2b       	or	r26, r22
    5958:	b7 2b       	or	r27, r23
    595a:	89 83       	std	Y+1, r24	; 0x01
    595c:	9a 83       	std	Y+2, r25	; 0x02
    595e:	ab 83       	std	Y+3, r26	; 0x03
    5960:	bc 83       	std	Y+4, r27	; 0x04
    5962:	29 81       	ldd	r18, Y+1	; 0x01
    5964:	3a 81       	ldd	r19, Y+2	; 0x02
    5966:	4b 81       	ldd	r20, Y+3	; 0x03
    5968:	5c 81       	ldd	r21, Y+4	; 0x04
    596a:	6d 81       	ldd	r22, Y+5	; 0x05
    596c:	7e 81       	ldd	r23, Y+6	; 0x06
    596e:	8f 81       	ldd	r24, Y+7	; 0x07
    5970:	98 85       	ldd	r25, Y+8	; 0x08
    5972:	60 96       	adiw	r28, 0x10	; 16
    5974:	cd bf       	out	0x3d, r28	; 61
    5976:	de bf       	out	0x3e, r29	; 62
    5978:	df 91       	pop	r29
    597a:	cf 91       	pop	r28
    597c:	0f 91       	pop	r16
    597e:	08 95       	ret

00005980 <__divdi3>:
    5980:	a8 e4       	ldi	r26, 0x48	; 72
    5982:	b0 e0       	ldi	r27, 0x00	; 0
    5984:	e6 ec       	ldi	r30, 0xC6	; 198
    5986:	fc e2       	ldi	r31, 0x2C	; 44
    5988:	0c 94 00 35 	jmp	0x6a00	; 0x6a00 <__prologue_saves__+0x2>
    598c:	f5 01       	movw	r30, r10
    598e:	29 a3       	lds	r18, 0x59
    5990:	3a a3       	lds	r19, 0x5a
    5992:	4b a3       	lds	r20, 0x5b
    5994:	5c a3       	lds	r21, 0x5c
    5996:	6d a3       	lds	r22, 0x5d
    5998:	7e a3       	lds	r23, 0x5e
    599a:	8f a3       	lds	r24, 0x5f
    599c:	98 a7       	lds	r25, 0x78
    599e:	a9 8e       	std	Y+25, r10	; 0x19
    59a0:	fa 8f       	std	Y+26, r31	; 0x1a
    59a2:	cb 8e       	std	Y+27, r12	; 0x1b
    59a4:	dc 8e       	std	Y+28, r13	; 0x1c
    59a6:	ed 8e       	std	Y+29, r14	; 0x1d
    59a8:	fe 8e       	std	Y+30, r15	; 0x1e
    59aa:	0f 8f       	std	Y+31, r16	; 0x1f
    59ac:	18 a3       	lds	r17, 0x58
    59ae:	8d a0       	lds	r24, 0x8d
    59b0:	9e a0       	lds	r25, 0x8e
    59b2:	af a0       	lds	r26, 0x8f
    59b4:	b8 a4       	lds	r27, 0xa8
    59b6:	b7 fe       	sbrs	r11, 7
    59b8:	67 c0       	rjmp	.+206    	; 0x5a88 <__divdi3+0x108>
    59ba:	21 95       	neg	r18
    59bc:	b1 e0       	ldi	r27, 0x01	; 1
    59be:	12 16       	cp	r1, r18
    59c0:	08 f0       	brcs	.+2      	; 0x59c4 <__divdi3+0x44>
    59c2:	b0 e0       	ldi	r27, 0x00	; 0
    59c4:	31 95       	neg	r19
    59c6:	a1 e0       	ldi	r26, 0x01	; 1
    59c8:	13 16       	cp	r1, r19
    59ca:	08 f0       	brcs	.+2      	; 0x59ce <__divdi3+0x4e>
    59cc:	a0 e0       	ldi	r26, 0x00	; 0
    59ce:	b3 2e       	mov	r11, r19
    59d0:	bb 1a       	sub	r11, r27
    59d2:	bb 2d       	mov	r27, r11
    59d4:	88 24       	eor	r8, r8
    59d6:	83 94       	inc	r8
    59d8:	3b 15       	cp	r19, r11
    59da:	08 f0       	brcs	.+2      	; 0x59de <__divdi3+0x5e>
    59dc:	88 24       	eor	r8, r8
    59de:	a8 29       	or	r26, r8
    59e0:	41 95       	neg	r20
    59e2:	31 e0       	ldi	r19, 0x01	; 1
    59e4:	14 16       	cp	r1, r20
    59e6:	08 f0       	brcs	.+2      	; 0x59ea <__divdi3+0x6a>
    59e8:	30 e0       	ldi	r19, 0x00	; 0
    59ea:	b4 2e       	mov	r11, r20
    59ec:	ba 1a       	sub	r11, r26
    59ee:	ab 2d       	mov	r26, r11
    59f0:	88 24       	eor	r8, r8
    59f2:	83 94       	inc	r8
    59f4:	4b 15       	cp	r20, r11
    59f6:	08 f0       	brcs	.+2      	; 0x59fa <__divdi3+0x7a>
    59f8:	88 24       	eor	r8, r8
    59fa:	38 29       	or	r19, r8
    59fc:	51 95       	neg	r21
    59fe:	41 e0       	ldi	r20, 0x01	; 1
    5a00:	15 16       	cp	r1, r21
    5a02:	08 f0       	brcs	.+2      	; 0x5a06 <__divdi3+0x86>
    5a04:	40 e0       	ldi	r20, 0x00	; 0
    5a06:	45 2e       	mov	r4, r21
    5a08:	43 1a       	sub	r4, r19
    5a0a:	31 e0       	ldi	r19, 0x01	; 1
    5a0c:	54 15       	cp	r21, r4
    5a0e:	08 f0       	brcs	.+2      	; 0x5a12 <__divdi3+0x92>
    5a10:	30 e0       	ldi	r19, 0x00	; 0
    5a12:	43 2b       	or	r20, r19
    5a14:	61 95       	neg	r22
    5a16:	31 e0       	ldi	r19, 0x01	; 1
    5a18:	16 16       	cp	r1, r22
    5a1a:	08 f0       	brcs	.+2      	; 0x5a1e <__divdi3+0x9e>
    5a1c:	30 e0       	ldi	r19, 0x00	; 0
    5a1e:	86 2e       	mov	r8, r22
    5a20:	84 1a       	sub	r8, r20
    5a22:	41 e0       	ldi	r20, 0x01	; 1
    5a24:	68 15       	cp	r22, r8
    5a26:	08 f0       	brcs	.+2      	; 0x5a2a <__divdi3+0xaa>
    5a28:	40 e0       	ldi	r20, 0x00	; 0
    5a2a:	34 2b       	or	r19, r20
    5a2c:	71 95       	neg	r23
    5a2e:	41 e0       	ldi	r20, 0x01	; 1
    5a30:	17 16       	cp	r1, r23
    5a32:	08 f0       	brcs	.+2      	; 0x5a36 <__divdi3+0xb6>
    5a34:	40 e0       	ldi	r20, 0x00	; 0
    5a36:	57 2f       	mov	r21, r23
    5a38:	53 1b       	sub	r21, r19
    5a3a:	31 e0       	ldi	r19, 0x01	; 1
    5a3c:	75 17       	cp	r23, r21
    5a3e:	08 f0       	brcs	.+2      	; 0x5a42 <__divdi3+0xc2>
    5a40:	30 e0       	ldi	r19, 0x00	; 0
    5a42:	43 2b       	or	r20, r19
    5a44:	81 95       	neg	r24
    5a46:	31 e0       	ldi	r19, 0x01	; 1
    5a48:	18 16       	cp	r1, r24
    5a4a:	08 f0       	brcs	.+2      	; 0x5a4e <__divdi3+0xce>
    5a4c:	30 e0       	ldi	r19, 0x00	; 0
    5a4e:	68 2f       	mov	r22, r24
    5a50:	64 1b       	sub	r22, r20
    5a52:	46 2f       	mov	r20, r22
    5a54:	61 e0       	ldi	r22, 0x01	; 1
    5a56:	84 17       	cp	r24, r20
    5a58:	08 f0       	brcs	.+2      	; 0x5a5c <__divdi3+0xdc>
    5a5a:	60 e0       	ldi	r22, 0x00	; 0
    5a5c:	36 2b       	or	r19, r22
    5a5e:	91 95       	neg	r25
    5a60:	93 1b       	sub	r25, r19
    5a62:	29 a3       	lds	r18, 0x59
    5a64:	ba a3       	lds	r27, 0x5a
    5a66:	ab a3       	lds	r26, 0x5b
    5a68:	4c a2       	lds	r20, 0x9c
    5a6a:	8d a2       	lds	r24, 0x9d
    5a6c:	5e a3       	lds	r21, 0x5e
    5a6e:	4f a3       	lds	r20, 0x5f
    5a70:	98 a7       	lds	r25, 0x78
    5a72:	8f ef       	ldi	r24, 0xFF	; 255
    5a74:	9f ef       	ldi	r25, 0xFF	; 255
    5a76:	af ef       	ldi	r26, 0xFF	; 255
    5a78:	bf ef       	ldi	r27, 0xFF	; 255
    5a7a:	25 96       	adiw	r28, 0x05	; 5
    5a7c:	8c af       	sts	0x7c, r24
    5a7e:	9d af       	sts	0x7d, r25
    5a80:	ae af       	sts	0x7e, r26
    5a82:	bf af       	sts	0x7f, r27
    5a84:	25 97       	sbiw	r28, 0x05	; 5
    5a86:	06 c0       	rjmp	.+12     	; 0x5a94 <__divdi3+0x114>
    5a88:	25 96       	adiw	r28, 0x05	; 5
    5a8a:	1c ae       	sts	0xbc, r17
    5a8c:	1d ae       	sts	0xbd, r17
    5a8e:	1e ae       	sts	0xbe, r17
    5a90:	1f ae       	sts	0xbf, r17
    5a92:	25 97       	sbiw	r28, 0x05	; 5
    5a94:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5a96:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5a98:	af 8d       	ldd	r26, Y+31	; 0x1f
    5a9a:	b8 a1       	lds	r27, 0x48
    5a9c:	b7 ff       	sbrs	r27, 7
    5a9e:	68 c0       	rjmp	.+208    	; 0x5b70 <__divdi3+0x1f0>
    5aa0:	25 96       	adiw	r28, 0x05	; 5
    5aa2:	2c ad       	sts	0x6c, r18
    5aa4:	3d ad       	sts	0x6d, r19
    5aa6:	4e ad       	sts	0x6e, r20
    5aa8:	5f ad       	sts	0x6f, r21
    5aaa:	25 97       	sbiw	r28, 0x05	; 5
    5aac:	20 95       	com	r18
    5aae:	30 95       	com	r19
    5ab0:	40 95       	com	r20
    5ab2:	50 95       	com	r21
    5ab4:	25 96       	adiw	r28, 0x05	; 5
    5ab6:	2c af       	sts	0x7c, r18
    5ab8:	3d af       	sts	0x7d, r19
    5aba:	4e af       	sts	0x7e, r20
    5abc:	5f af       	sts	0x7f, r21
    5abe:	25 97       	sbiw	r28, 0x05	; 5
    5ac0:	e1 95       	neg	r30
    5ac2:	81 e0       	ldi	r24, 0x01	; 1
    5ac4:	1e 16       	cp	r1, r30
    5ac6:	08 f0       	brcs	.+2      	; 0x5aca <__divdi3+0x14a>
    5ac8:	80 e0       	ldi	r24, 0x00	; 0
    5aca:	f1 95       	neg	r31
    5acc:	91 e0       	ldi	r25, 0x01	; 1
    5ace:	1f 16       	cp	r1, r31
    5ad0:	08 f0       	brcs	.+2      	; 0x5ad4 <__divdi3+0x154>
    5ad2:	90 e0       	ldi	r25, 0x00	; 0
    5ad4:	4f 2f       	mov	r20, r31
    5ad6:	48 1b       	sub	r20, r24
    5ad8:	81 e0       	ldi	r24, 0x01	; 1
    5ada:	f4 17       	cp	r31, r20
    5adc:	08 f0       	brcs	.+2      	; 0x5ae0 <__divdi3+0x160>
    5ade:	80 e0       	ldi	r24, 0x00	; 0
    5ae0:	98 2b       	or	r25, r24
    5ae2:	c1 94       	neg	r12
    5ae4:	81 e0       	ldi	r24, 0x01	; 1
    5ae6:	1c 14       	cp	r1, r12
    5ae8:	08 f0       	brcs	.+2      	; 0x5aec <__divdi3+0x16c>
    5aea:	80 e0       	ldi	r24, 0x00	; 0
    5aec:	6c 2d       	mov	r22, r12
    5aee:	69 1b       	sub	r22, r25
    5af0:	91 e0       	ldi	r25, 0x01	; 1
    5af2:	c6 16       	cp	r12, r22
    5af4:	08 f0       	brcs	.+2      	; 0x5af8 <__divdi3+0x178>
    5af6:	90 e0       	ldi	r25, 0x00	; 0
    5af8:	89 2b       	or	r24, r25
    5afa:	d1 94       	neg	r13
    5afc:	91 e0       	ldi	r25, 0x01	; 1
    5afe:	1d 14       	cp	r1, r13
    5b00:	08 f0       	brcs	.+2      	; 0x5b04 <__divdi3+0x184>
    5b02:	90 e0       	ldi	r25, 0x00	; 0
    5b04:	5d 2d       	mov	r21, r13
    5b06:	58 1b       	sub	r21, r24
    5b08:	81 e0       	ldi	r24, 0x01	; 1
    5b0a:	d5 16       	cp	r13, r21
    5b0c:	08 f0       	brcs	.+2      	; 0x5b10 <__divdi3+0x190>
    5b0e:	80 e0       	ldi	r24, 0x00	; 0
    5b10:	98 2b       	or	r25, r24
    5b12:	e1 94       	neg	r14
    5b14:	81 e0       	ldi	r24, 0x01	; 1
    5b16:	1e 14       	cp	r1, r14
    5b18:	08 f0       	brcs	.+2      	; 0x5b1c <__divdi3+0x19c>
    5b1a:	80 e0       	ldi	r24, 0x00	; 0
    5b1c:	3e 2d       	mov	r19, r14
    5b1e:	39 1b       	sub	r19, r25
    5b20:	91 e0       	ldi	r25, 0x01	; 1
    5b22:	e3 16       	cp	r14, r19
    5b24:	08 f0       	brcs	.+2      	; 0x5b28 <__divdi3+0x1a8>
    5b26:	90 e0       	ldi	r25, 0x00	; 0
    5b28:	89 2b       	or	r24, r25
    5b2a:	f1 94       	neg	r15
    5b2c:	91 e0       	ldi	r25, 0x01	; 1
    5b2e:	1f 14       	cp	r1, r15
    5b30:	08 f0       	brcs	.+2      	; 0x5b34 <__divdi3+0x1b4>
    5b32:	90 e0       	ldi	r25, 0x00	; 0
    5b34:	2f 2d       	mov	r18, r15
    5b36:	28 1b       	sub	r18, r24
    5b38:	81 e0       	ldi	r24, 0x01	; 1
    5b3a:	f2 16       	cp	r15, r18
    5b3c:	08 f0       	brcs	.+2      	; 0x5b40 <__divdi3+0x1c0>
    5b3e:	80 e0       	ldi	r24, 0x00	; 0
    5b40:	98 2b       	or	r25, r24
    5b42:	01 95       	neg	r16
    5b44:	81 e0       	ldi	r24, 0x01	; 1
    5b46:	10 16       	cp	r1, r16
    5b48:	08 f0       	brcs	.+2      	; 0x5b4c <__divdi3+0x1cc>
    5b4a:	80 e0       	ldi	r24, 0x00	; 0
    5b4c:	70 2f       	mov	r23, r16
    5b4e:	79 1b       	sub	r23, r25
    5b50:	97 2f       	mov	r25, r23
    5b52:	71 e0       	ldi	r23, 0x01	; 1
    5b54:	09 17       	cp	r16, r25
    5b56:	08 f0       	brcs	.+2      	; 0x5b5a <__divdi3+0x1da>
    5b58:	70 e0       	ldi	r23, 0x00	; 0
    5b5a:	87 2b       	or	r24, r23
    5b5c:	11 95       	neg	r17
    5b5e:	18 1b       	sub	r17, r24
    5b60:	e9 8f       	std	Y+25, r30	; 0x19
    5b62:	4a 8f       	std	Y+26, r20	; 0x1a
    5b64:	6b 8f       	std	Y+27, r22	; 0x1b
    5b66:	5c 8f       	std	Y+28, r21	; 0x1c
    5b68:	3d 8f       	std	Y+29, r19	; 0x1d
    5b6a:	2e 8f       	std	Y+30, r18	; 0x1e
    5b6c:	9f 8f       	std	Y+31, r25	; 0x1f
    5b6e:	18 a3       	lds	r17, 0x58
    5b70:	79 8d       	ldd	r23, Y+25	; 0x19
    5b72:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5b74:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5b76:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5b78:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5b7a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5b7c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5b7e:	88 a1       	lds	r24, 0x48
    5b80:	e9 a1       	lds	r30, 0x49
    5b82:	e9 8b       	std	Y+17, r30	; 0x11
    5b84:	ea a1       	lds	r30, 0x4a
    5b86:	ea 8b       	std	Y+18, r30	; 0x12
    5b88:	eb a1       	lds	r30, 0x4b
    5b8a:	eb 8b       	std	Y+19, r30	; 0x13
    5b8c:	ec a1       	lds	r30, 0x4c
    5b8e:	ec 8b       	std	Y+20, r30	; 0x14
    5b90:	ed a1       	lds	r30, 0x4d
    5b92:	ed 8b       	std	Y+21, r30	; 0x15
    5b94:	ee a1       	lds	r30, 0x4e
    5b96:	ee 8b       	std	Y+22, r30	; 0x16
    5b98:	ef a1       	lds	r30, 0x4f
    5b9a:	ef 8b       	std	Y+23, r30	; 0x17
    5b9c:	e8 a5       	lds	r30, 0x68
    5b9e:	e8 8f       	std	Y+24, r30	; 0x18
    5ba0:	79 87       	std	Y+9, r23	; 0x09
    5ba2:	6a 87       	std	Y+10, r22	; 0x0a
    5ba4:	5b 87       	std	Y+11, r21	; 0x0b
    5ba6:	4c 87       	std	Y+12, r20	; 0x0c
    5ba8:	3d 87       	std	Y+13, r19	; 0x0d
    5baa:	2e 87       	std	Y+14, r18	; 0x0e
    5bac:	9f 87       	std	Y+15, r25	; 0x0f
    5bae:	88 8b       	std	Y+16, r24	; 0x10
    5bb0:	89 84       	ldd	r8, Y+9	; 0x09
    5bb2:	9a 84       	ldd	r9, Y+10	; 0x0a
    5bb4:	ab 84       	ldd	r10, Y+11	; 0x0b
    5bb6:	bc 84       	ldd	r11, Y+12	; 0x0c
    5bb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    5bba:	9e 85       	ldd	r25, Y+14	; 0x0e
    5bbc:	af 85       	ldd	r26, Y+15	; 0x0f
    5bbe:	b8 89       	ldd	r27, Y+16	; 0x10
    5bc0:	e9 88       	ldd	r14, Y+17	; 0x11
    5bc2:	fa 88       	ldd	r15, Y+18	; 0x12
    5bc4:	0b 89       	ldd	r16, Y+19	; 0x13
    5bc6:	1c 89       	ldd	r17, Y+20	; 0x14
    5bc8:	ed aa       	sts	0x9d, r30
    5bca:	fe aa       	sts	0x9e, r31
    5bcc:	0f ab       	sts	0x5f, r16
    5bce:	18 af       	sts	0x78, r17
    5bd0:	cd 88       	ldd	r12, Y+21	; 0x15
    5bd2:	de 88       	ldd	r13, Y+22	; 0x16
    5bd4:	ef 88       	ldd	r14, Y+23	; 0x17
    5bd6:	f8 8c       	ldd	r15, Y+24	; 0x18
    5bd8:	00 97       	sbiw	r24, 0x00	; 0
    5bda:	a1 05       	cpc	r26, r1
    5bdc:	b1 05       	cpc	r27, r1
    5bde:	09 f0       	breq	.+2      	; 0x5be2 <__divdi3+0x262>
    5be0:	bd c3       	rjmp	.+1914   	; 0x635c <__stack+0x35d>
    5be2:	c8 14       	cp	r12, r8
    5be4:	d9 04       	cpc	r13, r9
    5be6:	ea 04       	cpc	r14, r10
    5be8:	fb 04       	cpc	r15, r11
    5bea:	08 f0       	brcs	.+2      	; 0x5bee <__divdi3+0x26e>
    5bec:	4d c1       	rjmp	.+666    	; 0x5e88 <__divdi3+0x508>
    5bee:	00 e0       	ldi	r16, 0x00	; 0
    5bf0:	80 16       	cp	r8, r16
    5bf2:	00 e0       	ldi	r16, 0x00	; 0
    5bf4:	90 06       	cpc	r9, r16
    5bf6:	01 e0       	ldi	r16, 0x01	; 1
    5bf8:	a0 06       	cpc	r10, r16
    5bfa:	00 e0       	ldi	r16, 0x00	; 0
    5bfc:	b0 06       	cpc	r11, r16
    5bfe:	58 f4       	brcc	.+22     	; 0x5c16 <__divdi3+0x296>
    5c00:	1f ef       	ldi	r17, 0xFF	; 255
    5c02:	81 16       	cp	r8, r17
    5c04:	91 04       	cpc	r9, r1
    5c06:	a1 04       	cpc	r10, r1
    5c08:	b1 04       	cpc	r11, r1
    5c0a:	09 f0       	breq	.+2      	; 0x5c0e <__divdi3+0x28e>
    5c0c:	90 f4       	brcc	.+36     	; 0x5c32 <__divdi3+0x2b2>
    5c0e:	80 e0       	ldi	r24, 0x00	; 0
    5c10:	90 e0       	ldi	r25, 0x00	; 0
    5c12:	dc 01       	movw	r26, r24
    5c14:	17 c0       	rjmp	.+46     	; 0x5c44 <__divdi3+0x2c4>
    5c16:	20 e0       	ldi	r18, 0x00	; 0
    5c18:	82 16       	cp	r8, r18
    5c1a:	20 e0       	ldi	r18, 0x00	; 0
    5c1c:	92 06       	cpc	r9, r18
    5c1e:	20 e0       	ldi	r18, 0x00	; 0
    5c20:	a2 06       	cpc	r10, r18
    5c22:	21 e0       	ldi	r18, 0x01	; 1
    5c24:	b2 06       	cpc	r11, r18
    5c26:	50 f4       	brcc	.+20     	; 0x5c3c <__divdi3+0x2bc>
    5c28:	80 e1       	ldi	r24, 0x10	; 16
    5c2a:	90 e0       	ldi	r25, 0x00	; 0
    5c2c:	a0 e0       	ldi	r26, 0x00	; 0
    5c2e:	b0 e0       	ldi	r27, 0x00	; 0
    5c30:	09 c0       	rjmp	.+18     	; 0x5c44 <__divdi3+0x2c4>
    5c32:	88 e0       	ldi	r24, 0x08	; 8
    5c34:	90 e0       	ldi	r25, 0x00	; 0
    5c36:	a0 e0       	ldi	r26, 0x00	; 0
    5c38:	b0 e0       	ldi	r27, 0x00	; 0
    5c3a:	04 c0       	rjmp	.+8      	; 0x5c44 <__divdi3+0x2c4>
    5c3c:	88 e1       	ldi	r24, 0x18	; 24
    5c3e:	90 e0       	ldi	r25, 0x00	; 0
    5c40:	a0 e0       	ldi	r26, 0x00	; 0
    5c42:	b0 e0       	ldi	r27, 0x00	; 0
    5c44:	b5 01       	movw	r22, r10
    5c46:	a4 01       	movw	r20, r8
    5c48:	08 2e       	mov	r0, r24
    5c4a:	04 c0       	rjmp	.+8      	; 0x5c54 <__divdi3+0x2d4>
    5c4c:	76 95       	lsr	r23
    5c4e:	67 95       	ror	r22
    5c50:	57 95       	ror	r21
    5c52:	47 95       	ror	r20
    5c54:	0a 94       	dec	r0
    5c56:	d2 f7       	brpl	.-12     	; 0x5c4c <__divdi3+0x2cc>
    5c58:	fa 01       	movw	r30, r20
    5c5a:	ef 5d       	subi	r30, 0xDF	; 223
    5c5c:	ff 4d       	sbci	r31, 0xDF	; 223
    5c5e:	20 81       	ld	r18, Z
    5c60:	40 e2       	ldi	r20, 0x20	; 32
    5c62:	50 e0       	ldi	r21, 0x00	; 0
    5c64:	60 e0       	ldi	r22, 0x00	; 0
    5c66:	70 e0       	ldi	r23, 0x00	; 0
    5c68:	48 1b       	sub	r20, r24
    5c6a:	59 0b       	sbc	r21, r25
    5c6c:	6a 0b       	sbc	r22, r26
    5c6e:	7b 0b       	sbc	r23, r27
    5c70:	42 1b       	sub	r20, r18
    5c72:	51 09       	sbc	r21, r1
    5c74:	61 09       	sbc	r22, r1
    5c76:	71 09       	sbc	r23, r1
    5c78:	41 15       	cp	r20, r1
    5c7a:	51 05       	cpc	r21, r1
    5c7c:	61 05       	cpc	r22, r1
    5c7e:	71 05       	cpc	r23, r1
    5c80:	a1 f1       	breq	.+104    	; 0x5cea <__divdi3+0x36a>
    5c82:	04 2e       	mov	r0, r20
    5c84:	04 c0       	rjmp	.+8      	; 0x5c8e <__divdi3+0x30e>
    5c86:	88 0c       	add	r8, r8
    5c88:	99 1c       	adc	r9, r9
    5c8a:	aa 1c       	adc	r10, r10
    5c8c:	bb 1c       	adc	r11, r11
    5c8e:	0a 94       	dec	r0
    5c90:	d2 f7       	brpl	.-12     	; 0x5c86 <__divdi3+0x306>
    5c92:	97 01       	movw	r18, r14
    5c94:	86 01       	movw	r16, r12
    5c96:	04 2e       	mov	r0, r20
    5c98:	04 c0       	rjmp	.+8      	; 0x5ca2 <__divdi3+0x322>
    5c9a:	00 0f       	add	r16, r16
    5c9c:	11 1f       	adc	r17, r17
    5c9e:	22 1f       	adc	r18, r18
    5ca0:	33 1f       	adc	r19, r19
    5ca2:	0a 94       	dec	r0
    5ca4:	d2 f7       	brpl	.-12     	; 0x5c9a <__divdi3+0x31a>
    5ca6:	80 e2       	ldi	r24, 0x20	; 32
    5ca8:	90 e0       	ldi	r25, 0x00	; 0
    5caa:	84 1b       	sub	r24, r20
    5cac:	95 0b       	sbc	r25, r21
    5cae:	cd a8       	sts	0x8d, r28
    5cb0:	de a8       	sts	0x8e, r29
    5cb2:	ef a8       	sts	0x8f, r30
    5cb4:	f8 ac       	sts	0xa8, r31
    5cb6:	04 c0       	rjmp	.+8      	; 0x5cc0 <__divdi3+0x340>
    5cb8:	f6 94       	lsr	r15
    5cba:	e7 94       	ror	r14
    5cbc:	d7 94       	ror	r13
    5cbe:	c7 94       	ror	r12
    5cc0:	8a 95       	dec	r24
    5cc2:	d2 f7       	brpl	.-12     	; 0x5cb8 <__divdi3+0x338>
    5cc4:	c0 2a       	or	r12, r16
    5cc6:	d1 2a       	or	r13, r17
    5cc8:	e2 2a       	or	r14, r18
    5cca:	f3 2a       	or	r15, r19
    5ccc:	0d a9       	sts	0x4d, r16
    5cce:	1e a9       	sts	0x4e, r17
    5cd0:	2f a9       	sts	0x4f, r18
    5cd2:	38 ad       	sts	0x68, r19
    5cd4:	04 c0       	rjmp	.+8      	; 0x5cde <__divdi3+0x35e>
    5cd6:	00 0f       	add	r16, r16
    5cd8:	11 1f       	adc	r17, r17
    5cda:	22 1f       	adc	r18, r18
    5cdc:	33 1f       	adc	r19, r19
    5cde:	4a 95       	dec	r20
    5ce0:	d2 f7       	brpl	.-12     	; 0x5cd6 <__divdi3+0x356>
    5ce2:	0d ab       	sts	0x5d, r16
    5ce4:	1e ab       	sts	0x5e, r17
    5ce6:	2f ab       	sts	0x5f, r18
    5ce8:	38 af       	sts	0x78, r19
    5cea:	25 01       	movw	r4, r10
    5cec:	66 24       	eor	r6, r6
    5cee:	77 24       	eor	r7, r7
    5cf0:	95 01       	movw	r18, r10
    5cf2:	84 01       	movw	r16, r8
    5cf4:	20 70       	andi	r18, 0x00	; 0
    5cf6:	30 70       	andi	r19, 0x00	; 0
    5cf8:	09 ab       	sts	0x59, r16
    5cfa:	1a ab       	sts	0x5a, r17
    5cfc:	2b ab       	sts	0x5b, r18
    5cfe:	3c ab       	sts	0x5c, r19
    5d00:	c7 01       	movw	r24, r14
    5d02:	b6 01       	movw	r22, r12
    5d04:	a3 01       	movw	r20, r6
    5d06:	92 01       	movw	r18, r4
    5d08:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    5d0c:	2d a7       	lds	r18, 0x7d
    5d0e:	3e a7       	lds	r19, 0x7e
    5d10:	4f a7       	lds	r20, 0x7f
    5d12:	58 ab       	sts	0x58, r21
    5d14:	69 a7       	lds	r22, 0x79
    5d16:	7a a7       	lds	r23, 0x7a
    5d18:	8b a7       	lds	r24, 0x7b
    5d1a:	9c a7       	lds	r25, 0x7c
    5d1c:	c7 01       	movw	r24, r14
    5d1e:	b6 01       	movw	r22, r12
    5d20:	a3 01       	movw	r20, r6
    5d22:	92 01       	movw	r18, r4
    5d24:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    5d28:	ca 01       	movw	r24, r20
    5d2a:	b9 01       	movw	r22, r18
    5d2c:	29 a9       	sts	0x49, r18
    5d2e:	3a a9       	sts	0x4a, r19
    5d30:	4b a9       	sts	0x4b, r20
    5d32:	5c a9       	sts	0x4c, r21
    5d34:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    5d38:	ab 01       	movw	r20, r22
    5d3a:	bc 01       	movw	r22, r24
    5d3c:	09 a5       	lds	r16, 0x69
    5d3e:	1a a5       	lds	r17, 0x6a
    5d40:	2b a5       	lds	r18, 0x6b
    5d42:	3c a5       	lds	r19, 0x6c
    5d44:	78 01       	movw	r14, r16
    5d46:	dd 24       	eor	r13, r13
    5d48:	cc 24       	eor	r12, r12
    5d4a:	0d a9       	sts	0x4d, r16
    5d4c:	1e a9       	sts	0x4e, r17
    5d4e:	2f a9       	sts	0x4f, r18
    5d50:	38 ad       	sts	0x68, r19
    5d52:	c9 01       	movw	r24, r18
    5d54:	aa 27       	eor	r26, r26
    5d56:	bb 27       	eor	r27, r27
    5d58:	c8 2a       	or	r12, r24
    5d5a:	d9 2a       	or	r13, r25
    5d5c:	ea 2a       	or	r14, r26
    5d5e:	fb 2a       	or	r15, r27
    5d60:	0d a5       	lds	r16, 0x6d
    5d62:	1e a5       	lds	r17, 0x6e
    5d64:	2f a5       	lds	r18, 0x6f
    5d66:	38 a9       	sts	0x48, r19
    5d68:	c4 16       	cp	r12, r20
    5d6a:	d5 06       	cpc	r13, r21
    5d6c:	e6 06       	cpc	r14, r22
    5d6e:	f7 06       	cpc	r15, r23
    5d70:	38 f5       	brcc	.+78     	; 0x5dc0 <__divdi3+0x440>
    5d72:	01 50       	subi	r16, 0x01	; 1
    5d74:	10 40       	sbci	r17, 0x00	; 0
    5d76:	20 40       	sbci	r18, 0x00	; 0
    5d78:	30 40       	sbci	r19, 0x00	; 0
    5d7a:	09 a7       	lds	r16, 0x79
    5d7c:	1a a7       	lds	r17, 0x7a
    5d7e:	2b a7       	lds	r18, 0x7b
    5d80:	3c a7       	lds	r19, 0x7c
    5d82:	c8 0c       	add	r12, r8
    5d84:	d9 1c       	adc	r13, r9
    5d86:	ea 1c       	adc	r14, r10
    5d88:	fb 1c       	adc	r15, r11
    5d8a:	c8 14       	cp	r12, r8
    5d8c:	d9 04       	cpc	r13, r9
    5d8e:	ea 04       	cpc	r14, r10
    5d90:	fb 04       	cpc	r15, r11
    5d92:	d0 f0       	brcs	.+52     	; 0x5dc8 <__divdi3+0x448>
    5d94:	c4 16       	cp	r12, r20
    5d96:	d5 06       	cpc	r13, r21
    5d98:	e6 06       	cpc	r14, r22
    5d9a:	f7 06       	cpc	r15, r23
    5d9c:	a8 f4       	brcc	.+42     	; 0x5dc8 <__divdi3+0x448>
    5d9e:	0d a5       	lds	r16, 0x6d
    5da0:	1e a5       	lds	r17, 0x6e
    5da2:	2f a5       	lds	r18, 0x6f
    5da4:	38 a9       	sts	0x48, r19
    5da6:	02 50       	subi	r16, 0x02	; 2
    5da8:	10 40       	sbci	r17, 0x00	; 0
    5daa:	20 40       	sbci	r18, 0x00	; 0
    5dac:	30 40       	sbci	r19, 0x00	; 0
    5dae:	09 a7       	lds	r16, 0x79
    5db0:	1a a7       	lds	r17, 0x7a
    5db2:	2b a7       	lds	r18, 0x7b
    5db4:	3c a7       	lds	r19, 0x7c
    5db6:	c8 0c       	add	r12, r8
    5db8:	d9 1c       	adc	r13, r9
    5dba:	ea 1c       	adc	r14, r10
    5dbc:	fb 1c       	adc	r15, r11
    5dbe:	04 c0       	rjmp	.+8      	; 0x5dc8 <__divdi3+0x448>
    5dc0:	09 a7       	lds	r16, 0x79
    5dc2:	1a a7       	lds	r17, 0x7a
    5dc4:	2b a7       	lds	r18, 0x7b
    5dc6:	3c a7       	lds	r19, 0x7c
    5dc8:	c4 1a       	sub	r12, r20
    5dca:	d5 0a       	sbc	r13, r21
    5dcc:	e6 0a       	sbc	r14, r22
    5dce:	f7 0a       	sbc	r15, r23
    5dd0:	c7 01       	movw	r24, r14
    5dd2:	b6 01       	movw	r22, r12
    5dd4:	a3 01       	movw	r20, r6
    5dd6:	92 01       	movw	r18, r4
    5dd8:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    5ddc:	2d a7       	lds	r18, 0x7d
    5dde:	3e a7       	lds	r19, 0x7e
    5de0:	4f a7       	lds	r20, 0x7f
    5de2:	58 ab       	sts	0x58, r21
    5de4:	69 af       	sts	0x79, r22
    5de6:	7a af       	sts	0x7a, r23
    5de8:	8b af       	sts	0x7b, r24
    5dea:	9c af       	sts	0x7c, r25
    5dec:	c7 01       	movw	r24, r14
    5dee:	b6 01       	movw	r22, r12
    5df0:	a3 01       	movw	r20, r6
    5df2:	92 01       	movw	r18, r4
    5df4:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    5df8:	ca 01       	movw	r24, r20
    5dfa:	b9 01       	movw	r22, r18
    5dfc:	29 a9       	sts	0x49, r18
    5dfe:	3a a9       	sts	0x4a, r19
    5e00:	4b a9       	sts	0x4b, r20
    5e02:	5c a9       	sts	0x4c, r21
    5e04:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    5e08:	6b 01       	movw	r12, r22
    5e0a:	7c 01       	movw	r14, r24
    5e0c:	49 ad       	sts	0x69, r20
    5e0e:	5a ad       	sts	0x6a, r21
    5e10:	6b ad       	sts	0x6b, r22
    5e12:	7c ad       	sts	0x6c, r23
    5e14:	9a 01       	movw	r18, r20
    5e16:	11 27       	eor	r17, r17
    5e18:	00 27       	eor	r16, r16
    5e1a:	4d a9       	sts	0x4d, r20
    5e1c:	5e a9       	sts	0x4e, r21
    5e1e:	6f a9       	sts	0x4f, r22
    5e20:	78 ad       	sts	0x68, r23
    5e22:	60 70       	andi	r22, 0x00	; 0
    5e24:	70 70       	andi	r23, 0x00	; 0
    5e26:	04 2b       	or	r16, r20
    5e28:	15 2b       	or	r17, r21
    5e2a:	26 2b       	or	r18, r22
    5e2c:	37 2b       	or	r19, r23
    5e2e:	8d a5       	lds	r24, 0x6d
    5e30:	9e a5       	lds	r25, 0x6e
    5e32:	af a5       	lds	r26, 0x6f
    5e34:	b8 a9       	sts	0x48, r27
    5e36:	0c 15       	cp	r16, r12
    5e38:	1d 05       	cpc	r17, r13
    5e3a:	2e 05       	cpc	r18, r14
    5e3c:	3f 05       	cpc	r19, r15
    5e3e:	c0 f4       	brcc	.+48     	; 0x5e70 <__divdi3+0x4f0>
    5e40:	01 97       	sbiw	r24, 0x01	; 1
    5e42:	a1 09       	sbc	r26, r1
    5e44:	b1 09       	sbc	r27, r1
    5e46:	08 0d       	add	r16, r8
    5e48:	19 1d       	adc	r17, r9
    5e4a:	2a 1d       	adc	r18, r10
    5e4c:	3b 1d       	adc	r19, r11
    5e4e:	08 15       	cp	r16, r8
    5e50:	19 05       	cpc	r17, r9
    5e52:	2a 05       	cpc	r18, r10
    5e54:	3b 05       	cpc	r19, r11
    5e56:	60 f0       	brcs	.+24     	; 0x5e70 <__divdi3+0x4f0>
    5e58:	0c 15       	cp	r16, r12
    5e5a:	1d 05       	cpc	r17, r13
    5e5c:	2e 05       	cpc	r18, r14
    5e5e:	3f 05       	cpc	r19, r15
    5e60:	38 f4       	brcc	.+14     	; 0x5e70 <__divdi3+0x4f0>
    5e62:	8d a5       	lds	r24, 0x6d
    5e64:	9e a5       	lds	r25, 0x6e
    5e66:	af a5       	lds	r26, 0x6f
    5e68:	b8 a9       	sts	0x48, r27
    5e6a:	02 97       	sbiw	r24, 0x02	; 2
    5e6c:	a1 09       	sbc	r26, r1
    5e6e:	b1 09       	sbc	r27, r1
    5e70:	09 a5       	lds	r16, 0x69
    5e72:	1a a5       	lds	r17, 0x6a
    5e74:	2b a5       	lds	r18, 0x6b
    5e76:	3c a5       	lds	r19, 0x6c
    5e78:	78 01       	movw	r14, r16
    5e7a:	dd 24       	eor	r13, r13
    5e7c:	cc 24       	eor	r12, r12
    5e7e:	c8 2a       	or	r12, r24
    5e80:	d9 2a       	or	r13, r25
    5e82:	ea 2a       	or	r14, r26
    5e84:	fb 2a       	or	r15, r27
    5e86:	b7 c4       	rjmp	.+2414   	; 0x67f6 <__stack+0x7f7>
    5e88:	81 14       	cp	r8, r1
    5e8a:	91 04       	cpc	r9, r1
    5e8c:	a1 04       	cpc	r10, r1
    5e8e:	b1 04       	cpc	r11, r1
    5e90:	51 f4       	brne	.+20     	; 0x5ea6 <__divdi3+0x526>
    5e92:	61 e0       	ldi	r22, 0x01	; 1
    5e94:	70 e0       	ldi	r23, 0x00	; 0
    5e96:	80 e0       	ldi	r24, 0x00	; 0
    5e98:	90 e0       	ldi	r25, 0x00	; 0
    5e9a:	a5 01       	movw	r20, r10
    5e9c:	94 01       	movw	r18, r8
    5e9e:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    5ea2:	49 01       	movw	r8, r18
    5ea4:	5a 01       	movw	r10, r20
    5ea6:	10 e0       	ldi	r17, 0x00	; 0
    5ea8:	81 16       	cp	r8, r17
    5eaa:	10 e0       	ldi	r17, 0x00	; 0
    5eac:	91 06       	cpc	r9, r17
    5eae:	11 e0       	ldi	r17, 0x01	; 1
    5eb0:	a1 06       	cpc	r10, r17
    5eb2:	10 e0       	ldi	r17, 0x00	; 0
    5eb4:	b1 06       	cpc	r11, r17
    5eb6:	58 f4       	brcc	.+22     	; 0x5ece <__divdi3+0x54e>
    5eb8:	2f ef       	ldi	r18, 0xFF	; 255
    5eba:	82 16       	cp	r8, r18
    5ebc:	91 04       	cpc	r9, r1
    5ebe:	a1 04       	cpc	r10, r1
    5ec0:	b1 04       	cpc	r11, r1
    5ec2:	09 f0       	breq	.+2      	; 0x5ec6 <__divdi3+0x546>
    5ec4:	90 f4       	brcc	.+36     	; 0x5eea <__divdi3+0x56a>
    5ec6:	80 e0       	ldi	r24, 0x00	; 0
    5ec8:	90 e0       	ldi	r25, 0x00	; 0
    5eca:	dc 01       	movw	r26, r24
    5ecc:	17 c0       	rjmp	.+46     	; 0x5efc <__divdi3+0x57c>
    5ece:	30 e0       	ldi	r19, 0x00	; 0
    5ed0:	83 16       	cp	r8, r19
    5ed2:	30 e0       	ldi	r19, 0x00	; 0
    5ed4:	93 06       	cpc	r9, r19
    5ed6:	30 e0       	ldi	r19, 0x00	; 0
    5ed8:	a3 06       	cpc	r10, r19
    5eda:	31 e0       	ldi	r19, 0x01	; 1
    5edc:	b3 06       	cpc	r11, r19
    5ede:	50 f4       	brcc	.+20     	; 0x5ef4 <__divdi3+0x574>
    5ee0:	80 e1       	ldi	r24, 0x10	; 16
    5ee2:	90 e0       	ldi	r25, 0x00	; 0
    5ee4:	a0 e0       	ldi	r26, 0x00	; 0
    5ee6:	b0 e0       	ldi	r27, 0x00	; 0
    5ee8:	09 c0       	rjmp	.+18     	; 0x5efc <__divdi3+0x57c>
    5eea:	88 e0       	ldi	r24, 0x08	; 8
    5eec:	90 e0       	ldi	r25, 0x00	; 0
    5eee:	a0 e0       	ldi	r26, 0x00	; 0
    5ef0:	b0 e0       	ldi	r27, 0x00	; 0
    5ef2:	04 c0       	rjmp	.+8      	; 0x5efc <__divdi3+0x57c>
    5ef4:	88 e1       	ldi	r24, 0x18	; 24
    5ef6:	90 e0       	ldi	r25, 0x00	; 0
    5ef8:	a0 e0       	ldi	r26, 0x00	; 0
    5efa:	b0 e0       	ldi	r27, 0x00	; 0
    5efc:	b5 01       	movw	r22, r10
    5efe:	a4 01       	movw	r20, r8
    5f00:	08 2e       	mov	r0, r24
    5f02:	04 c0       	rjmp	.+8      	; 0x5f0c <__divdi3+0x58c>
    5f04:	76 95       	lsr	r23
    5f06:	67 95       	ror	r22
    5f08:	57 95       	ror	r21
    5f0a:	47 95       	ror	r20
    5f0c:	0a 94       	dec	r0
    5f0e:	d2 f7       	brpl	.-12     	; 0x5f04 <__divdi3+0x584>
    5f10:	fa 01       	movw	r30, r20
    5f12:	ef 5d       	subi	r30, 0xDF	; 223
    5f14:	ff 4d       	sbci	r31, 0xDF	; 223
    5f16:	20 81       	ld	r18, Z
    5f18:	ac 01       	movw	r20, r24
    5f1a:	bd 01       	movw	r22, r26
    5f1c:	42 0f       	add	r20, r18
    5f1e:	51 1d       	adc	r21, r1
    5f20:	61 1d       	adc	r22, r1
    5f22:	71 1d       	adc	r23, r1
    5f24:	80 e2       	ldi	r24, 0x20	; 32
    5f26:	90 e0       	ldi	r25, 0x00	; 0
    5f28:	a0 e0       	ldi	r26, 0x00	; 0
    5f2a:	b0 e0       	ldi	r27, 0x00	; 0
    5f2c:	84 1b       	sub	r24, r20
    5f2e:	95 0b       	sbc	r25, r21
    5f30:	a6 0b       	sbc	r26, r22
    5f32:	b7 0b       	sbc	r27, r23
    5f34:	51 f4       	brne	.+20     	; 0x5f4a <__divdi3+0x5ca>
    5f36:	c8 18       	sub	r12, r8
    5f38:	d9 08       	sbc	r13, r9
    5f3a:	ea 08       	sbc	r14, r10
    5f3c:	fb 08       	sbc	r15, r11
    5f3e:	f1 e0       	ldi	r31, 0x01	; 1
    5f40:	4f 2e       	mov	r4, r31
    5f42:	51 2c       	mov	r5, r1
    5f44:	61 2c       	mov	r6, r1
    5f46:	71 2c       	mov	r7, r1
    5f48:	28 c1       	rjmp	.+592    	; 0x619a <__stack+0x19b>
    5f4a:	08 2e       	mov	r0, r24
    5f4c:	04 c0       	rjmp	.+8      	; 0x5f56 <__divdi3+0x5d6>
    5f4e:	88 0c       	add	r8, r8
    5f50:	99 1c       	adc	r9, r9
    5f52:	aa 1c       	adc	r10, r10
    5f54:	bb 1c       	adc	r11, r11
    5f56:	0a 94       	dec	r0
    5f58:	d2 f7       	brpl	.-12     	; 0x5f4e <__divdi3+0x5ce>
    5f5a:	97 01       	movw	r18, r14
    5f5c:	86 01       	movw	r16, r12
    5f5e:	04 2e       	mov	r0, r20
    5f60:	04 c0       	rjmp	.+8      	; 0x5f6a <__divdi3+0x5ea>
    5f62:	36 95       	lsr	r19
    5f64:	27 95       	ror	r18
    5f66:	17 95       	ror	r17
    5f68:	07 95       	ror	r16
    5f6a:	0a 94       	dec	r0
    5f6c:	d2 f7       	brpl	.-12     	; 0x5f62 <__divdi3+0x5e2>
    5f6e:	09 ab       	sts	0x59, r16
    5f70:	1a ab       	sts	0x5a, r17
    5f72:	2b ab       	sts	0x5b, r18
    5f74:	3c ab       	sts	0x5c, r19
    5f76:	97 01       	movw	r18, r14
    5f78:	86 01       	movw	r16, r12
    5f7a:	08 2e       	mov	r0, r24
    5f7c:	04 c0       	rjmp	.+8      	; 0x5f86 <__divdi3+0x606>
    5f7e:	00 0f       	add	r16, r16
    5f80:	11 1f       	adc	r17, r17
    5f82:	22 1f       	adc	r18, r18
    5f84:	33 1f       	adc	r19, r19
    5f86:	0a 94       	dec	r0
    5f88:	d2 f7       	brpl	.-12     	; 0x5f7e <__divdi3+0x5fe>
    5f8a:	0d a7       	lds	r16, 0x7d
    5f8c:	1e a7       	lds	r17, 0x7e
    5f8e:	2f a7       	lds	r18, 0x7f
    5f90:	38 ab       	sts	0x58, r19
    5f92:	ed a8       	sts	0x8d, r30
    5f94:	fe a8       	sts	0x8e, r31
    5f96:	0f a9       	sts	0x4f, r16
    5f98:	18 ad       	sts	0x68, r17
    5f9a:	04 c0       	rjmp	.+8      	; 0x5fa4 <__divdi3+0x624>
    5f9c:	16 95       	lsr	r17
    5f9e:	07 95       	ror	r16
    5fa0:	f7 94       	ror	r15
    5fa2:	e7 94       	ror	r14
    5fa4:	4a 95       	dec	r20
    5fa6:	d2 f7       	brpl	.-12     	; 0x5f9c <__divdi3+0x61c>
    5fa8:	b8 01       	movw	r22, r16
    5faa:	a7 01       	movw	r20, r14
    5fac:	0d a5       	lds	r16, 0x6d
    5fae:	1e a5       	lds	r17, 0x6e
    5fb0:	2f a5       	lds	r18, 0x6f
    5fb2:	38 a9       	sts	0x48, r19
    5fb4:	04 2b       	or	r16, r20
    5fb6:	15 2b       	or	r17, r21
    5fb8:	26 2b       	or	r18, r22
    5fba:	37 2b       	or	r19, r23
    5fbc:	0d a7       	lds	r16, 0x7d
    5fbe:	1e a7       	lds	r17, 0x7e
    5fc0:	2f a7       	lds	r18, 0x7f
    5fc2:	38 ab       	sts	0x58, r19
    5fc4:	ed a8       	sts	0x8d, r30
    5fc6:	fe a8       	sts	0x8e, r31
    5fc8:	0f a9       	sts	0x4f, r16
    5fca:	18 ad       	sts	0x68, r17
    5fcc:	04 c0       	rjmp	.+8      	; 0x5fd6 <__divdi3+0x656>
    5fce:	ee 0c       	add	r14, r14
    5fd0:	ff 1c       	adc	r15, r15
    5fd2:	00 1f       	adc	r16, r16
    5fd4:	11 1f       	adc	r17, r17
    5fd6:	8a 95       	dec	r24
    5fd8:	d2 f7       	brpl	.-12     	; 0x5fce <__divdi3+0x64e>
    5fda:	ed aa       	sts	0x9d, r30
    5fdc:	fe aa       	sts	0x9e, r31
    5fde:	0f ab       	sts	0x5f, r16
    5fe0:	18 af       	sts	0x78, r17
    5fe2:	25 01       	movw	r4, r10
    5fe4:	66 24       	eor	r6, r6
    5fe6:	77 24       	eor	r7, r7
    5fe8:	95 01       	movw	r18, r10
    5fea:	84 01       	movw	r16, r8
    5fec:	20 70       	andi	r18, 0x00	; 0
    5fee:	30 70       	andi	r19, 0x00	; 0
    5ff0:	09 af       	sts	0x79, r16
    5ff2:	1a af       	sts	0x7a, r17
    5ff4:	2b af       	sts	0x7b, r18
    5ff6:	3c af       	sts	0x7c, r19
    5ff8:	69 a9       	sts	0x49, r22
    5ffa:	7a a9       	sts	0x4a, r23
    5ffc:	8b a9       	sts	0x4b, r24
    5ffe:	9c a9       	sts	0x4c, r25
    6000:	a3 01       	movw	r20, r6
    6002:	92 01       	movw	r18, r4
    6004:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    6008:	29 a7       	lds	r18, 0x79
    600a:	3a a7       	lds	r19, 0x7a
    600c:	4b a7       	lds	r20, 0x7b
    600e:	5c a7       	lds	r21, 0x7c
    6010:	6b 01       	movw	r12, r22
    6012:	7c 01       	movw	r14, r24
    6014:	69 a9       	sts	0x49, r22
    6016:	7a a9       	sts	0x4a, r23
    6018:	8b a9       	sts	0x4b, r24
    601a:	9c a9       	sts	0x4c, r25
    601c:	a3 01       	movw	r20, r6
    601e:	92 01       	movw	r18, r4
    6020:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    6024:	ca 01       	movw	r24, r20
    6026:	b9 01       	movw	r22, r18
    6028:	29 ad       	sts	0x69, r18
    602a:	3a ad       	sts	0x6a, r19
    602c:	4b ad       	sts	0x6b, r20
    602e:	5c ad       	sts	0x6c, r21
    6030:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    6034:	ab 01       	movw	r20, r22
    6036:	bc 01       	movw	r22, r24
    6038:	76 01       	movw	r14, r12
    603a:	dd 24       	eor	r13, r13
    603c:	cc 24       	eor	r12, r12
    603e:	0d a5       	lds	r16, 0x6d
    6040:	1e a5       	lds	r17, 0x6e
    6042:	2f a5       	lds	r18, 0x6f
    6044:	38 a9       	sts	0x48, r19
    6046:	c9 01       	movw	r24, r18
    6048:	aa 27       	eor	r26, r26
    604a:	bb 27       	eor	r27, r27
    604c:	c8 2a       	or	r12, r24
    604e:	d9 2a       	or	r13, r25
    6050:	ea 2a       	or	r14, r26
    6052:	fb 2a       	or	r15, r27
    6054:	09 a5       	lds	r16, 0x69
    6056:	1a a5       	lds	r17, 0x6a
    6058:	2b a5       	lds	r18, 0x6b
    605a:	3c a5       	lds	r19, 0x6c
    605c:	c4 16       	cp	r12, r20
    605e:	d5 06       	cpc	r13, r21
    6060:	e6 06       	cpc	r14, r22
    6062:	f7 06       	cpc	r15, r23
    6064:	38 f5       	brcc	.+78     	; 0x60b4 <__stack+0xb5>
    6066:	01 50       	subi	r16, 0x01	; 1
    6068:	10 40       	sbci	r17, 0x00	; 0
    606a:	20 40       	sbci	r18, 0x00	; 0
    606c:	30 40       	sbci	r19, 0x00	; 0
    606e:	09 ab       	sts	0x59, r16
    6070:	1a ab       	sts	0x5a, r17
    6072:	2b ab       	sts	0x5b, r18
    6074:	3c ab       	sts	0x5c, r19
    6076:	c8 0c       	add	r12, r8
    6078:	d9 1c       	adc	r13, r9
    607a:	ea 1c       	adc	r14, r10
    607c:	fb 1c       	adc	r15, r11
    607e:	c8 14       	cp	r12, r8
    6080:	d9 04       	cpc	r13, r9
    6082:	ea 04       	cpc	r14, r10
    6084:	fb 04       	cpc	r15, r11
    6086:	d0 f0       	brcs	.+52     	; 0x60bc <__stack+0xbd>
    6088:	c4 16       	cp	r12, r20
    608a:	d5 06       	cpc	r13, r21
    608c:	e6 06       	cpc	r14, r22
    608e:	f7 06       	cpc	r15, r23
    6090:	a8 f4       	brcc	.+42     	; 0x60bc <__stack+0xbd>
    6092:	09 a5       	lds	r16, 0x69
    6094:	1a a5       	lds	r17, 0x6a
    6096:	2b a5       	lds	r18, 0x6b
    6098:	3c a5       	lds	r19, 0x6c
    609a:	02 50       	subi	r16, 0x02	; 2
    609c:	10 40       	sbci	r17, 0x00	; 0
    609e:	20 40       	sbci	r18, 0x00	; 0
    60a0:	30 40       	sbci	r19, 0x00	; 0
    60a2:	09 ab       	sts	0x59, r16
    60a4:	1a ab       	sts	0x5a, r17
    60a6:	2b ab       	sts	0x5b, r18
    60a8:	3c ab       	sts	0x5c, r19
    60aa:	c8 0c       	add	r12, r8
    60ac:	d9 1c       	adc	r13, r9
    60ae:	ea 1c       	adc	r14, r10
    60b0:	fb 1c       	adc	r15, r11
    60b2:	04 c0       	rjmp	.+8      	; 0x60bc <__stack+0xbd>
    60b4:	09 ab       	sts	0x59, r16
    60b6:	1a ab       	sts	0x5a, r17
    60b8:	2b ab       	sts	0x5b, r18
    60ba:	3c ab       	sts	0x5c, r19
    60bc:	c4 1a       	sub	r12, r20
    60be:	d5 0a       	sbc	r13, r21
    60c0:	e6 0a       	sbc	r14, r22
    60c2:	f7 0a       	sbc	r15, r23
    60c4:	c7 01       	movw	r24, r14
    60c6:	b6 01       	movw	r22, r12
    60c8:	a3 01       	movw	r20, r6
    60ca:	92 01       	movw	r18, r4
    60cc:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    60d0:	29 a7       	lds	r18, 0x79
    60d2:	3a a7       	lds	r19, 0x7a
    60d4:	4b a7       	lds	r20, 0x7b
    60d6:	5c a7       	lds	r21, 0x7c
    60d8:	21 96       	adiw	r28, 0x01	; 1
    60da:	6c af       	sts	0x7c, r22
    60dc:	7d af       	sts	0x7d, r23
    60de:	8e af       	sts	0x7e, r24
    60e0:	9f af       	sts	0x7f, r25
    60e2:	21 97       	sbiw	r28, 0x01	; 1
    60e4:	c7 01       	movw	r24, r14
    60e6:	b6 01       	movw	r22, r12
    60e8:	a3 01       	movw	r20, r6
    60ea:	92 01       	movw	r18, r4
    60ec:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    60f0:	ca 01       	movw	r24, r20
    60f2:	b9 01       	movw	r22, r18
    60f4:	29 ad       	sts	0x69, r18
    60f6:	3a ad       	sts	0x6a, r19
    60f8:	4b ad       	sts	0x6b, r20
    60fa:	5c ad       	sts	0x6c, r21
    60fc:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    6100:	8b 01       	movw	r16, r22
    6102:	9c 01       	movw	r18, r24
    6104:	21 96       	adiw	r28, 0x01	; 1
    6106:	4c ad       	sts	0x6c, r20
    6108:	5d ad       	sts	0x6d, r21
    610a:	6e ad       	sts	0x6e, r22
    610c:	7f ad       	sts	0x6f, r23
    610e:	21 97       	sbiw	r28, 0x01	; 1
    6110:	da 01       	movw	r26, r20
    6112:	99 27       	eor	r25, r25
    6114:	88 27       	eor	r24, r24
    6116:	4d a5       	lds	r20, 0x6d
    6118:	5e a5       	lds	r21, 0x6e
    611a:	6f a5       	lds	r22, 0x6f
    611c:	78 a9       	sts	0x48, r23
    611e:	60 70       	andi	r22, 0x00	; 0
    6120:	70 70       	andi	r23, 0x00	; 0
    6122:	84 2b       	or	r24, r20
    6124:	95 2b       	or	r25, r21
    6126:	a6 2b       	or	r26, r22
    6128:	b7 2b       	or	r27, r23
    612a:	49 a5       	lds	r20, 0x69
    612c:	5a a5       	lds	r21, 0x6a
    612e:	6b a5       	lds	r22, 0x6b
    6130:	7c a5       	lds	r23, 0x6c
    6132:	80 17       	cp	r24, r16
    6134:	91 07       	cpc	r25, r17
    6136:	a2 07       	cpc	r26, r18
    6138:	b3 07       	cpc	r27, r19
    613a:	f0 f4       	brcc	.+60     	; 0x6178 <__stack+0x179>
    613c:	41 50       	subi	r20, 0x01	; 1
    613e:	50 40       	sbci	r21, 0x00	; 0
    6140:	60 40       	sbci	r22, 0x00	; 0
    6142:	70 40       	sbci	r23, 0x00	; 0
    6144:	88 0d       	add	r24, r8
    6146:	99 1d       	adc	r25, r9
    6148:	aa 1d       	adc	r26, r10
    614a:	bb 1d       	adc	r27, r11
    614c:	88 15       	cp	r24, r8
    614e:	99 05       	cpc	r25, r9
    6150:	aa 05       	cpc	r26, r10
    6152:	bb 05       	cpc	r27, r11
    6154:	88 f0       	brcs	.+34     	; 0x6178 <__stack+0x179>
    6156:	80 17       	cp	r24, r16
    6158:	91 07       	cpc	r25, r17
    615a:	a2 07       	cpc	r26, r18
    615c:	b3 07       	cpc	r27, r19
    615e:	60 f4       	brcc	.+24     	; 0x6178 <__stack+0x179>
    6160:	49 a5       	lds	r20, 0x69
    6162:	5a a5       	lds	r21, 0x6a
    6164:	6b a5       	lds	r22, 0x6b
    6166:	7c a5       	lds	r23, 0x6c
    6168:	42 50       	subi	r20, 0x02	; 2
    616a:	50 40       	sbci	r21, 0x00	; 0
    616c:	60 40       	sbci	r22, 0x00	; 0
    616e:	70 40       	sbci	r23, 0x00	; 0
    6170:	88 0d       	add	r24, r8
    6172:	99 1d       	adc	r25, r9
    6174:	aa 1d       	adc	r26, r10
    6176:	bb 1d       	adc	r27, r11
    6178:	6c 01       	movw	r12, r24
    617a:	7d 01       	movw	r14, r26
    617c:	c0 1a       	sub	r12, r16
    617e:	d1 0a       	sbc	r13, r17
    6180:	e2 0a       	sbc	r14, r18
    6182:	f3 0a       	sbc	r15, r19
    6184:	09 a9       	sts	0x49, r16
    6186:	1a a9       	sts	0x4a, r17
    6188:	2b a9       	sts	0x4b, r18
    618a:	3c a9       	sts	0x4c, r19
    618c:	38 01       	movw	r6, r16
    618e:	55 24       	eor	r5, r5
    6190:	44 24       	eor	r4, r4
    6192:	44 2a       	or	r4, r20
    6194:	55 2a       	or	r5, r21
    6196:	66 2a       	or	r6, r22
    6198:	77 2a       	or	r7, r23
    619a:	85 01       	movw	r16, r10
    619c:	22 27       	eor	r18, r18
    619e:	33 27       	eor	r19, r19
    61a0:	0d a7       	lds	r16, 0x7d
    61a2:	1e a7       	lds	r17, 0x7e
    61a4:	2f a7       	lds	r18, 0x7f
    61a6:	38 ab       	sts	0x58, r19
    61a8:	95 01       	movw	r18, r10
    61aa:	84 01       	movw	r16, r8
    61ac:	20 70       	andi	r18, 0x00	; 0
    61ae:	30 70       	andi	r19, 0x00	; 0
    61b0:	09 af       	sts	0x79, r16
    61b2:	1a af       	sts	0x7a, r17
    61b4:	2b af       	sts	0x7b, r18
    61b6:	3c af       	sts	0x7c, r19
    61b8:	c7 01       	movw	r24, r14
    61ba:	b6 01       	movw	r22, r12
    61bc:	2d a5       	lds	r18, 0x6d
    61be:	3e a5       	lds	r19, 0x6e
    61c0:	4f a5       	lds	r20, 0x6f
    61c2:	58 a9       	sts	0x48, r21
    61c4:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    61c8:	29 a7       	lds	r18, 0x79
    61ca:	3a a7       	lds	r19, 0x7a
    61cc:	4b a7       	lds	r20, 0x7b
    61ce:	5c a7       	lds	r21, 0x7c
    61d0:	69 ab       	sts	0x59, r22
    61d2:	7a ab       	sts	0x5a, r23
    61d4:	8b ab       	sts	0x5b, r24
    61d6:	9c ab       	sts	0x5c, r25
    61d8:	c7 01       	movw	r24, r14
    61da:	b6 01       	movw	r22, r12
    61dc:	2d a5       	lds	r18, 0x6d
    61de:	3e a5       	lds	r19, 0x6e
    61e0:	4f a5       	lds	r20, 0x6f
    61e2:	58 a9       	sts	0x48, r21
    61e4:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    61e8:	ca 01       	movw	r24, r20
    61ea:	b9 01       	movw	r22, r18
    61ec:	29 ad       	sts	0x69, r18
    61ee:	3a ad       	sts	0x6a, r19
    61f0:	4b ad       	sts	0x6b, r20
    61f2:	5c ad       	sts	0x6c, r21
    61f4:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    61f8:	ab 01       	movw	r20, r22
    61fa:	bc 01       	movw	r22, r24
    61fc:	09 a9       	sts	0x49, r16
    61fe:	1a a9       	sts	0x4a, r17
    6200:	2b a9       	sts	0x4b, r18
    6202:	3c a9       	sts	0x4c, r19
    6204:	78 01       	movw	r14, r16
    6206:	dd 24       	eor	r13, r13
    6208:	cc 24       	eor	r12, r12
    620a:	0d a9       	sts	0x4d, r16
    620c:	1e a9       	sts	0x4e, r17
    620e:	2f a9       	sts	0x4f, r18
    6210:	38 ad       	sts	0x68, r19
    6212:	c9 01       	movw	r24, r18
    6214:	aa 27       	eor	r26, r26
    6216:	bb 27       	eor	r27, r27
    6218:	c8 2a       	or	r12, r24
    621a:	d9 2a       	or	r13, r25
    621c:	ea 2a       	or	r14, r26
    621e:	fb 2a       	or	r15, r27
    6220:	09 a5       	lds	r16, 0x69
    6222:	1a a5       	lds	r17, 0x6a
    6224:	2b a5       	lds	r18, 0x6b
    6226:	3c a5       	lds	r19, 0x6c
    6228:	c4 16       	cp	r12, r20
    622a:	d5 06       	cpc	r13, r21
    622c:	e6 06       	cpc	r14, r22
    622e:	f7 06       	cpc	r15, r23
    6230:	38 f5       	brcc	.+78     	; 0x6280 <__stack+0x281>
    6232:	01 50       	subi	r16, 0x01	; 1
    6234:	10 40       	sbci	r17, 0x00	; 0
    6236:	20 40       	sbci	r18, 0x00	; 0
    6238:	30 40       	sbci	r19, 0x00	; 0
    623a:	09 ab       	sts	0x59, r16
    623c:	1a ab       	sts	0x5a, r17
    623e:	2b ab       	sts	0x5b, r18
    6240:	3c ab       	sts	0x5c, r19
    6242:	c8 0c       	add	r12, r8
    6244:	d9 1c       	adc	r13, r9
    6246:	ea 1c       	adc	r14, r10
    6248:	fb 1c       	adc	r15, r11
    624a:	c8 14       	cp	r12, r8
    624c:	d9 04       	cpc	r13, r9
    624e:	ea 04       	cpc	r14, r10
    6250:	fb 04       	cpc	r15, r11
    6252:	d0 f0       	brcs	.+52     	; 0x6288 <__stack+0x289>
    6254:	c4 16       	cp	r12, r20
    6256:	d5 06       	cpc	r13, r21
    6258:	e6 06       	cpc	r14, r22
    625a:	f7 06       	cpc	r15, r23
    625c:	a8 f4       	brcc	.+42     	; 0x6288 <__stack+0x289>
    625e:	09 a5       	lds	r16, 0x69
    6260:	1a a5       	lds	r17, 0x6a
    6262:	2b a5       	lds	r18, 0x6b
    6264:	3c a5       	lds	r19, 0x6c
    6266:	02 50       	subi	r16, 0x02	; 2
    6268:	10 40       	sbci	r17, 0x00	; 0
    626a:	20 40       	sbci	r18, 0x00	; 0
    626c:	30 40       	sbci	r19, 0x00	; 0
    626e:	09 ab       	sts	0x59, r16
    6270:	1a ab       	sts	0x5a, r17
    6272:	2b ab       	sts	0x5b, r18
    6274:	3c ab       	sts	0x5c, r19
    6276:	c8 0c       	add	r12, r8
    6278:	d9 1c       	adc	r13, r9
    627a:	ea 1c       	adc	r14, r10
    627c:	fb 1c       	adc	r15, r11
    627e:	04 c0       	rjmp	.+8      	; 0x6288 <__stack+0x289>
    6280:	09 ab       	sts	0x59, r16
    6282:	1a ab       	sts	0x5a, r17
    6284:	2b ab       	sts	0x5b, r18
    6286:	3c ab       	sts	0x5c, r19
    6288:	c4 1a       	sub	r12, r20
    628a:	d5 0a       	sbc	r13, r21
    628c:	e6 0a       	sbc	r14, r22
    628e:	f7 0a       	sbc	r15, r23
    6290:	c7 01       	movw	r24, r14
    6292:	b6 01       	movw	r22, r12
    6294:	2d a5       	lds	r18, 0x6d
    6296:	3e a5       	lds	r19, 0x6e
    6298:	4f a5       	lds	r20, 0x6f
    629a:	58 a9       	sts	0x48, r21
    629c:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    62a0:	29 a7       	lds	r18, 0x79
    62a2:	3a a7       	lds	r19, 0x7a
    62a4:	4b a7       	lds	r20, 0x7b
    62a6:	5c a7       	lds	r21, 0x7c
    62a8:	21 96       	adiw	r28, 0x01	; 1
    62aa:	6c af       	sts	0x7c, r22
    62ac:	7d af       	sts	0x7d, r23
    62ae:	8e af       	sts	0x7e, r24
    62b0:	9f af       	sts	0x7f, r25
    62b2:	21 97       	sbiw	r28, 0x01	; 1
    62b4:	c7 01       	movw	r24, r14
    62b6:	b6 01       	movw	r22, r12
    62b8:	2d a5       	lds	r18, 0x6d
    62ba:	3e a5       	lds	r19, 0x6e
    62bc:	4f a5       	lds	r20, 0x6f
    62be:	58 a9       	sts	0x48, r21
    62c0:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    62c4:	ca 01       	movw	r24, r20
    62c6:	b9 01       	movw	r22, r18
    62c8:	29 ad       	sts	0x69, r18
    62ca:	3a ad       	sts	0x6a, r19
    62cc:	4b ad       	sts	0x6b, r20
    62ce:	5c ad       	sts	0x6c, r21
    62d0:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    62d4:	8b 01       	movw	r16, r22
    62d6:	9c 01       	movw	r18, r24
    62d8:	21 96       	adiw	r28, 0x01	; 1
    62da:	4c ad       	sts	0x6c, r20
    62dc:	5d ad       	sts	0x6d, r21
    62de:	6e ad       	sts	0x6e, r22
    62e0:	7f ad       	sts	0x6f, r23
    62e2:	21 97       	sbiw	r28, 0x01	; 1
    62e4:	da 01       	movw	r26, r20
    62e6:	99 27       	eor	r25, r25
    62e8:	88 27       	eor	r24, r24
    62ea:	4d a9       	sts	0x4d, r20
    62ec:	5e a9       	sts	0x4e, r21
    62ee:	6f a9       	sts	0x4f, r22
    62f0:	78 ad       	sts	0x68, r23
    62f2:	60 70       	andi	r22, 0x00	; 0
    62f4:	70 70       	andi	r23, 0x00	; 0
    62f6:	84 2b       	or	r24, r20
    62f8:	95 2b       	or	r25, r21
    62fa:	a6 2b       	or	r26, r22
    62fc:	b7 2b       	or	r27, r23
    62fe:	49 a5       	lds	r20, 0x69
    6300:	5a a5       	lds	r21, 0x6a
    6302:	6b a5       	lds	r22, 0x6b
    6304:	7c a5       	lds	r23, 0x6c
    6306:	80 17       	cp	r24, r16
    6308:	91 07       	cpc	r25, r17
    630a:	a2 07       	cpc	r26, r18
    630c:	b3 07       	cpc	r27, r19
    630e:	d0 f4       	brcc	.+52     	; 0x6344 <__stack+0x345>
    6310:	41 50       	subi	r20, 0x01	; 1
    6312:	50 40       	sbci	r21, 0x00	; 0
    6314:	60 40       	sbci	r22, 0x00	; 0
    6316:	70 40       	sbci	r23, 0x00	; 0
    6318:	88 0d       	add	r24, r8
    631a:	99 1d       	adc	r25, r9
    631c:	aa 1d       	adc	r26, r10
    631e:	bb 1d       	adc	r27, r11
    6320:	88 15       	cp	r24, r8
    6322:	99 05       	cpc	r25, r9
    6324:	aa 05       	cpc	r26, r10
    6326:	bb 05       	cpc	r27, r11
    6328:	68 f0       	brcs	.+26     	; 0x6344 <__stack+0x345>
    632a:	80 17       	cp	r24, r16
    632c:	91 07       	cpc	r25, r17
    632e:	a2 07       	cpc	r26, r18
    6330:	b3 07       	cpc	r27, r19
    6332:	40 f4       	brcc	.+16     	; 0x6344 <__stack+0x345>
    6334:	49 a5       	lds	r20, 0x69
    6336:	5a a5       	lds	r21, 0x6a
    6338:	6b a5       	lds	r22, 0x6b
    633a:	7c a5       	lds	r23, 0x6c
    633c:	42 50       	subi	r20, 0x02	; 2
    633e:	50 40       	sbci	r21, 0x00	; 0
    6340:	60 40       	sbci	r22, 0x00	; 0
    6342:	70 40       	sbci	r23, 0x00	; 0
    6344:	09 a9       	sts	0x49, r16
    6346:	1a a9       	sts	0x4a, r17
    6348:	2b a9       	sts	0x4b, r18
    634a:	3c a9       	sts	0x4c, r19
    634c:	78 01       	movw	r14, r16
    634e:	dd 24       	eor	r13, r13
    6350:	cc 24       	eor	r12, r12
    6352:	c4 2a       	or	r12, r20
    6354:	d5 2a       	or	r13, r21
    6356:	e6 2a       	or	r14, r22
    6358:	f7 2a       	or	r15, r23
    635a:	50 c2       	rjmp	.+1184   	; 0x67fc <__stack+0x7fd>
    635c:	c8 16       	cp	r12, r24
    635e:	d9 06       	cpc	r13, r25
    6360:	ea 06       	cpc	r14, r26
    6362:	fb 06       	cpc	r15, r27
    6364:	08 f4       	brcc	.+2      	; 0x6368 <__stack+0x369>
    6366:	37 c2       	rjmp	.+1134   	; 0x67d6 <__stack+0x7d7>
    6368:	80 30       	cpi	r24, 0x00	; 0
    636a:	10 e0       	ldi	r17, 0x00	; 0
    636c:	91 07       	cpc	r25, r17
    636e:	11 e0       	ldi	r17, 0x01	; 1
    6370:	a1 07       	cpc	r26, r17
    6372:	10 e0       	ldi	r17, 0x00	; 0
    6374:	b1 07       	cpc	r27, r17
    6376:	50 f4       	brcc	.+20     	; 0x638c <__stack+0x38d>
    6378:	8f 3f       	cpi	r24, 0xFF	; 255
    637a:	91 05       	cpc	r25, r1
    637c:	a1 05       	cpc	r26, r1
    637e:	b1 05       	cpc	r27, r1
    6380:	09 f0       	breq	.+2      	; 0x6384 <__stack+0x385>
    6382:	88 f4       	brcc	.+34     	; 0x63a6 <__stack+0x3a7>
    6384:	00 e0       	ldi	r16, 0x00	; 0
    6386:	10 e0       	ldi	r17, 0x00	; 0
    6388:	98 01       	movw	r18, r16
    638a:	16 c0       	rjmp	.+44     	; 0x63b8 <__stack+0x3b9>
    638c:	80 30       	cpi	r24, 0x00	; 0
    638e:	20 e0       	ldi	r18, 0x00	; 0
    6390:	92 07       	cpc	r25, r18
    6392:	20 e0       	ldi	r18, 0x00	; 0
    6394:	a2 07       	cpc	r26, r18
    6396:	21 e0       	ldi	r18, 0x01	; 1
    6398:	b2 07       	cpc	r27, r18
    639a:	50 f4       	brcc	.+20     	; 0x63b0 <__stack+0x3b1>
    639c:	00 e1       	ldi	r16, 0x10	; 16
    639e:	10 e0       	ldi	r17, 0x00	; 0
    63a0:	20 e0       	ldi	r18, 0x00	; 0
    63a2:	30 e0       	ldi	r19, 0x00	; 0
    63a4:	09 c0       	rjmp	.+18     	; 0x63b8 <__stack+0x3b9>
    63a6:	08 e0       	ldi	r16, 0x08	; 8
    63a8:	10 e0       	ldi	r17, 0x00	; 0
    63aa:	20 e0       	ldi	r18, 0x00	; 0
    63ac:	30 e0       	ldi	r19, 0x00	; 0
    63ae:	04 c0       	rjmp	.+8      	; 0x63b8 <__stack+0x3b9>
    63b0:	08 e1       	ldi	r16, 0x18	; 24
    63b2:	10 e0       	ldi	r17, 0x00	; 0
    63b4:	20 e0       	ldi	r18, 0x00	; 0
    63b6:	30 e0       	ldi	r19, 0x00	; 0
    63b8:	ac 01       	movw	r20, r24
    63ba:	bd 01       	movw	r22, r26
    63bc:	00 2e       	mov	r0, r16
    63be:	04 c0       	rjmp	.+8      	; 0x63c8 <__stack+0x3c9>
    63c0:	76 95       	lsr	r23
    63c2:	67 95       	ror	r22
    63c4:	57 95       	ror	r21
    63c6:	47 95       	ror	r20
    63c8:	0a 94       	dec	r0
    63ca:	d2 f7       	brpl	.-12     	; 0x63c0 <__stack+0x3c1>
    63cc:	fa 01       	movw	r30, r20
    63ce:	ef 5d       	subi	r30, 0xDF	; 223
    63d0:	ff 4d       	sbci	r31, 0xDF	; 223
    63d2:	40 81       	ld	r20, Z
    63d4:	04 0f       	add	r16, r20
    63d6:	11 1d       	adc	r17, r1
    63d8:	21 1d       	adc	r18, r1
    63da:	31 1d       	adc	r19, r1
    63dc:	40 e2       	ldi	r20, 0x20	; 32
    63de:	50 e0       	ldi	r21, 0x00	; 0
    63e0:	60 e0       	ldi	r22, 0x00	; 0
    63e2:	70 e0       	ldi	r23, 0x00	; 0
    63e4:	40 1b       	sub	r20, r16
    63e6:	51 0b       	sbc	r21, r17
    63e8:	62 0b       	sbc	r22, r18
    63ea:	73 0b       	sbc	r23, r19
    63ec:	a1 f4       	brne	.+40     	; 0x6416 <__stack+0x417>
    63ee:	8c 15       	cp	r24, r12
    63f0:	9d 05       	cpc	r25, r13
    63f2:	ae 05       	cpc	r26, r14
    63f4:	bf 05       	cpc	r27, r15
    63f6:	08 f4       	brcc	.+2      	; 0x63fa <__stack+0x3fb>
    63f8:	f5 c1       	rjmp	.+1002   	; 0x67e4 <__stack+0x7e5>
    63fa:	ed a8       	sts	0x8d, r30
    63fc:	fe a8       	sts	0x8e, r31
    63fe:	0f a9       	sts	0x4f, r16
    6400:	18 ad       	sts	0x68, r17
    6402:	44 24       	eor	r4, r4
    6404:	55 24       	eor	r5, r5
    6406:	32 01       	movw	r6, r4
    6408:	e8 14       	cp	r14, r8
    640a:	f9 04       	cpc	r15, r9
    640c:	0a 05       	cpc	r16, r10
    640e:	1b 05       	cpc	r17, r11
    6410:	08 f0       	brcs	.+2      	; 0x6414 <__stack+0x415>
    6412:	eb c1       	rjmp	.+982    	; 0x67ea <__stack+0x7eb>
    6414:	e3 c1       	rjmp	.+966    	; 0x67dc <__stack+0x7dd>
    6416:	34 2e       	mov	r3, r20
    6418:	2c 01       	movw	r4, r24
    641a:	3d 01       	movw	r6, r26
    641c:	04 c0       	rjmp	.+8      	; 0x6426 <__stack+0x427>
    641e:	44 0c       	add	r4, r4
    6420:	55 1c       	adc	r5, r5
    6422:	66 1c       	adc	r6, r6
    6424:	77 1c       	adc	r7, r7
    6426:	4a 95       	dec	r20
    6428:	d2 f7       	brpl	.-12     	; 0x641e <__stack+0x41f>
    642a:	d5 01       	movw	r26, r10
    642c:	c4 01       	movw	r24, r8
    642e:	00 2e       	mov	r0, r16
    6430:	04 c0       	rjmp	.+8      	; 0x643a <__stack+0x43b>
    6432:	b6 95       	lsr	r27
    6434:	a7 95       	ror	r26
    6436:	97 95       	ror	r25
    6438:	87 95       	ror	r24
    643a:	0a 94       	dec	r0
    643c:	d2 f7       	brpl	.-12     	; 0x6432 <__stack+0x433>
    643e:	48 2a       	or	r4, r24
    6440:	59 2a       	or	r5, r25
    6442:	6a 2a       	or	r6, r26
    6444:	7b 2a       	or	r7, r27
    6446:	a5 01       	movw	r20, r10
    6448:	94 01       	movw	r18, r8
    644a:	03 2c       	mov	r0, r3
    644c:	04 c0       	rjmp	.+8      	; 0x6456 <__stack+0x457>
    644e:	22 0f       	add	r18, r18
    6450:	33 1f       	adc	r19, r19
    6452:	44 1f       	adc	r20, r20
    6454:	55 1f       	adc	r21, r21
    6456:	0a 94       	dec	r0
    6458:	d2 f7       	brpl	.-12     	; 0x644e <__stack+0x44f>
    645a:	29 af       	sts	0x79, r18
    645c:	3a af       	sts	0x7a, r19
    645e:	4b af       	sts	0x7b, r20
    6460:	5c af       	sts	0x7c, r21
    6462:	b7 01       	movw	r22, r14
    6464:	a6 01       	movw	r20, r12
    6466:	00 2e       	mov	r0, r16
    6468:	04 c0       	rjmp	.+8      	; 0x6472 <__stack+0x473>
    646a:	76 95       	lsr	r23
    646c:	67 95       	ror	r22
    646e:	57 95       	ror	r21
    6470:	47 95       	ror	r20
    6472:	0a 94       	dec	r0
    6474:	d2 f7       	brpl	.-12     	; 0x646a <__stack+0x46b>
    6476:	49 ab       	sts	0x59, r20
    6478:	5a ab       	sts	0x5a, r21
    647a:	6b ab       	sts	0x5b, r22
    647c:	7c ab       	sts	0x5c, r23
    647e:	c7 01       	movw	r24, r14
    6480:	b6 01       	movw	r22, r12
    6482:	03 2c       	mov	r0, r3
    6484:	04 c0       	rjmp	.+8      	; 0x648e <__stack+0x48f>
    6486:	66 0f       	add	r22, r22
    6488:	77 1f       	adc	r23, r23
    648a:	88 1f       	adc	r24, r24
    648c:	99 1f       	adc	r25, r25
    648e:	0a 94       	dec	r0
    6490:	d2 f7       	brpl	.-12     	; 0x6486 <__stack+0x487>
    6492:	6d a7       	lds	r22, 0x7d
    6494:	7e a7       	lds	r23, 0x7e
    6496:	8f a7       	lds	r24, 0x7f
    6498:	98 ab       	sts	0x58, r25
    649a:	8d a9       	sts	0x4d, r24
    649c:	9e a9       	sts	0x4e, r25
    649e:	af a9       	sts	0x4f, r26
    64a0:	b8 ad       	sts	0x68, r27
    64a2:	04 c0       	rjmp	.+8      	; 0x64ac <__stack+0x4ad>
    64a4:	b6 95       	lsr	r27
    64a6:	a7 95       	ror	r26
    64a8:	97 95       	ror	r25
    64aa:	87 95       	ror	r24
    64ac:	0a 95       	dec	r16
    64ae:	d2 f7       	brpl	.-12     	; 0x64a4 <__stack+0x4a5>
    64b0:	4d a5       	lds	r20, 0x6d
    64b2:	5e a5       	lds	r21, 0x6e
    64b4:	6f a5       	lds	r22, 0x6f
    64b6:	78 a9       	sts	0x48, r23
    64b8:	48 2b       	or	r20, r24
    64ba:	59 2b       	or	r21, r25
    64bc:	6a 2b       	or	r22, r26
    64be:	7b 2b       	or	r23, r27
    64c0:	4d a7       	lds	r20, 0x7d
    64c2:	5e a7       	lds	r21, 0x7e
    64c4:	6f a7       	lds	r22, 0x7f
    64c6:	78 ab       	sts	0x58, r23
    64c8:	43 01       	movw	r8, r6
    64ca:	aa 24       	eor	r10, r10
    64cc:	bb 24       	eor	r11, r11
    64ce:	93 01       	movw	r18, r6
    64d0:	82 01       	movw	r16, r4
    64d2:	20 70       	andi	r18, 0x00	; 0
    64d4:	30 70       	andi	r19, 0x00	; 0
    64d6:	21 96       	adiw	r28, 0x01	; 1
    64d8:	0c af       	sts	0x7c, r16
    64da:	1d af       	sts	0x7d, r17
    64dc:	2e af       	sts	0x7e, r18
    64de:	3f af       	sts	0x7f, r19
    64e0:	21 97       	sbiw	r28, 0x01	; 1
    64e2:	69 a9       	sts	0x49, r22
    64e4:	7a a9       	sts	0x4a, r23
    64e6:	8b a9       	sts	0x4b, r24
    64e8:	9c a9       	sts	0x4c, r25
    64ea:	a5 01       	movw	r20, r10
    64ec:	94 01       	movw	r18, r8
    64ee:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    64f2:	29 a7       	lds	r18, 0x79
    64f4:	3a a7       	lds	r19, 0x7a
    64f6:	4b a7       	lds	r20, 0x7b
    64f8:	5c a7       	lds	r21, 0x7c
    64fa:	6b 01       	movw	r12, r22
    64fc:	7c 01       	movw	r14, r24
    64fe:	69 a9       	sts	0x49, r22
    6500:	7a a9       	sts	0x4a, r23
    6502:	8b a9       	sts	0x4b, r24
    6504:	9c a9       	sts	0x4c, r25
    6506:	a5 01       	movw	r20, r10
    6508:	94 01       	movw	r18, r8
    650a:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    650e:	ca 01       	movw	r24, r20
    6510:	b9 01       	movw	r22, r18
    6512:	21 96       	adiw	r28, 0x01	; 1
    6514:	2c ad       	sts	0x6c, r18
    6516:	3d ad       	sts	0x6d, r19
    6518:	4e ad       	sts	0x6e, r20
    651a:	5f ad       	sts	0x6f, r21
    651c:	21 97       	sbiw	r28, 0x01	; 1
    651e:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    6522:	dc 01       	movw	r26, r24
    6524:	cb 01       	movw	r24, r22
    6526:	76 01       	movw	r14, r12
    6528:	dd 24       	eor	r13, r13
    652a:	cc 24       	eor	r12, r12
    652c:	0d a5       	lds	r16, 0x6d
    652e:	1e a5       	lds	r17, 0x6e
    6530:	2f a5       	lds	r18, 0x6f
    6532:	38 a9       	sts	0x48, r19
    6534:	a9 01       	movw	r20, r18
    6536:	66 27       	eor	r22, r22
    6538:	77 27       	eor	r23, r23
    653a:	c4 2a       	or	r12, r20
    653c:	d5 2a       	or	r13, r21
    653e:	e6 2a       	or	r14, r22
    6540:	f7 2a       	or	r15, r23
    6542:	09 a5       	lds	r16, 0x69
    6544:	1a a5       	lds	r17, 0x6a
    6546:	2b a5       	lds	r18, 0x6b
    6548:	3c a5       	lds	r19, 0x6c
    654a:	c8 16       	cp	r12, r24
    654c:	d9 06       	cpc	r13, r25
    654e:	ea 06       	cpc	r14, r26
    6550:	fb 06       	cpc	r15, r27
    6552:	38 f5       	brcc	.+78     	; 0x65a2 <__stack+0x5a3>
    6554:	01 50       	subi	r16, 0x01	; 1
    6556:	10 40       	sbci	r17, 0x00	; 0
    6558:	20 40       	sbci	r18, 0x00	; 0
    655a:	30 40       	sbci	r19, 0x00	; 0
    655c:	09 ab       	sts	0x59, r16
    655e:	1a ab       	sts	0x5a, r17
    6560:	2b ab       	sts	0x5b, r18
    6562:	3c ab       	sts	0x5c, r19
    6564:	c4 0c       	add	r12, r4
    6566:	d5 1c       	adc	r13, r5
    6568:	e6 1c       	adc	r14, r6
    656a:	f7 1c       	adc	r15, r7
    656c:	c4 14       	cp	r12, r4
    656e:	d5 04       	cpc	r13, r5
    6570:	e6 04       	cpc	r14, r6
    6572:	f7 04       	cpc	r15, r7
    6574:	d0 f0       	brcs	.+52     	; 0x65aa <__stack+0x5ab>
    6576:	c8 16       	cp	r12, r24
    6578:	d9 06       	cpc	r13, r25
    657a:	ea 06       	cpc	r14, r26
    657c:	fb 06       	cpc	r15, r27
    657e:	a8 f4       	brcc	.+42     	; 0x65aa <__stack+0x5ab>
    6580:	09 a5       	lds	r16, 0x69
    6582:	1a a5       	lds	r17, 0x6a
    6584:	2b a5       	lds	r18, 0x6b
    6586:	3c a5       	lds	r19, 0x6c
    6588:	02 50       	subi	r16, 0x02	; 2
    658a:	10 40       	sbci	r17, 0x00	; 0
    658c:	20 40       	sbci	r18, 0x00	; 0
    658e:	30 40       	sbci	r19, 0x00	; 0
    6590:	09 ab       	sts	0x59, r16
    6592:	1a ab       	sts	0x5a, r17
    6594:	2b ab       	sts	0x5b, r18
    6596:	3c ab       	sts	0x5c, r19
    6598:	c4 0c       	add	r12, r4
    659a:	d5 1c       	adc	r13, r5
    659c:	e6 1c       	adc	r14, r6
    659e:	f7 1c       	adc	r15, r7
    65a0:	04 c0       	rjmp	.+8      	; 0x65aa <__stack+0x5ab>
    65a2:	09 ab       	sts	0x59, r16
    65a4:	1a ab       	sts	0x5a, r17
    65a6:	2b ab       	sts	0x5b, r18
    65a8:	3c ab       	sts	0x5c, r19
    65aa:	c8 1a       	sub	r12, r24
    65ac:	d9 0a       	sbc	r13, r25
    65ae:	ea 0a       	sbc	r14, r26
    65b0:	fb 0a       	sbc	r15, r27
    65b2:	c7 01       	movw	r24, r14
    65b4:	b6 01       	movw	r22, r12
    65b6:	a5 01       	movw	r20, r10
    65b8:	94 01       	movw	r18, r8
    65ba:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    65be:	29 a7       	lds	r18, 0x79
    65c0:	3a a7       	lds	r19, 0x7a
    65c2:	4b a7       	lds	r20, 0x7b
    65c4:	5c a7       	lds	r21, 0x7c
    65c6:	29 96       	adiw	r28, 0x09	; 9
    65c8:	6c af       	sts	0x7c, r22
    65ca:	7d af       	sts	0x7d, r23
    65cc:	8e af       	sts	0x7e, r24
    65ce:	9f af       	sts	0x7f, r25
    65d0:	29 97       	sbiw	r28, 0x09	; 9
    65d2:	c7 01       	movw	r24, r14
    65d4:	b6 01       	movw	r22, r12
    65d6:	a5 01       	movw	r20, r10
    65d8:	94 01       	movw	r18, r8
    65da:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    65de:	ca 01       	movw	r24, r20
    65e0:	b9 01       	movw	r22, r18
    65e2:	21 96       	adiw	r28, 0x01	; 1
    65e4:	2c ad       	sts	0x6c, r18
    65e6:	3d ad       	sts	0x6d, r19
    65e8:	4e ad       	sts	0x6e, r20
    65ea:	5f ad       	sts	0x6f, r21
    65ec:	21 97       	sbiw	r28, 0x01	; 1
    65ee:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    65f2:	4b 01       	movw	r8, r22
    65f4:	5c 01       	movw	r10, r24
    65f6:	29 96       	adiw	r28, 0x09	; 9
    65f8:	4c ad       	sts	0x6c, r20
    65fa:	5d ad       	sts	0x6d, r21
    65fc:	6e ad       	sts	0x6e, r22
    65fe:	7f ad       	sts	0x6f, r23
    6600:	29 97       	sbiw	r28, 0x09	; 9
    6602:	9a 01       	movw	r18, r20
    6604:	11 27       	eor	r17, r17
    6606:	00 27       	eor	r16, r16
    6608:	8d a5       	lds	r24, 0x6d
    660a:	9e a5       	lds	r25, 0x6e
    660c:	af a5       	lds	r26, 0x6f
    660e:	b8 a9       	sts	0x48, r27
    6610:	a0 70       	andi	r26, 0x00	; 0
    6612:	b0 70       	andi	r27, 0x00	; 0
    6614:	08 2b       	or	r16, r24
    6616:	19 2b       	or	r17, r25
    6618:	2a 2b       	or	r18, r26
    661a:	3b 2b       	or	r19, r27
    661c:	89 a5       	lds	r24, 0x69
    661e:	9a a5       	lds	r25, 0x6a
    6620:	ab a5       	lds	r26, 0x6b
    6622:	bc a5       	lds	r27, 0x6c
    6624:	08 15       	cp	r16, r8
    6626:	19 05       	cpc	r17, r9
    6628:	2a 05       	cpc	r18, r10
    662a:	3b 05       	cpc	r19, r11
    662c:	e0 f4       	brcc	.+56     	; 0x6666 <__stack+0x667>
    662e:	01 97       	sbiw	r24, 0x01	; 1
    6630:	a1 09       	sbc	r26, r1
    6632:	b1 09       	sbc	r27, r1
    6634:	04 0d       	add	r16, r4
    6636:	15 1d       	adc	r17, r5
    6638:	26 1d       	adc	r18, r6
    663a:	37 1d       	adc	r19, r7
    663c:	04 15       	cp	r16, r4
    663e:	15 05       	cpc	r17, r5
    6640:	26 05       	cpc	r18, r6
    6642:	37 05       	cpc	r19, r7
    6644:	80 f0       	brcs	.+32     	; 0x6666 <__stack+0x667>
    6646:	08 15       	cp	r16, r8
    6648:	19 05       	cpc	r17, r9
    664a:	2a 05       	cpc	r18, r10
    664c:	3b 05       	cpc	r19, r11
    664e:	58 f4       	brcc	.+22     	; 0x6666 <__stack+0x667>
    6650:	89 a5       	lds	r24, 0x69
    6652:	9a a5       	lds	r25, 0x6a
    6654:	ab a5       	lds	r26, 0x6b
    6656:	bc a5       	lds	r27, 0x6c
    6658:	02 97       	sbiw	r24, 0x02	; 2
    665a:	a1 09       	sbc	r26, r1
    665c:	b1 09       	sbc	r27, r1
    665e:	04 0d       	add	r16, r4
    6660:	15 1d       	adc	r17, r5
    6662:	26 1d       	adc	r18, r6
    6664:	37 1d       	adc	r19, r7
    6666:	b9 01       	movw	r22, r18
    6668:	a8 01       	movw	r20, r16
    666a:	48 19       	sub	r20, r8
    666c:	59 09       	sbc	r21, r9
    666e:	6a 09       	sbc	r22, r10
    6670:	7b 09       	sbc	r23, r11
    6672:	4d a7       	lds	r20, 0x7d
    6674:	5e a7       	lds	r21, 0x7e
    6676:	6f a7       	lds	r22, 0x7f
    6678:	78 ab       	sts	0x58, r23
    667a:	09 a9       	sts	0x49, r16
    667c:	1a a9       	sts	0x4a, r17
    667e:	2b a9       	sts	0x4b, r18
    6680:	3c a9       	sts	0x4c, r19
    6682:	78 01       	movw	r14, r16
    6684:	dd 24       	eor	r13, r13
    6686:	cc 24       	eor	r12, r12
    6688:	c8 2a       	or	r12, r24
    668a:	d9 2a       	or	r13, r25
    668c:	ea 2a       	or	r14, r26
    668e:	fb 2a       	or	r15, r27
    6690:	ff ef       	ldi	r31, 0xFF	; 255
    6692:	8f 2e       	mov	r8, r31
    6694:	ff ef       	ldi	r31, 0xFF	; 255
    6696:	9f 2e       	mov	r9, r31
    6698:	a1 2c       	mov	r10, r1
    669a:	b1 2c       	mov	r11, r1
    669c:	8c 20       	and	r8, r12
    669e:	9d 20       	and	r9, r13
    66a0:	ae 20       	and	r10, r14
    66a2:	bf 20       	and	r11, r15
    66a4:	87 01       	movw	r16, r14
    66a6:	22 27       	eor	r18, r18
    66a8:	33 27       	eor	r19, r19
    66aa:	09 a7       	lds	r16, 0x79
    66ac:	1a a7       	lds	r17, 0x7a
    66ae:	2b a7       	lds	r18, 0x7b
    66b0:	3c a7       	lds	r19, 0x7c
    66b2:	49 ac       	sts	0xa9, r20
    66b4:	5a ac       	sts	0xaa, r21
    66b6:	6b ac       	sts	0xab, r22
    66b8:	7c ac       	sts	0xac, r23
    66ba:	2f ef       	ldi	r18, 0xFF	; 255
    66bc:	3f ef       	ldi	r19, 0xFF	; 255
    66be:	40 e0       	ldi	r20, 0x00	; 0
    66c0:	50 e0       	ldi	r21, 0x00	; 0
    66c2:	42 22       	and	r4, r18
    66c4:	53 22       	and	r5, r19
    66c6:	64 22       	and	r6, r20
    66c8:	75 22       	and	r7, r21
    66ca:	29 ad       	sts	0x69, r18
    66cc:	3a ad       	sts	0x6a, r19
    66ce:	4b ad       	sts	0x6b, r20
    66d0:	5c ad       	sts	0x6c, r21
    66d2:	8a 01       	movw	r16, r20
    66d4:	22 27       	eor	r18, r18
    66d6:	33 27       	eor	r19, r19
    66d8:	09 ab       	sts	0x59, r16
    66da:	1a ab       	sts	0x5a, r17
    66dc:	2b ab       	sts	0x5b, r18
    66de:	3c ab       	sts	0x5c, r19
    66e0:	c5 01       	movw	r24, r10
    66e2:	b4 01       	movw	r22, r8
    66e4:	a3 01       	movw	r20, r6
    66e6:	92 01       	movw	r18, r4
    66e8:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    66ec:	69 af       	sts	0x79, r22
    66ee:	7a af       	sts	0x7a, r23
    66f0:	8b af       	sts	0x7b, r24
    66f2:	9c af       	sts	0x7c, r25
    66f4:	c5 01       	movw	r24, r10
    66f6:	b4 01       	movw	r22, r8
    66f8:	29 a9       	sts	0x49, r18
    66fa:	3a a9       	sts	0x4a, r19
    66fc:	4b a9       	sts	0x4b, r20
    66fe:	5c a9       	sts	0x4c, r21
    6700:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    6704:	4b 01       	movw	r8, r22
    6706:	5c 01       	movw	r10, r24
    6708:	69 a5       	lds	r22, 0x69
    670a:	7a a5       	lds	r23, 0x6a
    670c:	8b a5       	lds	r24, 0x6b
    670e:	9c a5       	lds	r25, 0x6c
    6710:	a3 01       	movw	r20, r6
    6712:	92 01       	movw	r18, r4
    6714:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    6718:	2b 01       	movw	r4, r22
    671a:	3c 01       	movw	r6, r24
    671c:	69 a5       	lds	r22, 0x69
    671e:	7a a5       	lds	r23, 0x6a
    6720:	8b a5       	lds	r24, 0x6b
    6722:	9c a5       	lds	r25, 0x6c
    6724:	29 a9       	sts	0x49, r18
    6726:	3a a9       	sts	0x4a, r19
    6728:	4b a9       	sts	0x4b, r20
    672a:	5c a9       	sts	0x4c, r21
    672c:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <__mulsi3>
    6730:	ab 01       	movw	r20, r22
    6732:	bc 01       	movw	r22, r24
    6734:	84 0c       	add	r8, r4
    6736:	95 1c       	adc	r9, r5
    6738:	a6 1c       	adc	r10, r6
    673a:	b7 1c       	adc	r11, r7
    673c:	09 ad       	sts	0x69, r16
    673e:	1a ad       	sts	0x6a, r17
    6740:	2b ad       	sts	0x6b, r18
    6742:	3c ad       	sts	0x6c, r19
    6744:	c9 01       	movw	r24, r18
    6746:	aa 27       	eor	r26, r26
    6748:	bb 27       	eor	r27, r27
    674a:	88 0e       	add	r8, r24
    674c:	99 1e       	adc	r9, r25
    674e:	aa 1e       	adc	r10, r26
    6750:	bb 1e       	adc	r11, r27
    6752:	84 14       	cp	r8, r4
    6754:	95 04       	cpc	r9, r5
    6756:	a6 04       	cpc	r10, r6
    6758:	b7 04       	cpc	r11, r7
    675a:	20 f4       	brcc	.+8      	; 0x6764 <__stack+0x765>
    675c:	40 50       	subi	r20, 0x00	; 0
    675e:	50 40       	sbci	r21, 0x00	; 0
    6760:	6f 4f       	sbci	r22, 0xFF	; 255
    6762:	7f 4f       	sbci	r23, 0xFF	; 255
    6764:	c5 01       	movw	r24, r10
    6766:	aa 27       	eor	r26, r26
    6768:	bb 27       	eor	r27, r27
    676a:	84 0f       	add	r24, r20
    676c:	95 1f       	adc	r25, r21
    676e:	a6 1f       	adc	r26, r22
    6770:	b7 1f       	adc	r27, r23
    6772:	0d a5       	lds	r16, 0x6d
    6774:	1e a5       	lds	r17, 0x6e
    6776:	2f a5       	lds	r18, 0x6f
    6778:	38 a9       	sts	0x48, r19
    677a:	08 17       	cp	r16, r24
    677c:	19 07       	cpc	r17, r25
    677e:	2a 07       	cpc	r18, r26
    6780:	3b 07       	cpc	r19, r27
    6782:	18 f1       	brcs	.+70     	; 0x67ca <__stack+0x7cb>
    6784:	80 17       	cp	r24, r16
    6786:	91 07       	cpc	r25, r17
    6788:	a2 07       	cpc	r26, r18
    678a:	b3 07       	cpc	r27, r19
    678c:	a1 f5       	brne	.+104    	; 0x67f6 <__stack+0x7f7>
    678e:	54 01       	movw	r10, r8
    6790:	99 24       	eor	r9, r9
    6792:	88 24       	eor	r8, r8
    6794:	89 ad       	sts	0x69, r24
    6796:	9a ad       	sts	0x6a, r25
    6798:	ab ad       	sts	0x6b, r26
    679a:	bc ad       	sts	0x6c, r27
    679c:	a0 70       	andi	r26, 0x00	; 0
    679e:	b0 70       	andi	r27, 0x00	; 0
    67a0:	88 0e       	add	r8, r24
    67a2:	99 1e       	adc	r9, r25
    67a4:	aa 1e       	adc	r10, r26
    67a6:	bb 1e       	adc	r11, r27
    67a8:	4d a9       	sts	0x4d, r20
    67aa:	5e a9       	sts	0x4e, r21
    67ac:	6f a9       	sts	0x4f, r22
    67ae:	78 ad       	sts	0x68, r23
    67b0:	03 2c       	mov	r0, r3
    67b2:	04 c0       	rjmp	.+8      	; 0x67bc <__stack+0x7bd>
    67b4:	44 0f       	add	r20, r20
    67b6:	55 1f       	adc	r21, r21
    67b8:	66 1f       	adc	r22, r22
    67ba:	77 1f       	adc	r23, r23
    67bc:	0a 94       	dec	r0
    67be:	d2 f7       	brpl	.-12     	; 0x67b4 <__stack+0x7b5>
    67c0:	48 15       	cp	r20, r8
    67c2:	59 05       	cpc	r21, r9
    67c4:	6a 05       	cpc	r22, r10
    67c6:	7b 05       	cpc	r23, r11
    67c8:	b0 f4       	brcc	.+44     	; 0x67f6 <__stack+0x7f7>
    67ca:	08 94       	sec
    67cc:	c1 08       	sbc	r12, r1
    67ce:	d1 08       	sbc	r13, r1
    67d0:	e1 08       	sbc	r14, r1
    67d2:	f1 08       	sbc	r15, r1
    67d4:	10 c0       	rjmp	.+32     	; 0x67f6 <__stack+0x7f7>
    67d6:	44 24       	eor	r4, r4
    67d8:	55 24       	eor	r5, r5
    67da:	32 01       	movw	r6, r4
    67dc:	cc 24       	eor	r12, r12
    67de:	dd 24       	eor	r13, r13
    67e0:	76 01       	movw	r14, r12
    67e2:	0c c0       	rjmp	.+24     	; 0x67fc <__stack+0x7fd>
    67e4:	44 24       	eor	r4, r4
    67e6:	55 24       	eor	r5, r5
    67e8:	32 01       	movw	r6, r4
    67ea:	81 e0       	ldi	r24, 0x01	; 1
    67ec:	c8 2e       	mov	r12, r24
    67ee:	d1 2c       	mov	r13, r1
    67f0:	e1 2c       	mov	r14, r1
    67f2:	f1 2c       	mov	r15, r1
    67f4:	03 c0       	rjmp	.+6      	; 0x67fc <__stack+0x7fd>
    67f6:	44 24       	eor	r4, r4
    67f8:	55 24       	eor	r5, r5
    67fa:	32 01       	movw	r6, r4
    67fc:	fe 01       	movw	r30, r28
    67fe:	31 96       	adiw	r30, 0x01	; 1
    6800:	88 e0       	ldi	r24, 0x08	; 8
    6802:	df 01       	movw	r26, r30
    6804:	1d 92       	st	X+, r1
    6806:	8a 95       	dec	r24
    6808:	e9 f7       	brne	.-6      	; 0x6804 <__stack+0x805>
    680a:	c9 82       	std	Y+1, r12	; 0x01
    680c:	da 82       	std	Y+2, r13	; 0x02
    680e:	eb 82       	std	Y+3, r14	; 0x03
    6810:	fc 82       	std	Y+4, r15	; 0x04
    6812:	4d 82       	std	Y+5, r4	; 0x05
    6814:	5e 82       	std	Y+6, r5	; 0x06
    6816:	6f 82       	std	Y+7, r6	; 0x07
    6818:	78 86       	std	Y+8, r7	; 0x08
    681a:	2c 2d       	mov	r18, r12
    681c:	3a 81       	ldd	r19, Y+2	; 0x02
    681e:	4b 81       	ldd	r20, Y+3	; 0x03
    6820:	5c 81       	ldd	r21, Y+4	; 0x04
    6822:	64 2d       	mov	r22, r4
    6824:	7e 81       	ldd	r23, Y+6	; 0x06
    6826:	8f 81       	ldd	r24, Y+7	; 0x07
    6828:	98 85       	ldd	r25, Y+8	; 0x08
    682a:	25 96       	adiw	r28, 0x05	; 5
    682c:	ec ac       	sts	0xac, r30
    682e:	fd ac       	sts	0xad, r31
    6830:	0e ad       	sts	0x6e, r16
    6832:	1f ad       	sts	0x6f, r17
    6834:	25 97       	sbiw	r28, 0x05	; 5
    6836:	e1 14       	cp	r14, r1
    6838:	f1 04       	cpc	r15, r1
    683a:	01 05       	cpc	r16, r1
    683c:	11 05       	cpc	r17, r1
    683e:	09 f4       	brne	.+2      	; 0x6842 <__stack+0x843>
    6840:	56 c0       	rjmp	.+172    	; 0x68ee <__stack+0x8ef>
    6842:	21 95       	neg	r18
    6844:	e1 e0       	ldi	r30, 0x01	; 1
    6846:	12 16       	cp	r1, r18
    6848:	08 f0       	brcs	.+2      	; 0x684c <__stack+0x84d>
    684a:	e0 e0       	ldi	r30, 0x00	; 0
    684c:	31 95       	neg	r19
    684e:	f1 e0       	ldi	r31, 0x01	; 1
    6850:	13 16       	cp	r1, r19
    6852:	08 f0       	brcs	.+2      	; 0x6856 <__stack+0x857>
    6854:	f0 e0       	ldi	r31, 0x00	; 0
    6856:	03 2f       	mov	r16, r19
    6858:	0e 1b       	sub	r16, r30
    685a:	e1 e0       	ldi	r30, 0x01	; 1
    685c:	30 17       	cp	r19, r16
    685e:	08 f0       	brcs	.+2      	; 0x6862 <__stack+0x863>
    6860:	e0 e0       	ldi	r30, 0x00	; 0
    6862:	fe 2b       	or	r31, r30
    6864:	41 95       	neg	r20
    6866:	e1 e0       	ldi	r30, 0x01	; 1
    6868:	14 16       	cp	r1, r20
    686a:	08 f0       	brcs	.+2      	; 0x686e <__stack+0x86f>
    686c:	e0 e0       	ldi	r30, 0x00	; 0
    686e:	14 2f       	mov	r17, r20
    6870:	1f 1b       	sub	r17, r31
    6872:	31 e0       	ldi	r19, 0x01	; 1
    6874:	41 17       	cp	r20, r17
    6876:	08 f0       	brcs	.+2      	; 0x687a <__stack+0x87b>
    6878:	30 e0       	ldi	r19, 0x00	; 0
    687a:	e3 2b       	or	r30, r19
    687c:	51 95       	neg	r21
    687e:	f1 e0       	ldi	r31, 0x01	; 1
    6880:	15 16       	cp	r1, r21
    6882:	08 f0       	brcs	.+2      	; 0x6886 <__stack+0x887>
    6884:	f0 e0       	ldi	r31, 0x00	; 0
    6886:	b5 2f       	mov	r27, r21
    6888:	be 1b       	sub	r27, r30
    688a:	31 e0       	ldi	r19, 0x01	; 1
    688c:	5b 17       	cp	r21, r27
    688e:	08 f0       	brcs	.+2      	; 0x6892 <__stack+0x893>
    6890:	30 e0       	ldi	r19, 0x00	; 0
    6892:	f3 2b       	or	r31, r19
    6894:	61 95       	neg	r22
    6896:	e1 e0       	ldi	r30, 0x01	; 1
    6898:	16 16       	cp	r1, r22
    689a:	08 f0       	brcs	.+2      	; 0x689e <__stack+0x89f>
    689c:	e0 e0       	ldi	r30, 0x00	; 0
    689e:	46 2e       	mov	r4, r22
    68a0:	4f 1a       	sub	r4, r31
    68a2:	31 e0       	ldi	r19, 0x01	; 1
    68a4:	64 15       	cp	r22, r4
    68a6:	08 f0       	brcs	.+2      	; 0x68aa <__stack+0x8ab>
    68a8:	30 e0       	ldi	r19, 0x00	; 0
    68aa:	e3 2b       	or	r30, r19
    68ac:	71 95       	neg	r23
    68ae:	f1 e0       	ldi	r31, 0x01	; 1
    68b0:	17 16       	cp	r1, r23
    68b2:	08 f0       	brcs	.+2      	; 0x68b6 <__stack+0x8b7>
    68b4:	f0 e0       	ldi	r31, 0x00	; 0
    68b6:	a7 2f       	mov	r26, r23
    68b8:	ae 1b       	sub	r26, r30
    68ba:	31 e0       	ldi	r19, 0x01	; 1
    68bc:	7a 17       	cp	r23, r26
    68be:	08 f0       	brcs	.+2      	; 0x68c2 <__stack+0x8c3>
    68c0:	30 e0       	ldi	r19, 0x00	; 0
    68c2:	f3 2b       	or	r31, r19
    68c4:	81 95       	neg	r24
    68c6:	e1 e0       	ldi	r30, 0x01	; 1
    68c8:	18 16       	cp	r1, r24
    68ca:	08 f0       	brcs	.+2      	; 0x68ce <__stack+0x8cf>
    68cc:	e0 e0       	ldi	r30, 0x00	; 0
    68ce:	f8 2e       	mov	r15, r24
    68d0:	ff 1a       	sub	r15, r31
    68d2:	ff 2d       	mov	r31, r15
    68d4:	31 e0       	ldi	r19, 0x01	; 1
    68d6:	8f 15       	cp	r24, r15
    68d8:	08 f0       	brcs	.+2      	; 0x68dc <__stack+0x8dd>
    68da:	30 e0       	ldi	r19, 0x00	; 0
    68dc:	e3 2b       	or	r30, r19
    68de:	91 95       	neg	r25
    68e0:	30 2f       	mov	r19, r16
    68e2:	41 2f       	mov	r20, r17
    68e4:	5b 2f       	mov	r21, r27
    68e6:	64 2d       	mov	r22, r4
    68e8:	7a 2f       	mov	r23, r26
    68ea:	8f 2f       	mov	r24, r31
    68ec:	9e 1b       	sub	r25, r30
    68ee:	c8 5b       	subi	r28, 0xB8	; 184
    68f0:	df 4f       	sbci	r29, 0xFF	; 255
    68f2:	e1 e1       	ldi	r30, 0x11	; 17
    68f4:	0c 94 19 35 	jmp	0x6a32	; 0x6a32 <__epilogue_restores__+0x2>

000068f8 <__mulsi3>:
    68f8:	62 9f       	mul	r22, r18
    68fa:	d0 01       	movw	r26, r0
    68fc:	73 9f       	mul	r23, r19
    68fe:	f0 01       	movw	r30, r0
    6900:	82 9f       	mul	r24, r18
    6902:	e0 0d       	add	r30, r0
    6904:	f1 1d       	adc	r31, r1
    6906:	64 9f       	mul	r22, r20
    6908:	e0 0d       	add	r30, r0
    690a:	f1 1d       	adc	r31, r1
    690c:	92 9f       	mul	r25, r18
    690e:	f0 0d       	add	r31, r0
    6910:	83 9f       	mul	r24, r19
    6912:	f0 0d       	add	r31, r0
    6914:	74 9f       	mul	r23, r20
    6916:	f0 0d       	add	r31, r0
    6918:	65 9f       	mul	r22, r21
    691a:	f0 0d       	add	r31, r0
    691c:	99 27       	eor	r25, r25
    691e:	72 9f       	mul	r23, r18
    6920:	b0 0d       	add	r27, r0
    6922:	e1 1d       	adc	r30, r1
    6924:	f9 1f       	adc	r31, r25
    6926:	63 9f       	mul	r22, r19
    6928:	b0 0d       	add	r27, r0
    692a:	e1 1d       	adc	r30, r1
    692c:	f9 1f       	adc	r31, r25
    692e:	bd 01       	movw	r22, r26
    6930:	cf 01       	movw	r24, r30
    6932:	11 24       	eor	r1, r1
    6934:	08 95       	ret

00006936 <__udivmodhi4>:
    6936:	aa 1b       	sub	r26, r26
    6938:	bb 1b       	sub	r27, r27
    693a:	51 e1       	ldi	r21, 0x11	; 17
    693c:	07 c0       	rjmp	.+14     	; 0x694c <__udivmodhi4_ep>

0000693e <__udivmodhi4_loop>:
    693e:	aa 1f       	adc	r26, r26
    6940:	bb 1f       	adc	r27, r27
    6942:	a6 17       	cp	r26, r22
    6944:	b7 07       	cpc	r27, r23
    6946:	10 f0       	brcs	.+4      	; 0x694c <__udivmodhi4_ep>
    6948:	a6 1b       	sub	r26, r22
    694a:	b7 0b       	sbc	r27, r23

0000694c <__udivmodhi4_ep>:
    694c:	88 1f       	adc	r24, r24
    694e:	99 1f       	adc	r25, r25
    6950:	5a 95       	dec	r21
    6952:	a9 f7       	brne	.-22     	; 0x693e <__udivmodhi4_loop>
    6954:	80 95       	com	r24
    6956:	90 95       	com	r25
    6958:	bc 01       	movw	r22, r24
    695a:	cd 01       	movw	r24, r26
    695c:	08 95       	ret

0000695e <__divmodhi4>:
    695e:	97 fb       	bst	r25, 7
    6960:	09 2e       	mov	r0, r25
    6962:	07 26       	eor	r0, r23
    6964:	0a d0       	rcall	.+20     	; 0x697a <__divmodhi4_neg1>
    6966:	77 fd       	sbrc	r23, 7
    6968:	04 d0       	rcall	.+8      	; 0x6972 <__divmodhi4_neg2>
    696a:	e5 df       	rcall	.-54     	; 0x6936 <__udivmodhi4>
    696c:	06 d0       	rcall	.+12     	; 0x697a <__divmodhi4_neg1>
    696e:	00 20       	and	r0, r0
    6970:	1a f4       	brpl	.+6      	; 0x6978 <__divmodhi4_exit>

00006972 <__divmodhi4_neg2>:
    6972:	70 95       	com	r23
    6974:	61 95       	neg	r22
    6976:	7f 4f       	sbci	r23, 0xFF	; 255

00006978 <__divmodhi4_exit>:
    6978:	08 95       	ret

0000697a <__divmodhi4_neg1>:
    697a:	f6 f7       	brtc	.-4      	; 0x6978 <__divmodhi4_exit>
    697c:	90 95       	com	r25
    697e:	81 95       	neg	r24
    6980:	9f 4f       	sbci	r25, 0xFF	; 255
    6982:	08 95       	ret

00006984 <__udivmodsi4>:
    6984:	a1 e2       	ldi	r26, 0x21	; 33
    6986:	1a 2e       	mov	r1, r26
    6988:	aa 1b       	sub	r26, r26
    698a:	bb 1b       	sub	r27, r27
    698c:	fd 01       	movw	r30, r26
    698e:	0d c0       	rjmp	.+26     	; 0x69aa <__udivmodsi4_ep>

00006990 <__udivmodsi4_loop>:
    6990:	aa 1f       	adc	r26, r26
    6992:	bb 1f       	adc	r27, r27
    6994:	ee 1f       	adc	r30, r30
    6996:	ff 1f       	adc	r31, r31
    6998:	a2 17       	cp	r26, r18
    699a:	b3 07       	cpc	r27, r19
    699c:	e4 07       	cpc	r30, r20
    699e:	f5 07       	cpc	r31, r21
    69a0:	20 f0       	brcs	.+8      	; 0x69aa <__udivmodsi4_ep>
    69a2:	a2 1b       	sub	r26, r18
    69a4:	b3 0b       	sbc	r27, r19
    69a6:	e4 0b       	sbc	r30, r20
    69a8:	f5 0b       	sbc	r31, r21

000069aa <__udivmodsi4_ep>:
    69aa:	66 1f       	adc	r22, r22
    69ac:	77 1f       	adc	r23, r23
    69ae:	88 1f       	adc	r24, r24
    69b0:	99 1f       	adc	r25, r25
    69b2:	1a 94       	dec	r1
    69b4:	69 f7       	brne	.-38     	; 0x6990 <__udivmodsi4_loop>
    69b6:	60 95       	com	r22
    69b8:	70 95       	com	r23
    69ba:	80 95       	com	r24
    69bc:	90 95       	com	r25
    69be:	9b 01       	movw	r18, r22
    69c0:	ac 01       	movw	r20, r24
    69c2:	bd 01       	movw	r22, r26
    69c4:	cf 01       	movw	r24, r30
    69c6:	08 95       	ret

000069c8 <__divmodsi4>:
    69c8:	97 fb       	bst	r25, 7
    69ca:	09 2e       	mov	r0, r25
    69cc:	05 26       	eor	r0, r21
    69ce:	0e d0       	rcall	.+28     	; 0x69ec <__divmodsi4_neg1>
    69d0:	57 fd       	sbrc	r21, 7
    69d2:	04 d0       	rcall	.+8      	; 0x69dc <__divmodsi4_neg2>
    69d4:	d7 df       	rcall	.-82     	; 0x6984 <__udivmodsi4>
    69d6:	0a d0       	rcall	.+20     	; 0x69ec <__divmodsi4_neg1>
    69d8:	00 1c       	adc	r0, r0
    69da:	38 f4       	brcc	.+14     	; 0x69ea <__divmodsi4_exit>

000069dc <__divmodsi4_neg2>:
    69dc:	50 95       	com	r21
    69de:	40 95       	com	r20
    69e0:	30 95       	com	r19
    69e2:	21 95       	neg	r18
    69e4:	3f 4f       	sbci	r19, 0xFF	; 255
    69e6:	4f 4f       	sbci	r20, 0xFF	; 255
    69e8:	5f 4f       	sbci	r21, 0xFF	; 255

000069ea <__divmodsi4_exit>:
    69ea:	08 95       	ret

000069ec <__divmodsi4_neg1>:
    69ec:	f6 f7       	brtc	.-4      	; 0x69ea <__divmodsi4_exit>
    69ee:	90 95       	com	r25
    69f0:	80 95       	com	r24
    69f2:	70 95       	com	r23
    69f4:	61 95       	neg	r22
    69f6:	7f 4f       	sbci	r23, 0xFF	; 255
    69f8:	8f 4f       	sbci	r24, 0xFF	; 255
    69fa:	9f 4f       	sbci	r25, 0xFF	; 255
    69fc:	08 95       	ret

000069fe <__prologue_saves__>:
    69fe:	2f 92       	push	r2
    6a00:	3f 92       	push	r3
    6a02:	4f 92       	push	r4
    6a04:	5f 92       	push	r5
    6a06:	6f 92       	push	r6
    6a08:	7f 92       	push	r7
    6a0a:	8f 92       	push	r8
    6a0c:	9f 92       	push	r9
    6a0e:	af 92       	push	r10
    6a10:	bf 92       	push	r11
    6a12:	cf 92       	push	r12
    6a14:	df 92       	push	r13
    6a16:	ef 92       	push	r14
    6a18:	ff 92       	push	r15
    6a1a:	0f 93       	push	r16
    6a1c:	1f 93       	push	r17
    6a1e:	cf 93       	push	r28
    6a20:	df 93       	push	r29
    6a22:	cd b7       	in	r28, 0x3d	; 61
    6a24:	de b7       	in	r29, 0x3e	; 62
    6a26:	ca 1b       	sub	r28, r26
    6a28:	db 0b       	sbc	r29, r27
    6a2a:	cd bf       	out	0x3d, r28	; 61
    6a2c:	de bf       	out	0x3e, r29	; 62
    6a2e:	19 94       	eijmp

00006a30 <__epilogue_restores__>:
    6a30:	2a 88       	ldd	r2, Y+18	; 0x12
    6a32:	39 88       	ldd	r3, Y+17	; 0x11
    6a34:	48 88       	ldd	r4, Y+16	; 0x10
    6a36:	5f 84       	ldd	r5, Y+15	; 0x0f
    6a38:	6e 84       	ldd	r6, Y+14	; 0x0e
    6a3a:	7d 84       	ldd	r7, Y+13	; 0x0d
    6a3c:	8c 84       	ldd	r8, Y+12	; 0x0c
    6a3e:	9b 84       	ldd	r9, Y+11	; 0x0b
    6a40:	aa 84       	ldd	r10, Y+10	; 0x0a
    6a42:	b9 84       	ldd	r11, Y+9	; 0x09
    6a44:	c8 84       	ldd	r12, Y+8	; 0x08
    6a46:	df 80       	ldd	r13, Y+7	; 0x07
    6a48:	ee 80       	ldd	r14, Y+6	; 0x06
    6a4a:	fd 80       	ldd	r15, Y+5	; 0x05
    6a4c:	0c 81       	ldd	r16, Y+4	; 0x04
    6a4e:	1b 81       	ldd	r17, Y+3	; 0x03
    6a50:	aa 81       	ldd	r26, Y+2	; 0x02
    6a52:	b9 81       	ldd	r27, Y+1	; 0x01
    6a54:	ce 0f       	add	r28, r30
    6a56:	d1 1d       	adc	r29, r1
    6a58:	cd bf       	out	0x3d, r28	; 61
    6a5a:	de bf       	out	0x3e, r29	; 62
    6a5c:	ed 01       	movw	r28, r26
    6a5e:	08 95       	ret

00006a60 <strcpy_P>:
    6a60:	fb 01       	movw	r30, r22
    6a62:	dc 01       	movw	r26, r24
    6a64:	05 90       	lpm	r0, Z+
    6a66:	0d 92       	st	X+, r0
    6a68:	00 20       	and	r0, r0
    6a6a:	e1 f7       	brne	.-8      	; 0x6a64 <strcpy_P+0x4>
    6a6c:	08 95       	ret

00006a6e <memmove>:
    6a6e:	68 17       	cp	r22, r24
    6a70:	79 07       	cpc	r23, r25
    6a72:	68 f4       	brcc	.+26     	; 0x6a8e <memmove+0x20>
    6a74:	fb 01       	movw	r30, r22
    6a76:	dc 01       	movw	r26, r24
    6a78:	e4 0f       	add	r30, r20
    6a7a:	f5 1f       	adc	r31, r21
    6a7c:	a4 0f       	add	r26, r20
    6a7e:	b5 1f       	adc	r27, r21
    6a80:	02 c0       	rjmp	.+4      	; 0x6a86 <memmove+0x18>
    6a82:	02 90       	ld	r0, -Z
    6a84:	0e 92       	st	-X, r0
    6a86:	41 50       	subi	r20, 0x01	; 1
    6a88:	50 40       	sbci	r21, 0x00	; 0
    6a8a:	d8 f7       	brcc	.-10     	; 0x6a82 <memmove+0x14>
    6a8c:	08 95       	ret
    6a8e:	0c 94 67 37 	jmp	0x6ece	; 0x6ece <memcpy>

00006a92 <printf>:
    6a92:	cf 93       	push	r28
    6a94:	df 93       	push	r29
    6a96:	cd b7       	in	r28, 0x3d	; 61
    6a98:	de b7       	in	r29, 0x3e	; 62
    6a9a:	fe 01       	movw	r30, r28
    6a9c:	36 96       	adiw	r30, 0x06	; 6
    6a9e:	61 91       	ld	r22, Z+
    6aa0:	71 91       	ld	r23, Z+
    6aa2:	80 91 a4 50 	lds	r24, 0x50A4
    6aa6:	90 91 a5 50 	lds	r25, 0x50A5
    6aaa:	af 01       	movw	r20, r30
    6aac:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <vfprintf>
    6ab0:	df 91       	pop	r29
    6ab2:	cf 91       	pop	r28
    6ab4:	08 95       	ret

00006ab6 <vfprintf>:
    6ab6:	2f 92       	push	r2
    6ab8:	3f 92       	push	r3
    6aba:	4f 92       	push	r4
    6abc:	5f 92       	push	r5
    6abe:	6f 92       	push	r6
    6ac0:	7f 92       	push	r7
    6ac2:	8f 92       	push	r8
    6ac4:	9f 92       	push	r9
    6ac6:	af 92       	push	r10
    6ac8:	bf 92       	push	r11
    6aca:	cf 92       	push	r12
    6acc:	df 92       	push	r13
    6ace:	ef 92       	push	r14
    6ad0:	ff 92       	push	r15
    6ad2:	0f 93       	push	r16
    6ad4:	1f 93       	push	r17
    6ad6:	cf 93       	push	r28
    6ad8:	df 93       	push	r29
    6ada:	cd b7       	in	r28, 0x3d	; 61
    6adc:	de b7       	in	r29, 0x3e	; 62
    6ade:	2d 97       	sbiw	r28, 0x0d	; 13
    6ae0:	cd bf       	out	0x3d, r28	; 61
    6ae2:	de bf       	out	0x3e, r29	; 62
    6ae4:	3c 01       	movw	r6, r24
    6ae6:	6c 87       	std	Y+12, r22	; 0x0c
    6ae8:	7d 87       	std	Y+13, r23	; 0x0d
    6aea:	5a 01       	movw	r10, r20
    6aec:	fc 01       	movw	r30, r24
    6aee:	16 82       	std	Z+6, r1	; 0x06
    6af0:	17 82       	std	Z+7, r1	; 0x07
    6af2:	83 81       	ldd	r24, Z+3	; 0x03
    6af4:	81 ff       	sbrs	r24, 1
    6af6:	c8 c1       	rjmp	.+912    	; 0x6e88 <vfprintf+0x3d2>
    6af8:	2e 01       	movw	r4, r28
    6afa:	08 94       	sec
    6afc:	41 1c       	adc	r4, r1
    6afe:	51 1c       	adc	r5, r1
    6b00:	f3 01       	movw	r30, r6
    6b02:	93 81       	ldd	r25, Z+3	; 0x03
    6b04:	ec 85       	ldd	r30, Y+12	; 0x0c
    6b06:	fd 85       	ldd	r31, Y+13	; 0x0d
    6b08:	93 fd       	sbrc	r25, 3
    6b0a:	85 91       	lpm	r24, Z+
    6b0c:	93 ff       	sbrs	r25, 3
    6b0e:	81 91       	ld	r24, Z+
    6b10:	ec 87       	std	Y+12, r30	; 0x0c
    6b12:	fd 87       	std	Y+13, r31	; 0x0d
    6b14:	88 23       	and	r24, r24
    6b16:	09 f4       	brne	.+2      	; 0x6b1a <vfprintf+0x64>
    6b18:	b3 c1       	rjmp	.+870    	; 0x6e80 <vfprintf+0x3ca>
    6b1a:	85 32       	cpi	r24, 0x25	; 37
    6b1c:	41 f4       	brne	.+16     	; 0x6b2e <vfprintf+0x78>
    6b1e:	93 fd       	sbrc	r25, 3
    6b20:	85 91       	lpm	r24, Z+
    6b22:	93 ff       	sbrs	r25, 3
    6b24:	81 91       	ld	r24, Z+
    6b26:	ec 87       	std	Y+12, r30	; 0x0c
    6b28:	fd 87       	std	Y+13, r31	; 0x0d
    6b2a:	85 32       	cpi	r24, 0x25	; 37
    6b2c:	29 f4       	brne	.+10     	; 0x6b38 <vfprintf+0x82>
    6b2e:	90 e0       	ldi	r25, 0x00	; 0
    6b30:	b3 01       	movw	r22, r6
    6b32:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6b36:	e4 cf       	rjmp	.-56     	; 0x6b00 <vfprintf+0x4a>
    6b38:	ff 24       	eor	r15, r15
    6b3a:	ee 24       	eor	r14, r14
    6b3c:	10 e0       	ldi	r17, 0x00	; 0
    6b3e:	10 32       	cpi	r17, 0x20	; 32
    6b40:	b0 f4       	brcc	.+44     	; 0x6b6e <vfprintf+0xb8>
    6b42:	8b 32       	cpi	r24, 0x2B	; 43
    6b44:	69 f0       	breq	.+26     	; 0x6b60 <vfprintf+0xaa>
    6b46:	8c 32       	cpi	r24, 0x2C	; 44
    6b48:	28 f4       	brcc	.+10     	; 0x6b54 <vfprintf+0x9e>
    6b4a:	80 32       	cpi	r24, 0x20	; 32
    6b4c:	51 f0       	breq	.+20     	; 0x6b62 <vfprintf+0xac>
    6b4e:	83 32       	cpi	r24, 0x23	; 35
    6b50:	71 f4       	brne	.+28     	; 0x6b6e <vfprintf+0xb8>
    6b52:	0b c0       	rjmp	.+22     	; 0x6b6a <vfprintf+0xb4>
    6b54:	8d 32       	cpi	r24, 0x2D	; 45
    6b56:	39 f0       	breq	.+14     	; 0x6b66 <vfprintf+0xb0>
    6b58:	80 33       	cpi	r24, 0x30	; 48
    6b5a:	49 f4       	brne	.+18     	; 0x6b6e <vfprintf+0xb8>
    6b5c:	11 60       	ori	r17, 0x01	; 1
    6b5e:	2c c0       	rjmp	.+88     	; 0x6bb8 <vfprintf+0x102>
    6b60:	12 60       	ori	r17, 0x02	; 2
    6b62:	14 60       	ori	r17, 0x04	; 4
    6b64:	29 c0       	rjmp	.+82     	; 0x6bb8 <vfprintf+0x102>
    6b66:	18 60       	ori	r17, 0x08	; 8
    6b68:	27 c0       	rjmp	.+78     	; 0x6bb8 <vfprintf+0x102>
    6b6a:	10 61       	ori	r17, 0x10	; 16
    6b6c:	25 c0       	rjmp	.+74     	; 0x6bb8 <vfprintf+0x102>
    6b6e:	17 fd       	sbrc	r17, 7
    6b70:	2e c0       	rjmp	.+92     	; 0x6bce <vfprintf+0x118>
    6b72:	28 2f       	mov	r18, r24
    6b74:	20 53       	subi	r18, 0x30	; 48
    6b76:	2a 30       	cpi	r18, 0x0A	; 10
    6b78:	98 f4       	brcc	.+38     	; 0x6ba0 <vfprintf+0xea>
    6b7a:	16 ff       	sbrs	r17, 6
    6b7c:	08 c0       	rjmp	.+16     	; 0x6b8e <vfprintf+0xd8>
    6b7e:	8f 2d       	mov	r24, r15
    6b80:	88 0f       	add	r24, r24
    6b82:	f8 2e       	mov	r15, r24
    6b84:	ff 0c       	add	r15, r15
    6b86:	ff 0c       	add	r15, r15
    6b88:	f8 0e       	add	r15, r24
    6b8a:	f2 0e       	add	r15, r18
    6b8c:	15 c0       	rjmp	.+42     	; 0x6bb8 <vfprintf+0x102>
    6b8e:	8e 2d       	mov	r24, r14
    6b90:	88 0f       	add	r24, r24
    6b92:	e8 2e       	mov	r14, r24
    6b94:	ee 0c       	add	r14, r14
    6b96:	ee 0c       	add	r14, r14
    6b98:	e8 0e       	add	r14, r24
    6b9a:	e2 0e       	add	r14, r18
    6b9c:	10 62       	ori	r17, 0x20	; 32
    6b9e:	0c c0       	rjmp	.+24     	; 0x6bb8 <vfprintf+0x102>
    6ba0:	8e 32       	cpi	r24, 0x2E	; 46
    6ba2:	21 f4       	brne	.+8      	; 0x6bac <vfprintf+0xf6>
    6ba4:	16 fd       	sbrc	r17, 6
    6ba6:	6c c1       	rjmp	.+728    	; 0x6e80 <vfprintf+0x3ca>
    6ba8:	10 64       	ori	r17, 0x40	; 64
    6baa:	06 c0       	rjmp	.+12     	; 0x6bb8 <vfprintf+0x102>
    6bac:	8c 36       	cpi	r24, 0x6C	; 108
    6bae:	11 f4       	brne	.+4      	; 0x6bb4 <vfprintf+0xfe>
    6bb0:	10 68       	ori	r17, 0x80	; 128
    6bb2:	02 c0       	rjmp	.+4      	; 0x6bb8 <vfprintf+0x102>
    6bb4:	88 36       	cpi	r24, 0x68	; 104
    6bb6:	59 f4       	brne	.+22     	; 0x6bce <vfprintf+0x118>
    6bb8:	ec 85       	ldd	r30, Y+12	; 0x0c
    6bba:	fd 85       	ldd	r31, Y+13	; 0x0d
    6bbc:	93 fd       	sbrc	r25, 3
    6bbe:	85 91       	lpm	r24, Z+
    6bc0:	93 ff       	sbrs	r25, 3
    6bc2:	81 91       	ld	r24, Z+
    6bc4:	ec 87       	std	Y+12, r30	; 0x0c
    6bc6:	fd 87       	std	Y+13, r31	; 0x0d
    6bc8:	88 23       	and	r24, r24
    6bca:	09 f0       	breq	.+2      	; 0x6bce <vfprintf+0x118>
    6bcc:	b8 cf       	rjmp	.-144    	; 0x6b3e <vfprintf+0x88>
    6bce:	98 2f       	mov	r25, r24
    6bd0:	95 54       	subi	r25, 0x45	; 69
    6bd2:	93 30       	cpi	r25, 0x03	; 3
    6bd4:	18 f0       	brcs	.+6      	; 0x6bdc <vfprintf+0x126>
    6bd6:	90 52       	subi	r25, 0x20	; 32
    6bd8:	93 30       	cpi	r25, 0x03	; 3
    6bda:	38 f4       	brcc	.+14     	; 0x6bea <vfprintf+0x134>
    6bdc:	24 e0       	ldi	r18, 0x04	; 4
    6bde:	30 e0       	ldi	r19, 0x00	; 0
    6be0:	a2 0e       	add	r10, r18
    6be2:	b3 1e       	adc	r11, r19
    6be4:	3f e3       	ldi	r19, 0x3F	; 63
    6be6:	39 83       	std	Y+1, r19	; 0x01
    6be8:	0f c0       	rjmp	.+30     	; 0x6c08 <vfprintf+0x152>
    6bea:	83 36       	cpi	r24, 0x63	; 99
    6bec:	31 f0       	breq	.+12     	; 0x6bfa <vfprintf+0x144>
    6bee:	83 37       	cpi	r24, 0x73	; 115
    6bf0:	81 f0       	breq	.+32     	; 0x6c12 <vfprintf+0x15c>
    6bf2:	83 35       	cpi	r24, 0x53	; 83
    6bf4:	09 f0       	breq	.+2      	; 0x6bf8 <vfprintf+0x142>
    6bf6:	5a c0       	rjmp	.+180    	; 0x6cac <vfprintf+0x1f6>
    6bf8:	22 c0       	rjmp	.+68     	; 0x6c3e <vfprintf+0x188>
    6bfa:	f5 01       	movw	r30, r10
    6bfc:	80 81       	ld	r24, Z
    6bfe:	89 83       	std	Y+1, r24	; 0x01
    6c00:	22 e0       	ldi	r18, 0x02	; 2
    6c02:	30 e0       	ldi	r19, 0x00	; 0
    6c04:	a2 0e       	add	r10, r18
    6c06:	b3 1e       	adc	r11, r19
    6c08:	21 e0       	ldi	r18, 0x01	; 1
    6c0a:	c2 2e       	mov	r12, r18
    6c0c:	d1 2c       	mov	r13, r1
    6c0e:	42 01       	movw	r8, r4
    6c10:	14 c0       	rjmp	.+40     	; 0x6c3a <vfprintf+0x184>
    6c12:	92 e0       	ldi	r25, 0x02	; 2
    6c14:	29 2e       	mov	r2, r25
    6c16:	31 2c       	mov	r3, r1
    6c18:	2a 0c       	add	r2, r10
    6c1a:	3b 1c       	adc	r3, r11
    6c1c:	f5 01       	movw	r30, r10
    6c1e:	80 80       	ld	r8, Z
    6c20:	91 80       	ldd	r9, Z+1	; 0x01
    6c22:	16 ff       	sbrs	r17, 6
    6c24:	03 c0       	rjmp	.+6      	; 0x6c2c <vfprintf+0x176>
    6c26:	6f 2d       	mov	r22, r15
    6c28:	70 e0       	ldi	r23, 0x00	; 0
    6c2a:	02 c0       	rjmp	.+4      	; 0x6c30 <vfprintf+0x17a>
    6c2c:	6f ef       	ldi	r22, 0xFF	; 255
    6c2e:	7f ef       	ldi	r23, 0xFF	; 255
    6c30:	c4 01       	movw	r24, r8
    6c32:	0e 94 70 37 	call	0x6ee0	; 0x6ee0 <strnlen>
    6c36:	6c 01       	movw	r12, r24
    6c38:	51 01       	movw	r10, r2
    6c3a:	1f 77       	andi	r17, 0x7F	; 127
    6c3c:	15 c0       	rjmp	.+42     	; 0x6c68 <vfprintf+0x1b2>
    6c3e:	82 e0       	ldi	r24, 0x02	; 2
    6c40:	28 2e       	mov	r2, r24
    6c42:	31 2c       	mov	r3, r1
    6c44:	2a 0c       	add	r2, r10
    6c46:	3b 1c       	adc	r3, r11
    6c48:	f5 01       	movw	r30, r10
    6c4a:	80 80       	ld	r8, Z
    6c4c:	91 80       	ldd	r9, Z+1	; 0x01
    6c4e:	16 ff       	sbrs	r17, 6
    6c50:	03 c0       	rjmp	.+6      	; 0x6c58 <vfprintf+0x1a2>
    6c52:	6f 2d       	mov	r22, r15
    6c54:	70 e0       	ldi	r23, 0x00	; 0
    6c56:	02 c0       	rjmp	.+4      	; 0x6c5c <vfprintf+0x1a6>
    6c58:	6f ef       	ldi	r22, 0xFF	; 255
    6c5a:	7f ef       	ldi	r23, 0xFF	; 255
    6c5c:	c4 01       	movw	r24, r8
    6c5e:	0e 94 5c 37 	call	0x6eb8	; 0x6eb8 <strnlen_P>
    6c62:	6c 01       	movw	r12, r24
    6c64:	10 68       	ori	r17, 0x80	; 128
    6c66:	51 01       	movw	r10, r2
    6c68:	13 fd       	sbrc	r17, 3
    6c6a:	1c c0       	rjmp	.+56     	; 0x6ca4 <vfprintf+0x1ee>
    6c6c:	06 c0       	rjmp	.+12     	; 0x6c7a <vfprintf+0x1c4>
    6c6e:	80 e2       	ldi	r24, 0x20	; 32
    6c70:	90 e0       	ldi	r25, 0x00	; 0
    6c72:	b3 01       	movw	r22, r6
    6c74:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6c78:	ea 94       	dec	r14
    6c7a:	8e 2d       	mov	r24, r14
    6c7c:	90 e0       	ldi	r25, 0x00	; 0
    6c7e:	c8 16       	cp	r12, r24
    6c80:	d9 06       	cpc	r13, r25
    6c82:	a8 f3       	brcs	.-22     	; 0x6c6e <vfprintf+0x1b8>
    6c84:	0f c0       	rjmp	.+30     	; 0x6ca4 <vfprintf+0x1ee>
    6c86:	f4 01       	movw	r30, r8
    6c88:	17 fd       	sbrc	r17, 7
    6c8a:	85 91       	lpm	r24, Z+
    6c8c:	17 ff       	sbrs	r17, 7
    6c8e:	81 91       	ld	r24, Z+
    6c90:	4f 01       	movw	r8, r30
    6c92:	90 e0       	ldi	r25, 0x00	; 0
    6c94:	b3 01       	movw	r22, r6
    6c96:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6c9a:	e1 10       	cpse	r14, r1
    6c9c:	ea 94       	dec	r14
    6c9e:	08 94       	sec
    6ca0:	c1 08       	sbc	r12, r1
    6ca2:	d1 08       	sbc	r13, r1
    6ca4:	c1 14       	cp	r12, r1
    6ca6:	d1 04       	cpc	r13, r1
    6ca8:	71 f7       	brne	.-36     	; 0x6c86 <vfprintf+0x1d0>
    6caa:	e7 c0       	rjmp	.+462    	; 0x6e7a <vfprintf+0x3c4>
    6cac:	84 36       	cpi	r24, 0x64	; 100
    6cae:	11 f0       	breq	.+4      	; 0x6cb4 <vfprintf+0x1fe>
    6cb0:	89 36       	cpi	r24, 0x69	; 105
    6cb2:	51 f5       	brne	.+84     	; 0x6d08 <vfprintf+0x252>
    6cb4:	f5 01       	movw	r30, r10
    6cb6:	17 ff       	sbrs	r17, 7
    6cb8:	07 c0       	rjmp	.+14     	; 0x6cc8 <vfprintf+0x212>
    6cba:	80 81       	ld	r24, Z
    6cbc:	91 81       	ldd	r25, Z+1	; 0x01
    6cbe:	a2 81       	ldd	r26, Z+2	; 0x02
    6cc0:	b3 81       	ldd	r27, Z+3	; 0x03
    6cc2:	24 e0       	ldi	r18, 0x04	; 4
    6cc4:	30 e0       	ldi	r19, 0x00	; 0
    6cc6:	08 c0       	rjmp	.+16     	; 0x6cd8 <vfprintf+0x222>
    6cc8:	80 81       	ld	r24, Z
    6cca:	91 81       	ldd	r25, Z+1	; 0x01
    6ccc:	aa 27       	eor	r26, r26
    6cce:	97 fd       	sbrc	r25, 7
    6cd0:	a0 95       	com	r26
    6cd2:	ba 2f       	mov	r27, r26
    6cd4:	22 e0       	ldi	r18, 0x02	; 2
    6cd6:	30 e0       	ldi	r19, 0x00	; 0
    6cd8:	a2 0e       	add	r10, r18
    6cda:	b3 1e       	adc	r11, r19
    6cdc:	01 2f       	mov	r16, r17
    6cde:	0f 76       	andi	r16, 0x6F	; 111
    6ce0:	b7 ff       	sbrs	r27, 7
    6ce2:	08 c0       	rjmp	.+16     	; 0x6cf4 <vfprintf+0x23e>
    6ce4:	b0 95       	com	r27
    6ce6:	a0 95       	com	r26
    6ce8:	90 95       	com	r25
    6cea:	81 95       	neg	r24
    6cec:	9f 4f       	sbci	r25, 0xFF	; 255
    6cee:	af 4f       	sbci	r26, 0xFF	; 255
    6cf0:	bf 4f       	sbci	r27, 0xFF	; 255
    6cf2:	00 68       	ori	r16, 0x80	; 128
    6cf4:	bc 01       	movw	r22, r24
    6cf6:	cd 01       	movw	r24, r26
    6cf8:	a2 01       	movw	r20, r4
    6cfa:	2a e0       	ldi	r18, 0x0A	; 10
    6cfc:	30 e0       	ldi	r19, 0x00	; 0
    6cfe:	0e 94 a7 37 	call	0x6f4e	; 0x6f4e <__ultoa_invert>
    6d02:	d8 2e       	mov	r13, r24
    6d04:	d4 18       	sub	r13, r4
    6d06:	3f c0       	rjmp	.+126    	; 0x6d86 <vfprintf+0x2d0>
    6d08:	85 37       	cpi	r24, 0x75	; 117
    6d0a:	21 f4       	brne	.+8      	; 0x6d14 <vfprintf+0x25e>
    6d0c:	1f 7e       	andi	r17, 0xEF	; 239
    6d0e:	2a e0       	ldi	r18, 0x0A	; 10
    6d10:	30 e0       	ldi	r19, 0x00	; 0
    6d12:	20 c0       	rjmp	.+64     	; 0x6d54 <vfprintf+0x29e>
    6d14:	19 7f       	andi	r17, 0xF9	; 249
    6d16:	8f 36       	cpi	r24, 0x6F	; 111
    6d18:	a9 f0       	breq	.+42     	; 0x6d44 <vfprintf+0x28e>
    6d1a:	80 37       	cpi	r24, 0x70	; 112
    6d1c:	20 f4       	brcc	.+8      	; 0x6d26 <vfprintf+0x270>
    6d1e:	88 35       	cpi	r24, 0x58	; 88
    6d20:	09 f0       	breq	.+2      	; 0x6d24 <vfprintf+0x26e>
    6d22:	ae c0       	rjmp	.+348    	; 0x6e80 <vfprintf+0x3ca>
    6d24:	0b c0       	rjmp	.+22     	; 0x6d3c <vfprintf+0x286>
    6d26:	80 37       	cpi	r24, 0x70	; 112
    6d28:	21 f0       	breq	.+8      	; 0x6d32 <vfprintf+0x27c>
    6d2a:	88 37       	cpi	r24, 0x78	; 120
    6d2c:	09 f0       	breq	.+2      	; 0x6d30 <vfprintf+0x27a>
    6d2e:	a8 c0       	rjmp	.+336    	; 0x6e80 <vfprintf+0x3ca>
    6d30:	01 c0       	rjmp	.+2      	; 0x6d34 <vfprintf+0x27e>
    6d32:	10 61       	ori	r17, 0x10	; 16
    6d34:	14 ff       	sbrs	r17, 4
    6d36:	09 c0       	rjmp	.+18     	; 0x6d4a <vfprintf+0x294>
    6d38:	14 60       	ori	r17, 0x04	; 4
    6d3a:	07 c0       	rjmp	.+14     	; 0x6d4a <vfprintf+0x294>
    6d3c:	14 ff       	sbrs	r17, 4
    6d3e:	08 c0       	rjmp	.+16     	; 0x6d50 <vfprintf+0x29a>
    6d40:	16 60       	ori	r17, 0x06	; 6
    6d42:	06 c0       	rjmp	.+12     	; 0x6d50 <vfprintf+0x29a>
    6d44:	28 e0       	ldi	r18, 0x08	; 8
    6d46:	30 e0       	ldi	r19, 0x00	; 0
    6d48:	05 c0       	rjmp	.+10     	; 0x6d54 <vfprintf+0x29e>
    6d4a:	20 e1       	ldi	r18, 0x10	; 16
    6d4c:	30 e0       	ldi	r19, 0x00	; 0
    6d4e:	02 c0       	rjmp	.+4      	; 0x6d54 <vfprintf+0x29e>
    6d50:	20 e1       	ldi	r18, 0x10	; 16
    6d52:	32 e0       	ldi	r19, 0x02	; 2
    6d54:	f5 01       	movw	r30, r10
    6d56:	17 ff       	sbrs	r17, 7
    6d58:	07 c0       	rjmp	.+14     	; 0x6d68 <vfprintf+0x2b2>
    6d5a:	60 81       	ld	r22, Z
    6d5c:	71 81       	ldd	r23, Z+1	; 0x01
    6d5e:	82 81       	ldd	r24, Z+2	; 0x02
    6d60:	93 81       	ldd	r25, Z+3	; 0x03
    6d62:	44 e0       	ldi	r20, 0x04	; 4
    6d64:	50 e0       	ldi	r21, 0x00	; 0
    6d66:	06 c0       	rjmp	.+12     	; 0x6d74 <vfprintf+0x2be>
    6d68:	60 81       	ld	r22, Z
    6d6a:	71 81       	ldd	r23, Z+1	; 0x01
    6d6c:	80 e0       	ldi	r24, 0x00	; 0
    6d6e:	90 e0       	ldi	r25, 0x00	; 0
    6d70:	42 e0       	ldi	r20, 0x02	; 2
    6d72:	50 e0       	ldi	r21, 0x00	; 0
    6d74:	a4 0e       	add	r10, r20
    6d76:	b5 1e       	adc	r11, r21
    6d78:	a2 01       	movw	r20, r4
    6d7a:	0e 94 a7 37 	call	0x6f4e	; 0x6f4e <__ultoa_invert>
    6d7e:	d8 2e       	mov	r13, r24
    6d80:	d4 18       	sub	r13, r4
    6d82:	01 2f       	mov	r16, r17
    6d84:	0f 77       	andi	r16, 0x7F	; 127
    6d86:	06 ff       	sbrs	r16, 6
    6d88:	09 c0       	rjmp	.+18     	; 0x6d9c <vfprintf+0x2e6>
    6d8a:	0e 7f       	andi	r16, 0xFE	; 254
    6d8c:	df 14       	cp	r13, r15
    6d8e:	30 f4       	brcc	.+12     	; 0x6d9c <vfprintf+0x2e6>
    6d90:	04 ff       	sbrs	r16, 4
    6d92:	06 c0       	rjmp	.+12     	; 0x6da0 <vfprintf+0x2ea>
    6d94:	02 fd       	sbrc	r16, 2
    6d96:	04 c0       	rjmp	.+8      	; 0x6da0 <vfprintf+0x2ea>
    6d98:	0f 7e       	andi	r16, 0xEF	; 239
    6d9a:	02 c0       	rjmp	.+4      	; 0x6da0 <vfprintf+0x2ea>
    6d9c:	1d 2d       	mov	r17, r13
    6d9e:	01 c0       	rjmp	.+2      	; 0x6da2 <vfprintf+0x2ec>
    6da0:	1f 2d       	mov	r17, r15
    6da2:	80 2f       	mov	r24, r16
    6da4:	90 e0       	ldi	r25, 0x00	; 0
    6da6:	04 ff       	sbrs	r16, 4
    6da8:	0c c0       	rjmp	.+24     	; 0x6dc2 <vfprintf+0x30c>
    6daa:	fe 01       	movw	r30, r28
    6dac:	ed 0d       	add	r30, r13
    6dae:	f1 1d       	adc	r31, r1
    6db0:	20 81       	ld	r18, Z
    6db2:	20 33       	cpi	r18, 0x30	; 48
    6db4:	11 f4       	brne	.+4      	; 0x6dba <vfprintf+0x304>
    6db6:	09 7e       	andi	r16, 0xE9	; 233
    6db8:	09 c0       	rjmp	.+18     	; 0x6dcc <vfprintf+0x316>
    6dba:	02 ff       	sbrs	r16, 2
    6dbc:	06 c0       	rjmp	.+12     	; 0x6dca <vfprintf+0x314>
    6dbe:	1e 5f       	subi	r17, 0xFE	; 254
    6dc0:	05 c0       	rjmp	.+10     	; 0x6dcc <vfprintf+0x316>
    6dc2:	86 78       	andi	r24, 0x86	; 134
    6dc4:	90 70       	andi	r25, 0x00	; 0
    6dc6:	00 97       	sbiw	r24, 0x00	; 0
    6dc8:	09 f0       	breq	.+2      	; 0x6dcc <vfprintf+0x316>
    6dca:	1f 5f       	subi	r17, 0xFF	; 255
    6dcc:	80 2e       	mov	r8, r16
    6dce:	99 24       	eor	r9, r9
    6dd0:	03 fd       	sbrc	r16, 3
    6dd2:	12 c0       	rjmp	.+36     	; 0x6df8 <vfprintf+0x342>
    6dd4:	00 ff       	sbrs	r16, 0
    6dd6:	0d c0       	rjmp	.+26     	; 0x6df2 <vfprintf+0x33c>
    6dd8:	fd 2c       	mov	r15, r13
    6dda:	1e 15       	cp	r17, r14
    6ddc:	50 f4       	brcc	.+20     	; 0x6df2 <vfprintf+0x33c>
    6dde:	fe 0c       	add	r15, r14
    6de0:	f1 1a       	sub	r15, r17
    6de2:	1e 2d       	mov	r17, r14
    6de4:	06 c0       	rjmp	.+12     	; 0x6df2 <vfprintf+0x33c>
    6de6:	80 e2       	ldi	r24, 0x20	; 32
    6de8:	90 e0       	ldi	r25, 0x00	; 0
    6dea:	b3 01       	movw	r22, r6
    6dec:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6df0:	1f 5f       	subi	r17, 0xFF	; 255
    6df2:	1e 15       	cp	r17, r14
    6df4:	c0 f3       	brcs	.-16     	; 0x6de6 <vfprintf+0x330>
    6df6:	04 c0       	rjmp	.+8      	; 0x6e00 <vfprintf+0x34a>
    6df8:	1e 15       	cp	r17, r14
    6dfa:	10 f4       	brcc	.+4      	; 0x6e00 <vfprintf+0x34a>
    6dfc:	e1 1a       	sub	r14, r17
    6dfe:	01 c0       	rjmp	.+2      	; 0x6e02 <vfprintf+0x34c>
    6e00:	ee 24       	eor	r14, r14
    6e02:	84 fe       	sbrs	r8, 4
    6e04:	0f c0       	rjmp	.+30     	; 0x6e24 <vfprintf+0x36e>
    6e06:	80 e3       	ldi	r24, 0x30	; 48
    6e08:	90 e0       	ldi	r25, 0x00	; 0
    6e0a:	b3 01       	movw	r22, r6
    6e0c:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6e10:	82 fe       	sbrs	r8, 2
    6e12:	1f c0       	rjmp	.+62     	; 0x6e52 <vfprintf+0x39c>
    6e14:	81 fe       	sbrs	r8, 1
    6e16:	03 c0       	rjmp	.+6      	; 0x6e1e <vfprintf+0x368>
    6e18:	88 e5       	ldi	r24, 0x58	; 88
    6e1a:	90 e0       	ldi	r25, 0x00	; 0
    6e1c:	10 c0       	rjmp	.+32     	; 0x6e3e <vfprintf+0x388>
    6e1e:	88 e7       	ldi	r24, 0x78	; 120
    6e20:	90 e0       	ldi	r25, 0x00	; 0
    6e22:	0d c0       	rjmp	.+26     	; 0x6e3e <vfprintf+0x388>
    6e24:	c4 01       	movw	r24, r8
    6e26:	86 78       	andi	r24, 0x86	; 134
    6e28:	90 70       	andi	r25, 0x00	; 0
    6e2a:	00 97       	sbiw	r24, 0x00	; 0
    6e2c:	91 f0       	breq	.+36     	; 0x6e52 <vfprintf+0x39c>
    6e2e:	81 fc       	sbrc	r8, 1
    6e30:	02 c0       	rjmp	.+4      	; 0x6e36 <vfprintf+0x380>
    6e32:	80 e2       	ldi	r24, 0x20	; 32
    6e34:	01 c0       	rjmp	.+2      	; 0x6e38 <vfprintf+0x382>
    6e36:	8b e2       	ldi	r24, 0x2B	; 43
    6e38:	07 fd       	sbrc	r16, 7
    6e3a:	8d e2       	ldi	r24, 0x2D	; 45
    6e3c:	90 e0       	ldi	r25, 0x00	; 0
    6e3e:	b3 01       	movw	r22, r6
    6e40:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6e44:	06 c0       	rjmp	.+12     	; 0x6e52 <vfprintf+0x39c>
    6e46:	80 e3       	ldi	r24, 0x30	; 48
    6e48:	90 e0       	ldi	r25, 0x00	; 0
    6e4a:	b3 01       	movw	r22, r6
    6e4c:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6e50:	fa 94       	dec	r15
    6e52:	df 14       	cp	r13, r15
    6e54:	c0 f3       	brcs	.-16     	; 0x6e46 <vfprintf+0x390>
    6e56:	da 94       	dec	r13
    6e58:	f2 01       	movw	r30, r4
    6e5a:	ed 0d       	add	r30, r13
    6e5c:	f1 1d       	adc	r31, r1
    6e5e:	80 81       	ld	r24, Z
    6e60:	90 e0       	ldi	r25, 0x00	; 0
    6e62:	b3 01       	movw	r22, r6
    6e64:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6e68:	dd 20       	and	r13, r13
    6e6a:	a9 f7       	brne	.-22     	; 0x6e56 <vfprintf+0x3a0>
    6e6c:	06 c0       	rjmp	.+12     	; 0x6e7a <vfprintf+0x3c4>
    6e6e:	80 e2       	ldi	r24, 0x20	; 32
    6e70:	90 e0       	ldi	r25, 0x00	; 0
    6e72:	b3 01       	movw	r22, r6
    6e74:	0e 94 7b 37 	call	0x6ef6	; 0x6ef6 <fputc>
    6e78:	ea 94       	dec	r14
    6e7a:	ee 20       	and	r14, r14
    6e7c:	c1 f7       	brne	.-16     	; 0x6e6e <vfprintf+0x3b8>
    6e7e:	40 ce       	rjmp	.-896    	; 0x6b00 <vfprintf+0x4a>
    6e80:	f3 01       	movw	r30, r6
    6e82:	86 81       	ldd	r24, Z+6	; 0x06
    6e84:	97 81       	ldd	r25, Z+7	; 0x07
    6e86:	02 c0       	rjmp	.+4      	; 0x6e8c <vfprintf+0x3d6>
    6e88:	8f ef       	ldi	r24, 0xFF	; 255
    6e8a:	9f ef       	ldi	r25, 0xFF	; 255
    6e8c:	2d 96       	adiw	r28, 0x0d	; 13
    6e8e:	cd bf       	out	0x3d, r28	; 61
    6e90:	de bf       	out	0x3e, r29	; 62
    6e92:	df 91       	pop	r29
    6e94:	cf 91       	pop	r28
    6e96:	1f 91       	pop	r17
    6e98:	0f 91       	pop	r16
    6e9a:	ff 90       	pop	r15
    6e9c:	ef 90       	pop	r14
    6e9e:	df 90       	pop	r13
    6ea0:	cf 90       	pop	r12
    6ea2:	bf 90       	pop	r11
    6ea4:	af 90       	pop	r10
    6ea6:	9f 90       	pop	r9
    6ea8:	8f 90       	pop	r8
    6eaa:	7f 90       	pop	r7
    6eac:	6f 90       	pop	r6
    6eae:	5f 90       	pop	r5
    6eb0:	4f 90       	pop	r4
    6eb2:	3f 90       	pop	r3
    6eb4:	2f 90       	pop	r2
    6eb6:	08 95       	ret

00006eb8 <strnlen_P>:
    6eb8:	fc 01       	movw	r30, r24
    6eba:	05 90       	lpm	r0, Z+
    6ebc:	61 50       	subi	r22, 0x01	; 1
    6ebe:	70 40       	sbci	r23, 0x00	; 0
    6ec0:	01 10       	cpse	r0, r1
    6ec2:	d8 f7       	brcc	.-10     	; 0x6eba <strnlen_P+0x2>
    6ec4:	80 95       	com	r24
    6ec6:	90 95       	com	r25
    6ec8:	8e 0f       	add	r24, r30
    6eca:	9f 1f       	adc	r25, r31
    6ecc:	08 95       	ret

00006ece <memcpy>:
    6ece:	fb 01       	movw	r30, r22
    6ed0:	dc 01       	movw	r26, r24
    6ed2:	02 c0       	rjmp	.+4      	; 0x6ed8 <memcpy+0xa>
    6ed4:	01 90       	ld	r0, Z+
    6ed6:	0d 92       	st	X+, r0
    6ed8:	41 50       	subi	r20, 0x01	; 1
    6eda:	50 40       	sbci	r21, 0x00	; 0
    6edc:	d8 f7       	brcc	.-10     	; 0x6ed4 <memcpy+0x6>
    6ede:	08 95       	ret

00006ee0 <strnlen>:
    6ee0:	fc 01       	movw	r30, r24
    6ee2:	61 50       	subi	r22, 0x01	; 1
    6ee4:	70 40       	sbci	r23, 0x00	; 0
    6ee6:	01 90       	ld	r0, Z+
    6ee8:	01 10       	cpse	r0, r1
    6eea:	d8 f7       	brcc	.-10     	; 0x6ee2 <strnlen+0x2>
    6eec:	80 95       	com	r24
    6eee:	90 95       	com	r25
    6ef0:	8e 0f       	add	r24, r30
    6ef2:	9f 1f       	adc	r25, r31
    6ef4:	08 95       	ret

00006ef6 <fputc>:
    6ef6:	0f 93       	push	r16
    6ef8:	1f 93       	push	r17
    6efa:	cf 93       	push	r28
    6efc:	df 93       	push	r29
    6efe:	8c 01       	movw	r16, r24
    6f00:	eb 01       	movw	r28, r22
    6f02:	8b 81       	ldd	r24, Y+3	; 0x03
    6f04:	81 ff       	sbrs	r24, 1
    6f06:	1b c0       	rjmp	.+54     	; 0x6f3e <fputc+0x48>
    6f08:	82 ff       	sbrs	r24, 2
    6f0a:	0d c0       	rjmp	.+26     	; 0x6f26 <fputc+0x30>
    6f0c:	2e 81       	ldd	r18, Y+6	; 0x06
    6f0e:	3f 81       	ldd	r19, Y+7	; 0x07
    6f10:	8c 81       	ldd	r24, Y+4	; 0x04
    6f12:	9d 81       	ldd	r25, Y+5	; 0x05
    6f14:	28 17       	cp	r18, r24
    6f16:	39 07       	cpc	r19, r25
    6f18:	64 f4       	brge	.+24     	; 0x6f32 <fputc+0x3c>
    6f1a:	e8 81       	ld	r30, Y
    6f1c:	f9 81       	ldd	r31, Y+1	; 0x01
    6f1e:	01 93       	st	Z+, r16
    6f20:	e8 83       	st	Y, r30
    6f22:	f9 83       	std	Y+1, r31	; 0x01
    6f24:	06 c0       	rjmp	.+12     	; 0x6f32 <fputc+0x3c>
    6f26:	e8 85       	ldd	r30, Y+8	; 0x08
    6f28:	f9 85       	ldd	r31, Y+9	; 0x09
    6f2a:	80 2f       	mov	r24, r16
    6f2c:	19 95       	eicall
    6f2e:	00 97       	sbiw	r24, 0x00	; 0
    6f30:	31 f4       	brne	.+12     	; 0x6f3e <fputc+0x48>
    6f32:	8e 81       	ldd	r24, Y+6	; 0x06
    6f34:	9f 81       	ldd	r25, Y+7	; 0x07
    6f36:	01 96       	adiw	r24, 0x01	; 1
    6f38:	8e 83       	std	Y+6, r24	; 0x06
    6f3a:	9f 83       	std	Y+7, r25	; 0x07
    6f3c:	02 c0       	rjmp	.+4      	; 0x6f42 <fputc+0x4c>
    6f3e:	0f ef       	ldi	r16, 0xFF	; 255
    6f40:	1f ef       	ldi	r17, 0xFF	; 255
    6f42:	c8 01       	movw	r24, r16
    6f44:	df 91       	pop	r29
    6f46:	cf 91       	pop	r28
    6f48:	1f 91       	pop	r17
    6f4a:	0f 91       	pop	r16
    6f4c:	08 95       	ret

00006f4e <__ultoa_invert>:
    6f4e:	fa 01       	movw	r30, r20
    6f50:	aa 27       	eor	r26, r26
    6f52:	28 30       	cpi	r18, 0x08	; 8
    6f54:	51 f1       	breq	.+84     	; 0x6faa <__ultoa_invert+0x5c>
    6f56:	20 31       	cpi	r18, 0x10	; 16
    6f58:	81 f1       	breq	.+96     	; 0x6fba <__ultoa_invert+0x6c>
    6f5a:	e8 94       	clt
    6f5c:	6f 93       	push	r22
    6f5e:	6e 7f       	andi	r22, 0xFE	; 254
    6f60:	6e 5f       	subi	r22, 0xFE	; 254
    6f62:	7f 4f       	sbci	r23, 0xFF	; 255
    6f64:	8f 4f       	sbci	r24, 0xFF	; 255
    6f66:	9f 4f       	sbci	r25, 0xFF	; 255
    6f68:	af 4f       	sbci	r26, 0xFF	; 255
    6f6a:	b1 e0       	ldi	r27, 0x01	; 1
    6f6c:	3e d0       	rcall	.+124    	; 0x6fea <__ultoa_invert+0x9c>
    6f6e:	b4 e0       	ldi	r27, 0x04	; 4
    6f70:	3c d0       	rcall	.+120    	; 0x6fea <__ultoa_invert+0x9c>
    6f72:	67 0f       	add	r22, r23
    6f74:	78 1f       	adc	r23, r24
    6f76:	89 1f       	adc	r24, r25
    6f78:	9a 1f       	adc	r25, r26
    6f7a:	a1 1d       	adc	r26, r1
    6f7c:	68 0f       	add	r22, r24
    6f7e:	79 1f       	adc	r23, r25
    6f80:	8a 1f       	adc	r24, r26
    6f82:	91 1d       	adc	r25, r1
    6f84:	a1 1d       	adc	r26, r1
    6f86:	6a 0f       	add	r22, r26
    6f88:	71 1d       	adc	r23, r1
    6f8a:	81 1d       	adc	r24, r1
    6f8c:	91 1d       	adc	r25, r1
    6f8e:	a1 1d       	adc	r26, r1
    6f90:	20 d0       	rcall	.+64     	; 0x6fd2 <__ultoa_invert+0x84>
    6f92:	09 f4       	brne	.+2      	; 0x6f96 <__ultoa_invert+0x48>
    6f94:	68 94       	set
    6f96:	3f 91       	pop	r19
    6f98:	2a e0       	ldi	r18, 0x0A	; 10
    6f9a:	26 9f       	mul	r18, r22
    6f9c:	11 24       	eor	r1, r1
    6f9e:	30 19       	sub	r19, r0
    6fa0:	30 5d       	subi	r19, 0xD0	; 208
    6fa2:	31 93       	st	Z+, r19
    6fa4:	de f6       	brtc	.-74     	; 0x6f5c <__ultoa_invert+0xe>
    6fa6:	cf 01       	movw	r24, r30
    6fa8:	08 95       	ret
    6faa:	46 2f       	mov	r20, r22
    6fac:	47 70       	andi	r20, 0x07	; 7
    6fae:	40 5d       	subi	r20, 0xD0	; 208
    6fb0:	41 93       	st	Z+, r20
    6fb2:	b3 e0       	ldi	r27, 0x03	; 3
    6fb4:	0f d0       	rcall	.+30     	; 0x6fd4 <__ultoa_invert+0x86>
    6fb6:	c9 f7       	brne	.-14     	; 0x6faa <__ultoa_invert+0x5c>
    6fb8:	f6 cf       	rjmp	.-20     	; 0x6fa6 <__ultoa_invert+0x58>
    6fba:	46 2f       	mov	r20, r22
    6fbc:	4f 70       	andi	r20, 0x0F	; 15
    6fbe:	40 5d       	subi	r20, 0xD0	; 208
    6fc0:	4a 33       	cpi	r20, 0x3A	; 58
    6fc2:	18 f0       	brcs	.+6      	; 0x6fca <__ultoa_invert+0x7c>
    6fc4:	49 5d       	subi	r20, 0xD9	; 217
    6fc6:	31 fd       	sbrc	r19, 1
    6fc8:	40 52       	subi	r20, 0x20	; 32
    6fca:	41 93       	st	Z+, r20
    6fcc:	02 d0       	rcall	.+4      	; 0x6fd2 <__ultoa_invert+0x84>
    6fce:	a9 f7       	brne	.-22     	; 0x6fba <__ultoa_invert+0x6c>
    6fd0:	ea cf       	rjmp	.-44     	; 0x6fa6 <__ultoa_invert+0x58>
    6fd2:	b4 e0       	ldi	r27, 0x04	; 4
    6fd4:	a6 95       	lsr	r26
    6fd6:	97 95       	ror	r25
    6fd8:	87 95       	ror	r24
    6fda:	77 95       	ror	r23
    6fdc:	67 95       	ror	r22
    6fde:	ba 95       	dec	r27
    6fe0:	c9 f7       	brne	.-14     	; 0x6fd4 <__ultoa_invert+0x86>
    6fe2:	00 97       	sbiw	r24, 0x00	; 0
    6fe4:	61 05       	cpc	r22, r1
    6fe6:	71 05       	cpc	r23, r1
    6fe8:	08 95       	ret
    6fea:	9b 01       	movw	r18, r22
    6fec:	ac 01       	movw	r20, r24
    6fee:	0a 2e       	mov	r0, r26
    6ff0:	06 94       	lsr	r0
    6ff2:	57 95       	ror	r21
    6ff4:	47 95       	ror	r20
    6ff6:	37 95       	ror	r19
    6ff8:	27 95       	ror	r18
    6ffa:	ba 95       	dec	r27
    6ffc:	c9 f7       	brne	.-14     	; 0x6ff0 <__ultoa_invert+0xa2>
    6ffe:	62 0f       	add	r22, r18
    7000:	73 1f       	adc	r23, r19
    7002:	84 1f       	adc	r24, r20
    7004:	95 1f       	adc	r25, r21
    7006:	a0 1d       	adc	r26, r0
    7008:	08 95       	ret

0000700a <_exit>:
    700a:	f8 94       	cli

0000700c <__stop_program>:
    700c:	ff cf       	rjmp	.-2      	; 0x700c <__stop_program>
