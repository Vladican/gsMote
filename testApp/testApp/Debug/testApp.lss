
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000cc06  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000132  00802000  0000cc06  0000cc9a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fab  00802132  00802132  0000cdcc  2**0
                  ALLOC
  3 .stab         00002718  00000000  00000000  0000cdcc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2a  00000000  00000000  0000f4e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003e0  00000000  00000000  0000ff10  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cd26  00000000  00000000  000102f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000022f6  00000000  00000000  0001d016  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000401f  00000000  00000000  0001f30c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c10  00000000  00000000  0002332c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000045f0  00000000  00000000  00024f3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000616c  00000000  00000000  0002952c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000148  00000000  00000000  0002f698  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 72 10 	jmp	0x20e4	; 0x20e4 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 86 0f 	jmp	0x1f0c	; 0x1f0c <__vector_16>
      44:	0c 94 b6 0f 	jmp	0x1f6c	; 0x1f6c <__vector_17>
      48:	0c 94 e6 0f 	jmp	0x1fcc	; 0x1fcc <__vector_18>
      4c:	0c 94 16 10 	jmp	0x202c	; 0x202c <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 d6 3d 	jmp	0x7bac	; 0x7bac <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 9a 2d 	jmp	0x5b34	; 0x5b34 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 1b 13 	jmp	0x2636	; 0x2636 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 59 12 	jmp	0x24b2	; 0x24b2 <__vector_79>
     140:	0c 94 89 12 	jmp	0x2512	; 0x2512 <__vector_80>
     144:	0c 94 b9 12 	jmp	0x2572	; 0x2572 <__vector_81>
     148:	0c 94 e9 12 	jmp	0x25d2	; 0x25d2 <__vector_82>
     14c:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 5c 0c 	jmp	0x18b8	; 0x18b8 <__vector_104>
     1a4:	0c 94 51 0a 	jmp	0x14a2	; 0x14a2 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e6 e0       	ldi	r30, 0x06	; 6
     244:	fc ec       	ldi	r31, 0xCC	; 204
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a2 33       	cpi	r26, 0x32	; 50
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a2 e3       	ldi	r26, 0x32	; 50
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ad 3d       	cpi	r26, 0xDD	; 221
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 06 02 	call	0x40c	; 0x40c <main>
     26a:	0c 94 01 66 	jmp	0xcc02	; 0xcc02 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	0f 92       	push	r0
     278:	0f 92       	push	r0
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
     27e:	89 83       	std	Y+1, r24	; 0x01
     280:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     282:	81 e0       	ldi	r24, 0x01	; 1
     284:	80 93 d1 50 	sts	0x50D1, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     288:	83 e0       	ldi	r24, 0x03	; 3
     28a:	80 93 5f 40 	sts	0x405F, r24
	chb_init();
     28e:	0e 94 bf 1d 	call	0x3b7e	; 0x3b7e <chb_init>
	chb_set_short_addr(moteID);
     292:	80 91 d1 50 	lds	r24, 0x50D1
     296:	88 2f       	mov	r24, r24
     298:	90 e0       	ldi	r25, 0x00	; 0
     29a:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     29e:	80 e8       	ldi	r24, 0x80	; 128
     2a0:	91 e0       	ldi	r25, 0x01	; 1
     2a2:	28 ec       	ldi	r18, 0xC8	; 200
     2a4:	fc 01       	movw	r30, r24
     2a6:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     2a8:	80 e4       	ldi	r24, 0x40	; 64
     2aa:	99 e0       	ldi	r25, 0x09	; 9
     2ac:	29 e0       	ldi	r18, 0x09	; 9
     2ae:	fc 01       	movw	r30, r24
     2b0:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     2b2:	80 e4       	ldi	r24, 0x40	; 64
     2b4:	99 e0       	ldi	r25, 0x09	; 9
     2b6:	22 e0       	ldi	r18, 0x02	; 2
     2b8:	fc 01       	movw	r30, r24
     2ba:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     2bc:	80 e4       	ldi	r24, 0x40	; 64
     2be:	99 e0       	ldi	r25, 0x09	; 9
     2c0:	69 81       	ldd	r22, Y+1	; 0x01
     2c2:	7a 81       	ldd	r23, Y+2	; 0x02
     2c4:	44 ef       	ldi	r20, 0xF4	; 244
     2c6:	51 e0       	ldi	r21, 0x01	; 1
     2c8:	64 9f       	mul	r22, r20
     2ca:	90 01       	movw	r18, r0
     2cc:	65 9f       	mul	r22, r21
     2ce:	30 0d       	add	r19, r0
     2d0:	74 9f       	mul	r23, r20
     2d2:	30 0d       	add	r19, r0
     2d4:	11 24       	eor	r1, r1
     2d6:	fc 01       	movw	r30, r24
     2d8:	26 a3       	lds	r18, 0x56
     2da:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     2dc:	80 e4       	ldi	r24, 0x40	; 64
     2de:	98 e0       	ldi	r25, 0x08	; 8
     2e0:	20 e0       	ldi	r18, 0x00	; 0
     2e2:	3a ef       	ldi	r19, 0xFA	; 250
     2e4:	fc 01       	movw	r30, r24
     2e6:	26 a3       	lds	r18, 0x56
     2e8:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     2ea:	80 e4       	ldi	r24, 0x40	; 64
     2ec:	98 e0       	ldi	r25, 0x08	; 8
     2ee:	21 e0       	ldi	r18, 0x01	; 1
     2f0:	fc 01       	movw	r30, r24
     2f2:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     2f4:	80 e4       	ldi	r24, 0x40	; 64
     2f6:	98 e0       	ldi	r25, 0x08	; 8
     2f8:	21 e0       	ldi	r18, 0x01	; 1
     2fa:	fc 01       	movw	r30, r24
     2fc:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     2fe:	80 ea       	ldi	r24, 0xA0	; 160
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	20 ea       	ldi	r18, 0xA0	; 160
     304:	30 e0       	ldi	r19, 0x00	; 0
     306:	f9 01       	movw	r30, r18
     308:	22 81       	ldd	r18, Z+2	; 0x02
     30a:	27 60       	ori	r18, 0x07	; 7
     30c:	fc 01       	movw	r30, r24
     30e:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     310:	78 94       	sei
}
     312:	0f 90       	pop	r0
     314:	0f 90       	pop	r0
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	08 95       	ret

0000031c <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     31c:	78 94       	sei
     31e:	1f 92       	push	r1
     320:	0f 92       	push	r0
     322:	0f b6       	in	r0, 0x3f	; 63
     324:	0f 92       	push	r0
     326:	00 90 3b 00 	lds	r0, 0x003B
     32a:	0f 92       	push	r0
     32c:	11 24       	eor	r1, r1
     32e:	2f 93       	push	r18
     330:	3f 93       	push	r19
     332:	4f 93       	push	r20
     334:	5f 93       	push	r21
     336:	6f 93       	push	r22
     338:	7f 93       	push	r23
     33a:	8f 93       	push	r24
     33c:	9f 93       	push	r25
     33e:	af 93       	push	r26
     340:	bf 93       	push	r27
     342:	ef 93       	push	r30
     344:	ff 93       	push	r31
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	cd b7       	in	r28, 0x3d	; 61
     34c:	de b7       	in	r29, 0x3e	; 62
     34e:	28 97       	sbiw	r28, 0x08	; 8
     350:	cd bf       	out	0x3d, r28	; 61
     352:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     354:	80 e4       	ldi	r24, 0x40	; 64
     356:	98 e0       	ldi	r25, 0x08	; 8
     358:	fc 01       	movw	r30, r24
     35a:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     35c:	80 e4       	ldi	r24, 0x40	; 64
     35e:	99 e0       	ldi	r25, 0x09	; 9
     360:	fc 01       	movw	r30, r24
     362:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     364:	82 e0       	ldi	r24, 0x02	; 2
     366:	80 93 5f 40 	sts	0x405F, r24
	unsigned char message[8];
	strcpy(message,"reset");
     36a:	ce 01       	movw	r24, r28
     36c:	01 96       	adiw	r24, 0x01	; 1
     36e:	20 e0       	ldi	r18, 0x00	; 0
     370:	30 e2       	ldi	r19, 0x20	; 32
     372:	46 e0       	ldi	r20, 0x06	; 6
     374:	f9 01       	movw	r30, r18
     376:	00 80       	ld	r0, Z
     378:	2f 5f       	subi	r18, 0xFF	; 255
     37a:	3f 4f       	sbci	r19, 0xFF	; 255
     37c:	fc 01       	movw	r30, r24
     37e:	00 82       	st	Z, r0
     380:	01 96       	adiw	r24, 0x01	; 1
     382:	41 50       	subi	r20, 0x01	; 1
     384:	44 23       	and	r20, r20
     386:	b1 f7       	brne	.-20     	; 0x374 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     388:	80 91 d1 50 	lds	r24, 0x50D1
     38c:	88 2f       	mov	r24, r24
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	22 e5       	ldi	r18, 0x52	; 82
     392:	30 e4       	ldi	r19, 0x40	; 64
     394:	b9 01       	movw	r22, r18
     396:	4a e0       	ldi	r20, 0x0A	; 10
     398:	50 e0       	ldi	r21, 0x00	; 0
     39a:	0e 94 f4 62 	call	0xc5e8	; 0xc5e8 <itoa>
	strcat(message,buff);
     39e:	22 e5       	ldi	r18, 0x52	; 82
     3a0:	30 e4       	ldi	r19, 0x40	; 64
     3a2:	ce 01       	movw	r24, r28
     3a4:	01 96       	adiw	r24, 0x01	; 1
     3a6:	b9 01       	movw	r22, r18
     3a8:	0e 94 db 62 	call	0xc5b6	; 0xc5b6 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     3ac:	0e 94 3a 0a 	call	0x1474	; 0x1474 <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     3b0:	ce 01       	movw	r24, r28
     3b2:	01 96       	adiw	r24, 0x01	; 1
     3b4:	9c 01       	movw	r18, r24
     3b6:	f9 01       	movw	r30, r18
     3b8:	01 90       	ld	r0, Z+
     3ba:	00 20       	and	r0, r0
     3bc:	e9 f7       	brne	.-6      	; 0x3b8 <__vector_83+0x9c>
     3be:	cf 01       	movw	r24, r30
     3c0:	01 97       	sbiw	r24, 0x01	; 1
     3c2:	82 1b       	sub	r24, r18
     3c4:	93 0b       	sbc	r25, r19
     3c6:	9c 01       	movw	r18, r24
     3c8:	40 e0       	ldi	r20, 0x00	; 0
     3ca:	50 e0       	ldi	r21, 0x00	; 0
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	be 01       	movw	r22, r28
     3d2:	6f 5f       	subi	r22, 0xFF	; 255
     3d4:	7f 4f       	sbci	r23, 0xFF	; 255
     3d6:	0e 94 86 1e 	call	0x3d0c	; 0x3d0c <chb_write>
}	
     3da:	28 96       	adiw	r28, 0x08	; 8
     3dc:	cd bf       	out	0x3d, r28	; 61
     3de:	de bf       	out	0x3e, r29	; 62
     3e0:	df 91       	pop	r29
     3e2:	cf 91       	pop	r28
     3e4:	ff 91       	pop	r31
     3e6:	ef 91       	pop	r30
     3e8:	bf 91       	pop	r27
     3ea:	af 91       	pop	r26
     3ec:	9f 91       	pop	r25
     3ee:	8f 91       	pop	r24
     3f0:	7f 91       	pop	r23
     3f2:	6f 91       	pop	r22
     3f4:	5f 91       	pop	r21
     3f6:	4f 91       	pop	r20
     3f8:	3f 91       	pop	r19
     3fa:	2f 91       	pop	r18
     3fc:	0f 90       	pop	r0
     3fe:	00 92 3b 00 	sts	0x003B, r0
     402:	0f 90       	pop	r0
     404:	0f be       	out	0x3f, r0	; 63
     406:	0f 90       	pop	r0
     408:	1f 90       	pop	r1
     40a:	18 95       	reti

0000040c <main>:
 */

#include "E-000001-000009_firmware_rev_1_0.h"


int main(){
     40c:	cf 92       	push	r12
     40e:	df 92       	push	r13
     410:	ef 92       	push	r14
     412:	ff 92       	push	r15
     414:	0f 93       	push	r16
     416:	1f 93       	push	r17
     418:	cf 93       	push	r28
     41a:	df 93       	push	r29
     41c:	cd b7       	in	r28, 0x3d	; 61
     41e:	de b7       	in	r29, 0x3e	; 62
     420:	cc 5a       	subi	r28, 0xAC	; 172
     422:	d8 40       	sbci	r29, 0x08	; 8
     424:	cd bf       	out	0x3d, r28	; 61
     426:	de bf       	out	0x3e, r29	; 62
	while(1){
		//if(RadioMonitorMode == TIME_SYNCH) chb_write(0x0000,message,strlen(message));
		nop();
	}
	*/
	SD_init();
     428:	0e 94 32 4b 	call	0x9664	; 0x9664 <SD_init>
	getBootSectorData();
     42c:	0e 94 32 3f 	call	0x7e64	; 0x7e64 <getBootSectorData>
	set_32MHz();
     430:	0e 94 8d 31 	call	0x631a	; 0x631a <set_32MHz>
	while(1){
		CO_collectADC(ADC_CH_1_gc,(uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc),GAIN_1_gc,SPS_1K_gc,128,SampledData);
     434:	80 e0       	ldi	r24, 0x00	; 0
     436:	61 ec       	ldi	r22, 0xC1	; 193
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	2a e0       	ldi	r18, 0x0A	; 10
     43c:	ee 24       	eor	r14, r14
     43e:	ff 24       	eor	r15, r15
     440:	87 01       	movw	r16, r14
     442:	68 94       	set
     444:	e7 f8       	bld	r14, 7
     446:	fe 01       	movw	r30, r28
     448:	31 96       	adiw	r30, 0x01	; 1
     44a:	6f 01       	movw	r12, r30
     44c:	0e 94 c8 08 	call	0x1190	; 0x1190 <CO_collectADC>
		DeciToString(SampledData,128,SampledDataInChars);
     450:	9e 01       	movw	r18, r28
     452:	27 5f       	subi	r18, 0xF7	; 247
     454:	3d 4f       	sbci	r19, 0xFD	; 253
     456:	ce 01       	movw	r24, r28
     458:	01 96       	adiw	r24, 0x01	; 1
     45a:	40 e8       	ldi	r20, 0x80	; 128
     45c:	50 e0       	ldi	r21, 0x00	; 0
     45e:	60 e0       	ldi	r22, 0x00	; 0
     460:	70 e0       	ldi	r23, 0x00	; 0
     462:	0e 94 ae 3e 	call	0x7d5c	; 0x7d5c <DeciToString>
		writeFile("samples",SampledDataInChars,1700);	
     466:	86 e0       	ldi	r24, 0x06	; 6
     468:	90 e2       	ldi	r25, 0x20	; 32
     46a:	9e 01       	movw	r18, r28
     46c:	27 5f       	subi	r18, 0xF7	; 247
     46e:	3d 4f       	sbci	r19, 0xFD	; 253
     470:	b9 01       	movw	r22, r18
     472:	24 ea       	ldi	r18, 0xA4	; 164
     474:	36 e0       	ldi	r19, 0x06	; 6
     476:	40 e0       	ldi	r20, 0x00	; 0
     478:	50 e0       	ldi	r21, 0x00	; 0
     47a:	0e 94 c7 45 	call	0x8b8e	; 0x8b8e <writeFile>
	}		
     47e:	da cf       	rjmp	.-76     	; 0x434 <main+0x28>

00000480 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     480:	cf 93       	push	r28
     482:	df 93       	push	r29
     484:	cd b7       	in	r28, 0x3d	; 61
     486:	de b7       	in	r29, 0x3e	; 62
     488:	6b 97       	sbiw	r28, 0x1b	; 27
     48a:	cd bf       	out	0x3d, r28	; 61
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	8e 8b       	std	Y+22, r24	; 0x16
     490:	9f 8b       	std	Y+23, r25	; 0x17
     492:	68 8f       	std	Y+24, r22	; 0x18
     494:	79 8f       	std	Y+25, r23	; 0x19
     496:	4a 8f       	std	Y+26, r20	; 0x1a
     498:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     49a:	19 82       	std	Y+1, r1	; 0x01
     49c:	1a 82       	std	Y+2, r1	; 0x02
     49e:	1b 82       	std	Y+3, r1	; 0x03
     4a0:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	90 e1       	ldi	r25, 0x10	; 16
     4a6:	a0 e0       	ldi	r26, 0x00	; 0
     4a8:	b0 e0       	ldi	r27, 0x00	; 0
     4aa:	8d 83       	std	Y+5, r24	; 0x05
     4ac:	9e 83       	std	Y+6, r25	; 0x06
     4ae:	af 83       	std	Y+7, r26	; 0x07
     4b0:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     4b2:	19 86       	std	Y+9, r1	; 0x09
     4b4:	1a 86       	std	Y+10, r1	; 0x0a
     4b6:	1b 86       	std	Y+11, r1	; 0x0b
     4b8:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     4ba:	81 e0       	ldi	r24, 0x01	; 1
     4bc:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	92 e0       	ldi	r25, 0x02	; 2
     4c4:	0e 94 1c 1a 	call	0x3438	; 0x3438 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     4c8:	80 e0       	ldi	r24, 0x00	; 0
     4ca:	92 e0       	ldi	r25, 0x02	; 2
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	32 e0       	ldi	r19, 0x02	; 2
     4d0:	f9 01       	movw	r30, r18
     4d2:	21 81       	ldd	r18, Z+1	; 0x01
     4d4:	29 7e       	andi	r18, 0xE9	; 233
     4d6:	fc 01       	movw	r30, r24
     4d8:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     4da:	80 e0       	ldi	r24, 0x00	; 0
     4dc:	92 e0       	ldi	r25, 0x02	; 2
     4de:	20 e0       	ldi	r18, 0x00	; 0
     4e0:	32 e0       	ldi	r19, 0x02	; 2
     4e2:	f9 01       	movw	r30, r18
     4e4:	24 81       	ldd	r18, Z+4	; 0x04
     4e6:	28 7f       	andi	r18, 0xF8	; 248
     4e8:	23 60       	ori	r18, 0x03	; 3
     4ea:	fc 01       	movw	r30, r24
     4ec:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     4ee:	80 e0       	ldi	r24, 0x00	; 0
     4f0:	92 e0       	ldi	r25, 0x02	; 2
     4f2:	20 e0       	ldi	r18, 0x00	; 0
     4f4:	32 e0       	ldi	r19, 0x02	; 2
     4f6:	f9 01       	movw	r30, r18
     4f8:	22 81       	ldd	r18, Z+2	; 0x02
     4fa:	2f 7c       	andi	r18, 0xCF	; 207
     4fc:	fc 01       	movw	r30, r24
     4fe:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     500:	80 e2       	ldi	r24, 0x20	; 32
     502:	92 e0       	ldi	r25, 0x02	; 2
     504:	20 e2       	ldi	r18, 0x20	; 32
     506:	32 e0       	ldi	r19, 0x02	; 2
     508:	f9 01       	movw	r30, r18
     50a:	20 81       	ld	r18, Z
     50c:	20 7e       	andi	r18, 0xE0	; 224
     50e:	21 60       	ori	r18, 0x01	; 1
     510:	fc 01       	movw	r30, r24
     512:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     514:	80 e2       	ldi	r24, 0x20	; 32
     516:	92 e0       	ldi	r25, 0x02	; 2
     518:	29 e0       	ldi	r18, 0x09	; 9
     51a:	fc 01       	movw	r30, r24
     51c:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     51e:	80 e0       	ldi	r24, 0x00	; 0
     520:	92 e0       	ldi	r25, 0x02	; 2
     522:	20 e0       	ldi	r18, 0x00	; 0
     524:	32 e0       	ldi	r19, 0x02	; 2
     526:	f9 01       	movw	r30, r18
     528:	20 81       	ld	r18, Z
     52a:	21 60       	ori	r18, 0x01	; 1
     52c:	fc 01       	movw	r30, r24
     52e:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	92 e0       	ldi	r25, 0x02	; 2
     534:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	92 e0       	ldi	r25, 0x02	; 2
     53c:	60 e2       	ldi	r22, 0x20	; 32
     53e:	72 e0       	ldi	r23, 0x02	; 2
     540:	40 e0       	ldi	r20, 0x00	; 0
     542:	0e 94 cb 1c 	call	0x3996	; 0x3996 <ADC_Offset_Get_Unsigned>
     546:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     548:	80 e0       	ldi	r24, 0x00	; 0
     54a:	92 e0       	ldi	r25, 0x02	; 2
     54c:	20 e0       	ldi	r18, 0x00	; 0
     54e:	32 e0       	ldi	r19, 0x02	; 2
     550:	f9 01       	movw	r30, r18
     552:	20 81       	ld	r18, Z
     554:	2e 7f       	andi	r18, 0xFE	; 254
     556:	fc 01       	movw	r30, r24
     558:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     55a:	80 e2       	ldi	r24, 0x20	; 32
     55c:	92 e0       	ldi	r25, 0x02	; 2
     55e:	fc 01       	movw	r30, r24
     560:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     562:	80 e0       	ldi	r24, 0x00	; 0
     564:	92 e0       	ldi	r25, 0x02	; 2
     566:	20 e0       	ldi	r18, 0x00	; 0
     568:	32 e0       	ldi	r19, 0x02	; 2
     56a:	f9 01       	movw	r30, r18
     56c:	23 81       	ldd	r18, Z+3	; 0x03
     56e:	2f 73       	andi	r18, 0x3F	; 63
     570:	fc 01       	movw	r30, r24
     572:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	92 e0       	ldi	r25, 0x02	; 2
     578:	20 e0       	ldi	r18, 0x00	; 0
     57a:	32 e0       	ldi	r19, 0x02	; 2
     57c:	f9 01       	movw	r30, r18
     57e:	20 81       	ld	r18, Z
     580:	21 60       	ori	r18, 0x01	; 1
     582:	fc 01       	movw	r30, r24
     584:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	92 e0       	ldi	r25, 0x02	; 2
     58a:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     58e:	80 e0       	ldi	r24, 0x00	; 0
     590:	92 e0       	ldi	r25, 0x02	; 2
     592:	20 e0       	ldi	r18, 0x00	; 0
     594:	32 e0       	ldi	r19, 0x02	; 2
     596:	f9 01       	movw	r30, r18
     598:	21 81       	ldd	r18, Z+1	; 0x01
     59a:	28 60       	ori	r18, 0x08	; 8
     59c:	fc 01       	movw	r30, r24
     59e:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     5a0:	1d 86       	std	Y+13, r1	; 0x0d
     5a2:	1e 86       	std	Y+14, r1	; 0x0e
     5a4:	56 c0       	rjmp	.+172    	; 0x652 <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     5a6:	80 e2       	ldi	r24, 0x20	; 32
     5a8:	92 e0       	ldi	r25, 0x02	; 2
     5aa:	fc 01       	movw	r30, r24
     5ac:	83 81       	ldd	r24, Z+3	; 0x03
     5ae:	88 2f       	mov	r24, r24
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	81 70       	andi	r24, 0x01	; 1
     5b4:	90 70       	andi	r25, 0x00	; 0
     5b6:	00 97       	sbiw	r24, 0x00	; 0
     5b8:	b1 f3       	breq	.-20     	; 0x5a6 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     5ba:	2d 89       	ldd	r18, Y+21	; 0x15
     5bc:	80 e2       	ldi	r24, 0x20	; 32
     5be:	92 e0       	ldi	r25, 0x02	; 2
     5c0:	62 2f       	mov	r22, r18
     5c2:	0e 94 75 1a 	call	0x34ea	; 0x34ea <ADC_ResultCh_GetWord_Signed>
     5c6:	8f 87       	std	Y+15, r24	; 0x0f
     5c8:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     5ca:	8f 85       	ldd	r24, Y+15	; 0x0f
     5cc:	98 89       	ldd	r25, Y+16	; 0x10
     5ce:	cc 01       	movw	r24, r24
     5d0:	a0 e0       	ldi	r26, 0x00	; 0
     5d2:	b0 e0       	ldi	r27, 0x00	; 0
     5d4:	29 81       	ldd	r18, Y+1	; 0x01
     5d6:	3a 81       	ldd	r19, Y+2	; 0x02
     5d8:	4b 81       	ldd	r20, Y+3	; 0x03
     5da:	5c 81       	ldd	r21, Y+4	; 0x04
     5dc:	82 0f       	add	r24, r18
     5de:	93 1f       	adc	r25, r19
     5e0:	a4 1f       	adc	r26, r20
     5e2:	b5 1f       	adc	r27, r21
     5e4:	89 83       	std	Y+1, r24	; 0x01
     5e6:	9a 83       	std	Y+2, r25	; 0x02
     5e8:	ab 83       	std	Y+3, r26	; 0x03
     5ea:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     5ec:	8f 85       	ldd	r24, Y+15	; 0x0f
     5ee:	98 89       	ldd	r25, Y+16	; 0x10
     5f0:	9c 01       	movw	r18, r24
     5f2:	40 e0       	ldi	r20, 0x00	; 0
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	89 85       	ldd	r24, Y+9	; 0x09
     5f8:	9a 85       	ldd	r25, Y+10	; 0x0a
     5fa:	ab 85       	ldd	r26, Y+11	; 0x0b
     5fc:	bc 85       	ldd	r27, Y+12	; 0x0c
     5fe:	82 17       	cp	r24, r18
     600:	93 07       	cpc	r25, r19
     602:	a4 07       	cpc	r26, r20
     604:	b5 07       	cpc	r27, r21
     606:	48 f4       	brcc	.+18     	; 0x61a <CO_collectTemp+0x19a>
     608:	8f 85       	ldd	r24, Y+15	; 0x0f
     60a:	98 89       	ldd	r25, Y+16	; 0x10
     60c:	cc 01       	movw	r24, r24
     60e:	a0 e0       	ldi	r26, 0x00	; 0
     610:	b0 e0       	ldi	r27, 0x00	; 0
     612:	89 87       	std	Y+9, r24	; 0x09
     614:	9a 87       	std	Y+10, r25	; 0x0a
     616:	ab 87       	std	Y+11, r26	; 0x0b
     618:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     61a:	8f 85       	ldd	r24, Y+15	; 0x0f
     61c:	98 89       	ldd	r25, Y+16	; 0x10
     61e:	9c 01       	movw	r18, r24
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	8d 81       	ldd	r24, Y+5	; 0x05
     626:	9e 81       	ldd	r25, Y+6	; 0x06
     628:	af 81       	ldd	r26, Y+7	; 0x07
     62a:	b8 85       	ldd	r27, Y+8	; 0x08
     62c:	28 17       	cp	r18, r24
     62e:	39 07       	cpc	r19, r25
     630:	4a 07       	cpc	r20, r26
     632:	5b 07       	cpc	r21, r27
     634:	48 f4       	brcc	.+18     	; 0x648 <CO_collectTemp+0x1c8>
     636:	8f 85       	ldd	r24, Y+15	; 0x0f
     638:	98 89       	ldd	r25, Y+16	; 0x10
     63a:	cc 01       	movw	r24, r24
     63c:	a0 e0       	ldi	r26, 0x00	; 0
     63e:	b0 e0       	ldi	r27, 0x00	; 0
     640:	8d 83       	std	Y+5, r24	; 0x05
     642:	9e 83       	std	Y+6, r25	; 0x06
     644:	af 83       	std	Y+7, r26	; 0x07
     646:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     648:	8d 85       	ldd	r24, Y+13	; 0x0d
     64a:	9e 85       	ldd	r25, Y+14	; 0x0e
     64c:	01 96       	adiw	r24, 0x01	; 1
     64e:	8d 87       	std	Y+13, r24	; 0x0d
     650:	9e 87       	std	Y+14, r25	; 0x0e
     652:	8d 85       	ldd	r24, Y+13	; 0x0d
     654:	9e 85       	ldd	r25, Y+14	; 0x0e
     656:	f4 e0       	ldi	r31, 0x04	; 4
     658:	80 30       	cpi	r24, 0x00	; 0
     65a:	9f 07       	cpc	r25, r31
     65c:	08 f4       	brcc	.+2      	; 0x660 <CO_collectTemp+0x1e0>
     65e:	a3 cf       	rjmp	.-186    	; 0x5a6 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     660:	80 e0       	ldi	r24, 0x00	; 0
     662:	92 e0       	ldi	r25, 0x02	; 2
     664:	20 e0       	ldi	r18, 0x00	; 0
     666:	32 e0       	ldi	r19, 0x02	; 2
     668:	f9 01       	movw	r30, r18
     66a:	21 81       	ldd	r18, Z+1	; 0x01
     66c:	27 7f       	andi	r18, 0xF7	; 247
     66e:	fc 01       	movw	r30, r24
     670:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	92 e0       	ldi	r25, 0x02	; 2
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	32 e0       	ldi	r19, 0x02	; 2
     67a:	f9 01       	movw	r30, r18
     67c:	20 81       	ld	r18, Z
     67e:	22 60       	ori	r18, 0x02	; 2
     680:	fc 01       	movw	r30, r24
     682:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     684:	80 e0       	ldi	r24, 0x00	; 0
     686:	92 e0       	ldi	r25, 0x02	; 2
     688:	20 e0       	ldi	r18, 0x00	; 0
     68a:	32 e0       	ldi	r19, 0x02	; 2
     68c:	f9 01       	movw	r30, r18
     68e:	20 81       	ld	r18, Z
     690:	2e 7f       	andi	r18, 0xFE	; 254
     692:	fc 01       	movw	r30, r24
     694:	20 83       	st	Z, r18

	ADCPower(FALSE);
     696:	80 e0       	ldi	r24, 0x00	; 0
     698:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

	average = sum / NUM_SAMPLES;
     69c:	89 81       	ldd	r24, Y+1	; 0x01
     69e:	9a 81       	ldd	r25, Y+2	; 0x02
     6a0:	ab 81       	ldd	r26, Y+3	; 0x03
     6a2:	bc 81       	ldd	r27, Y+4	; 0x04
     6a4:	07 2e       	mov	r0, r23
     6a6:	7a e0       	ldi	r23, 0x0A	; 10
     6a8:	b6 95       	lsr	r27
     6aa:	a7 95       	ror	r26
     6ac:	97 95       	ror	r25
     6ae:	87 95       	ror	r24
     6b0:	7a 95       	dec	r23
     6b2:	d1 f7       	brne	.-12     	; 0x6a8 <CO_collectTemp+0x228>
     6b4:	70 2d       	mov	r23, r0
     6b6:	89 8b       	std	Y+17, r24	; 0x11
     6b8:	9a 8b       	std	Y+18, r25	; 0x12
     6ba:	ab 8b       	std	Y+19, r26	; 0x13
     6bc:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     6be:	89 89       	ldd	r24, Y+17	; 0x11
     6c0:	9a 89       	ldd	r25, Y+18	; 0x12
     6c2:	ab 89       	ldd	r26, Y+19	; 0x13
     6c4:	bc 89       	ldd	r27, Y+20	; 0x14
     6c6:	28 ee       	ldi	r18, 0xE8	; 232
     6c8:	33 e0       	ldi	r19, 0x03	; 3
     6ca:	40 e0       	ldi	r20, 0x00	; 0
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	bc 01       	movw	r22, r24
     6d0:	cd 01       	movw	r24, r26
     6d2:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
     6d6:	dc 01       	movw	r26, r24
     6d8:	cb 01       	movw	r24, r22
     6da:	2f ef       	ldi	r18, 0xFF	; 255
     6dc:	3f e0       	ldi	r19, 0x0F	; 15
     6de:	40 e0       	ldi	r20, 0x00	; 0
     6e0:	50 e0       	ldi	r21, 0x00	; 0
     6e2:	bc 01       	movw	r22, r24
     6e4:	cd 01       	movw	r24, r26
     6e6:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
     6ea:	da 01       	movw	r26, r20
     6ec:	c9 01       	movw	r24, r18
     6ee:	9c 01       	movw	r18, r24
     6f0:	22 53       	subi	r18, 0x32	; 50
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	8e 89       	ldd	r24, Y+22	; 0x16
     6f6:	9f 89       	ldd	r25, Y+23	; 0x17
     6f8:	fc 01       	movw	r30, r24
     6fa:	20 83       	st	Z, r18
     6fc:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     6fe:	89 85       	ldd	r24, Y+9	; 0x09
     700:	9a 85       	ldd	r25, Y+10	; 0x0a
     702:	ab 85       	ldd	r26, Y+11	; 0x0b
     704:	bc 85       	ldd	r27, Y+12	; 0x0c
     706:	28 ee       	ldi	r18, 0xE8	; 232
     708:	33 e0       	ldi	r19, 0x03	; 3
     70a:	40 e0       	ldi	r20, 0x00	; 0
     70c:	50 e0       	ldi	r21, 0x00	; 0
     70e:	bc 01       	movw	r22, r24
     710:	cd 01       	movw	r24, r26
     712:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
     716:	dc 01       	movw	r26, r24
     718:	cb 01       	movw	r24, r22
     71a:	2f ef       	ldi	r18, 0xFF	; 255
     71c:	3f e0       	ldi	r19, 0x0F	; 15
     71e:	40 e0       	ldi	r20, 0x00	; 0
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	bc 01       	movw	r22, r24
     724:	cd 01       	movw	r24, r26
     726:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
     72a:	da 01       	movw	r26, r20
     72c:	c9 01       	movw	r24, r18
     72e:	9c 01       	movw	r18, r24
     730:	22 53       	subi	r18, 0x32	; 50
     732:	30 40       	sbci	r19, 0x00	; 0
     734:	8a 8d       	ldd	r24, Y+26	; 0x1a
     736:	9b 8d       	ldd	r25, Y+27	; 0x1b
     738:	fc 01       	movw	r30, r24
     73a:	20 83       	st	Z, r18
     73c:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     73e:	8d 81       	ldd	r24, Y+5	; 0x05
     740:	9e 81       	ldd	r25, Y+6	; 0x06
     742:	af 81       	ldd	r26, Y+7	; 0x07
     744:	b8 85       	ldd	r27, Y+8	; 0x08
     746:	28 ee       	ldi	r18, 0xE8	; 232
     748:	33 e0       	ldi	r19, 0x03	; 3
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	50 e0       	ldi	r21, 0x00	; 0
     74e:	bc 01       	movw	r22, r24
     750:	cd 01       	movw	r24, r26
     752:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
     756:	dc 01       	movw	r26, r24
     758:	cb 01       	movw	r24, r22
     75a:	2f ef       	ldi	r18, 0xFF	; 255
     75c:	3f e0       	ldi	r19, 0x0F	; 15
     75e:	40 e0       	ldi	r20, 0x00	; 0
     760:	50 e0       	ldi	r21, 0x00	; 0
     762:	bc 01       	movw	r22, r24
     764:	cd 01       	movw	r24, r26
     766:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
     76a:	da 01       	movw	r26, r20
     76c:	c9 01       	movw	r24, r18
     76e:	9c 01       	movw	r18, r24
     770:	22 53       	subi	r18, 0x32	; 50
     772:	30 40       	sbci	r19, 0x00	; 0
     774:	88 8d       	ldd	r24, Y+24	; 0x18
     776:	99 8d       	ldd	r25, Y+25	; 0x19
     778:	fc 01       	movw	r30, r24
     77a:	20 83       	st	Z, r18
     77c:	31 83       	std	Z+1, r19	; 0x01
}
     77e:	6b 96       	adiw	r28, 0x1b	; 27
     780:	cd bf       	out	0x3d, r28	; 61
     782:	de bf       	out	0x3e, r29	; 62
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	08 95       	ret

0000078a <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     78a:	0f 93       	push	r16
     78c:	1f 93       	push	r17
     78e:	cf 93       	push	r28
     790:	df 93       	push	r29
     792:	cd b7       	in	r28, 0x3d	; 61
     794:	de b7       	in	r29, 0x3e	; 62
     796:	a9 97       	sbiw	r28, 0x29	; 41
     798:	cd bf       	out	0x3d, r28	; 61
     79a:	de bf       	out	0x3e, r29	; 62
     79c:	8c a3       	lds	r24, 0x5c
     79e:	9d a3       	lds	r25, 0x5d
     7a0:	6e a3       	lds	r22, 0x5e
     7a2:	7f a3       	lds	r23, 0x5f
     7a4:	48 a7       	lds	r20, 0x78
     7a6:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     7a8:	19 82       	std	Y+1, r1	; 0x01
     7aa:	1a 82       	std	Y+2, r1	; 0x02
     7ac:	1b 82       	std	Y+3, r1	; 0x03
     7ae:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     7b0:	80 e0       	ldi	r24, 0x00	; 0
     7b2:	90 e1       	ldi	r25, 0x10	; 16
     7b4:	a0 e0       	ldi	r26, 0x00	; 0
     7b6:	b0 e0       	ldi	r27, 0x00	; 0
     7b8:	8d 83       	std	Y+5, r24	; 0x05
     7ba:	9e 83       	std	Y+6, r25	; 0x06
     7bc:	af 83       	std	Y+7, r26	; 0x07
     7be:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     7c0:	19 86       	std	Y+9, r1	; 0x09
     7c2:	1a 86       	std	Y+10, r1	; 0x0a
     7c4:	1b 86       	std	Y+11, r1	; 0x0b
     7c6:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     7c8:	81 e0       	ldi	r24, 0x01	; 1
     7ca:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     7ce:	84 e0       	ldi	r24, 0x04	; 4
     7d0:	60 e0       	ldi	r22, 0x00	; 0
     7d2:	0e 94 a6 32 	call	0x654c	; 0x654c <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     7d6:	84 e0       	ldi	r24, 0x04	; 4
     7d8:	60 e0       	ldi	r22, 0x00	; 0
     7da:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
     7de:	80 e0       	ldi	r24, 0x00	; 0
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	a8 ec       	ldi	r26, 0xC8	; 200
     7e4:	b2 e4       	ldi	r27, 0x42	; 66
     7e6:	8d 8b       	std	Y+21, r24	; 0x15
     7e8:	9e 8b       	std	Y+22, r25	; 0x16
     7ea:	af 8b       	std	Y+23, r26	; 0x17
     7ec:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     7ee:	6d 89       	ldd	r22, Y+21	; 0x15
     7f0:	7e 89       	ldd	r23, Y+22	; 0x16
     7f2:	8f 89       	ldd	r24, Y+23	; 0x17
     7f4:	98 8d       	ldd	r25, Y+24	; 0x18
     7f6:	20 e0       	ldi	r18, 0x00	; 0
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	4a ef       	ldi	r20, 0xFA	; 250
     7fc:	55 e4       	ldi	r21, 0x45	; 69
     7fe:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
     802:	dc 01       	movw	r26, r24
     804:	cb 01       	movw	r24, r22
     806:	89 8f       	std	Y+25, r24	; 0x19
     808:	9a 8f       	std	Y+26, r25	; 0x1a
     80a:	ab 8f       	std	Y+27, r26	; 0x1b
     80c:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     80e:	11 e0       	ldi	r17, 0x01	; 1
     810:	69 8d       	ldd	r22, Y+25	; 0x19
     812:	7a 8d       	ldd	r23, Y+26	; 0x1a
     814:	8b 8d       	ldd	r24, Y+27	; 0x1b
     816:	9c 8d       	ldd	r25, Y+28	; 0x1c
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	30 e0       	ldi	r19, 0x00	; 0
     81c:	40 e8       	ldi	r20, 0x80	; 128
     81e:	5f e3       	ldi	r21, 0x3F	; 63
     820:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
     824:	88 23       	and	r24, r24
     826:	0c f0       	brlt	.+2      	; 0x82a <CO_collectBatt+0xa0>
     828:	10 e0       	ldi	r17, 0x00	; 0
     82a:	11 23       	and	r17, r17
     82c:	29 f0       	breq	.+10     	; 0x838 <CO_collectBatt+0xae>
		__ticks = 1;
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	90 e0       	ldi	r25, 0x00	; 0
     832:	8d 8f       	std	Y+29, r24	; 0x1d
     834:	9e 8f       	std	Y+30, r25	; 0x1e
     836:	46 c0       	rjmp	.+140    	; 0x8c4 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     838:	11 e0       	ldi	r17, 0x01	; 1
     83a:	69 8d       	ldd	r22, Y+25	; 0x19
     83c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     83e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     840:	9c 8d       	ldd	r25, Y+28	; 0x1c
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	3f ef       	ldi	r19, 0xFF	; 255
     846:	4f e7       	ldi	r20, 0x7F	; 127
     848:	57 e4       	ldi	r21, 0x47	; 71
     84a:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
     84e:	18 16       	cp	r1, r24
     850:	0c f0       	brlt	.+2      	; 0x854 <CO_collectBatt+0xca>
     852:	10 e0       	ldi	r17, 0x00	; 0
     854:	11 23       	and	r17, r17
     856:	61 f1       	breq	.+88     	; 0x8b0 <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     858:	6d 89       	ldd	r22, Y+21	; 0x15
     85a:	7e 89       	ldd	r23, Y+22	; 0x16
     85c:	8f 89       	ldd	r24, Y+23	; 0x17
     85e:	98 8d       	ldd	r25, Y+24	; 0x18
     860:	20 e0       	ldi	r18, 0x00	; 0
     862:	30 e0       	ldi	r19, 0x00	; 0
     864:	40 e2       	ldi	r20, 0x20	; 32
     866:	51 e4       	ldi	r21, 0x41	; 65
     868:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
     86c:	dc 01       	movw	r26, r24
     86e:	cb 01       	movw	r24, r22
     870:	bc 01       	movw	r22, r24
     872:	cd 01       	movw	r24, r26
     874:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
     878:	dc 01       	movw	r26, r24
     87a:	cb 01       	movw	r24, r22
     87c:	8d 8f       	std	Y+29, r24	; 0x1d
     87e:	9e 8f       	std	Y+30, r25	; 0x1e
     880:	12 c0       	rjmp	.+36     	; 0x8a6 <CO_collectBatt+0x11c>
     882:	80 e2       	ldi	r24, 0x20	; 32
     884:	93 e0       	ldi	r25, 0x03	; 3
     886:	8f 8f       	std	Y+31, r24	; 0x1f
     888:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     88a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     88c:	98 a1       	lds	r25, 0x48
     88e:	8c 01       	movw	r16, r24
     890:	c8 01       	movw	r24, r16
     892:	01 97       	sbiw	r24, 0x01	; 1
     894:	f1 f7       	brne	.-4      	; 0x892 <CO_collectBatt+0x108>
     896:	8c 01       	movw	r16, r24
     898:	0f 8f       	std	Y+31, r16	; 0x1f
     89a:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     89c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     89e:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8a0:	01 97       	sbiw	r24, 0x01	; 1
     8a2:	8d 8f       	std	Y+29, r24	; 0x1d
     8a4:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8a6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8a8:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8aa:	00 97       	sbiw	r24, 0x00	; 0
     8ac:	51 f7       	brne	.-44     	; 0x882 <CO_collectBatt+0xf8>
     8ae:	17 c0       	rjmp	.+46     	; 0x8de <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8b0:	69 8d       	ldd	r22, Y+25	; 0x19
     8b2:	7a 8d       	ldd	r23, Y+26	; 0x1a
     8b4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8b6:	9c 8d       	ldd	r25, Y+28	; 0x1c
     8b8:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
     8bc:	dc 01       	movw	r26, r24
     8be:	cb 01       	movw	r24, r22
     8c0:	8d 8f       	std	Y+29, r24	; 0x1d
     8c2:	9e 8f       	std	Y+30, r25	; 0x1e
     8c4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8c6:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8c8:	89 a3       	lds	r24, 0x59
     8ca:	9a a3       	lds	r25, 0x5a
     8cc:	89 a1       	lds	r24, 0x49
     8ce:	9a a1       	lds	r25, 0x4a
     8d0:	8c 01       	movw	r16, r24
     8d2:	f8 01       	movw	r30, r16
     8d4:	31 97       	sbiw	r30, 0x01	; 1
     8d6:	f1 f7       	brne	.-4      	; 0x8d4 <CO_collectBatt+0x14a>
     8d8:	8f 01       	movw	r16, r30
     8da:	09 a3       	lds	r16, 0x59
     8dc:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     8de:	80 e4       	ldi	r24, 0x40	; 64
     8e0:	92 e0       	ldi	r25, 0x02	; 2
     8e2:	0e 94 1c 1a 	call	0x3438	; 0x3438 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     8e6:	80 e4       	ldi	r24, 0x40	; 64
     8e8:	92 e0       	ldi	r25, 0x02	; 2
     8ea:	20 e4       	ldi	r18, 0x40	; 64
     8ec:	32 e0       	ldi	r19, 0x02	; 2
     8ee:	f9 01       	movw	r30, r18
     8f0:	21 81       	ldd	r18, Z+1	; 0x01
     8f2:	29 7e       	andi	r18, 0xE9	; 233
     8f4:	fc 01       	movw	r30, r24
     8f6:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     8f8:	80 e4       	ldi	r24, 0x40	; 64
     8fa:	92 e0       	ldi	r25, 0x02	; 2
     8fc:	20 e4       	ldi	r18, 0x40	; 64
     8fe:	32 e0       	ldi	r19, 0x02	; 2
     900:	f9 01       	movw	r30, r18
     902:	24 81       	ldd	r18, Z+4	; 0x04
     904:	28 7f       	andi	r18, 0xF8	; 248
     906:	23 60       	ori	r18, 0x03	; 3
     908:	fc 01       	movw	r30, r24
     90a:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	92 e0       	ldi	r25, 0x02	; 2
     910:	20 e4       	ldi	r18, 0x40	; 64
     912:	32 e0       	ldi	r19, 0x02	; 2
     914:	f9 01       	movw	r30, r18
     916:	22 81       	ldd	r18, Z+2	; 0x02
     918:	2f 7c       	andi	r18, 0xCF	; 207
     91a:	fc 01       	movw	r30, r24
     91c:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     91e:	80 e6       	ldi	r24, 0x60	; 96
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	20 e6       	ldi	r18, 0x60	; 96
     924:	32 e0       	ldi	r19, 0x02	; 2
     926:	f9 01       	movw	r30, r18
     928:	20 81       	ld	r18, Z
     92a:	20 7e       	andi	r18, 0xE0	; 224
     92c:	21 60       	ori	r18, 0x01	; 1
     92e:	fc 01       	movw	r30, r24
     930:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     932:	80 e6       	ldi	r24, 0x60	; 96
     934:	92 e0       	ldi	r25, 0x02	; 2
     936:	29 e0       	ldi	r18, 0x09	; 9
     938:	fc 01       	movw	r30, r24
     93a:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     93c:	80 e4       	ldi	r24, 0x40	; 64
     93e:	92 e0       	ldi	r25, 0x02	; 2
     940:	20 e4       	ldi	r18, 0x40	; 64
     942:	32 e0       	ldi	r19, 0x02	; 2
     944:	f9 01       	movw	r30, r18
     946:	20 81       	ld	r18, Z
     948:	21 60       	ori	r18, 0x01	; 1
     94a:	fc 01       	movw	r30, r24
     94c:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     94e:	80 e4       	ldi	r24, 0x40	; 64
     950:	92 e0       	ldi	r25, 0x02	; 2
     952:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     956:	80 e4       	ldi	r24, 0x40	; 64
     958:	92 e0       	ldi	r25, 0x02	; 2
     95a:	60 e6       	ldi	r22, 0x60	; 96
     95c:	72 e0       	ldi	r23, 0x02	; 2
     95e:	40 e0       	ldi	r20, 0x00	; 0
     960:	0e 94 cb 1c 	call	0x3996	; 0x3996 <ADC_Offset_Get_Unsigned>
     964:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     966:	80 e4       	ldi	r24, 0x40	; 64
     968:	92 e0       	ldi	r25, 0x02	; 2
     96a:	20 e4       	ldi	r18, 0x40	; 64
     96c:	32 e0       	ldi	r19, 0x02	; 2
     96e:	f9 01       	movw	r30, r18
     970:	20 81       	ld	r18, Z
     972:	2e 7f       	andi	r18, 0xFE	; 254
     974:	fc 01       	movw	r30, r24
     976:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     978:	80 e6       	ldi	r24, 0x60	; 96
     97a:	92 e0       	ldi	r25, 0x02	; 2
     97c:	fc 01       	movw	r30, r24
     97e:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     980:	80 e4       	ldi	r24, 0x40	; 64
     982:	92 e0       	ldi	r25, 0x02	; 2
     984:	20 e4       	ldi	r18, 0x40	; 64
     986:	32 e0       	ldi	r19, 0x02	; 2
     988:	f9 01       	movw	r30, r18
     98a:	23 81       	ldd	r18, Z+3	; 0x03
     98c:	2f 73       	andi	r18, 0x3F	; 63
     98e:	fc 01       	movw	r30, r24
     990:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     992:	80 e4       	ldi	r24, 0x40	; 64
     994:	92 e0       	ldi	r25, 0x02	; 2
     996:	20 e4       	ldi	r18, 0x40	; 64
     998:	32 e0       	ldi	r19, 0x02	; 2
     99a:	f9 01       	movw	r30, r18
     99c:	20 81       	ld	r18, Z
     99e:	21 60       	ori	r18, 0x01	; 1
     9a0:	fc 01       	movw	r30, r24
     9a2:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     9a4:	80 e4       	ldi	r24, 0x40	; 64
     9a6:	92 e0       	ldi	r25, 0x02	; 2
     9a8:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     9ac:	80 e4       	ldi	r24, 0x40	; 64
     9ae:	92 e0       	ldi	r25, 0x02	; 2
     9b0:	20 e4       	ldi	r18, 0x40	; 64
     9b2:	32 e0       	ldi	r19, 0x02	; 2
     9b4:	f9 01       	movw	r30, r18
     9b6:	21 81       	ldd	r18, Z+1	; 0x01
     9b8:	28 60       	ori	r18, 0x08	; 8
     9ba:	fc 01       	movw	r30, r24
     9bc:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     9be:	1d 86       	std	Y+13, r1	; 0x0d
     9c0:	1e 86       	std	Y+14, r1	; 0x0e
     9c2:	56 c0       	rjmp	.+172    	; 0xa70 <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     9c4:	80 e6       	ldi	r24, 0x60	; 96
     9c6:	92 e0       	ldi	r25, 0x02	; 2
     9c8:	fc 01       	movw	r30, r24
     9ca:	83 81       	ldd	r24, Z+3	; 0x03
     9cc:	88 2f       	mov	r24, r24
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	81 70       	andi	r24, 0x01	; 1
     9d2:	90 70       	andi	r25, 0x00	; 0
     9d4:	00 97       	sbiw	r24, 0x00	; 0
     9d6:	b1 f3       	breq	.-20     	; 0x9c4 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     9d8:	2b a1       	lds	r18, 0x4b
     9da:	80 e6       	ldi	r24, 0x60	; 96
     9dc:	92 e0       	ldi	r25, 0x02	; 2
     9de:	62 2f       	mov	r22, r18
     9e0:	0e 94 75 1a 	call	0x34ea	; 0x34ea <ADC_ResultCh_GetWord_Signed>
     9e4:	8f 87       	std	Y+15, r24	; 0x0f
     9e6:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     9e8:	8f 85       	ldd	r24, Y+15	; 0x0f
     9ea:	98 89       	ldd	r25, Y+16	; 0x10
     9ec:	cc 01       	movw	r24, r24
     9ee:	a0 e0       	ldi	r26, 0x00	; 0
     9f0:	b0 e0       	ldi	r27, 0x00	; 0
     9f2:	29 81       	ldd	r18, Y+1	; 0x01
     9f4:	3a 81       	ldd	r19, Y+2	; 0x02
     9f6:	4b 81       	ldd	r20, Y+3	; 0x03
     9f8:	5c 81       	ldd	r21, Y+4	; 0x04
     9fa:	82 0f       	add	r24, r18
     9fc:	93 1f       	adc	r25, r19
     9fe:	a4 1f       	adc	r26, r20
     a00:	b5 1f       	adc	r27, r21
     a02:	89 83       	std	Y+1, r24	; 0x01
     a04:	9a 83       	std	Y+2, r25	; 0x02
     a06:	ab 83       	std	Y+3, r26	; 0x03
     a08:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     a0a:	8f 85       	ldd	r24, Y+15	; 0x0f
     a0c:	98 89       	ldd	r25, Y+16	; 0x10
     a0e:	9c 01       	movw	r18, r24
     a10:	40 e0       	ldi	r20, 0x00	; 0
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	89 85       	ldd	r24, Y+9	; 0x09
     a16:	9a 85       	ldd	r25, Y+10	; 0x0a
     a18:	ab 85       	ldd	r26, Y+11	; 0x0b
     a1a:	bc 85       	ldd	r27, Y+12	; 0x0c
     a1c:	82 17       	cp	r24, r18
     a1e:	93 07       	cpc	r25, r19
     a20:	a4 07       	cpc	r26, r20
     a22:	b5 07       	cpc	r27, r21
     a24:	48 f4       	brcc	.+18     	; 0xa38 <CO_collectBatt+0x2ae>
     a26:	8f 85       	ldd	r24, Y+15	; 0x0f
     a28:	98 89       	ldd	r25, Y+16	; 0x10
     a2a:	cc 01       	movw	r24, r24
     a2c:	a0 e0       	ldi	r26, 0x00	; 0
     a2e:	b0 e0       	ldi	r27, 0x00	; 0
     a30:	89 87       	std	Y+9, r24	; 0x09
     a32:	9a 87       	std	Y+10, r25	; 0x0a
     a34:	ab 87       	std	Y+11, r26	; 0x0b
     a36:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     a38:	8f 85       	ldd	r24, Y+15	; 0x0f
     a3a:	98 89       	ldd	r25, Y+16	; 0x10
     a3c:	9c 01       	movw	r18, r24
     a3e:	40 e0       	ldi	r20, 0x00	; 0
     a40:	50 e0       	ldi	r21, 0x00	; 0
     a42:	8d 81       	ldd	r24, Y+5	; 0x05
     a44:	9e 81       	ldd	r25, Y+6	; 0x06
     a46:	af 81       	ldd	r26, Y+7	; 0x07
     a48:	b8 85       	ldd	r27, Y+8	; 0x08
     a4a:	28 17       	cp	r18, r24
     a4c:	39 07       	cpc	r19, r25
     a4e:	4a 07       	cpc	r20, r26
     a50:	5b 07       	cpc	r21, r27
     a52:	48 f4       	brcc	.+18     	; 0xa66 <CO_collectBatt+0x2dc>
     a54:	8f 85       	ldd	r24, Y+15	; 0x0f
     a56:	98 89       	ldd	r25, Y+16	; 0x10
     a58:	cc 01       	movw	r24, r24
     a5a:	a0 e0       	ldi	r26, 0x00	; 0
     a5c:	b0 e0       	ldi	r27, 0x00	; 0
     a5e:	8d 83       	std	Y+5, r24	; 0x05
     a60:	9e 83       	std	Y+6, r25	; 0x06
     a62:	af 83       	std	Y+7, r26	; 0x07
     a64:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a66:	8d 85       	ldd	r24, Y+13	; 0x0d
     a68:	9e 85       	ldd	r25, Y+14	; 0x0e
     a6a:	01 96       	adiw	r24, 0x01	; 1
     a6c:	8d 87       	std	Y+13, r24	; 0x0d
     a6e:	9e 87       	std	Y+14, r25	; 0x0e
     a70:	8d 85       	ldd	r24, Y+13	; 0x0d
     a72:	9e 85       	ldd	r25, Y+14	; 0x0e
     a74:	f4 e0       	ldi	r31, 0x04	; 4
     a76:	80 30       	cpi	r24, 0x00	; 0
     a78:	9f 07       	cpc	r25, r31
     a7a:	08 f4       	brcc	.+2      	; 0xa7e <CO_collectBatt+0x2f4>
     a7c:	a3 cf       	rjmp	.-186    	; 0x9c4 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     a7e:	80 e4       	ldi	r24, 0x40	; 64
     a80:	92 e0       	ldi	r25, 0x02	; 2
     a82:	20 e4       	ldi	r18, 0x40	; 64
     a84:	32 e0       	ldi	r19, 0x02	; 2
     a86:	f9 01       	movw	r30, r18
     a88:	21 81       	ldd	r18, Z+1	; 0x01
     a8a:	27 7f       	andi	r18, 0xF7	; 247
     a8c:	fc 01       	movw	r30, r24
     a8e:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     a90:	80 e4       	ldi	r24, 0x40	; 64
     a92:	92 e0       	ldi	r25, 0x02	; 2
     a94:	20 e4       	ldi	r18, 0x40	; 64
     a96:	32 e0       	ldi	r19, 0x02	; 2
     a98:	f9 01       	movw	r30, r18
     a9a:	20 81       	ld	r18, Z
     a9c:	2e 7f       	andi	r18, 0xFE	; 254
     a9e:	fc 01       	movw	r30, r24
     aa0:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
     aa4:	9a 81       	ldd	r25, Y+2	; 0x02
     aa6:	ab 81       	ldd	r26, Y+3	; 0x03
     aa8:	bc 81       	ldd	r27, Y+4	; 0x04
     aaa:	07 2e       	mov	r0, r23
     aac:	7a e0       	ldi	r23, 0x0A	; 10
     aae:	b6 95       	lsr	r27
     ab0:	a7 95       	ror	r26
     ab2:	97 95       	ror	r25
     ab4:	87 95       	ror	r24
     ab6:	7a 95       	dec	r23
     ab8:	d1 f7       	brne	.-12     	; 0xaae <CO_collectBatt+0x324>
     aba:	70 2d       	mov	r23, r0
     abc:	89 8b       	std	Y+17, r24	; 0x11
     abe:	9a 8b       	std	Y+18, r25	; 0x12
     ac0:	ab 8b       	std	Y+19, r26	; 0x13
     ac2:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     ac4:	84 e0       	ldi	r24, 0x04	; 4
     ac6:	60 e0       	ldi	r22, 0x00	; 0
     ac8:	0e 94 0a 33 	call	0x6614	; 0x6614 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     acc:	80 e0       	ldi	r24, 0x00	; 0
     ace:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     ad2:	89 89       	ldd	r24, Y+17	; 0x11
     ad4:	9a 89       	ldd	r25, Y+18	; 0x12
     ad6:	ab 89       	ldd	r26, Y+19	; 0x13
     ad8:	bc 89       	ldd	r27, Y+20	; 0x14
     ada:	28 ee       	ldi	r18, 0xE8	; 232
     adc:	33 e0       	ldi	r19, 0x03	; 3
     ade:	40 e0       	ldi	r20, 0x00	; 0
     ae0:	50 e0       	ldi	r21, 0x00	; 0
     ae2:	bc 01       	movw	r22, r24
     ae4:	cd 01       	movw	r24, r26
     ae6:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
     aea:	dc 01       	movw	r26, r24
     aec:	cb 01       	movw	r24, r22
     aee:	2f ef       	ldi	r18, 0xFF	; 255
     af0:	3f e0       	ldi	r19, 0x0F	; 15
     af2:	40 e0       	ldi	r20, 0x00	; 0
     af4:	50 e0       	ldi	r21, 0x00	; 0
     af6:	bc 01       	movw	r22, r24
     af8:	cd 01       	movw	r24, r26
     afa:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
     afe:	da 01       	movw	r26, r20
     b00:	c9 01       	movw	r24, r18
     b02:	9c 01       	movw	r18, r24
     b04:	22 53       	subi	r18, 0x32	; 50
     b06:	30 40       	sbci	r19, 0x00	; 0
     b08:	8c a1       	lds	r24, 0x4c
     b0a:	9d a1       	lds	r25, 0x4d
     b0c:	fc 01       	movw	r30, r24
     b0e:	20 83       	st	Z, r18
     b10:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     b12:	89 85       	ldd	r24, Y+9	; 0x09
     b14:	9a 85       	ldd	r25, Y+10	; 0x0a
     b16:	ab 85       	ldd	r26, Y+11	; 0x0b
     b18:	bc 85       	ldd	r27, Y+12	; 0x0c
     b1a:	28 ee       	ldi	r18, 0xE8	; 232
     b1c:	33 e0       	ldi	r19, 0x03	; 3
     b1e:	40 e0       	ldi	r20, 0x00	; 0
     b20:	50 e0       	ldi	r21, 0x00	; 0
     b22:	bc 01       	movw	r22, r24
     b24:	cd 01       	movw	r24, r26
     b26:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
     b2a:	dc 01       	movw	r26, r24
     b2c:	cb 01       	movw	r24, r22
     b2e:	2f ef       	ldi	r18, 0xFF	; 255
     b30:	3f e0       	ldi	r19, 0x0F	; 15
     b32:	40 e0       	ldi	r20, 0x00	; 0
     b34:	50 e0       	ldi	r21, 0x00	; 0
     b36:	bc 01       	movw	r22, r24
     b38:	cd 01       	movw	r24, r26
     b3a:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
     b3e:	da 01       	movw	r26, r20
     b40:	c9 01       	movw	r24, r18
     b42:	9c 01       	movw	r18, r24
     b44:	22 53       	subi	r18, 0x32	; 50
     b46:	30 40       	sbci	r19, 0x00	; 0
     b48:	88 a5       	lds	r24, 0x68
     b4a:	99 a5       	lds	r25, 0x69
     b4c:	fc 01       	movw	r30, r24
     b4e:	20 83       	st	Z, r18
     b50:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     b52:	8d 81       	ldd	r24, Y+5	; 0x05
     b54:	9e 81       	ldd	r25, Y+6	; 0x06
     b56:	af 81       	ldd	r26, Y+7	; 0x07
     b58:	b8 85       	ldd	r27, Y+8	; 0x08
     b5a:	28 ee       	ldi	r18, 0xE8	; 232
     b5c:	33 e0       	ldi	r19, 0x03	; 3
     b5e:	40 e0       	ldi	r20, 0x00	; 0
     b60:	50 e0       	ldi	r21, 0x00	; 0
     b62:	bc 01       	movw	r22, r24
     b64:	cd 01       	movw	r24, r26
     b66:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
     b6a:	dc 01       	movw	r26, r24
     b6c:	cb 01       	movw	r24, r22
     b6e:	2f ef       	ldi	r18, 0xFF	; 255
     b70:	3f e0       	ldi	r19, 0x0F	; 15
     b72:	40 e0       	ldi	r20, 0x00	; 0
     b74:	50 e0       	ldi	r21, 0x00	; 0
     b76:	bc 01       	movw	r22, r24
     b78:	cd 01       	movw	r24, r26
     b7a:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
     b7e:	da 01       	movw	r26, r20
     b80:	c9 01       	movw	r24, r18
     b82:	9c 01       	movw	r18, r24
     b84:	22 53       	subi	r18, 0x32	; 50
     b86:	30 40       	sbci	r19, 0x00	; 0
     b88:	8e a1       	lds	r24, 0x4e
     b8a:	9f a1       	lds	r25, 0x4f
     b8c:	fc 01       	movw	r30, r24
     b8e:	20 83       	st	Z, r18
     b90:	31 83       	std	Z+1, r19	; 0x01
}
     b92:	a9 96       	adiw	r28, 0x29	; 41
     b94:	cd bf       	out	0x3d, r28	; 61
     b96:	de bf       	out	0x3e, r29	; 62
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	08 95       	ret

00000ba2 <ADCPower>:

void ADCPower(uint8_t on) {
     ba2:	0f 93       	push	r16
     ba4:	1f 93       	push	r17
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
     baa:	cd b7       	in	r28, 0x3d	; 61
     bac:	de b7       	in	r29, 0x3e	; 62
     bae:	2f 97       	sbiw	r28, 0x0f	; 15
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	de bf       	out	0x3e, r29	; 62
     bb4:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     bb6:	8f 85       	ldd	r24, Y+15	; 0x0f
     bb8:	88 23       	and	r24, r24
     bba:	09 f4       	brne	.+2      	; 0xbbe <ADCPower+0x1c>
     bbc:	ce c0       	rjmp	.+412    	; 0xd5a <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     bbe:	80 e0       	ldi	r24, 0x00	; 0
     bc0:	96 e0       	ldi	r25, 0x06	; 6
     bc2:	2e ed       	ldi	r18, 0xDE	; 222
     bc4:	fc 01       	movw	r30, r24
     bc6:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     bc8:	80 e2       	ldi	r24, 0x20	; 32
     bca:	96 e0       	ldi	r25, 0x06	; 6
     bcc:	2e e0       	ldi	r18, 0x0E	; 14
     bce:	fc 01       	movw	r30, r24
     bd0:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     bd2:	80 e4       	ldi	r24, 0x40	; 64
     bd4:	96 e0       	ldi	r25, 0x06	; 6
     bd6:	23 e0       	ldi	r18, 0x03	; 3
     bd8:	fc 01       	movw	r30, r24
     bda:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     bdc:	80 e8       	ldi	r24, 0x80	; 128
     bde:	96 e0       	ldi	r25, 0x06	; 6
     be0:	20 e1       	ldi	r18, 0x10	; 16
     be2:	fc 01       	movw	r30, r24
     be4:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     be6:	80 ea       	ldi	r24, 0xA0	; 160
     be8:	96 e0       	ldi	r25, 0x06	; 6
     bea:	2e e0       	ldi	r18, 0x0E	; 14
     bec:	fc 01       	movw	r30, r24
     bee:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     bf0:	80 e0       	ldi	r24, 0x00	; 0
     bf2:	96 e0       	ldi	r25, 0x06	; 6
     bf4:	2e e9       	ldi	r18, 0x9E	; 158
     bf6:	fc 01       	movw	r30, r24
     bf8:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     bfa:	80 e2       	ldi	r24, 0x20	; 32
     bfc:	96 e0       	ldi	r25, 0x06	; 6
     bfe:	28 e0       	ldi	r18, 0x08	; 8
     c00:	fc 01       	movw	r30, r24
     c02:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c04:	80 e4       	ldi	r24, 0x40	; 64
     c06:	96 e0       	ldi	r25, 0x06	; 6
     c08:	23 e0       	ldi	r18, 0x03	; 3
     c0a:	fc 01       	movw	r30, r24
     c0c:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     c0e:	80 e8       	ldi	r24, 0x80	; 128
     c10:	96 e0       	ldi	r25, 0x06	; 6
     c12:	20 e1       	ldi	r18, 0x10	; 16
     c14:	fc 01       	movw	r30, r24
     c16:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c18:	80 ea       	ldi	r24, 0xA0	; 160
     c1a:	96 e0       	ldi	r25, 0x06	; 6
     c1c:	2e e0       	ldi	r18, 0x0E	; 14
     c1e:	fc 01       	movw	r30, r24
     c20:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     c22:	10 92 82 50 	sts	0x5082, r1
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a8 ec       	ldi	r26, 0xC8	; 200
     c2c:	b2 e4       	ldi	r27, 0x42	; 66
     c2e:	89 83       	std	Y+1, r24	; 0x01
     c30:	9a 83       	std	Y+2, r25	; 0x02
     c32:	ab 83       	std	Y+3, r26	; 0x03
     c34:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     c36:	69 81       	ldd	r22, Y+1	; 0x01
     c38:	7a 81       	ldd	r23, Y+2	; 0x02
     c3a:	8b 81       	ldd	r24, Y+3	; 0x03
     c3c:	9c 81       	ldd	r25, Y+4	; 0x04
     c3e:	20 e0       	ldi	r18, 0x00	; 0
     c40:	30 e0       	ldi	r19, 0x00	; 0
     c42:	4a ef       	ldi	r20, 0xFA	; 250
     c44:	55 e4       	ldi	r21, 0x45	; 69
     c46:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
     c4a:	dc 01       	movw	r26, r24
     c4c:	cb 01       	movw	r24, r22
     c4e:	8d 83       	std	Y+5, r24	; 0x05
     c50:	9e 83       	std	Y+6, r25	; 0x06
     c52:	af 83       	std	Y+7, r26	; 0x07
     c54:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     c56:	11 e0       	ldi	r17, 0x01	; 1
     c58:	6d 81       	ldd	r22, Y+5	; 0x05
     c5a:	7e 81       	ldd	r23, Y+6	; 0x06
     c5c:	8f 81       	ldd	r24, Y+7	; 0x07
     c5e:	98 85       	ldd	r25, Y+8	; 0x08
     c60:	20 e0       	ldi	r18, 0x00	; 0
     c62:	30 e0       	ldi	r19, 0x00	; 0
     c64:	40 e8       	ldi	r20, 0x80	; 128
     c66:	5f e3       	ldi	r21, 0x3F	; 63
     c68:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
     c6c:	88 23       	and	r24, r24
     c6e:	0c f0       	brlt	.+2      	; 0xc72 <ADCPower+0xd0>
     c70:	10 e0       	ldi	r17, 0x00	; 0
     c72:	11 23       	and	r17, r17
     c74:	29 f0       	breq	.+10     	; 0xc80 <ADCPower+0xde>
		__ticks = 1;
     c76:	81 e0       	ldi	r24, 0x01	; 1
     c78:	90 e0       	ldi	r25, 0x00	; 0
     c7a:	89 87       	std	Y+9, r24	; 0x09
     c7c:	9a 87       	std	Y+10, r25	; 0x0a
     c7e:	46 c0       	rjmp	.+140    	; 0xd0c <ADCPower+0x16a>
	else if (__tmp > 65535)
     c80:	11 e0       	ldi	r17, 0x01	; 1
     c82:	6d 81       	ldd	r22, Y+5	; 0x05
     c84:	7e 81       	ldd	r23, Y+6	; 0x06
     c86:	8f 81       	ldd	r24, Y+7	; 0x07
     c88:	98 85       	ldd	r25, Y+8	; 0x08
     c8a:	20 e0       	ldi	r18, 0x00	; 0
     c8c:	3f ef       	ldi	r19, 0xFF	; 255
     c8e:	4f e7       	ldi	r20, 0x7F	; 127
     c90:	57 e4       	ldi	r21, 0x47	; 71
     c92:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
     c96:	18 16       	cp	r1, r24
     c98:	0c f0       	brlt	.+2      	; 0xc9c <ADCPower+0xfa>
     c9a:	10 e0       	ldi	r17, 0x00	; 0
     c9c:	11 23       	and	r17, r17
     c9e:	61 f1       	breq	.+88     	; 0xcf8 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ca0:	69 81       	ldd	r22, Y+1	; 0x01
     ca2:	7a 81       	ldd	r23, Y+2	; 0x02
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	30 e0       	ldi	r19, 0x00	; 0
     cac:	40 e2       	ldi	r20, 0x20	; 32
     cae:	51 e4       	ldi	r21, 0x41	; 65
     cb0:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
     cb4:	dc 01       	movw	r26, r24
     cb6:	cb 01       	movw	r24, r22
     cb8:	bc 01       	movw	r22, r24
     cba:	cd 01       	movw	r24, r26
     cbc:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
     cc0:	dc 01       	movw	r26, r24
     cc2:	cb 01       	movw	r24, r22
     cc4:	89 87       	std	Y+9, r24	; 0x09
     cc6:	9a 87       	std	Y+10, r25	; 0x0a
     cc8:	12 c0       	rjmp	.+36     	; 0xcee <ADCPower+0x14c>
     cca:	80 e2       	ldi	r24, 0x20	; 32
     ccc:	93 e0       	ldi	r25, 0x03	; 3
     cce:	8b 87       	std	Y+11, r24	; 0x0b
     cd0:	9c 87       	std	Y+12, r25	; 0x0c
     cd2:	8b 85       	ldd	r24, Y+11	; 0x0b
     cd4:	9c 85       	ldd	r25, Y+12	; 0x0c
     cd6:	8c 01       	movw	r16, r24
     cd8:	c8 01       	movw	r24, r16
     cda:	01 97       	sbiw	r24, 0x01	; 1
     cdc:	f1 f7       	brne	.-4      	; 0xcda <ADCPower+0x138>
     cde:	8c 01       	movw	r16, r24
     ce0:	0b 87       	std	Y+11, r16	; 0x0b
     ce2:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ce4:	89 85       	ldd	r24, Y+9	; 0x09
     ce6:	9a 85       	ldd	r25, Y+10	; 0x0a
     ce8:	01 97       	sbiw	r24, 0x01	; 1
     cea:	89 87       	std	Y+9, r24	; 0x09
     cec:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     cee:	89 85       	ldd	r24, Y+9	; 0x09
     cf0:	9a 85       	ldd	r25, Y+10	; 0x0a
     cf2:	00 97       	sbiw	r24, 0x00	; 0
     cf4:	51 f7       	brne	.-44     	; 0xcca <ADCPower+0x128>
     cf6:	17 c0       	rjmp	.+46     	; 0xd26 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     cf8:	6d 81       	ldd	r22, Y+5	; 0x05
     cfa:	7e 81       	ldd	r23, Y+6	; 0x06
     cfc:	8f 81       	ldd	r24, Y+7	; 0x07
     cfe:	98 85       	ldd	r25, Y+8	; 0x08
     d00:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
     d04:	dc 01       	movw	r26, r24
     d06:	cb 01       	movw	r24, r22
     d08:	89 87       	std	Y+9, r24	; 0x09
     d0a:	9a 87       	std	Y+10, r25	; 0x0a
     d0c:	89 85       	ldd	r24, Y+9	; 0x09
     d0e:	9a 85       	ldd	r25, Y+10	; 0x0a
     d10:	8d 87       	std	Y+13, r24	; 0x0d
     d12:	9e 87       	std	Y+14, r25	; 0x0e
     d14:	8d 85       	ldd	r24, Y+13	; 0x0d
     d16:	9e 85       	ldd	r25, Y+14	; 0x0e
     d18:	8c 01       	movw	r16, r24
     d1a:	f8 01       	movw	r30, r16
     d1c:	31 97       	sbiw	r30, 0x01	; 1
     d1e:	f1 f7       	brne	.-4      	; 0xd1c <ADCPower+0x17a>
     d20:	8f 01       	movw	r16, r30
     d22:	0d 87       	std	Y+13, r16	; 0x0d
     d24:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     d26:	80 e4       	ldi	r24, 0x40	; 64
     d28:	96 e0       	ldi	r25, 0x06	; 6
     d2a:	20 e4       	ldi	r18, 0x40	; 64
     d2c:	fc 01       	movw	r30, r24
     d2e:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     d30:	80 e0       	ldi	r24, 0x00	; 0
     d32:	80 93 83 50 	sts	0x5083, r24
     d36:	80 93 d6 50 	sts	0x50D6, r24
     d3a:	80 93 cf 23 	sts	0x23CF, r24
     d3e:	80 93 7b 50 	sts	0x507B, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     d42:	8f ef       	ldi	r24, 0xFF	; 255
     d44:	61 e0       	ldi	r22, 0x01	; 1
     d46:	0e 94 a6 32 	call	0x654c	; 0x654c <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     d4a:	8f ef       	ldi	r24, 0xFF	; 255
     d4c:	61 e0       	ldi	r22, 0x01	; 1
     d4e:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     d52:	8f ef       	ldi	r24, 0xFF	; 255
     d54:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>
     d58:	42 c0       	rjmp	.+132    	; 0xdde <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     d5a:	80 e0       	ldi	r24, 0x00	; 0
     d5c:	96 e0       	ldi	r25, 0x06	; 6
     d5e:	2e ed       	ldi	r18, 0xDE	; 222
     d60:	fc 01       	movw	r30, r24
     d62:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     d64:	80 e2       	ldi	r24, 0x20	; 32
     d66:	96 e0       	ldi	r25, 0x06	; 6
     d68:	2e e0       	ldi	r18, 0x0E	; 14
     d6a:	fc 01       	movw	r30, r24
     d6c:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     d6e:	80 e4       	ldi	r24, 0x40	; 64
     d70:	96 e0       	ldi	r25, 0x06	; 6
     d72:	23 e0       	ldi	r18, 0x03	; 3
     d74:	fc 01       	movw	r30, r24
     d76:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     d78:	80 e8       	ldi	r24, 0x80	; 128
     d7a:	96 e0       	ldi	r25, 0x06	; 6
     d7c:	20 e1       	ldi	r18, 0x10	; 16
     d7e:	fc 01       	movw	r30, r24
     d80:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     d82:	80 ea       	ldi	r24, 0xA0	; 160
     d84:	96 e0       	ldi	r25, 0x06	; 6
     d86:	2e e0       	ldi	r18, 0x0E	; 14
     d88:	fc 01       	movw	r30, r24
     d8a:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     d8c:	80 e0       	ldi	r24, 0x00	; 0
     d8e:	96 e0       	ldi	r25, 0x06	; 6
     d90:	2e ed       	ldi	r18, 0xDE	; 222
     d92:	fc 01       	movw	r30, r24
     d94:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     d96:	80 e2       	ldi	r24, 0x20	; 32
     d98:	96 e0       	ldi	r25, 0x06	; 6
     d9a:	2e e0       	ldi	r18, 0x0E	; 14
     d9c:	fc 01       	movw	r30, r24
     d9e:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     da0:	80 e4       	ldi	r24, 0x40	; 64
     da2:	96 e0       	ldi	r25, 0x06	; 6
     da4:	23 e0       	ldi	r18, 0x03	; 3
     da6:	fc 01       	movw	r30, r24
     da8:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     daa:	80 e8       	ldi	r24, 0x80	; 128
     dac:	96 e0       	ldi	r25, 0x06	; 6
     dae:	20 e1       	ldi	r18, 0x10	; 16
     db0:	fc 01       	movw	r30, r24
     db2:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     db4:	80 ea       	ldi	r24, 0xA0	; 160
     db6:	96 e0       	ldi	r25, 0x06	; 6
     db8:	2e e0       	ldi	r18, 0x0E	; 14
     dba:	fc 01       	movw	r30, r24
     dbc:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     dbe:	80 e4       	ldi	r24, 0x40	; 64
     dc0:	96 e0       	ldi	r25, 0x06	; 6
     dc2:	20 e4       	ldi	r18, 0x40	; 64
     dc4:	fc 01       	movw	r30, r24
     dc6:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     dc8:	80 e0       	ldi	r24, 0x00	; 0
     dca:	80 93 83 50 	sts	0x5083, r24
     dce:	80 93 d6 50 	sts	0x50D6, r24
     dd2:	80 93 cf 23 	sts	0x23CF, r24
     dd6:	80 93 7b 50 	sts	0x507B, r24
		channelStatus = 0x00;
     dda:	10 92 82 50 	sts	0x5082, r1
		
	}
}
     dde:	2f 96       	adiw	r28, 0x0f	; 15
     de0:	cd bf       	out	0x3d, r28	; 61
     de2:	de bf       	out	0x3e, r29	; 62
     de4:	df 91       	pop	r29
     de6:	cf 91       	pop	r28
     de8:	1f 91       	pop	r17
     dea:	0f 91       	pop	r16
     dec:	08 95       	ret

00000dee <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     dee:	0f 93       	push	r16
     df0:	1f 93       	push	r17
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	cd b7       	in	r28, 0x3d	; 61
     df8:	de b7       	in	r29, 0x3e	; 62
     dfa:	6a 97       	sbiw	r28, 0x1a	; 26
     dfc:	cd bf       	out	0x3d, r28	; 61
     dfe:	de bf       	out	0x3e, r29	; 62
     e00:	89 8f       	std	Y+25, r24	; 0x19
     e02:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     e04:	89 8d       	ldd	r24, Y+25	; 0x19
     e06:	28 2f       	mov	r18, r24
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	81 e0       	ldi	r24, 0x01	; 1
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	02 c0       	rjmp	.+4      	; 0xe14 <set_ampGain+0x26>
     e10:	88 0f       	add	r24, r24
     e12:	99 1f       	adc	r25, r25
     e14:	2a 95       	dec	r18
     e16:	e2 f7       	brpl	.-8      	; 0xe10 <set_ampGain+0x22>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	0e 94 d5 33 	call	0x67aa	; 0x67aa <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     e1e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e20:	88 2f       	mov	r24, r24
     e22:	90 e0       	ldi	r25, 0x00	; 0
     e24:	81 70       	andi	r24, 0x01	; 1
     e26:	90 70       	andi	r25, 0x00	; 0
     e28:	88 23       	and	r24, r24
     e2a:	31 f0       	breq	.+12     	; 0xe38 <set_ampGain+0x4a>
     e2c:	80 e0       	ldi	r24, 0x00	; 0
     e2e:	96 e0       	ldi	r25, 0x06	; 6
     e30:	20 e4       	ldi	r18, 0x40	; 64
     e32:	fc 01       	movw	r30, r24
     e34:	25 83       	std	Z+5, r18	; 0x05
     e36:	05 c0       	rjmp	.+10     	; 0xe42 <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     e38:	80 e0       	ldi	r24, 0x00	; 0
     e3a:	96 e0       	ldi	r25, 0x06	; 6
     e3c:	20 e4       	ldi	r18, 0x40	; 64
     e3e:	fc 01       	movw	r30, r24
     e40:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     e42:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e44:	88 2f       	mov	r24, r24
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	82 70       	andi	r24, 0x02	; 2
     e4a:	90 70       	andi	r25, 0x00	; 0
     e4c:	00 97       	sbiw	r24, 0x00	; 0
     e4e:	31 f0       	breq	.+12     	; 0xe5c <set_ampGain+0x6e>
     e50:	80 e2       	ldi	r24, 0x20	; 32
     e52:	96 e0       	ldi	r25, 0x06	; 6
     e54:	22 e0       	ldi	r18, 0x02	; 2
     e56:	fc 01       	movw	r30, r24
     e58:	25 83       	std	Z+5, r18	; 0x05
     e5a:	05 c0       	rjmp	.+10     	; 0xe66 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     e5c:	80 e2       	ldi	r24, 0x20	; 32
     e5e:	96 e0       	ldi	r25, 0x06	; 6
     e60:	22 e0       	ldi	r18, 0x02	; 2
     e62:	fc 01       	movw	r30, r24
     e64:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     e66:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e68:	88 2f       	mov	r24, r24
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	84 70       	andi	r24, 0x04	; 4
     e6e:	90 70       	andi	r25, 0x00	; 0
     e70:	00 97       	sbiw	r24, 0x00	; 0
     e72:	31 f0       	breq	.+12     	; 0xe80 <set_ampGain+0x92>
     e74:	80 e2       	ldi	r24, 0x20	; 32
     e76:	96 e0       	ldi	r25, 0x06	; 6
     e78:	24 e0       	ldi	r18, 0x04	; 4
     e7a:	fc 01       	movw	r30, r24
     e7c:	25 83       	std	Z+5, r18	; 0x05
     e7e:	05 c0       	rjmp	.+10     	; 0xe8a <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     e80:	80 e2       	ldi	r24, 0x20	; 32
     e82:	96 e0       	ldi	r25, 0x06	; 6
     e84:	24 e0       	ldi	r18, 0x04	; 4
     e86:	fc 01       	movw	r30, r24
     e88:	26 83       	std	Z+6, r18	; 0x06
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	a0 e8       	ldi	r26, 0x80	; 128
     e90:	bf e3       	ldi	r27, 0x3F	; 63
     e92:	89 83       	std	Y+1, r24	; 0x01
     e94:	9a 83       	std	Y+2, r25	; 0x02
     e96:	ab 83       	std	Y+3, r26	; 0x03
     e98:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     e9a:	69 81       	ldd	r22, Y+1	; 0x01
     e9c:	7a 81       	ldd	r23, Y+2	; 0x02
     e9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ea0:	9c 81       	ldd	r25, Y+4	; 0x04
     ea2:	2b ea       	ldi	r18, 0xAB	; 171
     ea4:	3a ea       	ldi	r19, 0xAA	; 170
     ea6:	4a e2       	ldi	r20, 0x2A	; 42
     ea8:	51 e4       	ldi	r21, 0x41	; 65
     eaa:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
     eae:	dc 01       	movw	r26, r24
     eb0:	cb 01       	movw	r24, r22
     eb2:	8d 83       	std	Y+5, r24	; 0x05
     eb4:	9e 83       	std	Y+6, r25	; 0x06
     eb6:	af 83       	std	Y+7, r26	; 0x07
     eb8:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     eba:	11 e0       	ldi	r17, 0x01	; 1
     ebc:	6d 81       	ldd	r22, Y+5	; 0x05
     ebe:	7e 81       	ldd	r23, Y+6	; 0x06
     ec0:	8f 81       	ldd	r24, Y+7	; 0x07
     ec2:	98 85       	ldd	r25, Y+8	; 0x08
     ec4:	20 e0       	ldi	r18, 0x00	; 0
     ec6:	30 e0       	ldi	r19, 0x00	; 0
     ec8:	40 e8       	ldi	r20, 0x80	; 128
     eca:	5f e3       	ldi	r21, 0x3F	; 63
     ecc:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
     ed0:	88 23       	and	r24, r24
     ed2:	0c f0       	brlt	.+2      	; 0xed6 <set_ampGain+0xe8>
     ed4:	10 e0       	ldi	r17, 0x00	; 0
     ed6:	11 23       	and	r17, r17
     ed8:	19 f0       	breq	.+6      	; 0xee0 <set_ampGain+0xf2>
		__ticks = 1;
     eda:	81 e0       	ldi	r24, 0x01	; 1
     edc:	89 87       	std	Y+9, r24	; 0x09
     ede:	a3 c0       	rjmp	.+326    	; 0x1026 <set_ampGain+0x238>
	else if (__tmp > 255)
     ee0:	11 e0       	ldi	r17, 0x01	; 1
     ee2:	6d 81       	ldd	r22, Y+5	; 0x05
     ee4:	7e 81       	ldd	r23, Y+6	; 0x06
     ee6:	8f 81       	ldd	r24, Y+7	; 0x07
     ee8:	98 85       	ldd	r25, Y+8	; 0x08
     eea:	20 e0       	ldi	r18, 0x00	; 0
     eec:	30 e0       	ldi	r19, 0x00	; 0
     eee:	4f e7       	ldi	r20, 0x7F	; 127
     ef0:	53 e4       	ldi	r21, 0x43	; 67
     ef2:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
     ef6:	18 16       	cp	r1, r24
     ef8:	0c f0       	brlt	.+2      	; 0xefc <set_ampGain+0x10e>
     efa:	10 e0       	ldi	r17, 0x00	; 0
     efc:	11 23       	and	r17, r17
     efe:	09 f4       	brne	.+2      	; 0xf02 <set_ampGain+0x114>
     f00:	89 c0       	rjmp	.+274    	; 0x1014 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     f02:	69 81       	ldd	r22, Y+1	; 0x01
     f04:	7a 81       	ldd	r23, Y+2	; 0x02
     f06:	8b 81       	ldd	r24, Y+3	; 0x03
     f08:	9c 81       	ldd	r25, Y+4	; 0x04
     f0a:	20 e0       	ldi	r18, 0x00	; 0
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	4a e7       	ldi	r20, 0x7A	; 122
     f10:	54 e4       	ldi	r21, 0x44	; 68
     f12:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
     f16:	dc 01       	movw	r26, r24
     f18:	cb 01       	movw	r24, r22
     f1a:	8a 87       	std	Y+10, r24	; 0x0a
     f1c:	9b 87       	std	Y+11, r25	; 0x0b
     f1e:	ac 87       	std	Y+12, r26	; 0x0c
     f20:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     f22:	6a 85       	ldd	r22, Y+10	; 0x0a
     f24:	7b 85       	ldd	r23, Y+11	; 0x0b
     f26:	8c 85       	ldd	r24, Y+12	; 0x0c
     f28:	9d 85       	ldd	r25, Y+13	; 0x0d
     f2a:	20 e0       	ldi	r18, 0x00	; 0
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	4a ef       	ldi	r20, 0xFA	; 250
     f30:	55 e4       	ldi	r21, 0x45	; 69
     f32:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
     f36:	dc 01       	movw	r26, r24
     f38:	cb 01       	movw	r24, r22
     f3a:	8e 87       	std	Y+14, r24	; 0x0e
     f3c:	9f 87       	std	Y+15, r25	; 0x0f
     f3e:	a8 8b       	std	Y+16, r26	; 0x10
     f40:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     f42:	11 e0       	ldi	r17, 0x01	; 1
     f44:	6e 85       	ldd	r22, Y+14	; 0x0e
     f46:	7f 85       	ldd	r23, Y+15	; 0x0f
     f48:	88 89       	ldd	r24, Y+16	; 0x10
     f4a:	99 89       	ldd	r25, Y+17	; 0x11
     f4c:	20 e0       	ldi	r18, 0x00	; 0
     f4e:	30 e0       	ldi	r19, 0x00	; 0
     f50:	40 e8       	ldi	r20, 0x80	; 128
     f52:	5f e3       	ldi	r21, 0x3F	; 63
     f54:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
     f58:	88 23       	and	r24, r24
     f5a:	0c f0       	brlt	.+2      	; 0xf5e <set_ampGain+0x170>
     f5c:	10 e0       	ldi	r17, 0x00	; 0
     f5e:	11 23       	and	r17, r17
     f60:	29 f0       	breq	.+10     	; 0xf6c <set_ampGain+0x17e>
		__ticks = 1;
     f62:	81 e0       	ldi	r24, 0x01	; 1
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	8a 8b       	std	Y+18, r24	; 0x12
     f68:	9b 8b       	std	Y+19, r25	; 0x13
     f6a:	46 c0       	rjmp	.+140    	; 0xff8 <set_ampGain+0x20a>
	else if (__tmp > 65535)
     f6c:	11 e0       	ldi	r17, 0x01	; 1
     f6e:	6e 85       	ldd	r22, Y+14	; 0x0e
     f70:	7f 85       	ldd	r23, Y+15	; 0x0f
     f72:	88 89       	ldd	r24, Y+16	; 0x10
     f74:	99 89       	ldd	r25, Y+17	; 0x11
     f76:	20 e0       	ldi	r18, 0x00	; 0
     f78:	3f ef       	ldi	r19, 0xFF	; 255
     f7a:	4f e7       	ldi	r20, 0x7F	; 127
     f7c:	57 e4       	ldi	r21, 0x47	; 71
     f7e:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
     f82:	18 16       	cp	r1, r24
     f84:	0c f0       	brlt	.+2      	; 0xf88 <set_ampGain+0x19a>
     f86:	10 e0       	ldi	r17, 0x00	; 0
     f88:	11 23       	and	r17, r17
     f8a:	61 f1       	breq	.+88     	; 0xfe4 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f8c:	6a 85       	ldd	r22, Y+10	; 0x0a
     f8e:	7b 85       	ldd	r23, Y+11	; 0x0b
     f90:	8c 85       	ldd	r24, Y+12	; 0x0c
     f92:	9d 85       	ldd	r25, Y+13	; 0x0d
     f94:	20 e0       	ldi	r18, 0x00	; 0
     f96:	30 e0       	ldi	r19, 0x00	; 0
     f98:	40 e2       	ldi	r20, 0x20	; 32
     f9a:	51 e4       	ldi	r21, 0x41	; 65
     f9c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
     fa0:	dc 01       	movw	r26, r24
     fa2:	cb 01       	movw	r24, r22
     fa4:	bc 01       	movw	r22, r24
     fa6:	cd 01       	movw	r24, r26
     fa8:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
     fac:	dc 01       	movw	r26, r24
     fae:	cb 01       	movw	r24, r22
     fb0:	8a 8b       	std	Y+18, r24	; 0x12
     fb2:	9b 8b       	std	Y+19, r25	; 0x13
     fb4:	12 c0       	rjmp	.+36     	; 0xfda <set_ampGain+0x1ec>
     fb6:	80 e2       	ldi	r24, 0x20	; 32
     fb8:	93 e0       	ldi	r25, 0x03	; 3
     fba:	8c 8b       	std	Y+20, r24	; 0x14
     fbc:	9d 8b       	std	Y+21, r25	; 0x15
     fbe:	8c 89       	ldd	r24, Y+20	; 0x14
     fc0:	9d 89       	ldd	r25, Y+21	; 0x15
     fc2:	8c 01       	movw	r16, r24
     fc4:	c8 01       	movw	r24, r16
     fc6:	01 97       	sbiw	r24, 0x01	; 1
     fc8:	f1 f7       	brne	.-4      	; 0xfc6 <set_ampGain+0x1d8>
     fca:	8c 01       	movw	r16, r24
     fcc:	0c 8b       	std	Y+20, r16	; 0x14
     fce:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     fd0:	8a 89       	ldd	r24, Y+18	; 0x12
     fd2:	9b 89       	ldd	r25, Y+19	; 0x13
     fd4:	01 97       	sbiw	r24, 0x01	; 1
     fd6:	8a 8b       	std	Y+18, r24	; 0x12
     fd8:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     fda:	8a 89       	ldd	r24, Y+18	; 0x12
     fdc:	9b 89       	ldd	r25, Y+19	; 0x13
     fde:	00 97       	sbiw	r24, 0x00	; 0
     fe0:	51 f7       	brne	.-44     	; 0xfb6 <set_ampGain+0x1c8>
     fe2:	28 c0       	rjmp	.+80     	; 0x1034 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     fe4:	6e 85       	ldd	r22, Y+14	; 0x0e
     fe6:	7f 85       	ldd	r23, Y+15	; 0x0f
     fe8:	88 89       	ldd	r24, Y+16	; 0x10
     fea:	99 89       	ldd	r25, Y+17	; 0x11
     fec:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
     ff0:	dc 01       	movw	r26, r24
     ff2:	cb 01       	movw	r24, r22
     ff4:	8a 8b       	std	Y+18, r24	; 0x12
     ff6:	9b 8b       	std	Y+19, r25	; 0x13
     ff8:	8a 89       	ldd	r24, Y+18	; 0x12
     ffa:	9b 89       	ldd	r25, Y+19	; 0x13
     ffc:	8e 8b       	std	Y+22, r24	; 0x16
     ffe:	9f 8b       	std	Y+23, r25	; 0x17
    1000:	8e 89       	ldd	r24, Y+22	; 0x16
    1002:	9f 89       	ldd	r25, Y+23	; 0x17
    1004:	8c 01       	movw	r16, r24
    1006:	f8 01       	movw	r30, r16
    1008:	31 97       	sbiw	r30, 0x01	; 1
    100a:	f1 f7       	brne	.-4      	; 0x1008 <set_ampGain+0x21a>
    100c:	8f 01       	movw	r16, r30
    100e:	0e 8b       	std	Y+22, r16	; 0x16
    1010:	1f 8b       	std	Y+23, r17	; 0x17
    1012:	10 c0       	rjmp	.+32     	; 0x1034 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1014:	6d 81       	ldd	r22, Y+5	; 0x05
    1016:	7e 81       	ldd	r23, Y+6	; 0x06
    1018:	8f 81       	ldd	r24, Y+7	; 0x07
    101a:	98 85       	ldd	r25, Y+8	; 0x08
    101c:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    1020:	dc 01       	movw	r26, r24
    1022:	cb 01       	movw	r24, r22
    1024:	89 87       	std	Y+9, r24	; 0x09
    1026:	89 85       	ldd	r24, Y+9	; 0x09
    1028:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    102a:	88 8d       	ldd	r24, Y+24	; 0x18
    102c:	18 2f       	mov	r17, r24
    102e:	1a 95       	dec	r17
    1030:	f1 f7       	brne	.-4      	; 0x102e <set_ampGain+0x240>
    1032:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    1034:	8f ef       	ldi	r24, 0xFF	; 255
    1036:	61 e0       	ldi	r22, 0x01	; 1
    1038:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    103c:	6a 96       	adiw	r28, 0x1a	; 26
    103e:	cd bf       	out	0x3d, r28	; 61
    1040:	de bf       	out	0x3e, r29	; 62
    1042:	df 91       	pop	r29
    1044:	cf 91       	pop	r28
    1046:	1f 91       	pop	r17
    1048:	0f 91       	pop	r16
    104a:	08 95       	ret

0000104c <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	00 d0       	rcall	.+0      	; 0x1052 <set_filter+0x6>
    1052:	cd b7       	in	r28, 0x3d	; 61
    1054:	de b7       	in	r29, 0x3e	; 62
    1056:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    1058:	8b 81       	ldd	r24, Y+3	; 0x03
    105a:	83 70       	andi	r24, 0x03	; 3
    105c:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    105e:	8b 81       	ldd	r24, Y+3	; 0x03
    1060:	8c 70       	andi	r24, 0x0C	; 12
    1062:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    1064:	8b 81       	ldd	r24, Y+3	; 0x03
    1066:	88 2f       	mov	r24, r24
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	85 70       	andi	r24, 0x05	; 5
    106c:	90 70       	andi	r25, 0x00	; 0
    106e:	00 97       	sbiw	r24, 0x00	; 0
    1070:	51 f0       	breq	.+20     	; 0x1086 <set_filter+0x3a>
    1072:	80 91 82 50 	lds	r24, 0x5082
    1076:	98 2f       	mov	r25, r24
    1078:	90 7f       	andi	r25, 0xF0	; 240
    107a:	8b 81       	ldd	r24, Y+3	; 0x03
    107c:	82 95       	swap	r24
    107e:	8f 70       	andi	r24, 0x0F	; 15
    1080:	89 2b       	or	r24, r25
    1082:	80 93 82 50 	sts	0x5082, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	88 2f       	mov	r24, r24
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	8a 70       	andi	r24, 0x0A	; 10
    108e:	90 70       	andi	r25, 0x00	; 0
    1090:	00 97       	sbiw	r24, 0x00	; 0
    1092:	49 f0       	breq	.+18     	; 0x10a6 <set_filter+0x5a>
    1094:	8b 81       	ldd	r24, Y+3	; 0x03
    1096:	98 2f       	mov	r25, r24
    1098:	90 7f       	andi	r25, 0xF0	; 240
    109a:	80 91 82 50 	lds	r24, 0x5082
    109e:	8f 70       	andi	r24, 0x0F	; 15
    10a0:	89 2b       	or	r24, r25
    10a2:	80 93 82 50 	sts	0x5082, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    10a6:	84 e0       	ldi	r24, 0x04	; 4
    10a8:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    10ac:	80 91 82 50 	lds	r24, 0x5082
    10b0:	80 93 66 50 	sts	0x5066, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    10b4:	89 81       	ldd	r24, Y+1	; 0x01
    10b6:	88 23       	and	r24, r24
    10b8:	19 f0       	breq	.+6      	; 0x10c0 <set_filter+0x74>
    10ba:	81 e0       	ldi	r24, 0x01	; 1
    10bc:	0e 94 12 37 	call	0x6e24	; 0x6e24 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    10c0:	8a 81       	ldd	r24, Y+2	; 0x02
    10c2:	88 23       	and	r24, r24
    10c4:	19 f0       	breq	.+6      	; 0x10cc <set_filter+0x80>
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	0e 94 2a 37 	call	0x6e54	; 0x6e54 <upperMuxCS>

	SPICS(TRUE);
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    10d2:	80 ec       	ldi	r24, 0xC0	; 192
    10d4:	98 e0       	ldi	r25, 0x08	; 8
    10d6:	2f ef       	ldi	r18, 0xFF	; 255
    10d8:	fc 01       	movw	r30, r24
    10da:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    10dc:	00 00       	nop
    10de:	80 ec       	ldi	r24, 0xC0	; 192
    10e0:	98 e0       	ldi	r25, 0x08	; 8
    10e2:	fc 01       	movw	r30, r24
    10e4:	82 81       	ldd	r24, Z+2	; 0x02
    10e6:	88 23       	and	r24, r24
    10e8:	d4 f7       	brge	.-12     	; 0x10de <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    10ea:	80 ec       	ldi	r24, 0xC0	; 192
    10ec:	98 e0       	ldi	r25, 0x08	; 8
    10ee:	fc 01       	movw	r30, r24
    10f0:	83 81       	ldd	r24, Z+3	; 0x03
    10f2:	80 93 72 50 	sts	0x5072, r24

	nop();
    10f6:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    10f8:	80 ec       	ldi	r24, 0xC0	; 192
    10fa:	98 e0       	ldi	r25, 0x08	; 8
    10fc:	20 91 66 50 	lds	r18, 0x5066
    1100:	fc 01       	movw	r30, r24
    1102:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1104:	00 00       	nop
    1106:	80 ec       	ldi	r24, 0xC0	; 192
    1108:	98 e0       	ldi	r25, 0x08	; 8
    110a:	fc 01       	movw	r30, r24
    110c:	82 81       	ldd	r24, Z+2	; 0x02
    110e:	88 23       	and	r24, r24
    1110:	d4 f7       	brge	.-12     	; 0x1106 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    1112:	80 ec       	ldi	r24, 0xC0	; 192
    1114:	98 e0       	ldi	r25, 0x08	; 8
    1116:	fc 01       	movw	r30, r24
    1118:	83 81       	ldd	r24, Z+3	; 0x03
    111a:	80 93 72 50 	sts	0x5072, r24
	SPICS(FALSE);
    111e:	80 e0       	ldi	r24, 0x00	; 0
    1120:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    1124:	89 81       	ldd	r24, Y+1	; 0x01
    1126:	88 23       	and	r24, r24
    1128:	19 f0       	breq	.+6      	; 0x1130 <set_filter+0xe4>
    112a:	80 e0       	ldi	r24, 0x00	; 0
    112c:	0e 94 12 37 	call	0x6e24	; 0x6e24 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    1130:	8a 81       	ldd	r24, Y+2	; 0x02
    1132:	88 23       	and	r24, r24
    1134:	19 f0       	breq	.+6      	; 0x113c <set_filter+0xf0>
    1136:	80 e0       	ldi	r24, 0x00	; 0
    1138:	0e 94 2a 37 	call	0x6e54	; 0x6e54 <upperMuxCS>
	SPIDisable();
    113c:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
}
    1140:	23 96       	adiw	r28, 0x03	; 3
    1142:	cd bf       	out	0x3d, r28	; 61
    1144:	de bf       	out	0x3e, r29	; 62
    1146:	df 91       	pop	r29
    1148:	cf 91       	pop	r28
    114a:	08 95       	ret

0000114c <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    114c:	cf 93       	push	r28
    114e:	df 93       	push	r29
    1150:	0f 92       	push	r0
    1152:	cd b7       	in	r28, 0x3d	; 61
    1154:	de b7       	in	r29, 0x3e	; 62
    1156:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    1158:	89 81       	ldd	r24, Y+1	; 0x01
    115a:	88 23       	and	r24, r24
    115c:	59 f0       	breq	.+22     	; 0x1174 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    115e:	80 e0       	ldi	r24, 0x00	; 0
    1160:	96 e0       	ldi	r25, 0x06	; 6
    1162:	20 e2       	ldi	r18, 0x20	; 32
    1164:	fc 01       	movw	r30, r24
    1166:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1168:	80 e0       	ldi	r24, 0x00	; 0
    116a:	96 e0       	ldi	r25, 0x06	; 6
    116c:	20 e2       	ldi	r18, 0x20	; 32
    116e:	fc 01       	movw	r30, r24
    1170:	25 83       	std	Z+5, r18	; 0x05
    1172:	0a c0       	rjmp	.+20     	; 0x1188 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    1174:	80 e0       	ldi	r24, 0x00	; 0
    1176:	96 e0       	ldi	r25, 0x06	; 6
    1178:	20 e2       	ldi	r18, 0x20	; 32
    117a:	fc 01       	movw	r30, r24
    117c:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    117e:	80 e0       	ldi	r24, 0x00	; 0
    1180:	96 e0       	ldi	r25, 0x06	; 6
    1182:	20 e2       	ldi	r18, 0x20	; 32
    1184:	fc 01       	movw	r30, r24
    1186:	22 83       	std	Z+2, r18	; 0x02
	}
}
    1188:	0f 90       	pop	r0
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	08 95       	ret

00001190 <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent, uint32_t numOfSamples, int32_t* DataArray) {
    1190:	cf 92       	push	r12
    1192:	df 92       	push	r13
    1194:	ef 92       	push	r14
    1196:	ff 92       	push	r15
    1198:	0f 93       	push	r16
    119a:	1f 93       	push	r17
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	cd b7       	in	r28, 0x3d	; 61
    11a2:	de b7       	in	r29, 0x3e	; 62
    11a4:	2c 97       	sbiw	r28, 0x0c	; 12
    11a6:	cd bf       	out	0x3d, r28	; 61
    11a8:	de bf       	out	0x3e, r29	; 62
    11aa:	8b 83       	std	Y+3, r24	; 0x03
    11ac:	6c 83       	std	Y+4, r22	; 0x04
    11ae:	4d 83       	std	Y+5, r20	; 0x05
    11b0:	2e 83       	std	Y+6, r18	; 0x06
    11b2:	ef 82       	std	Y+7, r14	; 0x07
    11b4:	f8 86       	std	Y+8, r15	; 0x08
    11b6:	09 87       	std	Y+9, r16	; 0x09
    11b8:	1a 87       	std	Y+10, r17	; 0x0a
    11ba:	cb 86       	std	Y+11, r12	; 0x0b
    11bc:	dc 86       	std	Y+12, r13	; 0x0c


	uint16_t period;
	ADC_BUFFER = DataArray;
    11be:	8b 85       	ldd	r24, Y+11	; 0x0b
    11c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    11c2:	80 93 73 50 	sts	0x5073, r24
    11c6:	90 93 74 50 	sts	0x5074, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    11d0:	8b 81       	ldd	r24, Y+3	; 0x03
    11d2:	6d 81       	ldd	r22, Y+5	; 0x05
    11d4:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_filter(filterConfig);
    11d8:	8c 81       	ldd	r24, Y+4	; 0x04
    11da:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    11de:	8b 81       	ldd	r24, Y+3	; 0x03
    11e0:	85 30       	cpi	r24, 0x05	; 5
    11e2:	31 f0       	breq	.+12     	; 0x11f0 <CO_collectADC+0x60>
    11e4:	8b 81       	ldd	r24, Y+3	; 0x03
    11e6:	86 30       	cpi	r24, 0x06	; 6
    11e8:	19 f0       	breq	.+6      	; 0x11f0 <CO_collectADC+0x60>
    11ea:	8b 81       	ldd	r24, Y+3	; 0x03
    11ec:	87 30       	cpi	r24, 0x07	; 7
    11ee:	19 f4       	brne	.+6      	; 0x11f6 <CO_collectADC+0x66>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	setADCInput(channel);
    11fc:	8b 81       	ldd	r24, Y+3	; 0x03
    11fe:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    1202:	84 e0       	ldi	r24, 0x04	; 4
    1204:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1208:	80 ec       	ldi	r24, 0xC0	; 192
    120a:	98 e0       	ldi	r25, 0x08	; 8
    120c:	24 e5       	ldi	r18, 0x54	; 84
    120e:	fc 01       	movw	r30, r24
    1210:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    1212:	80 ea       	ldi	r24, 0xA0	; 160
    1214:	96 e0       	ldi	r25, 0x06	; 6
    1216:	21 e0       	ldi	r18, 0x01	; 1
    1218:	fc 01       	movw	r30, r24
    121a:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    121c:	80 ea       	ldi	r24, 0xA0	; 160
    121e:	96 e0       	ldi	r25, 0x06	; 6
    1220:	22 e0       	ldi	r18, 0x02	; 2
    1222:	fc 01       	movw	r30, r24
    1224:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    1226:	80 ea       	ldi	r24, 0xA0	; 160
    1228:	96 e0       	ldi	r25, 0x06	; 6
    122a:	21 e0       	ldi	r18, 0x01	; 1
    122c:	fc 01       	movw	r30, r24
    122e:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    1230:	80 ea       	ldi	r24, 0xA0	; 160
    1232:	96 e0       	ldi	r25, 0x06	; 6
    1234:	21 e0       	ldi	r18, 0x01	; 1
    1236:	fc 01       	movw	r30, r24
    1238:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    123a:	80 e8       	ldi	r24, 0x80	; 128
    123c:	96 e0       	ldi	r25, 0x06	; 6
    123e:	20 e2       	ldi	r18, 0x20	; 32
    1240:	fc 01       	movw	r30, r24
    1242:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1244:	80 e4       	ldi	r24, 0x40	; 64
    1246:	9a e0       	ldi	r25, 0x0A	; 10
    1248:	23 e2       	ldi	r18, 0x23	; 35
    124a:	fc 01       	movw	r30, r24
    124c:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    124e:	8e 81       	ldd	r24, Y+6	; 0x06
    1250:	88 2f       	mov	r24, r24
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	25 e1       	ldi	r18, 0x15	; 21
    1256:	30 e0       	ldi	r19, 0x00	; 0
    1258:	28 1b       	sub	r18, r24
    125a:	39 0b       	sbc	r19, r25
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	02 c0       	rjmp	.+4      	; 0x1266 <CO_collectADC+0xd6>
    1262:	88 0f       	add	r24, r24
    1264:	99 1f       	adc	r25, r25
    1266:	2a 95       	dec	r18
    1268:	e2 f7       	brpl	.-8      	; 0x1262 <CO_collectADC+0xd2>
    126a:	01 97       	sbiw	r24, 0x01	; 1
    126c:	89 83       	std	Y+1, r24	; 0x01
    126e:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    1270:	80 e4       	ldi	r24, 0x40	; 64
    1272:	9a e0       	ldi	r25, 0x0A	; 10
    1274:	29 81       	ldd	r18, Y+1	; 0x01
    1276:	3a 81       	ldd	r19, Y+2	; 0x02
    1278:	fc 01       	movw	r30, r24
    127a:	26 a3       	lds	r18, 0x56
    127c:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    127e:	80 e4       	ldi	r24, 0x40	; 64
    1280:	9a e0       	ldi	r25, 0x0A	; 10
    1282:	29 81       	ldd	r18, Y+1	; 0x01
    1284:	3a 81       	ldd	r19, Y+2	; 0x02
    1286:	36 95       	lsr	r19
    1288:	27 95       	ror	r18
    128a:	fc 01       	movw	r30, r24
    128c:	22 af       	sts	0x72, r18
    128e:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1290:	80 e4       	ldi	r24, 0x40	; 64
    1292:	9a e0       	ldi	r25, 0x0A	; 10
    1294:	20 e4       	ldi	r18, 0x40	; 64
    1296:	3a e0       	ldi	r19, 0x0A	; 10
    1298:	f9 01       	movw	r30, r18
    129a:	20 81       	ld	r18, Z
    129c:	20 7f       	andi	r18, 0xF0	; 240
    129e:	21 60       	ori	r18, 0x01	; 1
    12a0:	fc 01       	movw	r30, r24
    12a2:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    12a4:	80 ea       	ldi	r24, 0xA0	; 160
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	20 ea       	ldi	r18, 0xA0	; 160
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	f9 01       	movw	r30, r18
    12ae:	22 81       	ldd	r18, Z+2	; 0x02
    12b0:	21 60       	ori	r18, 0x01	; 1
    12b2:	fc 01       	movw	r30, r24
    12b4:	22 83       	std	Z+2, r18	; 0x02
	sei();
    12b6:	78 94       	sei

	sampleCount = 0;
    12b8:	10 92 75 50 	sts	0x5075, r1
    12bc:	10 92 76 50 	sts	0x5076, r1
    12c0:	10 92 77 50 	sts	0x5077, r1
    12c4:	10 92 78 50 	sts	0x5078, r1
	discardCount = 0;
    12c8:	10 92 5e 40 	sts	0x405E, r1
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    12cc:	00 00       	nop
    12ce:	20 91 75 50 	lds	r18, 0x5075
    12d2:	30 91 76 50 	lds	r19, 0x5076
    12d6:	40 91 77 50 	lds	r20, 0x5077
    12da:	50 91 78 50 	lds	r21, 0x5078
    12de:	8f 81       	ldd	r24, Y+7	; 0x07
    12e0:	98 85       	ldd	r25, Y+8	; 0x08
    12e2:	a9 85       	ldd	r26, Y+9	; 0x09
    12e4:	ba 85       	ldd	r27, Y+10	; 0x0a
    12e6:	28 17       	cp	r18, r24
    12e8:	39 07       	cpc	r19, r25
    12ea:	4a 07       	cpc	r20, r26
    12ec:	5b 07       	cpc	r21, r27
    12ee:	78 f3       	brcs	.-34     	; 0x12ce <CO_collectADC+0x13e>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    12f0:	80 e4       	ldi	r24, 0x40	; 64
    12f2:	9a e0       	ldi	r25, 0x0A	; 10
    12f4:	20 e4       	ldi	r18, 0x40	; 64
    12f6:	3a e0       	ldi	r19, 0x0A	; 10
    12f8:	f9 01       	movw	r30, r18
    12fa:	20 81       	ld	r18, Z
    12fc:	20 7f       	andi	r18, 0xF0	; 240
    12fe:	fc 01       	movw	r30, r24
    1300:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    1302:	80 ea       	ldi	r24, 0xA0	; 160
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	20 ea       	ldi	r18, 0xA0	; 160
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	f9 01       	movw	r30, r18
    130c:	22 81       	ldd	r18, Z+2	; 0x02
    130e:	2e 7f       	andi	r18, 0xFE	; 254
    1310:	fc 01       	movw	r30, r24
    1312:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1314:	f8 94       	cli

	SPIDisable();	
    1316:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	enableADCMUX(FALSE);
    131a:	80 e0       	ldi	r24, 0x00	; 0
    131c:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	//ADCPower(FALSE);
}
    1320:	2c 96       	adiw	r28, 0x0c	; 12
    1322:	cd bf       	out	0x3d, r28	; 61
    1324:	de bf       	out	0x3e, r29	; 62
    1326:	df 91       	pop	r29
    1328:	cf 91       	pop	r28
    132a:	1f 91       	pop	r17
    132c:	0f 91       	pop	r16
    132e:	ff 90       	pop	r15
    1330:	ef 90       	pop	r14
    1332:	df 90       	pop	r13
    1334:	cf 90       	pop	r12
    1336:	08 95       	ret

00001338 <CO_collectADC_cont>:

//continuously take samples and send them via radio. NOT RECOMMENDET
void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1338:	cf 93       	push	r28
    133a:	df 93       	push	r29
    133c:	00 d0       	rcall	.+0      	; 0x133e <CO_collectADC_cont+0x6>
    133e:	00 d0       	rcall	.+0      	; 0x1340 <CO_collectADC_cont+0x8>
    1340:	cd b7       	in	r28, 0x3d	; 61
    1342:	de b7       	in	r29, 0x3e	; 62
    1344:	8b 83       	std	Y+3, r24	; 0x03
    1346:	6c 83       	std	Y+4, r22	; 0x04
    1348:	4d 83       	std	Y+5, r20	; 0x05
    134a:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
//get data to write files to SD card
//getBootSectorData();
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1352:	8b 81       	ldd	r24, Y+3	; 0x03
    1354:	6d 81       	ldd	r22, Y+5	; 0x05
    1356:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
set_filter(filterConfig);
    135a:	8c 81       	ldd	r24, Y+4	; 0x04
    135c:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1360:	8b 81       	ldd	r24, Y+3	; 0x03
    1362:	85 30       	cpi	r24, 0x05	; 5
    1364:	31 f0       	breq	.+12     	; 0x1372 <CO_collectADC_cont+0x3a>
    1366:	8b 81       	ldd	r24, Y+3	; 0x03
    1368:	86 30       	cpi	r24, 0x06	; 6
    136a:	19 f0       	breq	.+6      	; 0x1372 <CO_collectADC_cont+0x3a>
    136c:	8b 81       	ldd	r24, Y+3	; 0x03
    136e:	87 30       	cpi	r24, 0x07	; 7
    1370:	19 f4       	brne	.+6      	; 0x1378 <CO_collectADC_cont+0x40>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
setADCInput(channel);
    137e:	8b 81       	ldd	r24, Y+3	; 0x03
    1380:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1384:	84 e0       	ldi	r24, 0x04	; 4
    1386:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    138a:	80 ec       	ldi	r24, 0xC0	; 192
    138c:	98 e0       	ldi	r25, 0x08	; 8
    138e:	24 e5       	ldi	r18, 0x54	; 84
    1390:	fc 01       	movw	r30, r24
    1392:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1394:	80 ea       	ldi	r24, 0xA0	; 160
    1396:	96 e0       	ldi	r25, 0x06	; 6
    1398:	21 e0       	ldi	r18, 0x01	; 1
    139a:	fc 01       	movw	r30, r24
    139c:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    139e:	80 ea       	ldi	r24, 0xA0	; 160
    13a0:	96 e0       	ldi	r25, 0x06	; 6
    13a2:	22 e0       	ldi	r18, 0x02	; 2
    13a4:	fc 01       	movw	r30, r24
    13a6:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    13a8:	80 ea       	ldi	r24, 0xA0	; 160
    13aa:	96 e0       	ldi	r25, 0x06	; 6
    13ac:	21 e0       	ldi	r18, 0x01	; 1
    13ae:	fc 01       	movw	r30, r24
    13b0:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_MED_gc;
    13b2:	80 ea       	ldi	r24, 0xA0	; 160
    13b4:	96 e0       	ldi	r25, 0x06	; 6
    13b6:	28 e0       	ldi	r18, 0x08	; 8
    13b8:	fc 01       	movw	r30, r24
    13ba:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    13bc:	80 e8       	ldi	r24, 0x80	; 128
    13be:	96 e0       	ldi	r25, 0x06	; 6
    13c0:	20 e2       	ldi	r18, 0x20	; 32
    13c2:	fc 01       	movw	r30, r24
    13c4:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    13c6:	80 e4       	ldi	r24, 0x40	; 64
    13c8:	9a e0       	ldi	r25, 0x0A	; 10
    13ca:	23 e2       	ldi	r18, 0x23	; 35
    13cc:	fc 01       	movw	r30, r24
    13ce:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    13d0:	8e 81       	ldd	r24, Y+6	; 0x06
    13d2:	88 2f       	mov	r24, r24
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	25 e1       	ldi	r18, 0x15	; 21
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    13da:	28 1b       	sub	r18, r24
    13dc:	39 0b       	sbc	r19, r25
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	02 c0       	rjmp	.+4      	; 0x13e8 <CO_collectADC_cont+0xb0>
    13e4:	88 0f       	add	r24, r24
    13e6:	99 1f       	adc	r25, r25
    13e8:	2a 95       	dec	r18
    13ea:	e2 f7       	brpl	.-8      	; 0x13e4 <CO_collectADC_cont+0xac>
    13ec:	01 97       	sbiw	r24, 0x01	; 1
    13ee:	89 83       	std	Y+1, r24	; 0x01
    13f0:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    13f2:	80 e4       	ldi	r24, 0x40	; 64
    13f4:	9a e0       	ldi	r25, 0x0A	; 10
    13f6:	29 81       	ldd	r18, Y+1	; 0x01
    13f8:	3a 81       	ldd	r19, Y+2	; 0x02
    13fa:	fc 01       	movw	r30, r24
    13fc:	26 a3       	lds	r18, 0x56
    13fe:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1400:	80 e4       	ldi	r24, 0x40	; 64
    1402:	9a e0       	ldi	r25, 0x0A	; 10
    1404:	29 81       	ldd	r18, Y+1	; 0x01
    1406:	3a 81       	ldd	r19, Y+2	; 0x02
    1408:	36 95       	lsr	r19
    140a:	27 95       	ror	r18
    140c:	fc 01       	movw	r30, r24
    140e:	22 af       	sts	0x72, r18
    1410:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1412:	80 e4       	ldi	r24, 0x40	; 64
    1414:	9a e0       	ldi	r25, 0x0A	; 10
    1416:	20 e4       	ldi	r18, 0x40	; 64
    1418:	3a e0       	ldi	r19, 0x0A	; 10
    141a:	f9 01       	movw	r30, r18
    141c:	20 81       	ld	r18, Z
    141e:	20 7f       	andi	r18, 0xF0	; 240
    1420:	21 60       	ori	r18, 0x01	; 1
    1422:	fc 01       	movw	r30, r24
    1424:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_MEDLVLEN_bm;
    1426:	80 ea       	ldi	r24, 0xA0	; 160
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	20 ea       	ldi	r18, 0xA0	; 160
    142c:	30 e0       	ldi	r19, 0x00	; 0
    142e:	f9 01       	movw	r30, r18
    1430:	22 81       	ldd	r18, Z+2	; 0x02
    1432:	22 60       	ori	r18, 0x02	; 2
    1434:	fc 01       	movw	r30, r24
    1436:	22 83       	std	Z+2, r18	; 0x02
//enable RR of lowlvl interrupts
PMIC.CTRL |= PMIC_RREN_bm; 
    1438:	80 ea       	ldi	r24, 0xA0	; 160
    143a:	90 e0       	ldi	r25, 0x00	; 0
    143c:	20 ea       	ldi	r18, 0xA0	; 160
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	f9 01       	movw	r30, r18
    1442:	22 81       	ldd	r18, Z+2	; 0x02
    1444:	20 68       	ori	r18, 0x80	; 128
    1446:	fc 01       	movw	r30, r24
    1448:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
// chb_init();
// chb_set_short_addr(moteID);

sampleCount = 0;
    144a:	10 92 75 50 	sts	0x5075, r1
    144e:	10 92 76 50 	sts	0x5076, r1
    1452:	10 92 77 50 	sts	0x5077, r1
    1456:	10 92 78 50 	sts	0x5078, r1
TotalSampleCount = 0;
    145a:	10 92 a5 50 	sts	0x50A5, r1
    145e:	10 92 a6 50 	sts	0x50A6, r1
discardCount = 0;
    1462:	10 92 5e 40 	sts	0x405E, r1
sei();
    1466:	78 94       	sei
}
    1468:	26 96       	adiw	r28, 0x06	; 6
    146a:	cd bf       	out	0x3d, r28	; 61
    146c:	de bf       	out	0x3e, r29	; 62
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	08 95       	ret

00001474 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
    1474:	cf 93       	push	r28
    1476:	df 93       	push	r29
    1478:	cd b7       	in	r28, 0x3d	; 61
    147a:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    147c:	80 ea       	ldi	r24, 0xA0	; 160
    147e:	96 e0       	ldi	r25, 0x06	; 6
    1480:	fc 01       	movw	r30, r24
    1482:	13 86       	std	Z+11, r1	; 0x0b
}
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	08 95       	ret

0000148a <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1492:	80 ea       	ldi	r24, 0xA0	; 160
    1494:	96 e0       	ldi	r25, 0x06	; 6
    1496:	21 e0       	ldi	r18, 0x01	; 1
    1498:	fc 01       	movw	r30, r24
    149a:	23 87       	std	Z+11, r18	; 0x0b
}	
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	08 95       	ret

000014a2 <__vector_105>:

//ISR used by CO_collectADC_cont function
ISR(PORTF_INT1_vect) {
    14a2:	1f 92       	push	r1
    14a4:	0f 92       	push	r0
    14a6:	0f b6       	in	r0, 0x3f	; 63
    14a8:	0f 92       	push	r0
    14aa:	00 90 3b 00 	lds	r0, 0x003B
    14ae:	0f 92       	push	r0
    14b0:	11 24       	eor	r1, r1
    14b2:	2f 92       	push	r2
    14b4:	3f 92       	push	r3
    14b6:	4f 92       	push	r4
    14b8:	5f 92       	push	r5
    14ba:	6f 92       	push	r6
    14bc:	7f 92       	push	r7
    14be:	8f 92       	push	r8
    14c0:	9f 92       	push	r9
    14c2:	af 92       	push	r10
    14c4:	bf 92       	push	r11
    14c6:	cf 92       	push	r12
    14c8:	df 92       	push	r13
    14ca:	ef 92       	push	r14
    14cc:	ff 92       	push	r15
    14ce:	0f 93       	push	r16
    14d0:	1f 93       	push	r17
    14d2:	2f 93       	push	r18
    14d4:	3f 93       	push	r19
    14d6:	4f 93       	push	r20
    14d8:	5f 93       	push	r21
    14da:	6f 93       	push	r22
    14dc:	7f 93       	push	r23
    14de:	8f 93       	push	r24
    14e0:	9f 93       	push	r25
    14e2:	af 93       	push	r26
    14e4:	bf 93       	push	r27
    14e6:	ef 93       	push	r30
    14e8:	ff 93       	push	r31
    14ea:	cf 93       	push	r28
    14ec:	df 93       	push	r29
    14ee:	00 d0       	rcall	.+0      	; 0x14f0 <__vector_105+0x4e>
    14f0:	cd b7       	in	r28, 0x3d	; 61
    14f2:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    14f4:	80 91 5e 40 	lds	r24, 0x405E
    14f8:	88 23       	and	r24, r24
    14fa:	34 f0       	brlt	.+12     	; 0x1508 <__vector_105+0x66>
		discardCount++;
    14fc:	80 91 5e 40 	lds	r24, 0x405E
    1500:	8f 5f       	subi	r24, 0xFF	; 255
    1502:	80 93 5e 40 	sts	0x405E, r24
    1506:	af c1       	rjmp	.+862    	; 0x1866 <__vector_105+0x3c4>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1508:	84 e0       	ldi	r24, 0x04	; 4
    150a:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    150e:	80 ec       	ldi	r24, 0xC0	; 192
    1510:	98 e0       	ldi	r25, 0x08	; 8
    1512:	24 e5       	ldi	r18, 0x54	; 84
    1514:	fc 01       	movw	r30, r24
    1516:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    151e:	80 ea       	ldi	r24, 0xA0	; 160
    1520:	96 e0       	ldi	r25, 0x06	; 6
    1522:	22 e0       	ldi	r18, 0x02	; 2
    1524:	fc 01       	movw	r30, r24
    1526:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1528:	19 82       	std	Y+1, r1	; 0x01
    152a:	1a c0       	rjmp	.+52     	; 0x1560 <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    152c:	80 ec       	ldi	r24, 0xC0	; 192
    152e:	98 e0       	ldi	r25, 0x08	; 8
    1530:	2a ea       	ldi	r18, 0xAA	; 170
    1532:	fc 01       	movw	r30, r24
    1534:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1536:	00 00       	nop
    1538:	80 ec       	ldi	r24, 0xC0	; 192
    153a:	98 e0       	ldi	r25, 0x08	; 8
    153c:	fc 01       	movw	r30, r24
    153e:	82 81       	ldd	r24, Z+2	; 0x02
    1540:	88 23       	and	r24, r24
    1542:	d4 f7       	brge	.-12     	; 0x1538 <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1544:	89 81       	ldd	r24, Y+1	; 0x01
    1546:	88 2f       	mov	r24, r24
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	20 ec       	ldi	r18, 0xC0	; 192
    154c:	38 e0       	ldi	r19, 0x08	; 8
    154e:	f9 01       	movw	r30, r18
    1550:	23 81       	ldd	r18, Z+3	; 0x03
    1552:	8a 59       	subi	r24, 0x9A	; 154
    1554:	9f 4a       	sbci	r25, 0xAF	; 175
    1556:	fc 01       	movw	r30, r24
    1558:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    155a:	89 81       	ldd	r24, Y+1	; 0x01
    155c:	8f 5f       	subi	r24, 0xFF	; 255
    155e:	89 83       	std	Y+1, r24	; 0x01
    1560:	89 81       	ldd	r24, Y+1	; 0x01
    1562:	83 30       	cpi	r24, 0x03	; 3
    1564:	18 f3       	brcs	.-58     	; 0x152c <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1566:	80 ea       	ldi	r24, 0xA0	; 160
    1568:	96 e0       	ldi	r25, 0x06	; 6
    156a:	22 e0       	ldi	r18, 0x02	; 2
    156c:	fc 01       	movw	r30, r24
    156e:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1570:	80 e0       	ldi	r24, 0x00	; 0
    1572:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1576:	80 91 66 50 	lds	r24, 0x5066
    157a:	88 23       	and	r24, r24
    157c:	34 f4       	brge	.+12     	; 0x158a <__vector_105+0xe8>
    157e:	87 e6       	ldi	r24, 0x67	; 103
    1580:	90 e4       	ldi	r25, 0x40	; 64
    1582:	2f ef       	ldi	r18, 0xFF	; 255
    1584:	fc 01       	movw	r30, r24
    1586:	20 83       	st	Z, r18
    1588:	04 c0       	rjmp	.+8      	; 0x1592 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    158a:	87 e6       	ldi	r24, 0x67	; 103
    158c:	90 e4       	ldi	r25, 0x40	; 64
    158e:	fc 01       	movw	r30, r24
    1590:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1592:	86 e6       	ldi	r24, 0x66	; 102
    1594:	90 e4       	ldi	r25, 0x40	; 64
    1596:	20 91 66 50 	lds	r18, 0x5066
    159a:	fc 01       	movw	r30, r24
    159c:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    159e:	85 e6       	ldi	r24, 0x65	; 101
    15a0:	90 e4       	ldi	r25, 0x40	; 64
    15a2:	20 91 67 50 	lds	r18, 0x5067
    15a6:	fc 01       	movw	r30, r24
    15a8:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    15aa:	84 e6       	ldi	r24, 0x64	; 100
    15ac:	90 e4       	ldi	r25, 0x40	; 64
    15ae:	20 91 68 50 	lds	r18, 0x5068
    15b2:	fc 01       	movw	r30, r24
    15b4:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    15b6:	80 91 64 40 	lds	r24, 0x4064
    15ba:	90 91 65 40 	lds	r25, 0x4065
    15be:	a0 91 66 40 	lds	r26, 0x4066
    15c2:	b0 91 67 40 	lds	r27, 0x4067
    15c6:	5c 01       	movw	r10, r24
    15c8:	6d 01       	movw	r12, r26
    15ca:	bb 0f       	add	r27, r27
    15cc:	88 0b       	sbc	r24, r24
    15ce:	98 2f       	mov	r25, r24
    15d0:	dc 01       	movw	r26, r24
    15d2:	e8 2e       	mov	r14, r24
    15d4:	f8 2e       	mov	r15, r24
    15d6:	08 2f       	mov	r16, r24
    15d8:	18 2f       	mov	r17, r24
    15da:	a0 92 a7 50 	sts	0x50A7, r10
    15de:	b0 92 a8 50 	sts	0x50A8, r11
    15e2:	c0 92 a9 50 	sts	0x50A9, r12
    15e6:	d0 92 aa 50 	sts	0x50AA, r13
    15ea:	e0 92 ab 50 	sts	0x50AB, r14
    15ee:	f0 92 ac 50 	sts	0x50AC, r15
    15f2:	00 93 ad 50 	sts	0x50AD, r16
    15f6:	10 93 ae 50 	sts	0x50AE, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    15fa:	80 91 75 50 	lds	r24, 0x5075
    15fe:	90 91 76 50 	lds	r25, 0x5076
    1602:	a0 91 77 50 	lds	r26, 0x5077
    1606:	b0 91 78 50 	lds	r27, 0x5078
    160a:	88 0f       	add	r24, r24
    160c:	99 1f       	adc	r25, r25
    160e:	88 0f       	add	r24, r24
    1610:	99 1f       	adc	r25, r25
    1612:	9c 01       	movw	r18, r24
    1614:	28 52       	subi	r18, 0x28	; 40
    1616:	3c 4d       	sbci	r19, 0xDC	; 220
    1618:	2a 83       	std	Y+2, r18	; 0x02
    161a:	3b 83       	std	Y+3, r19	; 0x03
    161c:	a0 90 a7 50 	lds	r10, 0x50A7
    1620:	b0 90 a8 50 	lds	r11, 0x50A8
    1624:	c0 90 a9 50 	lds	r12, 0x50A9
    1628:	d0 90 aa 50 	lds	r13, 0x50AA
    162c:	e0 90 ab 50 	lds	r14, 0x50AB
    1630:	f0 90 ac 50 	lds	r15, 0x50AC
    1634:	00 91 ad 50 	lds	r16, 0x50AD
    1638:	10 91 ae 50 	lds	r17, 0x50AE
    163c:	2a 2d       	mov	r18, r10
    163e:	3b 2d       	mov	r19, r11
    1640:	4c 2d       	mov	r20, r12
    1642:	5d 2d       	mov	r21, r13
    1644:	6e 2d       	mov	r22, r14
    1646:	7f 2d       	mov	r23, r15
    1648:	80 2f       	mov	r24, r16
    164a:	91 2f       	mov	r25, r17
    164c:	0f 2e       	mov	r0, r31
    164e:	f0 ea       	ldi	r31, 0xA0	; 160
    1650:	af 2e       	mov	r10, r31
    1652:	f0 2d       	mov	r31, r0
    1654:	0f 2e       	mov	r0, r31
    1656:	f5 e2       	ldi	r31, 0x25	; 37
    1658:	bf 2e       	mov	r11, r31
    165a:	f0 2d       	mov	r31, r0
    165c:	0f 2e       	mov	r0, r31
    165e:	f6 e2       	ldi	r31, 0x26	; 38
    1660:	cf 2e       	mov	r12, r31
    1662:	f0 2d       	mov	r31, r0
    1664:	dd 24       	eor	r13, r13
    1666:	ee 24       	eor	r14, r14
    1668:	ff 24       	eor	r15, r15
    166a:	00 e0       	ldi	r16, 0x00	; 0
    166c:	10 e0       	ldi	r17, 0x00	; 0
    166e:	0e 94 49 51 	call	0xa292	; 0xa292 <__muldi3>
    1672:	22 2e       	mov	r2, r18
    1674:	33 2e       	mov	r3, r19
    1676:	44 2e       	mov	r4, r20
    1678:	55 2e       	mov	r5, r21
    167a:	66 2e       	mov	r6, r22
    167c:	77 2e       	mov	r7, r23
    167e:	88 2e       	mov	r8, r24
    1680:	99 2e       	mov	r9, r25
    1682:	a2 2c       	mov	r10, r2
    1684:	b3 2c       	mov	r11, r3
    1686:	c4 2c       	mov	r12, r4
    1688:	d5 2c       	mov	r13, r5
    168a:	e6 2c       	mov	r14, r6
    168c:	f7 2c       	mov	r15, r7
    168e:	08 2d       	mov	r16, r8
    1690:	19 2d       	mov	r17, r9
    1692:	2a 2d       	mov	r18, r10
    1694:	3b 2d       	mov	r19, r11
    1696:	4c 2d       	mov	r20, r12
    1698:	5d 2d       	mov	r21, r13
    169a:	6e 2d       	mov	r22, r14
    169c:	7f 2d       	mov	r23, r15
    169e:	80 2f       	mov	r24, r16
    16a0:	91 2f       	mov	r25, r17
    16a2:	aa 24       	eor	r10, r10
    16a4:	aa 94       	dec	r10
    16a6:	bb 24       	eor	r11, r11
    16a8:	ba 94       	dec	r11
    16aa:	0f 2e       	mov	r0, r31
    16ac:	ff e7       	ldi	r31, 0x7F	; 127
    16ae:	cf 2e       	mov	r12, r31
    16b0:	f0 2d       	mov	r31, r0
    16b2:	dd 24       	eor	r13, r13
    16b4:	ee 24       	eor	r14, r14
    16b6:	ff 24       	eor	r15, r15
    16b8:	00 e0       	ldi	r16, 0x00	; 0
    16ba:	10 e0       	ldi	r17, 0x00	; 0
    16bc:	0e 94 90 52 	call	0xa520	; 0xa520 <__divdi3>
    16c0:	22 2e       	mov	r2, r18
    16c2:	33 2e       	mov	r3, r19
    16c4:	44 2e       	mov	r4, r20
    16c6:	55 2e       	mov	r5, r21
    16c8:	66 2e       	mov	r6, r22
    16ca:	77 2e       	mov	r7, r23
    16cc:	88 2e       	mov	r8, r24
    16ce:	99 2e       	mov	r9, r25
    16d0:	a2 2c       	mov	r10, r2
    16d2:	b3 2c       	mov	r11, r3
    16d4:	c4 2c       	mov	r12, r4
    16d6:	d5 2c       	mov	r13, r5
    16d8:	e6 2c       	mov	r14, r6
    16da:	f7 2c       	mov	r15, r7
    16dc:	08 2d       	mov	r16, r8
    16de:	19 2d       	mov	r17, r9
    16e0:	2a 2d       	mov	r18, r10
    16e2:	3b 2d       	mov	r19, r11
    16e4:	4c 2d       	mov	r20, r12
    16e6:	5d 2d       	mov	r21, r13
    16e8:	6e 2d       	mov	r22, r14
    16ea:	7f 2d       	mov	r23, r15
    16ec:	80 2f       	mov	r24, r16
    16ee:	91 2f       	mov	r25, r17
    16f0:	01 e0       	ldi	r16, 0x01	; 1
    16f2:	0e 94 1c 52 	call	0xa438	; 0xa438 <__ashldi3>
    16f6:	22 2e       	mov	r2, r18
    16f8:	33 2e       	mov	r3, r19
    16fa:	44 2e       	mov	r4, r20
    16fc:	55 2e       	mov	r5, r21
    16fe:	66 2e       	mov	r6, r22
    1700:	77 2e       	mov	r7, r23
    1702:	88 2e       	mov	r8, r24
    1704:	99 2e       	mov	r9, r25
    1706:	a2 2c       	mov	r10, r2
    1708:	b3 2c       	mov	r11, r3
    170a:	c4 2c       	mov	r12, r4
    170c:	d5 2c       	mov	r13, r5
    170e:	e6 2c       	mov	r14, r6
    1710:	f7 2c       	mov	r15, r7
    1712:	08 2d       	mov	r16, r8
    1714:	19 2d       	mov	r17, r9
    1716:	2a 2d       	mov	r18, r10
    1718:	3b 2d       	mov	r19, r11
    171a:	4c 2d       	mov	r20, r12
    171c:	5d 2d       	mov	r21, r13
    171e:	6e 2d       	mov	r22, r14
    1720:	7f 2d       	mov	r23, r15
    1722:	80 2f       	mov	r24, r16
    1724:	91 2f       	mov	r25, r17
    1726:	0f 2e       	mov	r0, r31
    1728:	f3 e0       	ldi	r31, 0x03	; 3
    172a:	af 2e       	mov	r10, r31
    172c:	f0 2d       	mov	r31, r0
    172e:	bb 24       	eor	r11, r11
    1730:	cc 24       	eor	r12, r12
    1732:	dd 24       	eor	r13, r13
    1734:	ee 24       	eor	r14, r14
    1736:	ff 24       	eor	r15, r15
    1738:	00 e0       	ldi	r16, 0x00	; 0
    173a:	10 e0       	ldi	r17, 0x00	; 0
    173c:	0e 94 90 52 	call	0xa520	; 0xa520 <__divdi3>
    1740:	a2 2e       	mov	r10, r18
    1742:	b3 2e       	mov	r11, r19
    1744:	c4 2e       	mov	r12, r20
    1746:	d5 2e       	mov	r13, r21
    1748:	e6 2e       	mov	r14, r22
    174a:	f7 2e       	mov	r15, r23
    174c:	08 2f       	mov	r16, r24
    174e:	19 2f       	mov	r17, r25
    1750:	2a 2d       	mov	r18, r10
    1752:	3b 2d       	mov	r19, r11
    1754:	4c 2d       	mov	r20, r12
    1756:	5d 2d       	mov	r21, r13
    1758:	6e 2d       	mov	r22, r14
    175a:	7f 2d       	mov	r23, r15
    175c:	80 2f       	mov	r24, r16
    175e:	91 2f       	mov	r25, r17
    1760:	da 01       	movw	r26, r20
    1762:	c9 01       	movw	r24, r18
    1764:	b0 95       	com	r27
    1766:	a0 95       	com	r26
    1768:	90 95       	com	r25
    176a:	81 95       	neg	r24
    176c:	9f 4f       	sbci	r25, 0xFF	; 255
    176e:	af 4f       	sbci	r26, 0xFF	; 255
    1770:	bf 4f       	sbci	r27, 0xFF	; 255
    1772:	ea 81       	ldd	r30, Y+2	; 0x02
    1774:	fb 81       	ldd	r31, Y+3	; 0x03
    1776:	80 83       	st	Z, r24
    1778:	91 83       	std	Z+1, r25	; 0x01
    177a:	a2 83       	std	Z+2, r26	; 0x02
    177c:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    177e:	80 91 75 50 	lds	r24, 0x5075
    1782:	90 91 76 50 	lds	r25, 0x5076
    1786:	a0 91 77 50 	lds	r26, 0x5077
    178a:	b0 91 78 50 	lds	r27, 0x5078
    178e:	01 96       	adiw	r24, 0x01	; 1
    1790:	a1 1d       	adc	r26, r1
    1792:	b1 1d       	adc	r27, r1
    1794:	80 93 75 50 	sts	0x5075, r24
    1798:	90 93 76 50 	sts	0x5076, r25
    179c:	a0 93 77 50 	sts	0x5077, r26
    17a0:	b0 93 78 50 	sts	0x5078, r27
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    17a4:	80 91 75 50 	lds	r24, 0x5075
    17a8:	90 91 76 50 	lds	r25, 0x5076
    17ac:	a0 91 77 50 	lds	r26, 0x5077
    17b0:	b0 91 78 50 	lds	r27, 0x5078
    17b4:	8e 31       	cpi	r24, 0x1E	; 30
    17b6:	91 05       	cpc	r25, r1
    17b8:	a1 05       	cpc	r26, r1
    17ba:	b1 05       	cpc	r27, r1
    17bc:	08 f4       	brcc	.+2      	; 0x17c0 <__vector_105+0x31e>
    17be:	53 c0       	rjmp	.+166    	; 0x1866 <__vector_105+0x3c4>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    17c0:	10 92 75 50 	sts	0x5075, r1
    17c4:	10 92 76 50 	sts	0x5076, r1
    17c8:	10 92 77 50 	sts	0x5077, r1
    17cc:	10 92 78 50 	sts	0x5078, r1
		TotalSampleCount++;
    17d0:	80 91 a5 50 	lds	r24, 0x50A5
    17d4:	90 91 a6 50 	lds	r25, 0x50A6
    17d8:	01 96       	adiw	r24, 0x01	; 1
    17da:	80 93 a5 50 	sts	0x50A5, r24
    17de:	90 93 a6 50 	sts	0x50A6, r25
		discardCount = ADC_DISCARD -1; //discard the next sample after pausing the sampling to send/store data since the sample ready flag will be outdated and the value might be bad
    17e2:	8f e7       	ldi	r24, 0x7F	; 127
    17e4:	80 93 5e 40 	sts	0x405E, r24
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove(FRAMReadBuffer+2,FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    17e8:	80 91 75 50 	lds	r24, 0x5075
    17ec:	90 91 76 50 	lds	r25, 0x5076
    17f0:	a0 91 77 50 	lds	r26, 0x5077
    17f4:	b0 91 78 50 	lds	r27, 0x5078
    17f8:	9c 01       	movw	r18, r24
    17fa:	22 0f       	add	r18, r18
    17fc:	33 1f       	adc	r19, r19
    17fe:	22 0f       	add	r18, r18
    1800:	33 1f       	adc	r19, r19
    1802:	8a ed       	ldi	r24, 0xDA	; 218
    1804:	93 e2       	ldi	r25, 0x23	; 35
    1806:	48 ed       	ldi	r20, 0xD8	; 216
    1808:	53 e2       	ldi	r21, 0x23	; 35
    180a:	ba 01       	movw	r22, r20
    180c:	a9 01       	movw	r20, r18
    180e:	0e 94 c0 62 	call	0xc580	; 0xc580 <memcpy>
		FRAMReadBuffer[0] = moteID;		//send moteID of the mote that gathered the data
    1812:	80 91 d1 50 	lds	r24, 0x50D1
    1816:	80 93 d8 23 	sts	0x23D8, r24
		FRAMReadBuffer[1] = (uint8_t)sampleCount;	//send the number of data samples gathered cast as a byte since no more than 30/31 samples should be send at a time
    181a:	80 91 75 50 	lds	r24, 0x5075
    181e:	90 91 76 50 	lds	r25, 0x5076
    1822:	a0 91 77 50 	lds	r26, 0x5077
    1826:	b0 91 78 50 	lds	r27, 0x5078
    182a:	80 93 d9 23 	sts	0x23D9, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+2);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    182e:	80 91 75 50 	lds	r24, 0x5075
    1832:	90 91 76 50 	lds	r25, 0x5076
    1836:	a0 91 77 50 	lds	r26, 0x5077
    183a:	b0 91 78 50 	lds	r27, 0x5078
    183e:	88 0f       	add	r24, r24
    1840:	99 1f       	adc	r25, r25
    1842:	aa 1f       	adc	r26, r26
    1844:	bb 1f       	adc	r27, r27
    1846:	88 0f       	add	r24, r24
    1848:	99 1f       	adc	r25, r25
    184a:	aa 1f       	adc	r26, r26
    184c:	bb 1f       	adc	r27, r27
    184e:	9c 01       	movw	r18, r24
    1850:	ad 01       	movw	r20, r26
    1852:	2e 5f       	subi	r18, 0xFE	; 254
    1854:	3f 4f       	sbci	r19, 0xFF	; 255
    1856:	4f 4f       	sbci	r20, 0xFF	; 255
    1858:	5f 4f       	sbci	r21, 0xFF	; 255
    185a:	68 ed       	ldi	r22, 0xD8	; 216
    185c:	73 e2       	ldi	r23, 0x23	; 35
    185e:	80 e0       	ldi	r24, 0x00	; 0
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	0e 94 86 1e 	call	0x3d0c	; 0x3d0c <chb_write>
	}	
	}	
}
    1866:	23 96       	adiw	r28, 0x03	; 3
    1868:	cd bf       	out	0x3d, r28	; 61
    186a:	de bf       	out	0x3e, r29	; 62
    186c:	df 91       	pop	r29
    186e:	cf 91       	pop	r28
    1870:	ff 91       	pop	r31
    1872:	ef 91       	pop	r30
    1874:	bf 91       	pop	r27
    1876:	af 91       	pop	r26
    1878:	9f 91       	pop	r25
    187a:	8f 91       	pop	r24
    187c:	7f 91       	pop	r23
    187e:	6f 91       	pop	r22
    1880:	5f 91       	pop	r21
    1882:	4f 91       	pop	r20
    1884:	3f 91       	pop	r19
    1886:	2f 91       	pop	r18
    1888:	1f 91       	pop	r17
    188a:	0f 91       	pop	r16
    188c:	ff 90       	pop	r15
    188e:	ef 90       	pop	r14
    1890:	df 90       	pop	r13
    1892:	cf 90       	pop	r12
    1894:	bf 90       	pop	r11
    1896:	af 90       	pop	r10
    1898:	9f 90       	pop	r9
    189a:	8f 90       	pop	r8
    189c:	7f 90       	pop	r7
    189e:	6f 90       	pop	r6
    18a0:	5f 90       	pop	r5
    18a2:	4f 90       	pop	r4
    18a4:	3f 90       	pop	r3
    18a6:	2f 90       	pop	r2
    18a8:	0f 90       	pop	r0
    18aa:	00 92 3b 00 	sts	0x003B, r0
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63
    18b2:	0f 90       	pop	r0
    18b4:	1f 90       	pop	r1
    18b6:	18 95       	reti

000018b8 <__vector_104>:

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    18b8:	1f 92       	push	r1
    18ba:	0f 92       	push	r0
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	0f 92       	push	r0
    18c0:	00 90 3b 00 	lds	r0, 0x003B
    18c4:	0f 92       	push	r0
    18c6:	11 24       	eor	r1, r1
    18c8:	2f 92       	push	r2
    18ca:	3f 92       	push	r3
    18cc:	4f 92       	push	r4
    18ce:	5f 92       	push	r5
    18d0:	6f 92       	push	r6
    18d2:	7f 92       	push	r7
    18d4:	8f 92       	push	r8
    18d6:	9f 92       	push	r9
    18d8:	af 92       	push	r10
    18da:	bf 92       	push	r11
    18dc:	cf 92       	push	r12
    18de:	df 92       	push	r13
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	2f 93       	push	r18
    18ea:	3f 93       	push	r19
    18ec:	4f 93       	push	r20
    18ee:	5f 93       	push	r21
    18f0:	6f 93       	push	r22
    18f2:	7f 93       	push	r23
    18f4:	8f 93       	push	r24
    18f6:	9f 93       	push	r25
    18f8:	af 93       	push	r26
    18fa:	bf 93       	push	r27
    18fc:	ef 93       	push	r30
    18fe:	ff 93       	push	r31
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	00 d0       	rcall	.+0      	; 0x1906 <__vector_104+0x4e>
    1906:	cd b7       	in	r28, 0x3d	; 61
    1908:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    190a:	80 91 5e 40 	lds	r24, 0x405E
    190e:	88 23       	and	r24, r24
    1910:	34 f0       	brlt	.+12     	; 0x191e <__vector_104+0x66>
		discardCount++;
    1912:	80 91 5e 40 	lds	r24, 0x405E
    1916:	8f 5f       	subi	r24, 0xFF	; 255
    1918:	80 93 5e 40 	sts	0x405E, r24
    191c:	75 c1       	rjmp	.+746    	; 0x1c08 <__vector_104+0x350>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    191e:	81 e0       	ldi	r24, 0x01	; 1
    1920:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1924:	80 ea       	ldi	r24, 0xA0	; 160
    1926:	96 e0       	ldi	r25, 0x06	; 6
    1928:	22 e0       	ldi	r18, 0x02	; 2
    192a:	fc 01       	movw	r30, r24
    192c:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    192e:	19 82       	std	Y+1, r1	; 0x01
    1930:	1a c0       	rjmp	.+52     	; 0x1966 <__vector_104+0xae>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1932:	80 ec       	ldi	r24, 0xC0	; 192
    1934:	98 e0       	ldi	r25, 0x08	; 8
    1936:	2a ea       	ldi	r18, 0xAA	; 170
    1938:	fc 01       	movw	r30, r24
    193a:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    193c:	00 00       	nop
    193e:	80 ec       	ldi	r24, 0xC0	; 192
    1940:	98 e0       	ldi	r25, 0x08	; 8
    1942:	fc 01       	movw	r30, r24
    1944:	82 81       	ldd	r24, Z+2	; 0x02
    1946:	88 23       	and	r24, r24
    1948:	d4 f7       	brge	.-12     	; 0x193e <__vector_104+0x86>
			SPIBuffer[bufIndex] = SPIC.DATA;
    194a:	89 81       	ldd	r24, Y+1	; 0x01
    194c:	88 2f       	mov	r24, r24
    194e:	90 e0       	ldi	r25, 0x00	; 0
    1950:	20 ec       	ldi	r18, 0xC0	; 192
    1952:	38 e0       	ldi	r19, 0x08	; 8
    1954:	f9 01       	movw	r30, r18
    1956:	23 81       	ldd	r18, Z+3	; 0x03
    1958:	8a 59       	subi	r24, 0x9A	; 154
    195a:	9f 4a       	sbci	r25, 0xAF	; 175
    195c:	fc 01       	movw	r30, r24
    195e:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	8f 5f       	subi	r24, 0xFF	; 255
    1964:	89 83       	std	Y+1, r24	; 0x01
    1966:	89 81       	ldd	r24, Y+1	; 0x01
    1968:	83 30       	cpi	r24, 0x03	; 3
    196a:	18 f3       	brcs	.-58     	; 0x1932 <__vector_104+0x7a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    196c:	80 ea       	ldi	r24, 0xA0	; 160
    196e:	96 e0       	ldi	r25, 0x06	; 6
    1970:	22 e0       	ldi	r18, 0x02	; 2
    1972:	fc 01       	movw	r30, r24
    1974:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1976:	80 e0       	ldi	r24, 0x00	; 0
    1978:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    197c:	80 91 66 50 	lds	r24, 0x5066
    1980:	88 23       	and	r24, r24
    1982:	9c f4       	brge	.+38     	; 0x19aa <__vector_104+0xf2>
    1984:	80 91 75 50 	lds	r24, 0x5075
    1988:	90 91 76 50 	lds	r25, 0x5076
    198c:	a0 91 77 50 	lds	r26, 0x5077
    1990:	b0 91 78 50 	lds	r27, 0x5078
    1994:	88 0f       	add	r24, r24
    1996:	99 1f       	adc	r25, r25
    1998:	88 0f       	add	r24, r24
    199a:	99 1f       	adc	r25, r25
    199c:	03 96       	adiw	r24, 0x03	; 3
    199e:	8c 59       	subi	r24, 0x9C	; 156
    19a0:	9f 4b       	sbci	r25, 0xBF	; 191
    19a2:	2f ef       	ldi	r18, 0xFF	; 255
    19a4:	fc 01       	movw	r30, r24
    19a6:	20 83       	st	Z, r18
    19a8:	11 c0       	rjmp	.+34     	; 0x19cc <__vector_104+0x114>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    19aa:	80 91 75 50 	lds	r24, 0x5075
    19ae:	90 91 76 50 	lds	r25, 0x5076
    19b2:	a0 91 77 50 	lds	r26, 0x5077
    19b6:	b0 91 78 50 	lds	r27, 0x5078
    19ba:	88 0f       	add	r24, r24
    19bc:	99 1f       	adc	r25, r25
    19be:	88 0f       	add	r24, r24
    19c0:	99 1f       	adc	r25, r25
    19c2:	03 96       	adiw	r24, 0x03	; 3
    19c4:	8c 59       	subi	r24, 0x9C	; 156
    19c6:	9f 4b       	sbci	r25, 0xBF	; 191
    19c8:	fc 01       	movw	r30, r24
    19ca:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    19cc:	80 91 75 50 	lds	r24, 0x5075
    19d0:	90 91 76 50 	lds	r25, 0x5076
    19d4:	a0 91 77 50 	lds	r26, 0x5077
    19d8:	b0 91 78 50 	lds	r27, 0x5078
    19dc:	88 0f       	add	r24, r24
    19de:	99 1f       	adc	r25, r25
    19e0:	88 0f       	add	r24, r24
    19e2:	99 1f       	adc	r25, r25
    19e4:	02 96       	adiw	r24, 0x02	; 2
    19e6:	8c 59       	subi	r24, 0x9C	; 156
    19e8:	9f 4b       	sbci	r25, 0xBF	; 191
    19ea:	20 91 66 50 	lds	r18, 0x5066
    19ee:	fc 01       	movw	r30, r24
    19f0:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    19f2:	80 91 75 50 	lds	r24, 0x5075
    19f6:	90 91 76 50 	lds	r25, 0x5076
    19fa:	a0 91 77 50 	lds	r26, 0x5077
    19fe:	b0 91 78 50 	lds	r27, 0x5078
    1a02:	88 0f       	add	r24, r24
    1a04:	99 1f       	adc	r25, r25
    1a06:	88 0f       	add	r24, r24
    1a08:	99 1f       	adc	r25, r25
    1a0a:	01 96       	adiw	r24, 0x01	; 1
    1a0c:	8c 59       	subi	r24, 0x9C	; 156
    1a0e:	9f 4b       	sbci	r25, 0xBF	; 191
    1a10:	20 91 67 50 	lds	r18, 0x5067
    1a14:	fc 01       	movw	r30, r24
    1a16:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    1a18:	80 91 75 50 	lds	r24, 0x5075
    1a1c:	90 91 76 50 	lds	r25, 0x5076
    1a20:	a0 91 77 50 	lds	r26, 0x5077
    1a24:	b0 91 78 50 	lds	r27, 0x5078
    1a28:	88 0f       	add	r24, r24
    1a2a:	99 1f       	adc	r25, r25
    1a2c:	88 0f       	add	r24, r24
    1a2e:	99 1f       	adc	r25, r25
    1a30:	8c 59       	subi	r24, 0x9C	; 156
    1a32:	9f 4b       	sbci	r25, 0xBF	; 191
    1a34:	20 91 68 50 	lds	r18, 0x5068
    1a38:	fc 01       	movw	r30, r24
    1a3a:	20 83       	st	Z, r18
		
		ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)data24Bit[sampleCount] * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a3c:	20 91 73 50 	lds	r18, 0x5073
    1a40:	30 91 74 50 	lds	r19, 0x5074
    1a44:	80 91 75 50 	lds	r24, 0x5075
    1a48:	90 91 76 50 	lds	r25, 0x5076
    1a4c:	a0 91 77 50 	lds	r26, 0x5077
    1a50:	b0 91 78 50 	lds	r27, 0x5078
    1a54:	88 0f       	add	r24, r24
    1a56:	99 1f       	adc	r25, r25
    1a58:	88 0f       	add	r24, r24
    1a5a:	99 1f       	adc	r25, r25
    1a5c:	a9 01       	movw	r20, r18
    1a5e:	48 0f       	add	r20, r24
    1a60:	59 1f       	adc	r21, r25
    1a62:	4a 83       	std	Y+2, r20	; 0x02
    1a64:	5b 83       	std	Y+3, r21	; 0x03
    1a66:	80 91 75 50 	lds	r24, 0x5075
    1a6a:	90 91 76 50 	lds	r25, 0x5076
    1a6e:	a0 91 77 50 	lds	r26, 0x5077
    1a72:	b0 91 78 50 	lds	r27, 0x5078
    1a76:	88 0f       	add	r24, r24
    1a78:	99 1f       	adc	r25, r25
    1a7a:	88 0f       	add	r24, r24
    1a7c:	99 1f       	adc	r25, r25
    1a7e:	8c 59       	subi	r24, 0x9C	; 156
    1a80:	9f 4b       	sbci	r25, 0xBF	; 191
    1a82:	fc 01       	movw	r30, r24
    1a84:	80 81       	ld	r24, Z
    1a86:	91 81       	ldd	r25, Z+1	; 0x01
    1a88:	a2 81       	ldd	r26, Z+2	; 0x02
    1a8a:	b3 81       	ldd	r27, Z+3	; 0x03
    1a8c:	5c 01       	movw	r10, r24
    1a8e:	6d 01       	movw	r12, r26
    1a90:	bb 0f       	add	r27, r27
    1a92:	88 0b       	sbc	r24, r24
    1a94:	98 2f       	mov	r25, r24
    1a96:	dc 01       	movw	r26, r24
    1a98:	e8 2e       	mov	r14, r24
    1a9a:	f8 2e       	mov	r15, r24
    1a9c:	08 2f       	mov	r16, r24
    1a9e:	18 2f       	mov	r17, r24
    1aa0:	2a 2d       	mov	r18, r10
    1aa2:	3b 2d       	mov	r19, r11
    1aa4:	4c 2d       	mov	r20, r12
    1aa6:	5d 2d       	mov	r21, r13
    1aa8:	6e 2d       	mov	r22, r14
    1aaa:	7f 2d       	mov	r23, r15
    1aac:	80 2f       	mov	r24, r16
    1aae:	91 2f       	mov	r25, r17
    1ab0:	0f 2e       	mov	r0, r31
    1ab2:	f0 ea       	ldi	r31, 0xA0	; 160
    1ab4:	af 2e       	mov	r10, r31
    1ab6:	f0 2d       	mov	r31, r0
    1ab8:	0f 2e       	mov	r0, r31
    1aba:	f5 e2       	ldi	r31, 0x25	; 37
    1abc:	bf 2e       	mov	r11, r31
    1abe:	f0 2d       	mov	r31, r0
    1ac0:	0f 2e       	mov	r0, r31
    1ac2:	f6 e2       	ldi	r31, 0x26	; 38
    1ac4:	cf 2e       	mov	r12, r31
    1ac6:	f0 2d       	mov	r31, r0
    1ac8:	dd 24       	eor	r13, r13
    1aca:	ee 24       	eor	r14, r14
    1acc:	ff 24       	eor	r15, r15
    1ace:	00 e0       	ldi	r16, 0x00	; 0
    1ad0:	10 e0       	ldi	r17, 0x00	; 0
    1ad2:	0e 94 49 51 	call	0xa292	; 0xa292 <__muldi3>
    1ad6:	22 2e       	mov	r2, r18
    1ad8:	33 2e       	mov	r3, r19
    1ada:	44 2e       	mov	r4, r20
    1adc:	55 2e       	mov	r5, r21
    1ade:	66 2e       	mov	r6, r22
    1ae0:	77 2e       	mov	r7, r23
    1ae2:	88 2e       	mov	r8, r24
    1ae4:	99 2e       	mov	r9, r25
    1ae6:	a2 2c       	mov	r10, r2
    1ae8:	b3 2c       	mov	r11, r3
    1aea:	c4 2c       	mov	r12, r4
    1aec:	d5 2c       	mov	r13, r5
    1aee:	e6 2c       	mov	r14, r6
    1af0:	f7 2c       	mov	r15, r7
    1af2:	08 2d       	mov	r16, r8
    1af4:	19 2d       	mov	r17, r9
    1af6:	2a 2d       	mov	r18, r10
    1af8:	3b 2d       	mov	r19, r11
    1afa:	4c 2d       	mov	r20, r12
    1afc:	5d 2d       	mov	r21, r13
    1afe:	6e 2d       	mov	r22, r14
    1b00:	7f 2d       	mov	r23, r15
    1b02:	80 2f       	mov	r24, r16
    1b04:	91 2f       	mov	r25, r17
    1b06:	aa 24       	eor	r10, r10
    1b08:	aa 94       	dec	r10
    1b0a:	bb 24       	eor	r11, r11
    1b0c:	ba 94       	dec	r11
    1b0e:	0f 2e       	mov	r0, r31
    1b10:	ff e7       	ldi	r31, 0x7F	; 127
    1b12:	cf 2e       	mov	r12, r31
    1b14:	f0 2d       	mov	r31, r0
    1b16:	dd 24       	eor	r13, r13
    1b18:	ee 24       	eor	r14, r14
    1b1a:	ff 24       	eor	r15, r15
    1b1c:	00 e0       	ldi	r16, 0x00	; 0
    1b1e:	10 e0       	ldi	r17, 0x00	; 0
    1b20:	0e 94 4c 5a 	call	0xb498	; 0xb498 <__udivdi3>
    1b24:	22 2e       	mov	r2, r18
    1b26:	33 2e       	mov	r3, r19
    1b28:	44 2e       	mov	r4, r20
    1b2a:	55 2e       	mov	r5, r21
    1b2c:	66 2e       	mov	r6, r22
    1b2e:	77 2e       	mov	r7, r23
    1b30:	88 2e       	mov	r8, r24
    1b32:	99 2e       	mov	r9, r25
    1b34:	a2 2c       	mov	r10, r2
    1b36:	b3 2c       	mov	r11, r3
    1b38:	c4 2c       	mov	r12, r4
    1b3a:	d5 2c       	mov	r13, r5
    1b3c:	e6 2c       	mov	r14, r6
    1b3e:	f7 2c       	mov	r15, r7
    1b40:	08 2d       	mov	r16, r8
    1b42:	19 2d       	mov	r17, r9
    1b44:	2a 2d       	mov	r18, r10
    1b46:	3b 2d       	mov	r19, r11
    1b48:	4c 2d       	mov	r20, r12
    1b4a:	5d 2d       	mov	r21, r13
    1b4c:	6e 2d       	mov	r22, r14
    1b4e:	7f 2d       	mov	r23, r15
    1b50:	80 2f       	mov	r24, r16
    1b52:	91 2f       	mov	r25, r17
    1b54:	01 e0       	ldi	r16, 0x01	; 1
    1b56:	0e 94 1c 52 	call	0xa438	; 0xa438 <__ashldi3>
    1b5a:	22 2e       	mov	r2, r18
    1b5c:	33 2e       	mov	r3, r19
    1b5e:	44 2e       	mov	r4, r20
    1b60:	55 2e       	mov	r5, r21
    1b62:	66 2e       	mov	r6, r22
    1b64:	77 2e       	mov	r7, r23
    1b66:	88 2e       	mov	r8, r24
    1b68:	99 2e       	mov	r9, r25
    1b6a:	a2 2c       	mov	r10, r2
    1b6c:	b3 2c       	mov	r11, r3
    1b6e:	c4 2c       	mov	r12, r4
    1b70:	d5 2c       	mov	r13, r5
    1b72:	e6 2c       	mov	r14, r6
    1b74:	f7 2c       	mov	r15, r7
    1b76:	08 2d       	mov	r16, r8
    1b78:	19 2d       	mov	r17, r9
    1b7a:	2a 2d       	mov	r18, r10
    1b7c:	3b 2d       	mov	r19, r11
    1b7e:	4c 2d       	mov	r20, r12
    1b80:	5d 2d       	mov	r21, r13
    1b82:	6e 2d       	mov	r22, r14
    1b84:	7f 2d       	mov	r23, r15
    1b86:	80 2f       	mov	r24, r16
    1b88:	91 2f       	mov	r25, r17
    1b8a:	0f 2e       	mov	r0, r31
    1b8c:	f3 e0       	ldi	r31, 0x03	; 3
    1b8e:	af 2e       	mov	r10, r31
    1b90:	f0 2d       	mov	r31, r0
    1b92:	bb 24       	eor	r11, r11
    1b94:	cc 24       	eor	r12, r12
    1b96:	dd 24       	eor	r13, r13
    1b98:	ee 24       	eor	r14, r14
    1b9a:	ff 24       	eor	r15, r15
    1b9c:	00 e0       	ldi	r16, 0x00	; 0
    1b9e:	10 e0       	ldi	r17, 0x00	; 0
    1ba0:	0e 94 4c 5a 	call	0xb498	; 0xb498 <__udivdi3>
    1ba4:	a2 2e       	mov	r10, r18
    1ba6:	b3 2e       	mov	r11, r19
    1ba8:	c4 2e       	mov	r12, r20
    1baa:	d5 2e       	mov	r13, r21
    1bac:	e6 2e       	mov	r14, r22
    1bae:	f7 2e       	mov	r15, r23
    1bb0:	08 2f       	mov	r16, r24
    1bb2:	19 2f       	mov	r17, r25
    1bb4:	2a 2d       	mov	r18, r10
    1bb6:	3b 2d       	mov	r19, r11
    1bb8:	4c 2d       	mov	r20, r12
    1bba:	5d 2d       	mov	r21, r13
    1bbc:	6e 2d       	mov	r22, r14
    1bbe:	7f 2d       	mov	r23, r15
    1bc0:	80 2f       	mov	r24, r16
    1bc2:	91 2f       	mov	r25, r17
    1bc4:	da 01       	movw	r26, r20
    1bc6:	c9 01       	movw	r24, r18
    1bc8:	b0 95       	com	r27
    1bca:	a0 95       	com	r26
    1bcc:	90 95       	com	r25
    1bce:	81 95       	neg	r24
    1bd0:	9f 4f       	sbci	r25, 0xFF	; 255
    1bd2:	af 4f       	sbci	r26, 0xFF	; 255
    1bd4:	bf 4f       	sbci	r27, 0xFF	; 255
    1bd6:	ea 81       	ldd	r30, Y+2	; 0x02
    1bd8:	fb 81       	ldd	r31, Y+3	; 0x03
    1bda:	80 83       	st	Z, r24
    1bdc:	91 83       	std	Z+1, r25	; 0x01
    1bde:	a2 83       	std	Z+2, r26	; 0x02
    1be0:	b3 83       	std	Z+3, r27	; 0x03

		sampleCount++;
    1be2:	80 91 75 50 	lds	r24, 0x5075
    1be6:	90 91 76 50 	lds	r25, 0x5076
    1bea:	a0 91 77 50 	lds	r26, 0x5077
    1bee:	b0 91 78 50 	lds	r27, 0x5078
    1bf2:	01 96       	adiw	r24, 0x01	; 1
    1bf4:	a1 1d       	adc	r26, r1
    1bf6:	b1 1d       	adc	r27, r1
    1bf8:	80 93 75 50 	sts	0x5075, r24
    1bfc:	90 93 76 50 	sts	0x5076, r25
    1c00:	a0 93 77 50 	sts	0x5077, r26
    1c04:	b0 93 78 50 	sts	0x5078, r27
	}
}
    1c08:	23 96       	adiw	r28, 0x03	; 3
    1c0a:	cd bf       	out	0x3d, r28	; 61
    1c0c:	de bf       	out	0x3e, r29	; 62
    1c0e:	df 91       	pop	r29
    1c10:	cf 91       	pop	r28
    1c12:	ff 91       	pop	r31
    1c14:	ef 91       	pop	r30
    1c16:	bf 91       	pop	r27
    1c18:	af 91       	pop	r26
    1c1a:	9f 91       	pop	r25
    1c1c:	8f 91       	pop	r24
    1c1e:	7f 91       	pop	r23
    1c20:	6f 91       	pop	r22
    1c22:	5f 91       	pop	r21
    1c24:	4f 91       	pop	r20
    1c26:	3f 91       	pop	r19
    1c28:	2f 91       	pop	r18
    1c2a:	1f 91       	pop	r17
    1c2c:	0f 91       	pop	r16
    1c2e:	ff 90       	pop	r15
    1c30:	ef 90       	pop	r14
    1c32:	df 90       	pop	r13
    1c34:	cf 90       	pop	r12
    1c36:	bf 90       	pop	r11
    1c38:	af 90       	pop	r10
    1c3a:	9f 90       	pop	r9
    1c3c:	8f 90       	pop	r8
    1c3e:	7f 90       	pop	r7
    1c40:	6f 90       	pop	r6
    1c42:	5f 90       	pop	r5
    1c44:	4f 90       	pop	r4
    1c46:	3f 90       	pop	r3
    1c48:	2f 90       	pop	r2
    1c4a:	0f 90       	pop	r0
    1c4c:	00 92 3b 00 	sts	0x003B, r0
    1c50:	0f 90       	pop	r0
    1c52:	0f be       	out	0x3f, r0	; 63
    1c54:	0f 90       	pop	r0
    1c56:	1f 90       	pop	r1
    1c58:	18 95       	reti

00001c5a <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
    1c5e:	0f 92       	push	r0
    1c60:	cd b7       	in	r28, 0x3d	; 61
    1c62:	de b7       	in	r29, 0x3e	; 62
    1c64:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1c66:	89 81       	ldd	r24, Y+1	; 0x01
    1c68:	88 23       	and	r24, r24
    1c6a:	49 f0       	breq	.+18     	; 0x1c7e <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1c6c:	80 e2       	ldi	r24, 0x20	; 32
    1c6e:	60 e0       	ldi	r22, 0x00	; 0
    1c70:	0e 94 a6 32 	call	0x654c	; 0x654c <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c74:	80 e2       	ldi	r24, 0x20	; 32
    1c76:	60 e0       	ldi	r22, 0x00	; 0
    1c78:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
    1c7c:	04 c0       	rjmp	.+8      	; 0x1c86 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c7e:	80 e2       	ldi	r24, 0x20	; 32
    1c80:	60 e0       	ldi	r22, 0x00	; 0
    1c82:	0e 94 0a 33 	call	0x6614	; 0x6614 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1c86:	0f 90       	pop	r0
    1c88:	df 91       	pop	r29
    1c8a:	cf 91       	pop	r28
    1c8c:	08 95       	ret

00001c8e <CO_collectSeismic3Axises>:
	
}*/

void CO_collectSeismic3Axises(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, uint32_t* DataArray) {
    1c8e:	8f 92       	push	r8
    1c90:	9f 92       	push	r9
    1c92:	af 92       	push	r10
    1c94:	bf 92       	push	r11
    1c96:	cf 92       	push	r12
    1c98:	df 92       	push	r13
    1c9a:	ef 92       	push	r14
    1c9c:	ff 92       	push	r15
    1c9e:	0f 93       	push	r16
    1ca0:	cf 93       	push	r28
    1ca2:	df 93       	push	r29
    1ca4:	cd b7       	in	r28, 0x3d	; 61
    1ca6:	de b7       	in	r29, 0x3e	; 62
    1ca8:	2e 97       	sbiw	r28, 0x0e	; 14
    1caa:	cd bf       	out	0x3d, r28	; 61
    1cac:	de bf       	out	0x3e, r29	; 62
    1cae:	89 83       	std	Y+1, r24	; 0x01
    1cb0:	6a 83       	std	Y+2, r22	; 0x02
    1cb2:	7b 83       	std	Y+3, r23	; 0x03
    1cb4:	4c 83       	std	Y+4, r20	; 0x04
    1cb6:	2d 83       	std	Y+5, r18	; 0x05
    1cb8:	0e 83       	std	Y+6, r16	; 0x06
    1cba:	ef 82       	std	Y+7, r14	; 0x07
    1cbc:	f8 86       	std	Y+8, r15	; 0x08
    1cbe:	c9 86       	std	Y+9, r12	; 0x09
    1cc0:	da 86       	std	Y+10, r13	; 0x0a
    1cc2:	ab 86       	std	Y+11, r10	; 0x0b
    1cc4:	bc 86       	std	Y+12, r11	; 0x0c
    1cc6:	8d 86       	std	Y+13, r8	; 0x0d
    1cc8:	9e 86       	std	Y+14, r9	; 0x0e
	
	ADC_BUFFER = DataArray;
    1cca:	89 a1       	lds	r24, 0x49
    1ccc:	9a a1       	lds	r25, 0x4a
    1cce:	80 93 73 50 	sts	0x5073, r24
    1cd2:	90 93 74 50 	sts	0x5074, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1cd6:	81 e0       	ldi	r24, 0x01	; 1
    1cd8:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cde:	9b 81       	ldd	r25, Y+3	; 0x03
    1ce0:	fc 01       	movw	r30, r24
    1ce2:	90 81       	ld	r25, Z
    1ce4:	85 e0       	ldi	r24, 0x05	; 5
    1ce6:	69 2f       	mov	r22, r25
    1ce8:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1cec:	8a 81       	ldd	r24, Y+2	; 0x02
    1cee:	9b 81       	ldd	r25, Y+3	; 0x03
    1cf0:	01 96       	adiw	r24, 0x01	; 1
    1cf2:	fc 01       	movw	r30, r24
    1cf4:	90 81       	ld	r25, Z
    1cf6:	86 e0       	ldi	r24, 0x06	; 6
    1cf8:	69 2f       	mov	r22, r25
    1cfa:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1cfe:	8a 81       	ldd	r24, Y+2	; 0x02
    1d00:	9b 81       	ldd	r25, Y+3	; 0x03
    1d02:	02 96       	adiw	r24, 0x02	; 2
    1d04:	fc 01       	movw	r30, r24
    1d06:	90 81       	ld	r25, Z
    1d08:	87 e0       	ldi	r24, 0x07	; 7
    1d0a:	69 2f       	mov	r22, r25
    1d0c:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_filter(filterConfig);
    1d10:	89 81       	ldd	r24, Y+1	; 0x01
    1d12:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1d16:	8e 81       	ldd	r24, Y+6	; 0x06
    1d18:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1d1c:	84 e0       	ldi	r24, 0x04	; 4
    1d1e:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1d22:	80 ec       	ldi	r24, 0xC0	; 192
    1d24:	98 e0       	ldi	r25, 0x08	; 8
    1d26:	24 e5       	ldi	r18, 0x54	; 84
    1d28:	fc 01       	movw	r30, r24
    1d2a:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1d2c:	81 e0       	ldi	r24, 0x01	; 1
    1d2e:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1d32:	85 e0       	ldi	r24, 0x05	; 5
    1d34:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1d38:	80 ea       	ldi	r24, 0xA0	; 160
    1d3a:	96 e0       	ldi	r25, 0x06	; 6
    1d3c:	22 e0       	ldi	r18, 0x02	; 2
    1d3e:	fc 01       	movw	r30, r24
    1d40:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1d42:	80 ea       	ldi	r24, 0xA0	; 160
    1d44:	96 e0       	ldi	r25, 0x06	; 6
    1d46:	21 e0       	ldi	r18, 0x01	; 1
    1d48:	fc 01       	movw	r30, r24
    1d4a:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1d4c:	80 e8       	ldi	r24, 0x80	; 128
    1d4e:	91 e0       	ldi	r25, 0x01	; 1
    1d50:	28 e7       	ldi	r18, 0x78	; 120
    1d52:	fc 01       	movw	r30, r24
    1d54:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1d56:	80 e0       	ldi	r24, 0x00	; 0
    1d58:	98 e0       	ldi	r25, 0x08	; 8
    1d5a:	20 ef       	ldi	r18, 0xF0	; 240
    1d5c:	fc 01       	movw	r30, r24
    1d5e:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1d60:	80 e0       	ldi	r24, 0x00	; 0
    1d62:	98 e0       	ldi	r25, 0x08	; 8
    1d64:	2f 81       	ldd	r18, Y+7	; 0x07
    1d66:	38 85       	ldd	r19, Y+8	; 0x08
    1d68:	fc 01       	movw	r30, r24
    1d6a:	20 a7       	lds	r18, 0x70
    1d6c:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1d6e:	80 e0       	ldi	r24, 0x00	; 0
    1d70:	98 e0       	ldi	r25, 0x08	; 8
    1d72:	29 85       	ldd	r18, Y+9	; 0x09
    1d74:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d76:	fc 01       	movw	r30, r24
    1d78:	22 a7       	lds	r18, 0x72
    1d7a:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1d7c:	80 e0       	ldi	r24, 0x00	; 0
    1d7e:	98 e0       	ldi	r25, 0x08	; 8
    1d80:	2b 85       	ldd	r18, Y+11	; 0x0b
    1d82:	3c 85       	ldd	r19, Y+12	; 0x0c
    1d84:	fc 01       	movw	r30, r24
    1d86:	24 a7       	lds	r18, 0x74
    1d88:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1d8a:	80 e0       	ldi	r24, 0x00	; 0
    1d8c:	98 e0       	ldi	r25, 0x08	; 8
    1d8e:	2d 85       	ldd	r18, Y+13	; 0x0d
    1d90:	3e 85       	ldd	r19, Y+14	; 0x0e
    1d92:	fc 01       	movw	r30, r24
    1d94:	26 a7       	lds	r18, 0x76
    1d96:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	98 e0       	ldi	r25, 0x08	; 8
    1d9c:	2d 81       	ldd	r18, Y+5	; 0x05
    1d9e:	22 2f       	mov	r18, r18
    1da0:	30 e0       	ldi	r19, 0x00	; 0
    1da2:	21 50       	subi	r18, 0x01	; 1
    1da4:	30 40       	sbci	r19, 0x00	; 0
    1da6:	fc 01       	movw	r30, r24
    1da8:	26 a3       	lds	r18, 0x56
    1daa:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1dac:	80 e0       	ldi	r24, 0x00	; 0
    1dae:	98 e0       	ldi	r25, 0x08	; 8
    1db0:	22 e0       	ldi	r18, 0x02	; 2
    1db2:	fc 01       	movw	r30, r24
    1db4:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1db6:	80 e0       	ldi	r24, 0x00	; 0
    1db8:	98 e0       	ldi	r25, 0x08	; 8
    1dba:	2f ef       	ldi	r18, 0xFF	; 255
    1dbc:	fc 01       	movw	r30, r24
    1dbe:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1dc0:	80 e0       	ldi	r24, 0x00	; 0
    1dc2:	98 e0       	ldi	r25, 0x08	; 8
    1dc4:	20 e0       	ldi	r18, 0x00	; 0
    1dc6:	38 e0       	ldi	r19, 0x08	; 8
    1dc8:	f9 01       	movw	r30, r18
    1dca:	20 81       	ld	r18, Z
    1dcc:	20 7f       	andi	r18, 0xF0	; 240
    1dce:	28 60       	ori	r18, 0x08	; 8
    1dd0:	fc 01       	movw	r30, r24
    1dd2:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    1dd4:	10 92 50 40 	sts	0x4050, r1
    1dd8:	10 92 51 40 	sts	0x4051, r1
	sampleCount = 0;
    1ddc:	10 92 75 50 	sts	0x5075, r1
    1de0:	10 92 76 50 	sts	0x5076, r1
    1de4:	10 92 77 50 	sts	0x5077, r1
    1de8:	10 92 78 50 	sts	0x5078, r1
	SPICount = 0;
    1dec:	10 92 cf 50 	sts	0x50CF, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1df0:	80 e0       	ldi	r24, 0x00	; 0
    1df2:	80 93 34 21 	sts	0x2134, r24
    1df6:	80 93 33 21 	sts	0x2133, r24
    1dfa:	80 93 32 21 	sts	0x2132, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1dfe:	80 ea       	ldi	r24, 0xA0	; 160
    1e00:	90 e0       	ldi	r25, 0x00	; 0
    1e02:	20 ea       	ldi	r18, 0xA0	; 160
    1e04:	30 e0       	ldi	r19, 0x00	; 0
    1e06:	f9 01       	movw	r30, r18
    1e08:	22 81       	ldd	r18, Z+2	; 0x02
    1e0a:	26 60       	ori	r18, 0x06	; 6
    1e0c:	fc 01       	movw	r30, r24
    1e0e:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1e10:	78 94       	sei

	SPICS(TRUE);
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1e18:	80 e8       	ldi	r24, 0x80	; 128
    1e1a:	96 e0       	ldi	r25, 0x06	; 6
    1e1c:	20 e2       	ldi	r18, 0x20	; 32
    1e1e:	fc 01       	movw	r30, r24
    1e20:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1e22:	80 e4       	ldi	r24, 0x40	; 64
    1e24:	9a e0       	ldi	r25, 0x0A	; 10
    1e26:	23 e2       	ldi	r18, 0x23	; 35
    1e28:	fc 01       	movw	r30, r24
    1e2a:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    1e2c:	80 e4       	ldi	r24, 0x40	; 64
    1e2e:	9a e0       	ldi	r25, 0x0A	; 10
    1e30:	2c 81       	ldd	r18, Y+4	; 0x04
    1e32:	42 2f       	mov	r20, r18
    1e34:	50 e0       	ldi	r21, 0x00	; 0
    1e36:	20 e2       	ldi	r18, 0x20	; 32
    1e38:	30 e0       	ldi	r19, 0x00	; 0
    1e3a:	02 c0       	rjmp	.+4      	; 0x1e40 <CO_collectSeismic3Axises+0x1b2>
    1e3c:	22 0f       	add	r18, r18
    1e3e:	33 1f       	adc	r19, r19
    1e40:	4a 95       	dec	r20
    1e42:	e2 f7       	brpl	.-8      	; 0x1e3c <CO_collectSeismic3Axises+0x1ae>
    1e44:	fc 01       	movw	r30, r24
    1e46:	26 a3       	lds	r18, 0x56
    1e48:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    1e4a:	80 e4       	ldi	r24, 0x40	; 64
    1e4c:	9a e0       	ldi	r25, 0x0A	; 10
    1e4e:	2c 81       	ldd	r18, Y+4	; 0x04
    1e50:	42 2f       	mov	r20, r18
    1e52:	50 e0       	ldi	r21, 0x00	; 0
    1e54:	20 e1       	ldi	r18, 0x10	; 16
    1e56:	30 e0       	ldi	r19, 0x00	; 0
    1e58:	02 c0       	rjmp	.+4      	; 0x1e5e <CO_collectSeismic3Axises+0x1d0>
    1e5a:	22 0f       	add	r18, r18
    1e5c:	33 1f       	adc	r19, r19
    1e5e:	4a 95       	dec	r20
    1e60:	e2 f7       	brpl	.-8      	; 0x1e5a <CO_collectSeismic3Axises+0x1cc>
    1e62:	fc 01       	movw	r30, r24
    1e64:	22 af       	sts	0x72, r18
    1e66:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1e68:	80 e4       	ldi	r24, 0x40	; 64
    1e6a:	9a e0       	ldi	r25, 0x0A	; 10
    1e6c:	20 e4       	ldi	r18, 0x40	; 64
    1e6e:	3a e0       	ldi	r19, 0x0A	; 10
    1e70:	f9 01       	movw	r30, r18
    1e72:	20 81       	ld	r18, Z
    1e74:	20 7f       	andi	r18, 0xF0	; 240
    1e76:	21 60       	ori	r18, 0x01	; 1
    1e78:	fc 01       	movw	r30, r24
    1e7a:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    1e7c:	00 00       	nop
    1e7e:	20 91 75 50 	lds	r18, 0x5075
    1e82:	30 91 76 50 	lds	r19, 0x5076
    1e86:	40 91 77 50 	lds	r20, 0x5077
    1e8a:	50 91 78 50 	lds	r21, 0x5078
    1e8e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e90:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1e92:	af 8d       	ldd	r26, Y+31	; 0x1f
    1e94:	b8 a1       	lds	r27, 0x48
    1e96:	28 17       	cp	r18, r24
    1e98:	39 07       	cpc	r19, r25
    1e9a:	4a 07       	cpc	r20, r26
    1e9c:	5b 07       	cpc	r21, r27
    1e9e:	78 f3       	brcs	.-34     	; 0x1e7e <CO_collectSeismic3Axises+0x1f0>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1ea0:	80 e0       	ldi	r24, 0x00	; 0
    1ea2:	98 e0       	ldi	r25, 0x08	; 8
    1ea4:	20 e0       	ldi	r18, 0x00	; 0
    1ea6:	38 e0       	ldi	r19, 0x08	; 8
    1ea8:	f9 01       	movw	r30, r18
    1eaa:	20 81       	ld	r18, Z
    1eac:	20 7f       	andi	r18, 0xF0	; 240
    1eae:	fc 01       	movw	r30, r24
    1eb0:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1eb2:	80 e4       	ldi	r24, 0x40	; 64
    1eb4:	9a e0       	ldi	r25, 0x0A	; 10
    1eb6:	20 e4       	ldi	r18, 0x40	; 64
    1eb8:	3a e0       	ldi	r19, 0x0A	; 10
    1eba:	f9 01       	movw	r30, r18
    1ebc:	20 81       	ld	r18, Z
    1ebe:	20 7f       	andi	r18, 0xF0	; 240
    1ec0:	fc 01       	movw	r30, r24
    1ec2:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1ec4:	80 ea       	ldi	r24, 0xA0	; 160
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	20 ea       	ldi	r18, 0xA0	; 160
    1eca:	30 e0       	ldi	r19, 0x00	; 0
    1ecc:	f9 01       	movw	r30, r18
    1ece:	22 81       	ldd	r18, Z+2	; 0x02
    1ed0:	29 7f       	andi	r18, 0xF9	; 249
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1ed6:	f8 94       	cli

	SPICS(FALSE);
    1ed8:	80 e0       	ldi	r24, 0x00	; 0
    1eda:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    1ede:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	enableADCMUX(FALSE);
    1ee2:	80 e0       	ldi	r24, 0x00	; 0
    1ee4:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	ADCPower(FALSE);
    1ee8:	80 e0       	ldi	r24, 0x00	; 0
    1eea:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
}
    1eee:	2e 96       	adiw	r28, 0x0e	; 14
    1ef0:	cd bf       	out	0x3d, r28	; 61
    1ef2:	de bf       	out	0x3e, r29	; 62
    1ef4:	df 91       	pop	r29
    1ef6:	cf 91       	pop	r28
    1ef8:	0f 91       	pop	r16
    1efa:	ff 90       	pop	r15
    1efc:	ef 90       	pop	r14
    1efe:	df 90       	pop	r13
    1f00:	cf 90       	pop	r12
    1f02:	bf 90       	pop	r11
    1f04:	af 90       	pop	r10
    1f06:	9f 90       	pop	r9
    1f08:	8f 90       	pop	r8
    1f0a:	08 95       	ret

00001f0c <__vector_16>:

//first averaging point
ISR(TCC0_CCA_vect) {
    1f0c:	1f 92       	push	r1
    1f0e:	0f 92       	push	r0
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	0f 92       	push	r0
    1f14:	00 90 3b 00 	lds	r0, 0x003B
    1f18:	0f 92       	push	r0
    1f1a:	11 24       	eor	r1, r1
    1f1c:	2f 93       	push	r18
    1f1e:	3f 93       	push	r19
    1f20:	4f 93       	push	r20
    1f22:	5f 93       	push	r21
    1f24:	6f 93       	push	r22
    1f26:	7f 93       	push	r23
    1f28:	8f 93       	push	r24
    1f2a:	9f 93       	push	r25
    1f2c:	af 93       	push	r26
    1f2e:	bf 93       	push	r27
    1f30:	ef 93       	push	r30
    1f32:	ff 93       	push	r31
    1f34:	cf 93       	push	r28
    1f36:	df 93       	push	r29
    1f38:	cd b7       	in	r28, 0x3d	; 61
    1f3a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f3c:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
}
    1f40:	df 91       	pop	r29
    1f42:	cf 91       	pop	r28
    1f44:	ff 91       	pop	r31
    1f46:	ef 91       	pop	r30
    1f48:	bf 91       	pop	r27
    1f4a:	af 91       	pop	r26
    1f4c:	9f 91       	pop	r25
    1f4e:	8f 91       	pop	r24
    1f50:	7f 91       	pop	r23
    1f52:	6f 91       	pop	r22
    1f54:	5f 91       	pop	r21
    1f56:	4f 91       	pop	r20
    1f58:	3f 91       	pop	r19
    1f5a:	2f 91       	pop	r18
    1f5c:	0f 90       	pop	r0
    1f5e:	00 92 3b 00 	sts	0x003B, r0
    1f62:	0f 90       	pop	r0
    1f64:	0f be       	out	0x3f, r0	; 63
    1f66:	0f 90       	pop	r0
    1f68:	1f 90       	pop	r1
    1f6a:	18 95       	reti

00001f6c <__vector_17>:

//second averaging point
ISR(TCC0_CCB_vect) {
    1f6c:	1f 92       	push	r1
    1f6e:	0f 92       	push	r0
    1f70:	0f b6       	in	r0, 0x3f	; 63
    1f72:	0f 92       	push	r0
    1f74:	00 90 3b 00 	lds	r0, 0x003B
    1f78:	0f 92       	push	r0
    1f7a:	11 24       	eor	r1, r1
    1f7c:	2f 93       	push	r18
    1f7e:	3f 93       	push	r19
    1f80:	4f 93       	push	r20
    1f82:	5f 93       	push	r21
    1f84:	6f 93       	push	r22
    1f86:	7f 93       	push	r23
    1f88:	8f 93       	push	r24
    1f8a:	9f 93       	push	r25
    1f8c:	af 93       	push	r26
    1f8e:	bf 93       	push	r27
    1f90:	ef 93       	push	r30
    1f92:	ff 93       	push	r31
    1f94:	cf 93       	push	r28
    1f96:	df 93       	push	r29
    1f98:	cd b7       	in	r28, 0x3d	; 61
    1f9a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f9c:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
}
    1fa0:	df 91       	pop	r29
    1fa2:	cf 91       	pop	r28
    1fa4:	ff 91       	pop	r31
    1fa6:	ef 91       	pop	r30
    1fa8:	bf 91       	pop	r27
    1faa:	af 91       	pop	r26
    1fac:	9f 91       	pop	r25
    1fae:	8f 91       	pop	r24
    1fb0:	7f 91       	pop	r23
    1fb2:	6f 91       	pop	r22
    1fb4:	5f 91       	pop	r21
    1fb6:	4f 91       	pop	r20
    1fb8:	3f 91       	pop	r19
    1fba:	2f 91       	pop	r18
    1fbc:	0f 90       	pop	r0
    1fbe:	00 92 3b 00 	sts	0x003B, r0
    1fc2:	0f 90       	pop	r0
    1fc4:	0f be       	out	0x3f, r0	; 63
    1fc6:	0f 90       	pop	r0
    1fc8:	1f 90       	pop	r1
    1fca:	18 95       	reti

00001fcc <__vector_18>:

//third averaging point
ISR(TCC0_CCC_vect) {
    1fcc:	1f 92       	push	r1
    1fce:	0f 92       	push	r0
    1fd0:	0f b6       	in	r0, 0x3f	; 63
    1fd2:	0f 92       	push	r0
    1fd4:	00 90 3b 00 	lds	r0, 0x003B
    1fd8:	0f 92       	push	r0
    1fda:	11 24       	eor	r1, r1
    1fdc:	2f 93       	push	r18
    1fde:	3f 93       	push	r19
    1fe0:	4f 93       	push	r20
    1fe2:	5f 93       	push	r21
    1fe4:	6f 93       	push	r22
    1fe6:	7f 93       	push	r23
    1fe8:	8f 93       	push	r24
    1fea:	9f 93       	push	r25
    1fec:	af 93       	push	r26
    1fee:	bf 93       	push	r27
    1ff0:	ef 93       	push	r30
    1ff2:	ff 93       	push	r31
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
    1ff8:	cd b7       	in	r28, 0x3d	; 61
    1ffa:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1ffc:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
}
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	ff 91       	pop	r31
    2006:	ef 91       	pop	r30
    2008:	bf 91       	pop	r27
    200a:	af 91       	pop	r26
    200c:	9f 91       	pop	r25
    200e:	8f 91       	pop	r24
    2010:	7f 91       	pop	r23
    2012:	6f 91       	pop	r22
    2014:	5f 91       	pop	r21
    2016:	4f 91       	pop	r20
    2018:	3f 91       	pop	r19
    201a:	2f 91       	pop	r18
    201c:	0f 90       	pop	r0
    201e:	00 92 3b 00 	sts	0x003B, r0
    2022:	0f 90       	pop	r0
    2024:	0f be       	out	0x3f, r0	; 63
    2026:	0f 90       	pop	r0
    2028:	1f 90       	pop	r1
    202a:	18 95       	reti

0000202c <__vector_19>:

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    202c:	1f 92       	push	r1
    202e:	0f 92       	push	r0
    2030:	0f b6       	in	r0, 0x3f	; 63
    2032:	0f 92       	push	r0
    2034:	00 90 3b 00 	lds	r0, 0x003B
    2038:	0f 92       	push	r0
    203a:	11 24       	eor	r1, r1
    203c:	2f 93       	push	r18
    203e:	3f 93       	push	r19
    2040:	4f 93       	push	r20
    2042:	5f 93       	push	r21
    2044:	6f 93       	push	r22
    2046:	7f 93       	push	r23
    2048:	8f 93       	push	r24
    204a:	9f 93       	push	r25
    204c:	af 93       	push	r26
    204e:	bf 93       	push	r27
    2050:	ef 93       	push	r30
    2052:	ff 93       	push	r31
    2054:	cf 93       	push	r28
    2056:	df 93       	push	r29
    2058:	cd b7       	in	r28, 0x3d	; 61
    205a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    205c:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
	SPICount = 0;
    2060:	10 92 cf 50 	sts	0x50CF, r1
	if(PORTB.OUT & PIN1_bm) {
    2064:	80 e2       	ldi	r24, 0x20	; 32
    2066:	96 e0       	ldi	r25, 0x06	; 6
    2068:	fc 01       	movw	r30, r24
    206a:	84 81       	ldd	r24, Z+4	; 0x04
    206c:	88 2f       	mov	r24, r24
    206e:	90 e0       	ldi	r25, 0x00	; 0
    2070:	82 70       	andi	r24, 0x02	; 2
    2072:	90 70       	andi	r25, 0x00	; 0
    2074:	00 97       	sbiw	r24, 0x00	; 0
    2076:	b1 f0       	breq	.+44     	; 0x20a4 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2078:	80 e0       	ldi	r24, 0x00	; 0
    207a:	96 e0       	ldi	r25, 0x06	; 6
    207c:	fc 01       	movw	r30, r24
    207e:	84 81       	ldd	r24, Z+4	; 0x04
    2080:	88 2f       	mov	r24, r24
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	80 74       	andi	r24, 0x40	; 64
    2086:	90 70       	andi	r25, 0x00	; 0
    2088:	00 97       	sbiw	r24, 0x00	; 0
    208a:	31 f0       	breq	.+12     	; 0x2098 <__vector_19+0x6c>
    208c:	80 e2       	ldi	r24, 0x20	; 32
    208e:	96 e0       	ldi	r25, 0x06	; 6
    2090:	22 e0       	ldi	r18, 0x02	; 2
    2092:	fc 01       	movw	r30, r24
    2094:	27 83       	std	Z+7, r18	; 0x07
    2096:	10 c0       	rjmp	.+32     	; 0x20b8 <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    2098:	80 e0       	ldi	r24, 0x00	; 0
    209a:	96 e0       	ldi	r25, 0x06	; 6
    209c:	20 e4       	ldi	r18, 0x40	; 64
    209e:	fc 01       	movw	r30, r24
    20a0:	27 83       	std	Z+7, r18	; 0x07
    20a2:	0a c0       	rjmp	.+20     	; 0x20b8 <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    20a4:	80 e0       	ldi	r24, 0x00	; 0
    20a6:	96 e0       	ldi	r25, 0x06	; 6
    20a8:	20 e4       	ldi	r18, 0x40	; 64
    20aa:	fc 01       	movw	r30, r24
    20ac:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    20ae:	80 e2       	ldi	r24, 0x20	; 32
    20b0:	96 e0       	ldi	r25, 0x06	; 6
    20b2:	22 e0       	ldi	r18, 0x02	; 2
    20b4:	fc 01       	movw	r30, r24
    20b6:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    20b8:	df 91       	pop	r29
    20ba:	cf 91       	pop	r28
    20bc:	ff 91       	pop	r31
    20be:	ef 91       	pop	r30
    20c0:	bf 91       	pop	r27
    20c2:	af 91       	pop	r26
    20c4:	9f 91       	pop	r25
    20c6:	8f 91       	pop	r24
    20c8:	7f 91       	pop	r23
    20ca:	6f 91       	pop	r22
    20cc:	5f 91       	pop	r21
    20ce:	4f 91       	pop	r20
    20d0:	3f 91       	pop	r19
    20d2:	2f 91       	pop	r18
    20d4:	0f 90       	pop	r0
    20d6:	00 92 3b 00 	sts	0x003B, r0
    20da:	0f 90       	pop	r0
    20dc:	0f be       	out	0x3f, r0	; 63
    20de:	0f 90       	pop	r0
    20e0:	1f 90       	pop	r1
    20e2:	18 95       	reti

000020e4 <__vector_14>:

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    20e4:	1f 92       	push	r1
    20e6:	0f 92       	push	r0
    20e8:	0f b6       	in	r0, 0x3f	; 63
    20ea:	0f 92       	push	r0
    20ec:	00 90 3b 00 	lds	r0, 0x003B
    20f0:	0f 92       	push	r0
    20f2:	11 24       	eor	r1, r1
    20f4:	2f 93       	push	r18
    20f6:	3f 93       	push	r19
    20f8:	4f 93       	push	r20
    20fa:	5f 93       	push	r21
    20fc:	6f 93       	push	r22
    20fe:	7f 93       	push	r23
    2100:	8f 93       	push	r24
    2102:	9f 93       	push	r25
    2104:	af 93       	push	r26
    2106:	bf 93       	push	r27
    2108:	ef 93       	push	r30
    210a:	ff 93       	push	r31
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
    2110:	cd b7       	in	r28, 0x3d	; 61
    2112:	de b7       	in	r29, 0x3e	; 62
    2114:	29 97       	sbiw	r28, 0x09	; 9
    2116:	cd bf       	out	0x3d, r28	; 61
    2118:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    211a:	1a 82       	std	Y+2, r1	; 0x02
    211c:	1b 82       	std	Y+3, r1	; 0x03
    211e:	1c 82       	std	Y+4, r1	; 0x04
    2120:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2122:	19 82       	std	Y+1, r1	; 0x01
    2124:	4f c0       	rjmp	.+158    	; 0x21c4 <__vector_14+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2126:	89 81       	ldd	r24, Y+1	; 0x01
    2128:	88 2f       	mov	r24, r24
    212a:	90 e0       	ldi	r25, 0x00	; 0
    212c:	8a 59       	subi	r24, 0x9A	; 154
    212e:	9f 4a       	sbci	r25, 0xAF	; 175
    2130:	fc 01       	movw	r30, r24
    2132:	80 81       	ld	r24, Z
    2134:	88 23       	and	r24, r24
    2136:	3c f4       	brge	.+14     	; 0x2146 <__vector_14+0x62>
    2138:	ce 01       	movw	r24, r28
    213a:	06 96       	adiw	r24, 0x06	; 6
    213c:	03 96       	adiw	r24, 0x03	; 3
    213e:	2f ef       	ldi	r18, 0xFF	; 255
    2140:	fc 01       	movw	r30, r24
    2142:	20 83       	st	Z, r18
    2144:	05 c0       	rjmp	.+10     	; 0x2150 <__vector_14+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2146:	ce 01       	movw	r24, r28
    2148:	06 96       	adiw	r24, 0x06	; 6
    214a:	03 96       	adiw	r24, 0x03	; 3
    214c:	fc 01       	movw	r30, r24
    214e:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2150:	ce 01       	movw	r24, r28
    2152:	06 96       	adiw	r24, 0x06	; 6
    2154:	02 96       	adiw	r24, 0x02	; 2
    2156:	29 81       	ldd	r18, Y+1	; 0x01
    2158:	22 2f       	mov	r18, r18
    215a:	30 e0       	ldi	r19, 0x00	; 0
    215c:	2a 59       	subi	r18, 0x9A	; 154
    215e:	3f 4a       	sbci	r19, 0xAF	; 175
    2160:	f9 01       	movw	r30, r18
    2162:	20 81       	ld	r18, Z
    2164:	fc 01       	movw	r30, r24
    2166:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2168:	ce 01       	movw	r24, r28
    216a:	06 96       	adiw	r24, 0x06	; 6
    216c:	01 96       	adiw	r24, 0x01	; 1
    216e:	29 81       	ldd	r18, Y+1	; 0x01
    2170:	22 2f       	mov	r18, r18
    2172:	30 e0       	ldi	r19, 0x00	; 0
    2174:	2f 5f       	subi	r18, 0xFF	; 255
    2176:	3f 4f       	sbci	r19, 0xFF	; 255
    2178:	2a 59       	subi	r18, 0x9A	; 154
    217a:	3f 4a       	sbci	r19, 0xAF	; 175
    217c:	f9 01       	movw	r30, r18
    217e:	20 81       	ld	r18, Z
    2180:	fc 01       	movw	r30, r24
    2182:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2184:	ce 01       	movw	r24, r28
    2186:	06 96       	adiw	r24, 0x06	; 6
    2188:	29 81       	ldd	r18, Y+1	; 0x01
    218a:	22 2f       	mov	r18, r18
    218c:	30 e0       	ldi	r19, 0x00	; 0
    218e:	2e 5f       	subi	r18, 0xFE	; 254
    2190:	3f 4f       	sbci	r19, 0xFF	; 255
    2192:	2a 59       	subi	r18, 0x9A	; 154
    2194:	3f 4a       	sbci	r19, 0xAF	; 175
    2196:	f9 01       	movw	r30, r18
    2198:	20 81       	ld	r18, Z
    219a:	fc 01       	movw	r30, r24
    219c:	20 83       	st	Z, r18
		sum += currentSample;
    219e:	2a 81       	ldd	r18, Y+2	; 0x02
    21a0:	3b 81       	ldd	r19, Y+3	; 0x03
    21a2:	4c 81       	ldd	r20, Y+4	; 0x04
    21a4:	5d 81       	ldd	r21, Y+5	; 0x05
    21a6:	8e 81       	ldd	r24, Y+6	; 0x06
    21a8:	9f 81       	ldd	r25, Y+7	; 0x07
    21aa:	a8 85       	ldd	r26, Y+8	; 0x08
    21ac:	b9 85       	ldd	r27, Y+9	; 0x09
    21ae:	82 0f       	add	r24, r18
    21b0:	93 1f       	adc	r25, r19
    21b2:	a4 1f       	adc	r26, r20
    21b4:	b5 1f       	adc	r27, r21
    21b6:	8a 83       	std	Y+2, r24	; 0x02
    21b8:	9b 83       	std	Y+3, r25	; 0x03
    21ba:	ac 83       	std	Y+4, r26	; 0x04
    21bc:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    21be:	89 81       	ldd	r24, Y+1	; 0x01
    21c0:	8d 5f       	subi	r24, 0xFD	; 253
    21c2:	89 83       	std	Y+1, r24	; 0x01
    21c4:	89 81       	ldd	r24, Y+1	; 0x01
    21c6:	8c 30       	cpi	r24, 0x0C	; 12
    21c8:	08 f4       	brcc	.+2      	; 0x21cc <__vector_14+0xe8>
    21ca:	ad cf       	rjmp	.-166    	; 0x2126 <__vector_14+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    21cc:	8a 81       	ldd	r24, Y+2	; 0x02
    21ce:	9b 81       	ldd	r25, Y+3	; 0x03
    21d0:	ac 81       	ldd	r26, Y+4	; 0x04
    21d2:	bd 81       	ldd	r27, Y+5	; 0x05
    21d4:	24 e0       	ldi	r18, 0x04	; 4
    21d6:	30 e0       	ldi	r19, 0x00	; 0
    21d8:	40 e0       	ldi	r20, 0x00	; 0
    21da:	50 e0       	ldi	r21, 0x00	; 0
    21dc:	bc 01       	movw	r22, r24
    21de:	cd 01       	movw	r24, r26
    21e0:	0e 94 6d 62 	call	0xc4da	; 0xc4da <__divmodsi4>
    21e4:	da 01       	movw	r26, r20
    21e6:	c9 01       	movw	r24, r18
    21e8:	8a 83       	std	Y+2, r24	; 0x02
    21ea:	9b 83       	std	Y+3, r25	; 0x03
    21ec:	ac 83       	std	Y+4, r26	; 0x04
    21ee:	bd 83       	std	Y+5, r27	; 0x05
	ADC_BUFFER[sampleCount] = currentSample;
    21f0:	20 91 73 50 	lds	r18, 0x5073
    21f4:	30 91 74 50 	lds	r19, 0x5074
    21f8:	80 91 75 50 	lds	r24, 0x5075
    21fc:	90 91 76 50 	lds	r25, 0x5076
    2200:	a0 91 77 50 	lds	r26, 0x5077
    2204:	b0 91 78 50 	lds	r27, 0x5078
    2208:	88 0f       	add	r24, r24
    220a:	99 1f       	adc	r25, r25
    220c:	88 0f       	add	r24, r24
    220e:	99 1f       	adc	r25, r25
    2210:	28 0f       	add	r18, r24
    2212:	39 1f       	adc	r19, r25
    2214:	8e 81       	ldd	r24, Y+6	; 0x06
    2216:	9f 81       	ldd	r25, Y+7	; 0x07
    2218:	a8 85       	ldd	r26, Y+8	; 0x08
    221a:	b9 85       	ldd	r27, Y+9	; 0x09
    221c:	f9 01       	movw	r30, r18
    221e:	80 83       	st	Z, r24
    2220:	91 83       	std	Z+1, r25	; 0x01
    2222:	a2 83       	std	Z+2, r26	; 0x02
    2224:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    2226:	80 91 75 50 	lds	r24, 0x5075
    222a:	90 91 76 50 	lds	r25, 0x5076
    222e:	a0 91 77 50 	lds	r26, 0x5077
    2232:	b0 91 78 50 	lds	r27, 0x5078
    2236:	01 96       	adiw	r24, 0x01	; 1
    2238:	a1 1d       	adc	r26, r1
    223a:	b1 1d       	adc	r27, r1
    223c:	80 93 75 50 	sts	0x5075, r24
    2240:	90 93 76 50 	sts	0x5076, r25
    2244:	a0 93 77 50 	sts	0x5077, r26
    2248:	b0 93 78 50 	sts	0x5078, r27

}
    224c:	29 96       	adiw	r28, 0x09	; 9
    224e:	cd bf       	out	0x3d, r28	; 61
    2250:	de bf       	out	0x3e, r29	; 62
    2252:	df 91       	pop	r29
    2254:	cf 91       	pop	r28
    2256:	ff 91       	pop	r31
    2258:	ef 91       	pop	r30
    225a:	bf 91       	pop	r27
    225c:	af 91       	pop	r26
    225e:	9f 91       	pop	r25
    2260:	8f 91       	pop	r24
    2262:	7f 91       	pop	r23
    2264:	6f 91       	pop	r22
    2266:	5f 91       	pop	r21
    2268:	4f 91       	pop	r20
    226a:	3f 91       	pop	r19
    226c:	2f 91       	pop	r18
    226e:	0f 90       	pop	r0
    2270:	00 92 3b 00 	sts	0x003B, r0
    2274:	0f 90       	pop	r0
    2276:	0f be       	out	0x3f, r0	; 63
    2278:	0f 90       	pop	r0
    227a:	1f 90       	pop	r1
    227c:	18 95       	reti

0000227e <CO_collectSeismic1Channel>:

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    227e:	8f 92       	push	r8
    2280:	9f 92       	push	r9
    2282:	af 92       	push	r10
    2284:	bf 92       	push	r11
    2286:	cf 92       	push	r12
    2288:	df 92       	push	r13
    228a:	ef 92       	push	r14
    228c:	0f 93       	push	r16
    228e:	cf 93       	push	r28
    2290:	df 93       	push	r29
    2292:	cd b7       	in	r28, 0x3d	; 61
    2294:	de b7       	in	r29, 0x3e	; 62
    2296:	2c 97       	sbiw	r28, 0x0c	; 12
    2298:	cd bf       	out	0x3d, r28	; 61
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	89 83       	std	Y+1, r24	; 0x01
    229e:	6a 83       	std	Y+2, r22	; 0x02
    22a0:	4b 83       	std	Y+3, r20	; 0x03
    22a2:	2c 83       	std	Y+4, r18	; 0x04
    22a4:	0d 83       	std	Y+5, r16	; 0x05
    22a6:	ee 82       	std	Y+6, r14	; 0x06
    22a8:	cf 82       	std	Y+7, r12	; 0x07
    22aa:	d8 86       	std	Y+8, r13	; 0x08
    22ac:	a9 86       	std	Y+9, r10	; 0x09
    22ae:	ba 86       	std	Y+10, r11	; 0x0a
    22b0:	8b 86       	std	Y+11, r8	; 0x0b
    22b2:	9c 86       	std	Y+12, r9	; 0x0c
	
	uint16_t period;
	ADC_BUFFER=DataArray;
    22b4:	88 a1       	lds	r24, 0x48
    22b6:	99 a1       	lds	r25, 0x49
    22b8:	80 93 73 50 	sts	0x5073, r24
    22bc:	90 93 74 50 	sts	0x5074, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    22c0:	81 e0       	ldi	r24, 0x01	; 1
    22c2:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    22c6:	89 81       	ldd	r24, Y+1	; 0x01
    22c8:	6b 81       	ldd	r22, Y+3	; 0x03
    22ca:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_filter(filterConfig);
    22ce:	8a 81       	ldd	r24, Y+2	; 0x02
    22d0:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    22d4:	8e 81       	ldd	r24, Y+6	; 0x06
    22d6:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    22da:	84 e0       	ldi	r24, 0x04	; 4
    22dc:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    22e0:	80 ec       	ldi	r24, 0xC0	; 192
    22e2:	98 e0       	ldi	r25, 0x08	; 8
    22e4:	24 e5       	ldi	r18, 0x54	; 84
    22e6:	fc 01       	movw	r30, r24
    22e8:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    22ea:	81 e0       	ldi	r24, 0x01	; 1
    22ec:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	setADCInput(channel);
    22f0:	89 81       	ldd	r24, Y+1	; 0x01
    22f2:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    22f6:	80 ea       	ldi	r24, 0xA0	; 160
    22f8:	96 e0       	ldi	r25, 0x06	; 6
    22fa:	22 e0       	ldi	r18, 0x02	; 2
    22fc:	fc 01       	movw	r30, r24
    22fe:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2300:	80 ea       	ldi	r24, 0xA0	; 160
    2302:	96 e0       	ldi	r25, 0x06	; 6
    2304:	21 e0       	ldi	r18, 0x01	; 1
    2306:	fc 01       	movw	r30, r24
    2308:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    230a:	80 e8       	ldi	r24, 0x80	; 128
    230c:	91 e0       	ldi	r25, 0x01	; 1
    230e:	28 e7       	ldi	r18, 0x78	; 120
    2310:	fc 01       	movw	r30, r24
    2312:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2314:	80 e0       	ldi	r24, 0x00	; 0
    2316:	99 e0       	ldi	r25, 0x09	; 9
    2318:	20 ef       	ldi	r18, 0xF0	; 240
    231a:	fc 01       	movw	r30, r24
    231c:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    231e:	80 e0       	ldi	r24, 0x00	; 0
    2320:	99 e0       	ldi	r25, 0x09	; 9
    2322:	2f 81       	ldd	r18, Y+7	; 0x07
    2324:	38 85       	ldd	r19, Y+8	; 0x08
    2326:	fc 01       	movw	r30, r24
    2328:	20 a7       	lds	r18, 0x70
    232a:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    232c:	80 e0       	ldi	r24, 0x00	; 0
    232e:	99 e0       	ldi	r25, 0x09	; 9
    2330:	29 85       	ldd	r18, Y+9	; 0x09
    2332:	3a 85       	ldd	r19, Y+10	; 0x0a
    2334:	fc 01       	movw	r30, r24
    2336:	22 a7       	lds	r18, 0x72
    2338:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    233a:	80 e0       	ldi	r24, 0x00	; 0
    233c:	99 e0       	ldi	r25, 0x09	; 9
    233e:	2b 85       	ldd	r18, Y+11	; 0x0b
    2340:	3c 85       	ldd	r19, Y+12	; 0x0c
    2342:	fc 01       	movw	r30, r24
    2344:	24 a7       	lds	r18, 0x74
    2346:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    2348:	80 e0       	ldi	r24, 0x00	; 0
    234a:	99 e0       	ldi	r25, 0x09	; 9
    234c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    234e:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2350:	fc 01       	movw	r30, r24
    2352:	26 a7       	lds	r18, 0x76
    2354:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2356:	80 e0       	ldi	r24, 0x00	; 0
    2358:	99 e0       	ldi	r25, 0x09	; 9
    235a:	2d 81       	ldd	r18, Y+5	; 0x05
    235c:	22 2f       	mov	r18, r18
    235e:	30 e0       	ldi	r19, 0x00	; 0
    2360:	21 50       	subi	r18, 0x01	; 1
    2362:	30 40       	sbci	r19, 0x00	; 0
    2364:	fc 01       	movw	r30, r24
    2366:	26 a3       	lds	r18, 0x56
    2368:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    236a:	80 e0       	ldi	r24, 0x00	; 0
    236c:	99 e0       	ldi	r25, 0x09	; 9
    236e:	22 e0       	ldi	r18, 0x02	; 2
    2370:	fc 01       	movw	r30, r24
    2372:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2374:	80 e0       	ldi	r24, 0x00	; 0
    2376:	99 e0       	ldi	r25, 0x09	; 9
    2378:	2f ef       	ldi	r18, 0xFF	; 255
    237a:	fc 01       	movw	r30, r24
    237c:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    237e:	80 e0       	ldi	r24, 0x00	; 0
    2380:	99 e0       	ldi	r25, 0x09	; 9
    2382:	20 e0       	ldi	r18, 0x00	; 0
    2384:	39 e0       	ldi	r19, 0x09	; 9
    2386:	f9 01       	movw	r30, r18
    2388:	20 81       	ld	r18, Z
    238a:	20 7f       	andi	r18, 0xF0	; 240
    238c:	28 60       	ori	r18, 0x08	; 8
    238e:	fc 01       	movw	r30, r24
    2390:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2392:	10 92 75 50 	sts	0x5075, r1
    2396:	10 92 76 50 	sts	0x5076, r1
    239a:	10 92 77 50 	sts	0x5077, r1
    239e:	10 92 78 50 	sts	0x5078, r1
	SPICount = 0;
    23a2:	10 92 cf 50 	sts	0x50CF, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    23a6:	80 ea       	ldi	r24, 0xA0	; 160
    23a8:	90 e0       	ldi	r25, 0x00	; 0
    23aa:	20 ea       	ldi	r18, 0xA0	; 160
    23ac:	30 e0       	ldi	r19, 0x00	; 0
    23ae:	f9 01       	movw	r30, r18
    23b0:	22 81       	ldd	r18, Z+2	; 0x02
    23b2:	26 60       	ori	r18, 0x06	; 6
    23b4:	fc 01       	movw	r30, r24
    23b6:	22 83       	std	Z+2, r18	; 0x02
	sei();
    23b8:	78 94       	sei

	SPICS(TRUE);
    23ba:	81 e0       	ldi	r24, 0x01	; 1
    23bc:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    23c0:	80 e8       	ldi	r24, 0x80	; 128
    23c2:	96 e0       	ldi	r25, 0x06	; 6
    23c4:	20 e2       	ldi	r18, 0x20	; 32
    23c6:	fc 01       	movw	r30, r24
    23c8:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    23ca:	80 e4       	ldi	r24, 0x40	; 64
    23cc:	9a e0       	ldi	r25, 0x0A	; 10
    23ce:	23 e2       	ldi	r18, 0x23	; 35
    23d0:	fc 01       	movw	r30, r24
    23d2:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    23d4:	80 e4       	ldi	r24, 0x40	; 64
    23d6:	9a e0       	ldi	r25, 0x0A	; 10
    23d8:	2c 81       	ldd	r18, Y+4	; 0x04
    23da:	42 2f       	mov	r20, r18
    23dc:	50 e0       	ldi	r21, 0x00	; 0
    23de:	20 e2       	ldi	r18, 0x20	; 32
    23e0:	30 e0       	ldi	r19, 0x00	; 0
    23e2:	02 c0       	rjmp	.+4      	; 0x23e8 <CO_collectSeismic1Channel+0x16a>
    23e4:	22 0f       	add	r18, r18
    23e6:	33 1f       	adc	r19, r19
    23e8:	4a 95       	dec	r20
    23ea:	e2 f7       	brpl	.-8      	; 0x23e4 <CO_collectSeismic1Channel+0x166>
    23ec:	fc 01       	movw	r30, r24
    23ee:	26 a3       	lds	r18, 0x56
    23f0:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    23f2:	80 e4       	ldi	r24, 0x40	; 64
    23f4:	9a e0       	ldi	r25, 0x0A	; 10
    23f6:	2c 81       	ldd	r18, Y+4	; 0x04
    23f8:	42 2f       	mov	r20, r18
    23fa:	50 e0       	ldi	r21, 0x00	; 0
    23fc:	20 e1       	ldi	r18, 0x10	; 16
    23fe:	30 e0       	ldi	r19, 0x00	; 0
    2400:	02 c0       	rjmp	.+4      	; 0x2406 <CO_collectSeismic1Channel+0x188>
    2402:	22 0f       	add	r18, r18
    2404:	33 1f       	adc	r19, r19
    2406:	4a 95       	dec	r20
    2408:	e2 f7       	brpl	.-8      	; 0x2402 <CO_collectSeismic1Channel+0x184>
    240a:	fc 01       	movw	r30, r24
    240c:	22 af       	sts	0x72, r18
    240e:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2410:	80 e4       	ldi	r24, 0x40	; 64
    2412:	9a e0       	ldi	r25, 0x0A	; 10
    2414:	20 e4       	ldi	r18, 0x40	; 64
    2416:	3a e0       	ldi	r19, 0x0A	; 10
    2418:	f9 01       	movw	r30, r18
    241a:	20 81       	ld	r18, Z
    241c:	20 7f       	andi	r18, 0xF0	; 240
    241e:	21 60       	ori	r18, 0x01	; 1
    2420:	fc 01       	movw	r30, r24
    2422:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    2424:	00 00       	nop
    2426:	20 91 75 50 	lds	r18, 0x5075
    242a:	30 91 76 50 	lds	r19, 0x5076
    242e:	40 91 77 50 	lds	r20, 0x5077
    2432:	50 91 78 50 	lds	r21, 0x5078
    2436:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2438:	9d 8d       	ldd	r25, Y+29	; 0x1d
    243a:	ae 8d       	ldd	r26, Y+30	; 0x1e
    243c:	bf 8d       	ldd	r27, Y+31	; 0x1f
    243e:	28 17       	cp	r18, r24
    2440:	39 07       	cpc	r19, r25
    2442:	4a 07       	cpc	r20, r26
    2444:	5b 07       	cpc	r21, r27
    2446:	78 f3       	brcs	.-34     	; 0x2426 <CO_collectSeismic1Channel+0x1a8>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2448:	80 e0       	ldi	r24, 0x00	; 0
    244a:	99 e0       	ldi	r25, 0x09	; 9
    244c:	20 e0       	ldi	r18, 0x00	; 0
    244e:	39 e0       	ldi	r19, 0x09	; 9
    2450:	f9 01       	movw	r30, r18
    2452:	20 81       	ld	r18, Z
    2454:	20 7f       	andi	r18, 0xF0	; 240
    2456:	fc 01       	movw	r30, r24
    2458:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    245a:	80 e4       	ldi	r24, 0x40	; 64
    245c:	9a e0       	ldi	r25, 0x0A	; 10
    245e:	20 e4       	ldi	r18, 0x40	; 64
    2460:	3a e0       	ldi	r19, 0x0A	; 10
    2462:	f9 01       	movw	r30, r18
    2464:	20 81       	ld	r18, Z
    2466:	20 7f       	andi	r18, 0xF0	; 240
    2468:	fc 01       	movw	r30, r24
    246a:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    246c:	80 ea       	ldi	r24, 0xA0	; 160
    246e:	90 e0       	ldi	r25, 0x00	; 0
    2470:	20 ea       	ldi	r18, 0xA0	; 160
    2472:	30 e0       	ldi	r19, 0x00	; 0
    2474:	f9 01       	movw	r30, r18
    2476:	22 81       	ldd	r18, Z+2	; 0x02
    2478:	29 7f       	andi	r18, 0xF9	; 249
    247a:	fc 01       	movw	r30, r24
    247c:	22 83       	std	Z+2, r18	; 0x02
	cli();
    247e:	f8 94       	cli

	SPICS(FALSE);
    2480:	80 e0       	ldi	r24, 0x00	; 0
    2482:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    2486:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	enableADCMUX(FALSE);
    248a:	80 e0       	ldi	r24, 0x00	; 0
    248c:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	ADCPower(FALSE);
    2490:	80 e0       	ldi	r24, 0x00	; 0
    2492:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
}
    2496:	2c 96       	adiw	r28, 0x0c	; 12
    2498:	cd bf       	out	0x3d, r28	; 61
    249a:	de bf       	out	0x3e, r29	; 62
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	0f 91       	pop	r16
    24a2:	ef 90       	pop	r14
    24a4:	df 90       	pop	r13
    24a6:	cf 90       	pop	r12
    24a8:	bf 90       	pop	r11
    24aa:	af 90       	pop	r10
    24ac:	9f 90       	pop	r9
    24ae:	8f 90       	pop	r8
    24b0:	08 95       	ret

000024b2 <__vector_79>:

//first averaging point
ISR(TCD0_CCA_vect) {
    24b2:	1f 92       	push	r1
    24b4:	0f 92       	push	r0
    24b6:	0f b6       	in	r0, 0x3f	; 63
    24b8:	0f 92       	push	r0
    24ba:	00 90 3b 00 	lds	r0, 0x003B
    24be:	0f 92       	push	r0
    24c0:	11 24       	eor	r1, r1
    24c2:	2f 93       	push	r18
    24c4:	3f 93       	push	r19
    24c6:	4f 93       	push	r20
    24c8:	5f 93       	push	r21
    24ca:	6f 93       	push	r22
    24cc:	7f 93       	push	r23
    24ce:	8f 93       	push	r24
    24d0:	9f 93       	push	r25
    24d2:	af 93       	push	r26
    24d4:	bf 93       	push	r27
    24d6:	ef 93       	push	r30
    24d8:	ff 93       	push	r31
    24da:	cf 93       	push	r28
    24dc:	df 93       	push	r29
    24de:	cd b7       	in	r28, 0x3d	; 61
    24e0:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    24e2:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
}
    24e6:	df 91       	pop	r29
    24e8:	cf 91       	pop	r28
    24ea:	ff 91       	pop	r31
    24ec:	ef 91       	pop	r30
    24ee:	bf 91       	pop	r27
    24f0:	af 91       	pop	r26
    24f2:	9f 91       	pop	r25
    24f4:	8f 91       	pop	r24
    24f6:	7f 91       	pop	r23
    24f8:	6f 91       	pop	r22
    24fa:	5f 91       	pop	r21
    24fc:	4f 91       	pop	r20
    24fe:	3f 91       	pop	r19
    2500:	2f 91       	pop	r18
    2502:	0f 90       	pop	r0
    2504:	00 92 3b 00 	sts	0x003B, r0
    2508:	0f 90       	pop	r0
    250a:	0f be       	out	0x3f, r0	; 63
    250c:	0f 90       	pop	r0
    250e:	1f 90       	pop	r1
    2510:	18 95       	reti

00002512 <__vector_80>:
//second averaging point
ISR(TCD0_CCB_vect) {
    2512:	1f 92       	push	r1
    2514:	0f 92       	push	r0
    2516:	0f b6       	in	r0, 0x3f	; 63
    2518:	0f 92       	push	r0
    251a:	00 90 3b 00 	lds	r0, 0x003B
    251e:	0f 92       	push	r0
    2520:	11 24       	eor	r1, r1
    2522:	2f 93       	push	r18
    2524:	3f 93       	push	r19
    2526:	4f 93       	push	r20
    2528:	5f 93       	push	r21
    252a:	6f 93       	push	r22
    252c:	7f 93       	push	r23
    252e:	8f 93       	push	r24
    2530:	9f 93       	push	r25
    2532:	af 93       	push	r26
    2534:	bf 93       	push	r27
    2536:	ef 93       	push	r30
    2538:	ff 93       	push	r31
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
    253e:	cd b7       	in	r28, 0x3d	; 61
    2540:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2542:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
}
    2546:	df 91       	pop	r29
    2548:	cf 91       	pop	r28
    254a:	ff 91       	pop	r31
    254c:	ef 91       	pop	r30
    254e:	bf 91       	pop	r27
    2550:	af 91       	pop	r26
    2552:	9f 91       	pop	r25
    2554:	8f 91       	pop	r24
    2556:	7f 91       	pop	r23
    2558:	6f 91       	pop	r22
    255a:	5f 91       	pop	r21
    255c:	4f 91       	pop	r20
    255e:	3f 91       	pop	r19
    2560:	2f 91       	pop	r18
    2562:	0f 90       	pop	r0
    2564:	00 92 3b 00 	sts	0x003B, r0
    2568:	0f 90       	pop	r0
    256a:	0f be       	out	0x3f, r0	; 63
    256c:	0f 90       	pop	r0
    256e:	1f 90       	pop	r1
    2570:	18 95       	reti

00002572 <__vector_81>:

//third averaging point
ISR(TCD0_CCC_vect) {
    2572:	1f 92       	push	r1
    2574:	0f 92       	push	r0
    2576:	0f b6       	in	r0, 0x3f	; 63
    2578:	0f 92       	push	r0
    257a:	00 90 3b 00 	lds	r0, 0x003B
    257e:	0f 92       	push	r0
    2580:	11 24       	eor	r1, r1
    2582:	2f 93       	push	r18
    2584:	3f 93       	push	r19
    2586:	4f 93       	push	r20
    2588:	5f 93       	push	r21
    258a:	6f 93       	push	r22
    258c:	7f 93       	push	r23
    258e:	8f 93       	push	r24
    2590:	9f 93       	push	r25
    2592:	af 93       	push	r26
    2594:	bf 93       	push	r27
    2596:	ef 93       	push	r30
    2598:	ff 93       	push	r31
    259a:	cf 93       	push	r28
    259c:	df 93       	push	r29
    259e:	cd b7       	in	r28, 0x3d	; 61
    25a0:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    25a2:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
}
    25a6:	df 91       	pop	r29
    25a8:	cf 91       	pop	r28
    25aa:	ff 91       	pop	r31
    25ac:	ef 91       	pop	r30
    25ae:	bf 91       	pop	r27
    25b0:	af 91       	pop	r26
    25b2:	9f 91       	pop	r25
    25b4:	8f 91       	pop	r24
    25b6:	7f 91       	pop	r23
    25b8:	6f 91       	pop	r22
    25ba:	5f 91       	pop	r21
    25bc:	4f 91       	pop	r20
    25be:	3f 91       	pop	r19
    25c0:	2f 91       	pop	r18
    25c2:	0f 90       	pop	r0
    25c4:	00 92 3b 00 	sts	0x003B, r0
    25c8:	0f 90       	pop	r0
    25ca:	0f be       	out	0x3f, r0	; 63
    25cc:	0f 90       	pop	r0
    25ce:	1f 90       	pop	r1
    25d0:	18 95       	reti

000025d2 <__vector_82>:

//final averaging point
ISR(TCD0_CCD_vect) {
    25d2:	1f 92       	push	r1
    25d4:	0f 92       	push	r0
    25d6:	0f b6       	in	r0, 0x3f	; 63
    25d8:	0f 92       	push	r0
    25da:	00 90 3b 00 	lds	r0, 0x003B
    25de:	0f 92       	push	r0
    25e0:	11 24       	eor	r1, r1
    25e2:	2f 93       	push	r18
    25e4:	3f 93       	push	r19
    25e6:	4f 93       	push	r20
    25e8:	5f 93       	push	r21
    25ea:	6f 93       	push	r22
    25ec:	7f 93       	push	r23
    25ee:	8f 93       	push	r24
    25f0:	9f 93       	push	r25
    25f2:	af 93       	push	r26
    25f4:	bf 93       	push	r27
    25f6:	ef 93       	push	r30
    25f8:	ff 93       	push	r31
    25fa:	cf 93       	push	r28
    25fc:	df 93       	push	r29
    25fe:	cd b7       	in	r28, 0x3d	; 61
    2600:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2602:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <sampleCurrentChannel>
	SPICount = 0;
    2606:	10 92 cf 50 	sts	0x50CF, r1
}
    260a:	df 91       	pop	r29
    260c:	cf 91       	pop	r28
    260e:	ff 91       	pop	r31
    2610:	ef 91       	pop	r30
    2612:	bf 91       	pop	r27
    2614:	af 91       	pop	r26
    2616:	9f 91       	pop	r25
    2618:	8f 91       	pop	r24
    261a:	7f 91       	pop	r23
    261c:	6f 91       	pop	r22
    261e:	5f 91       	pop	r21
    2620:	4f 91       	pop	r20
    2622:	3f 91       	pop	r19
    2624:	2f 91       	pop	r18
    2626:	0f 90       	pop	r0
    2628:	00 92 3b 00 	sts	0x003B, r0
    262c:	0f 90       	pop	r0
    262e:	0f be       	out	0x3f, r0	; 63
    2630:	0f 90       	pop	r0
    2632:	1f 90       	pop	r1
    2634:	18 95       	reti

00002636 <__vector_77>:

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2636:	1f 92       	push	r1
    2638:	0f 92       	push	r0
    263a:	0f b6       	in	r0, 0x3f	; 63
    263c:	0f 92       	push	r0
    263e:	00 90 3b 00 	lds	r0, 0x003B
    2642:	0f 92       	push	r0
    2644:	11 24       	eor	r1, r1
    2646:	2f 93       	push	r18
    2648:	3f 93       	push	r19
    264a:	4f 93       	push	r20
    264c:	5f 93       	push	r21
    264e:	6f 93       	push	r22
    2650:	7f 93       	push	r23
    2652:	8f 93       	push	r24
    2654:	9f 93       	push	r25
    2656:	af 93       	push	r26
    2658:	bf 93       	push	r27
    265a:	ef 93       	push	r30
    265c:	ff 93       	push	r31
    265e:	cf 93       	push	r28
    2660:	df 93       	push	r29
    2662:	cd b7       	in	r28, 0x3d	; 61
    2664:	de b7       	in	r29, 0x3e	; 62
    2666:	29 97       	sbiw	r28, 0x09	; 9
    2668:	cd bf       	out	0x3d, r28	; 61
    266a:	de bf       	out	0x3e, r29	; 62
	//writeSE2FRAM();
	volatile int32_t sum = 0;
    266c:	1a 82       	std	Y+2, r1	; 0x02
    266e:	1b 82       	std	Y+3, r1	; 0x03
    2670:	1c 82       	std	Y+4, r1	; 0x04
    2672:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2674:	19 82       	std	Y+1, r1	; 0x01
    2676:	4f c0       	rjmp	.+158    	; 0x2716 <__vector_77+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	88 2f       	mov	r24, r24
    267c:	90 e0       	ldi	r25, 0x00	; 0
    267e:	8a 59       	subi	r24, 0x9A	; 154
    2680:	9f 4a       	sbci	r25, 0xAF	; 175
    2682:	fc 01       	movw	r30, r24
    2684:	80 81       	ld	r24, Z
    2686:	88 23       	and	r24, r24
    2688:	3c f4       	brge	.+14     	; 0x2698 <__vector_77+0x62>
    268a:	ce 01       	movw	r24, r28
    268c:	06 96       	adiw	r24, 0x06	; 6
    268e:	03 96       	adiw	r24, 0x03	; 3
    2690:	2f ef       	ldi	r18, 0xFF	; 255
    2692:	fc 01       	movw	r30, r24
    2694:	20 83       	st	Z, r18
    2696:	05 c0       	rjmp	.+10     	; 0x26a2 <__vector_77+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2698:	ce 01       	movw	r24, r28
    269a:	06 96       	adiw	r24, 0x06	; 6
    269c:	03 96       	adiw	r24, 0x03	; 3
    269e:	fc 01       	movw	r30, r24
    26a0:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    26a2:	ce 01       	movw	r24, r28
    26a4:	06 96       	adiw	r24, 0x06	; 6
    26a6:	02 96       	adiw	r24, 0x02	; 2
    26a8:	29 81       	ldd	r18, Y+1	; 0x01
    26aa:	22 2f       	mov	r18, r18
    26ac:	30 e0       	ldi	r19, 0x00	; 0
    26ae:	2a 59       	subi	r18, 0x9A	; 154
    26b0:	3f 4a       	sbci	r19, 0xAF	; 175
    26b2:	f9 01       	movw	r30, r18
    26b4:	20 81       	ld	r18, Z
    26b6:	fc 01       	movw	r30, r24
    26b8:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    26ba:	ce 01       	movw	r24, r28
    26bc:	06 96       	adiw	r24, 0x06	; 6
    26be:	01 96       	adiw	r24, 0x01	; 1
    26c0:	29 81       	ldd	r18, Y+1	; 0x01
    26c2:	22 2f       	mov	r18, r18
    26c4:	30 e0       	ldi	r19, 0x00	; 0
    26c6:	2f 5f       	subi	r18, 0xFF	; 255
    26c8:	3f 4f       	sbci	r19, 0xFF	; 255
    26ca:	2a 59       	subi	r18, 0x9A	; 154
    26cc:	3f 4a       	sbci	r19, 0xAF	; 175
    26ce:	f9 01       	movw	r30, r18
    26d0:	20 81       	ld	r18, Z
    26d2:	fc 01       	movw	r30, r24
    26d4:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    26d6:	ce 01       	movw	r24, r28
    26d8:	06 96       	adiw	r24, 0x06	; 6
    26da:	29 81       	ldd	r18, Y+1	; 0x01
    26dc:	22 2f       	mov	r18, r18
    26de:	30 e0       	ldi	r19, 0x00	; 0
    26e0:	2e 5f       	subi	r18, 0xFE	; 254
    26e2:	3f 4f       	sbci	r19, 0xFF	; 255
    26e4:	2a 59       	subi	r18, 0x9A	; 154
    26e6:	3f 4a       	sbci	r19, 0xAF	; 175
    26e8:	f9 01       	movw	r30, r18
    26ea:	20 81       	ld	r18, Z
    26ec:	fc 01       	movw	r30, r24
    26ee:	20 83       	st	Z, r18
		sum += currentSample;
    26f0:	2a 81       	ldd	r18, Y+2	; 0x02
    26f2:	3b 81       	ldd	r19, Y+3	; 0x03
    26f4:	4c 81       	ldd	r20, Y+4	; 0x04
    26f6:	5d 81       	ldd	r21, Y+5	; 0x05
    26f8:	8e 81       	ldd	r24, Y+6	; 0x06
    26fa:	9f 81       	ldd	r25, Y+7	; 0x07
    26fc:	a8 85       	ldd	r26, Y+8	; 0x08
    26fe:	b9 85       	ldd	r27, Y+9	; 0x09
    2700:	82 0f       	add	r24, r18
    2702:	93 1f       	adc	r25, r19
    2704:	a4 1f       	adc	r26, r20
    2706:	b5 1f       	adc	r27, r21
    2708:	8a 83       	std	Y+2, r24	; 0x02
    270a:	9b 83       	std	Y+3, r25	; 0x03
    270c:	ac 83       	std	Y+4, r26	; 0x04
    270e:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2710:	89 81       	ldd	r24, Y+1	; 0x01
    2712:	8d 5f       	subi	r24, 0xFD	; 253
    2714:	89 83       	std	Y+1, r24	; 0x01
    2716:	89 81       	ldd	r24, Y+1	; 0x01
    2718:	8c 30       	cpi	r24, 0x0C	; 12
    271a:	08 f4       	brcc	.+2      	; 0x271e <__vector_77+0xe8>
    271c:	ad cf       	rjmp	.-166    	; 0x2678 <__vector_77+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    271e:	8a 81       	ldd	r24, Y+2	; 0x02
    2720:	9b 81       	ldd	r25, Y+3	; 0x03
    2722:	ac 81       	ldd	r26, Y+4	; 0x04
    2724:	bd 81       	ldd	r27, Y+5	; 0x05
    2726:	24 e0       	ldi	r18, 0x04	; 4
    2728:	30 e0       	ldi	r19, 0x00	; 0
    272a:	40 e0       	ldi	r20, 0x00	; 0
    272c:	50 e0       	ldi	r21, 0x00	; 0
    272e:	bc 01       	movw	r22, r24
    2730:	cd 01       	movw	r24, r26
    2732:	0e 94 6d 62 	call	0xc4da	; 0xc4da <__divmodsi4>
    2736:	da 01       	movw	r26, r20
    2738:	c9 01       	movw	r24, r18
    273a:	8a 83       	std	Y+2, r24	; 0x02
    273c:	9b 83       	std	Y+3, r25	; 0x03
    273e:	ac 83       	std	Y+4, r26	; 0x04
    2740:	bd 83       	std	Y+5, r27	; 0x05
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    2742:	20 91 73 50 	lds	r18, 0x5073
    2746:	30 91 74 50 	lds	r19, 0x5074
    274a:	80 91 75 50 	lds	r24, 0x5075
    274e:	90 91 76 50 	lds	r25, 0x5076
    2752:	a0 91 77 50 	lds	r26, 0x5077
    2756:	b0 91 78 50 	lds	r27, 0x5078
    275a:	88 0f       	add	r24, r24
    275c:	99 1f       	adc	r25, r25
    275e:	88 0f       	add	r24, r24
    2760:	99 1f       	adc	r25, r25
    2762:	28 0f       	add	r18, r24
    2764:	39 1f       	adc	r19, r25
    2766:	8a 81       	ldd	r24, Y+2	; 0x02
    2768:	9b 81       	ldd	r25, Y+3	; 0x03
    276a:	ac 81       	ldd	r26, Y+4	; 0x04
    276c:	bd 81       	ldd	r27, Y+5	; 0x05
    276e:	f9 01       	movw	r30, r18
    2770:	80 83       	st	Z, r24
    2772:	91 83       	std	Z+1, r25	; 0x01
    2774:	a2 83       	std	Z+2, r26	; 0x02
    2776:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    2778:	80 91 75 50 	lds	r24, 0x5075
    277c:	90 91 76 50 	lds	r25, 0x5076
    2780:	a0 91 77 50 	lds	r26, 0x5077
    2784:	b0 91 78 50 	lds	r27, 0x5078
    2788:	01 96       	adiw	r24, 0x01	; 1
    278a:	a1 1d       	adc	r26, r1
    278c:	b1 1d       	adc	r27, r1
    278e:	80 93 75 50 	sts	0x5075, r24
    2792:	90 93 76 50 	sts	0x5076, r25
    2796:	a0 93 77 50 	sts	0x5077, r26
    279a:	b0 93 78 50 	sts	0x5078, r27
}
    279e:	29 96       	adiw	r28, 0x09	; 9
    27a0:	cd bf       	out	0x3d, r28	; 61
    27a2:	de bf       	out	0x3e, r29	; 62
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	ff 91       	pop	r31
    27aa:	ef 91       	pop	r30
    27ac:	bf 91       	pop	r27
    27ae:	af 91       	pop	r26
    27b0:	9f 91       	pop	r25
    27b2:	8f 91       	pop	r24
    27b4:	7f 91       	pop	r23
    27b6:	6f 91       	pop	r22
    27b8:	5f 91       	pop	r21
    27ba:	4f 91       	pop	r20
    27bc:	3f 91       	pop	r19
    27be:	2f 91       	pop	r18
    27c0:	0f 90       	pop	r0
    27c2:	00 92 3b 00 	sts	0x003B, r0
    27c6:	0f 90       	pop	r0
    27c8:	0f be       	out	0x3f, r0	; 63
    27ca:	0f 90       	pop	r0
    27cc:	1f 90       	pop	r1
    27ce:	18 95       	reti

000027d0 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
    27d0:	cf 93       	push	r28
    27d2:	df 93       	push	r29
    27d4:	cd b7       	in	r28, 0x3d	; 61
    27d6:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    27d8:	80 ea       	ldi	r24, 0xA0	; 160
    27da:	96 e0       	ldi	r25, 0x06	; 6
    27dc:	22 e0       	ldi	r18, 0x02	; 2
    27de:	fc 01       	movw	r30, r24
    27e0:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    27e2:	80 ec       	ldi	r24, 0xC0	; 192
    27e4:	98 e0       	ldi	r25, 0x08	; 8
    27e6:	2a ea       	ldi	r18, 0xAA	; 170
    27e8:	fc 01       	movw	r30, r24
    27ea:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27ec:	00 00       	nop
    27ee:	80 ec       	ldi	r24, 0xC0	; 192
    27f0:	98 e0       	ldi	r25, 0x08	; 8
    27f2:	fc 01       	movw	r30, r24
    27f4:	82 81       	ldd	r24, Z+2	; 0x02
    27f6:	88 23       	and	r24, r24
    27f8:	d4 f7       	brge	.-12     	; 0x27ee <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    27fa:	80 91 cf 50 	lds	r24, 0x50CF
    27fe:	88 2f       	mov	r24, r24
    2800:	90 e0       	ldi	r25, 0x00	; 0
    2802:	20 ec       	ldi	r18, 0xC0	; 192
    2804:	38 e0       	ldi	r19, 0x08	; 8
    2806:	f9 01       	movw	r30, r18
    2808:	23 81       	ldd	r18, Z+3	; 0x03
    280a:	8a 59       	subi	r24, 0x9A	; 154
    280c:	9f 4a       	sbci	r25, 0xAF	; 175
    280e:	fc 01       	movw	r30, r24
    2810:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2812:	80 ec       	ldi	r24, 0xC0	; 192
    2814:	98 e0       	ldi	r25, 0x08	; 8
    2816:	2a ea       	ldi	r18, 0xAA	; 170
    2818:	fc 01       	movw	r30, r24
    281a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    281c:	00 00       	nop
    281e:	80 ec       	ldi	r24, 0xC0	; 192
    2820:	98 e0       	ldi	r25, 0x08	; 8
    2822:	fc 01       	movw	r30, r24
    2824:	82 81       	ldd	r24, Z+2	; 0x02
    2826:	88 23       	and	r24, r24
    2828:	d4 f7       	brge	.-12     	; 0x281e <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    282a:	80 91 cf 50 	lds	r24, 0x50CF
    282e:	88 2f       	mov	r24, r24
    2830:	90 e0       	ldi	r25, 0x00	; 0
    2832:	01 96       	adiw	r24, 0x01	; 1
    2834:	20 ec       	ldi	r18, 0xC0	; 192
    2836:	38 e0       	ldi	r19, 0x08	; 8
    2838:	f9 01       	movw	r30, r18
    283a:	23 81       	ldd	r18, Z+3	; 0x03
    283c:	8a 59       	subi	r24, 0x9A	; 154
    283e:	9f 4a       	sbci	r25, 0xAF	; 175
    2840:	fc 01       	movw	r30, r24
    2842:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2844:	80 ec       	ldi	r24, 0xC0	; 192
    2846:	98 e0       	ldi	r25, 0x08	; 8
    2848:	2a ea       	ldi	r18, 0xAA	; 170
    284a:	fc 01       	movw	r30, r24
    284c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    284e:	00 00       	nop
    2850:	80 ec       	ldi	r24, 0xC0	; 192
    2852:	98 e0       	ldi	r25, 0x08	; 8
    2854:	fc 01       	movw	r30, r24
    2856:	82 81       	ldd	r24, Z+2	; 0x02
    2858:	88 23       	and	r24, r24
    285a:	d4 f7       	brge	.-12     	; 0x2850 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    285c:	80 91 cf 50 	lds	r24, 0x50CF
    2860:	88 2f       	mov	r24, r24
    2862:	90 e0       	ldi	r25, 0x00	; 0
    2864:	02 96       	adiw	r24, 0x02	; 2
    2866:	20 ec       	ldi	r18, 0xC0	; 192
    2868:	38 e0       	ldi	r19, 0x08	; 8
    286a:	f9 01       	movw	r30, r18
    286c:	23 81       	ldd	r18, Z+3	; 0x03
    286e:	8a 59       	subi	r24, 0x9A	; 154
    2870:	9f 4a       	sbci	r25, 0xAF	; 175
    2872:	fc 01       	movw	r30, r24
    2874:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2876:	80 ea       	ldi	r24, 0xA0	; 160
    2878:	96 e0       	ldi	r25, 0x06	; 6
    287a:	22 e0       	ldi	r18, 0x02	; 2
    287c:	fc 01       	movw	r30, r24
    287e:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2880:	80 91 cf 50 	lds	r24, 0x50CF
    2884:	8d 5f       	subi	r24, 0xFD	; 253
    2886:	80 93 cf 50 	sts	0x50CF, r24
}
    288a:	df 91       	pop	r29
    288c:	cf 91       	pop	r28
    288e:	08 95       	ret

00002890 <writeSE2FRAM>:

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2890:	cf 93       	push	r28
    2892:	df 93       	push	r29
    2894:	cd b7       	in	r28, 0x3d	; 61
    2896:	de b7       	in	r29, 0x3e	; 62
    2898:	29 97       	sbiw	r28, 0x09	; 9
    289a:	cd bf       	out	0x3d, r28	; 61
    289c:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    289e:	1a 82       	std	Y+2, r1	; 0x02
    28a0:	1b 82       	std	Y+3, r1	; 0x03
    28a2:	1c 82       	std	Y+4, r1	; 0x04
    28a4:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    28a6:	80 91 75 50 	lds	r24, 0x5075
    28aa:	90 91 76 50 	lds	r25, 0x5076
    28ae:	a0 91 77 50 	lds	r26, 0x5077
    28b2:	b0 91 78 50 	lds	r27, 0x5078
    28b6:	01 96       	adiw	r24, 0x01	; 1
    28b8:	a1 1d       	adc	r26, r1
    28ba:	b1 1d       	adc	r27, r1
    28bc:	80 93 75 50 	sts	0x5075, r24
    28c0:	90 93 76 50 	sts	0x5076, r25
    28c4:	a0 93 77 50 	sts	0x5077, r26
    28c8:	b0 93 78 50 	sts	0x5078, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    28cc:	80 ec       	ldi	r24, 0xC0	; 192
    28ce:	98 e0       	ldi	r25, 0x08	; 8
    28d0:	20 ed       	ldi	r18, 0xD0	; 208
    28d2:	fc 01       	movw	r30, r24
    28d4:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    28d6:	19 82       	std	Y+1, r1	; 0x01
    28d8:	4f c0       	rjmp	.+158    	; 0x2978 <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	88 2f       	mov	r24, r24
    28de:	90 e0       	ldi	r25, 0x00	; 0
    28e0:	8a 59       	subi	r24, 0x9A	; 154
    28e2:	9f 4a       	sbci	r25, 0xAF	; 175
    28e4:	fc 01       	movw	r30, r24
    28e6:	80 81       	ld	r24, Z
    28e8:	88 23       	and	r24, r24
    28ea:	3c f4       	brge	.+14     	; 0x28fa <writeSE2FRAM+0x6a>
    28ec:	ce 01       	movw	r24, r28
    28ee:	06 96       	adiw	r24, 0x06	; 6
    28f0:	03 96       	adiw	r24, 0x03	; 3
    28f2:	2f ef       	ldi	r18, 0xFF	; 255
    28f4:	fc 01       	movw	r30, r24
    28f6:	20 83       	st	Z, r18
    28f8:	05 c0       	rjmp	.+10     	; 0x2904 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    28fa:	ce 01       	movw	r24, r28
    28fc:	06 96       	adiw	r24, 0x06	; 6
    28fe:	03 96       	adiw	r24, 0x03	; 3
    2900:	fc 01       	movw	r30, r24
    2902:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2904:	ce 01       	movw	r24, r28
    2906:	06 96       	adiw	r24, 0x06	; 6
    2908:	02 96       	adiw	r24, 0x02	; 2
    290a:	29 81       	ldd	r18, Y+1	; 0x01
    290c:	22 2f       	mov	r18, r18
    290e:	30 e0       	ldi	r19, 0x00	; 0
    2910:	2a 59       	subi	r18, 0x9A	; 154
    2912:	3f 4a       	sbci	r19, 0xAF	; 175
    2914:	f9 01       	movw	r30, r18
    2916:	20 81       	ld	r18, Z
    2918:	fc 01       	movw	r30, r24
    291a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    291c:	ce 01       	movw	r24, r28
    291e:	06 96       	adiw	r24, 0x06	; 6
    2920:	01 96       	adiw	r24, 0x01	; 1
    2922:	29 81       	ldd	r18, Y+1	; 0x01
    2924:	22 2f       	mov	r18, r18
    2926:	30 e0       	ldi	r19, 0x00	; 0
    2928:	2f 5f       	subi	r18, 0xFF	; 255
    292a:	3f 4f       	sbci	r19, 0xFF	; 255
    292c:	2a 59       	subi	r18, 0x9A	; 154
    292e:	3f 4a       	sbci	r19, 0xAF	; 175
    2930:	f9 01       	movw	r30, r18
    2932:	20 81       	ld	r18, Z
    2934:	fc 01       	movw	r30, r24
    2936:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2938:	ce 01       	movw	r24, r28
    293a:	06 96       	adiw	r24, 0x06	; 6
    293c:	29 81       	ldd	r18, Y+1	; 0x01
    293e:	22 2f       	mov	r18, r18
    2940:	30 e0       	ldi	r19, 0x00	; 0
    2942:	2e 5f       	subi	r18, 0xFE	; 254
    2944:	3f 4f       	sbci	r19, 0xFF	; 255
    2946:	2a 59       	subi	r18, 0x9A	; 154
    2948:	3f 4a       	sbci	r19, 0xAF	; 175
    294a:	f9 01       	movw	r30, r18
    294c:	20 81       	ld	r18, Z
    294e:	fc 01       	movw	r30, r24
    2950:	20 83       	st	Z, r18
		sum += currentSample;
    2952:	2a 81       	ldd	r18, Y+2	; 0x02
    2954:	3b 81       	ldd	r19, Y+3	; 0x03
    2956:	4c 81       	ldd	r20, Y+4	; 0x04
    2958:	5d 81       	ldd	r21, Y+5	; 0x05
    295a:	8e 81       	ldd	r24, Y+6	; 0x06
    295c:	9f 81       	ldd	r25, Y+7	; 0x07
    295e:	a8 85       	ldd	r26, Y+8	; 0x08
    2960:	b9 85       	ldd	r27, Y+9	; 0x09
    2962:	82 0f       	add	r24, r18
    2964:	93 1f       	adc	r25, r19
    2966:	a4 1f       	adc	r26, r20
    2968:	b5 1f       	adc	r27, r21
    296a:	8a 83       	std	Y+2, r24	; 0x02
    296c:	9b 83       	std	Y+3, r25	; 0x03
    296e:	ac 83       	std	Y+4, r26	; 0x04
    2970:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2972:	89 81       	ldd	r24, Y+1	; 0x01
    2974:	8d 5f       	subi	r24, 0xFD	; 253
    2976:	89 83       	std	Y+1, r24	; 0x01
    2978:	89 81       	ldd	r24, Y+1	; 0x01
    297a:	8c 30       	cpi	r24, 0x0C	; 12
    297c:	08 f4       	brcc	.+2      	; 0x2980 <writeSE2FRAM+0xf0>
    297e:	ad cf       	rjmp	.-166    	; 0x28da <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2980:	8a 81       	ldd	r24, Y+2	; 0x02
    2982:	9b 81       	ldd	r25, Y+3	; 0x03
    2984:	ac 81       	ldd	r26, Y+4	; 0x04
    2986:	bd 81       	ldd	r27, Y+5	; 0x05
    2988:	24 e0       	ldi	r18, 0x04	; 4
    298a:	30 e0       	ldi	r19, 0x00	; 0
    298c:	40 e0       	ldi	r20, 0x00	; 0
    298e:	50 e0       	ldi	r21, 0x00	; 0
    2990:	bc 01       	movw	r22, r24
    2992:	cd 01       	movw	r24, r26
    2994:	0e 94 6d 62 	call	0xc4da	; 0xc4da <__divmodsi4>
    2998:	da 01       	movw	r26, r20
    299a:	c9 01       	movw	r24, r18
    299c:	8a 83       	std	Y+2, r24	; 0x02
    299e:	9b 83       	std	Y+3, r25	; 0x03
    29a0:	ac 83       	std	Y+4, r26	; 0x04
    29a2:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    29a4:	ce 01       	movw	r24, r28
    29a6:	02 96       	adiw	r24, 0x02	; 2
    29a8:	fc 01       	movw	r30, r24
    29aa:	80 81       	ld	r24, Z
    29ac:	80 93 68 50 	sts	0x5068, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    29b0:	ce 01       	movw	r24, r28
    29b2:	02 96       	adiw	r24, 0x02	; 2
    29b4:	fc 01       	movw	r30, r24
    29b6:	81 81       	ldd	r24, Z+1	; 0x01
    29b8:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    29bc:	ce 01       	movw	r24, r28
    29be:	02 96       	adiw	r24, 0x02	; 2
    29c0:	fc 01       	movw	r30, r24
    29c2:	82 81       	ldd	r24, Z+2	; 0x02
    29c4:	80 93 66 50 	sts	0x5066, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    29c8:	80 e4       	ldi	r24, 0x40	; 64
    29ca:	96 e0       	ldi	r25, 0x06	; 6
    29cc:	20 e1       	ldi	r18, 0x10	; 16
    29ce:	fc 01       	movw	r30, r24
    29d0:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    29d2:	80 e2       	ldi	r24, 0x20	; 32
    29d4:	96 e0       	ldi	r25, 0x06	; 6
    29d6:	28 e0       	ldi	r18, 0x08	; 8
    29d8:	fc 01       	movw	r30, r24
    29da:	26 83       	std	Z+6, r18	; 0x06
	nop();
    29dc:	00 00       	nop
	SPIC.DATA = FR_WREN;
    29de:	80 ec       	ldi	r24, 0xC0	; 192
    29e0:	98 e0       	ldi	r25, 0x08	; 8
    29e2:	26 e0       	ldi	r18, 0x06	; 6
    29e4:	fc 01       	movw	r30, r24
    29e6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29e8:	00 00       	nop
    29ea:	80 ec       	ldi	r24, 0xC0	; 192
    29ec:	98 e0       	ldi	r25, 0x08	; 8
    29ee:	fc 01       	movw	r30, r24
    29f0:	82 81       	ldd	r24, Z+2	; 0x02
    29f2:	88 23       	and	r24, r24
    29f4:	d4 f7       	brge	.-12     	; 0x29ea <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    29f6:	80 ec       	ldi	r24, 0xC0	; 192
    29f8:	98 e0       	ldi	r25, 0x08	; 8
    29fa:	fc 01       	movw	r30, r24
    29fc:	83 81       	ldd	r24, Z+3	; 0x03
    29fe:	80 93 72 50 	sts	0x5072, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2a02:	80 e2       	ldi	r24, 0x20	; 32
    2a04:	96 e0       	ldi	r25, 0x06	; 6
    2a06:	28 e0       	ldi	r18, 0x08	; 8
    2a08:	fc 01       	movw	r30, r24
    2a0a:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2a0c:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a0e:	80 e2       	ldi	r24, 0x20	; 32
    2a10:	96 e0       	ldi	r25, 0x06	; 6
    2a12:	28 e0       	ldi	r18, 0x08	; 8
    2a14:	fc 01       	movw	r30, r24
    2a16:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2a18:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2a1a:	80 ec       	ldi	r24, 0xC0	; 192
    2a1c:	98 e0       	ldi	r25, 0x08	; 8
    2a1e:	22 e0       	ldi	r18, 0x02	; 2
    2a20:	fc 01       	movw	r30, r24
    2a22:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a24:	00 00       	nop
    2a26:	80 ec       	ldi	r24, 0xC0	; 192
    2a28:	98 e0       	ldi	r25, 0x08	; 8
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	82 81       	ldd	r24, Z+2	; 0x02
    2a2e:	88 23       	and	r24, r24
    2a30:	d4 f7       	brge	.-12     	; 0x2a26 <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    2a32:	80 ec       	ldi	r24, 0xC0	; 192
    2a34:	98 e0       	ldi	r25, 0x08	; 8
    2a36:	fc 01       	movw	r30, r24
    2a38:	83 81       	ldd	r24, Z+3	; 0x03
    2a3a:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2a3e:	80 ec       	ldi	r24, 0xC0	; 192
    2a40:	98 e0       	ldi	r25, 0x08	; 8
    2a42:	20 91 51 40 	lds	r18, 0x4051
    2a46:	fc 01       	movw	r30, r24
    2a48:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a4a:	00 00       	nop
    2a4c:	80 ec       	ldi	r24, 0xC0	; 192
    2a4e:	98 e0       	ldi	r25, 0x08	; 8
    2a50:	fc 01       	movw	r30, r24
    2a52:	82 81       	ldd	r24, Z+2	; 0x02
    2a54:	88 23       	and	r24, r24
    2a56:	d4 f7       	brge	.-12     	; 0x2a4c <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    2a58:	80 ec       	ldi	r24, 0xC0	; 192
    2a5a:	98 e0       	ldi	r25, 0x08	; 8
    2a5c:	fc 01       	movw	r30, r24
    2a5e:	83 81       	ldd	r24, Z+3	; 0x03
    2a60:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2a64:	80 ec       	ldi	r24, 0xC0	; 192
    2a66:	98 e0       	ldi	r25, 0x08	; 8
    2a68:	20 e5       	ldi	r18, 0x50	; 80
    2a6a:	30 e4       	ldi	r19, 0x40	; 64
    2a6c:	f9 01       	movw	r30, r18
    2a6e:	20 81       	ld	r18, Z
    2a70:	fc 01       	movw	r30, r24
    2a72:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a74:	00 00       	nop
    2a76:	80 ec       	ldi	r24, 0xC0	; 192
    2a78:	98 e0       	ldi	r25, 0x08	; 8
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	82 81       	ldd	r24, Z+2	; 0x02
    2a7e:	88 23       	and	r24, r24
    2a80:	d4 f7       	brge	.-12     	; 0x2a76 <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    2a82:	80 ec       	ldi	r24, 0xC0	; 192
    2a84:	98 e0       	ldi	r25, 0x08	; 8
    2a86:	fc 01       	movw	r30, r24
    2a88:	83 81       	ldd	r24, Z+3	; 0x03
    2a8a:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[0];
    2a8e:	80 ec       	ldi	r24, 0xC0	; 192
    2a90:	98 e0       	ldi	r25, 0x08	; 8
    2a92:	20 91 66 50 	lds	r18, 0x5066
    2a96:	fc 01       	movw	r30, r24
    2a98:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a9a:	00 00       	nop
    2a9c:	80 ec       	ldi	r24, 0xC0	; 192
    2a9e:	98 e0       	ldi	r25, 0x08	; 8
    2aa0:	fc 01       	movw	r30, r24
    2aa2:	82 81       	ldd	r24, Z+2	; 0x02
    2aa4:	88 23       	and	r24, r24
    2aa6:	d4 f7       	brge	.-12     	; 0x2a9c <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    2aa8:	80 ec       	ldi	r24, 0xC0	; 192
    2aaa:	98 e0       	ldi	r25, 0x08	; 8
    2aac:	fc 01       	movw	r30, r24
    2aae:	83 81       	ldd	r24, Z+3	; 0x03
    2ab0:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[1];
    2ab4:	80 ec       	ldi	r24, 0xC0	; 192
    2ab6:	98 e0       	ldi	r25, 0x08	; 8
    2ab8:	20 91 67 50 	lds	r18, 0x5067
    2abc:	fc 01       	movw	r30, r24
    2abe:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ac0:	00 00       	nop
    2ac2:	80 ec       	ldi	r24, 0xC0	; 192
    2ac4:	98 e0       	ldi	r25, 0x08	; 8
    2ac6:	fc 01       	movw	r30, r24
    2ac8:	82 81       	ldd	r24, Z+2	; 0x02
    2aca:	88 23       	and	r24, r24
    2acc:	d4 f7       	brge	.-12     	; 0x2ac2 <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    2ace:	80 ec       	ldi	r24, 0xC0	; 192
    2ad0:	98 e0       	ldi	r25, 0x08	; 8
    2ad2:	fc 01       	movw	r30, r24
    2ad4:	83 81       	ldd	r24, Z+3	; 0x03
    2ad6:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[2];
    2ada:	80 ec       	ldi	r24, 0xC0	; 192
    2adc:	98 e0       	ldi	r25, 0x08	; 8
    2ade:	20 91 68 50 	lds	r18, 0x5068
    2ae2:	fc 01       	movw	r30, r24
    2ae4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ae6:	00 00       	nop
    2ae8:	80 ec       	ldi	r24, 0xC0	; 192
    2aea:	98 e0       	ldi	r25, 0x08	; 8
    2aec:	fc 01       	movw	r30, r24
    2aee:	82 81       	ldd	r24, Z+2	; 0x02
    2af0:	88 23       	and	r24, r24
    2af2:	d4 f7       	brge	.-12     	; 0x2ae8 <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    2af4:	80 ec       	ldi	r24, 0xC0	; 192
    2af6:	98 e0       	ldi	r25, 0x08	; 8
    2af8:	fc 01       	movw	r30, r24
    2afa:	83 81       	ldd	r24, Z+3	; 0x03
    2afc:	80 93 72 50 	sts	0x5072, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2b00:	80 e2       	ldi	r24, 0x20	; 32
    2b02:	96 e0       	ldi	r25, 0x06	; 6
    2b04:	28 e0       	ldi	r18, 0x08	; 8
    2b06:	fc 01       	movw	r30, r24
    2b08:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2b0a:	80 e4       	ldi	r24, 0x40	; 64
    2b0c:	96 e0       	ldi	r25, 0x06	; 6
    2b0e:	20 e1       	ldi	r18, 0x10	; 16
    2b10:	fc 01       	movw	r30, r24
    2b12:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2b14:	80 ec       	ldi	r24, 0xC0	; 192
    2b16:	98 e0       	ldi	r25, 0x08	; 8
    2b18:	24 e5       	ldi	r18, 0x54	; 84
    2b1a:	fc 01       	movw	r30, r24
    2b1c:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2b1e:	80 e4       	ldi	r24, 0x40	; 64
    2b20:	96 e0       	ldi	r25, 0x06	; 6
    2b22:	20 e1       	ldi	r18, 0x10	; 16
    2b24:	fc 01       	movw	r30, r24
    2b26:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2b28:	80 91 50 40 	lds	r24, 0x4050
    2b2c:	90 91 51 40 	lds	r25, 0x4051
    2b30:	03 96       	adiw	r24, 0x03	; 3
    2b32:	80 93 50 40 	sts	0x4050, r24
    2b36:	90 93 51 40 	sts	0x4051, r25
	checksumADC[0] += SPIBuffer[0];
    2b3a:	90 91 32 21 	lds	r25, 0x2132
    2b3e:	80 91 66 50 	lds	r24, 0x5066
    2b42:	89 0f       	add	r24, r25
    2b44:	80 93 32 21 	sts	0x2132, r24
	checksumADC[1] += SPIBuffer[1];
    2b48:	90 91 33 21 	lds	r25, 0x2133
    2b4c:	80 91 67 50 	lds	r24, 0x5067
    2b50:	89 0f       	add	r24, r25
    2b52:	80 93 33 21 	sts	0x2133, r24
	checksumADC[2] += SPIBuffer[2];
    2b56:	90 91 34 21 	lds	r25, 0x2134
    2b5a:	80 91 68 50 	lds	r24, 0x5068
    2b5e:	89 0f       	add	r24, r25
    2b60:	80 93 34 21 	sts	0x2134, r24
}
    2b64:	29 96       	adiw	r28, 0x09	; 9
    2b66:	cd bf       	out	0x3d, r28	; 61
    2b68:	de bf       	out	0x3e, r29	; 62
    2b6a:	df 91       	pop	r29
    2b6c:	cf 91       	pop	r28
    2b6e:	08 95       	ret

00002b70 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    2b70:	2f 92       	push	r2
    2b72:	3f 92       	push	r3
    2b74:	4f 92       	push	r4
    2b76:	5f 92       	push	r5
    2b78:	6f 92       	push	r6
    2b7a:	7f 92       	push	r7
    2b7c:	8f 92       	push	r8
    2b7e:	9f 92       	push	r9
    2b80:	af 92       	push	r10
    2b82:	bf 92       	push	r11
    2b84:	cf 92       	push	r12
    2b86:	df 92       	push	r13
    2b88:	ef 92       	push	r14
    2b8a:	ff 92       	push	r15
    2b8c:	0f 93       	push	r16
    2b8e:	1f 93       	push	r17
    2b90:	cf 93       	push	r28
    2b92:	df 93       	push	r29
    2b94:	00 d0       	rcall	.+0      	; 0x2b96 <calcChecksumFRAM+0x26>
    2b96:	0f 92       	push	r0
    2b98:	cd b7       	in	r28, 0x3d	; 61
    2b9a:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2b9c:	aa 24       	eor	r10, r10
    2b9e:	bb 24       	eor	r11, r11
    2ba0:	cc 24       	eor	r12, r12
    2ba2:	dd 24       	eor	r13, r13
    2ba4:	ee 24       	eor	r14, r14
    2ba6:	ff 24       	eor	r15, r15
    2ba8:	00 e0       	ldi	r16, 0x00	; 0
    2baa:	10 e0       	ldi	r17, 0x00	; 0
    2bac:	a0 92 9c 50 	sts	0x509C, r10
    2bb0:	b0 92 9d 50 	sts	0x509D, r11
    2bb4:	c0 92 9e 50 	sts	0x509E, r12
    2bb8:	d0 92 9f 50 	sts	0x509F, r13
    2bbc:	e0 92 a0 50 	sts	0x50A0, r14
    2bc0:	f0 92 a1 50 	sts	0x50A1, r15
    2bc4:	00 93 a2 50 	sts	0x50A2, r16
    2bc8:	10 93 a3 50 	sts	0x50A3, r17
    2bcc:	2a 2d       	mov	r18, r10
    2bce:	3b 2d       	mov	r19, r11
    2bd0:	4c 2d       	mov	r20, r12
    2bd2:	5d 2d       	mov	r21, r13
    2bd4:	6e 2d       	mov	r22, r14
    2bd6:	7f 2d       	mov	r23, r15
    2bd8:	80 2f       	mov	r24, r16
    2bda:	91 2f       	mov	r25, r17
    2bdc:	20 93 94 50 	sts	0x5094, r18
    2be0:	30 93 95 50 	sts	0x5095, r19
    2be4:	40 93 96 50 	sts	0x5096, r20
    2be8:	50 93 97 50 	sts	0x5097, r21
    2bec:	60 93 98 50 	sts	0x5098, r22
    2bf0:	70 93 99 50 	sts	0x5099, r23
    2bf4:	80 93 9a 50 	sts	0x509A, r24
    2bf8:	90 93 9b 50 	sts	0x509B, r25
    2bfc:	20 93 8c 50 	sts	0x508C, r18
    2c00:	30 93 8d 50 	sts	0x508D, r19
    2c04:	40 93 8e 50 	sts	0x508E, r20
    2c08:	50 93 8f 50 	sts	0x508F, r21
    2c0c:	60 93 90 50 	sts	0x5090, r22
    2c10:	70 93 91 50 	sts	0x5091, r23
    2c14:	80 93 92 50 	sts	0x5092, r24
    2c18:	90 93 93 50 	sts	0x5093, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2c1c:	80 e0       	ldi	r24, 0x00	; 0
    2c1e:	80 93 37 21 	sts	0x2137, r24
    2c22:	80 93 36 21 	sts	0x2136, r24
    2c26:	80 93 35 21 	sts	0x2135, r24
	FRAMAddress = FR_BASEADD;
    2c2a:	10 92 50 40 	sts	0x4050, r1
    2c2e:	10 92 51 40 	sts	0x4051, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2c32:	19 82       	std	Y+1, r1	; 0x01
    2c34:	1a 82       	std	Y+2, r1	; 0x02
    2c36:	88 c2       	rjmp	.+1296   	; 0x3148 <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2c38:	81 e7       	ldi	r24, 0x71	; 113
    2c3a:	9c e1       	ldi	r25, 0x1C	; 28
    2c3c:	0e 94 c9 37 	call	0x6f92	; 0x6f92 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2c40:	80 91 50 40 	lds	r24, 0x4050
    2c44:	90 91 51 40 	lds	r25, 0x4051
    2c48:	8f 58       	subi	r24, 0x8F	; 143
    2c4a:	93 4e       	sbci	r25, 0xE3	; 227
    2c4c:	80 93 50 40 	sts	0x4050, r24
    2c50:	90 93 51 40 	sts	0x4051, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2c54:	1b 82       	std	Y+3, r1	; 0x03
    2c56:	1c 82       	std	Y+4, r1	; 0x04
    2c58:	6b c2       	rjmp	.+1238   	; 0x3130 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5e:	23 e0       	ldi	r18, 0x03	; 3
    2c60:	30 e0       	ldi	r19, 0x00	; 0
    2c62:	b9 01       	movw	r22, r18
    2c64:	0e 94 24 62 	call	0xc448	; 0xc448 <__udivmodhi4>
    2c68:	9c 01       	movw	r18, r24
    2c6a:	2b 5c       	subi	r18, 0xCB	; 203
    2c6c:	3e 4d       	sbci	r19, 0xDE	; 222
    2c6e:	f9 01       	movw	r30, r18
    2c70:	40 81       	ld	r20, Z
    2c72:	2b 81       	ldd	r18, Y+3	; 0x03
    2c74:	3c 81       	ldd	r19, Y+4	; 0x04
    2c76:	28 52       	subi	r18, 0x28	; 40
    2c78:	3c 4d       	sbci	r19, 0xDC	; 220
    2c7a:	f9 01       	movw	r30, r18
    2c7c:	20 81       	ld	r18, Z
    2c7e:	24 0f       	add	r18, r20
    2c80:	8b 5c       	subi	r24, 0xCB	; 203
    2c82:	9e 4d       	sbci	r25, 0xDE	; 222
    2c84:	fc 01       	movw	r30, r24
    2c86:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2c88:	8b 81       	ldd	r24, Y+3	; 0x03
    2c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8c:	23 e0       	ldi	r18, 0x03	; 3
    2c8e:	30 e0       	ldi	r19, 0x00	; 0
    2c90:	b9 01       	movw	r22, r18
    2c92:	0e 94 24 62 	call	0xc448	; 0xc448 <__udivmodhi4>
    2c96:	00 97       	sbiw	r24, 0x00	; 0
    2c98:	09 f0       	breq	.+2      	; 0x2c9c <calcChecksumFRAM+0x12c>
    2c9a:	44 c0       	rjmp	.+136    	; 0x2d24 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2c9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca0:	88 52       	subi	r24, 0x28	; 40
    2ca2:	9c 4d       	sbci	r25, 0xDC	; 220
    2ca4:	fc 01       	movw	r30, r24
    2ca6:	80 81       	ld	r24, Z
    2ca8:	88 23       	and	r24, r24
    2caa:	d4 f4       	brge	.+52     	; 0x2ce0 <calcChecksumFRAM+0x170>
    2cac:	80 91 64 50 	lds	r24, 0x5064
    2cb0:	90 91 65 50 	lds	r25, 0x5065
    2cb4:	fc 01       	movw	r30, r24
    2cb6:	10 82       	st	Z, r1
    2cb8:	fc 01       	movw	r30, r24
    2cba:	11 82       	std	Z+1, r1	; 0x01
    2cbc:	fc 01       	movw	r30, r24
    2cbe:	12 82       	std	Z+2, r1	; 0x02
    2cc0:	2f ef       	ldi	r18, 0xFF	; 255
    2cc2:	fc 01       	movw	r30, r24
    2cc4:	23 83       	std	Z+3, r18	; 0x03
    2cc6:	2f ef       	ldi	r18, 0xFF	; 255
    2cc8:	fc 01       	movw	r30, r24
    2cca:	24 83       	std	Z+4, r18	; 0x04
    2ccc:	2f ef       	ldi	r18, 0xFF	; 255
    2cce:	fc 01       	movw	r30, r24
    2cd0:	25 83       	std	Z+5, r18	; 0x05
    2cd2:	2f ef       	ldi	r18, 0xFF	; 255
    2cd4:	fc 01       	movw	r30, r24
    2cd6:	26 83       	std	Z+6, r18	; 0x06
    2cd8:	2f ef       	ldi	r18, 0xFF	; 255
    2cda:	fc 01       	movw	r30, r24
    2cdc:	27 83       	std	Z+7, r18	; 0x07
    2cde:	14 c0       	rjmp	.+40     	; 0x2d08 <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2ce0:	80 91 64 50 	lds	r24, 0x5064
    2ce4:	90 91 65 50 	lds	r25, 0x5065
    2ce8:	fc 01       	movw	r30, r24
    2cea:	10 82       	st	Z, r1
    2cec:	fc 01       	movw	r30, r24
    2cee:	11 82       	std	Z+1, r1	; 0x01
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	12 82       	std	Z+2, r1	; 0x02
    2cf4:	fc 01       	movw	r30, r24
    2cf6:	13 82       	std	Z+3, r1	; 0x03
    2cf8:	fc 01       	movw	r30, r24
    2cfa:	14 82       	std	Z+4, r1	; 0x04
    2cfc:	fc 01       	movw	r30, r24
    2cfe:	15 82       	std	Z+5, r1	; 0x05
    2d00:	fc 01       	movw	r30, r24
    2d02:	16 82       	std	Z+6, r1	; 0x06
    2d04:	fc 01       	movw	r30, r24
    2d06:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2d08:	80 91 64 50 	lds	r24, 0x5064
    2d0c:	90 91 65 50 	lds	r25, 0x5065
    2d10:	02 96       	adiw	r24, 0x02	; 2
    2d12:	2b 81       	ldd	r18, Y+3	; 0x03
    2d14:	3c 81       	ldd	r19, Y+4	; 0x04
    2d16:	28 52       	subi	r18, 0x28	; 40
    2d18:	3c 4d       	sbci	r19, 0xDC	; 220
    2d1a:	f9 01       	movw	r30, r18
    2d1c:	20 81       	ld	r18, Z
    2d1e:	fc 01       	movw	r30, r24
    2d20:	20 83       	st	Z, r18
    2d22:	24 c0       	rjmp	.+72     	; 0x2d6c <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2d24:	8b 81       	ldd	r24, Y+3	; 0x03
    2d26:	9c 81       	ldd	r25, Y+4	; 0x04
    2d28:	23 e0       	ldi	r18, 0x03	; 3
    2d2a:	30 e0       	ldi	r19, 0x00	; 0
    2d2c:	b9 01       	movw	r22, r18
    2d2e:	0e 94 24 62 	call	0xc448	; 0xc448 <__udivmodhi4>
    2d32:	81 30       	cpi	r24, 0x01	; 1
    2d34:	91 05       	cpc	r25, r1
    2d36:	71 f4       	brne	.+28     	; 0x2d54 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2d38:	80 91 64 50 	lds	r24, 0x5064
    2d3c:	90 91 65 50 	lds	r25, 0x5065
    2d40:	01 96       	adiw	r24, 0x01	; 1
    2d42:	2b 81       	ldd	r18, Y+3	; 0x03
    2d44:	3c 81       	ldd	r19, Y+4	; 0x04
    2d46:	28 52       	subi	r18, 0x28	; 40
    2d48:	3c 4d       	sbci	r19, 0xDC	; 220
    2d4a:	f9 01       	movw	r30, r18
    2d4c:	20 81       	ld	r18, Z
    2d4e:	fc 01       	movw	r30, r24
    2d50:	20 83       	st	Z, r18
    2d52:	0c c0       	rjmp	.+24     	; 0x2d6c <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2d54:	80 91 64 50 	lds	r24, 0x5064
    2d58:	90 91 65 50 	lds	r25, 0x5065
    2d5c:	2b 81       	ldd	r18, Y+3	; 0x03
    2d5e:	3c 81       	ldd	r19, Y+4	; 0x04
    2d60:	28 52       	subi	r18, 0x28	; 40
    2d62:	3c 4d       	sbci	r19, 0xDC	; 220
    2d64:	f9 01       	movw	r30, r18
    2d66:	20 81       	ld	r18, Z
    2d68:	fc 01       	movw	r30, r24
    2d6a:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d70:	29 e0       	ldi	r18, 0x09	; 9
    2d72:	30 e0       	ldi	r19, 0x00	; 0
    2d74:	b9 01       	movw	r22, r18
    2d76:	0e 94 24 62 	call	0xc448	; 0xc448 <__udivmodhi4>
    2d7a:	82 30       	cpi	r24, 0x02	; 2
    2d7c:	91 05       	cpc	r25, r1
    2d7e:	09 f0       	breq	.+2      	; 0x2d82 <calcChecksumFRAM+0x212>
    2d80:	94 c0       	rjmp	.+296    	; 0x2eaa <calcChecksumFRAM+0x33a>
    2d82:	a0 90 8c 50 	lds	r10, 0x508C
    2d86:	b0 90 8d 50 	lds	r11, 0x508D
    2d8a:	c0 90 8e 50 	lds	r12, 0x508E
    2d8e:	d0 90 8f 50 	lds	r13, 0x508F
    2d92:	e0 90 90 50 	lds	r14, 0x5090
    2d96:	f0 90 91 50 	lds	r15, 0x5091
    2d9a:	00 91 92 50 	lds	r16, 0x5092
    2d9e:	10 91 93 50 	lds	r17, 0x5093
    2da2:	80 91 64 50 	lds	r24, 0x5064
    2da6:	90 91 65 50 	lds	r25, 0x5065
    2daa:	fc 01       	movw	r30, r24
    2dac:	20 80       	ld	r2, Z
    2dae:	fc 01       	movw	r30, r24
    2db0:	31 80       	ldd	r3, Z+1	; 0x01
    2db2:	fc 01       	movw	r30, r24
    2db4:	42 80       	ldd	r4, Z+2	; 0x02
    2db6:	fc 01       	movw	r30, r24
    2db8:	53 80       	ldd	r5, Z+3	; 0x03
    2dba:	fc 01       	movw	r30, r24
    2dbc:	64 80       	ldd	r6, Z+4	; 0x04
    2dbe:	fc 01       	movw	r30, r24
    2dc0:	75 80       	ldd	r7, Z+5	; 0x05
    2dc2:	fc 01       	movw	r30, r24
    2dc4:	86 80       	ldd	r8, Z+6	; 0x06
    2dc6:	fc 01       	movw	r30, r24
    2dc8:	97 80       	ldd	r9, Z+7	; 0x07
    2dca:	2a 2d       	mov	r18, r10
    2dcc:	22 0d       	add	r18, r2
    2dce:	e1 e0       	ldi	r30, 0x01	; 1
    2dd0:	2a 15       	cp	r18, r10
    2dd2:	08 f0       	brcs	.+2      	; 0x2dd6 <calcChecksumFRAM+0x266>
    2dd4:	e0 e0       	ldi	r30, 0x00	; 0
    2dd6:	3b 2d       	mov	r19, r11
    2dd8:	33 0d       	add	r19, r3
    2dda:	f1 e0       	ldi	r31, 0x01	; 1
    2ddc:	3b 15       	cp	r19, r11
    2dde:	08 f0       	brcs	.+2      	; 0x2de2 <calcChecksumFRAM+0x272>
    2de0:	f0 e0       	ldi	r31, 0x00	; 0
    2de2:	e3 0f       	add	r30, r19
    2de4:	a1 e0       	ldi	r26, 0x01	; 1
    2de6:	e3 17       	cp	r30, r19
    2de8:	08 f0       	brcs	.+2      	; 0x2dec <calcChecksumFRAM+0x27c>
    2dea:	a0 e0       	ldi	r26, 0x00	; 0
    2dec:	fa 2b       	or	r31, r26
    2dee:	3e 2f       	mov	r19, r30
    2df0:	4c 2d       	mov	r20, r12
    2df2:	44 0d       	add	r20, r4
    2df4:	e1 e0       	ldi	r30, 0x01	; 1
    2df6:	4c 15       	cp	r20, r12
    2df8:	08 f0       	brcs	.+2      	; 0x2dfc <calcChecksumFRAM+0x28c>
    2dfa:	e0 e0       	ldi	r30, 0x00	; 0
    2dfc:	f4 0f       	add	r31, r20
    2dfe:	a1 e0       	ldi	r26, 0x01	; 1
    2e00:	f4 17       	cp	r31, r20
    2e02:	08 f0       	brcs	.+2      	; 0x2e06 <calcChecksumFRAM+0x296>
    2e04:	a0 e0       	ldi	r26, 0x00	; 0
    2e06:	ea 2b       	or	r30, r26
    2e08:	4f 2f       	mov	r20, r31
    2e0a:	5d 2d       	mov	r21, r13
    2e0c:	55 0d       	add	r21, r5
    2e0e:	f1 e0       	ldi	r31, 0x01	; 1
    2e10:	5d 15       	cp	r21, r13
    2e12:	08 f0       	brcs	.+2      	; 0x2e16 <calcChecksumFRAM+0x2a6>
    2e14:	f0 e0       	ldi	r31, 0x00	; 0
    2e16:	e5 0f       	add	r30, r21
    2e18:	a1 e0       	ldi	r26, 0x01	; 1
    2e1a:	e5 17       	cp	r30, r21
    2e1c:	08 f0       	brcs	.+2      	; 0x2e20 <calcChecksumFRAM+0x2b0>
    2e1e:	a0 e0       	ldi	r26, 0x00	; 0
    2e20:	fa 2b       	or	r31, r26
    2e22:	5e 2f       	mov	r21, r30
    2e24:	6e 2d       	mov	r22, r14
    2e26:	66 0d       	add	r22, r6
    2e28:	e1 e0       	ldi	r30, 0x01	; 1
    2e2a:	6e 15       	cp	r22, r14
    2e2c:	08 f0       	brcs	.+2      	; 0x2e30 <calcChecksumFRAM+0x2c0>
    2e2e:	e0 e0       	ldi	r30, 0x00	; 0
    2e30:	f6 0f       	add	r31, r22
    2e32:	a1 e0       	ldi	r26, 0x01	; 1
    2e34:	f6 17       	cp	r31, r22
    2e36:	08 f0       	brcs	.+2      	; 0x2e3a <calcChecksumFRAM+0x2ca>
    2e38:	a0 e0       	ldi	r26, 0x00	; 0
    2e3a:	ea 2b       	or	r30, r26
    2e3c:	6f 2f       	mov	r22, r31
    2e3e:	7f 2d       	mov	r23, r15
    2e40:	77 0d       	add	r23, r7
    2e42:	f1 e0       	ldi	r31, 0x01	; 1
    2e44:	7f 15       	cp	r23, r15
    2e46:	08 f0       	brcs	.+2      	; 0x2e4a <calcChecksumFRAM+0x2da>
    2e48:	f0 e0       	ldi	r31, 0x00	; 0
    2e4a:	e7 0f       	add	r30, r23
    2e4c:	a1 e0       	ldi	r26, 0x01	; 1
    2e4e:	e7 17       	cp	r30, r23
    2e50:	08 f0       	brcs	.+2      	; 0x2e54 <calcChecksumFRAM+0x2e4>
    2e52:	a0 e0       	ldi	r26, 0x00	; 0
    2e54:	fa 2b       	or	r31, r26
    2e56:	7e 2f       	mov	r23, r30
    2e58:	80 2f       	mov	r24, r16
    2e5a:	88 0d       	add	r24, r8
    2e5c:	e1 e0       	ldi	r30, 0x01	; 1
    2e5e:	80 17       	cp	r24, r16
    2e60:	08 f0       	brcs	.+2      	; 0x2e64 <calcChecksumFRAM+0x2f4>
    2e62:	e0 e0       	ldi	r30, 0x00	; 0
    2e64:	f8 0f       	add	r31, r24
    2e66:	a1 e0       	ldi	r26, 0x01	; 1
    2e68:	f8 17       	cp	r31, r24
    2e6a:	08 f0       	brcs	.+2      	; 0x2e6e <calcChecksumFRAM+0x2fe>
    2e6c:	a0 e0       	ldi	r26, 0x00	; 0
    2e6e:	ea 2b       	or	r30, r26
    2e70:	8f 2f       	mov	r24, r31
    2e72:	91 2f       	mov	r25, r17
    2e74:	99 0d       	add	r25, r9
    2e76:	e9 0f       	add	r30, r25
    2e78:	9e 2f       	mov	r25, r30
    2e7a:	a2 2e       	mov	r10, r18
    2e7c:	b3 2e       	mov	r11, r19
    2e7e:	c4 2e       	mov	r12, r20
    2e80:	d5 2e       	mov	r13, r21
    2e82:	e6 2e       	mov	r14, r22
    2e84:	f7 2e       	mov	r15, r23
    2e86:	08 2f       	mov	r16, r24
    2e88:	19 2f       	mov	r17, r25
    2e8a:	a0 92 8c 50 	sts	0x508C, r10
    2e8e:	b0 92 8d 50 	sts	0x508D, r11
    2e92:	c0 92 8e 50 	sts	0x508E, r12
    2e96:	d0 92 8f 50 	sts	0x508F, r13
    2e9a:	e0 92 90 50 	sts	0x5090, r14
    2e9e:	f0 92 91 50 	sts	0x5091, r15
    2ea2:	00 93 92 50 	sts	0x5092, r16
    2ea6:	10 93 93 50 	sts	0x5093, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    2eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2eac:	9c 81       	ldd	r25, Y+4	; 0x04
    2eae:	29 e0       	ldi	r18, 0x09	; 9
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	b9 01       	movw	r22, r18
    2eb4:	0e 94 24 62 	call	0xc448	; 0xc448 <__udivmodhi4>
    2eb8:	85 30       	cpi	r24, 0x05	; 5
    2eba:	91 05       	cpc	r25, r1
    2ebc:	09 f0       	breq	.+2      	; 0x2ec0 <calcChecksumFRAM+0x350>
    2ebe:	94 c0       	rjmp	.+296    	; 0x2fe8 <calcChecksumFRAM+0x478>
    2ec0:	a0 90 94 50 	lds	r10, 0x5094
    2ec4:	b0 90 95 50 	lds	r11, 0x5095
    2ec8:	c0 90 96 50 	lds	r12, 0x5096
    2ecc:	d0 90 97 50 	lds	r13, 0x5097
    2ed0:	e0 90 98 50 	lds	r14, 0x5098
    2ed4:	f0 90 99 50 	lds	r15, 0x5099
    2ed8:	00 91 9a 50 	lds	r16, 0x509A
    2edc:	10 91 9b 50 	lds	r17, 0x509B
    2ee0:	80 91 64 50 	lds	r24, 0x5064
    2ee4:	90 91 65 50 	lds	r25, 0x5065
    2ee8:	fc 01       	movw	r30, r24
    2eea:	20 80       	ld	r2, Z
    2eec:	fc 01       	movw	r30, r24
    2eee:	31 80       	ldd	r3, Z+1	; 0x01
    2ef0:	fc 01       	movw	r30, r24
    2ef2:	42 80       	ldd	r4, Z+2	; 0x02
    2ef4:	fc 01       	movw	r30, r24
    2ef6:	53 80       	ldd	r5, Z+3	; 0x03
    2ef8:	fc 01       	movw	r30, r24
    2efa:	64 80       	ldd	r6, Z+4	; 0x04
    2efc:	fc 01       	movw	r30, r24
    2efe:	75 80       	ldd	r7, Z+5	; 0x05
    2f00:	fc 01       	movw	r30, r24
    2f02:	86 80       	ldd	r8, Z+6	; 0x06
    2f04:	fc 01       	movw	r30, r24
    2f06:	97 80       	ldd	r9, Z+7	; 0x07
    2f08:	2a 2d       	mov	r18, r10
    2f0a:	22 0d       	add	r18, r2
    2f0c:	e1 e0       	ldi	r30, 0x01	; 1
    2f0e:	2a 15       	cp	r18, r10
    2f10:	08 f0       	brcs	.+2      	; 0x2f14 <calcChecksumFRAM+0x3a4>
    2f12:	e0 e0       	ldi	r30, 0x00	; 0
    2f14:	3b 2d       	mov	r19, r11
    2f16:	33 0d       	add	r19, r3
    2f18:	f1 e0       	ldi	r31, 0x01	; 1
    2f1a:	3b 15       	cp	r19, r11
    2f1c:	08 f0       	brcs	.+2      	; 0x2f20 <calcChecksumFRAM+0x3b0>
    2f1e:	f0 e0       	ldi	r31, 0x00	; 0
    2f20:	e3 0f       	add	r30, r19
    2f22:	a1 e0       	ldi	r26, 0x01	; 1
    2f24:	e3 17       	cp	r30, r19
    2f26:	08 f0       	brcs	.+2      	; 0x2f2a <calcChecksumFRAM+0x3ba>
    2f28:	a0 e0       	ldi	r26, 0x00	; 0
    2f2a:	fa 2b       	or	r31, r26
    2f2c:	3e 2f       	mov	r19, r30
    2f2e:	4c 2d       	mov	r20, r12
    2f30:	44 0d       	add	r20, r4
    2f32:	e1 e0       	ldi	r30, 0x01	; 1
    2f34:	4c 15       	cp	r20, r12
    2f36:	08 f0       	brcs	.+2      	; 0x2f3a <calcChecksumFRAM+0x3ca>
    2f38:	e0 e0       	ldi	r30, 0x00	; 0
    2f3a:	f4 0f       	add	r31, r20
    2f3c:	a1 e0       	ldi	r26, 0x01	; 1
    2f3e:	f4 17       	cp	r31, r20
    2f40:	08 f0       	brcs	.+2      	; 0x2f44 <calcChecksumFRAM+0x3d4>
    2f42:	a0 e0       	ldi	r26, 0x00	; 0
    2f44:	ea 2b       	or	r30, r26
    2f46:	4f 2f       	mov	r20, r31
    2f48:	5d 2d       	mov	r21, r13
    2f4a:	55 0d       	add	r21, r5
    2f4c:	f1 e0       	ldi	r31, 0x01	; 1
    2f4e:	5d 15       	cp	r21, r13
    2f50:	08 f0       	brcs	.+2      	; 0x2f54 <calcChecksumFRAM+0x3e4>
    2f52:	f0 e0       	ldi	r31, 0x00	; 0
    2f54:	e5 0f       	add	r30, r21
    2f56:	a1 e0       	ldi	r26, 0x01	; 1
    2f58:	e5 17       	cp	r30, r21
    2f5a:	08 f0       	brcs	.+2      	; 0x2f5e <calcChecksumFRAM+0x3ee>
    2f5c:	a0 e0       	ldi	r26, 0x00	; 0
    2f5e:	fa 2b       	or	r31, r26
    2f60:	5e 2f       	mov	r21, r30
    2f62:	6e 2d       	mov	r22, r14
    2f64:	66 0d       	add	r22, r6
    2f66:	e1 e0       	ldi	r30, 0x01	; 1
    2f68:	6e 15       	cp	r22, r14
    2f6a:	08 f0       	brcs	.+2      	; 0x2f6e <calcChecksumFRAM+0x3fe>
    2f6c:	e0 e0       	ldi	r30, 0x00	; 0
    2f6e:	f6 0f       	add	r31, r22
    2f70:	a1 e0       	ldi	r26, 0x01	; 1
    2f72:	f6 17       	cp	r31, r22
    2f74:	08 f0       	brcs	.+2      	; 0x2f78 <calcChecksumFRAM+0x408>
    2f76:	a0 e0       	ldi	r26, 0x00	; 0
    2f78:	ea 2b       	or	r30, r26
    2f7a:	6f 2f       	mov	r22, r31
    2f7c:	7f 2d       	mov	r23, r15
    2f7e:	77 0d       	add	r23, r7
    2f80:	f1 e0       	ldi	r31, 0x01	; 1
    2f82:	7f 15       	cp	r23, r15
    2f84:	08 f0       	brcs	.+2      	; 0x2f88 <calcChecksumFRAM+0x418>
    2f86:	f0 e0       	ldi	r31, 0x00	; 0
    2f88:	e7 0f       	add	r30, r23
    2f8a:	a1 e0       	ldi	r26, 0x01	; 1
    2f8c:	e7 17       	cp	r30, r23
    2f8e:	08 f0       	brcs	.+2      	; 0x2f92 <calcChecksumFRAM+0x422>
    2f90:	a0 e0       	ldi	r26, 0x00	; 0
    2f92:	fa 2b       	or	r31, r26
    2f94:	7e 2f       	mov	r23, r30
    2f96:	80 2f       	mov	r24, r16
    2f98:	88 0d       	add	r24, r8
    2f9a:	e1 e0       	ldi	r30, 0x01	; 1
    2f9c:	80 17       	cp	r24, r16
    2f9e:	08 f0       	brcs	.+2      	; 0x2fa2 <calcChecksumFRAM+0x432>
    2fa0:	e0 e0       	ldi	r30, 0x00	; 0
    2fa2:	f8 0f       	add	r31, r24
    2fa4:	a1 e0       	ldi	r26, 0x01	; 1
    2fa6:	f8 17       	cp	r31, r24
    2fa8:	08 f0       	brcs	.+2      	; 0x2fac <calcChecksumFRAM+0x43c>
    2faa:	a0 e0       	ldi	r26, 0x00	; 0
    2fac:	ea 2b       	or	r30, r26
    2fae:	8f 2f       	mov	r24, r31
    2fb0:	91 2f       	mov	r25, r17
    2fb2:	99 0d       	add	r25, r9
    2fb4:	e9 0f       	add	r30, r25
    2fb6:	9e 2f       	mov	r25, r30
    2fb8:	a2 2e       	mov	r10, r18
    2fba:	b3 2e       	mov	r11, r19
    2fbc:	c4 2e       	mov	r12, r20
    2fbe:	d5 2e       	mov	r13, r21
    2fc0:	e6 2e       	mov	r14, r22
    2fc2:	f7 2e       	mov	r15, r23
    2fc4:	08 2f       	mov	r16, r24
    2fc6:	19 2f       	mov	r17, r25
    2fc8:	a0 92 94 50 	sts	0x5094, r10
    2fcc:	b0 92 95 50 	sts	0x5095, r11
    2fd0:	c0 92 96 50 	sts	0x5096, r12
    2fd4:	d0 92 97 50 	sts	0x5097, r13
    2fd8:	e0 92 98 50 	sts	0x5098, r14
    2fdc:	f0 92 99 50 	sts	0x5099, r15
    2fe0:	00 93 9a 50 	sts	0x509A, r16
    2fe4:	10 93 9b 50 	sts	0x509B, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    2fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fea:	9c 81       	ldd	r25, Y+4	; 0x04
    2fec:	29 e0       	ldi	r18, 0x09	; 9
    2fee:	30 e0       	ldi	r19, 0x00	; 0
    2ff0:	b9 01       	movw	r22, r18
    2ff2:	0e 94 24 62 	call	0xc448	; 0xc448 <__udivmodhi4>
    2ff6:	88 30       	cpi	r24, 0x08	; 8
    2ff8:	91 05       	cpc	r25, r1
    2ffa:	09 f0       	breq	.+2      	; 0x2ffe <calcChecksumFRAM+0x48e>
    2ffc:	94 c0       	rjmp	.+296    	; 0x3126 <calcChecksumFRAM+0x5b6>
    2ffe:	a0 90 9c 50 	lds	r10, 0x509C
    3002:	b0 90 9d 50 	lds	r11, 0x509D
    3006:	c0 90 9e 50 	lds	r12, 0x509E
    300a:	d0 90 9f 50 	lds	r13, 0x509F
    300e:	e0 90 a0 50 	lds	r14, 0x50A0
    3012:	f0 90 a1 50 	lds	r15, 0x50A1
    3016:	00 91 a2 50 	lds	r16, 0x50A2
    301a:	10 91 a3 50 	lds	r17, 0x50A3
    301e:	80 91 64 50 	lds	r24, 0x5064
    3022:	90 91 65 50 	lds	r25, 0x5065
    3026:	fc 01       	movw	r30, r24
    3028:	20 80       	ld	r2, Z
    302a:	fc 01       	movw	r30, r24
    302c:	31 80       	ldd	r3, Z+1	; 0x01
    302e:	fc 01       	movw	r30, r24
    3030:	42 80       	ldd	r4, Z+2	; 0x02
    3032:	fc 01       	movw	r30, r24
    3034:	53 80       	ldd	r5, Z+3	; 0x03
    3036:	fc 01       	movw	r30, r24
    3038:	64 80       	ldd	r6, Z+4	; 0x04
    303a:	fc 01       	movw	r30, r24
    303c:	75 80       	ldd	r7, Z+5	; 0x05
    303e:	fc 01       	movw	r30, r24
    3040:	86 80       	ldd	r8, Z+6	; 0x06
    3042:	fc 01       	movw	r30, r24
    3044:	97 80       	ldd	r9, Z+7	; 0x07
    3046:	2a 2d       	mov	r18, r10
    3048:	22 0d       	add	r18, r2
    304a:	e1 e0       	ldi	r30, 0x01	; 1
    304c:	2a 15       	cp	r18, r10
    304e:	08 f0       	brcs	.+2      	; 0x3052 <calcChecksumFRAM+0x4e2>
    3050:	e0 e0       	ldi	r30, 0x00	; 0
    3052:	3b 2d       	mov	r19, r11
    3054:	33 0d       	add	r19, r3
    3056:	f1 e0       	ldi	r31, 0x01	; 1
    3058:	3b 15       	cp	r19, r11
    305a:	08 f0       	brcs	.+2      	; 0x305e <calcChecksumFRAM+0x4ee>
    305c:	f0 e0       	ldi	r31, 0x00	; 0
    305e:	e3 0f       	add	r30, r19
    3060:	a1 e0       	ldi	r26, 0x01	; 1
    3062:	e3 17       	cp	r30, r19
    3064:	08 f0       	brcs	.+2      	; 0x3068 <calcChecksumFRAM+0x4f8>
    3066:	a0 e0       	ldi	r26, 0x00	; 0
    3068:	fa 2b       	or	r31, r26
    306a:	3e 2f       	mov	r19, r30
    306c:	4c 2d       	mov	r20, r12
    306e:	44 0d       	add	r20, r4
    3070:	e1 e0       	ldi	r30, 0x01	; 1
    3072:	4c 15       	cp	r20, r12
    3074:	08 f0       	brcs	.+2      	; 0x3078 <calcChecksumFRAM+0x508>
    3076:	e0 e0       	ldi	r30, 0x00	; 0
    3078:	f4 0f       	add	r31, r20
    307a:	a1 e0       	ldi	r26, 0x01	; 1
    307c:	f4 17       	cp	r31, r20
    307e:	08 f0       	brcs	.+2      	; 0x3082 <calcChecksumFRAM+0x512>
    3080:	a0 e0       	ldi	r26, 0x00	; 0
    3082:	ea 2b       	or	r30, r26
    3084:	4f 2f       	mov	r20, r31
    3086:	5d 2d       	mov	r21, r13
    3088:	55 0d       	add	r21, r5
    308a:	f1 e0       	ldi	r31, 0x01	; 1
    308c:	5d 15       	cp	r21, r13
    308e:	08 f0       	brcs	.+2      	; 0x3092 <calcChecksumFRAM+0x522>
    3090:	f0 e0       	ldi	r31, 0x00	; 0
    3092:	e5 0f       	add	r30, r21
    3094:	a1 e0       	ldi	r26, 0x01	; 1
    3096:	e5 17       	cp	r30, r21
    3098:	08 f0       	brcs	.+2      	; 0x309c <calcChecksumFRAM+0x52c>
    309a:	a0 e0       	ldi	r26, 0x00	; 0
    309c:	fa 2b       	or	r31, r26
    309e:	5e 2f       	mov	r21, r30
    30a0:	6e 2d       	mov	r22, r14
    30a2:	66 0d       	add	r22, r6
    30a4:	e1 e0       	ldi	r30, 0x01	; 1
    30a6:	6e 15       	cp	r22, r14
    30a8:	08 f0       	brcs	.+2      	; 0x30ac <calcChecksumFRAM+0x53c>
    30aa:	e0 e0       	ldi	r30, 0x00	; 0
    30ac:	f6 0f       	add	r31, r22
    30ae:	a1 e0       	ldi	r26, 0x01	; 1
    30b0:	f6 17       	cp	r31, r22
    30b2:	08 f0       	brcs	.+2      	; 0x30b6 <calcChecksumFRAM+0x546>
    30b4:	a0 e0       	ldi	r26, 0x00	; 0
    30b6:	ea 2b       	or	r30, r26
    30b8:	6f 2f       	mov	r22, r31
    30ba:	7f 2d       	mov	r23, r15
    30bc:	77 0d       	add	r23, r7
    30be:	f1 e0       	ldi	r31, 0x01	; 1
    30c0:	7f 15       	cp	r23, r15
    30c2:	08 f0       	brcs	.+2      	; 0x30c6 <calcChecksumFRAM+0x556>
    30c4:	f0 e0       	ldi	r31, 0x00	; 0
    30c6:	e7 0f       	add	r30, r23
    30c8:	a1 e0       	ldi	r26, 0x01	; 1
    30ca:	e7 17       	cp	r30, r23
    30cc:	08 f0       	brcs	.+2      	; 0x30d0 <calcChecksumFRAM+0x560>
    30ce:	a0 e0       	ldi	r26, 0x00	; 0
    30d0:	fa 2b       	or	r31, r26
    30d2:	7e 2f       	mov	r23, r30
    30d4:	80 2f       	mov	r24, r16
    30d6:	88 0d       	add	r24, r8
    30d8:	e1 e0       	ldi	r30, 0x01	; 1
    30da:	80 17       	cp	r24, r16
    30dc:	08 f0       	brcs	.+2      	; 0x30e0 <calcChecksumFRAM+0x570>
    30de:	e0 e0       	ldi	r30, 0x00	; 0
    30e0:	f8 0f       	add	r31, r24
    30e2:	a1 e0       	ldi	r26, 0x01	; 1
    30e4:	f8 17       	cp	r31, r24
    30e6:	08 f0       	brcs	.+2      	; 0x30ea <calcChecksumFRAM+0x57a>
    30e8:	a0 e0       	ldi	r26, 0x00	; 0
    30ea:	ea 2b       	or	r30, r26
    30ec:	8f 2f       	mov	r24, r31
    30ee:	91 2f       	mov	r25, r17
    30f0:	99 0d       	add	r25, r9
    30f2:	e9 0f       	add	r30, r25
    30f4:	9e 2f       	mov	r25, r30
    30f6:	a2 2e       	mov	r10, r18
    30f8:	b3 2e       	mov	r11, r19
    30fa:	c4 2e       	mov	r12, r20
    30fc:	d5 2e       	mov	r13, r21
    30fe:	e6 2e       	mov	r14, r22
    3100:	f7 2e       	mov	r15, r23
    3102:	08 2f       	mov	r16, r24
    3104:	19 2f       	mov	r17, r25
    3106:	a0 92 9c 50 	sts	0x509C, r10
    310a:	b0 92 9d 50 	sts	0x509D, r11
    310e:	c0 92 9e 50 	sts	0x509E, r12
    3112:	d0 92 9f 50 	sts	0x509F, r13
    3116:	e0 92 a0 50 	sts	0x50A0, r14
    311a:	f0 92 a1 50 	sts	0x50A1, r15
    311e:	00 93 a2 50 	sts	0x50A2, r16
    3122:	10 93 a3 50 	sts	0x50A3, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3126:	8b 81       	ldd	r24, Y+3	; 0x03
    3128:	9c 81       	ldd	r25, Y+4	; 0x04
    312a:	01 96       	adiw	r24, 0x01	; 1
    312c:	8b 83       	std	Y+3, r24	; 0x03
    312e:	9c 83       	std	Y+4, r25	; 0x04
    3130:	8b 81       	ldd	r24, Y+3	; 0x03
    3132:	9c 81       	ldd	r25, Y+4	; 0x04
    3134:	fc e1       	ldi	r31, 0x1C	; 28
    3136:	81 37       	cpi	r24, 0x71	; 113
    3138:	9f 07       	cpc	r25, r31
    313a:	08 f4       	brcc	.+2      	; 0x313e <calcChecksumFRAM+0x5ce>
    313c:	8e cd       	rjmp	.-1252   	; 0x2c5a <calcChecksumFRAM+0xea>
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    313e:	89 81       	ldd	r24, Y+1	; 0x01
    3140:	9a 81       	ldd	r25, Y+2	; 0x02
    3142:	01 96       	adiw	r24, 0x01	; 1
    3144:	89 83       	std	Y+1, r24	; 0x01
    3146:	9a 83       	std	Y+2, r25	; 0x02
    3148:	89 81       	ldd	r24, Y+1	; 0x01
    314a:	9a 81       	ldd	r25, Y+2	; 0x02
    314c:	89 30       	cpi	r24, 0x09	; 9
    314e:	91 05       	cpc	r25, r1
    3150:	08 f4       	brcc	.+2      	; 0x3154 <calcChecksumFRAM+0x5e4>
    3152:	72 cd       	rjmp	.-1308   	; 0x2c38 <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3154:	24 96       	adiw	r28, 0x04	; 4
    3156:	cd bf       	out	0x3d, r28	; 61
    3158:	de bf       	out	0x3e, r29	; 62
    315a:	df 91       	pop	r29
    315c:	cf 91       	pop	r28
    315e:	1f 91       	pop	r17
    3160:	0f 91       	pop	r16
    3162:	ff 90       	pop	r15
    3164:	ef 90       	pop	r14
    3166:	df 90       	pop	r13
    3168:	cf 90       	pop	r12
    316a:	bf 90       	pop	r11
    316c:	af 90       	pop	r10
    316e:	9f 90       	pop	r9
    3170:	8f 90       	pop	r8
    3172:	7f 90       	pop	r7
    3174:	6f 90       	pop	r6
    3176:	5f 90       	pop	r5
    3178:	4f 90       	pop	r4
    317a:	3f 90       	pop	r3
    317c:	2f 90       	pop	r2
    317e:	08 95       	ret

00003180 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    3180:	cf 93       	push	r28
    3182:	df 93       	push	r29
    3184:	cd b7       	in	r28, 0x3d	; 61
    3186:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    3188:	10 92 50 40 	sts	0x4050, r1
    318c:	10 92 51 40 	sts	0x4051, r1
	sampleCount = 0;
    3190:	10 92 75 50 	sts	0x5075, r1
    3194:	10 92 76 50 	sts	0x5076, r1
    3198:	10 92 77 50 	sts	0x5077, r1
    319c:	10 92 78 50 	sts	0x5078, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    31a0:	80 e0       	ldi	r24, 0x00	; 0
    31a2:	80 93 34 21 	sts	0x2134, r24
    31a6:	80 93 33 21 	sts	0x2133, r24
    31aa:	80 93 32 21 	sts	0x2132, r24
	
	ADCPower(TRUE);
    31ae:	81 e0       	ldi	r24, 0x01	; 1
    31b0:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    31b4:	84 e0       	ldi	r24, 0x04	; 4
    31b6:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    31ba:	80 ec       	ldi	r24, 0xC0	; 192
    31bc:	98 e0       	ldi	r25, 0x08	; 8
    31be:	20 ed       	ldi	r18, 0xD0	; 208
    31c0:	fc 01       	movw	r30, r24
    31c2:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    31c4:	8d e0       	ldi	r24, 0x0D	; 13
    31c6:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[1] = 0xF3;
    31ca:	83 ef       	ldi	r24, 0xF3	; 243
    31cc:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[2] = 0x57;
    31d0:	87 e5       	ldi	r24, 0x57	; 87
    31d2:	80 93 68 50 	sts	0x5068, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    31d6:	d7 c0       	rjmp	.+430    	; 0x3386 <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    31d8:	80 e4       	ldi	r24, 0x40	; 64
    31da:	96 e0       	ldi	r25, 0x06	; 6
    31dc:	20 e1       	ldi	r18, 0x10	; 16
    31de:	fc 01       	movw	r30, r24
    31e0:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    31e2:	80 e2       	ldi	r24, 0x20	; 32
    31e4:	96 e0       	ldi	r25, 0x06	; 6
    31e6:	28 e0       	ldi	r18, 0x08	; 8
    31e8:	fc 01       	movw	r30, r24
    31ea:	26 83       	std	Z+6, r18	; 0x06
		nop();
    31ec:	00 00       	nop
		SPIC.DATA = FR_WREN;
    31ee:	80 ec       	ldi	r24, 0xC0	; 192
    31f0:	98 e0       	ldi	r25, 0x08	; 8
    31f2:	26 e0       	ldi	r18, 0x06	; 6
    31f4:	fc 01       	movw	r30, r24
    31f6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    31f8:	00 00       	nop
    31fa:	80 ec       	ldi	r24, 0xC0	; 192
    31fc:	98 e0       	ldi	r25, 0x08	; 8
    31fe:	fc 01       	movw	r30, r24
    3200:	82 81       	ldd	r24, Z+2	; 0x02
    3202:	88 23       	and	r24, r24
    3204:	d4 f7       	brge	.-12     	; 0x31fa <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3206:	80 ec       	ldi	r24, 0xC0	; 192
    3208:	98 e0       	ldi	r25, 0x08	; 8
    320a:	fc 01       	movw	r30, r24
    320c:	83 81       	ldd	r24, Z+3	; 0x03
    320e:	80 93 72 50 	sts	0x5072, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3212:	80 e2       	ldi	r24, 0x20	; 32
    3214:	96 e0       	ldi	r25, 0x06	; 6
    3216:	28 e0       	ldi	r18, 0x08	; 8
    3218:	fc 01       	movw	r30, r24
    321a:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    321c:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    321e:	80 e2       	ldi	r24, 0x20	; 32
    3220:	96 e0       	ldi	r25, 0x06	; 6
    3222:	28 e0       	ldi	r18, 0x08	; 8
    3224:	fc 01       	movw	r30, r24
    3226:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3228:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    322a:	80 ec       	ldi	r24, 0xC0	; 192
    322c:	98 e0       	ldi	r25, 0x08	; 8
    322e:	22 e0       	ldi	r18, 0x02	; 2
    3230:	fc 01       	movw	r30, r24
    3232:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3234:	00 00       	nop
    3236:	80 ec       	ldi	r24, 0xC0	; 192
    3238:	98 e0       	ldi	r25, 0x08	; 8
    323a:	fc 01       	movw	r30, r24
    323c:	82 81       	ldd	r24, Z+2	; 0x02
    323e:	88 23       	and	r24, r24
    3240:	d4 f7       	brge	.-12     	; 0x3236 <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    3242:	80 ec       	ldi	r24, 0xC0	; 192
    3244:	98 e0       	ldi	r25, 0x08	; 8
    3246:	fc 01       	movw	r30, r24
    3248:	83 81       	ldd	r24, Z+3	; 0x03
    324a:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    324e:	80 ec       	ldi	r24, 0xC0	; 192
    3250:	98 e0       	ldi	r25, 0x08	; 8
    3252:	20 91 51 40 	lds	r18, 0x4051
    3256:	fc 01       	movw	r30, r24
    3258:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    325a:	00 00       	nop
    325c:	80 ec       	ldi	r24, 0xC0	; 192
    325e:	98 e0       	ldi	r25, 0x08	; 8
    3260:	fc 01       	movw	r30, r24
    3262:	82 81       	ldd	r24, Z+2	; 0x02
    3264:	88 23       	and	r24, r24
    3266:	d4 f7       	brge	.-12     	; 0x325c <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    3268:	80 ec       	ldi	r24, 0xC0	; 192
    326a:	98 e0       	ldi	r25, 0x08	; 8
    326c:	fc 01       	movw	r30, r24
    326e:	83 81       	ldd	r24, Z+3	; 0x03
    3270:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    3274:	80 ec       	ldi	r24, 0xC0	; 192
    3276:	98 e0       	ldi	r25, 0x08	; 8
    3278:	20 e5       	ldi	r18, 0x50	; 80
    327a:	30 e4       	ldi	r19, 0x40	; 64
    327c:	f9 01       	movw	r30, r18
    327e:	20 81       	ld	r18, Z
    3280:	fc 01       	movw	r30, r24
    3282:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3284:	00 00       	nop
    3286:	80 ec       	ldi	r24, 0xC0	; 192
    3288:	98 e0       	ldi	r25, 0x08	; 8
    328a:	fc 01       	movw	r30, r24
    328c:	82 81       	ldd	r24, Z+2	; 0x02
    328e:	88 23       	and	r24, r24
    3290:	d4 f7       	brge	.-12     	; 0x3286 <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3292:	80 ec       	ldi	r24, 0xC0	; 192
    3294:	98 e0       	ldi	r25, 0x08	; 8
    3296:	fc 01       	movw	r30, r24
    3298:	83 81       	ldd	r24, Z+3	; 0x03
    329a:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[0];
    329e:	80 ec       	ldi	r24, 0xC0	; 192
    32a0:	98 e0       	ldi	r25, 0x08	; 8
    32a2:	20 91 66 50 	lds	r18, 0x5066
    32a6:	fc 01       	movw	r30, r24
    32a8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    32aa:	00 00       	nop
    32ac:	80 ec       	ldi	r24, 0xC0	; 192
    32ae:	98 e0       	ldi	r25, 0x08	; 8
    32b0:	fc 01       	movw	r30, r24
    32b2:	82 81       	ldd	r24, Z+2	; 0x02
    32b4:	88 23       	and	r24, r24
    32b6:	d4 f7       	brge	.-12     	; 0x32ac <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    32b8:	80 ec       	ldi	r24, 0xC0	; 192
    32ba:	98 e0       	ldi	r25, 0x08	; 8
    32bc:	fc 01       	movw	r30, r24
    32be:	83 81       	ldd	r24, Z+3	; 0x03
    32c0:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[1];
    32c4:	80 ec       	ldi	r24, 0xC0	; 192
    32c6:	98 e0       	ldi	r25, 0x08	; 8
    32c8:	20 91 67 50 	lds	r18, 0x5067
    32cc:	fc 01       	movw	r30, r24
    32ce:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    32d0:	00 00       	nop
    32d2:	80 ec       	ldi	r24, 0xC0	; 192
    32d4:	98 e0       	ldi	r25, 0x08	; 8
    32d6:	fc 01       	movw	r30, r24
    32d8:	82 81       	ldd	r24, Z+2	; 0x02
    32da:	88 23       	and	r24, r24
    32dc:	d4 f7       	brge	.-12     	; 0x32d2 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    32de:	80 ec       	ldi	r24, 0xC0	; 192
    32e0:	98 e0       	ldi	r25, 0x08	; 8
    32e2:	fc 01       	movw	r30, r24
    32e4:	83 81       	ldd	r24, Z+3	; 0x03
    32e6:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[2];
    32ea:	80 ec       	ldi	r24, 0xC0	; 192
    32ec:	98 e0       	ldi	r25, 0x08	; 8
    32ee:	20 91 68 50 	lds	r18, 0x5068
    32f2:	fc 01       	movw	r30, r24
    32f4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    32f6:	00 00       	nop
    32f8:	80 ec       	ldi	r24, 0xC0	; 192
    32fa:	98 e0       	ldi	r25, 0x08	; 8
    32fc:	fc 01       	movw	r30, r24
    32fe:	82 81       	ldd	r24, Z+2	; 0x02
    3300:	88 23       	and	r24, r24
    3302:	d4 f7       	brge	.-12     	; 0x32f8 <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    3304:	80 ec       	ldi	r24, 0xC0	; 192
    3306:	98 e0       	ldi	r25, 0x08	; 8
    3308:	fc 01       	movw	r30, r24
    330a:	83 81       	ldd	r24, Z+3	; 0x03
    330c:	80 93 72 50 	sts	0x5072, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3310:	80 e2       	ldi	r24, 0x20	; 32
    3312:	96 e0       	ldi	r25, 0x06	; 6
    3314:	28 e0       	ldi	r18, 0x08	; 8
    3316:	fc 01       	movw	r30, r24
    3318:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    331a:	80 e4       	ldi	r24, 0x40	; 64
    331c:	96 e0       	ldi	r25, 0x06	; 6
    331e:	20 e1       	ldi	r18, 0x10	; 16
    3320:	fc 01       	movw	r30, r24
    3322:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    3324:	80 91 50 40 	lds	r24, 0x4050
    3328:	90 91 51 40 	lds	r25, 0x4051
    332c:	03 96       	adiw	r24, 0x03	; 3
    332e:	80 93 50 40 	sts	0x4050, r24
    3332:	90 93 51 40 	sts	0x4051, r25
		checksumADC[0] += SPIBuffer[0];
    3336:	90 91 32 21 	lds	r25, 0x2132
    333a:	80 91 66 50 	lds	r24, 0x5066
    333e:	89 0f       	add	r24, r25
    3340:	80 93 32 21 	sts	0x2132, r24
		checksumADC[1] += SPIBuffer[1];
    3344:	90 91 33 21 	lds	r25, 0x2133
    3348:	80 91 67 50 	lds	r24, 0x5067
    334c:	89 0f       	add	r24, r25
    334e:	80 93 33 21 	sts	0x2133, r24
		checksumADC[2] += SPIBuffer[2];
    3352:	90 91 34 21 	lds	r25, 0x2134
    3356:	80 91 68 50 	lds	r24, 0x5068
    335a:	89 0f       	add	r24, r25
    335c:	80 93 34 21 	sts	0x2134, r24
		
		sampleCount++;
    3360:	80 91 75 50 	lds	r24, 0x5075
    3364:	90 91 76 50 	lds	r25, 0x5076
    3368:	a0 91 77 50 	lds	r26, 0x5077
    336c:	b0 91 78 50 	lds	r27, 0x5078
    3370:	01 96       	adiw	r24, 0x01	; 1
    3372:	a1 1d       	adc	r26, r1
    3374:	b1 1d       	adc	r27, r1
    3376:	80 93 75 50 	sts	0x5075, r24
    337a:	90 93 76 50 	sts	0x5076, r25
    337e:	a0 93 77 50 	sts	0x5077, r26
    3382:	b0 93 78 50 	sts	0x5078, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3386:	80 91 75 50 	lds	r24, 0x5075
    338a:	90 91 76 50 	lds	r25, 0x5076
    338e:	a0 91 77 50 	lds	r26, 0x5077
    3392:	b0 91 78 50 	lds	r27, 0x5078
    3396:	83 35       	cpi	r24, 0x53	; 83
    3398:	f5 e5       	ldi	r31, 0x55	; 85
    339a:	9f 07       	cpc	r25, r31
    339c:	f0 e0       	ldi	r31, 0x00	; 0
    339e:	af 07       	cpc	r26, r31
    33a0:	f0 e0       	ldi	r31, 0x00	; 0
    33a2:	bf 07       	cpc	r27, r31
    33a4:	08 f4       	brcc	.+2      	; 0x33a8 <FRAMWriteKnowns+0x228>
    33a6:	18 cf       	rjmp	.-464    	; 0x31d8 <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    33a8:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	ADCPower(FALSE);
    33ac:	80 e0       	ldi	r24, 0x00	; 0
    33ae:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
}
    33b2:	df 91       	pop	r29
    33b4:	cf 91       	pop	r28
    33b6:	08 95       	ret

000033b8 <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    33b8:	cf 93       	push	r28
    33ba:	df 93       	push	r29
    33bc:	0f 92       	push	r0
    33be:	cd b7       	in	r28, 0x3d	; 61
    33c0:	de b7       	in	r29, 0x3e	; 62
    33c2:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    33c4:	89 81       	ldd	r24, Y+1	; 0x01
    33c6:	88 2f       	mov	r24, r24
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	81 70       	andi	r24, 0x01	; 1
    33cc:	90 70       	andi	r25, 0x00	; 0
    33ce:	88 23       	and	r24, r24
    33d0:	31 f0       	breq	.+12     	; 0x33de <setADCInput+0x26>
    33d2:	80 e0       	ldi	r24, 0x00	; 0
    33d4:	96 e0       	ldi	r25, 0x06	; 6
    33d6:	20 e4       	ldi	r18, 0x40	; 64
    33d8:	fc 01       	movw	r30, r24
    33da:	25 83       	std	Z+5, r18	; 0x05
    33dc:	05 c0       	rjmp	.+10     	; 0x33e8 <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    33de:	80 e0       	ldi	r24, 0x00	; 0
    33e0:	96 e0       	ldi	r25, 0x06	; 6
    33e2:	20 e4       	ldi	r18, 0x40	; 64
    33e4:	fc 01       	movw	r30, r24
    33e6:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    33e8:	89 81       	ldd	r24, Y+1	; 0x01
    33ea:	88 2f       	mov	r24, r24
    33ec:	90 e0       	ldi	r25, 0x00	; 0
    33ee:	82 70       	andi	r24, 0x02	; 2
    33f0:	90 70       	andi	r25, 0x00	; 0
    33f2:	00 97       	sbiw	r24, 0x00	; 0
    33f4:	31 f0       	breq	.+12     	; 0x3402 <setADCInput+0x4a>
    33f6:	80 e2       	ldi	r24, 0x20	; 32
    33f8:	96 e0       	ldi	r25, 0x06	; 6
    33fa:	22 e0       	ldi	r18, 0x02	; 2
    33fc:	fc 01       	movw	r30, r24
    33fe:	25 83       	std	Z+5, r18	; 0x05
    3400:	05 c0       	rjmp	.+10     	; 0x340c <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3402:	80 e2       	ldi	r24, 0x20	; 32
    3404:	96 e0       	ldi	r25, 0x06	; 6
    3406:	22 e0       	ldi	r18, 0x02	; 2
    3408:	fc 01       	movw	r30, r24
    340a:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    340c:	89 81       	ldd	r24, Y+1	; 0x01
    340e:	88 2f       	mov	r24, r24
    3410:	90 e0       	ldi	r25, 0x00	; 0
    3412:	84 70       	andi	r24, 0x04	; 4
    3414:	90 70       	andi	r25, 0x00	; 0
    3416:	00 97       	sbiw	r24, 0x00	; 0
    3418:	31 f0       	breq	.+12     	; 0x3426 <setADCInput+0x6e>
    341a:	80 e2       	ldi	r24, 0x20	; 32
    341c:	96 e0       	ldi	r25, 0x06	; 6
    341e:	24 e0       	ldi	r18, 0x04	; 4
    3420:	fc 01       	movw	r30, r24
    3422:	25 83       	std	Z+5, r18	; 0x05
    3424:	05 c0       	rjmp	.+10     	; 0x3430 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    3426:	80 e2       	ldi	r24, 0x20	; 32
    3428:	96 e0       	ldi	r25, 0x06	; 6
    342a:	24 e0       	ldi	r18, 0x04	; 4
    342c:	fc 01       	movw	r30, r24
    342e:	26 83       	std	Z+6, r18	; 0x06

}
    3430:	0f 90       	pop	r0
    3432:	df 91       	pop	r29
    3434:	cf 91       	pop	r28
    3436:	08 95       	ret

00003438 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    3438:	cf 93       	push	r28
    343a:	df 93       	push	r29
    343c:	0f 92       	push	r0
    343e:	0f 92       	push	r0
    3440:	cd b7       	in	r28, 0x3d	; 61
    3442:	de b7       	in	r29, 0x3e	; 62
    3444:	89 83       	std	Y+1, r24	; 0x01
    3446:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    3448:	89 81       	ldd	r24, Y+1	; 0x01
    344a:	9a 81       	ldd	r25, Y+2	; 0x02
    344c:	22 e0       	ldi	r18, 0x02	; 2
    344e:	80 30       	cpi	r24, 0x00	; 0
    3450:	92 07       	cpc	r25, r18
    3452:	89 f4       	brne	.+34     	; 0x3476 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3454:	80 e2       	ldi	r24, 0x20	; 32
    3456:	0e 94 99 1d 	call	0x3b32	; 0x3b32 <SP_ReadCalibrationByte>
    345a:	28 2f       	mov	r18, r24
    345c:	89 81       	ldd	r24, Y+1	; 0x01
    345e:	9a 81       	ldd	r25, Y+2	; 0x02
    3460:	fc 01       	movw	r30, r24
    3462:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3464:	81 e2       	ldi	r24, 0x21	; 33
    3466:	0e 94 99 1d 	call	0x3b32	; 0x3b32 <SP_ReadCalibrationByte>
    346a:	28 2f       	mov	r18, r24
    346c:	89 81       	ldd	r24, Y+1	; 0x01
    346e:	9a 81       	ldd	r25, Y+2	; 0x02
    3470:	fc 01       	movw	r30, r24
    3472:	25 87       	std	Z+13, r18	; 0x0d
    3474:	10 c0       	rjmp	.+32     	; 0x3496 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3476:	84 e2       	ldi	r24, 0x24	; 36
    3478:	0e 94 99 1d 	call	0x3b32	; 0x3b32 <SP_ReadCalibrationByte>
    347c:	28 2f       	mov	r18, r24
    347e:	89 81       	ldd	r24, Y+1	; 0x01
    3480:	9a 81       	ldd	r25, Y+2	; 0x02
    3482:	fc 01       	movw	r30, r24
    3484:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3486:	85 e2       	ldi	r24, 0x25	; 37
    3488:	0e 94 99 1d 	call	0x3b32	; 0x3b32 <SP_ReadCalibrationByte>
    348c:	28 2f       	mov	r18, r24
    348e:	89 81       	ldd	r24, Y+1	; 0x01
    3490:	9a 81       	ldd	r25, Y+2	; 0x02
    3492:	fc 01       	movw	r30, r24
    3494:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3496:	0f 90       	pop	r0
    3498:	0f 90       	pop	r0
    349a:	df 91       	pop	r29
    349c:	cf 91       	pop	r28
    349e:	08 95       	ret

000034a0 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    34a0:	cf 93       	push	r28
    34a2:	df 93       	push	r29
    34a4:	cd b7       	in	r28, 0x3d	; 61
    34a6:	de b7       	in	r29, 0x3e	; 62
    34a8:	25 97       	sbiw	r28, 0x05	; 5
    34aa:	cd bf       	out	0x3d, r28	; 61
    34ac:	de bf       	out	0x3e, r29	; 62
    34ae:	8b 83       	std	Y+3, r24	; 0x03
    34b0:	9c 83       	std	Y+4, r25	; 0x04
    34b2:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    34b4:	8b 81       	ldd	r24, Y+3	; 0x03
    34b6:	9c 81       	ldd	r25, Y+4	; 0x04
    34b8:	21 e0       	ldi	r18, 0x01	; 1
    34ba:	fc 01       	movw	r30, r24
    34bc:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    34be:	8b 81       	ldd	r24, Y+3	; 0x03
    34c0:	9c 81       	ldd	r25, Y+4	; 0x04
    34c2:	fc 01       	movw	r30, r24
    34c4:	24 81       	ldd	r18, Z+4	; 0x04
    34c6:	35 81       	ldd	r19, Z+5	; 0x05
    34c8:	8d 81       	ldd	r24, Y+5	; 0x05
    34ca:	88 2f       	mov	r24, r24
    34cc:	90 e0       	ldi	r25, 0x00	; 0
    34ce:	a9 01       	movw	r20, r18
    34d0:	48 1b       	sub	r20, r24
    34d2:	59 0b       	sbc	r21, r25
    34d4:	ca 01       	movw	r24, r20
    34d6:	89 83       	std	Y+1, r24	; 0x01
    34d8:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    34da:	89 81       	ldd	r24, Y+1	; 0x01
    34dc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    34de:	25 96       	adiw	r28, 0x05	; 5
    34e0:	cd bf       	out	0x3d, r28	; 61
    34e2:	de bf       	out	0x3e, r29	; 62
    34e4:	df 91       	pop	r29
    34e6:	cf 91       	pop	r28
    34e8:	08 95       	ret

000034ea <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    34ea:	cf 93       	push	r28
    34ec:	df 93       	push	r29
    34ee:	cd b7       	in	r28, 0x3d	; 61
    34f0:	de b7       	in	r29, 0x3e	; 62
    34f2:	25 97       	sbiw	r28, 0x05	; 5
    34f4:	cd bf       	out	0x3d, r28	; 61
    34f6:	de bf       	out	0x3e, r29	; 62
    34f8:	8b 83       	std	Y+3, r24	; 0x03
    34fa:	9c 83       	std	Y+4, r25	; 0x04
    34fc:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    34fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3500:	9c 81       	ldd	r25, Y+4	; 0x04
    3502:	21 e0       	ldi	r18, 0x01	; 1
    3504:	fc 01       	movw	r30, r24
    3506:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3508:	8b 81       	ldd	r24, Y+3	; 0x03
    350a:	9c 81       	ldd	r25, Y+4	; 0x04
    350c:	fc 01       	movw	r30, r24
    350e:	24 81       	ldd	r18, Z+4	; 0x04
    3510:	35 81       	ldd	r19, Z+5	; 0x05
    3512:	8d 81       	ldd	r24, Y+5	; 0x05
    3514:	99 27       	eor	r25, r25
    3516:	87 fd       	sbrc	r24, 7
    3518:	90 95       	com	r25
    351a:	a9 01       	movw	r20, r18
    351c:	48 1b       	sub	r20, r24
    351e:	59 0b       	sbc	r21, r25
    3520:	ca 01       	movw	r24, r20
    3522:	89 83       	std	Y+1, r24	; 0x01
    3524:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3526:	89 81       	ldd	r24, Y+1	; 0x01
    3528:	9a 81       	ldd	r25, Y+2	; 0x02
}
    352a:	25 96       	adiw	r28, 0x05	; 5
    352c:	cd bf       	out	0x3d, r28	; 61
    352e:	de bf       	out	0x3e, r29	; 62
    3530:	df 91       	pop	r29
    3532:	cf 91       	pop	r28
    3534:	08 95       	ret

00003536 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3536:	cf 93       	push	r28
    3538:	df 93       	push	r29
    353a:	0f 92       	push	r0
    353c:	0f 92       	push	r0
    353e:	cd b7       	in	r28, 0x3d	; 61
    3540:	de b7       	in	r29, 0x3e	; 62
    3542:	89 83       	std	Y+1, r24	; 0x01
    3544:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3546:	89 81       	ldd	r24, Y+1	; 0x01
    3548:	9a 81       	ldd	r25, Y+2	; 0x02
    354a:	21 e0       	ldi	r18, 0x01	; 1
    354c:	fc 01       	movw	r30, r24
    354e:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3550:	89 81       	ldd	r24, Y+1	; 0x01
    3552:	9a 81       	ldd	r25, Y+2	; 0x02
    3554:	fc 01       	movw	r30, r24
    3556:	84 81       	ldd	r24, Z+4	; 0x04
    3558:	95 81       	ldd	r25, Z+5	; 0x05
}
    355a:	0f 90       	pop	r0
    355c:	0f 90       	pop	r0
    355e:	df 91       	pop	r29
    3560:	cf 91       	pop	r28
    3562:	08 95       	ret

00003564 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3564:	cf 93       	push	r28
    3566:	df 93       	push	r29
    3568:	0f 92       	push	r0
    356a:	0f 92       	push	r0
    356c:	cd b7       	in	r28, 0x3d	; 61
    356e:	de b7       	in	r29, 0x3e	; 62
    3570:	89 83       	std	Y+1, r24	; 0x01
    3572:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3574:	89 81       	ldd	r24, Y+1	; 0x01
    3576:	9a 81       	ldd	r25, Y+2	; 0x02
    3578:	21 e0       	ldi	r18, 0x01	; 1
    357a:	fc 01       	movw	r30, r24
    357c:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    357e:	89 81       	ldd	r24, Y+1	; 0x01
    3580:	9a 81       	ldd	r25, Y+2	; 0x02
    3582:	fc 01       	movw	r30, r24
    3584:	84 81       	ldd	r24, Z+4	; 0x04
}
    3586:	0f 90       	pop	r0
    3588:	0f 90       	pop	r0
    358a:	df 91       	pop	r29
    358c:	cf 91       	pop	r28
    358e:	08 95       	ret

00003590 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3590:	cf 93       	push	r28
    3592:	df 93       	push	r29
    3594:	0f 92       	push	r0
    3596:	0f 92       	push	r0
    3598:	cd b7       	in	r28, 0x3d	; 61
    359a:	de b7       	in	r29, 0x3e	; 62
    359c:	89 83       	std	Y+1, r24	; 0x01
    359e:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    35a0:	89 81       	ldd	r24, Y+1	; 0x01
    35a2:	9a 81       	ldd	r25, Y+2	; 0x02
    35a4:	21 e0       	ldi	r18, 0x01	; 1
    35a6:	fc 01       	movw	r30, r24
    35a8:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    35aa:	89 81       	ldd	r24, Y+1	; 0x01
    35ac:	9a 81       	ldd	r25, Y+2	; 0x02
    35ae:	fc 01       	movw	r30, r24
    35b0:	85 81       	ldd	r24, Z+5	; 0x05
}
    35b2:	0f 90       	pop	r0
    35b4:	0f 90       	pop	r0
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
    35ba:	08 95       	ret

000035bc <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    35bc:	0f 93       	push	r16
    35be:	1f 93       	push	r17
    35c0:	cf 93       	push	r28
    35c2:	df 93       	push	r29
    35c4:	cd b7       	in	r28, 0x3d	; 61
    35c6:	de b7       	in	r29, 0x3e	; 62
    35c8:	6b 97       	sbiw	r28, 0x1b	; 27
    35ca:	cd bf       	out	0x3d, r28	; 61
    35cc:	de bf       	out	0x3e, r29	; 62
    35ce:	8a 8f       	std	Y+26, r24	; 0x1a
    35d0:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    35d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    35d4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    35d6:	fc 01       	movw	r30, r24
    35d8:	84 81       	ldd	r24, Z+4	; 0x04
    35da:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    35dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    35de:	9b 8d       	ldd	r25, Y+27	; 0x1b
    35e0:	fc 01       	movw	r30, r24
    35e2:	14 82       	std	Z+4, r1	; 0x04
    35e4:	80 e0       	ldi	r24, 0x00	; 0
    35e6:	90 e0       	ldi	r25, 0x00	; 0
    35e8:	a0 e8       	ldi	r26, 0x80	; 128
    35ea:	b2 e4       	ldi	r27, 0x42	; 66
    35ec:	8a 83       	std	Y+2, r24	; 0x02
    35ee:	9b 83       	std	Y+3, r25	; 0x03
    35f0:	ac 83       	std	Y+4, r26	; 0x04
    35f2:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    35f4:	6a 81       	ldd	r22, Y+2	; 0x02
    35f6:	7b 81       	ldd	r23, Y+3	; 0x03
    35f8:	8c 81       	ldd	r24, Y+4	; 0x04
    35fa:	9d 81       	ldd	r25, Y+5	; 0x05
    35fc:	2b ea       	ldi	r18, 0xAB	; 171
    35fe:	3a ea       	ldi	r19, 0xAA	; 170
    3600:	4a e2       	ldi	r20, 0x2A	; 42
    3602:	5f e3       	ldi	r21, 0x3F	; 63
    3604:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    3608:	dc 01       	movw	r26, r24
    360a:	cb 01       	movw	r24, r22
    360c:	8e 83       	std	Y+6, r24	; 0x06
    360e:	9f 83       	std	Y+7, r25	; 0x07
    3610:	a8 87       	std	Y+8, r26	; 0x08
    3612:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3614:	11 e0       	ldi	r17, 0x01	; 1
    3616:	6e 81       	ldd	r22, Y+6	; 0x06
    3618:	7f 81       	ldd	r23, Y+7	; 0x07
    361a:	88 85       	ldd	r24, Y+8	; 0x08
    361c:	99 85       	ldd	r25, Y+9	; 0x09
    361e:	20 e0       	ldi	r18, 0x00	; 0
    3620:	30 e0       	ldi	r19, 0x00	; 0
    3622:	40 e8       	ldi	r20, 0x80	; 128
    3624:	5f e3       	ldi	r21, 0x3F	; 63
    3626:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    362a:	88 23       	and	r24, r24
    362c:	0c f0       	brlt	.+2      	; 0x3630 <ADC_Wait_8MHz+0x74>
    362e:	10 e0       	ldi	r17, 0x00	; 0
    3630:	11 23       	and	r17, r17
    3632:	19 f0       	breq	.+6      	; 0x363a <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3634:	81 e0       	ldi	r24, 0x01	; 1
    3636:	8a 87       	std	Y+10, r24	; 0x0a
    3638:	a3 c0       	rjmp	.+326    	; 0x3780 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    363a:	11 e0       	ldi	r17, 0x01	; 1
    363c:	6e 81       	ldd	r22, Y+6	; 0x06
    363e:	7f 81       	ldd	r23, Y+7	; 0x07
    3640:	88 85       	ldd	r24, Y+8	; 0x08
    3642:	99 85       	ldd	r25, Y+9	; 0x09
    3644:	20 e0       	ldi	r18, 0x00	; 0
    3646:	30 e0       	ldi	r19, 0x00	; 0
    3648:	4f e7       	ldi	r20, 0x7F	; 127
    364a:	53 e4       	ldi	r21, 0x43	; 67
    364c:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    3650:	18 16       	cp	r1, r24
    3652:	0c f0       	brlt	.+2      	; 0x3656 <ADC_Wait_8MHz+0x9a>
    3654:	10 e0       	ldi	r17, 0x00	; 0
    3656:	11 23       	and	r17, r17
    3658:	09 f4       	brne	.+2      	; 0x365c <ADC_Wait_8MHz+0xa0>
    365a:	89 c0       	rjmp	.+274    	; 0x376e <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    365c:	6a 81       	ldd	r22, Y+2	; 0x02
    365e:	7b 81       	ldd	r23, Y+3	; 0x03
    3660:	8c 81       	ldd	r24, Y+4	; 0x04
    3662:	9d 81       	ldd	r25, Y+5	; 0x05
    3664:	20 e0       	ldi	r18, 0x00	; 0
    3666:	30 e0       	ldi	r19, 0x00	; 0
    3668:	4a e7       	ldi	r20, 0x7A	; 122
    366a:	54 e4       	ldi	r21, 0x44	; 68
    366c:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    3670:	dc 01       	movw	r26, r24
    3672:	cb 01       	movw	r24, r22
    3674:	8b 87       	std	Y+11, r24	; 0x0b
    3676:	9c 87       	std	Y+12, r25	; 0x0c
    3678:	ad 87       	std	Y+13, r26	; 0x0d
    367a:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    367c:	6b 85       	ldd	r22, Y+11	; 0x0b
    367e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3680:	8d 85       	ldd	r24, Y+13	; 0x0d
    3682:	9e 85       	ldd	r25, Y+14	; 0x0e
    3684:	20 e0       	ldi	r18, 0x00	; 0
    3686:	30 e0       	ldi	r19, 0x00	; 0
    3688:	4a ef       	ldi	r20, 0xFA	; 250
    368a:	53 e4       	ldi	r21, 0x43	; 67
    368c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    3690:	dc 01       	movw	r26, r24
    3692:	cb 01       	movw	r24, r22
    3694:	8f 87       	std	Y+15, r24	; 0x0f
    3696:	98 8b       	std	Y+16, r25	; 0x10
    3698:	a9 8b       	std	Y+17, r26	; 0x11
    369a:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    369c:	11 e0       	ldi	r17, 0x01	; 1
    369e:	6f 85       	ldd	r22, Y+15	; 0x0f
    36a0:	78 89       	ldd	r23, Y+16	; 0x10
    36a2:	89 89       	ldd	r24, Y+17	; 0x11
    36a4:	9a 89       	ldd	r25, Y+18	; 0x12
    36a6:	20 e0       	ldi	r18, 0x00	; 0
    36a8:	30 e0       	ldi	r19, 0x00	; 0
    36aa:	40 e8       	ldi	r20, 0x80	; 128
    36ac:	5f e3       	ldi	r21, 0x3F	; 63
    36ae:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    36b2:	88 23       	and	r24, r24
    36b4:	0c f0       	brlt	.+2      	; 0x36b8 <ADC_Wait_8MHz+0xfc>
    36b6:	10 e0       	ldi	r17, 0x00	; 0
    36b8:	11 23       	and	r17, r17
    36ba:	29 f0       	breq	.+10     	; 0x36c6 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    36bc:	81 e0       	ldi	r24, 0x01	; 1
    36be:	90 e0       	ldi	r25, 0x00	; 0
    36c0:	8b 8b       	std	Y+19, r24	; 0x13
    36c2:	9c 8b       	std	Y+20, r25	; 0x14
    36c4:	46 c0       	rjmp	.+140    	; 0x3752 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    36c6:	11 e0       	ldi	r17, 0x01	; 1
    36c8:	6f 85       	ldd	r22, Y+15	; 0x0f
    36ca:	78 89       	ldd	r23, Y+16	; 0x10
    36cc:	89 89       	ldd	r24, Y+17	; 0x11
    36ce:	9a 89       	ldd	r25, Y+18	; 0x12
    36d0:	20 e0       	ldi	r18, 0x00	; 0
    36d2:	3f ef       	ldi	r19, 0xFF	; 255
    36d4:	4f e7       	ldi	r20, 0x7F	; 127
    36d6:	57 e4       	ldi	r21, 0x47	; 71
    36d8:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    36dc:	18 16       	cp	r1, r24
    36de:	0c f0       	brlt	.+2      	; 0x36e2 <ADC_Wait_8MHz+0x126>
    36e0:	10 e0       	ldi	r17, 0x00	; 0
    36e2:	11 23       	and	r17, r17
    36e4:	61 f1       	breq	.+88     	; 0x373e <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    36e6:	6b 85       	ldd	r22, Y+11	; 0x0b
    36e8:	7c 85       	ldd	r23, Y+12	; 0x0c
    36ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    36ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    36ee:	20 e0       	ldi	r18, 0x00	; 0
    36f0:	30 e0       	ldi	r19, 0x00	; 0
    36f2:	40 e2       	ldi	r20, 0x20	; 32
    36f4:	51 e4       	ldi	r21, 0x41	; 65
    36f6:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    36fa:	dc 01       	movw	r26, r24
    36fc:	cb 01       	movw	r24, r22
    36fe:	bc 01       	movw	r22, r24
    3700:	cd 01       	movw	r24, r26
    3702:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    3706:	dc 01       	movw	r26, r24
    3708:	cb 01       	movw	r24, r22
    370a:	8b 8b       	std	Y+19, r24	; 0x13
    370c:	9c 8b       	std	Y+20, r25	; 0x14
    370e:	12 c0       	rjmp	.+36     	; 0x3734 <ADC_Wait_8MHz+0x178>
    3710:	82 e3       	ldi	r24, 0x32	; 50
    3712:	90 e0       	ldi	r25, 0x00	; 0
    3714:	8d 8b       	std	Y+21, r24	; 0x15
    3716:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3718:	8d 89       	ldd	r24, Y+21	; 0x15
    371a:	9e 89       	ldd	r25, Y+22	; 0x16
    371c:	8c 01       	movw	r16, r24
    371e:	c8 01       	movw	r24, r16
    3720:	01 97       	sbiw	r24, 0x01	; 1
    3722:	f1 f7       	brne	.-4      	; 0x3720 <ADC_Wait_8MHz+0x164>
    3724:	8c 01       	movw	r16, r24
    3726:	0d 8b       	std	Y+21, r16	; 0x15
    3728:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    372a:	8b 89       	ldd	r24, Y+19	; 0x13
    372c:	9c 89       	ldd	r25, Y+20	; 0x14
    372e:	01 97       	sbiw	r24, 0x01	; 1
    3730:	8b 8b       	std	Y+19, r24	; 0x13
    3732:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3734:	8b 89       	ldd	r24, Y+19	; 0x13
    3736:	9c 89       	ldd	r25, Y+20	; 0x14
    3738:	00 97       	sbiw	r24, 0x00	; 0
    373a:	51 f7       	brne	.-44     	; 0x3710 <ADC_Wait_8MHz+0x154>
    373c:	28 c0       	rjmp	.+80     	; 0x378e <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    373e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3740:	78 89       	ldd	r23, Y+16	; 0x10
    3742:	89 89       	ldd	r24, Y+17	; 0x11
    3744:	9a 89       	ldd	r25, Y+18	; 0x12
    3746:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    374a:	dc 01       	movw	r26, r24
    374c:	cb 01       	movw	r24, r22
    374e:	8b 8b       	std	Y+19, r24	; 0x13
    3750:	9c 8b       	std	Y+20, r25	; 0x14
    3752:	8b 89       	ldd	r24, Y+19	; 0x13
    3754:	9c 89       	ldd	r25, Y+20	; 0x14
    3756:	8f 8b       	std	Y+23, r24	; 0x17
    3758:	98 8f       	std	Y+24, r25	; 0x18
    375a:	8f 89       	ldd	r24, Y+23	; 0x17
    375c:	98 8d       	ldd	r25, Y+24	; 0x18
    375e:	8c 01       	movw	r16, r24
    3760:	f8 01       	movw	r30, r16
    3762:	31 97       	sbiw	r30, 0x01	; 1
    3764:	f1 f7       	brne	.-4      	; 0x3762 <ADC_Wait_8MHz+0x1a6>
    3766:	8f 01       	movw	r16, r30
    3768:	0f 8b       	std	Y+23, r16	; 0x17
    376a:	18 8f       	std	Y+24, r17	; 0x18
    376c:	10 c0       	rjmp	.+32     	; 0x378e <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    376e:	6e 81       	ldd	r22, Y+6	; 0x06
    3770:	7f 81       	ldd	r23, Y+7	; 0x07
    3772:	88 85       	ldd	r24, Y+8	; 0x08
    3774:	99 85       	ldd	r25, Y+9	; 0x09
    3776:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    377a:	dc 01       	movw	r26, r24
    377c:	cb 01       	movw	r24, r22
    377e:	8a 87       	std	Y+10, r24	; 0x0a
    3780:	8a 85       	ldd	r24, Y+10	; 0x0a
    3782:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3784:	89 8d       	ldd	r24, Y+25	; 0x19
    3786:	18 2f       	mov	r17, r24
    3788:	1a 95       	dec	r17
    378a:	f1 f7       	brne	.-4      	; 0x3788 <ADC_Wait_8MHz+0x1cc>
    378c:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    378e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3790:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3792:	29 81       	ldd	r18, Y+1	; 0x01
    3794:	fc 01       	movw	r30, r24
    3796:	24 83       	std	Z+4, r18	; 0x04
}
    3798:	6b 96       	adiw	r28, 0x1b	; 27
    379a:	cd bf       	out	0x3d, r28	; 61
    379c:	de bf       	out	0x3e, r29	; 62
    379e:	df 91       	pop	r29
    37a0:	cf 91       	pop	r28
    37a2:	1f 91       	pop	r17
    37a4:	0f 91       	pop	r16
    37a6:	08 95       	ret

000037a8 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    37a8:	0f 93       	push	r16
    37aa:	1f 93       	push	r17
    37ac:	cf 93       	push	r28
    37ae:	df 93       	push	r29
    37b0:	cd b7       	in	r28, 0x3d	; 61
    37b2:	de b7       	in	r29, 0x3e	; 62
    37b4:	6b 97       	sbiw	r28, 0x1b	; 27
    37b6:	cd bf       	out	0x3d, r28	; 61
    37b8:	de bf       	out	0x3e, r29	; 62
    37ba:	8a 8f       	std	Y+26, r24	; 0x1a
    37bc:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    37be:	8a 8d       	ldd	r24, Y+26	; 0x1a
    37c0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    37c2:	fc 01       	movw	r30, r24
    37c4:	84 81       	ldd	r24, Z+4	; 0x04
    37c6:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    37c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    37ca:	9b 8d       	ldd	r25, Y+27	; 0x1b
    37cc:	21 e0       	ldi	r18, 0x01	; 1
    37ce:	fc 01       	movw	r30, r24
    37d0:	24 83       	std	Z+4, r18	; 0x04
    37d2:	80 e0       	ldi	r24, 0x00	; 0
    37d4:	90 e0       	ldi	r25, 0x00	; 0
    37d6:	a0 e0       	ldi	r26, 0x00	; 0
    37d8:	b3 e4       	ldi	r27, 0x43	; 67
    37da:	8a 83       	std	Y+2, r24	; 0x02
    37dc:	9b 83       	std	Y+3, r25	; 0x03
    37de:	ac 83       	std	Y+4, r26	; 0x04
    37e0:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    37e2:	6a 81       	ldd	r22, Y+2	; 0x02
    37e4:	7b 81       	ldd	r23, Y+3	; 0x03
    37e6:	8c 81       	ldd	r24, Y+4	; 0x04
    37e8:	9d 81       	ldd	r25, Y+5	; 0x05
    37ea:	2b ea       	ldi	r18, 0xAB	; 171
    37ec:	3a ea       	ldi	r19, 0xAA	; 170
    37ee:	4a e2       	ldi	r20, 0x2A	; 42
    37f0:	5f e3       	ldi	r21, 0x3F	; 63
    37f2:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    37f6:	dc 01       	movw	r26, r24
    37f8:	cb 01       	movw	r24, r22
    37fa:	8e 83       	std	Y+6, r24	; 0x06
    37fc:	9f 83       	std	Y+7, r25	; 0x07
    37fe:	a8 87       	std	Y+8, r26	; 0x08
    3800:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3802:	11 e0       	ldi	r17, 0x01	; 1
    3804:	6e 81       	ldd	r22, Y+6	; 0x06
    3806:	7f 81       	ldd	r23, Y+7	; 0x07
    3808:	88 85       	ldd	r24, Y+8	; 0x08
    380a:	99 85       	ldd	r25, Y+9	; 0x09
    380c:	20 e0       	ldi	r18, 0x00	; 0
    380e:	30 e0       	ldi	r19, 0x00	; 0
    3810:	40 e8       	ldi	r20, 0x80	; 128
    3812:	5f e3       	ldi	r21, 0x3F	; 63
    3814:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    3818:	88 23       	and	r24, r24
    381a:	0c f0       	brlt	.+2      	; 0x381e <ADC_Wait_32MHz+0x76>
    381c:	10 e0       	ldi	r17, 0x00	; 0
    381e:	11 23       	and	r17, r17
    3820:	19 f0       	breq	.+6      	; 0x3828 <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3822:	81 e0       	ldi	r24, 0x01	; 1
    3824:	8a 87       	std	Y+10, r24	; 0x0a
    3826:	a3 c0       	rjmp	.+326    	; 0x396e <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3828:	11 e0       	ldi	r17, 0x01	; 1
    382a:	6e 81       	ldd	r22, Y+6	; 0x06
    382c:	7f 81       	ldd	r23, Y+7	; 0x07
    382e:	88 85       	ldd	r24, Y+8	; 0x08
    3830:	99 85       	ldd	r25, Y+9	; 0x09
    3832:	20 e0       	ldi	r18, 0x00	; 0
    3834:	30 e0       	ldi	r19, 0x00	; 0
    3836:	4f e7       	ldi	r20, 0x7F	; 127
    3838:	53 e4       	ldi	r21, 0x43	; 67
    383a:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    383e:	18 16       	cp	r1, r24
    3840:	0c f0       	brlt	.+2      	; 0x3844 <ADC_Wait_32MHz+0x9c>
    3842:	10 e0       	ldi	r17, 0x00	; 0
    3844:	11 23       	and	r17, r17
    3846:	09 f4       	brne	.+2      	; 0x384a <ADC_Wait_32MHz+0xa2>
    3848:	89 c0       	rjmp	.+274    	; 0x395c <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    384a:	6a 81       	ldd	r22, Y+2	; 0x02
    384c:	7b 81       	ldd	r23, Y+3	; 0x03
    384e:	8c 81       	ldd	r24, Y+4	; 0x04
    3850:	9d 81       	ldd	r25, Y+5	; 0x05
    3852:	20 e0       	ldi	r18, 0x00	; 0
    3854:	30 e0       	ldi	r19, 0x00	; 0
    3856:	4a e7       	ldi	r20, 0x7A	; 122
    3858:	54 e4       	ldi	r21, 0x44	; 68
    385a:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    385e:	dc 01       	movw	r26, r24
    3860:	cb 01       	movw	r24, r22
    3862:	8b 87       	std	Y+11, r24	; 0x0b
    3864:	9c 87       	std	Y+12, r25	; 0x0c
    3866:	ad 87       	std	Y+13, r26	; 0x0d
    3868:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    386a:	6b 85       	ldd	r22, Y+11	; 0x0b
    386c:	7c 85       	ldd	r23, Y+12	; 0x0c
    386e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3870:	9e 85       	ldd	r25, Y+14	; 0x0e
    3872:	20 e0       	ldi	r18, 0x00	; 0
    3874:	30 e0       	ldi	r19, 0x00	; 0
    3876:	4a ef       	ldi	r20, 0xFA	; 250
    3878:	53 e4       	ldi	r21, 0x43	; 67
    387a:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    387e:	dc 01       	movw	r26, r24
    3880:	cb 01       	movw	r24, r22
    3882:	8f 87       	std	Y+15, r24	; 0x0f
    3884:	98 8b       	std	Y+16, r25	; 0x10
    3886:	a9 8b       	std	Y+17, r26	; 0x11
    3888:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    388a:	11 e0       	ldi	r17, 0x01	; 1
    388c:	6f 85       	ldd	r22, Y+15	; 0x0f
    388e:	78 89       	ldd	r23, Y+16	; 0x10
    3890:	89 89       	ldd	r24, Y+17	; 0x11
    3892:	9a 89       	ldd	r25, Y+18	; 0x12
    3894:	20 e0       	ldi	r18, 0x00	; 0
    3896:	30 e0       	ldi	r19, 0x00	; 0
    3898:	40 e8       	ldi	r20, 0x80	; 128
    389a:	5f e3       	ldi	r21, 0x3F	; 63
    389c:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    38a0:	88 23       	and	r24, r24
    38a2:	0c f0       	brlt	.+2      	; 0x38a6 <ADC_Wait_32MHz+0xfe>
    38a4:	10 e0       	ldi	r17, 0x00	; 0
    38a6:	11 23       	and	r17, r17
    38a8:	29 f0       	breq	.+10     	; 0x38b4 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    38aa:	81 e0       	ldi	r24, 0x01	; 1
    38ac:	90 e0       	ldi	r25, 0x00	; 0
    38ae:	8b 8b       	std	Y+19, r24	; 0x13
    38b0:	9c 8b       	std	Y+20, r25	; 0x14
    38b2:	46 c0       	rjmp	.+140    	; 0x3940 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    38b4:	11 e0       	ldi	r17, 0x01	; 1
    38b6:	6f 85       	ldd	r22, Y+15	; 0x0f
    38b8:	78 89       	ldd	r23, Y+16	; 0x10
    38ba:	89 89       	ldd	r24, Y+17	; 0x11
    38bc:	9a 89       	ldd	r25, Y+18	; 0x12
    38be:	20 e0       	ldi	r18, 0x00	; 0
    38c0:	3f ef       	ldi	r19, 0xFF	; 255
    38c2:	4f e7       	ldi	r20, 0x7F	; 127
    38c4:	57 e4       	ldi	r21, 0x47	; 71
    38c6:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    38ca:	18 16       	cp	r1, r24
    38cc:	0c f0       	brlt	.+2      	; 0x38d0 <ADC_Wait_32MHz+0x128>
    38ce:	10 e0       	ldi	r17, 0x00	; 0
    38d0:	11 23       	and	r17, r17
    38d2:	61 f1       	breq	.+88     	; 0x392c <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    38d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    38d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    38d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    38da:	9e 85       	ldd	r25, Y+14	; 0x0e
    38dc:	20 e0       	ldi	r18, 0x00	; 0
    38de:	30 e0       	ldi	r19, 0x00	; 0
    38e0:	40 e2       	ldi	r20, 0x20	; 32
    38e2:	51 e4       	ldi	r21, 0x41	; 65
    38e4:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    38e8:	dc 01       	movw	r26, r24
    38ea:	cb 01       	movw	r24, r22
    38ec:	bc 01       	movw	r22, r24
    38ee:	cd 01       	movw	r24, r26
    38f0:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    38f4:	dc 01       	movw	r26, r24
    38f6:	cb 01       	movw	r24, r22
    38f8:	8b 8b       	std	Y+19, r24	; 0x13
    38fa:	9c 8b       	std	Y+20, r25	; 0x14
    38fc:	12 c0       	rjmp	.+36     	; 0x3922 <ADC_Wait_32MHz+0x17a>
    38fe:	82 e3       	ldi	r24, 0x32	; 50
    3900:	90 e0       	ldi	r25, 0x00	; 0
    3902:	8d 8b       	std	Y+21, r24	; 0x15
    3904:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3906:	8d 89       	ldd	r24, Y+21	; 0x15
    3908:	9e 89       	ldd	r25, Y+22	; 0x16
    390a:	8c 01       	movw	r16, r24
    390c:	c8 01       	movw	r24, r16
    390e:	01 97       	sbiw	r24, 0x01	; 1
    3910:	f1 f7       	brne	.-4      	; 0x390e <ADC_Wait_32MHz+0x166>
    3912:	8c 01       	movw	r16, r24
    3914:	0d 8b       	std	Y+21, r16	; 0x15
    3916:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3918:	8b 89       	ldd	r24, Y+19	; 0x13
    391a:	9c 89       	ldd	r25, Y+20	; 0x14
    391c:	01 97       	sbiw	r24, 0x01	; 1
    391e:	8b 8b       	std	Y+19, r24	; 0x13
    3920:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3922:	8b 89       	ldd	r24, Y+19	; 0x13
    3924:	9c 89       	ldd	r25, Y+20	; 0x14
    3926:	00 97       	sbiw	r24, 0x00	; 0
    3928:	51 f7       	brne	.-44     	; 0x38fe <ADC_Wait_32MHz+0x156>
    392a:	28 c0       	rjmp	.+80     	; 0x397c <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    392c:	6f 85       	ldd	r22, Y+15	; 0x0f
    392e:	78 89       	ldd	r23, Y+16	; 0x10
    3930:	89 89       	ldd	r24, Y+17	; 0x11
    3932:	9a 89       	ldd	r25, Y+18	; 0x12
    3934:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    3938:	dc 01       	movw	r26, r24
    393a:	cb 01       	movw	r24, r22
    393c:	8b 8b       	std	Y+19, r24	; 0x13
    393e:	9c 8b       	std	Y+20, r25	; 0x14
    3940:	8b 89       	ldd	r24, Y+19	; 0x13
    3942:	9c 89       	ldd	r25, Y+20	; 0x14
    3944:	8f 8b       	std	Y+23, r24	; 0x17
    3946:	98 8f       	std	Y+24, r25	; 0x18
    3948:	8f 89       	ldd	r24, Y+23	; 0x17
    394a:	98 8d       	ldd	r25, Y+24	; 0x18
    394c:	8c 01       	movw	r16, r24
    394e:	f8 01       	movw	r30, r16
    3950:	31 97       	sbiw	r30, 0x01	; 1
    3952:	f1 f7       	brne	.-4      	; 0x3950 <ADC_Wait_32MHz+0x1a8>
    3954:	8f 01       	movw	r16, r30
    3956:	0f 8b       	std	Y+23, r16	; 0x17
    3958:	18 8f       	std	Y+24, r17	; 0x18
    395a:	10 c0       	rjmp	.+32     	; 0x397c <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    395c:	6e 81       	ldd	r22, Y+6	; 0x06
    395e:	7f 81       	ldd	r23, Y+7	; 0x07
    3960:	88 85       	ldd	r24, Y+8	; 0x08
    3962:	99 85       	ldd	r25, Y+9	; 0x09
    3964:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    3968:	dc 01       	movw	r26, r24
    396a:	cb 01       	movw	r24, r22
    396c:	8a 87       	std	Y+10, r24	; 0x0a
    396e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3970:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3972:	89 8d       	ldd	r24, Y+25	; 0x19
    3974:	18 2f       	mov	r17, r24
    3976:	1a 95       	dec	r17
    3978:	f1 f7       	brne	.-4      	; 0x3976 <ADC_Wait_32MHz+0x1ce>
    397a:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    397c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    397e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3980:	29 81       	ldd	r18, Y+1	; 0x01
    3982:	fc 01       	movw	r30, r24
    3984:	24 83       	std	Z+4, r18	; 0x04
}
    3986:	6b 96       	adiw	r28, 0x1b	; 27
    3988:	cd bf       	out	0x3d, r28	; 61
    398a:	de bf       	out	0x3e, r29	; 62
    398c:	df 91       	pop	r29
    398e:	cf 91       	pop	r28
    3990:	1f 91       	pop	r17
    3992:	0f 91       	pop	r16
    3994:	08 95       	ret

00003996 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3996:	cf 93       	push	r28
    3998:	df 93       	push	r29
    399a:	cd b7       	in	r28, 0x3d	; 61
    399c:	de b7       	in	r29, 0x3e	; 62
    399e:	2a 97       	sbiw	r28, 0x0a	; 10
    39a0:	cd bf       	out	0x3d, r28	; 61
    39a2:	de bf       	out	0x3e, r29	; 62
    39a4:	8e 83       	std	Y+6, r24	; 0x06
    39a6:	9f 83       	std	Y+7, r25	; 0x07
    39a8:	68 87       	std	Y+8, r22	; 0x08
    39aa:	79 87       	std	Y+9, r23	; 0x09
    39ac:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    39ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    39b0:	88 23       	and	r24, r24
    39b2:	a9 f1       	breq	.+106    	; 0x3a1e <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    39b4:	19 82       	std	Y+1, r1	; 0x01
    39b6:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    39b8:	1b 82       	std	Y+3, r1	; 0x03
    39ba:	1c 82       	std	Y+4, r1	; 0x04
    39bc:	24 c0       	rjmp	.+72     	; 0x3a06 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    39be:	88 85       	ldd	r24, Y+8	; 0x08
    39c0:	99 85       	ldd	r25, Y+9	; 0x09
    39c2:	fc 01       	movw	r30, r24
    39c4:	80 81       	ld	r24, Z
    39c6:	28 2f       	mov	r18, r24
    39c8:	20 68       	ori	r18, 0x80	; 128
    39ca:	88 85       	ldd	r24, Y+8	; 0x08
    39cc:	99 85       	ldd	r25, Y+9	; 0x09
    39ce:	fc 01       	movw	r30, r24
    39d0:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    39d2:	88 85       	ldd	r24, Y+8	; 0x08
    39d4:	99 85       	ldd	r25, Y+9	; 0x09
    39d6:	fc 01       	movw	r30, r24
    39d8:	83 81       	ldd	r24, Z+3	; 0x03
    39da:	88 2f       	mov	r24, r24
    39dc:	90 e0       	ldi	r25, 0x00	; 0
    39de:	81 70       	andi	r24, 0x01	; 1
    39e0:	90 70       	andi	r25, 0x00	; 0
    39e2:	00 97       	sbiw	r24, 0x00	; 0
    39e4:	b1 f3       	breq	.-20     	; 0x39d2 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    39e6:	88 85       	ldd	r24, Y+8	; 0x08
    39e8:	99 85       	ldd	r25, Y+9	; 0x09
    39ea:	60 e0       	ldi	r22, 0x00	; 0
    39ec:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <ADC_ResultCh_GetWord_Unsigned>
    39f0:	29 81       	ldd	r18, Y+1	; 0x01
    39f2:	3a 81       	ldd	r19, Y+2	; 0x02
    39f4:	82 0f       	add	r24, r18
    39f6:	93 1f       	adc	r25, r19
    39f8:	89 83       	std	Y+1, r24	; 0x01
    39fa:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    39fc:	8b 81       	ldd	r24, Y+3	; 0x03
    39fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3a00:	01 96       	adiw	r24, 0x01	; 1
    3a02:	8b 83       	std	Y+3, r24	; 0x03
    3a04:	9c 83       	std	Y+4, r25	; 0x04
    3a06:	8b 81       	ldd	r24, Y+3	; 0x03
    3a08:	9c 81       	ldd	r25, Y+4	; 0x04
    3a0a:	84 30       	cpi	r24, 0x04	; 4
    3a0c:	91 05       	cpc	r25, r1
    3a0e:	bc f2       	brlt	.-82     	; 0x39be <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3a10:	89 81       	ldd	r24, Y+1	; 0x01
    3a12:	9a 81       	ldd	r25, Y+2	; 0x02
    3a14:	96 95       	lsr	r25
    3a16:	87 95       	ror	r24
    3a18:	96 95       	lsr	r25
    3a1a:	87 95       	ror	r24
    3a1c:	1b c0       	rjmp	.+54     	; 0x3a54 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3a1e:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3a20:	88 85       	ldd	r24, Y+8	; 0x08
    3a22:	99 85       	ldd	r25, Y+9	; 0x09
    3a24:	fc 01       	movw	r30, r24
    3a26:	80 81       	ld	r24, Z
    3a28:	28 2f       	mov	r18, r24
    3a2a:	20 68       	ori	r18, 0x80	; 128
    3a2c:	88 85       	ldd	r24, Y+8	; 0x08
    3a2e:	99 85       	ldd	r25, Y+9	; 0x09
    3a30:	fc 01       	movw	r30, r24
    3a32:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3a34:	88 85       	ldd	r24, Y+8	; 0x08
    3a36:	99 85       	ldd	r25, Y+9	; 0x09
    3a38:	fc 01       	movw	r30, r24
    3a3a:	83 81       	ldd	r24, Z+3	; 0x03
    3a3c:	88 2f       	mov	r24, r24
    3a3e:	90 e0       	ldi	r25, 0x00	; 0
    3a40:	81 70       	andi	r24, 0x01	; 1
    3a42:	90 70       	andi	r25, 0x00	; 0
    3a44:	00 97       	sbiw	r24, 0x00	; 0
    3a46:	b1 f3       	breq	.-20     	; 0x3a34 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3a48:	88 85       	ldd	r24, Y+8	; 0x08
    3a4a:	99 85       	ldd	r25, Y+9	; 0x09
    3a4c:	0e 94 9b 1a 	call	0x3536	; 0x3536 <ADC_ResultCh_GetWord>
    3a50:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3a52:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3a54:	2a 96       	adiw	r28, 0x0a	; 10
    3a56:	cd bf       	out	0x3d, r28	; 61
    3a58:	de bf       	out	0x3e, r29	; 62
    3a5a:	df 91       	pop	r29
    3a5c:	cf 91       	pop	r28
    3a5e:	08 95       	ret

00003a60 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3a60:	cf 93       	push	r28
    3a62:	df 93       	push	r29
    3a64:	cd b7       	in	r28, 0x3d	; 61
    3a66:	de b7       	in	r29, 0x3e	; 62
    3a68:	2a 97       	sbiw	r28, 0x0a	; 10
    3a6a:	cd bf       	out	0x3d, r28	; 61
    3a6c:	de bf       	out	0x3e, r29	; 62
    3a6e:	8e 83       	std	Y+6, r24	; 0x06
    3a70:	9f 83       	std	Y+7, r25	; 0x07
    3a72:	68 87       	std	Y+8, r22	; 0x08
    3a74:	79 87       	std	Y+9, r23	; 0x09
    3a76:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3a78:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a7a:	88 23       	and	r24, r24
    3a7c:	c1 f1       	breq	.+112    	; 0x3aee <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3a7e:	19 82       	std	Y+1, r1	; 0x01
    3a80:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3a82:	1b 82       	std	Y+3, r1	; 0x03
    3a84:	1c 82       	std	Y+4, r1	; 0x04
    3a86:	24 c0       	rjmp	.+72     	; 0x3ad0 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3a88:	88 85       	ldd	r24, Y+8	; 0x08
    3a8a:	99 85       	ldd	r25, Y+9	; 0x09
    3a8c:	fc 01       	movw	r30, r24
    3a8e:	80 81       	ld	r24, Z
    3a90:	28 2f       	mov	r18, r24
    3a92:	20 68       	ori	r18, 0x80	; 128
    3a94:	88 85       	ldd	r24, Y+8	; 0x08
    3a96:	99 85       	ldd	r25, Y+9	; 0x09
    3a98:	fc 01       	movw	r30, r24
    3a9a:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3a9c:	88 85       	ldd	r24, Y+8	; 0x08
    3a9e:	99 85       	ldd	r25, Y+9	; 0x09
    3aa0:	fc 01       	movw	r30, r24
    3aa2:	83 81       	ldd	r24, Z+3	; 0x03
    3aa4:	88 2f       	mov	r24, r24
    3aa6:	90 e0       	ldi	r25, 0x00	; 0
    3aa8:	81 70       	andi	r24, 0x01	; 1
    3aaa:	90 70       	andi	r25, 0x00	; 0
    3aac:	00 97       	sbiw	r24, 0x00	; 0
    3aae:	b1 f3       	breq	.-20     	; 0x3a9c <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3ab0:	88 85       	ldd	r24, Y+8	; 0x08
    3ab2:	99 85       	ldd	r25, Y+9	; 0x09
    3ab4:	60 e0       	ldi	r22, 0x00	; 0
    3ab6:	0e 94 75 1a 	call	0x34ea	; 0x34ea <ADC_ResultCh_GetWord_Signed>
    3aba:	29 81       	ldd	r18, Y+1	; 0x01
    3abc:	3a 81       	ldd	r19, Y+2	; 0x02
    3abe:	82 0f       	add	r24, r18
    3ac0:	93 1f       	adc	r25, r19
    3ac2:	89 83       	std	Y+1, r24	; 0x01
    3ac4:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3ac6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac8:	9c 81       	ldd	r25, Y+4	; 0x04
    3aca:	01 96       	adiw	r24, 0x01	; 1
    3acc:	8b 83       	std	Y+3, r24	; 0x03
    3ace:	9c 83       	std	Y+4, r25	; 0x04
    3ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad4:	84 30       	cpi	r24, 0x04	; 4
    3ad6:	91 05       	cpc	r25, r1
    3ad8:	bc f2       	brlt	.-82     	; 0x3a88 <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3ada:	89 81       	ldd	r24, Y+1	; 0x01
    3adc:	9a 81       	ldd	r25, Y+2	; 0x02
    3ade:	99 23       	and	r25, r25
    3ae0:	0c f4       	brge	.+2      	; 0x3ae4 <ADC_Offset_Get_Signed+0x84>
    3ae2:	03 96       	adiw	r24, 0x03	; 3
    3ae4:	95 95       	asr	r25
    3ae6:	87 95       	ror	r24
    3ae8:	95 95       	asr	r25
    3aea:	87 95       	ror	r24
    3aec:	1c c0       	rjmp	.+56     	; 0x3b26 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3aee:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3af0:	88 85       	ldd	r24, Y+8	; 0x08
    3af2:	99 85       	ldd	r25, Y+9	; 0x09
    3af4:	fc 01       	movw	r30, r24
    3af6:	80 81       	ld	r24, Z
    3af8:	28 2f       	mov	r18, r24
    3afa:	20 68       	ori	r18, 0x80	; 128
    3afc:	88 85       	ldd	r24, Y+8	; 0x08
    3afe:	99 85       	ldd	r25, Y+9	; 0x09
    3b00:	fc 01       	movw	r30, r24
    3b02:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3b04:	88 85       	ldd	r24, Y+8	; 0x08
    3b06:	99 85       	ldd	r25, Y+9	; 0x09
    3b08:	fc 01       	movw	r30, r24
    3b0a:	83 81       	ldd	r24, Z+3	; 0x03
    3b0c:	88 2f       	mov	r24, r24
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
    3b10:	81 70       	andi	r24, 0x01	; 1
    3b12:	90 70       	andi	r25, 0x00	; 0
    3b14:	00 97       	sbiw	r24, 0x00	; 0
    3b16:	b1 f3       	breq	.-20     	; 0x3b04 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3b18:	88 85       	ldd	r24, Y+8	; 0x08
    3b1a:	99 85       	ldd	r25, Y+9	; 0x09
    3b1c:	60 e0       	ldi	r22, 0x00	; 0
    3b1e:	0e 94 75 1a 	call	0x34ea	; 0x34ea <ADC_ResultCh_GetWord_Signed>
    3b22:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3b24:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3b26:	2a 96       	adiw	r28, 0x0a	; 10
    3b28:	cd bf       	out	0x3d, r28	; 61
    3b2a:	de bf       	out	0x3e, r29	; 62
    3b2c:	df 91       	pop	r29
    3b2e:	cf 91       	pop	r28
    3b30:	08 95       	ret

00003b32 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3b32:	1f 93       	push	r17
    3b34:	cf 93       	push	r28
    3b36:	df 93       	push	r29
    3b38:	cd b7       	in	r28, 0x3d	; 61
    3b3a:	de b7       	in	r29, 0x3e	; 62
    3b3c:	25 97       	sbiw	r28, 0x05	; 5
    3b3e:	cd bf       	out	0x3d, r28	; 61
    3b40:	de bf       	out	0x3e, r29	; 62
    3b42:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3b44:	8a ec       	ldi	r24, 0xCA	; 202
    3b46:	91 e0       	ldi	r25, 0x01	; 1
    3b48:	22 e0       	ldi	r18, 0x02	; 2
    3b4a:	fc 01       	movw	r30, r24
    3b4c:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3b4e:	8d 81       	ldd	r24, Y+5	; 0x05
    3b50:	88 2f       	mov	r24, r24
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	89 83       	std	Y+1, r24	; 0x01
    3b56:	9a 83       	std	Y+2, r25	; 0x02
    3b58:	89 81       	ldd	r24, Y+1	; 0x01
    3b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b5c:	fc 01       	movw	r30, r24
    3b5e:	14 91       	lpm	r17, Z
    3b60:	1b 83       	std	Y+3, r17	; 0x03
    3b62:	8b 81       	ldd	r24, Y+3	; 0x03
    3b64:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3b66:	8a ec       	ldi	r24, 0xCA	; 202
    3b68:	91 e0       	ldi	r25, 0x01	; 1
    3b6a:	fc 01       	movw	r30, r24
    3b6c:	10 82       	st	Z, r1

	return result;
    3b6e:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3b70:	25 96       	adiw	r28, 0x05	; 5
    3b72:	cd bf       	out	0x3d, r28	; 61
    3b74:	de bf       	out	0x3e, r29	; 62
    3b76:	df 91       	pop	r29
    3b78:	cf 91       	pop	r28
    3b7a:	1f 91       	pop	r17
    3b7c:	08 95       	ret

00003b7e <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3b7e:	cf 93       	push	r28
    3b80:	df 93       	push	r29
    3b82:	cd b7       	in	r28, 0x3d	; 61
    3b84:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3b86:	24 e1       	ldi	r18, 0x14	; 20
    3b88:	88 e3       	ldi	r24, 0x38	; 56
    3b8a:	91 e2       	ldi	r25, 0x21	; 33
    3b8c:	fc 01       	movw	r30, r24
    3b8e:	32 2f       	mov	r19, r18
    3b90:	11 92       	st	Z+, r1
    3b92:	3a 95       	dec	r19
    3b94:	e9 f7       	brne	.-6      	; 0x3b90 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3b96:	0e 94 85 2b 	call	0x570a	; 0x570a <chb_get_short_addr>
    3b9a:	80 93 38 21 	sts	0x2138, r24
    3b9e:	90 93 39 21 	sts	0x2139, r25
    chb_drvr_init();
    3ba2:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <chb_drvr_init>
	radio_msg_received_int_enable();
    3ba6:	0e 94 d8 1d 	call	0x3bb0	; 0x3bb0 <radio_msg_received_int_enable>
}
    3baa:	df 91       	pop	r29
    3bac:	cf 91       	pop	r28
    3bae:	08 95       	ret

00003bb0 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    3bb0:	cf 93       	push	r28
    3bb2:	df 93       	push	r29
    3bb4:	cd b7       	in	r28, 0x3d	; 61
    3bb6:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    3bb8:	80 e8       	ldi	r24, 0x80	; 128
    3bba:	96 e0       	ldi	r25, 0x06	; 6
    3bbc:	24 e0       	ldi	r18, 0x04	; 4
    3bbe:	fc 01       	movw	r30, r24
    3bc0:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3bc2:	80 e8       	ldi	r24, 0x80	; 128
    3bc4:	96 e0       	ldi	r25, 0x06	; 6
    3bc6:	24 e0       	ldi	r18, 0x04	; 4
    3bc8:	fc 01       	movw	r30, r24
    3bca:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3bcc:	80 e8       	ldi	r24, 0x80	; 128
    3bce:	96 e0       	ldi	r25, 0x06	; 6
    3bd0:	22 e0       	ldi	r18, 0x02	; 2
    3bd2:	fc 01       	movw	r30, r24
    3bd4:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3bd6:	80 e8       	ldi	r24, 0x80	; 128
    3bd8:	96 e0       	ldi	r25, 0x06	; 6
    3bda:	24 e0       	ldi	r18, 0x04	; 4
    3bdc:	fc 01       	movw	r30, r24
    3bde:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3be0:	80 e8       	ldi	r24, 0x80	; 128
    3be2:	96 e0       	ldi	r25, 0x06	; 6
    3be4:	23 e0       	ldi	r18, 0x03	; 3
    3be6:	fc 01       	movw	r30, r24
    3be8:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3bea:	80 ea       	ldi	r24, 0xA0	; 160
    3bec:	90 e0       	ldi	r25, 0x00	; 0
    3bee:	20 ea       	ldi	r18, 0xA0	; 160
    3bf0:	30 e0       	ldi	r19, 0x00	; 0
    3bf2:	f9 01       	movw	r30, r18
    3bf4:	22 81       	ldd	r18, Z+2	; 0x02
    3bf6:	24 60       	ori	r18, 0x04	; 4
    3bf8:	fc 01       	movw	r30, r24
    3bfa:	22 83       	std	Z+2, r18	; 0x02
	sei();
    3bfc:	78 94       	sei
}
    3bfe:	df 91       	pop	r29
    3c00:	cf 91       	pop	r28
    3c02:	08 95       	ret

00003c04 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3c04:	cf 93       	push	r28
    3c06:	df 93       	push	r29
    3c08:	cd b7       	in	r28, 0x3d	; 61
    3c0a:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3c0c:	88 e3       	ldi	r24, 0x38	; 56
    3c0e:	91 e2       	ldi	r25, 0x21	; 33
}
    3c10:	df 91       	pop	r29
    3c12:	cf 91       	pop	r28
    3c14:	08 95       	ret

00003c16 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3c16:	cf 93       	push	r28
    3c18:	df 93       	push	r29
    3c1a:	cd b7       	in	r28, 0x3d	; 61
    3c1c:	de b7       	in	r29, 0x3e	; 62
    3c1e:	27 97       	sbiw	r28, 0x07	; 7
    3c20:	cd bf       	out	0x3d, r28	; 61
    3c22:	de bf       	out	0x3e, r29	; 62
    3c24:	8b 83       	std	Y+3, r24	; 0x03
    3c26:	9c 83       	std	Y+4, r25	; 0x04
    3c28:	6d 83       	std	Y+5, r22	; 0x05
    3c2a:	7e 83       	std	Y+6, r23	; 0x06
    3c2c:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c30:	9c 81       	ldd	r25, Y+4	; 0x04
    3c32:	89 83       	std	Y+1, r24	; 0x01
    3c34:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3c36:	8f 81       	ldd	r24, Y+7	; 0x07
    3c38:	28 2f       	mov	r18, r24
    3c3a:	25 5f       	subi	r18, 0xF5	; 245
    3c3c:	89 81       	ldd	r24, Y+1	; 0x01
    3c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c40:	fc 01       	movw	r30, r24
    3c42:	20 83       	st	Z, r18
    3c44:	89 81       	ldd	r24, Y+1	; 0x01
    3c46:	9a 81       	ldd	r25, Y+2	; 0x02
    3c48:	01 96       	adiw	r24, 0x01	; 1
    3c4a:	89 83       	std	Y+1, r24	; 0x01
    3c4c:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3c4e:	8d 81       	ldd	r24, Y+5	; 0x05
    3c50:	9e 81       	ldd	r25, Y+6	; 0x06
    3c52:	ff ef       	ldi	r31, 0xFF	; 255
    3c54:	8f 3f       	cpi	r24, 0xFF	; 255
    3c56:	9f 07       	cpc	r25, r31
    3c58:	11 f0       	breq	.+4      	; 0x3c5e <chb_gen_hdr+0x48>
    3c5a:	21 e6       	ldi	r18, 0x61	; 97
    3c5c:	01 c0       	rjmp	.+2      	; 0x3c60 <chb_gen_hdr+0x4a>
    3c5e:	21 e4       	ldi	r18, 0x41	; 65
    3c60:	89 81       	ldd	r24, Y+1	; 0x01
    3c62:	9a 81       	ldd	r25, Y+2	; 0x02
    3c64:	fc 01       	movw	r30, r24
    3c66:	20 83       	st	Z, r18
    3c68:	89 81       	ldd	r24, Y+1	; 0x01
    3c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c6c:	01 96       	adiw	r24, 0x01	; 1
    3c6e:	89 83       	std	Y+1, r24	; 0x01
    3c70:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3c72:	89 81       	ldd	r24, Y+1	; 0x01
    3c74:	9a 81       	ldd	r25, Y+2	; 0x02
    3c76:	28 e9       	ldi	r18, 0x98	; 152
    3c78:	fc 01       	movw	r30, r24
    3c7a:	20 83       	st	Z, r18
    3c7c:	89 81       	ldd	r24, Y+1	; 0x01
    3c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c80:	01 96       	adiw	r24, 0x01	; 1
    3c82:	89 83       	std	Y+1, r24	; 0x01
    3c84:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3c86:	20 91 3a 21 	lds	r18, 0x213A
    3c8a:	89 81       	ldd	r24, Y+1	; 0x01
    3c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c8e:	fc 01       	movw	r30, r24
    3c90:	20 83       	st	Z, r18
    3c92:	89 81       	ldd	r24, Y+1	; 0x01
    3c94:	9a 81       	ldd	r25, Y+2	; 0x02
    3c96:	01 96       	adiw	r24, 0x01	; 1
    3c98:	89 83       	std	Y+1, r24	; 0x01
    3c9a:	9a 83       	std	Y+2, r25	; 0x02
    3c9c:	82 2f       	mov	r24, r18
    3c9e:	8f 5f       	subi	r24, 0xFF	; 255
    3ca0:	80 93 3a 21 	sts	0x213A, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3ca4:	89 81       	ldd	r24, Y+1	; 0x01
    3ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca8:	24 e3       	ldi	r18, 0x34	; 52
    3caa:	32 e1       	ldi	r19, 0x12	; 18
    3cac:	fc 01       	movw	r30, r24
    3cae:	20 83       	st	Z, r18
    3cb0:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3cb2:	89 81       	ldd	r24, Y+1	; 0x01
    3cb4:	9a 81       	ldd	r25, Y+2	; 0x02
    3cb6:	02 96       	adiw	r24, 0x02	; 2
    3cb8:	89 83       	std	Y+1, r24	; 0x01
    3cba:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3cbc:	89 81       	ldd	r24, Y+1	; 0x01
    3cbe:	9a 81       	ldd	r25, Y+2	; 0x02
    3cc0:	2d 81       	ldd	r18, Y+5	; 0x05
    3cc2:	3e 81       	ldd	r19, Y+6	; 0x06
    3cc4:	fc 01       	movw	r30, r24
    3cc6:	20 83       	st	Z, r18
    3cc8:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3cca:	89 81       	ldd	r24, Y+1	; 0x01
    3ccc:	9a 81       	ldd	r25, Y+2	; 0x02
    3cce:	02 96       	adiw	r24, 0x02	; 2
    3cd0:	89 83       	std	Y+1, r24	; 0x01
    3cd2:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3cd4:	20 91 38 21 	lds	r18, 0x2138
    3cd8:	30 91 39 21 	lds	r19, 0x2139
    3cdc:	89 81       	ldd	r24, Y+1	; 0x01
    3cde:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce0:	fc 01       	movw	r30, r24
    3ce2:	20 83       	st	Z, r18
    3ce4:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3ce6:	89 81       	ldd	r24, Y+1	; 0x01
    3ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    3cea:	02 96       	adiw	r24, 0x02	; 2
    3cec:	89 83       	std	Y+1, r24	; 0x01
    3cee:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3cf0:	29 81       	ldd	r18, Y+1	; 0x01
    3cf2:	3a 81       	ldd	r19, Y+2	; 0x02
    3cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf8:	a9 01       	movw	r20, r18
    3cfa:	48 1b       	sub	r20, r24
    3cfc:	59 0b       	sbc	r21, r25
    3cfe:	ca 01       	movw	r24, r20
}
    3d00:	27 96       	adiw	r28, 0x07	; 7
    3d02:	cd bf       	out	0x3d, r28	; 61
    3d04:	de bf       	out	0x3e, r29	; 62
    3d06:	df 91       	pop	r29
    3d08:	cf 91       	pop	r28
    3d0a:	08 95       	ret

00003d0c <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3d0c:	ef 92       	push	r14
    3d0e:	ff 92       	push	r15
    3d10:	0f 93       	push	r16
    3d12:	1f 93       	push	r17
    3d14:	cf 93       	push	r28
    3d16:	df 93       	push	r29
    3d18:	cd b7       	in	r28, 0x3d	; 61
    3d1a:	de b7       	in	r29, 0x3e	; 62
    3d1c:	e0 97       	sbiw	r28, 0x30	; 48
    3d1e:	cd bf       	out	0x3d, r28	; 61
    3d20:	de bf       	out	0x3e, r29	; 62
    3d22:	89 a7       	lds	r24, 0x79
    3d24:	9a a7       	lds	r25, 0x7a
    3d26:	6b a7       	lds	r22, 0x7b
    3d28:	7c a7       	lds	r23, 0x7c
    3d2a:	2d a7       	lds	r18, 0x7d
    3d2c:	3e a7       	lds	r19, 0x7e
    3d2e:	4f a7       	lds	r20, 0x7f
    3d30:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    3d32:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3d34:	62 c1       	rjmp	.+708    	; 0x3ffa <chb_write+0x2ee>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3d36:	8d a5       	lds	r24, 0x6d
    3d38:	9e a5       	lds	r25, 0x6e
    3d3a:	af a5       	lds	r26, 0x6f
    3d3c:	b8 a9       	sts	0x48, r27
    3d3e:	85 36       	cpi	r24, 0x65	; 101
    3d40:	91 05       	cpc	r25, r1
    3d42:	a1 05       	cpc	r26, r1
    3d44:	b1 05       	cpc	r27, r1
    3d46:	20 f0       	brcs	.+8      	; 0x3d50 <chb_write+0x44>
    3d48:	84 e6       	ldi	r24, 0x64	; 100
    3d4a:	90 e0       	ldi	r25, 0x00	; 0
    3d4c:	a0 e0       	ldi	r26, 0x00	; 0
    3d4e:	b0 e0       	ldi	r27, 0x00	; 0
    3d50:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    3d52:	ce 01       	movw	r24, r28
    3d54:	4f 96       	adiw	r24, 0x1f	; 31
    3d56:	29 a5       	lds	r18, 0x69
    3d58:	3a a5       	lds	r19, 0x6a
    3d5a:	b9 01       	movw	r22, r18
    3d5c:	4c 81       	ldd	r20, Y+4	; 0x04
    3d5e:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <chb_gen_hdr>
    3d62:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    3d64:	1a 82       	std	Y+2, r1	; 0x02
    3d66:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3d68:	89 81       	ldd	r24, Y+1	; 0x01
    3d6a:	88 2f       	mov	r24, r24
    3d6c:	90 e0       	ldi	r25, 0x00	; 0
    3d6e:	2b a5       	lds	r18, 0x6b
    3d70:	3c a5       	lds	r19, 0x6c
    3d72:	28 0f       	add	r18, r24
    3d74:	39 1f       	adc	r19, r25
    3d76:	ce 01       	movw	r24, r28
    3d78:	4f 96       	adiw	r24, 0x1f	; 31
    3d7a:	b9 01       	movw	r22, r18
    3d7c:	4c 81       	ldd	r20, Y+4	; 0x04
    3d7e:	0e 94 9f 2b 	call	0x573e	; 0x573e <chb_tx>
    3d82:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    3d84:	8e 81       	ldd	r24, Y+6	; 0x06
    3d86:	88 2f       	mov	r24, r24
    3d88:	90 e0       	ldi	r25, 0x00	; 0
    3d8a:	83 30       	cpi	r24, 0x03	; 3
    3d8c:	91 05       	cpc	r25, r1
    3d8e:	31 f1       	breq	.+76     	; 0x3ddc <chb_write+0xd0>
    3d90:	84 30       	cpi	r24, 0x04	; 4
    3d92:	91 05       	cpc	r25, r1
    3d94:	24 f4       	brge	.+8      	; 0x3d9e <chb_write+0x92>
    3d96:	81 30       	cpi	r24, 0x01	; 1
    3d98:	91 05       	cpc	r25, r1
    3d9a:	39 f0       	breq	.+14     	; 0x3daa <chb_write+0x9e>
    3d9c:	2e c0       	rjmp	.+92     	; 0x3dfa <chb_write+0xee>
    3d9e:	85 30       	cpi	r24, 0x05	; 5
    3da0:	91 05       	cpc	r25, r1
    3da2:	69 f0       	breq	.+26     	; 0x3dbe <chb_write+0xb2>
    3da4:	80 34       	cpi	r24, 0x40	; 64
    3da6:	91 05       	cpc	r25, r1
    3da8:	41 f5       	brne	.+80     	; 0x3dfa <chb_write+0xee>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3daa:	80 91 3f 21 	lds	r24, 0x213F
    3dae:	90 91 40 21 	lds	r25, 0x2140
    3db2:	01 96       	adiw	r24, 0x01	; 1
    3db4:	80 93 3f 21 	sts	0x213F, r24
    3db8:	90 93 40 21 	sts	0x2140, r25
                 break;
    3dbc:	1f c0       	rjmp	.+62     	; 0x3dfc <chb_write+0xf0>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3dbe:	80 91 41 21 	lds	r24, 0x2141
    3dc2:	90 91 42 21 	lds	r25, 0x2142
    3dc6:	01 96       	adiw	r24, 0x01	; 1
    3dc8:	80 93 41 21 	sts	0x2141, r24
    3dcc:	90 93 42 21 	sts	0x2142, r25
				 rtry++;
    3dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd2:	9b 81       	ldd	r25, Y+3	; 0x03
    3dd4:	01 96       	adiw	r24, 0x01	; 1
    3dd6:	8a 83       	std	Y+2, r24	; 0x02
    3dd8:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3dda:	10 c0       	rjmp	.+32     	; 0x3dfc <chb_write+0xf0>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3ddc:	80 91 43 21 	lds	r24, 0x2143
    3de0:	90 91 44 21 	lds	r25, 0x2144
    3de4:	01 96       	adiw	r24, 0x01	; 1
    3de6:	80 93 43 21 	sts	0x2143, r24
    3dea:	90 93 44 21 	sts	0x2144, r25
				 rtry++;
    3dee:	8a 81       	ldd	r24, Y+2	; 0x02
    3df0:	9b 81       	ldd	r25, Y+3	; 0x03
    3df2:	01 96       	adiw	r24, 0x01	; 1
    3df4:	8a 83       	std	Y+2, r24	; 0x02
    3df6:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3df8:	01 c0       	rjmp	.+2      	; 0x3dfc <chb_write+0xf0>
 
             default:
                 break;
    3dfa:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    3dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dfe:	9b 81       	ldd	r25, Y+3	; 0x03
    3e00:	18 16       	cp	r1, r24
    3e02:	19 06       	cpc	r1, r25
    3e04:	0c f0       	brlt	.+2      	; 0x3e08 <chb_write+0xfc>
    3e06:	d5 c0       	rjmp	.+426    	; 0x3fb2 <chb_write+0x2a6>
    3e08:	80 e0       	ldi	r24, 0x00	; 0
    3e0a:	90 e0       	ldi	r25, 0x00	; 0
    3e0c:	a0 e2       	ldi	r26, 0x20	; 32
    3e0e:	b1 e4       	ldi	r27, 0x41	; 65
    3e10:	8f 83       	std	Y+7, r24	; 0x07
    3e12:	98 87       	std	Y+8, r25	; 0x08
    3e14:	a9 87       	std	Y+9, r26	; 0x09
    3e16:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3e18:	6f 81       	ldd	r22, Y+7	; 0x07
    3e1a:	78 85       	ldd	r23, Y+8	; 0x08
    3e1c:	89 85       	ldd	r24, Y+9	; 0x09
    3e1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e20:	2b ea       	ldi	r18, 0xAB	; 171
    3e22:	3a ea       	ldi	r19, 0xAA	; 170
    3e24:	4a ea       	ldi	r20, 0xAA	; 170
    3e26:	5e e3       	ldi	r21, 0x3E	; 62
    3e28:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    3e2c:	dc 01       	movw	r26, r24
    3e2e:	cb 01       	movw	r24, r22
    3e30:	8b 87       	std	Y+11, r24	; 0x0b
    3e32:	9c 87       	std	Y+12, r25	; 0x0c
    3e34:	ad 87       	std	Y+13, r26	; 0x0d
    3e36:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    3e38:	11 e0       	ldi	r17, 0x01	; 1
    3e3a:	6b 85       	ldd	r22, Y+11	; 0x0b
    3e3c:	7c 85       	ldd	r23, Y+12	; 0x0c
    3e3e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e40:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e42:	20 e0       	ldi	r18, 0x00	; 0
    3e44:	30 e0       	ldi	r19, 0x00	; 0
    3e46:	40 e8       	ldi	r20, 0x80	; 128
    3e48:	5f e3       	ldi	r21, 0x3F	; 63
    3e4a:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    3e4e:	88 23       	and	r24, r24
    3e50:	0c f0       	brlt	.+2      	; 0x3e54 <chb_write+0x148>
    3e52:	10 e0       	ldi	r17, 0x00	; 0
    3e54:	11 23       	and	r17, r17
    3e56:	19 f0       	breq	.+6      	; 0x3e5e <chb_write+0x152>
		__ticks = 1;
    3e58:	81 e0       	ldi	r24, 0x01	; 1
    3e5a:	8f 87       	std	Y+15, r24	; 0x0f
    3e5c:	a3 c0       	rjmp	.+326    	; 0x3fa4 <chb_write+0x298>
	else if (__tmp > 255)
    3e5e:	11 e0       	ldi	r17, 0x01	; 1
    3e60:	6b 85       	ldd	r22, Y+11	; 0x0b
    3e62:	7c 85       	ldd	r23, Y+12	; 0x0c
    3e64:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e66:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e68:	20 e0       	ldi	r18, 0x00	; 0
    3e6a:	30 e0       	ldi	r19, 0x00	; 0
    3e6c:	4f e7       	ldi	r20, 0x7F	; 127
    3e6e:	53 e4       	ldi	r21, 0x43	; 67
    3e70:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    3e74:	18 16       	cp	r1, r24
    3e76:	0c f0       	brlt	.+2      	; 0x3e7a <chb_write+0x16e>
    3e78:	10 e0       	ldi	r17, 0x00	; 0
    3e7a:	11 23       	and	r17, r17
    3e7c:	09 f4       	brne	.+2      	; 0x3e80 <chb_write+0x174>
    3e7e:	89 c0       	rjmp	.+274    	; 0x3f92 <chb_write+0x286>
	{
		_delay_ms(__us / 1000.0);
    3e80:	6f 81       	ldd	r22, Y+7	; 0x07
    3e82:	78 85       	ldd	r23, Y+8	; 0x08
    3e84:	89 85       	ldd	r24, Y+9	; 0x09
    3e86:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e88:	20 e0       	ldi	r18, 0x00	; 0
    3e8a:	30 e0       	ldi	r19, 0x00	; 0
    3e8c:	4a e7       	ldi	r20, 0x7A	; 122
    3e8e:	54 e4       	ldi	r21, 0x44	; 68
    3e90:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    3e94:	dc 01       	movw	r26, r24
    3e96:	cb 01       	movw	r24, r22
    3e98:	88 8b       	std	Y+16, r24	; 0x10
    3e9a:	99 8b       	std	Y+17, r25	; 0x11
    3e9c:	aa 8b       	std	Y+18, r26	; 0x12
    3e9e:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3ea0:	68 89       	ldd	r22, Y+16	; 0x10
    3ea2:	79 89       	ldd	r23, Y+17	; 0x11
    3ea4:	8a 89       	ldd	r24, Y+18	; 0x12
    3ea6:	9b 89       	ldd	r25, Y+19	; 0x13
    3ea8:	20 e0       	ldi	r18, 0x00	; 0
    3eaa:	30 e0       	ldi	r19, 0x00	; 0
    3eac:	4a e7       	ldi	r20, 0x7A	; 122
    3eae:	53 e4       	ldi	r21, 0x43	; 67
    3eb0:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    3eb4:	dc 01       	movw	r26, r24
    3eb6:	cb 01       	movw	r24, r22
    3eb8:	8c 8b       	std	Y+20, r24	; 0x14
    3eba:	9d 8b       	std	Y+21, r25	; 0x15
    3ebc:	ae 8b       	std	Y+22, r26	; 0x16
    3ebe:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    3ec0:	11 e0       	ldi	r17, 0x01	; 1
    3ec2:	6c 89       	ldd	r22, Y+20	; 0x14
    3ec4:	7d 89       	ldd	r23, Y+21	; 0x15
    3ec6:	8e 89       	ldd	r24, Y+22	; 0x16
    3ec8:	9f 89       	ldd	r25, Y+23	; 0x17
    3eca:	20 e0       	ldi	r18, 0x00	; 0
    3ecc:	30 e0       	ldi	r19, 0x00	; 0
    3ece:	40 e8       	ldi	r20, 0x80	; 128
    3ed0:	5f e3       	ldi	r21, 0x3F	; 63
    3ed2:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    3ed6:	88 23       	and	r24, r24
    3ed8:	0c f0       	brlt	.+2      	; 0x3edc <chb_write+0x1d0>
    3eda:	10 e0       	ldi	r17, 0x00	; 0
    3edc:	11 23       	and	r17, r17
    3ede:	29 f0       	breq	.+10     	; 0x3eea <chb_write+0x1de>
		__ticks = 1;
    3ee0:	81 e0       	ldi	r24, 0x01	; 1
    3ee2:	90 e0       	ldi	r25, 0x00	; 0
    3ee4:	88 8f       	std	Y+24, r24	; 0x18
    3ee6:	99 8f       	std	Y+25, r25	; 0x19
    3ee8:	46 c0       	rjmp	.+140    	; 0x3f76 <chb_write+0x26a>
	else if (__tmp > 65535)
    3eea:	11 e0       	ldi	r17, 0x01	; 1
    3eec:	6c 89       	ldd	r22, Y+20	; 0x14
    3eee:	7d 89       	ldd	r23, Y+21	; 0x15
    3ef0:	8e 89       	ldd	r24, Y+22	; 0x16
    3ef2:	9f 89       	ldd	r25, Y+23	; 0x17
    3ef4:	20 e0       	ldi	r18, 0x00	; 0
    3ef6:	3f ef       	ldi	r19, 0xFF	; 255
    3ef8:	4f e7       	ldi	r20, 0x7F	; 127
    3efa:	57 e4       	ldi	r21, 0x47	; 71
    3efc:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    3f00:	18 16       	cp	r1, r24
    3f02:	0c f0       	brlt	.+2      	; 0x3f06 <chb_write+0x1fa>
    3f04:	10 e0       	ldi	r17, 0x00	; 0
    3f06:	11 23       	and	r17, r17
    3f08:	61 f1       	breq	.+88     	; 0x3f62 <chb_write+0x256>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3f0a:	68 89       	ldd	r22, Y+16	; 0x10
    3f0c:	79 89       	ldd	r23, Y+17	; 0x11
    3f0e:	8a 89       	ldd	r24, Y+18	; 0x12
    3f10:	9b 89       	ldd	r25, Y+19	; 0x13
    3f12:	20 e0       	ldi	r18, 0x00	; 0
    3f14:	30 e0       	ldi	r19, 0x00	; 0
    3f16:	40 e2       	ldi	r20, 0x20	; 32
    3f18:	51 e4       	ldi	r21, 0x41	; 65
    3f1a:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    3f1e:	dc 01       	movw	r26, r24
    3f20:	cb 01       	movw	r24, r22
    3f22:	bc 01       	movw	r22, r24
    3f24:	cd 01       	movw	r24, r26
    3f26:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    3f2a:	dc 01       	movw	r26, r24
    3f2c:	cb 01       	movw	r24, r22
    3f2e:	88 8f       	std	Y+24, r24	; 0x18
    3f30:	99 8f       	std	Y+25, r25	; 0x19
    3f32:	12 c0       	rjmp	.+36     	; 0x3f58 <chb_write+0x24c>
    3f34:	89 e1       	ldi	r24, 0x19	; 25
    3f36:	90 e0       	ldi	r25, 0x00	; 0
    3f38:	8a 8f       	std	Y+26, r24	; 0x1a
    3f3a:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3f3c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3f3e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3f40:	8c 01       	movw	r16, r24
    3f42:	c8 01       	movw	r24, r16
    3f44:	01 97       	sbiw	r24, 0x01	; 1
    3f46:	f1 f7       	brne	.-4      	; 0x3f44 <chb_write+0x238>
    3f48:	8c 01       	movw	r16, r24
    3f4a:	0a 8f       	std	Y+26, r16	; 0x1a
    3f4c:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f4e:	88 8d       	ldd	r24, Y+24	; 0x18
    3f50:	99 8d       	ldd	r25, Y+25	; 0x19
    3f52:	01 97       	sbiw	r24, 0x01	; 1
    3f54:	88 8f       	std	Y+24, r24	; 0x18
    3f56:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f58:	88 8d       	ldd	r24, Y+24	; 0x18
    3f5a:	99 8d       	ldd	r25, Y+25	; 0x19
    3f5c:	00 97       	sbiw	r24, 0x00	; 0
    3f5e:	51 f7       	brne	.-44     	; 0x3f34 <chb_write+0x228>
    3f60:	28 c0       	rjmp	.+80     	; 0x3fb2 <chb_write+0x2a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f62:	6c 89       	ldd	r22, Y+20	; 0x14
    3f64:	7d 89       	ldd	r23, Y+21	; 0x15
    3f66:	8e 89       	ldd	r24, Y+22	; 0x16
    3f68:	9f 89       	ldd	r25, Y+23	; 0x17
    3f6a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    3f6e:	dc 01       	movw	r26, r24
    3f70:	cb 01       	movw	r24, r22
    3f72:	88 8f       	std	Y+24, r24	; 0x18
    3f74:	99 8f       	std	Y+25, r25	; 0x19
    3f76:	88 8d       	ldd	r24, Y+24	; 0x18
    3f78:	99 8d       	ldd	r25, Y+25	; 0x19
    3f7a:	8c 8f       	std	Y+28, r24	; 0x1c
    3f7c:	9d 8f       	std	Y+29, r25	; 0x1d
    3f7e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3f80:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3f82:	8c 01       	movw	r16, r24
    3f84:	c8 01       	movw	r24, r16
    3f86:	01 97       	sbiw	r24, 0x01	; 1
    3f88:	f1 f7       	brne	.-4      	; 0x3f86 <chb_write+0x27a>
    3f8a:	8c 01       	movw	r16, r24
    3f8c:	0c 8f       	std	Y+28, r16	; 0x1c
    3f8e:	1d 8f       	std	Y+29, r17	; 0x1d
    3f90:	10 c0       	rjmp	.+32     	; 0x3fb2 <chb_write+0x2a6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3f92:	6b 85       	ldd	r22, Y+11	; 0x0b
    3f94:	7c 85       	ldd	r23, Y+12	; 0x0c
    3f96:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f98:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f9a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    3f9e:	dc 01       	movw	r26, r24
    3fa0:	cb 01       	movw	r24, r22
    3fa2:	8f 87       	std	Y+15, r24	; 0x0f
    3fa4:	8f 85       	ldd	r24, Y+15	; 0x0f
    3fa6:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3fa8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3faa:	18 2f       	mov	r17, r24
    3fac:	1a 95       	dec	r17
    3fae:	f1 f7       	brne	.-4      	; 0x3fac <chb_write+0x2a0>
    3fb0:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    3fb2:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb4:	9b 81       	ldd	r25, Y+3	; 0x03
    3fb6:	84 31       	cpi	r24, 0x14	; 20
    3fb8:	91 05       	cpc	r25, r1
    3fba:	11 f4       	brne	.+4      	; 0x3fc0 <chb_write+0x2b4>
    3fbc:	8e 81       	ldd	r24, Y+6	; 0x06
    3fbe:	27 c0       	rjmp	.+78     	; 0x400e <chb_write+0x302>
		} while(status != CHB_SUCCESS);			
    3fc0:	8e 81       	ldd	r24, Y+6	; 0x06
    3fc2:	88 23       	and	r24, r24
    3fc4:	09 f0       	breq	.+2      	; 0x3fc8 <chb_write+0x2bc>
    3fc6:	d0 ce       	rjmp	.-608    	; 0x3d68 <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    3fc8:	99 81       	ldd	r25, Y+1	; 0x01
    3fca:	8c 81       	ldd	r24, Y+4	; 0x04
    3fcc:	89 0f       	add	r24, r25
    3fce:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    3fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    3fd2:	88 2f       	mov	r24, r24
    3fd4:	90 e0       	ldi	r25, 0x00	; 0
    3fd6:	a0 e0       	ldi	r26, 0x00	; 0
    3fd8:	b0 e0       	ldi	r27, 0x00	; 0
    3fda:	2d a5       	lds	r18, 0x6d
    3fdc:	3e a5       	lds	r19, 0x6e
    3fde:	4f a5       	lds	r20, 0x6f
    3fe0:	58 a9       	sts	0x48, r21
    3fe2:	79 01       	movw	r14, r18
    3fe4:	8a 01       	movw	r16, r20
    3fe6:	e8 1a       	sub	r14, r24
    3fe8:	f9 0a       	sbc	r15, r25
    3fea:	0a 0b       	sbc	r16, r26
    3fec:	1b 0b       	sbc	r17, r27
    3fee:	d8 01       	movw	r26, r16
    3ff0:	c7 01       	movw	r24, r14
    3ff2:	8d a7       	lds	r24, 0x7d
    3ff4:	9e a7       	lds	r25, 0x7e
    3ff6:	af a7       	lds	r26, 0x7f
    3ff8:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3ffa:	8d a5       	lds	r24, 0x6d
    3ffc:	9e a5       	lds	r25, 0x6e
    3ffe:	af a5       	lds	r26, 0x6f
    4000:	b8 a9       	sts	0x48, r27
    4002:	00 97       	sbiw	r24, 0x00	; 0
    4004:	a1 05       	cpc	r26, r1
    4006:	b1 05       	cpc	r27, r1
    4008:	09 f0       	breq	.+2      	; 0x400c <chb_write+0x300>
    400a:	95 ce       	rjmp	.-726    	; 0x3d36 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    400c:	80 e0       	ldi	r24, 0x00	; 0
}
    400e:	e0 96       	adiw	r28, 0x30	; 48
    4010:	cd bf       	out	0x3d, r28	; 61
    4012:	de bf       	out	0x3e, r29	; 62
    4014:	df 91       	pop	r29
    4016:	cf 91       	pop	r28
    4018:	1f 91       	pop	r17
    401a:	0f 91       	pop	r16
    401c:	ff 90       	pop	r15
    401e:	ef 90       	pop	r14
    4020:	08 95       	ret

00004022 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4022:	cf 93       	push	r28
    4024:	df 93       	push	r29
    4026:	cd b7       	in	r28, 0x3d	; 61
    4028:	de b7       	in	r29, 0x3e	; 62
    402a:	27 97       	sbiw	r28, 0x07	; 7
    402c:	cd bf       	out	0x3d, r28	; 61
    402e:	de bf       	out	0x3e, r29	; 62
    4030:	8e 83       	std	Y+6, r24	; 0x06
    4032:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    4034:	8e 81       	ldd	r24, Y+6	; 0x06
    4036:	9f 81       	ldd	r25, Y+7	; 0x07
    4038:	05 96       	adiw	r24, 0x05	; 5
    403a:	8a 83       	std	Y+2, r24	; 0x02
    403c:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    403e:	0e 94 de 20 	call	0x41bc	; 0x41bc <chb_buf_read>
    4042:	8c 83       	std	Y+4, r24	; 0x04
    4044:	8c 81       	ldd	r24, Y+4	; 0x04
    4046:	88 23       	and	r24, r24
    4048:	14 f4       	brge	.+4      	; 0x404e <chb_read+0x2c>
    {
        return 0;
    404a:	80 e0       	ldi	r24, 0x00	; 0
    404c:	80 c0       	rjmp	.+256    	; 0x414e <chb_read+0x12c>
    }
    *data_ptr++ = len;
    404e:	8a 81       	ldd	r24, Y+2	; 0x02
    4050:	9b 81       	ldd	r25, Y+3	; 0x03
    4052:	2c 81       	ldd	r18, Y+4	; 0x04
    4054:	fc 01       	movw	r30, r24
    4056:	20 83       	st	Z, r18
    4058:	8a 81       	ldd	r24, Y+2	; 0x02
    405a:	9b 81       	ldd	r25, Y+3	; 0x03
    405c:	01 96       	adiw	r24, 0x01	; 1
    405e:	8a 83       	std	Y+2, r24	; 0x02
    4060:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4062:	19 82       	std	Y+1, r1	; 0x01
    4064:	0f c0       	rjmp	.+30     	; 0x4084 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    4066:	0e 94 de 20 	call	0x41bc	; 0x41bc <chb_buf_read>
    406a:	28 2f       	mov	r18, r24
    406c:	8a 81       	ldd	r24, Y+2	; 0x02
    406e:	9b 81       	ldd	r25, Y+3	; 0x03
    4070:	fc 01       	movw	r30, r24
    4072:	20 83       	st	Z, r18
    4074:	8a 81       	ldd	r24, Y+2	; 0x02
    4076:	9b 81       	ldd	r25, Y+3	; 0x03
    4078:	01 96       	adiw	r24, 0x01	; 1
    407a:	8a 83       	std	Y+2, r24	; 0x02
    407c:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    407e:	89 81       	ldd	r24, Y+1	; 0x01
    4080:	8f 5f       	subi	r24, 0xFF	; 255
    4082:	89 83       	std	Y+1, r24	; 0x01
    4084:	99 81       	ldd	r25, Y+1	; 0x01
    4086:	8c 81       	ldd	r24, Y+4	; 0x04
    4088:	98 17       	cp	r25, r24
    408a:	68 f3       	brcs	.-38     	; 0x4066 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    408c:	8e 81       	ldd	r24, Y+6	; 0x06
    408e:	9f 81       	ldd	r25, Y+7	; 0x07
    4090:	08 96       	adiw	r24, 0x08	; 8
    4092:	8a 83       	std	Y+2, r24	; 0x02
    4094:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4096:	8a 81       	ldd	r24, Y+2	; 0x02
    4098:	9b 81       	ldd	r25, Y+3	; 0x03
    409a:	fc 01       	movw	r30, r24
    409c:	80 81       	ld	r24, Z
    409e:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    40a0:	8e 81       	ldd	r24, Y+6	; 0x06
    40a2:	9f 81       	ldd	r25, Y+7	; 0x07
    40a4:	0b 96       	adiw	r24, 0x0b	; 11
    40a6:	8a 83       	std	Y+2, r24	; 0x02
    40a8:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    40aa:	8a 81       	ldd	r24, Y+2	; 0x02
    40ac:	9b 81       	ldd	r25, Y+3	; 0x03
    40ae:	fc 01       	movw	r30, r24
    40b0:	20 81       	ld	r18, Z
    40b2:	31 81       	ldd	r19, Z+1	; 0x01
    40b4:	8e 81       	ldd	r24, Y+6	; 0x06
    40b6:	9f 81       	ldd	r25, Y+7	; 0x07
    40b8:	fc 01       	movw	r30, r24
    40ba:	23 83       	std	Z+3, r18	; 0x03
    40bc:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    40be:	8a 81       	ldd	r24, Y+2	; 0x02
    40c0:	9b 81       	ldd	r25, Y+3	; 0x03
    40c2:	02 96       	adiw	r24, 0x02	; 2
    40c4:	8a 83       	std	Y+2, r24	; 0x02
    40c6:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    40c8:	8a 81       	ldd	r24, Y+2	; 0x02
    40ca:	9b 81       	ldd	r25, Y+3	; 0x03
    40cc:	fc 01       	movw	r30, r24
    40ce:	20 81       	ld	r18, Z
    40d0:	31 81       	ldd	r19, Z+1	; 0x01
    40d2:	8e 81       	ldd	r24, Y+6	; 0x06
    40d4:	9f 81       	ldd	r25, Y+7	; 0x07
    40d6:	fc 01       	movw	r30, r24
    40d8:	21 83       	std	Z+1, r18	; 0x01
    40da:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    40dc:	8a 81       	ldd	r24, Y+2	; 0x02
    40de:	9b 81       	ldd	r25, Y+3	; 0x03
    40e0:	02 96       	adiw	r24, 0x02	; 2
    40e2:	8a 83       	std	Y+2, r24	; 0x02
    40e4:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    40e6:	0e 94 02 21 	call	0x4204	; 0x4204 <chb_buf_get_len>
    40ea:	88 23       	and	r24, r24
    40ec:	11 f4       	brne	.+4      	; 0x40f2 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    40ee:	10 92 3b 21 	sts	0x213B, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    40f2:	80 91 0e 20 	lds	r24, 0x200E
    40f6:	9d 81       	ldd	r25, Y+5	; 0x05
    40f8:	98 17       	cp	r25, r24
    40fa:	71 f4       	brne	.+28     	; 0x4118 <chb_read+0xf6>
    40fc:	8e 81       	ldd	r24, Y+6	; 0x06
    40fe:	9f 81       	ldd	r25, Y+7	; 0x07
    4100:	fc 01       	movw	r30, r24
    4102:	21 81       	ldd	r18, Z+1	; 0x01
    4104:	32 81       	ldd	r19, Z+2	; 0x02
    4106:	80 91 0f 20 	lds	r24, 0x200F
    410a:	90 91 10 20 	lds	r25, 0x2010
    410e:	28 17       	cp	r18, r24
    4110:	39 07       	cpc	r19, r25
    4112:	11 f4       	brne	.+4      	; 0x4118 <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    4114:	80 e0       	ldi	r24, 0x00	; 0
    4116:	1b c0       	rjmp	.+54     	; 0x414e <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    4118:	8d 81       	ldd	r24, Y+5	; 0x05
    411a:	80 93 0e 20 	sts	0x200E, r24
        prev_src_addr = rx->src_addr;
    411e:	8e 81       	ldd	r24, Y+6	; 0x06
    4120:	9f 81       	ldd	r25, Y+7	; 0x07
    4122:	fc 01       	movw	r30, r24
    4124:	81 81       	ldd	r24, Z+1	; 0x01
    4126:	92 81       	ldd	r25, Z+2	; 0x02
    4128:	80 93 0f 20 	sts	0x200F, r24
    412c:	90 93 10 20 	sts	0x2010, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    4130:	8c 81       	ldd	r24, Y+4	; 0x04
    4132:	88 2f       	mov	r24, r24
    4134:	90 e0       	ldi	r25, 0x00	; 0
    4136:	09 97       	sbiw	r24, 0x09	; 9
    4138:	9c 01       	movw	r18, r24
    413a:	8e 81       	ldd	r24, Y+6	; 0x06
    413c:	9f 81       	ldd	r25, Y+7	; 0x07
    413e:	4a 81       	ldd	r20, Y+2	; 0x02
    4140:	5b 81       	ldd	r21, Y+3	; 0x03
    4142:	ba 01       	movw	r22, r20
    4144:	a9 01       	movw	r20, r18
    4146:	0e 94 c9 62 	call	0xc592	; 0xc592 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    414a:	8c 81       	ldd	r24, Y+4	; 0x04
    414c:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    414e:	27 96       	adiw	r28, 0x07	; 7
    4150:	cd bf       	out	0x3d, r28	; 61
    4152:	de bf       	out	0x3e, r29	; 62
    4154:	df 91       	pop	r29
    4156:	cf 91       	pop	r28
    4158:	08 95       	ret

0000415a <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    415a:	cf 93       	push	r28
    415c:	df 93       	push	r29
    415e:	cd b7       	in	r28, 0x3d	; 61
    4160:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4162:	10 92 cc 21 	sts	0x21CC, r1
    wr_ptr = 0;
    4166:	10 92 cd 21 	sts	0x21CD, r1
    len = 0;
    416a:	10 92 ce 21 	sts	0x21CE, r1
}
    416e:	df 91       	pop	r29
    4170:	cf 91       	pop	r28
    4172:	08 95       	ret

00004174 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4174:	cf 93       	push	r28
    4176:	df 93       	push	r29
    4178:	0f 92       	push	r0
    417a:	cd b7       	in	r28, 0x3d	; 61
    417c:	de b7       	in	r29, 0x3e	; 62
    417e:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4180:	80 91 cd 21 	lds	r24, 0x21CD
    4184:	88 2f       	mov	r24, r24
    4186:	90 e0       	ldi	r25, 0x00	; 0
    4188:	84 5b       	subi	r24, 0xB4	; 180
    418a:	9e 4d       	sbci	r25, 0xDE	; 222
    418c:	29 81       	ldd	r18, Y+1	; 0x01
    418e:	fc 01       	movw	r30, r24
    4190:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4192:	80 91 cd 21 	lds	r24, 0x21CD
    4196:	88 2f       	mov	r24, r24
    4198:	90 e0       	ldi	r25, 0x00	; 0
    419a:	01 96       	adiw	r24, 0x01	; 1
    419c:	20 e8       	ldi	r18, 0x80	; 128
    419e:	30 e0       	ldi	r19, 0x00	; 0
    41a0:	b9 01       	movw	r22, r18
    41a2:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    41a6:	80 93 cd 21 	sts	0x21CD, r24
    len++;
    41aa:	80 91 ce 21 	lds	r24, 0x21CE
    41ae:	8f 5f       	subi	r24, 0xFF	; 255
    41b0:	80 93 ce 21 	sts	0x21CE, r24
}
    41b4:	0f 90       	pop	r0
    41b6:	df 91       	pop	r29
    41b8:	cf 91       	pop	r28
    41ba:	08 95       	ret

000041bc <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    41bc:	cf 93       	push	r28
    41be:	df 93       	push	r29
    41c0:	0f 92       	push	r0
    41c2:	cd b7       	in	r28, 0x3d	; 61
    41c4:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    41c6:	80 91 cc 21 	lds	r24, 0x21CC
    41ca:	88 2f       	mov	r24, r24
    41cc:	90 e0       	ldi	r25, 0x00	; 0
    41ce:	84 5b       	subi	r24, 0xB4	; 180
    41d0:	9e 4d       	sbci	r25, 0xDE	; 222
    41d2:	fc 01       	movw	r30, r24
    41d4:	80 81       	ld	r24, Z
    41d6:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    41d8:	80 91 cc 21 	lds	r24, 0x21CC
    41dc:	88 2f       	mov	r24, r24
    41de:	90 e0       	ldi	r25, 0x00	; 0
    41e0:	01 96       	adiw	r24, 0x01	; 1
    41e2:	20 e8       	ldi	r18, 0x80	; 128
    41e4:	30 e0       	ldi	r19, 0x00	; 0
    41e6:	b9 01       	movw	r22, r18
    41e8:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    41ec:	80 93 cc 21 	sts	0x21CC, r24
    len--;
    41f0:	80 91 ce 21 	lds	r24, 0x21CE
    41f4:	81 50       	subi	r24, 0x01	; 1
    41f6:	80 93 ce 21 	sts	0x21CE, r24
    return data;
    41fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    41fc:	0f 90       	pop	r0
    41fe:	df 91       	pop	r29
    4200:	cf 91       	pop	r28
    4202:	08 95       	ret

00004204 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    4204:	cf 93       	push	r28
    4206:	df 93       	push	r29
    4208:	cd b7       	in	r28, 0x3d	; 61
    420a:	de b7       	in	r29, 0x3e	; 62
    return len;
    420c:	80 91 ce 21 	lds	r24, 0x21CE
}
    4210:	df 91       	pop	r29
    4212:	cf 91       	pop	r28
    4214:	08 95       	ret

00004216 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    4216:	cf 93       	push	r28
    4218:	df 93       	push	r29
    421a:	cd b7       	in	r28, 0x3d	; 61
    421c:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    421e:	81 e0       	ldi	r24, 0x01	; 1
    4220:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    4224:	8f 71       	andi	r24, 0x1F	; 31
}
    4226:	df 91       	pop	r29
    4228:	cf 91       	pop	r28
    422a:	08 95       	ret

0000422c <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    422c:	cf 93       	push	r28
    422e:	df 93       	push	r29
    4230:	cd b7       	in	r28, 0x3d	; 61
    4232:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    4234:	82 e0       	ldi	r24, 0x02	; 2
    4236:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    423a:	82 95       	swap	r24
    423c:	86 95       	lsr	r24
    423e:	87 70       	andi	r24, 0x07	; 7
}
    4240:	df 91       	pop	r29
    4242:	cf 91       	pop	r28
    4244:	08 95       	ret

00004246 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    4246:	0f 93       	push	r16
    4248:	1f 93       	push	r17
    424a:	cf 93       	push	r28
    424c:	df 93       	push	r29
    424e:	cd b7       	in	r28, 0x3d	; 61
    4250:	de b7       	in	r29, 0x3e	; 62
    4252:	e0 97       	sbiw	r28, 0x30	; 48
    4254:	cd bf       	out	0x3d, r28	; 61
    4256:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    4258:	84 e6       	ldi	r24, 0x64	; 100
    425a:	96 e0       	ldi	r25, 0x06	; 6
    425c:	24 e6       	ldi	r18, 0x64	; 100
    425e:	36 e0       	ldi	r19, 0x06	; 6
    4260:	f9 01       	movw	r30, r18
    4262:	20 81       	ld	r18, Z
    4264:	21 60       	ori	r18, 0x01	; 1
    4266:	fc 01       	movw	r30, r24
    4268:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    426a:	84 e6       	ldi	r24, 0x64	; 100
    426c:	96 e0       	ldi	r25, 0x06	; 6
    426e:	24 e6       	ldi	r18, 0x64	; 100
    4270:	36 e0       	ldi	r19, 0x06	; 6
    4272:	f9 01       	movw	r30, r18
    4274:	20 81       	ld	r18, Z
    4276:	2d 7f       	andi	r18, 0xFD	; 253
    4278:	fc 01       	movw	r30, r24
    427a:	20 83       	st	Z, r18
    427c:	80 e0       	ldi	r24, 0x00	; 0
    427e:	90 e0       	ldi	r25, 0x00	; 0
    4280:	ae eb       	ldi	r26, 0xBE	; 190
    4282:	b3 e4       	ldi	r27, 0x43	; 67
    4284:	89 83       	std	Y+1, r24	; 0x01
    4286:	9a 83       	std	Y+2, r25	; 0x02
    4288:	ab 83       	std	Y+3, r26	; 0x03
    428a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    428c:	69 81       	ldd	r22, Y+1	; 0x01
    428e:	7a 81       	ldd	r23, Y+2	; 0x02
    4290:	8b 81       	ldd	r24, Y+3	; 0x03
    4292:	9c 81       	ldd	r25, Y+4	; 0x04
    4294:	2b ea       	ldi	r18, 0xAB	; 171
    4296:	3a ea       	ldi	r19, 0xAA	; 170
    4298:	4a ea       	ldi	r20, 0xAA	; 170
    429a:	5e e3       	ldi	r21, 0x3E	; 62
    429c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    42a0:	dc 01       	movw	r26, r24
    42a2:	cb 01       	movw	r24, r22
    42a4:	8d 83       	std	Y+5, r24	; 0x05
    42a6:	9e 83       	std	Y+6, r25	; 0x06
    42a8:	af 83       	std	Y+7, r26	; 0x07
    42aa:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    42ac:	11 e0       	ldi	r17, 0x01	; 1
    42ae:	6d 81       	ldd	r22, Y+5	; 0x05
    42b0:	7e 81       	ldd	r23, Y+6	; 0x06
    42b2:	8f 81       	ldd	r24, Y+7	; 0x07
    42b4:	98 85       	ldd	r25, Y+8	; 0x08
    42b6:	20 e0       	ldi	r18, 0x00	; 0
    42b8:	30 e0       	ldi	r19, 0x00	; 0
    42ba:	40 e8       	ldi	r20, 0x80	; 128
    42bc:	5f e3       	ldi	r21, 0x3F	; 63
    42be:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    42c2:	88 23       	and	r24, r24
    42c4:	0c f0       	brlt	.+2      	; 0x42c8 <chb_reset+0x82>
    42c6:	10 e0       	ldi	r17, 0x00	; 0
    42c8:	11 23       	and	r17, r17
    42ca:	19 f0       	breq	.+6      	; 0x42d2 <chb_reset+0x8c>
		__ticks = 1;
    42cc:	81 e0       	ldi	r24, 0x01	; 1
    42ce:	89 87       	std	Y+9, r24	; 0x09
    42d0:	a3 c0       	rjmp	.+326    	; 0x4418 <chb_reset+0x1d2>
	else if (__tmp > 255)
    42d2:	11 e0       	ldi	r17, 0x01	; 1
    42d4:	6d 81       	ldd	r22, Y+5	; 0x05
    42d6:	7e 81       	ldd	r23, Y+6	; 0x06
    42d8:	8f 81       	ldd	r24, Y+7	; 0x07
    42da:	98 85       	ldd	r25, Y+8	; 0x08
    42dc:	20 e0       	ldi	r18, 0x00	; 0
    42de:	30 e0       	ldi	r19, 0x00	; 0
    42e0:	4f e7       	ldi	r20, 0x7F	; 127
    42e2:	53 e4       	ldi	r21, 0x43	; 67
    42e4:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    42e8:	18 16       	cp	r1, r24
    42ea:	0c f0       	brlt	.+2      	; 0x42ee <chb_reset+0xa8>
    42ec:	10 e0       	ldi	r17, 0x00	; 0
    42ee:	11 23       	and	r17, r17
    42f0:	09 f4       	brne	.+2      	; 0x42f4 <chb_reset+0xae>
    42f2:	89 c0       	rjmp	.+274    	; 0x4406 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    42f4:	69 81       	ldd	r22, Y+1	; 0x01
    42f6:	7a 81       	ldd	r23, Y+2	; 0x02
    42f8:	8b 81       	ldd	r24, Y+3	; 0x03
    42fa:	9c 81       	ldd	r25, Y+4	; 0x04
    42fc:	20 e0       	ldi	r18, 0x00	; 0
    42fe:	30 e0       	ldi	r19, 0x00	; 0
    4300:	4a e7       	ldi	r20, 0x7A	; 122
    4302:	54 e4       	ldi	r21, 0x44	; 68
    4304:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    4308:	dc 01       	movw	r26, r24
    430a:	cb 01       	movw	r24, r22
    430c:	8a 87       	std	Y+10, r24	; 0x0a
    430e:	9b 87       	std	Y+11, r25	; 0x0b
    4310:	ac 87       	std	Y+12, r26	; 0x0c
    4312:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4314:	6a 85       	ldd	r22, Y+10	; 0x0a
    4316:	7b 85       	ldd	r23, Y+11	; 0x0b
    4318:	8c 85       	ldd	r24, Y+12	; 0x0c
    431a:	9d 85       	ldd	r25, Y+13	; 0x0d
    431c:	20 e0       	ldi	r18, 0x00	; 0
    431e:	30 e0       	ldi	r19, 0x00	; 0
    4320:	4a e7       	ldi	r20, 0x7A	; 122
    4322:	53 e4       	ldi	r21, 0x43	; 67
    4324:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4328:	dc 01       	movw	r26, r24
    432a:	cb 01       	movw	r24, r22
    432c:	8e 87       	std	Y+14, r24	; 0x0e
    432e:	9f 87       	std	Y+15, r25	; 0x0f
    4330:	a8 8b       	std	Y+16, r26	; 0x10
    4332:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    4334:	11 e0       	ldi	r17, 0x01	; 1
    4336:	6e 85       	ldd	r22, Y+14	; 0x0e
    4338:	7f 85       	ldd	r23, Y+15	; 0x0f
    433a:	88 89       	ldd	r24, Y+16	; 0x10
    433c:	99 89       	ldd	r25, Y+17	; 0x11
    433e:	20 e0       	ldi	r18, 0x00	; 0
    4340:	30 e0       	ldi	r19, 0x00	; 0
    4342:	40 e8       	ldi	r20, 0x80	; 128
    4344:	5f e3       	ldi	r21, 0x3F	; 63
    4346:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    434a:	88 23       	and	r24, r24
    434c:	0c f0       	brlt	.+2      	; 0x4350 <chb_reset+0x10a>
    434e:	10 e0       	ldi	r17, 0x00	; 0
    4350:	11 23       	and	r17, r17
    4352:	29 f0       	breq	.+10     	; 0x435e <chb_reset+0x118>
		__ticks = 1;
    4354:	81 e0       	ldi	r24, 0x01	; 1
    4356:	90 e0       	ldi	r25, 0x00	; 0
    4358:	8a 8b       	std	Y+18, r24	; 0x12
    435a:	9b 8b       	std	Y+19, r25	; 0x13
    435c:	46 c0       	rjmp	.+140    	; 0x43ea <chb_reset+0x1a4>
	else if (__tmp > 65535)
    435e:	11 e0       	ldi	r17, 0x01	; 1
    4360:	6e 85       	ldd	r22, Y+14	; 0x0e
    4362:	7f 85       	ldd	r23, Y+15	; 0x0f
    4364:	88 89       	ldd	r24, Y+16	; 0x10
    4366:	99 89       	ldd	r25, Y+17	; 0x11
    4368:	20 e0       	ldi	r18, 0x00	; 0
    436a:	3f ef       	ldi	r19, 0xFF	; 255
    436c:	4f e7       	ldi	r20, 0x7F	; 127
    436e:	57 e4       	ldi	r21, 0x47	; 71
    4370:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    4374:	18 16       	cp	r1, r24
    4376:	0c f0       	brlt	.+2      	; 0x437a <chb_reset+0x134>
    4378:	10 e0       	ldi	r17, 0x00	; 0
    437a:	11 23       	and	r17, r17
    437c:	61 f1       	breq	.+88     	; 0x43d6 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    437e:	6a 85       	ldd	r22, Y+10	; 0x0a
    4380:	7b 85       	ldd	r23, Y+11	; 0x0b
    4382:	8c 85       	ldd	r24, Y+12	; 0x0c
    4384:	9d 85       	ldd	r25, Y+13	; 0x0d
    4386:	20 e0       	ldi	r18, 0x00	; 0
    4388:	30 e0       	ldi	r19, 0x00	; 0
    438a:	40 e2       	ldi	r20, 0x20	; 32
    438c:	51 e4       	ldi	r21, 0x41	; 65
    438e:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4392:	dc 01       	movw	r26, r24
    4394:	cb 01       	movw	r24, r22
    4396:	bc 01       	movw	r22, r24
    4398:	cd 01       	movw	r24, r26
    439a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    439e:	dc 01       	movw	r26, r24
    43a0:	cb 01       	movw	r24, r22
    43a2:	8a 8b       	std	Y+18, r24	; 0x12
    43a4:	9b 8b       	std	Y+19, r25	; 0x13
    43a6:	12 c0       	rjmp	.+36     	; 0x43cc <chb_reset+0x186>
    43a8:	89 e1       	ldi	r24, 0x19	; 25
    43aa:	90 e0       	ldi	r25, 0x00	; 0
    43ac:	8c 8b       	std	Y+20, r24	; 0x14
    43ae:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    43b0:	8c 89       	ldd	r24, Y+20	; 0x14
    43b2:	9d 89       	ldd	r25, Y+21	; 0x15
    43b4:	8c 01       	movw	r16, r24
    43b6:	c8 01       	movw	r24, r16
    43b8:	01 97       	sbiw	r24, 0x01	; 1
    43ba:	f1 f7       	brne	.-4      	; 0x43b8 <chb_reset+0x172>
    43bc:	8c 01       	movw	r16, r24
    43be:	0c 8b       	std	Y+20, r16	; 0x14
    43c0:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    43c2:	8a 89       	ldd	r24, Y+18	; 0x12
    43c4:	9b 89       	ldd	r25, Y+19	; 0x13
    43c6:	01 97       	sbiw	r24, 0x01	; 1
    43c8:	8a 8b       	std	Y+18, r24	; 0x12
    43ca:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    43cc:	8a 89       	ldd	r24, Y+18	; 0x12
    43ce:	9b 89       	ldd	r25, Y+19	; 0x13
    43d0:	00 97       	sbiw	r24, 0x00	; 0
    43d2:	51 f7       	brne	.-44     	; 0x43a8 <chb_reset+0x162>
    43d4:	28 c0       	rjmp	.+80     	; 0x4426 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    43d6:	6e 85       	ldd	r22, Y+14	; 0x0e
    43d8:	7f 85       	ldd	r23, Y+15	; 0x0f
    43da:	88 89       	ldd	r24, Y+16	; 0x10
    43dc:	99 89       	ldd	r25, Y+17	; 0x11
    43de:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    43e2:	dc 01       	movw	r26, r24
    43e4:	cb 01       	movw	r24, r22
    43e6:	8a 8b       	std	Y+18, r24	; 0x12
    43e8:	9b 8b       	std	Y+19, r25	; 0x13
    43ea:	8a 89       	ldd	r24, Y+18	; 0x12
    43ec:	9b 89       	ldd	r25, Y+19	; 0x13
    43ee:	8e 8b       	std	Y+22, r24	; 0x16
    43f0:	9f 8b       	std	Y+23, r25	; 0x17
    43f2:	8e 89       	ldd	r24, Y+22	; 0x16
    43f4:	9f 89       	ldd	r25, Y+23	; 0x17
    43f6:	8c 01       	movw	r16, r24
    43f8:	f8 01       	movw	r30, r16
    43fa:	31 97       	sbiw	r30, 0x01	; 1
    43fc:	f1 f7       	brne	.-4      	; 0x43fa <chb_reset+0x1b4>
    43fe:	8f 01       	movw	r16, r30
    4400:	0e 8b       	std	Y+22, r16	; 0x16
    4402:	1f 8b       	std	Y+23, r17	; 0x17
    4404:	10 c0       	rjmp	.+32     	; 0x4426 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4406:	6d 81       	ldd	r22, Y+5	; 0x05
    4408:	7e 81       	ldd	r23, Y+6	; 0x06
    440a:	8f 81       	ldd	r24, Y+7	; 0x07
    440c:	98 85       	ldd	r25, Y+8	; 0x08
    440e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    4412:	dc 01       	movw	r26, r24
    4414:	cb 01       	movw	r24, r22
    4416:	89 87       	std	Y+9, r24	; 0x09
    4418:	89 85       	ldd	r24, Y+9	; 0x09
    441a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    441c:	88 8d       	ldd	r24, Y+24	; 0x18
    441e:	18 2f       	mov	r17, r24
    4420:	1a 95       	dec	r17
    4422:	f1 f7       	brne	.-4      	; 0x4420 <chb_reset+0x1da>
    4424:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    4426:	84 e6       	ldi	r24, 0x64	; 100
    4428:	96 e0       	ldi	r25, 0x06	; 6
    442a:	24 e6       	ldi	r18, 0x64	; 100
    442c:	36 e0       	ldi	r19, 0x06	; 6
    442e:	f9 01       	movw	r30, r18
    4430:	20 81       	ld	r18, Z
    4432:	2e 7f       	andi	r18, 0xFE	; 254
    4434:	fc 01       	movw	r30, r24
    4436:	20 83       	st	Z, r18
    4438:	80 e0       	ldi	r24, 0x00	; 0
    443a:	90 e0       	ldi	r25, 0x00	; 0
    443c:	a0 e8       	ldi	r26, 0x80	; 128
    443e:	bf e3       	ldi	r27, 0x3F	; 63
    4440:	89 8f       	std	Y+25, r24	; 0x19
    4442:	9a 8f       	std	Y+26, r25	; 0x1a
    4444:	ab 8f       	std	Y+27, r26	; 0x1b
    4446:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4448:	69 8d       	ldd	r22, Y+25	; 0x19
    444a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    444c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    444e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4450:	2b ea       	ldi	r18, 0xAB	; 171
    4452:	3a ea       	ldi	r19, 0xAA	; 170
    4454:	4a ea       	ldi	r20, 0xAA	; 170
    4456:	5e e3       	ldi	r21, 0x3E	; 62
    4458:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    445c:	dc 01       	movw	r26, r24
    445e:	cb 01       	movw	r24, r22
    4460:	8d 8f       	std	Y+29, r24	; 0x1d
    4462:	9e 8f       	std	Y+30, r25	; 0x1e
    4464:	af 8f       	std	Y+31, r26	; 0x1f
    4466:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    4468:	11 e0       	ldi	r17, 0x01	; 1
    446a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    446c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    446e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4470:	98 a1       	lds	r25, 0x48
    4472:	20 e0       	ldi	r18, 0x00	; 0
    4474:	30 e0       	ldi	r19, 0x00	; 0
    4476:	40 e8       	ldi	r20, 0x80	; 128
    4478:	5f e3       	ldi	r21, 0x3F	; 63
    447a:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    447e:	88 23       	and	r24, r24
    4480:	0c f0       	brlt	.+2      	; 0x4484 <chb_reset+0x23e>
    4482:	10 e0       	ldi	r17, 0x00	; 0
    4484:	11 23       	and	r17, r17
    4486:	19 f0       	breq	.+6      	; 0x448e <chb_reset+0x248>
		__ticks = 1;
    4488:	81 e0       	ldi	r24, 0x01	; 1
    448a:	89 a3       	lds	r24, 0x59
    448c:	a3 c0       	rjmp	.+326    	; 0x45d4 <chb_reset+0x38e>
	else if (__tmp > 255)
    448e:	11 e0       	ldi	r17, 0x01	; 1
    4490:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4492:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4494:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4496:	98 a1       	lds	r25, 0x48
    4498:	20 e0       	ldi	r18, 0x00	; 0
    449a:	30 e0       	ldi	r19, 0x00	; 0
    449c:	4f e7       	ldi	r20, 0x7F	; 127
    449e:	53 e4       	ldi	r21, 0x43	; 67
    44a0:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    44a4:	18 16       	cp	r1, r24
    44a6:	0c f0       	brlt	.+2      	; 0x44aa <chb_reset+0x264>
    44a8:	10 e0       	ldi	r17, 0x00	; 0
    44aa:	11 23       	and	r17, r17
    44ac:	09 f4       	brne	.+2      	; 0x44b0 <chb_reset+0x26a>
    44ae:	89 c0       	rjmp	.+274    	; 0x45c2 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    44b0:	69 8d       	ldd	r22, Y+25	; 0x19
    44b2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    44b4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    44b6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    44b8:	20 e0       	ldi	r18, 0x00	; 0
    44ba:	30 e0       	ldi	r19, 0x00	; 0
    44bc:	4a e7       	ldi	r20, 0x7A	; 122
    44be:	54 e4       	ldi	r21, 0x44	; 68
    44c0:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    44c4:	dc 01       	movw	r26, r24
    44c6:	cb 01       	movw	r24, r22
    44c8:	8a a3       	lds	r24, 0x5a
    44ca:	9b a3       	lds	r25, 0x5b
    44cc:	ac a3       	lds	r26, 0x5c
    44ce:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    44d0:	6a a1       	lds	r22, 0x4a
    44d2:	7b a1       	lds	r23, 0x4b
    44d4:	8c a1       	lds	r24, 0x4c
    44d6:	9d a1       	lds	r25, 0x4d
    44d8:	20 e0       	ldi	r18, 0x00	; 0
    44da:	30 e0       	ldi	r19, 0x00	; 0
    44dc:	4a e7       	ldi	r20, 0x7A	; 122
    44de:	53 e4       	ldi	r21, 0x43	; 67
    44e0:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    44e4:	dc 01       	movw	r26, r24
    44e6:	cb 01       	movw	r24, r22
    44e8:	8e a3       	lds	r24, 0x5e
    44ea:	9f a3       	lds	r25, 0x5f
    44ec:	a8 a7       	lds	r26, 0x78
    44ee:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    44f0:	11 e0       	ldi	r17, 0x01	; 1
    44f2:	6e a1       	lds	r22, 0x4e
    44f4:	7f a1       	lds	r23, 0x4f
    44f6:	88 a5       	lds	r24, 0x68
    44f8:	99 a5       	lds	r25, 0x69
    44fa:	20 e0       	ldi	r18, 0x00	; 0
    44fc:	30 e0       	ldi	r19, 0x00	; 0
    44fe:	40 e8       	ldi	r20, 0x80	; 128
    4500:	5f e3       	ldi	r21, 0x3F	; 63
    4502:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    4506:	88 23       	and	r24, r24
    4508:	0c f0       	brlt	.+2      	; 0x450c <chb_reset+0x2c6>
    450a:	10 e0       	ldi	r17, 0x00	; 0
    450c:	11 23       	and	r17, r17
    450e:	29 f0       	breq	.+10     	; 0x451a <chb_reset+0x2d4>
		__ticks = 1;
    4510:	81 e0       	ldi	r24, 0x01	; 1
    4512:	90 e0       	ldi	r25, 0x00	; 0
    4514:	8a a7       	lds	r24, 0x7a
    4516:	9b a7       	lds	r25, 0x7b
    4518:	46 c0       	rjmp	.+140    	; 0x45a6 <chb_reset+0x360>
	else if (__tmp > 65535)
    451a:	11 e0       	ldi	r17, 0x01	; 1
    451c:	6e a1       	lds	r22, 0x4e
    451e:	7f a1       	lds	r23, 0x4f
    4520:	88 a5       	lds	r24, 0x68
    4522:	99 a5       	lds	r25, 0x69
    4524:	20 e0       	ldi	r18, 0x00	; 0
    4526:	3f ef       	ldi	r19, 0xFF	; 255
    4528:	4f e7       	ldi	r20, 0x7F	; 127
    452a:	57 e4       	ldi	r21, 0x47	; 71
    452c:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    4530:	18 16       	cp	r1, r24
    4532:	0c f0       	brlt	.+2      	; 0x4536 <chb_reset+0x2f0>
    4534:	10 e0       	ldi	r17, 0x00	; 0
    4536:	11 23       	and	r17, r17
    4538:	61 f1       	breq	.+88     	; 0x4592 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    453a:	6a a1       	lds	r22, 0x4a
    453c:	7b a1       	lds	r23, 0x4b
    453e:	8c a1       	lds	r24, 0x4c
    4540:	9d a1       	lds	r25, 0x4d
    4542:	20 e0       	ldi	r18, 0x00	; 0
    4544:	30 e0       	ldi	r19, 0x00	; 0
    4546:	40 e2       	ldi	r20, 0x20	; 32
    4548:	51 e4       	ldi	r21, 0x41	; 65
    454a:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    454e:	dc 01       	movw	r26, r24
    4550:	cb 01       	movw	r24, r22
    4552:	bc 01       	movw	r22, r24
    4554:	cd 01       	movw	r24, r26
    4556:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    455a:	dc 01       	movw	r26, r24
    455c:	cb 01       	movw	r24, r22
    455e:	8a a7       	lds	r24, 0x7a
    4560:	9b a7       	lds	r25, 0x7b
    4562:	12 c0       	rjmp	.+36     	; 0x4588 <chb_reset+0x342>
    4564:	89 e1       	ldi	r24, 0x19	; 25
    4566:	90 e0       	ldi	r25, 0x00	; 0
    4568:	8c a7       	lds	r24, 0x7c
    456a:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    456c:	8c a5       	lds	r24, 0x6c
    456e:	9d a5       	lds	r25, 0x6d
    4570:	8c 01       	movw	r16, r24
    4572:	c8 01       	movw	r24, r16
    4574:	01 97       	sbiw	r24, 0x01	; 1
    4576:	f1 f7       	brne	.-4      	; 0x4574 <chb_reset+0x32e>
    4578:	8c 01       	movw	r16, r24
    457a:	0c a7       	lds	r16, 0x7c
    457c:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    457e:	8a a5       	lds	r24, 0x6a
    4580:	9b a5       	lds	r25, 0x6b
    4582:	01 97       	sbiw	r24, 0x01	; 1
    4584:	8a a7       	lds	r24, 0x7a
    4586:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4588:	8a a5       	lds	r24, 0x6a
    458a:	9b a5       	lds	r25, 0x6b
    458c:	00 97       	sbiw	r24, 0x00	; 0
    458e:	51 f7       	brne	.-44     	; 0x4564 <chb_reset+0x31e>
    4590:	28 c0       	rjmp	.+80     	; 0x45e2 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4592:	6e a1       	lds	r22, 0x4e
    4594:	7f a1       	lds	r23, 0x4f
    4596:	88 a5       	lds	r24, 0x68
    4598:	99 a5       	lds	r25, 0x69
    459a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    459e:	dc 01       	movw	r26, r24
    45a0:	cb 01       	movw	r24, r22
    45a2:	8a a7       	lds	r24, 0x7a
    45a4:	9b a7       	lds	r25, 0x7b
    45a6:	8a a5       	lds	r24, 0x6a
    45a8:	9b a5       	lds	r25, 0x6b
    45aa:	8e a7       	lds	r24, 0x7e
    45ac:	9f a7       	lds	r25, 0x7f
    45ae:	8e a5       	lds	r24, 0x6e
    45b0:	9f a5       	lds	r25, 0x6f
    45b2:	8c 01       	movw	r16, r24
    45b4:	f8 01       	movw	r30, r16
    45b6:	31 97       	sbiw	r30, 0x01	; 1
    45b8:	f1 f7       	brne	.-4      	; 0x45b6 <chb_reset+0x370>
    45ba:	8f 01       	movw	r16, r30
    45bc:	0e a7       	lds	r16, 0x7e
    45be:	1f a7       	lds	r17, 0x7f
    45c0:	10 c0       	rjmp	.+32     	; 0x45e2 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    45c2:	6d 8d       	ldd	r22, Y+29	; 0x1d
    45c4:	7e 8d       	ldd	r23, Y+30	; 0x1e
    45c6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    45c8:	98 a1       	lds	r25, 0x48
    45ca:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    45ce:	dc 01       	movw	r26, r24
    45d0:	cb 01       	movw	r24, r22
    45d2:	89 a3       	lds	r24, 0x59
    45d4:	89 a1       	lds	r24, 0x49
    45d6:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    45d8:	88 a9       	sts	0x48, r24
    45da:	18 2f       	mov	r17, r24
    45dc:	1a 95       	dec	r17
    45de:	f1 f7       	brne	.-4      	; 0x45dc <chb_reset+0x396>
    45e0:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    45e2:	84 e6       	ldi	r24, 0x64	; 100
    45e4:	96 e0       	ldi	r25, 0x06	; 6
    45e6:	24 e6       	ldi	r18, 0x64	; 100
    45e8:	36 e0       	ldi	r19, 0x06	; 6
    45ea:	f9 01       	movw	r30, r18
    45ec:	20 81       	ld	r18, Z
    45ee:	21 60       	ori	r18, 0x01	; 1
    45f0:	fc 01       	movw	r30, r24
    45f2:	20 83       	st	Z, r18
    45f4:	01 c0       	rjmp	.+2      	; 0x45f8 <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    45f6:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    45f8:	8d e1       	ldi	r24, 0x1D	; 29
    45fa:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    45fe:	81 30       	cpi	r24, 0x01	; 1
    4600:	d1 f7       	brne	.-12     	; 0x45f6 <chb_reset+0x3b0>
    4602:	8c e1       	ldi	r24, 0x1C	; 28
    4604:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    4608:	87 30       	cpi	r24, 0x07	; 7
    460a:	a9 f7       	brne	.-22     	; 0x45f6 <chb_reset+0x3b0>
        {
            break;
    460c:	00 00       	nop
        }
    }
	

}
    460e:	e0 96       	adiw	r28, 0x30	; 48
    4610:	cd bf       	out	0x3d, r28	; 61
    4612:	de bf       	out	0x3e, r29	; 62
    4614:	df 91       	pop	r29
    4616:	cf 91       	pop	r28
    4618:	1f 91       	pop	r17
    461a:	0f 91       	pop	r16
    461c:	08 95       	ret

0000461e <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    461e:	cf 93       	push	r28
    4620:	df 93       	push	r29
    4622:	0f 92       	push	r0
    4624:	0f 92       	push	r0
    4626:	cd b7       	in	r28, 0x3d	; 61
    4628:	de b7       	in	r29, 0x3e	; 62
    462a:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    462c:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    462e:	8a 81       	ldd	r24, Y+2	; 0x02
    4630:	80 68       	ori	r24, 0x80	; 128
    4632:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4634:	8f e3       	ldi	r24, 0x3F	; 63
    4636:	90 e0       	ldi	r25, 0x00	; 0
    4638:	fc 01       	movw	r30, r24
    463a:	80 81       	ld	r24, Z
    463c:	80 93 4f 40 	sts	0x404F, r24
    4640:	f8 94       	cli
    RadioCS(TRUE);
    4642:	81 e0       	ldi	r24, 0x01	; 1
    4644:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4648:	8a 81       	ldd	r24, Y+2	; 0x02
    464a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    464e:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4650:	89 81       	ldd	r24, Y+1	; 0x01
    4652:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    4656:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4658:	80 e0       	ldi	r24, 0x00	; 0
    465a:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>
    CHB_LEAVE_CRIT();
    465e:	8f e3       	ldi	r24, 0x3F	; 63
    4660:	90 e0       	ldi	r25, 0x00	; 0
    4662:	20 91 4f 40 	lds	r18, 0x404F
    4666:	fc 01       	movw	r30, r24
    4668:	20 83       	st	Z, r18
    466a:	78 94       	sei

    return val;
    466c:	89 81       	ldd	r24, Y+1	; 0x01
}
    466e:	0f 90       	pop	r0
    4670:	0f 90       	pop	r0
    4672:	df 91       	pop	r29
    4674:	cf 91       	pop	r28
    4676:	08 95       	ret

00004678 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4678:	cf 93       	push	r28
    467a:	df 93       	push	r29
    467c:	00 d0       	rcall	.+0      	; 0x467e <chb_reg_read16+0x6>
    467e:	0f 92       	push	r0
    4680:	cd b7       	in	r28, 0x3d	; 61
    4682:	de b7       	in	r29, 0x3e	; 62
    4684:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4686:	1a 82       	std	Y+2, r1	; 0x02
    4688:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    468a:	19 82       	std	Y+1, r1	; 0x01
    468c:	1d c0       	rjmp	.+58     	; 0x46c8 <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    468e:	9c 81       	ldd	r25, Y+4	; 0x04
    4690:	89 81       	ldd	r24, Y+1	; 0x01
    4692:	89 0f       	add	r24, r25
    4694:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    4698:	88 2f       	mov	r24, r24
    469a:	90 e0       	ldi	r25, 0x00	; 0
    469c:	29 81       	ldd	r18, Y+1	; 0x01
    469e:	22 2f       	mov	r18, r18
    46a0:	30 e0       	ldi	r19, 0x00	; 0
    46a2:	22 0f       	add	r18, r18
    46a4:	33 1f       	adc	r19, r19
    46a6:	22 0f       	add	r18, r18
    46a8:	33 1f       	adc	r19, r19
    46aa:	22 0f       	add	r18, r18
    46ac:	33 1f       	adc	r19, r19
    46ae:	02 2e       	mov	r0, r18
    46b0:	02 c0       	rjmp	.+4      	; 0x46b6 <chb_reg_read16+0x3e>
    46b2:	88 0f       	add	r24, r24
    46b4:	99 1f       	adc	r25, r25
    46b6:	0a 94       	dec	r0
    46b8:	e2 f7       	brpl	.-8      	; 0x46b2 <chb_reg_read16+0x3a>
    46ba:	98 2f       	mov	r25, r24
    46bc:	8c 81       	ldd	r24, Y+4	; 0x04
    46be:	89 2b       	or	r24, r25
    46c0:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    46c2:	89 81       	ldd	r24, Y+1	; 0x01
    46c4:	8f 5f       	subi	r24, 0xFF	; 255
    46c6:	89 83       	std	Y+1, r24	; 0x01
    46c8:	89 81       	ldd	r24, Y+1	; 0x01
    46ca:	82 30       	cpi	r24, 0x02	; 2
    46cc:	00 f3       	brcs	.-64     	; 0x468e <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    46ce:	8a 81       	ldd	r24, Y+2	; 0x02
    46d0:	9b 81       	ldd	r25, Y+3	; 0x03
}
    46d2:	24 96       	adiw	r28, 0x04	; 4
    46d4:	cd bf       	out	0x3d, r28	; 61
    46d6:	de bf       	out	0x3e, r29	; 62
    46d8:	df 91       	pop	r29
    46da:	cf 91       	pop	r28
    46dc:	08 95       	ret

000046de <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    46de:	cf 93       	push	r28
    46e0:	df 93       	push	r29
    46e2:	00 d0       	rcall	.+0      	; 0x46e4 <chb_reg_write+0x6>
    46e4:	cd b7       	in	r28, 0x3d	; 61
    46e6:	de b7       	in	r29, 0x3e	; 62
    46e8:	8a 83       	std	Y+2, r24	; 0x02
    46ea:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    46ec:	8a 81       	ldd	r24, Y+2	; 0x02
    46ee:	80 6c       	ori	r24, 0xC0	; 192
    46f0:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    46f2:	8f e3       	ldi	r24, 0x3F	; 63
    46f4:	90 e0       	ldi	r25, 0x00	; 0
    46f6:	fc 01       	movw	r30, r24
    46f8:	80 81       	ld	r24, Z
    46fa:	80 93 4f 40 	sts	0x404F, r24
    46fe:	f8 94       	cli
    RadioCS(TRUE);
    4700:	81 e0       	ldi	r24, 0x01	; 1
    4702:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    4706:	8a 81       	ldd	r24, Y+2	; 0x02
    4708:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    470c:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    470e:	8b 81       	ldd	r24, Y+3	; 0x03
    4710:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    4714:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4716:	80 e0       	ldi	r24, 0x00	; 0
    4718:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>
    CHB_LEAVE_CRIT();
    471c:	8f e3       	ldi	r24, 0x3F	; 63
    471e:	90 e0       	ldi	r25, 0x00	; 0
    4720:	20 91 4f 40 	lds	r18, 0x404F
    4724:	fc 01       	movw	r30, r24
    4726:	20 83       	st	Z, r18
    4728:	78 94       	sei
}
    472a:	23 96       	adiw	r28, 0x03	; 3
    472c:	cd bf       	out	0x3d, r28	; 61
    472e:	de bf       	out	0x3e, r29	; 62
    4730:	df 91       	pop	r29
    4732:	cf 91       	pop	r28
    4734:	08 95       	ret

00004736 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4736:	cf 93       	push	r28
    4738:	df 93       	push	r29
    473a:	00 d0       	rcall	.+0      	; 0x473c <chb_reg_write16+0x6>
    473c:	0f 92       	push	r0
    473e:	cd b7       	in	r28, 0x3d	; 61
    4740:	de b7       	in	r29, 0x3e	; 62
    4742:	8a 83       	std	Y+2, r24	; 0x02
    4744:	6b 83       	std	Y+3, r22	; 0x03
    4746:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4748:	19 82       	std	Y+1, r1	; 0x01
    474a:	1d c0       	rjmp	.+58     	; 0x4786 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    474c:	9a 81       	ldd	r25, Y+2	; 0x02
    474e:	89 81       	ldd	r24, Y+1	; 0x01
    4750:	49 2f       	mov	r20, r25
    4752:	48 0f       	add	r20, r24
    4754:	89 81       	ldd	r24, Y+1	; 0x01
    4756:	88 2f       	mov	r24, r24
    4758:	90 e0       	ldi	r25, 0x00	; 0
    475a:	9c 01       	movw	r18, r24
    475c:	22 0f       	add	r18, r18
    475e:	33 1f       	adc	r19, r19
    4760:	22 0f       	add	r18, r18
    4762:	33 1f       	adc	r19, r19
    4764:	22 0f       	add	r18, r18
    4766:	33 1f       	adc	r19, r19
    4768:	8b 81       	ldd	r24, Y+3	; 0x03
    476a:	9c 81       	ldd	r25, Y+4	; 0x04
    476c:	02 c0       	rjmp	.+4      	; 0x4772 <chb_reg_write16+0x3c>
    476e:	96 95       	lsr	r25
    4770:	87 95       	ror	r24
    4772:	2a 95       	dec	r18
    4774:	e2 f7       	brpl	.-8      	; 0x476e <chb_reg_write16+0x38>
    4776:	98 2f       	mov	r25, r24
    4778:	84 2f       	mov	r24, r20
    477a:	69 2f       	mov	r22, r25
    477c:	0e 94 6f 23 	call	0x46de	; 0x46de <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4780:	89 81       	ldd	r24, Y+1	; 0x01
    4782:	8f 5f       	subi	r24, 0xFF	; 255
    4784:	89 83       	std	Y+1, r24	; 0x01
    4786:	89 81       	ldd	r24, Y+1	; 0x01
    4788:	82 30       	cpi	r24, 0x02	; 2
    478a:	00 f3       	brcs	.-64     	; 0x474c <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    478c:	24 96       	adiw	r28, 0x04	; 4
    478e:	cd bf       	out	0x3d, r28	; 61
    4790:	de bf       	out	0x3e, r29	; 62
    4792:	df 91       	pop	r29
    4794:	cf 91       	pop	r28
    4796:	08 95       	ret

00004798 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4798:	cf 93       	push	r28
    479a:	df 93       	push	r29
    479c:	00 d0       	rcall	.+0      	; 0x479e <chb_reg_write64+0x6>
    479e:	0f 92       	push	r0
    47a0:	cd b7       	in	r28, 0x3d	; 61
    47a2:	de b7       	in	r29, 0x3e	; 62
    47a4:	8a 83       	std	Y+2, r24	; 0x02
    47a6:	6b 83       	std	Y+3, r22	; 0x03
    47a8:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    47aa:	19 82       	std	Y+1, r1	; 0x01
    47ac:	14 c0       	rjmp	.+40     	; 0x47d6 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    47ae:	9a 81       	ldd	r25, Y+2	; 0x02
    47b0:	89 81       	ldd	r24, Y+1	; 0x01
    47b2:	49 2f       	mov	r20, r25
    47b4:	48 0f       	add	r20, r24
    47b6:	89 81       	ldd	r24, Y+1	; 0x01
    47b8:	88 2f       	mov	r24, r24
    47ba:	90 e0       	ldi	r25, 0x00	; 0
    47bc:	2b 81       	ldd	r18, Y+3	; 0x03
    47be:	3c 81       	ldd	r19, Y+4	; 0x04
    47c0:	82 0f       	add	r24, r18
    47c2:	93 1f       	adc	r25, r19
    47c4:	fc 01       	movw	r30, r24
    47c6:	90 81       	ld	r25, Z
    47c8:	84 2f       	mov	r24, r20
    47ca:	69 2f       	mov	r22, r25
    47cc:	0e 94 6f 23 	call	0x46de	; 0x46de <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    47d0:	89 81       	ldd	r24, Y+1	; 0x01
    47d2:	8f 5f       	subi	r24, 0xFF	; 255
    47d4:	89 83       	std	Y+1, r24	; 0x01
    47d6:	89 81       	ldd	r24, Y+1	; 0x01
    47d8:	88 30       	cpi	r24, 0x08	; 8
    47da:	48 f3       	brcs	.-46     	; 0x47ae <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    47dc:	24 96       	adiw	r28, 0x04	; 4
    47de:	cd bf       	out	0x3d, r28	; 61
    47e0:	de bf       	out	0x3e, r29	; 62
    47e2:	df 91       	pop	r29
    47e4:	cf 91       	pop	r28
    47e6:	08 95       	ret

000047e8 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    47e8:	cf 93       	push	r28
    47ea:	df 93       	push	r29
    47ec:	00 d0       	rcall	.+0      	; 0x47ee <chb_reg_read_mod_write+0x6>
    47ee:	0f 92       	push	r0
    47f0:	cd b7       	in	r28, 0x3d	; 61
    47f2:	de b7       	in	r29, 0x3e	; 62
    47f4:	8a 83       	std	Y+2, r24	; 0x02
    47f6:	6b 83       	std	Y+3, r22	; 0x03
    47f8:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    47fa:	8a 81       	ldd	r24, Y+2	; 0x02
    47fc:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    4800:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4802:	9b 81       	ldd	r25, Y+3	; 0x03
    4804:	8c 81       	ldd	r24, Y+4	; 0x04
    4806:	89 23       	and	r24, r25
    4808:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    480a:	8c 81       	ldd	r24, Y+4	; 0x04
    480c:	98 2f       	mov	r25, r24
    480e:	90 95       	com	r25
    4810:	89 81       	ldd	r24, Y+1	; 0x01
    4812:	89 23       	and	r24, r25
    4814:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4816:	99 81       	ldd	r25, Y+1	; 0x01
    4818:	8b 81       	ldd	r24, Y+3	; 0x03
    481a:	89 2b       	or	r24, r25
    481c:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    481e:	8a 81       	ldd	r24, Y+2	; 0x02
    4820:	69 81       	ldd	r22, Y+1	; 0x01
    4822:	0e 94 6f 23 	call	0x46de	; 0x46de <chb_reg_write>
}
    4826:	24 96       	adiw	r28, 0x04	; 4
    4828:	cd bf       	out	0x3d, r28	; 61
    482a:	de bf       	out	0x3e, r29	; 62
    482c:	df 91       	pop	r29
    482e:	cf 91       	pop	r28
    4830:	08 95       	ret

00004832 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4832:	cf 93       	push	r28
    4834:	df 93       	push	r29
    4836:	cd b7       	in	r28, 0x3d	; 61
    4838:	de b7       	in	r29, 0x3e	; 62
    483a:	28 97       	sbiw	r28, 0x08	; 8
    483c:	cd bf       	out	0x3d, r28	; 61
    483e:	de bf       	out	0x3e, r29	; 62
    4840:	8b 83       	std	Y+3, r24	; 0x03
    4842:	9c 83       	std	Y+4, r25	; 0x04
    4844:	6d 83       	std	Y+5, r22	; 0x05
    4846:	4e 83       	std	Y+6, r20	; 0x06
    4848:	5f 83       	std	Y+7, r21	; 0x07
    484a:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    484c:	8d 81       	ldd	r24, Y+5	; 0x05
    484e:	28 2f       	mov	r18, r24
    4850:	30 e0       	ldi	r19, 0x00	; 0
    4852:	88 85       	ldd	r24, Y+8	; 0x08
    4854:	88 2f       	mov	r24, r24
    4856:	90 e0       	ldi	r25, 0x00	; 0
    4858:	82 0f       	add	r24, r18
    485a:	93 1f       	adc	r25, r19
    485c:	80 38       	cpi	r24, 0x80	; 128
    485e:	91 05       	cpc	r25, r1
    4860:	0c f0       	brlt	.+2      	; 0x4864 <chb_frame_write+0x32>
    4862:	45 c0       	rjmp	.+138    	; 0x48ee <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4864:	8f e3       	ldi	r24, 0x3F	; 63
    4866:	90 e0       	ldi	r25, 0x00	; 0
    4868:	fc 01       	movw	r30, r24
    486a:	80 81       	ld	r24, Z
    486c:	80 93 4f 40 	sts	0x404F, r24
    4870:	f8 94       	cli
    RadioCS(TRUE); 
    4872:	81 e0       	ldi	r24, 0x01	; 1
    4874:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    4878:	80 e6       	ldi	r24, 0x60	; 96
    487a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    487e:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4880:	19 82       	std	Y+1, r1	; 0x01
    4882:	10 c0       	rjmp	.+32     	; 0x48a4 <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4884:	8b 81       	ldd	r24, Y+3	; 0x03
    4886:	9c 81       	ldd	r25, Y+4	; 0x04
    4888:	fc 01       	movw	r30, r24
    488a:	20 81       	ld	r18, Z
    488c:	8b 81       	ldd	r24, Y+3	; 0x03
    488e:	9c 81       	ldd	r25, Y+4	; 0x04
    4890:	01 96       	adiw	r24, 0x01	; 1
    4892:	8b 83       	std	Y+3, r24	; 0x03
    4894:	9c 83       	std	Y+4, r25	; 0x04
    4896:	82 2f       	mov	r24, r18
    4898:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    489c:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    489e:	89 81       	ldd	r24, Y+1	; 0x01
    48a0:	8f 5f       	subi	r24, 0xFF	; 255
    48a2:	89 83       	std	Y+1, r24	; 0x01
    48a4:	99 81       	ldd	r25, Y+1	; 0x01
    48a6:	8d 81       	ldd	r24, Y+5	; 0x05
    48a8:	98 17       	cp	r25, r24
    48aa:	60 f3       	brcs	.-40     	; 0x4884 <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    48ac:	19 82       	std	Y+1, r1	; 0x01
    48ae:	10 c0       	rjmp	.+32     	; 0x48d0 <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    48b0:	8e 81       	ldd	r24, Y+6	; 0x06
    48b2:	9f 81       	ldd	r25, Y+7	; 0x07
    48b4:	fc 01       	movw	r30, r24
    48b6:	20 81       	ld	r18, Z
    48b8:	8e 81       	ldd	r24, Y+6	; 0x06
    48ba:	9f 81       	ldd	r25, Y+7	; 0x07
    48bc:	01 96       	adiw	r24, 0x01	; 1
    48be:	8e 83       	std	Y+6, r24	; 0x06
    48c0:	9f 83       	std	Y+7, r25	; 0x07
    48c2:	82 2f       	mov	r24, r18
    48c4:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    48c8:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    48ca:	89 81       	ldd	r24, Y+1	; 0x01
    48cc:	8f 5f       	subi	r24, 0xFF	; 255
    48ce:	89 83       	std	Y+1, r24	; 0x01
    48d0:	99 81       	ldd	r25, Y+1	; 0x01
    48d2:	88 85       	ldd	r24, Y+8	; 0x08
    48d4:	98 17       	cp	r25, r24
    48d6:	60 f3       	brcs	.-40     	; 0x48b0 <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    48d8:	80 e0       	ldi	r24, 0x00	; 0
    48da:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>
    CHB_LEAVE_CRIT();
    48de:	8f e3       	ldi	r24, 0x3F	; 63
    48e0:	90 e0       	ldi	r25, 0x00	; 0
    48e2:	20 91 4f 40 	lds	r18, 0x404F
    48e6:	fc 01       	movw	r30, r24
    48e8:	20 83       	st	Z, r18
    48ea:	78 94       	sei
    48ec:	01 c0       	rjmp	.+2      	; 0x48f0 <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    48ee:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    48f0:	28 96       	adiw	r28, 0x08	; 8
    48f2:	cd bf       	out	0x3d, r28	; 61
    48f4:	de bf       	out	0x3e, r29	; 62
    48f6:	df 91       	pop	r29
    48f8:	cf 91       	pop	r28
    48fa:	08 95       	ret

000048fc <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    48fc:	0f 93       	push	r16
    48fe:	1f 93       	push	r17
    4900:	cf 93       	push	r28
    4902:	df 93       	push	r29
    4904:	cd b7       	in	r28, 0x3d	; 61
    4906:	de b7       	in	r29, 0x3e	; 62
    4908:	e7 97       	sbiw	r28, 0x37	; 55
    490a:	cd bf       	out	0x3d, r28	; 61
    490c:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    490e:	8f e3       	ldi	r24, 0x3F	; 63
    4910:	90 e0       	ldi	r25, 0x00	; 0
    4912:	fc 01       	movw	r30, r24
    4914:	80 81       	ld	r24, Z
    4916:	80 93 4f 40 	sts	0x404F, r24
    491a:	f8 94       	cli
    RadioCS(TRUE);
    491c:	81 e0       	ldi	r24, 0x01	; 1
    491e:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4922:	80 e2       	ldi	r24, 0x20	; 32
    4924:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    len = SPID_write(0);
    4928:	80 e0       	ldi	r24, 0x00	; 0
    492a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    492e:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4930:	8a 81       	ldd	r24, Y+2	; 0x02
    4932:	83 30       	cpi	r24, 0x03	; 3
    4934:	08 f4       	brcc	.+2      	; 0x4938 <chb_frame_read+0x3c>
    4936:	66 c0       	rjmp	.+204    	; 0x4a04 <chb_frame_read+0x108>
    4938:	8a 81       	ldd	r24, Y+2	; 0x02
    493a:	88 23       	and	r24, r24
    493c:	0c f4       	brge	.+2      	; 0x4940 <chb_frame_read+0x44>
    493e:	62 c0       	rjmp	.+196    	; 0x4a04 <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4940:	8a 81       	ldd	r24, Y+2	; 0x02
    4942:	08 2f       	mov	r16, r24
    4944:	10 e0       	ldi	r17, 0x00	; 0
    4946:	0e 94 02 21 	call	0x4204	; 0x4204 <chb_buf_get_len>
    494a:	88 2f       	mov	r24, r24
    494c:	90 e0       	ldi	r25, 0x00	; 0
    494e:	20 e8       	ldi	r18, 0x80	; 128
    4950:	30 e0       	ldi	r19, 0x00	; 0
    4952:	a9 01       	movw	r20, r18
    4954:	48 1b       	sub	r20, r24
    4956:	59 0b       	sbc	r21, r25
    4958:	ca 01       	movw	r24, r20
    495a:	08 17       	cp	r16, r24
    495c:	19 07       	cpc	r17, r25
    495e:	f4 f4       	brge	.+60     	; 0x499c <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4960:	8a 81       	ldd	r24, Y+2	; 0x02
    4962:	0e 94 ba 20 	call	0x4174	; 0x4174 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4966:	19 82       	std	Y+1, r1	; 0x01
    4968:	0a c0       	rjmp	.+20     	; 0x497e <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    496a:	80 e0       	ldi	r24, 0x00	; 0
    496c:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    4970:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4972:	8b 81       	ldd	r24, Y+3	; 0x03
    4974:	0e 94 ba 20 	call	0x4174	; 0x4174 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4978:	89 81       	ldd	r24, Y+1	; 0x01
    497a:	8f 5f       	subi	r24, 0xFF	; 255
    497c:	89 83       	std	Y+1, r24	; 0x01
    497e:	99 81       	ldd	r25, Y+1	; 0x01
    4980:	8a 81       	ldd	r24, Y+2	; 0x02
    4982:	98 17       	cp	r25, r24
    4984:	90 f3       	brcs	.-28     	; 0x496a <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4986:	80 e8       	ldi	r24, 0x80	; 128
    4988:	96 e0       	ldi	r25, 0x06	; 6
    498a:	24 e0       	ldi	r18, 0x04	; 4
    498c:	fc 01       	movw	r30, r24
    498e:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4990:	80 e8       	ldi	r24, 0x80	; 128
    4992:	96 e0       	ldi	r25, 0x06	; 6
    4994:	24 e0       	ldi	r18, 0x04	; 4
    4996:	fc 01       	movw	r30, r24
    4998:	26 83       	std	Z+6, r18	; 0x06
    499a:	34 c0       	rjmp	.+104    	; 0x4a04 <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    499c:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <chb_get_pcb>
    49a0:	8c 83       	std	Y+4, r24	; 0x04
    49a2:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    49a4:	19 82       	std	Y+1, r1	; 0x01
    49a6:	07 c0       	rjmp	.+14     	; 0x49b6 <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    49a8:	80 e0       	ldi	r24, 0x00	; 0
    49aa:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    49ae:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    49b0:	89 81       	ldd	r24, Y+1	; 0x01
    49b2:	8f 5f       	subi	r24, 0xFF	; 255
    49b4:	89 83       	std	Y+1, r24	; 0x01
    49b6:	99 81       	ldd	r25, Y+1	; 0x01
    49b8:	8a 81       	ldd	r24, Y+2	; 0x02
    49ba:	98 17       	cp	r25, r24
    49bc:	a8 f3       	brcs	.-22     	; 0x49a8 <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    49be:	8c 81       	ldd	r24, Y+4	; 0x04
    49c0:	9d 81       	ldd	r25, Y+5	; 0x05
    49c2:	fc 01       	movw	r30, r24
    49c4:	85 85       	ldd	r24, Z+13	; 0x0d
    49c6:	96 85       	ldd	r25, Z+14	; 0x0e
    49c8:	9c 01       	movw	r18, r24
    49ca:	2f 5f       	subi	r18, 0xFF	; 255
    49cc:	3f 4f       	sbci	r19, 0xFF	; 255
    49ce:	8c 81       	ldd	r24, Y+4	; 0x04
    49d0:	9d 81       	ldd	r25, Y+5	; 0x05
    49d2:	fc 01       	movw	r30, r24
    49d4:	25 87       	std	Z+13, r18	; 0x0d
    49d6:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    49d8:	ce 01       	movw	r24, r28
    49da:	06 96       	adiw	r24, 0x06	; 6
    49dc:	28 ee       	ldi	r18, 0xE8	; 232
    49de:	31 e0       	ldi	r19, 0x01	; 1
    49e0:	b9 01       	movw	r22, r18
    49e2:	0e 94 b9 62 	call	0xc572	; 0xc572 <strcpy_P>
            printf(buf);
    49e6:	0f 92       	push	r0
    49e8:	0f 92       	push	r0
    49ea:	8d b7       	in	r24, 0x3d	; 61
    49ec:	9e b7       	in	r25, 0x3e	; 62
    49ee:	01 96       	adiw	r24, 0x01	; 1
    49f0:	9e 01       	movw	r18, r28
    49f2:	2a 5f       	subi	r18, 0xFA	; 250
    49f4:	3f 4f       	sbci	r19, 0xFF	; 255
    49f6:	fc 01       	movw	r30, r24
    49f8:	20 83       	st	Z, r18
    49fa:	31 83       	std	Z+1, r19	; 0x01
    49fc:	0e 94 15 63 	call	0xc62a	; 0xc62a <printf>
    4a00:	0f 90       	pop	r0
    4a02:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4a04:	80 e0       	ldi	r24, 0x00	; 0
    4a06:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>
    CHB_LEAVE_CRIT();
    4a0a:	8f e3       	ldi	r24, 0x3F	; 63
    4a0c:	90 e0       	ldi	r25, 0x00	; 0
    4a0e:	20 91 4f 40 	lds	r18, 0x404F
    4a12:	fc 01       	movw	r30, r24
    4a14:	20 83       	st	Z, r18
    4a16:	78 94       	sei
}
    4a18:	e7 96       	adiw	r28, 0x37	; 55
    4a1a:	cd bf       	out	0x3d, r28	; 61
    4a1c:	de bf       	out	0x3e, r29	; 62
    4a1e:	df 91       	pop	r29
    4a20:	cf 91       	pop	r28
    4a22:	1f 91       	pop	r17
    4a24:	0f 91       	pop	r16
    4a26:	08 95       	ret

00004a28 <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4a28:	cf 93       	push	r28
    4a2a:	df 93       	push	r29
    4a2c:	0f 92       	push	r0
    4a2e:	cd b7       	in	r28, 0x3d	; 61
    4a30:	de b7       	in	r29, 0x3e	; 62
    4a32:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4a34:	89 81       	ldd	r24, Y+1	; 0x01
    4a36:	88 2f       	mov	r24, r24
    4a38:	90 e0       	ldi	r25, 0x00	; 0
    4a3a:	81 30       	cpi	r24, 0x01	; 1
    4a3c:	91 05       	cpc	r25, r1
    4a3e:	c1 f0       	breq	.+48     	; 0x4a70 <chb_set_mode+0x48>
    4a40:	82 30       	cpi	r24, 0x02	; 2
    4a42:	91 05       	cpc	r25, r1
    4a44:	1c f4       	brge	.+6      	; 0x4a4c <chb_set_mode+0x24>
    4a46:	00 97       	sbiw	r24, 0x00	; 0
    4a48:	41 f0       	breq	.+16     	; 0x4a5a <chb_set_mode+0x32>
    4a4a:	33 c0       	rjmp	.+102    	; 0x4ab2 <chb_set_mode+0x8a>
    4a4c:	82 30       	cpi	r24, 0x02	; 2
    4a4e:	91 05       	cpc	r25, r1
    4a50:	d1 f0       	breq	.+52     	; 0x4a86 <chb_set_mode+0x5e>
    4a52:	83 30       	cpi	r24, 0x03	; 3
    4a54:	91 05       	cpc	r25, r1
    4a56:	11 f1       	breq	.+68     	; 0x4a9c <chb_set_mode+0x74>
    4a58:	2c c0       	rjmp	.+88     	; 0x4ab2 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4a5a:	8c e0       	ldi	r24, 0x0C	; 12
    4a5c:	68 e0       	ldi	r22, 0x08	; 8
    4a5e:	4f e3       	ldi	r20, 0x3F	; 63
    4a60:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a64:	86 e1       	ldi	r24, 0x16	; 22
    4a66:	62 e0       	ldi	r22, 0x02	; 2
    4a68:	43 e0       	ldi	r20, 0x03	; 3
    4a6a:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        break;
    4a6e:	21 c0       	rjmp	.+66     	; 0x4ab2 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4a70:	8c e0       	ldi	r24, 0x0C	; 12
    4a72:	6c e0       	ldi	r22, 0x0C	; 12
    4a74:	4f e3       	ldi	r20, 0x3F	; 63
    4a76:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a7a:	86 e1       	ldi	r24, 0x16	; 22
    4a7c:	62 e0       	ldi	r22, 0x02	; 2
    4a7e:	43 e0       	ldi	r20, 0x03	; 3
    4a80:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        break;
    4a84:	16 c0       	rjmp	.+44     	; 0x4ab2 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4a86:	8c e0       	ldi	r24, 0x0C	; 12
    4a88:	6c e1       	ldi	r22, 0x1C	; 28
    4a8a:	4f e3       	ldi	r20, 0x3F	; 63
    4a8c:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a90:	86 e1       	ldi	r24, 0x16	; 22
    4a92:	62 e0       	ldi	r22, 0x02	; 2
    4a94:	43 e0       	ldi	r20, 0x03	; 3
    4a96:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        break;
    4a9a:	0b c0       	rjmp	.+22     	; 0x4ab2 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4a9c:	8c e0       	ldi	r24, 0x0C	; 12
    4a9e:	60 e0       	ldi	r22, 0x00	; 0
    4aa0:	4f e3       	ldi	r20, 0x3F	; 63
    4aa2:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4aa6:	86 e1       	ldi	r24, 0x16	; 22
    4aa8:	63 e0       	ldi	r22, 0x03	; 3
    4aaa:	43 e0       	ldi	r20, 0x03	; 3
    4aac:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
        break;
    4ab0:	00 00       	nop
    }
}
    4ab2:	0f 90       	pop	r0
    4ab4:	df 91       	pop	r29
    4ab6:	cf 91       	pop	r28
    4ab8:	08 95       	ret

00004aba <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4aba:	0f 93       	push	r16
    4abc:	1f 93       	push	r17
    4abe:	cf 93       	push	r28
    4ac0:	df 93       	push	r29
    4ac2:	cd b7       	in	r28, 0x3d	; 61
    4ac4:	de b7       	in	r29, 0x3e	; 62
    4ac6:	6a 97       	sbiw	r28, 0x1a	; 26
    4ac8:	cd bf       	out	0x3d, r28	; 61
    4aca:	de bf       	out	0x3e, r29	; 62
    4acc:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4ace:	88 e0       	ldi	r24, 0x08	; 8
    4ad0:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4ad2:	4f e1       	ldi	r20, 0x1F	; 31
    4ad4:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4ad8:	0e 94 0b 21 	call	0x4216	; 0x4216 <chb_get_state>
    4adc:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4ade:	89 81       	ldd	r24, Y+1	; 0x01
    4ae0:	86 30       	cpi	r24, 0x06	; 6
    4ae2:	21 f0       	breq	.+8      	; 0x4aec <chb_set_channel+0x32>
    4ae4:	89 81       	ldd	r24, Y+1	; 0x01
    4ae6:	89 30       	cpi	r24, 0x09	; 9
    4ae8:	09 f0       	breq	.+2      	; 0x4aec <chb_set_channel+0x32>
    4aea:	d5 c0       	rjmp	.+426    	; 0x4c96 <chb_set_channel+0x1dc>
    4aec:	80 e0       	ldi	r24, 0x00	; 0
    4aee:	90 e0       	ldi	r25, 0x00	; 0
    4af0:	ac ed       	ldi	r26, 0xDC	; 220
    4af2:	b2 e4       	ldi	r27, 0x42	; 66
    4af4:	8a 83       	std	Y+2, r24	; 0x02
    4af6:	9b 83       	std	Y+3, r25	; 0x03
    4af8:	ac 83       	std	Y+4, r26	; 0x04
    4afa:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4afc:	6a 81       	ldd	r22, Y+2	; 0x02
    4afe:	7b 81       	ldd	r23, Y+3	; 0x03
    4b00:	8c 81       	ldd	r24, Y+4	; 0x04
    4b02:	9d 81       	ldd	r25, Y+5	; 0x05
    4b04:	2b ea       	ldi	r18, 0xAB	; 171
    4b06:	3a ea       	ldi	r19, 0xAA	; 170
    4b08:	4a ea       	ldi	r20, 0xAA	; 170
    4b0a:	5e e3       	ldi	r21, 0x3E	; 62
    4b0c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4b10:	dc 01       	movw	r26, r24
    4b12:	cb 01       	movw	r24, r22
    4b14:	8e 83       	std	Y+6, r24	; 0x06
    4b16:	9f 83       	std	Y+7, r25	; 0x07
    4b18:	a8 87       	std	Y+8, r26	; 0x08
    4b1a:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4b1c:	11 e0       	ldi	r17, 0x01	; 1
    4b1e:	6e 81       	ldd	r22, Y+6	; 0x06
    4b20:	7f 81       	ldd	r23, Y+7	; 0x07
    4b22:	88 85       	ldd	r24, Y+8	; 0x08
    4b24:	99 85       	ldd	r25, Y+9	; 0x09
    4b26:	20 e0       	ldi	r18, 0x00	; 0
    4b28:	30 e0       	ldi	r19, 0x00	; 0
    4b2a:	40 e8       	ldi	r20, 0x80	; 128
    4b2c:	5f e3       	ldi	r21, 0x3F	; 63
    4b2e:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    4b32:	88 23       	and	r24, r24
    4b34:	0c f0       	brlt	.+2      	; 0x4b38 <chb_set_channel+0x7e>
    4b36:	10 e0       	ldi	r17, 0x00	; 0
    4b38:	11 23       	and	r17, r17
    4b3a:	19 f0       	breq	.+6      	; 0x4b42 <chb_set_channel+0x88>
		__ticks = 1;
    4b3c:	81 e0       	ldi	r24, 0x01	; 1
    4b3e:	8a 87       	std	Y+10, r24	; 0x0a
    4b40:	a3 c0       	rjmp	.+326    	; 0x4c88 <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4b42:	11 e0       	ldi	r17, 0x01	; 1
    4b44:	6e 81       	ldd	r22, Y+6	; 0x06
    4b46:	7f 81       	ldd	r23, Y+7	; 0x07
    4b48:	88 85       	ldd	r24, Y+8	; 0x08
    4b4a:	99 85       	ldd	r25, Y+9	; 0x09
    4b4c:	20 e0       	ldi	r18, 0x00	; 0
    4b4e:	30 e0       	ldi	r19, 0x00	; 0
    4b50:	4f e7       	ldi	r20, 0x7F	; 127
    4b52:	53 e4       	ldi	r21, 0x43	; 67
    4b54:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    4b58:	18 16       	cp	r1, r24
    4b5a:	0c f0       	brlt	.+2      	; 0x4b5e <chb_set_channel+0xa4>
    4b5c:	10 e0       	ldi	r17, 0x00	; 0
    4b5e:	11 23       	and	r17, r17
    4b60:	09 f4       	brne	.+2      	; 0x4b64 <chb_set_channel+0xaa>
    4b62:	89 c0       	rjmp	.+274    	; 0x4c76 <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4b64:	6a 81       	ldd	r22, Y+2	; 0x02
    4b66:	7b 81       	ldd	r23, Y+3	; 0x03
    4b68:	8c 81       	ldd	r24, Y+4	; 0x04
    4b6a:	9d 81       	ldd	r25, Y+5	; 0x05
    4b6c:	20 e0       	ldi	r18, 0x00	; 0
    4b6e:	30 e0       	ldi	r19, 0x00	; 0
    4b70:	4a e7       	ldi	r20, 0x7A	; 122
    4b72:	54 e4       	ldi	r21, 0x44	; 68
    4b74:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    4b78:	dc 01       	movw	r26, r24
    4b7a:	cb 01       	movw	r24, r22
    4b7c:	8b 87       	std	Y+11, r24	; 0x0b
    4b7e:	9c 87       	std	Y+12, r25	; 0x0c
    4b80:	ad 87       	std	Y+13, r26	; 0x0d
    4b82:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4b84:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b86:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b88:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b8c:	20 e0       	ldi	r18, 0x00	; 0
    4b8e:	30 e0       	ldi	r19, 0x00	; 0
    4b90:	4a e7       	ldi	r20, 0x7A	; 122
    4b92:	53 e4       	ldi	r21, 0x43	; 67
    4b94:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4b98:	dc 01       	movw	r26, r24
    4b9a:	cb 01       	movw	r24, r22
    4b9c:	8f 87       	std	Y+15, r24	; 0x0f
    4b9e:	98 8b       	std	Y+16, r25	; 0x10
    4ba0:	a9 8b       	std	Y+17, r26	; 0x11
    4ba2:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4ba4:	11 e0       	ldi	r17, 0x01	; 1
    4ba6:	6f 85       	ldd	r22, Y+15	; 0x0f
    4ba8:	78 89       	ldd	r23, Y+16	; 0x10
    4baa:	89 89       	ldd	r24, Y+17	; 0x11
    4bac:	9a 89       	ldd	r25, Y+18	; 0x12
    4bae:	20 e0       	ldi	r18, 0x00	; 0
    4bb0:	30 e0       	ldi	r19, 0x00	; 0
    4bb2:	40 e8       	ldi	r20, 0x80	; 128
    4bb4:	5f e3       	ldi	r21, 0x3F	; 63
    4bb6:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    4bba:	88 23       	and	r24, r24
    4bbc:	0c f0       	brlt	.+2      	; 0x4bc0 <chb_set_channel+0x106>
    4bbe:	10 e0       	ldi	r17, 0x00	; 0
    4bc0:	11 23       	and	r17, r17
    4bc2:	29 f0       	breq	.+10     	; 0x4bce <chb_set_channel+0x114>
		__ticks = 1;
    4bc4:	81 e0       	ldi	r24, 0x01	; 1
    4bc6:	90 e0       	ldi	r25, 0x00	; 0
    4bc8:	8b 8b       	std	Y+19, r24	; 0x13
    4bca:	9c 8b       	std	Y+20, r25	; 0x14
    4bcc:	46 c0       	rjmp	.+140    	; 0x4c5a <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4bce:	11 e0       	ldi	r17, 0x01	; 1
    4bd0:	6f 85       	ldd	r22, Y+15	; 0x0f
    4bd2:	78 89       	ldd	r23, Y+16	; 0x10
    4bd4:	89 89       	ldd	r24, Y+17	; 0x11
    4bd6:	9a 89       	ldd	r25, Y+18	; 0x12
    4bd8:	20 e0       	ldi	r18, 0x00	; 0
    4bda:	3f ef       	ldi	r19, 0xFF	; 255
    4bdc:	4f e7       	ldi	r20, 0x7F	; 127
    4bde:	57 e4       	ldi	r21, 0x47	; 71
    4be0:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    4be4:	18 16       	cp	r1, r24
    4be6:	0c f0       	brlt	.+2      	; 0x4bea <chb_set_channel+0x130>
    4be8:	10 e0       	ldi	r17, 0x00	; 0
    4bea:	11 23       	and	r17, r17
    4bec:	61 f1       	breq	.+88     	; 0x4c46 <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4bee:	6b 85       	ldd	r22, Y+11	; 0x0b
    4bf0:	7c 85       	ldd	r23, Y+12	; 0x0c
    4bf2:	8d 85       	ldd	r24, Y+13	; 0x0d
    4bf4:	9e 85       	ldd	r25, Y+14	; 0x0e
    4bf6:	20 e0       	ldi	r18, 0x00	; 0
    4bf8:	30 e0       	ldi	r19, 0x00	; 0
    4bfa:	40 e2       	ldi	r20, 0x20	; 32
    4bfc:	51 e4       	ldi	r21, 0x41	; 65
    4bfe:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4c02:	dc 01       	movw	r26, r24
    4c04:	cb 01       	movw	r24, r22
    4c06:	bc 01       	movw	r22, r24
    4c08:	cd 01       	movw	r24, r26
    4c0a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    4c0e:	dc 01       	movw	r26, r24
    4c10:	cb 01       	movw	r24, r22
    4c12:	8b 8b       	std	Y+19, r24	; 0x13
    4c14:	9c 8b       	std	Y+20, r25	; 0x14
    4c16:	12 c0       	rjmp	.+36     	; 0x4c3c <chb_set_channel+0x182>
    4c18:	89 e1       	ldi	r24, 0x19	; 25
    4c1a:	90 e0       	ldi	r25, 0x00	; 0
    4c1c:	8d 8b       	std	Y+21, r24	; 0x15
    4c1e:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4c20:	8d 89       	ldd	r24, Y+21	; 0x15
    4c22:	9e 89       	ldd	r25, Y+22	; 0x16
    4c24:	8c 01       	movw	r16, r24
    4c26:	c8 01       	movw	r24, r16
    4c28:	01 97       	sbiw	r24, 0x01	; 1
    4c2a:	f1 f7       	brne	.-4      	; 0x4c28 <chb_set_channel+0x16e>
    4c2c:	8c 01       	movw	r16, r24
    4c2e:	0d 8b       	std	Y+21, r16	; 0x15
    4c30:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c32:	8b 89       	ldd	r24, Y+19	; 0x13
    4c34:	9c 89       	ldd	r25, Y+20	; 0x14
    4c36:	01 97       	sbiw	r24, 0x01	; 1
    4c38:	8b 8b       	std	Y+19, r24	; 0x13
    4c3a:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c3c:	8b 89       	ldd	r24, Y+19	; 0x13
    4c3e:	9c 89       	ldd	r25, Y+20	; 0x14
    4c40:	00 97       	sbiw	r24, 0x00	; 0
    4c42:	51 f7       	brne	.-44     	; 0x4c18 <chb_set_channel+0x15e>
    4c44:	28 c0       	rjmp	.+80     	; 0x4c96 <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4c46:	6f 85       	ldd	r22, Y+15	; 0x0f
    4c48:	78 89       	ldd	r23, Y+16	; 0x10
    4c4a:	89 89       	ldd	r24, Y+17	; 0x11
    4c4c:	9a 89       	ldd	r25, Y+18	; 0x12
    4c4e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    4c52:	dc 01       	movw	r26, r24
    4c54:	cb 01       	movw	r24, r22
    4c56:	8b 8b       	std	Y+19, r24	; 0x13
    4c58:	9c 8b       	std	Y+20, r25	; 0x14
    4c5a:	8b 89       	ldd	r24, Y+19	; 0x13
    4c5c:	9c 89       	ldd	r25, Y+20	; 0x14
    4c5e:	8f 8b       	std	Y+23, r24	; 0x17
    4c60:	98 8f       	std	Y+24, r25	; 0x18
    4c62:	8f 89       	ldd	r24, Y+23	; 0x17
    4c64:	98 8d       	ldd	r25, Y+24	; 0x18
    4c66:	8c 01       	movw	r16, r24
    4c68:	c8 01       	movw	r24, r16
    4c6a:	01 97       	sbiw	r24, 0x01	; 1
    4c6c:	f1 f7       	brne	.-4      	; 0x4c6a <chb_set_channel+0x1b0>
    4c6e:	8c 01       	movw	r16, r24
    4c70:	0f 8b       	std	Y+23, r16	; 0x17
    4c72:	18 8f       	std	Y+24, r17	; 0x18
    4c74:	10 c0       	rjmp	.+32     	; 0x4c96 <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4c76:	6e 81       	ldd	r22, Y+6	; 0x06
    4c78:	7f 81       	ldd	r23, Y+7	; 0x07
    4c7a:	88 85       	ldd	r24, Y+8	; 0x08
    4c7c:	99 85       	ldd	r25, Y+9	; 0x09
    4c7e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    4c82:	dc 01       	movw	r26, r24
    4c84:	cb 01       	movw	r24, r22
    4c86:	8a 87       	std	Y+10, r24	; 0x0a
    4c88:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c8a:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4c8c:	89 8d       	ldd	r24, Y+25	; 0x19
    4c8e:	18 2f       	mov	r17, r24
    4c90:	1a 95       	dec	r17
    4c92:	f1 f7       	brne	.-4      	; 0x4c90 <chb_set_channel+0x1d6>
    4c94:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4c96:	88 e0       	ldi	r24, 0x08	; 8
    4c98:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    4c9c:	88 2f       	mov	r24, r24
    4c9e:	90 e0       	ldi	r25, 0x00	; 0
    4ca0:	9c 01       	movw	r18, r24
    4ca2:	2f 71       	andi	r18, 0x1F	; 31
    4ca4:	30 70       	andi	r19, 0x00	; 0
    4ca6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4ca8:	88 2f       	mov	r24, r24
    4caa:	90 e0       	ldi	r25, 0x00	; 0
    4cac:	28 17       	cp	r18, r24
    4cae:	39 07       	cpc	r19, r25
    4cb0:	11 f4       	brne	.+4      	; 0x4cb6 <chb_set_channel+0x1fc>
    4cb2:	80 e4       	ldi	r24, 0x40	; 64
    4cb4:	01 c0       	rjmp	.+2      	; 0x4cb8 <chb_set_channel+0x1fe>
    4cb6:	83 e4       	ldi	r24, 0x43	; 67
}
    4cb8:	6a 96       	adiw	r28, 0x1a	; 26
    4cba:	cd bf       	out	0x3d, r28	; 61
    4cbc:	de bf       	out	0x3e, r29	; 62
    4cbe:	df 91       	pop	r29
    4cc0:	cf 91       	pop	r28
    4cc2:	1f 91       	pop	r17
    4cc4:	0f 91       	pop	r16
    4cc6:	08 95       	ret

00004cc8 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4cc8:	cf 93       	push	r28
    4cca:	df 93       	push	r29
    4ccc:	0f 92       	push	r0
    4cce:	cd b7       	in	r28, 0x3d	; 61
    4cd0:	de b7       	in	r29, 0x3e	; 62
    4cd2:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4cd4:	85 e0       	ldi	r24, 0x05	; 5
    4cd6:	69 81       	ldd	r22, Y+1	; 0x01
    4cd8:	0e 94 6f 23 	call	0x46de	; 0x46de <chb_reg_write>
}
    4cdc:	0f 90       	pop	r0
    4cde:	df 91       	pop	r29
    4ce0:	cf 91       	pop	r28
    4ce2:	08 95       	ret

00004ce4 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4ce4:	0f 93       	push	r16
    4ce6:	1f 93       	push	r17
    4ce8:	cf 93       	push	r28
    4cea:	df 93       	push	r29
    4cec:	cd b7       	in	r28, 0x3d	; 61
    4cee:	de b7       	in	r29, 0x3e	; 62
    4cf0:	c2 56       	subi	r28, 0x62	; 98
    4cf2:	d0 40       	sbci	r29, 0x00	; 0
    4cf4:	cd bf       	out	0x3d, r28	; 61
    4cf6:	de bf       	out	0x3e, r29	; 62
    4cf8:	9e 01       	movw	r18, r28
    4cfa:	2e 59       	subi	r18, 0x9E	; 158
    4cfc:	3f 4f       	sbci	r19, 0xFF	; 255
    4cfe:	f9 01       	movw	r30, r18
    4d00:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4d02:	84 e6       	ldi	r24, 0x64	; 100
    4d04:	96 e0       	ldi	r25, 0x06	; 6
    4d06:	fc 01       	movw	r30, r24
    4d08:	80 81       	ld	r24, Z
    4d0a:	88 2f       	mov	r24, r24
    4d0c:	90 e0       	ldi	r25, 0x00	; 0
    4d0e:	82 70       	andi	r24, 0x02	; 2
    4d10:	90 70       	andi	r25, 0x00	; 0
    4d12:	00 97       	sbiw	r24, 0x00	; 0
    4d14:	11 f0       	breq	.+4      	; 0x4d1a <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4d16:	84 e4       	ldi	r24, 0x44	; 68
    4d18:	91 c4       	rjmp	.+2338   	; 0x563c <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4d1a:	0e 94 0b 21 	call	0x4216	; 0x4216 <chb_get_state>
    4d1e:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4d20:	89 81       	ldd	r24, Y+1	; 0x01
    4d22:	82 31       	cpi	r24, 0x12	; 18
    4d24:	49 f0       	breq	.+18     	; 0x4d38 <chb_set_state+0x54>
    4d26:	89 81       	ldd	r24, Y+1	; 0x01
    4d28:	81 31       	cpi	r24, 0x11	; 17
    4d2a:	31 f0       	breq	.+12     	; 0x4d38 <chb_set_state+0x54>
    4d2c:	89 81       	ldd	r24, Y+1	; 0x01
    4d2e:	81 30       	cpi	r24, 0x01	; 1
    4d30:	19 f0       	breq	.+6      	; 0x4d38 <chb_set_state+0x54>
    4d32:	89 81       	ldd	r24, Y+1	; 0x01
    4d34:	82 30       	cpi	r24, 0x02	; 2
    4d36:	39 f4       	brne	.+14     	; 0x4d46 <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4d38:	00 00       	nop
    4d3a:	0e 94 0b 21 	call	0x4216	; 0x4216 <chb_get_state>
    4d3e:	98 2f       	mov	r25, r24
    4d40:	89 81       	ldd	r24, Y+1	; 0x01
    4d42:	98 17       	cp	r25, r24
    4d44:	d1 f3       	breq	.-12     	; 0x4d3a <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4d46:	ce 01       	movw	r24, r28
    4d48:	8e 59       	subi	r24, 0x9E	; 158
    4d4a:	9f 4f       	sbci	r25, 0xFF	; 255
    4d4c:	fc 01       	movw	r30, r24
    4d4e:	80 81       	ld	r24, Z
    4d50:	88 2f       	mov	r24, r24
    4d52:	90 e0       	ldi	r25, 0x00	; 0
    4d54:	86 31       	cpi	r24, 0x16	; 22
    4d56:	91 05       	cpc	r25, r1
    4d58:	09 f4       	brne	.+2      	; 0x4d5c <chb_set_state+0x78>
    4d5a:	cd c1       	rjmp	.+922    	; 0x50f6 <chb_set_state+0x412>
    4d5c:	89 31       	cpi	r24, 0x19	; 25
    4d5e:	91 05       	cpc	r25, r1
    4d60:	09 f4       	brne	.+2      	; 0x4d64 <chb_set_state+0x80>
    4d62:	e9 c0       	rjmp	.+466    	; 0x4f36 <chb_set_state+0x252>
    4d64:	88 30       	cpi	r24, 0x08	; 8
    4d66:	91 05       	cpc	r25, r1
    4d68:	09 f0       	breq	.+2      	; 0x4d6c <chb_set_state+0x88>
    4d6a:	f7 c2       	rjmp	.+1518   	; 0x535a <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4d6c:	84 e6       	ldi	r24, 0x64	; 100
    4d6e:	96 e0       	ldi	r25, 0x06	; 6
    4d70:	24 e6       	ldi	r18, 0x64	; 100
    4d72:	36 e0       	ldi	r19, 0x06	; 6
    4d74:	f9 01       	movw	r30, r18
    4d76:	20 81       	ld	r18, Z
    4d78:	2d 7f       	andi	r18, 0xFD	; 253
    4d7a:	fc 01       	movw	r30, r24
    4d7c:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4d7e:	82 e0       	ldi	r24, 0x02	; 2
    4d80:	63 e0       	ldi	r22, 0x03	; 3
    4d82:	4f e1       	ldi	r20, 0x1F	; 31
    4d84:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
    4d88:	80 e0       	ldi	r24, 0x00	; 0
    4d8a:	90 e0       	ldi	r25, 0x00	; 0
    4d8c:	a0 e8       	ldi	r26, 0x80	; 128
    4d8e:	bf e3       	ldi	r27, 0x3F	; 63
    4d90:	8a 83       	std	Y+2, r24	; 0x02
    4d92:	9b 83       	std	Y+3, r25	; 0x03
    4d94:	ac 83       	std	Y+4, r26	; 0x04
    4d96:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4d98:	6a 81       	ldd	r22, Y+2	; 0x02
    4d9a:	7b 81       	ldd	r23, Y+3	; 0x03
    4d9c:	8c 81       	ldd	r24, Y+4	; 0x04
    4d9e:	9d 81       	ldd	r25, Y+5	; 0x05
    4da0:	2b ea       	ldi	r18, 0xAB	; 171
    4da2:	3a ea       	ldi	r19, 0xAA	; 170
    4da4:	4a ea       	ldi	r20, 0xAA	; 170
    4da6:	5e e3       	ldi	r21, 0x3E	; 62
    4da8:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4dac:	dc 01       	movw	r26, r24
    4dae:	cb 01       	movw	r24, r22
    4db0:	8e 83       	std	Y+6, r24	; 0x06
    4db2:	9f 83       	std	Y+7, r25	; 0x07
    4db4:	a8 87       	std	Y+8, r26	; 0x08
    4db6:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4db8:	11 e0       	ldi	r17, 0x01	; 1
    4dba:	6e 81       	ldd	r22, Y+6	; 0x06
    4dbc:	7f 81       	ldd	r23, Y+7	; 0x07
    4dbe:	88 85       	ldd	r24, Y+8	; 0x08
    4dc0:	99 85       	ldd	r25, Y+9	; 0x09
    4dc2:	20 e0       	ldi	r18, 0x00	; 0
    4dc4:	30 e0       	ldi	r19, 0x00	; 0
    4dc6:	40 e8       	ldi	r20, 0x80	; 128
    4dc8:	5f e3       	ldi	r21, 0x3F	; 63
    4dca:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    4dce:	88 23       	and	r24, r24
    4dd0:	0c f0       	brlt	.+2      	; 0x4dd4 <chb_set_state+0xf0>
    4dd2:	10 e0       	ldi	r17, 0x00	; 0
    4dd4:	11 23       	and	r17, r17
    4dd6:	19 f0       	breq	.+6      	; 0x4dde <chb_set_state+0xfa>
		__ticks = 1;
    4dd8:	81 e0       	ldi	r24, 0x01	; 1
    4dda:	8a 87       	std	Y+10, r24	; 0x0a
    4ddc:	a3 c0       	rjmp	.+326    	; 0x4f24 <chb_set_state+0x240>
	else if (__tmp > 255)
    4dde:	11 e0       	ldi	r17, 0x01	; 1
    4de0:	6e 81       	ldd	r22, Y+6	; 0x06
    4de2:	7f 81       	ldd	r23, Y+7	; 0x07
    4de4:	88 85       	ldd	r24, Y+8	; 0x08
    4de6:	99 85       	ldd	r25, Y+9	; 0x09
    4de8:	20 e0       	ldi	r18, 0x00	; 0
    4dea:	30 e0       	ldi	r19, 0x00	; 0
    4dec:	4f e7       	ldi	r20, 0x7F	; 127
    4dee:	53 e4       	ldi	r21, 0x43	; 67
    4df0:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    4df4:	18 16       	cp	r1, r24
    4df6:	0c f0       	brlt	.+2      	; 0x4dfa <chb_set_state+0x116>
    4df8:	10 e0       	ldi	r17, 0x00	; 0
    4dfa:	11 23       	and	r17, r17
    4dfc:	09 f4       	brne	.+2      	; 0x4e00 <chb_set_state+0x11c>
    4dfe:	89 c0       	rjmp	.+274    	; 0x4f12 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    4e00:	6a 81       	ldd	r22, Y+2	; 0x02
    4e02:	7b 81       	ldd	r23, Y+3	; 0x03
    4e04:	8c 81       	ldd	r24, Y+4	; 0x04
    4e06:	9d 81       	ldd	r25, Y+5	; 0x05
    4e08:	20 e0       	ldi	r18, 0x00	; 0
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	4a e7       	ldi	r20, 0x7A	; 122
    4e0e:	54 e4       	ldi	r21, 0x44	; 68
    4e10:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    4e14:	dc 01       	movw	r26, r24
    4e16:	cb 01       	movw	r24, r22
    4e18:	8b 87       	std	Y+11, r24	; 0x0b
    4e1a:	9c 87       	std	Y+12, r25	; 0x0c
    4e1c:	ad 87       	std	Y+13, r26	; 0x0d
    4e1e:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4e20:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e22:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e24:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e26:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e28:	20 e0       	ldi	r18, 0x00	; 0
    4e2a:	30 e0       	ldi	r19, 0x00	; 0
    4e2c:	4a e7       	ldi	r20, 0x7A	; 122
    4e2e:	53 e4       	ldi	r21, 0x43	; 67
    4e30:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4e34:	dc 01       	movw	r26, r24
    4e36:	cb 01       	movw	r24, r22
    4e38:	8f 87       	std	Y+15, r24	; 0x0f
    4e3a:	98 8b       	std	Y+16, r25	; 0x10
    4e3c:	a9 8b       	std	Y+17, r26	; 0x11
    4e3e:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4e40:	11 e0       	ldi	r17, 0x01	; 1
    4e42:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e44:	78 89       	ldd	r23, Y+16	; 0x10
    4e46:	89 89       	ldd	r24, Y+17	; 0x11
    4e48:	9a 89       	ldd	r25, Y+18	; 0x12
    4e4a:	20 e0       	ldi	r18, 0x00	; 0
    4e4c:	30 e0       	ldi	r19, 0x00	; 0
    4e4e:	40 e8       	ldi	r20, 0x80	; 128
    4e50:	5f e3       	ldi	r21, 0x3F	; 63
    4e52:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    4e56:	88 23       	and	r24, r24
    4e58:	0c f0       	brlt	.+2      	; 0x4e5c <chb_set_state+0x178>
    4e5a:	10 e0       	ldi	r17, 0x00	; 0
    4e5c:	11 23       	and	r17, r17
    4e5e:	29 f0       	breq	.+10     	; 0x4e6a <chb_set_state+0x186>
		__ticks = 1;
    4e60:	81 e0       	ldi	r24, 0x01	; 1
    4e62:	90 e0       	ldi	r25, 0x00	; 0
    4e64:	8b 8b       	std	Y+19, r24	; 0x13
    4e66:	9c 8b       	std	Y+20, r25	; 0x14
    4e68:	46 c0       	rjmp	.+140    	; 0x4ef6 <chb_set_state+0x212>
	else if (__tmp > 65535)
    4e6a:	11 e0       	ldi	r17, 0x01	; 1
    4e6c:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e6e:	78 89       	ldd	r23, Y+16	; 0x10
    4e70:	89 89       	ldd	r24, Y+17	; 0x11
    4e72:	9a 89       	ldd	r25, Y+18	; 0x12
    4e74:	20 e0       	ldi	r18, 0x00	; 0
    4e76:	3f ef       	ldi	r19, 0xFF	; 255
    4e78:	4f e7       	ldi	r20, 0x7F	; 127
    4e7a:	57 e4       	ldi	r21, 0x47	; 71
    4e7c:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    4e80:	18 16       	cp	r1, r24
    4e82:	0c f0       	brlt	.+2      	; 0x4e86 <chb_set_state+0x1a2>
    4e84:	10 e0       	ldi	r17, 0x00	; 0
    4e86:	11 23       	and	r17, r17
    4e88:	61 f1       	breq	.+88     	; 0x4ee2 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e8a:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e8c:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e8e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e90:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e92:	20 e0       	ldi	r18, 0x00	; 0
    4e94:	30 e0       	ldi	r19, 0x00	; 0
    4e96:	40 e2       	ldi	r20, 0x20	; 32
    4e98:	51 e4       	ldi	r21, 0x41	; 65
    4e9a:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4e9e:	dc 01       	movw	r26, r24
    4ea0:	cb 01       	movw	r24, r22
    4ea2:	bc 01       	movw	r22, r24
    4ea4:	cd 01       	movw	r24, r26
    4ea6:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    4eaa:	dc 01       	movw	r26, r24
    4eac:	cb 01       	movw	r24, r22
    4eae:	8b 8b       	std	Y+19, r24	; 0x13
    4eb0:	9c 8b       	std	Y+20, r25	; 0x14
    4eb2:	12 c0       	rjmp	.+36     	; 0x4ed8 <chb_set_state+0x1f4>
    4eb4:	89 e1       	ldi	r24, 0x19	; 25
    4eb6:	90 e0       	ldi	r25, 0x00	; 0
    4eb8:	8d 8b       	std	Y+21, r24	; 0x15
    4eba:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4ebc:	8d 89       	ldd	r24, Y+21	; 0x15
    4ebe:	9e 89       	ldd	r25, Y+22	; 0x16
    4ec0:	8c 01       	movw	r16, r24
    4ec2:	c8 01       	movw	r24, r16
    4ec4:	01 97       	sbiw	r24, 0x01	; 1
    4ec6:	f1 f7       	brne	.-4      	; 0x4ec4 <chb_set_state+0x1e0>
    4ec8:	8c 01       	movw	r16, r24
    4eca:	0d 8b       	std	Y+21, r16	; 0x15
    4ecc:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ece:	8b 89       	ldd	r24, Y+19	; 0x13
    4ed0:	9c 89       	ldd	r25, Y+20	; 0x14
    4ed2:	01 97       	sbiw	r24, 0x01	; 1
    4ed4:	8b 8b       	std	Y+19, r24	; 0x13
    4ed6:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ed8:	8b 89       	ldd	r24, Y+19	; 0x13
    4eda:	9c 89       	ldd	r25, Y+20	; 0x14
    4edc:	00 97       	sbiw	r24, 0x00	; 0
    4ede:	51 f7       	brne	.-44     	; 0x4eb4 <chb_set_state+0x1d0>
    4ee0:	29 c0       	rjmp	.+82     	; 0x4f34 <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ee2:	6f 85       	ldd	r22, Y+15	; 0x0f
    4ee4:	78 89       	ldd	r23, Y+16	; 0x10
    4ee6:	89 89       	ldd	r24, Y+17	; 0x11
    4ee8:	9a 89       	ldd	r25, Y+18	; 0x12
    4eea:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    4eee:	dc 01       	movw	r26, r24
    4ef0:	cb 01       	movw	r24, r22
    4ef2:	8b 8b       	std	Y+19, r24	; 0x13
    4ef4:	9c 8b       	std	Y+20, r25	; 0x14
    4ef6:	8b 89       	ldd	r24, Y+19	; 0x13
    4ef8:	9c 89       	ldd	r25, Y+20	; 0x14
    4efa:	8f 8b       	std	Y+23, r24	; 0x17
    4efc:	98 8f       	std	Y+24, r25	; 0x18
    4efe:	8f 89       	ldd	r24, Y+23	; 0x17
    4f00:	98 8d       	ldd	r25, Y+24	; 0x18
    4f02:	8c 01       	movw	r16, r24
    4f04:	f8 01       	movw	r30, r16
    4f06:	31 97       	sbiw	r30, 0x01	; 1
    4f08:	f1 f7       	brne	.-4      	; 0x4f06 <chb_set_state+0x222>
    4f0a:	8f 01       	movw	r16, r30
    4f0c:	0f 8b       	std	Y+23, r16	; 0x17
    4f0e:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    4f10:	24 c2       	rjmp	.+1096   	; 0x535a <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4f12:	6e 81       	ldd	r22, Y+6	; 0x06
    4f14:	7f 81       	ldd	r23, Y+7	; 0x07
    4f16:	88 85       	ldd	r24, Y+8	; 0x08
    4f18:	99 85       	ldd	r25, Y+9	; 0x09
    4f1a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    4f1e:	dc 01       	movw	r26, r24
    4f20:	cb 01       	movw	r24, r22
    4f22:	8a 87       	std	Y+10, r24	; 0x0a
    4f24:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f26:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4f28:	89 8d       	ldd	r24, Y+25	; 0x19
    4f2a:	18 2f       	mov	r17, r24
    4f2c:	1a 95       	dec	r17
    4f2e:	f1 f7       	brne	.-4      	; 0x4f2c <chb_set_state+0x248>
    4f30:	19 8f       	std	Y+25, r17	; 0x19
    4f32:	13 c2       	rjmp	.+1062   	; 0x535a <chb_set_state+0x676>
    4f34:	12 c2       	rjmp	.+1060   	; 0x535a <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    4f36:	89 81       	ldd	r24, Y+1	; 0x01
    4f38:	86 31       	cpi	r24, 0x16	; 22
    4f3a:	09 f0       	breq	.+2      	; 0x4f3e <chb_set_state+0x25a>
    4f3c:	0b c2       	rjmp	.+1046   	; 0x5354 <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    4f3e:	82 e0       	ldi	r24, 0x02	; 2
    4f40:	69 e0       	ldi	r22, 0x09	; 9
    4f42:	4f e1       	ldi	r20, 0x1F	; 31
    4f44:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
    4f48:	80 e0       	ldi	r24, 0x00	; 0
    4f4a:	90 e0       	ldi	r25, 0x00	; 0
    4f4c:	a0 e8       	ldi	r26, 0x80	; 128
    4f4e:	bf e3       	ldi	r27, 0x3F	; 63
    4f50:	8a 8f       	std	Y+26, r24	; 0x1a
    4f52:	9b 8f       	std	Y+27, r25	; 0x1b
    4f54:	ac 8f       	std	Y+28, r26	; 0x1c
    4f56:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4f58:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4f5a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4f5c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4f5e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f60:	2b ea       	ldi	r18, 0xAB	; 171
    4f62:	3a ea       	ldi	r19, 0xAA	; 170
    4f64:	4a ea       	ldi	r20, 0xAA	; 170
    4f66:	5e e3       	ldi	r21, 0x3E	; 62
    4f68:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4f6c:	dc 01       	movw	r26, r24
    4f6e:	cb 01       	movw	r24, r22
    4f70:	8e 8f       	std	Y+30, r24	; 0x1e
    4f72:	9f 8f       	std	Y+31, r25	; 0x1f
    4f74:	a8 a3       	lds	r26, 0x58
    4f76:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    4f78:	11 e0       	ldi	r17, 0x01	; 1
    4f7a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4f7c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4f7e:	88 a1       	lds	r24, 0x48
    4f80:	99 a1       	lds	r25, 0x49
    4f82:	20 e0       	ldi	r18, 0x00	; 0
    4f84:	30 e0       	ldi	r19, 0x00	; 0
    4f86:	40 e8       	ldi	r20, 0x80	; 128
    4f88:	5f e3       	ldi	r21, 0x3F	; 63
    4f8a:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    4f8e:	88 23       	and	r24, r24
    4f90:	0c f0       	brlt	.+2      	; 0x4f94 <chb_set_state+0x2b0>
    4f92:	10 e0       	ldi	r17, 0x00	; 0
    4f94:	11 23       	and	r17, r17
    4f96:	19 f0       	breq	.+6      	; 0x4f9e <chb_set_state+0x2ba>
		__ticks = 1;
    4f98:	81 e0       	ldi	r24, 0x01	; 1
    4f9a:	8a a3       	lds	r24, 0x5a
    4f9c:	a3 c0       	rjmp	.+326    	; 0x50e4 <chb_set_state+0x400>
	else if (__tmp > 255)
    4f9e:	11 e0       	ldi	r17, 0x01	; 1
    4fa0:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4fa2:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4fa4:	88 a1       	lds	r24, 0x48
    4fa6:	99 a1       	lds	r25, 0x49
    4fa8:	20 e0       	ldi	r18, 0x00	; 0
    4faa:	30 e0       	ldi	r19, 0x00	; 0
    4fac:	4f e7       	ldi	r20, 0x7F	; 127
    4fae:	53 e4       	ldi	r21, 0x43	; 67
    4fb0:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    4fb4:	18 16       	cp	r1, r24
    4fb6:	0c f0       	brlt	.+2      	; 0x4fba <chb_set_state+0x2d6>
    4fb8:	10 e0       	ldi	r17, 0x00	; 0
    4fba:	11 23       	and	r17, r17
    4fbc:	09 f4       	brne	.+2      	; 0x4fc0 <chb_set_state+0x2dc>
    4fbe:	89 c0       	rjmp	.+274    	; 0x50d2 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    4fc0:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4fc2:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4fc4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4fc6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4fc8:	20 e0       	ldi	r18, 0x00	; 0
    4fca:	30 e0       	ldi	r19, 0x00	; 0
    4fcc:	4a e7       	ldi	r20, 0x7A	; 122
    4fce:	54 e4       	ldi	r21, 0x44	; 68
    4fd0:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    4fd4:	dc 01       	movw	r26, r24
    4fd6:	cb 01       	movw	r24, r22
    4fd8:	8b a3       	lds	r24, 0x5b
    4fda:	9c a3       	lds	r25, 0x5c
    4fdc:	ad a3       	lds	r26, 0x5d
    4fde:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4fe0:	6b a1       	lds	r22, 0x4b
    4fe2:	7c a1       	lds	r23, 0x4c
    4fe4:	8d a1       	lds	r24, 0x4d
    4fe6:	9e a1       	lds	r25, 0x4e
    4fe8:	20 e0       	ldi	r18, 0x00	; 0
    4fea:	30 e0       	ldi	r19, 0x00	; 0
    4fec:	4a e7       	ldi	r20, 0x7A	; 122
    4fee:	53 e4       	ldi	r21, 0x43	; 67
    4ff0:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    4ff4:	dc 01       	movw	r26, r24
    4ff6:	cb 01       	movw	r24, r22
    4ff8:	8f a3       	lds	r24, 0x5f
    4ffa:	98 a7       	lds	r25, 0x78
    4ffc:	a9 a7       	lds	r26, 0x79
    4ffe:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    5000:	11 e0       	ldi	r17, 0x01	; 1
    5002:	6f a1       	lds	r22, 0x4f
    5004:	78 a5       	lds	r23, 0x68
    5006:	89 a5       	lds	r24, 0x69
    5008:	9a a5       	lds	r25, 0x6a
    500a:	20 e0       	ldi	r18, 0x00	; 0
    500c:	30 e0       	ldi	r19, 0x00	; 0
    500e:	40 e8       	ldi	r20, 0x80	; 128
    5010:	5f e3       	ldi	r21, 0x3F	; 63
    5012:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    5016:	88 23       	and	r24, r24
    5018:	0c f0       	brlt	.+2      	; 0x501c <chb_set_state+0x338>
    501a:	10 e0       	ldi	r17, 0x00	; 0
    501c:	11 23       	and	r17, r17
    501e:	29 f0       	breq	.+10     	; 0x502a <chb_set_state+0x346>
		__ticks = 1;
    5020:	81 e0       	ldi	r24, 0x01	; 1
    5022:	90 e0       	ldi	r25, 0x00	; 0
    5024:	8b a7       	lds	r24, 0x7b
    5026:	9c a7       	lds	r25, 0x7c
    5028:	46 c0       	rjmp	.+140    	; 0x50b6 <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    502a:	11 e0       	ldi	r17, 0x01	; 1
    502c:	6f a1       	lds	r22, 0x4f
    502e:	78 a5       	lds	r23, 0x68
    5030:	89 a5       	lds	r24, 0x69
    5032:	9a a5       	lds	r25, 0x6a
    5034:	20 e0       	ldi	r18, 0x00	; 0
    5036:	3f ef       	ldi	r19, 0xFF	; 255
    5038:	4f e7       	ldi	r20, 0x7F	; 127
    503a:	57 e4       	ldi	r21, 0x47	; 71
    503c:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    5040:	18 16       	cp	r1, r24
    5042:	0c f0       	brlt	.+2      	; 0x5046 <chb_set_state+0x362>
    5044:	10 e0       	ldi	r17, 0x00	; 0
    5046:	11 23       	and	r17, r17
    5048:	61 f1       	breq	.+88     	; 0x50a2 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    504a:	6b a1       	lds	r22, 0x4b
    504c:	7c a1       	lds	r23, 0x4c
    504e:	8d a1       	lds	r24, 0x4d
    5050:	9e a1       	lds	r25, 0x4e
    5052:	20 e0       	ldi	r18, 0x00	; 0
    5054:	30 e0       	ldi	r19, 0x00	; 0
    5056:	40 e2       	ldi	r20, 0x20	; 32
    5058:	51 e4       	ldi	r21, 0x41	; 65
    505a:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    505e:	dc 01       	movw	r26, r24
    5060:	cb 01       	movw	r24, r22
    5062:	bc 01       	movw	r22, r24
    5064:	cd 01       	movw	r24, r26
    5066:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    506a:	dc 01       	movw	r26, r24
    506c:	cb 01       	movw	r24, r22
    506e:	8b a7       	lds	r24, 0x7b
    5070:	9c a7       	lds	r25, 0x7c
    5072:	12 c0       	rjmp	.+36     	; 0x5098 <chb_set_state+0x3b4>
    5074:	89 e1       	ldi	r24, 0x19	; 25
    5076:	90 e0       	ldi	r25, 0x00	; 0
    5078:	8d a7       	lds	r24, 0x7d
    507a:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    507c:	8d a5       	lds	r24, 0x6d
    507e:	9e a5       	lds	r25, 0x6e
    5080:	8c 01       	movw	r16, r24
    5082:	c8 01       	movw	r24, r16
    5084:	01 97       	sbiw	r24, 0x01	; 1
    5086:	f1 f7       	brne	.-4      	; 0x5084 <chb_set_state+0x3a0>
    5088:	8c 01       	movw	r16, r24
    508a:	0d a7       	lds	r16, 0x7d
    508c:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    508e:	8b a5       	lds	r24, 0x6b
    5090:	9c a5       	lds	r25, 0x6c
    5092:	01 97       	sbiw	r24, 0x01	; 1
    5094:	8b a7       	lds	r24, 0x7b
    5096:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5098:	8b a5       	lds	r24, 0x6b
    509a:	9c a5       	lds	r25, 0x6c
    509c:	00 97       	sbiw	r24, 0x00	; 0
    509e:	51 f7       	brne	.-44     	; 0x5074 <chb_set_state+0x390>
    50a0:	29 c0       	rjmp	.+82     	; 0x50f4 <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    50a2:	6f a1       	lds	r22, 0x4f
    50a4:	78 a5       	lds	r23, 0x68
    50a6:	89 a5       	lds	r24, 0x69
    50a8:	9a a5       	lds	r25, 0x6a
    50aa:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    50ae:	dc 01       	movw	r26, r24
    50b0:	cb 01       	movw	r24, r22
    50b2:	8b a7       	lds	r24, 0x7b
    50b4:	9c a7       	lds	r25, 0x7c
    50b6:	8b a5       	lds	r24, 0x6b
    50b8:	9c a5       	lds	r25, 0x6c
    50ba:	8f a7       	lds	r24, 0x7f
    50bc:	98 ab       	sts	0x58, r25
    50be:	8f a5       	lds	r24, 0x6f
    50c0:	98 a9       	sts	0x48, r25
    50c2:	8c 01       	movw	r16, r24
    50c4:	f8 01       	movw	r30, r16
    50c6:	31 97       	sbiw	r30, 0x01	; 1
    50c8:	f1 f7       	brne	.-4      	; 0x50c6 <chb_set_state+0x3e2>
    50ca:	8f 01       	movw	r16, r30
    50cc:	0f a7       	lds	r16, 0x7f
    50ce:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    50d0:	41 c1       	rjmp	.+642    	; 0x5354 <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    50d2:	6e 8d       	ldd	r22, Y+30	; 0x1e
    50d4:	7f 8d       	ldd	r23, Y+31	; 0x1f
    50d6:	88 a1       	lds	r24, 0x48
    50d8:	99 a1       	lds	r25, 0x49
    50da:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    50de:	dc 01       	movw	r26, r24
    50e0:	cb 01       	movw	r24, r22
    50e2:	8a a3       	lds	r24, 0x5a
    50e4:	8a a1       	lds	r24, 0x4a
    50e6:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    50e8:	89 a9       	sts	0x49, r24
    50ea:	18 2f       	mov	r17, r24
    50ec:	1a 95       	dec	r17
    50ee:	f1 f7       	brne	.-4      	; 0x50ec <chb_set_state+0x408>
    50f0:	19 ab       	sts	0x59, r17
    50f2:	30 c1       	rjmp	.+608    	; 0x5354 <chb_set_state+0x670>
    50f4:	2f c1       	rjmp	.+606    	; 0x5354 <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    50f6:	89 81       	ldd	r24, Y+1	; 0x01
    50f8:	89 31       	cpi	r24, 0x19	; 25
    50fa:	09 f0       	breq	.+2      	; 0x50fe <chb_set_state+0x41a>
    50fc:	2d c1       	rjmp	.+602    	; 0x5358 <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    50fe:	82 e0       	ldi	r24, 0x02	; 2
    5100:	69 e0       	ldi	r22, 0x09	; 9
    5102:	4f e1       	ldi	r20, 0x1F	; 31
    5104:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
    5108:	80 e0       	ldi	r24, 0x00	; 0
    510a:	90 e0       	ldi	r25, 0x00	; 0
    510c:	a0 e8       	ldi	r26, 0x80	; 128
    510e:	bf e3       	ldi	r27, 0x3F	; 63
    5110:	8a ab       	sts	0x5a, r24
    5112:	9b ab       	sts	0x5b, r25
    5114:	ac ab       	sts	0x5c, r26
    5116:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5118:	6a a9       	sts	0x4a, r22
    511a:	7b a9       	sts	0x4b, r23
    511c:	8c a9       	sts	0x4c, r24
    511e:	9d a9       	sts	0x4d, r25
    5120:	2b ea       	ldi	r18, 0xAB	; 171
    5122:	3a ea       	ldi	r19, 0xAA	; 170
    5124:	4a ea       	ldi	r20, 0xAA	; 170
    5126:	5e e3       	ldi	r21, 0x3E	; 62
    5128:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    512c:	dc 01       	movw	r26, r24
    512e:	cb 01       	movw	r24, r22
    5130:	8e ab       	sts	0x5e, r24
    5132:	9f ab       	sts	0x5f, r25
    5134:	a8 af       	sts	0x78, r26
    5136:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    5138:	11 e0       	ldi	r17, 0x01	; 1
    513a:	6e a9       	sts	0x4e, r22
    513c:	7f a9       	sts	0x4f, r23
    513e:	88 ad       	sts	0x68, r24
    5140:	99 ad       	sts	0x69, r25
    5142:	20 e0       	ldi	r18, 0x00	; 0
    5144:	30 e0       	ldi	r19, 0x00	; 0
    5146:	40 e8       	ldi	r20, 0x80	; 128
    5148:	5f e3       	ldi	r21, 0x3F	; 63
    514a:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    514e:	88 23       	and	r24, r24
    5150:	0c f0       	brlt	.+2      	; 0x5154 <chb_set_state+0x470>
    5152:	10 e0       	ldi	r17, 0x00	; 0
    5154:	11 23       	and	r17, r17
    5156:	19 f0       	breq	.+6      	; 0x515e <chb_set_state+0x47a>
		__ticks = 1;
    5158:	81 e0       	ldi	r24, 0x01	; 1
    515a:	8a af       	sts	0x7a, r24
    515c:	e6 c0       	rjmp	.+460    	; 0x532a <chb_set_state+0x646>
	else if (__tmp > 255)
    515e:	11 e0       	ldi	r17, 0x01	; 1
    5160:	6e a9       	sts	0x4e, r22
    5162:	7f a9       	sts	0x4f, r23
    5164:	88 ad       	sts	0x68, r24
    5166:	99 ad       	sts	0x69, r25
    5168:	20 e0       	ldi	r18, 0x00	; 0
    516a:	30 e0       	ldi	r19, 0x00	; 0
    516c:	4f e7       	ldi	r20, 0x7F	; 127
    516e:	53 e4       	ldi	r21, 0x43	; 67
    5170:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    5174:	18 16       	cp	r1, r24
    5176:	0c f0       	brlt	.+2      	; 0x517a <chb_set_state+0x496>
    5178:	10 e0       	ldi	r17, 0x00	; 0
    517a:	11 23       	and	r17, r17
    517c:	09 f4       	brne	.+2      	; 0x5180 <chb_set_state+0x49c>
    517e:	cc c0       	rjmp	.+408    	; 0x5318 <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5180:	6a a9       	sts	0x4a, r22
    5182:	7b a9       	sts	0x4b, r23
    5184:	8c a9       	sts	0x4c, r24
    5186:	9d a9       	sts	0x4d, r25
    5188:	20 e0       	ldi	r18, 0x00	; 0
    518a:	30 e0       	ldi	r19, 0x00	; 0
    518c:	4a e7       	ldi	r20, 0x7A	; 122
    518e:	54 e4       	ldi	r21, 0x44	; 68
    5190:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    5194:	dc 01       	movw	r26, r24
    5196:	cb 01       	movw	r24, r22
    5198:	8b af       	sts	0x7b, r24
    519a:	9c af       	sts	0x7c, r25
    519c:	ad af       	sts	0x7d, r26
    519e:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    51a0:	8e 01       	movw	r16, r28
    51a2:	01 5c       	subi	r16, 0xC1	; 193
    51a4:	1f 4f       	sbci	r17, 0xFF	; 255
    51a6:	6b ad       	sts	0x6b, r22
    51a8:	7c ad       	sts	0x6c, r23
    51aa:	8d ad       	sts	0x6d, r24
    51ac:	9e ad       	sts	0x6e, r25
    51ae:	20 e0       	ldi	r18, 0x00	; 0
    51b0:	30 e0       	ldi	r19, 0x00	; 0
    51b2:	4a e7       	ldi	r20, 0x7A	; 122
    51b4:	53 e4       	ldi	r21, 0x43	; 67
    51b6:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    51ba:	dc 01       	movw	r26, r24
    51bc:	cb 01       	movw	r24, r22
    51be:	f8 01       	movw	r30, r16
    51c0:	80 83       	st	Z, r24
    51c2:	91 83       	std	Z+1, r25	; 0x01
    51c4:	a2 83       	std	Z+2, r26	; 0x02
    51c6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    51c8:	ce 01       	movw	r24, r28
    51ca:	cf 96       	adiw	r24, 0x3f	; 63
    51cc:	11 e0       	ldi	r17, 0x01	; 1
    51ce:	fc 01       	movw	r30, r24
    51d0:	60 81       	ld	r22, Z
    51d2:	71 81       	ldd	r23, Z+1	; 0x01
    51d4:	82 81       	ldd	r24, Z+2	; 0x02
    51d6:	93 81       	ldd	r25, Z+3	; 0x03
    51d8:	20 e0       	ldi	r18, 0x00	; 0
    51da:	30 e0       	ldi	r19, 0x00	; 0
    51dc:	40 e8       	ldi	r20, 0x80	; 128
    51de:	5f e3       	ldi	r21, 0x3F	; 63
    51e0:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    51e4:	88 23       	and	r24, r24
    51e6:	0c f0       	brlt	.+2      	; 0x51ea <chb_set_state+0x506>
    51e8:	10 e0       	ldi	r17, 0x00	; 0
    51ea:	11 23       	and	r17, r17
    51ec:	49 f0       	breq	.+18     	; 0x5200 <chb_set_state+0x51c>
		__ticks = 1;
    51ee:	ce 01       	movw	r24, r28
    51f0:	8d 5b       	subi	r24, 0xBD	; 189
    51f2:	9f 4f       	sbci	r25, 0xFF	; 255
    51f4:	21 e0       	ldi	r18, 0x01	; 1
    51f6:	30 e0       	ldi	r19, 0x00	; 0
    51f8:	fc 01       	movw	r30, r24
    51fa:	20 83       	st	Z, r18
    51fc:	31 83       	std	Z+1, r19	; 0x01
    51fe:	6e c0       	rjmp	.+220    	; 0x52dc <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    5200:	ce 01       	movw	r24, r28
    5202:	cf 96       	adiw	r24, 0x3f	; 63
    5204:	11 e0       	ldi	r17, 0x01	; 1
    5206:	fc 01       	movw	r30, r24
    5208:	60 81       	ld	r22, Z
    520a:	71 81       	ldd	r23, Z+1	; 0x01
    520c:	82 81       	ldd	r24, Z+2	; 0x02
    520e:	93 81       	ldd	r25, Z+3	; 0x03
    5210:	20 e0       	ldi	r18, 0x00	; 0
    5212:	3f ef       	ldi	r19, 0xFF	; 255
    5214:	4f e7       	ldi	r20, 0x7F	; 127
    5216:	57 e4       	ldi	r21, 0x47	; 71
    5218:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    521c:	18 16       	cp	r1, r24
    521e:	0c f0       	brlt	.+2      	; 0x5222 <chb_set_state+0x53e>
    5220:	10 e0       	ldi	r17, 0x00	; 0
    5222:	11 23       	and	r17, r17
    5224:	09 f4       	brne	.+2      	; 0x5228 <chb_set_state+0x544>
    5226:	49 c0       	rjmp	.+146    	; 0x52ba <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5228:	6b ad       	sts	0x6b, r22
    522a:	7c ad       	sts	0x6c, r23
    522c:	8d ad       	sts	0x6d, r24
    522e:	9e ad       	sts	0x6e, r25
    5230:	20 e0       	ldi	r18, 0x00	; 0
    5232:	30 e0       	ldi	r19, 0x00	; 0
    5234:	40 e2       	ldi	r20, 0x20	; 32
    5236:	51 e4       	ldi	r21, 0x41	; 65
    5238:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    523c:	dc 01       	movw	r26, r24
    523e:	cb 01       	movw	r24, r22
    5240:	8e 01       	movw	r16, r28
    5242:	0d 5b       	subi	r16, 0xBD	; 189
    5244:	1f 4f       	sbci	r17, 0xFF	; 255
    5246:	bc 01       	movw	r22, r24
    5248:	cd 01       	movw	r24, r26
    524a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    524e:	dc 01       	movw	r26, r24
    5250:	cb 01       	movw	r24, r22
    5252:	f8 01       	movw	r30, r16
    5254:	80 83       	st	Z, r24
    5256:	91 83       	std	Z+1, r25	; 0x01
    5258:	27 c0       	rjmp	.+78     	; 0x52a8 <chb_set_state+0x5c4>
    525a:	ce 01       	movw	r24, r28
    525c:	8b 5b       	subi	r24, 0xBB	; 187
    525e:	9f 4f       	sbci	r25, 0xFF	; 255
    5260:	29 e1       	ldi	r18, 0x19	; 25
    5262:	30 e0       	ldi	r19, 0x00	; 0
    5264:	fc 01       	movw	r30, r24
    5266:	20 83       	st	Z, r18
    5268:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    526a:	ce 01       	movw	r24, r28
    526c:	8b 5b       	subi	r24, 0xBB	; 187
    526e:	9f 4f       	sbci	r25, 0xFF	; 255
    5270:	fc 01       	movw	r30, r24
    5272:	80 81       	ld	r24, Z
    5274:	91 81       	ldd	r25, Z+1	; 0x01
    5276:	8c 01       	movw	r16, r24
    5278:	c8 01       	movw	r24, r16
    527a:	01 97       	sbiw	r24, 0x01	; 1
    527c:	f1 f7       	brne	.-4      	; 0x527a <chb_set_state+0x596>
    527e:	8c 01       	movw	r16, r24
    5280:	ce 01       	movw	r24, r28
    5282:	8b 5b       	subi	r24, 0xBB	; 187
    5284:	9f 4f       	sbci	r25, 0xFF	; 255
    5286:	fc 01       	movw	r30, r24
    5288:	00 83       	st	Z, r16
    528a:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    528c:	ce 01       	movw	r24, r28
    528e:	8d 5b       	subi	r24, 0xBD	; 189
    5290:	9f 4f       	sbci	r25, 0xFF	; 255
    5292:	9e 01       	movw	r18, r28
    5294:	2d 5b       	subi	r18, 0xBD	; 189
    5296:	3f 4f       	sbci	r19, 0xFF	; 255
    5298:	f9 01       	movw	r30, r18
    529a:	20 81       	ld	r18, Z
    529c:	31 81       	ldd	r19, Z+1	; 0x01
    529e:	21 50       	subi	r18, 0x01	; 1
    52a0:	30 40       	sbci	r19, 0x00	; 0
    52a2:	fc 01       	movw	r30, r24
    52a4:	20 83       	st	Z, r18
    52a6:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    52a8:	ce 01       	movw	r24, r28
    52aa:	8d 5b       	subi	r24, 0xBD	; 189
    52ac:	9f 4f       	sbci	r25, 0xFF	; 255
    52ae:	fc 01       	movw	r30, r24
    52b0:	80 81       	ld	r24, Z
    52b2:	91 81       	ldd	r25, Z+1	; 0x01
    52b4:	00 97       	sbiw	r24, 0x00	; 0
    52b6:	89 f6       	brne	.-94     	; 0x525a <chb_set_state+0x576>
    52b8:	4c c0       	rjmp	.+152    	; 0x5352 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    52ba:	8e 01       	movw	r16, r28
    52bc:	0d 5b       	subi	r16, 0xBD	; 189
    52be:	1f 4f       	sbci	r17, 0xFF	; 255
    52c0:	ce 01       	movw	r24, r28
    52c2:	cf 96       	adiw	r24, 0x3f	; 63
    52c4:	fc 01       	movw	r30, r24
    52c6:	60 81       	ld	r22, Z
    52c8:	71 81       	ldd	r23, Z+1	; 0x01
    52ca:	82 81       	ldd	r24, Z+2	; 0x02
    52cc:	93 81       	ldd	r25, Z+3	; 0x03
    52ce:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    52d2:	dc 01       	movw	r26, r24
    52d4:	cb 01       	movw	r24, r22
    52d6:	f8 01       	movw	r30, r16
    52d8:	80 83       	st	Z, r24
    52da:	91 83       	std	Z+1, r25	; 0x01
    52dc:	ce 01       	movw	r24, r28
    52de:	89 5b       	subi	r24, 0xB9	; 185
    52e0:	9f 4f       	sbci	r25, 0xFF	; 255
    52e2:	9e 01       	movw	r18, r28
    52e4:	2d 5b       	subi	r18, 0xBD	; 189
    52e6:	3f 4f       	sbci	r19, 0xFF	; 255
    52e8:	f9 01       	movw	r30, r18
    52ea:	20 81       	ld	r18, Z
    52ec:	31 81       	ldd	r19, Z+1	; 0x01
    52ee:	fc 01       	movw	r30, r24
    52f0:	20 83       	st	Z, r18
    52f2:	31 83       	std	Z+1, r19	; 0x01
    52f4:	ce 01       	movw	r24, r28
    52f6:	89 5b       	subi	r24, 0xB9	; 185
    52f8:	9f 4f       	sbci	r25, 0xFF	; 255
    52fa:	fc 01       	movw	r30, r24
    52fc:	80 81       	ld	r24, Z
    52fe:	91 81       	ldd	r25, Z+1	; 0x01
    5300:	8c 01       	movw	r16, r24
    5302:	c8 01       	movw	r24, r16
    5304:	01 97       	sbiw	r24, 0x01	; 1
    5306:	f1 f7       	brne	.-4      	; 0x5304 <chb_set_state+0x620>
    5308:	8c 01       	movw	r16, r24
    530a:	ce 01       	movw	r24, r28
    530c:	89 5b       	subi	r24, 0xB9	; 185
    530e:	9f 4f       	sbci	r25, 0xFF	; 255
    5310:	fc 01       	movw	r30, r24
    5312:	00 83       	st	Z, r16
    5314:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5316:	20 c0       	rjmp	.+64     	; 0x5358 <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5318:	6e a9       	sts	0x4e, r22
    531a:	7f a9       	sts	0x4f, r23
    531c:	88 ad       	sts	0x68, r24
    531e:	99 ad       	sts	0x69, r25
    5320:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    5324:	dc 01       	movw	r26, r24
    5326:	cb 01       	movw	r24, r22
    5328:	8a af       	sts	0x7a, r24
    532a:	ce 01       	movw	r24, r28
    532c:	87 5b       	subi	r24, 0xB7	; 183
    532e:	9f 4f       	sbci	r25, 0xFF	; 255
    5330:	2a ad       	sts	0x6a, r18
    5332:	fc 01       	movw	r30, r24
    5334:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5336:	ce 01       	movw	r24, r28
    5338:	87 5b       	subi	r24, 0xB7	; 183
    533a:	9f 4f       	sbci	r25, 0xFF	; 255
    533c:	fc 01       	movw	r30, r24
    533e:	80 81       	ld	r24, Z
    5340:	18 2f       	mov	r17, r24
    5342:	1a 95       	dec	r17
    5344:	f1 f7       	brne	.-4      	; 0x5342 <chb_set_state+0x65e>
    5346:	ce 01       	movw	r24, r28
    5348:	87 5b       	subi	r24, 0xB7	; 183
    534a:	9f 4f       	sbci	r25, 0xFF	; 255
    534c:	fc 01       	movw	r30, r24
    534e:	10 83       	st	Z, r17
    5350:	03 c0       	rjmp	.+6      	; 0x5358 <chb_set_state+0x674>
    5352:	02 c0       	rjmp	.+4      	; 0x5358 <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5354:	00 00       	nop
    5356:	01 c0       	rjmp	.+2      	; 0x535a <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5358:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    535a:	9e 01       	movw	r18, r28
    535c:	2e 59       	subi	r18, 0x9E	; 158
    535e:	3f 4f       	sbci	r19, 0xFF	; 255
    5360:	82 e0       	ldi	r24, 0x02	; 2
    5362:	f9 01       	movw	r30, r18
    5364:	60 81       	ld	r22, Z
    5366:	4f e1       	ldi	r20, 0x1F	; 31
    5368:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
    536c:	9e 01       	movw	r18, r28
    536e:	26 5b       	subi	r18, 0xB6	; 182
    5370:	3f 4f       	sbci	r19, 0xFF	; 255
    5372:	80 e0       	ldi	r24, 0x00	; 0
    5374:	90 e0       	ldi	r25, 0x00	; 0
    5376:	ac ed       	ldi	r26, 0xDC	; 220
    5378:	b2 e4       	ldi	r27, 0x42	; 66
    537a:	f9 01       	movw	r30, r18
    537c:	80 83       	st	Z, r24
    537e:	91 83       	std	Z+1, r25	; 0x01
    5380:	a2 83       	std	Z+2, r26	; 0x02
    5382:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5384:	8e 01       	movw	r16, r28
    5386:	02 5b       	subi	r16, 0xB2	; 178
    5388:	1f 4f       	sbci	r17, 0xFF	; 255
    538a:	ce 01       	movw	r24, r28
    538c:	86 5b       	subi	r24, 0xB6	; 182
    538e:	9f 4f       	sbci	r25, 0xFF	; 255
    5390:	fc 01       	movw	r30, r24
    5392:	60 81       	ld	r22, Z
    5394:	71 81       	ldd	r23, Z+1	; 0x01
    5396:	82 81       	ldd	r24, Z+2	; 0x02
    5398:	93 81       	ldd	r25, Z+3	; 0x03
    539a:	2b ea       	ldi	r18, 0xAB	; 171
    539c:	3a ea       	ldi	r19, 0xAA	; 170
    539e:	4a ea       	ldi	r20, 0xAA	; 170
    53a0:	5e e3       	ldi	r21, 0x3E	; 62
    53a2:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    53a6:	dc 01       	movw	r26, r24
    53a8:	cb 01       	movw	r24, r22
    53aa:	f8 01       	movw	r30, r16
    53ac:	80 83       	st	Z, r24
    53ae:	91 83       	std	Z+1, r25	; 0x01
    53b0:	a2 83       	std	Z+2, r26	; 0x02
    53b2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    53b4:	ce 01       	movw	r24, r28
    53b6:	82 5b       	subi	r24, 0xB2	; 178
    53b8:	9f 4f       	sbci	r25, 0xFF	; 255
    53ba:	11 e0       	ldi	r17, 0x01	; 1
    53bc:	fc 01       	movw	r30, r24
    53be:	60 81       	ld	r22, Z
    53c0:	71 81       	ldd	r23, Z+1	; 0x01
    53c2:	82 81       	ldd	r24, Z+2	; 0x02
    53c4:	93 81       	ldd	r25, Z+3	; 0x03
    53c6:	20 e0       	ldi	r18, 0x00	; 0
    53c8:	30 e0       	ldi	r19, 0x00	; 0
    53ca:	40 e8       	ldi	r20, 0x80	; 128
    53cc:	5f e3       	ldi	r21, 0x3F	; 63
    53ce:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    53d2:	88 23       	and	r24, r24
    53d4:	0c f0       	brlt	.+2      	; 0x53d8 <chb_set_state+0x6f4>
    53d6:	10 e0       	ldi	r17, 0x00	; 0
    53d8:	11 23       	and	r17, r17
    53da:	39 f0       	breq	.+14     	; 0x53ea <chb_set_state+0x706>
		__ticks = 1;
    53dc:	ce 01       	movw	r24, r28
    53de:	8e 5a       	subi	r24, 0xAE	; 174
    53e0:	9f 4f       	sbci	r25, 0xFF	; 255
    53e2:	21 e0       	ldi	r18, 0x01	; 1
    53e4:	fc 01       	movw	r30, r24
    53e6:	20 83       	st	Z, r18
    53e8:	05 c1       	rjmp	.+522    	; 0x55f4 <chb_set_state+0x910>
	else if (__tmp > 255)
    53ea:	ce 01       	movw	r24, r28
    53ec:	82 5b       	subi	r24, 0xB2	; 178
    53ee:	9f 4f       	sbci	r25, 0xFF	; 255
    53f0:	11 e0       	ldi	r17, 0x01	; 1
    53f2:	fc 01       	movw	r30, r24
    53f4:	60 81       	ld	r22, Z
    53f6:	71 81       	ldd	r23, Z+1	; 0x01
    53f8:	82 81       	ldd	r24, Z+2	; 0x02
    53fa:	93 81       	ldd	r25, Z+3	; 0x03
    53fc:	20 e0       	ldi	r18, 0x00	; 0
    53fe:	30 e0       	ldi	r19, 0x00	; 0
    5400:	4f e7       	ldi	r20, 0x7F	; 127
    5402:	53 e4       	ldi	r21, 0x43	; 67
    5404:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    5408:	18 16       	cp	r1, r24
    540a:	0c f0       	brlt	.+2      	; 0x540e <chb_set_state+0x72a>
    540c:	10 e0       	ldi	r17, 0x00	; 0
    540e:	11 23       	and	r17, r17
    5410:	09 f4       	brne	.+2      	; 0x5414 <chb_set_state+0x730>
    5412:	df c0       	rjmp	.+446    	; 0x55d2 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    5414:	ce 01       	movw	r24, r28
    5416:	86 5b       	subi	r24, 0xB6	; 182
    5418:	9f 4f       	sbci	r25, 0xFF	; 255
    541a:	fc 01       	movw	r30, r24
    541c:	60 81       	ld	r22, Z
    541e:	71 81       	ldd	r23, Z+1	; 0x01
    5420:	82 81       	ldd	r24, Z+2	; 0x02
    5422:	93 81       	ldd	r25, Z+3	; 0x03
    5424:	20 e0       	ldi	r18, 0x00	; 0
    5426:	30 e0       	ldi	r19, 0x00	; 0
    5428:	4a e7       	ldi	r20, 0x7A	; 122
    542a:	54 e4       	ldi	r21, 0x44	; 68
    542c:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    5430:	dc 01       	movw	r26, r24
    5432:	cb 01       	movw	r24, r22
    5434:	9e 01       	movw	r18, r28
    5436:	2d 5a       	subi	r18, 0xAD	; 173
    5438:	3f 4f       	sbci	r19, 0xFF	; 255
    543a:	f9 01       	movw	r30, r18
    543c:	80 83       	st	Z, r24
    543e:	91 83       	std	Z+1, r25	; 0x01
    5440:	a2 83       	std	Z+2, r26	; 0x02
    5442:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5444:	8e 01       	movw	r16, r28
    5446:	09 5a       	subi	r16, 0xA9	; 169
    5448:	1f 4f       	sbci	r17, 0xFF	; 255
    544a:	ce 01       	movw	r24, r28
    544c:	8d 5a       	subi	r24, 0xAD	; 173
    544e:	9f 4f       	sbci	r25, 0xFF	; 255
    5450:	fc 01       	movw	r30, r24
    5452:	60 81       	ld	r22, Z
    5454:	71 81       	ldd	r23, Z+1	; 0x01
    5456:	82 81       	ldd	r24, Z+2	; 0x02
    5458:	93 81       	ldd	r25, Z+3	; 0x03
    545a:	20 e0       	ldi	r18, 0x00	; 0
    545c:	30 e0       	ldi	r19, 0x00	; 0
    545e:	4a e7       	ldi	r20, 0x7A	; 122
    5460:	53 e4       	ldi	r21, 0x43	; 67
    5462:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    5466:	dc 01       	movw	r26, r24
    5468:	cb 01       	movw	r24, r22
    546a:	f8 01       	movw	r30, r16
    546c:	80 83       	st	Z, r24
    546e:	91 83       	std	Z+1, r25	; 0x01
    5470:	a2 83       	std	Z+2, r26	; 0x02
    5472:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5474:	ce 01       	movw	r24, r28
    5476:	89 5a       	subi	r24, 0xA9	; 169
    5478:	9f 4f       	sbci	r25, 0xFF	; 255
    547a:	11 e0       	ldi	r17, 0x01	; 1
    547c:	fc 01       	movw	r30, r24
    547e:	60 81       	ld	r22, Z
    5480:	71 81       	ldd	r23, Z+1	; 0x01
    5482:	82 81       	ldd	r24, Z+2	; 0x02
    5484:	93 81       	ldd	r25, Z+3	; 0x03
    5486:	20 e0       	ldi	r18, 0x00	; 0
    5488:	30 e0       	ldi	r19, 0x00	; 0
    548a:	40 e8       	ldi	r20, 0x80	; 128
    548c:	5f e3       	ldi	r21, 0x3F	; 63
    548e:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    5492:	88 23       	and	r24, r24
    5494:	0c f0       	brlt	.+2      	; 0x5498 <chb_set_state+0x7b4>
    5496:	10 e0       	ldi	r17, 0x00	; 0
    5498:	11 23       	and	r17, r17
    549a:	49 f0       	breq	.+18     	; 0x54ae <chb_set_state+0x7ca>
		__ticks = 1;
    549c:	ce 01       	movw	r24, r28
    549e:	85 5a       	subi	r24, 0xA5	; 165
    54a0:	9f 4f       	sbci	r25, 0xFF	; 255
    54a2:	21 e0       	ldi	r18, 0x01	; 1
    54a4:	30 e0       	ldi	r19, 0x00	; 0
    54a6:	fc 01       	movw	r30, r24
    54a8:	20 83       	st	Z, r18
    54aa:	31 83       	std	Z+1, r19	; 0x01
    54ac:	74 c0       	rjmp	.+232    	; 0x5596 <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    54ae:	ce 01       	movw	r24, r28
    54b0:	89 5a       	subi	r24, 0xA9	; 169
    54b2:	9f 4f       	sbci	r25, 0xFF	; 255
    54b4:	11 e0       	ldi	r17, 0x01	; 1
    54b6:	fc 01       	movw	r30, r24
    54b8:	60 81       	ld	r22, Z
    54ba:	71 81       	ldd	r23, Z+1	; 0x01
    54bc:	82 81       	ldd	r24, Z+2	; 0x02
    54be:	93 81       	ldd	r25, Z+3	; 0x03
    54c0:	20 e0       	ldi	r18, 0x00	; 0
    54c2:	3f ef       	ldi	r19, 0xFF	; 255
    54c4:	4f e7       	ldi	r20, 0x7F	; 127
    54c6:	57 e4       	ldi	r21, 0x47	; 71
    54c8:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    54cc:	18 16       	cp	r1, r24
    54ce:	0c f0       	brlt	.+2      	; 0x54d2 <chb_set_state+0x7ee>
    54d0:	10 e0       	ldi	r17, 0x00	; 0
    54d2:	11 23       	and	r17, r17
    54d4:	09 f4       	brne	.+2      	; 0x54d8 <chb_set_state+0x7f4>
    54d6:	4d c0       	rjmp	.+154    	; 0x5572 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    54d8:	ce 01       	movw	r24, r28
    54da:	8d 5a       	subi	r24, 0xAD	; 173
    54dc:	9f 4f       	sbci	r25, 0xFF	; 255
    54de:	fc 01       	movw	r30, r24
    54e0:	60 81       	ld	r22, Z
    54e2:	71 81       	ldd	r23, Z+1	; 0x01
    54e4:	82 81       	ldd	r24, Z+2	; 0x02
    54e6:	93 81       	ldd	r25, Z+3	; 0x03
    54e8:	20 e0       	ldi	r18, 0x00	; 0
    54ea:	30 e0       	ldi	r19, 0x00	; 0
    54ec:	40 e2       	ldi	r20, 0x20	; 32
    54ee:	51 e4       	ldi	r21, 0x41	; 65
    54f0:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    54f4:	dc 01       	movw	r26, r24
    54f6:	cb 01       	movw	r24, r22
    54f8:	8e 01       	movw	r16, r28
    54fa:	05 5a       	subi	r16, 0xA5	; 165
    54fc:	1f 4f       	sbci	r17, 0xFF	; 255
    54fe:	bc 01       	movw	r22, r24
    5500:	cd 01       	movw	r24, r26
    5502:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    5506:	dc 01       	movw	r26, r24
    5508:	cb 01       	movw	r24, r22
    550a:	f8 01       	movw	r30, r16
    550c:	80 83       	st	Z, r24
    550e:	91 83       	std	Z+1, r25	; 0x01
    5510:	27 c0       	rjmp	.+78     	; 0x5560 <chb_set_state+0x87c>
    5512:	ce 01       	movw	r24, r28
    5514:	83 5a       	subi	r24, 0xA3	; 163
    5516:	9f 4f       	sbci	r25, 0xFF	; 255
    5518:	29 e1       	ldi	r18, 0x19	; 25
    551a:	30 e0       	ldi	r19, 0x00	; 0
    551c:	fc 01       	movw	r30, r24
    551e:	20 83       	st	Z, r18
    5520:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5522:	ce 01       	movw	r24, r28
    5524:	83 5a       	subi	r24, 0xA3	; 163
    5526:	9f 4f       	sbci	r25, 0xFF	; 255
    5528:	fc 01       	movw	r30, r24
    552a:	80 81       	ld	r24, Z
    552c:	91 81       	ldd	r25, Z+1	; 0x01
    552e:	8c 01       	movw	r16, r24
    5530:	c8 01       	movw	r24, r16
    5532:	01 97       	sbiw	r24, 0x01	; 1
    5534:	f1 f7       	brne	.-4      	; 0x5532 <chb_set_state+0x84e>
    5536:	8c 01       	movw	r16, r24
    5538:	ce 01       	movw	r24, r28
    553a:	83 5a       	subi	r24, 0xA3	; 163
    553c:	9f 4f       	sbci	r25, 0xFF	; 255
    553e:	fc 01       	movw	r30, r24
    5540:	00 83       	st	Z, r16
    5542:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5544:	ce 01       	movw	r24, r28
    5546:	85 5a       	subi	r24, 0xA5	; 165
    5548:	9f 4f       	sbci	r25, 0xFF	; 255
    554a:	9e 01       	movw	r18, r28
    554c:	25 5a       	subi	r18, 0xA5	; 165
    554e:	3f 4f       	sbci	r19, 0xFF	; 255
    5550:	f9 01       	movw	r30, r18
    5552:	20 81       	ld	r18, Z
    5554:	31 81       	ldd	r19, Z+1	; 0x01
    5556:	21 50       	subi	r18, 0x01	; 1
    5558:	30 40       	sbci	r19, 0x00	; 0
    555a:	fc 01       	movw	r30, r24
    555c:	20 83       	st	Z, r18
    555e:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5560:	ce 01       	movw	r24, r28
    5562:	85 5a       	subi	r24, 0xA5	; 165
    5564:	9f 4f       	sbci	r25, 0xFF	; 255
    5566:	fc 01       	movw	r30, r24
    5568:	80 81       	ld	r24, Z
    556a:	91 81       	ldd	r25, Z+1	; 0x01
    556c:	00 97       	sbiw	r24, 0x00	; 0
    556e:	89 f6       	brne	.-94     	; 0x5512 <chb_set_state+0x82e>
    5570:	58 c0       	rjmp	.+176    	; 0x5622 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5572:	8e 01       	movw	r16, r28
    5574:	05 5a       	subi	r16, 0xA5	; 165
    5576:	1f 4f       	sbci	r17, 0xFF	; 255
    5578:	ce 01       	movw	r24, r28
    557a:	89 5a       	subi	r24, 0xA9	; 169
    557c:	9f 4f       	sbci	r25, 0xFF	; 255
    557e:	fc 01       	movw	r30, r24
    5580:	60 81       	ld	r22, Z
    5582:	71 81       	ldd	r23, Z+1	; 0x01
    5584:	82 81       	ldd	r24, Z+2	; 0x02
    5586:	93 81       	ldd	r25, Z+3	; 0x03
    5588:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    558c:	dc 01       	movw	r26, r24
    558e:	cb 01       	movw	r24, r22
    5590:	f8 01       	movw	r30, r16
    5592:	80 83       	st	Z, r24
    5594:	91 83       	std	Z+1, r25	; 0x01
    5596:	ce 01       	movw	r24, r28
    5598:	81 5a       	subi	r24, 0xA1	; 161
    559a:	9f 4f       	sbci	r25, 0xFF	; 255
    559c:	9e 01       	movw	r18, r28
    559e:	25 5a       	subi	r18, 0xA5	; 165
    55a0:	3f 4f       	sbci	r19, 0xFF	; 255
    55a2:	f9 01       	movw	r30, r18
    55a4:	20 81       	ld	r18, Z
    55a6:	31 81       	ldd	r19, Z+1	; 0x01
    55a8:	fc 01       	movw	r30, r24
    55aa:	20 83       	st	Z, r18
    55ac:	31 83       	std	Z+1, r19	; 0x01
    55ae:	ce 01       	movw	r24, r28
    55b0:	81 5a       	subi	r24, 0xA1	; 161
    55b2:	9f 4f       	sbci	r25, 0xFF	; 255
    55b4:	fc 01       	movw	r30, r24
    55b6:	80 81       	ld	r24, Z
    55b8:	91 81       	ldd	r25, Z+1	; 0x01
    55ba:	8c 01       	movw	r16, r24
    55bc:	c8 01       	movw	r24, r16
    55be:	01 97       	sbiw	r24, 0x01	; 1
    55c0:	f1 f7       	brne	.-4      	; 0x55be <chb_set_state+0x8da>
    55c2:	8c 01       	movw	r16, r24
    55c4:	ce 01       	movw	r24, r28
    55c6:	81 5a       	subi	r24, 0xA1	; 161
    55c8:	9f 4f       	sbci	r25, 0xFF	; 255
    55ca:	fc 01       	movw	r30, r24
    55cc:	00 83       	st	Z, r16
    55ce:	11 83       	std	Z+1, r17	; 0x01
    55d0:	28 c0       	rjmp	.+80     	; 0x5622 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    55d2:	8e 01       	movw	r16, r28
    55d4:	0e 5a       	subi	r16, 0xAE	; 174
    55d6:	1f 4f       	sbci	r17, 0xFF	; 255
    55d8:	ce 01       	movw	r24, r28
    55da:	82 5b       	subi	r24, 0xB2	; 178
    55dc:	9f 4f       	sbci	r25, 0xFF	; 255
    55de:	fc 01       	movw	r30, r24
    55e0:	60 81       	ld	r22, Z
    55e2:	71 81       	ldd	r23, Z+1	; 0x01
    55e4:	82 81       	ldd	r24, Z+2	; 0x02
    55e6:	93 81       	ldd	r25, Z+3	; 0x03
    55e8:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    55ec:	dc 01       	movw	r26, r24
    55ee:	cb 01       	movw	r24, r22
    55f0:	f8 01       	movw	r30, r16
    55f2:	80 83       	st	Z, r24
    55f4:	ce 01       	movw	r24, r28
    55f6:	8f 59       	subi	r24, 0x9F	; 159
    55f8:	9f 4f       	sbci	r25, 0xFF	; 255
    55fa:	9e 01       	movw	r18, r28
    55fc:	2e 5a       	subi	r18, 0xAE	; 174
    55fe:	3f 4f       	sbci	r19, 0xFF	; 255
    5600:	f9 01       	movw	r30, r18
    5602:	20 81       	ld	r18, Z
    5604:	fc 01       	movw	r30, r24
    5606:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5608:	ce 01       	movw	r24, r28
    560a:	8f 59       	subi	r24, 0x9F	; 159
    560c:	9f 4f       	sbci	r25, 0xFF	; 255
    560e:	fc 01       	movw	r30, r24
    5610:	80 81       	ld	r24, Z
    5612:	18 2f       	mov	r17, r24
    5614:	1a 95       	dec	r17
    5616:	f1 f7       	brne	.-4      	; 0x5614 <chb_set_state+0x930>
    5618:	ce 01       	movw	r24, r28
    561a:	8f 59       	subi	r24, 0x9F	; 159
    561c:	9f 4f       	sbci	r25, 0xFF	; 255
    561e:	fc 01       	movw	r30, r24
    5620:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5622:	0e 94 0b 21 	call	0x4216	; 0x4216 <chb_get_state>
    5626:	28 2f       	mov	r18, r24
    5628:	ce 01       	movw	r24, r28
    562a:	8e 59       	subi	r24, 0x9E	; 158
    562c:	9f 4f       	sbci	r25, 0xFF	; 255
    562e:	fc 01       	movw	r30, r24
    5630:	80 81       	ld	r24, Z
    5632:	28 17       	cp	r18, r24
    5634:	11 f4       	brne	.+4      	; 0x563a <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5636:	80 e4       	ldi	r24, 0x40	; 64
    5638:	01 c0       	rjmp	.+2      	; 0x563c <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    563a:	83 e4       	ldi	r24, 0x43	; 67
}
    563c:	ce 59       	subi	r28, 0x9E	; 158
    563e:	df 4f       	sbci	r29, 0xFF	; 255
    5640:	cd bf       	out	0x3d, r28	; 61
    5642:	de bf       	out	0x3e, r29	; 62
    5644:	df 91       	pop	r29
    5646:	cf 91       	pop	r28
    5648:	1f 91       	pop	r17
    564a:	0f 91       	pop	r16
    564c:	08 95       	ret

0000564e <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    564e:	cf 93       	push	r28
    5650:	df 93       	push	r29
    5652:	0f 92       	push	r0
    5654:	0f 92       	push	r0
    5656:	cd b7       	in	r28, 0x3d	; 61
    5658:	de b7       	in	r29, 0x3e	; 62
    565a:	89 83       	std	Y+1, r24	; 0x01
    565c:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    565e:	29 81       	ldd	r18, Y+1	; 0x01
    5660:	3a 81       	ldd	r19, Y+2	; 0x02
    5662:	80 e0       	ldi	r24, 0x00	; 0
    5664:	90 e0       	ldi	r25, 0x00	; 0
    5666:	b9 01       	movw	r22, r18
    5668:	48 e0       	ldi	r20, 0x08	; 8
    566a:	50 e0       	ldi	r21, 0x00	; 0
    566c:	0e 94 4a 2f 	call	0x5e94	; 0x5e94 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5670:	29 81       	ldd	r18, Y+1	; 0x01
    5672:	3a 81       	ldd	r19, Y+2	; 0x02
    5674:	84 e2       	ldi	r24, 0x24	; 36
    5676:	b9 01       	movw	r22, r18
    5678:	0e 94 cc 23 	call	0x4798	; 0x4798 <chb_reg_write64>
}
    567c:	0f 90       	pop	r0
    567e:	0f 90       	pop	r0
    5680:	df 91       	pop	r29
    5682:	cf 91       	pop	r28
    5684:	08 95       	ret

00005686 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5686:	cf 93       	push	r28
    5688:	df 93       	push	r29
    568a:	0f 92       	push	r0
    568c:	0f 92       	push	r0
    568e:	cd b7       	in	r28, 0x3d	; 61
    5690:	de b7       	in	r29, 0x3e	; 62
    5692:	89 83       	std	Y+1, r24	; 0x01
    5694:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5696:	29 81       	ldd	r18, Y+1	; 0x01
    5698:	3a 81       	ldd	r19, Y+2	; 0x02
    569a:	80 e0       	ldi	r24, 0x00	; 0
    569c:	90 e0       	ldi	r25, 0x00	; 0
    569e:	b9 01       	movw	r22, r18
    56a0:	48 e0       	ldi	r20, 0x08	; 8
    56a2:	50 e0       	ldi	r21, 0x00	; 0
    56a4:	0e 94 86 2f 	call	0x5f0c	; 0x5f0c <chb_eeprom_read>
}
    56a8:	0f 90       	pop	r0
    56aa:	0f 90       	pop	r0
    56ac:	df 91       	pop	r29
    56ae:	cf 91       	pop	r28
    56b0:	08 95       	ret

000056b2 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    56b2:	cf 93       	push	r28
    56b4:	df 93       	push	r29
    56b6:	00 d0       	rcall	.+0      	; 0x56b8 <chb_set_short_addr+0x6>
    56b8:	00 d0       	rcall	.+0      	; 0x56ba <chb_set_short_addr+0x8>
    56ba:	cd b7       	in	r28, 0x3d	; 61
    56bc:	de b7       	in	r29, 0x3e	; 62
    56be:	8d 83       	std	Y+5, r24	; 0x05
    56c0:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    56c2:	ce 01       	movw	r24, r28
    56c4:	05 96       	adiw	r24, 0x05	; 5
    56c6:	89 83       	std	Y+1, r24	; 0x01
    56c8:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    56ca:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <chb_get_pcb>
    56ce:	8b 83       	std	Y+3, r24	; 0x03
    56d0:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    56d2:	29 81       	ldd	r18, Y+1	; 0x01
    56d4:	3a 81       	ldd	r19, Y+2	; 0x02
    56d6:	89 e0       	ldi	r24, 0x09	; 9
    56d8:	90 e0       	ldi	r25, 0x00	; 0
    56da:	b9 01       	movw	r22, r18
    56dc:	42 e0       	ldi	r20, 0x02	; 2
    56de:	50 e0       	ldi	r21, 0x00	; 0
    56e0:	0e 94 4a 2f 	call	0x5e94	; 0x5e94 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    56e4:	2d 81       	ldd	r18, Y+5	; 0x05
    56e6:	3e 81       	ldd	r19, Y+6	; 0x06
    56e8:	80 e2       	ldi	r24, 0x20	; 32
    56ea:	b9 01       	movw	r22, r18
    56ec:	0e 94 9b 23 	call	0x4736	; 0x4736 <chb_reg_write16>
    pcb->src_addr = addr;
    56f0:	2d 81       	ldd	r18, Y+5	; 0x05
    56f2:	3e 81       	ldd	r19, Y+6	; 0x06
    56f4:	8b 81       	ldd	r24, Y+3	; 0x03
    56f6:	9c 81       	ldd	r25, Y+4	; 0x04
    56f8:	fc 01       	movw	r30, r24
    56fa:	20 83       	st	Z, r18
    56fc:	31 83       	std	Z+1, r19	; 0x01
}
    56fe:	26 96       	adiw	r28, 0x06	; 6
    5700:	cd bf       	out	0x3d, r28	; 61
    5702:	de bf       	out	0x3e, r29	; 62
    5704:	df 91       	pop	r29
    5706:	cf 91       	pop	r28
    5708:	08 95       	ret

0000570a <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    570a:	cf 93       	push	r28
    570c:	df 93       	push	r29
    570e:	0f 92       	push	r0
    5710:	0f 92       	push	r0
    5712:	cd b7       	in	r28, 0x3d	; 61
    5714:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    5716:	89 e0       	ldi	r24, 0x09	; 9
    5718:	90 e0       	ldi	r25, 0x00	; 0
    571a:	9e 01       	movw	r18, r28
    571c:	2f 5f       	subi	r18, 0xFF	; 255
    571e:	3f 4f       	sbci	r19, 0xFF	; 255
    5720:	b9 01       	movw	r22, r18
    5722:	42 e0       	ldi	r20, 0x02	; 2
    5724:	50 e0       	ldi	r21, 0x00	; 0
    5726:	0e 94 86 2f 	call	0x5f0c	; 0x5f0c <chb_eeprom_read>
    return *(U16 *)addr;
    572a:	ce 01       	movw	r24, r28
    572c:	01 96       	adiw	r24, 0x01	; 1
    572e:	fc 01       	movw	r30, r24
    5730:	80 81       	ld	r24, Z
    5732:	91 81       	ldd	r25, Z+1	; 0x01
}
    5734:	0f 90       	pop	r0
    5736:	0f 90       	pop	r0
    5738:	df 91       	pop	r29
    573a:	cf 91       	pop	r28
    573c:	08 95       	ret

0000573e <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    573e:	cf 93       	push	r28
    5740:	df 93       	push	r29
    5742:	cd b7       	in	r28, 0x3d	; 61
    5744:	de b7       	in	r29, 0x3e	; 62
    5746:	28 97       	sbiw	r28, 0x08	; 8
    5748:	cd bf       	out	0x3d, r28	; 61
    574a:	de bf       	out	0x3e, r29	; 62
    574c:	8c 83       	std	Y+4, r24	; 0x04
    574e:	9d 83       	std	Y+5, r25	; 0x05
    5750:	6e 83       	std	Y+6, r22	; 0x06
    5752:	7f 83       	std	Y+7, r23	; 0x07
    5754:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5756:	0e 94 0b 21 	call	0x4216	; 0x4216 <chb_get_state>
    575a:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    575c:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <chb_get_pcb>
    5760:	8a 83       	std	Y+2, r24	; 0x02
    5762:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5764:	89 81       	ldd	r24, Y+1	; 0x01
    5766:	82 30       	cpi	r24, 0x02	; 2
    5768:	19 f0       	breq	.+6      	; 0x5770 <chb_tx+0x32>
    576a:	89 81       	ldd	r24, Y+1	; 0x01
    576c:	82 31       	cpi	r24, 0x12	; 18
    576e:	11 f4       	brne	.+4      	; 0x5774 <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5770:	84 e4       	ldi	r24, 0x44	; 68
    5772:	23 c0       	rjmp	.+70     	; 0x57ba <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5774:	88 e0       	ldi	r24, 0x08	; 8
    5776:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    577a:	89 e1       	ldi	r24, 0x19	; 25
    577c:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5780:	8c 81       	ldd	r24, Y+4	; 0x04
    5782:	9d 81       	ldd	r25, Y+5	; 0x05
    5784:	2e 81       	ldd	r18, Y+6	; 0x06
    5786:	3f 81       	ldd	r19, Y+7	; 0x07
    5788:	6a e0       	ldi	r22, 0x0A	; 10
    578a:	a9 01       	movw	r20, r18
    578c:	28 85       	ldd	r18, Y+8	; 0x08
    578e:	0e 94 19 24 	call	0x4832	; 0x4832 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5792:	82 e0       	ldi	r24, 0x02	; 2
    5794:	62 e0       	ldi	r22, 0x02	; 2
    5796:	4f e1       	ldi	r20, 0x1F	; 31
    5798:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    579c:	00 00       	nop
    579e:	8a 81       	ldd	r24, Y+2	; 0x02
    57a0:	9b 81       	ldd	r25, Y+3	; 0x03
    57a2:	fc 01       	movw	r30, r24
    57a4:	94 81       	ldd	r25, Z+4	; 0x04
    57a6:	81 e0       	ldi	r24, 0x01	; 1
    57a8:	89 27       	eor	r24, r25
    57aa:	88 23       	and	r24, r24
    57ac:	c1 f7       	brne	.-16     	; 0x579e <chb_tx+0x60>
    pcb->tx_end = false;
    57ae:	8a 81       	ldd	r24, Y+2	; 0x02
    57b0:	9b 81       	ldd	r25, Y+3	; 0x03
    57b2:	fc 01       	movw	r30, r24
    57b4:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    57b6:	0e 94 16 21 	call	0x422c	; 0x422c <chb_get_status>
}
    57ba:	28 96       	adiw	r28, 0x08	; 8
    57bc:	cd bf       	out	0x3d, r28	; 61
    57be:	de bf       	out	0x3e, r29	; 62
    57c0:	df 91       	pop	r29
    57c2:	cf 91       	pop	r28
    57c4:	08 95       	ret

000057c6 <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    57c6:	0f 93       	push	r16
    57c8:	1f 93       	push	r17
    57ca:	cf 93       	push	r28
    57cc:	df 93       	push	r29
    57ce:	cd b7       	in	r28, 0x3d	; 61
    57d0:	de b7       	in	r29, 0x3e	; 62
    57d2:	69 97       	sbiw	r28, 0x19	; 25
    57d4:	cd bf       	out	0x3d, r28	; 61
    57d6:	de bf       	out	0x3e, r29	; 62
    57d8:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    57da:	89 8d       	ldd	r24, Y+25	; 0x19
    57dc:	88 23       	and	r24, r24
    57de:	69 f0       	breq	.+26     	; 0x57fa <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    57e0:	88 e0       	ldi	r24, 0x08	; 8
    57e2:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    57e6:	84 e6       	ldi	r24, 0x64	; 100
    57e8:	96 e0       	ldi	r25, 0x06	; 6
    57ea:	24 e6       	ldi	r18, 0x64	; 100
    57ec:	36 e0       	ldi	r19, 0x06	; 6
    57ee:	f9 01       	movw	r30, r18
    57f0:	20 81       	ld	r18, Z
    57f2:	22 60       	ori	r18, 0x02	; 2
    57f4:	fc 01       	movw	r30, r24
    57f6:	20 83       	st	Z, r18
    57f8:	e1 c0       	rjmp	.+450    	; 0x59bc <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    57fa:	84 e6       	ldi	r24, 0x64	; 100
    57fc:	96 e0       	ldi	r25, 0x06	; 6
    57fe:	24 e6       	ldi	r18, 0x64	; 100
    5800:	36 e0       	ldi	r19, 0x06	; 6
    5802:	f9 01       	movw	r30, r18
    5804:	20 81       	ld	r18, Z
    5806:	2d 7f       	andi	r18, 0xFD	; 253
    5808:	fc 01       	movw	r30, r24
    580a:	20 83       	st	Z, r18
    580c:	80 e0       	ldi	r24, 0x00	; 0
    580e:	90 e0       	ldi	r25, 0x00	; 0
    5810:	a0 e7       	ldi	r26, 0x70	; 112
    5812:	b3 e4       	ldi	r27, 0x43	; 67
    5814:	89 83       	std	Y+1, r24	; 0x01
    5816:	9a 83       	std	Y+2, r25	; 0x02
    5818:	ab 83       	std	Y+3, r26	; 0x03
    581a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    581c:	69 81       	ldd	r22, Y+1	; 0x01
    581e:	7a 81       	ldd	r23, Y+2	; 0x02
    5820:	8b 81       	ldd	r24, Y+3	; 0x03
    5822:	9c 81       	ldd	r25, Y+4	; 0x04
    5824:	2b ea       	ldi	r18, 0xAB	; 171
    5826:	3a ea       	ldi	r19, 0xAA	; 170
    5828:	4a ea       	ldi	r20, 0xAA	; 170
    582a:	5e e3       	ldi	r21, 0x3E	; 62
    582c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    5830:	dc 01       	movw	r26, r24
    5832:	cb 01       	movw	r24, r22
    5834:	8d 83       	std	Y+5, r24	; 0x05
    5836:	9e 83       	std	Y+6, r25	; 0x06
    5838:	af 83       	std	Y+7, r26	; 0x07
    583a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    583c:	11 e0       	ldi	r17, 0x01	; 1
    583e:	6d 81       	ldd	r22, Y+5	; 0x05
    5840:	7e 81       	ldd	r23, Y+6	; 0x06
    5842:	8f 81       	ldd	r24, Y+7	; 0x07
    5844:	98 85       	ldd	r25, Y+8	; 0x08
    5846:	20 e0       	ldi	r18, 0x00	; 0
    5848:	30 e0       	ldi	r19, 0x00	; 0
    584a:	40 e8       	ldi	r20, 0x80	; 128
    584c:	5f e3       	ldi	r21, 0x3F	; 63
    584e:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    5852:	88 23       	and	r24, r24
    5854:	0c f0       	brlt	.+2      	; 0x5858 <chb_sleep+0x92>
    5856:	10 e0       	ldi	r17, 0x00	; 0
    5858:	11 23       	and	r17, r17
    585a:	19 f0       	breq	.+6      	; 0x5862 <chb_sleep+0x9c>
		__ticks = 1;
    585c:	81 e0       	ldi	r24, 0x01	; 1
    585e:	89 87       	std	Y+9, r24	; 0x09
    5860:	a3 c0       	rjmp	.+326    	; 0x59a8 <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5862:	11 e0       	ldi	r17, 0x01	; 1
    5864:	6d 81       	ldd	r22, Y+5	; 0x05
    5866:	7e 81       	ldd	r23, Y+6	; 0x06
    5868:	8f 81       	ldd	r24, Y+7	; 0x07
    586a:	98 85       	ldd	r25, Y+8	; 0x08
    586c:	20 e0       	ldi	r18, 0x00	; 0
    586e:	30 e0       	ldi	r19, 0x00	; 0
    5870:	4f e7       	ldi	r20, 0x7F	; 127
    5872:	53 e4       	ldi	r21, 0x43	; 67
    5874:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    5878:	18 16       	cp	r1, r24
    587a:	0c f0       	brlt	.+2      	; 0x587e <chb_sleep+0xb8>
    587c:	10 e0       	ldi	r17, 0x00	; 0
    587e:	11 23       	and	r17, r17
    5880:	09 f4       	brne	.+2      	; 0x5884 <chb_sleep+0xbe>
    5882:	89 c0       	rjmp	.+274    	; 0x5996 <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5884:	69 81       	ldd	r22, Y+1	; 0x01
    5886:	7a 81       	ldd	r23, Y+2	; 0x02
    5888:	8b 81       	ldd	r24, Y+3	; 0x03
    588a:	9c 81       	ldd	r25, Y+4	; 0x04
    588c:	20 e0       	ldi	r18, 0x00	; 0
    588e:	30 e0       	ldi	r19, 0x00	; 0
    5890:	4a e7       	ldi	r20, 0x7A	; 122
    5892:	54 e4       	ldi	r21, 0x44	; 68
    5894:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    5898:	dc 01       	movw	r26, r24
    589a:	cb 01       	movw	r24, r22
    589c:	8a 87       	std	Y+10, r24	; 0x0a
    589e:	9b 87       	std	Y+11, r25	; 0x0b
    58a0:	ac 87       	std	Y+12, r26	; 0x0c
    58a2:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    58a4:	6a 85       	ldd	r22, Y+10	; 0x0a
    58a6:	7b 85       	ldd	r23, Y+11	; 0x0b
    58a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    58aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    58ac:	20 e0       	ldi	r18, 0x00	; 0
    58ae:	30 e0       	ldi	r19, 0x00	; 0
    58b0:	4a e7       	ldi	r20, 0x7A	; 122
    58b2:	53 e4       	ldi	r21, 0x43	; 67
    58b4:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    58b8:	dc 01       	movw	r26, r24
    58ba:	cb 01       	movw	r24, r22
    58bc:	8e 87       	std	Y+14, r24	; 0x0e
    58be:	9f 87       	std	Y+15, r25	; 0x0f
    58c0:	a8 8b       	std	Y+16, r26	; 0x10
    58c2:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    58c4:	11 e0       	ldi	r17, 0x01	; 1
    58c6:	6e 85       	ldd	r22, Y+14	; 0x0e
    58c8:	7f 85       	ldd	r23, Y+15	; 0x0f
    58ca:	88 89       	ldd	r24, Y+16	; 0x10
    58cc:	99 89       	ldd	r25, Y+17	; 0x11
    58ce:	20 e0       	ldi	r18, 0x00	; 0
    58d0:	30 e0       	ldi	r19, 0x00	; 0
    58d2:	40 e8       	ldi	r20, 0x80	; 128
    58d4:	5f e3       	ldi	r21, 0x3F	; 63
    58d6:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    58da:	88 23       	and	r24, r24
    58dc:	0c f0       	brlt	.+2      	; 0x58e0 <chb_sleep+0x11a>
    58de:	10 e0       	ldi	r17, 0x00	; 0
    58e0:	11 23       	and	r17, r17
    58e2:	29 f0       	breq	.+10     	; 0x58ee <chb_sleep+0x128>
		__ticks = 1;
    58e4:	81 e0       	ldi	r24, 0x01	; 1
    58e6:	90 e0       	ldi	r25, 0x00	; 0
    58e8:	8a 8b       	std	Y+18, r24	; 0x12
    58ea:	9b 8b       	std	Y+19, r25	; 0x13
    58ec:	46 c0       	rjmp	.+140    	; 0x597a <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    58ee:	11 e0       	ldi	r17, 0x01	; 1
    58f0:	6e 85       	ldd	r22, Y+14	; 0x0e
    58f2:	7f 85       	ldd	r23, Y+15	; 0x0f
    58f4:	88 89       	ldd	r24, Y+16	; 0x10
    58f6:	99 89       	ldd	r25, Y+17	; 0x11
    58f8:	20 e0       	ldi	r18, 0x00	; 0
    58fa:	3f ef       	ldi	r19, 0xFF	; 255
    58fc:	4f e7       	ldi	r20, 0x7F	; 127
    58fe:	57 e4       	ldi	r21, 0x47	; 71
    5900:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    5904:	18 16       	cp	r1, r24
    5906:	0c f0       	brlt	.+2      	; 0x590a <chb_sleep+0x144>
    5908:	10 e0       	ldi	r17, 0x00	; 0
    590a:	11 23       	and	r17, r17
    590c:	61 f1       	breq	.+88     	; 0x5966 <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    590e:	6a 85       	ldd	r22, Y+10	; 0x0a
    5910:	7b 85       	ldd	r23, Y+11	; 0x0b
    5912:	8c 85       	ldd	r24, Y+12	; 0x0c
    5914:	9d 85       	ldd	r25, Y+13	; 0x0d
    5916:	20 e0       	ldi	r18, 0x00	; 0
    5918:	30 e0       	ldi	r19, 0x00	; 0
    591a:	40 e2       	ldi	r20, 0x20	; 32
    591c:	51 e4       	ldi	r21, 0x41	; 65
    591e:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    5922:	dc 01       	movw	r26, r24
    5924:	cb 01       	movw	r24, r22
    5926:	bc 01       	movw	r22, r24
    5928:	cd 01       	movw	r24, r26
    592a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    592e:	dc 01       	movw	r26, r24
    5930:	cb 01       	movw	r24, r22
    5932:	8a 8b       	std	Y+18, r24	; 0x12
    5934:	9b 8b       	std	Y+19, r25	; 0x13
    5936:	12 c0       	rjmp	.+36     	; 0x595c <chb_sleep+0x196>
    5938:	89 e1       	ldi	r24, 0x19	; 25
    593a:	90 e0       	ldi	r25, 0x00	; 0
    593c:	8c 8b       	std	Y+20, r24	; 0x14
    593e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5940:	8c 89       	ldd	r24, Y+20	; 0x14
    5942:	9d 89       	ldd	r25, Y+21	; 0x15
    5944:	8c 01       	movw	r16, r24
    5946:	c8 01       	movw	r24, r16
    5948:	01 97       	sbiw	r24, 0x01	; 1
    594a:	f1 f7       	brne	.-4      	; 0x5948 <chb_sleep+0x182>
    594c:	8c 01       	movw	r16, r24
    594e:	0c 8b       	std	Y+20, r16	; 0x14
    5950:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5952:	8a 89       	ldd	r24, Y+18	; 0x12
    5954:	9b 89       	ldd	r25, Y+19	; 0x13
    5956:	01 97       	sbiw	r24, 0x01	; 1
    5958:	8a 8b       	std	Y+18, r24	; 0x12
    595a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    595c:	8a 89       	ldd	r24, Y+18	; 0x12
    595e:	9b 89       	ldd	r25, Y+19	; 0x13
    5960:	00 97       	sbiw	r24, 0x00	; 0
    5962:	51 f7       	brne	.-44     	; 0x5938 <chb_sleep+0x172>
    5964:	28 c0       	rjmp	.+80     	; 0x59b6 <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5966:	6e 85       	ldd	r22, Y+14	; 0x0e
    5968:	7f 85       	ldd	r23, Y+15	; 0x0f
    596a:	88 89       	ldd	r24, Y+16	; 0x10
    596c:	99 89       	ldd	r25, Y+17	; 0x11
    596e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    5972:	dc 01       	movw	r26, r24
    5974:	cb 01       	movw	r24, r22
    5976:	8a 8b       	std	Y+18, r24	; 0x12
    5978:	9b 8b       	std	Y+19, r25	; 0x13
    597a:	8a 89       	ldd	r24, Y+18	; 0x12
    597c:	9b 89       	ldd	r25, Y+19	; 0x13
    597e:	8e 8b       	std	Y+22, r24	; 0x16
    5980:	9f 8b       	std	Y+23, r25	; 0x17
    5982:	8e 89       	ldd	r24, Y+22	; 0x16
    5984:	9f 89       	ldd	r25, Y+23	; 0x17
    5986:	8c 01       	movw	r16, r24
    5988:	f8 01       	movw	r30, r16
    598a:	31 97       	sbiw	r30, 0x01	; 1
    598c:	f1 f7       	brne	.-4      	; 0x598a <chb_sleep+0x1c4>
    598e:	8f 01       	movw	r16, r30
    5990:	0e 8b       	std	Y+22, r16	; 0x16
    5992:	1f 8b       	std	Y+23, r17	; 0x17
    5994:	10 c0       	rjmp	.+32     	; 0x59b6 <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5996:	6d 81       	ldd	r22, Y+5	; 0x05
    5998:	7e 81       	ldd	r23, Y+6	; 0x06
    599a:	8f 81       	ldd	r24, Y+7	; 0x07
    599c:	98 85       	ldd	r25, Y+8	; 0x08
    599e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    59a2:	dc 01       	movw	r26, r24
    59a4:	cb 01       	movw	r24, r22
    59a6:	89 87       	std	Y+9, r24	; 0x09
    59a8:	89 85       	ldd	r24, Y+9	; 0x09
    59aa:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    59ac:	88 8d       	ldd	r24, Y+24	; 0x18
    59ae:	18 2f       	mov	r17, r24
    59b0:	1a 95       	dec	r17
    59b2:	f1 f7       	brne	.-4      	; 0x59b0 <chb_sleep+0x1ea>
    59b4:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    59b6:	86 e1       	ldi	r24, 0x16	; 22
    59b8:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <chb_set_state>
    }
}
    59bc:	69 96       	adiw	r28, 0x19	; 25
    59be:	cd bf       	out	0x3d, r28	; 61
    59c0:	de bf       	out	0x3e, r29	; 62
    59c2:	df 91       	pop	r29
    59c4:	cf 91       	pop	r28
    59c6:	1f 91       	pop	r17
    59c8:	0f 91       	pop	r16
    59ca:	08 95       	ret

000059cc <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    59cc:	cf 93       	push	r28
    59ce:	df 93       	push	r29
    59d0:	cd b7       	in	r28, 0x3d	; 61
    59d2:	de b7       	in	r29, 0x3e	; 62
    59d4:	ea 97       	sbiw	r28, 0x3a	; 58
    59d6:	cd bf       	out	0x3d, r28	; 61
    59d8:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    59da:	0e 94 23 21 	call	0x4246	; 0x4246 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    59de:	8e e0       	ldi	r24, 0x0E	; 14
    59e0:	60 e0       	ldi	r22, 0x00	; 0
    59e2:	0e 94 6f 23 	call	0x46de	; 0x46de <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    59e6:	82 e0       	ldi	r24, 0x02	; 2
    59e8:	63 e0       	ldi	r22, 0x03	; 3
    59ea:	4f e1       	ldi	r20, 0x1F	; 31
    59ec:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    59f0:	00 00       	nop
    59f2:	81 e0       	ldi	r24, 0x01	; 1
    59f4:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    59f8:	88 2f       	mov	r24, r24
    59fa:	90 e0       	ldi	r25, 0x00	; 0
    59fc:	8f 71       	andi	r24, 0x1F	; 31
    59fe:	90 70       	andi	r25, 0x00	; 0
    5a00:	88 30       	cpi	r24, 0x08	; 8
    5a02:	91 05       	cpc	r25, r1
    5a04:	b1 f7       	brne	.-20     	; 0x59f2 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5a06:	8e e2       	ldi	r24, 0x2E	; 46
    5a08:	60 e4       	ldi	r22, 0x40	; 64
    5a0a:	40 ec       	ldi	r20, 0xC0	; 192
    5a0c:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5a10:	8e e0       	ldi	r24, 0x0E	; 14
    5a12:	6c e0       	ldi	r22, 0x0C	; 12
    5a14:	0e 94 6f 23 	call	0x46de	; 0x46de <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5a18:	84 e0       	ldi	r24, 0x04	; 4
    5a1a:	60 e2       	ldi	r22, 0x20	; 32
    5a1c:	40 e2       	ldi	r20, 0x20	; 32
    5a1e:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5a22:	81 e0       	ldi	r24, 0x01	; 1
    5a24:	0e 94 14 25 	call	0x4a28	; 0x4a28 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5a28:	81 e0       	ldi	r24, 0x01	; 1
    5a2a:	0e 94 5d 25 	call	0x4aba	; 0x4aba <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5a2e:	86 e1       	ldi	r24, 0x16	; 22
    5a30:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5a34:	82 e2       	ldi	r24, 0x22	; 34
    5a36:	64 e3       	ldi	r22, 0x34	; 52
    5a38:	72 e1       	ldi	r23, 0x12	; 18
    5a3a:	0e 94 9b 23 	call	0x4736	; 0x4736 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5a3e:	0e 94 85 2b 	call	0x570a	; 0x570a <chb_get_short_addr>
    5a42:	9c 01       	movw	r18, r24
    5a44:	80 e2       	ldi	r24, 0x20	; 32
    5a46:	b9 01       	movw	r22, r18
    5a48:	0e 94 9b 23 	call	0x4736	; 0x4736 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5a4c:	ce 01       	movw	r24, r28
    5a4e:	01 96       	adiw	r24, 0x01	; 1
    5a50:	0e 94 43 2b 	call	0x5686	; 0x5686 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5a54:	84 e2       	ldi	r24, 0x24	; 36
    5a56:	9e 01       	movw	r18, r28
    5a58:	2f 5f       	subi	r18, 0xFF	; 255
    5a5a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a5c:	b9 01       	movw	r22, r18
    5a5e:	0e 94 cc 23 	call	0x4798	; 0x4798 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5a62:	82 e7       	ldi	r24, 0x72	; 114
    5a64:	96 e0       	ldi	r25, 0x06	; 6
    5a66:	22 e7       	ldi	r18, 0x72	; 114
    5a68:	36 e0       	ldi	r19, 0x06	; 6
    5a6a:	f9 01       	movw	r30, r18
    5a6c:	20 81       	ld	r18, Z
    5a6e:	21 60       	ori	r18, 0x01	; 1
    5a70:	fc 01       	movw	r30, r24
    5a72:	20 83       	st	Z, r18
    5a74:	89 e6       	ldi	r24, 0x69	; 105
    5a76:	96 e0       	ldi	r25, 0x06	; 6
    5a78:	29 e6       	ldi	r18, 0x69	; 105
    5a7a:	36 e0       	ldi	r19, 0x06	; 6
    5a7c:	f9 01       	movw	r30, r18
    5a7e:	20 81       	ld	r18, Z
    5a80:	23 60       	ori	r18, 0x03	; 3
    5a82:	fc 01       	movw	r30, r24
    5a84:	20 83       	st	Z, r18
    5a86:	8a e6       	ldi	r24, 0x6A	; 106
    5a88:	96 e0       	ldi	r25, 0x06	; 6
    5a8a:	2a e6       	ldi	r18, 0x6A	; 106
    5a8c:	36 e0       	ldi	r19, 0x06	; 6
    5a8e:	f9 01       	movw	r30, r18
    5a90:	20 81       	ld	r18, Z
    5a92:	24 60       	ori	r18, 0x04	; 4
    5a94:	fc 01       	movw	r30, r24
    5a96:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5a98:	80 ea       	ldi	r24, 0xA0	; 160
    5a9a:	90 e0       	ldi	r25, 0x00	; 0
    5a9c:	20 ea       	ldi	r18, 0xA0	; 160
    5a9e:	30 e0       	ldi	r19, 0x00	; 0
    5aa0:	f9 01       	movw	r30, r18
    5aa2:	22 81       	ldd	r18, Z+2	; 0x02
    5aa4:	27 60       	ori	r18, 0x07	; 7
    5aa6:	fc 01       	movw	r30, r24
    5aa8:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5aaa:	0e 94 0b 21 	call	0x4216	; 0x4216 <chb_get_state>
    5aae:	86 31       	cpi	r24, 0x16	; 22
    5ab0:	b1 f0       	breq	.+44     	; 0x5ade <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5ab2:	ce 01       	movw	r24, r28
    5ab4:	09 96       	adiw	r24, 0x09	; 9
    5ab6:	2c e0       	ldi	r18, 0x0C	; 12
    5ab8:	32 e0       	ldi	r19, 0x02	; 2
    5aba:	b9 01       	movw	r22, r18
    5abc:	0e 94 b9 62 	call	0xc572	; 0xc572 <strcpy_P>
        printf(buf);
    5ac0:	0f 92       	push	r0
    5ac2:	0f 92       	push	r0
    5ac4:	8d b7       	in	r24, 0x3d	; 61
    5ac6:	9e b7       	in	r25, 0x3e	; 62
    5ac8:	01 96       	adiw	r24, 0x01	; 1
    5aca:	9e 01       	movw	r18, r28
    5acc:	27 5f       	subi	r18, 0xF7	; 247
    5ace:	3f 4f       	sbci	r19, 0xFF	; 255
    5ad0:	fc 01       	movw	r30, r24
    5ad2:	20 83       	st	Z, r18
    5ad4:	31 83       	std	Z+1, r19	; 0x01
    5ad6:	0e 94 15 63 	call	0xc62a	; 0xc62a <printf>
    5ada:	0f 90       	pop	r0
    5adc:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5ade:	10 92 cb 50 	sts	0x50CB, r1
    5ae2:	10 92 cc 50 	sts	0x50CC, r1
    5ae6:	10 92 cd 50 	sts	0x50CD, r1
    5aea:	10 92 ce 50 	sts	0x50CE, r1
}
    5aee:	ea 96       	adiw	r28, 0x3a	; 58
    5af0:	cd bf       	out	0x3d, r28	; 61
    5af2:	de bf       	out	0x3e, r29	; 62
    5af4:	df 91       	pop	r29
    5af6:	cf 91       	pop	r28
    5af8:	08 95       	ret

00005afa <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5afa:	cf 93       	push	r28
    5afc:	df 93       	push	r29
    5afe:	cd b7       	in	r28, 0x3d	; 61
    5b00:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5b02:	0e 94 c6 2f 	call	0x5f8c	; 0x5f8c <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5b06:	80 e6       	ldi	r24, 0x60	; 96
    5b08:	96 e0       	ldi	r25, 0x06	; 6
    5b0a:	20 e6       	ldi	r18, 0x60	; 96
    5b0c:	36 e0       	ldi	r19, 0x06	; 6
    5b0e:	f9 01       	movw	r30, r18
    5b10:	20 81       	ld	r18, Z
    5b12:	22 60       	ori	r18, 0x02	; 2
    5b14:	fc 01       	movw	r30, r24
    5b16:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5b18:	80 e6       	ldi	r24, 0x60	; 96
    5b1a:	96 e0       	ldi	r25, 0x06	; 6
    5b1c:	20 e6       	ldi	r18, 0x60	; 96
    5b1e:	36 e0       	ldi	r19, 0x06	; 6
    5b20:	f9 01       	movw	r30, r18
    5b22:	20 81       	ld	r18, Z
    5b24:	21 60       	ori	r18, 0x01	; 1
    5b26:	fc 01       	movw	r30, r24
    5b28:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5b2a:	0e 94 e6 2c 	call	0x59cc	; 0x59cc <chb_radio_init>
}
    5b2e:	df 91       	pop	r29
    5b30:	cf 91       	pop	r28
    5b32:	08 95       	ret

00005b34 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5b34:	1f 92       	push	r1
    5b36:	0f 92       	push	r0
    5b38:	0f b6       	in	r0, 0x3f	; 63
    5b3a:	0f 92       	push	r0
    5b3c:	00 90 3b 00 	lds	r0, 0x003B
    5b40:	0f 92       	push	r0
    5b42:	11 24       	eor	r1, r1
    5b44:	2f 93       	push	r18
    5b46:	3f 93       	push	r19
    5b48:	4f 93       	push	r20
    5b4a:	5f 93       	push	r21
    5b4c:	6f 93       	push	r22
    5b4e:	7f 93       	push	r23
    5b50:	8f 93       	push	r24
    5b52:	9f 93       	push	r25
    5b54:	af 93       	push	r26
    5b56:	bf 93       	push	r27
    5b58:	ef 93       	push	r30
    5b5a:	ff 93       	push	r31
    5b5c:	cf 93       	push	r28
    5b5e:	df 93       	push	r29
    5b60:	cd b7       	in	r28, 0x3d	; 61
    5b62:	de b7       	in	r29, 0x3e	; 62
    5b64:	25 97       	sbiw	r28, 0x05	; 5
    5b66:	cd bf       	out	0x3d, r28	; 61
    5b68:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    5b6a:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5b6c:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <chb_get_pcb>
    5b70:	8a 83       	std	Y+2, r24	; 0x02
    5b72:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5b74:	8f e3       	ldi	r24, 0x3F	; 63
    5b76:	90 e0       	ldi	r25, 0x00	; 0
    5b78:	fc 01       	movw	r30, r24
    5b7a:	80 81       	ld	r24, Z
    5b7c:	80 93 4f 40 	sts	0x404F, r24
    5b80:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5b82:	81 e0       	ldi	r24, 0x01	; 1
    5b84:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5b88:	8f e8       	ldi	r24, 0x8F	; 143
    5b8a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    5b8e:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    5b90:	80 e0       	ldi	r24, 0x00	; 0
    5b92:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <SPID_write>
    5b96:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5b98:	80 e0       	ldi	r24, 0x00	; 0
    5b9a:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <RadioCS>

    while (intp_src)
    5b9e:	9d c0       	rjmp	.+314    	; 0x5cda <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5ba0:	89 81       	ldd	r24, Y+1	; 0x01
    5ba2:	88 2f       	mov	r24, r24
    5ba4:	90 e0       	ldi	r25, 0x00	; 0
    5ba6:	84 70       	andi	r24, 0x04	; 4
    5ba8:	90 70       	andi	r25, 0x00	; 0
    5baa:	00 97       	sbiw	r24, 0x00	; 0
    5bac:	21 f0       	breq	.+8      	; 0x5bb6 <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5bae:	89 81       	ldd	r24, Y+1	; 0x01
    5bb0:	8b 7f       	andi	r24, 0xFB	; 251
    5bb2:	89 83       	std	Y+1, r24	; 0x01
    5bb4:	92 c0       	rjmp	.+292    	; 0x5cda <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5bb6:	89 81       	ldd	r24, Y+1	; 0x01
    5bb8:	88 2f       	mov	r24, r24
    5bba:	90 e0       	ldi	r25, 0x00	; 0
    5bbc:	88 70       	andi	r24, 0x08	; 8
    5bbe:	90 70       	andi	r25, 0x00	; 0
    5bc0:	00 97       	sbiw	r24, 0x00	; 0
    5bc2:	09 f4       	brne	.+2      	; 0x5bc6 <__vector_64+0x92>
    5bc4:	4c c0       	rjmp	.+152    	; 0x5c5e <__vector_64+0x12a>
        {
            state = chb_get_state();
    5bc6:	0e 94 0b 21 	call	0x4216	; 0x4216 <chb_get_state>
    5bca:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    5bce:	86 30       	cpi	r24, 0x06	; 6
    5bd0:	31 f0       	breq	.+12     	; 0x5bde <__vector_64+0xaa>
    5bd2:	8d 81       	ldd	r24, Y+5	; 0x05
    5bd4:	86 31       	cpi	r24, 0x16	; 22
    5bd6:	19 f0       	breq	.+6      	; 0x5bde <__vector_64+0xaa>
    5bd8:	8d 81       	ldd	r24, Y+5	; 0x05
    5bda:	81 31       	cpi	r24, 0x11	; 17
    5bdc:	89 f5       	brne	.+98     	; 0x5c40 <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5bde:	88 e0       	ldi	r24, 0x08	; 8
    5be0:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5be4:	87 e0       	ldi	r24, 0x07	; 7
    5be6:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    5bea:	28 2f       	mov	r18, r24
    5bec:	8a 81       	ldd	r24, Y+2	; 0x02
    5bee:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf0:	fc 01       	movw	r30, r24
    5bf2:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5bf4:	86 e0       	ldi	r24, 0x06	; 6
    5bf6:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
    5bfa:	28 2f       	mov	r18, r24
    5bfc:	22 1f       	adc	r18, r18
    5bfe:	22 27       	eor	r18, r18
    5c00:	22 1f       	adc	r18, r18
    5c02:	8a 81       	ldd	r24, Y+2	; 0x02
    5c04:	9b 81       	ldd	r25, Y+3	; 0x03
    5c06:	fc 01       	movw	r30, r24
    5c08:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5c0a:	8a 81       	ldd	r24, Y+2	; 0x02
    5c0c:	9b 81       	ldd	r25, Y+3	; 0x03
    5c0e:	fc 01       	movw	r30, r24
    5c10:	83 89       	ldd	r24, Z+19	; 0x13
    5c12:	88 23       	and	r24, r24
    5c14:	d1 f0       	breq	.+52     	; 0x5c4a <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    5c16:	0e 94 7e 24 	call	0x48fc	; 0x48fc <chb_frame_read>
                    pcb->rcvd_xfers++;
    5c1a:	8a 81       	ldd	r24, Y+2	; 0x02
    5c1c:	9b 81       	ldd	r25, Y+3	; 0x03
    5c1e:	fc 01       	movw	r30, r24
    5c20:	85 81       	ldd	r24, Z+5	; 0x05
    5c22:	96 81       	ldd	r25, Z+6	; 0x06
    5c24:	9c 01       	movw	r18, r24
    5c26:	2f 5f       	subi	r18, 0xFF	; 255
    5c28:	3f 4f       	sbci	r19, 0xFF	; 255
    5c2a:	8a 81       	ldd	r24, Y+2	; 0x02
    5c2c:	9b 81       	ldd	r25, Y+3	; 0x03
    5c2e:	fc 01       	movw	r30, r24
    5c30:	25 83       	std	Z+5, r18	; 0x05
    5c32:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5c34:	8a 81       	ldd	r24, Y+2	; 0x02
    5c36:	9b 81       	ldd	r25, Y+3	; 0x03
    5c38:	21 e0       	ldi	r18, 0x01	; 1
    5c3a:	fc 01       	movw	r30, r24
    5c3c:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5c3e:	05 c0       	rjmp	.+10     	; 0x5c4a <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    5c40:	8a 81       	ldd	r24, Y+2	; 0x02
    5c42:	9b 81       	ldd	r25, Y+3	; 0x03
    5c44:	21 e0       	ldi	r18, 0x01	; 1
    5c46:	fc 01       	movw	r30, r24
    5c48:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5c4a:	89 81       	ldd	r24, Y+1	; 0x01
    5c4c:	87 7f       	andi	r24, 0xF7	; 247
    5c4e:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5c50:	00 00       	nop
    5c52:	86 e1       	ldi	r24, 0x16	; 22
    5c54:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <chb_set_state>
    5c58:	80 34       	cpi	r24, 0x40	; 64
    5c5a:	d9 f7       	brne	.-10     	; 0x5c52 <__vector_64+0x11e>
    5c5c:	3e c0       	rjmp	.+124    	; 0x5cda <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5c5e:	89 81       	ldd	r24, Y+1	; 0x01
    5c60:	88 2f       	mov	r24, r24
    5c62:	90 e0       	ldi	r25, 0x00	; 0
    5c64:	80 74       	andi	r24, 0x40	; 64
    5c66:	90 70       	andi	r25, 0x00	; 0
    5c68:	00 97       	sbiw	r24, 0x00	; 0
    5c6a:	89 f0       	breq	.+34     	; 0x5c8e <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5c6c:	89 81       	ldd	r24, Y+1	; 0x01
    5c6e:	8f 7b       	andi	r24, 0xBF	; 191
    5c70:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5c72:	8a 81       	ldd	r24, Y+2	; 0x02
    5c74:	9b 81       	ldd	r25, Y+3	; 0x03
    5c76:	fc 01       	movw	r30, r24
    5c78:	87 85       	ldd	r24, Z+15	; 0x0f
    5c7a:	90 89       	ldd	r25, Z+16	; 0x10
    5c7c:	9c 01       	movw	r18, r24
    5c7e:	2f 5f       	subi	r18, 0xFF	; 255
    5c80:	3f 4f       	sbci	r19, 0xFF	; 255
    5c82:	8a 81       	ldd	r24, Y+2	; 0x02
    5c84:	9b 81       	ldd	r25, Y+3	; 0x03
    5c86:	fc 01       	movw	r30, r24
    5c88:	27 87       	std	Z+15, r18	; 0x0f
    5c8a:	30 8b       	std	Z+16, r19	; 0x10
    5c8c:	26 c0       	rjmp	.+76     	; 0x5cda <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5c8e:	89 81       	ldd	r24, Y+1	; 0x01
    5c90:	88 2f       	mov	r24, r24
    5c92:	90 e0       	ldi	r25, 0x00	; 0
    5c94:	82 70       	andi	r24, 0x02	; 2
    5c96:	90 70       	andi	r25, 0x00	; 0
    5c98:	00 97       	sbiw	r24, 0x00	; 0
    5c9a:	21 f0       	breq	.+8      	; 0x5ca4 <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5c9c:	89 81       	ldd	r24, Y+1	; 0x01
    5c9e:	8d 7f       	andi	r24, 0xFD	; 253
    5ca0:	89 83       	std	Y+1, r24	; 0x01
    5ca2:	1b c0       	rjmp	.+54     	; 0x5cda <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5ca4:	89 81       	ldd	r24, Y+1	; 0x01
    5ca6:	88 2f       	mov	r24, r24
    5ca8:	90 e0       	ldi	r25, 0x00	; 0
    5caa:	81 70       	andi	r24, 0x01	; 1
    5cac:	90 70       	andi	r25, 0x00	; 0
    5cae:	88 23       	and	r24, r24
    5cb0:	21 f0       	breq	.+8      	; 0x5cba <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5cb2:	89 81       	ldd	r24, Y+1	; 0x01
    5cb4:	8e 7f       	andi	r24, 0xFE	; 254
    5cb6:	89 83       	std	Y+1, r24	; 0x01
    5cb8:	10 c0       	rjmp	.+32     	; 0x5cda <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5cba:	89 81       	ldd	r24, Y+1	; 0x01
    5cbc:	88 23       	and	r24, r24
    5cbe:	6c f4       	brge	.+26     	; 0x5cda <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5cc0:	89 81       	ldd	r24, Y+1	; 0x01
    5cc2:	8f 77       	andi	r24, 0x7F	; 127
    5cc4:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5cc6:	8a 81       	ldd	r24, Y+2	; 0x02
    5cc8:	9b 81       	ldd	r25, Y+3	; 0x03
    5cca:	fc 01       	movw	r30, r24
    5ccc:	81 89       	ldd	r24, Z+17	; 0x11
    5cce:	28 2f       	mov	r18, r24
    5cd0:	2f 5f       	subi	r18, 0xFF	; 255
    5cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    5cd4:	9b 81       	ldd	r25, Y+3	; 0x03
    5cd6:	fc 01       	movw	r30, r24
    5cd8:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5cda:	89 81       	ldd	r24, Y+1	; 0x01
    5cdc:	88 23       	and	r24, r24
    5cde:	09 f0       	breq	.+2      	; 0x5ce2 <__vector_64+0x1ae>
    5ce0:	5f cf       	rjmp	.-322    	; 0x5ba0 <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5ce2:	8f e3       	ldi	r24, 0x3F	; 63
    5ce4:	90 e0       	ldi	r25, 0x00	; 0
    5ce6:	20 91 4f 40 	lds	r18, 0x404F
    5cea:	fc 01       	movw	r30, r24
    5cec:	20 83       	st	Z, r18
    5cee:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5cf0:	8f e0       	ldi	r24, 0x0F	; 15
    5cf2:	0e 94 0f 23 	call	0x461e	; 0x461e <chb_reg_read>
}
    5cf6:	25 96       	adiw	r28, 0x05	; 5
    5cf8:	cd bf       	out	0x3d, r28	; 61
    5cfa:	de bf       	out	0x3e, r29	; 62
    5cfc:	df 91       	pop	r29
    5cfe:	cf 91       	pop	r28
    5d00:	ff 91       	pop	r31
    5d02:	ef 91       	pop	r30
    5d04:	bf 91       	pop	r27
    5d06:	af 91       	pop	r26
    5d08:	9f 91       	pop	r25
    5d0a:	8f 91       	pop	r24
    5d0c:	7f 91       	pop	r23
    5d0e:	6f 91       	pop	r22
    5d10:	5f 91       	pop	r21
    5d12:	4f 91       	pop	r20
    5d14:	3f 91       	pop	r19
    5d16:	2f 91       	pop	r18
    5d18:	0f 90       	pop	r0
    5d1a:	00 92 3b 00 	sts	0x003B, r0
    5d1e:	0f 90       	pop	r0
    5d20:	0f be       	out	0x3f, r0	; 63
    5d22:	0f 90       	pop	r0
    5d24:	1f 90       	pop	r1
    5d26:	18 95       	reti

00005d28 <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5d28:	cf 93       	push	r28
    5d2a:	df 93       	push	r29
    5d2c:	0f 92       	push	r0
    5d2e:	cd b7       	in	r28, 0x3d	; 61
    5d30:	de b7       	in	r29, 0x3e	; 62
    5d32:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5d34:	89 81       	ldd	r24, Y+1	; 0x01
    5d36:	88 23       	and	r24, r24
    5d38:	31 f0       	breq	.+12     	; 0x5d46 <RadioCS+0x1e>
    5d3a:	80 e6       	ldi	r24, 0x60	; 96
    5d3c:	96 e0       	ldi	r25, 0x06	; 6
    5d3e:	20 e1       	ldi	r18, 0x10	; 16
    5d40:	fc 01       	movw	r30, r24
    5d42:	26 83       	std	Z+6, r18	; 0x06
    5d44:	05 c0       	rjmp	.+10     	; 0x5d50 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5d46:	80 e6       	ldi	r24, 0x60	; 96
    5d48:	96 e0       	ldi	r25, 0x06	; 6
    5d4a:	20 e1       	ldi	r18, 0x10	; 16
    5d4c:	fc 01       	movw	r30, r24
    5d4e:	25 83       	std	Z+5, r18	; 0x05
	}
    5d50:	0f 90       	pop	r0
    5d52:	df 91       	pop	r29
    5d54:	cf 91       	pop	r28
    5d56:	08 95       	ret

00005d58 <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5d58:	cf 93       	push	r28
    5d5a:	df 93       	push	r29
    5d5c:	00 d0       	rcall	.+0      	; 0x5d5e <chb_eep_write_byte+0x6>
    5d5e:	cd b7       	in	r28, 0x3d	; 61
    5d60:	de b7       	in	r29, 0x3e	; 62
    5d62:	89 83       	std	Y+1, r24	; 0x01
    5d64:	9a 83       	std	Y+2, r25	; 0x02
    5d66:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5d68:	00 00       	nop
    5d6a:	80 ec       	ldi	r24, 0xC0	; 192
    5d6c:	91 e0       	ldi	r25, 0x01	; 1
    5d6e:	fc 01       	movw	r30, r24
    5d70:	87 85       	ldd	r24, Z+15	; 0x0f
    5d72:	88 23       	and	r24, r24
    5d74:	d4 f3       	brlt	.-12     	; 0x5d6a <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5d76:	80 ec       	ldi	r24, 0xC0	; 192
    5d78:	91 e0       	ldi	r25, 0x01	; 1
    5d7a:	fc 01       	movw	r30, r24
    5d7c:	87 85       	ldd	r24, Z+15	; 0x0f
    5d7e:	88 2f       	mov	r24, r24
    5d80:	90 e0       	ldi	r25, 0x00	; 0
    5d82:	82 70       	andi	r24, 0x02	; 2
    5d84:	90 70       	andi	r25, 0x00	; 0
    5d86:	00 97       	sbiw	r24, 0x00	; 0
    5d88:	99 f0       	breq	.+38     	; 0x5db0 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5d8a:	80 ec       	ldi	r24, 0xC0	; 192
    5d8c:	91 e0       	ldi	r25, 0x01	; 1
    5d8e:	26 e3       	ldi	r18, 0x36	; 54
    5d90:	fc 01       	movw	r30, r24
    5d92:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5d94:	ef 93       	push	r30
    5d96:	ff 93       	push	r31
    5d98:	0f 93       	push	r16
    5d9a:	2f 93       	push	r18
    5d9c:	eb ec       	ldi	r30, 0xCB	; 203
    5d9e:	f1 e0       	ldi	r31, 0x01	; 1
    5da0:	08 ed       	ldi	r16, 0xD8	; 216
    5da2:	21 e0       	ldi	r18, 0x01	; 1
    5da4:	04 bf       	out	0x34, r16	; 52
    5da6:	20 83       	st	Z, r18
    5da8:	2f 91       	pop	r18
    5daa:	0f 91       	pop	r16
    5dac:	ff 91       	pop	r31
    5dae:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    5db0:	80 ec       	ldi	r24, 0xC0	; 192
    5db2:	91 e0       	ldi	r25, 0x01	; 1
    5db4:	23 e3       	ldi	r18, 0x33	; 51
    5db6:	fc 01       	movw	r30, r24
    5db8:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    5dba:	80 ec       	ldi	r24, 0xC0	; 192
    5dbc:	91 e0       	ldi	r25, 0x01	; 1
    5dbe:	29 81       	ldd	r18, Y+1	; 0x01
    5dc0:	fc 01       	movw	r30, r24
    5dc2:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5dc4:	80 ec       	ldi	r24, 0xC0	; 192
    5dc6:	91 e0       	ldi	r25, 0x01	; 1
    5dc8:	29 81       	ldd	r18, Y+1	; 0x01
    5dca:	3a 81       	ldd	r19, Y+2	; 0x02
    5dcc:	23 2f       	mov	r18, r19
    5dce:	33 27       	eor	r19, r19
    5dd0:	2f 71       	andi	r18, 0x1F	; 31
    5dd2:	fc 01       	movw	r30, r24
    5dd4:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5dd6:	80 ec       	ldi	r24, 0xC0	; 192
    5dd8:	91 e0       	ldi	r25, 0x01	; 1
    5dda:	fc 01       	movw	r30, r24
    5ddc:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    5dde:	80 ec       	ldi	r24, 0xC0	; 192
    5de0:	91 e0       	ldi	r25, 0x01	; 1
    5de2:	2b 81       	ldd	r18, Y+3	; 0x03
    5de4:	fc 01       	movw	r30, r24
    5de6:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    5de8:	80 ec       	ldi	r24, 0xC0	; 192
    5dea:	91 e0       	ldi	r25, 0x01	; 1
    5dec:	25 e3       	ldi	r18, 0x35	; 53
    5dee:	fc 01       	movw	r30, r24
    5df0:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5df2:	ef 93       	push	r30
    5df4:	ff 93       	push	r31
    5df6:	0f 93       	push	r16
    5df8:	2f 93       	push	r18
    5dfa:	eb ec       	ldi	r30, 0xCB	; 203
    5dfc:	f1 e0       	ldi	r31, 0x01	; 1
    5dfe:	08 ed       	ldi	r16, 0xD8	; 216
    5e00:	21 e0       	ldi	r18, 0x01	; 1
    5e02:	04 bf       	out	0x34, r16	; 52
    5e04:	20 83       	st	Z, r18
    5e06:	2f 91       	pop	r18
    5e08:	0f 91       	pop	r16
    5e0a:	ff 91       	pop	r31
    5e0c:	ef 91       	pop	r30
}
    5e0e:	23 96       	adiw	r28, 0x03	; 3
    5e10:	cd bf       	out	0x3d, r28	; 61
    5e12:	de bf       	out	0x3e, r29	; 62
    5e14:	df 91       	pop	r29
    5e16:	cf 91       	pop	r28
    5e18:	08 95       	ret

00005e1a <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    5e1a:	cf 93       	push	r28
    5e1c:	df 93       	push	r29
    5e1e:	0f 92       	push	r0
    5e20:	0f 92       	push	r0
    5e22:	cd b7       	in	r28, 0x3d	; 61
    5e24:	de b7       	in	r29, 0x3e	; 62
    5e26:	89 83       	std	Y+1, r24	; 0x01
    5e28:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5e2a:	00 00       	nop
    5e2c:	80 ec       	ldi	r24, 0xC0	; 192
    5e2e:	91 e0       	ldi	r25, 0x01	; 1
    5e30:	fc 01       	movw	r30, r24
    5e32:	87 85       	ldd	r24, Z+15	; 0x0f
    5e34:	88 23       	and	r24, r24
    5e36:	d4 f3       	brlt	.-12     	; 0x5e2c <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    5e38:	80 ec       	ldi	r24, 0xC0	; 192
    5e3a:	91 e0       	ldi	r25, 0x01	; 1
    5e3c:	29 81       	ldd	r18, Y+1	; 0x01
    5e3e:	fc 01       	movw	r30, r24
    5e40:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5e42:	80 ec       	ldi	r24, 0xC0	; 192
    5e44:	91 e0       	ldi	r25, 0x01	; 1
    5e46:	29 81       	ldd	r18, Y+1	; 0x01
    5e48:	3a 81       	ldd	r19, Y+2	; 0x02
    5e4a:	23 2f       	mov	r18, r19
    5e4c:	33 27       	eor	r19, r19
    5e4e:	2f 71       	andi	r18, 0x1F	; 31
    5e50:	fc 01       	movw	r30, r24
    5e52:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5e54:	80 ec       	ldi	r24, 0xC0	; 192
    5e56:	91 e0       	ldi	r25, 0x01	; 1
    5e58:	fc 01       	movw	r30, r24
    5e5a:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    5e5c:	80 ec       	ldi	r24, 0xC0	; 192
    5e5e:	91 e0       	ldi	r25, 0x01	; 1
    5e60:	26 e0       	ldi	r18, 0x06	; 6
    5e62:	fc 01       	movw	r30, r24
    5e64:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5e66:	ef 93       	push	r30
    5e68:	ff 93       	push	r31
    5e6a:	0f 93       	push	r16
    5e6c:	2f 93       	push	r18
    5e6e:	eb ec       	ldi	r30, 0xCB	; 203
    5e70:	f1 e0       	ldi	r31, 0x01	; 1
    5e72:	08 ed       	ldi	r16, 0xD8	; 216
    5e74:	21 e0       	ldi	r18, 0x01	; 1
    5e76:	04 bf       	out	0x34, r16	; 52
    5e78:	20 83       	st	Z, r18
    5e7a:	2f 91       	pop	r18
    5e7c:	0f 91       	pop	r16
    5e7e:	ff 91       	pop	r31
    5e80:	ef 91       	pop	r30

    return NVM.DATA0;
    5e82:	80 ec       	ldi	r24, 0xC0	; 192
    5e84:	91 e0       	ldi	r25, 0x01	; 1
    5e86:	fc 01       	movw	r30, r24
    5e88:	84 81       	ldd	r24, Z+4	; 0x04
}
    5e8a:	0f 90       	pop	r0
    5e8c:	0f 90       	pop	r0
    5e8e:	df 91       	pop	r29
    5e90:	cf 91       	pop	r28
    5e92:	08 95       	ret

00005e94 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    5e94:	cf 93       	push	r28
    5e96:	df 93       	push	r29
    5e98:	cd b7       	in	r28, 0x3d	; 61
    5e9a:	de b7       	in	r29, 0x3e	; 62
    5e9c:	27 97       	sbiw	r28, 0x07	; 7
    5e9e:	cd bf       	out	0x3d, r28	; 61
    5ea0:	de bf       	out	0x3e, r29	; 62
    5ea2:	8a 83       	std	Y+2, r24	; 0x02
    5ea4:	9b 83       	std	Y+3, r25	; 0x03
    5ea6:	6c 83       	std	Y+4, r22	; 0x04
    5ea8:	7d 83       	std	Y+5, r23	; 0x05
    5eaa:	4e 83       	std	Y+6, r20	; 0x06
    5eac:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5eae:	80 ec       	ldi	r24, 0xC0	; 192
    5eb0:	91 e0       	ldi	r25, 0x01	; 1
    5eb2:	20 ec       	ldi	r18, 0xC0	; 192
    5eb4:	31 e0       	ldi	r19, 0x01	; 1
    5eb6:	f9 01       	movw	r30, r18
    5eb8:	24 85       	ldd	r18, Z+12	; 0x0c
    5eba:	27 7f       	andi	r18, 0xF7	; 247
    5ebc:	fc 01       	movw	r30, r24
    5ebe:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    5ec0:	19 82       	std	Y+1, r1	; 0x01
    5ec2:	16 c0       	rjmp	.+44     	; 0x5ef0 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    5ec4:	89 81       	ldd	r24, Y+1	; 0x01
    5ec6:	28 2f       	mov	r18, r24
    5ec8:	30 e0       	ldi	r19, 0x00	; 0
    5eca:	8a 81       	ldd	r24, Y+2	; 0x02
    5ecc:	9b 81       	ldd	r25, Y+3	; 0x03
    5ece:	82 0f       	add	r24, r18
    5ed0:	93 1f       	adc	r25, r19
    5ed2:	29 81       	ldd	r18, Y+1	; 0x01
    5ed4:	22 2f       	mov	r18, r18
    5ed6:	30 e0       	ldi	r19, 0x00	; 0
    5ed8:	4c 81       	ldd	r20, Y+4	; 0x04
    5eda:	5d 81       	ldd	r21, Y+5	; 0x05
    5edc:	24 0f       	add	r18, r20
    5ede:	35 1f       	adc	r19, r21
    5ee0:	f9 01       	movw	r30, r18
    5ee2:	20 81       	ld	r18, Z
    5ee4:	62 2f       	mov	r22, r18
    5ee6:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    5eea:	89 81       	ldd	r24, Y+1	; 0x01
    5eec:	8f 5f       	subi	r24, 0xFF	; 255
    5eee:	89 83       	std	Y+1, r24	; 0x01
    5ef0:	89 81       	ldd	r24, Y+1	; 0x01
    5ef2:	28 2f       	mov	r18, r24
    5ef4:	30 e0       	ldi	r19, 0x00	; 0
    5ef6:	8e 81       	ldd	r24, Y+6	; 0x06
    5ef8:	9f 81       	ldd	r25, Y+7	; 0x07
    5efa:	28 17       	cp	r18, r24
    5efc:	39 07       	cpc	r19, r25
    5efe:	10 f3       	brcs	.-60     	; 0x5ec4 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    5f00:	27 96       	adiw	r28, 0x07	; 7
    5f02:	cd bf       	out	0x3d, r28	; 61
    5f04:	de bf       	out	0x3e, r29	; 62
    5f06:	df 91       	pop	r29
    5f08:	cf 91       	pop	r28
    5f0a:	08 95       	ret

00005f0c <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    5f0c:	0f 93       	push	r16
    5f0e:	1f 93       	push	r17
    5f10:	cf 93       	push	r28
    5f12:	df 93       	push	r29
    5f14:	cd b7       	in	r28, 0x3d	; 61
    5f16:	de b7       	in	r29, 0x3e	; 62
    5f18:	27 97       	sbiw	r28, 0x07	; 7
    5f1a:	cd bf       	out	0x3d, r28	; 61
    5f1c:	de bf       	out	0x3e, r29	; 62
    5f1e:	8a 83       	std	Y+2, r24	; 0x02
    5f20:	9b 83       	std	Y+3, r25	; 0x03
    5f22:	6c 83       	std	Y+4, r22	; 0x04
    5f24:	7d 83       	std	Y+5, r23	; 0x05
    5f26:	4e 83       	std	Y+6, r20	; 0x06
    5f28:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5f2a:	80 ec       	ldi	r24, 0xC0	; 192
    5f2c:	91 e0       	ldi	r25, 0x01	; 1
    5f2e:	20 ec       	ldi	r18, 0xC0	; 192
    5f30:	31 e0       	ldi	r19, 0x01	; 1
    5f32:	f9 01       	movw	r30, r18
    5f34:	24 85       	ldd	r18, Z+12	; 0x0c
    5f36:	27 7f       	andi	r18, 0xF7	; 247
    5f38:	fc 01       	movw	r30, r24
    5f3a:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5f3c:	19 82       	std	Y+1, r1	; 0x01
    5f3e:	16 c0       	rjmp	.+44     	; 0x5f6c <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    5f40:	89 81       	ldd	r24, Y+1	; 0x01
    5f42:	88 2f       	mov	r24, r24
    5f44:	90 e0       	ldi	r25, 0x00	; 0
    5f46:	2c 81       	ldd	r18, Y+4	; 0x04
    5f48:	3d 81       	ldd	r19, Y+5	; 0x05
    5f4a:	89 01       	movw	r16, r18
    5f4c:	08 0f       	add	r16, r24
    5f4e:	19 1f       	adc	r17, r25
    5f50:	89 81       	ldd	r24, Y+1	; 0x01
    5f52:	28 2f       	mov	r18, r24
    5f54:	30 e0       	ldi	r19, 0x00	; 0
    5f56:	8a 81       	ldd	r24, Y+2	; 0x02
    5f58:	9b 81       	ldd	r25, Y+3	; 0x03
    5f5a:	82 0f       	add	r24, r18
    5f5c:	93 1f       	adc	r25, r19
    5f5e:	0e 94 0d 2f 	call	0x5e1a	; 0x5e1a <chb_eep_read_byte>
    5f62:	f8 01       	movw	r30, r16
    5f64:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5f66:	89 81       	ldd	r24, Y+1	; 0x01
    5f68:	8f 5f       	subi	r24, 0xFF	; 255
    5f6a:	89 83       	std	Y+1, r24	; 0x01
    5f6c:	89 81       	ldd	r24, Y+1	; 0x01
    5f6e:	28 2f       	mov	r18, r24
    5f70:	30 e0       	ldi	r19, 0x00	; 0
    5f72:	8e 81       	ldd	r24, Y+6	; 0x06
    5f74:	9f 81       	ldd	r25, Y+7	; 0x07
    5f76:	28 17       	cp	r18, r24
    5f78:	39 07       	cpc	r19, r25
    5f7a:	10 f3       	brcs	.-60     	; 0x5f40 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    5f7c:	27 96       	adiw	r28, 0x07	; 7
    5f7e:	cd bf       	out	0x3d, r28	; 61
    5f80:	de bf       	out	0x3e, r29	; 62
    5f82:	df 91       	pop	r29
    5f84:	cf 91       	pop	r28
    5f86:	1f 91       	pop	r17
    5f88:	0f 91       	pop	r16
    5f8a:	08 95       	ret

00005f8c <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    5f8c:	cf 93       	push	r28
    5f8e:	df 93       	push	r29
    5f90:	cd b7       	in	r28, 0x3d	; 61
    5f92:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    5f94:	80 e6       	ldi	r24, 0x60	; 96
    5f96:	96 e0       	ldi	r25, 0x06	; 6
    5f98:	20 e6       	ldi	r18, 0x60	; 96
    5f9a:	36 e0       	ldi	r19, 0x06	; 6
    5f9c:	f9 01       	movw	r30, r18
    5f9e:	20 81       	ld	r18, Z
    5fa0:	20 6b       	ori	r18, 0xB0	; 176
    5fa2:	fc 01       	movw	r30, r24
    5fa4:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    5fa6:	84 e6       	ldi	r24, 0x64	; 100
    5fa8:	96 e0       	ldi	r25, 0x06	; 6
    5faa:	24 e6       	ldi	r18, 0x64	; 100
    5fac:	36 e0       	ldi	r19, 0x06	; 6
    5fae:	f9 01       	movw	r30, r18
    5fb0:	20 81       	ld	r18, Z
    5fb2:	20 61       	ori	r18, 0x10	; 16
    5fb4:	fc 01       	movw	r30, r24
    5fb6:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    5fb8:	80 ec       	ldi	r24, 0xC0	; 192
    5fba:	99 e0       	ldi	r25, 0x09	; 9
    5fbc:	20 ec       	ldi	r18, 0xC0	; 192
    5fbe:	39 e0       	ldi	r19, 0x09	; 9
    5fc0:	f9 01       	movw	r30, r18
    5fc2:	20 81       	ld	r18, Z
    5fc4:	21 65       	ori	r18, 0x51	; 81
    5fc6:	fc 01       	movw	r30, r24
    5fc8:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    5fca:	84 e6       	ldi	r24, 0x64	; 100
    5fcc:	96 e0       	ldi	r25, 0x06	; 6
    5fce:	24 e6       	ldi	r18, 0x64	; 100
    5fd0:	36 e0       	ldi	r19, 0x06	; 6
    5fd2:	f9 01       	movw	r30, r18
    5fd4:	20 81       	ld	r18, Z
    5fd6:	20 61       	ori	r18, 0x10	; 16
    5fd8:	fc 01       	movw	r30, r24
    5fda:	20 83       	st	Z, r18
}
    5fdc:	df 91       	pop	r29
    5fde:	cf 91       	pop	r28
    5fe0:	08 95       	ret

00005fe2 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    5fe2:	cf 93       	push	r28
    5fe4:	df 93       	push	r29
    5fe6:	0f 92       	push	r0
    5fe8:	0f 92       	push	r0
    5fea:	cd b7       	in	r28, 0x3d	; 61
    5fec:	de b7       	in	r29, 0x3e	; 62
    5fee:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    5ff0:	80 ec       	ldi	r24, 0xC0	; 192
    5ff2:	99 e0       	ldi	r25, 0x09	; 9
    5ff4:	2a 81       	ldd	r18, Y+2	; 0x02
    5ff6:	fc 01       	movw	r30, r24
    5ff8:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5ffa:	00 00       	nop
    5ffc:	80 ec       	ldi	r24, 0xC0	; 192
    5ffe:	99 e0       	ldi	r25, 0x09	; 9
    6000:	fc 01       	movw	r30, r24
    6002:	82 81       	ldd	r24, Z+2	; 0x02
    6004:	88 23       	and	r24, r24
    6006:	d4 f7       	brge	.-12     	; 0x5ffc <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    6008:	80 ec       	ldi	r24, 0xC0	; 192
    600a:	99 e0       	ldi	r25, 0x09	; 9
    600c:	fc 01       	movw	r30, r24
    600e:	83 81       	ldd	r24, Z+3	; 0x03
    6010:	89 83       	std	Y+1, r24	; 0x01
	return data;
    6012:	89 81       	ldd	r24, Y+1	; 0x01
    6014:	0f 90       	pop	r0
    6016:	0f 90       	pop	r0
    6018:	df 91       	pop	r29
    601a:	cf 91       	pop	r28
    601c:	08 95       	ret

0000601e <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    601e:	0f 93       	push	r16
    6020:	cf 93       	push	r28
    6022:	df 93       	push	r29
    6024:	00 d0       	rcall	.+0      	; 0x6026 <CCPWrite+0x8>
    6026:	00 d0       	rcall	.+0      	; 0x6028 <CCPWrite+0xa>
    6028:	cd b7       	in	r28, 0x3d	; 61
    602a:	de b7       	in	r29, 0x3e	; 62
    602c:	8c 83       	std	Y+4, r24	; 0x04
    602e:	9d 83       	std	Y+5, r25	; 0x05
    6030:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    6032:	8f e3       	ldi	r24, 0x3F	; 63
    6034:	90 e0       	ldi	r25, 0x00	; 0
    6036:	fc 01       	movw	r30, r24
    6038:	80 81       	ld	r24, Z
    603a:	8b 83       	std	Y+3, r24	; 0x03
    603c:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    603e:	8c 81       	ldd	r24, Y+4	; 0x04
    6040:	9d 81       	ldd	r25, Y+5	; 0x05
    6042:	89 83       	std	Y+1, r24	; 0x01
    6044:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    6046:	8b e3       	ldi	r24, 0x3B	; 59
    6048:	90 e0       	ldi	r25, 0x00	; 0
    604a:	fc 01       	movw	r30, r24
    604c:	10 82       	st	Z, r1
#endif
	asm volatile(
    604e:	89 81       	ldd	r24, Y+1	; 0x01
    6050:	9a 81       	ldd	r25, Y+2	; 0x02
    6052:	2e 81       	ldd	r18, Y+6	; 0x06
    6054:	fc 01       	movw	r30, r24
    6056:	08 ed       	ldi	r16, 0xD8	; 216
    6058:	04 bf       	out	0x34, r16	; 52
    605a:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    605c:	8f e3       	ldi	r24, 0x3F	; 63
    605e:	90 e0       	ldi	r25, 0x00	; 0
    6060:	2b 81       	ldd	r18, Y+3	; 0x03
    6062:	fc 01       	movw	r30, r24
    6064:	20 83       	st	Z, r18
#endif
}
    6066:	26 96       	adiw	r28, 0x06	; 6
    6068:	cd bf       	out	0x3d, r28	; 61
    606a:	de bf       	out	0x3e, r29	; 62
    606c:	df 91       	pop	r29
    606e:	cf 91       	pop	r28
    6070:	0f 91       	pop	r16
    6072:	08 95       	ret

00006074 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6074:	cf 93       	push	r28
    6076:	df 93       	push	r29
    6078:	00 d0       	rcall	.+0      	; 0x607a <CLKSYS_XOSC_Config+0x6>
    607a:	cd b7       	in	r28, 0x3d	; 61
    607c:	de b7       	in	r29, 0x3e	; 62
    607e:	89 83       	std	Y+1, r24	; 0x01
    6080:	6a 83       	std	Y+2, r22	; 0x02
    6082:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6084:	80 e5       	ldi	r24, 0x50	; 80
    6086:	90 e0       	ldi	r25, 0x00	; 0
    6088:	2a 81       	ldd	r18, Y+2	; 0x02
    608a:	22 23       	and	r18, r18
    608c:	11 f0       	breq	.+4      	; 0x6092 <CLKSYS_XOSC_Config+0x1e>
    608e:	20 e2       	ldi	r18, 0x20	; 32
    6090:	01 c0       	rjmp	.+2      	; 0x6094 <CLKSYS_XOSC_Config+0x20>
    6092:	20 e0       	ldi	r18, 0x00	; 0
    6094:	39 81       	ldd	r19, Y+1	; 0x01
    6096:	32 2b       	or	r19, r18
    6098:	2b 81       	ldd	r18, Y+3	; 0x03
    609a:	23 2b       	or	r18, r19
    609c:	fc 01       	movw	r30, r24
    609e:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    60a0:	23 96       	adiw	r28, 0x03	; 3
    60a2:	cd bf       	out	0x3d, r28	; 61
    60a4:	de bf       	out	0x3e, r29	; 62
    60a6:	df 91       	pop	r29
    60a8:	cf 91       	pop	r28
    60aa:	08 95       	ret

000060ac <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    60ac:	cf 93       	push	r28
    60ae:	df 93       	push	r29
    60b0:	0f 92       	push	r0
    60b2:	0f 92       	push	r0
    60b4:	cd b7       	in	r28, 0x3d	; 61
    60b6:	de b7       	in	r29, 0x3e	; 62
    60b8:	89 83       	std	Y+1, r24	; 0x01
    60ba:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    60bc:	8a 81       	ldd	r24, Y+2	; 0x02
    60be:	8f 71       	andi	r24, 0x1F	; 31
    60c0:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    60c2:	80 e5       	ldi	r24, 0x50	; 80
    60c4:	90 e0       	ldi	r25, 0x00	; 0
    60c6:	39 81       	ldd	r19, Y+1	; 0x01
    60c8:	2a 81       	ldd	r18, Y+2	; 0x02
    60ca:	23 2b       	or	r18, r19
    60cc:	fc 01       	movw	r30, r24
    60ce:	25 83       	std	Z+5, r18	; 0x05
}
    60d0:	0f 90       	pop	r0
    60d2:	0f 90       	pop	r0
    60d4:	df 91       	pop	r29
    60d6:	cf 91       	pop	r28
    60d8:	08 95       	ret

000060da <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    60da:	cf 93       	push	r28
    60dc:	df 93       	push	r29
    60de:	0f 92       	push	r0
    60e0:	0f 92       	push	r0
    60e2:	cd b7       	in	r28, 0x3d	; 61
    60e4:	de b7       	in	r29, 0x3e	; 62
    60e6:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    60e8:	80 e5       	ldi	r24, 0x50	; 80
    60ea:	90 e0       	ldi	r25, 0x00	; 0
    60ec:	20 e5       	ldi	r18, 0x50	; 80
    60ee:	30 e0       	ldi	r19, 0x00	; 0
    60f0:	f9 01       	movw	r30, r18
    60f2:	20 81       	ld	r18, Z
    60f4:	32 2f       	mov	r19, r18
    60f6:	2a 81       	ldd	r18, Y+2	; 0x02
    60f8:	20 95       	com	r18
    60fa:	23 23       	and	r18, r19
    60fc:	fc 01       	movw	r30, r24
    60fe:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    6100:	80 e5       	ldi	r24, 0x50	; 80
    6102:	90 e0       	ldi	r25, 0x00	; 0
    6104:	fc 01       	movw	r30, r24
    6106:	90 81       	ld	r25, Z
    6108:	8a 81       	ldd	r24, Y+2	; 0x02
    610a:	89 23       	and	r24, r25
    610c:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    610e:	89 81       	ldd	r24, Y+1	; 0x01
}
    6110:	0f 90       	pop	r0
    6112:	0f 90       	pop	r0
    6114:	df 91       	pop	r29
    6116:	cf 91       	pop	r28
    6118:	08 95       	ret

0000611a <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    611a:	cf 93       	push	r28
    611c:	df 93       	push	r29
    611e:	00 d0       	rcall	.+0      	; 0x6120 <CLKSYS_Prescalers_Config+0x6>
    6120:	cd b7       	in	r28, 0x3d	; 61
    6122:	de b7       	in	r29, 0x3e	; 62
    6124:	8a 83       	std	Y+2, r24	; 0x02
    6126:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    6128:	9a 81       	ldd	r25, Y+2	; 0x02
    612a:	8b 81       	ldd	r24, Y+3	; 0x03
    612c:	89 2b       	or	r24, r25
    612e:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    6130:	81 e4       	ldi	r24, 0x41	; 65
    6132:	90 e0       	ldi	r25, 0x00	; 0
    6134:	69 81       	ldd	r22, Y+1	; 0x01
    6136:	0e 94 0f 30 	call	0x601e	; 0x601e <CCPWrite>
}
    613a:	23 96       	adiw	r28, 0x03	; 3
    613c:	cd bf       	out	0x3d, r28	; 61
    613e:	de bf       	out	0x3e, r29	; 62
    6140:	df 91       	pop	r29
    6142:	cf 91       	pop	r28
    6144:	08 95       	ret

00006146 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6146:	cf 93       	push	r28
    6148:	df 93       	push	r29
    614a:	0f 92       	push	r0
    614c:	0f 92       	push	r0
    614e:	cd b7       	in	r28, 0x3d	; 61
    6150:	de b7       	in	r29, 0x3e	; 62
    6152:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    6154:	80 e4       	ldi	r24, 0x40	; 64
    6156:	90 e0       	ldi	r25, 0x00	; 0
    6158:	fc 01       	movw	r30, r24
    615a:	80 81       	ld	r24, Z
    615c:	98 2f       	mov	r25, r24
    615e:	98 7f       	andi	r25, 0xF8	; 248
    6160:	8a 81       	ldd	r24, Y+2	; 0x02
    6162:	89 2b       	or	r24, r25
    6164:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    6166:	80 e4       	ldi	r24, 0x40	; 64
    6168:	90 e0       	ldi	r25, 0x00	; 0
    616a:	69 81       	ldd	r22, Y+1	; 0x01
    616c:	0e 94 0f 30 	call	0x601e	; 0x601e <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    6170:	80 e4       	ldi	r24, 0x40	; 64
    6172:	90 e0       	ldi	r25, 0x00	; 0
    6174:	fc 01       	movw	r30, r24
    6176:	90 81       	ld	r25, Z
    6178:	8a 81       	ldd	r24, Y+2	; 0x02
    617a:	89 23       	and	r24, r25
    617c:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    617e:	89 81       	ldd	r24, Y+1	; 0x01
}
    6180:	0f 90       	pop	r0
    6182:	0f 90       	pop	r0
    6184:	df 91       	pop	r29
    6186:	cf 91       	pop	r28
    6188:	08 95       	ret

0000618a <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    618a:	cf 93       	push	r28
    618c:	df 93       	push	r29
    618e:	0f 92       	push	r0
    6190:	cd b7       	in	r28, 0x3d	; 61
    6192:	de b7       	in	r29, 0x3e	; 62
    6194:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6196:	80 e4       	ldi	r24, 0x40	; 64
    6198:	90 e0       	ldi	r25, 0x00	; 0
    619a:	20 e4       	ldi	r18, 0x40	; 64
    619c:	30 e0       	ldi	r19, 0x00	; 0
    619e:	f9 01       	movw	r30, r18
    61a0:	23 81       	ldd	r18, Z+3	; 0x03
    61a2:	32 2f       	mov	r19, r18
    61a4:	31 7f       	andi	r19, 0xF1	; 241
    61a6:	29 81       	ldd	r18, Y+1	; 0x01
    61a8:	23 2b       	or	r18, r19
    61aa:	21 60       	ori	r18, 0x01	; 1
    61ac:	fc 01       	movw	r30, r24
    61ae:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    61b0:	0f 90       	pop	r0
    61b2:	df 91       	pop	r29
    61b4:	cf 91       	pop	r28
    61b6:	08 95       	ret

000061b8 <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    61b8:	cf 93       	push	r28
    61ba:	df 93       	push	r29
    61bc:	0f 92       	push	r0
    61be:	0f 92       	push	r0
    61c0:	cd b7       	in	r28, 0x3d	; 61
    61c2:	de b7       	in	r29, 0x3e	; 62
    61c4:	89 83       	std	Y+1, r24	; 0x01
    61c6:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    61c8:	80 e5       	ldi	r24, 0x50	; 80
    61ca:	90 e0       	ldi	r25, 0x00	; 0
    61cc:	20 e5       	ldi	r18, 0x50	; 80
    61ce:	30 e0       	ldi	r19, 0x00	; 0
    61d0:	f9 01       	movw	r30, r18
    61d2:	26 81       	ldd	r18, Z+6	; 0x06
    61d4:	32 2f       	mov	r19, r18
    61d6:	29 81       	ldd	r18, Y+1	; 0x01
    61d8:	20 95       	com	r18
    61da:	32 23       	and	r19, r18
    61dc:	2a 81       	ldd	r18, Y+2	; 0x02
    61de:	22 23       	and	r18, r18
    61e0:	11 f0       	breq	.+4      	; 0x61e6 <CLKSYS_AutoCalibration_Enable+0x2e>
    61e2:	29 81       	ldd	r18, Y+1	; 0x01
    61e4:	01 c0       	rjmp	.+2      	; 0x61e8 <CLKSYS_AutoCalibration_Enable+0x30>
    61e6:	20 e0       	ldi	r18, 0x00	; 0
    61e8:	23 2b       	or	r18, r19
    61ea:	fc 01       	movw	r30, r24
    61ec:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    61ee:	89 81       	ldd	r24, Y+1	; 0x01
    61f0:	81 30       	cpi	r24, 0x01	; 1
    61f2:	51 f4       	brne	.+20     	; 0x6208 <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    61f4:	88 e6       	ldi	r24, 0x68	; 104
    61f6:	90 e0       	ldi	r25, 0x00	; 0
    61f8:	28 e6       	ldi	r18, 0x68	; 104
    61fa:	30 e0       	ldi	r19, 0x00	; 0
    61fc:	f9 01       	movw	r30, r18
    61fe:	20 81       	ld	r18, Z
    6200:	21 60       	ori	r18, 0x01	; 1
    6202:	fc 01       	movw	r30, r24
    6204:	20 83       	st	Z, r18
    6206:	0c c0       	rjmp	.+24     	; 0x6220 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    6208:	89 81       	ldd	r24, Y+1	; 0x01
    620a:	82 30       	cpi	r24, 0x02	; 2
    620c:	49 f4       	brne	.+18     	; 0x6220 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    620e:	80 e6       	ldi	r24, 0x60	; 96
    6210:	90 e0       	ldi	r25, 0x00	; 0
    6212:	20 e6       	ldi	r18, 0x60	; 96
    6214:	30 e0       	ldi	r19, 0x00	; 0
    6216:	f9 01       	movw	r30, r18
    6218:	20 81       	ld	r18, Z
    621a:	21 60       	ori	r18, 0x01	; 1
    621c:	fc 01       	movw	r30, r24
    621e:	20 83       	st	Z, r18
	}
}
    6220:	0f 90       	pop	r0
    6222:	0f 90       	pop	r0
    6224:	df 91       	pop	r29
    6226:	cf 91       	pop	r28
    6228:	08 95       	ret

0000622a <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    622a:	cf 93       	push	r28
    622c:	df 93       	push	r29
    622e:	cd b7       	in	r28, 0x3d	; 61
    6230:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    6232:	83 e5       	ldi	r24, 0x53	; 83
    6234:	90 e0       	ldi	r25, 0x00	; 0
    6236:	63 e0       	ldi	r22, 0x03	; 3
    6238:	0e 94 0f 30 	call	0x601e	; 0x601e <CCPWrite>
}
    623c:	df 91       	pop	r29
    623e:	cf 91       	pop	r28
    6240:	08 95       	ret

00006242 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    6242:	cf 93       	push	r28
    6244:	df 93       	push	r29
    6246:	cd b7       	in	r28, 0x3d	; 61
    6248:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    624a:	82 e4       	ldi	r24, 0x42	; 66
    624c:	90 e0       	ldi	r25, 0x00	; 0
    624e:	61 e0       	ldi	r22, 0x01	; 1
    6250:	0e 94 0f 30 	call	0x601e	; 0x601e <CCPWrite>
}
    6254:	df 91       	pop	r29
    6256:	cf 91       	pop	r28
    6258:	08 95       	ret

0000625a <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    625a:	cf 93       	push	r28
    625c:	df 93       	push	r29
    625e:	cd b7       	in	r28, 0x3d	; 61
    6260:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6262:	80 ec       	ldi	r24, 0xC0	; 192
    6264:	60 e0       	ldi	r22, 0x00	; 0
    6266:	4b e0       	ldi	r20, 0x0B	; 11
    6268:	0e 94 3a 30 	call	0x6074	; 0x6074 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    626c:	80 e5       	ldi	r24, 0x50	; 80
    626e:	90 e0       	ldi	r25, 0x00	; 0
    6270:	20 e5       	ldi	r18, 0x50	; 80
    6272:	30 e0       	ldi	r19, 0x00	; 0
    6274:	f9 01       	movw	r30, r18
    6276:	20 81       	ld	r18, Z
    6278:	28 60       	ori	r18, 0x08	; 8
    627a:	fc 01       	movw	r30, r24
    627c:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    627e:	80 e5       	ldi	r24, 0x50	; 80
    6280:	90 e0       	ldi	r25, 0x00	; 0
    6282:	fc 01       	movw	r30, r24
    6284:	81 81       	ldd	r24, Z+1	; 0x01
    6286:	88 2f       	mov	r24, r24
    6288:	90 e0       	ldi	r25, 0x00	; 0
    628a:	88 70       	andi	r24, 0x08	; 8
    628c:	90 70       	andi	r25, 0x00	; 0
    628e:	00 97       	sbiw	r24, 0x00	; 0
    6290:	b1 f3       	breq	.-20     	; 0x627e <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6292:	80 ec       	ldi	r24, 0xC0	; 192
    6294:	62 e0       	ldi	r22, 0x02	; 2
    6296:	0e 94 56 30 	call	0x60ac	; 0x60ac <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    629a:	80 e5       	ldi	r24, 0x50	; 80
    629c:	90 e0       	ldi	r25, 0x00	; 0
    629e:	20 e5       	ldi	r18, 0x50	; 80
    62a0:	30 e0       	ldi	r19, 0x00	; 0
    62a2:	f9 01       	movw	r30, r18
    62a4:	20 81       	ld	r18, Z
    62a6:	20 61       	ori	r18, 0x10	; 16
    62a8:	fc 01       	movw	r30, r24
    62aa:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    62ac:	80 e5       	ldi	r24, 0x50	; 80
    62ae:	90 e0       	ldi	r25, 0x00	; 0
    62b0:	fc 01       	movw	r30, r24
    62b2:	81 81       	ldd	r24, Z+1	; 0x01
    62b4:	88 2f       	mov	r24, r24
    62b6:	90 e0       	ldi	r25, 0x00	; 0
    62b8:	80 71       	andi	r24, 0x10	; 16
    62ba:	90 70       	andi	r25, 0x00	; 0
    62bc:	00 97       	sbiw	r24, 0x00	; 0
    62be:	b1 f3       	breq	.-20     	; 0x62ac <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    62c0:	84 e0       	ldi	r24, 0x04	; 4
    62c2:	0e 94 a3 30 	call	0x6146	; 0x6146 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    62c6:	81 e0       	ldi	r24, 0x01	; 1
    62c8:	0e 94 6d 30 	call	0x60da	; 0x60da <CLKSYS_Disable>
}
    62cc:	df 91       	pop	r29
    62ce:	cf 91       	pop	r28
    62d0:	08 95       	ret

000062d2 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    62d2:	cf 93       	push	r28
    62d4:	df 93       	push	r29
    62d6:	cd b7       	in	r28, 0x3d	; 61
    62d8:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    62da:	80 e5       	ldi	r24, 0x50	; 80
    62dc:	90 e0       	ldi	r25, 0x00	; 0
    62de:	20 e5       	ldi	r18, 0x50	; 80
    62e0:	30 e0       	ldi	r19, 0x00	; 0
    62e2:	f9 01       	movw	r30, r18
    62e4:	20 81       	ld	r18, Z
    62e6:	22 60       	ori	r18, 0x02	; 2
    62e8:	fc 01       	movw	r30, r24
    62ea:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    62ec:	80 e0       	ldi	r24, 0x00	; 0
    62ee:	61 e0       	ldi	r22, 0x01	; 1
    62f0:	0e 94 8d 30 	call	0x611a	; 0x611a <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    62f4:	80 e5       	ldi	r24, 0x50	; 80
    62f6:	90 e0       	ldi	r25, 0x00	; 0
    62f8:	fc 01       	movw	r30, r24
    62fa:	81 81       	ldd	r24, Z+1	; 0x01
    62fc:	88 2f       	mov	r24, r24
    62fe:	90 e0       	ldi	r25, 0x00	; 0
    6300:	82 70       	andi	r24, 0x02	; 2
    6302:	90 70       	andi	r25, 0x00	; 0
    6304:	00 97       	sbiw	r24, 0x00	; 0
    6306:	b1 f3       	breq	.-20     	; 0x62f4 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6308:	81 e0       	ldi	r24, 0x01	; 1
    630a:	0e 94 a3 30 	call	0x6146	; 0x6146 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    630e:	81 e0       	ldi	r24, 0x01	; 1
    6310:	0e 94 6d 30 	call	0x60da	; 0x60da <CLKSYS_Disable>
	
}
    6314:	df 91       	pop	r29
    6316:	cf 91       	pop	r28
    6318:	08 95       	ret

0000631a <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    631a:	cf 93       	push	r28
    631c:	df 93       	push	r29
    631e:	cd b7       	in	r28, 0x3d	; 61
    6320:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6322:	80 e5       	ldi	r24, 0x50	; 80
    6324:	90 e0       	ldi	r25, 0x00	; 0
    6326:	20 e5       	ldi	r18, 0x50	; 80
    6328:	30 e0       	ldi	r19, 0x00	; 0
    632a:	f9 01       	movw	r30, r18
    632c:	20 81       	ld	r18, Z
    632e:	22 60       	ori	r18, 0x02	; 2
    6330:	fc 01       	movw	r30, r24
    6332:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6334:	80 e0       	ldi	r24, 0x00	; 0
    6336:	60 e0       	ldi	r22, 0x00	; 0
    6338:	0e 94 8d 30 	call	0x611a	; 0x611a <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    633c:	80 e5       	ldi	r24, 0x50	; 80
    633e:	90 e0       	ldi	r25, 0x00	; 0
    6340:	fc 01       	movw	r30, r24
    6342:	81 81       	ldd	r24, Z+1	; 0x01
    6344:	88 2f       	mov	r24, r24
    6346:	90 e0       	ldi	r25, 0x00	; 0
    6348:	82 70       	andi	r24, 0x02	; 2
    634a:	90 70       	andi	r25, 0x00	; 0
    634c:	00 97       	sbiw	r24, 0x00	; 0
    634e:	b1 f3       	breq	.-20     	; 0x633c <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6350:	81 e0       	ldi	r24, 0x01	; 1
    6352:	0e 94 a3 30 	call	0x6146	; 0x6146 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6356:	81 e0       	ldi	r24, 0x01	; 1
    6358:	0e 94 6d 30 	call	0x60da	; 0x60da <CLKSYS_Disable>
	
}
    635c:	df 91       	pop	r29
    635e:	cf 91       	pop	r28
    6360:	08 95       	ret

00006362 <portExCS>:


void portExCS(uint8_t write) {
    6362:	0f 93       	push	r16
    6364:	1f 93       	push	r17
    6366:	cf 93       	push	r28
    6368:	df 93       	push	r29
    636a:	cd b7       	in	r28, 0x3d	; 61
    636c:	de b7       	in	r29, 0x3e	; 62
    636e:	69 97       	sbiw	r28, 0x19	; 25
    6370:	cd bf       	out	0x3d, r28	; 61
    6372:	de bf       	out	0x3e, r29	; 62
    6374:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6376:	89 8d       	ldd	r24, Y+25	; 0x19
    6378:	88 23       	and	r24, r24
    637a:	31 f0       	breq	.+12     	; 0x6388 <portExCS+0x26>
    637c:	80 e0       	ldi	r24, 0x00	; 0
    637e:	96 e0       	ldi	r25, 0x06	; 6
    6380:	28 e0       	ldi	r18, 0x08	; 8
    6382:	fc 01       	movw	r30, r24
    6384:	26 83       	std	Z+6, r18	; 0x06
    6386:	05 c0       	rjmp	.+10     	; 0x6392 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    6388:	80 e0       	ldi	r24, 0x00	; 0
    638a:	96 e0       	ldi	r25, 0x06	; 6
    638c:	28 e0       	ldi	r18, 0x08	; 8
    638e:	fc 01       	movw	r30, r24
    6390:	25 83       	std	Z+5, r18	; 0x05
    6392:	80 e0       	ldi	r24, 0x00	; 0
    6394:	90 e0       	ldi	r25, 0x00	; 0
    6396:	a0 e2       	ldi	r26, 0x20	; 32
    6398:	b1 e4       	ldi	r27, 0x41	; 65
    639a:	89 83       	std	Y+1, r24	; 0x01
    639c:	9a 83       	std	Y+2, r25	; 0x02
    639e:	ab 83       	std	Y+3, r26	; 0x03
    63a0:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    63a2:	69 81       	ldd	r22, Y+1	; 0x01
    63a4:	7a 81       	ldd	r23, Y+2	; 0x02
    63a6:	8b 81       	ldd	r24, Y+3	; 0x03
    63a8:	9c 81       	ldd	r25, Y+4	; 0x04
    63aa:	2b ea       	ldi	r18, 0xAB	; 171
    63ac:	3a ea       	ldi	r19, 0xAA	; 170
    63ae:	4a e2       	ldi	r20, 0x2A	; 42
    63b0:	51 e4       	ldi	r21, 0x41	; 65
    63b2:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    63b6:	dc 01       	movw	r26, r24
    63b8:	cb 01       	movw	r24, r22
    63ba:	8d 83       	std	Y+5, r24	; 0x05
    63bc:	9e 83       	std	Y+6, r25	; 0x06
    63be:	af 83       	std	Y+7, r26	; 0x07
    63c0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    63c2:	11 e0       	ldi	r17, 0x01	; 1
    63c4:	6d 81       	ldd	r22, Y+5	; 0x05
    63c6:	7e 81       	ldd	r23, Y+6	; 0x06
    63c8:	8f 81       	ldd	r24, Y+7	; 0x07
    63ca:	98 85       	ldd	r25, Y+8	; 0x08
    63cc:	20 e0       	ldi	r18, 0x00	; 0
    63ce:	30 e0       	ldi	r19, 0x00	; 0
    63d0:	40 e8       	ldi	r20, 0x80	; 128
    63d2:	5f e3       	ldi	r21, 0x3F	; 63
    63d4:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    63d8:	88 23       	and	r24, r24
    63da:	0c f0       	brlt	.+2      	; 0x63de <portExCS+0x7c>
    63dc:	10 e0       	ldi	r17, 0x00	; 0
    63de:	11 23       	and	r17, r17
    63e0:	19 f0       	breq	.+6      	; 0x63e8 <portExCS+0x86>
		__ticks = 1;
    63e2:	81 e0       	ldi	r24, 0x01	; 1
    63e4:	89 87       	std	Y+9, r24	; 0x09
    63e6:	a3 c0       	rjmp	.+326    	; 0x652e <portExCS+0x1cc>
	else if (__tmp > 255)
    63e8:	11 e0       	ldi	r17, 0x01	; 1
    63ea:	6d 81       	ldd	r22, Y+5	; 0x05
    63ec:	7e 81       	ldd	r23, Y+6	; 0x06
    63ee:	8f 81       	ldd	r24, Y+7	; 0x07
    63f0:	98 85       	ldd	r25, Y+8	; 0x08
    63f2:	20 e0       	ldi	r18, 0x00	; 0
    63f4:	30 e0       	ldi	r19, 0x00	; 0
    63f6:	4f e7       	ldi	r20, 0x7F	; 127
    63f8:	53 e4       	ldi	r21, 0x43	; 67
    63fa:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    63fe:	18 16       	cp	r1, r24
    6400:	0c f0       	brlt	.+2      	; 0x6404 <portExCS+0xa2>
    6402:	10 e0       	ldi	r17, 0x00	; 0
    6404:	11 23       	and	r17, r17
    6406:	09 f4       	brne	.+2      	; 0x640a <portExCS+0xa8>
    6408:	89 c0       	rjmp	.+274    	; 0x651c <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    640a:	69 81       	ldd	r22, Y+1	; 0x01
    640c:	7a 81       	ldd	r23, Y+2	; 0x02
    640e:	8b 81       	ldd	r24, Y+3	; 0x03
    6410:	9c 81       	ldd	r25, Y+4	; 0x04
    6412:	20 e0       	ldi	r18, 0x00	; 0
    6414:	30 e0       	ldi	r19, 0x00	; 0
    6416:	4a e7       	ldi	r20, 0x7A	; 122
    6418:	54 e4       	ldi	r21, 0x44	; 68
    641a:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    641e:	dc 01       	movw	r26, r24
    6420:	cb 01       	movw	r24, r22
    6422:	8a 87       	std	Y+10, r24	; 0x0a
    6424:	9b 87       	std	Y+11, r25	; 0x0b
    6426:	ac 87       	std	Y+12, r26	; 0x0c
    6428:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    642a:	6a 85       	ldd	r22, Y+10	; 0x0a
    642c:	7b 85       	ldd	r23, Y+11	; 0x0b
    642e:	8c 85       	ldd	r24, Y+12	; 0x0c
    6430:	9d 85       	ldd	r25, Y+13	; 0x0d
    6432:	20 e0       	ldi	r18, 0x00	; 0
    6434:	30 e0       	ldi	r19, 0x00	; 0
    6436:	4a ef       	ldi	r20, 0xFA	; 250
    6438:	55 e4       	ldi	r21, 0x45	; 69
    643a:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    643e:	dc 01       	movw	r26, r24
    6440:	cb 01       	movw	r24, r22
    6442:	8e 87       	std	Y+14, r24	; 0x0e
    6444:	9f 87       	std	Y+15, r25	; 0x0f
    6446:	a8 8b       	std	Y+16, r26	; 0x10
    6448:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    644a:	11 e0       	ldi	r17, 0x01	; 1
    644c:	6e 85       	ldd	r22, Y+14	; 0x0e
    644e:	7f 85       	ldd	r23, Y+15	; 0x0f
    6450:	88 89       	ldd	r24, Y+16	; 0x10
    6452:	99 89       	ldd	r25, Y+17	; 0x11
    6454:	20 e0       	ldi	r18, 0x00	; 0
    6456:	30 e0       	ldi	r19, 0x00	; 0
    6458:	40 e8       	ldi	r20, 0x80	; 128
    645a:	5f e3       	ldi	r21, 0x3F	; 63
    645c:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    6460:	88 23       	and	r24, r24
    6462:	0c f0       	brlt	.+2      	; 0x6466 <portExCS+0x104>
    6464:	10 e0       	ldi	r17, 0x00	; 0
    6466:	11 23       	and	r17, r17
    6468:	29 f0       	breq	.+10     	; 0x6474 <portExCS+0x112>
		__ticks = 1;
    646a:	81 e0       	ldi	r24, 0x01	; 1
    646c:	90 e0       	ldi	r25, 0x00	; 0
    646e:	8a 8b       	std	Y+18, r24	; 0x12
    6470:	9b 8b       	std	Y+19, r25	; 0x13
    6472:	46 c0       	rjmp	.+140    	; 0x6500 <portExCS+0x19e>
	else if (__tmp > 65535)
    6474:	11 e0       	ldi	r17, 0x01	; 1
    6476:	6e 85       	ldd	r22, Y+14	; 0x0e
    6478:	7f 85       	ldd	r23, Y+15	; 0x0f
    647a:	88 89       	ldd	r24, Y+16	; 0x10
    647c:	99 89       	ldd	r25, Y+17	; 0x11
    647e:	20 e0       	ldi	r18, 0x00	; 0
    6480:	3f ef       	ldi	r19, 0xFF	; 255
    6482:	4f e7       	ldi	r20, 0x7F	; 127
    6484:	57 e4       	ldi	r21, 0x47	; 71
    6486:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    648a:	18 16       	cp	r1, r24
    648c:	0c f0       	brlt	.+2      	; 0x6490 <portExCS+0x12e>
    648e:	10 e0       	ldi	r17, 0x00	; 0
    6490:	11 23       	and	r17, r17
    6492:	61 f1       	breq	.+88     	; 0x64ec <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6494:	6a 85       	ldd	r22, Y+10	; 0x0a
    6496:	7b 85       	ldd	r23, Y+11	; 0x0b
    6498:	8c 85       	ldd	r24, Y+12	; 0x0c
    649a:	9d 85       	ldd	r25, Y+13	; 0x0d
    649c:	20 e0       	ldi	r18, 0x00	; 0
    649e:	30 e0       	ldi	r19, 0x00	; 0
    64a0:	40 e2       	ldi	r20, 0x20	; 32
    64a2:	51 e4       	ldi	r21, 0x41	; 65
    64a4:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    64a8:	dc 01       	movw	r26, r24
    64aa:	cb 01       	movw	r24, r22
    64ac:	bc 01       	movw	r22, r24
    64ae:	cd 01       	movw	r24, r26
    64b0:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    64b4:	dc 01       	movw	r26, r24
    64b6:	cb 01       	movw	r24, r22
    64b8:	8a 8b       	std	Y+18, r24	; 0x12
    64ba:	9b 8b       	std	Y+19, r25	; 0x13
    64bc:	12 c0       	rjmp	.+36     	; 0x64e2 <portExCS+0x180>
    64be:	80 e2       	ldi	r24, 0x20	; 32
    64c0:	93 e0       	ldi	r25, 0x03	; 3
    64c2:	8c 8b       	std	Y+20, r24	; 0x14
    64c4:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    64c6:	8c 89       	ldd	r24, Y+20	; 0x14
    64c8:	9d 89       	ldd	r25, Y+21	; 0x15
    64ca:	8c 01       	movw	r16, r24
    64cc:	c8 01       	movw	r24, r16
    64ce:	01 97       	sbiw	r24, 0x01	; 1
    64d0:	f1 f7       	brne	.-4      	; 0x64ce <portExCS+0x16c>
    64d2:	8c 01       	movw	r16, r24
    64d4:	0c 8b       	std	Y+20, r16	; 0x14
    64d6:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    64d8:	8a 89       	ldd	r24, Y+18	; 0x12
    64da:	9b 89       	ldd	r25, Y+19	; 0x13
    64dc:	01 97       	sbiw	r24, 0x01	; 1
    64de:	8a 8b       	std	Y+18, r24	; 0x12
    64e0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    64e2:	8a 89       	ldd	r24, Y+18	; 0x12
    64e4:	9b 89       	ldd	r25, Y+19	; 0x13
    64e6:	00 97       	sbiw	r24, 0x00	; 0
    64e8:	51 f7       	brne	.-44     	; 0x64be <portExCS+0x15c>
    64ea:	28 c0       	rjmp	.+80     	; 0x653c <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    64ec:	6e 85       	ldd	r22, Y+14	; 0x0e
    64ee:	7f 85       	ldd	r23, Y+15	; 0x0f
    64f0:	88 89       	ldd	r24, Y+16	; 0x10
    64f2:	99 89       	ldd	r25, Y+17	; 0x11
    64f4:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    64f8:	dc 01       	movw	r26, r24
    64fa:	cb 01       	movw	r24, r22
    64fc:	8a 8b       	std	Y+18, r24	; 0x12
    64fe:	9b 8b       	std	Y+19, r25	; 0x13
    6500:	8a 89       	ldd	r24, Y+18	; 0x12
    6502:	9b 89       	ldd	r25, Y+19	; 0x13
    6504:	8e 8b       	std	Y+22, r24	; 0x16
    6506:	9f 8b       	std	Y+23, r25	; 0x17
    6508:	8e 89       	ldd	r24, Y+22	; 0x16
    650a:	9f 89       	ldd	r25, Y+23	; 0x17
    650c:	8c 01       	movw	r16, r24
    650e:	f8 01       	movw	r30, r16
    6510:	31 97       	sbiw	r30, 0x01	; 1
    6512:	f1 f7       	brne	.-4      	; 0x6510 <portExCS+0x1ae>
    6514:	8f 01       	movw	r16, r30
    6516:	0e 8b       	std	Y+22, r16	; 0x16
    6518:	1f 8b       	std	Y+23, r17	; 0x17
    651a:	10 c0       	rjmp	.+32     	; 0x653c <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    651c:	6d 81       	ldd	r22, Y+5	; 0x05
    651e:	7e 81       	ldd	r23, Y+6	; 0x06
    6520:	8f 81       	ldd	r24, Y+7	; 0x07
    6522:	98 85       	ldd	r25, Y+8	; 0x08
    6524:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6528:	dc 01       	movw	r26, r24
    652a:	cb 01       	movw	r24, r22
    652c:	89 87       	std	Y+9, r24	; 0x09
    652e:	89 85       	ldd	r24, Y+9	; 0x09
    6530:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6532:	88 8d       	ldd	r24, Y+24	; 0x18
    6534:	18 2f       	mov	r17, r24
    6536:	1a 95       	dec	r17
    6538:	f1 f7       	brne	.-4      	; 0x6536 <portExCS+0x1d4>
    653a:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    653c:	69 96       	adiw	r28, 0x19	; 25
    653e:	cd bf       	out	0x3d, r28	; 61
    6540:	de bf       	out	0x3e, r29	; 62
    6542:	df 91       	pop	r29
    6544:	cf 91       	pop	r28
    6546:	1f 91       	pop	r17
    6548:	0f 91       	pop	r16
    654a:	08 95       	ret

0000654c <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    654c:	cf 93       	push	r28
    654e:	df 93       	push	r29
    6550:	00 d0       	rcall	.+0      	; 0x6552 <PortEx_DIRSET+0x6>
    6552:	cd b7       	in	r28, 0x3d	; 61
    6554:	de b7       	in	r29, 0x3e	; 62
    6556:	8a 83       	std	Y+2, r24	; 0x02
    6558:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    655a:	80 e0       	ldi	r24, 0x00	; 0
    655c:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    6560:	81 e0       	ldi	r24, 0x01	; 1
    6562:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	portExCS(TRUE);
    6566:	81 e0       	ldi	r24, 0x01	; 1
    6568:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    656c:	8b 81       	ldd	r24, Y+3	; 0x03
    656e:	88 23       	and	r24, r24
    6570:	39 f0       	breq	.+14     	; 0x6580 <PortEx_DIRSET+0x34>
    6572:	90 91 7b 50 	lds	r25, 0x507B
    6576:	8a 81       	ldd	r24, Y+2	; 0x02
    6578:	89 2b       	or	r24, r25
    657a:	80 93 7b 50 	sts	0x507B, r24
    657e:	06 c0       	rjmp	.+12     	; 0x658c <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6580:	90 91 d6 50 	lds	r25, 0x50D6
    6584:	8a 81       	ldd	r24, Y+2	; 0x02
    6586:	89 2b       	or	r24, r25
    6588:	80 93 d6 50 	sts	0x50D6, r24
	
	SPIBuffer[0] = PS_WRITE;
    658c:	80 e4       	ldi	r24, 0x40	; 64
    658e:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6592:	8b 81       	ldd	r24, Y+3	; 0x03
    6594:	88 23       	and	r24, r24
    6596:	41 f0       	breq	.+16     	; 0x65a8 <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    6598:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    659c:	80 91 7b 50 	lds	r24, 0x507B
    65a0:	80 95       	com	r24
    65a2:	80 93 68 50 	sts	0x5068, r24
    65a6:	08 c0       	rjmp	.+16     	; 0x65b8 <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    65a8:	81 e0       	ldi	r24, 0x01	; 1
    65aa:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    65ae:	80 91 d6 50 	lds	r24, 0x50D6
    65b2:	80 95       	com	r24
    65b4:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    65b8:	19 82       	std	Y+1, r1	; 0x01
    65ba:	1b c0       	rjmp	.+54     	; 0x65f2 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    65bc:	80 ec       	ldi	r24, 0xC0	; 192
    65be:	98 e0       	ldi	r25, 0x08	; 8
    65c0:	29 81       	ldd	r18, Y+1	; 0x01
    65c2:	22 2f       	mov	r18, r18
    65c4:	30 e0       	ldi	r19, 0x00	; 0
    65c6:	2a 59       	subi	r18, 0x9A	; 154
    65c8:	3f 4a       	sbci	r19, 0xAF	; 175
    65ca:	f9 01       	movw	r30, r18
    65cc:	20 81       	ld	r18, Z
    65ce:	fc 01       	movw	r30, r24
    65d0:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    65d2:	00 00       	nop
    65d4:	80 ec       	ldi	r24, 0xC0	; 192
    65d6:	98 e0       	ldi	r25, 0x08	; 8
    65d8:	fc 01       	movw	r30, r24
    65da:	82 81       	ldd	r24, Z+2	; 0x02
    65dc:	88 23       	and	r24, r24
    65de:	d4 f7       	brge	.-12     	; 0x65d4 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    65e0:	80 ec       	ldi	r24, 0xC0	; 192
    65e2:	98 e0       	ldi	r25, 0x08	; 8
    65e4:	fc 01       	movw	r30, r24
    65e6:	83 81       	ldd	r24, Z+3	; 0x03
    65e8:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    65ec:	89 81       	ldd	r24, Y+1	; 0x01
    65ee:	8f 5f       	subi	r24, 0xFF	; 255
    65f0:	89 83       	std	Y+1, r24	; 0x01
    65f2:	89 81       	ldd	r24, Y+1	; 0x01
    65f4:	83 30       	cpi	r24, 0x03	; 3
    65f6:	10 f3       	brcs	.-60     	; 0x65bc <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    65f8:	80 e0       	ldi	r24, 0x00	; 0
    65fa:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>
	SPICS(FALSE);
    65fe:	80 e0       	ldi	r24, 0x00	; 0
    6600:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    6604:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>


}
    6608:	23 96       	adiw	r28, 0x03	; 3
    660a:	cd bf       	out	0x3d, r28	; 61
    660c:	de bf       	out	0x3e, r29	; 62
    660e:	df 91       	pop	r29
    6610:	cf 91       	pop	r28
    6612:	08 95       	ret

00006614 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6614:	cf 93       	push	r28
    6616:	df 93       	push	r29
    6618:	00 d0       	rcall	.+0      	; 0x661a <PortEx_DIRCLR+0x6>
    661a:	cd b7       	in	r28, 0x3d	; 61
    661c:	de b7       	in	r29, 0x3e	; 62
    661e:	8a 83       	std	Y+2, r24	; 0x02
    6620:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6622:	80 e0       	ldi	r24, 0x00	; 0
    6624:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    6628:	81 e0       	ldi	r24, 0x01	; 1
    662a:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	portExCS(TRUE);
    662e:	81 e0       	ldi	r24, 0x01	; 1
    6630:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6634:	8b 81       	ldd	r24, Y+3	; 0x03
    6636:	88 23       	and	r24, r24
    6638:	49 f0       	breq	.+18     	; 0x664c <PortEx_DIRCLR+0x38>
    663a:	80 91 7b 50 	lds	r24, 0x507B
    663e:	98 2f       	mov	r25, r24
    6640:	90 95       	com	r25
    6642:	8a 81       	ldd	r24, Y+2	; 0x02
    6644:	89 23       	and	r24, r25
    6646:	80 93 7b 50 	sts	0x507B, r24
    664a:	08 c0       	rjmp	.+16     	; 0x665c <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    664c:	80 91 d6 50 	lds	r24, 0x50D6
    6650:	98 2f       	mov	r25, r24
    6652:	90 95       	com	r25
    6654:	8a 81       	ldd	r24, Y+2	; 0x02
    6656:	89 23       	and	r24, r25
    6658:	80 93 d6 50 	sts	0x50D6, r24
	
	SPIBuffer[0] = PS_WRITE;
    665c:	80 e4       	ldi	r24, 0x40	; 64
    665e:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6662:	8b 81       	ldd	r24, Y+3	; 0x03
    6664:	88 23       	and	r24, r24
    6666:	41 f0       	breq	.+16     	; 0x6678 <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    6668:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    666c:	80 91 7b 50 	lds	r24, 0x507B
    6670:	80 95       	com	r24
    6672:	80 93 68 50 	sts	0x5068, r24
    6676:	08 c0       	rjmp	.+16     	; 0x6688 <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6678:	81 e0       	ldi	r24, 0x01	; 1
    667a:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    667e:	80 91 d6 50 	lds	r24, 0x50D6
    6682:	80 95       	com	r24
    6684:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6688:	19 82       	std	Y+1, r1	; 0x01
    668a:	1b c0       	rjmp	.+54     	; 0x66c2 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    668c:	80 ec       	ldi	r24, 0xC0	; 192
    668e:	98 e0       	ldi	r25, 0x08	; 8
    6690:	29 81       	ldd	r18, Y+1	; 0x01
    6692:	22 2f       	mov	r18, r18
    6694:	30 e0       	ldi	r19, 0x00	; 0
    6696:	2a 59       	subi	r18, 0x9A	; 154
    6698:	3f 4a       	sbci	r19, 0xAF	; 175
    669a:	f9 01       	movw	r30, r18
    669c:	20 81       	ld	r18, Z
    669e:	fc 01       	movw	r30, r24
    66a0:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    66a2:	00 00       	nop
    66a4:	80 ec       	ldi	r24, 0xC0	; 192
    66a6:	98 e0       	ldi	r25, 0x08	; 8
    66a8:	fc 01       	movw	r30, r24
    66aa:	82 81       	ldd	r24, Z+2	; 0x02
    66ac:	88 23       	and	r24, r24
    66ae:	d4 f7       	brge	.-12     	; 0x66a4 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    66b0:	80 ec       	ldi	r24, 0xC0	; 192
    66b2:	98 e0       	ldi	r25, 0x08	; 8
    66b4:	fc 01       	movw	r30, r24
    66b6:	83 81       	ldd	r24, Z+3	; 0x03
    66b8:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    66bc:	89 81       	ldd	r24, Y+1	; 0x01
    66be:	8f 5f       	subi	r24, 0xFF	; 255
    66c0:	89 83       	std	Y+1, r24	; 0x01
    66c2:	89 81       	ldd	r24, Y+1	; 0x01
    66c4:	83 30       	cpi	r24, 0x03	; 3
    66c6:	10 f3       	brcs	.-60     	; 0x668c <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    66c8:	80 e0       	ldi	r24, 0x00	; 0
    66ca:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	portExCS(FALSE);
    66ce:	80 e0       	ldi	r24, 0x00	; 0
    66d0:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>
	SPIDisable();
    66d4:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
}
    66d8:	23 96       	adiw	r28, 0x03	; 3
    66da:	cd bf       	out	0x3d, r28	; 61
    66dc:	de bf       	out	0x3e, r29	; 62
    66de:	df 91       	pop	r29
    66e0:	cf 91       	pop	r28
    66e2:	08 95       	ret

000066e4 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    66e4:	cf 93       	push	r28
    66e6:	df 93       	push	r29
    66e8:	00 d0       	rcall	.+0      	; 0x66ea <PortEx_OUTSET+0x6>
    66ea:	cd b7       	in	r28, 0x3d	; 61
    66ec:	de b7       	in	r29, 0x3e	; 62
    66ee:	8a 83       	std	Y+2, r24	; 0x02
    66f0:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    66f2:	80 e0       	ldi	r24, 0x00	; 0
    66f4:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    66f8:	81 e0       	ldi	r24, 0x01	; 1
    66fa:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	portExCS(TRUE);
    66fe:	81 e0       	ldi	r24, 0x01	; 1
    6700:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6704:	8b 81       	ldd	r24, Y+3	; 0x03
    6706:	88 23       	and	r24, r24
    6708:	39 f0       	breq	.+14     	; 0x6718 <PortEx_OUTSET+0x34>
    670a:	90 91 cf 23 	lds	r25, 0x23CF
    670e:	8a 81       	ldd	r24, Y+2	; 0x02
    6710:	89 2b       	or	r24, r25
    6712:	80 93 cf 23 	sts	0x23CF, r24
    6716:	06 c0       	rjmp	.+12     	; 0x6724 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6718:	90 91 83 50 	lds	r25, 0x5083
    671c:	8a 81       	ldd	r24, Y+2	; 0x02
    671e:	89 2b       	or	r24, r25
    6720:	80 93 83 50 	sts	0x5083, r24
	
	SPIBuffer[0] = PS_WRITE;
    6724:	80 e4       	ldi	r24, 0x40	; 64
    6726:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    672a:	8b 81       	ldd	r24, Y+3	; 0x03
    672c:	88 23       	and	r24, r24
    672e:	41 f0       	breq	.+16     	; 0x6740 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6730:	84 e1       	ldi	r24, 0x14	; 20
    6732:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    6736:	80 91 cf 23 	lds	r24, 0x23CF
    673a:	80 93 68 50 	sts	0x5068, r24
    673e:	07 c0       	rjmp	.+14     	; 0x674e <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6740:	85 e1       	ldi	r24, 0x15	; 21
    6742:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    6746:	80 91 83 50 	lds	r24, 0x5083
    674a:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    674e:	19 82       	std	Y+1, r1	; 0x01
    6750:	1b c0       	rjmp	.+54     	; 0x6788 <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6752:	80 ec       	ldi	r24, 0xC0	; 192
    6754:	98 e0       	ldi	r25, 0x08	; 8
    6756:	29 81       	ldd	r18, Y+1	; 0x01
    6758:	22 2f       	mov	r18, r18
    675a:	30 e0       	ldi	r19, 0x00	; 0
    675c:	2a 59       	subi	r18, 0x9A	; 154
    675e:	3f 4a       	sbci	r19, 0xAF	; 175
    6760:	f9 01       	movw	r30, r18
    6762:	20 81       	ld	r18, Z
    6764:	fc 01       	movw	r30, r24
    6766:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6768:	00 00       	nop
    676a:	80 ec       	ldi	r24, 0xC0	; 192
    676c:	98 e0       	ldi	r25, 0x08	; 8
    676e:	fc 01       	movw	r30, r24
    6770:	82 81       	ldd	r24, Z+2	; 0x02
    6772:	88 23       	and	r24, r24
    6774:	d4 f7       	brge	.-12     	; 0x676a <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6776:	80 ec       	ldi	r24, 0xC0	; 192
    6778:	98 e0       	ldi	r25, 0x08	; 8
    677a:	fc 01       	movw	r30, r24
    677c:	83 81       	ldd	r24, Z+3	; 0x03
    677e:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6782:	89 81       	ldd	r24, Y+1	; 0x01
    6784:	8f 5f       	subi	r24, 0xFF	; 255
    6786:	89 83       	std	Y+1, r24	; 0x01
    6788:	89 81       	ldd	r24, Y+1	; 0x01
    678a:	83 30       	cpi	r24, 0x03	; 3
    678c:	10 f3       	brcs	.-60     	; 0x6752 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    678e:	80 e0       	ldi	r24, 0x00	; 0
    6790:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	portExCS(FALSE);
    6794:	80 e0       	ldi	r24, 0x00	; 0
    6796:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>
	SPIDisable();
    679a:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
}
    679e:	23 96       	adiw	r28, 0x03	; 3
    67a0:	cd bf       	out	0x3d, r28	; 61
    67a2:	de bf       	out	0x3e, r29	; 62
    67a4:	df 91       	pop	r29
    67a6:	cf 91       	pop	r28
    67a8:	08 95       	ret

000067aa <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    67aa:	cf 93       	push	r28
    67ac:	df 93       	push	r29
    67ae:	00 d0       	rcall	.+0      	; 0x67b0 <PortEx_OUTCLR+0x6>
    67b0:	cd b7       	in	r28, 0x3d	; 61
    67b2:	de b7       	in	r29, 0x3e	; 62
    67b4:	8a 83       	std	Y+2, r24	; 0x02
    67b6:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    67b8:	80 e0       	ldi	r24, 0x00	; 0
    67ba:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    67be:	81 e0       	ldi	r24, 0x01	; 1
    67c0:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	portExCS(TRUE);
    67c4:	81 e0       	ldi	r24, 0x01	; 1
    67c6:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    67ca:	8b 81       	ldd	r24, Y+3	; 0x03
    67cc:	88 23       	and	r24, r24
    67ce:	49 f0       	breq	.+18     	; 0x67e2 <PortEx_OUTCLR+0x38>
    67d0:	8a 81       	ldd	r24, Y+2	; 0x02
    67d2:	98 2f       	mov	r25, r24
    67d4:	90 95       	com	r25
    67d6:	80 91 cf 23 	lds	r24, 0x23CF
    67da:	89 23       	and	r24, r25
    67dc:	80 93 cf 23 	sts	0x23CF, r24
    67e0:	08 c0       	rjmp	.+16     	; 0x67f2 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    67e2:	8a 81       	ldd	r24, Y+2	; 0x02
    67e4:	98 2f       	mov	r25, r24
    67e6:	90 95       	com	r25
    67e8:	80 91 83 50 	lds	r24, 0x5083
    67ec:	89 23       	and	r24, r25
    67ee:	80 93 83 50 	sts	0x5083, r24
	
	SPIBuffer[0] = PS_WRITE;
    67f2:	80 e4       	ldi	r24, 0x40	; 64
    67f4:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    67f8:	8b 81       	ldd	r24, Y+3	; 0x03
    67fa:	88 23       	and	r24, r24
    67fc:	41 f0       	breq	.+16     	; 0x680e <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    67fe:	84 e1       	ldi	r24, 0x14	; 20
    6800:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    6804:	80 91 cf 23 	lds	r24, 0x23CF
    6808:	80 93 68 50 	sts	0x5068, r24
    680c:	07 c0       	rjmp	.+14     	; 0x681c <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    680e:	85 e1       	ldi	r24, 0x15	; 21
    6810:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    6814:	80 91 83 50 	lds	r24, 0x5083
    6818:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    681c:	19 82       	std	Y+1, r1	; 0x01
    681e:	1b c0       	rjmp	.+54     	; 0x6856 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6820:	80 ec       	ldi	r24, 0xC0	; 192
    6822:	98 e0       	ldi	r25, 0x08	; 8
    6824:	29 81       	ldd	r18, Y+1	; 0x01
    6826:	22 2f       	mov	r18, r18
    6828:	30 e0       	ldi	r19, 0x00	; 0
    682a:	2a 59       	subi	r18, 0x9A	; 154
    682c:	3f 4a       	sbci	r19, 0xAF	; 175
    682e:	f9 01       	movw	r30, r18
    6830:	20 81       	ld	r18, Z
    6832:	fc 01       	movw	r30, r24
    6834:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6836:	00 00       	nop
    6838:	80 ec       	ldi	r24, 0xC0	; 192
    683a:	98 e0       	ldi	r25, 0x08	; 8
    683c:	fc 01       	movw	r30, r24
    683e:	82 81       	ldd	r24, Z+2	; 0x02
    6840:	88 23       	and	r24, r24
    6842:	d4 f7       	brge	.-12     	; 0x6838 <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6844:	80 ec       	ldi	r24, 0xC0	; 192
    6846:	98 e0       	ldi	r25, 0x08	; 8
    6848:	fc 01       	movw	r30, r24
    684a:	83 81       	ldd	r24, Z+3	; 0x03
    684c:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6850:	89 81       	ldd	r24, Y+1	; 0x01
    6852:	8f 5f       	subi	r24, 0xFF	; 255
    6854:	89 83       	std	Y+1, r24	; 0x01
    6856:	89 81       	ldd	r24, Y+1	; 0x01
    6858:	83 30       	cpi	r24, 0x03	; 3
    685a:	10 f3       	brcs	.-60     	; 0x6820 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    685c:	80 e0       	ldi	r24, 0x00	; 0
    685e:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	portExCS(FALSE);
    6862:	80 e0       	ldi	r24, 0x00	; 0
    6864:	0e 94 b1 31 	call	0x6362	; 0x6362 <portExCS>
	SPIDisable();
    6868:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
}
    686c:	23 96       	adiw	r28, 0x03	; 3
    686e:	cd bf       	out	0x3d, r28	; 61
    6870:	de bf       	out	0x3e, r29	; 62
    6872:	df 91       	pop	r29
    6874:	cf 91       	pop	r28
    6876:	08 95       	ret

00006878 <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6878:	0f 93       	push	r16
    687a:	1f 93       	push	r17
    687c:	cf 93       	push	r28
    687e:	df 93       	push	r29
    6880:	cd b7       	in	r28, 0x3d	; 61
    6882:	de b7       	in	r29, 0x3e	; 62
    6884:	2f 97       	sbiw	r28, 0x0f	; 15
    6886:	cd bf       	out	0x3d, r28	; 61
    6888:	de bf       	out	0x3e, r29	; 62
    688a:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    688c:	8f 85       	ldd	r24, Y+15	; 0x0f
    688e:	88 23       	and	r24, r24
    6890:	09 f4       	brne	.+2      	; 0x6894 <Ext1Power+0x1c>
    6892:	8b c0       	rjmp	.+278    	; 0x69aa <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6894:	80 ea       	ldi	r24, 0xA0	; 160
    6896:	96 e0       	ldi	r25, 0x06	; 6
    6898:	20 e2       	ldi	r18, 0x20	; 32
    689a:	fc 01       	movw	r30, r24
    689c:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    689e:	80 ea       	ldi	r24, 0xA0	; 160
    68a0:	96 e0       	ldi	r25, 0x06	; 6
    68a2:	20 e2       	ldi	r18, 0x20	; 32
    68a4:	fc 01       	movw	r30, r24
    68a6:	25 83       	std	Z+5, r18	; 0x05
    68a8:	80 e0       	ldi	r24, 0x00	; 0
    68aa:	90 e0       	ldi	r25, 0x00	; 0
    68ac:	a8 ec       	ldi	r26, 0xC8	; 200
    68ae:	b2 e4       	ldi	r27, 0x42	; 66
    68b0:	89 83       	std	Y+1, r24	; 0x01
    68b2:	9a 83       	std	Y+2, r25	; 0x02
    68b4:	ab 83       	std	Y+3, r26	; 0x03
    68b6:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    68b8:	69 81       	ldd	r22, Y+1	; 0x01
    68ba:	7a 81       	ldd	r23, Y+2	; 0x02
    68bc:	8b 81       	ldd	r24, Y+3	; 0x03
    68be:	9c 81       	ldd	r25, Y+4	; 0x04
    68c0:	20 e0       	ldi	r18, 0x00	; 0
    68c2:	30 e0       	ldi	r19, 0x00	; 0
    68c4:	4a ef       	ldi	r20, 0xFA	; 250
    68c6:	55 e4       	ldi	r21, 0x45	; 69
    68c8:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    68cc:	dc 01       	movw	r26, r24
    68ce:	cb 01       	movw	r24, r22
    68d0:	8d 83       	std	Y+5, r24	; 0x05
    68d2:	9e 83       	std	Y+6, r25	; 0x06
    68d4:	af 83       	std	Y+7, r26	; 0x07
    68d6:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    68d8:	11 e0       	ldi	r17, 0x01	; 1
    68da:	6d 81       	ldd	r22, Y+5	; 0x05
    68dc:	7e 81       	ldd	r23, Y+6	; 0x06
    68de:	8f 81       	ldd	r24, Y+7	; 0x07
    68e0:	98 85       	ldd	r25, Y+8	; 0x08
    68e2:	20 e0       	ldi	r18, 0x00	; 0
    68e4:	30 e0       	ldi	r19, 0x00	; 0
    68e6:	40 e8       	ldi	r20, 0x80	; 128
    68e8:	5f e3       	ldi	r21, 0x3F	; 63
    68ea:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    68ee:	88 23       	and	r24, r24
    68f0:	0c f0       	brlt	.+2      	; 0x68f4 <Ext1Power+0x7c>
    68f2:	10 e0       	ldi	r17, 0x00	; 0
    68f4:	11 23       	and	r17, r17
    68f6:	29 f0       	breq	.+10     	; 0x6902 <Ext1Power+0x8a>
		__ticks = 1;
    68f8:	81 e0       	ldi	r24, 0x01	; 1
    68fa:	90 e0       	ldi	r25, 0x00	; 0
    68fc:	89 87       	std	Y+9, r24	; 0x09
    68fe:	9a 87       	std	Y+10, r25	; 0x0a
    6900:	46 c0       	rjmp	.+140    	; 0x698e <Ext1Power+0x116>
	else if (__tmp > 65535)
    6902:	11 e0       	ldi	r17, 0x01	; 1
    6904:	6d 81       	ldd	r22, Y+5	; 0x05
    6906:	7e 81       	ldd	r23, Y+6	; 0x06
    6908:	8f 81       	ldd	r24, Y+7	; 0x07
    690a:	98 85       	ldd	r25, Y+8	; 0x08
    690c:	20 e0       	ldi	r18, 0x00	; 0
    690e:	3f ef       	ldi	r19, 0xFF	; 255
    6910:	4f e7       	ldi	r20, 0x7F	; 127
    6912:	57 e4       	ldi	r21, 0x47	; 71
    6914:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    6918:	18 16       	cp	r1, r24
    691a:	0c f0       	brlt	.+2      	; 0x691e <Ext1Power+0xa6>
    691c:	10 e0       	ldi	r17, 0x00	; 0
    691e:	11 23       	and	r17, r17
    6920:	61 f1       	breq	.+88     	; 0x697a <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6922:	69 81       	ldd	r22, Y+1	; 0x01
    6924:	7a 81       	ldd	r23, Y+2	; 0x02
    6926:	8b 81       	ldd	r24, Y+3	; 0x03
    6928:	9c 81       	ldd	r25, Y+4	; 0x04
    692a:	20 e0       	ldi	r18, 0x00	; 0
    692c:	30 e0       	ldi	r19, 0x00	; 0
    692e:	40 e2       	ldi	r20, 0x20	; 32
    6930:	51 e4       	ldi	r21, 0x41	; 65
    6932:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6936:	dc 01       	movw	r26, r24
    6938:	cb 01       	movw	r24, r22
    693a:	bc 01       	movw	r22, r24
    693c:	cd 01       	movw	r24, r26
    693e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6942:	dc 01       	movw	r26, r24
    6944:	cb 01       	movw	r24, r22
    6946:	89 87       	std	Y+9, r24	; 0x09
    6948:	9a 87       	std	Y+10, r25	; 0x0a
    694a:	12 c0       	rjmp	.+36     	; 0x6970 <Ext1Power+0xf8>
    694c:	80 e2       	ldi	r24, 0x20	; 32
    694e:	93 e0       	ldi	r25, 0x03	; 3
    6950:	8b 87       	std	Y+11, r24	; 0x0b
    6952:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6954:	8b 85       	ldd	r24, Y+11	; 0x0b
    6956:	9c 85       	ldd	r25, Y+12	; 0x0c
    6958:	8c 01       	movw	r16, r24
    695a:	c8 01       	movw	r24, r16
    695c:	01 97       	sbiw	r24, 0x01	; 1
    695e:	f1 f7       	brne	.-4      	; 0x695c <Ext1Power+0xe4>
    6960:	8c 01       	movw	r16, r24
    6962:	0b 87       	std	Y+11, r16	; 0x0b
    6964:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6966:	89 85       	ldd	r24, Y+9	; 0x09
    6968:	9a 85       	ldd	r25, Y+10	; 0x0a
    696a:	01 97       	sbiw	r24, 0x01	; 1
    696c:	89 87       	std	Y+9, r24	; 0x09
    696e:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6970:	89 85       	ldd	r24, Y+9	; 0x09
    6972:	9a 85       	ldd	r25, Y+10	; 0x0a
    6974:	00 97       	sbiw	r24, 0x00	; 0
    6976:	51 f7       	brne	.-44     	; 0x694c <Ext1Power+0xd4>
    6978:	22 c0       	rjmp	.+68     	; 0x69be <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    697a:	6d 81       	ldd	r22, Y+5	; 0x05
    697c:	7e 81       	ldd	r23, Y+6	; 0x06
    697e:	8f 81       	ldd	r24, Y+7	; 0x07
    6980:	98 85       	ldd	r25, Y+8	; 0x08
    6982:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6986:	dc 01       	movw	r26, r24
    6988:	cb 01       	movw	r24, r22
    698a:	89 87       	std	Y+9, r24	; 0x09
    698c:	9a 87       	std	Y+10, r25	; 0x0a
    698e:	89 85       	ldd	r24, Y+9	; 0x09
    6990:	9a 85       	ldd	r25, Y+10	; 0x0a
    6992:	8d 87       	std	Y+13, r24	; 0x0d
    6994:	9e 87       	std	Y+14, r25	; 0x0e
    6996:	8d 85       	ldd	r24, Y+13	; 0x0d
    6998:	9e 85       	ldd	r25, Y+14	; 0x0e
    699a:	8c 01       	movw	r16, r24
    699c:	f8 01       	movw	r30, r16
    699e:	31 97       	sbiw	r30, 0x01	; 1
    69a0:	f1 f7       	brne	.-4      	; 0x699e <Ext1Power+0x126>
    69a2:	8f 01       	movw	r16, r30
    69a4:	0d 87       	std	Y+13, r16	; 0x0d
    69a6:	1e 87       	std	Y+14, r17	; 0x0e
    69a8:	0a c0       	rjmp	.+20     	; 0x69be <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    69aa:	80 ea       	ldi	r24, 0xA0	; 160
    69ac:	96 e0       	ldi	r25, 0x06	; 6
    69ae:	20 e2       	ldi	r18, 0x20	; 32
    69b0:	fc 01       	movw	r30, r24
    69b2:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    69b4:	80 ea       	ldi	r24, 0xA0	; 160
    69b6:	96 e0       	ldi	r25, 0x06	; 6
    69b8:	20 e2       	ldi	r18, 0x20	; 32
    69ba:	fc 01       	movw	r30, r24
    69bc:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    69be:	2f 96       	adiw	r28, 0x0f	; 15
    69c0:	cd bf       	out	0x3d, r28	; 61
    69c2:	de bf       	out	0x3e, r29	; 62
    69c4:	df 91       	pop	r29
    69c6:	cf 91       	pop	r28
    69c8:	1f 91       	pop	r17
    69ca:	0f 91       	pop	r16
    69cc:	08 95       	ret

000069ce <Ext2Power>:

void Ext2Power(uint8_t on) {
    69ce:	0f 93       	push	r16
    69d0:	1f 93       	push	r17
    69d2:	cf 93       	push	r28
    69d4:	df 93       	push	r29
    69d6:	cd b7       	in	r28, 0x3d	; 61
    69d8:	de b7       	in	r29, 0x3e	; 62
    69da:	2f 97       	sbiw	r28, 0x0f	; 15
    69dc:	cd bf       	out	0x3d, r28	; 61
    69de:	de bf       	out	0x3e, r29	; 62
    69e0:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    69e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    69e4:	88 23       	and	r24, r24
    69e6:	09 f4       	brne	.+2      	; 0x69ea <Ext2Power+0x1c>
    69e8:	8b c0       	rjmp	.+278    	; 0x6b00 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    69ea:	80 ea       	ldi	r24, 0xA0	; 160
    69ec:	96 e0       	ldi	r25, 0x06	; 6
    69ee:	20 e4       	ldi	r18, 0x40	; 64
    69f0:	fc 01       	movw	r30, r24
    69f2:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    69f4:	80 ea       	ldi	r24, 0xA0	; 160
    69f6:	96 e0       	ldi	r25, 0x06	; 6
    69f8:	20 e4       	ldi	r18, 0x40	; 64
    69fa:	fc 01       	movw	r30, r24
    69fc:	25 83       	std	Z+5, r18	; 0x05
    69fe:	80 e0       	ldi	r24, 0x00	; 0
    6a00:	90 e0       	ldi	r25, 0x00	; 0
    6a02:	a8 ec       	ldi	r26, 0xC8	; 200
    6a04:	b2 e4       	ldi	r27, 0x42	; 66
    6a06:	89 83       	std	Y+1, r24	; 0x01
    6a08:	9a 83       	std	Y+2, r25	; 0x02
    6a0a:	ab 83       	std	Y+3, r26	; 0x03
    6a0c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6a0e:	69 81       	ldd	r22, Y+1	; 0x01
    6a10:	7a 81       	ldd	r23, Y+2	; 0x02
    6a12:	8b 81       	ldd	r24, Y+3	; 0x03
    6a14:	9c 81       	ldd	r25, Y+4	; 0x04
    6a16:	20 e0       	ldi	r18, 0x00	; 0
    6a18:	30 e0       	ldi	r19, 0x00	; 0
    6a1a:	4a ef       	ldi	r20, 0xFA	; 250
    6a1c:	55 e4       	ldi	r21, 0x45	; 69
    6a1e:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6a22:	dc 01       	movw	r26, r24
    6a24:	cb 01       	movw	r24, r22
    6a26:	8d 83       	std	Y+5, r24	; 0x05
    6a28:	9e 83       	std	Y+6, r25	; 0x06
    6a2a:	af 83       	std	Y+7, r26	; 0x07
    6a2c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6a2e:	11 e0       	ldi	r17, 0x01	; 1
    6a30:	6d 81       	ldd	r22, Y+5	; 0x05
    6a32:	7e 81       	ldd	r23, Y+6	; 0x06
    6a34:	8f 81       	ldd	r24, Y+7	; 0x07
    6a36:	98 85       	ldd	r25, Y+8	; 0x08
    6a38:	20 e0       	ldi	r18, 0x00	; 0
    6a3a:	30 e0       	ldi	r19, 0x00	; 0
    6a3c:	40 e8       	ldi	r20, 0x80	; 128
    6a3e:	5f e3       	ldi	r21, 0x3F	; 63
    6a40:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    6a44:	88 23       	and	r24, r24
    6a46:	0c f0       	brlt	.+2      	; 0x6a4a <Ext2Power+0x7c>
    6a48:	10 e0       	ldi	r17, 0x00	; 0
    6a4a:	11 23       	and	r17, r17
    6a4c:	29 f0       	breq	.+10     	; 0x6a58 <Ext2Power+0x8a>
		__ticks = 1;
    6a4e:	81 e0       	ldi	r24, 0x01	; 1
    6a50:	90 e0       	ldi	r25, 0x00	; 0
    6a52:	89 87       	std	Y+9, r24	; 0x09
    6a54:	9a 87       	std	Y+10, r25	; 0x0a
    6a56:	46 c0       	rjmp	.+140    	; 0x6ae4 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6a58:	11 e0       	ldi	r17, 0x01	; 1
    6a5a:	6d 81       	ldd	r22, Y+5	; 0x05
    6a5c:	7e 81       	ldd	r23, Y+6	; 0x06
    6a5e:	8f 81       	ldd	r24, Y+7	; 0x07
    6a60:	98 85       	ldd	r25, Y+8	; 0x08
    6a62:	20 e0       	ldi	r18, 0x00	; 0
    6a64:	3f ef       	ldi	r19, 0xFF	; 255
    6a66:	4f e7       	ldi	r20, 0x7F	; 127
    6a68:	57 e4       	ldi	r21, 0x47	; 71
    6a6a:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    6a6e:	18 16       	cp	r1, r24
    6a70:	0c f0       	brlt	.+2      	; 0x6a74 <Ext2Power+0xa6>
    6a72:	10 e0       	ldi	r17, 0x00	; 0
    6a74:	11 23       	and	r17, r17
    6a76:	61 f1       	breq	.+88     	; 0x6ad0 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6a78:	69 81       	ldd	r22, Y+1	; 0x01
    6a7a:	7a 81       	ldd	r23, Y+2	; 0x02
    6a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    6a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    6a80:	20 e0       	ldi	r18, 0x00	; 0
    6a82:	30 e0       	ldi	r19, 0x00	; 0
    6a84:	40 e2       	ldi	r20, 0x20	; 32
    6a86:	51 e4       	ldi	r21, 0x41	; 65
    6a88:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6a8c:	dc 01       	movw	r26, r24
    6a8e:	cb 01       	movw	r24, r22
    6a90:	bc 01       	movw	r22, r24
    6a92:	cd 01       	movw	r24, r26
    6a94:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6a98:	dc 01       	movw	r26, r24
    6a9a:	cb 01       	movw	r24, r22
    6a9c:	89 87       	std	Y+9, r24	; 0x09
    6a9e:	9a 87       	std	Y+10, r25	; 0x0a
    6aa0:	12 c0       	rjmp	.+36     	; 0x6ac6 <Ext2Power+0xf8>
    6aa2:	80 e2       	ldi	r24, 0x20	; 32
    6aa4:	93 e0       	ldi	r25, 0x03	; 3
    6aa6:	8b 87       	std	Y+11, r24	; 0x0b
    6aa8:	9c 87       	std	Y+12, r25	; 0x0c
    6aaa:	8b 85       	ldd	r24, Y+11	; 0x0b
    6aac:	9c 85       	ldd	r25, Y+12	; 0x0c
    6aae:	8c 01       	movw	r16, r24
    6ab0:	c8 01       	movw	r24, r16
    6ab2:	01 97       	sbiw	r24, 0x01	; 1
    6ab4:	f1 f7       	brne	.-4      	; 0x6ab2 <Ext2Power+0xe4>
    6ab6:	8c 01       	movw	r16, r24
    6ab8:	0b 87       	std	Y+11, r16	; 0x0b
    6aba:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6abc:	89 85       	ldd	r24, Y+9	; 0x09
    6abe:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ac0:	01 97       	sbiw	r24, 0x01	; 1
    6ac2:	89 87       	std	Y+9, r24	; 0x09
    6ac4:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6ac6:	89 85       	ldd	r24, Y+9	; 0x09
    6ac8:	9a 85       	ldd	r25, Y+10	; 0x0a
    6aca:	00 97       	sbiw	r24, 0x00	; 0
    6acc:	51 f7       	brne	.-44     	; 0x6aa2 <Ext2Power+0xd4>
    6ace:	22 c0       	rjmp	.+68     	; 0x6b14 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6ad0:	6d 81       	ldd	r22, Y+5	; 0x05
    6ad2:	7e 81       	ldd	r23, Y+6	; 0x06
    6ad4:	8f 81       	ldd	r24, Y+7	; 0x07
    6ad6:	98 85       	ldd	r25, Y+8	; 0x08
    6ad8:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6adc:	dc 01       	movw	r26, r24
    6ade:	cb 01       	movw	r24, r22
    6ae0:	89 87       	std	Y+9, r24	; 0x09
    6ae2:	9a 87       	std	Y+10, r25	; 0x0a
    6ae4:	89 85       	ldd	r24, Y+9	; 0x09
    6ae6:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ae8:	8d 87       	std	Y+13, r24	; 0x0d
    6aea:	9e 87       	std	Y+14, r25	; 0x0e
    6aec:	8d 85       	ldd	r24, Y+13	; 0x0d
    6aee:	9e 85       	ldd	r25, Y+14	; 0x0e
    6af0:	8c 01       	movw	r16, r24
    6af2:	f8 01       	movw	r30, r16
    6af4:	31 97       	sbiw	r30, 0x01	; 1
    6af6:	f1 f7       	brne	.-4      	; 0x6af4 <Ext2Power+0x126>
    6af8:	8f 01       	movw	r16, r30
    6afa:	0d 87       	std	Y+13, r16	; 0x0d
    6afc:	1e 87       	std	Y+14, r17	; 0x0e
    6afe:	0a c0       	rjmp	.+20     	; 0x6b14 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6b00:	80 ea       	ldi	r24, 0xA0	; 160
    6b02:	96 e0       	ldi	r25, 0x06	; 6
    6b04:	20 e4       	ldi	r18, 0x40	; 64
    6b06:	fc 01       	movw	r30, r24
    6b08:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6b0a:	80 ea       	ldi	r24, 0xA0	; 160
    6b0c:	96 e0       	ldi	r25, 0x06	; 6
    6b0e:	20 e4       	ldi	r18, 0x40	; 64
    6b10:	fc 01       	movw	r30, r24
    6b12:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6b14:	2f 96       	adiw	r28, 0x0f	; 15
    6b16:	cd bf       	out	0x3d, r28	; 61
    6b18:	de bf       	out	0x3e, r29	; 62
    6b1a:	df 91       	pop	r29
    6b1c:	cf 91       	pop	r28
    6b1e:	1f 91       	pop	r17
    6b20:	0f 91       	pop	r16
    6b22:	08 95       	ret

00006b24 <HVPower>:

void HVPower(uint8_t on) {
    6b24:	0f 93       	push	r16
    6b26:	1f 93       	push	r17
    6b28:	cf 93       	push	r28
    6b2a:	df 93       	push	r29
    6b2c:	cd b7       	in	r28, 0x3d	; 61
    6b2e:	de b7       	in	r29, 0x3e	; 62
    6b30:	a7 97       	sbiw	r28, 0x27	; 39
    6b32:	cd bf       	out	0x3d, r28	; 61
    6b34:	de bf       	out	0x3e, r29	; 62
    6b36:	8f a3       	lds	r24, 0x5f
	if (on) {
    6b38:	8f a1       	lds	r24, 0x4f
    6b3a:	88 23       	and	r24, r24
    6b3c:	09 f4       	brne	.+2      	; 0x6b40 <HVPower+0x1c>
    6b3e:	8b c0       	rjmp	.+278    	; 0x6c56 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6b40:	80 ea       	ldi	r24, 0xA0	; 160
    6b42:	96 e0       	ldi	r25, 0x06	; 6
    6b44:	20 e8       	ldi	r18, 0x80	; 128
    6b46:	fc 01       	movw	r30, r24
    6b48:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6b4a:	80 ea       	ldi	r24, 0xA0	; 160
    6b4c:	96 e0       	ldi	r25, 0x06	; 6
    6b4e:	20 e8       	ldi	r18, 0x80	; 128
    6b50:	fc 01       	movw	r30, r24
    6b52:	25 83       	std	Z+5, r18	; 0x05
    6b54:	80 e0       	ldi	r24, 0x00	; 0
    6b56:	90 e0       	ldi	r25, 0x00	; 0
    6b58:	a8 ec       	ldi	r26, 0xC8	; 200
    6b5a:	b2 e4       	ldi	r27, 0x42	; 66
    6b5c:	89 83       	std	Y+1, r24	; 0x01
    6b5e:	9a 83       	std	Y+2, r25	; 0x02
    6b60:	ab 83       	std	Y+3, r26	; 0x03
    6b62:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6b64:	69 81       	ldd	r22, Y+1	; 0x01
    6b66:	7a 81       	ldd	r23, Y+2	; 0x02
    6b68:	8b 81       	ldd	r24, Y+3	; 0x03
    6b6a:	9c 81       	ldd	r25, Y+4	; 0x04
    6b6c:	20 e0       	ldi	r18, 0x00	; 0
    6b6e:	30 e0       	ldi	r19, 0x00	; 0
    6b70:	4a ef       	ldi	r20, 0xFA	; 250
    6b72:	55 e4       	ldi	r21, 0x45	; 69
    6b74:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6b78:	dc 01       	movw	r26, r24
    6b7a:	cb 01       	movw	r24, r22
    6b7c:	8d 83       	std	Y+5, r24	; 0x05
    6b7e:	9e 83       	std	Y+6, r25	; 0x06
    6b80:	af 83       	std	Y+7, r26	; 0x07
    6b82:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6b84:	11 e0       	ldi	r17, 0x01	; 1
    6b86:	6d 81       	ldd	r22, Y+5	; 0x05
    6b88:	7e 81       	ldd	r23, Y+6	; 0x06
    6b8a:	8f 81       	ldd	r24, Y+7	; 0x07
    6b8c:	98 85       	ldd	r25, Y+8	; 0x08
    6b8e:	20 e0       	ldi	r18, 0x00	; 0
    6b90:	30 e0       	ldi	r19, 0x00	; 0
    6b92:	40 e8       	ldi	r20, 0x80	; 128
    6b94:	5f e3       	ldi	r21, 0x3F	; 63
    6b96:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    6b9a:	88 23       	and	r24, r24
    6b9c:	0c f0       	brlt	.+2      	; 0x6ba0 <HVPower+0x7c>
    6b9e:	10 e0       	ldi	r17, 0x00	; 0
    6ba0:	11 23       	and	r17, r17
    6ba2:	29 f0       	breq	.+10     	; 0x6bae <HVPower+0x8a>
		__ticks = 1;
    6ba4:	81 e0       	ldi	r24, 0x01	; 1
    6ba6:	90 e0       	ldi	r25, 0x00	; 0
    6ba8:	89 87       	std	Y+9, r24	; 0x09
    6baa:	9a 87       	std	Y+10, r25	; 0x0a
    6bac:	46 c0       	rjmp	.+140    	; 0x6c3a <HVPower+0x116>
	else if (__tmp > 65535)
    6bae:	11 e0       	ldi	r17, 0x01	; 1
    6bb0:	6d 81       	ldd	r22, Y+5	; 0x05
    6bb2:	7e 81       	ldd	r23, Y+6	; 0x06
    6bb4:	8f 81       	ldd	r24, Y+7	; 0x07
    6bb6:	98 85       	ldd	r25, Y+8	; 0x08
    6bb8:	20 e0       	ldi	r18, 0x00	; 0
    6bba:	3f ef       	ldi	r19, 0xFF	; 255
    6bbc:	4f e7       	ldi	r20, 0x7F	; 127
    6bbe:	57 e4       	ldi	r21, 0x47	; 71
    6bc0:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    6bc4:	18 16       	cp	r1, r24
    6bc6:	0c f0       	brlt	.+2      	; 0x6bca <HVPower+0xa6>
    6bc8:	10 e0       	ldi	r17, 0x00	; 0
    6bca:	11 23       	and	r17, r17
    6bcc:	61 f1       	breq	.+88     	; 0x6c26 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6bce:	69 81       	ldd	r22, Y+1	; 0x01
    6bd0:	7a 81       	ldd	r23, Y+2	; 0x02
    6bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    6bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    6bd6:	20 e0       	ldi	r18, 0x00	; 0
    6bd8:	30 e0       	ldi	r19, 0x00	; 0
    6bda:	40 e2       	ldi	r20, 0x20	; 32
    6bdc:	51 e4       	ldi	r21, 0x41	; 65
    6bde:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6be2:	dc 01       	movw	r26, r24
    6be4:	cb 01       	movw	r24, r22
    6be6:	bc 01       	movw	r22, r24
    6be8:	cd 01       	movw	r24, r26
    6bea:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6bee:	dc 01       	movw	r26, r24
    6bf0:	cb 01       	movw	r24, r22
    6bf2:	89 87       	std	Y+9, r24	; 0x09
    6bf4:	9a 87       	std	Y+10, r25	; 0x0a
    6bf6:	12 c0       	rjmp	.+36     	; 0x6c1c <HVPower+0xf8>
    6bf8:	80 e2       	ldi	r24, 0x20	; 32
    6bfa:	93 e0       	ldi	r25, 0x03	; 3
    6bfc:	8b 87       	std	Y+11, r24	; 0x0b
    6bfe:	9c 87       	std	Y+12, r25	; 0x0c
    6c00:	8b 85       	ldd	r24, Y+11	; 0x0b
    6c02:	9c 85       	ldd	r25, Y+12	; 0x0c
    6c04:	8c 01       	movw	r16, r24
    6c06:	c8 01       	movw	r24, r16
    6c08:	01 97       	sbiw	r24, 0x01	; 1
    6c0a:	f1 f7       	brne	.-4      	; 0x6c08 <HVPower+0xe4>
    6c0c:	8c 01       	movw	r16, r24
    6c0e:	0b 87       	std	Y+11, r16	; 0x0b
    6c10:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6c12:	89 85       	ldd	r24, Y+9	; 0x09
    6c14:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c16:	01 97       	sbiw	r24, 0x01	; 1
    6c18:	89 87       	std	Y+9, r24	; 0x09
    6c1a:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6c1c:	89 85       	ldd	r24, Y+9	; 0x09
    6c1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c20:	00 97       	sbiw	r24, 0x00	; 0
    6c22:	51 f7       	brne	.-44     	; 0x6bf8 <HVPower+0xd4>
    6c24:	22 c0       	rjmp	.+68     	; 0x6c6a <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6c26:	6d 81       	ldd	r22, Y+5	; 0x05
    6c28:	7e 81       	ldd	r23, Y+6	; 0x06
    6c2a:	8f 81       	ldd	r24, Y+7	; 0x07
    6c2c:	98 85       	ldd	r25, Y+8	; 0x08
    6c2e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6c32:	dc 01       	movw	r26, r24
    6c34:	cb 01       	movw	r24, r22
    6c36:	89 87       	std	Y+9, r24	; 0x09
    6c38:	9a 87       	std	Y+10, r25	; 0x0a
    6c3a:	89 85       	ldd	r24, Y+9	; 0x09
    6c3c:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c3e:	8d 87       	std	Y+13, r24	; 0x0d
    6c40:	9e 87       	std	Y+14, r25	; 0x0e
    6c42:	8d 85       	ldd	r24, Y+13	; 0x0d
    6c44:	9e 85       	ldd	r25, Y+14	; 0x0e
    6c46:	8c 01       	movw	r16, r24
    6c48:	f8 01       	movw	r30, r16
    6c4a:	31 97       	sbiw	r30, 0x01	; 1
    6c4c:	f1 f7       	brne	.-4      	; 0x6c4a <HVPower+0x126>
    6c4e:	8f 01       	movw	r16, r30
    6c50:	0d 87       	std	Y+13, r16	; 0x0d
    6c52:	1e 87       	std	Y+14, r17	; 0x0e
    6c54:	0a c0       	rjmp	.+20     	; 0x6c6a <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6c56:	80 ea       	ldi	r24, 0xA0	; 160
    6c58:	96 e0       	ldi	r25, 0x06	; 6
    6c5a:	20 e8       	ldi	r18, 0x80	; 128
    6c5c:	fc 01       	movw	r30, r24
    6c5e:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6c60:	80 ea       	ldi	r24, 0xA0	; 160
    6c62:	96 e0       	ldi	r25, 0x06	; 6
    6c64:	20 e8       	ldi	r18, 0x80	; 128
    6c66:	fc 01       	movw	r30, r24
    6c68:	22 83       	std	Z+2, r18	; 0x02
    6c6a:	80 e0       	ldi	r24, 0x00	; 0
    6c6c:	90 e0       	ldi	r25, 0x00	; 0
    6c6e:	aa e7       	ldi	r26, 0x7A	; 122
    6c70:	b4 e4       	ldi	r27, 0x44	; 68
    6c72:	8f 87       	std	Y+15, r24	; 0x0f
    6c74:	98 8b       	std	Y+16, r25	; 0x10
    6c76:	a9 8b       	std	Y+17, r26	; 0x11
    6c78:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6c7a:	6f 85       	ldd	r22, Y+15	; 0x0f
    6c7c:	78 89       	ldd	r23, Y+16	; 0x10
    6c7e:	89 89       	ldd	r24, Y+17	; 0x11
    6c80:	9a 89       	ldd	r25, Y+18	; 0x12
    6c82:	2b ea       	ldi	r18, 0xAB	; 171
    6c84:	3a ea       	ldi	r19, 0xAA	; 170
    6c86:	4a e2       	ldi	r20, 0x2A	; 42
    6c88:	51 e4       	ldi	r21, 0x41	; 65
    6c8a:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6c8e:	dc 01       	movw	r26, r24
    6c90:	cb 01       	movw	r24, r22
    6c92:	8b 8b       	std	Y+19, r24	; 0x13
    6c94:	9c 8b       	std	Y+20, r25	; 0x14
    6c96:	ad 8b       	std	Y+21, r26	; 0x15
    6c98:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6c9a:	11 e0       	ldi	r17, 0x01	; 1
    6c9c:	6b 89       	ldd	r22, Y+19	; 0x13
    6c9e:	7c 89       	ldd	r23, Y+20	; 0x14
    6ca0:	8d 89       	ldd	r24, Y+21	; 0x15
    6ca2:	9e 89       	ldd	r25, Y+22	; 0x16
    6ca4:	20 e0       	ldi	r18, 0x00	; 0
    6ca6:	30 e0       	ldi	r19, 0x00	; 0
    6ca8:	40 e8       	ldi	r20, 0x80	; 128
    6caa:	5f e3       	ldi	r21, 0x3F	; 63
    6cac:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    6cb0:	88 23       	and	r24, r24
    6cb2:	0c f0       	brlt	.+2      	; 0x6cb6 <HVPower+0x192>
    6cb4:	10 e0       	ldi	r17, 0x00	; 0
    6cb6:	11 23       	and	r17, r17
    6cb8:	19 f0       	breq	.+6      	; 0x6cc0 <HVPower+0x19c>
		__ticks = 1;
    6cba:	81 e0       	ldi	r24, 0x01	; 1
    6cbc:	8f 8b       	std	Y+23, r24	; 0x17
    6cbe:	a3 c0       	rjmp	.+326    	; 0x6e06 <HVPower+0x2e2>
	else if (__tmp > 255)
    6cc0:	11 e0       	ldi	r17, 0x01	; 1
    6cc2:	6b 89       	ldd	r22, Y+19	; 0x13
    6cc4:	7c 89       	ldd	r23, Y+20	; 0x14
    6cc6:	8d 89       	ldd	r24, Y+21	; 0x15
    6cc8:	9e 89       	ldd	r25, Y+22	; 0x16
    6cca:	20 e0       	ldi	r18, 0x00	; 0
    6ccc:	30 e0       	ldi	r19, 0x00	; 0
    6cce:	4f e7       	ldi	r20, 0x7F	; 127
    6cd0:	53 e4       	ldi	r21, 0x43	; 67
    6cd2:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    6cd6:	18 16       	cp	r1, r24
    6cd8:	0c f0       	brlt	.+2      	; 0x6cdc <HVPower+0x1b8>
    6cda:	10 e0       	ldi	r17, 0x00	; 0
    6cdc:	11 23       	and	r17, r17
    6cde:	09 f4       	brne	.+2      	; 0x6ce2 <HVPower+0x1be>
    6ce0:	89 c0       	rjmp	.+274    	; 0x6df4 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6ce2:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ce4:	78 89       	ldd	r23, Y+16	; 0x10
    6ce6:	89 89       	ldd	r24, Y+17	; 0x11
    6ce8:	9a 89       	ldd	r25, Y+18	; 0x12
    6cea:	20 e0       	ldi	r18, 0x00	; 0
    6cec:	30 e0       	ldi	r19, 0x00	; 0
    6cee:	4a e7       	ldi	r20, 0x7A	; 122
    6cf0:	54 e4       	ldi	r21, 0x44	; 68
    6cf2:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    6cf6:	dc 01       	movw	r26, r24
    6cf8:	cb 01       	movw	r24, r22
    6cfa:	88 8f       	std	Y+24, r24	; 0x18
    6cfc:	99 8f       	std	Y+25, r25	; 0x19
    6cfe:	aa 8f       	std	Y+26, r26	; 0x1a
    6d00:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6d02:	68 8d       	ldd	r22, Y+24	; 0x18
    6d04:	79 8d       	ldd	r23, Y+25	; 0x19
    6d06:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d08:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d0a:	20 e0       	ldi	r18, 0x00	; 0
    6d0c:	30 e0       	ldi	r19, 0x00	; 0
    6d0e:	4a ef       	ldi	r20, 0xFA	; 250
    6d10:	55 e4       	ldi	r21, 0x45	; 69
    6d12:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6d16:	dc 01       	movw	r26, r24
    6d18:	cb 01       	movw	r24, r22
    6d1a:	8c 8f       	std	Y+28, r24	; 0x1c
    6d1c:	9d 8f       	std	Y+29, r25	; 0x1d
    6d1e:	ae 8f       	std	Y+30, r26	; 0x1e
    6d20:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6d22:	11 e0       	ldi	r17, 0x01	; 1
    6d24:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6d26:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6d28:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d2a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d2c:	20 e0       	ldi	r18, 0x00	; 0
    6d2e:	30 e0       	ldi	r19, 0x00	; 0
    6d30:	40 e8       	ldi	r20, 0x80	; 128
    6d32:	5f e3       	ldi	r21, 0x3F	; 63
    6d34:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    6d38:	88 23       	and	r24, r24
    6d3a:	0c f0       	brlt	.+2      	; 0x6d3e <HVPower+0x21a>
    6d3c:	10 e0       	ldi	r17, 0x00	; 0
    6d3e:	11 23       	and	r17, r17
    6d40:	29 f0       	breq	.+10     	; 0x6d4c <HVPower+0x228>
		__ticks = 1;
    6d42:	81 e0       	ldi	r24, 0x01	; 1
    6d44:	90 e0       	ldi	r25, 0x00	; 0
    6d46:	88 a3       	lds	r24, 0x58
    6d48:	99 a3       	lds	r25, 0x59
    6d4a:	46 c0       	rjmp	.+140    	; 0x6dd8 <HVPower+0x2b4>
	else if (__tmp > 65535)
    6d4c:	11 e0       	ldi	r17, 0x01	; 1
    6d4e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6d50:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6d52:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d54:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d56:	20 e0       	ldi	r18, 0x00	; 0
    6d58:	3f ef       	ldi	r19, 0xFF	; 255
    6d5a:	4f e7       	ldi	r20, 0x7F	; 127
    6d5c:	57 e4       	ldi	r21, 0x47	; 71
    6d5e:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    6d62:	18 16       	cp	r1, r24
    6d64:	0c f0       	brlt	.+2      	; 0x6d68 <HVPower+0x244>
    6d66:	10 e0       	ldi	r17, 0x00	; 0
    6d68:	11 23       	and	r17, r17
    6d6a:	61 f1       	breq	.+88     	; 0x6dc4 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6d6c:	68 8d       	ldd	r22, Y+24	; 0x18
    6d6e:	79 8d       	ldd	r23, Y+25	; 0x19
    6d70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d72:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d74:	20 e0       	ldi	r18, 0x00	; 0
    6d76:	30 e0       	ldi	r19, 0x00	; 0
    6d78:	40 e2       	ldi	r20, 0x20	; 32
    6d7a:	51 e4       	ldi	r21, 0x41	; 65
    6d7c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    6d80:	dc 01       	movw	r26, r24
    6d82:	cb 01       	movw	r24, r22
    6d84:	bc 01       	movw	r22, r24
    6d86:	cd 01       	movw	r24, r26
    6d88:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6d8c:	dc 01       	movw	r26, r24
    6d8e:	cb 01       	movw	r24, r22
    6d90:	88 a3       	lds	r24, 0x58
    6d92:	99 a3       	lds	r25, 0x59
    6d94:	12 c0       	rjmp	.+36     	; 0x6dba <HVPower+0x296>
    6d96:	80 e2       	ldi	r24, 0x20	; 32
    6d98:	93 e0       	ldi	r25, 0x03	; 3
    6d9a:	8a a3       	lds	r24, 0x5a
    6d9c:	9b a3       	lds	r25, 0x5b
    6d9e:	8a a1       	lds	r24, 0x4a
    6da0:	9b a1       	lds	r25, 0x4b
    6da2:	8c 01       	movw	r16, r24
    6da4:	c8 01       	movw	r24, r16
    6da6:	01 97       	sbiw	r24, 0x01	; 1
    6da8:	f1 f7       	brne	.-4      	; 0x6da6 <HVPower+0x282>
    6daa:	8c 01       	movw	r16, r24
    6dac:	0a a3       	lds	r16, 0x5a
    6dae:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6db0:	88 a1       	lds	r24, 0x48
    6db2:	99 a1       	lds	r25, 0x49
    6db4:	01 97       	sbiw	r24, 0x01	; 1
    6db6:	88 a3       	lds	r24, 0x58
    6db8:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6dba:	88 a1       	lds	r24, 0x48
    6dbc:	99 a1       	lds	r25, 0x49
    6dbe:	00 97       	sbiw	r24, 0x00	; 0
    6dc0:	51 f7       	brne	.-44     	; 0x6d96 <HVPower+0x272>
    6dc2:	28 c0       	rjmp	.+80     	; 0x6e14 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6dc4:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6dc6:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6dc8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6dca:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6dcc:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6dd0:	dc 01       	movw	r26, r24
    6dd2:	cb 01       	movw	r24, r22
    6dd4:	88 a3       	lds	r24, 0x58
    6dd6:	99 a3       	lds	r25, 0x59
    6dd8:	88 a1       	lds	r24, 0x48
    6dda:	99 a1       	lds	r25, 0x49
    6ddc:	8c a3       	lds	r24, 0x5c
    6dde:	9d a3       	lds	r25, 0x5d
    6de0:	8c a1       	lds	r24, 0x4c
    6de2:	9d a1       	lds	r25, 0x4d
    6de4:	8c 01       	movw	r16, r24
    6de6:	f8 01       	movw	r30, r16
    6de8:	31 97       	sbiw	r30, 0x01	; 1
    6dea:	f1 f7       	brne	.-4      	; 0x6de8 <HVPower+0x2c4>
    6dec:	8f 01       	movw	r16, r30
    6dee:	0c a3       	lds	r16, 0x5c
    6df0:	1d a3       	lds	r17, 0x5d
    6df2:	10 c0       	rjmp	.+32     	; 0x6e14 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6df4:	6b 89       	ldd	r22, Y+19	; 0x13
    6df6:	7c 89       	ldd	r23, Y+20	; 0x14
    6df8:	8d 89       	ldd	r24, Y+21	; 0x15
    6dfa:	9e 89       	ldd	r25, Y+22	; 0x16
    6dfc:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    6e00:	dc 01       	movw	r26, r24
    6e02:	cb 01       	movw	r24, r22
    6e04:	8f 8b       	std	Y+23, r24	; 0x17
    6e06:	8f 89       	ldd	r24, Y+23	; 0x17
    6e08:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6e0a:	8e a1       	lds	r24, 0x4e
    6e0c:	18 2f       	mov	r17, r24
    6e0e:	1a 95       	dec	r17
    6e10:	f1 f7       	brne	.-4      	; 0x6e0e <HVPower+0x2ea>
    6e12:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    6e14:	a7 96       	adiw	r28, 0x27	; 39
    6e16:	cd bf       	out	0x3d, r28	; 61
    6e18:	de bf       	out	0x3e, r29	; 62
    6e1a:	df 91       	pop	r29
    6e1c:	cf 91       	pop	r28
    6e1e:	1f 91       	pop	r17
    6e20:	0f 91       	pop	r16
    6e22:	08 95       	ret

00006e24 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    6e24:	cf 93       	push	r28
    6e26:	df 93       	push	r29
    6e28:	0f 92       	push	r0
    6e2a:	cd b7       	in	r28, 0x3d	; 61
    6e2c:	de b7       	in	r29, 0x3e	; 62
    6e2e:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    6e30:	89 81       	ldd	r24, Y+1	; 0x01
    6e32:	88 23       	and	r24, r24
    6e34:	31 f0       	breq	.+12     	; 0x6e42 <lowerMuxCS+0x1e>
    6e36:	80 e8       	ldi	r24, 0x80	; 128
    6e38:	96 e0       	ldi	r25, 0x06	; 6
    6e3a:	20 e1       	ldi	r18, 0x10	; 16
    6e3c:	fc 01       	movw	r30, r24
    6e3e:	26 83       	std	Z+6, r18	; 0x06
    6e40:	05 c0       	rjmp	.+10     	; 0x6e4c <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    6e42:	80 e8       	ldi	r24, 0x80	; 128
    6e44:	96 e0       	ldi	r25, 0x06	; 6
    6e46:	20 e1       	ldi	r18, 0x10	; 16
    6e48:	fc 01       	movw	r30, r24
    6e4a:	25 83       	std	Z+5, r18	; 0x05
}
    6e4c:	0f 90       	pop	r0
    6e4e:	df 91       	pop	r29
    6e50:	cf 91       	pop	r28
    6e52:	08 95       	ret

00006e54 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    6e54:	cf 93       	push	r28
    6e56:	df 93       	push	r29
    6e58:	0f 92       	push	r0
    6e5a:	cd b7       	in	r28, 0x3d	; 61
    6e5c:	de b7       	in	r29, 0x3e	; 62
    6e5e:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    6e60:	89 81       	ldd	r24, Y+1	; 0x01
    6e62:	88 23       	and	r24, r24
    6e64:	31 f0       	breq	.+12     	; 0x6e72 <upperMuxCS+0x1e>
    6e66:	80 e4       	ldi	r24, 0x40	; 64
    6e68:	96 e0       	ldi	r25, 0x06	; 6
    6e6a:	22 e0       	ldi	r18, 0x02	; 2
    6e6c:	fc 01       	movw	r30, r24
    6e6e:	26 83       	std	Z+6, r18	; 0x06
    6e70:	05 c0       	rjmp	.+10     	; 0x6e7c <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    6e72:	80 e4       	ldi	r24, 0x40	; 64
    6e74:	96 e0       	ldi	r25, 0x06	; 6
    6e76:	22 e0       	ldi	r18, 0x02	; 2
    6e78:	fc 01       	movw	r30, r24
    6e7a:	25 83       	std	Z+5, r18	; 0x05
}
    6e7c:	0f 90       	pop	r0
    6e7e:	df 91       	pop	r29
    6e80:	cf 91       	pop	r28
    6e82:	08 95       	ret

00006e84 <SPIInit>:

void SPIInit(uint8_t mode) {
    6e84:	cf 93       	push	r28
    6e86:	df 93       	push	r29
    6e88:	0f 92       	push	r0
    6e8a:	cd b7       	in	r28, 0x3d	; 61
    6e8c:	de b7       	in	r29, 0x3e	; 62
    6e8e:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6e90:	80 e4       	ldi	r24, 0x40	; 64
    6e92:	96 e0       	ldi	r25, 0x06	; 6
    6e94:	20 e1       	ldi	r18, 0x10	; 16
    6e96:	fc 01       	movw	r30, r24
    6e98:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6e9a:	80 e4       	ldi	r24, 0x40	; 64
    6e9c:	96 e0       	ldi	r25, 0x06	; 6
    6e9e:	28 e3       	ldi	r18, 0x38	; 56
    6ea0:	fc 01       	movw	r30, r24
    6ea2:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6ea4:	80 e4       	ldi	r24, 0x40	; 64
    6ea6:	96 e0       	ldi	r25, 0x06	; 6
    6ea8:	20 e1       	ldi	r18, 0x10	; 16
    6eaa:	fc 01       	movw	r30, r24
    6eac:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    6eae:	80 ec       	ldi	r24, 0xC0	; 192
    6eb0:	98 e0       	ldi	r25, 0x08	; 8
    6eb2:	29 81       	ldd	r18, Y+1	; 0x01
    6eb4:	21 65       	ori	r18, 0x51	; 81
    6eb6:	fc 01       	movw	r30, r24
    6eb8:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6eba:	80 ec       	ldi	r24, 0xC0	; 192
    6ebc:	98 e0       	ldi	r25, 0x08	; 8
    6ebe:	fc 01       	movw	r30, r24
    6ec0:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6ec2:	80 e4       	ldi	r24, 0x40	; 64
    6ec4:	96 e0       	ldi	r25, 0x06	; 6
    6ec6:	20 ea       	ldi	r18, 0xA0	; 160
    6ec8:	fc 01       	movw	r30, r24
    6eca:	21 83       	std	Z+1, r18	; 0x01

	
}
    6ecc:	0f 90       	pop	r0
    6ece:	df 91       	pop	r29
    6ed0:	cf 91       	pop	r28
    6ed2:	08 95       	ret

00006ed4 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    6ed4:	cf 93       	push	r28
    6ed6:	df 93       	push	r29
    6ed8:	0f 92       	push	r0
    6eda:	0f 92       	push	r0
    6edc:	cd b7       	in	r28, 0x3d	; 61
    6ede:	de b7       	in	r29, 0x3e	; 62
    6ee0:	89 83       	std	Y+1, r24	; 0x01
    6ee2:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6ee4:	80 e4       	ldi	r24, 0x40	; 64
    6ee6:	96 e0       	ldi	r25, 0x06	; 6
    6ee8:	20 e1       	ldi	r18, 0x10	; 16
    6eea:	fc 01       	movw	r30, r24
    6eec:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6eee:	80 e4       	ldi	r24, 0x40	; 64
    6ef0:	96 e0       	ldi	r25, 0x06	; 6
    6ef2:	28 e3       	ldi	r18, 0x38	; 56
    6ef4:	fc 01       	movw	r30, r24
    6ef6:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6ef8:	80 e4       	ldi	r24, 0x40	; 64
    6efa:	96 e0       	ldi	r25, 0x06	; 6
    6efc:	20 e1       	ldi	r18, 0x10	; 16
    6efe:	fc 01       	movw	r30, r24
    6f00:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    6f02:	80 ec       	ldi	r24, 0xC0	; 192
    6f04:	98 e0       	ldi	r25, 0x08	; 8
    6f06:	3a 81       	ldd	r19, Y+2	; 0x02
    6f08:	29 81       	ldd	r18, Y+1	; 0x01
    6f0a:	23 2b       	or	r18, r19
    6f0c:	20 65       	ori	r18, 0x50	; 80
    6f0e:	fc 01       	movw	r30, r24
    6f10:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6f12:	80 ec       	ldi	r24, 0xC0	; 192
    6f14:	98 e0       	ldi	r25, 0x08	; 8
    6f16:	fc 01       	movw	r30, r24
    6f18:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6f1a:	80 e4       	ldi	r24, 0x40	; 64
    6f1c:	96 e0       	ldi	r25, 0x06	; 6
    6f1e:	20 ea       	ldi	r18, 0xA0	; 160
    6f20:	fc 01       	movw	r30, r24
    6f22:	21 83       	std	Z+1, r18	; 0x01
}
    6f24:	0f 90       	pop	r0
    6f26:	0f 90       	pop	r0
    6f28:	df 91       	pop	r29
    6f2a:	cf 91       	pop	r28
    6f2c:	08 95       	ret

00006f2e <SPICS>:

void SPICS(uint8_t enable) {
    6f2e:	cf 93       	push	r28
    6f30:	df 93       	push	r29
    6f32:	0f 92       	push	r0
    6f34:	cd b7       	in	r28, 0x3d	; 61
    6f36:	de b7       	in	r29, 0x3e	; 62
    6f38:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    6f3a:	89 81       	ldd	r24, Y+1	; 0x01
    6f3c:	88 23       	and	r24, r24
    6f3e:	31 f0       	breq	.+12     	; 0x6f4c <SPICS+0x1e>
    6f40:	80 e4       	ldi	r24, 0x40	; 64
    6f42:	96 e0       	ldi	r25, 0x06	; 6
    6f44:	20 e1       	ldi	r18, 0x10	; 16
    6f46:	fc 01       	movw	r30, r24
    6f48:	26 83       	std	Z+6, r18	; 0x06
    6f4a:	05 c0       	rjmp	.+10     	; 0x6f56 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    6f4c:	80 e4       	ldi	r24, 0x40	; 64
    6f4e:	96 e0       	ldi	r25, 0x06	; 6
    6f50:	20 e1       	ldi	r18, 0x10	; 16
    6f52:	fc 01       	movw	r30, r24
    6f54:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    6f56:	0f 90       	pop	r0
    6f58:	df 91       	pop	r29
    6f5a:	cf 91       	pop	r28
    6f5c:	08 95       	ret

00006f5e <SPIDisable>:

void SPIDisable() {
    6f5e:	cf 93       	push	r28
    6f60:	df 93       	push	r29
    6f62:	cd b7       	in	r28, 0x3d	; 61
    6f64:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    6f66:	80 e4       	ldi	r24, 0x40	; 64
    6f68:	96 e0       	ldi	r25, 0x06	; 6
    6f6a:	20 e1       	ldi	r18, 0x10	; 16
    6f6c:	fc 01       	movw	r30, r24
    6f6e:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    6f70:	80 ec       	ldi	r24, 0xC0	; 192
    6f72:	98 e0       	ldi	r25, 0x08	; 8
    6f74:	fc 01       	movw	r30, r24
    6f76:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    6f78:	80 e4       	ldi	r24, 0x40	; 64
    6f7a:	96 e0       	ldi	r25, 0x06	; 6
    6f7c:	20 e1       	ldi	r18, 0x10	; 16
    6f7e:	fc 01       	movw	r30, r24
    6f80:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    6f82:	80 e4       	ldi	r24, 0x40	; 64
    6f84:	96 e0       	ldi	r25, 0x06	; 6
    6f86:	20 eb       	ldi	r18, 0xB0	; 176
    6f88:	fc 01       	movw	r30, r24
    6f8a:	22 83       	std	Z+2, r18	; 0x02

}
    6f8c:	df 91       	pop	r29
    6f8e:	cf 91       	pop	r28
    6f90:	08 95       	ret

00006f92 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    6f92:	cf 93       	push	r28
    6f94:	df 93       	push	r29
    6f96:	00 d0       	rcall	.+0      	; 0x6f98 <readFRAM+0x6>
    6f98:	0f 92       	push	r0
    6f9a:	cd b7       	in	r28, 0x3d	; 61
    6f9c:	de b7       	in	r29, 0x3e	; 62
    6f9e:	8b 83       	std	Y+3, r24	; 0x03
    6fa0:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    6fa2:	80 e0       	ldi	r24, 0x00	; 0
    6fa4:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    6fa8:	80 ec       	ldi	r24, 0xC0	; 192
    6faa:	98 e0       	ldi	r25, 0x08	; 8
    6fac:	20 ed       	ldi	r18, 0xD0	; 208
    6fae:	fc 01       	movw	r30, r24
    6fb0:	20 83       	st	Z, r18
	SPICS(TRUE);
    6fb2:	81 e0       	ldi	r24, 0x01	; 1
    6fb4:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    6fb8:	80 e2       	ldi	r24, 0x20	; 32
    6fba:	96 e0       	ldi	r25, 0x06	; 6
    6fbc:	28 e0       	ldi	r18, 0x08	; 8
    6fbe:	fc 01       	movw	r30, r24
    6fc0:	26 83       	std	Z+6, r18	; 0x06
	nop();
    6fc2:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    6fc4:	80 ec       	ldi	r24, 0xC0	; 192
    6fc6:	98 e0       	ldi	r25, 0x08	; 8
    6fc8:	23 e0       	ldi	r18, 0x03	; 3
    6fca:	fc 01       	movw	r30, r24
    6fcc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6fce:	00 00       	nop
    6fd0:	80 ec       	ldi	r24, 0xC0	; 192
    6fd2:	98 e0       	ldi	r25, 0x08	; 8
    6fd4:	fc 01       	movw	r30, r24
    6fd6:	82 81       	ldd	r24, Z+2	; 0x02
    6fd8:	88 23       	and	r24, r24
    6fda:	d4 f7       	brge	.-12     	; 0x6fd0 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    6fdc:	80 ec       	ldi	r24, 0xC0	; 192
    6fde:	98 e0       	ldi	r25, 0x08	; 8
    6fe0:	fc 01       	movw	r30, r24
    6fe2:	83 81       	ldd	r24, Z+3	; 0x03
    6fe4:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    6fe8:	80 ec       	ldi	r24, 0xC0	; 192
    6fea:	98 e0       	ldi	r25, 0x08	; 8
    6fec:	20 91 51 40 	lds	r18, 0x4051
    6ff0:	fc 01       	movw	r30, r24
    6ff2:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6ff4:	00 00       	nop
    6ff6:	80 ec       	ldi	r24, 0xC0	; 192
    6ff8:	98 e0       	ldi	r25, 0x08	; 8
    6ffa:	fc 01       	movw	r30, r24
    6ffc:	82 81       	ldd	r24, Z+2	; 0x02
    6ffe:	88 23       	and	r24, r24
    7000:	d4 f7       	brge	.-12     	; 0x6ff6 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    7002:	80 ec       	ldi	r24, 0xC0	; 192
    7004:	98 e0       	ldi	r25, 0x08	; 8
    7006:	fc 01       	movw	r30, r24
    7008:	83 81       	ldd	r24, Z+3	; 0x03
    700a:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    700e:	80 ec       	ldi	r24, 0xC0	; 192
    7010:	98 e0       	ldi	r25, 0x08	; 8
    7012:	20 e5       	ldi	r18, 0x50	; 80
    7014:	30 e4       	ldi	r19, 0x40	; 64
    7016:	f9 01       	movw	r30, r18
    7018:	20 81       	ld	r18, Z
    701a:	fc 01       	movw	r30, r24
    701c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    701e:	00 00       	nop
    7020:	80 ec       	ldi	r24, 0xC0	; 192
    7022:	98 e0       	ldi	r25, 0x08	; 8
    7024:	fc 01       	movw	r30, r24
    7026:	82 81       	ldd	r24, Z+2	; 0x02
    7028:	88 23       	and	r24, r24
    702a:	d4 f7       	brge	.-12     	; 0x7020 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    702c:	80 ec       	ldi	r24, 0xC0	; 192
    702e:	98 e0       	ldi	r25, 0x08	; 8
    7030:	fc 01       	movw	r30, r24
    7032:	83 81       	ldd	r24, Z+3	; 0x03
    7034:	80 93 72 50 	sts	0x5072, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7038:	19 82       	std	Y+1, r1	; 0x01
    703a:	1a 82       	std	Y+2, r1	; 0x02
    703c:	1b c0       	rjmp	.+54     	; 0x7074 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    703e:	80 ec       	ldi	r24, 0xC0	; 192
    7040:	98 e0       	ldi	r25, 0x08	; 8
    7042:	2a ea       	ldi	r18, 0xAA	; 170
    7044:	fc 01       	movw	r30, r24
    7046:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    7048:	00 00       	nop
    704a:	80 ec       	ldi	r24, 0xC0	; 192
    704c:	98 e0       	ldi	r25, 0x08	; 8
    704e:	fc 01       	movw	r30, r24
    7050:	82 81       	ldd	r24, Z+2	; 0x02
    7052:	88 23       	and	r24, r24
    7054:	d4 f7       	brge	.-12     	; 0x704a <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    7056:	80 ec       	ldi	r24, 0xC0	; 192
    7058:	98 e0       	ldi	r25, 0x08	; 8
    705a:	fc 01       	movw	r30, r24
    705c:	23 81       	ldd	r18, Z+3	; 0x03
    705e:	89 81       	ldd	r24, Y+1	; 0x01
    7060:	9a 81       	ldd	r25, Y+2	; 0x02
    7062:	88 52       	subi	r24, 0x28	; 40
    7064:	9c 4d       	sbci	r25, 0xDC	; 220
    7066:	fc 01       	movw	r30, r24
    7068:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    706a:	89 81       	ldd	r24, Y+1	; 0x01
    706c:	9a 81       	ldd	r25, Y+2	; 0x02
    706e:	01 96       	adiw	r24, 0x01	; 1
    7070:	89 83       	std	Y+1, r24	; 0x01
    7072:	9a 83       	std	Y+2, r25	; 0x02
    7074:	29 81       	ldd	r18, Y+1	; 0x01
    7076:	3a 81       	ldd	r19, Y+2	; 0x02
    7078:	8b 81       	ldd	r24, Y+3	; 0x03
    707a:	9c 81       	ldd	r25, Y+4	; 0x04
    707c:	28 17       	cp	r18, r24
    707e:	39 07       	cpc	r19, r25
    7080:	f0 f2       	brcs	.-68     	; 0x703e <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7082:	80 e2       	ldi	r24, 0x20	; 32
    7084:	96 e0       	ldi	r25, 0x06	; 6
    7086:	28 e0       	ldi	r18, 0x08	; 8
    7088:	fc 01       	movw	r30, r24
    708a:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    708c:	80 e0       	ldi	r24, 0x00	; 0
    708e:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    7092:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>

}
    7096:	24 96       	adiw	r28, 0x04	; 4
    7098:	cd bf       	out	0x3d, r28	; 61
    709a:	de bf       	out	0x3e, r29	; 62
    709c:	df 91       	pop	r29
    709e:	cf 91       	pop	r28
    70a0:	08 95       	ret

000070a2 <FRAMTest3Channel>:

//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
    70a2:	0f 93       	push	r16
    70a4:	1f 93       	push	r17
    70a6:	cf 93       	push	r28
    70a8:	df 93       	push	r29
    70aa:	cd b7       	in	r28, 0x3d	; 61
    70ac:	de b7       	in	r29, 0x3e	; 62
    70ae:	6b 97       	sbiw	r28, 0x1b	; 27
    70b0:	cd bf       	out	0x3d, r28	; 61
    70b2:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    70b4:	19 8e       	std	Y+25, r1	; 0x19
    70b6:	1a 8e       	std	Y+26, r1	; 0x1a
    70b8:	1b 8e       	std	Y+27, r1	; 0x1b
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
    70c0:	80 e0       	ldi	r24, 0x00	; 0
    70c2:	90 e0       	ldi	r25, 0x00	; 0
    70c4:	aa e7       	ldi	r26, 0x7A	; 122
    70c6:	b3 e4       	ldi	r27, 0x43	; 67
    70c8:	89 83       	std	Y+1, r24	; 0x01
    70ca:	9a 83       	std	Y+2, r25	; 0x02
    70cc:	ab 83       	std	Y+3, r26	; 0x03
    70ce:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    70d0:	69 81       	ldd	r22, Y+1	; 0x01
    70d2:	7a 81       	ldd	r23, Y+2	; 0x02
    70d4:	8b 81       	ldd	r24, Y+3	; 0x03
    70d6:	9c 81       	ldd	r25, Y+4	; 0x04
    70d8:	2b ea       	ldi	r18, 0xAB	; 171
    70da:	3a ea       	ldi	r19, 0xAA	; 170
    70dc:	4a e2       	ldi	r20, 0x2A	; 42
    70de:	51 e4       	ldi	r21, 0x41	; 65
    70e0:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    70e4:	dc 01       	movw	r26, r24
    70e6:	cb 01       	movw	r24, r22
    70e8:	8d 83       	std	Y+5, r24	; 0x05
    70ea:	9e 83       	std	Y+6, r25	; 0x06
    70ec:	af 83       	std	Y+7, r26	; 0x07
    70ee:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    70f0:	11 e0       	ldi	r17, 0x01	; 1
    70f2:	6d 81       	ldd	r22, Y+5	; 0x05
    70f4:	7e 81       	ldd	r23, Y+6	; 0x06
    70f6:	8f 81       	ldd	r24, Y+7	; 0x07
    70f8:	98 85       	ldd	r25, Y+8	; 0x08
    70fa:	20 e0       	ldi	r18, 0x00	; 0
    70fc:	30 e0       	ldi	r19, 0x00	; 0
    70fe:	40 e8       	ldi	r20, 0x80	; 128
    7100:	5f e3       	ldi	r21, 0x3F	; 63
    7102:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    7106:	88 23       	and	r24, r24
    7108:	0c f0       	brlt	.+2      	; 0x710c <FRAMTest3Channel+0x6a>
    710a:	10 e0       	ldi	r17, 0x00	; 0
    710c:	11 23       	and	r17, r17
    710e:	19 f0       	breq	.+6      	; 0x7116 <FRAMTest3Channel+0x74>
		__ticks = 1;
    7110:	81 e0       	ldi	r24, 0x01	; 1
    7112:	89 87       	std	Y+9, r24	; 0x09
    7114:	a3 c0       	rjmp	.+326    	; 0x725c <FRAMTest3Channel+0x1ba>
	else if (__tmp > 255)
    7116:	11 e0       	ldi	r17, 0x01	; 1
    7118:	6d 81       	ldd	r22, Y+5	; 0x05
    711a:	7e 81       	ldd	r23, Y+6	; 0x06
    711c:	8f 81       	ldd	r24, Y+7	; 0x07
    711e:	98 85       	ldd	r25, Y+8	; 0x08
    7120:	20 e0       	ldi	r18, 0x00	; 0
    7122:	30 e0       	ldi	r19, 0x00	; 0
    7124:	4f e7       	ldi	r20, 0x7F	; 127
    7126:	53 e4       	ldi	r21, 0x43	; 67
    7128:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    712c:	18 16       	cp	r1, r24
    712e:	0c f0       	brlt	.+2      	; 0x7132 <FRAMTest3Channel+0x90>
    7130:	10 e0       	ldi	r17, 0x00	; 0
    7132:	11 23       	and	r17, r17
    7134:	09 f4       	brne	.+2      	; 0x7138 <FRAMTest3Channel+0x96>
    7136:	89 c0       	rjmp	.+274    	; 0x724a <FRAMTest3Channel+0x1a8>
	{
		_delay_ms(__us / 1000.0);
    7138:	69 81       	ldd	r22, Y+1	; 0x01
    713a:	7a 81       	ldd	r23, Y+2	; 0x02
    713c:	8b 81       	ldd	r24, Y+3	; 0x03
    713e:	9c 81       	ldd	r25, Y+4	; 0x04
    7140:	20 e0       	ldi	r18, 0x00	; 0
    7142:	30 e0       	ldi	r19, 0x00	; 0
    7144:	4a e7       	ldi	r20, 0x7A	; 122
    7146:	54 e4       	ldi	r21, 0x44	; 68
    7148:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    714c:	dc 01       	movw	r26, r24
    714e:	cb 01       	movw	r24, r22
    7150:	8a 87       	std	Y+10, r24	; 0x0a
    7152:	9b 87       	std	Y+11, r25	; 0x0b
    7154:	ac 87       	std	Y+12, r26	; 0x0c
    7156:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7158:	6a 85       	ldd	r22, Y+10	; 0x0a
    715a:	7b 85       	ldd	r23, Y+11	; 0x0b
    715c:	8c 85       	ldd	r24, Y+12	; 0x0c
    715e:	9d 85       	ldd	r25, Y+13	; 0x0d
    7160:	20 e0       	ldi	r18, 0x00	; 0
    7162:	30 e0       	ldi	r19, 0x00	; 0
    7164:	4a ef       	ldi	r20, 0xFA	; 250
    7166:	55 e4       	ldi	r21, 0x45	; 69
    7168:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    716c:	dc 01       	movw	r26, r24
    716e:	cb 01       	movw	r24, r22
    7170:	8e 87       	std	Y+14, r24	; 0x0e
    7172:	9f 87       	std	Y+15, r25	; 0x0f
    7174:	a8 8b       	std	Y+16, r26	; 0x10
    7176:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7178:	11 e0       	ldi	r17, 0x01	; 1
    717a:	6e 85       	ldd	r22, Y+14	; 0x0e
    717c:	7f 85       	ldd	r23, Y+15	; 0x0f
    717e:	88 89       	ldd	r24, Y+16	; 0x10
    7180:	99 89       	ldd	r25, Y+17	; 0x11
    7182:	20 e0       	ldi	r18, 0x00	; 0
    7184:	30 e0       	ldi	r19, 0x00	; 0
    7186:	40 e8       	ldi	r20, 0x80	; 128
    7188:	5f e3       	ldi	r21, 0x3F	; 63
    718a:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    718e:	88 23       	and	r24, r24
    7190:	0c f0       	brlt	.+2      	; 0x7194 <FRAMTest3Channel+0xf2>
    7192:	10 e0       	ldi	r17, 0x00	; 0
    7194:	11 23       	and	r17, r17
    7196:	29 f0       	breq	.+10     	; 0x71a2 <FRAMTest3Channel+0x100>
		__ticks = 1;
    7198:	81 e0       	ldi	r24, 0x01	; 1
    719a:	90 e0       	ldi	r25, 0x00	; 0
    719c:	8a 8b       	std	Y+18, r24	; 0x12
    719e:	9b 8b       	std	Y+19, r25	; 0x13
    71a0:	46 c0       	rjmp	.+140    	; 0x722e <FRAMTest3Channel+0x18c>
	else if (__tmp > 65535)
    71a2:	11 e0       	ldi	r17, 0x01	; 1
    71a4:	6e 85       	ldd	r22, Y+14	; 0x0e
    71a6:	7f 85       	ldd	r23, Y+15	; 0x0f
    71a8:	88 89       	ldd	r24, Y+16	; 0x10
    71aa:	99 89       	ldd	r25, Y+17	; 0x11
    71ac:	20 e0       	ldi	r18, 0x00	; 0
    71ae:	3f ef       	ldi	r19, 0xFF	; 255
    71b0:	4f e7       	ldi	r20, 0x7F	; 127
    71b2:	57 e4       	ldi	r21, 0x47	; 71
    71b4:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    71b8:	18 16       	cp	r1, r24
    71ba:	0c f0       	brlt	.+2      	; 0x71be <FRAMTest3Channel+0x11c>
    71bc:	10 e0       	ldi	r17, 0x00	; 0
    71be:	11 23       	and	r17, r17
    71c0:	61 f1       	breq	.+88     	; 0x721a <FRAMTest3Channel+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    71c2:	6a 85       	ldd	r22, Y+10	; 0x0a
    71c4:	7b 85       	ldd	r23, Y+11	; 0x0b
    71c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    71c8:	9d 85       	ldd	r25, Y+13	; 0x0d
    71ca:	20 e0       	ldi	r18, 0x00	; 0
    71cc:	30 e0       	ldi	r19, 0x00	; 0
    71ce:	40 e2       	ldi	r20, 0x20	; 32
    71d0:	51 e4       	ldi	r21, 0x41	; 65
    71d2:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    71d6:	dc 01       	movw	r26, r24
    71d8:	cb 01       	movw	r24, r22
    71da:	bc 01       	movw	r22, r24
    71dc:	cd 01       	movw	r24, r26
    71de:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    71e2:	dc 01       	movw	r26, r24
    71e4:	cb 01       	movw	r24, r22
    71e6:	8a 8b       	std	Y+18, r24	; 0x12
    71e8:	9b 8b       	std	Y+19, r25	; 0x13
    71ea:	12 c0       	rjmp	.+36     	; 0x7210 <FRAMTest3Channel+0x16e>
    71ec:	80 e2       	ldi	r24, 0x20	; 32
    71ee:	93 e0       	ldi	r25, 0x03	; 3
    71f0:	8c 8b       	std	Y+20, r24	; 0x14
    71f2:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    71f4:	8c 89       	ldd	r24, Y+20	; 0x14
    71f6:	9d 89       	ldd	r25, Y+21	; 0x15
    71f8:	8c 01       	movw	r16, r24
    71fa:	c8 01       	movw	r24, r16
    71fc:	01 97       	sbiw	r24, 0x01	; 1
    71fe:	f1 f7       	brne	.-4      	; 0x71fc <FRAMTest3Channel+0x15a>
    7200:	8c 01       	movw	r16, r24
    7202:	0c 8b       	std	Y+20, r16	; 0x14
    7204:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7206:	8a 89       	ldd	r24, Y+18	; 0x12
    7208:	9b 89       	ldd	r25, Y+19	; 0x13
    720a:	01 97       	sbiw	r24, 0x01	; 1
    720c:	8a 8b       	std	Y+18, r24	; 0x12
    720e:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7210:	8a 89       	ldd	r24, Y+18	; 0x12
    7212:	9b 89       	ldd	r25, Y+19	; 0x13
    7214:	00 97       	sbiw	r24, 0x00	; 0
    7216:	51 f7       	brne	.-44     	; 0x71ec <FRAMTest3Channel+0x14a>
    7218:	28 c0       	rjmp	.+80     	; 0x726a <FRAMTest3Channel+0x1c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    721a:	6e 85       	ldd	r22, Y+14	; 0x0e
    721c:	7f 85       	ldd	r23, Y+15	; 0x0f
    721e:	88 89       	ldd	r24, Y+16	; 0x10
    7220:	99 89       	ldd	r25, Y+17	; 0x11
    7222:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7226:	dc 01       	movw	r26, r24
    7228:	cb 01       	movw	r24, r22
    722a:	8a 8b       	std	Y+18, r24	; 0x12
    722c:	9b 8b       	std	Y+19, r25	; 0x13
    722e:	8a 89       	ldd	r24, Y+18	; 0x12
    7230:	9b 89       	ldd	r25, Y+19	; 0x13
    7232:	8e 8b       	std	Y+22, r24	; 0x16
    7234:	9f 8b       	std	Y+23, r25	; 0x17
    7236:	8e 89       	ldd	r24, Y+22	; 0x16
    7238:	9f 89       	ldd	r25, Y+23	; 0x17
    723a:	8c 01       	movw	r16, r24
    723c:	c8 01       	movw	r24, r16
    723e:	01 97       	sbiw	r24, 0x01	; 1
    7240:	f1 f7       	brne	.-4      	; 0x723e <FRAMTest3Channel+0x19c>
    7242:	8c 01       	movw	r16, r24
    7244:	0e 8b       	std	Y+22, r16	; 0x16
    7246:	1f 8b       	std	Y+23, r17	; 0x17
    7248:	10 c0       	rjmp	.+32     	; 0x726a <FRAMTest3Channel+0x1c8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    724a:	6d 81       	ldd	r22, Y+5	; 0x05
    724c:	7e 81       	ldd	r23, Y+6	; 0x06
    724e:	8f 81       	ldd	r24, Y+7	; 0x07
    7250:	98 85       	ldd	r25, Y+8	; 0x08
    7252:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7256:	dc 01       	movw	r26, r24
    7258:	cb 01       	movw	r24, r22
    725a:	89 87       	std	Y+9, r24	; 0x09
    725c:	89 85       	ldd	r24, Y+9	; 0x09
    725e:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7260:	88 8d       	ldd	r24, Y+24	; 0x18
    7262:	18 2f       	mov	r17, r24
    7264:	1a 95       	dec	r17
    7266:	f1 f7       	brne	.-4      	; 0x7264 <FRAMTest3Channel+0x1c2>
    7268:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    726a:	0e 94 b8 15 	call	0x2b70	; 0x2b70 <calcChecksumFRAM>

	ADCPower(FALSE);
    726e:	80 e0       	ldi	r24, 0x00	; 0
    7270:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
}
    7274:	6b 96       	adiw	r28, 0x1b	; 27
    7276:	cd bf       	out	0x3d, r28	; 61
    7278:	de bf       	out	0x3e, r29	; 62
    727a:	df 91       	pop	r29
    727c:	cf 91       	pop	r28
    727e:	1f 91       	pop	r17
    7280:	0f 91       	pop	r16
    7282:	08 95       	ret

00007284 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {
    7284:	0f 93       	push	r16
    7286:	1f 93       	push	r17
    7288:	cf 93       	push	r28
    728a:	df 93       	push	r29
    728c:	cd b7       	in	r28, 0x3d	; 61
    728e:	de b7       	in	r29, 0x3e	; 62
    7290:	68 97       	sbiw	r28, 0x18	; 24
    7292:	cd bf       	out	0x3d, r28	; 61
    7294:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7296:	81 e0       	ldi	r24, 0x01	; 1
    7298:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
    729c:	80 e0       	ldi	r24, 0x00	; 0
    729e:	90 e0       	ldi	r25, 0x00	; 0
    72a0:	aa e7       	ldi	r26, 0x7A	; 122
    72a2:	b3 e4       	ldi	r27, 0x43	; 67
    72a4:	89 83       	std	Y+1, r24	; 0x01
    72a6:	9a 83       	std	Y+2, r25	; 0x02
    72a8:	ab 83       	std	Y+3, r26	; 0x03
    72aa:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    72ac:	69 81       	ldd	r22, Y+1	; 0x01
    72ae:	7a 81       	ldd	r23, Y+2	; 0x02
    72b0:	8b 81       	ldd	r24, Y+3	; 0x03
    72b2:	9c 81       	ldd	r25, Y+4	; 0x04
    72b4:	2b ea       	ldi	r18, 0xAB	; 171
    72b6:	3a ea       	ldi	r19, 0xAA	; 170
    72b8:	4a e2       	ldi	r20, 0x2A	; 42
    72ba:	51 e4       	ldi	r21, 0x41	; 65
    72bc:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    72c0:	dc 01       	movw	r26, r24
    72c2:	cb 01       	movw	r24, r22
    72c4:	8d 83       	std	Y+5, r24	; 0x05
    72c6:	9e 83       	std	Y+6, r25	; 0x06
    72c8:	af 83       	std	Y+7, r26	; 0x07
    72ca:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    72cc:	11 e0       	ldi	r17, 0x01	; 1
    72ce:	6d 81       	ldd	r22, Y+5	; 0x05
    72d0:	7e 81       	ldd	r23, Y+6	; 0x06
    72d2:	8f 81       	ldd	r24, Y+7	; 0x07
    72d4:	98 85       	ldd	r25, Y+8	; 0x08
    72d6:	20 e0       	ldi	r18, 0x00	; 0
    72d8:	30 e0       	ldi	r19, 0x00	; 0
    72da:	40 e8       	ldi	r20, 0x80	; 128
    72dc:	5f e3       	ldi	r21, 0x3F	; 63
    72de:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    72e2:	88 23       	and	r24, r24
    72e4:	0c f0       	brlt	.+2      	; 0x72e8 <FRAMTest1Channel+0x64>
    72e6:	10 e0       	ldi	r17, 0x00	; 0
    72e8:	11 23       	and	r17, r17
    72ea:	19 f0       	breq	.+6      	; 0x72f2 <FRAMTest1Channel+0x6e>
		__ticks = 1;
    72ec:	81 e0       	ldi	r24, 0x01	; 1
    72ee:	89 87       	std	Y+9, r24	; 0x09
    72f0:	a3 c0       	rjmp	.+326    	; 0x7438 <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    72f2:	11 e0       	ldi	r17, 0x01	; 1
    72f4:	6d 81       	ldd	r22, Y+5	; 0x05
    72f6:	7e 81       	ldd	r23, Y+6	; 0x06
    72f8:	8f 81       	ldd	r24, Y+7	; 0x07
    72fa:	98 85       	ldd	r25, Y+8	; 0x08
    72fc:	20 e0       	ldi	r18, 0x00	; 0
    72fe:	30 e0       	ldi	r19, 0x00	; 0
    7300:	4f e7       	ldi	r20, 0x7F	; 127
    7302:	53 e4       	ldi	r21, 0x43	; 67
    7304:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    7308:	18 16       	cp	r1, r24
    730a:	0c f0       	brlt	.+2      	; 0x730e <FRAMTest1Channel+0x8a>
    730c:	10 e0       	ldi	r17, 0x00	; 0
    730e:	11 23       	and	r17, r17
    7310:	09 f4       	brne	.+2      	; 0x7314 <FRAMTest1Channel+0x90>
    7312:	89 c0       	rjmp	.+274    	; 0x7426 <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    7314:	69 81       	ldd	r22, Y+1	; 0x01
    7316:	7a 81       	ldd	r23, Y+2	; 0x02
    7318:	8b 81       	ldd	r24, Y+3	; 0x03
    731a:	9c 81       	ldd	r25, Y+4	; 0x04
    731c:	20 e0       	ldi	r18, 0x00	; 0
    731e:	30 e0       	ldi	r19, 0x00	; 0
    7320:	4a e7       	ldi	r20, 0x7A	; 122
    7322:	54 e4       	ldi	r21, 0x44	; 68
    7324:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    7328:	dc 01       	movw	r26, r24
    732a:	cb 01       	movw	r24, r22
    732c:	8a 87       	std	Y+10, r24	; 0x0a
    732e:	9b 87       	std	Y+11, r25	; 0x0b
    7330:	ac 87       	std	Y+12, r26	; 0x0c
    7332:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7334:	6a 85       	ldd	r22, Y+10	; 0x0a
    7336:	7b 85       	ldd	r23, Y+11	; 0x0b
    7338:	8c 85       	ldd	r24, Y+12	; 0x0c
    733a:	9d 85       	ldd	r25, Y+13	; 0x0d
    733c:	20 e0       	ldi	r18, 0x00	; 0
    733e:	30 e0       	ldi	r19, 0x00	; 0
    7340:	4a ef       	ldi	r20, 0xFA	; 250
    7342:	55 e4       	ldi	r21, 0x45	; 69
    7344:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    7348:	dc 01       	movw	r26, r24
    734a:	cb 01       	movw	r24, r22
    734c:	8e 87       	std	Y+14, r24	; 0x0e
    734e:	9f 87       	std	Y+15, r25	; 0x0f
    7350:	a8 8b       	std	Y+16, r26	; 0x10
    7352:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7354:	11 e0       	ldi	r17, 0x01	; 1
    7356:	6e 85       	ldd	r22, Y+14	; 0x0e
    7358:	7f 85       	ldd	r23, Y+15	; 0x0f
    735a:	88 89       	ldd	r24, Y+16	; 0x10
    735c:	99 89       	ldd	r25, Y+17	; 0x11
    735e:	20 e0       	ldi	r18, 0x00	; 0
    7360:	30 e0       	ldi	r19, 0x00	; 0
    7362:	40 e8       	ldi	r20, 0x80	; 128
    7364:	5f e3       	ldi	r21, 0x3F	; 63
    7366:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    736a:	88 23       	and	r24, r24
    736c:	0c f0       	brlt	.+2      	; 0x7370 <FRAMTest1Channel+0xec>
    736e:	10 e0       	ldi	r17, 0x00	; 0
    7370:	11 23       	and	r17, r17
    7372:	29 f0       	breq	.+10     	; 0x737e <FRAMTest1Channel+0xfa>
		__ticks = 1;
    7374:	81 e0       	ldi	r24, 0x01	; 1
    7376:	90 e0       	ldi	r25, 0x00	; 0
    7378:	8a 8b       	std	Y+18, r24	; 0x12
    737a:	9b 8b       	std	Y+19, r25	; 0x13
    737c:	46 c0       	rjmp	.+140    	; 0x740a <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    737e:	11 e0       	ldi	r17, 0x01	; 1
    7380:	6e 85       	ldd	r22, Y+14	; 0x0e
    7382:	7f 85       	ldd	r23, Y+15	; 0x0f
    7384:	88 89       	ldd	r24, Y+16	; 0x10
    7386:	99 89       	ldd	r25, Y+17	; 0x11
    7388:	20 e0       	ldi	r18, 0x00	; 0
    738a:	3f ef       	ldi	r19, 0xFF	; 255
    738c:	4f e7       	ldi	r20, 0x7F	; 127
    738e:	57 e4       	ldi	r21, 0x47	; 71
    7390:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    7394:	18 16       	cp	r1, r24
    7396:	0c f0       	brlt	.+2      	; 0x739a <FRAMTest1Channel+0x116>
    7398:	10 e0       	ldi	r17, 0x00	; 0
    739a:	11 23       	and	r17, r17
    739c:	61 f1       	breq	.+88     	; 0x73f6 <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    739e:	6a 85       	ldd	r22, Y+10	; 0x0a
    73a0:	7b 85       	ldd	r23, Y+11	; 0x0b
    73a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    73a4:	9d 85       	ldd	r25, Y+13	; 0x0d
    73a6:	20 e0       	ldi	r18, 0x00	; 0
    73a8:	30 e0       	ldi	r19, 0x00	; 0
    73aa:	40 e2       	ldi	r20, 0x20	; 32
    73ac:	51 e4       	ldi	r21, 0x41	; 65
    73ae:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    73b2:	dc 01       	movw	r26, r24
    73b4:	cb 01       	movw	r24, r22
    73b6:	bc 01       	movw	r22, r24
    73b8:	cd 01       	movw	r24, r26
    73ba:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    73be:	dc 01       	movw	r26, r24
    73c0:	cb 01       	movw	r24, r22
    73c2:	8a 8b       	std	Y+18, r24	; 0x12
    73c4:	9b 8b       	std	Y+19, r25	; 0x13
    73c6:	12 c0       	rjmp	.+36     	; 0x73ec <FRAMTest1Channel+0x168>
    73c8:	80 e2       	ldi	r24, 0x20	; 32
    73ca:	93 e0       	ldi	r25, 0x03	; 3
    73cc:	8c 8b       	std	Y+20, r24	; 0x14
    73ce:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    73d0:	8c 89       	ldd	r24, Y+20	; 0x14
    73d2:	9d 89       	ldd	r25, Y+21	; 0x15
    73d4:	8c 01       	movw	r16, r24
    73d6:	c8 01       	movw	r24, r16
    73d8:	01 97       	sbiw	r24, 0x01	; 1
    73da:	f1 f7       	brne	.-4      	; 0x73d8 <FRAMTest1Channel+0x154>
    73dc:	8c 01       	movw	r16, r24
    73de:	0c 8b       	std	Y+20, r16	; 0x14
    73e0:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    73e2:	8a 89       	ldd	r24, Y+18	; 0x12
    73e4:	9b 89       	ldd	r25, Y+19	; 0x13
    73e6:	01 97       	sbiw	r24, 0x01	; 1
    73e8:	8a 8b       	std	Y+18, r24	; 0x12
    73ea:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    73ec:	8a 89       	ldd	r24, Y+18	; 0x12
    73ee:	9b 89       	ldd	r25, Y+19	; 0x13
    73f0:	00 97       	sbiw	r24, 0x00	; 0
    73f2:	51 f7       	brne	.-44     	; 0x73c8 <FRAMTest1Channel+0x144>
    73f4:	28 c0       	rjmp	.+80     	; 0x7446 <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    73f6:	6e 85       	ldd	r22, Y+14	; 0x0e
    73f8:	7f 85       	ldd	r23, Y+15	; 0x0f
    73fa:	88 89       	ldd	r24, Y+16	; 0x10
    73fc:	99 89       	ldd	r25, Y+17	; 0x11
    73fe:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7402:	dc 01       	movw	r26, r24
    7404:	cb 01       	movw	r24, r22
    7406:	8a 8b       	std	Y+18, r24	; 0x12
    7408:	9b 8b       	std	Y+19, r25	; 0x13
    740a:	8a 89       	ldd	r24, Y+18	; 0x12
    740c:	9b 89       	ldd	r25, Y+19	; 0x13
    740e:	8e 8b       	std	Y+22, r24	; 0x16
    7410:	9f 8b       	std	Y+23, r25	; 0x17
    7412:	8e 89       	ldd	r24, Y+22	; 0x16
    7414:	9f 89       	ldd	r25, Y+23	; 0x17
    7416:	8c 01       	movw	r16, r24
    7418:	c8 01       	movw	r24, r16
    741a:	01 97       	sbiw	r24, 0x01	; 1
    741c:	f1 f7       	brne	.-4      	; 0x741a <FRAMTest1Channel+0x196>
    741e:	8c 01       	movw	r16, r24
    7420:	0e 8b       	std	Y+22, r16	; 0x16
    7422:	1f 8b       	std	Y+23, r17	; 0x17
    7424:	10 c0       	rjmp	.+32     	; 0x7446 <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7426:	6d 81       	ldd	r22, Y+5	; 0x05
    7428:	7e 81       	ldd	r23, Y+6	; 0x06
    742a:	8f 81       	ldd	r24, Y+7	; 0x07
    742c:	98 85       	ldd	r25, Y+8	; 0x08
    742e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7432:	dc 01       	movw	r26, r24
    7434:	cb 01       	movw	r24, r22
    7436:	89 87       	std	Y+9, r24	; 0x09
    7438:	89 85       	ldd	r24, Y+9	; 0x09
    743a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    743c:	88 8d       	ldd	r24, Y+24	; 0x18
    743e:	18 2f       	mov	r17, r24
    7440:	1a 95       	dec	r17
    7442:	f1 f7       	brne	.-4      	; 0x7440 <FRAMTest1Channel+0x1bc>
    7444:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7446:	0e 94 b8 15 	call	0x2b70	; 0x2b70 <calcChecksumFRAM>

	ADCPower(FALSE);
    744a:	80 e0       	ldi	r24, 0x00	; 0
    744c:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

}
    7450:	68 96       	adiw	r28, 0x18	; 24
    7452:	cd bf       	out	0x3d, r28	; 61
    7454:	de bf       	out	0x3e, r29	; 62
    7456:	df 91       	pop	r29
    7458:	cf 91       	pop	r28
    745a:	1f 91       	pop	r17
    745c:	0f 91       	pop	r16
    745e:	08 95       	ret

00007460 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7460:	0f 93       	push	r16
    7462:	1f 93       	push	r17
    7464:	cf 93       	push	r28
    7466:	df 93       	push	r29
    7468:	cd b7       	in	r28, 0x3d	; 61
    746a:	de b7       	in	r29, 0x3e	; 62
    746c:	68 97       	sbiw	r28, 0x18	; 24
    746e:	cd bf       	out	0x3d, r28	; 61
    7470:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    7472:	0e 94 c0 18 	call	0x3180	; 0x3180 <FRAMWriteKnowns>
	ADCPower(TRUE);
    7476:	81 e0       	ldi	r24, 0x01	; 1
    7478:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
    747c:	80 e0       	ldi	r24, 0x00	; 0
    747e:	90 e0       	ldi	r25, 0x00	; 0
    7480:	aa e7       	ldi	r26, 0x7A	; 122
    7482:	b3 e4       	ldi	r27, 0x43	; 67
    7484:	89 83       	std	Y+1, r24	; 0x01
    7486:	9a 83       	std	Y+2, r25	; 0x02
    7488:	ab 83       	std	Y+3, r26	; 0x03
    748a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    748c:	69 81       	ldd	r22, Y+1	; 0x01
    748e:	7a 81       	ldd	r23, Y+2	; 0x02
    7490:	8b 81       	ldd	r24, Y+3	; 0x03
    7492:	9c 81       	ldd	r25, Y+4	; 0x04
    7494:	2b ea       	ldi	r18, 0xAB	; 171
    7496:	3a ea       	ldi	r19, 0xAA	; 170
    7498:	4a e2       	ldi	r20, 0x2A	; 42
    749a:	51 e4       	ldi	r21, 0x41	; 65
    749c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    74a0:	dc 01       	movw	r26, r24
    74a2:	cb 01       	movw	r24, r22
    74a4:	8d 83       	std	Y+5, r24	; 0x05
    74a6:	9e 83       	std	Y+6, r25	; 0x06
    74a8:	af 83       	std	Y+7, r26	; 0x07
    74aa:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    74ac:	11 e0       	ldi	r17, 0x01	; 1
    74ae:	6d 81       	ldd	r22, Y+5	; 0x05
    74b0:	7e 81       	ldd	r23, Y+6	; 0x06
    74b2:	8f 81       	ldd	r24, Y+7	; 0x07
    74b4:	98 85       	ldd	r25, Y+8	; 0x08
    74b6:	20 e0       	ldi	r18, 0x00	; 0
    74b8:	30 e0       	ldi	r19, 0x00	; 0
    74ba:	40 e8       	ldi	r20, 0x80	; 128
    74bc:	5f e3       	ldi	r21, 0x3F	; 63
    74be:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    74c2:	88 23       	and	r24, r24
    74c4:	0c f0       	brlt	.+2      	; 0x74c8 <FRAMWriteKnownsCheck+0x68>
    74c6:	10 e0       	ldi	r17, 0x00	; 0
    74c8:	11 23       	and	r17, r17
    74ca:	19 f0       	breq	.+6      	; 0x74d2 <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    74cc:	81 e0       	ldi	r24, 0x01	; 1
    74ce:	89 87       	std	Y+9, r24	; 0x09
    74d0:	a3 c0       	rjmp	.+326    	; 0x7618 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    74d2:	11 e0       	ldi	r17, 0x01	; 1
    74d4:	6d 81       	ldd	r22, Y+5	; 0x05
    74d6:	7e 81       	ldd	r23, Y+6	; 0x06
    74d8:	8f 81       	ldd	r24, Y+7	; 0x07
    74da:	98 85       	ldd	r25, Y+8	; 0x08
    74dc:	20 e0       	ldi	r18, 0x00	; 0
    74de:	30 e0       	ldi	r19, 0x00	; 0
    74e0:	4f e7       	ldi	r20, 0x7F	; 127
    74e2:	53 e4       	ldi	r21, 0x43	; 67
    74e4:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    74e8:	18 16       	cp	r1, r24
    74ea:	0c f0       	brlt	.+2      	; 0x74ee <FRAMWriteKnownsCheck+0x8e>
    74ec:	10 e0       	ldi	r17, 0x00	; 0
    74ee:	11 23       	and	r17, r17
    74f0:	09 f4       	brne	.+2      	; 0x74f4 <FRAMWriteKnownsCheck+0x94>
    74f2:	89 c0       	rjmp	.+274    	; 0x7606 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    74f4:	69 81       	ldd	r22, Y+1	; 0x01
    74f6:	7a 81       	ldd	r23, Y+2	; 0x02
    74f8:	8b 81       	ldd	r24, Y+3	; 0x03
    74fa:	9c 81       	ldd	r25, Y+4	; 0x04
    74fc:	20 e0       	ldi	r18, 0x00	; 0
    74fe:	30 e0       	ldi	r19, 0x00	; 0
    7500:	4a e7       	ldi	r20, 0x7A	; 122
    7502:	54 e4       	ldi	r21, 0x44	; 68
    7504:	0e 94 95 60 	call	0xc12a	; 0xc12a <__divsf3>
    7508:	dc 01       	movw	r26, r24
    750a:	cb 01       	movw	r24, r22
    750c:	8a 87       	std	Y+10, r24	; 0x0a
    750e:	9b 87       	std	Y+11, r25	; 0x0b
    7510:	ac 87       	std	Y+12, r26	; 0x0c
    7512:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7514:	6a 85       	ldd	r22, Y+10	; 0x0a
    7516:	7b 85       	ldd	r23, Y+11	; 0x0b
    7518:	8c 85       	ldd	r24, Y+12	; 0x0c
    751a:	9d 85       	ldd	r25, Y+13	; 0x0d
    751c:	20 e0       	ldi	r18, 0x00	; 0
    751e:	30 e0       	ldi	r19, 0x00	; 0
    7520:	4a ef       	ldi	r20, 0xFA	; 250
    7522:	55 e4       	ldi	r21, 0x45	; 69
    7524:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    7528:	dc 01       	movw	r26, r24
    752a:	cb 01       	movw	r24, r22
    752c:	8e 87       	std	Y+14, r24	; 0x0e
    752e:	9f 87       	std	Y+15, r25	; 0x0f
    7530:	a8 8b       	std	Y+16, r26	; 0x10
    7532:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7534:	11 e0       	ldi	r17, 0x01	; 1
    7536:	6e 85       	ldd	r22, Y+14	; 0x0e
    7538:	7f 85       	ldd	r23, Y+15	; 0x0f
    753a:	88 89       	ldd	r24, Y+16	; 0x10
    753c:	99 89       	ldd	r25, Y+17	; 0x11
    753e:	20 e0       	ldi	r18, 0x00	; 0
    7540:	30 e0       	ldi	r19, 0x00	; 0
    7542:	40 e8       	ldi	r20, 0x80	; 128
    7544:	5f e3       	ldi	r21, 0x3F	; 63
    7546:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    754a:	88 23       	and	r24, r24
    754c:	0c f0       	brlt	.+2      	; 0x7550 <FRAMWriteKnownsCheck+0xf0>
    754e:	10 e0       	ldi	r17, 0x00	; 0
    7550:	11 23       	and	r17, r17
    7552:	29 f0       	breq	.+10     	; 0x755e <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    7554:	81 e0       	ldi	r24, 0x01	; 1
    7556:	90 e0       	ldi	r25, 0x00	; 0
    7558:	8a 8b       	std	Y+18, r24	; 0x12
    755a:	9b 8b       	std	Y+19, r25	; 0x13
    755c:	46 c0       	rjmp	.+140    	; 0x75ea <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    755e:	11 e0       	ldi	r17, 0x01	; 1
    7560:	6e 85       	ldd	r22, Y+14	; 0x0e
    7562:	7f 85       	ldd	r23, Y+15	; 0x0f
    7564:	88 89       	ldd	r24, Y+16	; 0x10
    7566:	99 89       	ldd	r25, Y+17	; 0x11
    7568:	20 e0       	ldi	r18, 0x00	; 0
    756a:	3f ef       	ldi	r19, 0xFF	; 255
    756c:	4f e7       	ldi	r20, 0x7F	; 127
    756e:	57 e4       	ldi	r21, 0x47	; 71
    7570:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    7574:	18 16       	cp	r1, r24
    7576:	0c f0       	brlt	.+2      	; 0x757a <FRAMWriteKnownsCheck+0x11a>
    7578:	10 e0       	ldi	r17, 0x00	; 0
    757a:	11 23       	and	r17, r17
    757c:	61 f1       	breq	.+88     	; 0x75d6 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    757e:	6a 85       	ldd	r22, Y+10	; 0x0a
    7580:	7b 85       	ldd	r23, Y+11	; 0x0b
    7582:	8c 85       	ldd	r24, Y+12	; 0x0c
    7584:	9d 85       	ldd	r25, Y+13	; 0x0d
    7586:	20 e0       	ldi	r18, 0x00	; 0
    7588:	30 e0       	ldi	r19, 0x00	; 0
    758a:	40 e2       	ldi	r20, 0x20	; 32
    758c:	51 e4       	ldi	r21, 0x41	; 65
    758e:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    7592:	dc 01       	movw	r26, r24
    7594:	cb 01       	movw	r24, r22
    7596:	bc 01       	movw	r22, r24
    7598:	cd 01       	movw	r24, r26
    759a:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    759e:	dc 01       	movw	r26, r24
    75a0:	cb 01       	movw	r24, r22
    75a2:	8a 8b       	std	Y+18, r24	; 0x12
    75a4:	9b 8b       	std	Y+19, r25	; 0x13
    75a6:	12 c0       	rjmp	.+36     	; 0x75cc <FRAMWriteKnownsCheck+0x16c>
    75a8:	80 e2       	ldi	r24, 0x20	; 32
    75aa:	93 e0       	ldi	r25, 0x03	; 3
    75ac:	8c 8b       	std	Y+20, r24	; 0x14
    75ae:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    75b0:	8c 89       	ldd	r24, Y+20	; 0x14
    75b2:	9d 89       	ldd	r25, Y+21	; 0x15
    75b4:	8c 01       	movw	r16, r24
    75b6:	c8 01       	movw	r24, r16
    75b8:	01 97       	sbiw	r24, 0x01	; 1
    75ba:	f1 f7       	brne	.-4      	; 0x75b8 <FRAMWriteKnownsCheck+0x158>
    75bc:	8c 01       	movw	r16, r24
    75be:	0c 8b       	std	Y+20, r16	; 0x14
    75c0:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    75c2:	8a 89       	ldd	r24, Y+18	; 0x12
    75c4:	9b 89       	ldd	r25, Y+19	; 0x13
    75c6:	01 97       	sbiw	r24, 0x01	; 1
    75c8:	8a 8b       	std	Y+18, r24	; 0x12
    75ca:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    75cc:	8a 89       	ldd	r24, Y+18	; 0x12
    75ce:	9b 89       	ldd	r25, Y+19	; 0x13
    75d0:	00 97       	sbiw	r24, 0x00	; 0
    75d2:	51 f7       	brne	.-44     	; 0x75a8 <FRAMWriteKnownsCheck+0x148>
    75d4:	28 c0       	rjmp	.+80     	; 0x7626 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    75d6:	6e 85       	ldd	r22, Y+14	; 0x0e
    75d8:	7f 85       	ldd	r23, Y+15	; 0x0f
    75da:	88 89       	ldd	r24, Y+16	; 0x10
    75dc:	99 89       	ldd	r25, Y+17	; 0x11
    75de:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    75e2:	dc 01       	movw	r26, r24
    75e4:	cb 01       	movw	r24, r22
    75e6:	8a 8b       	std	Y+18, r24	; 0x12
    75e8:	9b 8b       	std	Y+19, r25	; 0x13
    75ea:	8a 89       	ldd	r24, Y+18	; 0x12
    75ec:	9b 89       	ldd	r25, Y+19	; 0x13
    75ee:	8e 8b       	std	Y+22, r24	; 0x16
    75f0:	9f 8b       	std	Y+23, r25	; 0x17
    75f2:	8e 89       	ldd	r24, Y+22	; 0x16
    75f4:	9f 89       	ldd	r25, Y+23	; 0x17
    75f6:	8c 01       	movw	r16, r24
    75f8:	c8 01       	movw	r24, r16
    75fa:	01 97       	sbiw	r24, 0x01	; 1
    75fc:	f1 f7       	brne	.-4      	; 0x75fa <FRAMWriteKnownsCheck+0x19a>
    75fe:	8c 01       	movw	r16, r24
    7600:	0e 8b       	std	Y+22, r16	; 0x16
    7602:	1f 8b       	std	Y+23, r17	; 0x17
    7604:	10 c0       	rjmp	.+32     	; 0x7626 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7606:	6d 81       	ldd	r22, Y+5	; 0x05
    7608:	7e 81       	ldd	r23, Y+6	; 0x06
    760a:	8f 81       	ldd	r24, Y+7	; 0x07
    760c:	98 85       	ldd	r25, Y+8	; 0x08
    760e:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7612:	dc 01       	movw	r26, r24
    7614:	cb 01       	movw	r24, r22
    7616:	89 87       	std	Y+9, r24	; 0x09
    7618:	89 85       	ldd	r24, Y+9	; 0x09
    761a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    761c:	88 8d       	ldd	r24, Y+24	; 0x18
    761e:	18 2f       	mov	r17, r24
    7620:	1a 95       	dec	r17
    7622:	f1 f7       	brne	.-4      	; 0x7620 <FRAMWriteKnownsCheck+0x1c0>
    7624:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7626:	0e 94 b8 15 	call	0x2b70	; 0x2b70 <calcChecksumFRAM>

	ADCPower(FALSE);
    762a:	80 e0       	ldi	r24, 0x00	; 0
    762c:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

}
    7630:	68 96       	adiw	r28, 0x18	; 24
    7632:	cd bf       	out	0x3d, r28	; 61
    7634:	de bf       	out	0x3e, r29	; 62
    7636:	df 91       	pop	r29
    7638:	cf 91       	pop	r28
    763a:	1f 91       	pop	r17
    763c:	0f 91       	pop	r16
    763e:	08 95       	ret

00007640 <checkMote>:

//random function for testing stuff	
void checkMote(){
    7640:	0f 93       	push	r16
    7642:	1f 93       	push	r17
    7644:	cf 93       	push	r28
    7646:	df 93       	push	r29
    7648:	cd b7       	in	r28, 0x3d	; 61
    764a:	de b7       	in	r29, 0x3e	; 62
    764c:	aa 97       	sbiw	r28, 0x2a	; 42
    764e:	cd bf       	out	0x3d, r28	; 61
    7650:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    7652:	81 e0       	ldi	r24, 0x01	; 1
    7654:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	Ext1Power(TRUE);
    7658:	81 e0       	ldi	r24, 0x01	; 1
    765a:	0e 94 3c 34 	call	0x6878	; 0x6878 <Ext1Power>
    765e:	80 e0       	ldi	r24, 0x00	; 0
    7660:	90 e0       	ldi	r25, 0x00	; 0
    7662:	a8 ec       	ldi	r26, 0xC8	; 200
    7664:	b2 e4       	ldi	r27, 0x42	; 66
    7666:	89 83       	std	Y+1, r24	; 0x01
    7668:	9a 83       	std	Y+2, r25	; 0x02
    766a:	ab 83       	std	Y+3, r26	; 0x03
    766c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    766e:	69 81       	ldd	r22, Y+1	; 0x01
    7670:	7a 81       	ldd	r23, Y+2	; 0x02
    7672:	8b 81       	ldd	r24, Y+3	; 0x03
    7674:	9c 81       	ldd	r25, Y+4	; 0x04
    7676:	20 e0       	ldi	r18, 0x00	; 0
    7678:	30 e0       	ldi	r19, 0x00	; 0
    767a:	4a ef       	ldi	r20, 0xFA	; 250
    767c:	55 e4       	ldi	r21, 0x45	; 69
    767e:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    7682:	dc 01       	movw	r26, r24
    7684:	cb 01       	movw	r24, r22
    7686:	8d 83       	std	Y+5, r24	; 0x05
    7688:	9e 83       	std	Y+6, r25	; 0x06
    768a:	af 83       	std	Y+7, r26	; 0x07
    768c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    768e:	11 e0       	ldi	r17, 0x01	; 1
    7690:	6d 81       	ldd	r22, Y+5	; 0x05
    7692:	7e 81       	ldd	r23, Y+6	; 0x06
    7694:	8f 81       	ldd	r24, Y+7	; 0x07
    7696:	98 85       	ldd	r25, Y+8	; 0x08
    7698:	20 e0       	ldi	r18, 0x00	; 0
    769a:	30 e0       	ldi	r19, 0x00	; 0
    769c:	40 e8       	ldi	r20, 0x80	; 128
    769e:	5f e3       	ldi	r21, 0x3F	; 63
    76a0:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    76a4:	88 23       	and	r24, r24
    76a6:	0c f0       	brlt	.+2      	; 0x76aa <checkMote+0x6a>
    76a8:	10 e0       	ldi	r17, 0x00	; 0
    76aa:	11 23       	and	r17, r17
    76ac:	29 f0       	breq	.+10     	; 0x76b8 <checkMote+0x78>
		__ticks = 1;
    76ae:	81 e0       	ldi	r24, 0x01	; 1
    76b0:	90 e0       	ldi	r25, 0x00	; 0
    76b2:	89 87       	std	Y+9, r24	; 0x09
    76b4:	9a 87       	std	Y+10, r25	; 0x0a
    76b6:	46 c0       	rjmp	.+140    	; 0x7744 <checkMote+0x104>
	else if (__tmp > 65535)
    76b8:	11 e0       	ldi	r17, 0x01	; 1
    76ba:	6d 81       	ldd	r22, Y+5	; 0x05
    76bc:	7e 81       	ldd	r23, Y+6	; 0x06
    76be:	8f 81       	ldd	r24, Y+7	; 0x07
    76c0:	98 85       	ldd	r25, Y+8	; 0x08
    76c2:	20 e0       	ldi	r18, 0x00	; 0
    76c4:	3f ef       	ldi	r19, 0xFF	; 255
    76c6:	4f e7       	ldi	r20, 0x7F	; 127
    76c8:	57 e4       	ldi	r21, 0x47	; 71
    76ca:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    76ce:	18 16       	cp	r1, r24
    76d0:	0c f0       	brlt	.+2      	; 0x76d4 <checkMote+0x94>
    76d2:	10 e0       	ldi	r17, 0x00	; 0
    76d4:	11 23       	and	r17, r17
    76d6:	61 f1       	breq	.+88     	; 0x7730 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    76d8:	69 81       	ldd	r22, Y+1	; 0x01
    76da:	7a 81       	ldd	r23, Y+2	; 0x02
    76dc:	8b 81       	ldd	r24, Y+3	; 0x03
    76de:	9c 81       	ldd	r25, Y+4	; 0x04
    76e0:	20 e0       	ldi	r18, 0x00	; 0
    76e2:	30 e0       	ldi	r19, 0x00	; 0
    76e4:	40 e2       	ldi	r20, 0x20	; 32
    76e6:	51 e4       	ldi	r21, 0x41	; 65
    76e8:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    76ec:	dc 01       	movw	r26, r24
    76ee:	cb 01       	movw	r24, r22
    76f0:	bc 01       	movw	r22, r24
    76f2:	cd 01       	movw	r24, r26
    76f4:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    76f8:	dc 01       	movw	r26, r24
    76fa:	cb 01       	movw	r24, r22
    76fc:	89 87       	std	Y+9, r24	; 0x09
    76fe:	9a 87       	std	Y+10, r25	; 0x0a
    7700:	12 c0       	rjmp	.+36     	; 0x7726 <checkMote+0xe6>
    7702:	80 e2       	ldi	r24, 0x20	; 32
    7704:	93 e0       	ldi	r25, 0x03	; 3
    7706:	8b 87       	std	Y+11, r24	; 0x0b
    7708:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    770a:	8b 85       	ldd	r24, Y+11	; 0x0b
    770c:	9c 85       	ldd	r25, Y+12	; 0x0c
    770e:	8c 01       	movw	r16, r24
    7710:	c8 01       	movw	r24, r16
    7712:	01 97       	sbiw	r24, 0x01	; 1
    7714:	f1 f7       	brne	.-4      	; 0x7712 <checkMote+0xd2>
    7716:	8c 01       	movw	r16, r24
    7718:	0b 87       	std	Y+11, r16	; 0x0b
    771a:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    771c:	89 85       	ldd	r24, Y+9	; 0x09
    771e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7720:	01 97       	sbiw	r24, 0x01	; 1
    7722:	89 87       	std	Y+9, r24	; 0x09
    7724:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7726:	89 85       	ldd	r24, Y+9	; 0x09
    7728:	9a 85       	ldd	r25, Y+10	; 0x0a
    772a:	00 97       	sbiw	r24, 0x00	; 0
    772c:	51 f7       	brne	.-44     	; 0x7702 <checkMote+0xc2>
    772e:	17 c0       	rjmp	.+46     	; 0x775e <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7730:	6d 81       	ldd	r22, Y+5	; 0x05
    7732:	7e 81       	ldd	r23, Y+6	; 0x06
    7734:	8f 81       	ldd	r24, Y+7	; 0x07
    7736:	98 85       	ldd	r25, Y+8	; 0x08
    7738:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    773c:	dc 01       	movw	r26, r24
    773e:	cb 01       	movw	r24, r22
    7740:	89 87       	std	Y+9, r24	; 0x09
    7742:	9a 87       	std	Y+10, r25	; 0x0a
    7744:	89 85       	ldd	r24, Y+9	; 0x09
    7746:	9a 85       	ldd	r25, Y+10	; 0x0a
    7748:	8d 87       	std	Y+13, r24	; 0x0d
    774a:	9e 87       	std	Y+14, r25	; 0x0e
    774c:	8d 85       	ldd	r24, Y+13	; 0x0d
    774e:	9e 85       	ldd	r25, Y+14	; 0x0e
    7750:	8c 01       	movw	r16, r24
    7752:	c8 01       	movw	r24, r16
    7754:	01 97       	sbiw	r24, 0x01	; 1
    7756:	f1 f7       	brne	.-4      	; 0x7754 <checkMote+0x114>
    7758:	8c 01       	movw	r16, r24
    775a:	0d 87       	std	Y+13, r16	; 0x0d
    775c:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    775e:	88 e0       	ldi	r24, 0x08	; 8
    7760:	60 e0       	ldi	r22, 0x00	; 0
    7762:	0e 94 a6 32 	call	0x654c	; 0x654c <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7766:	88 e0       	ldi	r24, 0x08	; 8
    7768:	60 e0       	ldi	r22, 0x00	; 0
    776a:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
    776e:	80 e0       	ldi	r24, 0x00	; 0
    7770:	90 e4       	ldi	r25, 0x40	; 64
    7772:	ac e9       	ldi	r26, 0x9C	; 156
    7774:	b5 e4       	ldi	r27, 0x45	; 69
    7776:	8f 87       	std	Y+15, r24	; 0x0f
    7778:	98 8b       	std	Y+16, r25	; 0x10
    777a:	a9 8b       	std	Y+17, r26	; 0x11
    777c:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    777e:	6f 85       	ldd	r22, Y+15	; 0x0f
    7780:	78 89       	ldd	r23, Y+16	; 0x10
    7782:	89 89       	ldd	r24, Y+17	; 0x11
    7784:	9a 89       	ldd	r25, Y+18	; 0x12
    7786:	20 e0       	ldi	r18, 0x00	; 0
    7788:	30 e0       	ldi	r19, 0x00	; 0
    778a:	4a ef       	ldi	r20, 0xFA	; 250
    778c:	55 e4       	ldi	r21, 0x45	; 69
    778e:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    7792:	dc 01       	movw	r26, r24
    7794:	cb 01       	movw	r24, r22
    7796:	8b 8b       	std	Y+19, r24	; 0x13
    7798:	9c 8b       	std	Y+20, r25	; 0x14
    779a:	ad 8b       	std	Y+21, r26	; 0x15
    779c:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    779e:	11 e0       	ldi	r17, 0x01	; 1
    77a0:	6b 89       	ldd	r22, Y+19	; 0x13
    77a2:	7c 89       	ldd	r23, Y+20	; 0x14
    77a4:	8d 89       	ldd	r24, Y+21	; 0x15
    77a6:	9e 89       	ldd	r25, Y+22	; 0x16
    77a8:	20 e0       	ldi	r18, 0x00	; 0
    77aa:	30 e0       	ldi	r19, 0x00	; 0
    77ac:	40 e8       	ldi	r20, 0x80	; 128
    77ae:	5f e3       	ldi	r21, 0x3F	; 63
    77b0:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    77b4:	88 23       	and	r24, r24
    77b6:	0c f0       	brlt	.+2      	; 0x77ba <checkMote+0x17a>
    77b8:	10 e0       	ldi	r17, 0x00	; 0
    77ba:	11 23       	and	r17, r17
    77bc:	29 f0       	breq	.+10     	; 0x77c8 <checkMote+0x188>
		__ticks = 1;
    77be:	81 e0       	ldi	r24, 0x01	; 1
    77c0:	90 e0       	ldi	r25, 0x00	; 0
    77c2:	8f 8b       	std	Y+23, r24	; 0x17
    77c4:	98 8f       	std	Y+24, r25	; 0x18
    77c6:	46 c0       	rjmp	.+140    	; 0x7854 <checkMote+0x214>
	else if (__tmp > 65535)
    77c8:	11 e0       	ldi	r17, 0x01	; 1
    77ca:	6b 89       	ldd	r22, Y+19	; 0x13
    77cc:	7c 89       	ldd	r23, Y+20	; 0x14
    77ce:	8d 89       	ldd	r24, Y+21	; 0x15
    77d0:	9e 89       	ldd	r25, Y+22	; 0x16
    77d2:	20 e0       	ldi	r18, 0x00	; 0
    77d4:	3f ef       	ldi	r19, 0xFF	; 255
    77d6:	4f e7       	ldi	r20, 0x7F	; 127
    77d8:	57 e4       	ldi	r21, 0x47	; 71
    77da:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    77de:	18 16       	cp	r1, r24
    77e0:	0c f0       	brlt	.+2      	; 0x77e4 <checkMote+0x1a4>
    77e2:	10 e0       	ldi	r17, 0x00	; 0
    77e4:	11 23       	and	r17, r17
    77e6:	61 f1       	breq	.+88     	; 0x7840 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    77e8:	6f 85       	ldd	r22, Y+15	; 0x0f
    77ea:	78 89       	ldd	r23, Y+16	; 0x10
    77ec:	89 89       	ldd	r24, Y+17	; 0x11
    77ee:	9a 89       	ldd	r25, Y+18	; 0x12
    77f0:	20 e0       	ldi	r18, 0x00	; 0
    77f2:	30 e0       	ldi	r19, 0x00	; 0
    77f4:	40 e2       	ldi	r20, 0x20	; 32
    77f6:	51 e4       	ldi	r21, 0x41	; 65
    77f8:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    77fc:	dc 01       	movw	r26, r24
    77fe:	cb 01       	movw	r24, r22
    7800:	bc 01       	movw	r22, r24
    7802:	cd 01       	movw	r24, r26
    7804:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7808:	dc 01       	movw	r26, r24
    780a:	cb 01       	movw	r24, r22
    780c:	8f 8b       	std	Y+23, r24	; 0x17
    780e:	98 8f       	std	Y+24, r25	; 0x18
    7810:	12 c0       	rjmp	.+36     	; 0x7836 <checkMote+0x1f6>
    7812:	80 e2       	ldi	r24, 0x20	; 32
    7814:	93 e0       	ldi	r25, 0x03	; 3
    7816:	89 8f       	std	Y+25, r24	; 0x19
    7818:	9a 8f       	std	Y+26, r25	; 0x1a
    781a:	89 8d       	ldd	r24, Y+25	; 0x19
    781c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    781e:	8c 01       	movw	r16, r24
    7820:	c8 01       	movw	r24, r16
    7822:	01 97       	sbiw	r24, 0x01	; 1
    7824:	f1 f7       	brne	.-4      	; 0x7822 <checkMote+0x1e2>
    7826:	8c 01       	movw	r16, r24
    7828:	09 8f       	std	Y+25, r16	; 0x19
    782a:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    782c:	8f 89       	ldd	r24, Y+23	; 0x17
    782e:	98 8d       	ldd	r25, Y+24	; 0x18
    7830:	01 97       	sbiw	r24, 0x01	; 1
    7832:	8f 8b       	std	Y+23, r24	; 0x17
    7834:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7836:	8f 89       	ldd	r24, Y+23	; 0x17
    7838:	98 8d       	ldd	r25, Y+24	; 0x18
    783a:	00 97       	sbiw	r24, 0x00	; 0
    783c:	51 f7       	brne	.-44     	; 0x7812 <checkMote+0x1d2>
    783e:	17 c0       	rjmp	.+46     	; 0x786e <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7840:	6b 89       	ldd	r22, Y+19	; 0x13
    7842:	7c 89       	ldd	r23, Y+20	; 0x14
    7844:	8d 89       	ldd	r24, Y+21	; 0x15
    7846:	9e 89       	ldd	r25, Y+22	; 0x16
    7848:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    784c:	dc 01       	movw	r26, r24
    784e:	cb 01       	movw	r24, r22
    7850:	8f 8b       	std	Y+23, r24	; 0x17
    7852:	98 8f       	std	Y+24, r25	; 0x18
    7854:	8f 89       	ldd	r24, Y+23	; 0x17
    7856:	98 8d       	ldd	r25, Y+24	; 0x18
    7858:	8b 8f       	std	Y+27, r24	; 0x1b
    785a:	9c 8f       	std	Y+28, r25	; 0x1c
    785c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    785e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7860:	8c 01       	movw	r16, r24
    7862:	c8 01       	movw	r24, r16
    7864:	01 97       	sbiw	r24, 0x01	; 1
    7866:	f1 f7       	brne	.-4      	; 0x7864 <checkMote+0x224>
    7868:	8c 01       	movw	r16, r24
    786a:	0b 8f       	std	Y+27, r16	; 0x1b
    786c:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    786e:	88 e0       	ldi	r24, 0x08	; 8
    7870:	60 e0       	ldi	r22, 0x00	; 0
    7872:	0e 94 d5 33 	call	0x67aa	; 0x67aa <PortEx_OUTCLR>
    7876:	80 e0       	ldi	r24, 0x00	; 0
    7878:	90 e4       	ldi	r25, 0x40	; 64
    787a:	ac e9       	ldi	r26, 0x9C	; 156
    787c:	b5 e4       	ldi	r27, 0x45	; 69
    787e:	8d 8f       	std	Y+29, r24	; 0x1d
    7880:	9e 8f       	std	Y+30, r25	; 0x1e
    7882:	af 8f       	std	Y+31, r26	; 0x1f
    7884:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7886:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7888:	7e 8d       	ldd	r23, Y+30	; 0x1e
    788a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    788c:	98 a1       	lds	r25, 0x48
    788e:	20 e0       	ldi	r18, 0x00	; 0
    7890:	30 e0       	ldi	r19, 0x00	; 0
    7892:	4a ef       	ldi	r20, 0xFA	; 250
    7894:	55 e4       	ldi	r21, 0x45	; 69
    7896:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    789a:	dc 01       	movw	r26, r24
    789c:	cb 01       	movw	r24, r22
    789e:	89 a3       	lds	r24, 0x59
    78a0:	9a a3       	lds	r25, 0x5a
    78a2:	ab a3       	lds	r26, 0x5b
    78a4:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    78a6:	11 e0       	ldi	r17, 0x01	; 1
    78a8:	69 a1       	lds	r22, 0x49
    78aa:	7a a1       	lds	r23, 0x4a
    78ac:	8b a1       	lds	r24, 0x4b
    78ae:	9c a1       	lds	r25, 0x4c
    78b0:	20 e0       	ldi	r18, 0x00	; 0
    78b2:	30 e0       	ldi	r19, 0x00	; 0
    78b4:	40 e8       	ldi	r20, 0x80	; 128
    78b6:	5f e3       	ldi	r21, 0x3F	; 63
    78b8:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    78bc:	88 23       	and	r24, r24
    78be:	0c f0       	brlt	.+2      	; 0x78c2 <checkMote+0x282>
    78c0:	10 e0       	ldi	r17, 0x00	; 0
    78c2:	11 23       	and	r17, r17
    78c4:	29 f0       	breq	.+10     	; 0x78d0 <checkMote+0x290>
		__ticks = 1;
    78c6:	81 e0       	ldi	r24, 0x01	; 1
    78c8:	90 e0       	ldi	r25, 0x00	; 0
    78ca:	8d a3       	lds	r24, 0x5d
    78cc:	9e a3       	lds	r25, 0x5e
    78ce:	46 c0       	rjmp	.+140    	; 0x795c <checkMote+0x31c>
	else if (__tmp > 65535)
    78d0:	11 e0       	ldi	r17, 0x01	; 1
    78d2:	69 a1       	lds	r22, 0x49
    78d4:	7a a1       	lds	r23, 0x4a
    78d6:	8b a1       	lds	r24, 0x4b
    78d8:	9c a1       	lds	r25, 0x4c
    78da:	20 e0       	ldi	r18, 0x00	; 0
    78dc:	3f ef       	ldi	r19, 0xFF	; 255
    78de:	4f e7       	ldi	r20, 0x7F	; 127
    78e0:	57 e4       	ldi	r21, 0x47	; 71
    78e2:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    78e6:	18 16       	cp	r1, r24
    78e8:	0c f0       	brlt	.+2      	; 0x78ec <checkMote+0x2ac>
    78ea:	10 e0       	ldi	r17, 0x00	; 0
    78ec:	11 23       	and	r17, r17
    78ee:	61 f1       	breq	.+88     	; 0x7948 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    78f0:	6d 8d       	ldd	r22, Y+29	; 0x1d
    78f2:	7e 8d       	ldd	r23, Y+30	; 0x1e
    78f4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    78f6:	98 a1       	lds	r25, 0x48
    78f8:	20 e0       	ldi	r18, 0x00	; 0
    78fa:	30 e0       	ldi	r19, 0x00	; 0
    78fc:	40 e2       	ldi	r20, 0x20	; 32
    78fe:	51 e4       	ldi	r21, 0x41	; 65
    7900:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    7904:	dc 01       	movw	r26, r24
    7906:	cb 01       	movw	r24, r22
    7908:	bc 01       	movw	r22, r24
    790a:	cd 01       	movw	r24, r26
    790c:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7910:	dc 01       	movw	r26, r24
    7912:	cb 01       	movw	r24, r22
    7914:	8d a3       	lds	r24, 0x5d
    7916:	9e a3       	lds	r25, 0x5e
    7918:	12 c0       	rjmp	.+36     	; 0x793e <checkMote+0x2fe>
    791a:	80 e2       	ldi	r24, 0x20	; 32
    791c:	93 e0       	ldi	r25, 0x03	; 3
    791e:	8f a3       	lds	r24, 0x5f
    7920:	98 a7       	lds	r25, 0x78
    7922:	8f a1       	lds	r24, 0x4f
    7924:	98 a5       	lds	r25, 0x68
    7926:	8c 01       	movw	r16, r24
    7928:	c8 01       	movw	r24, r16
    792a:	01 97       	sbiw	r24, 0x01	; 1
    792c:	f1 f7       	brne	.-4      	; 0x792a <checkMote+0x2ea>
    792e:	8c 01       	movw	r16, r24
    7930:	0f a3       	lds	r16, 0x5f
    7932:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7934:	8d a1       	lds	r24, 0x4d
    7936:	9e a1       	lds	r25, 0x4e
    7938:	01 97       	sbiw	r24, 0x01	; 1
    793a:	8d a3       	lds	r24, 0x5d
    793c:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    793e:	8d a1       	lds	r24, 0x4d
    7940:	9e a1       	lds	r25, 0x4e
    7942:	00 97       	sbiw	r24, 0x00	; 0
    7944:	51 f7       	brne	.-44     	; 0x791a <checkMote+0x2da>
    7946:	18 c0       	rjmp	.+48     	; 0x7978 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7948:	69 a1       	lds	r22, 0x49
    794a:	7a a1       	lds	r23, 0x4a
    794c:	8b a1       	lds	r24, 0x4b
    794e:	9c a1       	lds	r25, 0x4c
    7950:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    7954:	dc 01       	movw	r26, r24
    7956:	cb 01       	movw	r24, r22
    7958:	8d a3       	lds	r24, 0x5d
    795a:	9e a3       	lds	r25, 0x5e
    795c:	8d a1       	lds	r24, 0x4d
    795e:	9e a1       	lds	r25, 0x4e
    7960:	89 a7       	lds	r24, 0x79
    7962:	9a a7       	lds	r25, 0x7a
    7964:	89 a5       	lds	r24, 0x69
    7966:	9a a5       	lds	r25, 0x6a
    7968:	8c 01       	movw	r16, r24
    796a:	c8 01       	movw	r24, r16
    796c:	01 97       	sbiw	r24, 0x01	; 1
    796e:	f1 f7       	brne	.-4      	; 0x796c <checkMote+0x32c>
    7970:	8c 01       	movw	r16, r24
    7972:	09 a7       	lds	r16, 0x79
    7974:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7976:	f7 ce       	rjmp	.-530    	; 0x7766 <checkMote+0x126>
    7978:	f6 ce       	rjmp	.-532    	; 0x7766 <checkMote+0x126>

0000797a <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    797a:	cf 93       	push	r28
    797c:	df 93       	push	r29
    797e:	cd b7       	in	r28, 0x3d	; 61
    7980:	de b7       	in	r29, 0x3e	; 62
    7982:	28 97       	sbiw	r28, 0x08	; 8
    7984:	cd bf       	out	0x3d, r28	; 61
    7986:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7988:	19 82       	std	Y+1, r1	; 0x01
    798a:	1a 82       	std	Y+2, r1	; 0x02
    798c:	0c c0       	rjmp	.+24     	; 0x79a6 <SD_write_and_read_knowns+0x2c>
    798e:	29 81       	ldd	r18, Y+1	; 0x01
    7990:	89 81       	ldd	r24, Y+1	; 0x01
    7992:	9a 81       	ldd	r25, Y+2	; 0x02
    7994:	88 52       	subi	r24, 0x28	; 40
    7996:	9c 4d       	sbci	r25, 0xDC	; 220
    7998:	fc 01       	movw	r30, r24
    799a:	20 83       	st	Z, r18
    799c:	89 81       	ldd	r24, Y+1	; 0x01
    799e:	9a 81       	ldd	r25, Y+2	; 0x02
    79a0:	01 96       	adiw	r24, 0x01	; 1
    79a2:	89 83       	std	Y+1, r24	; 0x01
    79a4:	9a 83       	std	Y+2, r25	; 0x02
    79a6:	89 81       	ldd	r24, Y+1	; 0x01
    79a8:	9a 81       	ldd	r25, Y+2	; 0x02
    79aa:	88 31       	cpi	r24, 0x18	; 24
    79ac:	91 05       	cpc	r25, r1
    79ae:	7c f3       	brlt	.-34     	; 0x798e <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    79b0:	28 ed       	ldi	r18, 0xD8	; 216
    79b2:	33 e2       	ldi	r19, 0x23	; 35
    79b4:	64 e1       	ldi	r22, 0x14	; 20
    79b6:	70 e0       	ldi	r23, 0x00	; 0
    79b8:	80 e0       	ldi	r24, 0x00	; 0
    79ba:	90 e0       	ldi	r25, 0x00	; 0
    79bc:	a9 01       	movw	r20, r18
    79be:	28 e1       	ldi	r18, 0x18	; 24
    79c0:	30 e0       	ldi	r19, 0x00	; 0
    79c2:	0e 94 d9 4d 	call	0x9bb2	; 0x9bb2 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    79c6:	1b 82       	std	Y+3, r1	; 0x03
    79c8:	1c 82       	std	Y+4, r1	; 0x04
    79ca:	0b c0       	rjmp	.+22     	; 0x79e2 <SD_write_and_read_knowns+0x68>
    79cc:	8b 81       	ldd	r24, Y+3	; 0x03
    79ce:	9c 81       	ldd	r25, Y+4	; 0x04
    79d0:	88 52       	subi	r24, 0x28	; 40
    79d2:	9c 4d       	sbci	r25, 0xDC	; 220
    79d4:	fc 01       	movw	r30, r24
    79d6:	10 82       	st	Z, r1
    79d8:	8b 81       	ldd	r24, Y+3	; 0x03
    79da:	9c 81       	ldd	r25, Y+4	; 0x04
    79dc:	01 96       	adiw	r24, 0x01	; 1
    79de:	8b 83       	std	Y+3, r24	; 0x03
    79e0:	9c 83       	std	Y+4, r25	; 0x04
    79e2:	8b 81       	ldd	r24, Y+3	; 0x03
    79e4:	9c 81       	ldd	r25, Y+4	; 0x04
    79e6:	88 31       	cpi	r24, 0x18	; 24
    79e8:	91 05       	cpc	r25, r1
    79ea:	84 f3       	brlt	.-32     	; 0x79cc <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    79ec:	28 ed       	ldi	r18, 0xD8	; 216
    79ee:	33 e2       	ldi	r19, 0x23	; 35
    79f0:	64 e1       	ldi	r22, 0x14	; 20
    79f2:	70 e0       	ldi	r23, 0x00	; 0
    79f4:	80 e0       	ldi	r24, 0x00	; 0
    79f6:	90 e0       	ldi	r25, 0x00	; 0
    79f8:	a9 01       	movw	r20, r18
    79fa:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    79fe:	1d 82       	std	Y+5, r1	; 0x05
    7a00:	1e 82       	std	Y+6, r1	; 0x06
    7a02:	13 c0       	rjmp	.+38     	; 0x7a2a <SD_write_and_read_knowns+0xb0>
    7a04:	8d 81       	ldd	r24, Y+5	; 0x05
    7a06:	9e 81       	ldd	r25, Y+6	; 0x06
    7a08:	24 e6       	ldi	r18, 0x64	; 100
    7a0a:	30 e0       	ldi	r19, 0x00	; 0
    7a0c:	b9 01       	movw	r22, r18
    7a0e:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    7a12:	28 2f       	mov	r18, r24
    7a14:	8d 81       	ldd	r24, Y+5	; 0x05
    7a16:	9e 81       	ldd	r25, Y+6	; 0x06
    7a18:	88 52       	subi	r24, 0x28	; 40
    7a1a:	9c 4d       	sbci	r25, 0xDC	; 220
    7a1c:	fc 01       	movw	r30, r24
    7a1e:	20 83       	st	Z, r18
    7a20:	8d 81       	ldd	r24, Y+5	; 0x05
    7a22:	9e 81       	ldd	r25, Y+6	; 0x06
    7a24:	01 96       	adiw	r24, 0x01	; 1
    7a26:	8d 83       	std	Y+5, r24	; 0x05
    7a28:	9e 83       	std	Y+6, r25	; 0x06
    7a2a:	8d 81       	ldd	r24, Y+5	; 0x05
    7a2c:	9e 81       	ldd	r25, Y+6	; 0x06
    7a2e:	f4 e0       	ldi	r31, 0x04	; 4
    7a30:	82 3e       	cpi	r24, 0xE2	; 226
    7a32:	9f 07       	cpc	r25, r31
    7a34:	3c f3       	brlt	.-50     	; 0x7a04 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7a36:	28 ed       	ldi	r18, 0xD8	; 216
    7a38:	33 e2       	ldi	r19, 0x23	; 35
    7a3a:	60 e5       	ldi	r22, 0x50	; 80
    7a3c:	70 e0       	ldi	r23, 0x00	; 0
    7a3e:	80 e0       	ldi	r24, 0x00	; 0
    7a40:	90 e0       	ldi	r25, 0x00	; 0
    7a42:	a9 01       	movw	r20, r18
    7a44:	22 ee       	ldi	r18, 0xE2	; 226
    7a46:	34 e0       	ldi	r19, 0x04	; 4
    7a48:	0e 94 1d 4f 	call	0x9e3a	; 0x9e3a <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7a4c:	1f 82       	std	Y+7, r1	; 0x07
    7a4e:	18 86       	std	Y+8, r1	; 0x08
    7a50:	0b c0       	rjmp	.+22     	; 0x7a68 <SD_write_and_read_knowns+0xee>
    7a52:	8f 81       	ldd	r24, Y+7	; 0x07
    7a54:	98 85       	ldd	r25, Y+8	; 0x08
    7a56:	88 52       	subi	r24, 0x28	; 40
    7a58:	9c 4d       	sbci	r25, 0xDC	; 220
    7a5a:	fc 01       	movw	r30, r24
    7a5c:	10 82       	st	Z, r1
    7a5e:	8f 81       	ldd	r24, Y+7	; 0x07
    7a60:	98 85       	ldd	r25, Y+8	; 0x08
    7a62:	01 96       	adiw	r24, 0x01	; 1
    7a64:	8f 83       	std	Y+7, r24	; 0x07
    7a66:	98 87       	std	Y+8, r25	; 0x08
    7a68:	8f 81       	ldd	r24, Y+7	; 0x07
    7a6a:	98 85       	ldd	r25, Y+8	; 0x08
    7a6c:	f4 e0       	ldi	r31, 0x04	; 4
    7a6e:	82 3e       	cpi	r24, 0xE2	; 226
    7a70:	9f 07       	cpc	r25, r31
    7a72:	7c f3       	brlt	.-34     	; 0x7a52 <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7a74:	28 ed       	ldi	r18, 0xD8	; 216
    7a76:	33 e2       	ldi	r19, 0x23	; 35
    7a78:	60 e5       	ldi	r22, 0x50	; 80
    7a7a:	70 e0       	ldi	r23, 0x00	; 0
    7a7c:	80 e0       	ldi	r24, 0x00	; 0
    7a7e:	90 e0       	ldi	r25, 0x00	; 0
    7a80:	a9 01       	movw	r20, r18
    7a82:	23 e0       	ldi	r18, 0x03	; 3
    7a84:	30 e0       	ldi	r19, 0x00	; 0
    7a86:	0e 94 7b 50 	call	0xa0f6	; 0xa0f6 <SD_read_multiple_blocks>
}
    7a8a:	28 96       	adiw	r28, 0x08	; 8
    7a8c:	cd bf       	out	0x3d, r28	; 61
    7a8e:	de bf       	out	0x3e, r29	; 62
    7a90:	df 91       	pop	r29
    7a92:	cf 91       	pop	r28
    7a94:	08 95       	ret

00007a96 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7a96:	cf 93       	push	r28
    7a98:	df 93       	push	r29
    7a9a:	00 d0       	rcall	.+0      	; 0x7a9c <SD_write_and_read_knowns_FAT+0x6>
    7a9c:	0f 92       	push	r0
    7a9e:	cd b7       	in	r28, 0x3d	; 61
    7aa0:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7aa2:	19 82       	std	Y+1, r1	; 0x01
    7aa4:	1a 82       	std	Y+2, r1	; 0x02
    7aa6:	0c c0       	rjmp	.+24     	; 0x7ac0 <SD_write_and_read_knowns_FAT+0x2a>
    7aa8:	29 81       	ldd	r18, Y+1	; 0x01
    7aaa:	89 81       	ldd	r24, Y+1	; 0x01
    7aac:	9a 81       	ldd	r25, Y+2	; 0x02
    7aae:	88 52       	subi	r24, 0x28	; 40
    7ab0:	9c 4d       	sbci	r25, 0xDC	; 220
    7ab2:	fc 01       	movw	r30, r24
    7ab4:	20 83       	st	Z, r18
    7ab6:	89 81       	ldd	r24, Y+1	; 0x01
    7ab8:	9a 81       	ldd	r25, Y+2	; 0x02
    7aba:	01 96       	adiw	r24, 0x01	; 1
    7abc:	89 83       	std	Y+1, r24	; 0x01
    7abe:	9a 83       	std	Y+2, r25	; 0x02
    7ac0:	89 81       	ldd	r24, Y+1	; 0x01
    7ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    7ac4:	88 31       	cpi	r24, 0x18	; 24
    7ac6:	91 05       	cpc	r25, r1
    7ac8:	7c f3       	brlt	.-34     	; 0x7aa8 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",FRAMReadBuffer,512);
    7aca:	81 e1       	ldi	r24, 0x11	; 17
    7acc:	90 e2       	ldi	r25, 0x20	; 32
    7ace:	28 ed       	ldi	r18, 0xD8	; 216
    7ad0:	33 e2       	ldi	r19, 0x23	; 35
    7ad2:	b9 01       	movw	r22, r18
    7ad4:	20 e0       	ldi	r18, 0x00	; 0
    7ad6:	32 e0       	ldi	r19, 0x02	; 2
    7ad8:	40 e0       	ldi	r20, 0x00	; 0
    7ada:	50 e0       	ldi	r21, 0x00	; 0
    7adc:	0e 94 c7 45 	call	0x8b8e	; 0x8b8e <writeFile>
    7ae0:	80 93 a4 50 	sts	0x50A4, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7ae4:	1b 82       	std	Y+3, r1	; 0x03
    7ae6:	1c 82       	std	Y+4, r1	; 0x04
    7ae8:	0b c0       	rjmp	.+22     	; 0x7b00 <SD_write_and_read_knowns_FAT+0x6a>
    7aea:	8b 81       	ldd	r24, Y+3	; 0x03
    7aec:	9c 81       	ldd	r25, Y+4	; 0x04
    7aee:	88 52       	subi	r24, 0x28	; 40
    7af0:	9c 4d       	sbci	r25, 0xDC	; 220
    7af2:	fc 01       	movw	r30, r24
    7af4:	10 82       	st	Z, r1
    7af6:	8b 81       	ldd	r24, Y+3	; 0x03
    7af8:	9c 81       	ldd	r25, Y+4	; 0x04
    7afa:	01 96       	adiw	r24, 0x01	; 1
    7afc:	8b 83       	std	Y+3, r24	; 0x03
    7afe:	9c 83       	std	Y+4, r25	; 0x04
    7b00:	8b 81       	ldd	r24, Y+3	; 0x03
    7b02:	9c 81       	ldd	r25, Y+4	; 0x04
    7b04:	88 31       	cpi	r24, 0x18	; 24
    7b06:	91 05       	cpc	r25, r1
    7b08:	84 f3       	brlt	.-32     	; 0x7aea <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    7b0a:	21 e1       	ldi	r18, 0x11	; 17
    7b0c:	30 e2       	ldi	r19, 0x20	; 32
    7b0e:	80 e0       	ldi	r24, 0x00	; 0
    7b10:	b9 01       	movw	r22, r18
    7b12:	0e 94 e2 43 	call	0x87c4	; 0x87c4 <readFile>
    7b16:	80 93 a4 50 	sts	0x50A4, r24
}
    7b1a:	24 96       	adiw	r28, 0x04	; 4
    7b1c:	cd bf       	out	0x3d, r28	; 61
    7b1e:	de bf       	out	0x3e, r29	; 62
    7b20:	df 91       	pop	r29
    7b22:	cf 91       	pop	r28
    7b24:	08 95       	ret

00007b26 <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    7b26:	cf 93       	push	r28
    7b28:	df 93       	push	r29
    7b2a:	cd b7       	in	r28, 0x3d	; 61
    7b2c:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7b2e:	0e 94 bf 1d 	call	0x3b7e	; 0x3b7e <chb_init>
	chb_set_short_addr(0x0002);
    7b32:	82 e0       	ldi	r24, 0x02	; 2
    7b34:	90 e0       	ldi	r25, 0x00	; 0
    7b36:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7b3a:	00 00       	nop
    7b3c:	fe cf       	rjmp	.-4      	; 0x7b3a <chibi_test_radio+0x14>

00007b3e <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    7b3e:	cf 93       	push	r28
    7b40:	df 93       	push	r29
    7b42:	0f 92       	push	r0
    7b44:	0f 92       	push	r0
    7b46:	cd b7       	in	r28, 0x3d	; 61
    7b48:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    7b4a:	0e 94 32 4b 	call	0x9664	; 0x9664 <SD_init>
	getBootSectorData();
    7b4e:	0e 94 32 3f 	call	0x7e64	; 0x7e64 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7b52:	19 82       	std	Y+1, r1	; 0x01
    7b54:	1a 82       	std	Y+2, r1	; 0x02
    7b56:	13 c0       	rjmp	.+38     	; 0x7b7e <TestCard+0x40>
    7b58:	89 81       	ldd	r24, Y+1	; 0x01
    7b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    7b5c:	29 e7       	ldi	r18, 0x79	; 121
    7b5e:	30 e0       	ldi	r19, 0x00	; 0
    7b60:	b9 01       	movw	r22, r18
    7b62:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    7b66:	28 2f       	mov	r18, r24
    7b68:	89 81       	ldd	r24, Y+1	; 0x01
    7b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    7b6c:	88 52       	subi	r24, 0x28	; 40
    7b6e:	9c 4d       	sbci	r25, 0xDC	; 220
    7b70:	fc 01       	movw	r30, r24
    7b72:	20 83       	st	Z, r18
    7b74:	89 81       	ldd	r24, Y+1	; 0x01
    7b76:	9a 81       	ldd	r25, Y+2	; 0x02
    7b78:	01 96       	adiw	r24, 0x01	; 1
    7b7a:	89 83       	std	Y+1, r24	; 0x01
    7b7c:	9a 83       	std	Y+2, r25	; 0x02
    7b7e:	89 81       	ldd	r24, Y+1	; 0x01
    7b80:	9a 81       	ldd	r25, Y+2	; 0x02
    7b82:	f2 e0       	ldi	r31, 0x02	; 2
    7b84:	80 30       	cpi	r24, 0x00	; 0
    7b86:	9f 07       	cpc	r25, r31
    7b88:	3c f3       	brlt	.-50     	; 0x7b58 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",FRAMReadBuffer,512);//}
    7b8a:	81 e1       	ldi	r24, 0x11	; 17
    7b8c:	90 e2       	ldi	r25, 0x20	; 32
    7b8e:	28 ed       	ldi	r18, 0xD8	; 216
    7b90:	33 e2       	ldi	r19, 0x23	; 35
    7b92:	b9 01       	movw	r22, r18
    7b94:	20 e0       	ldi	r18, 0x00	; 0
    7b96:	32 e0       	ldi	r19, 0x02	; 2
    7b98:	40 e0       	ldi	r20, 0x00	; 0
    7b9a:	50 e0       	ldi	r21, 0x00	; 0
    7b9c:	0e 94 c7 45 	call	0x8b8e	; 0x8b8e <writeFile>
	nop();
    7ba0:	00 00       	nop
}
    7ba2:	0f 90       	pop	r0
    7ba4:	0f 90       	pop	r0
    7ba6:	df 91       	pop	r29
    7ba8:	cf 91       	pop	r28
    7baa:	08 95       	ret

00007bac <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    7bac:	1f 92       	push	r1
    7bae:	0f 92       	push	r0
    7bb0:	0f b6       	in	r0, 0x3f	; 63
    7bb2:	0f 92       	push	r0
    7bb4:	00 90 3b 00 	lds	r0, 0x003B
    7bb8:	0f 92       	push	r0
    7bba:	11 24       	eor	r1, r1
    7bbc:	2f 93       	push	r18
    7bbe:	3f 93       	push	r19
    7bc0:	4f 93       	push	r20
    7bc2:	5f 93       	push	r21
    7bc4:	6f 93       	push	r22
    7bc6:	7f 93       	push	r23
    7bc8:	8f 93       	push	r24
    7bca:	9f 93       	push	r25
    7bcc:	af 93       	push	r26
    7bce:	bf 93       	push	r27
    7bd0:	ef 93       	push	r30
    7bd2:	ff 93       	push	r31
    7bd4:	cf 93       	push	r28
    7bd6:	df 93       	push	r29
    7bd8:	cd b7       	in	r28, 0x3d	; 61
    7bda:	de b7       	in	r29, 0x3e	; 62
    7bdc:	c4 58       	subi	r28, 0x84	; 132
    7bde:	d0 40       	sbci	r29, 0x00	; 0
    7be0:	cd bf       	out	0x3d, r28	; 61
    7be2:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    7be4:	80 91 5f 40 	lds	r24, 0x405F
    7be8:	88 2f       	mov	r24, r24
    7bea:	90 e0       	ldi	r25, 0x00	; 0
    7bec:	81 30       	cpi	r24, 0x01	; 1
    7bee:	91 05       	cpc	r25, r1
    7bf0:	29 f0       	breq	.+10     	; 0x7bfc <__vector_43+0x50>
    7bf2:	82 30       	cpi	r24, 0x02	; 2
    7bf4:	91 05       	cpc	r25, r1
    7bf6:	09 f4       	brne	.+2      	; 0x7bfa <__vector_43+0x4e>
    7bf8:	73 c0       	rjmp	.+230    	; 0x7ce0 <__vector_43+0x134>
    7bfa:	91 c0       	rjmp	.+290    	; 0x7d1e <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    7bfc:	ce 01       	movw	r24, r28
    7bfe:	05 96       	adiw	r24, 0x05	; 5
    7c00:	0e 94 11 20 	call	0x4022	; 0x4022 <chb_read>
			if(!strncmp(msg,"reset",5)){
    7c04:	ce 01       	movw	r24, r28
    7c06:	05 96       	adiw	r24, 0x05	; 5
    7c08:	29 e1       	ldi	r18, 0x19	; 25
    7c0a:	30 e2       	ldi	r19, 0x20	; 32
    7c0c:	b9 01       	movw	r22, r18
    7c0e:	45 e0       	ldi	r20, 0x05	; 5
    7c10:	50 e0       	ldi	r21, 0x00	; 0
    7c12:	0e 94 e6 62 	call	0xc5cc	; 0xc5cc <strncmp>
    7c16:	00 97       	sbiw	r24, 0x00	; 0
    7c18:	51 f4       	brne	.+20     	; 0x7c2e <__vector_43+0x82>
				MotesReadyToSynch++;
    7c1a:	80 91 79 50 	lds	r24, 0x5079
    7c1e:	90 91 7a 50 	lds	r25, 0x507A
    7c22:	01 96       	adiw	r24, 0x01	; 1
    7c24:	80 93 79 50 	sts	0x5079, r24
    7c28:	90 93 7a 50 	sts	0x507A, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7c2c:	7a c0       	rjmp	.+244    	; 0x7d22 <__vector_43+0x176>
			if(!strncmp(msg,"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    7c2e:	19 82       	std	Y+1, r1	; 0x01
    7c30:	1a 82       	std	Y+2, r1	; 0x02
    7c32:	1b 82       	std	Y+3, r1	; 0x03
    7c34:	1c 82       	std	Y+4, r1	; 0x04
    7c36:	1a c0       	rjmp	.+52     	; 0x7c6c <__vector_43+0xc0>
    7c38:	9e 01       	movw	r18, r28
    7c3a:	2b 5f       	subi	r18, 0xFB	; 251
    7c3c:	3f 4f       	sbci	r19, 0xFF	; 255
    7c3e:	89 81       	ldd	r24, Y+1	; 0x01
    7c40:	9a 81       	ldd	r25, Y+2	; 0x02
    7c42:	82 0f       	add	r24, r18
    7c44:	93 1f       	adc	r25, r19
    7c46:	fc 01       	movw	r30, r24
    7c48:	20 81       	ld	r18, Z
    7c4a:	89 81       	ldd	r24, Y+1	; 0x01
    7c4c:	9a 81       	ldd	r25, Y+2	; 0x02
    7c4e:	88 52       	subi	r24, 0x28	; 40
    7c50:	9c 4d       	sbci	r25, 0xDC	; 220
    7c52:	fc 01       	movw	r30, r24
    7c54:	20 83       	st	Z, r18
    7c56:	89 81       	ldd	r24, Y+1	; 0x01
    7c58:	9a 81       	ldd	r25, Y+2	; 0x02
    7c5a:	ab 81       	ldd	r26, Y+3	; 0x03
    7c5c:	bc 81       	ldd	r27, Y+4	; 0x04
    7c5e:	01 96       	adiw	r24, 0x01	; 1
    7c60:	a1 1d       	adc	r26, r1
    7c62:	b1 1d       	adc	r27, r1
    7c64:	89 83       	std	Y+1, r24	; 0x01
    7c66:	9a 83       	std	Y+2, r25	; 0x02
    7c68:	ab 83       	std	Y+3, r26	; 0x03
    7c6a:	bc 83       	std	Y+4, r27	; 0x04
    7c6c:	89 81       	ldd	r24, Y+1	; 0x01
    7c6e:	9a 81       	ldd	r25, Y+2	; 0x02
    7c70:	ab 81       	ldd	r26, Y+3	; 0x03
    7c72:	bc 81       	ldd	r27, Y+4	; 0x04
    7c74:	80 38       	cpi	r24, 0x80	; 128
    7c76:	91 05       	cpc	r25, r1
    7c78:	a1 05       	cpc	r26, r1
    7c7a:	b1 05       	cpc	r27, r1
    7c7c:	e8 f2       	brcs	.-70     	; 0x7c38 <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    7c7e:	80 91 cb 50 	lds	r24, 0x50CB
    7c82:	90 91 cc 50 	lds	r25, 0x50CC
    7c86:	a0 91 cd 50 	lds	r26, 0x50CD
    7c8a:	b0 91 ce 50 	lds	r27, 0x50CE
    7c8e:	80 58       	subi	r24, 0x80	; 128
    7c90:	9f 4f       	sbci	r25, 0xFF	; 255
    7c92:	af 4f       	sbci	r26, 0xFF	; 255
    7c94:	bf 4f       	sbci	r27, 0xFF	; 255
    7c96:	80 93 cb 50 	sts	0x50CB, r24
    7c9a:	90 93 cc 50 	sts	0x50CC, r25
    7c9e:	a0 93 cd 50 	sts	0x50CD, r26
    7ca2:	b0 93 ce 50 	sts	0x50CE, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    7ca6:	80 91 cb 50 	lds	r24, 0x50CB
    7caa:	90 91 cc 50 	lds	r25, 0x50CC
    7cae:	a0 91 cd 50 	lds	r26, 0x50CD
    7cb2:	b0 91 ce 50 	lds	r27, 0x50CE
    7cb6:	80 58       	subi	r24, 0x80	; 128
    7cb8:	9f 4f       	sbci	r25, 0xFF	; 255
    7cba:	af 4f       	sbci	r26, 0xFF	; 255
    7cbc:	bf 4f       	sbci	r27, 0xFF	; 255
    7cbe:	81 37       	cpi	r24, 0x71	; 113
    7cc0:	fc e1       	ldi	r31, 0x1C	; 28
    7cc2:	9f 07       	cpc	r25, r31
    7cc4:	f0 e0       	ldi	r31, 0x00	; 0
    7cc6:	af 07       	cpc	r26, r31
    7cc8:	f0 e0       	ldi	r31, 0x00	; 0
    7cca:	bf 07       	cpc	r27, r31
    7ccc:	50 f1       	brcs	.+84     	; 0x7d22 <__vector_43+0x176>
    7cce:	10 92 cb 50 	sts	0x50CB, r1
    7cd2:	10 92 cc 50 	sts	0x50CC, r1
    7cd6:	10 92 cd 50 	sts	0x50CD, r1
    7cda:	10 92 ce 50 	sts	0x50CE, r1
			}			
			break;
    7cde:	21 c0       	rjmp	.+66     	; 0x7d22 <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    7ce0:	ce 01       	movw	r24, r28
    7ce2:	05 96       	adiw	r24, 0x05	; 5
    7ce4:	0e 94 11 20 	call	0x4022	; 0x4022 <chb_read>
			if(!strncmp(msg,"start sampling",14)){	//if basestation synch response message received, do the following
    7ce8:	ce 01       	movw	r24, r28
    7cea:	05 96       	adiw	r24, 0x05	; 5
    7cec:	2f e1       	ldi	r18, 0x1F	; 31
    7cee:	30 e2       	ldi	r19, 0x20	; 32
    7cf0:	b9 01       	movw	r22, r18
    7cf2:	4e e0       	ldi	r20, 0x0E	; 14
    7cf4:	50 e0       	ldi	r21, 0x00	; 0
    7cf6:	0e 94 e6 62 	call	0xc5cc	; 0xc5cc <strncmp>
    7cfa:	00 97       	sbiw	r24, 0x00	; 0
    7cfc:	a1 f4       	brne	.+40     	; 0x7d26 <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    7cfe:	83 e0       	ldi	r24, 0x03	; 3
    7d00:	80 93 5f 40 	sts	0x405F, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    7d04:	80 e4       	ldi	r24, 0x40	; 64
    7d06:	99 e0       	ldi	r25, 0x09	; 9
    7d08:	29 e0       	ldi	r18, 0x09	; 9
    7d0a:	fc 01       	movw	r30, r24
    7d0c:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    7d0e:	80 e4       	ldi	r24, 0x40	; 64
    7d10:	98 e0       	ldi	r25, 0x08	; 8
    7d12:	21 e0       	ldi	r18, 0x01	; 1
    7d14:	fc 01       	movw	r30, r24
    7d16:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    7d18:	0e 94 45 0a 	call	0x148a	; 0x148a <ADC_Resume_Sampling>
			}
			break;
    7d1c:	04 c0       	rjmp	.+8      	; 0x7d26 <__vector_43+0x17a>
		default:
			break;
    7d1e:	00 00       	nop
    7d20:	03 c0       	rjmp	.+6      	; 0x7d28 <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7d22:	00 00       	nop
    7d24:	01 c0       	rjmp	.+2      	; 0x7d28 <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    7d26:	00 00       	nop
		default:
			break;
	}
}
    7d28:	cc 57       	subi	r28, 0x7C	; 124
    7d2a:	df 4f       	sbci	r29, 0xFF	; 255
    7d2c:	cd bf       	out	0x3d, r28	; 61
    7d2e:	de bf       	out	0x3e, r29	; 62
    7d30:	df 91       	pop	r29
    7d32:	cf 91       	pop	r28
    7d34:	ff 91       	pop	r31
    7d36:	ef 91       	pop	r30
    7d38:	bf 91       	pop	r27
    7d3a:	af 91       	pop	r26
    7d3c:	9f 91       	pop	r25
    7d3e:	8f 91       	pop	r24
    7d40:	7f 91       	pop	r23
    7d42:	6f 91       	pop	r22
    7d44:	5f 91       	pop	r21
    7d46:	4f 91       	pop	r20
    7d48:	3f 91       	pop	r19
    7d4a:	2f 91       	pop	r18
    7d4c:	0f 90       	pop	r0
    7d4e:	00 92 3b 00 	sts	0x003B, r0
    7d52:	0f 90       	pop	r0
    7d54:	0f be       	out	0x3f, r0	; 63
    7d56:	0f 90       	pop	r0
    7d58:	1f 90       	pop	r1
    7d5a:	18 95       	reti

00007d5c <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    7d5c:	cf 93       	push	r28
    7d5e:	df 93       	push	r29
    7d60:	cd b7       	in	r28, 0x3d	; 61
    7d62:	de b7       	in	r29, 0x3e	; 62
    7d64:	a0 97       	sbiw	r28, 0x20	; 32
    7d66:	cd bf       	out	0x3d, r28	; 61
    7d68:	de bf       	out	0x3e, r29	; 62
    7d6a:	89 8f       	std	Y+25, r24	; 0x19
    7d6c:	9a 8f       	std	Y+26, r25	; 0x1a
    7d6e:	4b 8f       	std	Y+27, r20	; 0x1b
    7d70:	5c 8f       	std	Y+28, r21	; 0x1c
    7d72:	6d 8f       	std	Y+29, r22	; 0x1d
    7d74:	7e 8f       	std	Y+30, r23	; 0x1e
    7d76:	2f 8f       	std	Y+31, r18	; 0x1f
    7d78:	38 a3       	lds	r19, 0x58
	char b[20];
	uint32_t i;
	ReturnString[0] = 0;
    7d7a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7d7c:	98 a1       	lds	r25, 0x48
    7d7e:	fc 01       	movw	r30, r24
    7d80:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    7d82:	19 82       	std	Y+1, r1	; 0x01
    7d84:	1a 82       	std	Y+2, r1	; 0x02
    7d86:	1b 82       	std	Y+3, r1	; 0x03
    7d88:	1c 82       	std	Y+4, r1	; 0x04
    7d8a:	58 c0       	rjmp	.+176    	; 0x7e3c <DeciToString+0xe0>
		sprintf(b,"%d",DecimalArray[i]);
    7d8c:	89 81       	ldd	r24, Y+1	; 0x01
    7d8e:	9a 81       	ldd	r25, Y+2	; 0x02
    7d90:	88 0f       	add	r24, r24
    7d92:	99 1f       	adc	r25, r25
    7d94:	88 0f       	add	r24, r24
    7d96:	99 1f       	adc	r25, r25
    7d98:	29 8d       	ldd	r18, Y+25	; 0x19
    7d9a:	3a 8d       	ldd	r19, Y+26	; 0x1a
    7d9c:	82 0f       	add	r24, r18
    7d9e:	93 1f       	adc	r25, r19
    7da0:	fc 01       	movw	r30, r24
    7da2:	80 81       	ld	r24, Z
    7da4:	91 81       	ldd	r25, Z+1	; 0x01
    7da6:	a2 81       	ldd	r26, Z+2	; 0x02
    7da8:	b3 81       	ldd	r27, Z+3	; 0x03
    7daa:	2d b7       	in	r18, 0x3d	; 61
    7dac:	3e b7       	in	r19, 0x3e	; 62
    7dae:	28 50       	subi	r18, 0x08	; 8
    7db0:	30 40       	sbci	r19, 0x00	; 0
    7db2:	2d bf       	out	0x3d, r18	; 61
    7db4:	3e bf       	out	0x3e, r19	; 62
    7db6:	2d b7       	in	r18, 0x3d	; 61
    7db8:	3e b7       	in	r19, 0x3e	; 62
    7dba:	2f 5f       	subi	r18, 0xFF	; 255
    7dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    7dbe:	ae 01       	movw	r20, r28
    7dc0:	4b 5f       	subi	r20, 0xFB	; 251
    7dc2:	5f 4f       	sbci	r21, 0xFF	; 255
    7dc4:	f9 01       	movw	r30, r18
    7dc6:	40 83       	st	Z, r20
    7dc8:	51 83       	std	Z+1, r21	; 0x01
    7dca:	4e e2       	ldi	r20, 0x2E	; 46
    7dcc:	50 e2       	ldi	r21, 0x20	; 32
    7dce:	f9 01       	movw	r30, r18
    7dd0:	42 83       	std	Z+2, r20	; 0x02
    7dd2:	53 83       	std	Z+3, r21	; 0x03
    7dd4:	f9 01       	movw	r30, r18
    7dd6:	84 83       	std	Z+4, r24	; 0x04
    7dd8:	95 83       	std	Z+5, r25	; 0x05
    7dda:	a6 83       	std	Z+6, r26	; 0x06
    7ddc:	b7 83       	std	Z+7, r27	; 0x07
    7dde:	0e 94 27 63 	call	0xc64e	; 0xc64e <sprintf>
    7de2:	2d b7       	in	r18, 0x3d	; 61
    7de4:	3e b7       	in	r19, 0x3e	; 62
    7de6:	28 5f       	subi	r18, 0xF8	; 248
    7de8:	3f 4f       	sbci	r19, 0xFF	; 255
    7dea:	2d bf       	out	0x3d, r18	; 61
    7dec:	3e bf       	out	0x3e, r19	; 62
		strcat(ReturnString,b);
    7dee:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7df0:	98 a1       	lds	r25, 0x48
    7df2:	9e 01       	movw	r18, r28
    7df4:	2b 5f       	subi	r18, 0xFB	; 251
    7df6:	3f 4f       	sbci	r19, 0xFF	; 255
    7df8:	b9 01       	movw	r22, r18
    7dfa:	0e 94 db 62 	call	0xc5b6	; 0xc5b6 <strcat>
		//add a space between each value
		strcat(ReturnString," ");
    7dfe:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7e00:	98 a1       	lds	r25, 0x48
    7e02:	9c 01       	movw	r18, r24
    7e04:	f9 01       	movw	r30, r18
    7e06:	01 90       	ld	r0, Z+
    7e08:	00 20       	and	r0, r0
    7e0a:	e9 f7       	brne	.-6      	; 0x7e06 <DeciToString+0xaa>
    7e0c:	cf 01       	movw	r24, r30
    7e0e:	01 97       	sbiw	r24, 0x01	; 1
    7e10:	82 1b       	sub	r24, r18
    7e12:	93 0b       	sbc	r25, r19
    7e14:	2f 8d       	ldd	r18, Y+31	; 0x1f
    7e16:	38 a1       	lds	r19, 0x48
    7e18:	82 0f       	add	r24, r18
    7e1a:	93 1f       	adc	r25, r19
    7e1c:	20 e2       	ldi	r18, 0x20	; 32
    7e1e:	30 e0       	ldi	r19, 0x00	; 0
    7e20:	fc 01       	movw	r30, r24
    7e22:	20 83       	st	Z, r18
    7e24:	31 83       	std	Z+1, r19	; 0x01

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    7e26:	89 81       	ldd	r24, Y+1	; 0x01
    7e28:	9a 81       	ldd	r25, Y+2	; 0x02
    7e2a:	ab 81       	ldd	r26, Y+3	; 0x03
    7e2c:	bc 81       	ldd	r27, Y+4	; 0x04
    7e2e:	01 96       	adiw	r24, 0x01	; 1
    7e30:	a1 1d       	adc	r26, r1
    7e32:	b1 1d       	adc	r27, r1
    7e34:	89 83       	std	Y+1, r24	; 0x01
    7e36:	9a 83       	std	Y+2, r25	; 0x02
    7e38:	ab 83       	std	Y+3, r26	; 0x03
    7e3a:	bc 83       	std	Y+4, r27	; 0x04
    7e3c:	29 81       	ldd	r18, Y+1	; 0x01
    7e3e:	3a 81       	ldd	r19, Y+2	; 0x02
    7e40:	4b 81       	ldd	r20, Y+3	; 0x03
    7e42:	5c 81       	ldd	r21, Y+4	; 0x04
    7e44:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7e46:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7e48:	ad 8d       	ldd	r26, Y+29	; 0x1d
    7e4a:	be 8d       	ldd	r27, Y+30	; 0x1e
    7e4c:	28 17       	cp	r18, r24
    7e4e:	39 07       	cpc	r19, r25
    7e50:	4a 07       	cpc	r20, r26
    7e52:	5b 07       	cpc	r21, r27
    7e54:	08 f4       	brcc	.+2      	; 0x7e58 <DeciToString+0xfc>
    7e56:	9a cf       	rjmp	.-204    	; 0x7d8c <DeciToString+0x30>
		sprintf(b,"%d",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString," ");
	}		
    7e58:	a0 96       	adiw	r28, 0x20	; 32
    7e5a:	cd bf       	out	0x3d, r28	; 61
    7e5c:	de bf       	out	0x3e, r29	; 62
    7e5e:	df 91       	pop	r29
    7e60:	cf 91       	pop	r28
    7e62:	08 95       	ret

00007e64 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    7e64:	ef 92       	push	r14
    7e66:	ff 92       	push	r15
    7e68:	0f 93       	push	r16
    7e6a:	1f 93       	push	r17
    7e6c:	cf 93       	push	r28
    7e6e:	df 93       	push	r29
    7e70:	cd b7       	in	r28, 0x3d	; 61
    7e72:	de b7       	in	r29, 0x3e	; 62
    7e74:	2a 97       	sbiw	r28, 0x0a	; 10
    7e76:	cd bf       	out	0x3d, r28	; 61
    7e78:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    7e7a:	10 92 7e 50 	sts	0x507E, r1
    7e7e:	10 92 7f 50 	sts	0x507F, r1
    7e82:	10 92 80 50 	sts	0x5080, r1
    7e86:	10 92 81 50 	sts	0x5081, r1

SD_read_block(0,SDBuffer);
    7e8a:	2f ec       	ldi	r18, 0xCF	; 207
    7e8c:	31 e2       	ldi	r19, 0x21	; 33
    7e8e:	60 e0       	ldi	r22, 0x00	; 0
    7e90:	70 e0       	ldi	r23, 0x00	; 0
    7e92:	cb 01       	movw	r24, r22
    7e94:	a9 01       	movw	r20, r18
    7e96:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    7e9a:	8f ec       	ldi	r24, 0xCF	; 207
    7e9c:	91 e2       	ldi	r25, 0x21	; 33
    7e9e:	89 83       	std	Y+1, r24	; 0x01
    7ea0:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    7ea2:	89 81       	ldd	r24, Y+1	; 0x01
    7ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    7ea6:	fc 01       	movw	r30, r24
    7ea8:	80 81       	ld	r24, Z
    7eaa:	89 3e       	cpi	r24, 0xE9	; 233
    7eac:	09 f4       	brne	.+2      	; 0x7eb0 <getBootSectorData+0x4c>
    7eae:	4d c0       	rjmp	.+154    	; 0x7f4a <getBootSectorData+0xe6>
    7eb0:	89 81       	ldd	r24, Y+1	; 0x01
    7eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    7eb4:	fc 01       	movw	r30, r24
    7eb6:	80 81       	ld	r24, Z
    7eb8:	8b 3e       	cpi	r24, 0xEB	; 235
    7eba:	09 f4       	brne	.+2      	; 0x7ebe <getBootSectorData+0x5a>
    7ebc:	46 c0       	rjmp	.+140    	; 0x7f4a <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    7ebe:	8f ec       	ldi	r24, 0xCF	; 207
    7ec0:	91 e2       	ldi	r25, 0x21	; 33
    7ec2:	8b 83       	std	Y+3, r24	; 0x03
    7ec4:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    7ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    7ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    7eca:	82 50       	subi	r24, 0x02	; 2
    7ecc:	9e 4f       	sbci	r25, 0xFE	; 254
    7ece:	fc 01       	movw	r30, r24
    7ed0:	80 81       	ld	r24, Z
    7ed2:	91 81       	ldd	r25, Z+1	; 0x01
    7ed4:	fa ea       	ldi	r31, 0xAA	; 170
    7ed6:	85 35       	cpi	r24, 0x55	; 85
    7ed8:	9f 07       	cpc	r25, r31
    7eda:	11 f0       	breq	.+4      	; 0x7ee0 <getBootSectorData+0x7c>
    7edc:	81 e0       	ldi	r24, 0x01	; 1
    7ede:	01 c1       	rjmp	.+514    	; 0x80e2 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    7ee0:	8b 81       	ldd	r24, Y+3	; 0x03
    7ee2:	9c 81       	ldd	r25, Y+4	; 0x04
    7ee4:	82 54       	subi	r24, 0x42	; 66
    7ee6:	9e 4f       	sbci	r25, 0xFE	; 254
    7ee8:	8d 83       	std	Y+5, r24	; 0x05
    7eea:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    7eec:	8d 81       	ldd	r24, Y+5	; 0x05
    7eee:	9e 81       	ldd	r25, Y+6	; 0x06
    7ef0:	fc 01       	movw	r30, r24
    7ef2:	80 85       	ldd	r24, Z+8	; 0x08
    7ef4:	91 85       	ldd	r25, Z+9	; 0x09
    7ef6:	a2 85       	ldd	r26, Z+10	; 0x0a
    7ef8:	b3 85       	ldd	r27, Z+11	; 0x0b
    7efa:	80 93 7e 50 	sts	0x507E, r24
    7efe:	90 93 7f 50 	sts	0x507F, r25
    7f02:	a0 93 80 50 	sts	0x5080, r26
    7f06:	b0 93 81 50 	sts	0x5081, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    7f0a:	8d 81       	ldd	r24, Y+5	; 0x05
    7f0c:	9e 81       	ldd	r25, Y+6	; 0x06
    7f0e:	fc 01       	movw	r30, r24
    7f10:	80 85       	ldd	r24, Z+8	; 0x08
    7f12:	91 85       	ldd	r25, Z+9	; 0x09
    7f14:	a2 85       	ldd	r26, Z+10	; 0x0a
    7f16:	b3 85       	ldd	r27, Z+11	; 0x0b
    7f18:	2f ec       	ldi	r18, 0xCF	; 207
    7f1a:	31 e2       	ldi	r19, 0x21	; 33
    7f1c:	bc 01       	movw	r22, r24
    7f1e:	cd 01       	movw	r24, r26
    7f20:	a9 01       	movw	r20, r18
    7f22:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    7f26:	8f ec       	ldi	r24, 0xCF	; 207
    7f28:	91 e2       	ldi	r25, 0x21	; 33
    7f2a:	89 83       	std	Y+1, r24	; 0x01
    7f2c:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    7f2e:	89 81       	ldd	r24, Y+1	; 0x01
    7f30:	9a 81       	ldd	r25, Y+2	; 0x02
    7f32:	fc 01       	movw	r30, r24
    7f34:	80 81       	ld	r24, Z
    7f36:	89 3e       	cpi	r24, 0xE9	; 233
    7f38:	41 f0       	breq	.+16     	; 0x7f4a <getBootSectorData+0xe6>
    7f3a:	89 81       	ldd	r24, Y+1	; 0x01
    7f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    7f3e:	fc 01       	movw	r30, r24
    7f40:	80 81       	ld	r24, Z
    7f42:	8b 3e       	cpi	r24, 0xEB	; 235
    7f44:	11 f0       	breq	.+4      	; 0x7f4a <getBootSectorData+0xe6>
    7f46:	81 e0       	ldi	r24, 0x01	; 1
    7f48:	cc c0       	rjmp	.+408    	; 0x80e2 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    7f4a:	89 81       	ldd	r24, Y+1	; 0x01
    7f4c:	9a 81       	ldd	r25, Y+2	; 0x02
    7f4e:	fc 01       	movw	r30, r24
    7f50:	83 85       	ldd	r24, Z+11	; 0x0b
    7f52:	94 85       	ldd	r25, Z+12	; 0x0c
    7f54:	80 93 4d 40 	sts	0x404D, r24
    7f58:	90 93 4e 40 	sts	0x404E, r25
sectorPerCluster = bpb->sectorPerCluster;
    7f5c:	89 81       	ldd	r24, Y+1	; 0x01
    7f5e:	9a 81       	ldd	r25, Y+2	; 0x02
    7f60:	fc 01       	movw	r30, r24
    7f62:	85 85       	ldd	r24, Z+13	; 0x0d
    7f64:	88 2f       	mov	r24, r24
    7f66:	90 e0       	ldi	r25, 0x00	; 0
    7f68:	80 93 7c 50 	sts	0x507C, r24
    7f6c:	90 93 7d 50 	sts	0x507D, r25
reservedSectorCount = bpb->reservedSectorCount;
    7f70:	89 81       	ldd	r24, Y+1	; 0x01
    7f72:	9a 81       	ldd	r25, Y+2	; 0x02
    7f74:	fc 01       	movw	r30, r24
    7f76:	86 85       	ldd	r24, Z+14	; 0x0e
    7f78:	97 85       	ldd	r25, Z+15	; 0x0f
    7f7a:	80 93 84 50 	sts	0x5084, r24
    7f7e:	90 93 85 50 	sts	0x5085, r25
rootCluster = bpb->rootCluster;
    7f82:	89 81       	ldd	r24, Y+1	; 0x01
    7f84:	9a 81       	ldd	r25, Y+2	; 0x02
    7f86:	fc 01       	movw	r30, r24
    7f88:	84 a5       	lds	r24, 0x64
    7f8a:	95 a5       	lds	r25, 0x65
    7f8c:	a6 a5       	lds	r26, 0x66
    7f8e:	b7 a5       	lds	r27, 0x67
    7f90:	80 93 60 40 	sts	0x4060, r24
    7f94:	90 93 61 40 	sts	0x4061, r25
    7f98:	a0 93 62 40 	sts	0x4062, r26
    7f9c:	b0 93 63 40 	sts	0x4063, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    7fa0:	89 81       	ldd	r24, Y+1	; 0x01
    7fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    7fa4:	fc 01       	movw	r30, r24
    7fa6:	24 8d       	ldd	r18, Z+28	; 0x1c
    7fa8:	35 8d       	ldd	r19, Z+29	; 0x1d
    7faa:	46 8d       	ldd	r20, Z+30	; 0x1e
    7fac:	57 8d       	ldd	r21, Z+31	; 0x1f
    7fae:	80 91 84 50 	lds	r24, 0x5084
    7fb2:	90 91 85 50 	lds	r25, 0x5085
    7fb6:	cc 01       	movw	r24, r24
    7fb8:	a0 e0       	ldi	r26, 0x00	; 0
    7fba:	b0 e0       	ldi	r27, 0x00	; 0
    7fbc:	79 01       	movw	r14, r18
    7fbe:	8a 01       	movw	r16, r20
    7fc0:	e8 0e       	add	r14, r24
    7fc2:	f9 1e       	adc	r15, r25
    7fc4:	0a 1f       	adc	r16, r26
    7fc6:	1b 1f       	adc	r17, r27
    7fc8:	89 81       	ldd	r24, Y+1	; 0x01
    7fca:	9a 81       	ldd	r25, Y+2	; 0x02
    7fcc:	fc 01       	movw	r30, r24
    7fce:	80 89       	ldd	r24, Z+16	; 0x10
    7fd0:	88 2f       	mov	r24, r24
    7fd2:	90 e0       	ldi	r25, 0x00	; 0
    7fd4:	a0 e0       	ldi	r26, 0x00	; 0
    7fd6:	b0 e0       	ldi	r27, 0x00	; 0
    7fd8:	29 81       	ldd	r18, Y+1	; 0x01
    7fda:	3a 81       	ldd	r19, Y+2	; 0x02
    7fdc:	f9 01       	movw	r30, r18
    7fde:	24 a1       	lds	r18, 0x44
    7fe0:	35 a1       	lds	r19, 0x45
    7fe2:	46 a1       	lds	r20, 0x46
    7fe4:	57 a1       	lds	r21, 0x47
    7fe6:	bc 01       	movw	r22, r24
    7fe8:	cd 01       	movw	r24, r26
    7fea:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    7fee:	dc 01       	movw	r26, r24
    7ff0:	cb 01       	movw	r24, r22
    7ff2:	8e 0d       	add	r24, r14
    7ff4:	9f 1d       	adc	r25, r15
    7ff6:	a0 1f       	adc	r26, r16
    7ff8:	b1 1f       	adc	r27, r17
    7ffa:	80 93 d4 23 	sts	0x23D4, r24
    7ffe:	90 93 d5 23 	sts	0x23D5, r25
    8002:	a0 93 d6 23 	sts	0x23D6, r26
    8006:	b0 93 d7 23 	sts	0x23D7, r27

dataSectors = bpb->totalSectors_F32
    800a:	89 81       	ldd	r24, Y+1	; 0x01
    800c:	9a 81       	ldd	r25, Y+2	; 0x02
    800e:	fc 01       	movw	r30, r24
    8010:	20 a1       	lds	r18, 0x40
    8012:	31 a1       	lds	r19, 0x41
    8014:	42 a1       	lds	r20, 0x42
    8016:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    8018:	89 81       	ldd	r24, Y+1	; 0x01
    801a:	9a 81       	ldd	r25, Y+2	; 0x02
    801c:	fc 01       	movw	r30, r24
    801e:	86 85       	ldd	r24, Z+14	; 0x0e
    8020:	97 85       	ldd	r25, Z+15	; 0x0f
    8022:	cc 01       	movw	r24, r24
    8024:	a0 e0       	ldi	r26, 0x00	; 0
    8026:	b0 e0       	ldi	r27, 0x00	; 0
    8028:	79 01       	movw	r14, r18
    802a:	8a 01       	movw	r16, r20
    802c:	e8 1a       	sub	r14, r24
    802e:	f9 0a       	sbc	r15, r25
    8030:	0a 0b       	sbc	r16, r26
    8032:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    8034:	89 81       	ldd	r24, Y+1	; 0x01
    8036:	9a 81       	ldd	r25, Y+2	; 0x02
    8038:	fc 01       	movw	r30, r24
    803a:	80 89       	ldd	r24, Z+16	; 0x10
    803c:	88 2f       	mov	r24, r24
    803e:	90 e0       	ldi	r25, 0x00	; 0
    8040:	a0 e0       	ldi	r26, 0x00	; 0
    8042:	b0 e0       	ldi	r27, 0x00	; 0
    8044:	29 81       	ldd	r18, Y+1	; 0x01
    8046:	3a 81       	ldd	r19, Y+2	; 0x02
    8048:	f9 01       	movw	r30, r18
    804a:	24 a1       	lds	r18, 0x44
    804c:	35 a1       	lds	r19, 0x45
    804e:	46 a1       	lds	r20, 0x46
    8050:	57 a1       	lds	r21, 0x47
    8052:	bc 01       	movw	r22, r24
    8054:	cd 01       	movw	r24, r26
    8056:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    805a:	dc 01       	movw	r26, r24
    805c:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    805e:	a8 01       	movw	r20, r16
    8060:	97 01       	movw	r18, r14
    8062:	28 1b       	sub	r18, r24
    8064:	39 0b       	sbc	r19, r25
    8066:	4a 0b       	sbc	r20, r26
    8068:	5b 0b       	sbc	r21, r27
    806a:	da 01       	movw	r26, r20
    806c:	c9 01       	movw	r24, r18
    806e:	8f 83       	std	Y+7, r24	; 0x07
    8070:	98 87       	std	Y+8, r25	; 0x08
    8072:	a9 87       	std	Y+9, r26	; 0x09
    8074:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    8076:	80 91 7c 50 	lds	r24, 0x507C
    807a:	90 91 7d 50 	lds	r25, 0x507D
    807e:	9c 01       	movw	r18, r24
    8080:	40 e0       	ldi	r20, 0x00	; 0
    8082:	50 e0       	ldi	r21, 0x00	; 0
    8084:	8f 81       	ldd	r24, Y+7	; 0x07
    8086:	98 85       	ldd	r25, Y+8	; 0x08
    8088:	a9 85       	ldd	r26, Y+9	; 0x09
    808a:	ba 85       	ldd	r27, Y+10	; 0x0a
    808c:	bc 01       	movw	r22, r24
    808e:	cd 01       	movw	r24, r26
    8090:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    8094:	da 01       	movw	r26, r20
    8096:	c9 01       	movw	r24, r18
    8098:	80 93 5a 40 	sts	0x405A, r24
    809c:	90 93 5b 40 	sts	0x405B, r25
    80a0:	a0 93 5c 40 	sts	0x405C, r26
    80a4:	b0 93 5d 40 	sts	0x405D, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    80a8:	81 e0       	ldi	r24, 0x01	; 1
    80aa:	60 e0       	ldi	r22, 0x00	; 0
    80ac:	20 e0       	ldi	r18, 0x00	; 0
    80ae:	30 e0       	ldi	r19, 0x00	; 0
    80b0:	a9 01       	movw	r20, r18
    80b2:	0e 94 57 41 	call	0x82ae	; 0x82ae <getSetFreeCluster>
    80b6:	9b 01       	movw	r18, r22
    80b8:	ac 01       	movw	r20, r24
    80ba:	80 91 5a 40 	lds	r24, 0x405A
    80be:	90 91 5b 40 	lds	r25, 0x405B
    80c2:	a0 91 5c 40 	lds	r26, 0x405C
    80c6:	b0 91 5d 40 	lds	r27, 0x405D
    80ca:	82 17       	cp	r24, r18
    80cc:	93 07       	cpc	r25, r19
    80ce:	a4 07       	cpc	r26, r20
    80d0:	b5 07       	cpc	r27, r21
    80d2:	18 f4       	brcc	.+6      	; 0x80da <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    80d4:	10 92 d0 50 	sts	0x50D0, r1
    80d8:	03 c0       	rjmp	.+6      	; 0x80e0 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    80da:	81 e0       	ldi	r24, 0x01	; 1
    80dc:	80 93 d0 50 	sts	0x50D0, r24
return 0;
    80e0:	80 e0       	ldi	r24, 0x00	; 0
}
    80e2:	2a 96       	adiw	r28, 0x0a	; 10
    80e4:	cd bf       	out	0x3d, r28	; 61
    80e6:	de bf       	out	0x3e, r29	; 62
    80e8:	df 91       	pop	r29
    80ea:	cf 91       	pop	r28
    80ec:	1f 91       	pop	r17
    80ee:	0f 91       	pop	r16
    80f0:	ff 90       	pop	r15
    80f2:	ef 90       	pop	r14
    80f4:	08 95       	ret

000080f6 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    80f6:	cf 93       	push	r28
    80f8:	df 93       	push	r29
    80fa:	00 d0       	rcall	.+0      	; 0x80fc <getFirstSector+0x6>
    80fc:	0f 92       	push	r0
    80fe:	cd b7       	in	r28, 0x3d	; 61
    8100:	de b7       	in	r29, 0x3e	; 62
    8102:	69 83       	std	Y+1, r22	; 0x01
    8104:	7a 83       	std	Y+2, r23	; 0x02
    8106:	8b 83       	std	Y+3, r24	; 0x03
    8108:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    810a:	89 81       	ldd	r24, Y+1	; 0x01
    810c:	9a 81       	ldd	r25, Y+2	; 0x02
    810e:	ab 81       	ldd	r26, Y+3	; 0x03
    8110:	bc 81       	ldd	r27, Y+4	; 0x04
    8112:	02 97       	sbiw	r24, 0x02	; 2
    8114:	a1 09       	sbc	r26, r1
    8116:	b1 09       	sbc	r27, r1
    8118:	20 91 7c 50 	lds	r18, 0x507C
    811c:	30 91 7d 50 	lds	r19, 0x507D
    8120:	99 01       	movw	r18, r18
    8122:	40 e0       	ldi	r20, 0x00	; 0
    8124:	50 e0       	ldi	r21, 0x00	; 0
    8126:	bc 01       	movw	r22, r24
    8128:	cd 01       	movw	r24, r26
    812a:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    812e:	9b 01       	movw	r18, r22
    8130:	ac 01       	movw	r20, r24
    8132:	80 91 d4 23 	lds	r24, 0x23D4
    8136:	90 91 d5 23 	lds	r25, 0x23D5
    813a:	a0 91 d6 23 	lds	r26, 0x23D6
    813e:	b0 91 d7 23 	lds	r27, 0x23D7
    8142:	82 0f       	add	r24, r18
    8144:	93 1f       	adc	r25, r19
    8146:	a4 1f       	adc	r26, r20
    8148:	b5 1f       	adc	r27, r21
}
    814a:	bc 01       	movw	r22, r24
    814c:	cd 01       	movw	r24, r26
    814e:	24 96       	adiw	r28, 0x04	; 4
    8150:	cd bf       	out	0x3d, r28	; 61
    8152:	de bf       	out	0x3e, r29	; 62
    8154:	df 91       	pop	r29
    8156:	cf 91       	pop	r28
    8158:	08 95       	ret

0000815a <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    815a:	ef 92       	push	r14
    815c:	ff 92       	push	r15
    815e:	0f 93       	push	r16
    8160:	1f 93       	push	r17
    8162:	cf 93       	push	r28
    8164:	df 93       	push	r29
    8166:	cd b7       	in	r28, 0x3d	; 61
    8168:	de b7       	in	r29, 0x3e	; 62
    816a:	62 97       	sbiw	r28, 0x12	; 18
    816c:	cd bf       	out	0x3d, r28	; 61
    816e:	de bf       	out	0x3e, r29	; 62
    8170:	6a 87       	std	Y+10, r22	; 0x0a
    8172:	7b 87       	std	Y+11, r23	; 0x0b
    8174:	8c 87       	std	Y+12, r24	; 0x0c
    8176:	9d 87       	std	Y+13, r25	; 0x0d
    8178:	4e 87       	std	Y+14, r20	; 0x0e
    817a:	0f 87       	std	Y+15, r16	; 0x0f
    817c:	18 8b       	std	Y+16, r17	; 0x10
    817e:	29 8b       	std	Y+17, r18	; 0x11
    8180:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    8182:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    8184:	80 91 84 50 	lds	r24, 0x5084
    8188:	90 91 85 50 	lds	r25, 0x5085
    818c:	9c 01       	movw	r18, r24
    818e:	40 e0       	ldi	r20, 0x00	; 0
    8190:	50 e0       	ldi	r21, 0x00	; 0
    8192:	80 91 7e 50 	lds	r24, 0x507E
    8196:	90 91 7f 50 	lds	r25, 0x507F
    819a:	a0 91 80 50 	lds	r26, 0x5080
    819e:	b0 91 81 50 	lds	r27, 0x5081
    81a2:	79 01       	movw	r14, r18
    81a4:	8a 01       	movw	r16, r20
    81a6:	e8 0e       	add	r14, r24
    81a8:	f9 1e       	adc	r15, r25
    81aa:	0a 1f       	adc	r16, r26
    81ac:	1b 1f       	adc	r17, r27
    81ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    81b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    81b2:	ac 85       	ldd	r26, Y+12	; 0x0c
    81b4:	bd 85       	ldd	r27, Y+13	; 0x0d
    81b6:	88 0f       	add	r24, r24
    81b8:	99 1f       	adc	r25, r25
    81ba:	aa 1f       	adc	r26, r26
    81bc:	bb 1f       	adc	r27, r27
    81be:	88 0f       	add	r24, r24
    81c0:	99 1f       	adc	r25, r25
    81c2:	aa 1f       	adc	r26, r26
    81c4:	bb 1f       	adc	r27, r27
    81c6:	20 91 4d 40 	lds	r18, 0x404D
    81ca:	30 91 4e 40 	lds	r19, 0x404E
    81ce:	99 01       	movw	r18, r18
    81d0:	40 e0       	ldi	r20, 0x00	; 0
    81d2:	50 e0       	ldi	r21, 0x00	; 0
    81d4:	bc 01       	movw	r22, r24
    81d6:	cd 01       	movw	r24, r26
    81d8:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    81dc:	da 01       	movw	r26, r20
    81de:	c9 01       	movw	r24, r18
    81e0:	8e 0d       	add	r24, r14
    81e2:	9f 1d       	adc	r25, r15
    81e4:	a0 1f       	adc	r26, r16
    81e6:	b1 1f       	adc	r27, r17
    81e8:	8a 83       	std	Y+2, r24	; 0x02
    81ea:	9b 83       	std	Y+3, r25	; 0x03
    81ec:	ac 83       	std	Y+4, r26	; 0x04
    81ee:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    81f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    81f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    81f4:	ac 85       	ldd	r26, Y+12	; 0x0c
    81f6:	bd 85       	ldd	r27, Y+13	; 0x0d
    81f8:	88 0f       	add	r24, r24
    81fa:	99 1f       	adc	r25, r25
    81fc:	aa 1f       	adc	r26, r26
    81fe:	bb 1f       	adc	r27, r27
    8200:	88 0f       	add	r24, r24
    8202:	99 1f       	adc	r25, r25
    8204:	aa 1f       	adc	r26, r26
    8206:	bb 1f       	adc	r27, r27
    8208:	20 91 4d 40 	lds	r18, 0x404D
    820c:	30 91 4e 40 	lds	r19, 0x404E
    8210:	99 01       	movw	r18, r18
    8212:	40 e0       	ldi	r20, 0x00	; 0
    8214:	50 e0       	ldi	r21, 0x00	; 0
    8216:	bc 01       	movw	r22, r24
    8218:	cd 01       	movw	r24, r26
    821a:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    821e:	dc 01       	movw	r26, r24
    8220:	cb 01       	movw	r24, r22
    8222:	8e 83       	std	Y+6, r24	; 0x06
    8224:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    8226:	8a 81       	ldd	r24, Y+2	; 0x02
    8228:	9b 81       	ldd	r25, Y+3	; 0x03
    822a:	ac 81       	ldd	r26, Y+4	; 0x04
    822c:	bd 81       	ldd	r27, Y+5	; 0x05
    822e:	2f ec       	ldi	r18, 0xCF	; 207
    8230:	31 e2       	ldi	r19, 0x21	; 33
    8232:	bc 01       	movw	r22, r24
    8234:	cd 01       	movw	r24, r26
    8236:	a9 01       	movw	r20, r18
    8238:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    823c:	8e 81       	ldd	r24, Y+6	; 0x06
    823e:	9f 81       	ldd	r25, Y+7	; 0x07
    8240:	81 53       	subi	r24, 0x31	; 49
    8242:	9e 4d       	sbci	r25, 0xDE	; 222
    8244:	88 87       	std	Y+8, r24	; 0x08
    8246:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    8248:	8e 85       	ldd	r24, Y+14	; 0x0e
    824a:	88 23       	and	r24, r24
    824c:	49 f4       	brne	.+18     	; 0x8260 <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    824e:	88 85       	ldd	r24, Y+8	; 0x08
    8250:	99 85       	ldd	r25, Y+9	; 0x09
    8252:	fc 01       	movw	r30, r24
    8254:	80 81       	ld	r24, Z
    8256:	91 81       	ldd	r25, Z+1	; 0x01
    8258:	a2 81       	ldd	r26, Z+2	; 0x02
    825a:	b3 81       	ldd	r27, Z+3	; 0x03
    825c:	bf 70       	andi	r27, 0x0F	; 15
    825e:	1b c0       	rjmp	.+54     	; 0x8296 <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    8260:	28 85       	ldd	r18, Y+8	; 0x08
    8262:	39 85       	ldd	r19, Y+9	; 0x09
    8264:	8f 85       	ldd	r24, Y+15	; 0x0f
    8266:	98 89       	ldd	r25, Y+16	; 0x10
    8268:	a9 89       	ldd	r26, Y+17	; 0x11
    826a:	ba 89       	ldd	r27, Y+18	; 0x12
    826c:	f9 01       	movw	r30, r18
    826e:	80 83       	st	Z, r24
    8270:	91 83       	std	Z+1, r25	; 0x01
    8272:	a2 83       	std	Z+2, r26	; 0x02
    8274:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    8276:	8a 81       	ldd	r24, Y+2	; 0x02
    8278:	9b 81       	ldd	r25, Y+3	; 0x03
    827a:	ac 81       	ldd	r26, Y+4	; 0x04
    827c:	bd 81       	ldd	r27, Y+5	; 0x05
    827e:	2f ec       	ldi	r18, 0xCF	; 207
    8280:	31 e2       	ldi	r19, 0x21	; 33
    8282:	bc 01       	movw	r22, r24
    8284:	cd 01       	movw	r24, r26
    8286:	a9 01       	movw	r20, r18
    8288:	20 e0       	ldi	r18, 0x00	; 0
    828a:	32 e0       	ldi	r19, 0x02	; 2
    828c:	0e 94 d9 4d 	call	0x9bb2	; 0x9bb2 <SD_write_block>

return (0);
    8290:	80 e0       	ldi	r24, 0x00	; 0
    8292:	90 e0       	ldi	r25, 0x00	; 0
    8294:	dc 01       	movw	r26, r24
}
    8296:	bc 01       	movw	r22, r24
    8298:	cd 01       	movw	r24, r26
    829a:	62 96       	adiw	r28, 0x12	; 18
    829c:	cd bf       	out	0x3d, r28	; 61
    829e:	de bf       	out	0x3e, r29	; 62
    82a0:	df 91       	pop	r29
    82a2:	cf 91       	pop	r28
    82a4:	1f 91       	pop	r17
    82a6:	0f 91       	pop	r16
    82a8:	ff 90       	pop	r15
    82aa:	ef 90       	pop	r14
    82ac:	08 95       	ret

000082ae <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    82ae:	cf 93       	push	r28
    82b0:	df 93       	push	r29
    82b2:	cd b7       	in	r28, 0x3d	; 61
    82b4:	de b7       	in	r29, 0x3e	; 62
    82b6:	28 97       	sbiw	r28, 0x08	; 8
    82b8:	cd bf       	out	0x3d, r28	; 61
    82ba:	de bf       	out	0x3e, r29	; 62
    82bc:	8b 83       	std	Y+3, r24	; 0x03
    82be:	6c 83       	std	Y+4, r22	; 0x04
    82c0:	2d 83       	std	Y+5, r18	; 0x05
    82c2:	3e 83       	std	Y+6, r19	; 0x06
    82c4:	4f 83       	std	Y+7, r20	; 0x07
    82c6:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    82c8:	8f ec       	ldi	r24, 0xCF	; 207
    82ca:	91 e2       	ldi	r25, 0x21	; 33
    82cc:	89 83       	std	Y+1, r24	; 0x01
    82ce:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    82d0:	80 91 7e 50 	lds	r24, 0x507E
    82d4:	90 91 7f 50 	lds	r25, 0x507F
    82d8:	a0 91 80 50 	lds	r26, 0x5080
    82dc:	b0 91 81 50 	lds	r27, 0x5081
    82e0:	01 96       	adiw	r24, 0x01	; 1
    82e2:	a1 1d       	adc	r26, r1
    82e4:	b1 1d       	adc	r27, r1
    82e6:	2f ec       	ldi	r18, 0xCF	; 207
    82e8:	31 e2       	ldi	r19, 0x21	; 33
    82ea:	bc 01       	movw	r22, r24
    82ec:	cd 01       	movw	r24, r26
    82ee:	a9 01       	movw	r20, r18
    82f0:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    82f4:	89 81       	ldd	r24, Y+1	; 0x01
    82f6:	9a 81       	ldd	r25, Y+2	; 0x02
    82f8:	fc 01       	movw	r30, r24
    82fa:	80 81       	ld	r24, Z
    82fc:	91 81       	ldd	r25, Z+1	; 0x01
    82fe:	a2 81       	ldd	r26, Z+2	; 0x02
    8300:	b3 81       	ldd	r27, Z+3	; 0x03
    8302:	82 35       	cpi	r24, 0x52	; 82
    8304:	f2 e5       	ldi	r31, 0x52	; 82
    8306:	9f 07       	cpc	r25, r31
    8308:	f1 e6       	ldi	r31, 0x61	; 97
    830a:	af 07       	cpc	r26, r31
    830c:	f1 e4       	ldi	r31, 0x41	; 65
    830e:	bf 07       	cpc	r27, r31
    8310:	11 f5       	brne	.+68     	; 0x8356 <getSetFreeCluster+0xa8>
    8312:	89 81       	ldd	r24, Y+1	; 0x01
    8314:	9a 81       	ldd	r25, Y+2	; 0x02
    8316:	8c 51       	subi	r24, 0x1C	; 28
    8318:	9e 4f       	sbci	r25, 0xFE	; 254
    831a:	fc 01       	movw	r30, r24
    831c:	80 81       	ld	r24, Z
    831e:	91 81       	ldd	r25, Z+1	; 0x01
    8320:	a2 81       	ldd	r26, Z+2	; 0x02
    8322:	b3 81       	ldd	r27, Z+3	; 0x03
    8324:	82 37       	cpi	r24, 0x72	; 114
    8326:	f2 e7       	ldi	r31, 0x72	; 114
    8328:	9f 07       	cpc	r25, r31
    832a:	f1 e4       	ldi	r31, 0x41	; 65
    832c:	af 07       	cpc	r26, r31
    832e:	f1 e6       	ldi	r31, 0x61	; 97
    8330:	bf 07       	cpc	r27, r31
    8332:	89 f4       	brne	.+34     	; 0x8356 <getSetFreeCluster+0xa8>
    8334:	89 81       	ldd	r24, Y+1	; 0x01
    8336:	9a 81       	ldd	r25, Y+2	; 0x02
    8338:	84 50       	subi	r24, 0x04	; 4
    833a:	9e 4f       	sbci	r25, 0xFE	; 254
    833c:	fc 01       	movw	r30, r24
    833e:	80 81       	ld	r24, Z
    8340:	91 81       	ldd	r25, Z+1	; 0x01
    8342:	a2 81       	ldd	r26, Z+2	; 0x02
    8344:	b3 81       	ldd	r27, Z+3	; 0x03
    8346:	80 30       	cpi	r24, 0x00	; 0
    8348:	f0 e0       	ldi	r31, 0x00	; 0
    834a:	9f 07       	cpc	r25, r31
    834c:	f5 e5       	ldi	r31, 0x55	; 85
    834e:	af 07       	cpc	r26, r31
    8350:	fa ea       	ldi	r31, 0xAA	; 170
    8352:	bf 07       	cpc	r27, r31
    8354:	21 f0       	breq	.+8      	; 0x835e <getSetFreeCluster+0xb0>
  return 0xffffffff;
    8356:	8f ef       	ldi	r24, 0xFF	; 255
    8358:	9f ef       	ldi	r25, 0xFF	; 255
    835a:	dc 01       	movw	r26, r24
    835c:	51 c0       	rjmp	.+162    	; 0x8400 <getSetFreeCluster+0x152>

 if(get_set == GET)
    835e:	8c 81       	ldd	r24, Y+4	; 0x04
    8360:	88 23       	and	r24, r24
    8362:	b9 f4       	brne	.+46     	; 0x8392 <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    8364:	8b 81       	ldd	r24, Y+3	; 0x03
    8366:	81 30       	cpi	r24, 0x01	; 1
    8368:	51 f4       	brne	.+20     	; 0x837e <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    836a:	89 81       	ldd	r24, Y+1	; 0x01
    836c:	9a 81       	ldd	r25, Y+2	; 0x02
    836e:	88 51       	subi	r24, 0x18	; 24
    8370:	9e 4f       	sbci	r25, 0xFE	; 254
    8372:	fc 01       	movw	r30, r24
    8374:	80 81       	ld	r24, Z
    8376:	91 81       	ldd	r25, Z+1	; 0x01
    8378:	a2 81       	ldd	r26, Z+2	; 0x02
    837a:	b3 81       	ldd	r27, Z+3	; 0x03
    837c:	41 c0       	rjmp	.+130    	; 0x8400 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    837e:	89 81       	ldd	r24, Y+1	; 0x01
    8380:	9a 81       	ldd	r25, Y+2	; 0x02
    8382:	84 51       	subi	r24, 0x14	; 20
    8384:	9e 4f       	sbci	r25, 0xFE	; 254
    8386:	fc 01       	movw	r30, r24
    8388:	80 81       	ld	r24, Z
    838a:	91 81       	ldd	r25, Z+1	; 0x01
    838c:	a2 81       	ldd	r26, Z+2	; 0x02
    838e:	b3 81       	ldd	r27, Z+3	; 0x03
    8390:	37 c0       	rjmp	.+110    	; 0x8400 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    8392:	8b 81       	ldd	r24, Y+3	; 0x03
    8394:	81 30       	cpi	r24, 0x01	; 1
    8396:	79 f4       	brne	.+30     	; 0x83b6 <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    8398:	89 81       	ldd	r24, Y+1	; 0x01
    839a:	9a 81       	ldd	r25, Y+2	; 0x02
    839c:	9c 01       	movw	r18, r24
    839e:	28 51       	subi	r18, 0x18	; 24
    83a0:	3e 4f       	sbci	r19, 0xFE	; 254
    83a2:	8d 81       	ldd	r24, Y+5	; 0x05
    83a4:	9e 81       	ldd	r25, Y+6	; 0x06
    83a6:	af 81       	ldd	r26, Y+7	; 0x07
    83a8:	b8 85       	ldd	r27, Y+8	; 0x08
    83aa:	f9 01       	movw	r30, r18
    83ac:	80 83       	st	Z, r24
    83ae:	91 83       	std	Z+1, r25	; 0x01
    83b0:	a2 83       	std	Z+2, r26	; 0x02
    83b2:	b3 83       	std	Z+3, r27	; 0x03
    83b4:	0e c0       	rjmp	.+28     	; 0x83d2 <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    83b6:	89 81       	ldd	r24, Y+1	; 0x01
    83b8:	9a 81       	ldd	r25, Y+2	; 0x02
    83ba:	9c 01       	movw	r18, r24
    83bc:	24 51       	subi	r18, 0x14	; 20
    83be:	3e 4f       	sbci	r19, 0xFE	; 254
    83c0:	8d 81       	ldd	r24, Y+5	; 0x05
    83c2:	9e 81       	ldd	r25, Y+6	; 0x06
    83c4:	af 81       	ldd	r26, Y+7	; 0x07
    83c6:	b8 85       	ldd	r27, Y+8	; 0x08
    83c8:	f9 01       	movw	r30, r18
    83ca:	80 83       	st	Z, r24
    83cc:	91 83       	std	Z+1, r25	; 0x01
    83ce:	a2 83       	std	Z+2, r26	; 0x02
    83d0:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    83d2:	80 91 7e 50 	lds	r24, 0x507E
    83d6:	90 91 7f 50 	lds	r25, 0x507F
    83da:	a0 91 80 50 	lds	r26, 0x5080
    83de:	b0 91 81 50 	lds	r27, 0x5081
    83e2:	01 96       	adiw	r24, 0x01	; 1
    83e4:	a1 1d       	adc	r26, r1
    83e6:	b1 1d       	adc	r27, r1
    83e8:	2f ec       	ldi	r18, 0xCF	; 207
    83ea:	31 e2       	ldi	r19, 0x21	; 33
    83ec:	bc 01       	movw	r22, r24
    83ee:	cd 01       	movw	r24, r26
    83f0:	a9 01       	movw	r20, r18
    83f2:	20 e0       	ldi	r18, 0x00	; 0
    83f4:	32 e0       	ldi	r19, 0x02	; 2
    83f6:	0e 94 d9 4d 	call	0x9bb2	; 0x9bb2 <SD_write_block>
 }
 return 0xffffffff;
    83fa:	8f ef       	ldi	r24, 0xFF	; 255
    83fc:	9f ef       	ldi	r25, 0xFF	; 255
    83fe:	dc 01       	movw	r26, r24
}
    8400:	bc 01       	movw	r22, r24
    8402:	cd 01       	movw	r24, r26
    8404:	28 96       	adiw	r28, 0x08	; 8
    8406:	cd bf       	out	0x3d, r28	; 61
    8408:	de bf       	out	0x3e, r29	; 62
    840a:	df 91       	pop	r29
    840c:	cf 91       	pop	r28
    840e:	08 95       	ret

00008410 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    8410:	0f 93       	push	r16
    8412:	1f 93       	push	r17
    8414:	cf 93       	push	r28
    8416:	df 93       	push	r29
    8418:	cd b7       	in	r28, 0x3d	; 61
    841a:	de b7       	in	r29, 0x3e	; 62
    841c:	6c 97       	sbiw	r28, 0x1c	; 28
    841e:	cd bf       	out	0x3d, r28	; 61
    8420:	de bf       	out	0x3e, r29	; 62
    8422:	8a 8f       	std	Y+26, r24	; 0x1a
    8424:	6b 8f       	std	Y+27, r22	; 0x1b
    8426:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    8428:	80 91 60 40 	lds	r24, 0x4060
    842c:	90 91 61 40 	lds	r25, 0x4061
    8430:	a0 91 62 40 	lds	r26, 0x4062
    8434:	b0 91 63 40 	lds	r27, 0x4063
    8438:	89 83       	std	Y+1, r24	; 0x01
    843a:	9a 83       	std	Y+2, r25	; 0x02
    843c:	ab 83       	std	Y+3, r26	; 0x03
    843e:	bc 83       	std	Y+4, r27	; 0x04
    8440:	01 c0       	rjmp	.+2      	; 0x8444 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    8442:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    8444:	89 81       	ldd	r24, Y+1	; 0x01
    8446:	9a 81       	ldd	r25, Y+2	; 0x02
    8448:	ab 81       	ldd	r26, Y+3	; 0x03
    844a:	bc 81       	ldd	r27, Y+4	; 0x04
    844c:	bc 01       	movw	r22, r24
    844e:	cd 01       	movw	r24, r26
    8450:	0e 94 7b 40 	call	0x80f6	; 0x80f6 <getFirstSector>
    8454:	dc 01       	movw	r26, r24
    8456:	cb 01       	movw	r24, r22
    8458:	88 8b       	std	Y+16, r24	; 0x10
    845a:	99 8b       	std	Y+17, r25	; 0x11
    845c:	aa 8b       	std	Y+18, r26	; 0x12
    845e:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    8460:	1d 82       	std	Y+5, r1	; 0x05
    8462:	1e 82       	std	Y+6, r1	; 0x06
    8464:	1f 82       	std	Y+7, r1	; 0x07
    8466:	18 86       	std	Y+8, r1	; 0x08
    8468:	68 c1       	rjmp	.+720    	; 0x873a <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    846a:	28 89       	ldd	r18, Y+16	; 0x10
    846c:	39 89       	ldd	r19, Y+17	; 0x11
    846e:	4a 89       	ldd	r20, Y+18	; 0x12
    8470:	5b 89       	ldd	r21, Y+19	; 0x13
    8472:	8d 81       	ldd	r24, Y+5	; 0x05
    8474:	9e 81       	ldd	r25, Y+6	; 0x06
    8476:	af 81       	ldd	r26, Y+7	; 0x07
    8478:	b8 85       	ldd	r27, Y+8	; 0x08
    847a:	82 0f       	add	r24, r18
    847c:	93 1f       	adc	r25, r19
    847e:	a4 1f       	adc	r26, r20
    8480:	b5 1f       	adc	r27, r21
    8482:	2f ec       	ldi	r18, 0xCF	; 207
    8484:	31 e2       	ldi	r19, 0x21	; 33
    8486:	bc 01       	movw	r22, r24
    8488:	cd 01       	movw	r24, r26
    848a:	a9 01       	movw	r20, r18
    848c:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    8490:	1d 86       	std	Y+13, r1	; 0x0d
    8492:	1e 86       	std	Y+14, r1	; 0x0e
    8494:	3d c1       	rjmp	.+634    	; 0x8710 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    8496:	8d 85       	ldd	r24, Y+13	; 0x0d
    8498:	9e 85       	ldd	r25, Y+14	; 0x0e
    849a:	81 53       	subi	r24, 0x31	; 49
    849c:	9e 4d       	sbci	r25, 0xDE	; 222
    849e:	8c 8b       	std	Y+20, r24	; 0x14
    84a0:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    84a2:	8c 89       	ldd	r24, Y+20	; 0x14
    84a4:	9d 89       	ldd	r25, Y+21	; 0x15
    84a6:	fc 01       	movw	r30, r24
    84a8:	80 81       	ld	r24, Z
    84aa:	88 23       	and	r24, r24
    84ac:	19 f4       	brne	.+6      	; 0x84b4 <findFiles+0xa4>
		{
		  return 0;   
    84ae:	80 e0       	ldi	r24, 0x00	; 0
    84b0:	90 e0       	ldi	r25, 0x00	; 0
    84b2:	80 c1       	rjmp	.+768    	; 0x87b4 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    84b4:	8c 89       	ldd	r24, Y+20	; 0x14
    84b6:	9d 89       	ldd	r25, Y+21	; 0x15
    84b8:	fc 01       	movw	r30, r24
    84ba:	80 81       	ld	r24, Z
    84bc:	85 3e       	cpi	r24, 0xE5	; 229
    84be:	09 f4       	brne	.+2      	; 0x84c2 <findFiles+0xb2>
    84c0:	22 c1       	rjmp	.+580    	; 0x8706 <findFiles+0x2f6>
    84c2:	8c 89       	ldd	r24, Y+20	; 0x14
    84c4:	9d 89       	ldd	r25, Y+21	; 0x15
    84c6:	fc 01       	movw	r30, r24
    84c8:	83 85       	ldd	r24, Z+11	; 0x0b
    84ca:	8f 30       	cpi	r24, 0x0F	; 15
    84cc:	09 f4       	brne	.+2      	; 0x84d0 <findFiles+0xc0>
    84ce:	1b c1       	rjmp	.+566    	; 0x8706 <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    84d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    84d2:	81 30       	cpi	r24, 0x01	; 1
    84d4:	21 f0       	breq	.+8      	; 0x84de <findFiles+0xce>
    84d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    84d8:	82 30       	cpi	r24, 0x02	; 2
    84da:	09 f0       	breq	.+2      	; 0x84de <findFiles+0xce>
    84dc:	11 c1       	rjmp	.+546    	; 0x8700 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    84de:	1f 86       	std	Y+15, r1	; 0x0f
    84e0:	17 c0       	rjmp	.+46     	; 0x8510 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    84e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    84e4:	88 2f       	mov	r24, r24
    84e6:	90 e0       	ldi	r25, 0x00	; 0
    84e8:	2c 89       	ldd	r18, Y+20	; 0x14
    84ea:	3d 89       	ldd	r19, Y+21	; 0x15
    84ec:	82 0f       	add	r24, r18
    84ee:	93 1f       	adc	r25, r19
    84f0:	fc 01       	movw	r30, r24
    84f2:	40 81       	ld	r20, Z
    84f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    84f6:	88 2f       	mov	r24, r24
    84f8:	90 e0       	ldi	r25, 0x00	; 0
    84fa:	2b 8d       	ldd	r18, Y+27	; 0x1b
    84fc:	3c 8d       	ldd	r19, Y+28	; 0x1c
    84fe:	82 0f       	add	r24, r18
    8500:	93 1f       	adc	r25, r19
    8502:	fc 01       	movw	r30, r24
    8504:	80 81       	ld	r24, Z
    8506:	48 17       	cp	r20, r24
    8508:	39 f4       	brne	.+14     	; 0x8518 <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    850a:	8f 85       	ldd	r24, Y+15	; 0x0f
    850c:	8f 5f       	subi	r24, 0xFF	; 255
    850e:	8f 87       	std	Y+15, r24	; 0x0f
    8510:	8f 85       	ldd	r24, Y+15	; 0x0f
    8512:	8b 30       	cpi	r24, 0x0B	; 11
    8514:	30 f3       	brcs	.-52     	; 0x84e2 <findFiles+0xd2>
    8516:	01 c0       	rjmp	.+2      	; 0x851a <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    8518:	00 00       	nop
            if(j == 11)
    851a:	8f 85       	ldd	r24, Y+15	; 0x0f
    851c:	8b 30       	cpi	r24, 0x0B	; 11
    851e:	09 f0       	breq	.+2      	; 0x8522 <findFiles+0x112>
    8520:	f2 c0       	rjmp	.+484    	; 0x8706 <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    8522:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8524:	81 30       	cpi	r24, 0x01	; 1
    8526:	09 f0       	breq	.+2      	; 0x852a <findFiles+0x11a>
    8528:	52 c0       	rjmp	.+164    	; 0x85ce <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    852a:	28 89       	ldd	r18, Y+16	; 0x10
    852c:	39 89       	ldd	r19, Y+17	; 0x11
    852e:	4a 89       	ldd	r20, Y+18	; 0x12
    8530:	5b 89       	ldd	r21, Y+19	; 0x13
    8532:	8d 81       	ldd	r24, Y+5	; 0x05
    8534:	9e 81       	ldd	r25, Y+6	; 0x06
    8536:	af 81       	ldd	r26, Y+7	; 0x07
    8538:	b8 85       	ldd	r27, Y+8	; 0x08
    853a:	82 0f       	add	r24, r18
    853c:	93 1f       	adc	r25, r19
    853e:	a4 1f       	adc	r26, r20
    8540:	b5 1f       	adc	r27, r21
    8542:	80 93 d2 50 	sts	0x50D2, r24
    8546:	90 93 d3 50 	sts	0x50D3, r25
    854a:	a0 93 d4 50 	sts	0x50D4, r26
    854e:	b0 93 d5 50 	sts	0x50D5, r27
				appendFileLocation = i;
    8552:	8d 85       	ldd	r24, Y+13	; 0x0d
    8554:	9e 85       	ldd	r25, Y+14	; 0x0e
    8556:	cc 01       	movw	r24, r24
    8558:	a0 e0       	ldi	r26, 0x00	; 0
    855a:	b0 e0       	ldi	r27, 0x00	; 0
    855c:	80 93 d0 23 	sts	0x23D0, r24
    8560:	90 93 d1 23 	sts	0x23D1, r25
    8564:	a0 93 d2 23 	sts	0x23D2, r26
    8568:	b0 93 d3 23 	sts	0x23D3, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    856c:	8c 89       	ldd	r24, Y+20	; 0x14
    856e:	9d 89       	ldd	r25, Y+21	; 0x15
    8570:	fc 01       	movw	r30, r24
    8572:	84 89       	ldd	r24, Z+20	; 0x14
    8574:	95 89       	ldd	r25, Z+21	; 0x15
    8576:	cc 01       	movw	r24, r24
    8578:	a0 e0       	ldi	r26, 0x00	; 0
    857a:	b0 e0       	ldi	r27, 0x00	; 0
    857c:	ac 01       	movw	r20, r24
    857e:	33 27       	eor	r19, r19
    8580:	22 27       	eor	r18, r18
    8582:	8c 89       	ldd	r24, Y+20	; 0x14
    8584:	9d 89       	ldd	r25, Y+21	; 0x15
    8586:	fc 01       	movw	r30, r24
    8588:	82 8d       	ldd	r24, Z+26	; 0x1a
    858a:	93 8d       	ldd	r25, Z+27	; 0x1b
    858c:	cc 01       	movw	r24, r24
    858e:	a0 e0       	ldi	r26, 0x00	; 0
    8590:	b0 e0       	ldi	r27, 0x00	; 0
    8592:	82 2b       	or	r24, r18
    8594:	93 2b       	or	r25, r19
    8596:	a4 2b       	or	r26, r20
    8598:	b5 2b       	or	r27, r21
    859a:	80 93 88 50 	sts	0x5088, r24
    859e:	90 93 89 50 	sts	0x5089, r25
    85a2:	a0 93 8a 50 	sts	0x508A, r26
    85a6:	b0 93 8b 50 	sts	0x508B, r27
				fileSize = dir->fileSize;
    85aa:	8c 89       	ldd	r24, Y+20	; 0x14
    85ac:	9d 89       	ldd	r25, Y+21	; 0x15
    85ae:	fc 01       	movw	r30, r24
    85b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    85b2:	95 8d       	ldd	r25, Z+29	; 0x1d
    85b4:	a6 8d       	ldd	r26, Z+30	; 0x1e
    85b6:	b7 8d       	ldd	r27, Z+31	; 0x1f
    85b8:	80 93 49 40 	sts	0x4049, r24
    85bc:	90 93 4a 40 	sts	0x404A, r25
    85c0:	a0 93 4b 40 	sts	0x404B, r26
    85c4:	b0 93 4c 40 	sts	0x404C, r27
			    return (dir);
    85c8:	8c 89       	ldd	r24, Y+20	; 0x14
    85ca:	9d 89       	ldd	r25, Y+21	; 0x15
    85cc:	f3 c0       	rjmp	.+486    	; 0x87b4 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    85ce:	8c 89       	ldd	r24, Y+20	; 0x14
    85d0:	9d 89       	ldd	r25, Y+21	; 0x15
    85d2:	fc 01       	movw	r30, r24
    85d4:	84 89       	ldd	r24, Z+20	; 0x14
    85d6:	95 89       	ldd	r25, Z+21	; 0x15
    85d8:	cc 01       	movw	r24, r24
    85da:	a0 e0       	ldi	r26, 0x00	; 0
    85dc:	b0 e0       	ldi	r27, 0x00	; 0
    85de:	ac 01       	movw	r20, r24
    85e0:	33 27       	eor	r19, r19
    85e2:	22 27       	eor	r18, r18
    85e4:	8c 89       	ldd	r24, Y+20	; 0x14
    85e6:	9d 89       	ldd	r25, Y+21	; 0x15
    85e8:	fc 01       	movw	r30, r24
    85ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    85ec:	93 8d       	ldd	r25, Z+27	; 0x1b
    85ee:	cc 01       	movw	r24, r24
    85f0:	a0 e0       	ldi	r26, 0x00	; 0
    85f2:	b0 e0       	ldi	r27, 0x00	; 0
    85f4:	82 2b       	or	r24, r18
    85f6:	93 2b       	or	r25, r19
    85f8:	a4 2b       	or	r26, r20
    85fa:	b5 2b       	or	r27, r21
    85fc:	89 87       	std	Y+9, r24	; 0x09
    85fe:	9a 87       	std	Y+10, r25	; 0x0a
    8600:	ab 87       	std	Y+11, r26	; 0x0b
    8602:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8604:	8c 89       	ldd	r24, Y+20	; 0x14
    8606:	9d 89       	ldd	r25, Y+21	; 0x15
    8608:	25 ee       	ldi	r18, 0xE5	; 229
    860a:	fc 01       	movw	r30, r24
    860c:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    860e:	28 89       	ldd	r18, Y+16	; 0x10
    8610:	39 89       	ldd	r19, Y+17	; 0x11
    8612:	4a 89       	ldd	r20, Y+18	; 0x12
    8614:	5b 89       	ldd	r21, Y+19	; 0x13
    8616:	8d 81       	ldd	r24, Y+5	; 0x05
    8618:	9e 81       	ldd	r25, Y+6	; 0x06
    861a:	af 81       	ldd	r26, Y+7	; 0x07
    861c:	b8 85       	ldd	r27, Y+8	; 0x08
    861e:	82 0f       	add	r24, r18
    8620:	93 1f       	adc	r25, r19
    8622:	a4 1f       	adc	r26, r20
    8624:	b5 1f       	adc	r27, r21
    8626:	2f ec       	ldi	r18, 0xCF	; 207
    8628:	31 e2       	ldi	r19, 0x21	; 33
    862a:	bc 01       	movw	r22, r24
    862c:	cd 01       	movw	r24, r26
    862e:	a9 01       	movw	r20, r18
    8630:	20 e0       	ldi	r18, 0x00	; 0
    8632:	32 e0       	ldi	r19, 0x02	; 2
    8634:	0e 94 d9 4d 	call	0x9bb2	; 0x9bb2 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8638:	8c 89       	ldd	r24, Y+20	; 0x14
    863a:	9d 89       	ldd	r25, Y+21	; 0x15
    863c:	fc 01       	movw	r30, r24
    863e:	24 8d       	ldd	r18, Z+28	; 0x1c
    8640:	35 8d       	ldd	r19, Z+29	; 0x1d
    8642:	46 8d       	ldd	r20, Z+30	; 0x1e
    8644:	57 8d       	ldd	r21, Z+31	; 0x1f
    8646:	80 e0       	ldi	r24, 0x00	; 0
    8648:	ba 01       	movw	r22, r20
    864a:	a9 01       	movw	r20, r18
    864c:	0e 94 76 4a 	call	0x94ec	; 0x94ec <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8650:	82 e0       	ldi	r24, 0x02	; 2
    8652:	60 e0       	ldi	r22, 0x00	; 0
    8654:	20 e0       	ldi	r18, 0x00	; 0
    8656:	30 e0       	ldi	r19, 0x00	; 0
    8658:	a9 01       	movw	r20, r18
    865a:	0e 94 57 41 	call	0x82ae	; 0x82ae <getSetFreeCluster>
    865e:	dc 01       	movw	r26, r24
    8660:	cb 01       	movw	r24, r22
    8662:	89 83       	std	Y+1, r24	; 0x01
    8664:	9a 83       	std	Y+2, r25	; 0x02
    8666:	ab 83       	std	Y+3, r26	; 0x03
    8668:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    866a:	29 85       	ldd	r18, Y+9	; 0x09
    866c:	3a 85       	ldd	r19, Y+10	; 0x0a
    866e:	4b 85       	ldd	r20, Y+11	; 0x0b
    8670:	5c 85       	ldd	r21, Y+12	; 0x0c
    8672:	89 81       	ldd	r24, Y+1	; 0x01
    8674:	9a 81       	ldd	r25, Y+2	; 0x02
    8676:	ab 81       	ldd	r26, Y+3	; 0x03
    8678:	bc 81       	ldd	r27, Y+4	; 0x04
    867a:	28 17       	cp	r18, r24
    867c:	39 07       	cpc	r19, r25
    867e:	4a 07       	cpc	r20, r26
    8680:	5b 07       	cpc	r21, r27
    8682:	40 f4       	brcc	.+16     	; 0x8694 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    8684:	29 85       	ldd	r18, Y+9	; 0x09
    8686:	3a 85       	ldd	r19, Y+10	; 0x0a
    8688:	4b 85       	ldd	r20, Y+11	; 0x0b
    868a:	5c 85       	ldd	r21, Y+12	; 0x0c
    868c:	82 e0       	ldi	r24, 0x02	; 2
    868e:	61 e0       	ldi	r22, 0x01	; 1
    8690:	0e 94 57 41 	call	0x82ae	; 0x82ae <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    8694:	89 85       	ldd	r24, Y+9	; 0x09
    8696:	9a 85       	ldd	r25, Y+10	; 0x0a
    8698:	ab 85       	ldd	r26, Y+11	; 0x0b
    869a:	bc 85       	ldd	r27, Y+12	; 0x0c
    869c:	bc 01       	movw	r22, r24
    869e:	cd 01       	movw	r24, r26
    86a0:	40 e0       	ldi	r20, 0x00	; 0
    86a2:	00 e0       	ldi	r16, 0x00	; 0
    86a4:	10 e0       	ldi	r17, 0x00	; 0
    86a6:	98 01       	movw	r18, r16
    86a8:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
    86ac:	dc 01       	movw	r26, r24
    86ae:	cb 01       	movw	r24, r22
    86b0:	8e 8b       	std	Y+22, r24	; 0x16
    86b2:	9f 8b       	std	Y+23, r25	; 0x17
    86b4:	a8 8f       	std	Y+24, r26	; 0x18
    86b6:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    86b8:	89 85       	ldd	r24, Y+9	; 0x09
    86ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    86bc:	ab 85       	ldd	r26, Y+11	; 0x0b
    86be:	bc 85       	ldd	r27, Y+12	; 0x0c
    86c0:	bc 01       	movw	r22, r24
    86c2:	cd 01       	movw	r24, r26
    86c4:	41 e0       	ldi	r20, 0x01	; 1
    86c6:	00 e0       	ldi	r16, 0x00	; 0
    86c8:	10 e0       	ldi	r17, 0x00	; 0
    86ca:	98 01       	movw	r18, r16
    86cc:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    86d0:	8e 89       	ldd	r24, Y+22	; 0x16
    86d2:	9f 89       	ldd	r25, Y+23	; 0x17
    86d4:	a8 8d       	ldd	r26, Y+24	; 0x18
    86d6:	b9 8d       	ldd	r27, Y+25	; 0x19
    86d8:	87 3f       	cpi	r24, 0xF7	; 247
    86da:	ff ef       	ldi	r31, 0xFF	; 255
    86dc:	9f 07       	cpc	r25, r31
    86de:	ff ef       	ldi	r31, 0xFF	; 255
    86e0:	af 07       	cpc	r26, r31
    86e2:	ff e0       	ldi	r31, 0x0F	; 15
    86e4:	bf 07       	cpc	r27, r31
    86e6:	18 f0       	brcs	.+6      	; 0x86ee <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    86e8:	80 e0       	ldi	r24, 0x00	; 0
    86ea:	90 e0       	ldi	r25, 0x00	; 0
    86ec:	63 c0       	rjmp	.+198    	; 0x87b4 <findFiles+0x3a4>
					firstCluster = nextCluster;
    86ee:	8e 89       	ldd	r24, Y+22	; 0x16
    86f0:	9f 89       	ldd	r25, Y+23	; 0x17
    86f2:	a8 8d       	ldd	r26, Y+24	; 0x18
    86f4:	b9 8d       	ldd	r27, Y+25	; 0x19
    86f6:	89 87       	std	Y+9, r24	; 0x09
    86f8:	9a 87       	std	Y+10, r25	; 0x0a
    86fa:	ab 87       	std	Y+11, r26	; 0x0b
    86fc:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    86fe:	ca cf       	rjmp	.-108    	; 0x8694 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8700:	80 e0       	ldi	r24, 0x00	; 0
    8702:	90 e0       	ldi	r25, 0x00	; 0
    8704:	57 c0       	rjmp	.+174    	; 0x87b4 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8706:	8d 85       	ldd	r24, Y+13	; 0x0d
    8708:	9e 85       	ldd	r25, Y+14	; 0x0e
    870a:	80 96       	adiw	r24, 0x20	; 32
    870c:	8d 87       	std	Y+13, r24	; 0x0d
    870e:	9e 87       	std	Y+14, r25	; 0x0e
    8710:	80 91 4d 40 	lds	r24, 0x404D
    8714:	90 91 4e 40 	lds	r25, 0x404E
    8718:	2d 85       	ldd	r18, Y+13	; 0x0d
    871a:	3e 85       	ldd	r19, Y+14	; 0x0e
    871c:	28 17       	cp	r18, r24
    871e:	39 07       	cpc	r19, r25
    8720:	08 f4       	brcc	.+2      	; 0x8724 <findFiles+0x314>
    8722:	b9 ce       	rjmp	.-654    	; 0x8496 <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8724:	8d 81       	ldd	r24, Y+5	; 0x05
    8726:	9e 81       	ldd	r25, Y+6	; 0x06
    8728:	af 81       	ldd	r26, Y+7	; 0x07
    872a:	b8 85       	ldd	r27, Y+8	; 0x08
    872c:	01 96       	adiw	r24, 0x01	; 1
    872e:	a1 1d       	adc	r26, r1
    8730:	b1 1d       	adc	r27, r1
    8732:	8d 83       	std	Y+5, r24	; 0x05
    8734:	9e 83       	std	Y+6, r25	; 0x06
    8736:	af 83       	std	Y+7, r26	; 0x07
    8738:	b8 87       	std	Y+8, r27	; 0x08
    873a:	80 91 7c 50 	lds	r24, 0x507C
    873e:	90 91 7d 50 	lds	r25, 0x507D
    8742:	9c 01       	movw	r18, r24
    8744:	40 e0       	ldi	r20, 0x00	; 0
    8746:	50 e0       	ldi	r21, 0x00	; 0
    8748:	8d 81       	ldd	r24, Y+5	; 0x05
    874a:	9e 81       	ldd	r25, Y+6	; 0x06
    874c:	af 81       	ldd	r26, Y+7	; 0x07
    874e:	b8 85       	ldd	r27, Y+8	; 0x08
    8750:	82 17       	cp	r24, r18
    8752:	93 07       	cpc	r25, r19
    8754:	a4 07       	cpc	r26, r20
    8756:	b5 07       	cpc	r27, r21
    8758:	08 f4       	brcc	.+2      	; 0x875c <findFiles+0x34c>
    875a:	87 ce       	rjmp	.-754    	; 0x846a <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    875c:	89 81       	ldd	r24, Y+1	; 0x01
    875e:	9a 81       	ldd	r25, Y+2	; 0x02
    8760:	ab 81       	ldd	r26, Y+3	; 0x03
    8762:	bc 81       	ldd	r27, Y+4	; 0x04
    8764:	bc 01       	movw	r22, r24
    8766:	cd 01       	movw	r24, r26
    8768:	40 e0       	ldi	r20, 0x00	; 0
    876a:	00 e0       	ldi	r16, 0x00	; 0
    876c:	10 e0       	ldi	r17, 0x00	; 0
    876e:	98 01       	movw	r18, r16
    8770:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
    8774:	dc 01       	movw	r26, r24
    8776:	cb 01       	movw	r24, r22
    8778:	89 83       	std	Y+1, r24	; 0x01
    877a:	9a 83       	std	Y+2, r25	; 0x02
    877c:	ab 83       	std	Y+3, r26	; 0x03
    877e:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8780:	89 81       	ldd	r24, Y+1	; 0x01
    8782:	9a 81       	ldd	r25, Y+2	; 0x02
    8784:	ab 81       	ldd	r26, Y+3	; 0x03
    8786:	bc 81       	ldd	r27, Y+4	; 0x04
    8788:	87 3f       	cpi	r24, 0xF7	; 247
    878a:	2f ef       	ldi	r18, 0xFF	; 255
    878c:	92 07       	cpc	r25, r18
    878e:	2f ef       	ldi	r18, 0xFF	; 255
    8790:	a2 07       	cpc	r26, r18
    8792:	2f e0       	ldi	r18, 0x0F	; 15
    8794:	b2 07       	cpc	r27, r18
    8796:	18 f0       	brcs	.+6      	; 0x879e <findFiles+0x38e>
   	 return 0;
    8798:	80 e0       	ldi	r24, 0x00	; 0
    879a:	90 e0       	ldi	r25, 0x00	; 0
    879c:	0b c0       	rjmp	.+22     	; 0x87b4 <findFiles+0x3a4>
   if(cluster == 0) 
    879e:	89 81       	ldd	r24, Y+1	; 0x01
    87a0:	9a 81       	ldd	r25, Y+2	; 0x02
    87a2:	ab 81       	ldd	r26, Y+3	; 0x03
    87a4:	bc 81       	ldd	r27, Y+4	; 0x04
    87a6:	00 97       	sbiw	r24, 0x00	; 0
    87a8:	a1 05       	cpc	r26, r1
    87aa:	b1 05       	cpc	r27, r1
    87ac:	09 f0       	breq	.+2      	; 0x87b0 <findFiles+0x3a0>
    87ae:	49 ce       	rjmp	.-878    	; 0x8442 <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    87b0:	80 e0       	ldi	r24, 0x00	; 0
    87b2:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    87b4:	6c 96       	adiw	r28, 0x1c	; 28
    87b6:	cd bf       	out	0x3d, r28	; 61
    87b8:	de bf       	out	0x3e, r29	; 62
    87ba:	df 91       	pop	r29
    87bc:	cf 91       	pop	r28
    87be:	1f 91       	pop	r17
    87c0:	0f 91       	pop	r16
    87c2:	08 95       	ret

000087c4 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    87c4:	0f 93       	push	r16
    87c6:	1f 93       	push	r17
    87c8:	cf 93       	push	r28
    87ca:	df 93       	push	r29
    87cc:	cd b7       	in	r28, 0x3d	; 61
    87ce:	de b7       	in	r29, 0x3e	; 62
    87d0:	67 97       	sbiw	r28, 0x17	; 23
    87d2:	cd bf       	out	0x3d, r28	; 61
    87d4:	de bf       	out	0x3e, r29	; 62
    87d6:	8d 8b       	std	Y+21, r24	; 0x15
    87d8:	6e 8b       	std	Y+22, r22	; 0x16
    87da:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    87dc:	1e 82       	std	Y+6, r1	; 0x06
    87de:	1f 82       	std	Y+7, r1	; 0x07
    87e0:	18 86       	std	Y+8, r1	; 0x08
    87e2:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    87e4:	8e 89       	ldd	r24, Y+22	; 0x16
    87e6:	9f 89       	ldd	r25, Y+23	; 0x17
    87e8:	0e 94 91 44 	call	0x8922	; 0x8922 <convertFileName>
    87ec:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    87ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    87f0:	88 23       	and	r24, r24
    87f2:	11 f0       	breq	.+4      	; 0x87f8 <readFile+0x34>
    87f4:	82 e0       	ldi	r24, 0x02	; 2
    87f6:	8d c0       	rjmp	.+282    	; 0x8912 <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    87f8:	2c eb       	ldi	r18, 0xBC	; 188
    87fa:	30 e5       	ldi	r19, 0x50	; 80
    87fc:	81 e0       	ldi	r24, 0x01	; 1
    87fe:	b9 01       	movw	r22, r18
    8800:	0e 94 08 42 	call	0x8410	; 0x8410 <findFiles>
    8804:	8b 87       	std	Y+11, r24	; 0x0b
    8806:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    8808:	8b 85       	ldd	r24, Y+11	; 0x0b
    880a:	9c 85       	ldd	r25, Y+12	; 0x0c
    880c:	00 97       	sbiw	r24, 0x00	; 0
    880e:	39 f4       	brne	.+14     	; 0x881e <readFile+0x5a>
{
  if(flag == READ) return (1);
    8810:	8d 89       	ldd	r24, Y+21	; 0x15
    8812:	88 23       	and	r24, r24
    8814:	11 f4       	brne	.+4      	; 0x881a <readFile+0x56>
    8816:	81 e0       	ldi	r24, 0x01	; 1
    8818:	7c c0       	rjmp	.+248    	; 0x8912 <readFile+0x14e>
  else return (0);
    881a:	80 e0       	ldi	r24, 0x00	; 0
    881c:	7a c0       	rjmp	.+244    	; 0x8912 <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    881e:	8d 89       	ldd	r24, Y+21	; 0x15
    8820:	81 30       	cpi	r24, 0x01	; 1
    8822:	11 f4       	brne	.+4      	; 0x8828 <readFile+0x64>
    8824:	81 e0       	ldi	r24, 0x01	; 1
    8826:	75 c0       	rjmp	.+234    	; 0x8912 <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8828:	8b 85       	ldd	r24, Y+11	; 0x0b
    882a:	9c 85       	ldd	r25, Y+12	; 0x0c
    882c:	fc 01       	movw	r30, r24
    882e:	84 89       	ldd	r24, Z+20	; 0x14
    8830:	95 89       	ldd	r25, Z+21	; 0x15
    8832:	cc 01       	movw	r24, r24
    8834:	a0 e0       	ldi	r26, 0x00	; 0
    8836:	b0 e0       	ldi	r27, 0x00	; 0
    8838:	ac 01       	movw	r20, r24
    883a:	33 27       	eor	r19, r19
    883c:	22 27       	eor	r18, r18
    883e:	8b 85       	ldd	r24, Y+11	; 0x0b
    8840:	9c 85       	ldd	r25, Y+12	; 0x0c
    8842:	fc 01       	movw	r30, r24
    8844:	82 8d       	ldd	r24, Z+26	; 0x1a
    8846:	93 8d       	ldd	r25, Z+27	; 0x1b
    8848:	cc 01       	movw	r24, r24
    884a:	a0 e0       	ldi	r26, 0x00	; 0
    884c:	b0 e0       	ldi	r27, 0x00	; 0
    884e:	82 2b       	or	r24, r18
    8850:	93 2b       	or	r25, r19
    8852:	a4 2b       	or	r26, r20
    8854:	b5 2b       	or	r27, r21
    8856:	89 83       	std	Y+1, r24	; 0x01
    8858:	9a 83       	std	Y+2, r25	; 0x02
    885a:	ab 83       	std	Y+3, r26	; 0x03
    885c:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    885e:	8b 85       	ldd	r24, Y+11	; 0x0b
    8860:	9c 85       	ldd	r25, Y+12	; 0x0c
    8862:	fc 01       	movw	r30, r24
    8864:	84 8d       	ldd	r24, Z+28	; 0x1c
    8866:	95 8d       	ldd	r25, Z+29	; 0x1d
    8868:	a6 8d       	ldd	r26, Z+30	; 0x1e
    886a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    886c:	8d 87       	std	Y+13, r24	; 0x0d
    886e:	9e 87       	std	Y+14, r25	; 0x0e
    8870:	af 87       	std	Y+15, r26	; 0x0f
    8872:	b8 8b       	std	Y+16, r27	; 0x10
    8874:	01 c0       	rjmp	.+2      	; 0x8878 <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8876:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8878:	89 81       	ldd	r24, Y+1	; 0x01
    887a:	9a 81       	ldd	r25, Y+2	; 0x02
    887c:	ab 81       	ldd	r26, Y+3	; 0x03
    887e:	bc 81       	ldd	r27, Y+4	; 0x04
    8880:	bc 01       	movw	r22, r24
    8882:	cd 01       	movw	r24, r26
    8884:	0e 94 7b 40 	call	0x80f6	; 0x80f6 <getFirstSector>
    8888:	dc 01       	movw	r26, r24
    888a:	cb 01       	movw	r24, r22
    888c:	89 8b       	std	Y+17, r24	; 0x11
    888e:	9a 8b       	std	Y+18, r25	; 0x12
    8890:	ab 8b       	std	Y+19, r26	; 0x13
    8892:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    8894:	1d 82       	std	Y+5, r1	; 0x05
    8896:	17 c0       	rjmp	.+46     	; 0x88c6 <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8898:	8d 81       	ldd	r24, Y+5	; 0x05
    889a:	28 2f       	mov	r18, r24
    889c:	30 e0       	ldi	r19, 0x00	; 0
    889e:	40 e0       	ldi	r20, 0x00	; 0
    88a0:	50 e0       	ldi	r21, 0x00	; 0
    88a2:	89 89       	ldd	r24, Y+17	; 0x11
    88a4:	9a 89       	ldd	r25, Y+18	; 0x12
    88a6:	ab 89       	ldd	r26, Y+19	; 0x13
    88a8:	bc 89       	ldd	r27, Y+20	; 0x14
    88aa:	82 0f       	add	r24, r18
    88ac:	93 1f       	adc	r25, r19
    88ae:	a4 1f       	adc	r26, r20
    88b0:	b5 1f       	adc	r27, r21
    88b2:	28 ed       	ldi	r18, 0xD8	; 216
    88b4:	33 e2       	ldi	r19, 0x23	; 35
    88b6:	bc 01       	movw	r22, r24
    88b8:	cd 01       	movw	r24, r26
    88ba:	a9 01       	movw	r20, r18
    88bc:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    88c0:	8d 81       	ldd	r24, Y+5	; 0x05
    88c2:	8f 5f       	subi	r24, 0xFF	; 255
    88c4:	8d 83       	std	Y+5, r24	; 0x05
    88c6:	8d 81       	ldd	r24, Y+5	; 0x05
    88c8:	28 2f       	mov	r18, r24
    88ca:	30 e0       	ldi	r19, 0x00	; 0
    88cc:	80 91 7c 50 	lds	r24, 0x507C
    88d0:	90 91 7d 50 	lds	r25, 0x507D
    88d4:	28 17       	cp	r18, r24
    88d6:	39 07       	cpc	r19, r25
    88d8:	f8 f2       	brcs	.-66     	; 0x8898 <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    88da:	89 81       	ldd	r24, Y+1	; 0x01
    88dc:	9a 81       	ldd	r25, Y+2	; 0x02
    88de:	ab 81       	ldd	r26, Y+3	; 0x03
    88e0:	bc 81       	ldd	r27, Y+4	; 0x04
    88e2:	bc 01       	movw	r22, r24
    88e4:	cd 01       	movw	r24, r26
    88e6:	40 e0       	ldi	r20, 0x00	; 0
    88e8:	00 e0       	ldi	r16, 0x00	; 0
    88ea:	10 e0       	ldi	r17, 0x00	; 0
    88ec:	98 01       	movw	r18, r16
    88ee:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
    88f2:	dc 01       	movw	r26, r24
    88f4:	cb 01       	movw	r24, r22
    88f6:	89 83       	std	Y+1, r24	; 0x01
    88f8:	9a 83       	std	Y+2, r25	; 0x02
    88fa:	ab 83       	std	Y+3, r26	; 0x03
    88fc:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    88fe:	89 81       	ldd	r24, Y+1	; 0x01
    8900:	9a 81       	ldd	r25, Y+2	; 0x02
    8902:	ab 81       	ldd	r26, Y+3	; 0x03
    8904:	bc 81       	ldd	r27, Y+4	; 0x04
    8906:	00 97       	sbiw	r24, 0x00	; 0
    8908:	a1 05       	cpc	r26, r1
    890a:	b1 05       	cpc	r27, r1
    890c:	09 f0       	breq	.+2      	; 0x8910 <readFile+0x14c>
    890e:	b3 cf       	rjmp	.-154    	; 0x8876 <readFile+0xb2>
	  return 0;}
    8910:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8912:	67 96       	adiw	r28, 0x17	; 23
    8914:	cd bf       	out	0x3d, r28	; 61
    8916:	de bf       	out	0x3e, r29	; 62
    8918:	df 91       	pop	r29
    891a:	cf 91       	pop	r28
    891c:	1f 91       	pop	r17
    891e:	0f 91       	pop	r16
    8920:	08 95       	ret

00008922 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8922:	cf 93       	push	r28
    8924:	df 93       	push	r29
    8926:	cd b7       	in	r28, 0x3d	; 61
    8928:	de b7       	in	r29, 0x3e	; 62
    892a:	62 97       	sbiw	r28, 0x12	; 18
    892c:	cd bf       	out	0x3d, r28	; 61
    892e:	de bf       	out	0x3e, r29	; 62
    8930:	89 8b       	std	Y+17, r24	; 0x11
    8932:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8934:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    8936:	89 89       	ldd	r24, Y+17	; 0x11
    8938:	9a 89       	ldd	r25, Y+18	; 0x12
    893a:	9c 01       	movw	r18, r24
    893c:	f9 01       	movw	r30, r18
    893e:	01 90       	ld	r0, Z+
    8940:	00 20       	and	r0, r0
    8942:	e9 f7       	brne	.-6      	; 0x893e <convertFileName+0x1c>
    8944:	cf 01       	movw	r24, r30
    8946:	01 97       	sbiw	r24, 0x01	; 1
    8948:	82 1b       	sub	r24, r18
    894a:	93 0b       	sbc	r25, r19
    894c:	80 31       	cpi	r24, 0x10	; 16
    894e:	91 05       	cpc	r25, r1
    8950:	10 f0       	brcs	.+4      	; 0x8956 <convertFileName+0x34>
    8952:	81 e0       	ldi	r24, 0x01	; 1
    8954:	16 c1       	rjmp	.+556    	; 0x8b82 <convertFileName+0x260>
int i=0;
    8956:	1c 82       	std	Y+4, r1	; 0x04
    8958:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    895a:	13 c0       	rjmp	.+38     	; 0x8982 <convertFileName+0x60>
	Filename[i] = fileName[i];
    895c:	8c 81       	ldd	r24, Y+4	; 0x04
    895e:	9d 81       	ldd	r25, Y+5	; 0x05
    8960:	29 89       	ldd	r18, Y+17	; 0x11
    8962:	3a 89       	ldd	r19, Y+18	; 0x12
    8964:	82 0f       	add	r24, r18
    8966:	93 1f       	adc	r25, r19
    8968:	fc 01       	movw	r30, r24
    896a:	20 81       	ld	r18, Z
    896c:	8c 81       	ldd	r24, Y+4	; 0x04
    896e:	9d 81       	ldd	r25, Y+5	; 0x05
    8970:	84 54       	subi	r24, 0x44	; 68
    8972:	9f 4a       	sbci	r25, 0xAF	; 175
    8974:	fc 01       	movw	r30, r24
    8976:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    8978:	8c 81       	ldd	r24, Y+4	; 0x04
    897a:	9d 81       	ldd	r25, Y+5	; 0x05
    897c:	01 96       	adiw	r24, 0x01	; 1
    897e:	8c 83       	std	Y+4, r24	; 0x04
    8980:	9d 83       	std	Y+5, r25	; 0x05
    8982:	4c 81       	ldd	r20, Y+4	; 0x04
    8984:	5d 81       	ldd	r21, Y+5	; 0x05
    8986:	89 89       	ldd	r24, Y+17	; 0x11
    8988:	9a 89       	ldd	r25, Y+18	; 0x12
    898a:	9c 01       	movw	r18, r24
    898c:	f9 01       	movw	r30, r18
    898e:	01 90       	ld	r0, Z+
    8990:	00 20       	and	r0, r0
    8992:	e9 f7       	brne	.-6      	; 0x898e <convertFileName+0x6c>
    8994:	cf 01       	movw	r24, r30
    8996:	01 97       	sbiw	r24, 0x01	; 1
    8998:	82 1b       	sub	r24, r18
    899a:	93 0b       	sbc	r25, r19
    899c:	48 17       	cp	r20, r24
    899e:	59 07       	cpc	r21, r25
    89a0:	e8 f2       	brcs	.-70     	; 0x895c <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    89a2:	0c c0       	rjmp	.+24     	; 0x89bc <convertFileName+0x9a>
    89a4:	8c 81       	ldd	r24, Y+4	; 0x04
    89a6:	9d 81       	ldd	r25, Y+5	; 0x05
    89a8:	84 54       	subi	r24, 0x44	; 68
    89aa:	9f 4a       	sbci	r25, 0xAF	; 175
    89ac:	20 e2       	ldi	r18, 0x20	; 32
    89ae:	fc 01       	movw	r30, r24
    89b0:	20 83       	st	Z, r18
    89b2:	8c 81       	ldd	r24, Y+4	; 0x04
    89b4:	9d 81       	ldd	r25, Y+5	; 0x05
    89b6:	01 96       	adiw	r24, 0x01	; 1
    89b8:	8c 83       	std	Y+4, r24	; 0x04
    89ba:	9d 83       	std	Y+5, r25	; 0x05
    89bc:	8c 81       	ldd	r24, Y+4	; 0x04
    89be:	9d 81       	ldd	r25, Y+5	; 0x05
    89c0:	8f 30       	cpi	r24, 0x0F	; 15
    89c2:	91 05       	cpc	r25, r1
    89c4:	7c f3       	brlt	.-34     	; 0x89a4 <convertFileName+0x82>


for(j=0; j<12; j++)
    89c6:	1a 82       	std	Y+2, r1	; 0x02
    89c8:	0c c0       	rjmp	.+24     	; 0x89e2 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    89ca:	8a 81       	ldd	r24, Y+2	; 0x02
    89cc:	88 2f       	mov	r24, r24
    89ce:	90 e0       	ldi	r25, 0x00	; 0
    89d0:	84 54       	subi	r24, 0x44	; 68
    89d2:	9f 4a       	sbci	r25, 0xAF	; 175
    89d4:	fc 01       	movw	r30, r24
    89d6:	80 81       	ld	r24, Z
    89d8:	8e 32       	cpi	r24, 0x2E	; 46
    89da:	39 f0       	breq	.+14     	; 0x89ea <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    89dc:	8a 81       	ldd	r24, Y+2	; 0x02
    89de:	8f 5f       	subi	r24, 0xFF	; 255
    89e0:	8a 83       	std	Y+2, r24	; 0x02
    89e2:	8a 81       	ldd	r24, Y+2	; 0x02
    89e4:	8c 30       	cpi	r24, 0x0C	; 12
    89e6:	88 f3       	brcs	.-30     	; 0x89ca <convertFileName+0xa8>
    89e8:	01 c0       	rjmp	.+2      	; 0x89ec <convertFileName+0xca>
if(Filename[j] == '.') break;
    89ea:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    89ec:	8a 81       	ldd	r24, Y+2	; 0x02
    89ee:	89 30       	cpi	r24, 0x09	; 9
    89f0:	28 f0       	brcs	.+10     	; 0x89fc <convertFileName+0xda>
    89f2:	8a 81       	ldd	r24, Y+2	; 0x02
    89f4:	8c 30       	cpi	r24, 0x0C	; 12
    89f6:	10 f4       	brcc	.+4      	; 0x89fc <convertFileName+0xda>
	return 1;}
    89f8:	81 e0       	ldi	r24, 0x01	; 1
    89fa:	c3 c0       	rjmp	.+390    	; 0x8b82 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    89fc:	8a 81       	ldd	r24, Y+2	; 0x02
    89fe:	8c 30       	cpi	r24, 0x0C	; 12
    8a00:	11 f4       	brne	.+4      	; 0x8a06 <convertFileName+0xe4>
    8a02:	81 e0       	ldi	r24, 0x01	; 1
    8a04:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8a06:	1b 82       	std	Y+3, r1	; 0x03
    8a08:	14 c0       	rjmp	.+40     	; 0x8a32 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    8a0c:	88 2f       	mov	r24, r24
    8a0e:	90 e0       	ldi	r25, 0x00	; 0
    8a10:	2b 81       	ldd	r18, Y+3	; 0x03
    8a12:	22 2f       	mov	r18, r18
    8a14:	30 e0       	ldi	r19, 0x00	; 0
    8a16:	24 54       	subi	r18, 0x44	; 68
    8a18:	3f 4a       	sbci	r19, 0xAF	; 175
    8a1a:	f9 01       	movw	r30, r18
    8a1c:	40 81       	ld	r20, Z
    8a1e:	9e 01       	movw	r18, r28
    8a20:	2a 5f       	subi	r18, 0xFA	; 250
    8a22:	3f 4f       	sbci	r19, 0xFF	; 255
    8a24:	82 0f       	add	r24, r18
    8a26:	93 1f       	adc	r25, r19
    8a28:	fc 01       	movw	r30, r24
    8a2a:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    8a2e:	8f 5f       	subi	r24, 0xFF	; 255
    8a30:	8b 83       	std	Y+3, r24	; 0x03
    8a32:	9b 81       	ldd	r25, Y+3	; 0x03
    8a34:	8a 81       	ldd	r24, Y+2	; 0x02
    8a36:	98 17       	cp	r25, r24
    8a38:	40 f3       	brcs	.-48     	; 0x8a0a <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8a3a:	8a 81       	ldd	r24, Y+2	; 0x02
    8a3c:	8b 83       	std	Y+3, r24	; 0x03
    8a3e:	0e c0       	rjmp	.+28     	; 0x8a5c <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8a40:	8b 81       	ldd	r24, Y+3	; 0x03
    8a42:	88 2f       	mov	r24, r24
    8a44:	90 e0       	ldi	r25, 0x00	; 0
    8a46:	9e 01       	movw	r18, r28
    8a48:	2a 5f       	subi	r18, 0xFA	; 250
    8a4a:	3f 4f       	sbci	r19, 0xFF	; 255
    8a4c:	82 0f       	add	r24, r18
    8a4e:	93 1f       	adc	r25, r19
    8a50:	20 e2       	ldi	r18, 0x20	; 32
    8a52:	fc 01       	movw	r30, r24
    8a54:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8a56:	8b 81       	ldd	r24, Y+3	; 0x03
    8a58:	8f 5f       	subi	r24, 0xFF	; 255
    8a5a:	8b 83       	std	Y+3, r24	; 0x03
    8a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    8a5e:	88 30       	cpi	r24, 0x08	; 8
    8a60:	78 f3       	brcs	.-34     	; 0x8a40 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8a62:	99 81       	ldd	r25, Y+1	; 0x01
    8a64:	81 e0       	ldi	r24, 0x01	; 1
    8a66:	89 27       	eor	r24, r25
    8a68:	88 23       	and	r24, r24
    8a6a:	19 f0       	breq	.+6      	; 0x8a72 <convertFileName+0x150>
    8a6c:	8a 81       	ldd	r24, Y+2	; 0x02
    8a6e:	8f 5f       	subi	r24, 0xFF	; 255
    8a70:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8a72:	88 e0       	ldi	r24, 0x08	; 8
    8a74:	8b 83       	std	Y+3, r24	; 0x03
    8a76:	32 c0       	rjmp	.+100    	; 0x8adc <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8a78:	8a 81       	ldd	r24, Y+2	; 0x02
    8a7a:	88 2f       	mov	r24, r24
    8a7c:	90 e0       	ldi	r25, 0x00	; 0
    8a7e:	84 54       	subi	r24, 0x44	; 68
    8a80:	9f 4a       	sbci	r25, 0xAF	; 175
    8a82:	fc 01       	movw	r30, r24
    8a84:	80 81       	ld	r24, Z
    8a86:	88 23       	and	r24, r24
    8a88:	19 f1       	breq	.+70     	; 0x8ad0 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    8a8c:	88 2f       	mov	r24, r24
    8a8e:	90 e0       	ldi	r25, 0x00	; 0
    8a90:	2a 81       	ldd	r18, Y+2	; 0x02
    8a92:	22 2f       	mov	r18, r18
    8a94:	30 e0       	ldi	r19, 0x00	; 0
    8a96:	24 54       	subi	r18, 0x44	; 68
    8a98:	3f 4a       	sbci	r19, 0xAF	; 175
    8a9a:	f9 01       	movw	r30, r18
    8a9c:	40 81       	ld	r20, Z
    8a9e:	9e 01       	movw	r18, r28
    8aa0:	2a 5f       	subi	r18, 0xFA	; 250
    8aa2:	3f 4f       	sbci	r19, 0xFF	; 255
    8aa4:	82 0f       	add	r24, r18
    8aa6:	93 1f       	adc	r25, r19
    8aa8:	fc 01       	movw	r30, r24
    8aaa:	40 83       	st	Z, r20
    8aac:	8a 81       	ldd	r24, Y+2	; 0x02
    8aae:	8f 5f       	subi	r24, 0xFF	; 255
    8ab0:	8a 83       	std	Y+2, r24	; 0x02
    8ab2:	11 c0       	rjmp	.+34     	; 0x8ad6 <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    8ab6:	88 2f       	mov	r24, r24
    8ab8:	90 e0       	ldi	r25, 0x00	; 0
    8aba:	9e 01       	movw	r18, r28
    8abc:	2a 5f       	subi	r18, 0xFA	; 250
    8abe:	3f 4f       	sbci	r19, 0xFF	; 255
    8ac0:	82 0f       	add	r24, r18
    8ac2:	93 1f       	adc	r25, r19
    8ac4:	20 e2       	ldi	r18, 0x20	; 32
    8ac6:	fc 01       	movw	r30, r24
    8ac8:	20 83       	st	Z, r18
    8aca:	8b 81       	ldd	r24, Y+3	; 0x03
    8acc:	8f 5f       	subi	r24, 0xFF	; 255
    8ace:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    8ad2:	8b 30       	cpi	r24, 0x0B	; 11
    8ad4:	78 f3       	brcs	.-34     	; 0x8ab4 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    8ad8:	8f 5f       	subi	r24, 0xFF	; 255
    8ada:	8b 83       	std	Y+3, r24	; 0x03
    8adc:	8b 81       	ldd	r24, Y+3	; 0x03
    8ade:	8b 30       	cpi	r24, 0x0B	; 11
    8ae0:	58 f2       	brcs	.-106    	; 0x8a78 <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8ae2:	1a 82       	std	Y+2, r1	; 0x02
    8ae4:	31 c0       	rjmp	.+98     	; 0x8b48 <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    8ae8:	88 2f       	mov	r24, r24
    8aea:	90 e0       	ldi	r25, 0x00	; 0
    8aec:	9e 01       	movw	r18, r28
    8aee:	2a 5f       	subi	r18, 0xFA	; 250
    8af0:	3f 4f       	sbci	r19, 0xFF	; 255
    8af2:	82 0f       	add	r24, r18
    8af4:	93 1f       	adc	r25, r19
    8af6:	fc 01       	movw	r30, r24
    8af8:	80 81       	ld	r24, Z
    8afa:	81 36       	cpi	r24, 0x61	; 97
    8afc:	10 f1       	brcs	.+68     	; 0x8b42 <convertFileName+0x220>
    8afe:	8a 81       	ldd	r24, Y+2	; 0x02
    8b00:	88 2f       	mov	r24, r24
    8b02:	90 e0       	ldi	r25, 0x00	; 0
    8b04:	9e 01       	movw	r18, r28
    8b06:	2a 5f       	subi	r18, 0xFA	; 250
    8b08:	3f 4f       	sbci	r19, 0xFF	; 255
    8b0a:	82 0f       	add	r24, r18
    8b0c:	93 1f       	adc	r25, r19
    8b0e:	fc 01       	movw	r30, r24
    8b10:	80 81       	ld	r24, Z
    8b12:	8b 37       	cpi	r24, 0x7B	; 123
    8b14:	b0 f4       	brcc	.+44     	; 0x8b42 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8b16:	8a 81       	ldd	r24, Y+2	; 0x02
    8b18:	88 2f       	mov	r24, r24
    8b1a:	90 e0       	ldi	r25, 0x00	; 0
    8b1c:	2a 81       	ldd	r18, Y+2	; 0x02
    8b1e:	22 2f       	mov	r18, r18
    8b20:	30 e0       	ldi	r19, 0x00	; 0
    8b22:	ae 01       	movw	r20, r28
    8b24:	4a 5f       	subi	r20, 0xFA	; 250
    8b26:	5f 4f       	sbci	r21, 0xFF	; 255
    8b28:	24 0f       	add	r18, r20
    8b2a:	35 1f       	adc	r19, r21
    8b2c:	f9 01       	movw	r30, r18
    8b2e:	20 81       	ld	r18, Z
    8b30:	42 2f       	mov	r20, r18
    8b32:	40 52       	subi	r20, 0x20	; 32
    8b34:	9e 01       	movw	r18, r28
    8b36:	2a 5f       	subi	r18, 0xFA	; 250
    8b38:	3f 4f       	sbci	r19, 0xFF	; 255
    8b3a:	82 0f       	add	r24, r18
    8b3c:	93 1f       	adc	r25, r19
    8b3e:	fc 01       	movw	r30, r24
    8b40:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8b42:	8a 81       	ldd	r24, Y+2	; 0x02
    8b44:	8f 5f       	subi	r24, 0xFF	; 255
    8b46:	8a 83       	std	Y+2, r24	; 0x02
    8b48:	8a 81       	ldd	r24, Y+2	; 0x02
    8b4a:	8b 30       	cpi	r24, 0x0B	; 11
    8b4c:	60 f2       	brcs	.-104    	; 0x8ae6 <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8b4e:	1a 82       	std	Y+2, r1	; 0x02
    8b50:	14 c0       	rjmp	.+40     	; 0x8b7a <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8b52:	8a 81       	ldd	r24, Y+2	; 0x02
    8b54:	88 2f       	mov	r24, r24
    8b56:	90 e0       	ldi	r25, 0x00	; 0
    8b58:	2a 81       	ldd	r18, Y+2	; 0x02
    8b5a:	22 2f       	mov	r18, r18
    8b5c:	30 e0       	ldi	r19, 0x00	; 0
    8b5e:	ae 01       	movw	r20, r28
    8b60:	4a 5f       	subi	r20, 0xFA	; 250
    8b62:	5f 4f       	sbci	r21, 0xFF	; 255
    8b64:	24 0f       	add	r18, r20
    8b66:	35 1f       	adc	r19, r21
    8b68:	f9 01       	movw	r30, r18
    8b6a:	20 81       	ld	r18, Z
    8b6c:	84 54       	subi	r24, 0x44	; 68
    8b6e:	9f 4a       	sbci	r25, 0xAF	; 175
    8b70:	fc 01       	movw	r30, r24
    8b72:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8b74:	8a 81       	ldd	r24, Y+2	; 0x02
    8b76:	8f 5f       	subi	r24, 0xFF	; 255
    8b78:	8a 83       	std	Y+2, r24	; 0x02
    8b7a:	8a 81       	ldd	r24, Y+2	; 0x02
    8b7c:	8b 30       	cpi	r24, 0x0B	; 11
    8b7e:	48 f3       	brcs	.-46     	; 0x8b52 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8b80:	80 e0       	ldi	r24, 0x00	; 0
}
    8b82:	62 96       	adiw	r28, 0x12	; 18
    8b84:	cd bf       	out	0x3d, r28	; 61
    8b86:	de bf       	out	0x3e, r29	; 62
    8b88:	df 91       	pop	r29
    8b8a:	cf 91       	pop	r28
    8b8c:	08 95       	ret

00008b8e <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    8b8e:	ef 92       	push	r14
    8b90:	ff 92       	push	r15
    8b92:	0f 93       	push	r16
    8b94:	1f 93       	push	r17
    8b96:	cf 93       	push	r28
    8b98:	df 93       	push	r29
    8b9a:	cd b7       	in	r28, 0x3d	; 61
    8b9c:	de b7       	in	r29, 0x3e	; 62
    8b9e:	e7 97       	sbiw	r28, 0x37	; 55
    8ba0:	cd bf       	out	0x3d, r28	; 61
    8ba2:	de bf       	out	0x3e, r29	; 62
    8ba4:	88 ab       	sts	0x58, r24
    8ba6:	99 ab       	sts	0x59, r25
    8ba8:	6a ab       	sts	0x5a, r22
    8baa:	7b ab       	sts	0x5b, r23
    8bac:	2c ab       	sts	0x5c, r18
    8bae:	3d ab       	sts	0x5d, r19
    8bb0:	4e ab       	sts	0x5e, r20
    8bb2:	5f ab       	sts	0x5f, r21
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8bb4:	1a 82       	std	Y+2, r1	; 0x02
    8bb6:	1b 82       	std	Y+3, r1	; 0x03
    8bb8:	1c 82       	std	Y+4, r1	; 0x04
    8bba:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8bbc:	1e 82       	std	Y+6, r1	; 0x06
    8bbe:	1f 82       	std	Y+7, r1	; 0x07
    8bc0:	18 86       	std	Y+8, r1	; 0x08
    8bc2:	19 86       	std	Y+9, r1	; 0x09
    8bc4:	1a 86       	std	Y+10, r1	; 0x0a
    8bc6:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    8bc8:	28 a9       	sts	0x48, r18
    8bca:	39 a9       	sts	0x49, r19
    8bcc:	81 e0       	ldi	r24, 0x01	; 1
    8bce:	b9 01       	movw	r22, r18
    8bd0:	0e 94 e2 43 	call	0x87c4	; 0x87c4 <readFile>
    8bd4:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8bd6:	89 81       	ldd	r24, Y+1	; 0x01
    8bd8:	81 30       	cpi	r24, 0x01	; 1
    8bda:	09 f0       	breq	.+2      	; 0x8bde <writeFile+0x50>
    8bdc:	84 c0       	rjmp	.+264    	; 0x8ce6 <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    8bde:	81 e0       	ldi	r24, 0x01	; 1
    8be0:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8be2:	80 91 88 50 	lds	r24, 0x5088
    8be6:	90 91 89 50 	lds	r25, 0x5089
    8bea:	a0 91 8a 50 	lds	r26, 0x508A
    8bee:	b0 91 8b 50 	lds	r27, 0x508B
    8bf2:	8c 87       	std	Y+12, r24	; 0x0c
    8bf4:	9d 87       	std	Y+13, r25	; 0x0d
    8bf6:	ae 87       	std	Y+14, r26	; 0x0e
    8bf8:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8bfa:	1c 8a       	std	Y+20, r1	; 0x14
    8bfc:	1d 8a       	std	Y+21, r1	; 0x15
    8bfe:	1e 8a       	std	Y+22, r1	; 0x16
    8c00:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8c02:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c04:	9d 85       	ldd	r25, Y+13	; 0x0d
    8c06:	ae 85       	ldd	r26, Y+14	; 0x0e
    8c08:	bf 85       	ldd	r27, Y+15	; 0x0f
    8c0a:	bc 01       	movw	r22, r24
    8c0c:	cd 01       	movw	r24, r26
    8c0e:	40 e0       	ldi	r20, 0x00	; 0
    8c10:	00 e0       	ldi	r16, 0x00	; 0
    8c12:	10 e0       	ldi	r17, 0x00	; 0
    8c14:	98 01       	movw	r18, r16
    8c16:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
    8c1a:	dc 01       	movw	r26, r24
    8c1c:	cb 01       	movw	r24, r22
    8c1e:	8a a3       	lds	r24, 0x5a
    8c20:	9b a3       	lds	r25, 0x5b
    8c22:	ac a3       	lds	r26, 0x5c
    8c24:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    8c26:	8a a1       	lds	r24, 0x4a
    8c28:	9b a1       	lds	r25, 0x4b
    8c2a:	ac a1       	lds	r26, 0x4c
    8c2c:	bd a1       	lds	r27, 0x4d
    8c2e:	8f 3f       	cpi	r24, 0xFF	; 255
    8c30:	0f ef       	ldi	r16, 0xFF	; 255
    8c32:	90 07       	cpc	r25, r16
    8c34:	0f ef       	ldi	r16, 0xFF	; 255
    8c36:	a0 07       	cpc	r26, r16
    8c38:	0f e0       	ldi	r16, 0x0F	; 15
    8c3a:	b0 07       	cpc	r27, r16
    8c3c:	a1 f0       	breq	.+40     	; 0x8c66 <writeFile+0xd8>
	cluster = nextCluster;
    8c3e:	8a a1       	lds	r24, 0x4a
    8c40:	9b a1       	lds	r25, 0x4b
    8c42:	ac a1       	lds	r26, 0x4c
    8c44:	bd a1       	lds	r27, 0x4d
    8c46:	8c 87       	std	Y+12, r24	; 0x0c
    8c48:	9d 87       	std	Y+13, r25	; 0x0d
    8c4a:	ae 87       	std	Y+14, r26	; 0x0e
    8c4c:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8c4e:	8c 89       	ldd	r24, Y+20	; 0x14
    8c50:	9d 89       	ldd	r25, Y+21	; 0x15
    8c52:	ae 89       	ldd	r26, Y+22	; 0x16
    8c54:	bf 89       	ldd	r27, Y+23	; 0x17
    8c56:	01 96       	adiw	r24, 0x01	; 1
    8c58:	a1 1d       	adc	r26, r1
    8c5a:	b1 1d       	adc	r27, r1
    8c5c:	8c 8b       	std	Y+20, r24	; 0x14
    8c5e:	9d 8b       	std	Y+21, r25	; 0x15
    8c60:	ae 8b       	std	Y+22, r26	; 0x16
    8c62:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8c64:	ce cf       	rjmp	.-100    	; 0x8c02 <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8c66:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8c68:	e0 90 49 40 	lds	r14, 0x4049
    8c6c:	f0 90 4a 40 	lds	r15, 0x404A
    8c70:	00 91 4b 40 	lds	r16, 0x404B
    8c74:	10 91 4c 40 	lds	r17, 0x404C
    8c78:	80 91 7c 50 	lds	r24, 0x507C
    8c7c:	90 91 7d 50 	lds	r25, 0x507D
    8c80:	cc 01       	movw	r24, r24
    8c82:	a0 e0       	ldi	r26, 0x00	; 0
    8c84:	b0 e0       	ldi	r27, 0x00	; 0
    8c86:	2c 89       	ldd	r18, Y+20	; 0x14
    8c88:	3d 89       	ldd	r19, Y+21	; 0x15
    8c8a:	4e 89       	ldd	r20, Y+22	; 0x16
    8c8c:	5f 89       	ldd	r21, Y+23	; 0x17
    8c8e:	bc 01       	movw	r22, r24
    8c90:	cd 01       	movw	r24, r26
    8c92:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    8c96:	dc 01       	movw	r26, r24
    8c98:	cb 01       	movw	r24, r22
    8c9a:	20 91 4d 40 	lds	r18, 0x404D
    8c9e:	30 91 4e 40 	lds	r19, 0x404E
    8ca2:	99 01       	movw	r18, r18
    8ca4:	40 e0       	ldi	r20, 0x00	; 0
    8ca6:	50 e0       	ldi	r21, 0x00	; 0
    8ca8:	bc 01       	movw	r22, r24
    8caa:	cd 01       	movw	r24, r26
    8cac:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    8cb0:	dc 01       	movw	r26, r24
    8cb2:	cb 01       	movw	r24, r22
    8cb4:	a8 01       	movw	r20, r16
    8cb6:	97 01       	movw	r18, r14
    8cb8:	28 1b       	sub	r18, r24
    8cba:	39 0b       	sbc	r19, r25
    8cbc:	4a 0b       	sbc	r20, r26
    8cbe:	5b 0b       	sbc	r21, r27
    8cc0:	da 01       	movw	r26, r20
    8cc2:	c9 01       	movw	r24, r18
    8cc4:	20 91 4d 40 	lds	r18, 0x404D
    8cc8:	30 91 4e 40 	lds	r19, 0x404E
    8ccc:	99 01       	movw	r18, r18
    8cce:	40 e0       	ldi	r20, 0x00	; 0
    8cd0:	50 e0       	ldi	r21, 0x00	; 0
    8cd2:	bc 01       	movw	r22, r24
    8cd4:	cd 01       	movw	r24, r26
    8cd6:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    8cda:	da 01       	movw	r26, r20
    8cdc:	c9 01       	movw	r24, r18
    8cde:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8ce0:	81 e0       	ldi	r24, 0x01	; 1
    8ce2:	8b 83       	std	Y+3, r24	; 0x03
    8ce4:	69 c0       	rjmp	.+210    	; 0x8db8 <writeFile+0x22a>
}
else if(j == 2) 
    8ce6:	89 81       	ldd	r24, Y+1	; 0x01
    8ce8:	82 30       	cpi	r24, 0x02	; 2
    8cea:	11 f4       	brne	.+4      	; 0x8cf0 <writeFile+0x162>
   return 1; //invalid file name
    8cec:	81 e0       	ldi	r24, 0x01	; 1
    8cee:	1b c3       	rjmp	.+1590   	; 0x9326 <writeFile+0x798>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8cf0:	82 e0       	ldi	r24, 0x02	; 2
    8cf2:	60 e0       	ldi	r22, 0x00	; 0
    8cf4:	20 e0       	ldi	r18, 0x00	; 0
    8cf6:	30 e0       	ldi	r19, 0x00	; 0
    8cf8:	a9 01       	movw	r20, r18
    8cfa:	0e 94 57 41 	call	0x82ae	; 0x82ae <getSetFreeCluster>
    8cfe:	dc 01       	movw	r26, r24
    8d00:	cb 01       	movw	r24, r22
    8d02:	8c 87       	std	Y+12, r24	; 0x0c
    8d04:	9d 87       	std	Y+13, r25	; 0x0d
    8d06:	ae 87       	std	Y+14, r26	; 0x0e
    8d08:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8d0a:	80 91 5a 40 	lds	r24, 0x405A
    8d0e:	90 91 5b 40 	lds	r25, 0x405B
    8d12:	a0 91 5c 40 	lds	r26, 0x405C
    8d16:	b0 91 5d 40 	lds	r27, 0x405D
    8d1a:	2c 85       	ldd	r18, Y+12	; 0x0c
    8d1c:	3d 85       	ldd	r19, Y+13	; 0x0d
    8d1e:	4e 85       	ldd	r20, Y+14	; 0x0e
    8d20:	5f 85       	ldd	r21, Y+15	; 0x0f
    8d22:	82 17       	cp	r24, r18
    8d24:	93 07       	cpc	r25, r19
    8d26:	a4 07       	cpc	r26, r20
    8d28:	b5 07       	cpc	r27, r21
    8d2a:	60 f4       	brcc	.+24     	; 0x8d44 <writeFile+0x1b6>
     cluster = rootCluster;
    8d2c:	80 91 60 40 	lds	r24, 0x4060
    8d30:	90 91 61 40 	lds	r25, 0x4061
    8d34:	a0 91 62 40 	lds	r26, 0x4062
    8d38:	b0 91 63 40 	lds	r27, 0x4063
    8d3c:	8c 87       	std	Y+12, r24	; 0x0c
    8d3e:	9d 87       	std	Y+13, r25	; 0x0d
    8d40:	ae 87       	std	Y+14, r26	; 0x0e
    8d42:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8d44:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d46:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d48:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d4a:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d4c:	bc 01       	movw	r22, r24
    8d4e:	cd 01       	movw	r24, r26
    8d50:	0e 94 9d 49 	call	0x933a	; 0x933a <searchNextFreeCluster>
    8d54:	dc 01       	movw	r26, r24
    8d56:	cb 01       	movw	r24, r22
    8d58:	8c 87       	std	Y+12, r24	; 0x0c
    8d5a:	9d 87       	std	Y+13, r25	; 0x0d
    8d5c:	ae 87       	std	Y+14, r26	; 0x0e
    8d5e:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8d60:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d62:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d64:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d66:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d68:	00 97       	sbiw	r24, 0x00	; 0
    8d6a:	a1 05       	cpc	r26, r1
    8d6c:	b1 05       	cpc	r27, r1
    8d6e:	11 f4       	brne	.+4      	; 0x8d74 <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    8d70:	82 e0       	ldi	r24, 0x02	; 2
    8d72:	d9 c2       	rjmp	.+1458   	; 0x9326 <writeFile+0x798>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8d74:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d76:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d78:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d7a:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d7c:	bc 01       	movw	r22, r24
    8d7e:	cd 01       	movw	r24, r26
    8d80:	41 e0       	ldi	r20, 0x01	; 1
    8d82:	0f ef       	ldi	r16, 0xFF	; 255
    8d84:	1f ef       	ldi	r17, 0xFF	; 255
    8d86:	2f ef       	ldi	r18, 0xFF	; 255
    8d88:	3f e0       	ldi	r19, 0x0F	; 15
    8d8a:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8d8e:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d90:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d92:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d94:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d96:	cd 01       	movw	r24, r26
    8d98:	aa 27       	eor	r26, r26
    8d9a:	bb 27       	eor	r27, r27
    8d9c:	8e 83       	std	Y+6, r24	; 0x06
    8d9e:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8da0:	8c 85       	ldd	r24, Y+12	; 0x0c
    8da2:	9d 85       	ldd	r25, Y+13	; 0x0d
    8da4:	88 87       	std	Y+8, r24	; 0x08
    8da6:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8da8:	10 92 49 40 	sts	0x4049, r1
    8dac:	10 92 4a 40 	sts	0x404A, r1
    8db0:	10 92 4b 40 	sts	0x404B, r1
    8db4:	10 92 4c 40 	sts	0x404C, r1
}

//start writing data here

if(start){
    8db8:	8b 81       	ldd	r24, Y+3	; 0x03
    8dba:	88 23       	and	r24, r24
    8dbc:	11 f1       	breq	.+68     	; 0x8e02 <writeFile+0x274>
  start = 0;
    8dbe:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    8dc0:	8c 85       	ldd	r24, Y+12	; 0x0c
    8dc2:	9d 85       	ldd	r25, Y+13	; 0x0d
    8dc4:	ae 85       	ldd	r26, Y+14	; 0x0e
    8dc6:	bf 85       	ldd	r27, Y+15	; 0x0f
    8dc8:	bc 01       	movw	r22, r24
    8dca:	cd 01       	movw	r24, r26
    8dcc:	0e 94 7b 40 	call	0x80f6	; 0x80f6 <getFirstSector>
    8dd0:	dc 01       	movw	r26, r24
    8dd2:	cb 01       	movw	r24, r22
    8dd4:	9c 01       	movw	r18, r24
    8dd6:	8d 81       	ldd	r24, Y+5	; 0x05
    8dd8:	88 2f       	mov	r24, r24
    8dda:	90 e0       	ldi	r25, 0x00	; 0
    8ddc:	82 0f       	add	r24, r18
    8dde:	93 1f       	adc	r25, r19
    8de0:	8a 87       	std	Y+10, r24	; 0x0a
    8de2:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    8de4:	8a 85       	ldd	r24, Y+10	; 0x0a
    8de6:	9b 85       	ldd	r25, Y+11	; 0x0b
    8de8:	cc 01       	movw	r24, r24
    8dea:	a0 e0       	ldi	r26, 0x00	; 0
    8dec:	b0 e0       	ldi	r27, 0x00	; 0
    8dee:	2f ec       	ldi	r18, 0xCF	; 207
    8df0:	31 e2       	ldi	r19, 0x21	; 33
    8df2:	bc 01       	movw	r22, r24
    8df4:	cd 01       	movw	r24, r26
    8df6:	a9 01       	movw	r20, r18
    8df8:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
  j = sector;
    8dfc:	8d 81       	ldd	r24, Y+5	; 0x05
    8dfe:	89 83       	std	Y+1, r24	; 0x01
    8e00:	0d c0       	rjmp	.+26     	; 0x8e1c <writeFile+0x28e>
}
else{
  startBlock = getFirstSector (cluster);
    8e02:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e04:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e06:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e08:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e0a:	bc 01       	movw	r22, r24
    8e0c:	cd 01       	movw	r24, r26
    8e0e:	0e 94 7b 40 	call	0x80f6	; 0x80f6 <getFirstSector>
    8e12:	dc 01       	movw	r26, r24
    8e14:	cb 01       	movw	r24, r22
    8e16:	8a 87       	std	Y+10, r24	; 0x0a
    8e18:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    8e1a:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    8e1c:	18 8e       	std	Y+24, r1	; 0x18
    8e1e:	19 8e       	std	Y+25, r1	; 0x19
    8e20:	1a 8e       	std	Y+26, r1	; 0x1a
    8e22:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    8e24:	1c 8e       	std	Y+28, r1	; 0x1c
    8e26:	1d 8e       	std	Y+29, r1	; 0x1d
    8e28:	1e 8e       	std	Y+30, r1	; 0x1e
    8e2a:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    8e2c:	cd c0       	rjmp	.+410    	; 0x8fc8 <writeFile+0x43a>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    8e2e:	8c a9       	sts	0x4c, r24
    8e30:	9d a9       	sts	0x4d, r25
    8e32:	ae a9       	sts	0x4e, r26
    8e34:	bf a9       	sts	0x4f, r27
    8e36:	80 30       	cpi	r24, 0x00	; 0
    8e38:	32 e0       	ldi	r19, 0x02	; 2
    8e3a:	93 07       	cpc	r25, r19
    8e3c:	30 e0       	ldi	r19, 0x00	; 0
    8e3e:	a3 07       	cpc	r26, r19
    8e40:	30 e0       	ldi	r19, 0x00	; 0
    8e42:	b3 07       	cpc	r27, r19
    8e44:	08 f1       	brcs	.+66     	; 0x8e88 <writeFile+0x2fa>
		 writtenData += 512;
    8e46:	88 8d       	ldd	r24, Y+24	; 0x18
    8e48:	99 8d       	ldd	r25, Y+25	; 0x19
    8e4a:	aa 8d       	ldd	r26, Y+26	; 0x1a
    8e4c:	bb 8d       	ldd	r27, Y+27	; 0x1b
    8e4e:	80 50       	subi	r24, 0x00	; 0
    8e50:	9e 4f       	sbci	r25, 0xFE	; 254
    8e52:	af 4f       	sbci	r26, 0xFF	; 255
    8e54:	bf 4f       	sbci	r27, 0xFF	; 255
    8e56:	88 8f       	std	Y+24, r24	; 0x18
    8e58:	99 8f       	std	Y+25, r25	; 0x19
    8e5a:	aa 8f       	std	Y+26, r26	; 0x1a
    8e5c:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    8e5e:	80 e0       	ldi	r24, 0x00	; 0
    8e60:	92 e0       	ldi	r25, 0x02	; 2
    8e62:	a0 e0       	ldi	r26, 0x00	; 0
    8e64:	b0 e0       	ldi	r27, 0x00	; 0
    8e66:	8c 8f       	std	Y+28, r24	; 0x1c
    8e68:	9d 8f       	std	Y+29, r25	; 0x1d
    8e6a:	ae 8f       	std	Y+30, r26	; 0x1e
    8e6c:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    8e6e:	8c a9       	sts	0x4c, r24
    8e70:	9d a9       	sts	0x4d, r25
    8e72:	ae a9       	sts	0x4e, r26
    8e74:	bf a9       	sts	0x4f, r27
    8e76:	80 50       	subi	r24, 0x00	; 0
    8e78:	92 40       	sbci	r25, 0x02	; 2
    8e7a:	a0 40       	sbci	r26, 0x00	; 0
    8e7c:	b0 40       	sbci	r27, 0x00	; 0
    8e7e:	8c ab       	sts	0x5c, r24
    8e80:	9d ab       	sts	0x5d, r25
    8e82:	ae ab       	sts	0x5e, r26
    8e84:	bf ab       	sts	0x5f, r27
    8e86:	1f c0       	rjmp	.+62     	; 0x8ec6 <writeFile+0x338>
	}
	else{
		writtenData += lengthOfData;
    8e88:	28 8d       	ldd	r18, Y+24	; 0x18
    8e8a:	39 8d       	ldd	r19, Y+25	; 0x19
    8e8c:	4a 8d       	ldd	r20, Y+26	; 0x1a
    8e8e:	5b 8d       	ldd	r21, Y+27	; 0x1b
    8e90:	8c a9       	sts	0x4c, r24
    8e92:	9d a9       	sts	0x4d, r25
    8e94:	ae a9       	sts	0x4e, r26
    8e96:	bf a9       	sts	0x4f, r27
    8e98:	82 0f       	add	r24, r18
    8e9a:	93 1f       	adc	r25, r19
    8e9c:	a4 1f       	adc	r26, r20
    8e9e:	b5 1f       	adc	r27, r21
    8ea0:	88 8f       	std	Y+24, r24	; 0x18
    8ea2:	99 8f       	std	Y+25, r25	; 0x19
    8ea4:	aa 8f       	std	Y+26, r26	; 0x1a
    8ea6:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    8ea8:	8c a9       	sts	0x4c, r24
    8eaa:	9d a9       	sts	0x4d, r25
    8eac:	ae a9       	sts	0x4e, r26
    8eae:	bf a9       	sts	0x4f, r27
    8eb0:	91 70       	andi	r25, 0x01	; 1
    8eb2:	a0 70       	andi	r26, 0x00	; 0
    8eb4:	b0 70       	andi	r27, 0x00	; 0
    8eb6:	8c 8f       	std	Y+28, r24	; 0x1c
    8eb8:	9d 8f       	std	Y+29, r25	; 0x1d
    8eba:	ae 8f       	std	Y+30, r26	; 0x1e
    8ebc:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    8ebe:	1c aa       	sts	0x9c, r17
    8ec0:	1d aa       	sts	0x9d, r17
    8ec2:	1e aa       	sts	0x9e, r17
    8ec4:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    8ec6:	80 91 49 40 	lds	r24, 0x4049
    8eca:	90 91 4a 40 	lds	r25, 0x404A
    8ece:	a0 91 4b 40 	lds	r26, 0x404B
    8ed2:	b0 91 4c 40 	lds	r27, 0x404C
    8ed6:	80 50       	subi	r24, 0x00	; 0
    8ed8:	9e 4f       	sbci	r25, 0xFE	; 254
    8eda:	af 4f       	sbci	r26, 0xFF	; 255
    8edc:	bf 4f       	sbci	r27, 0xFF	; 255
    8ede:	80 93 49 40 	sts	0x4049, r24
    8ee2:	90 93 4a 40 	sts	0x404A, r25
    8ee6:	a0 93 4b 40 	sts	0x404B, r26
    8eea:	b0 93 4c 40 	sts	0x404C, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    8eee:	8a 85       	ldd	r24, Y+10	; 0x0a
    8ef0:	9b 85       	ldd	r25, Y+11	; 0x0b
    8ef2:	cc 01       	movw	r24, r24
    8ef4:	a0 e0       	ldi	r26, 0x00	; 0
    8ef6:	b0 e0       	ldi	r27, 0x00	; 0
    8ef8:	48 8d       	ldd	r20, Y+24	; 0x18
    8efa:	59 8d       	ldd	r21, Y+25	; 0x19
    8efc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8efe:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8f00:	ba 01       	movw	r22, r20
    8f02:	62 1b       	sub	r22, r18
    8f04:	73 0b       	sbc	r23, r19
    8f06:	9b 01       	movw	r18, r22
    8f08:	4a a9       	sts	0x4a, r20
    8f0a:	5b a9       	sts	0x4b, r21
    8f0c:	42 0f       	add	r20, r18
    8f0e:	53 1f       	adc	r21, r19
    8f10:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8f12:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8f14:	bc 01       	movw	r22, r24
    8f16:	cd 01       	movw	r24, r26
    8f18:	0e 94 d9 4d 	call	0x9bb2	; 0x9bb2 <SD_write_block>
	j++;
    8f1c:	89 81       	ldd	r24, Y+1	; 0x01
    8f1e:	8f 5f       	subi	r24, 0xFF	; 255
    8f20:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    8f22:	89 81       	ldd	r24, Y+1	; 0x01
    8f24:	28 2f       	mov	r18, r24
    8f26:	30 e0       	ldi	r19, 0x00	; 0
    8f28:	80 91 7c 50 	lds	r24, 0x507C
    8f2c:	90 91 7d 50 	lds	r25, 0x507D
    8f30:	28 17       	cp	r18, r24
    8f32:	39 07       	cpc	r19, r25
    8f34:	e1 f5       	brne	.+120    	; 0x8fae <writeFile+0x420>
		j = 0; 
    8f36:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    8f38:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f3a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f3c:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f3e:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f40:	88 8b       	std	Y+16, r24	; 0x10
    8f42:	99 8b       	std	Y+17, r25	; 0x11
    8f44:	aa 8b       	std	Y+18, r26	; 0x12
    8f46:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    8f48:	88 89       	ldd	r24, Y+16	; 0x10
    8f4a:	99 89       	ldd	r25, Y+17	; 0x11
    8f4c:	aa 89       	ldd	r26, Y+18	; 0x12
    8f4e:	bb 89       	ldd	r27, Y+19	; 0x13
    8f50:	bc 01       	movw	r22, r24
    8f52:	cd 01       	movw	r24, r26
    8f54:	0e 94 9d 49 	call	0x933a	; 0x933a <searchNextFreeCluster>
    8f58:	dc 01       	movw	r26, r24
    8f5a:	cb 01       	movw	r24, r22
    8f5c:	8c 87       	std	Y+12, r24	; 0x0c
    8f5e:	9d 87       	std	Y+13, r25	; 0x0d
    8f60:	ae 87       	std	Y+14, r26	; 0x0e
    8f62:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    8f64:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f66:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f68:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f6a:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f6c:	00 97       	sbiw	r24, 0x00	; 0
    8f6e:	a1 05       	cpc	r26, r1
    8f70:	b1 05       	cpc	r27, r1
    8f72:	11 f4       	brne	.+4      	; 0x8f78 <writeFile+0x3ea>
		  //No free cluster!
		  return 2;
    8f74:	82 e0       	ldi	r24, 0x02	; 2
    8f76:	d7 c1       	rjmp	.+942    	; 0x9326 <writeFile+0x798>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    8f78:	88 89       	ldd	r24, Y+16	; 0x10
    8f7a:	99 89       	ldd	r25, Y+17	; 0x11
    8f7c:	aa 89       	ldd	r26, Y+18	; 0x12
    8f7e:	bb 89       	ldd	r27, Y+19	; 0x13
    8f80:	0c 85       	ldd	r16, Y+12	; 0x0c
    8f82:	1d 85       	ldd	r17, Y+13	; 0x0d
    8f84:	2e 85       	ldd	r18, Y+14	; 0x0e
    8f86:	3f 85       	ldd	r19, Y+15	; 0x0f
    8f88:	bc 01       	movw	r22, r24
    8f8a:	cd 01       	movw	r24, r26
    8f8c:	41 e0       	ldi	r20, 0x01	; 1
    8f8e:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    8f92:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f94:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f96:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f98:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f9a:	bc 01       	movw	r22, r24
    8f9c:	cd 01       	movw	r24, r26
    8f9e:	41 e0       	ldi	r20, 0x01	; 1
    8fa0:	0f ef       	ldi	r16, 0xFF	; 255
    8fa2:	1f ef       	ldi	r17, 0xFF	; 255
    8fa4:	2f ef       	ldi	r18, 0xFF	; 255
    8fa6:	3f e0       	ldi	r19, 0x0F	; 15
    8fa8:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
    8fac:	05 c0       	rjmp	.+10     	; 0x8fb8 <writeFile+0x42a>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    8fae:	8a 85       	ldd	r24, Y+10	; 0x0a
    8fb0:	9b 85       	ldd	r25, Y+11	; 0x0b
    8fb2:	01 96       	adiw	r24, 0x01	; 1
    8fb4:	8a 87       	std	Y+10, r24	; 0x0a
    8fb6:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    8fb8:	2c 85       	ldd	r18, Y+12	; 0x0c
    8fba:	3d 85       	ldd	r19, Y+13	; 0x0d
    8fbc:	4e 85       	ldd	r20, Y+14	; 0x0e
    8fbe:	5f 85       	ldd	r21, Y+15	; 0x0f
    8fc0:	82 e0       	ldi	r24, 0x02	; 2
    8fc2:	61 e0       	ldi	r22, 0x01	; 1
    8fc4:	0e 94 57 41 	call	0x82ae	; 0x82ae <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    8fc8:	8c a9       	sts	0x4c, r24
    8fca:	9d a9       	sts	0x4d, r25
    8fcc:	ae a9       	sts	0x4e, r26
    8fce:	bf a9       	sts	0x4f, r27
    8fd0:	00 97       	sbiw	r24, 0x00	; 0
    8fd2:	a1 05       	cpc	r26, r1
    8fd4:	b1 05       	cpc	r27, r1
    8fd6:	09 f0       	breq	.+2      	; 0x8fda <writeFile+0x44c>
    8fd8:	2a cf       	rjmp	.-428    	; 0x8e2e <writeFile+0x2a0>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    8fda:	8c 81       	ldd	r24, Y+4	; 0x04
    8fdc:	88 23       	and	r24, r24
    8fde:	09 f4       	brne	.+2      	; 0x8fe2 <writeFile+0x454>
    8fe0:	66 c0       	rjmp	.+204    	; 0x90ae <writeFile+0x520>
{
  SD_read_block (appendFileSector,SDBuffer);    
    8fe2:	80 91 d2 50 	lds	r24, 0x50D2
    8fe6:	90 91 d3 50 	lds	r25, 0x50D3
    8fea:	a0 91 d4 50 	lds	r26, 0x50D4
    8fee:	b0 91 d5 50 	lds	r27, 0x50D5
    8ff2:	2f ec       	ldi	r18, 0xCF	; 207
    8ff4:	31 e2       	ldi	r19, 0x21	; 33
    8ff6:	bc 01       	movw	r22, r24
    8ff8:	cd 01       	movw	r24, r26
    8ffa:	a9 01       	movw	r20, r18
    8ffc:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    9000:	80 91 d0 23 	lds	r24, 0x23D0
    9004:	90 91 d1 23 	lds	r25, 0x23D1
    9008:	a0 91 d2 23 	lds	r26, 0x23D2
    900c:	b0 91 d3 23 	lds	r27, 0x23D3
    9010:	81 53       	subi	r24, 0x31	; 49
    9012:	9e 4d       	sbci	r25, 0xDE	; 222
    9014:	8e a3       	lds	r24, 0x5e
    9016:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    9018:	8e a1       	lds	r24, 0x4e
    901a:	9f a1       	lds	r25, 0x4f
    901c:	fc 01       	movw	r30, r24
    901e:	12 8a       	std	Z+18, r1	; 0x12
    9020:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    9022:	20 91 49 40 	lds	r18, 0x4049
    9026:	30 91 4a 40 	lds	r19, 0x404A
    902a:	40 91 4b 40 	lds	r20, 0x404B
    902e:	50 91 4c 40 	lds	r21, 0x404C
    9032:	8e a1       	lds	r24, 0x4e
    9034:	9f a1       	lds	r25, 0x4f
    9036:	fc 01       	movw	r30, r24
    9038:	84 8d       	ldd	r24, Z+28	; 0x1c
    903a:	95 8d       	ldd	r25, Z+29	; 0x1d
    903c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    903e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    9040:	79 01       	movw	r14, r18
    9042:	8a 01       	movw	r16, r20
    9044:	e8 1a       	sub	r14, r24
    9046:	f9 0a       	sbc	r15, r25
    9048:	0a 0b       	sbc	r16, r26
    904a:	1b 0b       	sbc	r17, r27
    904c:	d8 01       	movw	r26, r16
    904e:	c7 01       	movw	r24, r14
    9050:	88 a7       	lds	r24, 0x78
    9052:	99 a7       	lds	r25, 0x79
    9054:	aa a7       	lds	r26, 0x7a
    9056:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    9058:	80 91 49 40 	lds	r24, 0x4049
    905c:	90 91 4a 40 	lds	r25, 0x404A
    9060:	a0 91 4b 40 	lds	r26, 0x404B
    9064:	b0 91 4c 40 	lds	r27, 0x404C
    9068:	2e a1       	lds	r18, 0x4e
    906a:	3f a1       	lds	r19, 0x4f
    906c:	f9 01       	movw	r30, r18
    906e:	84 8f       	std	Z+28, r24	; 0x1c
    9070:	95 8f       	std	Z+29, r25	; 0x1d
    9072:	a6 8f       	std	Z+30, r26	; 0x1e
    9074:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    9076:	80 91 d2 50 	lds	r24, 0x50D2
    907a:	90 91 d3 50 	lds	r25, 0x50D3
    907e:	a0 91 d4 50 	lds	r26, 0x50D4
    9082:	b0 91 d5 50 	lds	r27, 0x50D5
    9086:	2f ec       	ldi	r18, 0xCF	; 207
    9088:	31 e2       	ldi	r19, 0x21	; 33
    908a:	bc 01       	movw	r22, r24
    908c:	cd 01       	movw	r24, r26
    908e:	a9 01       	movw	r20, r18
    9090:	20 e0       	ldi	r18, 0x00	; 0
    9092:	32 e0       	ldi	r19, 0x02	; 2
    9094:	0e 94 d9 4d 	call	0x9bb2	; 0x9bb2 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    9098:	28 a5       	lds	r18, 0x68
    909a:	39 a5       	lds	r19, 0x69
    909c:	4a a5       	lds	r20, 0x6a
    909e:	5b a5       	lds	r21, 0x6b
    90a0:	81 e0       	ldi	r24, 0x01	; 1
    90a2:	ba 01       	movw	r22, r20
    90a4:	a9 01       	movw	r20, r18
    90a6:	0e 94 76 4a 	call	0x94ec	; 0x94ec <freeMemoryUpdate>

 //File appended!
  return 0;
    90aa:	80 e0       	ldi	r24, 0x00	; 0
    90ac:	3c c1       	rjmp	.+632    	; 0x9326 <writeFile+0x798>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    90ae:	80 91 60 40 	lds	r24, 0x4060
    90b2:	90 91 61 40 	lds	r25, 0x4061
    90b6:	a0 91 62 40 	lds	r26, 0x4062
    90ba:	b0 91 63 40 	lds	r27, 0x4063
    90be:	88 8b       	std	Y+16, r24	; 0x10
    90c0:	99 8b       	std	Y+17, r25	; 0x11
    90c2:	aa 8b       	std	Y+18, r26	; 0x12
    90c4:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    90c6:	88 89       	ldd	r24, Y+16	; 0x10
    90c8:	99 89       	ldd	r25, Y+17	; 0x11
    90ca:	aa 89       	ldd	r26, Y+18	; 0x12
    90cc:	bb 89       	ldd	r27, Y+19	; 0x13
    90ce:	bc 01       	movw	r22, r24
    90d0:	cd 01       	movw	r24, r26
    90d2:	0e 94 7b 40 	call	0x80f6	; 0x80f6 <getFirstSector>
    90d6:	dc 01       	movw	r26, r24
    90d8:	cb 01       	movw	r24, r22
    90da:	8c a7       	lds	r24, 0x7c
    90dc:	9d a7       	lds	r25, 0x7d
    90de:	ae a7       	lds	r26, 0x7e
    90e0:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    90e2:	1d 82       	std	Y+5, r1	; 0x05
    90e4:	ad c0       	rjmp	.+346    	; 0x9240 <writeFile+0x6b2>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    90e6:	8d 81       	ldd	r24, Y+5	; 0x05
    90e8:	28 2f       	mov	r18, r24
    90ea:	30 e0       	ldi	r19, 0x00	; 0
    90ec:	40 e0       	ldi	r20, 0x00	; 0
    90ee:	50 e0       	ldi	r21, 0x00	; 0
    90f0:	8c a5       	lds	r24, 0x6c
    90f2:	9d a5       	lds	r25, 0x6d
    90f4:	ae a5       	lds	r26, 0x6e
    90f6:	bf a5       	lds	r27, 0x6f
    90f8:	82 0f       	add	r24, r18
    90fa:	93 1f       	adc	r25, r19
    90fc:	a4 1f       	adc	r26, r20
    90fe:	b5 1f       	adc	r27, r21
    9100:	2f ec       	ldi	r18, 0xCF	; 207
    9102:	31 e2       	ldi	r19, 0x21	; 33
    9104:	bc 01       	movw	r22, r24
    9106:	cd 01       	movw	r24, r26
    9108:	a9 01       	movw	r20, r18
    910a:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    910e:	18 a2       	lds	r17, 0x98
    9110:	19 a2       	lds	r17, 0x99
    9112:	89 c0       	rjmp	.+274    	; 0x9226 <writeFile+0x698>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    9114:	88 a1       	lds	r24, 0x48
    9116:	99 a1       	lds	r25, 0x49
    9118:	81 53       	subi	r24, 0x31	; 49
    911a:	9e 4d       	sbci	r25, 0xDE	; 222
    911c:	8e a3       	lds	r24, 0x5e
    911e:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    9120:	8a 81       	ldd	r24, Y+2	; 0x02
    9122:	88 23       	and	r24, r24
    9124:	11 f0       	breq	.+4      	; 0x912a <writeFile+0x59c>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    9126:	80 e0       	ldi	r24, 0x00	; 0
    9128:	fe c0       	rjmp	.+508    	; 0x9326 <writeFile+0x798>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    912a:	8e a1       	lds	r24, 0x4e
    912c:	9f a1       	lds	r25, 0x4f
    912e:	fc 01       	movw	r30, r24
    9130:	80 81       	ld	r24, Z
    9132:	88 23       	and	r24, r24
    9134:	39 f0       	breq	.+14     	; 0x9144 <writeFile+0x5b6>
    9136:	8e a1       	lds	r24, 0x4e
    9138:	9f a1       	lds	r25, 0x4f
    913a:	fc 01       	movw	r30, r24
    913c:	80 81       	ld	r24, Z
    913e:	85 3e       	cpi	r24, 0xE5	; 229
    9140:	09 f0       	breq	.+2      	; 0x9144 <writeFile+0x5b6>
    9142:	6c c0       	rjmp	.+216    	; 0x921c <writeFile+0x68e>
		{
		  for(j=0; j<11; j++)
    9144:	19 82       	std	Y+1, r1	; 0x01
    9146:	13 c0       	rjmp	.+38     	; 0x916e <writeFile+0x5e0>
  			dir->name[j] = Filename[j];
    9148:	89 81       	ldd	r24, Y+1	; 0x01
    914a:	88 2f       	mov	r24, r24
    914c:	90 e0       	ldi	r25, 0x00	; 0
    914e:	29 81       	ldd	r18, Y+1	; 0x01
    9150:	22 2f       	mov	r18, r18
    9152:	30 e0       	ldi	r19, 0x00	; 0
    9154:	24 54       	subi	r18, 0x44	; 68
    9156:	3f 4a       	sbci	r19, 0xAF	; 175
    9158:	f9 01       	movw	r30, r18
    915a:	40 81       	ld	r20, Z
    915c:	2e a1       	lds	r18, 0x4e
    915e:	3f a1       	lds	r19, 0x4f
    9160:	82 0f       	add	r24, r18
    9162:	93 1f       	adc	r25, r19
    9164:	fc 01       	movw	r30, r24
    9166:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    9168:	89 81       	ldd	r24, Y+1	; 0x01
    916a:	8f 5f       	subi	r24, 0xFF	; 255
    916c:	89 83       	std	Y+1, r24	; 0x01
    916e:	89 81       	ldd	r24, Y+1	; 0x01
    9170:	8b 30       	cpi	r24, 0x0B	; 11
    9172:	50 f3       	brcs	.-44     	; 0x9148 <writeFile+0x5ba>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    9174:	8e a1       	lds	r24, 0x4e
    9176:	9f a1       	lds	r25, 0x4f
    9178:	20 e2       	ldi	r18, 0x20	; 32
    917a:	fc 01       	movw	r30, r24
    917c:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    917e:	8e a1       	lds	r24, 0x4e
    9180:	9f a1       	lds	r25, 0x4f
    9182:	fc 01       	movw	r30, r24
    9184:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    9186:	8e a1       	lds	r24, 0x4e
    9188:	9f a1       	lds	r25, 0x4f
    918a:	fc 01       	movw	r30, r24
    918c:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    918e:	8e a1       	lds	r24, 0x4e
    9190:	9f a1       	lds	r25, 0x4f
    9192:	fc 01       	movw	r30, r24
    9194:	12 8a       	std	Z+18, r1	; 0x12
    9196:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    9198:	8e a1       	lds	r24, 0x4e
    919a:	9f a1       	lds	r25, 0x4f
    919c:	2e 81       	ldd	r18, Y+6	; 0x06
    919e:	3f 81       	ldd	r19, Y+7	; 0x07
    91a0:	fc 01       	movw	r30, r24
    91a2:	24 8b       	std	Z+20, r18	; 0x14
    91a4:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    91a6:	8e a1       	lds	r24, 0x4e
    91a8:	9f a1       	lds	r25, 0x4f
    91aa:	28 85       	ldd	r18, Y+8	; 0x08
    91ac:	39 85       	ldd	r19, Y+9	; 0x09
    91ae:	fc 01       	movw	r30, r24
    91b0:	22 8f       	std	Z+26, r18	; 0x1a
    91b2:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    91b4:	80 91 49 40 	lds	r24, 0x4049
    91b8:	90 91 4a 40 	lds	r25, 0x404A
    91bc:	a0 91 4b 40 	lds	r26, 0x404B
    91c0:	b0 91 4c 40 	lds	r27, 0x404C
    91c4:	2e a1       	lds	r18, 0x4e
    91c6:	3f a1       	lds	r19, 0x4f
    91c8:	f9 01       	movw	r30, r18
    91ca:	84 8f       	std	Z+28, r24	; 0x1c
    91cc:	95 8f       	std	Z+29, r25	; 0x1d
    91ce:	a6 8f       	std	Z+30, r26	; 0x1e
    91d0:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    91d2:	8d 81       	ldd	r24, Y+5	; 0x05
    91d4:	28 2f       	mov	r18, r24
    91d6:	30 e0       	ldi	r19, 0x00	; 0
    91d8:	40 e0       	ldi	r20, 0x00	; 0
    91da:	50 e0       	ldi	r21, 0x00	; 0
    91dc:	8c a5       	lds	r24, 0x6c
    91de:	9d a5       	lds	r25, 0x6d
    91e0:	ae a5       	lds	r26, 0x6e
    91e2:	bf a5       	lds	r27, 0x6f
    91e4:	82 0f       	add	r24, r18
    91e6:	93 1f       	adc	r25, r19
    91e8:	a4 1f       	adc	r26, r20
    91ea:	b5 1f       	adc	r27, r21
    91ec:	2f ec       	ldi	r18, 0xCF	; 207
    91ee:	31 e2       	ldi	r19, 0x21	; 33
    91f0:	bc 01       	movw	r22, r24
    91f2:	cd 01       	movw	r24, r26
    91f4:	a9 01       	movw	r20, r18
    91f6:	20 e0       	ldi	r18, 0x00	; 0
    91f8:	32 e0       	ldi	r19, 0x02	; 2
    91fa:	0e 94 d9 4d 	call	0x9bb2	; 0x9bb2 <SD_write_block>
		  fileCreatedFlag = 1;
    91fe:	81 e0       	ldi	r24, 0x01	; 1
    9200:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    9202:	20 91 49 40 	lds	r18, 0x4049
    9206:	30 91 4a 40 	lds	r19, 0x404A
    920a:	40 91 4b 40 	lds	r20, 0x404B
    920e:	50 91 4c 40 	lds	r21, 0x404C
    9212:	81 e0       	ldi	r24, 0x01	; 1
    9214:	ba 01       	movw	r22, r20
    9216:	a9 01       	movw	r20, r18
    9218:	0e 94 76 4a 	call	0x94ec	; 0x94ec <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    921c:	88 a1       	lds	r24, 0x48
    921e:	99 a1       	lds	r25, 0x49
    9220:	80 96       	adiw	r24, 0x20	; 32
    9222:	88 a3       	lds	r24, 0x58
    9224:	99 a3       	lds	r25, 0x59
    9226:	28 a1       	lds	r18, 0x48
    9228:	39 a1       	lds	r19, 0x49
    922a:	80 91 4d 40 	lds	r24, 0x404D
    922e:	90 91 4e 40 	lds	r25, 0x404E
    9232:	28 17       	cp	r18, r24
    9234:	39 07       	cpc	r19, r25
    9236:	08 f4       	brcc	.+2      	; 0x923a <writeFile+0x6ac>
    9238:	6d cf       	rjmp	.-294    	; 0x9114 <writeFile+0x586>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    923a:	8d 81       	ldd	r24, Y+5	; 0x05
    923c:	8f 5f       	subi	r24, 0xFF	; 255
    923e:	8d 83       	std	Y+5, r24	; 0x05
    9240:	8d 81       	ldd	r24, Y+5	; 0x05
    9242:	28 2f       	mov	r18, r24
    9244:	30 e0       	ldi	r19, 0x00	; 0
    9246:	80 91 7c 50 	lds	r24, 0x507C
    924a:	90 91 7d 50 	lds	r25, 0x507D
    924e:	28 17       	cp	r18, r24
    9250:	39 07       	cpc	r19, r25
    9252:	08 f4       	brcc	.+2      	; 0x9256 <writeFile+0x6c8>
    9254:	48 cf       	rjmp	.-368    	; 0x90e6 <writeFile+0x558>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    9256:	88 89       	ldd	r24, Y+16	; 0x10
    9258:	99 89       	ldd	r25, Y+17	; 0x11
    925a:	aa 89       	ldd	r26, Y+18	; 0x12
    925c:	bb 89       	ldd	r27, Y+19	; 0x13
    925e:	bc 01       	movw	r22, r24
    9260:	cd 01       	movw	r24, r26
    9262:	40 e0       	ldi	r20, 0x00	; 0
    9264:	00 e0       	ldi	r16, 0x00	; 0
    9266:	10 e0       	ldi	r17, 0x00	; 0
    9268:	98 01       	movw	r18, r16
    926a:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
    926e:	dc 01       	movw	r26, r24
    9270:	cb 01       	movw	r24, r22
    9272:	8c 87       	std	Y+12, r24	; 0x0c
    9274:	9d 87       	std	Y+13, r25	; 0x0d
    9276:	ae 87       	std	Y+14, r26	; 0x0e
    9278:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    927a:	8c 85       	ldd	r24, Y+12	; 0x0c
    927c:	9d 85       	ldd	r25, Y+13	; 0x0d
    927e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9280:	bf 85       	ldd	r27, Y+15	; 0x0f
    9282:	87 3f       	cpi	r24, 0xF7	; 247
    9284:	ff ef       	ldi	r31, 0xFF	; 255
    9286:	9f 07       	cpc	r25, r31
    9288:	ff ef       	ldi	r31, 0xFF	; 255
    928a:	af 07       	cpc	r26, r31
    928c:	ff e0       	ldi	r31, 0x0F	; 15
    928e:	bf 07       	cpc	r27, r31
    9290:	b8 f1       	brcs	.+110    	; 0x9300 <writeFile+0x772>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    9292:	8c 85       	ldd	r24, Y+12	; 0x0c
    9294:	9d 85       	ldd	r25, Y+13	; 0x0d
    9296:	ae 85       	ldd	r26, Y+14	; 0x0e
    9298:	bf 85       	ldd	r27, Y+15	; 0x0f
    929a:	8f 3f       	cpi	r24, 0xFF	; 255
    929c:	0f ef       	ldi	r16, 0xFF	; 255
    929e:	90 07       	cpc	r25, r16
    92a0:	0f ef       	ldi	r16, 0xFF	; 255
    92a2:	a0 07       	cpc	r26, r16
    92a4:	0f e0       	ldi	r16, 0x0F	; 15
    92a6:	b0 07       	cpc	r27, r16
    92a8:	49 f5       	brne	.+82     	; 0x92fc <writeFile+0x76e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    92aa:	88 89       	ldd	r24, Y+16	; 0x10
    92ac:	99 89       	ldd	r25, Y+17	; 0x11
    92ae:	aa 89       	ldd	r26, Y+18	; 0x12
    92b0:	bb 89       	ldd	r27, Y+19	; 0x13
    92b2:	bc 01       	movw	r22, r24
    92b4:	cd 01       	movw	r24, r26
    92b6:	0e 94 9d 49 	call	0x933a	; 0x933a <searchNextFreeCluster>
    92ba:	dc 01       	movw	r26, r24
    92bc:	cb 01       	movw	r24, r22
    92be:	8c 87       	std	Y+12, r24	; 0x0c
    92c0:	9d 87       	std	Y+13, r25	; 0x0d
    92c2:	ae 87       	std	Y+14, r26	; 0x0e
    92c4:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    92c6:	88 89       	ldd	r24, Y+16	; 0x10
    92c8:	99 89       	ldd	r25, Y+17	; 0x11
    92ca:	aa 89       	ldd	r26, Y+18	; 0x12
    92cc:	bb 89       	ldd	r27, Y+19	; 0x13
    92ce:	0c 85       	ldd	r16, Y+12	; 0x0c
    92d0:	1d 85       	ldd	r17, Y+13	; 0x0d
    92d2:	2e 85       	ldd	r18, Y+14	; 0x0e
    92d4:	3f 85       	ldd	r19, Y+15	; 0x0f
    92d6:	bc 01       	movw	r22, r24
    92d8:	cd 01       	movw	r24, r26
    92da:	41 e0       	ldi	r20, 0x01	; 1
    92dc:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    92e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    92e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    92e4:	ae 85       	ldd	r26, Y+14	; 0x0e
    92e6:	bf 85       	ldd	r27, Y+15	; 0x0f
    92e8:	bc 01       	movw	r22, r24
    92ea:	cd 01       	movw	r24, r26
    92ec:	41 e0       	ldi	r20, 0x01	; 1
    92ee:	0f ef       	ldi	r16, 0xFF	; 255
    92f0:	1f ef       	ldi	r17, 0xFF	; 255
    92f2:	2f ef       	ldi	r18, 0xFF	; 255
    92f4:	3f e0       	ldi	r19, 0x0F	; 15
    92f6:	0e 94 ad 40 	call	0x815a	; 0x815a <getSetNextCluster>
    92fa:	02 c0       	rjmp	.+4      	; 0x9300 <writeFile+0x772>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    92fc:	83 e0       	ldi	r24, 0x03	; 3
    92fe:	13 c0       	rjmp	.+38     	; 0x9326 <writeFile+0x798>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    9300:	8c 85       	ldd	r24, Y+12	; 0x0c
    9302:	9d 85       	ldd	r25, Y+13	; 0x0d
    9304:	ae 85       	ldd	r26, Y+14	; 0x0e
    9306:	bf 85       	ldd	r27, Y+15	; 0x0f
    9308:	00 97       	sbiw	r24, 0x00	; 0
    930a:	a1 05       	cpc	r26, r1
    930c:	b1 05       	cpc	r27, r1
    930e:	11 f4       	brne	.+4      	; 0x9314 <writeFile+0x786>
	   return 4;
    9310:	84 e0       	ldi	r24, 0x04	; 4
    9312:	09 c0       	rjmp	.+18     	; 0x9326 <writeFile+0x798>
	}
   
   prevCluster = cluster;
    9314:	8c 85       	ldd	r24, Y+12	; 0x0c
    9316:	9d 85       	ldd	r25, Y+13	; 0x0d
    9318:	ae 85       	ldd	r26, Y+14	; 0x0e
    931a:	bf 85       	ldd	r27, Y+15	; 0x0f
    931c:	88 8b       	std	Y+16, r24	; 0x10
    931e:	99 8b       	std	Y+17, r25	; 0x11
    9320:	aa 8b       	std	Y+18, r26	; 0x12
    9322:	bb 8b       	std	Y+19, r27	; 0x13
 }
    9324:	d0 ce       	rjmp	.-608    	; 0x90c6 <writeFile+0x538>
 
 return 0;
}
    9326:	e7 96       	adiw	r28, 0x37	; 55
    9328:	cd bf       	out	0x3d, r28	; 61
    932a:	de bf       	out	0x3e, r29	; 62
    932c:	df 91       	pop	r29
    932e:	cf 91       	pop	r28
    9330:	1f 91       	pop	r17
    9332:	0f 91       	pop	r16
    9334:	ff 90       	pop	r15
    9336:	ef 90       	pop	r14
    9338:	08 95       	ret

0000933a <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    933a:	ef 92       	push	r14
    933c:	ff 92       	push	r15
    933e:	0f 93       	push	r16
    9340:	1f 93       	push	r17
    9342:	cf 93       	push	r28
    9344:	df 93       	push	r29
    9346:	cd b7       	in	r28, 0x3d	; 61
    9348:	de b7       	in	r29, 0x3e	; 62
    934a:	2f 97       	sbiw	r28, 0x0f	; 15
    934c:	cd bf       	out	0x3d, r28	; 61
    934e:	de bf       	out	0x3e, r29	; 62
    9350:	6c 87       	std	Y+12, r22	; 0x0c
    9352:	7d 87       	std	Y+13, r23	; 0x0d
    9354:	8e 87       	std	Y+14, r24	; 0x0e
    9356:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    9358:	8c 85       	ldd	r24, Y+12	; 0x0c
    935a:	9d 85       	ldd	r25, Y+13	; 0x0d
    935c:	ae 85       	ldd	r26, Y+14	; 0x0e
    935e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9360:	80 78       	andi	r24, 0x80	; 128
    9362:	8c 87       	std	Y+12, r24	; 0x0c
    9364:	9d 87       	std	Y+13, r25	; 0x0d
    9366:	ae 87       	std	Y+14, r26	; 0x0e
    9368:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    936a:	8c 85       	ldd	r24, Y+12	; 0x0c
    936c:	9d 85       	ldd	r25, Y+13	; 0x0d
    936e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9370:	bf 85       	ldd	r27, Y+15	; 0x0f
    9372:	89 83       	std	Y+1, r24	; 0x01
    9374:	9a 83       	std	Y+2, r25	; 0x02
    9376:	ab 83       	std	Y+3, r26	; 0x03
    9378:	bc 83       	std	Y+4, r27	; 0x04
    937a:	7a c0       	rjmp	.+244    	; 0x9470 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    937c:	80 91 84 50 	lds	r24, 0x5084
    9380:	90 91 85 50 	lds	r25, 0x5085
    9384:	9c 01       	movw	r18, r24
    9386:	40 e0       	ldi	r20, 0x00	; 0
    9388:	50 e0       	ldi	r21, 0x00	; 0
    938a:	80 91 7e 50 	lds	r24, 0x507E
    938e:	90 91 7f 50 	lds	r25, 0x507F
    9392:	a0 91 80 50 	lds	r26, 0x5080
    9396:	b0 91 81 50 	lds	r27, 0x5081
    939a:	79 01       	movw	r14, r18
    939c:	8a 01       	movw	r16, r20
    939e:	e8 0e       	add	r14, r24
    93a0:	f9 1e       	adc	r15, r25
    93a2:	0a 1f       	adc	r16, r26
    93a4:	1b 1f       	adc	r17, r27
    93a6:	89 81       	ldd	r24, Y+1	; 0x01
    93a8:	9a 81       	ldd	r25, Y+2	; 0x02
    93aa:	ab 81       	ldd	r26, Y+3	; 0x03
    93ac:	bc 81       	ldd	r27, Y+4	; 0x04
    93ae:	88 0f       	add	r24, r24
    93b0:	99 1f       	adc	r25, r25
    93b2:	aa 1f       	adc	r26, r26
    93b4:	bb 1f       	adc	r27, r27
    93b6:	88 0f       	add	r24, r24
    93b8:	99 1f       	adc	r25, r25
    93ba:	aa 1f       	adc	r26, r26
    93bc:	bb 1f       	adc	r27, r27
    93be:	20 91 4d 40 	lds	r18, 0x404D
    93c2:	30 91 4e 40 	lds	r19, 0x404E
    93c6:	99 01       	movw	r18, r18
    93c8:	40 e0       	ldi	r20, 0x00	; 0
    93ca:	50 e0       	ldi	r21, 0x00	; 0
    93cc:	bc 01       	movw	r22, r24
    93ce:	cd 01       	movw	r24, r26
    93d0:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    93d4:	da 01       	movw	r26, r20
    93d6:	c9 01       	movw	r24, r18
    93d8:	8e 0d       	add	r24, r14
    93da:	9f 1d       	adc	r25, r15
    93dc:	a0 1f       	adc	r26, r16
    93de:	b1 1f       	adc	r27, r17
    93e0:	8e 83       	std	Y+6, r24	; 0x06
    93e2:	9f 83       	std	Y+7, r25	; 0x07
    93e4:	a8 87       	std	Y+8, r26	; 0x08
    93e6:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    93e8:	8e 81       	ldd	r24, Y+6	; 0x06
    93ea:	9f 81       	ldd	r25, Y+7	; 0x07
    93ec:	a8 85       	ldd	r26, Y+8	; 0x08
    93ee:	b9 85       	ldd	r27, Y+9	; 0x09
    93f0:	2f ec       	ldi	r18, 0xCF	; 207
    93f2:	31 e2       	ldi	r19, 0x21	; 33
    93f4:	bc 01       	movw	r22, r24
    93f6:	cd 01       	movw	r24, r26
    93f8:	a9 01       	movw	r20, r18
    93fa:	0e 94 a7 4e 	call	0x9d4e	; 0x9d4e <SD_read_block>
      for(i=0; i<128; i++)
    93fe:	1d 82       	std	Y+5, r1	; 0x05
    9400:	28 c0       	rjmp	.+80     	; 0x9452 <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    9402:	8d 81       	ldd	r24, Y+5	; 0x05
    9404:	88 2f       	mov	r24, r24
    9406:	90 e0       	ldi	r25, 0x00	; 0
    9408:	88 0f       	add	r24, r24
    940a:	99 1f       	adc	r25, r25
    940c:	88 0f       	add	r24, r24
    940e:	99 1f       	adc	r25, r25
    9410:	81 53       	subi	r24, 0x31	; 49
    9412:	9e 4d       	sbci	r25, 0xDE	; 222
    9414:	8a 87       	std	Y+10, r24	; 0x0a
    9416:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    9418:	8a 85       	ldd	r24, Y+10	; 0x0a
    941a:	9b 85       	ldd	r25, Y+11	; 0x0b
    941c:	fc 01       	movw	r30, r24
    941e:	80 81       	ld	r24, Z
    9420:	91 81       	ldd	r25, Z+1	; 0x01
    9422:	a2 81       	ldd	r26, Z+2	; 0x02
    9424:	b3 81       	ldd	r27, Z+3	; 0x03
    9426:	bf 70       	andi	r27, 0x0F	; 15
    9428:	00 97       	sbiw	r24, 0x00	; 0
    942a:	a1 05       	cpc	r26, r1
    942c:	b1 05       	cpc	r27, r1
    942e:	71 f4       	brne	.+28     	; 0x944c <searchNextFreeCluster+0x112>
            return(cluster+i);
    9430:	8d 81       	ldd	r24, Y+5	; 0x05
    9432:	28 2f       	mov	r18, r24
    9434:	30 e0       	ldi	r19, 0x00	; 0
    9436:	40 e0       	ldi	r20, 0x00	; 0
    9438:	50 e0       	ldi	r21, 0x00	; 0
    943a:	89 81       	ldd	r24, Y+1	; 0x01
    943c:	9a 81       	ldd	r25, Y+2	; 0x02
    943e:	ab 81       	ldd	r26, Y+3	; 0x03
    9440:	bc 81       	ldd	r27, Y+4	; 0x04
    9442:	82 0f       	add	r24, r18
    9444:	93 1f       	adc	r25, r19
    9446:	a4 1f       	adc	r26, r20
    9448:	b5 1f       	adc	r27, r21
    944a:	27 c0       	rjmp	.+78     	; 0x949a <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    944c:	8d 81       	ldd	r24, Y+5	; 0x05
    944e:	8f 5f       	subi	r24, 0xFF	; 255
    9450:	8d 83       	std	Y+5, r24	; 0x05
    9452:	8d 81       	ldd	r24, Y+5	; 0x05
    9454:	88 23       	and	r24, r24
    9456:	ac f6       	brge	.-86     	; 0x9402 <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9458:	89 81       	ldd	r24, Y+1	; 0x01
    945a:	9a 81       	ldd	r25, Y+2	; 0x02
    945c:	ab 81       	ldd	r26, Y+3	; 0x03
    945e:	bc 81       	ldd	r27, Y+4	; 0x04
    9460:	80 58       	subi	r24, 0x80	; 128
    9462:	9f 4f       	sbci	r25, 0xFF	; 255
    9464:	af 4f       	sbci	r26, 0xFF	; 255
    9466:	bf 4f       	sbci	r27, 0xFF	; 255
    9468:	89 83       	std	Y+1, r24	; 0x01
    946a:	9a 83       	std	Y+2, r25	; 0x02
    946c:	ab 83       	std	Y+3, r26	; 0x03
    946e:	bc 83       	std	Y+4, r27	; 0x04
    9470:	80 91 5a 40 	lds	r24, 0x405A
    9474:	90 91 5b 40 	lds	r25, 0x405B
    9478:	a0 91 5c 40 	lds	r26, 0x405C
    947c:	b0 91 5d 40 	lds	r27, 0x405D
    9480:	29 81       	ldd	r18, Y+1	; 0x01
    9482:	3a 81       	ldd	r19, Y+2	; 0x02
    9484:	4b 81       	ldd	r20, Y+3	; 0x03
    9486:	5c 81       	ldd	r21, Y+4	; 0x04
    9488:	28 17       	cp	r18, r24
    948a:	39 07       	cpc	r19, r25
    948c:	4a 07       	cpc	r20, r26
    948e:	5b 07       	cpc	r21, r27
    9490:	08 f4       	brcc	.+2      	; 0x9494 <searchNextFreeCluster+0x15a>
    9492:	74 cf       	rjmp	.-280    	; 0x937c <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    9494:	80 e0       	ldi	r24, 0x00	; 0
    9496:	90 e0       	ldi	r25, 0x00	; 0
    9498:	dc 01       	movw	r26, r24
}
    949a:	bc 01       	movw	r22, r24
    949c:	cd 01       	movw	r24, r26
    949e:	2f 96       	adiw	r28, 0x0f	; 15
    94a0:	cd bf       	out	0x3d, r28	; 61
    94a2:	de bf       	out	0x3e, r29	; 62
    94a4:	df 91       	pop	r29
    94a6:	cf 91       	pop	r28
    94a8:	1f 91       	pop	r17
    94aa:	0f 91       	pop	r16
    94ac:	ff 90       	pop	r15
    94ae:	ef 90       	pop	r14
    94b0:	08 95       	ret

000094b2 <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    94b2:	cf 93       	push	r28
    94b4:	df 93       	push	r29
    94b6:	00 d0       	rcall	.+0      	; 0x94b8 <deleteFile+0x6>
    94b8:	cd b7       	in	r28, 0x3d	; 61
    94ba:	de b7       	in	r29, 0x3e	; 62
    94bc:	8a 83       	std	Y+2, r24	; 0x02
    94be:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    94c0:	8a 81       	ldd	r24, Y+2	; 0x02
    94c2:	9b 81       	ldd	r25, Y+3	; 0x03
    94c4:	0e 94 91 44 	call	0x8922	; 0x8922 <convertFileName>
    94c8:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    94ca:	89 81       	ldd	r24, Y+1	; 0x01
    94cc:	88 23       	and	r24, r24
    94ce:	39 f4       	brne	.+14     	; 0x94de <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    94d0:	2c eb       	ldi	r18, 0xBC	; 188
    94d2:	30 e5       	ldi	r19, 0x50	; 80
    94d4:	82 e0       	ldi	r24, 0x02	; 2
    94d6:	b9 01       	movw	r22, r18
    94d8:	0e 94 08 42 	call	0x8410	; 0x8410 <findFiles>
    94dc:	01 c0       	rjmp	.+2      	; 0x94e0 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    94de:	00 00       	nop

  findFiles (DELETE, Filename);
}
    94e0:	23 96       	adiw	r28, 0x03	; 3
    94e2:	cd bf       	out	0x3d, r28	; 61
    94e4:	de bf       	out	0x3e, r29	; 62
    94e6:	df 91       	pop	r29
    94e8:	cf 91       	pop	r28
    94ea:	08 95       	ret

000094ec <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    94ec:	ef 92       	push	r14
    94ee:	ff 92       	push	r15
    94f0:	0f 93       	push	r16
    94f2:	1f 93       	push	r17
    94f4:	cf 93       	push	r28
    94f6:	df 93       	push	r29
    94f8:	cd b7       	in	r28, 0x3d	; 61
    94fa:	de b7       	in	r29, 0x3e	; 62
    94fc:	29 97       	sbiw	r28, 0x09	; 9
    94fe:	cd bf       	out	0x3d, r28	; 61
    9500:	de bf       	out	0x3e, r29	; 62
    9502:	8d 83       	std	Y+5, r24	; 0x05
    9504:	4e 83       	std	Y+6, r20	; 0x06
    9506:	5f 83       	std	Y+7, r21	; 0x07
    9508:	68 87       	std	Y+8, r22	; 0x08
    950a:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    950c:	8e 81       	ldd	r24, Y+6	; 0x06
    950e:	9f 81       	ldd	r25, Y+7	; 0x07
    9510:	a8 85       	ldd	r26, Y+8	; 0x08
    9512:	b9 85       	ldd	r27, Y+9	; 0x09
    9514:	91 70       	andi	r25, 0x01	; 1
    9516:	a0 70       	andi	r26, 0x00	; 0
    9518:	b0 70       	andi	r27, 0x00	; 0
    951a:	00 97       	sbiw	r24, 0x00	; 0
    951c:	a1 05       	cpc	r26, r1
    951e:	b1 05       	cpc	r27, r1
    9520:	91 f4       	brne	.+36     	; 0x9546 <freeMemoryUpdate+0x5a>
    9522:	8e 81       	ldd	r24, Y+6	; 0x06
    9524:	9f 81       	ldd	r25, Y+7	; 0x07
    9526:	a8 85       	ldd	r26, Y+8	; 0x08
    9528:	b9 85       	ldd	r27, Y+9	; 0x09
    952a:	07 2e       	mov	r0, r23
    952c:	79 e0       	ldi	r23, 0x09	; 9
    952e:	b6 95       	lsr	r27
    9530:	a7 95       	ror	r26
    9532:	97 95       	ror	r25
    9534:	87 95       	ror	r24
    9536:	7a 95       	dec	r23
    9538:	d1 f7       	brne	.-12     	; 0x952e <freeMemoryUpdate+0x42>
    953a:	70 2d       	mov	r23, r0
    953c:	8e 83       	std	Y+6, r24	; 0x06
    953e:	9f 83       	std	Y+7, r25	; 0x07
    9540:	a8 87       	std	Y+8, r26	; 0x08
    9542:	b9 87       	std	Y+9, r27	; 0x09
    9544:	14 c0       	rjmp	.+40     	; 0x956e <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    9546:	8e 81       	ldd	r24, Y+6	; 0x06
    9548:	9f 81       	ldd	r25, Y+7	; 0x07
    954a:	a8 85       	ldd	r26, Y+8	; 0x08
    954c:	b9 85       	ldd	r27, Y+9	; 0x09
    954e:	07 2e       	mov	r0, r23
    9550:	79 e0       	ldi	r23, 0x09	; 9
    9552:	b6 95       	lsr	r27
    9554:	a7 95       	ror	r26
    9556:	97 95       	ror	r25
    9558:	87 95       	ror	r24
    955a:	7a 95       	dec	r23
    955c:	d1 f7       	brne	.-12     	; 0x9552 <freeMemoryUpdate+0x66>
    955e:	70 2d       	mov	r23, r0
    9560:	01 96       	adiw	r24, 0x01	; 1
    9562:	a1 1d       	adc	r26, r1
    9564:	b1 1d       	adc	r27, r1
    9566:	8e 83       	std	Y+6, r24	; 0x06
    9568:	9f 83       	std	Y+7, r25	; 0x07
    956a:	a8 87       	std	Y+8, r26	; 0x08
    956c:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    956e:	8e 81       	ldd	r24, Y+6	; 0x06
    9570:	9f 81       	ldd	r25, Y+7	; 0x07
    9572:	a8 85       	ldd	r26, Y+8	; 0x08
    9574:	b9 85       	ldd	r27, Y+9	; 0x09
    9576:	87 70       	andi	r24, 0x07	; 7
    9578:	90 70       	andi	r25, 0x00	; 0
    957a:	a0 70       	andi	r26, 0x00	; 0
    957c:	b0 70       	andi	r27, 0x00	; 0
    957e:	00 97       	sbiw	r24, 0x00	; 0
    9580:	a1 05       	cpc	r26, r1
    9582:	b1 05       	cpc	r27, r1
    9584:	89 f4       	brne	.+34     	; 0x95a8 <freeMemoryUpdate+0xbc>
    9586:	8e 81       	ldd	r24, Y+6	; 0x06
    9588:	9f 81       	ldd	r25, Y+7	; 0x07
    958a:	a8 85       	ldd	r26, Y+8	; 0x08
    958c:	b9 85       	ldd	r27, Y+9	; 0x09
    958e:	68 94       	set
    9590:	12 f8       	bld	r1, 2
    9592:	b6 95       	lsr	r27
    9594:	a7 95       	ror	r26
    9596:	97 95       	ror	r25
    9598:	87 95       	ror	r24
    959a:	16 94       	lsr	r1
    959c:	d1 f7       	brne	.-12     	; 0x9592 <freeMemoryUpdate+0xa6>
    959e:	8e 83       	std	Y+6, r24	; 0x06
    95a0:	9f 83       	std	Y+7, r25	; 0x07
    95a2:	a8 87       	std	Y+8, r26	; 0x08
    95a4:	b9 87       	std	Y+9, r27	; 0x09
    95a6:	13 c0       	rjmp	.+38     	; 0x95ce <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    95a8:	8e 81       	ldd	r24, Y+6	; 0x06
    95aa:	9f 81       	ldd	r25, Y+7	; 0x07
    95ac:	a8 85       	ldd	r26, Y+8	; 0x08
    95ae:	b9 85       	ldd	r27, Y+9	; 0x09
    95b0:	68 94       	set
    95b2:	12 f8       	bld	r1, 2
    95b4:	b6 95       	lsr	r27
    95b6:	a7 95       	ror	r26
    95b8:	97 95       	ror	r25
    95ba:	87 95       	ror	r24
    95bc:	16 94       	lsr	r1
    95be:	d1 f7       	brne	.-12     	; 0x95b4 <freeMemoryUpdate+0xc8>
    95c0:	01 96       	adiw	r24, 0x01	; 1
    95c2:	a1 1d       	adc	r26, r1
    95c4:	b1 1d       	adc	r27, r1
    95c6:	8e 83       	std	Y+6, r24	; 0x06
    95c8:	9f 83       	std	Y+7, r25	; 0x07
    95ca:	a8 87       	std	Y+8, r26	; 0x08
    95cc:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    95ce:	80 91 d0 50 	lds	r24, 0x50D0
    95d2:	88 23       	and	r24, r24
    95d4:	e9 f1       	breq	.+122    	; 0x9650 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    95d6:	81 e0       	ldi	r24, 0x01	; 1
    95d8:	60 e0       	ldi	r22, 0x00	; 0
    95da:	20 e0       	ldi	r18, 0x00	; 0
    95dc:	30 e0       	ldi	r19, 0x00	; 0
    95de:	a9 01       	movw	r20, r18
    95e0:	0e 94 57 41 	call	0x82ae	; 0x82ae <getSetFreeCluster>
    95e4:	dc 01       	movw	r26, r24
    95e6:	cb 01       	movw	r24, r22
    95e8:	89 83       	std	Y+1, r24	; 0x01
    95ea:	9a 83       	std	Y+2, r25	; 0x02
    95ec:	ab 83       	std	Y+3, r26	; 0x03
    95ee:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    95f0:	8d 81       	ldd	r24, Y+5	; 0x05
    95f2:	88 23       	and	r24, r24
    95f4:	89 f4       	brne	.+34     	; 0x9618 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    95f6:	29 81       	ldd	r18, Y+1	; 0x01
    95f8:	3a 81       	ldd	r19, Y+2	; 0x02
    95fa:	4b 81       	ldd	r20, Y+3	; 0x03
    95fc:	5c 81       	ldd	r21, Y+4	; 0x04
    95fe:	8e 81       	ldd	r24, Y+6	; 0x06
    9600:	9f 81       	ldd	r25, Y+7	; 0x07
    9602:	a8 85       	ldd	r26, Y+8	; 0x08
    9604:	b9 85       	ldd	r27, Y+9	; 0x09
    9606:	82 0f       	add	r24, r18
    9608:	93 1f       	adc	r25, r19
    960a:	a4 1f       	adc	r26, r20
    960c:	b5 1f       	adc	r27, r21
    960e:	89 83       	std	Y+1, r24	; 0x01
    9610:	9a 83       	std	Y+2, r25	; 0x02
    9612:	ab 83       	std	Y+3, r26	; 0x03
    9614:	bc 83       	std	Y+4, r27	; 0x04
    9616:	14 c0       	rjmp	.+40     	; 0x9640 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    9618:	29 81       	ldd	r18, Y+1	; 0x01
    961a:	3a 81       	ldd	r19, Y+2	; 0x02
    961c:	4b 81       	ldd	r20, Y+3	; 0x03
    961e:	5c 81       	ldd	r21, Y+4	; 0x04
    9620:	8e 81       	ldd	r24, Y+6	; 0x06
    9622:	9f 81       	ldd	r25, Y+7	; 0x07
    9624:	a8 85       	ldd	r26, Y+8	; 0x08
    9626:	b9 85       	ldd	r27, Y+9	; 0x09
    9628:	79 01       	movw	r14, r18
    962a:	8a 01       	movw	r16, r20
    962c:	e8 1a       	sub	r14, r24
    962e:	f9 0a       	sbc	r15, r25
    9630:	0a 0b       	sbc	r16, r26
    9632:	1b 0b       	sbc	r17, r27
    9634:	d8 01       	movw	r26, r16
    9636:	c7 01       	movw	r24, r14
    9638:	89 83       	std	Y+1, r24	; 0x01
    963a:	9a 83       	std	Y+2, r25	; 0x02
    963c:	ab 83       	std	Y+3, r26	; 0x03
    963e:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9640:	29 81       	ldd	r18, Y+1	; 0x01
    9642:	3a 81       	ldd	r19, Y+2	; 0x02
    9644:	4b 81       	ldd	r20, Y+3	; 0x03
    9646:	5c 81       	ldd	r21, Y+4	; 0x04
    9648:	81 e0       	ldi	r24, 0x01	; 1
    964a:	61 e0       	ldi	r22, 0x01	; 1
    964c:	0e 94 57 41 	call	0x82ae	; 0x82ae <getSetFreeCluster>
  }
}
    9650:	29 96       	adiw	r28, 0x09	; 9
    9652:	cd bf       	out	0x3d, r28	; 61
    9654:	de bf       	out	0x3e, r29	; 62
    9656:	df 91       	pop	r29
    9658:	cf 91       	pop	r28
    965a:	1f 91       	pop	r17
    965c:	0f 91       	pop	r16
    965e:	ff 90       	pop	r15
    9660:	ef 90       	pop	r14
    9662:	08 95       	ret

00009664 <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    9664:	0f 93       	push	r16
    9666:	1f 93       	push	r17
    9668:	cf 93       	push	r28
    966a:	df 93       	push	r29
    966c:	cd b7       	in	r28, 0x3d	; 61
    966e:	de b7       	in	r29, 0x3e	; 62
    9670:	a9 97       	sbiw	r28, 0x29	; 41
    9672:	cd bf       	out	0x3d, r28	; 61
    9674:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    9676:	81 e0       	ldi	r24, 0x01	; 1
    9678:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    967c:	81 e0       	ldi	r24, 0x01	; 1
    967e:	0e 94 3c 34 	call	0x6878	; 0x6878 <Ext1Power>
    9682:	80 e0       	ldi	r24, 0x00	; 0
    9684:	90 e0       	ldi	r25, 0x00	; 0
    9686:	a8 ec       	ldi	r26, 0xC8	; 200
    9688:	b2 e4       	ldi	r27, 0x42	; 66
    968a:	8e 87       	std	Y+14, r24	; 0x0e
    968c:	9f 87       	std	Y+15, r25	; 0x0f
    968e:	a8 8b       	std	Y+16, r26	; 0x10
    9690:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9692:	6e 85       	ldd	r22, Y+14	; 0x0e
    9694:	7f 85       	ldd	r23, Y+15	; 0x0f
    9696:	88 89       	ldd	r24, Y+16	; 0x10
    9698:	99 89       	ldd	r25, Y+17	; 0x11
    969a:	20 e0       	ldi	r18, 0x00	; 0
    969c:	30 e0       	ldi	r19, 0x00	; 0
    969e:	4a ef       	ldi	r20, 0xFA	; 250
    96a0:	55 e4       	ldi	r21, 0x45	; 69
    96a2:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    96a6:	dc 01       	movw	r26, r24
    96a8:	cb 01       	movw	r24, r22
    96aa:	8a 8b       	std	Y+18, r24	; 0x12
    96ac:	9b 8b       	std	Y+19, r25	; 0x13
    96ae:	ac 8b       	std	Y+20, r26	; 0x14
    96b0:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    96b2:	11 e0       	ldi	r17, 0x01	; 1
    96b4:	6a 89       	ldd	r22, Y+18	; 0x12
    96b6:	7b 89       	ldd	r23, Y+19	; 0x13
    96b8:	8c 89       	ldd	r24, Y+20	; 0x14
    96ba:	9d 89       	ldd	r25, Y+21	; 0x15
    96bc:	20 e0       	ldi	r18, 0x00	; 0
    96be:	30 e0       	ldi	r19, 0x00	; 0
    96c0:	40 e8       	ldi	r20, 0x80	; 128
    96c2:	5f e3       	ldi	r21, 0x3F	; 63
    96c4:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    96c8:	88 23       	and	r24, r24
    96ca:	0c f0       	brlt	.+2      	; 0x96ce <SD_init+0x6a>
    96cc:	10 e0       	ldi	r17, 0x00	; 0
    96ce:	11 23       	and	r17, r17
    96d0:	29 f0       	breq	.+10     	; 0x96dc <SD_init+0x78>
		__ticks = 1;
    96d2:	81 e0       	ldi	r24, 0x01	; 1
    96d4:	90 e0       	ldi	r25, 0x00	; 0
    96d6:	8e 8b       	std	Y+22, r24	; 0x16
    96d8:	9f 8b       	std	Y+23, r25	; 0x17
    96da:	46 c0       	rjmp	.+140    	; 0x9768 <SD_init+0x104>
	else if (__tmp > 65535)
    96dc:	11 e0       	ldi	r17, 0x01	; 1
    96de:	6a 89       	ldd	r22, Y+18	; 0x12
    96e0:	7b 89       	ldd	r23, Y+19	; 0x13
    96e2:	8c 89       	ldd	r24, Y+20	; 0x14
    96e4:	9d 89       	ldd	r25, Y+21	; 0x15
    96e6:	20 e0       	ldi	r18, 0x00	; 0
    96e8:	3f ef       	ldi	r19, 0xFF	; 255
    96ea:	4f e7       	ldi	r20, 0x7F	; 127
    96ec:	57 e4       	ldi	r21, 0x47	; 71
    96ee:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    96f2:	18 16       	cp	r1, r24
    96f4:	0c f0       	brlt	.+2      	; 0x96f8 <SD_init+0x94>
    96f6:	10 e0       	ldi	r17, 0x00	; 0
    96f8:	11 23       	and	r17, r17
    96fa:	61 f1       	breq	.+88     	; 0x9754 <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    96fc:	6e 85       	ldd	r22, Y+14	; 0x0e
    96fe:	7f 85       	ldd	r23, Y+15	; 0x0f
    9700:	88 89       	ldd	r24, Y+16	; 0x10
    9702:	99 89       	ldd	r25, Y+17	; 0x11
    9704:	20 e0       	ldi	r18, 0x00	; 0
    9706:	30 e0       	ldi	r19, 0x00	; 0
    9708:	40 e2       	ldi	r20, 0x20	; 32
    970a:	51 e4       	ldi	r21, 0x41	; 65
    970c:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    9710:	dc 01       	movw	r26, r24
    9712:	cb 01       	movw	r24, r22
    9714:	bc 01       	movw	r22, r24
    9716:	cd 01       	movw	r24, r26
    9718:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    971c:	dc 01       	movw	r26, r24
    971e:	cb 01       	movw	r24, r22
    9720:	8e 8b       	std	Y+22, r24	; 0x16
    9722:	9f 8b       	std	Y+23, r25	; 0x17
    9724:	12 c0       	rjmp	.+36     	; 0x974a <SD_init+0xe6>
    9726:	80 e2       	ldi	r24, 0x20	; 32
    9728:	93 e0       	ldi	r25, 0x03	; 3
    972a:	88 8f       	std	Y+24, r24	; 0x18
    972c:	99 8f       	std	Y+25, r25	; 0x19
    972e:	88 8d       	ldd	r24, Y+24	; 0x18
    9730:	99 8d       	ldd	r25, Y+25	; 0x19
    9732:	8c 01       	movw	r16, r24
    9734:	c8 01       	movw	r24, r16
    9736:	01 97       	sbiw	r24, 0x01	; 1
    9738:	f1 f7       	brne	.-4      	; 0x9736 <SD_init+0xd2>
    973a:	8c 01       	movw	r16, r24
    973c:	08 8f       	std	Y+24, r16	; 0x18
    973e:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9740:	8e 89       	ldd	r24, Y+22	; 0x16
    9742:	9f 89       	ldd	r25, Y+23	; 0x17
    9744:	01 97       	sbiw	r24, 0x01	; 1
    9746:	8e 8b       	std	Y+22, r24	; 0x16
    9748:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    974a:	8e 89       	ldd	r24, Y+22	; 0x16
    974c:	9f 89       	ldd	r25, Y+23	; 0x17
    974e:	00 97       	sbiw	r24, 0x00	; 0
    9750:	51 f7       	brne	.-44     	; 0x9726 <SD_init+0xc2>
    9752:	17 c0       	rjmp	.+46     	; 0x9782 <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9754:	6a 89       	ldd	r22, Y+18	; 0x12
    9756:	7b 89       	ldd	r23, Y+19	; 0x13
    9758:	8c 89       	ldd	r24, Y+20	; 0x14
    975a:	9d 89       	ldd	r25, Y+21	; 0x15
    975c:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    9760:	dc 01       	movw	r26, r24
    9762:	cb 01       	movw	r24, r22
    9764:	8e 8b       	std	Y+22, r24	; 0x16
    9766:	9f 8b       	std	Y+23, r25	; 0x17
    9768:	8e 89       	ldd	r24, Y+22	; 0x16
    976a:	9f 89       	ldd	r25, Y+23	; 0x17
    976c:	8a 8f       	std	Y+26, r24	; 0x1a
    976e:	9b 8f       	std	Y+27, r25	; 0x1b
    9770:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9772:	9b 8d       	ldd	r25, Y+27	; 0x1b
    9774:	8c 01       	movw	r16, r24
    9776:	f8 01       	movw	r30, r16
    9778:	31 97       	sbiw	r30, 0x01	; 1
    977a:	f1 f7       	brne	.-4      	; 0x9778 <SD_init+0x114>
    977c:	8f 01       	movw	r16, r30
    977e:	0a 8f       	std	Y+26, r16	; 0x1a
    9780:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9782:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    9784:	88 e0       	ldi	r24, 0x08	; 8
    9786:	60 e0       	ldi	r22, 0x00	; 0
    9788:	0e 94 a6 32 	call	0x654c	; 0x654c <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    978c:	88 e0       	ldi	r24, 0x08	; 8
    978e:	60 e0       	ldi	r22, 0x00	; 0
    9790:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9794:	80 e0       	ldi	r24, 0x00	; 0
    9796:	90 e0       	ldi	r25, 0x00	; 0
    9798:	63 e0       	ldi	r22, 0x03	; 3
    979a:	70 e0       	ldi	r23, 0x00	; 0
    979c:	0e 94 6a 37 	call	0x6ed4	; 0x6ed4 <SPIInit2>
	SPICS(TRUE);
    97a0:	81 e0       	ldi	r24, 0x01	; 1
    97a2:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    97a6:	1a 82       	std	Y+2, r1	; 0x02
    97a8:	1b 82       	std	Y+3, r1	; 0x03
    97aa:	17 c0       	rjmp	.+46     	; 0x97da <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    97ac:	80 ec       	ldi	r24, 0xC0	; 192
    97ae:	98 e0       	ldi	r25, 0x08	; 8
    97b0:	2f ef       	ldi	r18, 0xFF	; 255
    97b2:	fc 01       	movw	r30, r24
    97b4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    97b6:	00 00       	nop
    97b8:	80 ec       	ldi	r24, 0xC0	; 192
    97ba:	98 e0       	ldi	r25, 0x08	; 8
    97bc:	fc 01       	movw	r30, r24
    97be:	82 81       	ldd	r24, Z+2	; 0x02
    97c0:	88 23       	and	r24, r24
    97c2:	d4 f7       	brge	.-12     	; 0x97b8 <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    97c4:	80 ec       	ldi	r24, 0xC0	; 192
    97c6:	98 e0       	ldi	r25, 0x08	; 8
    97c8:	fc 01       	movw	r30, r24
    97ca:	83 81       	ldd	r24, Z+3	; 0x03
    97cc:	80 93 bb 50 	sts	0x50BB, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    97d0:	8a 81       	ldd	r24, Y+2	; 0x02
    97d2:	9b 81       	ldd	r25, Y+3	; 0x03
    97d4:	01 96       	adiw	r24, 0x01	; 1
    97d6:	8a 83       	std	Y+2, r24	; 0x02
    97d8:	9b 83       	std	Y+3, r25	; 0x03
    97da:	8a 81       	ldd	r24, Y+2	; 0x02
    97dc:	9b 81       	ldd	r25, Y+3	; 0x03
    97de:	8a 30       	cpi	r24, 0x0A	; 10
    97e0:	91 05       	cpc	r25, r1
    97e2:	24 f3       	brlt	.-56     	; 0x97ac <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    97e4:	80 e0       	ldi	r24, 0x00	; 0
    97e6:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    97ea:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    97ee:	88 e0       	ldi	r24, 0x08	; 8
    97f0:	60 e0       	ldi	r22, 0x00	; 0
    97f2:	0e 94 d5 33 	call	0x67aa	; 0x67aa <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    97f6:	80 e0       	ldi	r24, 0x00	; 0
    97f8:	90 e0       	ldi	r25, 0x00	; 0
    97fa:	63 e0       	ldi	r22, 0x03	; 3
    97fc:	70 e0       	ldi	r23, 0x00	; 0
    97fe:	0e 94 6a 37 	call	0x6ed4	; 0x6ed4 <SPIInit2>
	SPICS(TRUE);
    9802:	81 e0       	ldi	r24, 0x01	; 1
    9804:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9808:	1c 82       	std	Y+4, r1	; 0x04
    980a:	1d 82       	std	Y+5, r1	; 0x05
    980c:	0d c0       	rjmp	.+26     	; 0x9828 <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    980e:	8c 81       	ldd	r24, Y+4	; 0x04
    9810:	9d 81       	ldd	r25, Y+5	; 0x05
    9812:	8a 30       	cpi	r24, 0x0A	; 10
    9814:	91 05       	cpc	r25, r1
    9816:	1c f0       	brlt	.+6      	; 0x981e <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    9818:	81 e0       	ldi	r24, 0x01	; 1
    981a:	89 83       	std	Y+1, r24	; 0x01
			break;
    981c:	10 c0       	rjmp	.+32     	; 0x983e <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    981e:	8c 81       	ldd	r24, Y+4	; 0x04
    9820:	9d 81       	ldd	r25, Y+5	; 0x05
    9822:	01 96       	adiw	r24, 0x01	; 1
    9824:	8c 83       	std	Y+4, r24	; 0x04
    9826:	9d 83       	std	Y+5, r25	; 0x05
    9828:	80 e0       	ldi	r24, 0x00	; 0
    982a:	40 e0       	ldi	r20, 0x00	; 0
    982c:	50 e0       	ldi	r21, 0x00	; 0
    982e:	ba 01       	movw	r22, r20
    9830:	25 e9       	ldi	r18, 0x95	; 149
    9832:	08 e0       	ldi	r16, 0x08	; 8
    9834:	10 e0       	ldi	r17, 0x00	; 0
    9836:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
    983a:	81 30       	cpi	r24, 0x01	; 1
    983c:	41 f7       	brne	.-48     	; 0x980e <SD_init+0x1aa>
    983e:	80 e0       	ldi	r24, 0x00	; 0
    9840:	90 e0       	ldi	r25, 0x00	; 0
    9842:	a8 ec       	ldi	r26, 0xC8	; 200
    9844:	b2 e4       	ldi	r27, 0x42	; 66
    9846:	8c 8f       	std	Y+28, r24	; 0x1c
    9848:	9d 8f       	std	Y+29, r25	; 0x1d
    984a:	ae 8f       	std	Y+30, r26	; 0x1e
    984c:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    984e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9850:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9852:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9854:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9856:	20 e0       	ldi	r18, 0x00	; 0
    9858:	30 e0       	ldi	r19, 0x00	; 0
    985a:	4a ef       	ldi	r20, 0xFA	; 250
    985c:	55 e4       	ldi	r21, 0x45	; 69
    985e:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    9862:	dc 01       	movw	r26, r24
    9864:	cb 01       	movw	r24, r22
    9866:	88 a3       	lds	r24, 0x58
    9868:	99 a3       	lds	r25, 0x59
    986a:	aa a3       	lds	r26, 0x5a
    986c:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    986e:	11 e0       	ldi	r17, 0x01	; 1
    9870:	68 a1       	lds	r22, 0x48
    9872:	79 a1       	lds	r23, 0x49
    9874:	8a a1       	lds	r24, 0x4a
    9876:	9b a1       	lds	r25, 0x4b
    9878:	20 e0       	ldi	r18, 0x00	; 0
    987a:	30 e0       	ldi	r19, 0x00	; 0
    987c:	40 e8       	ldi	r20, 0x80	; 128
    987e:	5f e3       	ldi	r21, 0x3F	; 63
    9880:	0e 94 91 60 	call	0xc122	; 0xc122 <__cmpsf2>
    9884:	88 23       	and	r24, r24
    9886:	0c f0       	brlt	.+2      	; 0x988a <SD_init+0x226>
    9888:	10 e0       	ldi	r17, 0x00	; 0
    988a:	11 23       	and	r17, r17
    988c:	29 f0       	breq	.+10     	; 0x9898 <SD_init+0x234>
		__ticks = 1;
    988e:	81 e0       	ldi	r24, 0x01	; 1
    9890:	90 e0       	ldi	r25, 0x00	; 0
    9892:	8c a3       	lds	r24, 0x5c
    9894:	9d a3       	lds	r25, 0x5d
    9896:	46 c0       	rjmp	.+140    	; 0x9924 <SD_init+0x2c0>
	else if (__tmp > 65535)
    9898:	11 e0       	ldi	r17, 0x01	; 1
    989a:	68 a1       	lds	r22, 0x48
    989c:	79 a1       	lds	r23, 0x49
    989e:	8a a1       	lds	r24, 0x4a
    98a0:	9b a1       	lds	r25, 0x4b
    98a2:	20 e0       	ldi	r18, 0x00	; 0
    98a4:	3f ef       	ldi	r19, 0xFF	; 255
    98a6:	4f e7       	ldi	r20, 0x7F	; 127
    98a8:	57 e4       	ldi	r21, 0x47	; 71
    98aa:	0e 94 9e 61 	call	0xc33c	; 0xc33c <__gesf2>
    98ae:	18 16       	cp	r1, r24
    98b0:	0c f0       	brlt	.+2      	; 0x98b4 <SD_init+0x250>
    98b2:	10 e0       	ldi	r17, 0x00	; 0
    98b4:	11 23       	and	r17, r17
    98b6:	61 f1       	breq	.+88     	; 0x9910 <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    98b8:	6c 8d       	ldd	r22, Y+28	; 0x1c
    98ba:	7d 8d       	ldd	r23, Y+29	; 0x1d
    98bc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    98be:	9f 8d       	ldd	r25, Y+31	; 0x1f
    98c0:	20 e0       	ldi	r18, 0x00	; 0
    98c2:	30 e0       	ldi	r19, 0x00	; 0
    98c4:	40 e2       	ldi	r20, 0x20	; 32
    98c6:	51 e4       	ldi	r21, 0x41	; 65
    98c8:	0e 94 a2 61 	call	0xc344	; 0xc344 <__mulsf3>
    98cc:	dc 01       	movw	r26, r24
    98ce:	cb 01       	movw	r24, r22
    98d0:	bc 01       	movw	r22, r24
    98d2:	cd 01       	movw	r24, r26
    98d4:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    98d8:	dc 01       	movw	r26, r24
    98da:	cb 01       	movw	r24, r22
    98dc:	8c a3       	lds	r24, 0x5c
    98de:	9d a3       	lds	r25, 0x5d
    98e0:	12 c0       	rjmp	.+36     	; 0x9906 <SD_init+0x2a2>
    98e2:	80 e2       	ldi	r24, 0x20	; 32
    98e4:	93 e0       	ldi	r25, 0x03	; 3
    98e6:	8e a3       	lds	r24, 0x5e
    98e8:	9f a3       	lds	r25, 0x5f
    98ea:	8e a1       	lds	r24, 0x4e
    98ec:	9f a1       	lds	r25, 0x4f
    98ee:	8c 01       	movw	r16, r24
    98f0:	c8 01       	movw	r24, r16
    98f2:	01 97       	sbiw	r24, 0x01	; 1
    98f4:	f1 f7       	brne	.-4      	; 0x98f2 <SD_init+0x28e>
    98f6:	8c 01       	movw	r16, r24
    98f8:	0e a3       	lds	r16, 0x5e
    98fa:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    98fc:	8c a1       	lds	r24, 0x4c
    98fe:	9d a1       	lds	r25, 0x4d
    9900:	01 97       	sbiw	r24, 0x01	; 1
    9902:	8c a3       	lds	r24, 0x5c
    9904:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9906:	8c a1       	lds	r24, 0x4c
    9908:	9d a1       	lds	r25, 0x4d
    990a:	00 97       	sbiw	r24, 0x00	; 0
    990c:	51 f7       	brne	.-44     	; 0x98e2 <SD_init+0x27e>
    990e:	17 c0       	rjmp	.+46     	; 0x993e <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9910:	68 a1       	lds	r22, 0x48
    9912:	79 a1       	lds	r23, 0x49
    9914:	8a a1       	lds	r24, 0x4a
    9916:	9b a1       	lds	r25, 0x4b
    9918:	0e 94 fd 60 	call	0xc1fa	; 0xc1fa <__fixunssfsi>
    991c:	dc 01       	movw	r26, r24
    991e:	cb 01       	movw	r24, r22
    9920:	8c a3       	lds	r24, 0x5c
    9922:	9d a3       	lds	r25, 0x5d
    9924:	8c a1       	lds	r24, 0x4c
    9926:	9d a1       	lds	r25, 0x4d
    9928:	88 a7       	lds	r24, 0x78
    992a:	99 a7       	lds	r25, 0x79
    992c:	88 a5       	lds	r24, 0x68
    992e:	99 a5       	lds	r25, 0x69
    9930:	8c 01       	movw	r16, r24
    9932:	f8 01       	movw	r30, r16
    9934:	31 97       	sbiw	r30, 0x01	; 1
    9936:	f1 f7       	brne	.-4      	; 0x9934 <SD_init+0x2d0>
    9938:	8f 01       	movw	r16, r30
    993a:	08 a7       	lds	r16, 0x78
    993c:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    993e:	1e 82       	std	Y+6, r1	; 0x06
    9940:	1f 82       	std	Y+7, r1	; 0x07
    9942:	0d c0       	rjmp	.+26     	; 0x995e <SD_init+0x2fa>
		if (i >= 10) {
    9944:	8e 81       	ldd	r24, Y+6	; 0x06
    9946:	9f 81       	ldd	r25, Y+7	; 0x07
    9948:	8a 30       	cpi	r24, 0x0A	; 10
    994a:	91 05       	cpc	r25, r1
    994c:	1c f0       	brlt	.+6      	; 0x9954 <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    994e:	81 e0       	ldi	r24, 0x01	; 1
    9950:	89 83       	std	Y+1, r24	; 0x01
			break;
    9952:	11 c0       	rjmp	.+34     	; 0x9976 <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9954:	8e 81       	ldd	r24, Y+6	; 0x06
    9956:	9f 81       	ldd	r25, Y+7	; 0x07
    9958:	01 96       	adiw	r24, 0x01	; 1
    995a:	8e 83       	std	Y+6, r24	; 0x06
    995c:	9f 83       	std	Y+7, r25	; 0x07
    995e:	88 e0       	ldi	r24, 0x08	; 8
    9960:	4a ea       	ldi	r20, 0xAA	; 170
    9962:	51 e0       	ldi	r21, 0x01	; 1
    9964:	60 e0       	ldi	r22, 0x00	; 0
    9966:	70 e0       	ldi	r23, 0x00	; 0
    9968:	27 e8       	ldi	r18, 0x87	; 135
    996a:	08 e0       	ldi	r16, 0x08	; 8
    996c:	10 e0       	ldi	r17, 0x00	; 0
    996e:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
    9972:	81 30       	cpi	r24, 0x01	; 1
    9974:	39 f7       	brne	.-50     	; 0x9944 <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9976:	18 86       	std	Y+8, r1	; 0x08
    9978:	19 86       	std	Y+9, r1	; 0x09
    997a:	13 c0       	rjmp	.+38     	; 0x99a2 <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    997c:	88 85       	ldd	r24, Y+8	; 0x08
    997e:	99 85       	ldd	r25, Y+9	; 0x09
    9980:	8c 01       	movw	r16, r24
    9982:	0e 5f       	subi	r16, 0xFE	; 254
    9984:	1f 4f       	sbci	r17, 0xFF	; 255
    9986:	8f ef       	ldi	r24, 0xFF	; 255
    9988:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    998c:	28 2f       	mov	r18, r24
    998e:	c8 01       	movw	r24, r16
    9990:	81 55       	subi	r24, 0x51	; 81
    9992:	9f 4a       	sbci	r25, 0xAF	; 175
    9994:	fc 01       	movw	r30, r24
    9996:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9998:	88 85       	ldd	r24, Y+8	; 0x08
    999a:	99 85       	ldd	r25, Y+9	; 0x09
    999c:	01 96       	adiw	r24, 0x01	; 1
    999e:	88 87       	std	Y+8, r24	; 0x08
    99a0:	99 87       	std	Y+9, r25	; 0x09
    99a2:	88 85       	ldd	r24, Y+8	; 0x08
    99a4:	99 85       	ldd	r25, Y+9	; 0x09
    99a6:	84 30       	cpi	r24, 0x04	; 4
    99a8:	91 05       	cpc	r25, r1
    99aa:	44 f3       	brlt	.-48     	; 0x997c <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    99ac:	80 91 b3 50 	lds	r24, 0x50B3
    99b0:	81 30       	cpi	r24, 0x01	; 1
    99b2:	21 f4       	brne	.+8      	; 0x99bc <SD_init+0x358>
    99b4:	80 91 b4 50 	lds	r24, 0x50B4
    99b8:	8a 3a       	cpi	r24, 0xAA	; 170
    99ba:	11 f0       	breq	.+4      	; 0x99c0 <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    99bc:	81 e0       	ldi	r24, 0x01	; 1
    99be:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    99c0:	87 e3       	ldi	r24, 0x37	; 55
    99c2:	40 e0       	ldi	r20, 0x00	; 0
    99c4:	50 e0       	ldi	r21, 0x00	; 0
    99c6:	ba 01       	movw	r22, r20
    99c8:	2f ef       	ldi	r18, 0xFF	; 255
    99ca:	08 e0       	ldi	r16, 0x08	; 8
    99cc:	10 e0       	ldi	r17, 0x00	; 0
    99ce:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    99d2:	81 e0       	ldi	r24, 0x01	; 1
    99d4:	40 e0       	ldi	r20, 0x00	; 0
    99d6:	50 e0       	ldi	r21, 0x00	; 0
    99d8:	60 e0       	ldi	r22, 0x00	; 0
    99da:	70 e4       	ldi	r23, 0x40	; 64
    99dc:	2f ef       	ldi	r18, 0xFF	; 255
    99de:	08 e0       	ldi	r16, 0x08	; 8
    99e0:	10 e0       	ldi	r17, 0x00	; 0
    99e2:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
	} while(Buffer[1]!= 0x00);
    99e6:	80 91 b0 50 	lds	r24, 0x50B0
    99ea:	88 23       	and	r24, r24
    99ec:	49 f7       	brne	.-46     	; 0x99c0 <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    99ee:	1a 86       	std	Y+10, r1	; 0x0a
    99f0:	1b 86       	std	Y+11, r1	; 0x0b
    99f2:	0d c0       	rjmp	.+26     	; 0x9a0e <SD_init+0x3aa>
		if (i >= 10) {
    99f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    99f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    99f8:	8a 30       	cpi	r24, 0x0A	; 10
    99fa:	91 05       	cpc	r25, r1
    99fc:	1c f0       	brlt	.+6      	; 0x9a04 <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    99fe:	81 e0       	ldi	r24, 0x01	; 1
    9a00:	89 83       	std	Y+1, r24	; 0x01
			break;
    9a02:	10 c0       	rjmp	.+32     	; 0x9a24 <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9a04:	8a 85       	ldd	r24, Y+10	; 0x0a
    9a06:	9b 85       	ldd	r25, Y+11	; 0x0b
    9a08:	01 96       	adiw	r24, 0x01	; 1
    9a0a:	8a 87       	std	Y+10, r24	; 0x0a
    9a0c:	9b 87       	std	Y+11, r25	; 0x0b
    9a0e:	8a e3       	ldi	r24, 0x3A	; 58
    9a10:	40 e0       	ldi	r20, 0x00	; 0
    9a12:	50 e0       	ldi	r21, 0x00	; 0
    9a14:	ba 01       	movw	r22, r20
    9a16:	2f ef       	ldi	r18, 0xFF	; 255
    9a18:	08 e0       	ldi	r16, 0x08	; 8
    9a1a:	10 e0       	ldi	r17, 0x00	; 0
    9a1c:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
    9a20:	88 23       	and	r24, r24
    9a22:	41 f7       	brne	.-48     	; 0x99f4 <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9a24:	1c 86       	std	Y+12, r1	; 0x0c
    9a26:	1d 86       	std	Y+13, r1	; 0x0d
    9a28:	0f c0       	rjmp	.+30     	; 0x9a48 <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9a2a:	8f ef       	ldi	r24, 0xFF	; 255
    9a2c:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9a30:	28 2f       	mov	r18, r24
    9a32:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a34:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a36:	81 55       	subi	r24, 0x51	; 81
    9a38:	9f 4a       	sbci	r25, 0xAF	; 175
    9a3a:	fc 01       	movw	r30, r24
    9a3c:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9a3e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a40:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a42:	01 96       	adiw	r24, 0x01	; 1
    9a44:	8c 87       	std	Y+12, r24	; 0x0c
    9a46:	9d 87       	std	Y+13, r25	; 0x0d
    9a48:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a4a:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a4c:	84 30       	cpi	r24, 0x04	; 4
    9a4e:	91 05       	cpc	r25, r1
    9a50:	64 f3       	brlt	.-40     	; 0x9a2a <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9a52:	80 91 af 50 	lds	r24, 0x50AF
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9a56:	80 e0       	ldi	r24, 0x00	; 0
    9a58:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    9a5c:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9a60:	88 e0       	ldi	r24, 0x08	; 8
    9a62:	60 e0       	ldi	r22, 0x00	; 0
    9a64:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
	return errorCode;	
    9a68:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9a6a:	a9 96       	adiw	r28, 0x29	; 41
    9a6c:	cd bf       	out	0x3d, r28	; 61
    9a6e:	de bf       	out	0x3e, r29	; 62
    9a70:	df 91       	pop	r29
    9a72:	cf 91       	pop	r28
    9a74:	1f 91       	pop	r17
    9a76:	0f 91       	pop	r16
    9a78:	08 95       	ret

00009a7a <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9a7a:	cf 93       	push	r28
    9a7c:	df 93       	push	r29
    9a7e:	0f 92       	push	r0
    9a80:	0f 92       	push	r0
    9a82:	cd b7       	in	r28, 0x3d	; 61
    9a84:	de b7       	in	r29, 0x3e	; 62
    9a86:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9a88:	80 ec       	ldi	r24, 0xC0	; 192
    9a8a:	98 e0       	ldi	r25, 0x08	; 8
    9a8c:	2a 81       	ldd	r18, Y+2	; 0x02
    9a8e:	fc 01       	movw	r30, r24
    9a90:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9a92:	00 00       	nop
    9a94:	80 ec       	ldi	r24, 0xC0	; 192
    9a96:	98 e0       	ldi	r25, 0x08	; 8
    9a98:	fc 01       	movw	r30, r24
    9a9a:	82 81       	ldd	r24, Z+2	; 0x02
    9a9c:	88 23       	and	r24, r24
    9a9e:	d4 f7       	brge	.-12     	; 0x9a94 <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9aa0:	80 ec       	ldi	r24, 0xC0	; 192
    9aa2:	98 e0       	ldi	r25, 0x08	; 8
    9aa4:	fc 01       	movw	r30, r24
    9aa6:	83 81       	ldd	r24, Z+3	; 0x03
    9aa8:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9aaa:	89 81       	ldd	r24, Y+1	; 0x01
}
    9aac:	0f 90       	pop	r0
    9aae:	0f 90       	pop	r0
    9ab0:	df 91       	pop	r29
    9ab2:	cf 91       	pop	r28
    9ab4:	08 95       	ret

00009ab6 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9ab6:	0f 93       	push	r16
    9ab8:	1f 93       	push	r17
    9aba:	cf 93       	push	r28
    9abc:	df 93       	push	r29
    9abe:	cd b7       	in	r28, 0x3d	; 61
    9ac0:	de b7       	in	r29, 0x3e	; 62
    9ac2:	2a 97       	sbiw	r28, 0x0a	; 10
    9ac4:	cd bf       	out	0x3d, r28	; 61
    9ac6:	de bf       	out	0x3e, r29	; 62
    9ac8:	8b 83       	std	Y+3, r24	; 0x03
    9aca:	4c 83       	std	Y+4, r20	; 0x04
    9acc:	5d 83       	std	Y+5, r21	; 0x05
    9ace:	6e 83       	std	Y+6, r22	; 0x06
    9ad0:	7f 83       	std	Y+7, r23	; 0x07
    9ad2:	28 87       	std	Y+8, r18	; 0x08
    9ad4:	09 87       	std	Y+9, r16	; 0x09
    9ad6:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9ad8:	8b 81       	ldd	r24, Y+3	; 0x03
    9ada:	80 64       	ori	r24, 0x40	; 64
    9adc:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9ae0:	8c 81       	ldd	r24, Y+4	; 0x04
    9ae2:	9d 81       	ldd	r25, Y+5	; 0x05
    9ae4:	ae 81       	ldd	r26, Y+6	; 0x06
    9ae6:	bf 81       	ldd	r27, Y+7	; 0x07
    9ae8:	8b 2f       	mov	r24, r27
    9aea:	99 27       	eor	r25, r25
    9aec:	aa 27       	eor	r26, r26
    9aee:	bb 27       	eor	r27, r27
    9af0:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9af4:	8c 81       	ldd	r24, Y+4	; 0x04
    9af6:	9d 81       	ldd	r25, Y+5	; 0x05
    9af8:	ae 81       	ldd	r26, Y+6	; 0x06
    9afa:	bf 81       	ldd	r27, Y+7	; 0x07
    9afc:	cd 01       	movw	r24, r26
    9afe:	aa 27       	eor	r26, r26
    9b00:	bb 27       	eor	r27, r27
    9b02:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9b06:	8c 81       	ldd	r24, Y+4	; 0x04
    9b08:	9d 81       	ldd	r25, Y+5	; 0x05
    9b0a:	ae 81       	ldd	r26, Y+6	; 0x06
    9b0c:	bf 81       	ldd	r27, Y+7	; 0x07
    9b0e:	89 2f       	mov	r24, r25
    9b10:	9a 2f       	mov	r25, r26
    9b12:	ab 2f       	mov	r26, r27
    9b14:	bb 27       	eor	r27, r27
    9b16:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9b1a:	8c 81       	ldd	r24, Y+4	; 0x04
    9b1c:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
	SPI_write(crc);
    9b20:	88 85       	ldd	r24, Y+8	; 0x08
    9b22:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
	
	for(int i=0; i<read; i++){
    9b26:	19 82       	std	Y+1, r1	; 0x01
    9b28:	1a 82       	std	Y+2, r1	; 0x02
    9b2a:	33 c0       	rjmp	.+102    	; 0x9b92 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9b2c:	89 81       	ldd	r24, Y+1	; 0x01
    9b2e:	9a 81       	ldd	r25, Y+2	; 0x02
    9b30:	2d e0       	ldi	r18, 0x0D	; 13
    9b32:	30 e0       	ldi	r19, 0x00	; 0
    9b34:	b9 01       	movw	r22, r18
    9b36:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9b3a:	8c 01       	movw	r16, r24
    9b3c:	8f ef       	ldi	r24, 0xFF	; 255
    9b3e:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9b42:	28 2f       	mov	r18, r24
    9b44:	c8 01       	movw	r24, r16
    9b46:	81 55       	subi	r24, 0x51	; 81
    9b48:	9f 4a       	sbci	r25, 0xAF	; 175
    9b4a:	fc 01       	movw	r30, r24
    9b4c:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9b4e:	89 81       	ldd	r24, Y+1	; 0x01
    9b50:	9a 81       	ldd	r25, Y+2	; 0x02
    9b52:	2d e0       	ldi	r18, 0x0D	; 13
    9b54:	30 e0       	ldi	r19, 0x00	; 0
    9b56:	b9 01       	movw	r22, r18
    9b58:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9b5c:	81 55       	subi	r24, 0x51	; 81
    9b5e:	9f 4a       	sbci	r25, 0xAF	; 175
    9b60:	fc 01       	movw	r30, r24
    9b62:	80 81       	ld	r24, Z
    9b64:	8f 3f       	cpi	r24, 0xFF	; 255
    9b66:	81 f0       	breq	.+32     	; 0x9b88 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9b68:	89 81       	ldd	r24, Y+1	; 0x01
    9b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    9b6c:	2d e0       	ldi	r18, 0x0D	; 13
    9b6e:	30 e0       	ldi	r19, 0x00	; 0
    9b70:	b9 01       	movw	r22, r18
    9b72:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9b76:	81 55       	subi	r24, 0x51	; 81
    9b78:	9f 4a       	sbci	r25, 0xAF	; 175
    9b7a:	fc 01       	movw	r30, r24
    9b7c:	80 81       	ld	r24, Z
    9b7e:	80 93 b0 50 	sts	0x50B0, r24
			return Buffer[1];
    9b82:	80 91 b0 50 	lds	r24, 0x50B0
    9b86:	0d c0       	rjmp	.+26     	; 0x9ba2 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9b88:	89 81       	ldd	r24, Y+1	; 0x01
    9b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    9b8c:	01 96       	adiw	r24, 0x01	; 1
    9b8e:	89 83       	std	Y+1, r24	; 0x01
    9b90:	9a 83       	std	Y+2, r25	; 0x02
    9b92:	29 81       	ldd	r18, Y+1	; 0x01
    9b94:	3a 81       	ldd	r19, Y+2	; 0x02
    9b96:	89 85       	ldd	r24, Y+9	; 0x09
    9b98:	9a 85       	ldd	r25, Y+10	; 0x0a
    9b9a:	28 17       	cp	r18, r24
    9b9c:	39 07       	cpc	r19, r25
    9b9e:	34 f2       	brlt	.-116    	; 0x9b2c <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9ba0:	8f ef       	ldi	r24, 0xFF	; 255
}
    9ba2:	2a 96       	adiw	r28, 0x0a	; 10
    9ba4:	cd bf       	out	0x3d, r28	; 61
    9ba6:	de bf       	out	0x3e, r29	; 62
    9ba8:	df 91       	pop	r29
    9baa:	cf 91       	pop	r28
    9bac:	1f 91       	pop	r17
    9bae:	0f 91       	pop	r16
    9bb0:	08 95       	ret

00009bb2 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9bb2:	0f 93       	push	r16
    9bb4:	1f 93       	push	r17
    9bb6:	cf 93       	push	r28
    9bb8:	df 93       	push	r29
    9bba:	cd b7       	in	r28, 0x3d	; 61
    9bbc:	de b7       	in	r29, 0x3e	; 62
    9bbe:	62 97       	sbiw	r28, 0x12	; 18
    9bc0:	cd bf       	out	0x3d, r28	; 61
    9bc2:	de bf       	out	0x3e, r29	; 62
    9bc4:	6b 87       	std	Y+11, r22	; 0x0b
    9bc6:	7c 87       	std	Y+12, r23	; 0x0c
    9bc8:	8d 87       	std	Y+13, r24	; 0x0d
    9bca:	9e 87       	std	Y+14, r25	; 0x0e
    9bcc:	4f 87       	std	Y+15, r20	; 0x0f
    9bce:	58 8b       	std	Y+16, r21	; 0x10
    9bd0:	29 8b       	std	Y+17, r18	; 0x11
    9bd2:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9bd4:	88 e0       	ldi	r24, 0x08	; 8
    9bd6:	60 e0       	ldi	r22, 0x00	; 0
    9bd8:	0e 94 d5 33 	call	0x67aa	; 0x67aa <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9bdc:	80 e0       	ldi	r24, 0x00	; 0
    9bde:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    9be2:	81 e0       	ldi	r24, 0x01	; 1
    9be4:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9be8:	20 e0       	ldi	r18, 0x00	; 0
    9bea:	32 e0       	ldi	r19, 0x02	; 2
    9bec:	89 89       	ldd	r24, Y+17	; 0x11
    9bee:	9a 89       	ldd	r25, Y+18	; 0x12
    9bf0:	a9 01       	movw	r20, r18
    9bf2:	48 1b       	sub	r20, r24
    9bf4:	59 0b       	sbc	r21, r25
    9bf6:	ca 01       	movw	r24, r20
    9bf8:	89 83       	std	Y+1, r24	; 0x01
    9bfa:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9bfc:	89 81       	ldd	r24, Y+1	; 0x01
    9bfe:	9a 81       	ldd	r25, Y+2	; 0x02
    9c00:	52 e0       	ldi	r21, 0x02	; 2
    9c02:	80 30       	cpi	r24, 0x00	; 0
    9c04:	95 07       	cpc	r25, r21
    9c06:	11 f4       	brne	.+4      	; 0x9c0c <SD_write_block+0x5a>
    9c08:	19 82       	std	Y+1, r1	; 0x01
    9c0a:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9c0c:	1b 82       	std	Y+3, r1	; 0x03
    9c0e:	1c 82       	std	Y+4, r1	; 0x04
    9c10:	0b c0       	rjmp	.+22     	; 0x9c28 <SD_write_block+0x76>
	if (i >= 10) {
    9c12:	8b 81       	ldd	r24, Y+3	; 0x03
    9c14:	9c 81       	ldd	r25, Y+4	; 0x04
    9c16:	8a 30       	cpi	r24, 0x0A	; 10
    9c18:	91 05       	cpc	r25, r1
    9c1a:	0c f0       	brlt	.+2      	; 0x9c1e <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9c1c:	ff cf       	rjmp	.-2      	; 0x9c1c <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9c1e:	8b 81       	ldd	r24, Y+3	; 0x03
    9c20:	9c 81       	ldd	r25, Y+4	; 0x04
    9c22:	01 96       	adiw	r24, 0x01	; 1
    9c24:	8b 83       	std	Y+3, r24	; 0x03
    9c26:	9c 83       	std	Y+4, r25	; 0x04
    9c28:	2b 85       	ldd	r18, Y+11	; 0x0b
    9c2a:	3c 85       	ldd	r19, Y+12	; 0x0c
    9c2c:	4d 85       	ldd	r20, Y+13	; 0x0d
    9c2e:	5e 85       	ldd	r21, Y+14	; 0x0e
    9c30:	88 e1       	ldi	r24, 0x18	; 24
    9c32:	ba 01       	movw	r22, r20
    9c34:	a9 01       	movw	r20, r18
    9c36:	2f ef       	ldi	r18, 0xFF	; 255
    9c38:	08 e0       	ldi	r16, 0x08	; 8
    9c3a:	10 e0       	ldi	r17, 0x00	; 0
    9c3c:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
    9c40:	88 23       	and	r24, r24
    9c42:	39 f7       	brne	.-50     	; 0x9c12 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9c44:	8f ef       	ldi	r24, 0xFF	; 255
    9c46:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9c4a:	80 93 af 50 	sts	0x50AF, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9c4e:	8e ef       	ldi	r24, 0xFE	; 254
    9c50:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9c54:	1d 82       	std	Y+5, r1	; 0x05
    9c56:	1e 82       	std	Y+6, r1	; 0x06
    9c58:	1d c0       	rjmp	.+58     	; 0x9c94 <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9c5a:	8d 81       	ldd	r24, Y+5	; 0x05
    9c5c:	9e 81       	ldd	r25, Y+6	; 0x06
    9c5e:	2d e0       	ldi	r18, 0x0D	; 13
    9c60:	30 e0       	ldi	r19, 0x00	; 0
    9c62:	b9 01       	movw	r22, r18
    9c64:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9c68:	8c 01       	movw	r16, r24
    9c6a:	8d 81       	ldd	r24, Y+5	; 0x05
    9c6c:	9e 81       	ldd	r25, Y+6	; 0x06
    9c6e:	2f 85       	ldd	r18, Y+15	; 0x0f
    9c70:	38 89       	ldd	r19, Y+16	; 0x10
    9c72:	82 0f       	add	r24, r18
    9c74:	93 1f       	adc	r25, r19
    9c76:	fc 01       	movw	r30, r24
    9c78:	80 81       	ld	r24, Z
    9c7a:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9c7e:	28 2f       	mov	r18, r24
    9c80:	c8 01       	movw	r24, r16
    9c82:	81 55       	subi	r24, 0x51	; 81
    9c84:	9f 4a       	sbci	r25, 0xAF	; 175
    9c86:	fc 01       	movw	r30, r24
    9c88:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9c8a:	8d 81       	ldd	r24, Y+5	; 0x05
    9c8c:	9e 81       	ldd	r25, Y+6	; 0x06
    9c8e:	01 96       	adiw	r24, 0x01	; 1
    9c90:	8d 83       	std	Y+5, r24	; 0x05
    9c92:	9e 83       	std	Y+6, r25	; 0x06
    9c94:	2d 81       	ldd	r18, Y+5	; 0x05
    9c96:	3e 81       	ldd	r19, Y+6	; 0x06
    9c98:	89 89       	ldd	r24, Y+17	; 0x11
    9c9a:	9a 89       	ldd	r25, Y+18	; 0x12
    9c9c:	28 17       	cp	r18, r24
    9c9e:	39 07       	cpc	r19, r25
    9ca0:	e4 f2       	brlt	.-72     	; 0x9c5a <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9ca2:	1f 82       	std	Y+7, r1	; 0x07
    9ca4:	18 86       	std	Y+8, r1	; 0x08
    9ca6:	16 c0       	rjmp	.+44     	; 0x9cd4 <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9ca8:	8f 81       	ldd	r24, Y+7	; 0x07
    9caa:	98 85       	ldd	r25, Y+8	; 0x08
    9cac:	2d e0       	ldi	r18, 0x0D	; 13
    9cae:	30 e0       	ldi	r19, 0x00	; 0
    9cb0:	b9 01       	movw	r22, r18
    9cb2:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9cb6:	8c 01       	movw	r16, r24
    9cb8:	80 e0       	ldi	r24, 0x00	; 0
    9cba:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9cbe:	28 2f       	mov	r18, r24
    9cc0:	c8 01       	movw	r24, r16
    9cc2:	81 55       	subi	r24, 0x51	; 81
    9cc4:	9f 4a       	sbci	r25, 0xAF	; 175
    9cc6:	fc 01       	movw	r30, r24
    9cc8:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9cca:	8f 81       	ldd	r24, Y+7	; 0x07
    9ccc:	98 85       	ldd	r25, Y+8	; 0x08
    9cce:	01 96       	adiw	r24, 0x01	; 1
    9cd0:	8f 83       	std	Y+7, r24	; 0x07
    9cd2:	98 87       	std	Y+8, r25	; 0x08
    9cd4:	2f 81       	ldd	r18, Y+7	; 0x07
    9cd6:	38 85       	ldd	r19, Y+8	; 0x08
    9cd8:	89 81       	ldd	r24, Y+1	; 0x01
    9cda:	9a 81       	ldd	r25, Y+2	; 0x02
    9cdc:	28 17       	cp	r18, r24
    9cde:	39 07       	cpc	r19, r25
    9ce0:	1c f3       	brlt	.-58     	; 0x9ca8 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9ce2:	8f ef       	ldi	r24, 0xFF	; 255
    9ce4:	80 93 af 50 	sts	0x50AF, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9ce8:	19 86       	std	Y+9, r1	; 0x09
    9cea:	1a 86       	std	Y+10, r1	; 0x0a
    9cec:	0a c0       	rjmp	.+20     	; 0x9d02 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9cee:	8f ef       	ldi	r24, 0xFF	; 255
    9cf0:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9cf4:	80 93 af 50 	sts	0x50AF, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9cf8:	89 85       	ldd	r24, Y+9	; 0x09
    9cfa:	9a 85       	ldd	r25, Y+10	; 0x0a
    9cfc:	01 96       	adiw	r24, 0x01	; 1
    9cfe:	89 87       	std	Y+9, r24	; 0x09
    9d00:	9a 87       	std	Y+10, r25	; 0x0a
    9d02:	89 85       	ldd	r24, Y+9	; 0x09
    9d04:	9a 85       	ldd	r25, Y+10	; 0x0a
    9d06:	82 30       	cpi	r24, 0x02	; 2
    9d08:	91 05       	cpc	r25, r1
    9d0a:	8c f3       	brlt	.-30     	; 0x9cee <SD_write_block+0x13c>
    9d0c:	80 91 af 50 	lds	r24, 0x50AF
    9d10:	8f 3f       	cpi	r24, 0xFF	; 255
    9d12:	69 f3       	breq	.-38     	; 0x9cee <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9d14:	80 91 af 50 	lds	r24, 0x50AF
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9d18:	05 c0       	rjmp	.+10     	; 0x9d24 <SD_write_block+0x172>
    9d1a:	8f ef       	ldi	r24, 0xFF	; 255
    9d1c:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9d20:	80 93 af 50 	sts	0x50AF, r24
    9d24:	80 91 af 50 	lds	r24, 0x50AF
    9d28:	8f 3f       	cpi	r24, 0xFF	; 255
    9d2a:	b9 f7       	brne	.-18     	; 0x9d1a <SD_write_block+0x168>
	SPICS(FALSE);
    9d2c:	80 e0       	ldi	r24, 0x00	; 0
    9d2e:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    9d32:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9d36:	88 e0       	ldi	r24, 0x08	; 8
    9d38:	60 e0       	ldi	r22, 0x00	; 0
    9d3a:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
}
    9d3e:	62 96       	adiw	r28, 0x12	; 18
    9d40:	cd bf       	out	0x3d, r28	; 61
    9d42:	de bf       	out	0x3e, r29	; 62
    9d44:	df 91       	pop	r29
    9d46:	cf 91       	pop	r28
    9d48:	1f 91       	pop	r17
    9d4a:	0f 91       	pop	r16
    9d4c:	08 95       	ret

00009d4e <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9d4e:	0f 93       	push	r16
    9d50:	1f 93       	push	r17
    9d52:	cf 93       	push	r28
    9d54:	df 93       	push	r29
    9d56:	cd b7       	in	r28, 0x3d	; 61
    9d58:	de b7       	in	r29, 0x3e	; 62
    9d5a:	2a 97       	sbiw	r28, 0x0a	; 10
    9d5c:	cd bf       	out	0x3d, r28	; 61
    9d5e:	de bf       	out	0x3e, r29	; 62
    9d60:	6d 83       	std	Y+5, r22	; 0x05
    9d62:	7e 83       	std	Y+6, r23	; 0x06
    9d64:	8f 83       	std	Y+7, r24	; 0x07
    9d66:	98 87       	std	Y+8, r25	; 0x08
    9d68:	49 87       	std	Y+9, r20	; 0x09
    9d6a:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9d6c:	88 e0       	ldi	r24, 0x08	; 8
    9d6e:	60 e0       	ldi	r22, 0x00	; 0
    9d70:	0e 94 d5 33 	call	0x67aa	; 0x67aa <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9d74:	80 e0       	ldi	r24, 0x00	; 0
    9d76:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    9d7a:	81 e0       	ldi	r24, 0x01	; 1
    9d7c:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9d80:	19 82       	std	Y+1, r1	; 0x01
    9d82:	1a 82       	std	Y+2, r1	; 0x02
    9d84:	0b c0       	rjmp	.+22     	; 0x9d9c <SD_read_block+0x4e>
		if (i >= 10) {
    9d86:	89 81       	ldd	r24, Y+1	; 0x01
    9d88:	9a 81       	ldd	r25, Y+2	; 0x02
    9d8a:	8a 30       	cpi	r24, 0x0A	; 10
    9d8c:	91 05       	cpc	r25, r1
    9d8e:	0c f0       	brlt	.+2      	; 0x9d92 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9d90:	ff cf       	rjmp	.-2      	; 0x9d90 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9d92:	89 81       	ldd	r24, Y+1	; 0x01
    9d94:	9a 81       	ldd	r25, Y+2	; 0x02
    9d96:	01 96       	adiw	r24, 0x01	; 1
    9d98:	89 83       	std	Y+1, r24	; 0x01
    9d9a:	9a 83       	std	Y+2, r25	; 0x02
    9d9c:	2d 81       	ldd	r18, Y+5	; 0x05
    9d9e:	3e 81       	ldd	r19, Y+6	; 0x06
    9da0:	4f 81       	ldd	r20, Y+7	; 0x07
    9da2:	58 85       	ldd	r21, Y+8	; 0x08
    9da4:	81 e1       	ldi	r24, 0x11	; 17
    9da6:	ba 01       	movw	r22, r20
    9da8:	a9 01       	movw	r20, r18
    9daa:	2f ef       	ldi	r18, 0xFF	; 255
    9dac:	08 e0       	ldi	r16, 0x08	; 8
    9dae:	10 e0       	ldi	r17, 0x00	; 0
    9db0:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
    9db4:	88 23       	and	r24, r24
    9db6:	39 f7       	brne	.-50     	; 0x9d86 <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9db8:	05 c0       	rjmp	.+10     	; 0x9dc4 <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9dba:	8f ef       	ldi	r24, 0xFF	; 255
    9dbc:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9dc0:	80 93 af 50 	sts	0x50AF, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9dc4:	80 91 af 50 	lds	r24, 0x50AF
    9dc8:	8e 3f       	cpi	r24, 0xFE	; 254
    9dca:	b9 f7       	brne	.-18     	; 0x9dba <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9dcc:	1b 82       	std	Y+3, r1	; 0x03
    9dce:	1c 82       	std	Y+4, r1	; 0x04
    9dd0:	11 c0       	rjmp	.+34     	; 0x9df4 <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    9dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    9dd6:	29 85       	ldd	r18, Y+9	; 0x09
    9dd8:	3a 85       	ldd	r19, Y+10	; 0x0a
    9dda:	89 01       	movw	r16, r18
    9ddc:	08 0f       	add	r16, r24
    9dde:	19 1f       	adc	r17, r25
    9de0:	8f ef       	ldi	r24, 0xFF	; 255
    9de2:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9de6:	f8 01       	movw	r30, r16
    9de8:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9dea:	8b 81       	ldd	r24, Y+3	; 0x03
    9dec:	9c 81       	ldd	r25, Y+4	; 0x04
    9dee:	01 96       	adiw	r24, 0x01	; 1
    9df0:	8b 83       	std	Y+3, r24	; 0x03
    9df2:	9c 83       	std	Y+4, r25	; 0x04
    9df4:	8b 81       	ldd	r24, Y+3	; 0x03
    9df6:	9c 81       	ldd	r25, Y+4	; 0x04
    9df8:	f2 e0       	ldi	r31, 0x02	; 2
    9dfa:	80 30       	cpi	r24, 0x00	; 0
    9dfc:	9f 07       	cpc	r25, r31
    9dfe:	4c f3       	brlt	.-46     	; 0x9dd2 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    9e00:	10 92 bb 50 	sts	0x50BB, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9e04:	05 c0       	rjmp	.+10     	; 0x9e10 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    9e06:	8f ef       	ldi	r24, 0xFF	; 255
    9e08:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9e0c:	80 93 bb 50 	sts	0x50BB, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9e10:	80 91 bb 50 	lds	r24, 0x50BB
    9e14:	8f 3f       	cpi	r24, 0xFF	; 255
    9e16:	b9 f7       	brne	.-18     	; 0x9e06 <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    9e18:	80 e0       	ldi	r24, 0x00	; 0
    9e1a:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    9e1e:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9e22:	88 e0       	ldi	r24, 0x08	; 8
    9e24:	60 e0       	ldi	r22, 0x00	; 0
    9e26:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
}
    9e2a:	2a 96       	adiw	r28, 0x0a	; 10
    9e2c:	cd bf       	out	0x3d, r28	; 61
    9e2e:	de bf       	out	0x3e, r29	; 62
    9e30:	df 91       	pop	r29
    9e32:	cf 91       	pop	r28
    9e34:	1f 91       	pop	r17
    9e36:	0f 91       	pop	r16
    9e38:	08 95       	ret

00009e3a <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    9e3a:	0f 93       	push	r16
    9e3c:	1f 93       	push	r17
    9e3e:	cf 93       	push	r28
    9e40:	df 93       	push	r29
    9e42:	cd b7       	in	r28, 0x3d	; 61
    9e44:	de b7       	in	r29, 0x3e	; 62
    9e46:	6a 97       	sbiw	r28, 0x1a	; 26
    9e48:	cd bf       	out	0x3d, r28	; 61
    9e4a:	de bf       	out	0x3e, r29	; 62
    9e4c:	6b 8b       	std	Y+19, r22	; 0x13
    9e4e:	7c 8b       	std	Y+20, r23	; 0x14
    9e50:	8d 8b       	std	Y+21, r24	; 0x15
    9e52:	9e 8b       	std	Y+22, r25	; 0x16
    9e54:	4f 8b       	std	Y+23, r20	; 0x17
    9e56:	58 8f       	std	Y+24, r21	; 0x18
    9e58:	29 8f       	std	Y+25, r18	; 0x19
    9e5a:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9e5c:	88 e0       	ldi	r24, 0x08	; 8
    9e5e:	60 e0       	ldi	r22, 0x00	; 0
    9e60:	0e 94 d5 33 	call	0x67aa	; 0x67aa <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9e64:	80 e0       	ldi	r24, 0x00	; 0
    9e66:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    9e6a:	81 e0       	ldi	r24, 0x01	; 1
    9e6c:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    9e70:	89 8d       	ldd	r24, Y+25	; 0x19
    9e72:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9e74:	99 23       	and	r25, r25
    9e76:	14 f4       	brge	.+4      	; 0x9e7c <SD_write_multiple_blocks+0x42>
    9e78:	81 50       	subi	r24, 0x01	; 1
    9e7a:	9e 4f       	sbci	r25, 0xFE	; 254
    9e7c:	89 2f       	mov	r24, r25
    9e7e:	99 0f       	add	r25, r25
    9e80:	99 0b       	sbc	r25, r25
    9e82:	85 95       	asr	r24
    9e84:	89 83       	std	Y+1, r24	; 0x01
    9e86:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    9e88:	89 8d       	ldd	r24, Y+25	; 0x19
    9e8a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9e8c:	20 e0       	ldi	r18, 0x00	; 0
    9e8e:	32 e0       	ldi	r19, 0x02	; 2
    9e90:	b9 01       	movw	r22, r18
    9e92:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9e96:	20 e0       	ldi	r18, 0x00	; 0
    9e98:	32 e0       	ldi	r19, 0x02	; 2
    9e9a:	a9 01       	movw	r20, r18
    9e9c:	48 1b       	sub	r20, r24
    9e9e:	59 0b       	sbc	r21, r25
    9ea0:	ca 01       	movw	r24, r20
    9ea2:	8b 83       	std	Y+3, r24	; 0x03
    9ea4:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    9ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    9eaa:	52 e0       	ldi	r21, 0x02	; 2
    9eac:	80 30       	cpi	r24, 0x00	; 0
    9eae:	95 07       	cpc	r25, r21
    9eb0:	19 f4       	brne	.+6      	; 0x9eb8 <SD_write_multiple_blocks+0x7e>
    9eb2:	1b 82       	std	Y+3, r1	; 0x03
    9eb4:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9eb6:	05 c0       	rjmp	.+10     	; 0x9ec2 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    9eb8:	89 81       	ldd	r24, Y+1	; 0x01
    9eba:	9a 81       	ldd	r25, Y+2	; 0x02
    9ebc:	01 96       	adiw	r24, 0x01	; 1
    9ebe:	89 83       	std	Y+1, r24	; 0x01
    9ec0:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9ec2:	00 00       	nop
    9ec4:	2b 89       	ldd	r18, Y+19	; 0x13
    9ec6:	3c 89       	ldd	r19, Y+20	; 0x14
    9ec8:	4d 89       	ldd	r20, Y+21	; 0x15
    9eca:	5e 89       	ldd	r21, Y+22	; 0x16
    9ecc:	89 e1       	ldi	r24, 0x19	; 25
    9ece:	ba 01       	movw	r22, r20
    9ed0:	a9 01       	movw	r20, r18
    9ed2:	2f ef       	ldi	r18, 0xFF	; 255
    9ed4:	08 e0       	ldi	r16, 0x08	; 8
    9ed6:	10 e0       	ldi	r17, 0x00	; 0
    9ed8:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
    9edc:	88 23       	and	r24, r24
    9ede:	91 f7       	brne	.-28     	; 0x9ec4 <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    9ee0:	1d 82       	std	Y+5, r1	; 0x05
    9ee2:	1e 82       	std	Y+6, r1	; 0x06
    9ee4:	ba c0       	rjmp	.+372    	; 0xa05a <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    9ee6:	8f ef       	ldi	r24, 0xFF	; 255
    9ee8:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9eec:	80 93 b0 50 	sts	0x50B0, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    9ef0:	8c ef       	ldi	r24, 0xFC	; 252
    9ef2:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9ef6:	80 93 b0 50 	sts	0x50B0, r24
		if(j == (numSectors-1)){
    9efa:	89 81       	ldd	r24, Y+1	; 0x01
    9efc:	9a 81       	ldd	r25, Y+2	; 0x02
    9efe:	9c 01       	movw	r18, r24
    9f00:	21 50       	subi	r18, 0x01	; 1
    9f02:	30 40       	sbci	r19, 0x00	; 0
    9f04:	8d 81       	ldd	r24, Y+5	; 0x05
    9f06:	9e 81       	ldd	r25, Y+6	; 0x06
    9f08:	28 17       	cp	r18, r24
    9f0a:	39 07       	cpc	r19, r25
    9f0c:	09 f0       	breq	.+2      	; 0x9f10 <SD_write_multiple_blocks+0xd6>
    9f0e:	54 c0       	rjmp	.+168    	; 0x9fb8 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9f10:	1f 82       	std	Y+7, r1	; 0x07
    9f12:	18 86       	std	Y+8, r1	; 0x08
    9f14:	25 c0       	rjmp	.+74     	; 0x9f60 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9f16:	8f 81       	ldd	r24, Y+7	; 0x07
    9f18:	98 85       	ldd	r25, Y+8	; 0x08
    9f1a:	2c e0       	ldi	r18, 0x0C	; 12
    9f1c:	30 e0       	ldi	r19, 0x00	; 0
    9f1e:	b9 01       	movw	r22, r18
    9f20:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9f24:	8c 01       	movw	r16, r24
    9f26:	8d 81       	ldd	r24, Y+5	; 0x05
    9f28:	9e 81       	ldd	r25, Y+6	; 0x06
    9f2a:	9c 01       	movw	r18, r24
    9f2c:	32 2f       	mov	r19, r18
    9f2e:	22 27       	eor	r18, r18
    9f30:	33 0f       	add	r19, r19
    9f32:	8f 81       	ldd	r24, Y+7	; 0x07
    9f34:	98 85       	ldd	r25, Y+8	; 0x08
    9f36:	82 0f       	add	r24, r18
    9f38:	93 1f       	adc	r25, r19
    9f3a:	2f 89       	ldd	r18, Y+23	; 0x17
    9f3c:	38 8d       	ldd	r19, Y+24	; 0x18
    9f3e:	82 0f       	add	r24, r18
    9f40:	93 1f       	adc	r25, r19
    9f42:	fc 01       	movw	r30, r24
    9f44:	80 81       	ld	r24, Z
    9f46:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9f4a:	28 2f       	mov	r18, r24
    9f4c:	c8 01       	movw	r24, r16
    9f4e:	81 55       	subi	r24, 0x51	; 81
    9f50:	9f 4a       	sbci	r25, 0xAF	; 175
    9f52:	fc 01       	movw	r30, r24
    9f54:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9f56:	8f 81       	ldd	r24, Y+7	; 0x07
    9f58:	98 85       	ldd	r25, Y+8	; 0x08
    9f5a:	01 96       	adiw	r24, 0x01	; 1
    9f5c:	8f 83       	std	Y+7, r24	; 0x07
    9f5e:	98 87       	std	Y+8, r25	; 0x08
    9f60:	20 e0       	ldi	r18, 0x00	; 0
    9f62:	32 e0       	ldi	r19, 0x02	; 2
    9f64:	8b 81       	ldd	r24, Y+3	; 0x03
    9f66:	9c 81       	ldd	r25, Y+4	; 0x04
    9f68:	28 1b       	sub	r18, r24
    9f6a:	39 0b       	sbc	r19, r25
    9f6c:	8f 81       	ldd	r24, Y+7	; 0x07
    9f6e:	98 85       	ldd	r25, Y+8	; 0x08
    9f70:	82 17       	cp	r24, r18
    9f72:	93 07       	cpc	r25, r19
    9f74:	84 f2       	brlt	.-96     	; 0x9f16 <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9f76:	19 86       	std	Y+9, r1	; 0x09
    9f78:	1a 86       	std	Y+10, r1	; 0x0a
    9f7a:	16 c0       	rjmp	.+44     	; 0x9fa8 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    9f7c:	89 85       	ldd	r24, Y+9	; 0x09
    9f7e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f80:	2c e0       	ldi	r18, 0x0C	; 12
    9f82:	30 e0       	ldi	r19, 0x00	; 0
    9f84:	b9 01       	movw	r22, r18
    9f86:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9f8a:	8c 01       	movw	r16, r24
    9f8c:	80 e0       	ldi	r24, 0x00	; 0
    9f8e:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9f92:	28 2f       	mov	r18, r24
    9f94:	c8 01       	movw	r24, r16
    9f96:	81 55       	subi	r24, 0x51	; 81
    9f98:	9f 4a       	sbci	r25, 0xAF	; 175
    9f9a:	fc 01       	movw	r30, r24
    9f9c:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9f9e:	89 85       	ldd	r24, Y+9	; 0x09
    9fa0:	9a 85       	ldd	r25, Y+10	; 0x0a
    9fa2:	01 96       	adiw	r24, 0x01	; 1
    9fa4:	89 87       	std	Y+9, r24	; 0x09
    9fa6:	9a 87       	std	Y+10, r25	; 0x0a
    9fa8:	29 85       	ldd	r18, Y+9	; 0x09
    9faa:	3a 85       	ldd	r19, Y+10	; 0x0a
    9fac:	8b 81       	ldd	r24, Y+3	; 0x03
    9fae:	9c 81       	ldd	r25, Y+4	; 0x04
    9fb0:	28 17       	cp	r18, r24
    9fb2:	39 07       	cpc	r19, r25
    9fb4:	1c f3       	brlt	.-58     	; 0x9f7c <SD_write_multiple_blocks+0x142>
    9fb6:	2e c0       	rjmp	.+92     	; 0xa014 <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9fb8:	1b 86       	std	Y+11, r1	; 0x0b
    9fba:	1c 86       	std	Y+12, r1	; 0x0c
    9fbc:	25 c0       	rjmp	.+74     	; 0xa008 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9fbe:	8b 85       	ldd	r24, Y+11	; 0x0b
    9fc0:	9c 85       	ldd	r25, Y+12	; 0x0c
    9fc2:	2c e0       	ldi	r18, 0x0C	; 12
    9fc4:	30 e0       	ldi	r19, 0x00	; 0
    9fc6:	b9 01       	movw	r22, r18
    9fc8:	0e 94 38 62 	call	0xc470	; 0xc470 <__divmodhi4>
    9fcc:	8c 01       	movw	r16, r24
    9fce:	8d 81       	ldd	r24, Y+5	; 0x05
    9fd0:	9e 81       	ldd	r25, Y+6	; 0x06
    9fd2:	9c 01       	movw	r18, r24
    9fd4:	32 2f       	mov	r19, r18
    9fd6:	22 27       	eor	r18, r18
    9fd8:	33 0f       	add	r19, r19
    9fda:	8b 85       	ldd	r24, Y+11	; 0x0b
    9fdc:	9c 85       	ldd	r25, Y+12	; 0x0c
    9fde:	82 0f       	add	r24, r18
    9fe0:	93 1f       	adc	r25, r19
    9fe2:	2f 89       	ldd	r18, Y+23	; 0x17
    9fe4:	38 8d       	ldd	r19, Y+24	; 0x18
    9fe6:	82 0f       	add	r24, r18
    9fe8:	93 1f       	adc	r25, r19
    9fea:	fc 01       	movw	r30, r24
    9fec:	80 81       	ld	r24, Z
    9fee:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    9ff2:	28 2f       	mov	r18, r24
    9ff4:	c8 01       	movw	r24, r16
    9ff6:	81 55       	subi	r24, 0x51	; 81
    9ff8:	9f 4a       	sbci	r25, 0xAF	; 175
    9ffa:	fc 01       	movw	r30, r24
    9ffc:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9ffe:	8b 85       	ldd	r24, Y+11	; 0x0b
    a000:	9c 85       	ldd	r25, Y+12	; 0x0c
    a002:	01 96       	adiw	r24, 0x01	; 1
    a004:	8b 87       	std	Y+11, r24	; 0x0b
    a006:	9c 87       	std	Y+12, r25	; 0x0c
    a008:	8b 85       	ldd	r24, Y+11	; 0x0b
    a00a:	9c 85       	ldd	r25, Y+12	; 0x0c
    a00c:	f2 e0       	ldi	r31, 0x02	; 2
    a00e:	80 30       	cpi	r24, 0x00	; 0
    a010:	9f 07       	cpc	r25, r31
    a012:	ac f2       	brlt	.-86     	; 0x9fbe <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a014:	1d 86       	std	Y+13, r1	; 0x0d
    a016:	1e 86       	std	Y+14, r1	; 0x0e
    a018:	0a c0       	rjmp	.+20     	; 0xa02e <SD_write_multiple_blocks+0x1f4>
    a01a:	8f ef       	ldi	r24, 0xFF	; 255
    a01c:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a020:	80 93 b0 50 	sts	0x50B0, r24
    a024:	8d 85       	ldd	r24, Y+13	; 0x0d
    a026:	9e 85       	ldd	r25, Y+14	; 0x0e
    a028:	01 96       	adiw	r24, 0x01	; 1
    a02a:	8d 87       	std	Y+13, r24	; 0x0d
    a02c:	9e 87       	std	Y+14, r25	; 0x0e
    a02e:	8d 85       	ldd	r24, Y+13	; 0x0d
    a030:	9e 85       	ldd	r25, Y+14	; 0x0e
    a032:	82 30       	cpi	r24, 0x02	; 2
    a034:	91 05       	cpc	r25, r1
    a036:	8c f3       	brlt	.-30     	; 0xa01a <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a038:	10 92 b0 50 	sts	0x50B0, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a03c:	05 c0       	rjmp	.+10     	; 0xa048 <SD_write_multiple_blocks+0x20e>
    a03e:	8f ef       	ldi	r24, 0xFF	; 255
    a040:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a044:	80 93 b0 50 	sts	0x50B0, r24
    a048:	80 91 b0 50 	lds	r24, 0x50B0
    a04c:	8f 3f       	cpi	r24, 0xFF	; 255
    a04e:	b9 f7       	brne	.-18     	; 0xa03e <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a050:	8d 81       	ldd	r24, Y+5	; 0x05
    a052:	9e 81       	ldd	r25, Y+6	; 0x06
    a054:	01 96       	adiw	r24, 0x01	; 1
    a056:	8d 83       	std	Y+5, r24	; 0x05
    a058:	9e 83       	std	Y+6, r25	; 0x06
    a05a:	2d 81       	ldd	r18, Y+5	; 0x05
    a05c:	3e 81       	ldd	r19, Y+6	; 0x06
    a05e:	89 81       	ldd	r24, Y+1	; 0x01
    a060:	9a 81       	ldd	r25, Y+2	; 0x02
    a062:	28 17       	cp	r18, r24
    a064:	39 07       	cpc	r19, r25
    a066:	0c f4       	brge	.+2      	; 0xa06a <SD_write_multiple_blocks+0x230>
    a068:	3e cf       	rjmp	.-388    	; 0x9ee6 <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a06a:	1f 86       	std	Y+15, r1	; 0x0f
    a06c:	18 8a       	std	Y+16, r1	; 0x10
    a06e:	0a c0       	rjmp	.+20     	; 0xa084 <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a070:	8f ef       	ldi	r24, 0xFF	; 255
    a072:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a076:	80 93 b0 50 	sts	0x50B0, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a07a:	8f 85       	ldd	r24, Y+15	; 0x0f
    a07c:	98 89       	ldd	r25, Y+16	; 0x10
    a07e:	01 96       	adiw	r24, 0x01	; 1
    a080:	8f 87       	std	Y+15, r24	; 0x0f
    a082:	98 8b       	std	Y+16, r25	; 0x10
    a084:	8f 85       	ldd	r24, Y+15	; 0x0f
    a086:	98 89       	ldd	r25, Y+16	; 0x10
    a088:	84 30       	cpi	r24, 0x04	; 4
    a08a:	91 05       	cpc	r25, r1
    a08c:	8c f3       	brlt	.-30     	; 0xa070 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a08e:	8d ef       	ldi	r24, 0xFD	; 253
    a090:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a094:	80 93 b0 50 	sts	0x50B0, r24
	for(int i=0;i<4;i++){
    a098:	19 8a       	std	Y+17, r1	; 0x11
    a09a:	1a 8a       	std	Y+18, r1	; 0x12
    a09c:	0a c0       	rjmp	.+20     	; 0xa0b2 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a09e:	8f ef       	ldi	r24, 0xFF	; 255
    a0a0:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a0a4:	80 93 b0 50 	sts	0x50B0, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a0a8:	89 89       	ldd	r24, Y+17	; 0x11
    a0aa:	9a 89       	ldd	r25, Y+18	; 0x12
    a0ac:	01 96       	adiw	r24, 0x01	; 1
    a0ae:	89 8b       	std	Y+17, r24	; 0x11
    a0b0:	9a 8b       	std	Y+18, r25	; 0x12
    a0b2:	89 89       	ldd	r24, Y+17	; 0x11
    a0b4:	9a 89       	ldd	r25, Y+18	; 0x12
    a0b6:	84 30       	cpi	r24, 0x04	; 4
    a0b8:	91 05       	cpc	r25, r1
    a0ba:	8c f3       	brlt	.-30     	; 0xa09e <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a0bc:	10 92 b0 50 	sts	0x50B0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a0c0:	05 c0       	rjmp	.+10     	; 0xa0cc <SD_write_multiple_blocks+0x292>
    a0c2:	8f ef       	ldi	r24, 0xFF	; 255
    a0c4:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a0c8:	80 93 b0 50 	sts	0x50B0, r24
    a0cc:	80 91 b0 50 	lds	r24, 0x50B0
    a0d0:	8f 3f       	cpi	r24, 0xFF	; 255
    a0d2:	b9 f7       	brne	.-18     	; 0xa0c2 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a0d4:	80 e0       	ldi	r24, 0x00	; 0
    a0d6:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    a0da:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a0de:	88 e0       	ldi	r24, 0x08	; 8
    a0e0:	60 e0       	ldi	r22, 0x00	; 0
    a0e2:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
}
    a0e6:	6a 96       	adiw	r28, 0x1a	; 26
    a0e8:	cd bf       	out	0x3d, r28	; 61
    a0ea:	de bf       	out	0x3e, r29	; 62
    a0ec:	df 91       	pop	r29
    a0ee:	cf 91       	pop	r28
    a0f0:	1f 91       	pop	r17
    a0f2:	0f 91       	pop	r16
    a0f4:	08 95       	ret

0000a0f6 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a0f6:	0f 93       	push	r16
    a0f8:	1f 93       	push	r17
    a0fa:	cf 93       	push	r28
    a0fc:	df 93       	push	r29
    a0fe:	cd b7       	in	r28, 0x3d	; 61
    a100:	de b7       	in	r29, 0x3e	; 62
    a102:	2e 97       	sbiw	r28, 0x0e	; 14
    a104:	cd bf       	out	0x3d, r28	; 61
    a106:	de bf       	out	0x3e, r29	; 62
    a108:	6f 83       	std	Y+7, r22	; 0x07
    a10a:	78 87       	std	Y+8, r23	; 0x08
    a10c:	89 87       	std	Y+9, r24	; 0x09
    a10e:	9a 87       	std	Y+10, r25	; 0x0a
    a110:	4b 87       	std	Y+11, r20	; 0x0b
    a112:	5c 87       	std	Y+12, r21	; 0x0c
    a114:	2d 87       	std	Y+13, r18	; 0x0d
    a116:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a118:	88 e0       	ldi	r24, 0x08	; 8
    a11a:	60 e0       	ldi	r22, 0x00	; 0
    a11c:	0e 94 d5 33 	call	0x67aa	; 0x67aa <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a120:	80 e0       	ldi	r24, 0x00	; 0
    a122:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    a126:	81 e0       	ldi	r24, 0x01	; 1
    a128:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a12c:	00 00       	nop
    a12e:	2f 81       	ldd	r18, Y+7	; 0x07
    a130:	38 85       	ldd	r19, Y+8	; 0x08
    a132:	49 85       	ldd	r20, Y+9	; 0x09
    a134:	5a 85       	ldd	r21, Y+10	; 0x0a
    a136:	82 e1       	ldi	r24, 0x12	; 18
    a138:	ba 01       	movw	r22, r20
    a13a:	a9 01       	movw	r20, r18
    a13c:	2f ef       	ldi	r18, 0xFF	; 255
    a13e:	08 e0       	ldi	r16, 0x08	; 8
    a140:	10 e0       	ldi	r17, 0x00	; 0
    a142:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
    a146:	88 23       	and	r24, r24
    a148:	91 f7       	brne	.-28     	; 0xa12e <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a14a:	19 82       	std	Y+1, r1	; 0x01
    a14c:	1a 82       	std	Y+2, r1	; 0x02
    a14e:	4b c0       	rjmp	.+150    	; 0xa1e6 <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a150:	8f ef       	ldi	r24, 0xFF	; 255
    a152:	80 93 b0 50 	sts	0x50B0, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a156:	05 c0       	rjmp	.+10     	; 0xa162 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a158:	8f ef       	ldi	r24, 0xFF	; 255
    a15a:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a15e:	80 93 b0 50 	sts	0x50B0, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a162:	80 91 b0 50 	lds	r24, 0x50B0
    a166:	8e 3f       	cpi	r24, 0xFE	; 254
    a168:	b9 f7       	brne	.-18     	; 0xa158 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a16a:	1b 82       	std	Y+3, r1	; 0x03
    a16c:	1c 82       	std	Y+4, r1	; 0x04
    a16e:	19 c0       	rjmp	.+50     	; 0xa1a2 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a170:	89 81       	ldd	r24, Y+1	; 0x01
    a172:	9a 81       	ldd	r25, Y+2	; 0x02
    a174:	9c 01       	movw	r18, r24
    a176:	32 2f       	mov	r19, r18
    a178:	22 27       	eor	r18, r18
    a17a:	33 0f       	add	r19, r19
    a17c:	8b 81       	ldd	r24, Y+3	; 0x03
    a17e:	9c 81       	ldd	r25, Y+4	; 0x04
    a180:	82 0f       	add	r24, r18
    a182:	93 1f       	adc	r25, r19
    a184:	2b 85       	ldd	r18, Y+11	; 0x0b
    a186:	3c 85       	ldd	r19, Y+12	; 0x0c
    a188:	89 01       	movw	r16, r18
    a18a:	08 0f       	add	r16, r24
    a18c:	19 1f       	adc	r17, r25
    a18e:	8f ef       	ldi	r24, 0xFF	; 255
    a190:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a194:	f8 01       	movw	r30, r16
    a196:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a198:	8b 81       	ldd	r24, Y+3	; 0x03
    a19a:	9c 81       	ldd	r25, Y+4	; 0x04
    a19c:	01 96       	adiw	r24, 0x01	; 1
    a19e:	8b 83       	std	Y+3, r24	; 0x03
    a1a0:	9c 83       	std	Y+4, r25	; 0x04
    a1a2:	8b 81       	ldd	r24, Y+3	; 0x03
    a1a4:	9c 81       	ldd	r25, Y+4	; 0x04
    a1a6:	f2 e0       	ldi	r31, 0x02	; 2
    a1a8:	80 30       	cpi	r24, 0x00	; 0
    a1aa:	9f 07       	cpc	r25, r31
    a1ac:	0c f3       	brlt	.-62     	; 0xa170 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a1ae:	1d 82       	std	Y+5, r1	; 0x05
    a1b0:	1e 82       	std	Y+6, r1	; 0x06
    a1b2:	0f c0       	rjmp	.+30     	; 0xa1d2 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a1b4:	8f ef       	ldi	r24, 0xFF	; 255
    a1b6:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a1ba:	28 2f       	mov	r18, r24
    a1bc:	8d 81       	ldd	r24, Y+5	; 0x05
    a1be:	9e 81       	ldd	r25, Y+6	; 0x06
    a1c0:	81 55       	subi	r24, 0x51	; 81
    a1c2:	9f 4a       	sbci	r25, 0xAF	; 175
    a1c4:	fc 01       	movw	r30, r24
    a1c6:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a1c8:	8d 81       	ldd	r24, Y+5	; 0x05
    a1ca:	9e 81       	ldd	r25, Y+6	; 0x06
    a1cc:	01 96       	adiw	r24, 0x01	; 1
    a1ce:	8d 83       	std	Y+5, r24	; 0x05
    a1d0:	9e 83       	std	Y+6, r25	; 0x06
    a1d2:	8d 81       	ldd	r24, Y+5	; 0x05
    a1d4:	9e 81       	ldd	r25, Y+6	; 0x06
    a1d6:	82 30       	cpi	r24, 0x02	; 2
    a1d8:	91 05       	cpc	r25, r1
    a1da:	64 f3       	brlt	.-40     	; 0xa1b4 <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a1dc:	89 81       	ldd	r24, Y+1	; 0x01
    a1de:	9a 81       	ldd	r25, Y+2	; 0x02
    a1e0:	01 96       	adiw	r24, 0x01	; 1
    a1e2:	89 83       	std	Y+1, r24	; 0x01
    a1e4:	9a 83       	std	Y+2, r25	; 0x02
    a1e6:	29 81       	ldd	r18, Y+1	; 0x01
    a1e8:	3a 81       	ldd	r19, Y+2	; 0x02
    a1ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    a1ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    a1ee:	28 17       	cp	r18, r24
    a1f0:	39 07       	cpc	r19, r25
    a1f2:	0c f4       	brge	.+2      	; 0xa1f6 <SD_read_multiple_blocks+0x100>
    a1f4:	ad cf       	rjmp	.-166    	; 0xa150 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a1f6:	8c e0       	ldi	r24, 0x0C	; 12
    a1f8:	40 e0       	ldi	r20, 0x00	; 0
    a1fa:	50 e0       	ldi	r21, 0x00	; 0
    a1fc:	ba 01       	movw	r22, r20
    a1fe:	2f ef       	ldi	r18, 0xFF	; 255
    a200:	08 e0       	ldi	r16, 0x08	; 8
    a202:	10 e0       	ldi	r17, 0x00	; 0
    a204:	0e 94 5b 4d 	call	0x9ab6	; 0x9ab6 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a208:	8f ef       	ldi	r24, 0xFF	; 255
    a20a:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a20e:	80 93 af 50 	sts	0x50AF, r24
	Buffer[1] = FILLER_BYTE;
    a212:	10 92 b0 50 	sts	0x50B0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a216:	05 c0       	rjmp	.+10     	; 0xa222 <SD_read_multiple_blocks+0x12c>
    a218:	8f ef       	ldi	r24, 0xFF	; 255
    a21a:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
    a21e:	80 93 b0 50 	sts	0x50B0, r24
    a222:	80 91 b0 50 	lds	r24, 0x50B0
    a226:	8f 3f       	cpi	r24, 0xFF	; 255
    a228:	b9 f7       	brne	.-18     	; 0xa218 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a22a:	80 e0       	ldi	r24, 0x00	; 0
    a22c:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    a230:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a234:	88 e0       	ldi	r24, 0x08	; 8
    a236:	60 e0       	ldi	r22, 0x00	; 0
    a238:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
}
    a23c:	2e 96       	adiw	r28, 0x0e	; 14
    a23e:	cd bf       	out	0x3d, r28	; 61
    a240:	de bf       	out	0x3e, r29	; 62
    a242:	df 91       	pop	r29
    a244:	cf 91       	pop	r28
    a246:	1f 91       	pop	r17
    a248:	0f 91       	pop	r16
    a24a:	08 95       	ret

0000a24c <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a24c:	cf 93       	push	r28
    a24e:	df 93       	push	r29
    a250:	cd b7       	in	r28, 0x3d	; 61
    a252:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a254:	88 e0       	ldi	r24, 0x08	; 8
    a256:	60 e0       	ldi	r22, 0x00	; 0
    a258:	0e 94 a6 32 	call	0x654c	; 0x654c <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a25c:	88 e0       	ldi	r24, 0x08	; 8
    a25e:	60 e0       	ldi	r22, 0x00	; 0
    a260:	0e 94 72 33 	call	0x66e4	; 0x66e4 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a264:	80 e0       	ldi	r24, 0x00	; 0
    a266:	0e 94 42 37 	call	0x6e84	; 0x6e84 <SPIInit>
	SPICS(TRUE);
    a26a:	81 e0       	ldi	r24, 0x01	; 1
    a26c:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a270:	8f ef       	ldi	r24, 0xFF	; 255
    a272:	0e 94 3d 4d 	call	0x9a7a	; 0x9a7a <SPI_write>
	SPICS(FALSE);	//stop spi
    a276:	80 e0       	ldi	r24, 0x00	; 0
    a278:	0e 94 97 37 	call	0x6f2e	; 0x6f2e <SPICS>
	SPIDisable();
    a27c:	0e 94 af 37 	call	0x6f5e	; 0x6f5e <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a280:	80 e0       	ldi	r24, 0x00	; 0
    a282:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a286:	80 e0       	ldi	r24, 0x00	; 0
    a288:	0e 94 3c 34 	call	0x6878	; 0x6878 <Ext1Power>
}
    a28c:	df 91       	pop	r29
    a28e:	cf 91       	pop	r28
    a290:	08 95       	ret

0000a292 <__muldi3>:
    a292:	a0 e3       	ldi	r26, 0x30	; 48
    a294:	b0 e0       	ldi	r27, 0x00	; 0
    a296:	ef e4       	ldi	r30, 0x4F	; 79
    a298:	f1 e5       	ldi	r31, 0x51	; 81
    a29a:	0c 94 8a 62 	jmp	0xc514	; 0xc514 <__prologue_saves__+0x4>
    a29e:	29 8f       	std	Y+25, r18	; 0x19
    a2a0:	3a 8f       	std	Y+26, r19	; 0x1a
    a2a2:	4b 8f       	std	Y+27, r20	; 0x1b
    a2a4:	5c 8f       	std	Y+28, r21	; 0x1c
    a2a6:	6d 8f       	std	Y+29, r22	; 0x1d
    a2a8:	7e 8f       	std	Y+30, r23	; 0x1e
    a2aa:	8f 8f       	std	Y+31, r24	; 0x1f
    a2ac:	98 a3       	lds	r25, 0x58
    a2ae:	a9 8a       	std	Y+17, r10	; 0x11
    a2b0:	ba 8a       	std	Y+18, r11	; 0x12
    a2b2:	cb 8a       	std	Y+19, r12	; 0x13
    a2b4:	dc 8a       	std	Y+20, r13	; 0x14
    a2b6:	ed 8a       	std	Y+21, r14	; 0x15
    a2b8:	fe 8a       	std	Y+22, r15	; 0x16
    a2ba:	0f 8b       	std	Y+23, r16	; 0x17
    a2bc:	18 8f       	std	Y+24, r17	; 0x18
    a2be:	09 8d       	ldd	r16, Y+25	; 0x19
    a2c0:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a2c2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a2c4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a2c6:	09 a3       	lds	r16, 0x59
    a2c8:	1a a3       	lds	r17, 0x5a
    a2ca:	2b a3       	lds	r18, 0x5b
    a2cc:	3c a3       	lds	r19, 0x5c
    a2ce:	68 01       	movw	r12, r16
    a2d0:	79 01       	movw	r14, r18
    a2d2:	8f ef       	ldi	r24, 0xFF	; 255
    a2d4:	9f ef       	ldi	r25, 0xFF	; 255
    a2d6:	a0 e0       	ldi	r26, 0x00	; 0
    a2d8:	b0 e0       	ldi	r27, 0x00	; 0
    a2da:	c8 22       	and	r12, r24
    a2dc:	d9 22       	and	r13, r25
    a2de:	ea 22       	and	r14, r26
    a2e0:	fb 22       	and	r15, r27
    a2e2:	89 01       	movw	r16, r18
    a2e4:	22 27       	eor	r18, r18
    a2e6:	33 27       	eor	r19, r19
    a2e8:	09 a7       	lds	r16, 0x79
    a2ea:	1a a7       	lds	r17, 0x7a
    a2ec:	2b a7       	lds	r18, 0x7b
    a2ee:	3c a7       	lds	r19, 0x7c
    a2f0:	09 89       	ldd	r16, Y+17	; 0x11
    a2f2:	1a 89       	ldd	r17, Y+18	; 0x12
    a2f4:	2b 89       	ldd	r18, Y+19	; 0x13
    a2f6:	3c 89       	ldd	r19, Y+20	; 0x14
    a2f8:	0d a3       	lds	r16, 0x5d
    a2fa:	1e a3       	lds	r17, 0x5e
    a2fc:	2f a3       	lds	r18, 0x5f
    a2fe:	38 a7       	lds	r19, 0x78
    a300:	48 01       	movw	r8, r16
    a302:	59 01       	movw	r10, r18
    a304:	88 22       	and	r8, r24
    a306:	99 22       	and	r9, r25
    a308:	aa 22       	and	r10, r26
    a30a:	bb 22       	and	r11, r27
    a30c:	29 01       	movw	r4, r18
    a30e:	66 24       	eor	r6, r6
    a310:	77 24       	eor	r7, r7
    a312:	c5 01       	movw	r24, r10
    a314:	b4 01       	movw	r22, r8
    a316:	a7 01       	movw	r20, r14
    a318:	96 01       	movw	r18, r12
    a31a:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a31e:	6d a7       	lds	r22, 0x7d
    a320:	7e a7       	lds	r23, 0x7e
    a322:	8f a7       	lds	r24, 0x7f
    a324:	98 ab       	sts	0x58, r25
    a326:	c3 01       	movw	r24, r6
    a328:	b2 01       	movw	r22, r4
    a32a:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a32e:	6b 01       	movw	r12, r22
    a330:	7c 01       	movw	r14, r24
    a332:	c5 01       	movw	r24, r10
    a334:	b4 01       	movw	r22, r8
    a336:	29 a5       	lds	r18, 0x69
    a338:	3a a5       	lds	r19, 0x6a
    a33a:	4b a5       	lds	r20, 0x6b
    a33c:	5c a5       	lds	r21, 0x6c
    a33e:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a342:	4b 01       	movw	r8, r22
    a344:	5c 01       	movw	r10, r24
    a346:	c3 01       	movw	r24, r6
    a348:	b2 01       	movw	r22, r4
    a34a:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a34e:	ab 01       	movw	r20, r22
    a350:	bc 01       	movw	r22, r24
    a352:	c8 0c       	add	r12, r8
    a354:	d9 1c       	adc	r13, r9
    a356:	ea 1c       	adc	r14, r10
    a358:	fb 1c       	adc	r15, r11
    a35a:	0d a5       	lds	r16, 0x6d
    a35c:	1e a5       	lds	r17, 0x6e
    a35e:	2f a5       	lds	r18, 0x6f
    a360:	38 a9       	sts	0x48, r19
    a362:	c9 01       	movw	r24, r18
    a364:	aa 27       	eor	r26, r26
    a366:	bb 27       	eor	r27, r27
    a368:	c8 0e       	add	r12, r24
    a36a:	d9 1e       	adc	r13, r25
    a36c:	ea 1e       	adc	r14, r26
    a36e:	fb 1e       	adc	r15, r27
    a370:	c8 14       	cp	r12, r8
    a372:	d9 04       	cpc	r13, r9
    a374:	ea 04       	cpc	r14, r10
    a376:	fb 04       	cpc	r15, r11
    a378:	20 f4       	brcc	.+8      	; 0xa382 <__muldi3+0xf0>
    a37a:	40 50       	subi	r20, 0x00	; 0
    a37c:	50 40       	sbci	r21, 0x00	; 0
    a37e:	6f 4f       	sbci	r22, 0xFF	; 255
    a380:	7f 4f       	sbci	r23, 0xFF	; 255
    a382:	c7 01       	movw	r24, r14
    a384:	aa 27       	eor	r26, r26
    a386:	bb 27       	eor	r27, r27
    a388:	84 0f       	add	r24, r20
    a38a:	95 1f       	adc	r25, r21
    a38c:	a6 1f       	adc	r26, r22
    a38e:	b7 1f       	adc	r27, r23
    a390:	8d 83       	std	Y+5, r24	; 0x05
    a392:	9e 83       	std	Y+6, r25	; 0x06
    a394:	af 83       	std	Y+7, r26	; 0x07
    a396:	b8 87       	std	Y+8, r27	; 0x08
    a398:	76 01       	movw	r14, r12
    a39a:	dd 24       	eor	r13, r13
    a39c:	cc 24       	eor	r12, r12
    a39e:	4d a5       	lds	r20, 0x6d
    a3a0:	5e a5       	lds	r21, 0x6e
    a3a2:	6f a5       	lds	r22, 0x6f
    a3a4:	78 a9       	sts	0x48, r23
    a3a6:	60 70       	andi	r22, 0x00	; 0
    a3a8:	70 70       	andi	r23, 0x00	; 0
    a3aa:	c4 0e       	add	r12, r20
    a3ac:	d5 1e       	adc	r13, r21
    a3ae:	e6 1e       	adc	r14, r22
    a3b0:	f7 1e       	adc	r15, r23
    a3b2:	c9 82       	std	Y+1, r12	; 0x01
    a3b4:	da 82       	std	Y+2, r13	; 0x02
    a3b6:	eb 82       	std	Y+3, r14	; 0x03
    a3b8:	fc 82       	std	Y+4, r15	; 0x04
    a3ba:	1c 2d       	mov	r17, r12
    a3bc:	0a 81       	ldd	r16, Y+2	; 0x02
    a3be:	8b 80       	ldd	r8, Y+3	; 0x03
    a3c0:	4c 80       	ldd	r4, Y+4	; 0x04
    a3c2:	8d 87       	std	Y+13, r24	; 0x0d
    a3c4:	8e 81       	ldd	r24, Y+6	; 0x06
    a3c6:	8e 87       	std	Y+14, r24	; 0x0e
    a3c8:	8f 81       	ldd	r24, Y+7	; 0x07
    a3ca:	8f 87       	std	Y+15, r24	; 0x0f
    a3cc:	88 85       	ldd	r24, Y+8	; 0x08
    a3ce:	88 8b       	std	Y+16, r24	; 0x10
    a3d0:	2d 89       	ldd	r18, Y+21	; 0x15
    a3d2:	3e 89       	ldd	r19, Y+22	; 0x16
    a3d4:	4f 89       	ldd	r20, Y+23	; 0x17
    a3d6:	58 8d       	ldd	r21, Y+24	; 0x18
    a3d8:	69 a1       	lds	r22, 0x49
    a3da:	7a a1       	lds	r23, 0x4a
    a3dc:	8b a1       	lds	r24, 0x4b
    a3de:	9c a1       	lds	r25, 0x4c
    a3e0:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a3e4:	6b 01       	movw	r12, r22
    a3e6:	7c 01       	movw	r14, r24
    a3e8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a3ea:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a3ec:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a3ee:	58 a1       	lds	r21, 0x48
    a3f0:	6d a1       	lds	r22, 0x4d
    a3f2:	7e a1       	lds	r23, 0x4e
    a3f4:	8f a1       	lds	r24, 0x4f
    a3f6:	98 a5       	lds	r25, 0x68
    a3f8:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a3fc:	dc 01       	movw	r26, r24
    a3fe:	cb 01       	movw	r24, r22
    a400:	c8 0e       	add	r12, r24
    a402:	d9 1e       	adc	r13, r25
    a404:	ea 1e       	adc	r14, r26
    a406:	fb 1e       	adc	r15, r27
    a408:	8d 85       	ldd	r24, Y+13	; 0x0d
    a40a:	9e 85       	ldd	r25, Y+14	; 0x0e
    a40c:	af 85       	ldd	r26, Y+15	; 0x0f
    a40e:	b8 89       	ldd	r27, Y+16	; 0x10
    a410:	8c 0d       	add	r24, r12
    a412:	9d 1d       	adc	r25, r13
    a414:	ae 1d       	adc	r26, r14
    a416:	bf 1d       	adc	r27, r15
    a418:	8d 87       	std	Y+13, r24	; 0x0d
    a41a:	9e 87       	std	Y+14, r25	; 0x0e
    a41c:	af 87       	std	Y+15, r26	; 0x0f
    a41e:	b8 8b       	std	Y+16, r27	; 0x10
    a420:	68 2f       	mov	r22, r24
    a422:	7e 85       	ldd	r23, Y+14	; 0x0e
    a424:	21 2f       	mov	r18, r17
    a426:	30 2f       	mov	r19, r16
    a428:	48 2d       	mov	r20, r8
    a42a:	54 2d       	mov	r21, r4
    a42c:	8f 85       	ldd	r24, Y+15	; 0x0f
    a42e:	98 89       	ldd	r25, Y+16	; 0x10
    a430:	e0 96       	adiw	r28, 0x30	; 48
    a432:	e0 e1       	ldi	r30, 0x10	; 16
    a434:	0c 94 a3 62 	jmp	0xc546	; 0xc546 <__epilogue_restores__+0x4>

0000a438 <__ashldi3>:
    a438:	cf 92       	push	r12
    a43a:	df 92       	push	r13
    a43c:	ef 92       	push	r14
    a43e:	ff 92       	push	r15
    a440:	0f 93       	push	r16
    a442:	cf 93       	push	r28
    a444:	df 93       	push	r29
    a446:	cd b7       	in	r28, 0x3d	; 61
    a448:	de b7       	in	r29, 0x3e	; 62
    a44a:	60 97       	sbiw	r28, 0x10	; 16
    a44c:	cd bf       	out	0x3d, r28	; 61
    a44e:	de bf       	out	0x3e, r29	; 62
    a450:	00 23       	and	r16, r16
    a452:	09 f4       	brne	.+2      	; 0xa456 <__ashldi3+0x1e>
    a454:	5a c0       	rjmp	.+180    	; 0xa50a <__ashldi3+0xd2>
    a456:	29 87       	std	Y+9, r18	; 0x09
    a458:	3a 87       	std	Y+10, r19	; 0x0a
    a45a:	4b 87       	std	Y+11, r20	; 0x0b
    a45c:	5c 87       	std	Y+12, r21	; 0x0c
    a45e:	6d 87       	std	Y+13, r22	; 0x0d
    a460:	7e 87       	std	Y+14, r23	; 0x0e
    a462:	8f 87       	std	Y+15, r24	; 0x0f
    a464:	98 8b       	std	Y+16, r25	; 0x10
    a466:	80 e2       	ldi	r24, 0x20	; 32
    a468:	80 1b       	sub	r24, r16
    a46a:	49 85       	ldd	r20, Y+9	; 0x09
    a46c:	5a 85       	ldd	r21, Y+10	; 0x0a
    a46e:	6b 85       	ldd	r22, Y+11	; 0x0b
    a470:	7c 85       	ldd	r23, Y+12	; 0x0c
    a472:	18 16       	cp	r1, r24
    a474:	b4 f0       	brlt	.+44     	; 0xa4a2 <__ashldi3+0x6a>
    a476:	19 82       	std	Y+1, r1	; 0x01
    a478:	1a 82       	std	Y+2, r1	; 0x02
    a47a:	1b 82       	std	Y+3, r1	; 0x03
    a47c:	1c 82       	std	Y+4, r1	; 0x04
    a47e:	99 27       	eor	r25, r25
    a480:	87 fd       	sbrc	r24, 7
    a482:	90 95       	com	r25
    a484:	90 95       	com	r25
    a486:	81 95       	neg	r24
    a488:	9f 4f       	sbci	r25, 0xFF	; 255
    a48a:	04 c0       	rjmp	.+8      	; 0xa494 <__ashldi3+0x5c>
    a48c:	44 0f       	add	r20, r20
    a48e:	55 1f       	adc	r21, r21
    a490:	66 1f       	adc	r22, r22
    a492:	77 1f       	adc	r23, r23
    a494:	8a 95       	dec	r24
    a496:	d2 f7       	brpl	.-12     	; 0xa48c <__ashldi3+0x54>
    a498:	4d 83       	std	Y+5, r20	; 0x05
    a49a:	5e 83       	std	Y+6, r21	; 0x06
    a49c:	6f 83       	std	Y+7, r22	; 0x07
    a49e:	78 87       	std	Y+8, r23	; 0x08
    a4a0:	2c c0       	rjmp	.+88     	; 0xa4fa <__ashldi3+0xc2>
    a4a2:	6a 01       	movw	r12, r20
    a4a4:	7b 01       	movw	r14, r22
    a4a6:	00 2e       	mov	r0, r16
    a4a8:	04 c0       	rjmp	.+8      	; 0xa4b2 <__ashldi3+0x7a>
    a4aa:	cc 0c       	add	r12, r12
    a4ac:	dd 1c       	adc	r13, r13
    a4ae:	ee 1c       	adc	r14, r14
    a4b0:	ff 1c       	adc	r15, r15
    a4b2:	0a 94       	dec	r0
    a4b4:	d2 f7       	brpl	.-12     	; 0xa4aa <__ashldi3+0x72>
    a4b6:	c9 82       	std	Y+1, r12	; 0x01
    a4b8:	da 82       	std	Y+2, r13	; 0x02
    a4ba:	eb 82       	std	Y+3, r14	; 0x03
    a4bc:	fc 82       	std	Y+4, r15	; 0x04
    a4be:	6a 01       	movw	r12, r20
    a4c0:	7b 01       	movw	r14, r22
    a4c2:	04 c0       	rjmp	.+8      	; 0xa4cc <__ashldi3+0x94>
    a4c4:	f6 94       	lsr	r15
    a4c6:	e7 94       	ror	r14
    a4c8:	d7 94       	ror	r13
    a4ca:	c7 94       	ror	r12
    a4cc:	8a 95       	dec	r24
    a4ce:	d2 f7       	brpl	.-12     	; 0xa4c4 <__ashldi3+0x8c>
    a4d0:	d7 01       	movw	r26, r14
    a4d2:	c6 01       	movw	r24, r12
    a4d4:	4d 85       	ldd	r20, Y+13	; 0x0d
    a4d6:	5e 85       	ldd	r21, Y+14	; 0x0e
    a4d8:	6f 85       	ldd	r22, Y+15	; 0x0f
    a4da:	78 89       	ldd	r23, Y+16	; 0x10
    a4dc:	04 c0       	rjmp	.+8      	; 0xa4e6 <__ashldi3+0xae>
    a4de:	44 0f       	add	r20, r20
    a4e0:	55 1f       	adc	r21, r21
    a4e2:	66 1f       	adc	r22, r22
    a4e4:	77 1f       	adc	r23, r23
    a4e6:	0a 95       	dec	r16
    a4e8:	d2 f7       	brpl	.-12     	; 0xa4de <__ashldi3+0xa6>
    a4ea:	84 2b       	or	r24, r20
    a4ec:	95 2b       	or	r25, r21
    a4ee:	a6 2b       	or	r26, r22
    a4f0:	b7 2b       	or	r27, r23
    a4f2:	8d 83       	std	Y+5, r24	; 0x05
    a4f4:	9e 83       	std	Y+6, r25	; 0x06
    a4f6:	af 83       	std	Y+7, r26	; 0x07
    a4f8:	b8 87       	std	Y+8, r27	; 0x08
    a4fa:	29 81       	ldd	r18, Y+1	; 0x01
    a4fc:	3a 81       	ldd	r19, Y+2	; 0x02
    a4fe:	4b 81       	ldd	r20, Y+3	; 0x03
    a500:	5c 81       	ldd	r21, Y+4	; 0x04
    a502:	6d 81       	ldd	r22, Y+5	; 0x05
    a504:	7e 81       	ldd	r23, Y+6	; 0x06
    a506:	8f 81       	ldd	r24, Y+7	; 0x07
    a508:	98 85       	ldd	r25, Y+8	; 0x08
    a50a:	60 96       	adiw	r28, 0x10	; 16
    a50c:	cd bf       	out	0x3d, r28	; 61
    a50e:	de bf       	out	0x3e, r29	; 62
    a510:	df 91       	pop	r29
    a512:	cf 91       	pop	r28
    a514:	0f 91       	pop	r16
    a516:	ff 90       	pop	r15
    a518:	ef 90       	pop	r14
    a51a:	df 90       	pop	r13
    a51c:	cf 90       	pop	r12
    a51e:	08 95       	ret

0000a520 <__divdi3>:
    a520:	a8 e4       	ldi	r26, 0x48	; 72
    a522:	b0 e0       	ldi	r27, 0x00	; 0
    a524:	e6 e9       	ldi	r30, 0x96	; 150
    a526:	f2 e5       	ldi	r31, 0x52	; 82
    a528:	0c 94 89 62 	jmp	0xc512	; 0xc512 <__prologue_saves__+0x2>
    a52c:	f5 01       	movw	r30, r10
    a52e:	29 a3       	lds	r18, 0x59
    a530:	3a a3       	lds	r19, 0x5a
    a532:	4b a3       	lds	r20, 0x5b
    a534:	5c a3       	lds	r21, 0x5c
    a536:	6d a3       	lds	r22, 0x5d
    a538:	7e a3       	lds	r23, 0x5e
    a53a:	8f a3       	lds	r24, 0x5f
    a53c:	98 a7       	lds	r25, 0x78
    a53e:	a9 8e       	std	Y+25, r10	; 0x19
    a540:	fa 8f       	std	Y+26, r31	; 0x1a
    a542:	cb 8e       	std	Y+27, r12	; 0x1b
    a544:	dc 8e       	std	Y+28, r13	; 0x1c
    a546:	ed 8e       	std	Y+29, r14	; 0x1d
    a548:	fe 8e       	std	Y+30, r15	; 0x1e
    a54a:	0f 8f       	std	Y+31, r16	; 0x1f
    a54c:	18 a3       	lds	r17, 0x58
    a54e:	8d a0       	lds	r24, 0x8d
    a550:	9e a0       	lds	r25, 0x8e
    a552:	af a0       	lds	r26, 0x8f
    a554:	b8 a4       	lds	r27, 0xa8
    a556:	b7 fe       	sbrs	r11, 7
    a558:	67 c0       	rjmp	.+206    	; 0xa628 <__divdi3+0x108>
    a55a:	21 95       	neg	r18
    a55c:	b1 e0       	ldi	r27, 0x01	; 1
    a55e:	12 16       	cp	r1, r18
    a560:	08 f0       	brcs	.+2      	; 0xa564 <__divdi3+0x44>
    a562:	b0 e0       	ldi	r27, 0x00	; 0
    a564:	31 95       	neg	r19
    a566:	a1 e0       	ldi	r26, 0x01	; 1
    a568:	13 16       	cp	r1, r19
    a56a:	08 f0       	brcs	.+2      	; 0xa56e <__divdi3+0x4e>
    a56c:	a0 e0       	ldi	r26, 0x00	; 0
    a56e:	b3 2e       	mov	r11, r19
    a570:	bb 1a       	sub	r11, r27
    a572:	bb 2d       	mov	r27, r11
    a574:	88 24       	eor	r8, r8
    a576:	83 94       	inc	r8
    a578:	3b 15       	cp	r19, r11
    a57a:	08 f0       	brcs	.+2      	; 0xa57e <__divdi3+0x5e>
    a57c:	88 24       	eor	r8, r8
    a57e:	a8 29       	or	r26, r8
    a580:	41 95       	neg	r20
    a582:	31 e0       	ldi	r19, 0x01	; 1
    a584:	14 16       	cp	r1, r20
    a586:	08 f0       	brcs	.+2      	; 0xa58a <__divdi3+0x6a>
    a588:	30 e0       	ldi	r19, 0x00	; 0
    a58a:	b4 2e       	mov	r11, r20
    a58c:	ba 1a       	sub	r11, r26
    a58e:	ab 2d       	mov	r26, r11
    a590:	88 24       	eor	r8, r8
    a592:	83 94       	inc	r8
    a594:	4b 15       	cp	r20, r11
    a596:	08 f0       	brcs	.+2      	; 0xa59a <__divdi3+0x7a>
    a598:	88 24       	eor	r8, r8
    a59a:	38 29       	or	r19, r8
    a59c:	51 95       	neg	r21
    a59e:	41 e0       	ldi	r20, 0x01	; 1
    a5a0:	15 16       	cp	r1, r21
    a5a2:	08 f0       	brcs	.+2      	; 0xa5a6 <__divdi3+0x86>
    a5a4:	40 e0       	ldi	r20, 0x00	; 0
    a5a6:	45 2e       	mov	r4, r21
    a5a8:	43 1a       	sub	r4, r19
    a5aa:	31 e0       	ldi	r19, 0x01	; 1
    a5ac:	54 15       	cp	r21, r4
    a5ae:	08 f0       	brcs	.+2      	; 0xa5b2 <__divdi3+0x92>
    a5b0:	30 e0       	ldi	r19, 0x00	; 0
    a5b2:	43 2b       	or	r20, r19
    a5b4:	61 95       	neg	r22
    a5b6:	31 e0       	ldi	r19, 0x01	; 1
    a5b8:	16 16       	cp	r1, r22
    a5ba:	08 f0       	brcs	.+2      	; 0xa5be <__divdi3+0x9e>
    a5bc:	30 e0       	ldi	r19, 0x00	; 0
    a5be:	86 2e       	mov	r8, r22
    a5c0:	84 1a       	sub	r8, r20
    a5c2:	41 e0       	ldi	r20, 0x01	; 1
    a5c4:	68 15       	cp	r22, r8
    a5c6:	08 f0       	brcs	.+2      	; 0xa5ca <__divdi3+0xaa>
    a5c8:	40 e0       	ldi	r20, 0x00	; 0
    a5ca:	34 2b       	or	r19, r20
    a5cc:	71 95       	neg	r23
    a5ce:	41 e0       	ldi	r20, 0x01	; 1
    a5d0:	17 16       	cp	r1, r23
    a5d2:	08 f0       	brcs	.+2      	; 0xa5d6 <__divdi3+0xb6>
    a5d4:	40 e0       	ldi	r20, 0x00	; 0
    a5d6:	57 2f       	mov	r21, r23
    a5d8:	53 1b       	sub	r21, r19
    a5da:	31 e0       	ldi	r19, 0x01	; 1
    a5dc:	75 17       	cp	r23, r21
    a5de:	08 f0       	brcs	.+2      	; 0xa5e2 <__divdi3+0xc2>
    a5e0:	30 e0       	ldi	r19, 0x00	; 0
    a5e2:	43 2b       	or	r20, r19
    a5e4:	81 95       	neg	r24
    a5e6:	31 e0       	ldi	r19, 0x01	; 1
    a5e8:	18 16       	cp	r1, r24
    a5ea:	08 f0       	brcs	.+2      	; 0xa5ee <__divdi3+0xce>
    a5ec:	30 e0       	ldi	r19, 0x00	; 0
    a5ee:	68 2f       	mov	r22, r24
    a5f0:	64 1b       	sub	r22, r20
    a5f2:	46 2f       	mov	r20, r22
    a5f4:	61 e0       	ldi	r22, 0x01	; 1
    a5f6:	84 17       	cp	r24, r20
    a5f8:	08 f0       	brcs	.+2      	; 0xa5fc <__divdi3+0xdc>
    a5fa:	60 e0       	ldi	r22, 0x00	; 0
    a5fc:	36 2b       	or	r19, r22
    a5fe:	91 95       	neg	r25
    a600:	93 1b       	sub	r25, r19
    a602:	29 a3       	lds	r18, 0x59
    a604:	ba a3       	lds	r27, 0x5a
    a606:	ab a3       	lds	r26, 0x5b
    a608:	4c a2       	lds	r20, 0x9c
    a60a:	8d a2       	lds	r24, 0x9d
    a60c:	5e a3       	lds	r21, 0x5e
    a60e:	4f a3       	lds	r20, 0x5f
    a610:	98 a7       	lds	r25, 0x78
    a612:	8f ef       	ldi	r24, 0xFF	; 255
    a614:	9f ef       	ldi	r25, 0xFF	; 255
    a616:	af ef       	ldi	r26, 0xFF	; 255
    a618:	bf ef       	ldi	r27, 0xFF	; 255
    a61a:	25 96       	adiw	r28, 0x05	; 5
    a61c:	8c af       	sts	0x7c, r24
    a61e:	9d af       	sts	0x7d, r25
    a620:	ae af       	sts	0x7e, r26
    a622:	bf af       	sts	0x7f, r27
    a624:	25 97       	sbiw	r28, 0x05	; 5
    a626:	06 c0       	rjmp	.+12     	; 0xa634 <__divdi3+0x114>
    a628:	25 96       	adiw	r28, 0x05	; 5
    a62a:	1c ae       	sts	0xbc, r17
    a62c:	1d ae       	sts	0xbd, r17
    a62e:	1e ae       	sts	0xbe, r17
    a630:	1f ae       	sts	0xbf, r17
    a632:	25 97       	sbiw	r28, 0x05	; 5
    a634:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a636:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a638:	af 8d       	ldd	r26, Y+31	; 0x1f
    a63a:	b8 a1       	lds	r27, 0x48
    a63c:	b7 ff       	sbrs	r27, 7
    a63e:	68 c0       	rjmp	.+208    	; 0xa710 <__divdi3+0x1f0>
    a640:	25 96       	adiw	r28, 0x05	; 5
    a642:	2c ad       	sts	0x6c, r18
    a644:	3d ad       	sts	0x6d, r19
    a646:	4e ad       	sts	0x6e, r20
    a648:	5f ad       	sts	0x6f, r21
    a64a:	25 97       	sbiw	r28, 0x05	; 5
    a64c:	20 95       	com	r18
    a64e:	30 95       	com	r19
    a650:	40 95       	com	r20
    a652:	50 95       	com	r21
    a654:	25 96       	adiw	r28, 0x05	; 5
    a656:	2c af       	sts	0x7c, r18
    a658:	3d af       	sts	0x7d, r19
    a65a:	4e af       	sts	0x7e, r20
    a65c:	5f af       	sts	0x7f, r21
    a65e:	25 97       	sbiw	r28, 0x05	; 5
    a660:	e1 95       	neg	r30
    a662:	81 e0       	ldi	r24, 0x01	; 1
    a664:	1e 16       	cp	r1, r30
    a666:	08 f0       	brcs	.+2      	; 0xa66a <__divdi3+0x14a>
    a668:	80 e0       	ldi	r24, 0x00	; 0
    a66a:	f1 95       	neg	r31
    a66c:	91 e0       	ldi	r25, 0x01	; 1
    a66e:	1f 16       	cp	r1, r31
    a670:	08 f0       	brcs	.+2      	; 0xa674 <__divdi3+0x154>
    a672:	90 e0       	ldi	r25, 0x00	; 0
    a674:	4f 2f       	mov	r20, r31
    a676:	48 1b       	sub	r20, r24
    a678:	81 e0       	ldi	r24, 0x01	; 1
    a67a:	f4 17       	cp	r31, r20
    a67c:	08 f0       	brcs	.+2      	; 0xa680 <__divdi3+0x160>
    a67e:	80 e0       	ldi	r24, 0x00	; 0
    a680:	98 2b       	or	r25, r24
    a682:	c1 94       	neg	r12
    a684:	81 e0       	ldi	r24, 0x01	; 1
    a686:	1c 14       	cp	r1, r12
    a688:	08 f0       	brcs	.+2      	; 0xa68c <__divdi3+0x16c>
    a68a:	80 e0       	ldi	r24, 0x00	; 0
    a68c:	6c 2d       	mov	r22, r12
    a68e:	69 1b       	sub	r22, r25
    a690:	91 e0       	ldi	r25, 0x01	; 1
    a692:	c6 16       	cp	r12, r22
    a694:	08 f0       	brcs	.+2      	; 0xa698 <__divdi3+0x178>
    a696:	90 e0       	ldi	r25, 0x00	; 0
    a698:	89 2b       	or	r24, r25
    a69a:	d1 94       	neg	r13
    a69c:	91 e0       	ldi	r25, 0x01	; 1
    a69e:	1d 14       	cp	r1, r13
    a6a0:	08 f0       	brcs	.+2      	; 0xa6a4 <__divdi3+0x184>
    a6a2:	90 e0       	ldi	r25, 0x00	; 0
    a6a4:	5d 2d       	mov	r21, r13
    a6a6:	58 1b       	sub	r21, r24
    a6a8:	81 e0       	ldi	r24, 0x01	; 1
    a6aa:	d5 16       	cp	r13, r21
    a6ac:	08 f0       	brcs	.+2      	; 0xa6b0 <__divdi3+0x190>
    a6ae:	80 e0       	ldi	r24, 0x00	; 0
    a6b0:	98 2b       	or	r25, r24
    a6b2:	e1 94       	neg	r14
    a6b4:	81 e0       	ldi	r24, 0x01	; 1
    a6b6:	1e 14       	cp	r1, r14
    a6b8:	08 f0       	brcs	.+2      	; 0xa6bc <__divdi3+0x19c>
    a6ba:	80 e0       	ldi	r24, 0x00	; 0
    a6bc:	3e 2d       	mov	r19, r14
    a6be:	39 1b       	sub	r19, r25
    a6c0:	91 e0       	ldi	r25, 0x01	; 1
    a6c2:	e3 16       	cp	r14, r19
    a6c4:	08 f0       	brcs	.+2      	; 0xa6c8 <__divdi3+0x1a8>
    a6c6:	90 e0       	ldi	r25, 0x00	; 0
    a6c8:	89 2b       	or	r24, r25
    a6ca:	f1 94       	neg	r15
    a6cc:	91 e0       	ldi	r25, 0x01	; 1
    a6ce:	1f 14       	cp	r1, r15
    a6d0:	08 f0       	brcs	.+2      	; 0xa6d4 <__divdi3+0x1b4>
    a6d2:	90 e0       	ldi	r25, 0x00	; 0
    a6d4:	2f 2d       	mov	r18, r15
    a6d6:	28 1b       	sub	r18, r24
    a6d8:	81 e0       	ldi	r24, 0x01	; 1
    a6da:	f2 16       	cp	r15, r18
    a6dc:	08 f0       	brcs	.+2      	; 0xa6e0 <__divdi3+0x1c0>
    a6de:	80 e0       	ldi	r24, 0x00	; 0
    a6e0:	98 2b       	or	r25, r24
    a6e2:	01 95       	neg	r16
    a6e4:	81 e0       	ldi	r24, 0x01	; 1
    a6e6:	10 16       	cp	r1, r16
    a6e8:	08 f0       	brcs	.+2      	; 0xa6ec <__divdi3+0x1cc>
    a6ea:	80 e0       	ldi	r24, 0x00	; 0
    a6ec:	70 2f       	mov	r23, r16
    a6ee:	79 1b       	sub	r23, r25
    a6f0:	97 2f       	mov	r25, r23
    a6f2:	71 e0       	ldi	r23, 0x01	; 1
    a6f4:	09 17       	cp	r16, r25
    a6f6:	08 f0       	brcs	.+2      	; 0xa6fa <__divdi3+0x1da>
    a6f8:	70 e0       	ldi	r23, 0x00	; 0
    a6fa:	87 2b       	or	r24, r23
    a6fc:	11 95       	neg	r17
    a6fe:	18 1b       	sub	r17, r24
    a700:	e9 8f       	std	Y+25, r30	; 0x19
    a702:	4a 8f       	std	Y+26, r20	; 0x1a
    a704:	6b 8f       	std	Y+27, r22	; 0x1b
    a706:	5c 8f       	std	Y+28, r21	; 0x1c
    a708:	3d 8f       	std	Y+29, r19	; 0x1d
    a70a:	2e 8f       	std	Y+30, r18	; 0x1e
    a70c:	9f 8f       	std	Y+31, r25	; 0x1f
    a70e:	18 a3       	lds	r17, 0x58
    a710:	79 8d       	ldd	r23, Y+25	; 0x19
    a712:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a714:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a716:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a718:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a71a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a71c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a71e:	88 a1       	lds	r24, 0x48
    a720:	e9 a1       	lds	r30, 0x49
    a722:	e9 8b       	std	Y+17, r30	; 0x11
    a724:	ea a1       	lds	r30, 0x4a
    a726:	ea 8b       	std	Y+18, r30	; 0x12
    a728:	eb a1       	lds	r30, 0x4b
    a72a:	eb 8b       	std	Y+19, r30	; 0x13
    a72c:	ec a1       	lds	r30, 0x4c
    a72e:	ec 8b       	std	Y+20, r30	; 0x14
    a730:	ed a1       	lds	r30, 0x4d
    a732:	ed 8b       	std	Y+21, r30	; 0x15
    a734:	ee a1       	lds	r30, 0x4e
    a736:	ee 8b       	std	Y+22, r30	; 0x16
    a738:	ef a1       	lds	r30, 0x4f
    a73a:	ef 8b       	std	Y+23, r30	; 0x17
    a73c:	e8 a5       	lds	r30, 0x68
    a73e:	e8 8f       	std	Y+24, r30	; 0x18
    a740:	79 87       	std	Y+9, r23	; 0x09
    a742:	6a 87       	std	Y+10, r22	; 0x0a
    a744:	5b 87       	std	Y+11, r21	; 0x0b
    a746:	4c 87       	std	Y+12, r20	; 0x0c
    a748:	3d 87       	std	Y+13, r19	; 0x0d
    a74a:	2e 87       	std	Y+14, r18	; 0x0e
    a74c:	9f 87       	std	Y+15, r25	; 0x0f
    a74e:	88 8b       	std	Y+16, r24	; 0x10
    a750:	89 84       	ldd	r8, Y+9	; 0x09
    a752:	9a 84       	ldd	r9, Y+10	; 0x0a
    a754:	ab 84       	ldd	r10, Y+11	; 0x0b
    a756:	bc 84       	ldd	r11, Y+12	; 0x0c
    a758:	8d 85       	ldd	r24, Y+13	; 0x0d
    a75a:	9e 85       	ldd	r25, Y+14	; 0x0e
    a75c:	af 85       	ldd	r26, Y+15	; 0x0f
    a75e:	b8 89       	ldd	r27, Y+16	; 0x10
    a760:	e9 88       	ldd	r14, Y+17	; 0x11
    a762:	fa 88       	ldd	r15, Y+18	; 0x12
    a764:	0b 89       	ldd	r16, Y+19	; 0x13
    a766:	1c 89       	ldd	r17, Y+20	; 0x14
    a768:	ed aa       	sts	0x9d, r30
    a76a:	fe aa       	sts	0x9e, r31
    a76c:	0f ab       	sts	0x5f, r16
    a76e:	18 af       	sts	0x78, r17
    a770:	cd 88       	ldd	r12, Y+21	; 0x15
    a772:	de 88       	ldd	r13, Y+22	; 0x16
    a774:	ef 88       	ldd	r14, Y+23	; 0x17
    a776:	f8 8c       	ldd	r15, Y+24	; 0x18
    a778:	00 97       	sbiw	r24, 0x00	; 0
    a77a:	a1 05       	cpc	r26, r1
    a77c:	b1 05       	cpc	r27, r1
    a77e:	09 f0       	breq	.+2      	; 0xa782 <__divdi3+0x262>
    a780:	bd c3       	rjmp	.+1914   	; 0xaefc <__divdi3+0x9dc>
    a782:	c8 14       	cp	r12, r8
    a784:	d9 04       	cpc	r13, r9
    a786:	ea 04       	cpc	r14, r10
    a788:	fb 04       	cpc	r15, r11
    a78a:	08 f0       	brcs	.+2      	; 0xa78e <__divdi3+0x26e>
    a78c:	4d c1       	rjmp	.+666    	; 0xaa28 <__divdi3+0x508>
    a78e:	00 e0       	ldi	r16, 0x00	; 0
    a790:	80 16       	cp	r8, r16
    a792:	00 e0       	ldi	r16, 0x00	; 0
    a794:	90 06       	cpc	r9, r16
    a796:	01 e0       	ldi	r16, 0x01	; 1
    a798:	a0 06       	cpc	r10, r16
    a79a:	00 e0       	ldi	r16, 0x00	; 0
    a79c:	b0 06       	cpc	r11, r16
    a79e:	58 f4       	brcc	.+22     	; 0xa7b6 <__divdi3+0x296>
    a7a0:	1f ef       	ldi	r17, 0xFF	; 255
    a7a2:	81 16       	cp	r8, r17
    a7a4:	91 04       	cpc	r9, r1
    a7a6:	a1 04       	cpc	r10, r1
    a7a8:	b1 04       	cpc	r11, r1
    a7aa:	09 f0       	breq	.+2      	; 0xa7ae <__divdi3+0x28e>
    a7ac:	90 f4       	brcc	.+36     	; 0xa7d2 <__divdi3+0x2b2>
    a7ae:	80 e0       	ldi	r24, 0x00	; 0
    a7b0:	90 e0       	ldi	r25, 0x00	; 0
    a7b2:	dc 01       	movw	r26, r24
    a7b4:	17 c0       	rjmp	.+46     	; 0xa7e4 <__divdi3+0x2c4>
    a7b6:	20 e0       	ldi	r18, 0x00	; 0
    a7b8:	82 16       	cp	r8, r18
    a7ba:	20 e0       	ldi	r18, 0x00	; 0
    a7bc:	92 06       	cpc	r9, r18
    a7be:	20 e0       	ldi	r18, 0x00	; 0
    a7c0:	a2 06       	cpc	r10, r18
    a7c2:	21 e0       	ldi	r18, 0x01	; 1
    a7c4:	b2 06       	cpc	r11, r18
    a7c6:	50 f4       	brcc	.+20     	; 0xa7dc <__divdi3+0x2bc>
    a7c8:	80 e1       	ldi	r24, 0x10	; 16
    a7ca:	90 e0       	ldi	r25, 0x00	; 0
    a7cc:	a0 e0       	ldi	r26, 0x00	; 0
    a7ce:	b0 e0       	ldi	r27, 0x00	; 0
    a7d0:	09 c0       	rjmp	.+18     	; 0xa7e4 <__divdi3+0x2c4>
    a7d2:	88 e0       	ldi	r24, 0x08	; 8
    a7d4:	90 e0       	ldi	r25, 0x00	; 0
    a7d6:	a0 e0       	ldi	r26, 0x00	; 0
    a7d8:	b0 e0       	ldi	r27, 0x00	; 0
    a7da:	04 c0       	rjmp	.+8      	; 0xa7e4 <__divdi3+0x2c4>
    a7dc:	88 e1       	ldi	r24, 0x18	; 24
    a7de:	90 e0       	ldi	r25, 0x00	; 0
    a7e0:	a0 e0       	ldi	r26, 0x00	; 0
    a7e2:	b0 e0       	ldi	r27, 0x00	; 0
    a7e4:	b5 01       	movw	r22, r10
    a7e6:	a4 01       	movw	r20, r8
    a7e8:	08 2e       	mov	r0, r24
    a7ea:	04 c0       	rjmp	.+8      	; 0xa7f4 <__divdi3+0x2d4>
    a7ec:	76 95       	lsr	r23
    a7ee:	67 95       	ror	r22
    a7f0:	57 95       	ror	r21
    a7f2:	47 95       	ror	r20
    a7f4:	0a 94       	dec	r0
    a7f6:	d2 f7       	brpl	.-12     	; 0xa7ec <__divdi3+0x2cc>
    a7f8:	fa 01       	movw	r30, r20
    a7fa:	ef 5c       	subi	r30, 0xCF	; 207
    a7fc:	ff 4d       	sbci	r31, 0xDF	; 223
    a7fe:	20 81       	ld	r18, Z
    a800:	40 e2       	ldi	r20, 0x20	; 32
    a802:	50 e0       	ldi	r21, 0x00	; 0
    a804:	60 e0       	ldi	r22, 0x00	; 0
    a806:	70 e0       	ldi	r23, 0x00	; 0
    a808:	48 1b       	sub	r20, r24
    a80a:	59 0b       	sbc	r21, r25
    a80c:	6a 0b       	sbc	r22, r26
    a80e:	7b 0b       	sbc	r23, r27
    a810:	42 1b       	sub	r20, r18
    a812:	51 09       	sbc	r21, r1
    a814:	61 09       	sbc	r22, r1
    a816:	71 09       	sbc	r23, r1
    a818:	41 15       	cp	r20, r1
    a81a:	51 05       	cpc	r21, r1
    a81c:	61 05       	cpc	r22, r1
    a81e:	71 05       	cpc	r23, r1
    a820:	a1 f1       	breq	.+104    	; 0xa88a <__divdi3+0x36a>
    a822:	04 2e       	mov	r0, r20
    a824:	04 c0       	rjmp	.+8      	; 0xa82e <__divdi3+0x30e>
    a826:	88 0c       	add	r8, r8
    a828:	99 1c       	adc	r9, r9
    a82a:	aa 1c       	adc	r10, r10
    a82c:	bb 1c       	adc	r11, r11
    a82e:	0a 94       	dec	r0
    a830:	d2 f7       	brpl	.-12     	; 0xa826 <__divdi3+0x306>
    a832:	97 01       	movw	r18, r14
    a834:	86 01       	movw	r16, r12
    a836:	04 2e       	mov	r0, r20
    a838:	04 c0       	rjmp	.+8      	; 0xa842 <__divdi3+0x322>
    a83a:	00 0f       	add	r16, r16
    a83c:	11 1f       	adc	r17, r17
    a83e:	22 1f       	adc	r18, r18
    a840:	33 1f       	adc	r19, r19
    a842:	0a 94       	dec	r0
    a844:	d2 f7       	brpl	.-12     	; 0xa83a <__divdi3+0x31a>
    a846:	80 e2       	ldi	r24, 0x20	; 32
    a848:	90 e0       	ldi	r25, 0x00	; 0
    a84a:	84 1b       	sub	r24, r20
    a84c:	95 0b       	sbc	r25, r21
    a84e:	cd a8       	sts	0x8d, r28
    a850:	de a8       	sts	0x8e, r29
    a852:	ef a8       	sts	0x8f, r30
    a854:	f8 ac       	sts	0xa8, r31
    a856:	04 c0       	rjmp	.+8      	; 0xa860 <__divdi3+0x340>
    a858:	f6 94       	lsr	r15
    a85a:	e7 94       	ror	r14
    a85c:	d7 94       	ror	r13
    a85e:	c7 94       	ror	r12
    a860:	8a 95       	dec	r24
    a862:	d2 f7       	brpl	.-12     	; 0xa858 <__divdi3+0x338>
    a864:	c0 2a       	or	r12, r16
    a866:	d1 2a       	or	r13, r17
    a868:	e2 2a       	or	r14, r18
    a86a:	f3 2a       	or	r15, r19
    a86c:	0d a9       	sts	0x4d, r16
    a86e:	1e a9       	sts	0x4e, r17
    a870:	2f a9       	sts	0x4f, r18
    a872:	38 ad       	sts	0x68, r19
    a874:	04 c0       	rjmp	.+8      	; 0xa87e <__divdi3+0x35e>
    a876:	00 0f       	add	r16, r16
    a878:	11 1f       	adc	r17, r17
    a87a:	22 1f       	adc	r18, r18
    a87c:	33 1f       	adc	r19, r19
    a87e:	4a 95       	dec	r20
    a880:	d2 f7       	brpl	.-12     	; 0xa876 <__divdi3+0x356>
    a882:	0d ab       	sts	0x5d, r16
    a884:	1e ab       	sts	0x5e, r17
    a886:	2f ab       	sts	0x5f, r18
    a888:	38 af       	sts	0x78, r19
    a88a:	25 01       	movw	r4, r10
    a88c:	66 24       	eor	r6, r6
    a88e:	77 24       	eor	r7, r7
    a890:	95 01       	movw	r18, r10
    a892:	84 01       	movw	r16, r8
    a894:	20 70       	andi	r18, 0x00	; 0
    a896:	30 70       	andi	r19, 0x00	; 0
    a898:	09 ab       	sts	0x59, r16
    a89a:	1a ab       	sts	0x5a, r17
    a89c:	2b ab       	sts	0x5b, r18
    a89e:	3c ab       	sts	0x5c, r19
    a8a0:	c7 01       	movw	r24, r14
    a8a2:	b6 01       	movw	r22, r12
    a8a4:	a3 01       	movw	r20, r6
    a8a6:	92 01       	movw	r18, r4
    a8a8:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    a8ac:	2d a7       	lds	r18, 0x7d
    a8ae:	3e a7       	lds	r19, 0x7e
    a8b0:	4f a7       	lds	r20, 0x7f
    a8b2:	58 ab       	sts	0x58, r21
    a8b4:	69 a7       	lds	r22, 0x79
    a8b6:	7a a7       	lds	r23, 0x7a
    a8b8:	8b a7       	lds	r24, 0x7b
    a8ba:	9c a7       	lds	r25, 0x7c
    a8bc:	c7 01       	movw	r24, r14
    a8be:	b6 01       	movw	r22, r12
    a8c0:	a3 01       	movw	r20, r6
    a8c2:	92 01       	movw	r18, r4
    a8c4:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    a8c8:	ca 01       	movw	r24, r20
    a8ca:	b9 01       	movw	r22, r18
    a8cc:	29 a9       	sts	0x49, r18
    a8ce:	3a a9       	sts	0x4a, r19
    a8d0:	4b a9       	sts	0x4b, r20
    a8d2:	5c a9       	sts	0x4c, r21
    a8d4:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a8d8:	ab 01       	movw	r20, r22
    a8da:	bc 01       	movw	r22, r24
    a8dc:	09 a5       	lds	r16, 0x69
    a8de:	1a a5       	lds	r17, 0x6a
    a8e0:	2b a5       	lds	r18, 0x6b
    a8e2:	3c a5       	lds	r19, 0x6c
    a8e4:	78 01       	movw	r14, r16
    a8e6:	dd 24       	eor	r13, r13
    a8e8:	cc 24       	eor	r12, r12
    a8ea:	0d a9       	sts	0x4d, r16
    a8ec:	1e a9       	sts	0x4e, r17
    a8ee:	2f a9       	sts	0x4f, r18
    a8f0:	38 ad       	sts	0x68, r19
    a8f2:	c9 01       	movw	r24, r18
    a8f4:	aa 27       	eor	r26, r26
    a8f6:	bb 27       	eor	r27, r27
    a8f8:	c8 2a       	or	r12, r24
    a8fa:	d9 2a       	or	r13, r25
    a8fc:	ea 2a       	or	r14, r26
    a8fe:	fb 2a       	or	r15, r27
    a900:	0d a5       	lds	r16, 0x6d
    a902:	1e a5       	lds	r17, 0x6e
    a904:	2f a5       	lds	r18, 0x6f
    a906:	38 a9       	sts	0x48, r19
    a908:	c4 16       	cp	r12, r20
    a90a:	d5 06       	cpc	r13, r21
    a90c:	e6 06       	cpc	r14, r22
    a90e:	f7 06       	cpc	r15, r23
    a910:	38 f5       	brcc	.+78     	; 0xa960 <__divdi3+0x440>
    a912:	01 50       	subi	r16, 0x01	; 1
    a914:	10 40       	sbci	r17, 0x00	; 0
    a916:	20 40       	sbci	r18, 0x00	; 0
    a918:	30 40       	sbci	r19, 0x00	; 0
    a91a:	09 a7       	lds	r16, 0x79
    a91c:	1a a7       	lds	r17, 0x7a
    a91e:	2b a7       	lds	r18, 0x7b
    a920:	3c a7       	lds	r19, 0x7c
    a922:	c8 0c       	add	r12, r8
    a924:	d9 1c       	adc	r13, r9
    a926:	ea 1c       	adc	r14, r10
    a928:	fb 1c       	adc	r15, r11
    a92a:	c8 14       	cp	r12, r8
    a92c:	d9 04       	cpc	r13, r9
    a92e:	ea 04       	cpc	r14, r10
    a930:	fb 04       	cpc	r15, r11
    a932:	d0 f0       	brcs	.+52     	; 0xa968 <__divdi3+0x448>
    a934:	c4 16       	cp	r12, r20
    a936:	d5 06       	cpc	r13, r21
    a938:	e6 06       	cpc	r14, r22
    a93a:	f7 06       	cpc	r15, r23
    a93c:	a8 f4       	brcc	.+42     	; 0xa968 <__divdi3+0x448>
    a93e:	0d a5       	lds	r16, 0x6d
    a940:	1e a5       	lds	r17, 0x6e
    a942:	2f a5       	lds	r18, 0x6f
    a944:	38 a9       	sts	0x48, r19
    a946:	02 50       	subi	r16, 0x02	; 2
    a948:	10 40       	sbci	r17, 0x00	; 0
    a94a:	20 40       	sbci	r18, 0x00	; 0
    a94c:	30 40       	sbci	r19, 0x00	; 0
    a94e:	09 a7       	lds	r16, 0x79
    a950:	1a a7       	lds	r17, 0x7a
    a952:	2b a7       	lds	r18, 0x7b
    a954:	3c a7       	lds	r19, 0x7c
    a956:	c8 0c       	add	r12, r8
    a958:	d9 1c       	adc	r13, r9
    a95a:	ea 1c       	adc	r14, r10
    a95c:	fb 1c       	adc	r15, r11
    a95e:	04 c0       	rjmp	.+8      	; 0xa968 <__divdi3+0x448>
    a960:	09 a7       	lds	r16, 0x79
    a962:	1a a7       	lds	r17, 0x7a
    a964:	2b a7       	lds	r18, 0x7b
    a966:	3c a7       	lds	r19, 0x7c
    a968:	c4 1a       	sub	r12, r20
    a96a:	d5 0a       	sbc	r13, r21
    a96c:	e6 0a       	sbc	r14, r22
    a96e:	f7 0a       	sbc	r15, r23
    a970:	c7 01       	movw	r24, r14
    a972:	b6 01       	movw	r22, r12
    a974:	a3 01       	movw	r20, r6
    a976:	92 01       	movw	r18, r4
    a978:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    a97c:	2d a7       	lds	r18, 0x7d
    a97e:	3e a7       	lds	r19, 0x7e
    a980:	4f a7       	lds	r20, 0x7f
    a982:	58 ab       	sts	0x58, r21
    a984:	69 af       	sts	0x79, r22
    a986:	7a af       	sts	0x7a, r23
    a988:	8b af       	sts	0x7b, r24
    a98a:	9c af       	sts	0x7c, r25
    a98c:	c7 01       	movw	r24, r14
    a98e:	b6 01       	movw	r22, r12
    a990:	a3 01       	movw	r20, r6
    a992:	92 01       	movw	r18, r4
    a994:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    a998:	ca 01       	movw	r24, r20
    a99a:	b9 01       	movw	r22, r18
    a99c:	29 a9       	sts	0x49, r18
    a99e:	3a a9       	sts	0x4a, r19
    a9a0:	4b a9       	sts	0x4b, r20
    a9a2:	5c a9       	sts	0x4c, r21
    a9a4:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    a9a8:	6b 01       	movw	r12, r22
    a9aa:	7c 01       	movw	r14, r24
    a9ac:	49 ad       	sts	0x69, r20
    a9ae:	5a ad       	sts	0x6a, r21
    a9b0:	6b ad       	sts	0x6b, r22
    a9b2:	7c ad       	sts	0x6c, r23
    a9b4:	9a 01       	movw	r18, r20
    a9b6:	11 27       	eor	r17, r17
    a9b8:	00 27       	eor	r16, r16
    a9ba:	4d a9       	sts	0x4d, r20
    a9bc:	5e a9       	sts	0x4e, r21
    a9be:	6f a9       	sts	0x4f, r22
    a9c0:	78 ad       	sts	0x68, r23
    a9c2:	60 70       	andi	r22, 0x00	; 0
    a9c4:	70 70       	andi	r23, 0x00	; 0
    a9c6:	04 2b       	or	r16, r20
    a9c8:	15 2b       	or	r17, r21
    a9ca:	26 2b       	or	r18, r22
    a9cc:	37 2b       	or	r19, r23
    a9ce:	8d a5       	lds	r24, 0x6d
    a9d0:	9e a5       	lds	r25, 0x6e
    a9d2:	af a5       	lds	r26, 0x6f
    a9d4:	b8 a9       	sts	0x48, r27
    a9d6:	0c 15       	cp	r16, r12
    a9d8:	1d 05       	cpc	r17, r13
    a9da:	2e 05       	cpc	r18, r14
    a9dc:	3f 05       	cpc	r19, r15
    a9de:	c0 f4       	brcc	.+48     	; 0xaa10 <__divdi3+0x4f0>
    a9e0:	01 97       	sbiw	r24, 0x01	; 1
    a9e2:	a1 09       	sbc	r26, r1
    a9e4:	b1 09       	sbc	r27, r1
    a9e6:	08 0d       	add	r16, r8
    a9e8:	19 1d       	adc	r17, r9
    a9ea:	2a 1d       	adc	r18, r10
    a9ec:	3b 1d       	adc	r19, r11
    a9ee:	08 15       	cp	r16, r8
    a9f0:	19 05       	cpc	r17, r9
    a9f2:	2a 05       	cpc	r18, r10
    a9f4:	3b 05       	cpc	r19, r11
    a9f6:	60 f0       	brcs	.+24     	; 0xaa10 <__divdi3+0x4f0>
    a9f8:	0c 15       	cp	r16, r12
    a9fa:	1d 05       	cpc	r17, r13
    a9fc:	2e 05       	cpc	r18, r14
    a9fe:	3f 05       	cpc	r19, r15
    aa00:	38 f4       	brcc	.+14     	; 0xaa10 <__divdi3+0x4f0>
    aa02:	8d a5       	lds	r24, 0x6d
    aa04:	9e a5       	lds	r25, 0x6e
    aa06:	af a5       	lds	r26, 0x6f
    aa08:	b8 a9       	sts	0x48, r27
    aa0a:	02 97       	sbiw	r24, 0x02	; 2
    aa0c:	a1 09       	sbc	r26, r1
    aa0e:	b1 09       	sbc	r27, r1
    aa10:	09 a5       	lds	r16, 0x69
    aa12:	1a a5       	lds	r17, 0x6a
    aa14:	2b a5       	lds	r18, 0x6b
    aa16:	3c a5       	lds	r19, 0x6c
    aa18:	78 01       	movw	r14, r16
    aa1a:	dd 24       	eor	r13, r13
    aa1c:	cc 24       	eor	r12, r12
    aa1e:	c8 2a       	or	r12, r24
    aa20:	d9 2a       	or	r13, r25
    aa22:	ea 2a       	or	r14, r26
    aa24:	fb 2a       	or	r15, r27
    aa26:	b7 c4       	rjmp	.+2414   	; 0xb396 <__divdi3+0xe76>
    aa28:	81 14       	cp	r8, r1
    aa2a:	91 04       	cpc	r9, r1
    aa2c:	a1 04       	cpc	r10, r1
    aa2e:	b1 04       	cpc	r11, r1
    aa30:	51 f4       	brne	.+20     	; 0xaa46 <__divdi3+0x526>
    aa32:	61 e0       	ldi	r22, 0x01	; 1
    aa34:	70 e0       	ldi	r23, 0x00	; 0
    aa36:	80 e0       	ldi	r24, 0x00	; 0
    aa38:	90 e0       	ldi	r25, 0x00	; 0
    aa3a:	a5 01       	movw	r20, r10
    aa3c:	94 01       	movw	r18, r8
    aa3e:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    aa42:	49 01       	movw	r8, r18
    aa44:	5a 01       	movw	r10, r20
    aa46:	10 e0       	ldi	r17, 0x00	; 0
    aa48:	81 16       	cp	r8, r17
    aa4a:	10 e0       	ldi	r17, 0x00	; 0
    aa4c:	91 06       	cpc	r9, r17
    aa4e:	11 e0       	ldi	r17, 0x01	; 1
    aa50:	a1 06       	cpc	r10, r17
    aa52:	10 e0       	ldi	r17, 0x00	; 0
    aa54:	b1 06       	cpc	r11, r17
    aa56:	58 f4       	brcc	.+22     	; 0xaa6e <__divdi3+0x54e>
    aa58:	2f ef       	ldi	r18, 0xFF	; 255
    aa5a:	82 16       	cp	r8, r18
    aa5c:	91 04       	cpc	r9, r1
    aa5e:	a1 04       	cpc	r10, r1
    aa60:	b1 04       	cpc	r11, r1
    aa62:	09 f0       	breq	.+2      	; 0xaa66 <__divdi3+0x546>
    aa64:	90 f4       	brcc	.+36     	; 0xaa8a <__divdi3+0x56a>
    aa66:	80 e0       	ldi	r24, 0x00	; 0
    aa68:	90 e0       	ldi	r25, 0x00	; 0
    aa6a:	dc 01       	movw	r26, r24
    aa6c:	17 c0       	rjmp	.+46     	; 0xaa9c <__divdi3+0x57c>
    aa6e:	30 e0       	ldi	r19, 0x00	; 0
    aa70:	83 16       	cp	r8, r19
    aa72:	30 e0       	ldi	r19, 0x00	; 0
    aa74:	93 06       	cpc	r9, r19
    aa76:	30 e0       	ldi	r19, 0x00	; 0
    aa78:	a3 06       	cpc	r10, r19
    aa7a:	31 e0       	ldi	r19, 0x01	; 1
    aa7c:	b3 06       	cpc	r11, r19
    aa7e:	50 f4       	brcc	.+20     	; 0xaa94 <__divdi3+0x574>
    aa80:	80 e1       	ldi	r24, 0x10	; 16
    aa82:	90 e0       	ldi	r25, 0x00	; 0
    aa84:	a0 e0       	ldi	r26, 0x00	; 0
    aa86:	b0 e0       	ldi	r27, 0x00	; 0
    aa88:	09 c0       	rjmp	.+18     	; 0xaa9c <__divdi3+0x57c>
    aa8a:	88 e0       	ldi	r24, 0x08	; 8
    aa8c:	90 e0       	ldi	r25, 0x00	; 0
    aa8e:	a0 e0       	ldi	r26, 0x00	; 0
    aa90:	b0 e0       	ldi	r27, 0x00	; 0
    aa92:	04 c0       	rjmp	.+8      	; 0xaa9c <__divdi3+0x57c>
    aa94:	88 e1       	ldi	r24, 0x18	; 24
    aa96:	90 e0       	ldi	r25, 0x00	; 0
    aa98:	a0 e0       	ldi	r26, 0x00	; 0
    aa9a:	b0 e0       	ldi	r27, 0x00	; 0
    aa9c:	b5 01       	movw	r22, r10
    aa9e:	a4 01       	movw	r20, r8
    aaa0:	08 2e       	mov	r0, r24
    aaa2:	04 c0       	rjmp	.+8      	; 0xaaac <__divdi3+0x58c>
    aaa4:	76 95       	lsr	r23
    aaa6:	67 95       	ror	r22
    aaa8:	57 95       	ror	r21
    aaaa:	47 95       	ror	r20
    aaac:	0a 94       	dec	r0
    aaae:	d2 f7       	brpl	.-12     	; 0xaaa4 <__divdi3+0x584>
    aab0:	fa 01       	movw	r30, r20
    aab2:	ef 5c       	subi	r30, 0xCF	; 207
    aab4:	ff 4d       	sbci	r31, 0xDF	; 223
    aab6:	20 81       	ld	r18, Z
    aab8:	ac 01       	movw	r20, r24
    aaba:	bd 01       	movw	r22, r26
    aabc:	42 0f       	add	r20, r18
    aabe:	51 1d       	adc	r21, r1
    aac0:	61 1d       	adc	r22, r1
    aac2:	71 1d       	adc	r23, r1
    aac4:	80 e2       	ldi	r24, 0x20	; 32
    aac6:	90 e0       	ldi	r25, 0x00	; 0
    aac8:	a0 e0       	ldi	r26, 0x00	; 0
    aaca:	b0 e0       	ldi	r27, 0x00	; 0
    aacc:	84 1b       	sub	r24, r20
    aace:	95 0b       	sbc	r25, r21
    aad0:	a6 0b       	sbc	r26, r22
    aad2:	b7 0b       	sbc	r27, r23
    aad4:	51 f4       	brne	.+20     	; 0xaaea <__divdi3+0x5ca>
    aad6:	c8 18       	sub	r12, r8
    aad8:	d9 08       	sbc	r13, r9
    aada:	ea 08       	sbc	r14, r10
    aadc:	fb 08       	sbc	r15, r11
    aade:	f1 e0       	ldi	r31, 0x01	; 1
    aae0:	4f 2e       	mov	r4, r31
    aae2:	51 2c       	mov	r5, r1
    aae4:	61 2c       	mov	r6, r1
    aae6:	71 2c       	mov	r7, r1
    aae8:	28 c1       	rjmp	.+592    	; 0xad3a <__divdi3+0x81a>
    aaea:	08 2e       	mov	r0, r24
    aaec:	04 c0       	rjmp	.+8      	; 0xaaf6 <__divdi3+0x5d6>
    aaee:	88 0c       	add	r8, r8
    aaf0:	99 1c       	adc	r9, r9
    aaf2:	aa 1c       	adc	r10, r10
    aaf4:	bb 1c       	adc	r11, r11
    aaf6:	0a 94       	dec	r0
    aaf8:	d2 f7       	brpl	.-12     	; 0xaaee <__divdi3+0x5ce>
    aafa:	97 01       	movw	r18, r14
    aafc:	86 01       	movw	r16, r12
    aafe:	04 2e       	mov	r0, r20
    ab00:	04 c0       	rjmp	.+8      	; 0xab0a <__divdi3+0x5ea>
    ab02:	36 95       	lsr	r19
    ab04:	27 95       	ror	r18
    ab06:	17 95       	ror	r17
    ab08:	07 95       	ror	r16
    ab0a:	0a 94       	dec	r0
    ab0c:	d2 f7       	brpl	.-12     	; 0xab02 <__divdi3+0x5e2>
    ab0e:	09 ab       	sts	0x59, r16
    ab10:	1a ab       	sts	0x5a, r17
    ab12:	2b ab       	sts	0x5b, r18
    ab14:	3c ab       	sts	0x5c, r19
    ab16:	97 01       	movw	r18, r14
    ab18:	86 01       	movw	r16, r12
    ab1a:	08 2e       	mov	r0, r24
    ab1c:	04 c0       	rjmp	.+8      	; 0xab26 <__divdi3+0x606>
    ab1e:	00 0f       	add	r16, r16
    ab20:	11 1f       	adc	r17, r17
    ab22:	22 1f       	adc	r18, r18
    ab24:	33 1f       	adc	r19, r19
    ab26:	0a 94       	dec	r0
    ab28:	d2 f7       	brpl	.-12     	; 0xab1e <__divdi3+0x5fe>
    ab2a:	0d a7       	lds	r16, 0x7d
    ab2c:	1e a7       	lds	r17, 0x7e
    ab2e:	2f a7       	lds	r18, 0x7f
    ab30:	38 ab       	sts	0x58, r19
    ab32:	ed a8       	sts	0x8d, r30
    ab34:	fe a8       	sts	0x8e, r31
    ab36:	0f a9       	sts	0x4f, r16
    ab38:	18 ad       	sts	0x68, r17
    ab3a:	04 c0       	rjmp	.+8      	; 0xab44 <__divdi3+0x624>
    ab3c:	16 95       	lsr	r17
    ab3e:	07 95       	ror	r16
    ab40:	f7 94       	ror	r15
    ab42:	e7 94       	ror	r14
    ab44:	4a 95       	dec	r20
    ab46:	d2 f7       	brpl	.-12     	; 0xab3c <__divdi3+0x61c>
    ab48:	b8 01       	movw	r22, r16
    ab4a:	a7 01       	movw	r20, r14
    ab4c:	0d a5       	lds	r16, 0x6d
    ab4e:	1e a5       	lds	r17, 0x6e
    ab50:	2f a5       	lds	r18, 0x6f
    ab52:	38 a9       	sts	0x48, r19
    ab54:	04 2b       	or	r16, r20
    ab56:	15 2b       	or	r17, r21
    ab58:	26 2b       	or	r18, r22
    ab5a:	37 2b       	or	r19, r23
    ab5c:	0d a7       	lds	r16, 0x7d
    ab5e:	1e a7       	lds	r17, 0x7e
    ab60:	2f a7       	lds	r18, 0x7f
    ab62:	38 ab       	sts	0x58, r19
    ab64:	ed a8       	sts	0x8d, r30
    ab66:	fe a8       	sts	0x8e, r31
    ab68:	0f a9       	sts	0x4f, r16
    ab6a:	18 ad       	sts	0x68, r17
    ab6c:	04 c0       	rjmp	.+8      	; 0xab76 <__divdi3+0x656>
    ab6e:	ee 0c       	add	r14, r14
    ab70:	ff 1c       	adc	r15, r15
    ab72:	00 1f       	adc	r16, r16
    ab74:	11 1f       	adc	r17, r17
    ab76:	8a 95       	dec	r24
    ab78:	d2 f7       	brpl	.-12     	; 0xab6e <__divdi3+0x64e>
    ab7a:	ed aa       	sts	0x9d, r30
    ab7c:	fe aa       	sts	0x9e, r31
    ab7e:	0f ab       	sts	0x5f, r16
    ab80:	18 af       	sts	0x78, r17
    ab82:	25 01       	movw	r4, r10
    ab84:	66 24       	eor	r6, r6
    ab86:	77 24       	eor	r7, r7
    ab88:	95 01       	movw	r18, r10
    ab8a:	84 01       	movw	r16, r8
    ab8c:	20 70       	andi	r18, 0x00	; 0
    ab8e:	30 70       	andi	r19, 0x00	; 0
    ab90:	09 af       	sts	0x79, r16
    ab92:	1a af       	sts	0x7a, r17
    ab94:	2b af       	sts	0x7b, r18
    ab96:	3c af       	sts	0x7c, r19
    ab98:	69 a9       	sts	0x49, r22
    ab9a:	7a a9       	sts	0x4a, r23
    ab9c:	8b a9       	sts	0x4b, r24
    ab9e:	9c a9       	sts	0x4c, r25
    aba0:	a3 01       	movw	r20, r6
    aba2:	92 01       	movw	r18, r4
    aba4:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    aba8:	29 a7       	lds	r18, 0x79
    abaa:	3a a7       	lds	r19, 0x7a
    abac:	4b a7       	lds	r20, 0x7b
    abae:	5c a7       	lds	r21, 0x7c
    abb0:	6b 01       	movw	r12, r22
    abb2:	7c 01       	movw	r14, r24
    abb4:	69 a9       	sts	0x49, r22
    abb6:	7a a9       	sts	0x4a, r23
    abb8:	8b a9       	sts	0x4b, r24
    abba:	9c a9       	sts	0x4c, r25
    abbc:	a3 01       	movw	r20, r6
    abbe:	92 01       	movw	r18, r4
    abc0:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    abc4:	ca 01       	movw	r24, r20
    abc6:	b9 01       	movw	r22, r18
    abc8:	29 ad       	sts	0x69, r18
    abca:	3a ad       	sts	0x6a, r19
    abcc:	4b ad       	sts	0x6b, r20
    abce:	5c ad       	sts	0x6c, r21
    abd0:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    abd4:	ab 01       	movw	r20, r22
    abd6:	bc 01       	movw	r22, r24
    abd8:	76 01       	movw	r14, r12
    abda:	dd 24       	eor	r13, r13
    abdc:	cc 24       	eor	r12, r12
    abde:	0d a5       	lds	r16, 0x6d
    abe0:	1e a5       	lds	r17, 0x6e
    abe2:	2f a5       	lds	r18, 0x6f
    abe4:	38 a9       	sts	0x48, r19
    abe6:	c9 01       	movw	r24, r18
    abe8:	aa 27       	eor	r26, r26
    abea:	bb 27       	eor	r27, r27
    abec:	c8 2a       	or	r12, r24
    abee:	d9 2a       	or	r13, r25
    abf0:	ea 2a       	or	r14, r26
    abf2:	fb 2a       	or	r15, r27
    abf4:	09 a5       	lds	r16, 0x69
    abf6:	1a a5       	lds	r17, 0x6a
    abf8:	2b a5       	lds	r18, 0x6b
    abfa:	3c a5       	lds	r19, 0x6c
    abfc:	c4 16       	cp	r12, r20
    abfe:	d5 06       	cpc	r13, r21
    ac00:	e6 06       	cpc	r14, r22
    ac02:	f7 06       	cpc	r15, r23
    ac04:	38 f5       	brcc	.+78     	; 0xac54 <__divdi3+0x734>
    ac06:	01 50       	subi	r16, 0x01	; 1
    ac08:	10 40       	sbci	r17, 0x00	; 0
    ac0a:	20 40       	sbci	r18, 0x00	; 0
    ac0c:	30 40       	sbci	r19, 0x00	; 0
    ac0e:	09 ab       	sts	0x59, r16
    ac10:	1a ab       	sts	0x5a, r17
    ac12:	2b ab       	sts	0x5b, r18
    ac14:	3c ab       	sts	0x5c, r19
    ac16:	c8 0c       	add	r12, r8
    ac18:	d9 1c       	adc	r13, r9
    ac1a:	ea 1c       	adc	r14, r10
    ac1c:	fb 1c       	adc	r15, r11
    ac1e:	c8 14       	cp	r12, r8
    ac20:	d9 04       	cpc	r13, r9
    ac22:	ea 04       	cpc	r14, r10
    ac24:	fb 04       	cpc	r15, r11
    ac26:	d0 f0       	brcs	.+52     	; 0xac5c <__divdi3+0x73c>
    ac28:	c4 16       	cp	r12, r20
    ac2a:	d5 06       	cpc	r13, r21
    ac2c:	e6 06       	cpc	r14, r22
    ac2e:	f7 06       	cpc	r15, r23
    ac30:	a8 f4       	brcc	.+42     	; 0xac5c <__divdi3+0x73c>
    ac32:	09 a5       	lds	r16, 0x69
    ac34:	1a a5       	lds	r17, 0x6a
    ac36:	2b a5       	lds	r18, 0x6b
    ac38:	3c a5       	lds	r19, 0x6c
    ac3a:	02 50       	subi	r16, 0x02	; 2
    ac3c:	10 40       	sbci	r17, 0x00	; 0
    ac3e:	20 40       	sbci	r18, 0x00	; 0
    ac40:	30 40       	sbci	r19, 0x00	; 0
    ac42:	09 ab       	sts	0x59, r16
    ac44:	1a ab       	sts	0x5a, r17
    ac46:	2b ab       	sts	0x5b, r18
    ac48:	3c ab       	sts	0x5c, r19
    ac4a:	c8 0c       	add	r12, r8
    ac4c:	d9 1c       	adc	r13, r9
    ac4e:	ea 1c       	adc	r14, r10
    ac50:	fb 1c       	adc	r15, r11
    ac52:	04 c0       	rjmp	.+8      	; 0xac5c <__divdi3+0x73c>
    ac54:	09 ab       	sts	0x59, r16
    ac56:	1a ab       	sts	0x5a, r17
    ac58:	2b ab       	sts	0x5b, r18
    ac5a:	3c ab       	sts	0x5c, r19
    ac5c:	c4 1a       	sub	r12, r20
    ac5e:	d5 0a       	sbc	r13, r21
    ac60:	e6 0a       	sbc	r14, r22
    ac62:	f7 0a       	sbc	r15, r23
    ac64:	c7 01       	movw	r24, r14
    ac66:	b6 01       	movw	r22, r12
    ac68:	a3 01       	movw	r20, r6
    ac6a:	92 01       	movw	r18, r4
    ac6c:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    ac70:	29 a7       	lds	r18, 0x79
    ac72:	3a a7       	lds	r19, 0x7a
    ac74:	4b a7       	lds	r20, 0x7b
    ac76:	5c a7       	lds	r21, 0x7c
    ac78:	21 96       	adiw	r28, 0x01	; 1
    ac7a:	6c af       	sts	0x7c, r22
    ac7c:	7d af       	sts	0x7d, r23
    ac7e:	8e af       	sts	0x7e, r24
    ac80:	9f af       	sts	0x7f, r25
    ac82:	21 97       	sbiw	r28, 0x01	; 1
    ac84:	c7 01       	movw	r24, r14
    ac86:	b6 01       	movw	r22, r12
    ac88:	a3 01       	movw	r20, r6
    ac8a:	92 01       	movw	r18, r4
    ac8c:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    ac90:	ca 01       	movw	r24, r20
    ac92:	b9 01       	movw	r22, r18
    ac94:	29 ad       	sts	0x69, r18
    ac96:	3a ad       	sts	0x6a, r19
    ac98:	4b ad       	sts	0x6b, r20
    ac9a:	5c ad       	sts	0x6c, r21
    ac9c:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    aca0:	8b 01       	movw	r16, r22
    aca2:	9c 01       	movw	r18, r24
    aca4:	21 96       	adiw	r28, 0x01	; 1
    aca6:	4c ad       	sts	0x6c, r20
    aca8:	5d ad       	sts	0x6d, r21
    acaa:	6e ad       	sts	0x6e, r22
    acac:	7f ad       	sts	0x6f, r23
    acae:	21 97       	sbiw	r28, 0x01	; 1
    acb0:	da 01       	movw	r26, r20
    acb2:	99 27       	eor	r25, r25
    acb4:	88 27       	eor	r24, r24
    acb6:	4d a5       	lds	r20, 0x6d
    acb8:	5e a5       	lds	r21, 0x6e
    acba:	6f a5       	lds	r22, 0x6f
    acbc:	78 a9       	sts	0x48, r23
    acbe:	60 70       	andi	r22, 0x00	; 0
    acc0:	70 70       	andi	r23, 0x00	; 0
    acc2:	84 2b       	or	r24, r20
    acc4:	95 2b       	or	r25, r21
    acc6:	a6 2b       	or	r26, r22
    acc8:	b7 2b       	or	r27, r23
    acca:	49 a5       	lds	r20, 0x69
    accc:	5a a5       	lds	r21, 0x6a
    acce:	6b a5       	lds	r22, 0x6b
    acd0:	7c a5       	lds	r23, 0x6c
    acd2:	80 17       	cp	r24, r16
    acd4:	91 07       	cpc	r25, r17
    acd6:	a2 07       	cpc	r26, r18
    acd8:	b3 07       	cpc	r27, r19
    acda:	f0 f4       	brcc	.+60     	; 0xad18 <__divdi3+0x7f8>
    acdc:	41 50       	subi	r20, 0x01	; 1
    acde:	50 40       	sbci	r21, 0x00	; 0
    ace0:	60 40       	sbci	r22, 0x00	; 0
    ace2:	70 40       	sbci	r23, 0x00	; 0
    ace4:	88 0d       	add	r24, r8
    ace6:	99 1d       	adc	r25, r9
    ace8:	aa 1d       	adc	r26, r10
    acea:	bb 1d       	adc	r27, r11
    acec:	88 15       	cp	r24, r8
    acee:	99 05       	cpc	r25, r9
    acf0:	aa 05       	cpc	r26, r10
    acf2:	bb 05       	cpc	r27, r11
    acf4:	88 f0       	brcs	.+34     	; 0xad18 <__divdi3+0x7f8>
    acf6:	80 17       	cp	r24, r16
    acf8:	91 07       	cpc	r25, r17
    acfa:	a2 07       	cpc	r26, r18
    acfc:	b3 07       	cpc	r27, r19
    acfe:	60 f4       	brcc	.+24     	; 0xad18 <__divdi3+0x7f8>
    ad00:	49 a5       	lds	r20, 0x69
    ad02:	5a a5       	lds	r21, 0x6a
    ad04:	6b a5       	lds	r22, 0x6b
    ad06:	7c a5       	lds	r23, 0x6c
    ad08:	42 50       	subi	r20, 0x02	; 2
    ad0a:	50 40       	sbci	r21, 0x00	; 0
    ad0c:	60 40       	sbci	r22, 0x00	; 0
    ad0e:	70 40       	sbci	r23, 0x00	; 0
    ad10:	88 0d       	add	r24, r8
    ad12:	99 1d       	adc	r25, r9
    ad14:	aa 1d       	adc	r26, r10
    ad16:	bb 1d       	adc	r27, r11
    ad18:	6c 01       	movw	r12, r24
    ad1a:	7d 01       	movw	r14, r26
    ad1c:	c0 1a       	sub	r12, r16
    ad1e:	d1 0a       	sbc	r13, r17
    ad20:	e2 0a       	sbc	r14, r18
    ad22:	f3 0a       	sbc	r15, r19
    ad24:	09 a9       	sts	0x49, r16
    ad26:	1a a9       	sts	0x4a, r17
    ad28:	2b a9       	sts	0x4b, r18
    ad2a:	3c a9       	sts	0x4c, r19
    ad2c:	38 01       	movw	r6, r16
    ad2e:	55 24       	eor	r5, r5
    ad30:	44 24       	eor	r4, r4
    ad32:	44 2a       	or	r4, r20
    ad34:	55 2a       	or	r5, r21
    ad36:	66 2a       	or	r6, r22
    ad38:	77 2a       	or	r7, r23
    ad3a:	85 01       	movw	r16, r10
    ad3c:	22 27       	eor	r18, r18
    ad3e:	33 27       	eor	r19, r19
    ad40:	0d a7       	lds	r16, 0x7d
    ad42:	1e a7       	lds	r17, 0x7e
    ad44:	2f a7       	lds	r18, 0x7f
    ad46:	38 ab       	sts	0x58, r19
    ad48:	95 01       	movw	r18, r10
    ad4a:	84 01       	movw	r16, r8
    ad4c:	20 70       	andi	r18, 0x00	; 0
    ad4e:	30 70       	andi	r19, 0x00	; 0
    ad50:	09 af       	sts	0x79, r16
    ad52:	1a af       	sts	0x7a, r17
    ad54:	2b af       	sts	0x7b, r18
    ad56:	3c af       	sts	0x7c, r19
    ad58:	c7 01       	movw	r24, r14
    ad5a:	b6 01       	movw	r22, r12
    ad5c:	2d a5       	lds	r18, 0x6d
    ad5e:	3e a5       	lds	r19, 0x6e
    ad60:	4f a5       	lds	r20, 0x6f
    ad62:	58 a9       	sts	0x48, r21
    ad64:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    ad68:	29 a7       	lds	r18, 0x79
    ad6a:	3a a7       	lds	r19, 0x7a
    ad6c:	4b a7       	lds	r20, 0x7b
    ad6e:	5c a7       	lds	r21, 0x7c
    ad70:	69 ab       	sts	0x59, r22
    ad72:	7a ab       	sts	0x5a, r23
    ad74:	8b ab       	sts	0x5b, r24
    ad76:	9c ab       	sts	0x5c, r25
    ad78:	c7 01       	movw	r24, r14
    ad7a:	b6 01       	movw	r22, r12
    ad7c:	2d a5       	lds	r18, 0x6d
    ad7e:	3e a5       	lds	r19, 0x6e
    ad80:	4f a5       	lds	r20, 0x6f
    ad82:	58 a9       	sts	0x48, r21
    ad84:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    ad88:	ca 01       	movw	r24, r20
    ad8a:	b9 01       	movw	r22, r18
    ad8c:	29 ad       	sts	0x69, r18
    ad8e:	3a ad       	sts	0x6a, r19
    ad90:	4b ad       	sts	0x6b, r20
    ad92:	5c ad       	sts	0x6c, r21
    ad94:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    ad98:	ab 01       	movw	r20, r22
    ad9a:	bc 01       	movw	r22, r24
    ad9c:	09 a9       	sts	0x49, r16
    ad9e:	1a a9       	sts	0x4a, r17
    ada0:	2b a9       	sts	0x4b, r18
    ada2:	3c a9       	sts	0x4c, r19
    ada4:	78 01       	movw	r14, r16
    ada6:	dd 24       	eor	r13, r13
    ada8:	cc 24       	eor	r12, r12
    adaa:	0d a9       	sts	0x4d, r16
    adac:	1e a9       	sts	0x4e, r17
    adae:	2f a9       	sts	0x4f, r18
    adb0:	38 ad       	sts	0x68, r19
    adb2:	c9 01       	movw	r24, r18
    adb4:	aa 27       	eor	r26, r26
    adb6:	bb 27       	eor	r27, r27
    adb8:	c8 2a       	or	r12, r24
    adba:	d9 2a       	or	r13, r25
    adbc:	ea 2a       	or	r14, r26
    adbe:	fb 2a       	or	r15, r27
    adc0:	09 a5       	lds	r16, 0x69
    adc2:	1a a5       	lds	r17, 0x6a
    adc4:	2b a5       	lds	r18, 0x6b
    adc6:	3c a5       	lds	r19, 0x6c
    adc8:	c4 16       	cp	r12, r20
    adca:	d5 06       	cpc	r13, r21
    adcc:	e6 06       	cpc	r14, r22
    adce:	f7 06       	cpc	r15, r23
    add0:	38 f5       	brcc	.+78     	; 0xae20 <__divdi3+0x900>
    add2:	01 50       	subi	r16, 0x01	; 1
    add4:	10 40       	sbci	r17, 0x00	; 0
    add6:	20 40       	sbci	r18, 0x00	; 0
    add8:	30 40       	sbci	r19, 0x00	; 0
    adda:	09 ab       	sts	0x59, r16
    addc:	1a ab       	sts	0x5a, r17
    adde:	2b ab       	sts	0x5b, r18
    ade0:	3c ab       	sts	0x5c, r19
    ade2:	c8 0c       	add	r12, r8
    ade4:	d9 1c       	adc	r13, r9
    ade6:	ea 1c       	adc	r14, r10
    ade8:	fb 1c       	adc	r15, r11
    adea:	c8 14       	cp	r12, r8
    adec:	d9 04       	cpc	r13, r9
    adee:	ea 04       	cpc	r14, r10
    adf0:	fb 04       	cpc	r15, r11
    adf2:	d0 f0       	brcs	.+52     	; 0xae28 <__divdi3+0x908>
    adf4:	c4 16       	cp	r12, r20
    adf6:	d5 06       	cpc	r13, r21
    adf8:	e6 06       	cpc	r14, r22
    adfa:	f7 06       	cpc	r15, r23
    adfc:	a8 f4       	brcc	.+42     	; 0xae28 <__divdi3+0x908>
    adfe:	09 a5       	lds	r16, 0x69
    ae00:	1a a5       	lds	r17, 0x6a
    ae02:	2b a5       	lds	r18, 0x6b
    ae04:	3c a5       	lds	r19, 0x6c
    ae06:	02 50       	subi	r16, 0x02	; 2
    ae08:	10 40       	sbci	r17, 0x00	; 0
    ae0a:	20 40       	sbci	r18, 0x00	; 0
    ae0c:	30 40       	sbci	r19, 0x00	; 0
    ae0e:	09 ab       	sts	0x59, r16
    ae10:	1a ab       	sts	0x5a, r17
    ae12:	2b ab       	sts	0x5b, r18
    ae14:	3c ab       	sts	0x5c, r19
    ae16:	c8 0c       	add	r12, r8
    ae18:	d9 1c       	adc	r13, r9
    ae1a:	ea 1c       	adc	r14, r10
    ae1c:	fb 1c       	adc	r15, r11
    ae1e:	04 c0       	rjmp	.+8      	; 0xae28 <__divdi3+0x908>
    ae20:	09 ab       	sts	0x59, r16
    ae22:	1a ab       	sts	0x5a, r17
    ae24:	2b ab       	sts	0x5b, r18
    ae26:	3c ab       	sts	0x5c, r19
    ae28:	c4 1a       	sub	r12, r20
    ae2a:	d5 0a       	sbc	r13, r21
    ae2c:	e6 0a       	sbc	r14, r22
    ae2e:	f7 0a       	sbc	r15, r23
    ae30:	c7 01       	movw	r24, r14
    ae32:	b6 01       	movw	r22, r12
    ae34:	2d a5       	lds	r18, 0x6d
    ae36:	3e a5       	lds	r19, 0x6e
    ae38:	4f a5       	lds	r20, 0x6f
    ae3a:	58 a9       	sts	0x48, r21
    ae3c:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    ae40:	29 a7       	lds	r18, 0x79
    ae42:	3a a7       	lds	r19, 0x7a
    ae44:	4b a7       	lds	r20, 0x7b
    ae46:	5c a7       	lds	r21, 0x7c
    ae48:	21 96       	adiw	r28, 0x01	; 1
    ae4a:	6c af       	sts	0x7c, r22
    ae4c:	7d af       	sts	0x7d, r23
    ae4e:	8e af       	sts	0x7e, r24
    ae50:	9f af       	sts	0x7f, r25
    ae52:	21 97       	sbiw	r28, 0x01	; 1
    ae54:	c7 01       	movw	r24, r14
    ae56:	b6 01       	movw	r22, r12
    ae58:	2d a5       	lds	r18, 0x6d
    ae5a:	3e a5       	lds	r19, 0x6e
    ae5c:	4f a5       	lds	r20, 0x6f
    ae5e:	58 a9       	sts	0x48, r21
    ae60:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    ae64:	ca 01       	movw	r24, r20
    ae66:	b9 01       	movw	r22, r18
    ae68:	29 ad       	sts	0x69, r18
    ae6a:	3a ad       	sts	0x6a, r19
    ae6c:	4b ad       	sts	0x6b, r20
    ae6e:	5c ad       	sts	0x6c, r21
    ae70:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    ae74:	8b 01       	movw	r16, r22
    ae76:	9c 01       	movw	r18, r24
    ae78:	21 96       	adiw	r28, 0x01	; 1
    ae7a:	4c ad       	sts	0x6c, r20
    ae7c:	5d ad       	sts	0x6d, r21
    ae7e:	6e ad       	sts	0x6e, r22
    ae80:	7f ad       	sts	0x6f, r23
    ae82:	21 97       	sbiw	r28, 0x01	; 1
    ae84:	da 01       	movw	r26, r20
    ae86:	99 27       	eor	r25, r25
    ae88:	88 27       	eor	r24, r24
    ae8a:	4d a9       	sts	0x4d, r20
    ae8c:	5e a9       	sts	0x4e, r21
    ae8e:	6f a9       	sts	0x4f, r22
    ae90:	78 ad       	sts	0x68, r23
    ae92:	60 70       	andi	r22, 0x00	; 0
    ae94:	70 70       	andi	r23, 0x00	; 0
    ae96:	84 2b       	or	r24, r20
    ae98:	95 2b       	or	r25, r21
    ae9a:	a6 2b       	or	r26, r22
    ae9c:	b7 2b       	or	r27, r23
    ae9e:	49 a5       	lds	r20, 0x69
    aea0:	5a a5       	lds	r21, 0x6a
    aea2:	6b a5       	lds	r22, 0x6b
    aea4:	7c a5       	lds	r23, 0x6c
    aea6:	80 17       	cp	r24, r16
    aea8:	91 07       	cpc	r25, r17
    aeaa:	a2 07       	cpc	r26, r18
    aeac:	b3 07       	cpc	r27, r19
    aeae:	d0 f4       	brcc	.+52     	; 0xaee4 <__divdi3+0x9c4>
    aeb0:	41 50       	subi	r20, 0x01	; 1
    aeb2:	50 40       	sbci	r21, 0x00	; 0
    aeb4:	60 40       	sbci	r22, 0x00	; 0
    aeb6:	70 40       	sbci	r23, 0x00	; 0
    aeb8:	88 0d       	add	r24, r8
    aeba:	99 1d       	adc	r25, r9
    aebc:	aa 1d       	adc	r26, r10
    aebe:	bb 1d       	adc	r27, r11
    aec0:	88 15       	cp	r24, r8
    aec2:	99 05       	cpc	r25, r9
    aec4:	aa 05       	cpc	r26, r10
    aec6:	bb 05       	cpc	r27, r11
    aec8:	68 f0       	brcs	.+26     	; 0xaee4 <__divdi3+0x9c4>
    aeca:	80 17       	cp	r24, r16
    aecc:	91 07       	cpc	r25, r17
    aece:	a2 07       	cpc	r26, r18
    aed0:	b3 07       	cpc	r27, r19
    aed2:	40 f4       	brcc	.+16     	; 0xaee4 <__divdi3+0x9c4>
    aed4:	49 a5       	lds	r20, 0x69
    aed6:	5a a5       	lds	r21, 0x6a
    aed8:	6b a5       	lds	r22, 0x6b
    aeda:	7c a5       	lds	r23, 0x6c
    aedc:	42 50       	subi	r20, 0x02	; 2
    aede:	50 40       	sbci	r21, 0x00	; 0
    aee0:	60 40       	sbci	r22, 0x00	; 0
    aee2:	70 40       	sbci	r23, 0x00	; 0
    aee4:	09 a9       	sts	0x49, r16
    aee6:	1a a9       	sts	0x4a, r17
    aee8:	2b a9       	sts	0x4b, r18
    aeea:	3c a9       	sts	0x4c, r19
    aeec:	78 01       	movw	r14, r16
    aeee:	dd 24       	eor	r13, r13
    aef0:	cc 24       	eor	r12, r12
    aef2:	c4 2a       	or	r12, r20
    aef4:	d5 2a       	or	r13, r21
    aef6:	e6 2a       	or	r14, r22
    aef8:	f7 2a       	or	r15, r23
    aefa:	50 c2       	rjmp	.+1184   	; 0xb39c <__divdi3+0xe7c>
    aefc:	c8 16       	cp	r12, r24
    aefe:	d9 06       	cpc	r13, r25
    af00:	ea 06       	cpc	r14, r26
    af02:	fb 06       	cpc	r15, r27
    af04:	08 f4       	brcc	.+2      	; 0xaf08 <__divdi3+0x9e8>
    af06:	37 c2       	rjmp	.+1134   	; 0xb376 <__divdi3+0xe56>
    af08:	80 30       	cpi	r24, 0x00	; 0
    af0a:	10 e0       	ldi	r17, 0x00	; 0
    af0c:	91 07       	cpc	r25, r17
    af0e:	11 e0       	ldi	r17, 0x01	; 1
    af10:	a1 07       	cpc	r26, r17
    af12:	10 e0       	ldi	r17, 0x00	; 0
    af14:	b1 07       	cpc	r27, r17
    af16:	50 f4       	brcc	.+20     	; 0xaf2c <__divdi3+0xa0c>
    af18:	8f 3f       	cpi	r24, 0xFF	; 255
    af1a:	91 05       	cpc	r25, r1
    af1c:	a1 05       	cpc	r26, r1
    af1e:	b1 05       	cpc	r27, r1
    af20:	09 f0       	breq	.+2      	; 0xaf24 <__divdi3+0xa04>
    af22:	88 f4       	brcc	.+34     	; 0xaf46 <__divdi3+0xa26>
    af24:	00 e0       	ldi	r16, 0x00	; 0
    af26:	10 e0       	ldi	r17, 0x00	; 0
    af28:	98 01       	movw	r18, r16
    af2a:	16 c0       	rjmp	.+44     	; 0xaf58 <__divdi3+0xa38>
    af2c:	80 30       	cpi	r24, 0x00	; 0
    af2e:	20 e0       	ldi	r18, 0x00	; 0
    af30:	92 07       	cpc	r25, r18
    af32:	20 e0       	ldi	r18, 0x00	; 0
    af34:	a2 07       	cpc	r26, r18
    af36:	21 e0       	ldi	r18, 0x01	; 1
    af38:	b2 07       	cpc	r27, r18
    af3a:	50 f4       	brcc	.+20     	; 0xaf50 <__divdi3+0xa30>
    af3c:	00 e1       	ldi	r16, 0x10	; 16
    af3e:	10 e0       	ldi	r17, 0x00	; 0
    af40:	20 e0       	ldi	r18, 0x00	; 0
    af42:	30 e0       	ldi	r19, 0x00	; 0
    af44:	09 c0       	rjmp	.+18     	; 0xaf58 <__divdi3+0xa38>
    af46:	08 e0       	ldi	r16, 0x08	; 8
    af48:	10 e0       	ldi	r17, 0x00	; 0
    af4a:	20 e0       	ldi	r18, 0x00	; 0
    af4c:	30 e0       	ldi	r19, 0x00	; 0
    af4e:	04 c0       	rjmp	.+8      	; 0xaf58 <__divdi3+0xa38>
    af50:	08 e1       	ldi	r16, 0x18	; 24
    af52:	10 e0       	ldi	r17, 0x00	; 0
    af54:	20 e0       	ldi	r18, 0x00	; 0
    af56:	30 e0       	ldi	r19, 0x00	; 0
    af58:	ac 01       	movw	r20, r24
    af5a:	bd 01       	movw	r22, r26
    af5c:	00 2e       	mov	r0, r16
    af5e:	04 c0       	rjmp	.+8      	; 0xaf68 <__divdi3+0xa48>
    af60:	76 95       	lsr	r23
    af62:	67 95       	ror	r22
    af64:	57 95       	ror	r21
    af66:	47 95       	ror	r20
    af68:	0a 94       	dec	r0
    af6a:	d2 f7       	brpl	.-12     	; 0xaf60 <__divdi3+0xa40>
    af6c:	fa 01       	movw	r30, r20
    af6e:	ef 5c       	subi	r30, 0xCF	; 207
    af70:	ff 4d       	sbci	r31, 0xDF	; 223
    af72:	40 81       	ld	r20, Z
    af74:	04 0f       	add	r16, r20
    af76:	11 1d       	adc	r17, r1
    af78:	21 1d       	adc	r18, r1
    af7a:	31 1d       	adc	r19, r1
    af7c:	40 e2       	ldi	r20, 0x20	; 32
    af7e:	50 e0       	ldi	r21, 0x00	; 0
    af80:	60 e0       	ldi	r22, 0x00	; 0
    af82:	70 e0       	ldi	r23, 0x00	; 0
    af84:	40 1b       	sub	r20, r16
    af86:	51 0b       	sbc	r21, r17
    af88:	62 0b       	sbc	r22, r18
    af8a:	73 0b       	sbc	r23, r19
    af8c:	a1 f4       	brne	.+40     	; 0xafb6 <__divdi3+0xa96>
    af8e:	8c 15       	cp	r24, r12
    af90:	9d 05       	cpc	r25, r13
    af92:	ae 05       	cpc	r26, r14
    af94:	bf 05       	cpc	r27, r15
    af96:	08 f4       	brcc	.+2      	; 0xaf9a <__divdi3+0xa7a>
    af98:	f5 c1       	rjmp	.+1002   	; 0xb384 <__divdi3+0xe64>
    af9a:	ed a8       	sts	0x8d, r30
    af9c:	fe a8       	sts	0x8e, r31
    af9e:	0f a9       	sts	0x4f, r16
    afa0:	18 ad       	sts	0x68, r17
    afa2:	44 24       	eor	r4, r4
    afa4:	55 24       	eor	r5, r5
    afa6:	32 01       	movw	r6, r4
    afa8:	e8 14       	cp	r14, r8
    afaa:	f9 04       	cpc	r15, r9
    afac:	0a 05       	cpc	r16, r10
    afae:	1b 05       	cpc	r17, r11
    afb0:	08 f0       	brcs	.+2      	; 0xafb4 <__divdi3+0xa94>
    afb2:	eb c1       	rjmp	.+982    	; 0xb38a <__divdi3+0xe6a>
    afb4:	e3 c1       	rjmp	.+966    	; 0xb37c <__divdi3+0xe5c>
    afb6:	34 2e       	mov	r3, r20
    afb8:	2c 01       	movw	r4, r24
    afba:	3d 01       	movw	r6, r26
    afbc:	04 c0       	rjmp	.+8      	; 0xafc6 <__divdi3+0xaa6>
    afbe:	44 0c       	add	r4, r4
    afc0:	55 1c       	adc	r5, r5
    afc2:	66 1c       	adc	r6, r6
    afc4:	77 1c       	adc	r7, r7
    afc6:	4a 95       	dec	r20
    afc8:	d2 f7       	brpl	.-12     	; 0xafbe <__divdi3+0xa9e>
    afca:	d5 01       	movw	r26, r10
    afcc:	c4 01       	movw	r24, r8
    afce:	00 2e       	mov	r0, r16
    afd0:	04 c0       	rjmp	.+8      	; 0xafda <__divdi3+0xaba>
    afd2:	b6 95       	lsr	r27
    afd4:	a7 95       	ror	r26
    afd6:	97 95       	ror	r25
    afd8:	87 95       	ror	r24
    afda:	0a 94       	dec	r0
    afdc:	d2 f7       	brpl	.-12     	; 0xafd2 <__divdi3+0xab2>
    afde:	48 2a       	or	r4, r24
    afe0:	59 2a       	or	r5, r25
    afe2:	6a 2a       	or	r6, r26
    afe4:	7b 2a       	or	r7, r27
    afe6:	a5 01       	movw	r20, r10
    afe8:	94 01       	movw	r18, r8
    afea:	03 2c       	mov	r0, r3
    afec:	04 c0       	rjmp	.+8      	; 0xaff6 <__divdi3+0xad6>
    afee:	22 0f       	add	r18, r18
    aff0:	33 1f       	adc	r19, r19
    aff2:	44 1f       	adc	r20, r20
    aff4:	55 1f       	adc	r21, r21
    aff6:	0a 94       	dec	r0
    aff8:	d2 f7       	brpl	.-12     	; 0xafee <__divdi3+0xace>
    affa:	29 af       	sts	0x79, r18
    affc:	3a af       	sts	0x7a, r19
    affe:	4b af       	sts	0x7b, r20
    b000:	5c af       	sts	0x7c, r21
    b002:	b7 01       	movw	r22, r14
    b004:	a6 01       	movw	r20, r12
    b006:	00 2e       	mov	r0, r16
    b008:	04 c0       	rjmp	.+8      	; 0xb012 <__divdi3+0xaf2>
    b00a:	76 95       	lsr	r23
    b00c:	67 95       	ror	r22
    b00e:	57 95       	ror	r21
    b010:	47 95       	ror	r20
    b012:	0a 94       	dec	r0
    b014:	d2 f7       	brpl	.-12     	; 0xb00a <__divdi3+0xaea>
    b016:	49 ab       	sts	0x59, r20
    b018:	5a ab       	sts	0x5a, r21
    b01a:	6b ab       	sts	0x5b, r22
    b01c:	7c ab       	sts	0x5c, r23
    b01e:	c7 01       	movw	r24, r14
    b020:	b6 01       	movw	r22, r12
    b022:	03 2c       	mov	r0, r3
    b024:	04 c0       	rjmp	.+8      	; 0xb02e <__divdi3+0xb0e>
    b026:	66 0f       	add	r22, r22
    b028:	77 1f       	adc	r23, r23
    b02a:	88 1f       	adc	r24, r24
    b02c:	99 1f       	adc	r25, r25
    b02e:	0a 94       	dec	r0
    b030:	d2 f7       	brpl	.-12     	; 0xb026 <__divdi3+0xb06>
    b032:	6d a7       	lds	r22, 0x7d
    b034:	7e a7       	lds	r23, 0x7e
    b036:	8f a7       	lds	r24, 0x7f
    b038:	98 ab       	sts	0x58, r25
    b03a:	8d a9       	sts	0x4d, r24
    b03c:	9e a9       	sts	0x4e, r25
    b03e:	af a9       	sts	0x4f, r26
    b040:	b8 ad       	sts	0x68, r27
    b042:	04 c0       	rjmp	.+8      	; 0xb04c <__divdi3+0xb2c>
    b044:	b6 95       	lsr	r27
    b046:	a7 95       	ror	r26
    b048:	97 95       	ror	r25
    b04a:	87 95       	ror	r24
    b04c:	0a 95       	dec	r16
    b04e:	d2 f7       	brpl	.-12     	; 0xb044 <__divdi3+0xb24>
    b050:	4d a5       	lds	r20, 0x6d
    b052:	5e a5       	lds	r21, 0x6e
    b054:	6f a5       	lds	r22, 0x6f
    b056:	78 a9       	sts	0x48, r23
    b058:	48 2b       	or	r20, r24
    b05a:	59 2b       	or	r21, r25
    b05c:	6a 2b       	or	r22, r26
    b05e:	7b 2b       	or	r23, r27
    b060:	4d a7       	lds	r20, 0x7d
    b062:	5e a7       	lds	r21, 0x7e
    b064:	6f a7       	lds	r22, 0x7f
    b066:	78 ab       	sts	0x58, r23
    b068:	43 01       	movw	r8, r6
    b06a:	aa 24       	eor	r10, r10
    b06c:	bb 24       	eor	r11, r11
    b06e:	93 01       	movw	r18, r6
    b070:	82 01       	movw	r16, r4
    b072:	20 70       	andi	r18, 0x00	; 0
    b074:	30 70       	andi	r19, 0x00	; 0
    b076:	21 96       	adiw	r28, 0x01	; 1
    b078:	0c af       	sts	0x7c, r16
    b07a:	1d af       	sts	0x7d, r17
    b07c:	2e af       	sts	0x7e, r18
    b07e:	3f af       	sts	0x7f, r19
    b080:	21 97       	sbiw	r28, 0x01	; 1
    b082:	69 a9       	sts	0x49, r22
    b084:	7a a9       	sts	0x4a, r23
    b086:	8b a9       	sts	0x4b, r24
    b088:	9c a9       	sts	0x4c, r25
    b08a:	a5 01       	movw	r20, r10
    b08c:	94 01       	movw	r18, r8
    b08e:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b092:	29 a7       	lds	r18, 0x79
    b094:	3a a7       	lds	r19, 0x7a
    b096:	4b a7       	lds	r20, 0x7b
    b098:	5c a7       	lds	r21, 0x7c
    b09a:	6b 01       	movw	r12, r22
    b09c:	7c 01       	movw	r14, r24
    b09e:	69 a9       	sts	0x49, r22
    b0a0:	7a a9       	sts	0x4a, r23
    b0a2:	8b a9       	sts	0x4b, r24
    b0a4:	9c a9       	sts	0x4c, r25
    b0a6:	a5 01       	movw	r20, r10
    b0a8:	94 01       	movw	r18, r8
    b0aa:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b0ae:	ca 01       	movw	r24, r20
    b0b0:	b9 01       	movw	r22, r18
    b0b2:	21 96       	adiw	r28, 0x01	; 1
    b0b4:	2c ad       	sts	0x6c, r18
    b0b6:	3d ad       	sts	0x6d, r19
    b0b8:	4e ad       	sts	0x6e, r20
    b0ba:	5f ad       	sts	0x6f, r21
    b0bc:	21 97       	sbiw	r28, 0x01	; 1
    b0be:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b0c2:	dc 01       	movw	r26, r24
    b0c4:	cb 01       	movw	r24, r22
    b0c6:	76 01       	movw	r14, r12
    b0c8:	dd 24       	eor	r13, r13
    b0ca:	cc 24       	eor	r12, r12
    b0cc:	0d a5       	lds	r16, 0x6d
    b0ce:	1e a5       	lds	r17, 0x6e
    b0d0:	2f a5       	lds	r18, 0x6f
    b0d2:	38 a9       	sts	0x48, r19
    b0d4:	a9 01       	movw	r20, r18
    b0d6:	66 27       	eor	r22, r22
    b0d8:	77 27       	eor	r23, r23
    b0da:	c4 2a       	or	r12, r20
    b0dc:	d5 2a       	or	r13, r21
    b0de:	e6 2a       	or	r14, r22
    b0e0:	f7 2a       	or	r15, r23
    b0e2:	09 a5       	lds	r16, 0x69
    b0e4:	1a a5       	lds	r17, 0x6a
    b0e6:	2b a5       	lds	r18, 0x6b
    b0e8:	3c a5       	lds	r19, 0x6c
    b0ea:	c8 16       	cp	r12, r24
    b0ec:	d9 06       	cpc	r13, r25
    b0ee:	ea 06       	cpc	r14, r26
    b0f0:	fb 06       	cpc	r15, r27
    b0f2:	38 f5       	brcc	.+78     	; 0xb142 <__divdi3+0xc22>
    b0f4:	01 50       	subi	r16, 0x01	; 1
    b0f6:	10 40       	sbci	r17, 0x00	; 0
    b0f8:	20 40       	sbci	r18, 0x00	; 0
    b0fa:	30 40       	sbci	r19, 0x00	; 0
    b0fc:	09 ab       	sts	0x59, r16
    b0fe:	1a ab       	sts	0x5a, r17
    b100:	2b ab       	sts	0x5b, r18
    b102:	3c ab       	sts	0x5c, r19
    b104:	c4 0c       	add	r12, r4
    b106:	d5 1c       	adc	r13, r5
    b108:	e6 1c       	adc	r14, r6
    b10a:	f7 1c       	adc	r15, r7
    b10c:	c4 14       	cp	r12, r4
    b10e:	d5 04       	cpc	r13, r5
    b110:	e6 04       	cpc	r14, r6
    b112:	f7 04       	cpc	r15, r7
    b114:	d0 f0       	brcs	.+52     	; 0xb14a <__divdi3+0xc2a>
    b116:	c8 16       	cp	r12, r24
    b118:	d9 06       	cpc	r13, r25
    b11a:	ea 06       	cpc	r14, r26
    b11c:	fb 06       	cpc	r15, r27
    b11e:	a8 f4       	brcc	.+42     	; 0xb14a <__divdi3+0xc2a>
    b120:	09 a5       	lds	r16, 0x69
    b122:	1a a5       	lds	r17, 0x6a
    b124:	2b a5       	lds	r18, 0x6b
    b126:	3c a5       	lds	r19, 0x6c
    b128:	02 50       	subi	r16, 0x02	; 2
    b12a:	10 40       	sbci	r17, 0x00	; 0
    b12c:	20 40       	sbci	r18, 0x00	; 0
    b12e:	30 40       	sbci	r19, 0x00	; 0
    b130:	09 ab       	sts	0x59, r16
    b132:	1a ab       	sts	0x5a, r17
    b134:	2b ab       	sts	0x5b, r18
    b136:	3c ab       	sts	0x5c, r19
    b138:	c4 0c       	add	r12, r4
    b13a:	d5 1c       	adc	r13, r5
    b13c:	e6 1c       	adc	r14, r6
    b13e:	f7 1c       	adc	r15, r7
    b140:	04 c0       	rjmp	.+8      	; 0xb14a <__divdi3+0xc2a>
    b142:	09 ab       	sts	0x59, r16
    b144:	1a ab       	sts	0x5a, r17
    b146:	2b ab       	sts	0x5b, r18
    b148:	3c ab       	sts	0x5c, r19
    b14a:	c8 1a       	sub	r12, r24
    b14c:	d9 0a       	sbc	r13, r25
    b14e:	ea 0a       	sbc	r14, r26
    b150:	fb 0a       	sbc	r15, r27
    b152:	c7 01       	movw	r24, r14
    b154:	b6 01       	movw	r22, r12
    b156:	a5 01       	movw	r20, r10
    b158:	94 01       	movw	r18, r8
    b15a:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b15e:	29 a7       	lds	r18, 0x79
    b160:	3a a7       	lds	r19, 0x7a
    b162:	4b a7       	lds	r20, 0x7b
    b164:	5c a7       	lds	r21, 0x7c
    b166:	29 96       	adiw	r28, 0x09	; 9
    b168:	6c af       	sts	0x7c, r22
    b16a:	7d af       	sts	0x7d, r23
    b16c:	8e af       	sts	0x7e, r24
    b16e:	9f af       	sts	0x7f, r25
    b170:	29 97       	sbiw	r28, 0x09	; 9
    b172:	c7 01       	movw	r24, r14
    b174:	b6 01       	movw	r22, r12
    b176:	a5 01       	movw	r20, r10
    b178:	94 01       	movw	r18, r8
    b17a:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b17e:	ca 01       	movw	r24, r20
    b180:	b9 01       	movw	r22, r18
    b182:	21 96       	adiw	r28, 0x01	; 1
    b184:	2c ad       	sts	0x6c, r18
    b186:	3d ad       	sts	0x6d, r19
    b188:	4e ad       	sts	0x6e, r20
    b18a:	5f ad       	sts	0x6f, r21
    b18c:	21 97       	sbiw	r28, 0x01	; 1
    b18e:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b192:	4b 01       	movw	r8, r22
    b194:	5c 01       	movw	r10, r24
    b196:	29 96       	adiw	r28, 0x09	; 9
    b198:	4c ad       	sts	0x6c, r20
    b19a:	5d ad       	sts	0x6d, r21
    b19c:	6e ad       	sts	0x6e, r22
    b19e:	7f ad       	sts	0x6f, r23
    b1a0:	29 97       	sbiw	r28, 0x09	; 9
    b1a2:	9a 01       	movw	r18, r20
    b1a4:	11 27       	eor	r17, r17
    b1a6:	00 27       	eor	r16, r16
    b1a8:	8d a5       	lds	r24, 0x6d
    b1aa:	9e a5       	lds	r25, 0x6e
    b1ac:	af a5       	lds	r26, 0x6f
    b1ae:	b8 a9       	sts	0x48, r27
    b1b0:	a0 70       	andi	r26, 0x00	; 0
    b1b2:	b0 70       	andi	r27, 0x00	; 0
    b1b4:	08 2b       	or	r16, r24
    b1b6:	19 2b       	or	r17, r25
    b1b8:	2a 2b       	or	r18, r26
    b1ba:	3b 2b       	or	r19, r27
    b1bc:	89 a5       	lds	r24, 0x69
    b1be:	9a a5       	lds	r25, 0x6a
    b1c0:	ab a5       	lds	r26, 0x6b
    b1c2:	bc a5       	lds	r27, 0x6c
    b1c4:	08 15       	cp	r16, r8
    b1c6:	19 05       	cpc	r17, r9
    b1c8:	2a 05       	cpc	r18, r10
    b1ca:	3b 05       	cpc	r19, r11
    b1cc:	e0 f4       	brcc	.+56     	; 0xb206 <__divdi3+0xce6>
    b1ce:	01 97       	sbiw	r24, 0x01	; 1
    b1d0:	a1 09       	sbc	r26, r1
    b1d2:	b1 09       	sbc	r27, r1
    b1d4:	04 0d       	add	r16, r4
    b1d6:	15 1d       	adc	r17, r5
    b1d8:	26 1d       	adc	r18, r6
    b1da:	37 1d       	adc	r19, r7
    b1dc:	04 15       	cp	r16, r4
    b1de:	15 05       	cpc	r17, r5
    b1e0:	26 05       	cpc	r18, r6
    b1e2:	37 05       	cpc	r19, r7
    b1e4:	80 f0       	brcs	.+32     	; 0xb206 <__divdi3+0xce6>
    b1e6:	08 15       	cp	r16, r8
    b1e8:	19 05       	cpc	r17, r9
    b1ea:	2a 05       	cpc	r18, r10
    b1ec:	3b 05       	cpc	r19, r11
    b1ee:	58 f4       	brcc	.+22     	; 0xb206 <__divdi3+0xce6>
    b1f0:	89 a5       	lds	r24, 0x69
    b1f2:	9a a5       	lds	r25, 0x6a
    b1f4:	ab a5       	lds	r26, 0x6b
    b1f6:	bc a5       	lds	r27, 0x6c
    b1f8:	02 97       	sbiw	r24, 0x02	; 2
    b1fa:	a1 09       	sbc	r26, r1
    b1fc:	b1 09       	sbc	r27, r1
    b1fe:	04 0d       	add	r16, r4
    b200:	15 1d       	adc	r17, r5
    b202:	26 1d       	adc	r18, r6
    b204:	37 1d       	adc	r19, r7
    b206:	b9 01       	movw	r22, r18
    b208:	a8 01       	movw	r20, r16
    b20a:	48 19       	sub	r20, r8
    b20c:	59 09       	sbc	r21, r9
    b20e:	6a 09       	sbc	r22, r10
    b210:	7b 09       	sbc	r23, r11
    b212:	4d a7       	lds	r20, 0x7d
    b214:	5e a7       	lds	r21, 0x7e
    b216:	6f a7       	lds	r22, 0x7f
    b218:	78 ab       	sts	0x58, r23
    b21a:	09 a9       	sts	0x49, r16
    b21c:	1a a9       	sts	0x4a, r17
    b21e:	2b a9       	sts	0x4b, r18
    b220:	3c a9       	sts	0x4c, r19
    b222:	78 01       	movw	r14, r16
    b224:	dd 24       	eor	r13, r13
    b226:	cc 24       	eor	r12, r12
    b228:	c8 2a       	or	r12, r24
    b22a:	d9 2a       	or	r13, r25
    b22c:	ea 2a       	or	r14, r26
    b22e:	fb 2a       	or	r15, r27
    b230:	ff ef       	ldi	r31, 0xFF	; 255
    b232:	8f 2e       	mov	r8, r31
    b234:	ff ef       	ldi	r31, 0xFF	; 255
    b236:	9f 2e       	mov	r9, r31
    b238:	a1 2c       	mov	r10, r1
    b23a:	b1 2c       	mov	r11, r1
    b23c:	8c 20       	and	r8, r12
    b23e:	9d 20       	and	r9, r13
    b240:	ae 20       	and	r10, r14
    b242:	bf 20       	and	r11, r15
    b244:	87 01       	movw	r16, r14
    b246:	22 27       	eor	r18, r18
    b248:	33 27       	eor	r19, r19
    b24a:	09 a7       	lds	r16, 0x79
    b24c:	1a a7       	lds	r17, 0x7a
    b24e:	2b a7       	lds	r18, 0x7b
    b250:	3c a7       	lds	r19, 0x7c
    b252:	49 ac       	sts	0xa9, r20
    b254:	5a ac       	sts	0xaa, r21
    b256:	6b ac       	sts	0xab, r22
    b258:	7c ac       	sts	0xac, r23
    b25a:	2f ef       	ldi	r18, 0xFF	; 255
    b25c:	3f ef       	ldi	r19, 0xFF	; 255
    b25e:	40 e0       	ldi	r20, 0x00	; 0
    b260:	50 e0       	ldi	r21, 0x00	; 0
    b262:	42 22       	and	r4, r18
    b264:	53 22       	and	r5, r19
    b266:	64 22       	and	r6, r20
    b268:	75 22       	and	r7, r21
    b26a:	29 ad       	sts	0x69, r18
    b26c:	3a ad       	sts	0x6a, r19
    b26e:	4b ad       	sts	0x6b, r20
    b270:	5c ad       	sts	0x6c, r21
    b272:	8a 01       	movw	r16, r20
    b274:	22 27       	eor	r18, r18
    b276:	33 27       	eor	r19, r19
    b278:	09 ab       	sts	0x59, r16
    b27a:	1a ab       	sts	0x5a, r17
    b27c:	2b ab       	sts	0x5b, r18
    b27e:	3c ab       	sts	0x5c, r19
    b280:	c5 01       	movw	r24, r10
    b282:	b4 01       	movw	r22, r8
    b284:	a3 01       	movw	r20, r6
    b286:	92 01       	movw	r18, r4
    b288:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b28c:	69 af       	sts	0x79, r22
    b28e:	7a af       	sts	0x7a, r23
    b290:	8b af       	sts	0x7b, r24
    b292:	9c af       	sts	0x7c, r25
    b294:	c5 01       	movw	r24, r10
    b296:	b4 01       	movw	r22, r8
    b298:	29 a9       	sts	0x49, r18
    b29a:	3a a9       	sts	0x4a, r19
    b29c:	4b a9       	sts	0x4b, r20
    b29e:	5c a9       	sts	0x4c, r21
    b2a0:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b2a4:	4b 01       	movw	r8, r22
    b2a6:	5c 01       	movw	r10, r24
    b2a8:	69 a5       	lds	r22, 0x69
    b2aa:	7a a5       	lds	r23, 0x6a
    b2ac:	8b a5       	lds	r24, 0x6b
    b2ae:	9c a5       	lds	r25, 0x6c
    b2b0:	a3 01       	movw	r20, r6
    b2b2:	92 01       	movw	r18, r4
    b2b4:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b2b8:	2b 01       	movw	r4, r22
    b2ba:	3c 01       	movw	r6, r24
    b2bc:	69 a5       	lds	r22, 0x69
    b2be:	7a a5       	lds	r23, 0x6a
    b2c0:	8b a5       	lds	r24, 0x6b
    b2c2:	9c a5       	lds	r25, 0x6c
    b2c4:	29 a9       	sts	0x49, r18
    b2c6:	3a a9       	sts	0x4a, r19
    b2c8:	4b a9       	sts	0x4b, r20
    b2ca:	5c a9       	sts	0x4c, r21
    b2cc:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b2d0:	ab 01       	movw	r20, r22
    b2d2:	bc 01       	movw	r22, r24
    b2d4:	84 0c       	add	r8, r4
    b2d6:	95 1c       	adc	r9, r5
    b2d8:	a6 1c       	adc	r10, r6
    b2da:	b7 1c       	adc	r11, r7
    b2dc:	09 ad       	sts	0x69, r16
    b2de:	1a ad       	sts	0x6a, r17
    b2e0:	2b ad       	sts	0x6b, r18
    b2e2:	3c ad       	sts	0x6c, r19
    b2e4:	c9 01       	movw	r24, r18
    b2e6:	aa 27       	eor	r26, r26
    b2e8:	bb 27       	eor	r27, r27
    b2ea:	88 0e       	add	r8, r24
    b2ec:	99 1e       	adc	r9, r25
    b2ee:	aa 1e       	adc	r10, r26
    b2f0:	bb 1e       	adc	r11, r27
    b2f2:	84 14       	cp	r8, r4
    b2f4:	95 04       	cpc	r9, r5
    b2f6:	a6 04       	cpc	r10, r6
    b2f8:	b7 04       	cpc	r11, r7
    b2fa:	20 f4       	brcc	.+8      	; 0xb304 <__divdi3+0xde4>
    b2fc:	40 50       	subi	r20, 0x00	; 0
    b2fe:	50 40       	sbci	r21, 0x00	; 0
    b300:	6f 4f       	sbci	r22, 0xFF	; 255
    b302:	7f 4f       	sbci	r23, 0xFF	; 255
    b304:	c5 01       	movw	r24, r10
    b306:	aa 27       	eor	r26, r26
    b308:	bb 27       	eor	r27, r27
    b30a:	84 0f       	add	r24, r20
    b30c:	95 1f       	adc	r25, r21
    b30e:	a6 1f       	adc	r26, r22
    b310:	b7 1f       	adc	r27, r23
    b312:	0d a5       	lds	r16, 0x6d
    b314:	1e a5       	lds	r17, 0x6e
    b316:	2f a5       	lds	r18, 0x6f
    b318:	38 a9       	sts	0x48, r19
    b31a:	08 17       	cp	r16, r24
    b31c:	19 07       	cpc	r17, r25
    b31e:	2a 07       	cpc	r18, r26
    b320:	3b 07       	cpc	r19, r27
    b322:	18 f1       	brcs	.+70     	; 0xb36a <__divdi3+0xe4a>
    b324:	80 17       	cp	r24, r16
    b326:	91 07       	cpc	r25, r17
    b328:	a2 07       	cpc	r26, r18
    b32a:	b3 07       	cpc	r27, r19
    b32c:	a1 f5       	brne	.+104    	; 0xb396 <__divdi3+0xe76>
    b32e:	54 01       	movw	r10, r8
    b330:	99 24       	eor	r9, r9
    b332:	88 24       	eor	r8, r8
    b334:	89 ad       	sts	0x69, r24
    b336:	9a ad       	sts	0x6a, r25
    b338:	ab ad       	sts	0x6b, r26
    b33a:	bc ad       	sts	0x6c, r27
    b33c:	a0 70       	andi	r26, 0x00	; 0
    b33e:	b0 70       	andi	r27, 0x00	; 0
    b340:	88 0e       	add	r8, r24
    b342:	99 1e       	adc	r9, r25
    b344:	aa 1e       	adc	r10, r26
    b346:	bb 1e       	adc	r11, r27
    b348:	4d a9       	sts	0x4d, r20
    b34a:	5e a9       	sts	0x4e, r21
    b34c:	6f a9       	sts	0x4f, r22
    b34e:	78 ad       	sts	0x68, r23
    b350:	03 2c       	mov	r0, r3
    b352:	04 c0       	rjmp	.+8      	; 0xb35c <__divdi3+0xe3c>
    b354:	44 0f       	add	r20, r20
    b356:	55 1f       	adc	r21, r21
    b358:	66 1f       	adc	r22, r22
    b35a:	77 1f       	adc	r23, r23
    b35c:	0a 94       	dec	r0
    b35e:	d2 f7       	brpl	.-12     	; 0xb354 <__divdi3+0xe34>
    b360:	48 15       	cp	r20, r8
    b362:	59 05       	cpc	r21, r9
    b364:	6a 05       	cpc	r22, r10
    b366:	7b 05       	cpc	r23, r11
    b368:	b0 f4       	brcc	.+44     	; 0xb396 <__divdi3+0xe76>
    b36a:	08 94       	sec
    b36c:	c1 08       	sbc	r12, r1
    b36e:	d1 08       	sbc	r13, r1
    b370:	e1 08       	sbc	r14, r1
    b372:	f1 08       	sbc	r15, r1
    b374:	10 c0       	rjmp	.+32     	; 0xb396 <__divdi3+0xe76>
    b376:	44 24       	eor	r4, r4
    b378:	55 24       	eor	r5, r5
    b37a:	32 01       	movw	r6, r4
    b37c:	cc 24       	eor	r12, r12
    b37e:	dd 24       	eor	r13, r13
    b380:	76 01       	movw	r14, r12
    b382:	0c c0       	rjmp	.+24     	; 0xb39c <__divdi3+0xe7c>
    b384:	44 24       	eor	r4, r4
    b386:	55 24       	eor	r5, r5
    b388:	32 01       	movw	r6, r4
    b38a:	81 e0       	ldi	r24, 0x01	; 1
    b38c:	c8 2e       	mov	r12, r24
    b38e:	d1 2c       	mov	r13, r1
    b390:	e1 2c       	mov	r14, r1
    b392:	f1 2c       	mov	r15, r1
    b394:	03 c0       	rjmp	.+6      	; 0xb39c <__divdi3+0xe7c>
    b396:	44 24       	eor	r4, r4
    b398:	55 24       	eor	r5, r5
    b39a:	32 01       	movw	r6, r4
    b39c:	fe 01       	movw	r30, r28
    b39e:	31 96       	adiw	r30, 0x01	; 1
    b3a0:	88 e0       	ldi	r24, 0x08	; 8
    b3a2:	df 01       	movw	r26, r30
    b3a4:	1d 92       	st	X+, r1
    b3a6:	8a 95       	dec	r24
    b3a8:	e9 f7       	brne	.-6      	; 0xb3a4 <__divdi3+0xe84>
    b3aa:	c9 82       	std	Y+1, r12	; 0x01
    b3ac:	da 82       	std	Y+2, r13	; 0x02
    b3ae:	eb 82       	std	Y+3, r14	; 0x03
    b3b0:	fc 82       	std	Y+4, r15	; 0x04
    b3b2:	4d 82       	std	Y+5, r4	; 0x05
    b3b4:	5e 82       	std	Y+6, r5	; 0x06
    b3b6:	6f 82       	std	Y+7, r6	; 0x07
    b3b8:	78 86       	std	Y+8, r7	; 0x08
    b3ba:	2c 2d       	mov	r18, r12
    b3bc:	3a 81       	ldd	r19, Y+2	; 0x02
    b3be:	4b 81       	ldd	r20, Y+3	; 0x03
    b3c0:	5c 81       	ldd	r21, Y+4	; 0x04
    b3c2:	64 2d       	mov	r22, r4
    b3c4:	7e 81       	ldd	r23, Y+6	; 0x06
    b3c6:	8f 81       	ldd	r24, Y+7	; 0x07
    b3c8:	98 85       	ldd	r25, Y+8	; 0x08
    b3ca:	25 96       	adiw	r28, 0x05	; 5
    b3cc:	ec ac       	sts	0xac, r30
    b3ce:	fd ac       	sts	0xad, r31
    b3d0:	0e ad       	sts	0x6e, r16
    b3d2:	1f ad       	sts	0x6f, r17
    b3d4:	25 97       	sbiw	r28, 0x05	; 5
    b3d6:	e1 14       	cp	r14, r1
    b3d8:	f1 04       	cpc	r15, r1
    b3da:	01 05       	cpc	r16, r1
    b3dc:	11 05       	cpc	r17, r1
    b3de:	09 f4       	brne	.+2      	; 0xb3e2 <__divdi3+0xec2>
    b3e0:	56 c0       	rjmp	.+172    	; 0xb48e <__divdi3+0xf6e>
    b3e2:	21 95       	neg	r18
    b3e4:	e1 e0       	ldi	r30, 0x01	; 1
    b3e6:	12 16       	cp	r1, r18
    b3e8:	08 f0       	brcs	.+2      	; 0xb3ec <__divdi3+0xecc>
    b3ea:	e0 e0       	ldi	r30, 0x00	; 0
    b3ec:	31 95       	neg	r19
    b3ee:	f1 e0       	ldi	r31, 0x01	; 1
    b3f0:	13 16       	cp	r1, r19
    b3f2:	08 f0       	brcs	.+2      	; 0xb3f6 <__divdi3+0xed6>
    b3f4:	f0 e0       	ldi	r31, 0x00	; 0
    b3f6:	03 2f       	mov	r16, r19
    b3f8:	0e 1b       	sub	r16, r30
    b3fa:	e1 e0       	ldi	r30, 0x01	; 1
    b3fc:	30 17       	cp	r19, r16
    b3fe:	08 f0       	brcs	.+2      	; 0xb402 <__divdi3+0xee2>
    b400:	e0 e0       	ldi	r30, 0x00	; 0
    b402:	fe 2b       	or	r31, r30
    b404:	41 95       	neg	r20
    b406:	e1 e0       	ldi	r30, 0x01	; 1
    b408:	14 16       	cp	r1, r20
    b40a:	08 f0       	brcs	.+2      	; 0xb40e <__divdi3+0xeee>
    b40c:	e0 e0       	ldi	r30, 0x00	; 0
    b40e:	14 2f       	mov	r17, r20
    b410:	1f 1b       	sub	r17, r31
    b412:	31 e0       	ldi	r19, 0x01	; 1
    b414:	41 17       	cp	r20, r17
    b416:	08 f0       	brcs	.+2      	; 0xb41a <__divdi3+0xefa>
    b418:	30 e0       	ldi	r19, 0x00	; 0
    b41a:	e3 2b       	or	r30, r19
    b41c:	51 95       	neg	r21
    b41e:	f1 e0       	ldi	r31, 0x01	; 1
    b420:	15 16       	cp	r1, r21
    b422:	08 f0       	brcs	.+2      	; 0xb426 <__divdi3+0xf06>
    b424:	f0 e0       	ldi	r31, 0x00	; 0
    b426:	b5 2f       	mov	r27, r21
    b428:	be 1b       	sub	r27, r30
    b42a:	31 e0       	ldi	r19, 0x01	; 1
    b42c:	5b 17       	cp	r21, r27
    b42e:	08 f0       	brcs	.+2      	; 0xb432 <__divdi3+0xf12>
    b430:	30 e0       	ldi	r19, 0x00	; 0
    b432:	f3 2b       	or	r31, r19
    b434:	61 95       	neg	r22
    b436:	e1 e0       	ldi	r30, 0x01	; 1
    b438:	16 16       	cp	r1, r22
    b43a:	08 f0       	brcs	.+2      	; 0xb43e <__divdi3+0xf1e>
    b43c:	e0 e0       	ldi	r30, 0x00	; 0
    b43e:	46 2e       	mov	r4, r22
    b440:	4f 1a       	sub	r4, r31
    b442:	31 e0       	ldi	r19, 0x01	; 1
    b444:	64 15       	cp	r22, r4
    b446:	08 f0       	brcs	.+2      	; 0xb44a <__divdi3+0xf2a>
    b448:	30 e0       	ldi	r19, 0x00	; 0
    b44a:	e3 2b       	or	r30, r19
    b44c:	71 95       	neg	r23
    b44e:	f1 e0       	ldi	r31, 0x01	; 1
    b450:	17 16       	cp	r1, r23
    b452:	08 f0       	brcs	.+2      	; 0xb456 <__divdi3+0xf36>
    b454:	f0 e0       	ldi	r31, 0x00	; 0
    b456:	a7 2f       	mov	r26, r23
    b458:	ae 1b       	sub	r26, r30
    b45a:	31 e0       	ldi	r19, 0x01	; 1
    b45c:	7a 17       	cp	r23, r26
    b45e:	08 f0       	brcs	.+2      	; 0xb462 <__divdi3+0xf42>
    b460:	30 e0       	ldi	r19, 0x00	; 0
    b462:	f3 2b       	or	r31, r19
    b464:	81 95       	neg	r24
    b466:	e1 e0       	ldi	r30, 0x01	; 1
    b468:	18 16       	cp	r1, r24
    b46a:	08 f0       	brcs	.+2      	; 0xb46e <__divdi3+0xf4e>
    b46c:	e0 e0       	ldi	r30, 0x00	; 0
    b46e:	f8 2e       	mov	r15, r24
    b470:	ff 1a       	sub	r15, r31
    b472:	ff 2d       	mov	r31, r15
    b474:	31 e0       	ldi	r19, 0x01	; 1
    b476:	8f 15       	cp	r24, r15
    b478:	08 f0       	brcs	.+2      	; 0xb47c <__divdi3+0xf5c>
    b47a:	30 e0       	ldi	r19, 0x00	; 0
    b47c:	e3 2b       	or	r30, r19
    b47e:	91 95       	neg	r25
    b480:	30 2f       	mov	r19, r16
    b482:	41 2f       	mov	r20, r17
    b484:	5b 2f       	mov	r21, r27
    b486:	64 2d       	mov	r22, r4
    b488:	7a 2f       	mov	r23, r26
    b48a:	8f 2f       	mov	r24, r31
    b48c:	9e 1b       	sub	r25, r30
    b48e:	c8 5b       	subi	r28, 0xB8	; 184
    b490:	df 4f       	sbci	r29, 0xFF	; 255
    b492:	e1 e1       	ldi	r30, 0x11	; 17
    b494:	0c 94 a2 62 	jmp	0xc544	; 0xc544 <__epilogue_restores__+0x2>

0000b498 <__udivdi3>:
    b498:	a4 e3       	ldi	r26, 0x34	; 52
    b49a:	b0 e0       	ldi	r27, 0x00	; 0
    b49c:	e2 e5       	ldi	r30, 0x52	; 82
    b49e:	fa e5       	ldi	r31, 0x5A	; 90
    b4a0:	0c 94 89 62 	jmp	0xc512	; 0xc512 <__prologue_saves__+0x2>
    b4a4:	29 8b       	std	Y+17, r18	; 0x11
    b4a6:	3a 8b       	std	Y+18, r19	; 0x12
    b4a8:	4b 8b       	std	Y+19, r20	; 0x13
    b4aa:	5c 8b       	std	Y+20, r21	; 0x14
    b4ac:	6d 8b       	std	Y+21, r22	; 0x15
    b4ae:	7e 8b       	std	Y+22, r23	; 0x16
    b4b0:	8f 8b       	std	Y+23, r24	; 0x17
    b4b2:	98 8f       	std	Y+24, r25	; 0x18
    b4b4:	a9 86       	std	Y+9, r10	; 0x09
    b4b6:	ba 86       	std	Y+10, r11	; 0x0a
    b4b8:	cb 86       	std	Y+11, r12	; 0x0b
    b4ba:	dc 86       	std	Y+12, r13	; 0x0c
    b4bc:	ed 86       	std	Y+13, r14	; 0x0d
    b4be:	fe 86       	std	Y+14, r15	; 0x0e
    b4c0:	0f 87       	std	Y+15, r16	; 0x0f
    b4c2:	18 8b       	std	Y+16, r17	; 0x10
    b4c4:	89 84       	ldd	r8, Y+9	; 0x09
    b4c6:	9a 84       	ldd	r9, Y+10	; 0x0a
    b4c8:	ab 84       	ldd	r10, Y+11	; 0x0b
    b4ca:	bc 84       	ldd	r11, Y+12	; 0x0c
    b4cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    b4ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    b4d0:	af 85       	ldd	r26, Y+15	; 0x0f
    b4d2:	b8 89       	ldd	r27, Y+16	; 0x10
    b4d4:	09 89       	ldd	r16, Y+17	; 0x11
    b4d6:	1a 89       	ldd	r17, Y+18	; 0x12
    b4d8:	2b 89       	ldd	r18, Y+19	; 0x13
    b4da:	3c 89       	ldd	r19, Y+20	; 0x14
    b4dc:	0d a3       	lds	r16, 0x5d
    b4de:	1e a3       	lds	r17, 0x5e
    b4e0:	2f a3       	lds	r18, 0x5f
    b4e2:	38 a7       	lds	r19, 0x78
    b4e4:	cd 88       	ldd	r12, Y+21	; 0x15
    b4e6:	de 88       	ldd	r13, Y+22	; 0x16
    b4e8:	ef 88       	ldd	r14, Y+23	; 0x17
    b4ea:	f8 8c       	ldd	r15, Y+24	; 0x18
    b4ec:	00 97       	sbiw	r24, 0x00	; 0
    b4ee:	a1 05       	cpc	r26, r1
    b4f0:	b1 05       	cpc	r27, r1
    b4f2:	09 f0       	breq	.+2      	; 0xb4f6 <__udivdi3+0x5e>
    b4f4:	b5 c3       	rjmp	.+1898   	; 0xbc60 <__udivdi3+0x7c8>
    b4f6:	c8 14       	cp	r12, r8
    b4f8:	d9 04       	cpc	r13, r9
    b4fa:	ea 04       	cpc	r14, r10
    b4fc:	fb 04       	cpc	r15, r11
    b4fe:	08 f0       	brcs	.+2      	; 0xb502 <__udivdi3+0x6a>
    b500:	4d c1       	rjmp	.+666    	; 0xb79c <__udivdi3+0x304>
    b502:	10 e0       	ldi	r17, 0x00	; 0
    b504:	81 16       	cp	r8, r17
    b506:	10 e0       	ldi	r17, 0x00	; 0
    b508:	91 06       	cpc	r9, r17
    b50a:	11 e0       	ldi	r17, 0x01	; 1
    b50c:	a1 06       	cpc	r10, r17
    b50e:	10 e0       	ldi	r17, 0x00	; 0
    b510:	b1 06       	cpc	r11, r17
    b512:	58 f4       	brcc	.+22     	; 0xb52a <__udivdi3+0x92>
    b514:	2f ef       	ldi	r18, 0xFF	; 255
    b516:	82 16       	cp	r8, r18
    b518:	91 04       	cpc	r9, r1
    b51a:	a1 04       	cpc	r10, r1
    b51c:	b1 04       	cpc	r11, r1
    b51e:	09 f0       	breq	.+2      	; 0xb522 <__udivdi3+0x8a>
    b520:	90 f4       	brcc	.+36     	; 0xb546 <__udivdi3+0xae>
    b522:	80 e0       	ldi	r24, 0x00	; 0
    b524:	90 e0       	ldi	r25, 0x00	; 0
    b526:	dc 01       	movw	r26, r24
    b528:	17 c0       	rjmp	.+46     	; 0xb558 <__udivdi3+0xc0>
    b52a:	30 e0       	ldi	r19, 0x00	; 0
    b52c:	83 16       	cp	r8, r19
    b52e:	30 e0       	ldi	r19, 0x00	; 0
    b530:	93 06       	cpc	r9, r19
    b532:	30 e0       	ldi	r19, 0x00	; 0
    b534:	a3 06       	cpc	r10, r19
    b536:	31 e0       	ldi	r19, 0x01	; 1
    b538:	b3 06       	cpc	r11, r19
    b53a:	50 f4       	brcc	.+20     	; 0xb550 <__udivdi3+0xb8>
    b53c:	80 e1       	ldi	r24, 0x10	; 16
    b53e:	90 e0       	ldi	r25, 0x00	; 0
    b540:	a0 e0       	ldi	r26, 0x00	; 0
    b542:	b0 e0       	ldi	r27, 0x00	; 0
    b544:	09 c0       	rjmp	.+18     	; 0xb558 <__udivdi3+0xc0>
    b546:	88 e0       	ldi	r24, 0x08	; 8
    b548:	90 e0       	ldi	r25, 0x00	; 0
    b54a:	a0 e0       	ldi	r26, 0x00	; 0
    b54c:	b0 e0       	ldi	r27, 0x00	; 0
    b54e:	04 c0       	rjmp	.+8      	; 0xb558 <__udivdi3+0xc0>
    b550:	88 e1       	ldi	r24, 0x18	; 24
    b552:	90 e0       	ldi	r25, 0x00	; 0
    b554:	a0 e0       	ldi	r26, 0x00	; 0
    b556:	b0 e0       	ldi	r27, 0x00	; 0
    b558:	b5 01       	movw	r22, r10
    b55a:	a4 01       	movw	r20, r8
    b55c:	08 2e       	mov	r0, r24
    b55e:	04 c0       	rjmp	.+8      	; 0xb568 <__udivdi3+0xd0>
    b560:	76 95       	lsr	r23
    b562:	67 95       	ror	r22
    b564:	57 95       	ror	r21
    b566:	47 95       	ror	r20
    b568:	0a 94       	dec	r0
    b56a:	d2 f7       	brpl	.-12     	; 0xb560 <__udivdi3+0xc8>
    b56c:	fa 01       	movw	r30, r20
    b56e:	ef 5c       	subi	r30, 0xCF	; 207
    b570:	ff 4d       	sbci	r31, 0xDF	; 223
    b572:	20 81       	ld	r18, Z
    b574:	40 e2       	ldi	r20, 0x20	; 32
    b576:	50 e0       	ldi	r21, 0x00	; 0
    b578:	60 e0       	ldi	r22, 0x00	; 0
    b57a:	70 e0       	ldi	r23, 0x00	; 0
    b57c:	48 1b       	sub	r20, r24
    b57e:	59 0b       	sbc	r21, r25
    b580:	6a 0b       	sbc	r22, r26
    b582:	7b 0b       	sbc	r23, r27
    b584:	42 1b       	sub	r20, r18
    b586:	51 09       	sbc	r21, r1
    b588:	61 09       	sbc	r22, r1
    b58a:	71 09       	sbc	r23, r1
    b58c:	41 15       	cp	r20, r1
    b58e:	51 05       	cpc	r21, r1
    b590:	61 05       	cpc	r22, r1
    b592:	71 05       	cpc	r23, r1
    b594:	a1 f1       	breq	.+104    	; 0xb5fe <__udivdi3+0x166>
    b596:	04 2e       	mov	r0, r20
    b598:	04 c0       	rjmp	.+8      	; 0xb5a2 <__udivdi3+0x10a>
    b59a:	88 0c       	add	r8, r8
    b59c:	99 1c       	adc	r9, r9
    b59e:	aa 1c       	adc	r10, r10
    b5a0:	bb 1c       	adc	r11, r11
    b5a2:	0a 94       	dec	r0
    b5a4:	d2 f7       	brpl	.-12     	; 0xb59a <__udivdi3+0x102>
    b5a6:	97 01       	movw	r18, r14
    b5a8:	86 01       	movw	r16, r12
    b5aa:	04 2e       	mov	r0, r20
    b5ac:	04 c0       	rjmp	.+8      	; 0xb5b6 <__udivdi3+0x11e>
    b5ae:	00 0f       	add	r16, r16
    b5b0:	11 1f       	adc	r17, r17
    b5b2:	22 1f       	adc	r18, r18
    b5b4:	33 1f       	adc	r19, r19
    b5b6:	0a 94       	dec	r0
    b5b8:	d2 f7       	brpl	.-12     	; 0xb5ae <__udivdi3+0x116>
    b5ba:	80 e2       	ldi	r24, 0x20	; 32
    b5bc:	90 e0       	ldi	r25, 0x00	; 0
    b5be:	84 1b       	sub	r24, r20
    b5c0:	95 0b       	sbc	r25, r21
    b5c2:	cd a0       	lds	r28, 0x8d
    b5c4:	de a0       	lds	r29, 0x8e
    b5c6:	ef a0       	lds	r30, 0x8f
    b5c8:	f8 a4       	lds	r31, 0xa8
    b5ca:	04 c0       	rjmp	.+8      	; 0xb5d4 <__udivdi3+0x13c>
    b5cc:	f6 94       	lsr	r15
    b5ce:	e7 94       	ror	r14
    b5d0:	d7 94       	ror	r13
    b5d2:	c7 94       	ror	r12
    b5d4:	8a 95       	dec	r24
    b5d6:	d2 f7       	brpl	.-12     	; 0xb5cc <__udivdi3+0x134>
    b5d8:	c0 2a       	or	r12, r16
    b5da:	d1 2a       	or	r13, r17
    b5dc:	e2 2a       	or	r14, r18
    b5de:	f3 2a       	or	r15, r19
    b5e0:	0d a1       	lds	r16, 0x4d
    b5e2:	1e a1       	lds	r17, 0x4e
    b5e4:	2f a1       	lds	r18, 0x4f
    b5e6:	38 a5       	lds	r19, 0x68
    b5e8:	04 c0       	rjmp	.+8      	; 0xb5f2 <__udivdi3+0x15a>
    b5ea:	00 0f       	add	r16, r16
    b5ec:	11 1f       	adc	r17, r17
    b5ee:	22 1f       	adc	r18, r18
    b5f0:	33 1f       	adc	r19, r19
    b5f2:	4a 95       	dec	r20
    b5f4:	d2 f7       	brpl	.-12     	; 0xb5ea <__udivdi3+0x152>
    b5f6:	0d a3       	lds	r16, 0x5d
    b5f8:	1e a3       	lds	r17, 0x5e
    b5fa:	2f a3       	lds	r18, 0x5f
    b5fc:	38 a7       	lds	r19, 0x78
    b5fe:	25 01       	movw	r4, r10
    b600:	66 24       	eor	r6, r6
    b602:	77 24       	eor	r7, r7
    b604:	95 01       	movw	r18, r10
    b606:	84 01       	movw	r16, r8
    b608:	20 70       	andi	r18, 0x00	; 0
    b60a:	30 70       	andi	r19, 0x00	; 0
    b60c:	09 a3       	lds	r16, 0x59
    b60e:	1a a3       	lds	r17, 0x5a
    b610:	2b a3       	lds	r18, 0x5b
    b612:	3c a3       	lds	r19, 0x5c
    b614:	c7 01       	movw	r24, r14
    b616:	b6 01       	movw	r22, r12
    b618:	a3 01       	movw	r20, r6
    b61a:	92 01       	movw	r18, r4
    b61c:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b620:	2d 8f       	std	Y+29, r18	; 0x1d
    b622:	3e 8f       	std	Y+30, r19	; 0x1e
    b624:	4f 8f       	std	Y+31, r20	; 0x1f
    b626:	58 a3       	lds	r21, 0x58
    b628:	69 8f       	std	Y+25, r22	; 0x19
    b62a:	7a 8f       	std	Y+26, r23	; 0x1a
    b62c:	8b 8f       	std	Y+27, r24	; 0x1b
    b62e:	9c 8f       	std	Y+28, r25	; 0x1c
    b630:	c7 01       	movw	r24, r14
    b632:	b6 01       	movw	r22, r12
    b634:	a3 01       	movw	r20, r6
    b636:	92 01       	movw	r18, r4
    b638:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b63c:	ca 01       	movw	r24, r20
    b63e:	b9 01       	movw	r22, r18
    b640:	29 a1       	lds	r18, 0x49
    b642:	3a a1       	lds	r19, 0x4a
    b644:	4b a1       	lds	r20, 0x4b
    b646:	5c a1       	lds	r21, 0x4c
    b648:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b64c:	ab 01       	movw	r20, r22
    b64e:	bc 01       	movw	r22, r24
    b650:	09 8d       	ldd	r16, Y+25	; 0x19
    b652:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b654:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b656:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b658:	78 01       	movw	r14, r16
    b65a:	dd 24       	eor	r13, r13
    b65c:	cc 24       	eor	r12, r12
    b65e:	0d a1       	lds	r16, 0x4d
    b660:	1e a1       	lds	r17, 0x4e
    b662:	2f a1       	lds	r18, 0x4f
    b664:	38 a5       	lds	r19, 0x68
    b666:	c9 01       	movw	r24, r18
    b668:	aa 27       	eor	r26, r26
    b66a:	bb 27       	eor	r27, r27
    b66c:	c8 2a       	or	r12, r24
    b66e:	d9 2a       	or	r13, r25
    b670:	ea 2a       	or	r14, r26
    b672:	fb 2a       	or	r15, r27
    b674:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b676:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b678:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b67a:	38 a1       	lds	r19, 0x48
    b67c:	c4 16       	cp	r12, r20
    b67e:	d5 06       	cpc	r13, r21
    b680:	e6 06       	cpc	r14, r22
    b682:	f7 06       	cpc	r15, r23
    b684:	38 f5       	brcc	.+78     	; 0xb6d4 <__udivdi3+0x23c>
    b686:	01 50       	subi	r16, 0x01	; 1
    b688:	10 40       	sbci	r17, 0x00	; 0
    b68a:	20 40       	sbci	r18, 0x00	; 0
    b68c:	30 40       	sbci	r19, 0x00	; 0
    b68e:	09 8f       	std	Y+25, r16	; 0x19
    b690:	1a 8f       	std	Y+26, r17	; 0x1a
    b692:	2b 8f       	std	Y+27, r18	; 0x1b
    b694:	3c 8f       	std	Y+28, r19	; 0x1c
    b696:	c8 0c       	add	r12, r8
    b698:	d9 1c       	adc	r13, r9
    b69a:	ea 1c       	adc	r14, r10
    b69c:	fb 1c       	adc	r15, r11
    b69e:	c8 14       	cp	r12, r8
    b6a0:	d9 04       	cpc	r13, r9
    b6a2:	ea 04       	cpc	r14, r10
    b6a4:	fb 04       	cpc	r15, r11
    b6a6:	d0 f0       	brcs	.+52     	; 0xb6dc <__udivdi3+0x244>
    b6a8:	c4 16       	cp	r12, r20
    b6aa:	d5 06       	cpc	r13, r21
    b6ac:	e6 06       	cpc	r14, r22
    b6ae:	f7 06       	cpc	r15, r23
    b6b0:	a8 f4       	brcc	.+42     	; 0xb6dc <__udivdi3+0x244>
    b6b2:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b6b4:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b6b6:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b6b8:	38 a1       	lds	r19, 0x48
    b6ba:	02 50       	subi	r16, 0x02	; 2
    b6bc:	10 40       	sbci	r17, 0x00	; 0
    b6be:	20 40       	sbci	r18, 0x00	; 0
    b6c0:	30 40       	sbci	r19, 0x00	; 0
    b6c2:	09 8f       	std	Y+25, r16	; 0x19
    b6c4:	1a 8f       	std	Y+26, r17	; 0x1a
    b6c6:	2b 8f       	std	Y+27, r18	; 0x1b
    b6c8:	3c 8f       	std	Y+28, r19	; 0x1c
    b6ca:	c8 0c       	add	r12, r8
    b6cc:	d9 1c       	adc	r13, r9
    b6ce:	ea 1c       	adc	r14, r10
    b6d0:	fb 1c       	adc	r15, r11
    b6d2:	04 c0       	rjmp	.+8      	; 0xb6dc <__udivdi3+0x244>
    b6d4:	09 8f       	std	Y+25, r16	; 0x19
    b6d6:	1a 8f       	std	Y+26, r17	; 0x1a
    b6d8:	2b 8f       	std	Y+27, r18	; 0x1b
    b6da:	3c 8f       	std	Y+28, r19	; 0x1c
    b6dc:	c4 1a       	sub	r12, r20
    b6de:	d5 0a       	sbc	r13, r21
    b6e0:	e6 0a       	sbc	r14, r22
    b6e2:	f7 0a       	sbc	r15, r23
    b6e4:	c7 01       	movw	r24, r14
    b6e6:	b6 01       	movw	r22, r12
    b6e8:	a3 01       	movw	r20, r6
    b6ea:	92 01       	movw	r18, r4
    b6ec:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b6f0:	2d 8f       	std	Y+29, r18	; 0x1d
    b6f2:	3e 8f       	std	Y+30, r19	; 0x1e
    b6f4:	4f 8f       	std	Y+31, r20	; 0x1f
    b6f6:	58 a3       	lds	r21, 0x58
    b6f8:	69 a7       	lds	r22, 0x79
    b6fa:	7a a7       	lds	r23, 0x7a
    b6fc:	8b a7       	lds	r24, 0x7b
    b6fe:	9c a7       	lds	r25, 0x7c
    b700:	c7 01       	movw	r24, r14
    b702:	b6 01       	movw	r22, r12
    b704:	a3 01       	movw	r20, r6
    b706:	92 01       	movw	r18, r4
    b708:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b70c:	ca 01       	movw	r24, r20
    b70e:	b9 01       	movw	r22, r18
    b710:	29 a1       	lds	r18, 0x49
    b712:	3a a1       	lds	r19, 0x4a
    b714:	4b a1       	lds	r20, 0x4b
    b716:	5c a1       	lds	r21, 0x4c
    b718:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b71c:	6b 01       	movw	r12, r22
    b71e:	7c 01       	movw	r14, r24
    b720:	49 a5       	lds	r20, 0x69
    b722:	5a a5       	lds	r21, 0x6a
    b724:	6b a5       	lds	r22, 0x6b
    b726:	7c a5       	lds	r23, 0x6c
    b728:	9a 01       	movw	r18, r20
    b72a:	11 27       	eor	r17, r17
    b72c:	00 27       	eor	r16, r16
    b72e:	4d a1       	lds	r20, 0x4d
    b730:	5e a1       	lds	r21, 0x4e
    b732:	6f a1       	lds	r22, 0x4f
    b734:	78 a5       	lds	r23, 0x68
    b736:	60 70       	andi	r22, 0x00	; 0
    b738:	70 70       	andi	r23, 0x00	; 0
    b73a:	04 2b       	or	r16, r20
    b73c:	15 2b       	or	r17, r21
    b73e:	26 2b       	or	r18, r22
    b740:	37 2b       	or	r19, r23
    b742:	8d 8d       	ldd	r24, Y+29	; 0x1d
    b744:	9e 8d       	ldd	r25, Y+30	; 0x1e
    b746:	af 8d       	ldd	r26, Y+31	; 0x1f
    b748:	b8 a1       	lds	r27, 0x48
    b74a:	0c 15       	cp	r16, r12
    b74c:	1d 05       	cpc	r17, r13
    b74e:	2e 05       	cpc	r18, r14
    b750:	3f 05       	cpc	r19, r15
    b752:	c0 f4       	brcc	.+48     	; 0xb784 <__udivdi3+0x2ec>
    b754:	01 97       	sbiw	r24, 0x01	; 1
    b756:	a1 09       	sbc	r26, r1
    b758:	b1 09       	sbc	r27, r1
    b75a:	08 0d       	add	r16, r8
    b75c:	19 1d       	adc	r17, r9
    b75e:	2a 1d       	adc	r18, r10
    b760:	3b 1d       	adc	r19, r11
    b762:	08 15       	cp	r16, r8
    b764:	19 05       	cpc	r17, r9
    b766:	2a 05       	cpc	r18, r10
    b768:	3b 05       	cpc	r19, r11
    b76a:	60 f0       	brcs	.+24     	; 0xb784 <__udivdi3+0x2ec>
    b76c:	0c 15       	cp	r16, r12
    b76e:	1d 05       	cpc	r17, r13
    b770:	2e 05       	cpc	r18, r14
    b772:	3f 05       	cpc	r19, r15
    b774:	38 f4       	brcc	.+14     	; 0xb784 <__udivdi3+0x2ec>
    b776:	8d 8d       	ldd	r24, Y+29	; 0x1d
    b778:	9e 8d       	ldd	r25, Y+30	; 0x1e
    b77a:	af 8d       	ldd	r26, Y+31	; 0x1f
    b77c:	b8 a1       	lds	r27, 0x48
    b77e:	02 97       	sbiw	r24, 0x02	; 2
    b780:	a1 09       	sbc	r26, r1
    b782:	b1 09       	sbc	r27, r1
    b784:	09 8d       	ldd	r16, Y+25	; 0x19
    b786:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b788:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b78a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b78c:	78 01       	movw	r14, r16
    b78e:	dd 24       	eor	r13, r13
    b790:	cc 24       	eor	r12, r12
    b792:	c8 2a       	or	r12, r24
    b794:	d9 2a       	or	r13, r25
    b796:	ea 2a       	or	r14, r26
    b798:	fb 2a       	or	r15, r27
    b79a:	a5 c4       	rjmp	.+2378   	; 0xc0e6 <__udivdi3+0xc4e>
    b79c:	81 14       	cp	r8, r1
    b79e:	91 04       	cpc	r9, r1
    b7a0:	a1 04       	cpc	r10, r1
    b7a2:	b1 04       	cpc	r11, r1
    b7a4:	51 f4       	brne	.+20     	; 0xb7ba <__udivdi3+0x322>
    b7a6:	61 e0       	ldi	r22, 0x01	; 1
    b7a8:	70 e0       	ldi	r23, 0x00	; 0
    b7aa:	80 e0       	ldi	r24, 0x00	; 0
    b7ac:	90 e0       	ldi	r25, 0x00	; 0
    b7ae:	a5 01       	movw	r20, r10
    b7b0:	94 01       	movw	r18, r8
    b7b2:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b7b6:	49 01       	movw	r8, r18
    b7b8:	5a 01       	movw	r10, r20
    b7ba:	10 e0       	ldi	r17, 0x00	; 0
    b7bc:	81 16       	cp	r8, r17
    b7be:	10 e0       	ldi	r17, 0x00	; 0
    b7c0:	91 06       	cpc	r9, r17
    b7c2:	11 e0       	ldi	r17, 0x01	; 1
    b7c4:	a1 06       	cpc	r10, r17
    b7c6:	10 e0       	ldi	r17, 0x00	; 0
    b7c8:	b1 06       	cpc	r11, r17
    b7ca:	58 f4       	brcc	.+22     	; 0xb7e2 <__udivdi3+0x34a>
    b7cc:	2f ef       	ldi	r18, 0xFF	; 255
    b7ce:	82 16       	cp	r8, r18
    b7d0:	91 04       	cpc	r9, r1
    b7d2:	a1 04       	cpc	r10, r1
    b7d4:	b1 04       	cpc	r11, r1
    b7d6:	09 f0       	breq	.+2      	; 0xb7da <__udivdi3+0x342>
    b7d8:	90 f4       	brcc	.+36     	; 0xb7fe <__udivdi3+0x366>
    b7da:	80 e0       	ldi	r24, 0x00	; 0
    b7dc:	90 e0       	ldi	r25, 0x00	; 0
    b7de:	dc 01       	movw	r26, r24
    b7e0:	17 c0       	rjmp	.+46     	; 0xb810 <__udivdi3+0x378>
    b7e2:	30 e0       	ldi	r19, 0x00	; 0
    b7e4:	83 16       	cp	r8, r19
    b7e6:	30 e0       	ldi	r19, 0x00	; 0
    b7e8:	93 06       	cpc	r9, r19
    b7ea:	30 e0       	ldi	r19, 0x00	; 0
    b7ec:	a3 06       	cpc	r10, r19
    b7ee:	31 e0       	ldi	r19, 0x01	; 1
    b7f0:	b3 06       	cpc	r11, r19
    b7f2:	50 f4       	brcc	.+20     	; 0xb808 <__udivdi3+0x370>
    b7f4:	80 e1       	ldi	r24, 0x10	; 16
    b7f6:	90 e0       	ldi	r25, 0x00	; 0
    b7f8:	a0 e0       	ldi	r26, 0x00	; 0
    b7fa:	b0 e0       	ldi	r27, 0x00	; 0
    b7fc:	09 c0       	rjmp	.+18     	; 0xb810 <__udivdi3+0x378>
    b7fe:	88 e0       	ldi	r24, 0x08	; 8
    b800:	90 e0       	ldi	r25, 0x00	; 0
    b802:	a0 e0       	ldi	r26, 0x00	; 0
    b804:	b0 e0       	ldi	r27, 0x00	; 0
    b806:	04 c0       	rjmp	.+8      	; 0xb810 <__udivdi3+0x378>
    b808:	88 e1       	ldi	r24, 0x18	; 24
    b80a:	90 e0       	ldi	r25, 0x00	; 0
    b80c:	a0 e0       	ldi	r26, 0x00	; 0
    b80e:	b0 e0       	ldi	r27, 0x00	; 0
    b810:	b5 01       	movw	r22, r10
    b812:	a4 01       	movw	r20, r8
    b814:	08 2e       	mov	r0, r24
    b816:	04 c0       	rjmp	.+8      	; 0xb820 <__udivdi3+0x388>
    b818:	76 95       	lsr	r23
    b81a:	67 95       	ror	r22
    b81c:	57 95       	ror	r21
    b81e:	47 95       	ror	r20
    b820:	0a 94       	dec	r0
    b822:	d2 f7       	brpl	.-12     	; 0xb818 <__udivdi3+0x380>
    b824:	fa 01       	movw	r30, r20
    b826:	ef 5c       	subi	r30, 0xCF	; 207
    b828:	ff 4d       	sbci	r31, 0xDF	; 223
    b82a:	20 81       	ld	r18, Z
    b82c:	ac 01       	movw	r20, r24
    b82e:	bd 01       	movw	r22, r26
    b830:	42 0f       	add	r20, r18
    b832:	51 1d       	adc	r21, r1
    b834:	61 1d       	adc	r22, r1
    b836:	71 1d       	adc	r23, r1
    b838:	80 e2       	ldi	r24, 0x20	; 32
    b83a:	90 e0       	ldi	r25, 0x00	; 0
    b83c:	a0 e0       	ldi	r26, 0x00	; 0
    b83e:	b0 e0       	ldi	r27, 0x00	; 0
    b840:	84 1b       	sub	r24, r20
    b842:	95 0b       	sbc	r25, r21
    b844:	a6 0b       	sbc	r26, r22
    b846:	b7 0b       	sbc	r27, r23
    b848:	51 f4       	brne	.+20     	; 0xb85e <__udivdi3+0x3c6>
    b84a:	c8 18       	sub	r12, r8
    b84c:	d9 08       	sbc	r13, r9
    b84e:	ea 08       	sbc	r14, r10
    b850:	fb 08       	sbc	r15, r11
    b852:	f1 e0       	ldi	r31, 0x01	; 1
    b854:	4f 2e       	mov	r4, r31
    b856:	51 2c       	mov	r5, r1
    b858:	61 2c       	mov	r6, r1
    b85a:	71 2c       	mov	r7, r1
    b85c:	24 c1       	rjmp	.+584    	; 0xbaa6 <__udivdi3+0x60e>
    b85e:	08 2e       	mov	r0, r24
    b860:	04 c0       	rjmp	.+8      	; 0xb86a <__udivdi3+0x3d2>
    b862:	88 0c       	add	r8, r8
    b864:	99 1c       	adc	r9, r9
    b866:	aa 1c       	adc	r10, r10
    b868:	bb 1c       	adc	r11, r11
    b86a:	0a 94       	dec	r0
    b86c:	d2 f7       	brpl	.-12     	; 0xb862 <__udivdi3+0x3ca>
    b86e:	97 01       	movw	r18, r14
    b870:	86 01       	movw	r16, r12
    b872:	04 2e       	mov	r0, r20
    b874:	04 c0       	rjmp	.+8      	; 0xb87e <__udivdi3+0x3e6>
    b876:	36 95       	lsr	r19
    b878:	27 95       	ror	r18
    b87a:	17 95       	ror	r17
    b87c:	07 95       	ror	r16
    b87e:	0a 94       	dec	r0
    b880:	d2 f7       	brpl	.-12     	; 0xb876 <__udivdi3+0x3de>
    b882:	09 a3       	lds	r16, 0x59
    b884:	1a a3       	lds	r17, 0x5a
    b886:	2b a3       	lds	r18, 0x5b
    b888:	3c a3       	lds	r19, 0x5c
    b88a:	97 01       	movw	r18, r14
    b88c:	86 01       	movw	r16, r12
    b88e:	08 2e       	mov	r0, r24
    b890:	04 c0       	rjmp	.+8      	; 0xb89a <__udivdi3+0x402>
    b892:	00 0f       	add	r16, r16
    b894:	11 1f       	adc	r17, r17
    b896:	22 1f       	adc	r18, r18
    b898:	33 1f       	adc	r19, r19
    b89a:	0a 94       	dec	r0
    b89c:	d2 f7       	brpl	.-12     	; 0xb892 <__udivdi3+0x3fa>
    b89e:	0d 8f       	std	Y+29, r16	; 0x1d
    b8a0:	1e 8f       	std	Y+30, r17	; 0x1e
    b8a2:	2f 8f       	std	Y+31, r18	; 0x1f
    b8a4:	38 a3       	lds	r19, 0x58
    b8a6:	0d a1       	lds	r16, 0x4d
    b8a8:	1e a1       	lds	r17, 0x4e
    b8aa:	2f a1       	lds	r18, 0x4f
    b8ac:	38 a5       	lds	r19, 0x68
    b8ae:	04 c0       	rjmp	.+8      	; 0xb8b8 <__udivdi3+0x420>
    b8b0:	36 95       	lsr	r19
    b8b2:	27 95       	ror	r18
    b8b4:	17 95       	ror	r17
    b8b6:	07 95       	ror	r16
    b8b8:	4a 95       	dec	r20
    b8ba:	d2 f7       	brpl	.-12     	; 0xb8b0 <__udivdi3+0x418>
    b8bc:	b9 01       	movw	r22, r18
    b8be:	a8 01       	movw	r20, r16
    b8c0:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b8c2:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b8c4:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b8c6:	38 a1       	lds	r19, 0x48
    b8c8:	04 2b       	or	r16, r20
    b8ca:	15 2b       	or	r17, r21
    b8cc:	26 2b       	or	r18, r22
    b8ce:	37 2b       	or	r19, r23
    b8d0:	0d 8f       	std	Y+29, r16	; 0x1d
    b8d2:	1e 8f       	std	Y+30, r17	; 0x1e
    b8d4:	2f 8f       	std	Y+31, r18	; 0x1f
    b8d6:	38 a3       	lds	r19, 0x58
    b8d8:	0d a1       	lds	r16, 0x4d
    b8da:	1e a1       	lds	r17, 0x4e
    b8dc:	2f a1       	lds	r18, 0x4f
    b8de:	38 a5       	lds	r19, 0x68
    b8e0:	04 c0       	rjmp	.+8      	; 0xb8ea <__udivdi3+0x452>
    b8e2:	00 0f       	add	r16, r16
    b8e4:	11 1f       	adc	r17, r17
    b8e6:	22 1f       	adc	r18, r18
    b8e8:	33 1f       	adc	r19, r19
    b8ea:	8a 95       	dec	r24
    b8ec:	d2 f7       	brpl	.-12     	; 0xb8e2 <__udivdi3+0x44a>
    b8ee:	0d a3       	lds	r16, 0x5d
    b8f0:	1e a3       	lds	r17, 0x5e
    b8f2:	2f a3       	lds	r18, 0x5f
    b8f4:	38 a7       	lds	r19, 0x78
    b8f6:	25 01       	movw	r4, r10
    b8f8:	66 24       	eor	r6, r6
    b8fa:	77 24       	eor	r7, r7
    b8fc:	95 01       	movw	r18, r10
    b8fe:	84 01       	movw	r16, r8
    b900:	20 70       	andi	r18, 0x00	; 0
    b902:	30 70       	andi	r19, 0x00	; 0
    b904:	09 a7       	lds	r16, 0x79
    b906:	1a a7       	lds	r17, 0x7a
    b908:	2b a7       	lds	r18, 0x7b
    b90a:	3c a7       	lds	r19, 0x7c
    b90c:	69 a1       	lds	r22, 0x49
    b90e:	7a a1       	lds	r23, 0x4a
    b910:	8b a1       	lds	r24, 0x4b
    b912:	9c a1       	lds	r25, 0x4c
    b914:	a3 01       	movw	r20, r6
    b916:	92 01       	movw	r18, r4
    b918:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b91c:	29 8f       	std	Y+25, r18	; 0x19
    b91e:	3a 8f       	std	Y+26, r19	; 0x1a
    b920:	4b 8f       	std	Y+27, r20	; 0x1b
    b922:	5c 8f       	std	Y+28, r21	; 0x1c
    b924:	6b 01       	movw	r12, r22
    b926:	7c 01       	movw	r14, r24
    b928:	69 a1       	lds	r22, 0x49
    b92a:	7a a1       	lds	r23, 0x4a
    b92c:	8b a1       	lds	r24, 0x4b
    b92e:	9c a1       	lds	r25, 0x4c
    b930:	a3 01       	movw	r20, r6
    b932:	92 01       	movw	r18, r4
    b934:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b938:	ca 01       	movw	r24, r20
    b93a:	b9 01       	movw	r22, r18
    b93c:	29 a5       	lds	r18, 0x69
    b93e:	3a a5       	lds	r19, 0x6a
    b940:	4b a5       	lds	r20, 0x6b
    b942:	5c a5       	lds	r21, 0x6c
    b944:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    b948:	ab 01       	movw	r20, r22
    b94a:	bc 01       	movw	r22, r24
    b94c:	76 01       	movw	r14, r12
    b94e:	dd 24       	eor	r13, r13
    b950:	cc 24       	eor	r12, r12
    b952:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b954:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b956:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b958:	38 a1       	lds	r19, 0x48
    b95a:	c9 01       	movw	r24, r18
    b95c:	aa 27       	eor	r26, r26
    b95e:	bb 27       	eor	r27, r27
    b960:	c8 2a       	or	r12, r24
    b962:	d9 2a       	or	r13, r25
    b964:	ea 2a       	or	r14, r26
    b966:	fb 2a       	or	r15, r27
    b968:	09 8d       	ldd	r16, Y+25	; 0x19
    b96a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b96c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b96e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b970:	c4 16       	cp	r12, r20
    b972:	d5 06       	cpc	r13, r21
    b974:	e6 06       	cpc	r14, r22
    b976:	f7 06       	cpc	r15, r23
    b978:	38 f5       	brcc	.+78     	; 0xb9c8 <__udivdi3+0x530>
    b97a:	01 50       	subi	r16, 0x01	; 1
    b97c:	10 40       	sbci	r17, 0x00	; 0
    b97e:	20 40       	sbci	r18, 0x00	; 0
    b980:	30 40       	sbci	r19, 0x00	; 0
    b982:	09 a3       	lds	r16, 0x59
    b984:	1a a3       	lds	r17, 0x5a
    b986:	2b a3       	lds	r18, 0x5b
    b988:	3c a3       	lds	r19, 0x5c
    b98a:	c8 0c       	add	r12, r8
    b98c:	d9 1c       	adc	r13, r9
    b98e:	ea 1c       	adc	r14, r10
    b990:	fb 1c       	adc	r15, r11
    b992:	c8 14       	cp	r12, r8
    b994:	d9 04       	cpc	r13, r9
    b996:	ea 04       	cpc	r14, r10
    b998:	fb 04       	cpc	r15, r11
    b99a:	d0 f0       	brcs	.+52     	; 0xb9d0 <__udivdi3+0x538>
    b99c:	c4 16       	cp	r12, r20
    b99e:	d5 06       	cpc	r13, r21
    b9a0:	e6 06       	cpc	r14, r22
    b9a2:	f7 06       	cpc	r15, r23
    b9a4:	a8 f4       	brcc	.+42     	; 0xb9d0 <__udivdi3+0x538>
    b9a6:	09 8d       	ldd	r16, Y+25	; 0x19
    b9a8:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b9aa:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b9ac:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b9ae:	02 50       	subi	r16, 0x02	; 2
    b9b0:	10 40       	sbci	r17, 0x00	; 0
    b9b2:	20 40       	sbci	r18, 0x00	; 0
    b9b4:	30 40       	sbci	r19, 0x00	; 0
    b9b6:	09 a3       	lds	r16, 0x59
    b9b8:	1a a3       	lds	r17, 0x5a
    b9ba:	2b a3       	lds	r18, 0x5b
    b9bc:	3c a3       	lds	r19, 0x5c
    b9be:	c8 0c       	add	r12, r8
    b9c0:	d9 1c       	adc	r13, r9
    b9c2:	ea 1c       	adc	r14, r10
    b9c4:	fb 1c       	adc	r15, r11
    b9c6:	04 c0       	rjmp	.+8      	; 0xb9d0 <__udivdi3+0x538>
    b9c8:	09 a3       	lds	r16, 0x59
    b9ca:	1a a3       	lds	r17, 0x5a
    b9cc:	2b a3       	lds	r18, 0x5b
    b9ce:	3c a3       	lds	r19, 0x5c
    b9d0:	c4 1a       	sub	r12, r20
    b9d2:	d5 0a       	sbc	r13, r21
    b9d4:	e6 0a       	sbc	r14, r22
    b9d6:	f7 0a       	sbc	r15, r23
    b9d8:	c7 01       	movw	r24, r14
    b9da:	b6 01       	movw	r22, r12
    b9dc:	a3 01       	movw	r20, r6
    b9de:	92 01       	movw	r18, r4
    b9e0:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    b9e4:	29 8f       	std	Y+25, r18	; 0x19
    b9e6:	3a 8f       	std	Y+26, r19	; 0x1a
    b9e8:	4b 8f       	std	Y+27, r20	; 0x1b
    b9ea:	5c 8f       	std	Y+28, r21	; 0x1c
    b9ec:	6d a7       	lds	r22, 0x7d
    b9ee:	7e a7       	lds	r23, 0x7e
    b9f0:	8f a7       	lds	r24, 0x7f
    b9f2:	98 ab       	sts	0x58, r25
    b9f4:	c7 01       	movw	r24, r14
    b9f6:	b6 01       	movw	r22, r12
    b9f8:	a3 01       	movw	r20, r6
    b9fa:	92 01       	movw	r18, r4
    b9fc:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    ba00:	ca 01       	movw	r24, r20
    ba02:	b9 01       	movw	r22, r18
    ba04:	29 a5       	lds	r18, 0x69
    ba06:	3a a5       	lds	r19, 0x6a
    ba08:	4b a5       	lds	r20, 0x6b
    ba0a:	5c a5       	lds	r21, 0x6c
    ba0c:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    ba10:	8b 01       	movw	r16, r22
    ba12:	9c 01       	movw	r18, r24
    ba14:	4d a5       	lds	r20, 0x6d
    ba16:	5e a5       	lds	r21, 0x6e
    ba18:	6f a5       	lds	r22, 0x6f
    ba1a:	78 a9       	sts	0x48, r23
    ba1c:	da 01       	movw	r26, r20
    ba1e:	99 27       	eor	r25, r25
    ba20:	88 27       	eor	r24, r24
    ba22:	4d 8d       	ldd	r20, Y+29	; 0x1d
    ba24:	5e 8d       	ldd	r21, Y+30	; 0x1e
    ba26:	6f 8d       	ldd	r22, Y+31	; 0x1f
    ba28:	78 a1       	lds	r23, 0x48
    ba2a:	60 70       	andi	r22, 0x00	; 0
    ba2c:	70 70       	andi	r23, 0x00	; 0
    ba2e:	84 2b       	or	r24, r20
    ba30:	95 2b       	or	r25, r21
    ba32:	a6 2b       	or	r26, r22
    ba34:	b7 2b       	or	r27, r23
    ba36:	49 8d       	ldd	r20, Y+25	; 0x19
    ba38:	5a 8d       	ldd	r21, Y+26	; 0x1a
    ba3a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    ba3c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    ba3e:	80 17       	cp	r24, r16
    ba40:	91 07       	cpc	r25, r17
    ba42:	a2 07       	cpc	r26, r18
    ba44:	b3 07       	cpc	r27, r19
    ba46:	f0 f4       	brcc	.+60     	; 0xba84 <__udivdi3+0x5ec>
    ba48:	41 50       	subi	r20, 0x01	; 1
    ba4a:	50 40       	sbci	r21, 0x00	; 0
    ba4c:	60 40       	sbci	r22, 0x00	; 0
    ba4e:	70 40       	sbci	r23, 0x00	; 0
    ba50:	88 0d       	add	r24, r8
    ba52:	99 1d       	adc	r25, r9
    ba54:	aa 1d       	adc	r26, r10
    ba56:	bb 1d       	adc	r27, r11
    ba58:	88 15       	cp	r24, r8
    ba5a:	99 05       	cpc	r25, r9
    ba5c:	aa 05       	cpc	r26, r10
    ba5e:	bb 05       	cpc	r27, r11
    ba60:	88 f0       	brcs	.+34     	; 0xba84 <__udivdi3+0x5ec>
    ba62:	80 17       	cp	r24, r16
    ba64:	91 07       	cpc	r25, r17
    ba66:	a2 07       	cpc	r26, r18
    ba68:	b3 07       	cpc	r27, r19
    ba6a:	60 f4       	brcc	.+24     	; 0xba84 <__udivdi3+0x5ec>
    ba6c:	49 8d       	ldd	r20, Y+25	; 0x19
    ba6e:	5a 8d       	ldd	r21, Y+26	; 0x1a
    ba70:	6b 8d       	ldd	r22, Y+27	; 0x1b
    ba72:	7c 8d       	ldd	r23, Y+28	; 0x1c
    ba74:	42 50       	subi	r20, 0x02	; 2
    ba76:	50 40       	sbci	r21, 0x00	; 0
    ba78:	60 40       	sbci	r22, 0x00	; 0
    ba7a:	70 40       	sbci	r23, 0x00	; 0
    ba7c:	88 0d       	add	r24, r8
    ba7e:	99 1d       	adc	r25, r9
    ba80:	aa 1d       	adc	r26, r10
    ba82:	bb 1d       	adc	r27, r11
    ba84:	6c 01       	movw	r12, r24
    ba86:	7d 01       	movw	r14, r26
    ba88:	c0 1a       	sub	r12, r16
    ba8a:	d1 0a       	sbc	r13, r17
    ba8c:	e2 0a       	sbc	r14, r18
    ba8e:	f3 0a       	sbc	r15, r19
    ba90:	09 a1       	lds	r16, 0x49
    ba92:	1a a1       	lds	r17, 0x4a
    ba94:	2b a1       	lds	r18, 0x4b
    ba96:	3c a1       	lds	r19, 0x4c
    ba98:	38 01       	movw	r6, r16
    ba9a:	55 24       	eor	r5, r5
    ba9c:	44 24       	eor	r4, r4
    ba9e:	44 2a       	or	r4, r20
    baa0:	55 2a       	or	r5, r21
    baa2:	66 2a       	or	r6, r22
    baa4:	77 2a       	or	r7, r23
    baa6:	85 01       	movw	r16, r10
    baa8:	22 27       	eor	r18, r18
    baaa:	33 27       	eor	r19, r19
    baac:	0d 8f       	std	Y+29, r16	; 0x1d
    baae:	1e 8f       	std	Y+30, r17	; 0x1e
    bab0:	2f 8f       	std	Y+31, r18	; 0x1f
    bab2:	38 a3       	lds	r19, 0x58
    bab4:	95 01       	movw	r18, r10
    bab6:	84 01       	movw	r16, r8
    bab8:	20 70       	andi	r18, 0x00	; 0
    baba:	30 70       	andi	r19, 0x00	; 0
    babc:	09 a7       	lds	r16, 0x79
    babe:	1a a7       	lds	r17, 0x7a
    bac0:	2b a7       	lds	r18, 0x7b
    bac2:	3c a7       	lds	r19, 0x7c
    bac4:	c7 01       	movw	r24, r14
    bac6:	b6 01       	movw	r22, r12
    bac8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    baca:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bacc:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bace:	58 a1       	lds	r21, 0x48
    bad0:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    bad4:	29 8f       	std	Y+25, r18	; 0x19
    bad6:	3a 8f       	std	Y+26, r19	; 0x1a
    bad8:	4b 8f       	std	Y+27, r20	; 0x1b
    bada:	5c 8f       	std	Y+28, r21	; 0x1c
    badc:	69 a3       	lds	r22, 0x59
    bade:	7a a3       	lds	r23, 0x5a
    bae0:	8b a3       	lds	r24, 0x5b
    bae2:	9c a3       	lds	r25, 0x5c
    bae4:	c7 01       	movw	r24, r14
    bae6:	b6 01       	movw	r22, r12
    bae8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    baea:	3e 8d       	ldd	r19, Y+30	; 0x1e
    baec:	4f 8d       	ldd	r20, Y+31	; 0x1f
    baee:	58 a1       	lds	r21, 0x48
    baf0:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    baf4:	ca 01       	movw	r24, r20
    baf6:	b9 01       	movw	r22, r18
    baf8:	29 a5       	lds	r18, 0x69
    bafa:	3a a5       	lds	r19, 0x6a
    bafc:	4b a5       	lds	r20, 0x6b
    bafe:	5c a5       	lds	r21, 0x6c
    bb00:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    bb04:	ab 01       	movw	r20, r22
    bb06:	bc 01       	movw	r22, r24
    bb08:	09 a1       	lds	r16, 0x49
    bb0a:	1a a1       	lds	r17, 0x4a
    bb0c:	2b a1       	lds	r18, 0x4b
    bb0e:	3c a1       	lds	r19, 0x4c
    bb10:	78 01       	movw	r14, r16
    bb12:	dd 24       	eor	r13, r13
    bb14:	cc 24       	eor	r12, r12
    bb16:	0d a1       	lds	r16, 0x4d
    bb18:	1e a1       	lds	r17, 0x4e
    bb1a:	2f a1       	lds	r18, 0x4f
    bb1c:	38 a5       	lds	r19, 0x68
    bb1e:	c9 01       	movw	r24, r18
    bb20:	aa 27       	eor	r26, r26
    bb22:	bb 27       	eor	r27, r27
    bb24:	c8 2a       	or	r12, r24
    bb26:	d9 2a       	or	r13, r25
    bb28:	ea 2a       	or	r14, r26
    bb2a:	fb 2a       	or	r15, r27
    bb2c:	09 8d       	ldd	r16, Y+25	; 0x19
    bb2e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bb30:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bb32:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bb34:	c4 16       	cp	r12, r20
    bb36:	d5 06       	cpc	r13, r21
    bb38:	e6 06       	cpc	r14, r22
    bb3a:	f7 06       	cpc	r15, r23
    bb3c:	38 f5       	brcc	.+78     	; 0xbb8c <__udivdi3+0x6f4>
    bb3e:	01 50       	subi	r16, 0x01	; 1
    bb40:	10 40       	sbci	r17, 0x00	; 0
    bb42:	20 40       	sbci	r18, 0x00	; 0
    bb44:	30 40       	sbci	r19, 0x00	; 0
    bb46:	09 a3       	lds	r16, 0x59
    bb48:	1a a3       	lds	r17, 0x5a
    bb4a:	2b a3       	lds	r18, 0x5b
    bb4c:	3c a3       	lds	r19, 0x5c
    bb4e:	c8 0c       	add	r12, r8
    bb50:	d9 1c       	adc	r13, r9
    bb52:	ea 1c       	adc	r14, r10
    bb54:	fb 1c       	adc	r15, r11
    bb56:	c8 14       	cp	r12, r8
    bb58:	d9 04       	cpc	r13, r9
    bb5a:	ea 04       	cpc	r14, r10
    bb5c:	fb 04       	cpc	r15, r11
    bb5e:	d0 f0       	brcs	.+52     	; 0xbb94 <__udivdi3+0x6fc>
    bb60:	c4 16       	cp	r12, r20
    bb62:	d5 06       	cpc	r13, r21
    bb64:	e6 06       	cpc	r14, r22
    bb66:	f7 06       	cpc	r15, r23
    bb68:	a8 f4       	brcc	.+42     	; 0xbb94 <__udivdi3+0x6fc>
    bb6a:	09 8d       	ldd	r16, Y+25	; 0x19
    bb6c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bb6e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bb70:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bb72:	02 50       	subi	r16, 0x02	; 2
    bb74:	10 40       	sbci	r17, 0x00	; 0
    bb76:	20 40       	sbci	r18, 0x00	; 0
    bb78:	30 40       	sbci	r19, 0x00	; 0
    bb7a:	09 a3       	lds	r16, 0x59
    bb7c:	1a a3       	lds	r17, 0x5a
    bb7e:	2b a3       	lds	r18, 0x5b
    bb80:	3c a3       	lds	r19, 0x5c
    bb82:	c8 0c       	add	r12, r8
    bb84:	d9 1c       	adc	r13, r9
    bb86:	ea 1c       	adc	r14, r10
    bb88:	fb 1c       	adc	r15, r11
    bb8a:	04 c0       	rjmp	.+8      	; 0xbb94 <__udivdi3+0x6fc>
    bb8c:	09 a3       	lds	r16, 0x59
    bb8e:	1a a3       	lds	r17, 0x5a
    bb90:	2b a3       	lds	r18, 0x5b
    bb92:	3c a3       	lds	r19, 0x5c
    bb94:	c4 1a       	sub	r12, r20
    bb96:	d5 0a       	sbc	r13, r21
    bb98:	e6 0a       	sbc	r14, r22
    bb9a:	f7 0a       	sbc	r15, r23
    bb9c:	c7 01       	movw	r24, r14
    bb9e:	b6 01       	movw	r22, r12
    bba0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bba2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bba4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bba6:	58 a1       	lds	r21, 0x48
    bba8:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    bbac:	29 8f       	std	Y+25, r18	; 0x19
    bbae:	3a 8f       	std	Y+26, r19	; 0x1a
    bbb0:	4b 8f       	std	Y+27, r20	; 0x1b
    bbb2:	5c 8f       	std	Y+28, r21	; 0x1c
    bbb4:	6d a7       	lds	r22, 0x7d
    bbb6:	7e a7       	lds	r23, 0x7e
    bbb8:	8f a7       	lds	r24, 0x7f
    bbba:	98 ab       	sts	0x58, r25
    bbbc:	c7 01       	movw	r24, r14
    bbbe:	b6 01       	movw	r22, r12
    bbc0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bbc2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bbc4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bbc6:	58 a1       	lds	r21, 0x48
    bbc8:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    bbcc:	ca 01       	movw	r24, r20
    bbce:	b9 01       	movw	r22, r18
    bbd0:	29 a5       	lds	r18, 0x69
    bbd2:	3a a5       	lds	r19, 0x6a
    bbd4:	4b a5       	lds	r20, 0x6b
    bbd6:	5c a5       	lds	r21, 0x6c
    bbd8:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    bbdc:	8b 01       	movw	r16, r22
    bbde:	9c 01       	movw	r18, r24
    bbe0:	4d a5       	lds	r20, 0x6d
    bbe2:	5e a5       	lds	r21, 0x6e
    bbe4:	6f a5       	lds	r22, 0x6f
    bbe6:	78 a9       	sts	0x48, r23
    bbe8:	da 01       	movw	r26, r20
    bbea:	99 27       	eor	r25, r25
    bbec:	88 27       	eor	r24, r24
    bbee:	4d a1       	lds	r20, 0x4d
    bbf0:	5e a1       	lds	r21, 0x4e
    bbf2:	6f a1       	lds	r22, 0x4f
    bbf4:	78 a5       	lds	r23, 0x68
    bbf6:	60 70       	andi	r22, 0x00	; 0
    bbf8:	70 70       	andi	r23, 0x00	; 0
    bbfa:	84 2b       	or	r24, r20
    bbfc:	95 2b       	or	r25, r21
    bbfe:	a6 2b       	or	r26, r22
    bc00:	b7 2b       	or	r27, r23
    bc02:	49 8d       	ldd	r20, Y+25	; 0x19
    bc04:	5a 8d       	ldd	r21, Y+26	; 0x1a
    bc06:	6b 8d       	ldd	r22, Y+27	; 0x1b
    bc08:	7c 8d       	ldd	r23, Y+28	; 0x1c
    bc0a:	80 17       	cp	r24, r16
    bc0c:	91 07       	cpc	r25, r17
    bc0e:	a2 07       	cpc	r26, r18
    bc10:	b3 07       	cpc	r27, r19
    bc12:	d0 f4       	brcc	.+52     	; 0xbc48 <__udivdi3+0x7b0>
    bc14:	41 50       	subi	r20, 0x01	; 1
    bc16:	50 40       	sbci	r21, 0x00	; 0
    bc18:	60 40       	sbci	r22, 0x00	; 0
    bc1a:	70 40       	sbci	r23, 0x00	; 0
    bc1c:	88 0d       	add	r24, r8
    bc1e:	99 1d       	adc	r25, r9
    bc20:	aa 1d       	adc	r26, r10
    bc22:	bb 1d       	adc	r27, r11
    bc24:	88 15       	cp	r24, r8
    bc26:	99 05       	cpc	r25, r9
    bc28:	aa 05       	cpc	r26, r10
    bc2a:	bb 05       	cpc	r27, r11
    bc2c:	68 f0       	brcs	.+26     	; 0xbc48 <__udivdi3+0x7b0>
    bc2e:	80 17       	cp	r24, r16
    bc30:	91 07       	cpc	r25, r17
    bc32:	a2 07       	cpc	r26, r18
    bc34:	b3 07       	cpc	r27, r19
    bc36:	40 f4       	brcc	.+16     	; 0xbc48 <__udivdi3+0x7b0>
    bc38:	49 8d       	ldd	r20, Y+25	; 0x19
    bc3a:	5a 8d       	ldd	r21, Y+26	; 0x1a
    bc3c:	6b 8d       	ldd	r22, Y+27	; 0x1b
    bc3e:	7c 8d       	ldd	r23, Y+28	; 0x1c
    bc40:	42 50       	subi	r20, 0x02	; 2
    bc42:	50 40       	sbci	r21, 0x00	; 0
    bc44:	60 40       	sbci	r22, 0x00	; 0
    bc46:	70 40       	sbci	r23, 0x00	; 0
    bc48:	09 a1       	lds	r16, 0x49
    bc4a:	1a a1       	lds	r17, 0x4a
    bc4c:	2b a1       	lds	r18, 0x4b
    bc4e:	3c a1       	lds	r19, 0x4c
    bc50:	78 01       	movw	r14, r16
    bc52:	dd 24       	eor	r13, r13
    bc54:	cc 24       	eor	r12, r12
    bc56:	c4 2a       	or	r12, r20
    bc58:	d5 2a       	or	r13, r21
    bc5a:	e6 2a       	or	r14, r22
    bc5c:	f7 2a       	or	r15, r23
    bc5e:	46 c2       	rjmp	.+1164   	; 0xc0ec <__udivdi3+0xc54>
    bc60:	c8 16       	cp	r12, r24
    bc62:	d9 06       	cpc	r13, r25
    bc64:	ea 06       	cpc	r14, r26
    bc66:	fb 06       	cpc	r15, r27
    bc68:	08 f4       	brcc	.+2      	; 0xbc6c <__udivdi3+0x7d4>
    bc6a:	2d c2       	rjmp	.+1114   	; 0xc0c6 <__udivdi3+0xc2e>
    bc6c:	80 30       	cpi	r24, 0x00	; 0
    bc6e:	10 e0       	ldi	r17, 0x00	; 0
    bc70:	91 07       	cpc	r25, r17
    bc72:	11 e0       	ldi	r17, 0x01	; 1
    bc74:	a1 07       	cpc	r26, r17
    bc76:	10 e0       	ldi	r17, 0x00	; 0
    bc78:	b1 07       	cpc	r27, r17
    bc7a:	50 f4       	brcc	.+20     	; 0xbc90 <__udivdi3+0x7f8>
    bc7c:	8f 3f       	cpi	r24, 0xFF	; 255
    bc7e:	91 05       	cpc	r25, r1
    bc80:	a1 05       	cpc	r26, r1
    bc82:	b1 05       	cpc	r27, r1
    bc84:	09 f0       	breq	.+2      	; 0xbc88 <__udivdi3+0x7f0>
    bc86:	88 f4       	brcc	.+34     	; 0xbcaa <__udivdi3+0x812>
    bc88:	00 e0       	ldi	r16, 0x00	; 0
    bc8a:	10 e0       	ldi	r17, 0x00	; 0
    bc8c:	98 01       	movw	r18, r16
    bc8e:	16 c0       	rjmp	.+44     	; 0xbcbc <__udivdi3+0x824>
    bc90:	80 30       	cpi	r24, 0x00	; 0
    bc92:	20 e0       	ldi	r18, 0x00	; 0
    bc94:	92 07       	cpc	r25, r18
    bc96:	20 e0       	ldi	r18, 0x00	; 0
    bc98:	a2 07       	cpc	r26, r18
    bc9a:	21 e0       	ldi	r18, 0x01	; 1
    bc9c:	b2 07       	cpc	r27, r18
    bc9e:	50 f4       	brcc	.+20     	; 0xbcb4 <__udivdi3+0x81c>
    bca0:	00 e1       	ldi	r16, 0x10	; 16
    bca2:	10 e0       	ldi	r17, 0x00	; 0
    bca4:	20 e0       	ldi	r18, 0x00	; 0
    bca6:	30 e0       	ldi	r19, 0x00	; 0
    bca8:	09 c0       	rjmp	.+18     	; 0xbcbc <__udivdi3+0x824>
    bcaa:	08 e0       	ldi	r16, 0x08	; 8
    bcac:	10 e0       	ldi	r17, 0x00	; 0
    bcae:	20 e0       	ldi	r18, 0x00	; 0
    bcb0:	30 e0       	ldi	r19, 0x00	; 0
    bcb2:	04 c0       	rjmp	.+8      	; 0xbcbc <__udivdi3+0x824>
    bcb4:	08 e1       	ldi	r16, 0x18	; 24
    bcb6:	10 e0       	ldi	r17, 0x00	; 0
    bcb8:	20 e0       	ldi	r18, 0x00	; 0
    bcba:	30 e0       	ldi	r19, 0x00	; 0
    bcbc:	ac 01       	movw	r20, r24
    bcbe:	bd 01       	movw	r22, r26
    bcc0:	00 2e       	mov	r0, r16
    bcc2:	04 c0       	rjmp	.+8      	; 0xbccc <__udivdi3+0x834>
    bcc4:	76 95       	lsr	r23
    bcc6:	67 95       	ror	r22
    bcc8:	57 95       	ror	r21
    bcca:	47 95       	ror	r20
    bccc:	0a 94       	dec	r0
    bcce:	d2 f7       	brpl	.-12     	; 0xbcc4 <__udivdi3+0x82c>
    bcd0:	fa 01       	movw	r30, r20
    bcd2:	ef 5c       	subi	r30, 0xCF	; 207
    bcd4:	ff 4d       	sbci	r31, 0xDF	; 223
    bcd6:	40 81       	ld	r20, Z
    bcd8:	04 0f       	add	r16, r20
    bcda:	11 1d       	adc	r17, r1
    bcdc:	21 1d       	adc	r18, r1
    bcde:	31 1d       	adc	r19, r1
    bce0:	40 e2       	ldi	r20, 0x20	; 32
    bce2:	50 e0       	ldi	r21, 0x00	; 0
    bce4:	60 e0       	ldi	r22, 0x00	; 0
    bce6:	70 e0       	ldi	r23, 0x00	; 0
    bce8:	40 1b       	sub	r20, r16
    bcea:	51 0b       	sbc	r21, r17
    bcec:	62 0b       	sbc	r22, r18
    bcee:	73 0b       	sbc	r23, r19
    bcf0:	a1 f4       	brne	.+40     	; 0xbd1a <__udivdi3+0x882>
    bcf2:	8c 15       	cp	r24, r12
    bcf4:	9d 05       	cpc	r25, r13
    bcf6:	ae 05       	cpc	r26, r14
    bcf8:	bf 05       	cpc	r27, r15
    bcfa:	08 f4       	brcc	.+2      	; 0xbcfe <__udivdi3+0x866>
    bcfc:	eb c1       	rjmp	.+982    	; 0xc0d4 <__udivdi3+0xc3c>
    bcfe:	0d a1       	lds	r16, 0x4d
    bd00:	1e a1       	lds	r17, 0x4e
    bd02:	2f a1       	lds	r18, 0x4f
    bd04:	38 a5       	lds	r19, 0x68
    bd06:	44 24       	eor	r4, r4
    bd08:	55 24       	eor	r5, r5
    bd0a:	32 01       	movw	r6, r4
    bd0c:	08 15       	cp	r16, r8
    bd0e:	19 05       	cpc	r17, r9
    bd10:	2a 05       	cpc	r18, r10
    bd12:	3b 05       	cpc	r19, r11
    bd14:	08 f0       	brcs	.+2      	; 0xbd18 <__udivdi3+0x880>
    bd16:	e1 c1       	rjmp	.+962    	; 0xc0da <__udivdi3+0xc42>
    bd18:	d9 c1       	rjmp	.+946    	; 0xc0cc <__udivdi3+0xc34>
    bd1a:	34 2e       	mov	r3, r20
    bd1c:	2c 01       	movw	r4, r24
    bd1e:	3d 01       	movw	r6, r26
    bd20:	04 c0       	rjmp	.+8      	; 0xbd2a <__udivdi3+0x892>
    bd22:	44 0c       	add	r4, r4
    bd24:	55 1c       	adc	r5, r5
    bd26:	66 1c       	adc	r6, r6
    bd28:	77 1c       	adc	r7, r7
    bd2a:	4a 95       	dec	r20
    bd2c:	d2 f7       	brpl	.-12     	; 0xbd22 <__udivdi3+0x88a>
    bd2e:	d5 01       	movw	r26, r10
    bd30:	c4 01       	movw	r24, r8
    bd32:	00 2e       	mov	r0, r16
    bd34:	04 c0       	rjmp	.+8      	; 0xbd3e <__udivdi3+0x8a6>
    bd36:	b6 95       	lsr	r27
    bd38:	a7 95       	ror	r26
    bd3a:	97 95       	ror	r25
    bd3c:	87 95       	ror	r24
    bd3e:	0a 94       	dec	r0
    bd40:	d2 f7       	brpl	.-12     	; 0xbd36 <__udivdi3+0x89e>
    bd42:	48 2a       	or	r4, r24
    bd44:	59 2a       	or	r5, r25
    bd46:	6a 2a       	or	r6, r26
    bd48:	7b 2a       	or	r7, r27
    bd4a:	a5 01       	movw	r20, r10
    bd4c:	94 01       	movw	r18, r8
    bd4e:	03 2c       	mov	r0, r3
    bd50:	04 c0       	rjmp	.+8      	; 0xbd5a <__udivdi3+0x8c2>
    bd52:	22 0f       	add	r18, r18
    bd54:	33 1f       	adc	r19, r19
    bd56:	44 1f       	adc	r20, r20
    bd58:	55 1f       	adc	r21, r21
    bd5a:	0a 94       	dec	r0
    bd5c:	d2 f7       	brpl	.-12     	; 0xbd52 <__udivdi3+0x8ba>
    bd5e:	29 a7       	lds	r18, 0x79
    bd60:	3a a7       	lds	r19, 0x7a
    bd62:	4b a7       	lds	r20, 0x7b
    bd64:	5c a7       	lds	r21, 0x7c
    bd66:	b7 01       	movw	r22, r14
    bd68:	a6 01       	movw	r20, r12
    bd6a:	00 2e       	mov	r0, r16
    bd6c:	04 c0       	rjmp	.+8      	; 0xbd76 <__udivdi3+0x8de>
    bd6e:	76 95       	lsr	r23
    bd70:	67 95       	ror	r22
    bd72:	57 95       	ror	r21
    bd74:	47 95       	ror	r20
    bd76:	0a 94       	dec	r0
    bd78:	d2 f7       	brpl	.-12     	; 0xbd6e <__udivdi3+0x8d6>
    bd7a:	49 a3       	lds	r20, 0x59
    bd7c:	5a a3       	lds	r21, 0x5a
    bd7e:	6b a3       	lds	r22, 0x5b
    bd80:	7c a3       	lds	r23, 0x5c
    bd82:	c7 01       	movw	r24, r14
    bd84:	b6 01       	movw	r22, r12
    bd86:	03 2c       	mov	r0, r3
    bd88:	04 c0       	rjmp	.+8      	; 0xbd92 <__udivdi3+0x8fa>
    bd8a:	66 0f       	add	r22, r22
    bd8c:	77 1f       	adc	r23, r23
    bd8e:	88 1f       	adc	r24, r24
    bd90:	99 1f       	adc	r25, r25
    bd92:	0a 94       	dec	r0
    bd94:	d2 f7       	brpl	.-12     	; 0xbd8a <__udivdi3+0x8f2>
    bd96:	6d 8f       	std	Y+29, r22	; 0x1d
    bd98:	7e 8f       	std	Y+30, r23	; 0x1e
    bd9a:	8f 8f       	std	Y+31, r24	; 0x1f
    bd9c:	98 a3       	lds	r25, 0x58
    bd9e:	8d a1       	lds	r24, 0x4d
    bda0:	9e a1       	lds	r25, 0x4e
    bda2:	af a1       	lds	r26, 0x4f
    bda4:	b8 a5       	lds	r27, 0x68
    bda6:	04 c0       	rjmp	.+8      	; 0xbdb0 <__udivdi3+0x918>
    bda8:	b6 95       	lsr	r27
    bdaa:	a7 95       	ror	r26
    bdac:	97 95       	ror	r25
    bdae:	87 95       	ror	r24
    bdb0:	0a 95       	dec	r16
    bdb2:	d2 f7       	brpl	.-12     	; 0xbda8 <__udivdi3+0x910>
    bdb4:	4d 8d       	ldd	r20, Y+29	; 0x1d
    bdb6:	5e 8d       	ldd	r21, Y+30	; 0x1e
    bdb8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    bdba:	78 a1       	lds	r23, 0x48
    bdbc:	48 2b       	or	r20, r24
    bdbe:	59 2b       	or	r21, r25
    bdc0:	6a 2b       	or	r22, r26
    bdc2:	7b 2b       	or	r23, r27
    bdc4:	4d 8f       	std	Y+29, r20	; 0x1d
    bdc6:	5e 8f       	std	Y+30, r21	; 0x1e
    bdc8:	6f 8f       	std	Y+31, r22	; 0x1f
    bdca:	78 a3       	lds	r23, 0x58
    bdcc:	43 01       	movw	r8, r6
    bdce:	aa 24       	eor	r10, r10
    bdd0:	bb 24       	eor	r11, r11
    bdd2:	93 01       	movw	r18, r6
    bdd4:	82 01       	movw	r16, r4
    bdd6:	20 70       	andi	r18, 0x00	; 0
    bdd8:	30 70       	andi	r19, 0x00	; 0
    bdda:	0d a7       	lds	r16, 0x7d
    bddc:	1e a7       	lds	r17, 0x7e
    bdde:	2f a7       	lds	r18, 0x7f
    bde0:	38 ab       	sts	0x58, r19
    bde2:	69 a1       	lds	r22, 0x49
    bde4:	7a a1       	lds	r23, 0x4a
    bde6:	8b a1       	lds	r24, 0x4b
    bde8:	9c a1       	lds	r25, 0x4c
    bdea:	a5 01       	movw	r20, r10
    bdec:	94 01       	movw	r18, r8
    bdee:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    bdf2:	29 8f       	std	Y+25, r18	; 0x19
    bdf4:	3a 8f       	std	Y+26, r19	; 0x1a
    bdf6:	4b 8f       	std	Y+27, r20	; 0x1b
    bdf8:	5c 8f       	std	Y+28, r21	; 0x1c
    bdfa:	6b 01       	movw	r12, r22
    bdfc:	7c 01       	movw	r14, r24
    bdfe:	69 a1       	lds	r22, 0x49
    be00:	7a a1       	lds	r23, 0x4a
    be02:	8b a1       	lds	r24, 0x4b
    be04:	9c a1       	lds	r25, 0x4c
    be06:	a5 01       	movw	r20, r10
    be08:	94 01       	movw	r18, r8
    be0a:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    be0e:	ca 01       	movw	r24, r20
    be10:	b9 01       	movw	r22, r18
    be12:	2d a5       	lds	r18, 0x6d
    be14:	3e a5       	lds	r19, 0x6e
    be16:	4f a5       	lds	r20, 0x6f
    be18:	58 a9       	sts	0x48, r21
    be1a:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    be1e:	dc 01       	movw	r26, r24
    be20:	cb 01       	movw	r24, r22
    be22:	76 01       	movw	r14, r12
    be24:	dd 24       	eor	r13, r13
    be26:	cc 24       	eor	r12, r12
    be28:	0d 8d       	ldd	r16, Y+29	; 0x1d
    be2a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    be2c:	2f 8d       	ldd	r18, Y+31	; 0x1f
    be2e:	38 a1       	lds	r19, 0x48
    be30:	a9 01       	movw	r20, r18
    be32:	66 27       	eor	r22, r22
    be34:	77 27       	eor	r23, r23
    be36:	c4 2a       	or	r12, r20
    be38:	d5 2a       	or	r13, r21
    be3a:	e6 2a       	or	r14, r22
    be3c:	f7 2a       	or	r15, r23
    be3e:	09 8d       	ldd	r16, Y+25	; 0x19
    be40:	1a 8d       	ldd	r17, Y+26	; 0x1a
    be42:	2b 8d       	ldd	r18, Y+27	; 0x1b
    be44:	3c 8d       	ldd	r19, Y+28	; 0x1c
    be46:	c8 16       	cp	r12, r24
    be48:	d9 06       	cpc	r13, r25
    be4a:	ea 06       	cpc	r14, r26
    be4c:	fb 06       	cpc	r15, r27
    be4e:	38 f5       	brcc	.+78     	; 0xbe9e <__udivdi3+0xa06>
    be50:	01 50       	subi	r16, 0x01	; 1
    be52:	10 40       	sbci	r17, 0x00	; 0
    be54:	20 40       	sbci	r18, 0x00	; 0
    be56:	30 40       	sbci	r19, 0x00	; 0
    be58:	09 a3       	lds	r16, 0x59
    be5a:	1a a3       	lds	r17, 0x5a
    be5c:	2b a3       	lds	r18, 0x5b
    be5e:	3c a3       	lds	r19, 0x5c
    be60:	c4 0c       	add	r12, r4
    be62:	d5 1c       	adc	r13, r5
    be64:	e6 1c       	adc	r14, r6
    be66:	f7 1c       	adc	r15, r7
    be68:	c4 14       	cp	r12, r4
    be6a:	d5 04       	cpc	r13, r5
    be6c:	e6 04       	cpc	r14, r6
    be6e:	f7 04       	cpc	r15, r7
    be70:	d0 f0       	brcs	.+52     	; 0xbea6 <__udivdi3+0xa0e>
    be72:	c8 16       	cp	r12, r24
    be74:	d9 06       	cpc	r13, r25
    be76:	ea 06       	cpc	r14, r26
    be78:	fb 06       	cpc	r15, r27
    be7a:	a8 f4       	brcc	.+42     	; 0xbea6 <__udivdi3+0xa0e>
    be7c:	09 8d       	ldd	r16, Y+25	; 0x19
    be7e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    be80:	2b 8d       	ldd	r18, Y+27	; 0x1b
    be82:	3c 8d       	ldd	r19, Y+28	; 0x1c
    be84:	02 50       	subi	r16, 0x02	; 2
    be86:	10 40       	sbci	r17, 0x00	; 0
    be88:	20 40       	sbci	r18, 0x00	; 0
    be8a:	30 40       	sbci	r19, 0x00	; 0
    be8c:	09 a3       	lds	r16, 0x59
    be8e:	1a a3       	lds	r17, 0x5a
    be90:	2b a3       	lds	r18, 0x5b
    be92:	3c a3       	lds	r19, 0x5c
    be94:	c4 0c       	add	r12, r4
    be96:	d5 1c       	adc	r13, r5
    be98:	e6 1c       	adc	r14, r6
    be9a:	f7 1c       	adc	r15, r7
    be9c:	04 c0       	rjmp	.+8      	; 0xbea6 <__udivdi3+0xa0e>
    be9e:	09 a3       	lds	r16, 0x59
    bea0:	1a a3       	lds	r17, 0x5a
    bea2:	2b a3       	lds	r18, 0x5b
    bea4:	3c a3       	lds	r19, 0x5c
    bea6:	c8 1a       	sub	r12, r24
    bea8:	d9 0a       	sbc	r13, r25
    beaa:	ea 0a       	sbc	r14, r26
    beac:	fb 0a       	sbc	r15, r27
    beae:	c7 01       	movw	r24, r14
    beb0:	b6 01       	movw	r22, r12
    beb2:	a5 01       	movw	r20, r10
    beb4:	94 01       	movw	r18, r8
    beb6:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    beba:	29 8f       	std	Y+25, r18	; 0x19
    bebc:	3a 8f       	std	Y+26, r19	; 0x1a
    bebe:	4b 8f       	std	Y+27, r20	; 0x1b
    bec0:	5c 8f       	std	Y+28, r21	; 0x1c
    bec2:	69 ab       	sts	0x59, r22
    bec4:	7a ab       	sts	0x5a, r23
    bec6:	8b ab       	sts	0x5b, r24
    bec8:	9c ab       	sts	0x5c, r25
    beca:	c7 01       	movw	r24, r14
    becc:	b6 01       	movw	r22, r12
    bece:	a5 01       	movw	r20, r10
    bed0:	94 01       	movw	r18, r8
    bed2:	0e 94 4b 62 	call	0xc496	; 0xc496 <__udivmodsi4>
    bed6:	ca 01       	movw	r24, r20
    bed8:	b9 01       	movw	r22, r18
    beda:	2d a5       	lds	r18, 0x6d
    bedc:	3e a5       	lds	r19, 0x6e
    bede:	4f a5       	lds	r20, 0x6f
    bee0:	58 a9       	sts	0x48, r21
    bee2:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    bee6:	4b 01       	movw	r8, r22
    bee8:	5c 01       	movw	r10, r24
    beea:	49 a9       	sts	0x49, r20
    beec:	5a a9       	sts	0x4a, r21
    beee:	6b a9       	sts	0x4b, r22
    bef0:	7c a9       	sts	0x4c, r23
    bef2:	9a 01       	movw	r18, r20
    bef4:	11 27       	eor	r17, r17
    bef6:	00 27       	eor	r16, r16
    bef8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    befa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    befc:	af 8d       	ldd	r26, Y+31	; 0x1f
    befe:	b8 a1       	lds	r27, 0x48
    bf00:	a0 70       	andi	r26, 0x00	; 0
    bf02:	b0 70       	andi	r27, 0x00	; 0
    bf04:	08 2b       	or	r16, r24
    bf06:	19 2b       	or	r17, r25
    bf08:	2a 2b       	or	r18, r26
    bf0a:	3b 2b       	or	r19, r27
    bf0c:	89 8d       	ldd	r24, Y+25	; 0x19
    bf0e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    bf10:	ab 8d       	ldd	r26, Y+27	; 0x1b
    bf12:	bc 8d       	ldd	r27, Y+28	; 0x1c
    bf14:	08 15       	cp	r16, r8
    bf16:	19 05       	cpc	r17, r9
    bf18:	2a 05       	cpc	r18, r10
    bf1a:	3b 05       	cpc	r19, r11
    bf1c:	e0 f4       	brcc	.+56     	; 0xbf56 <__udivdi3+0xabe>
    bf1e:	01 97       	sbiw	r24, 0x01	; 1
    bf20:	a1 09       	sbc	r26, r1
    bf22:	b1 09       	sbc	r27, r1
    bf24:	04 0d       	add	r16, r4
    bf26:	15 1d       	adc	r17, r5
    bf28:	26 1d       	adc	r18, r6
    bf2a:	37 1d       	adc	r19, r7
    bf2c:	04 15       	cp	r16, r4
    bf2e:	15 05       	cpc	r17, r5
    bf30:	26 05       	cpc	r18, r6
    bf32:	37 05       	cpc	r19, r7
    bf34:	80 f0       	brcs	.+32     	; 0xbf56 <__udivdi3+0xabe>
    bf36:	08 15       	cp	r16, r8
    bf38:	19 05       	cpc	r17, r9
    bf3a:	2a 05       	cpc	r18, r10
    bf3c:	3b 05       	cpc	r19, r11
    bf3e:	58 f4       	brcc	.+22     	; 0xbf56 <__udivdi3+0xabe>
    bf40:	89 8d       	ldd	r24, Y+25	; 0x19
    bf42:	9a 8d       	ldd	r25, Y+26	; 0x1a
    bf44:	ab 8d       	ldd	r26, Y+27	; 0x1b
    bf46:	bc 8d       	ldd	r27, Y+28	; 0x1c
    bf48:	02 97       	sbiw	r24, 0x02	; 2
    bf4a:	a1 09       	sbc	r26, r1
    bf4c:	b1 09       	sbc	r27, r1
    bf4e:	04 0d       	add	r16, r4
    bf50:	15 1d       	adc	r17, r5
    bf52:	26 1d       	adc	r18, r6
    bf54:	37 1d       	adc	r19, r7
    bf56:	b9 01       	movw	r22, r18
    bf58:	a8 01       	movw	r20, r16
    bf5a:	48 19       	sub	r20, r8
    bf5c:	59 09       	sbc	r21, r9
    bf5e:	6a 09       	sbc	r22, r10
    bf60:	7b 09       	sbc	r23, r11
    bf62:	4d 8f       	std	Y+29, r20	; 0x1d
    bf64:	5e 8f       	std	Y+30, r21	; 0x1e
    bf66:	6f 8f       	std	Y+31, r22	; 0x1f
    bf68:	78 a3       	lds	r23, 0x58
    bf6a:	09 a1       	lds	r16, 0x49
    bf6c:	1a a1       	lds	r17, 0x4a
    bf6e:	2b a1       	lds	r18, 0x4b
    bf70:	3c a1       	lds	r19, 0x4c
    bf72:	78 01       	movw	r14, r16
    bf74:	dd 24       	eor	r13, r13
    bf76:	cc 24       	eor	r12, r12
    bf78:	c8 2a       	or	r12, r24
    bf7a:	d9 2a       	or	r13, r25
    bf7c:	ea 2a       	or	r14, r26
    bf7e:	fb 2a       	or	r15, r27
    bf80:	ff ef       	ldi	r31, 0xFF	; 255
    bf82:	8f 2e       	mov	r8, r31
    bf84:	ff ef       	ldi	r31, 0xFF	; 255
    bf86:	9f 2e       	mov	r9, r31
    bf88:	a1 2c       	mov	r10, r1
    bf8a:	b1 2c       	mov	r11, r1
    bf8c:	8c 20       	and	r8, r12
    bf8e:	9d 20       	and	r9, r13
    bf90:	ae 20       	and	r10, r14
    bf92:	bf 20       	and	r11, r15
    bf94:	87 01       	movw	r16, r14
    bf96:	22 27       	eor	r18, r18
    bf98:	33 27       	eor	r19, r19
    bf9a:	09 8f       	std	Y+25, r16	; 0x19
    bf9c:	1a 8f       	std	Y+26, r17	; 0x1a
    bf9e:	2b 8f       	std	Y+27, r18	; 0x1b
    bfa0:	3c 8f       	std	Y+28, r19	; 0x1c
    bfa2:	49 a4       	lds	r20, 0xa9
    bfa4:	5a a4       	lds	r21, 0xaa
    bfa6:	6b a4       	lds	r22, 0xab
    bfa8:	7c a4       	lds	r23, 0xac
    bfaa:	2f ef       	ldi	r18, 0xFF	; 255
    bfac:	3f ef       	ldi	r19, 0xFF	; 255
    bfae:	40 e0       	ldi	r20, 0x00	; 0
    bfb0:	50 e0       	ldi	r21, 0x00	; 0
    bfb2:	42 22       	and	r4, r18
    bfb4:	53 22       	and	r5, r19
    bfb6:	64 22       	and	r6, r20
    bfb8:	75 22       	and	r7, r21
    bfba:	29 a5       	lds	r18, 0x69
    bfbc:	3a a5       	lds	r19, 0x6a
    bfbe:	4b a5       	lds	r20, 0x6b
    bfc0:	5c a5       	lds	r21, 0x6c
    bfc2:	8a 01       	movw	r16, r20
    bfc4:	22 27       	eor	r18, r18
    bfc6:	33 27       	eor	r19, r19
    bfc8:	09 a3       	lds	r16, 0x59
    bfca:	1a a3       	lds	r17, 0x5a
    bfcc:	2b a3       	lds	r18, 0x5b
    bfce:	3c a3       	lds	r19, 0x5c
    bfd0:	c5 01       	movw	r24, r10
    bfd2:	b4 01       	movw	r22, r8
    bfd4:	a3 01       	movw	r20, r6
    bfd6:	92 01       	movw	r18, r4
    bfd8:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    bfdc:	69 a7       	lds	r22, 0x79
    bfde:	7a a7       	lds	r23, 0x7a
    bfe0:	8b a7       	lds	r24, 0x7b
    bfe2:	9c a7       	lds	r25, 0x7c
    bfe4:	c5 01       	movw	r24, r10
    bfe6:	b4 01       	movw	r22, r8
    bfe8:	29 a1       	lds	r18, 0x49
    bfea:	3a a1       	lds	r19, 0x4a
    bfec:	4b a1       	lds	r20, 0x4b
    bfee:	5c a1       	lds	r21, 0x4c
    bff0:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    bff4:	4b 01       	movw	r8, r22
    bff6:	5c 01       	movw	r10, r24
    bff8:	69 8d       	ldd	r22, Y+25	; 0x19
    bffa:	7a 8d       	ldd	r23, Y+26	; 0x1a
    bffc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    bffe:	9c 8d       	ldd	r25, Y+28	; 0x1c
    c000:	a3 01       	movw	r20, r6
    c002:	92 01       	movw	r18, r4
    c004:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    c008:	2b 01       	movw	r4, r22
    c00a:	3c 01       	movw	r6, r24
    c00c:	69 8d       	ldd	r22, Y+25	; 0x19
    c00e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    c010:	8b 8d       	ldd	r24, Y+27	; 0x1b
    c012:	9c 8d       	ldd	r25, Y+28	; 0x1c
    c014:	29 a1       	lds	r18, 0x49
    c016:	3a a1       	lds	r19, 0x4a
    c018:	4b a1       	lds	r20, 0x4b
    c01a:	5c a1       	lds	r21, 0x4c
    c01c:	0e 94 05 62 	call	0xc40a	; 0xc40a <__mulsi3>
    c020:	ab 01       	movw	r20, r22
    c022:	bc 01       	movw	r22, r24
    c024:	84 0c       	add	r8, r4
    c026:	95 1c       	adc	r9, r5
    c028:	a6 1c       	adc	r10, r6
    c02a:	b7 1c       	adc	r11, r7
    c02c:	09 a5       	lds	r16, 0x69
    c02e:	1a a5       	lds	r17, 0x6a
    c030:	2b a5       	lds	r18, 0x6b
    c032:	3c a5       	lds	r19, 0x6c
    c034:	c9 01       	movw	r24, r18
    c036:	aa 27       	eor	r26, r26
    c038:	bb 27       	eor	r27, r27
    c03a:	88 0e       	add	r8, r24
    c03c:	99 1e       	adc	r9, r25
    c03e:	aa 1e       	adc	r10, r26
    c040:	bb 1e       	adc	r11, r27
    c042:	84 14       	cp	r8, r4
    c044:	95 04       	cpc	r9, r5
    c046:	a6 04       	cpc	r10, r6
    c048:	b7 04       	cpc	r11, r7
    c04a:	20 f4       	brcc	.+8      	; 0xc054 <__udivdi3+0xbbc>
    c04c:	40 50       	subi	r20, 0x00	; 0
    c04e:	50 40       	sbci	r21, 0x00	; 0
    c050:	6f 4f       	sbci	r22, 0xFF	; 255
    c052:	7f 4f       	sbci	r23, 0xFF	; 255
    c054:	c5 01       	movw	r24, r10
    c056:	aa 27       	eor	r26, r26
    c058:	bb 27       	eor	r27, r27
    c05a:	84 0f       	add	r24, r20
    c05c:	95 1f       	adc	r25, r21
    c05e:	a6 1f       	adc	r26, r22
    c060:	b7 1f       	adc	r27, r23
    c062:	0d 8d       	ldd	r16, Y+29	; 0x1d
    c064:	1e 8d       	ldd	r17, Y+30	; 0x1e
    c066:	2f 8d       	ldd	r18, Y+31	; 0x1f
    c068:	38 a1       	lds	r19, 0x48
    c06a:	08 17       	cp	r16, r24
    c06c:	19 07       	cpc	r17, r25
    c06e:	2a 07       	cpc	r18, r26
    c070:	3b 07       	cpc	r19, r27
    c072:	18 f1       	brcs	.+70     	; 0xc0ba <__udivdi3+0xc22>
    c074:	80 17       	cp	r24, r16
    c076:	91 07       	cpc	r25, r17
    c078:	a2 07       	cpc	r26, r18
    c07a:	b3 07       	cpc	r27, r19
    c07c:	a1 f5       	brne	.+104    	; 0xc0e6 <__udivdi3+0xc4e>
    c07e:	54 01       	movw	r10, r8
    c080:	99 24       	eor	r9, r9
    c082:	88 24       	eor	r8, r8
    c084:	89 a5       	lds	r24, 0x69
    c086:	9a a5       	lds	r25, 0x6a
    c088:	ab a5       	lds	r26, 0x6b
    c08a:	bc a5       	lds	r27, 0x6c
    c08c:	a0 70       	andi	r26, 0x00	; 0
    c08e:	b0 70       	andi	r27, 0x00	; 0
    c090:	88 0e       	add	r8, r24
    c092:	99 1e       	adc	r9, r25
    c094:	aa 1e       	adc	r10, r26
    c096:	bb 1e       	adc	r11, r27
    c098:	4d a1       	lds	r20, 0x4d
    c09a:	5e a1       	lds	r21, 0x4e
    c09c:	6f a1       	lds	r22, 0x4f
    c09e:	78 a5       	lds	r23, 0x68
    c0a0:	03 2c       	mov	r0, r3
    c0a2:	04 c0       	rjmp	.+8      	; 0xc0ac <__udivdi3+0xc14>
    c0a4:	44 0f       	add	r20, r20
    c0a6:	55 1f       	adc	r21, r21
    c0a8:	66 1f       	adc	r22, r22
    c0aa:	77 1f       	adc	r23, r23
    c0ac:	0a 94       	dec	r0
    c0ae:	d2 f7       	brpl	.-12     	; 0xc0a4 <__udivdi3+0xc0c>
    c0b0:	48 15       	cp	r20, r8
    c0b2:	59 05       	cpc	r21, r9
    c0b4:	6a 05       	cpc	r22, r10
    c0b6:	7b 05       	cpc	r23, r11
    c0b8:	b0 f4       	brcc	.+44     	; 0xc0e6 <__udivdi3+0xc4e>
    c0ba:	08 94       	sec
    c0bc:	c1 08       	sbc	r12, r1
    c0be:	d1 08       	sbc	r13, r1
    c0c0:	e1 08       	sbc	r14, r1
    c0c2:	f1 08       	sbc	r15, r1
    c0c4:	10 c0       	rjmp	.+32     	; 0xc0e6 <__udivdi3+0xc4e>
    c0c6:	44 24       	eor	r4, r4
    c0c8:	55 24       	eor	r5, r5
    c0ca:	32 01       	movw	r6, r4
    c0cc:	cc 24       	eor	r12, r12
    c0ce:	dd 24       	eor	r13, r13
    c0d0:	76 01       	movw	r14, r12
    c0d2:	0c c0       	rjmp	.+24     	; 0xc0ec <__udivdi3+0xc54>
    c0d4:	44 24       	eor	r4, r4
    c0d6:	55 24       	eor	r5, r5
    c0d8:	32 01       	movw	r6, r4
    c0da:	81 e0       	ldi	r24, 0x01	; 1
    c0dc:	c8 2e       	mov	r12, r24
    c0de:	d1 2c       	mov	r13, r1
    c0e0:	e1 2c       	mov	r14, r1
    c0e2:	f1 2c       	mov	r15, r1
    c0e4:	03 c0       	rjmp	.+6      	; 0xc0ec <__udivdi3+0xc54>
    c0e6:	44 24       	eor	r4, r4
    c0e8:	55 24       	eor	r5, r5
    c0ea:	32 01       	movw	r6, r4
    c0ec:	fe 01       	movw	r30, r28
    c0ee:	31 96       	adiw	r30, 0x01	; 1
    c0f0:	88 e0       	ldi	r24, 0x08	; 8
    c0f2:	df 01       	movw	r26, r30
    c0f4:	1d 92       	st	X+, r1
    c0f6:	8a 95       	dec	r24
    c0f8:	e9 f7       	brne	.-6      	; 0xc0f4 <__udivdi3+0xc5c>
    c0fa:	c9 82       	std	Y+1, r12	; 0x01
    c0fc:	da 82       	std	Y+2, r13	; 0x02
    c0fe:	eb 82       	std	Y+3, r14	; 0x03
    c100:	fc 82       	std	Y+4, r15	; 0x04
    c102:	4d 82       	std	Y+5, r4	; 0x05
    c104:	5e 82       	std	Y+6, r5	; 0x06
    c106:	6f 82       	std	Y+7, r6	; 0x07
    c108:	78 86       	std	Y+8, r7	; 0x08
    c10a:	2c 2d       	mov	r18, r12
    c10c:	3a 81       	ldd	r19, Y+2	; 0x02
    c10e:	4b 81       	ldd	r20, Y+3	; 0x03
    c110:	5c 81       	ldd	r21, Y+4	; 0x04
    c112:	64 2d       	mov	r22, r4
    c114:	7e 81       	ldd	r23, Y+6	; 0x06
    c116:	8f 81       	ldd	r24, Y+7	; 0x07
    c118:	98 85       	ldd	r25, Y+8	; 0x08
    c11a:	e4 96       	adiw	r28, 0x34	; 52
    c11c:	e1 e1       	ldi	r30, 0x11	; 17
    c11e:	0c 94 a2 62 	jmp	0xc544	; 0xc544 <__epilogue_restores__+0x2>

0000c122 <__cmpsf2>:
    c122:	97 d0       	rcall	.+302    	; 0xc252 <__fp_cmp>
    c124:	08 f4       	brcc	.+2      	; 0xc128 <__cmpsf2+0x6>
    c126:	81 e0       	ldi	r24, 0x01	; 1
    c128:	08 95       	ret

0000c12a <__divsf3>:
    c12a:	0c d0       	rcall	.+24     	; 0xc144 <__divsf3x>
    c12c:	cd c0       	rjmp	.+410    	; 0xc2c8 <__fp_round>
    c12e:	c5 d0       	rcall	.+394    	; 0xc2ba <__fp_pscB>
    c130:	40 f0       	brcs	.+16     	; 0xc142 <__divsf3+0x18>
    c132:	bc d0       	rcall	.+376    	; 0xc2ac <__fp_pscA>
    c134:	30 f0       	brcs	.+12     	; 0xc142 <__divsf3+0x18>
    c136:	21 f4       	brne	.+8      	; 0xc140 <__divsf3+0x16>
    c138:	5f 3f       	cpi	r21, 0xFF	; 255
    c13a:	19 f0       	breq	.+6      	; 0xc142 <__divsf3+0x18>
    c13c:	ae c0       	rjmp	.+348    	; 0xc29a <__fp_inf>
    c13e:	51 11       	cpse	r21, r1
    c140:	f7 c0       	rjmp	.+494    	; 0xc330 <__fp_szero>
    c142:	b1 c0       	rjmp	.+354    	; 0xc2a6 <__fp_nan>

0000c144 <__divsf3x>:
    c144:	d2 d0       	rcall	.+420    	; 0xc2ea <__fp_split3>
    c146:	98 f3       	brcs	.-26     	; 0xc12e <__divsf3+0x4>

0000c148 <__divsf3_pse>:
    c148:	99 23       	and	r25, r25
    c14a:	c9 f3       	breq	.-14     	; 0xc13e <__divsf3+0x14>
    c14c:	55 23       	and	r21, r21
    c14e:	b1 f3       	breq	.-20     	; 0xc13c <__divsf3+0x12>
    c150:	95 1b       	sub	r25, r21
    c152:	55 0b       	sbc	r21, r21
    c154:	bb 27       	eor	r27, r27
    c156:	aa 27       	eor	r26, r26
    c158:	62 17       	cp	r22, r18
    c15a:	73 07       	cpc	r23, r19
    c15c:	84 07       	cpc	r24, r20
    c15e:	38 f0       	brcs	.+14     	; 0xc16e <__divsf3_pse+0x26>
    c160:	9f 5f       	subi	r25, 0xFF	; 255
    c162:	5f 4f       	sbci	r21, 0xFF	; 255
    c164:	22 0f       	add	r18, r18
    c166:	33 1f       	adc	r19, r19
    c168:	44 1f       	adc	r20, r20
    c16a:	aa 1f       	adc	r26, r26
    c16c:	a9 f3       	breq	.-22     	; 0xc158 <__divsf3_pse+0x10>
    c16e:	33 d0       	rcall	.+102    	; 0xc1d6 <__divsf3_pse+0x8e>
    c170:	0e 2e       	mov	r0, r30
    c172:	3a f0       	brmi	.+14     	; 0xc182 <__divsf3_pse+0x3a>
    c174:	e0 e8       	ldi	r30, 0x80	; 128
    c176:	30 d0       	rcall	.+96     	; 0xc1d8 <__divsf3_pse+0x90>
    c178:	91 50       	subi	r25, 0x01	; 1
    c17a:	50 40       	sbci	r21, 0x00	; 0
    c17c:	e6 95       	lsr	r30
    c17e:	00 1c       	adc	r0, r0
    c180:	ca f7       	brpl	.-14     	; 0xc174 <__divsf3_pse+0x2c>
    c182:	29 d0       	rcall	.+82     	; 0xc1d6 <__divsf3_pse+0x8e>
    c184:	fe 2f       	mov	r31, r30
    c186:	27 d0       	rcall	.+78     	; 0xc1d6 <__divsf3_pse+0x8e>
    c188:	66 0f       	add	r22, r22
    c18a:	77 1f       	adc	r23, r23
    c18c:	88 1f       	adc	r24, r24
    c18e:	bb 1f       	adc	r27, r27
    c190:	26 17       	cp	r18, r22
    c192:	37 07       	cpc	r19, r23
    c194:	48 07       	cpc	r20, r24
    c196:	ab 07       	cpc	r26, r27
    c198:	b0 e8       	ldi	r27, 0x80	; 128
    c19a:	09 f0       	breq	.+2      	; 0xc19e <__divsf3_pse+0x56>
    c19c:	bb 0b       	sbc	r27, r27
    c19e:	80 2d       	mov	r24, r0
    c1a0:	bf 01       	movw	r22, r30
    c1a2:	ff 27       	eor	r31, r31
    c1a4:	93 58       	subi	r25, 0x83	; 131
    c1a6:	5f 4f       	sbci	r21, 0xFF	; 255
    c1a8:	2a f0       	brmi	.+10     	; 0xc1b4 <__divsf3_pse+0x6c>
    c1aa:	9e 3f       	cpi	r25, 0xFE	; 254
    c1ac:	51 05       	cpc	r21, r1
    c1ae:	68 f0       	brcs	.+26     	; 0xc1ca <__divsf3_pse+0x82>
    c1b0:	74 c0       	rjmp	.+232    	; 0xc29a <__fp_inf>
    c1b2:	be c0       	rjmp	.+380    	; 0xc330 <__fp_szero>
    c1b4:	5f 3f       	cpi	r21, 0xFF	; 255
    c1b6:	ec f3       	brlt	.-6      	; 0xc1b2 <__divsf3_pse+0x6a>
    c1b8:	98 3e       	cpi	r25, 0xE8	; 232
    c1ba:	dc f3       	brlt	.-10     	; 0xc1b2 <__divsf3_pse+0x6a>
    c1bc:	86 95       	lsr	r24
    c1be:	77 95       	ror	r23
    c1c0:	67 95       	ror	r22
    c1c2:	b7 95       	ror	r27
    c1c4:	f7 95       	ror	r31
    c1c6:	9f 5f       	subi	r25, 0xFF	; 255
    c1c8:	c9 f7       	brne	.-14     	; 0xc1bc <__divsf3_pse+0x74>
    c1ca:	88 0f       	add	r24, r24
    c1cc:	91 1d       	adc	r25, r1
    c1ce:	96 95       	lsr	r25
    c1d0:	87 95       	ror	r24
    c1d2:	97 f9       	bld	r25, 7
    c1d4:	08 95       	ret
    c1d6:	e1 e0       	ldi	r30, 0x01	; 1
    c1d8:	66 0f       	add	r22, r22
    c1da:	77 1f       	adc	r23, r23
    c1dc:	88 1f       	adc	r24, r24
    c1de:	bb 1f       	adc	r27, r27
    c1e0:	62 17       	cp	r22, r18
    c1e2:	73 07       	cpc	r23, r19
    c1e4:	84 07       	cpc	r24, r20
    c1e6:	ba 07       	cpc	r27, r26
    c1e8:	20 f0       	brcs	.+8      	; 0xc1f2 <__divsf3_pse+0xaa>
    c1ea:	62 1b       	sub	r22, r18
    c1ec:	73 0b       	sbc	r23, r19
    c1ee:	84 0b       	sbc	r24, r20
    c1f0:	ba 0b       	sbc	r27, r26
    c1f2:	ee 1f       	adc	r30, r30
    c1f4:	88 f7       	brcc	.-30     	; 0xc1d8 <__divsf3_pse+0x90>
    c1f6:	e0 95       	com	r30
    c1f8:	08 95       	ret

0000c1fa <__fixunssfsi>:
    c1fa:	7f d0       	rcall	.+254    	; 0xc2fa <__fp_splitA>
    c1fc:	88 f0       	brcs	.+34     	; 0xc220 <__fixunssfsi+0x26>
    c1fe:	9f 57       	subi	r25, 0x7F	; 127
    c200:	90 f0       	brcs	.+36     	; 0xc226 <__fixunssfsi+0x2c>
    c202:	b9 2f       	mov	r27, r25
    c204:	99 27       	eor	r25, r25
    c206:	b7 51       	subi	r27, 0x17	; 23
    c208:	a0 f0       	brcs	.+40     	; 0xc232 <__fixunssfsi+0x38>
    c20a:	d1 f0       	breq	.+52     	; 0xc240 <__fixunssfsi+0x46>
    c20c:	66 0f       	add	r22, r22
    c20e:	77 1f       	adc	r23, r23
    c210:	88 1f       	adc	r24, r24
    c212:	99 1f       	adc	r25, r25
    c214:	1a f0       	brmi	.+6      	; 0xc21c <__fixunssfsi+0x22>
    c216:	ba 95       	dec	r27
    c218:	c9 f7       	brne	.-14     	; 0xc20c <__fixunssfsi+0x12>
    c21a:	12 c0       	rjmp	.+36     	; 0xc240 <__fixunssfsi+0x46>
    c21c:	b1 30       	cpi	r27, 0x01	; 1
    c21e:	81 f0       	breq	.+32     	; 0xc240 <__fixunssfsi+0x46>
    c220:	86 d0       	rcall	.+268    	; 0xc32e <__fp_zero>
    c222:	b1 e0       	ldi	r27, 0x01	; 1
    c224:	08 95       	ret
    c226:	83 c0       	rjmp	.+262    	; 0xc32e <__fp_zero>
    c228:	67 2f       	mov	r22, r23
    c22a:	78 2f       	mov	r23, r24
    c22c:	88 27       	eor	r24, r24
    c22e:	b8 5f       	subi	r27, 0xF8	; 248
    c230:	39 f0       	breq	.+14     	; 0xc240 <__fixunssfsi+0x46>
    c232:	b9 3f       	cpi	r27, 0xF9	; 249
    c234:	cc f3       	brlt	.-14     	; 0xc228 <__fixunssfsi+0x2e>
    c236:	86 95       	lsr	r24
    c238:	77 95       	ror	r23
    c23a:	67 95       	ror	r22
    c23c:	b3 95       	inc	r27
    c23e:	d9 f7       	brne	.-10     	; 0xc236 <__fixunssfsi+0x3c>
    c240:	3e f4       	brtc	.+14     	; 0xc250 <__fixunssfsi+0x56>
    c242:	90 95       	com	r25
    c244:	80 95       	com	r24
    c246:	70 95       	com	r23
    c248:	61 95       	neg	r22
    c24a:	7f 4f       	sbci	r23, 0xFF	; 255
    c24c:	8f 4f       	sbci	r24, 0xFF	; 255
    c24e:	9f 4f       	sbci	r25, 0xFF	; 255
    c250:	08 95       	ret

0000c252 <__fp_cmp>:
    c252:	99 0f       	add	r25, r25
    c254:	00 08       	sbc	r0, r0
    c256:	55 0f       	add	r21, r21
    c258:	aa 0b       	sbc	r26, r26
    c25a:	e0 e8       	ldi	r30, 0x80	; 128
    c25c:	fe ef       	ldi	r31, 0xFE	; 254
    c25e:	16 16       	cp	r1, r22
    c260:	17 06       	cpc	r1, r23
    c262:	e8 07       	cpc	r30, r24
    c264:	f9 07       	cpc	r31, r25
    c266:	c0 f0       	brcs	.+48     	; 0xc298 <__fp_cmp+0x46>
    c268:	12 16       	cp	r1, r18
    c26a:	13 06       	cpc	r1, r19
    c26c:	e4 07       	cpc	r30, r20
    c26e:	f5 07       	cpc	r31, r21
    c270:	98 f0       	brcs	.+38     	; 0xc298 <__fp_cmp+0x46>
    c272:	62 1b       	sub	r22, r18
    c274:	73 0b       	sbc	r23, r19
    c276:	84 0b       	sbc	r24, r20
    c278:	95 0b       	sbc	r25, r21
    c27a:	39 f4       	brne	.+14     	; 0xc28a <__fp_cmp+0x38>
    c27c:	0a 26       	eor	r0, r26
    c27e:	61 f0       	breq	.+24     	; 0xc298 <__fp_cmp+0x46>
    c280:	23 2b       	or	r18, r19
    c282:	24 2b       	or	r18, r20
    c284:	25 2b       	or	r18, r21
    c286:	21 f4       	brne	.+8      	; 0xc290 <__fp_cmp+0x3e>
    c288:	08 95       	ret
    c28a:	0a 26       	eor	r0, r26
    c28c:	09 f4       	brne	.+2      	; 0xc290 <__fp_cmp+0x3e>
    c28e:	a1 40       	sbci	r26, 0x01	; 1
    c290:	a6 95       	lsr	r26
    c292:	8f ef       	ldi	r24, 0xFF	; 255
    c294:	81 1d       	adc	r24, r1
    c296:	81 1d       	adc	r24, r1
    c298:	08 95       	ret

0000c29a <__fp_inf>:
    c29a:	97 f9       	bld	r25, 7
    c29c:	9f 67       	ori	r25, 0x7F	; 127
    c29e:	80 e8       	ldi	r24, 0x80	; 128
    c2a0:	70 e0       	ldi	r23, 0x00	; 0
    c2a2:	60 e0       	ldi	r22, 0x00	; 0
    c2a4:	08 95       	ret

0000c2a6 <__fp_nan>:
    c2a6:	9f ef       	ldi	r25, 0xFF	; 255
    c2a8:	80 ec       	ldi	r24, 0xC0	; 192
    c2aa:	08 95       	ret

0000c2ac <__fp_pscA>:
    c2ac:	00 24       	eor	r0, r0
    c2ae:	0a 94       	dec	r0
    c2b0:	16 16       	cp	r1, r22
    c2b2:	17 06       	cpc	r1, r23
    c2b4:	18 06       	cpc	r1, r24
    c2b6:	09 06       	cpc	r0, r25
    c2b8:	08 95       	ret

0000c2ba <__fp_pscB>:
    c2ba:	00 24       	eor	r0, r0
    c2bc:	0a 94       	dec	r0
    c2be:	12 16       	cp	r1, r18
    c2c0:	13 06       	cpc	r1, r19
    c2c2:	14 06       	cpc	r1, r20
    c2c4:	05 06       	cpc	r0, r21
    c2c6:	08 95       	ret

0000c2c8 <__fp_round>:
    c2c8:	09 2e       	mov	r0, r25
    c2ca:	03 94       	inc	r0
    c2cc:	00 0c       	add	r0, r0
    c2ce:	11 f4       	brne	.+4      	; 0xc2d4 <__fp_round+0xc>
    c2d0:	88 23       	and	r24, r24
    c2d2:	52 f0       	brmi	.+20     	; 0xc2e8 <__fp_round+0x20>
    c2d4:	bb 0f       	add	r27, r27
    c2d6:	40 f4       	brcc	.+16     	; 0xc2e8 <__fp_round+0x20>
    c2d8:	bf 2b       	or	r27, r31
    c2da:	11 f4       	brne	.+4      	; 0xc2e0 <__fp_round+0x18>
    c2dc:	60 ff       	sbrs	r22, 0
    c2de:	04 c0       	rjmp	.+8      	; 0xc2e8 <__fp_round+0x20>
    c2e0:	6f 5f       	subi	r22, 0xFF	; 255
    c2e2:	7f 4f       	sbci	r23, 0xFF	; 255
    c2e4:	8f 4f       	sbci	r24, 0xFF	; 255
    c2e6:	9f 4f       	sbci	r25, 0xFF	; 255
    c2e8:	08 95       	ret

0000c2ea <__fp_split3>:
    c2ea:	57 fd       	sbrc	r21, 7
    c2ec:	90 58       	subi	r25, 0x80	; 128
    c2ee:	44 0f       	add	r20, r20
    c2f0:	55 1f       	adc	r21, r21
    c2f2:	59 f0       	breq	.+22     	; 0xc30a <__fp_splitA+0x10>
    c2f4:	5f 3f       	cpi	r21, 0xFF	; 255
    c2f6:	71 f0       	breq	.+28     	; 0xc314 <__fp_splitA+0x1a>
    c2f8:	47 95       	ror	r20

0000c2fa <__fp_splitA>:
    c2fa:	88 0f       	add	r24, r24
    c2fc:	97 fb       	bst	r25, 7
    c2fe:	99 1f       	adc	r25, r25
    c300:	61 f0       	breq	.+24     	; 0xc31a <__fp_splitA+0x20>
    c302:	9f 3f       	cpi	r25, 0xFF	; 255
    c304:	79 f0       	breq	.+30     	; 0xc324 <__fp_splitA+0x2a>
    c306:	87 95       	ror	r24
    c308:	08 95       	ret
    c30a:	12 16       	cp	r1, r18
    c30c:	13 06       	cpc	r1, r19
    c30e:	14 06       	cpc	r1, r20
    c310:	55 1f       	adc	r21, r21
    c312:	f2 cf       	rjmp	.-28     	; 0xc2f8 <__fp_split3+0xe>
    c314:	46 95       	lsr	r20
    c316:	f1 df       	rcall	.-30     	; 0xc2fa <__fp_splitA>
    c318:	08 c0       	rjmp	.+16     	; 0xc32a <__fp_splitA+0x30>
    c31a:	16 16       	cp	r1, r22
    c31c:	17 06       	cpc	r1, r23
    c31e:	18 06       	cpc	r1, r24
    c320:	99 1f       	adc	r25, r25
    c322:	f1 cf       	rjmp	.-30     	; 0xc306 <__fp_splitA+0xc>
    c324:	86 95       	lsr	r24
    c326:	71 05       	cpc	r23, r1
    c328:	61 05       	cpc	r22, r1
    c32a:	08 94       	sec
    c32c:	08 95       	ret

0000c32e <__fp_zero>:
    c32e:	e8 94       	clt

0000c330 <__fp_szero>:
    c330:	bb 27       	eor	r27, r27
    c332:	66 27       	eor	r22, r22
    c334:	77 27       	eor	r23, r23
    c336:	cb 01       	movw	r24, r22
    c338:	97 f9       	bld	r25, 7
    c33a:	08 95       	ret

0000c33c <__gesf2>:
    c33c:	8a df       	rcall	.-236    	; 0xc252 <__fp_cmp>
    c33e:	08 f4       	brcc	.+2      	; 0xc342 <__gesf2+0x6>
    c340:	8f ef       	ldi	r24, 0xFF	; 255
    c342:	08 95       	ret

0000c344 <__mulsf3>:
    c344:	0b d0       	rcall	.+22     	; 0xc35c <__mulsf3x>
    c346:	c0 cf       	rjmp	.-128    	; 0xc2c8 <__fp_round>
    c348:	b1 df       	rcall	.-158    	; 0xc2ac <__fp_pscA>
    c34a:	28 f0       	brcs	.+10     	; 0xc356 <__mulsf3+0x12>
    c34c:	b6 df       	rcall	.-148    	; 0xc2ba <__fp_pscB>
    c34e:	18 f0       	brcs	.+6      	; 0xc356 <__mulsf3+0x12>
    c350:	95 23       	and	r25, r21
    c352:	09 f0       	breq	.+2      	; 0xc356 <__mulsf3+0x12>
    c354:	a2 cf       	rjmp	.-188    	; 0xc29a <__fp_inf>
    c356:	a7 cf       	rjmp	.-178    	; 0xc2a6 <__fp_nan>
    c358:	11 24       	eor	r1, r1
    c35a:	ea cf       	rjmp	.-44     	; 0xc330 <__fp_szero>

0000c35c <__mulsf3x>:
    c35c:	c6 df       	rcall	.-116    	; 0xc2ea <__fp_split3>
    c35e:	a0 f3       	brcs	.-24     	; 0xc348 <__mulsf3+0x4>

0000c360 <__mulsf3_pse>:
    c360:	95 9f       	mul	r25, r21
    c362:	d1 f3       	breq	.-12     	; 0xc358 <__mulsf3+0x14>
    c364:	95 0f       	add	r25, r21
    c366:	50 e0       	ldi	r21, 0x00	; 0
    c368:	55 1f       	adc	r21, r21
    c36a:	62 9f       	mul	r22, r18
    c36c:	f0 01       	movw	r30, r0
    c36e:	72 9f       	mul	r23, r18
    c370:	bb 27       	eor	r27, r27
    c372:	f0 0d       	add	r31, r0
    c374:	b1 1d       	adc	r27, r1
    c376:	63 9f       	mul	r22, r19
    c378:	aa 27       	eor	r26, r26
    c37a:	f0 0d       	add	r31, r0
    c37c:	b1 1d       	adc	r27, r1
    c37e:	aa 1f       	adc	r26, r26
    c380:	64 9f       	mul	r22, r20
    c382:	66 27       	eor	r22, r22
    c384:	b0 0d       	add	r27, r0
    c386:	a1 1d       	adc	r26, r1
    c388:	66 1f       	adc	r22, r22
    c38a:	82 9f       	mul	r24, r18
    c38c:	22 27       	eor	r18, r18
    c38e:	b0 0d       	add	r27, r0
    c390:	a1 1d       	adc	r26, r1
    c392:	62 1f       	adc	r22, r18
    c394:	73 9f       	mul	r23, r19
    c396:	b0 0d       	add	r27, r0
    c398:	a1 1d       	adc	r26, r1
    c39a:	62 1f       	adc	r22, r18
    c39c:	83 9f       	mul	r24, r19
    c39e:	a0 0d       	add	r26, r0
    c3a0:	61 1d       	adc	r22, r1
    c3a2:	22 1f       	adc	r18, r18
    c3a4:	74 9f       	mul	r23, r20
    c3a6:	33 27       	eor	r19, r19
    c3a8:	a0 0d       	add	r26, r0
    c3aa:	61 1d       	adc	r22, r1
    c3ac:	23 1f       	adc	r18, r19
    c3ae:	84 9f       	mul	r24, r20
    c3b0:	60 0d       	add	r22, r0
    c3b2:	21 1d       	adc	r18, r1
    c3b4:	82 2f       	mov	r24, r18
    c3b6:	76 2f       	mov	r23, r22
    c3b8:	6a 2f       	mov	r22, r26
    c3ba:	11 24       	eor	r1, r1
    c3bc:	9f 57       	subi	r25, 0x7F	; 127
    c3be:	50 40       	sbci	r21, 0x00	; 0
    c3c0:	8a f0       	brmi	.+34     	; 0xc3e4 <__mulsf3_pse+0x84>
    c3c2:	e1 f0       	breq	.+56     	; 0xc3fc <__mulsf3_pse+0x9c>
    c3c4:	88 23       	and	r24, r24
    c3c6:	4a f0       	brmi	.+18     	; 0xc3da <__mulsf3_pse+0x7a>
    c3c8:	ee 0f       	add	r30, r30
    c3ca:	ff 1f       	adc	r31, r31
    c3cc:	bb 1f       	adc	r27, r27
    c3ce:	66 1f       	adc	r22, r22
    c3d0:	77 1f       	adc	r23, r23
    c3d2:	88 1f       	adc	r24, r24
    c3d4:	91 50       	subi	r25, 0x01	; 1
    c3d6:	50 40       	sbci	r21, 0x00	; 0
    c3d8:	a9 f7       	brne	.-22     	; 0xc3c4 <__mulsf3_pse+0x64>
    c3da:	9e 3f       	cpi	r25, 0xFE	; 254
    c3dc:	51 05       	cpc	r21, r1
    c3de:	70 f0       	brcs	.+28     	; 0xc3fc <__mulsf3_pse+0x9c>
    c3e0:	5c cf       	rjmp	.-328    	; 0xc29a <__fp_inf>
    c3e2:	a6 cf       	rjmp	.-180    	; 0xc330 <__fp_szero>
    c3e4:	5f 3f       	cpi	r21, 0xFF	; 255
    c3e6:	ec f3       	brlt	.-6      	; 0xc3e2 <__mulsf3_pse+0x82>
    c3e8:	98 3e       	cpi	r25, 0xE8	; 232
    c3ea:	dc f3       	brlt	.-10     	; 0xc3e2 <__mulsf3_pse+0x82>
    c3ec:	86 95       	lsr	r24
    c3ee:	77 95       	ror	r23
    c3f0:	67 95       	ror	r22
    c3f2:	b7 95       	ror	r27
    c3f4:	f7 95       	ror	r31
    c3f6:	e7 95       	ror	r30
    c3f8:	9f 5f       	subi	r25, 0xFF	; 255
    c3fa:	c1 f7       	brne	.-16     	; 0xc3ec <__mulsf3_pse+0x8c>
    c3fc:	fe 2b       	or	r31, r30
    c3fe:	88 0f       	add	r24, r24
    c400:	91 1d       	adc	r25, r1
    c402:	96 95       	lsr	r25
    c404:	87 95       	ror	r24
    c406:	97 f9       	bld	r25, 7
    c408:	08 95       	ret

0000c40a <__mulsi3>:
    c40a:	62 9f       	mul	r22, r18
    c40c:	d0 01       	movw	r26, r0
    c40e:	73 9f       	mul	r23, r19
    c410:	f0 01       	movw	r30, r0
    c412:	82 9f       	mul	r24, r18
    c414:	e0 0d       	add	r30, r0
    c416:	f1 1d       	adc	r31, r1
    c418:	64 9f       	mul	r22, r20
    c41a:	e0 0d       	add	r30, r0
    c41c:	f1 1d       	adc	r31, r1
    c41e:	92 9f       	mul	r25, r18
    c420:	f0 0d       	add	r31, r0
    c422:	83 9f       	mul	r24, r19
    c424:	f0 0d       	add	r31, r0
    c426:	74 9f       	mul	r23, r20
    c428:	f0 0d       	add	r31, r0
    c42a:	65 9f       	mul	r22, r21
    c42c:	f0 0d       	add	r31, r0
    c42e:	99 27       	eor	r25, r25
    c430:	72 9f       	mul	r23, r18
    c432:	b0 0d       	add	r27, r0
    c434:	e1 1d       	adc	r30, r1
    c436:	f9 1f       	adc	r31, r25
    c438:	63 9f       	mul	r22, r19
    c43a:	b0 0d       	add	r27, r0
    c43c:	e1 1d       	adc	r30, r1
    c43e:	f9 1f       	adc	r31, r25
    c440:	bd 01       	movw	r22, r26
    c442:	cf 01       	movw	r24, r30
    c444:	11 24       	eor	r1, r1
    c446:	08 95       	ret

0000c448 <__udivmodhi4>:
    c448:	aa 1b       	sub	r26, r26
    c44a:	bb 1b       	sub	r27, r27
    c44c:	51 e1       	ldi	r21, 0x11	; 17
    c44e:	07 c0       	rjmp	.+14     	; 0xc45e <__udivmodhi4_ep>

0000c450 <__udivmodhi4_loop>:
    c450:	aa 1f       	adc	r26, r26
    c452:	bb 1f       	adc	r27, r27
    c454:	a6 17       	cp	r26, r22
    c456:	b7 07       	cpc	r27, r23
    c458:	10 f0       	brcs	.+4      	; 0xc45e <__udivmodhi4_ep>
    c45a:	a6 1b       	sub	r26, r22
    c45c:	b7 0b       	sbc	r27, r23

0000c45e <__udivmodhi4_ep>:
    c45e:	88 1f       	adc	r24, r24
    c460:	99 1f       	adc	r25, r25
    c462:	5a 95       	dec	r21
    c464:	a9 f7       	brne	.-22     	; 0xc450 <__udivmodhi4_loop>
    c466:	80 95       	com	r24
    c468:	90 95       	com	r25
    c46a:	bc 01       	movw	r22, r24
    c46c:	cd 01       	movw	r24, r26
    c46e:	08 95       	ret

0000c470 <__divmodhi4>:
    c470:	97 fb       	bst	r25, 7
    c472:	09 2e       	mov	r0, r25
    c474:	07 26       	eor	r0, r23
    c476:	0a d0       	rcall	.+20     	; 0xc48c <__divmodhi4_neg1>
    c478:	77 fd       	sbrc	r23, 7
    c47a:	04 d0       	rcall	.+8      	; 0xc484 <__divmodhi4_neg2>
    c47c:	e5 df       	rcall	.-54     	; 0xc448 <__udivmodhi4>
    c47e:	06 d0       	rcall	.+12     	; 0xc48c <__divmodhi4_neg1>
    c480:	00 20       	and	r0, r0
    c482:	1a f4       	brpl	.+6      	; 0xc48a <__divmodhi4_exit>

0000c484 <__divmodhi4_neg2>:
    c484:	70 95       	com	r23
    c486:	61 95       	neg	r22
    c488:	7f 4f       	sbci	r23, 0xFF	; 255

0000c48a <__divmodhi4_exit>:
    c48a:	08 95       	ret

0000c48c <__divmodhi4_neg1>:
    c48c:	f6 f7       	brtc	.-4      	; 0xc48a <__divmodhi4_exit>
    c48e:	90 95       	com	r25
    c490:	81 95       	neg	r24
    c492:	9f 4f       	sbci	r25, 0xFF	; 255
    c494:	08 95       	ret

0000c496 <__udivmodsi4>:
    c496:	a1 e2       	ldi	r26, 0x21	; 33
    c498:	1a 2e       	mov	r1, r26
    c49a:	aa 1b       	sub	r26, r26
    c49c:	bb 1b       	sub	r27, r27
    c49e:	fd 01       	movw	r30, r26
    c4a0:	0d c0       	rjmp	.+26     	; 0xc4bc <__udivmodsi4_ep>

0000c4a2 <__udivmodsi4_loop>:
    c4a2:	aa 1f       	adc	r26, r26
    c4a4:	bb 1f       	adc	r27, r27
    c4a6:	ee 1f       	adc	r30, r30
    c4a8:	ff 1f       	adc	r31, r31
    c4aa:	a2 17       	cp	r26, r18
    c4ac:	b3 07       	cpc	r27, r19
    c4ae:	e4 07       	cpc	r30, r20
    c4b0:	f5 07       	cpc	r31, r21
    c4b2:	20 f0       	brcs	.+8      	; 0xc4bc <__udivmodsi4_ep>
    c4b4:	a2 1b       	sub	r26, r18
    c4b6:	b3 0b       	sbc	r27, r19
    c4b8:	e4 0b       	sbc	r30, r20
    c4ba:	f5 0b       	sbc	r31, r21

0000c4bc <__udivmodsi4_ep>:
    c4bc:	66 1f       	adc	r22, r22
    c4be:	77 1f       	adc	r23, r23
    c4c0:	88 1f       	adc	r24, r24
    c4c2:	99 1f       	adc	r25, r25
    c4c4:	1a 94       	dec	r1
    c4c6:	69 f7       	brne	.-38     	; 0xc4a2 <__udivmodsi4_loop>
    c4c8:	60 95       	com	r22
    c4ca:	70 95       	com	r23
    c4cc:	80 95       	com	r24
    c4ce:	90 95       	com	r25
    c4d0:	9b 01       	movw	r18, r22
    c4d2:	ac 01       	movw	r20, r24
    c4d4:	bd 01       	movw	r22, r26
    c4d6:	cf 01       	movw	r24, r30
    c4d8:	08 95       	ret

0000c4da <__divmodsi4>:
    c4da:	97 fb       	bst	r25, 7
    c4dc:	09 2e       	mov	r0, r25
    c4de:	05 26       	eor	r0, r21
    c4e0:	0e d0       	rcall	.+28     	; 0xc4fe <__divmodsi4_neg1>
    c4e2:	57 fd       	sbrc	r21, 7
    c4e4:	04 d0       	rcall	.+8      	; 0xc4ee <__divmodsi4_neg2>
    c4e6:	d7 df       	rcall	.-82     	; 0xc496 <__udivmodsi4>
    c4e8:	0a d0       	rcall	.+20     	; 0xc4fe <__divmodsi4_neg1>
    c4ea:	00 1c       	adc	r0, r0
    c4ec:	38 f4       	brcc	.+14     	; 0xc4fc <__divmodsi4_exit>

0000c4ee <__divmodsi4_neg2>:
    c4ee:	50 95       	com	r21
    c4f0:	40 95       	com	r20
    c4f2:	30 95       	com	r19
    c4f4:	21 95       	neg	r18
    c4f6:	3f 4f       	sbci	r19, 0xFF	; 255
    c4f8:	4f 4f       	sbci	r20, 0xFF	; 255
    c4fa:	5f 4f       	sbci	r21, 0xFF	; 255

0000c4fc <__divmodsi4_exit>:
    c4fc:	08 95       	ret

0000c4fe <__divmodsi4_neg1>:
    c4fe:	f6 f7       	brtc	.-4      	; 0xc4fc <__divmodsi4_exit>
    c500:	90 95       	com	r25
    c502:	80 95       	com	r24
    c504:	70 95       	com	r23
    c506:	61 95       	neg	r22
    c508:	7f 4f       	sbci	r23, 0xFF	; 255
    c50a:	8f 4f       	sbci	r24, 0xFF	; 255
    c50c:	9f 4f       	sbci	r25, 0xFF	; 255
    c50e:	08 95       	ret

0000c510 <__prologue_saves__>:
    c510:	2f 92       	push	r2
    c512:	3f 92       	push	r3
    c514:	4f 92       	push	r4
    c516:	5f 92       	push	r5
    c518:	6f 92       	push	r6
    c51a:	7f 92       	push	r7
    c51c:	8f 92       	push	r8
    c51e:	9f 92       	push	r9
    c520:	af 92       	push	r10
    c522:	bf 92       	push	r11
    c524:	cf 92       	push	r12
    c526:	df 92       	push	r13
    c528:	ef 92       	push	r14
    c52a:	ff 92       	push	r15
    c52c:	0f 93       	push	r16
    c52e:	1f 93       	push	r17
    c530:	cf 93       	push	r28
    c532:	df 93       	push	r29
    c534:	cd b7       	in	r28, 0x3d	; 61
    c536:	de b7       	in	r29, 0x3e	; 62
    c538:	ca 1b       	sub	r28, r26
    c53a:	db 0b       	sbc	r29, r27
    c53c:	cd bf       	out	0x3d, r28	; 61
    c53e:	de bf       	out	0x3e, r29	; 62
    c540:	19 94       	eijmp

0000c542 <__epilogue_restores__>:
    c542:	2a 88       	ldd	r2, Y+18	; 0x12
    c544:	39 88       	ldd	r3, Y+17	; 0x11
    c546:	48 88       	ldd	r4, Y+16	; 0x10
    c548:	5f 84       	ldd	r5, Y+15	; 0x0f
    c54a:	6e 84       	ldd	r6, Y+14	; 0x0e
    c54c:	7d 84       	ldd	r7, Y+13	; 0x0d
    c54e:	8c 84       	ldd	r8, Y+12	; 0x0c
    c550:	9b 84       	ldd	r9, Y+11	; 0x0b
    c552:	aa 84       	ldd	r10, Y+10	; 0x0a
    c554:	b9 84       	ldd	r11, Y+9	; 0x09
    c556:	c8 84       	ldd	r12, Y+8	; 0x08
    c558:	df 80       	ldd	r13, Y+7	; 0x07
    c55a:	ee 80       	ldd	r14, Y+6	; 0x06
    c55c:	fd 80       	ldd	r15, Y+5	; 0x05
    c55e:	0c 81       	ldd	r16, Y+4	; 0x04
    c560:	1b 81       	ldd	r17, Y+3	; 0x03
    c562:	aa 81       	ldd	r26, Y+2	; 0x02
    c564:	b9 81       	ldd	r27, Y+1	; 0x01
    c566:	ce 0f       	add	r28, r30
    c568:	d1 1d       	adc	r29, r1
    c56a:	cd bf       	out	0x3d, r28	; 61
    c56c:	de bf       	out	0x3e, r29	; 62
    c56e:	ed 01       	movw	r28, r26
    c570:	08 95       	ret

0000c572 <strcpy_P>:
    c572:	fb 01       	movw	r30, r22
    c574:	dc 01       	movw	r26, r24
    c576:	05 90       	lpm	r0, Z+
    c578:	0d 92       	st	X+, r0
    c57a:	00 20       	and	r0, r0
    c57c:	e1 f7       	brne	.-8      	; 0xc576 <strcpy_P+0x4>
    c57e:	08 95       	ret

0000c580 <memcpy>:
    c580:	fb 01       	movw	r30, r22
    c582:	dc 01       	movw	r26, r24
    c584:	02 c0       	rjmp	.+4      	; 0xc58a <memcpy+0xa>
    c586:	01 90       	ld	r0, Z+
    c588:	0d 92       	st	X+, r0
    c58a:	41 50       	subi	r20, 0x01	; 1
    c58c:	50 40       	sbci	r21, 0x00	; 0
    c58e:	d8 f7       	brcc	.-10     	; 0xc586 <memcpy+0x6>
    c590:	08 95       	ret

0000c592 <memmove>:
    c592:	68 17       	cp	r22, r24
    c594:	79 07       	cpc	r23, r25
    c596:	68 f4       	brcc	.+26     	; 0xc5b2 <memmove+0x20>
    c598:	fb 01       	movw	r30, r22
    c59a:	dc 01       	movw	r26, r24
    c59c:	e4 0f       	add	r30, r20
    c59e:	f5 1f       	adc	r31, r21
    c5a0:	a4 0f       	add	r26, r20
    c5a2:	b5 1f       	adc	r27, r21
    c5a4:	02 c0       	rjmp	.+4      	; 0xc5aa <memmove+0x18>
    c5a6:	02 90       	ld	r0, -Z
    c5a8:	0e 92       	st	-X, r0
    c5aa:	41 50       	subi	r20, 0x01	; 1
    c5ac:	50 40       	sbci	r21, 0x00	; 0
    c5ae:	d8 f7       	brcc	.-10     	; 0xc5a6 <memmove+0x14>
    c5b0:	08 95       	ret
    c5b2:	0c 94 c0 62 	jmp	0xc580	; 0xc580 <memcpy>

0000c5b6 <strcat>:
    c5b6:	fb 01       	movw	r30, r22
    c5b8:	dc 01       	movw	r26, r24
    c5ba:	0d 90       	ld	r0, X+
    c5bc:	00 20       	and	r0, r0
    c5be:	e9 f7       	brne	.-6      	; 0xc5ba <strcat+0x4>
    c5c0:	11 97       	sbiw	r26, 0x01	; 1
    c5c2:	01 90       	ld	r0, Z+
    c5c4:	0d 92       	st	X+, r0
    c5c6:	00 20       	and	r0, r0
    c5c8:	e1 f7       	brne	.-8      	; 0xc5c2 <strcat+0xc>
    c5ca:	08 95       	ret

0000c5cc <strncmp>:
    c5cc:	fb 01       	movw	r30, r22
    c5ce:	dc 01       	movw	r26, r24
    c5d0:	41 50       	subi	r20, 0x01	; 1
    c5d2:	50 40       	sbci	r21, 0x00	; 0
    c5d4:	30 f0       	brcs	.+12     	; 0xc5e2 <strncmp+0x16>
    c5d6:	8d 91       	ld	r24, X+
    c5d8:	01 90       	ld	r0, Z+
    c5da:	80 19       	sub	r24, r0
    c5dc:	19 f4       	brne	.+6      	; 0xc5e4 <strncmp+0x18>
    c5de:	00 20       	and	r0, r0
    c5e0:	b9 f7       	brne	.-18     	; 0xc5d0 <strncmp+0x4>
    c5e2:	88 1b       	sub	r24, r24
    c5e4:	99 0b       	sbc	r25, r25
    c5e6:	08 95       	ret

0000c5e8 <itoa>:
    c5e8:	fb 01       	movw	r30, r22
    c5ea:	9f 01       	movw	r18, r30
    c5ec:	e8 94       	clt
    c5ee:	42 30       	cpi	r20, 0x02	; 2
    c5f0:	c4 f0       	brlt	.+48     	; 0xc622 <itoa+0x3a>
    c5f2:	45 32       	cpi	r20, 0x25	; 37
    c5f4:	b4 f4       	brge	.+44     	; 0xc622 <itoa+0x3a>
    c5f6:	4a 30       	cpi	r20, 0x0A	; 10
    c5f8:	29 f4       	brne	.+10     	; 0xc604 <itoa+0x1c>
    c5fa:	97 fb       	bst	r25, 7
    c5fc:	1e f4       	brtc	.+6      	; 0xc604 <itoa+0x1c>
    c5fe:	90 95       	com	r25
    c600:	81 95       	neg	r24
    c602:	9f 4f       	sbci	r25, 0xFF	; 255
    c604:	64 2f       	mov	r22, r20
    c606:	77 27       	eor	r23, r23
    c608:	0e 94 24 62 	call	0xc448	; 0xc448 <__udivmodhi4>
    c60c:	80 5d       	subi	r24, 0xD0	; 208
    c60e:	8a 33       	cpi	r24, 0x3A	; 58
    c610:	0c f0       	brlt	.+2      	; 0xc614 <itoa+0x2c>
    c612:	89 5d       	subi	r24, 0xD9	; 217
    c614:	81 93       	st	Z+, r24
    c616:	cb 01       	movw	r24, r22
    c618:	00 97       	sbiw	r24, 0x00	; 0
    c61a:	a1 f7       	brne	.-24     	; 0xc604 <itoa+0x1c>
    c61c:	16 f4       	brtc	.+4      	; 0xc622 <itoa+0x3a>
    c61e:	5d e2       	ldi	r21, 0x2D	; 45
    c620:	51 93       	st	Z+, r21
    c622:	10 82       	st	Z, r1
    c624:	c9 01       	movw	r24, r18
    c626:	0c 94 67 65 	jmp	0xcace	; 0xcace <strrev>

0000c62a <printf>:
    c62a:	cf 93       	push	r28
    c62c:	df 93       	push	r29
    c62e:	cd b7       	in	r28, 0x3d	; 61
    c630:	de b7       	in	r29, 0x3e	; 62
    c632:	fe 01       	movw	r30, r28
    c634:	36 96       	adiw	r30, 0x06	; 6
    c636:	61 91       	ld	r22, Z+
    c638:	71 91       	ld	r23, Z+
    c63a:	80 91 d9 50 	lds	r24, 0x50D9
    c63e:	90 91 da 50 	lds	r25, 0x50DA
    c642:	af 01       	movw	r20, r30
    c644:	0e 94 50 63 	call	0xc6a0	; 0xc6a0 <vfprintf>
    c648:	df 91       	pop	r29
    c64a:	cf 91       	pop	r28
    c64c:	08 95       	ret

0000c64e <sprintf>:
    c64e:	0f 93       	push	r16
    c650:	1f 93       	push	r17
    c652:	cf 93       	push	r28
    c654:	df 93       	push	r29
    c656:	cd b7       	in	r28, 0x3d	; 61
    c658:	de b7       	in	r29, 0x3e	; 62
    c65a:	2e 97       	sbiw	r28, 0x0e	; 14
    c65c:	cd bf       	out	0x3d, r28	; 61
    c65e:	de bf       	out	0x3e, r29	; 62
    c660:	0e 89       	ldd	r16, Y+22	; 0x16
    c662:	1f 89       	ldd	r17, Y+23	; 0x17
    c664:	86 e0       	ldi	r24, 0x06	; 6
    c666:	8c 83       	std	Y+4, r24	; 0x04
    c668:	09 83       	std	Y+1, r16	; 0x01
    c66a:	1a 83       	std	Y+2, r17	; 0x02
    c66c:	8f ef       	ldi	r24, 0xFF	; 255
    c66e:	9f e7       	ldi	r25, 0x7F	; 127
    c670:	8d 83       	std	Y+5, r24	; 0x05
    c672:	9e 83       	std	Y+6, r25	; 0x06
    c674:	ae 01       	movw	r20, r28
    c676:	46 5e       	subi	r20, 0xE6	; 230
    c678:	5f 4f       	sbci	r21, 0xFF	; 255
    c67a:	ce 01       	movw	r24, r28
    c67c:	01 96       	adiw	r24, 0x01	; 1
    c67e:	68 8d       	ldd	r22, Y+24	; 0x18
    c680:	79 8d       	ldd	r23, Y+25	; 0x19
    c682:	0e 94 50 63 	call	0xc6a0	; 0xc6a0 <vfprintf>
    c686:	ef 81       	ldd	r30, Y+7	; 0x07
    c688:	f8 85       	ldd	r31, Y+8	; 0x08
    c68a:	e0 0f       	add	r30, r16
    c68c:	f1 1f       	adc	r31, r17
    c68e:	10 82       	st	Z, r1
    c690:	2e 96       	adiw	r28, 0x0e	; 14
    c692:	cd bf       	out	0x3d, r28	; 61
    c694:	de bf       	out	0x3e, r29	; 62
    c696:	df 91       	pop	r29
    c698:	cf 91       	pop	r28
    c69a:	1f 91       	pop	r17
    c69c:	0f 91       	pop	r16
    c69e:	08 95       	ret

0000c6a0 <vfprintf>:
    c6a0:	2f 92       	push	r2
    c6a2:	3f 92       	push	r3
    c6a4:	4f 92       	push	r4
    c6a6:	5f 92       	push	r5
    c6a8:	6f 92       	push	r6
    c6aa:	7f 92       	push	r7
    c6ac:	8f 92       	push	r8
    c6ae:	9f 92       	push	r9
    c6b0:	af 92       	push	r10
    c6b2:	bf 92       	push	r11
    c6b4:	cf 92       	push	r12
    c6b6:	df 92       	push	r13
    c6b8:	ef 92       	push	r14
    c6ba:	ff 92       	push	r15
    c6bc:	0f 93       	push	r16
    c6be:	1f 93       	push	r17
    c6c0:	cf 93       	push	r28
    c6c2:	df 93       	push	r29
    c6c4:	cd b7       	in	r28, 0x3d	; 61
    c6c6:	de b7       	in	r29, 0x3e	; 62
    c6c8:	2d 97       	sbiw	r28, 0x0d	; 13
    c6ca:	cd bf       	out	0x3d, r28	; 61
    c6cc:	de bf       	out	0x3e, r29	; 62
    c6ce:	3c 01       	movw	r6, r24
    c6d0:	6c 87       	std	Y+12, r22	; 0x0c
    c6d2:	7d 87       	std	Y+13, r23	; 0x0d
    c6d4:	5a 01       	movw	r10, r20
    c6d6:	fc 01       	movw	r30, r24
    c6d8:	16 82       	std	Z+6, r1	; 0x06
    c6da:	17 82       	std	Z+7, r1	; 0x07
    c6dc:	83 81       	ldd	r24, Z+3	; 0x03
    c6de:	81 ff       	sbrs	r24, 1
    c6e0:	c8 c1       	rjmp	.+912    	; 0xca72 <vfprintf+0x3d2>
    c6e2:	2e 01       	movw	r4, r28
    c6e4:	08 94       	sec
    c6e6:	41 1c       	adc	r4, r1
    c6e8:	51 1c       	adc	r5, r1
    c6ea:	f3 01       	movw	r30, r6
    c6ec:	93 81       	ldd	r25, Z+3	; 0x03
    c6ee:	ec 85       	ldd	r30, Y+12	; 0x0c
    c6f0:	fd 85       	ldd	r31, Y+13	; 0x0d
    c6f2:	93 fd       	sbrc	r25, 3
    c6f4:	85 91       	lpm	r24, Z+
    c6f6:	93 ff       	sbrs	r25, 3
    c6f8:	81 91       	ld	r24, Z+
    c6fa:	ec 87       	std	Y+12, r30	; 0x0c
    c6fc:	fd 87       	std	Y+13, r31	; 0x0d
    c6fe:	88 23       	and	r24, r24
    c700:	09 f4       	brne	.+2      	; 0xc704 <vfprintf+0x64>
    c702:	b3 c1       	rjmp	.+870    	; 0xca6a <vfprintf+0x3ca>
    c704:	85 32       	cpi	r24, 0x25	; 37
    c706:	41 f4       	brne	.+16     	; 0xc718 <vfprintf+0x78>
    c708:	93 fd       	sbrc	r25, 3
    c70a:	85 91       	lpm	r24, Z+
    c70c:	93 ff       	sbrs	r25, 3
    c70e:	81 91       	ld	r24, Z+
    c710:	ec 87       	std	Y+12, r30	; 0x0c
    c712:	fd 87       	std	Y+13, r31	; 0x0d
    c714:	85 32       	cpi	r24, 0x25	; 37
    c716:	29 f4       	brne	.+10     	; 0xc722 <vfprintf+0x82>
    c718:	90 e0       	ldi	r25, 0x00	; 0
    c71a:	b3 01       	movw	r22, r6
    c71c:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    c720:	e4 cf       	rjmp	.-56     	; 0xc6ea <vfprintf+0x4a>
    c722:	ff 24       	eor	r15, r15
    c724:	ee 24       	eor	r14, r14
    c726:	10 e0       	ldi	r17, 0x00	; 0
    c728:	10 32       	cpi	r17, 0x20	; 32
    c72a:	b0 f4       	brcc	.+44     	; 0xc758 <vfprintf+0xb8>
    c72c:	8b 32       	cpi	r24, 0x2B	; 43
    c72e:	69 f0       	breq	.+26     	; 0xc74a <vfprintf+0xaa>
    c730:	8c 32       	cpi	r24, 0x2C	; 44
    c732:	28 f4       	brcc	.+10     	; 0xc73e <vfprintf+0x9e>
    c734:	80 32       	cpi	r24, 0x20	; 32
    c736:	51 f0       	breq	.+20     	; 0xc74c <vfprintf+0xac>
    c738:	83 32       	cpi	r24, 0x23	; 35
    c73a:	71 f4       	brne	.+28     	; 0xc758 <vfprintf+0xb8>
    c73c:	0b c0       	rjmp	.+22     	; 0xc754 <vfprintf+0xb4>
    c73e:	8d 32       	cpi	r24, 0x2D	; 45
    c740:	39 f0       	breq	.+14     	; 0xc750 <vfprintf+0xb0>
    c742:	80 33       	cpi	r24, 0x30	; 48
    c744:	49 f4       	brne	.+18     	; 0xc758 <vfprintf+0xb8>
    c746:	11 60       	ori	r17, 0x01	; 1
    c748:	2c c0       	rjmp	.+88     	; 0xc7a2 <vfprintf+0x102>
    c74a:	12 60       	ori	r17, 0x02	; 2
    c74c:	14 60       	ori	r17, 0x04	; 4
    c74e:	29 c0       	rjmp	.+82     	; 0xc7a2 <vfprintf+0x102>
    c750:	18 60       	ori	r17, 0x08	; 8
    c752:	27 c0       	rjmp	.+78     	; 0xc7a2 <vfprintf+0x102>
    c754:	10 61       	ori	r17, 0x10	; 16
    c756:	25 c0       	rjmp	.+74     	; 0xc7a2 <vfprintf+0x102>
    c758:	17 fd       	sbrc	r17, 7
    c75a:	2e c0       	rjmp	.+92     	; 0xc7b8 <vfprintf+0x118>
    c75c:	28 2f       	mov	r18, r24
    c75e:	20 53       	subi	r18, 0x30	; 48
    c760:	2a 30       	cpi	r18, 0x0A	; 10
    c762:	98 f4       	brcc	.+38     	; 0xc78a <vfprintf+0xea>
    c764:	16 ff       	sbrs	r17, 6
    c766:	08 c0       	rjmp	.+16     	; 0xc778 <vfprintf+0xd8>
    c768:	8f 2d       	mov	r24, r15
    c76a:	88 0f       	add	r24, r24
    c76c:	f8 2e       	mov	r15, r24
    c76e:	ff 0c       	add	r15, r15
    c770:	ff 0c       	add	r15, r15
    c772:	f8 0e       	add	r15, r24
    c774:	f2 0e       	add	r15, r18
    c776:	15 c0       	rjmp	.+42     	; 0xc7a2 <vfprintf+0x102>
    c778:	8e 2d       	mov	r24, r14
    c77a:	88 0f       	add	r24, r24
    c77c:	e8 2e       	mov	r14, r24
    c77e:	ee 0c       	add	r14, r14
    c780:	ee 0c       	add	r14, r14
    c782:	e8 0e       	add	r14, r24
    c784:	e2 0e       	add	r14, r18
    c786:	10 62       	ori	r17, 0x20	; 32
    c788:	0c c0       	rjmp	.+24     	; 0xc7a2 <vfprintf+0x102>
    c78a:	8e 32       	cpi	r24, 0x2E	; 46
    c78c:	21 f4       	brne	.+8      	; 0xc796 <vfprintf+0xf6>
    c78e:	16 fd       	sbrc	r17, 6
    c790:	6c c1       	rjmp	.+728    	; 0xca6a <vfprintf+0x3ca>
    c792:	10 64       	ori	r17, 0x40	; 64
    c794:	06 c0       	rjmp	.+12     	; 0xc7a2 <vfprintf+0x102>
    c796:	8c 36       	cpi	r24, 0x6C	; 108
    c798:	11 f4       	brne	.+4      	; 0xc79e <vfprintf+0xfe>
    c79a:	10 68       	ori	r17, 0x80	; 128
    c79c:	02 c0       	rjmp	.+4      	; 0xc7a2 <vfprintf+0x102>
    c79e:	88 36       	cpi	r24, 0x68	; 104
    c7a0:	59 f4       	brne	.+22     	; 0xc7b8 <vfprintf+0x118>
    c7a2:	ec 85       	ldd	r30, Y+12	; 0x0c
    c7a4:	fd 85       	ldd	r31, Y+13	; 0x0d
    c7a6:	93 fd       	sbrc	r25, 3
    c7a8:	85 91       	lpm	r24, Z+
    c7aa:	93 ff       	sbrs	r25, 3
    c7ac:	81 91       	ld	r24, Z+
    c7ae:	ec 87       	std	Y+12, r30	; 0x0c
    c7b0:	fd 87       	std	Y+13, r31	; 0x0d
    c7b2:	88 23       	and	r24, r24
    c7b4:	09 f0       	breq	.+2      	; 0xc7b8 <vfprintf+0x118>
    c7b6:	b8 cf       	rjmp	.-144    	; 0xc728 <vfprintf+0x88>
    c7b8:	98 2f       	mov	r25, r24
    c7ba:	95 54       	subi	r25, 0x45	; 69
    c7bc:	93 30       	cpi	r25, 0x03	; 3
    c7be:	18 f0       	brcs	.+6      	; 0xc7c6 <vfprintf+0x126>
    c7c0:	90 52       	subi	r25, 0x20	; 32
    c7c2:	93 30       	cpi	r25, 0x03	; 3
    c7c4:	38 f4       	brcc	.+14     	; 0xc7d4 <vfprintf+0x134>
    c7c6:	24 e0       	ldi	r18, 0x04	; 4
    c7c8:	30 e0       	ldi	r19, 0x00	; 0
    c7ca:	a2 0e       	add	r10, r18
    c7cc:	b3 1e       	adc	r11, r19
    c7ce:	3f e3       	ldi	r19, 0x3F	; 63
    c7d0:	39 83       	std	Y+1, r19	; 0x01
    c7d2:	0f c0       	rjmp	.+30     	; 0xc7f2 <vfprintf+0x152>
    c7d4:	83 36       	cpi	r24, 0x63	; 99
    c7d6:	31 f0       	breq	.+12     	; 0xc7e4 <vfprintf+0x144>
    c7d8:	83 37       	cpi	r24, 0x73	; 115
    c7da:	81 f0       	breq	.+32     	; 0xc7fc <vfprintf+0x15c>
    c7dc:	83 35       	cpi	r24, 0x53	; 83
    c7de:	09 f0       	breq	.+2      	; 0xc7e2 <vfprintf+0x142>
    c7e0:	5a c0       	rjmp	.+180    	; 0xc896 <vfprintf+0x1f6>
    c7e2:	22 c0       	rjmp	.+68     	; 0xc828 <vfprintf+0x188>
    c7e4:	f5 01       	movw	r30, r10
    c7e6:	80 81       	ld	r24, Z
    c7e8:	89 83       	std	Y+1, r24	; 0x01
    c7ea:	22 e0       	ldi	r18, 0x02	; 2
    c7ec:	30 e0       	ldi	r19, 0x00	; 0
    c7ee:	a2 0e       	add	r10, r18
    c7f0:	b3 1e       	adc	r11, r19
    c7f2:	21 e0       	ldi	r18, 0x01	; 1
    c7f4:	c2 2e       	mov	r12, r18
    c7f6:	d1 2c       	mov	r13, r1
    c7f8:	42 01       	movw	r8, r4
    c7fa:	14 c0       	rjmp	.+40     	; 0xc824 <vfprintf+0x184>
    c7fc:	92 e0       	ldi	r25, 0x02	; 2
    c7fe:	29 2e       	mov	r2, r25
    c800:	31 2c       	mov	r3, r1
    c802:	2a 0c       	add	r2, r10
    c804:	3b 1c       	adc	r3, r11
    c806:	f5 01       	movw	r30, r10
    c808:	80 80       	ld	r8, Z
    c80a:	91 80       	ldd	r9, Z+1	; 0x01
    c80c:	16 ff       	sbrs	r17, 6
    c80e:	03 c0       	rjmp	.+6      	; 0xc816 <vfprintf+0x176>
    c810:	6f 2d       	mov	r22, r15
    c812:	70 e0       	ldi	r23, 0x00	; 0
    c814:	02 c0       	rjmp	.+4      	; 0xc81a <vfprintf+0x17a>
    c816:	6f ef       	ldi	r22, 0xFF	; 255
    c818:	7f ef       	ldi	r23, 0xFF	; 255
    c81a:	c4 01       	movw	r24, r8
    c81c:	0e 94 5c 65 	call	0xcab8	; 0xcab8 <strnlen>
    c820:	6c 01       	movw	r12, r24
    c822:	51 01       	movw	r10, r2
    c824:	1f 77       	andi	r17, 0x7F	; 127
    c826:	15 c0       	rjmp	.+42     	; 0xc852 <vfprintf+0x1b2>
    c828:	82 e0       	ldi	r24, 0x02	; 2
    c82a:	28 2e       	mov	r2, r24
    c82c:	31 2c       	mov	r3, r1
    c82e:	2a 0c       	add	r2, r10
    c830:	3b 1c       	adc	r3, r11
    c832:	f5 01       	movw	r30, r10
    c834:	80 80       	ld	r8, Z
    c836:	91 80       	ldd	r9, Z+1	; 0x01
    c838:	16 ff       	sbrs	r17, 6
    c83a:	03 c0       	rjmp	.+6      	; 0xc842 <vfprintf+0x1a2>
    c83c:	6f 2d       	mov	r22, r15
    c83e:	70 e0       	ldi	r23, 0x00	; 0
    c840:	02 c0       	rjmp	.+4      	; 0xc846 <vfprintf+0x1a6>
    c842:	6f ef       	ldi	r22, 0xFF	; 255
    c844:	7f ef       	ldi	r23, 0xFF	; 255
    c846:	c4 01       	movw	r24, r8
    c848:	0e 94 51 65 	call	0xcaa2	; 0xcaa2 <strnlen_P>
    c84c:	6c 01       	movw	r12, r24
    c84e:	10 68       	ori	r17, 0x80	; 128
    c850:	51 01       	movw	r10, r2
    c852:	13 fd       	sbrc	r17, 3
    c854:	1c c0       	rjmp	.+56     	; 0xc88e <vfprintf+0x1ee>
    c856:	06 c0       	rjmp	.+12     	; 0xc864 <vfprintf+0x1c4>
    c858:	80 e2       	ldi	r24, 0x20	; 32
    c85a:	90 e0       	ldi	r25, 0x00	; 0
    c85c:	b3 01       	movw	r22, r6
    c85e:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    c862:	ea 94       	dec	r14
    c864:	8e 2d       	mov	r24, r14
    c866:	90 e0       	ldi	r25, 0x00	; 0
    c868:	c8 16       	cp	r12, r24
    c86a:	d9 06       	cpc	r13, r25
    c86c:	a8 f3       	brcs	.-22     	; 0xc858 <vfprintf+0x1b8>
    c86e:	0f c0       	rjmp	.+30     	; 0xc88e <vfprintf+0x1ee>
    c870:	f4 01       	movw	r30, r8
    c872:	17 fd       	sbrc	r17, 7
    c874:	85 91       	lpm	r24, Z+
    c876:	17 ff       	sbrs	r17, 7
    c878:	81 91       	ld	r24, Z+
    c87a:	4f 01       	movw	r8, r30
    c87c:	90 e0       	ldi	r25, 0x00	; 0
    c87e:	b3 01       	movw	r22, r6
    c880:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    c884:	e1 10       	cpse	r14, r1
    c886:	ea 94       	dec	r14
    c888:	08 94       	sec
    c88a:	c1 08       	sbc	r12, r1
    c88c:	d1 08       	sbc	r13, r1
    c88e:	c1 14       	cp	r12, r1
    c890:	d1 04       	cpc	r13, r1
    c892:	71 f7       	brne	.-36     	; 0xc870 <vfprintf+0x1d0>
    c894:	e7 c0       	rjmp	.+462    	; 0xca64 <vfprintf+0x3c4>
    c896:	84 36       	cpi	r24, 0x64	; 100
    c898:	11 f0       	breq	.+4      	; 0xc89e <vfprintf+0x1fe>
    c89a:	89 36       	cpi	r24, 0x69	; 105
    c89c:	51 f5       	brne	.+84     	; 0xc8f2 <vfprintf+0x252>
    c89e:	f5 01       	movw	r30, r10
    c8a0:	17 ff       	sbrs	r17, 7
    c8a2:	07 c0       	rjmp	.+14     	; 0xc8b2 <vfprintf+0x212>
    c8a4:	80 81       	ld	r24, Z
    c8a6:	91 81       	ldd	r25, Z+1	; 0x01
    c8a8:	a2 81       	ldd	r26, Z+2	; 0x02
    c8aa:	b3 81       	ldd	r27, Z+3	; 0x03
    c8ac:	24 e0       	ldi	r18, 0x04	; 4
    c8ae:	30 e0       	ldi	r19, 0x00	; 0
    c8b0:	08 c0       	rjmp	.+16     	; 0xc8c2 <vfprintf+0x222>
    c8b2:	80 81       	ld	r24, Z
    c8b4:	91 81       	ldd	r25, Z+1	; 0x01
    c8b6:	aa 27       	eor	r26, r26
    c8b8:	97 fd       	sbrc	r25, 7
    c8ba:	a0 95       	com	r26
    c8bc:	ba 2f       	mov	r27, r26
    c8be:	22 e0       	ldi	r18, 0x02	; 2
    c8c0:	30 e0       	ldi	r19, 0x00	; 0
    c8c2:	a2 0e       	add	r10, r18
    c8c4:	b3 1e       	adc	r11, r19
    c8c6:	01 2f       	mov	r16, r17
    c8c8:	0f 76       	andi	r16, 0x6F	; 111
    c8ca:	b7 ff       	sbrs	r27, 7
    c8cc:	08 c0       	rjmp	.+16     	; 0xc8de <vfprintf+0x23e>
    c8ce:	b0 95       	com	r27
    c8d0:	a0 95       	com	r26
    c8d2:	90 95       	com	r25
    c8d4:	81 95       	neg	r24
    c8d6:	9f 4f       	sbci	r25, 0xFF	; 255
    c8d8:	af 4f       	sbci	r26, 0xFF	; 255
    c8da:	bf 4f       	sbci	r27, 0xFF	; 255
    c8dc:	00 68       	ori	r16, 0x80	; 128
    c8de:	bc 01       	movw	r22, r24
    c8e0:	cd 01       	movw	r24, r26
    c8e2:	a2 01       	movw	r20, r4
    c8e4:	2a e0       	ldi	r18, 0x0A	; 10
    c8e6:	30 e0       	ldi	r19, 0x00	; 0
    c8e8:	0e 94 a3 65 	call	0xcb46	; 0xcb46 <__ultoa_invert>
    c8ec:	d8 2e       	mov	r13, r24
    c8ee:	d4 18       	sub	r13, r4
    c8f0:	3f c0       	rjmp	.+126    	; 0xc970 <vfprintf+0x2d0>
    c8f2:	85 37       	cpi	r24, 0x75	; 117
    c8f4:	21 f4       	brne	.+8      	; 0xc8fe <vfprintf+0x25e>
    c8f6:	1f 7e       	andi	r17, 0xEF	; 239
    c8f8:	2a e0       	ldi	r18, 0x0A	; 10
    c8fa:	30 e0       	ldi	r19, 0x00	; 0
    c8fc:	20 c0       	rjmp	.+64     	; 0xc93e <vfprintf+0x29e>
    c8fe:	19 7f       	andi	r17, 0xF9	; 249
    c900:	8f 36       	cpi	r24, 0x6F	; 111
    c902:	a9 f0       	breq	.+42     	; 0xc92e <vfprintf+0x28e>
    c904:	80 37       	cpi	r24, 0x70	; 112
    c906:	20 f4       	brcc	.+8      	; 0xc910 <vfprintf+0x270>
    c908:	88 35       	cpi	r24, 0x58	; 88
    c90a:	09 f0       	breq	.+2      	; 0xc90e <vfprintf+0x26e>
    c90c:	ae c0       	rjmp	.+348    	; 0xca6a <vfprintf+0x3ca>
    c90e:	0b c0       	rjmp	.+22     	; 0xc926 <vfprintf+0x286>
    c910:	80 37       	cpi	r24, 0x70	; 112
    c912:	21 f0       	breq	.+8      	; 0xc91c <vfprintf+0x27c>
    c914:	88 37       	cpi	r24, 0x78	; 120
    c916:	09 f0       	breq	.+2      	; 0xc91a <vfprintf+0x27a>
    c918:	a8 c0       	rjmp	.+336    	; 0xca6a <vfprintf+0x3ca>
    c91a:	01 c0       	rjmp	.+2      	; 0xc91e <vfprintf+0x27e>
    c91c:	10 61       	ori	r17, 0x10	; 16
    c91e:	14 ff       	sbrs	r17, 4
    c920:	09 c0       	rjmp	.+18     	; 0xc934 <vfprintf+0x294>
    c922:	14 60       	ori	r17, 0x04	; 4
    c924:	07 c0       	rjmp	.+14     	; 0xc934 <vfprintf+0x294>
    c926:	14 ff       	sbrs	r17, 4
    c928:	08 c0       	rjmp	.+16     	; 0xc93a <vfprintf+0x29a>
    c92a:	16 60       	ori	r17, 0x06	; 6
    c92c:	06 c0       	rjmp	.+12     	; 0xc93a <vfprintf+0x29a>
    c92e:	28 e0       	ldi	r18, 0x08	; 8
    c930:	30 e0       	ldi	r19, 0x00	; 0
    c932:	05 c0       	rjmp	.+10     	; 0xc93e <vfprintf+0x29e>
    c934:	20 e1       	ldi	r18, 0x10	; 16
    c936:	30 e0       	ldi	r19, 0x00	; 0
    c938:	02 c0       	rjmp	.+4      	; 0xc93e <vfprintf+0x29e>
    c93a:	20 e1       	ldi	r18, 0x10	; 16
    c93c:	32 e0       	ldi	r19, 0x02	; 2
    c93e:	f5 01       	movw	r30, r10
    c940:	17 ff       	sbrs	r17, 7
    c942:	07 c0       	rjmp	.+14     	; 0xc952 <vfprintf+0x2b2>
    c944:	60 81       	ld	r22, Z
    c946:	71 81       	ldd	r23, Z+1	; 0x01
    c948:	82 81       	ldd	r24, Z+2	; 0x02
    c94a:	93 81       	ldd	r25, Z+3	; 0x03
    c94c:	44 e0       	ldi	r20, 0x04	; 4
    c94e:	50 e0       	ldi	r21, 0x00	; 0
    c950:	06 c0       	rjmp	.+12     	; 0xc95e <vfprintf+0x2be>
    c952:	60 81       	ld	r22, Z
    c954:	71 81       	ldd	r23, Z+1	; 0x01
    c956:	80 e0       	ldi	r24, 0x00	; 0
    c958:	90 e0       	ldi	r25, 0x00	; 0
    c95a:	42 e0       	ldi	r20, 0x02	; 2
    c95c:	50 e0       	ldi	r21, 0x00	; 0
    c95e:	a4 0e       	add	r10, r20
    c960:	b5 1e       	adc	r11, r21
    c962:	a2 01       	movw	r20, r4
    c964:	0e 94 a3 65 	call	0xcb46	; 0xcb46 <__ultoa_invert>
    c968:	d8 2e       	mov	r13, r24
    c96a:	d4 18       	sub	r13, r4
    c96c:	01 2f       	mov	r16, r17
    c96e:	0f 77       	andi	r16, 0x7F	; 127
    c970:	06 ff       	sbrs	r16, 6
    c972:	09 c0       	rjmp	.+18     	; 0xc986 <vfprintf+0x2e6>
    c974:	0e 7f       	andi	r16, 0xFE	; 254
    c976:	df 14       	cp	r13, r15
    c978:	30 f4       	brcc	.+12     	; 0xc986 <vfprintf+0x2e6>
    c97a:	04 ff       	sbrs	r16, 4
    c97c:	06 c0       	rjmp	.+12     	; 0xc98a <vfprintf+0x2ea>
    c97e:	02 fd       	sbrc	r16, 2
    c980:	04 c0       	rjmp	.+8      	; 0xc98a <vfprintf+0x2ea>
    c982:	0f 7e       	andi	r16, 0xEF	; 239
    c984:	02 c0       	rjmp	.+4      	; 0xc98a <vfprintf+0x2ea>
    c986:	1d 2d       	mov	r17, r13
    c988:	01 c0       	rjmp	.+2      	; 0xc98c <vfprintf+0x2ec>
    c98a:	1f 2d       	mov	r17, r15
    c98c:	80 2f       	mov	r24, r16
    c98e:	90 e0       	ldi	r25, 0x00	; 0
    c990:	04 ff       	sbrs	r16, 4
    c992:	0c c0       	rjmp	.+24     	; 0xc9ac <vfprintf+0x30c>
    c994:	fe 01       	movw	r30, r28
    c996:	ed 0d       	add	r30, r13
    c998:	f1 1d       	adc	r31, r1
    c99a:	20 81       	ld	r18, Z
    c99c:	20 33       	cpi	r18, 0x30	; 48
    c99e:	11 f4       	brne	.+4      	; 0xc9a4 <vfprintf+0x304>
    c9a0:	09 7e       	andi	r16, 0xE9	; 233
    c9a2:	09 c0       	rjmp	.+18     	; 0xc9b6 <vfprintf+0x316>
    c9a4:	02 ff       	sbrs	r16, 2
    c9a6:	06 c0       	rjmp	.+12     	; 0xc9b4 <vfprintf+0x314>
    c9a8:	1e 5f       	subi	r17, 0xFE	; 254
    c9aa:	05 c0       	rjmp	.+10     	; 0xc9b6 <vfprintf+0x316>
    c9ac:	86 78       	andi	r24, 0x86	; 134
    c9ae:	90 70       	andi	r25, 0x00	; 0
    c9b0:	00 97       	sbiw	r24, 0x00	; 0
    c9b2:	09 f0       	breq	.+2      	; 0xc9b6 <vfprintf+0x316>
    c9b4:	1f 5f       	subi	r17, 0xFF	; 255
    c9b6:	80 2e       	mov	r8, r16
    c9b8:	99 24       	eor	r9, r9
    c9ba:	03 fd       	sbrc	r16, 3
    c9bc:	12 c0       	rjmp	.+36     	; 0xc9e2 <vfprintf+0x342>
    c9be:	00 ff       	sbrs	r16, 0
    c9c0:	0d c0       	rjmp	.+26     	; 0xc9dc <vfprintf+0x33c>
    c9c2:	fd 2c       	mov	r15, r13
    c9c4:	1e 15       	cp	r17, r14
    c9c6:	50 f4       	brcc	.+20     	; 0xc9dc <vfprintf+0x33c>
    c9c8:	fe 0c       	add	r15, r14
    c9ca:	f1 1a       	sub	r15, r17
    c9cc:	1e 2d       	mov	r17, r14
    c9ce:	06 c0       	rjmp	.+12     	; 0xc9dc <vfprintf+0x33c>
    c9d0:	80 e2       	ldi	r24, 0x20	; 32
    c9d2:	90 e0       	ldi	r25, 0x00	; 0
    c9d4:	b3 01       	movw	r22, r6
    c9d6:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    c9da:	1f 5f       	subi	r17, 0xFF	; 255
    c9dc:	1e 15       	cp	r17, r14
    c9de:	c0 f3       	brcs	.-16     	; 0xc9d0 <vfprintf+0x330>
    c9e0:	04 c0       	rjmp	.+8      	; 0xc9ea <vfprintf+0x34a>
    c9e2:	1e 15       	cp	r17, r14
    c9e4:	10 f4       	brcc	.+4      	; 0xc9ea <vfprintf+0x34a>
    c9e6:	e1 1a       	sub	r14, r17
    c9e8:	01 c0       	rjmp	.+2      	; 0xc9ec <vfprintf+0x34c>
    c9ea:	ee 24       	eor	r14, r14
    c9ec:	84 fe       	sbrs	r8, 4
    c9ee:	0f c0       	rjmp	.+30     	; 0xca0e <vfprintf+0x36e>
    c9f0:	80 e3       	ldi	r24, 0x30	; 48
    c9f2:	90 e0       	ldi	r25, 0x00	; 0
    c9f4:	b3 01       	movw	r22, r6
    c9f6:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    c9fa:	82 fe       	sbrs	r8, 2
    c9fc:	1f c0       	rjmp	.+62     	; 0xca3c <vfprintf+0x39c>
    c9fe:	81 fe       	sbrs	r8, 1
    ca00:	03 c0       	rjmp	.+6      	; 0xca08 <vfprintf+0x368>
    ca02:	88 e5       	ldi	r24, 0x58	; 88
    ca04:	90 e0       	ldi	r25, 0x00	; 0
    ca06:	10 c0       	rjmp	.+32     	; 0xca28 <vfprintf+0x388>
    ca08:	88 e7       	ldi	r24, 0x78	; 120
    ca0a:	90 e0       	ldi	r25, 0x00	; 0
    ca0c:	0d c0       	rjmp	.+26     	; 0xca28 <vfprintf+0x388>
    ca0e:	c4 01       	movw	r24, r8
    ca10:	86 78       	andi	r24, 0x86	; 134
    ca12:	90 70       	andi	r25, 0x00	; 0
    ca14:	00 97       	sbiw	r24, 0x00	; 0
    ca16:	91 f0       	breq	.+36     	; 0xca3c <vfprintf+0x39c>
    ca18:	81 fc       	sbrc	r8, 1
    ca1a:	02 c0       	rjmp	.+4      	; 0xca20 <vfprintf+0x380>
    ca1c:	80 e2       	ldi	r24, 0x20	; 32
    ca1e:	01 c0       	rjmp	.+2      	; 0xca22 <vfprintf+0x382>
    ca20:	8b e2       	ldi	r24, 0x2B	; 43
    ca22:	07 fd       	sbrc	r16, 7
    ca24:	8d e2       	ldi	r24, 0x2D	; 45
    ca26:	90 e0       	ldi	r25, 0x00	; 0
    ca28:	b3 01       	movw	r22, r6
    ca2a:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    ca2e:	06 c0       	rjmp	.+12     	; 0xca3c <vfprintf+0x39c>
    ca30:	80 e3       	ldi	r24, 0x30	; 48
    ca32:	90 e0       	ldi	r25, 0x00	; 0
    ca34:	b3 01       	movw	r22, r6
    ca36:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    ca3a:	fa 94       	dec	r15
    ca3c:	df 14       	cp	r13, r15
    ca3e:	c0 f3       	brcs	.-16     	; 0xca30 <vfprintf+0x390>
    ca40:	da 94       	dec	r13
    ca42:	f2 01       	movw	r30, r4
    ca44:	ed 0d       	add	r30, r13
    ca46:	f1 1d       	adc	r31, r1
    ca48:	80 81       	ld	r24, Z
    ca4a:	90 e0       	ldi	r25, 0x00	; 0
    ca4c:	b3 01       	movw	r22, r6
    ca4e:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    ca52:	dd 20       	and	r13, r13
    ca54:	a9 f7       	brne	.-22     	; 0xca40 <vfprintf+0x3a0>
    ca56:	06 c0       	rjmp	.+12     	; 0xca64 <vfprintf+0x3c4>
    ca58:	80 e2       	ldi	r24, 0x20	; 32
    ca5a:	90 e0       	ldi	r25, 0x00	; 0
    ca5c:	b3 01       	movw	r22, r6
    ca5e:	0e 94 77 65 	call	0xcaee	; 0xcaee <fputc>
    ca62:	ea 94       	dec	r14
    ca64:	ee 20       	and	r14, r14
    ca66:	c1 f7       	brne	.-16     	; 0xca58 <vfprintf+0x3b8>
    ca68:	40 ce       	rjmp	.-896    	; 0xc6ea <vfprintf+0x4a>
    ca6a:	f3 01       	movw	r30, r6
    ca6c:	86 81       	ldd	r24, Z+6	; 0x06
    ca6e:	97 81       	ldd	r25, Z+7	; 0x07
    ca70:	02 c0       	rjmp	.+4      	; 0xca76 <vfprintf+0x3d6>
    ca72:	8f ef       	ldi	r24, 0xFF	; 255
    ca74:	9f ef       	ldi	r25, 0xFF	; 255
    ca76:	2d 96       	adiw	r28, 0x0d	; 13
    ca78:	cd bf       	out	0x3d, r28	; 61
    ca7a:	de bf       	out	0x3e, r29	; 62
    ca7c:	df 91       	pop	r29
    ca7e:	cf 91       	pop	r28
    ca80:	1f 91       	pop	r17
    ca82:	0f 91       	pop	r16
    ca84:	ff 90       	pop	r15
    ca86:	ef 90       	pop	r14
    ca88:	df 90       	pop	r13
    ca8a:	cf 90       	pop	r12
    ca8c:	bf 90       	pop	r11
    ca8e:	af 90       	pop	r10
    ca90:	9f 90       	pop	r9
    ca92:	8f 90       	pop	r8
    ca94:	7f 90       	pop	r7
    ca96:	6f 90       	pop	r6
    ca98:	5f 90       	pop	r5
    ca9a:	4f 90       	pop	r4
    ca9c:	3f 90       	pop	r3
    ca9e:	2f 90       	pop	r2
    caa0:	08 95       	ret

0000caa2 <strnlen_P>:
    caa2:	fc 01       	movw	r30, r24
    caa4:	05 90       	lpm	r0, Z+
    caa6:	61 50       	subi	r22, 0x01	; 1
    caa8:	70 40       	sbci	r23, 0x00	; 0
    caaa:	01 10       	cpse	r0, r1
    caac:	d8 f7       	brcc	.-10     	; 0xcaa4 <strnlen_P+0x2>
    caae:	80 95       	com	r24
    cab0:	90 95       	com	r25
    cab2:	8e 0f       	add	r24, r30
    cab4:	9f 1f       	adc	r25, r31
    cab6:	08 95       	ret

0000cab8 <strnlen>:
    cab8:	fc 01       	movw	r30, r24
    caba:	61 50       	subi	r22, 0x01	; 1
    cabc:	70 40       	sbci	r23, 0x00	; 0
    cabe:	01 90       	ld	r0, Z+
    cac0:	01 10       	cpse	r0, r1
    cac2:	d8 f7       	brcc	.-10     	; 0xcaba <strnlen+0x2>
    cac4:	80 95       	com	r24
    cac6:	90 95       	com	r25
    cac8:	8e 0f       	add	r24, r30
    caca:	9f 1f       	adc	r25, r31
    cacc:	08 95       	ret

0000cace <strrev>:
    cace:	dc 01       	movw	r26, r24
    cad0:	fc 01       	movw	r30, r24
    cad2:	67 2f       	mov	r22, r23
    cad4:	71 91       	ld	r23, Z+
    cad6:	77 23       	and	r23, r23
    cad8:	e1 f7       	brne	.-8      	; 0xcad2 <strrev+0x4>
    cada:	32 97       	sbiw	r30, 0x02	; 2
    cadc:	04 c0       	rjmp	.+8      	; 0xcae6 <strrev+0x18>
    cade:	7c 91       	ld	r23, X
    cae0:	6d 93       	st	X+, r22
    cae2:	70 83       	st	Z, r23
    cae4:	62 91       	ld	r22, -Z
    cae6:	ae 17       	cp	r26, r30
    cae8:	bf 07       	cpc	r27, r31
    caea:	c8 f3       	brcs	.-14     	; 0xcade <strrev+0x10>
    caec:	08 95       	ret

0000caee <fputc>:
    caee:	0f 93       	push	r16
    caf0:	1f 93       	push	r17
    caf2:	cf 93       	push	r28
    caf4:	df 93       	push	r29
    caf6:	8c 01       	movw	r16, r24
    caf8:	eb 01       	movw	r28, r22
    cafa:	8b 81       	ldd	r24, Y+3	; 0x03
    cafc:	81 ff       	sbrs	r24, 1
    cafe:	1b c0       	rjmp	.+54     	; 0xcb36 <fputc+0x48>
    cb00:	82 ff       	sbrs	r24, 2
    cb02:	0d c0       	rjmp	.+26     	; 0xcb1e <fputc+0x30>
    cb04:	2e 81       	ldd	r18, Y+6	; 0x06
    cb06:	3f 81       	ldd	r19, Y+7	; 0x07
    cb08:	8c 81       	ldd	r24, Y+4	; 0x04
    cb0a:	9d 81       	ldd	r25, Y+5	; 0x05
    cb0c:	28 17       	cp	r18, r24
    cb0e:	39 07       	cpc	r19, r25
    cb10:	64 f4       	brge	.+24     	; 0xcb2a <fputc+0x3c>
    cb12:	e8 81       	ld	r30, Y
    cb14:	f9 81       	ldd	r31, Y+1	; 0x01
    cb16:	01 93       	st	Z+, r16
    cb18:	e8 83       	st	Y, r30
    cb1a:	f9 83       	std	Y+1, r31	; 0x01
    cb1c:	06 c0       	rjmp	.+12     	; 0xcb2a <fputc+0x3c>
    cb1e:	e8 85       	ldd	r30, Y+8	; 0x08
    cb20:	f9 85       	ldd	r31, Y+9	; 0x09
    cb22:	80 2f       	mov	r24, r16
    cb24:	19 95       	eicall
    cb26:	00 97       	sbiw	r24, 0x00	; 0
    cb28:	31 f4       	brne	.+12     	; 0xcb36 <fputc+0x48>
    cb2a:	8e 81       	ldd	r24, Y+6	; 0x06
    cb2c:	9f 81       	ldd	r25, Y+7	; 0x07
    cb2e:	01 96       	adiw	r24, 0x01	; 1
    cb30:	8e 83       	std	Y+6, r24	; 0x06
    cb32:	9f 83       	std	Y+7, r25	; 0x07
    cb34:	02 c0       	rjmp	.+4      	; 0xcb3a <fputc+0x4c>
    cb36:	0f ef       	ldi	r16, 0xFF	; 255
    cb38:	1f ef       	ldi	r17, 0xFF	; 255
    cb3a:	c8 01       	movw	r24, r16
    cb3c:	df 91       	pop	r29
    cb3e:	cf 91       	pop	r28
    cb40:	1f 91       	pop	r17
    cb42:	0f 91       	pop	r16
    cb44:	08 95       	ret

0000cb46 <__ultoa_invert>:
    cb46:	fa 01       	movw	r30, r20
    cb48:	aa 27       	eor	r26, r26
    cb4a:	28 30       	cpi	r18, 0x08	; 8
    cb4c:	51 f1       	breq	.+84     	; 0xcba2 <__ultoa_invert+0x5c>
    cb4e:	20 31       	cpi	r18, 0x10	; 16
    cb50:	81 f1       	breq	.+96     	; 0xcbb2 <__ultoa_invert+0x6c>
    cb52:	e8 94       	clt
    cb54:	6f 93       	push	r22
    cb56:	6e 7f       	andi	r22, 0xFE	; 254
    cb58:	6e 5f       	subi	r22, 0xFE	; 254
    cb5a:	7f 4f       	sbci	r23, 0xFF	; 255
    cb5c:	8f 4f       	sbci	r24, 0xFF	; 255
    cb5e:	9f 4f       	sbci	r25, 0xFF	; 255
    cb60:	af 4f       	sbci	r26, 0xFF	; 255
    cb62:	b1 e0       	ldi	r27, 0x01	; 1
    cb64:	3e d0       	rcall	.+124    	; 0xcbe2 <__ultoa_invert+0x9c>
    cb66:	b4 e0       	ldi	r27, 0x04	; 4
    cb68:	3c d0       	rcall	.+120    	; 0xcbe2 <__ultoa_invert+0x9c>
    cb6a:	67 0f       	add	r22, r23
    cb6c:	78 1f       	adc	r23, r24
    cb6e:	89 1f       	adc	r24, r25
    cb70:	9a 1f       	adc	r25, r26
    cb72:	a1 1d       	adc	r26, r1
    cb74:	68 0f       	add	r22, r24
    cb76:	79 1f       	adc	r23, r25
    cb78:	8a 1f       	adc	r24, r26
    cb7a:	91 1d       	adc	r25, r1
    cb7c:	a1 1d       	adc	r26, r1
    cb7e:	6a 0f       	add	r22, r26
    cb80:	71 1d       	adc	r23, r1
    cb82:	81 1d       	adc	r24, r1
    cb84:	91 1d       	adc	r25, r1
    cb86:	a1 1d       	adc	r26, r1
    cb88:	20 d0       	rcall	.+64     	; 0xcbca <__ultoa_invert+0x84>
    cb8a:	09 f4       	brne	.+2      	; 0xcb8e <__ultoa_invert+0x48>
    cb8c:	68 94       	set
    cb8e:	3f 91       	pop	r19
    cb90:	2a e0       	ldi	r18, 0x0A	; 10
    cb92:	26 9f       	mul	r18, r22
    cb94:	11 24       	eor	r1, r1
    cb96:	30 19       	sub	r19, r0
    cb98:	30 5d       	subi	r19, 0xD0	; 208
    cb9a:	31 93       	st	Z+, r19
    cb9c:	de f6       	brtc	.-74     	; 0xcb54 <__ultoa_invert+0xe>
    cb9e:	cf 01       	movw	r24, r30
    cba0:	08 95       	ret
    cba2:	46 2f       	mov	r20, r22
    cba4:	47 70       	andi	r20, 0x07	; 7
    cba6:	40 5d       	subi	r20, 0xD0	; 208
    cba8:	41 93       	st	Z+, r20
    cbaa:	b3 e0       	ldi	r27, 0x03	; 3
    cbac:	0f d0       	rcall	.+30     	; 0xcbcc <__ultoa_invert+0x86>
    cbae:	c9 f7       	brne	.-14     	; 0xcba2 <__ultoa_invert+0x5c>
    cbb0:	f6 cf       	rjmp	.-20     	; 0xcb9e <__ultoa_invert+0x58>
    cbb2:	46 2f       	mov	r20, r22
    cbb4:	4f 70       	andi	r20, 0x0F	; 15
    cbb6:	40 5d       	subi	r20, 0xD0	; 208
    cbb8:	4a 33       	cpi	r20, 0x3A	; 58
    cbba:	18 f0       	brcs	.+6      	; 0xcbc2 <__ultoa_invert+0x7c>
    cbbc:	49 5d       	subi	r20, 0xD9	; 217
    cbbe:	31 fd       	sbrc	r19, 1
    cbc0:	40 52       	subi	r20, 0x20	; 32
    cbc2:	41 93       	st	Z+, r20
    cbc4:	02 d0       	rcall	.+4      	; 0xcbca <__ultoa_invert+0x84>
    cbc6:	a9 f7       	brne	.-22     	; 0xcbb2 <__ultoa_invert+0x6c>
    cbc8:	ea cf       	rjmp	.-44     	; 0xcb9e <__ultoa_invert+0x58>
    cbca:	b4 e0       	ldi	r27, 0x04	; 4
    cbcc:	a6 95       	lsr	r26
    cbce:	97 95       	ror	r25
    cbd0:	87 95       	ror	r24
    cbd2:	77 95       	ror	r23
    cbd4:	67 95       	ror	r22
    cbd6:	ba 95       	dec	r27
    cbd8:	c9 f7       	brne	.-14     	; 0xcbcc <__ultoa_invert+0x86>
    cbda:	00 97       	sbiw	r24, 0x00	; 0
    cbdc:	61 05       	cpc	r22, r1
    cbde:	71 05       	cpc	r23, r1
    cbe0:	08 95       	ret
    cbe2:	9b 01       	movw	r18, r22
    cbe4:	ac 01       	movw	r20, r24
    cbe6:	0a 2e       	mov	r0, r26
    cbe8:	06 94       	lsr	r0
    cbea:	57 95       	ror	r21
    cbec:	47 95       	ror	r20
    cbee:	37 95       	ror	r19
    cbf0:	27 95       	ror	r18
    cbf2:	ba 95       	dec	r27
    cbf4:	c9 f7       	brne	.-14     	; 0xcbe8 <__ultoa_invert+0xa2>
    cbf6:	62 0f       	add	r22, r18
    cbf8:	73 1f       	adc	r23, r19
    cbfa:	84 1f       	adc	r24, r20
    cbfc:	95 1f       	adc	r25, r21
    cbfe:	a0 1d       	adc	r26, r0
    cc00:	08 95       	ret

0000cc02 <_exit>:
    cc02:	f8 94       	cli

0000cc04 <__stop_program>:
    cc04:	ff cf       	rjmp	.-2      	; 0xcc04 <__stop_program>
