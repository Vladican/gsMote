
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000778c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00802000  0000778c  00007820  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fad  00802138  00802138  00007958  2**0
                  ALLOC
  3 .stab         000029b8  00000000  00000000  00007958  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2d  00000000  00000000  0000a310  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003e0  00000000  00000000  0000ad40  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c9ee  00000000  00000000  0000b120  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002649  00000000  00000000  00017b0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000054a7  00000000  00000000  0001a157  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c08  00000000  00000000  0001f600  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000467f  00000000  00000000  00021208  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000080ee  00000000  00000000  00025887  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b166  00000000  00000000  0002d975  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000190  00000000  00000000  00188adb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 95 08 	jmp	0x112a	; 0x112a <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__vector_16>
      44:	0c 94 3e 0b 	jmp	0x167c	; 0x167c <__vector_17>
      48:	0c 94 16 0b 	jmp	0x162c	; 0x162c <__vector_18>
      4c:	0c 94 d0 0a 	jmp	0x15a0	; 0x15a0 <__vector_19>
      50:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 56 1e 	jmp	0x3cac	; 0x3cac <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 3e 18 	jmp	0x307c	; 0x307c <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 43 09 	jmp	0x1286	; 0x1286 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 a8 0a 	jmp	0x1550	; 0x1550 <__vector_79>
     140:	0c 94 80 0a 	jmp	0x1500	; 0x1500 <__vector_80>
     144:	0c 94 58 0a 	jmp	0x14b0	; 0x14b0 <__vector_81>
     148:	0c 94 2e 0a 	jmp	0x145c	; 0x145c <__vector_82>
     14c:	0c 94 08 03 	jmp	0x610	; 0x610 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 6a 07 	jmp	0xed4	; 0xed4 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ec e8       	ldi	r30, 0x8C	; 140
     244:	f7 e7       	ldi	r31, 0x77	; 119
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 33       	cpi	r26, 0x38	; 56
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e3       	ldi	r26, 0x38	; 56
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a5 3e       	cpi	r26, 0xE5	; 229
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 01 02 	call	0x402	; 0x402 <main>
     26a:	0c 94 c4 3b 	jmp	0x7788	; 0x7788 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	6b 01       	movw	r12, r22
     284:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     286:	dc 01       	movw	r26, r24
     288:	cb 01       	movw	r24, r22
     28a:	88 55       	subi	r24, 0x58	; 88
     28c:	92 40       	sbci	r25, 0x02	; 2
     28e:	a0 40       	sbci	r26, 0x00	; 0
     290:	b0 40       	sbci	r27, 0x00	; 0
     292:	89 3e       	cpi	r24, 0xE9	; 233
     294:	2f e3       	ldi	r18, 0x3F	; 63
     296:	92 07       	cpc	r25, r18
     298:	2f e0       	ldi	r18, 0x0F	; 15
     29a:	a2 07       	cpc	r26, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	b2 07       	cpc	r27, r18
     2a0:	08 f0       	brcs	.+2      	; 0x2a4 <StartSerial+0x32>
     2a2:	5c c0       	rjmp	.+184    	; 0x35c <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2a4:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2a8:	e0 e4       	ldi	r30, 0x40	; 64
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2b0:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2b2:	84 e0       	ldi	r24, 0x04	; 4
     2b4:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2b6:	cc 0c       	add	r12, r12
     2b8:	dd 1c       	adc	r13, r13
     2ba:	ee 1c       	adc	r14, r14
     2bc:	ff 1c       	adc	r15, r15
     2be:	cc 0c       	add	r12, r12
     2c0:	dd 1c       	adc	r13, r13
     2c2:	ee 1c       	adc	r14, r14
     2c4:	ff 1c       	adc	r15, r15
     2c6:	c7 01       	movw	r24, r14
     2c8:	b6 01       	movw	r22, r12
     2ca:	66 0f       	add	r22, r22
     2cc:	77 1f       	adc	r23, r23
     2ce:	88 1f       	adc	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	66 0f       	add	r22, r22
     2d4:	77 1f       	adc	r23, r23
     2d6:	88 1f       	adc	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__floatunsisf>
     2de:	9b 01       	movw	r18, r22
     2e0:	ac 01       	movw	r20, r24
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	74 e2       	ldi	r23, 0x24	; 36
     2e6:	84 ef       	ldi	r24, 0xF4	; 244
     2e8:	9b e4       	ldi	r25, 0x4B	; 75
     2ea:	0e 94 7e 36 	call	0x6cfc	; 0x6cfc <__divsf3>
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	40 e8       	ldi	r20, 0x80	; 128
     2f4:	5f e3       	ldi	r21, 0x3F	; 63
     2f6:	0e 94 19 36 	call	0x6c32	; 0x6c32 <__subsf3>
     2fa:	c6 2f       	mov	r28, r22
     2fc:	d7 2f       	mov	r29, r23
     2fe:	18 2f       	mov	r17, r24
     300:	09 2f       	mov	r16, r25
     302:	86 2f       	mov	r24, r22
     304:	9d 2f       	mov	r25, r29
     306:	a1 2f       	mov	r26, r17
     308:	b0 2f       	mov	r27, r16
     30a:	bc 01       	movw	r22, r24
     30c:	cd 01       	movw	r24, r26
     30e:	0e 94 e6 36 	call	0x6dcc	; 0x6dcc <__fixunssfsi>
     312:	6b 01       	movw	r12, r22
     314:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__floatunsisf>
     31e:	9b 01       	movw	r18, r22
     320:	ac 01       	movw	r20, r24
     322:	8c 2f       	mov	r24, r28
     324:	9d 2f       	mov	r25, r29
     326:	a1 2f       	mov	r26, r17
     328:	b0 2f       	mov	r27, r16
     32a:	bc 01       	movw	r22, r24
     32c:	cd 01       	movw	r24, r26
     32e:	0e 94 19 36 	call	0x6c32	; 0x6c32 <__subsf3>
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	40 e0       	ldi	r20, 0x00	; 0
     338:	5f e3       	ldi	r21, 0x3F	; 63
     33a:	0e 94 a0 37 	call	0x6f40	; 0x6f40 <__gesf2>
     33e:	88 23       	and	r24, r24
     340:	1c f0       	brlt	.+6      	; 0x348 <StartSerial+0xd6>
     342:	08 94       	sec
     344:	c1 1c       	adc	r12, r1
     346:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     348:	e0 ea       	ldi	r30, 0xA0	; 160
     34a:	f8 e0       	ldi	r31, 0x08	; 8
     34c:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     34e:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     354:	88 e1       	ldi	r24, 0x18	; 24
     356:	84 83       	std	Z+4, r24	; 0x04
	return true;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	01 c0       	rjmp	.+2      	; 0x35e <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     35c:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	1f 91       	pop	r17
     364:	0f 91       	pop	r16
     366:	ff 90       	pop	r15
     368:	ef 90       	pop	r14
     36a:	df 90       	pop	r13
     36c:	cf 90       	pop	r12
     36e:	08 95       	ret

00000370 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     370:	e0 ea       	ldi	r30, 0xA0	; 160
     372:	f8 e0       	ldi	r31, 0x08	; 8
     374:	91 81       	ldd	r25, Z+1	; 0x01
     376:	95 ff       	sbrs	r25, 5
     378:	fd cf       	rjmp	.-6      	; 0x374 <SerialWriteByte+0x4>
		//wait
	}
	//incremented byte
	USARTC0.DATA = byte;
     37a:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     37e:	08 95       	ret

00000380 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     380:	e0 ea       	ldi	r30, 0xA0	; 160
     382:	f8 e0       	ldi	r31, 0x08	; 8
     384:	81 81       	ldd	r24, Z+1	; 0x01
     386:	88 23       	and	r24, r24
     388:	ec f7       	brge	.-6      	; 0x384 <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     38a:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     38e:	08 95       	ret

00000390 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     390:	8f 92       	push	r8
     392:	9f 92       	push	r9
     394:	af 92       	push	r10
     396:	bf 92       	push	r11
     398:	cf 92       	push	r12
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	6a 01       	movw	r12, r20
     3a6:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     3a8:	41 15       	cp	r20, r1
     3aa:	51 05       	cpc	r21, r1
     3ac:	61 05       	cpc	r22, r1
     3ae:	71 05       	cpc	r23, r1
     3b0:	91 f0       	breq	.+36     	; 0x3d6 <SerialWriteBuffer+0x46>
     3b2:	c8 2f       	mov	r28, r24
     3b4:	d9 2f       	mov	r29, r25
     3b6:	88 24       	eor	r8, r8
     3b8:	99 24       	eor	r9, r9
     3ba:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     3bc:	89 91       	ld	r24, Y+
     3be:	0e 94 b8 01 	call	0x370	; 0x370 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     3c2:	08 94       	sec
     3c4:	81 1c       	adc	r8, r1
     3c6:	91 1c       	adc	r9, r1
     3c8:	a1 1c       	adc	r10, r1
     3ca:	b1 1c       	adc	r11, r1
     3cc:	8c 14       	cp	r8, r12
     3ce:	9d 04       	cpc	r9, r13
     3d0:	ae 04       	cpc	r10, r14
     3d2:	bf 04       	cpc	r11, r15
     3d4:	99 f7       	brne	.-26     	; 0x3bc <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	ff 90       	pop	r15
     3dc:	ef 90       	pop	r14
     3de:	df 90       	pop	r13
     3e0:	cf 90       	pop	r12
     3e2:	bf 90       	pop	r11
     3e4:	af 90       	pop	r10
     3e6:	9f 90       	pop	r9
     3e8:	8f 90       	pop	r8
     3ea:	08 95       	ret

000003ec <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     3ec:	e0 ea       	ldi	r30, 0xA0	; 160
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	84 81       	ldd	r24, Z+4	; 0x04
     3f2:	87 7e       	andi	r24, 0xE7	; 231
     3f4:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     3f6:	e0 e4       	ldi	r30, 0x40	; 64
     3f8:	f6 e0       	ldi	r31, 0x06	; 6
     3fa:	88 e0       	ldi	r24, 0x08	; 8
     3fc:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     3fe:	82 83       	std	Z+2, r24	; 0x02
     400:	08 95       	ret

00000402 <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
     40a:	64 97       	sbiw	r28, 0x14	; 20
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 5000;
	uint32_t samples = 0;
	DataAvailable = 0;
     410:	10 92 d5 21 	sts	0x21D5, r1
	ADC_Sampling_Finished = 1;
     414:	81 e0       	ldi	r24, 0x01	; 1
     416:	80 93 d5 50 	sts	0x50D5, r24
	uint8_t RadioMessageBuffer[20];
	set_32MHz();
     41a:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <set_32MHz>
	chb_init();
     41e:	0e 94 f5 13 	call	0x27ea	; 0x27ea <chb_init>
	chb_set_channel(1);
     422:	81 e0       	ldi	r24, 0x01	; 1
     424:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <chb_set_channel>
	chb_set_short_addr(0x0002);
     428:	82 e0       	ldi	r24, 0x02	; 2
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     430:	0e 94 07 14 	call	0x280e	; 0x280e <chb_get_pcb>
     434:	3c 01       	movw	r6, r24

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 5000;
     436:	0f 2e       	mov	r0, r31
     438:	f8 e8       	ldi	r31, 0x88	; 136
     43a:	4f 2e       	mov	r4, r31
     43c:	f3 e1       	ldi	r31, 0x13	; 19
     43e:	5f 2e       	mov	r5, r31
     440:	f0 2d       	mov	r31, r0
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     442:	10 e0       	ldi	r17, 0x00	; 0
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
						//CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 5, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     444:	0f 2e       	mov	r0, r31
     446:	ff ed       	ldi	r31, 0xDF	; 223
     448:	2f 2e       	mov	r2, r31
     44a:	f3 e2       	ldi	r31, 0x23	; 35
     44c:	3f 2e       	mov	r3, r31
     44e:	f0 2d       	mov	r31, r0
     450:	01 c0       	rjmp	.+2      	; 0x454 <main+0x52>
					switch(RadioMessageBuffer[1]){
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     452:	11 e0       	ldi	r17, 0x01	; 1
	chb_init();
	chb_set_channel(1);
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
     454:	f3 01       	movw	r30, r6
     456:	83 81       	ldd	r24, Z+3	; 0x03
     458:	88 23       	and	r24, r24
     45a:	e1 f3       	breq	.-8      	; 0x454 <main+0x52>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     45c:	ce 01       	movw	r24, r28
     45e:	01 96       	adiw	r24, 0x01	; 1
     460:	0e 94 cd 14 	call	0x299a	; 0x299a <chb_read>
			
			if(length == 1){
     464:	81 30       	cpi	r24, 0x01	; 1
     466:	b1 f7       	brne	.-20     	; 0x454 <main+0x52>
				switch ( RadioMessageBuffer[0])
     468:	89 81       	ldd	r24, Y+1	; 0x01
     46a:	82 35       	cpi	r24, 0x52	; 82
     46c:	71 f0       	breq	.+28     	; 0x48a <main+0x88>
     46e:	83 35       	cpi	r24, 0x53	; 83
     470:	30 f4       	brcc	.+12     	; 0x47e <main+0x7c>
     472:	86 34       	cpi	r24, 0x46	; 70
     474:	09 f4       	brne	.+2      	; 0x478 <main+0x76>
     476:	65 c0       	rjmp	.+202    	; 0x542 <main+0x140>
     478:	87 34       	cpi	r24, 0x47	; 71
     47a:	61 f7       	brne	.-40     	; 0x454 <main+0x52>
     47c:	30 c0       	rjmp	.+96     	; 0x4de <main+0xdc>
     47e:	83 35       	cpi	r24, 0x53	; 83
     480:	09 f4       	brne	.+2      	; 0x484 <main+0x82>
     482:	62 c0       	rjmp	.+196    	; 0x548 <main+0x146>
     484:	84 35       	cpi	r24, 0x54	; 84
     486:	31 f7       	brne	.-52     	; 0x454 <main+0x52>
     488:	67 c0       	rjmp	.+206    	; 0x558 <main+0x156>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     48a:	80 91 d5 50 	lds	r24, 0x50D5
     48e:	88 23       	and	r24, r24
     490:	09 f3       	breq	.-62     	; 0x454 <main+0x52>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 5, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     492:	00 d0       	rcall	.+0      	; 0x494 <main+0x92>
     494:	0f 92       	push	r0
     496:	8c e1       	ldi	r24, 0x1C	; 28
     498:	97 e0       	ldi	r25, 0x07	; 7
     49a:	ed b7       	in	r30, 0x3d	; 61
     49c:	fe b7       	in	r31, 0x3e	; 62
     49e:	81 83       	std	Z+1, r24	; 0x01
     4a0:	92 83       	std	Z+2, r25	; 0x02
     4a2:	23 82       	std	Z+3, r2	; 0x03
     4a4:	34 82       	std	Z+4, r3	; 0x04
     4a6:	87 e0       	ldi	r24, 0x07	; 7
     4a8:	61 2f       	mov	r22, r17
     4aa:	a2 01       	movw	r20, r4
     4ac:	25 e0       	ldi	r18, 0x05	; 5
     4ae:	01 e0       	ldi	r16, 0x01	; 1
     4b0:	ee 24       	eor	r14, r14
     4b2:	ff 24       	eor	r15, r15
     4b4:	e3 94       	inc	r14
     4b6:	cc 24       	eor	r12, r12
     4b8:	dd 24       	eor	r13, r13
     4ba:	68 94       	set
     4bc:	c1 f8       	bld	r12, 1
     4be:	0f 2e       	mov	r0, r31
     4c0:	f3 e0       	ldi	r31, 0x03	; 3
     4c2:	af 2e       	mov	r10, r31
     4c4:	bb 24       	eor	r11, r11
     4c6:	f0 2d       	mov	r31, r0
     4c8:	88 24       	eor	r8, r8
     4ca:	99 24       	eor	r9, r9
     4cc:	68 94       	set
     4ce:	82 f8       	bld	r8, 2
     4d0:	0e 94 12 11 	call	0x2224	; 0x2224 <CO_collectSeismic1Channel>
     4d4:	0f 90       	pop	r0
     4d6:	0f 90       	pop	r0
     4d8:	0f 90       	pop	r0
     4da:	0f 90       	pop	r0
     4dc:	bb cf       	rjmp	.-138    	; 0x454 <main+0x52>
					}						
					break;
				case 'G':
					//set gain to what is specified
					switch(RadioMessageBuffer[1]){
     4de:	8a 81       	ldd	r24, Y+2	; 0x02
     4e0:	88 30       	cpi	r24, 0x08	; 8
     4e2:	d1 f0       	breq	.+52     	; 0x518 <main+0x116>
     4e4:	89 30       	cpi	r24, 0x09	; 9
     4e6:	40 f4       	brcc	.+16     	; 0x4f8 <main+0xf6>
     4e8:	82 30       	cpi	r24, 0x02	; 2
     4ea:	09 f4       	brne	.+2      	; 0x4ee <main+0xec>
     4ec:	b2 cf       	rjmp	.-156    	; 0x452 <main+0x50>
     4ee:	84 30       	cpi	r24, 0x04	; 4
     4f0:	89 f0       	breq	.+34     	; 0x514 <main+0x112>
     4f2:	81 30       	cpi	r24, 0x01	; 1
     4f4:	d9 f4       	brne	.+54     	; 0x52c <main+0x12a>
     4f6:	0c c0       	rjmp	.+24     	; 0x510 <main+0x10e>
     4f8:	80 32       	cpi	r24, 0x20	; 32
     4fa:	91 f0       	breq	.+36     	; 0x520 <main+0x11e>
     4fc:	81 32       	cpi	r24, 0x21	; 33
     4fe:	18 f4       	brcc	.+6      	; 0x506 <main+0x104>
     500:	80 31       	cpi	r24, 0x10	; 16
     502:	a1 f4       	brne	.+40     	; 0x52c <main+0x12a>
     504:	0b c0       	rjmp	.+22     	; 0x51c <main+0x11a>
     506:	80 34       	cpi	r24, 0x40	; 64
     508:	69 f0       	breq	.+26     	; 0x524 <main+0x122>
     50a:	80 38       	cpi	r24, 0x80	; 128
     50c:	79 f4       	brne	.+30     	; 0x52c <main+0x12a>
     50e:	0c c0       	rjmp	.+24     	; 0x528 <main+0x126>
						case 1:
							gain = GAIN_1_gc;
     510:	10 e0       	ldi	r17, 0x00	; 0
     512:	a0 cf       	rjmp	.-192    	; 0x454 <main+0x52>
							break;
						case 2:
							gain = GAIN_2_gc;
							break;
						case 4:
							gain = GAIN_4_gc;
     514:	12 e0       	ldi	r17, 0x02	; 2
							break;
     516:	9e cf       	rjmp	.-196    	; 0x454 <main+0x52>
						case 8:
							gain = GAIN_8_gc;
     518:	13 e0       	ldi	r17, 0x03	; 3
							break;
     51a:	9c cf       	rjmp	.-200    	; 0x454 <main+0x52>
						case 16:
							gain = GAIN_16_gc;
     51c:	14 e0       	ldi	r17, 0x04	; 4
							break;
     51e:	9a cf       	rjmp	.-204    	; 0x454 <main+0x52>
						case 32:
							gain = GAIN_32_gc;
     520:	15 e0       	ldi	r17, 0x05	; 5
							break;
     522:	98 cf       	rjmp	.-208    	; 0x454 <main+0x52>
						case 64:
							gain = GAIN_64_gc;
     524:	16 e0       	ldi	r17, 0x06	; 6
							break;
     526:	96 cf       	rjmp	.-212    	; 0x454 <main+0x52>
						case 128:
							gain = GAIN_128_gc;
     528:	17 e0       	ldi	r17, 0x07	; 7
							break;
     52a:	94 cf       	rjmp	.-216    	; 0x454 <main+0x52>
						default:
							chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	60 e0       	ldi	r22, 0x00	; 0
     532:	70 e2       	ldi	r23, 0x20	; 32
     534:	2c e0       	ldi	r18, 0x0C	; 12
     536:	30 e0       	ldi	r19, 0x00	; 0
     538:	40 e0       	ldi	r20, 0x00	; 0
     53a:	50 e0       	ldi	r21, 0x00	; 0
     53c:	0e 94 0a 14 	call	0x2814	; 0x2814 <chb_write>
							break;
     540:	89 cf       	rjmp	.-238    	; 0x454 <main+0x52>
					}					
					break;
				case 'F':
					//set sampling frequency to what is specified
					freq = *(uint16_t*)(RadioMessageBuffer+1);
     542:	4a 80       	ldd	r4, Y+2	; 0x02
     544:	5b 80       	ldd	r5, Y+3	; 0x03
					break;
     546:	86 cf       	rjmp	.-244    	; 0x454 <main+0x52>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     548:	80 91 d5 50 	lds	r24, 0x50D5
     54c:	88 23       	and	r24, r24
     54e:	09 f0       	breq	.+2      	; 0x552 <main+0x150>
     550:	81 cf       	rjmp	.-254    	; 0x454 <main+0x52>
						ADC_Stop_Sampling();
     552:	0e 94 30 07 	call	0xe60	; 0xe60 <ADC_Stop_Sampling>
     556:	7e cf       	rjmp	.-260    	; 0x454 <main+0x52>
					}
					//otherwise, the ADC has finished sampling on its own and the data will be transmitted after this switch statement
					break;
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     558:	80 91 d5 50 	lds	r24, 0x50D5
     55c:	88 23       	and	r24, r24
     55e:	09 f4       	brne	.+2      	; 0x562 <main+0x160>
     560:	79 cf       	rjmp	.-270    	; 0x454 <main+0x52>
     562:	80 91 d5 21 	lds	r24, 0x21D5
     566:	88 23       	and	r24, r24
     568:	09 f4       	brne	.+2      	; 0x56c <main+0x16a>
     56a:	74 cf       	rjmp	.-280    	; 0x454 <main+0x52>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     56c:	0e 94 51 07 	call	0xea2	; 0xea2 <ADC_Get_Num_Samples>
     570:	a0 e0       	ldi	r26, 0x00	; 0
     572:	b0 e0       	ldi	r27, 0x00	; 0
						if(samples > 0) chb_write(0x0000,FRAMReadBuffer,samples*4);
     574:	00 97       	sbiw	r24, 0x00	; 0
     576:	a1 05       	cpc	r26, r1
     578:	b1 05       	cpc	r27, r1
     57a:	79 f0       	breq	.+30     	; 0x59a <main+0x198>
     57c:	9c 01       	movw	r18, r24
     57e:	ad 01       	movw	r20, r26
     580:	22 0f       	add	r18, r18
     582:	33 1f       	adc	r19, r19
     584:	44 1f       	adc	r20, r20
     586:	55 1f       	adc	r21, r21
     588:	22 0f       	add	r18, r18
     58a:	33 1f       	adc	r19, r19
     58c:	44 1f       	adc	r20, r20
     58e:	55 1f       	adc	r21, r21
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	b1 01       	movw	r22, r2
     596:	0e 94 0a 14 	call	0x2814	; 0x2814 <chb_write>
						DataAvailable = 0;
     59a:	10 92 d5 21 	sts	0x21D5, r1
     59e:	5a cf       	rjmp	.-332    	; 0x454 <main+0x52>

000005a0 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     5a0:	0f 93       	push	r16
     5a2:	1f 93       	push	r17
     5a4:	cf 93       	push	r28
     5a6:	8c 01       	movw	r16, r24
	moteID = 1;
     5a8:	c1 e0       	ldi	r28, 0x01	; 1
     5aa:	c0 93 d0 50 	sts	0x50D0, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     5ae:	83 e0       	ldi	r24, 0x03	; 3
     5b0:	80 93 5e 40 	sts	0x405E, r24
	chb_init();
     5b4:	0e 94 f5 13 	call	0x27ea	; 0x27ea <chb_init>
	chb_set_short_addr(moteID);
     5b8:	80 91 d0 50 	lds	r24, 0x50D0
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     5c2:	88 ec       	ldi	r24, 0xC8	; 200
     5c4:	e0 e8       	ldi	r30, 0x80	; 128
     5c6:	f1 e0       	ldi	r31, 0x01	; 1
     5c8:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     5ca:	e0 e4       	ldi	r30, 0x40	; 64
     5cc:	f9 e0       	ldi	r31, 0x09	; 9
     5ce:	89 e0       	ldi	r24, 0x09	; 9
     5d0:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     5d2:	82 e0       	ldi	r24, 0x02	; 2
     5d4:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     5d6:	24 ef       	ldi	r18, 0xF4	; 244
     5d8:	31 e0       	ldi	r19, 0x01	; 1
     5da:	02 9f       	mul	r16, r18
     5dc:	c0 01       	movw	r24, r0
     5de:	03 9f       	mul	r16, r19
     5e0:	90 0d       	add	r25, r0
     5e2:	12 9f       	mul	r17, r18
     5e4:	90 0d       	add	r25, r0
     5e6:	11 24       	eor	r1, r1
     5e8:	86 a3       	lds	r24, 0x56
     5ea:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     5ec:	e0 e4       	ldi	r30, 0x40	; 64
     5ee:	f8 e0       	ldi	r31, 0x08	; 8
     5f0:	80 e0       	ldi	r24, 0x00	; 0
     5f2:	9a ef       	ldi	r25, 0xFA	; 250
     5f4:	86 a3       	lds	r24, 0x56
     5f6:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     5f8:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     5fa:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     5fc:	e0 ea       	ldi	r30, 0xA0	; 160
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	82 81       	ldd	r24, Z+2	; 0x02
     602:	87 60       	ori	r24, 0x07	; 7
     604:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     606:	78 94       	sei
}
     608:	cf 91       	pop	r28
     60a:	1f 91       	pop	r17
     60c:	0f 91       	pop	r16
     60e:	08 95       	ret

00000610 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     610:	78 94       	sei
     612:	1f 92       	push	r1
     614:	0f 92       	push	r0
     616:	0f b6       	in	r0, 0x3f	; 63
     618:	0f 92       	push	r0
     61a:	0b b6       	in	r0, 0x3b	; 59
     61c:	0f 92       	push	r0
     61e:	11 24       	eor	r1, r1
     620:	ef 92       	push	r14
     622:	ff 92       	push	r15
     624:	0f 93       	push	r16
     626:	1f 93       	push	r17
     628:	2f 93       	push	r18
     62a:	3f 93       	push	r19
     62c:	4f 93       	push	r20
     62e:	5f 93       	push	r21
     630:	6f 93       	push	r22
     632:	7f 93       	push	r23
     634:	8f 93       	push	r24
     636:	9f 93       	push	r25
     638:	af 93       	push	r26
     63a:	bf 93       	push	r27
     63c:	ef 93       	push	r30
     63e:	ff 93       	push	r31
     640:	cf 93       	push	r28
     642:	df 93       	push	r29
     644:	cd b7       	in	r28, 0x3d	; 61
     646:	de b7       	in	r29, 0x3e	; 62
     648:	28 97       	sbiw	r28, 0x08	; 8
     64a:	cd bf       	out	0x3d, r28	; 61
     64c:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     64e:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
     652:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     656:	82 e0       	ldi	r24, 0x02	; 2
     658:	80 93 5e 40 	sts	0x405E, r24
	char message[8];
	strcpy(message,"reset");
     65c:	de 01       	movw	r26, r28
     65e:	11 96       	adiw	r26, 0x01	; 1
     660:	ed e0       	ldi	r30, 0x0D	; 13
     662:	f0 e2       	ldi	r31, 0x20	; 32
     664:	86 e0       	ldi	r24, 0x06	; 6
     666:	01 90       	ld	r0, Z+
     668:	0d 92       	st	X+, r0
     66a:	81 50       	subi	r24, 0x01	; 1
     66c:	e1 f7       	brne	.-8      	; 0x666 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
     66e:	07 ed       	ldi	r16, 0xD7	; 215
     670:	10 e5       	ldi	r17, 0x50	; 80
     672:	80 91 d0 50 	lds	r24, 0x50D0
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	b8 01       	movw	r22, r16
     67a:	4a e0       	ldi	r20, 0x0A	; 10
     67c:	50 e0       	ldi	r21, 0x00	; 0
     67e:	0e 94 ae 38 	call	0x715c	; 0x715c <itoa>
	strcat(message,buff);
     682:	7e 01       	movw	r14, r28
     684:	08 94       	sec
     686:	e1 1c       	adc	r14, r1
     688:	f1 1c       	adc	r15, r1
     68a:	c7 01       	movw	r24, r14
     68c:	b8 01       	movw	r22, r16
     68e:	0e 94 95 38 	call	0x712a	; 0x712a <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     692:	0e 94 61 07 	call	0xec2	; 0xec2 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     696:	f7 01       	movw	r30, r14
     698:	01 90       	ld	r0, Z+
     69a:	00 20       	and	r0, r0
     69c:	e9 f7       	brne	.-6      	; 0x698 <__vector_83+0x88>
     69e:	31 97       	sbiw	r30, 0x01	; 1
     6a0:	ee 19       	sub	r30, r14
     6a2:	ff 09       	sbc	r31, r15
     6a4:	9f 01       	movw	r18, r30
     6a6:	40 e0       	ldi	r20, 0x00	; 0
     6a8:	50 e0       	ldi	r21, 0x00	; 0
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	b7 01       	movw	r22, r14
     6b0:	0e 94 0a 14 	call	0x2814	; 0x2814 <chb_write>
}	
     6b4:	28 96       	adiw	r28, 0x08	; 8
     6b6:	cd bf       	out	0x3d, r28	; 61
     6b8:	de bf       	out	0x3e, r29	; 62
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	ff 91       	pop	r31
     6c0:	ef 91       	pop	r30
     6c2:	bf 91       	pop	r27
     6c4:	af 91       	pop	r26
     6c6:	9f 91       	pop	r25
     6c8:	8f 91       	pop	r24
     6ca:	7f 91       	pop	r23
     6cc:	6f 91       	pop	r22
     6ce:	5f 91       	pop	r21
     6d0:	4f 91       	pop	r20
     6d2:	3f 91       	pop	r19
     6d4:	2f 91       	pop	r18
     6d6:	1f 91       	pop	r17
     6d8:	0f 91       	pop	r16
     6da:	ff 90       	pop	r15
     6dc:	ef 90       	pop	r14
     6de:	0f 90       	pop	r0
     6e0:	0b be       	out	0x3b, r0	; 59
     6e2:	0f 90       	pop	r0
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	0f 90       	pop	r0
     6e8:	1f 90       	pop	r1
     6ea:	18 95       	reti

000006ec <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     6ec:	cf 93       	push	r28
     6ee:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     6f0:	21 e0       	ldi	r18, 0x01	; 1
     6f2:	30 e0       	ldi	r19, 0x00	; 0
     6f4:	a9 01       	movw	r20, r18
     6f6:	02 c0       	rjmp	.+4      	; 0x6fc <set_ampGain+0x10>
     6f8:	44 0f       	add	r20, r20
     6fa:	55 1f       	adc	r21, r21
     6fc:	8a 95       	dec	r24
     6fe:	e2 f7       	brpl	.-8      	; 0x6f8 <set_ampGain+0xc>
     700:	ca 01       	movw	r24, r20
     702:	61 e0       	ldi	r22, 0x01	; 1
     704:	0e 94 91 1b 	call	0x3722	; 0x3722 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     708:	c0 ff       	sbrs	r28, 0
     70a:	05 c0       	rjmp	.+10     	; 0x716 <set_ampGain+0x2a>
     70c:	80 e4       	ldi	r24, 0x40	; 64
     70e:	e0 e0       	ldi	r30, 0x00	; 0
     710:	f6 e0       	ldi	r31, 0x06	; 6
     712:	85 83       	std	Z+5, r24	; 0x05
     714:	04 c0       	rjmp	.+8      	; 0x71e <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
     716:	80 e4       	ldi	r24, 0x40	; 64
     718:	e0 e0       	ldi	r30, 0x00	; 0
     71a:	f6 e0       	ldi	r31, 0x06	; 6
     71c:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     71e:	c1 ff       	sbrs	r28, 1
     720:	05 c0       	rjmp	.+10     	; 0x72c <set_ampGain+0x40>
     722:	82 e0       	ldi	r24, 0x02	; 2
     724:	e0 e2       	ldi	r30, 0x20	; 32
     726:	f6 e0       	ldi	r31, 0x06	; 6
     728:	85 83       	std	Z+5, r24	; 0x05
     72a:	04 c0       	rjmp	.+8      	; 0x734 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	e0 e2       	ldi	r30, 0x20	; 32
     730:	f6 e0       	ldi	r31, 0x06	; 6
     732:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     734:	c2 ff       	sbrs	r28, 2
     736:	05 c0       	rjmp	.+10     	; 0x742 <set_ampGain+0x56>
     738:	84 e0       	ldi	r24, 0x04	; 4
     73a:	e0 e2       	ldi	r30, 0x20	; 32
     73c:	f6 e0       	ldi	r31, 0x06	; 6
     73e:	85 83       	std	Z+5, r24	; 0x05
     740:	04 c0       	rjmp	.+8      	; 0x74a <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
     742:	84 e0       	ldi	r24, 0x04	; 4
     744:	e0 e2       	ldi	r30, 0x20	; 32
     746:	f6 e0       	ldi	r31, 0x06	; 6
     748:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     74a:	5a e0       	ldi	r21, 0x0A	; 10
     74c:	5a 95       	dec	r21
     74e:	f1 f7       	brne	.-4      	; 0x74c <set_ampGain+0x60>
     750:	00 c0       	rjmp	.+0      	; 0x752 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     752:	8f ef       	ldi	r24, 0xFF	; 255
     754:	61 e0       	ldi	r22, 0x01	; 1
     756:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     75a:	cf 91       	pop	r28
     75c:	08 95       	ret

0000075e <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     762:	c8 2f       	mov	r28, r24
     764:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     766:	d8 2f       	mov	r29, r24
     768:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     76a:	28 2f       	mov	r18, r24
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	a9 01       	movw	r20, r18
     770:	45 70       	andi	r20, 0x05	; 5
     772:	50 70       	andi	r21, 0x00	; 0
     774:	41 15       	cp	r20, r1
     776:	51 05       	cpc	r21, r1
     778:	49 f0       	breq	.+18     	; 0x78c <set_filter+0x2e>
     77a:	90 91 81 50 	lds	r25, 0x5081
     77e:	48 2f       	mov	r20, r24
     780:	42 95       	swap	r20
     782:	4f 70       	andi	r20, 0x0F	; 15
     784:	90 7f       	andi	r25, 0xF0	; 240
     786:	94 2b       	or	r25, r20
     788:	90 93 81 50 	sts	0x5081, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     78c:	2a 70       	andi	r18, 0x0A	; 10
     78e:	30 70       	andi	r19, 0x00	; 0
     790:	21 15       	cp	r18, r1
     792:	31 05       	cpc	r19, r1
     794:	39 f0       	breq	.+14     	; 0x7a4 <set_filter+0x46>
     796:	90 91 81 50 	lds	r25, 0x5081
     79a:	80 7f       	andi	r24, 0xF0	; 240
     79c:	9f 70       	andi	r25, 0x0F	; 15
     79e:	89 2b       	or	r24, r25
     7a0:	80 93 81 50 	sts	0x5081, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     7a4:	84 e0       	ldi	r24, 0x04	; 4
     7a6:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     7aa:	80 91 81 50 	lds	r24, 0x5081
     7ae:	80 93 65 50 	sts	0x5065, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     7b2:	cc 23       	and	r28, r28
     7b4:	19 f0       	breq	.+6      	; 0x7bc <set_filter+0x5e>
     7b6:	81 e0       	ldi	r24, 0x01	; 1
     7b8:	0e 94 40 1b 	call	0x3680	; 0x3680 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     7bc:	dd 23       	and	r29, r29
     7be:	19 f0       	breq	.+6      	; 0x7c6 <set_filter+0x68>
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	0e 94 4c 1b 	call	0x3698	; 0x3698 <upperMuxCS>

	SPICS(TRUE);
     7c6:	81 e0       	ldi	r24, 0x01	; 1
     7c8:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     7cc:	8f ef       	ldi	r24, 0xFF	; 255
     7ce:	e0 ec       	ldi	r30, 0xC0	; 192
     7d0:	f8 e0       	ldi	r31, 0x08	; 8
     7d2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     7d4:	82 81       	ldd	r24, Z+2	; 0x02
     7d6:	88 23       	and	r24, r24
     7d8:	ec f7       	brge	.-6      	; 0x7d4 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     7da:	e0 ec       	ldi	r30, 0xC0	; 192
     7dc:	f8 e0       	ldi	r31, 0x08	; 8
     7de:	83 81       	ldd	r24, Z+3	; 0x03
     7e0:	80 93 71 50 	sts	0x5071, r24

	nop();
     7e4:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     7e6:	a1 e7       	ldi	r26, 0x71	; 113
     7e8:	b0 e5       	ldi	r27, 0x50	; 80
     7ea:	1c 97       	sbiw	r26, 0x0c	; 12
     7ec:	8c 91       	ld	r24, X
     7ee:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     7f0:	82 81       	ldd	r24, Z+2	; 0x02
     7f2:	88 23       	and	r24, r24
     7f4:	ec f7       	brge	.-6      	; 0x7f0 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     7f6:	e0 ec       	ldi	r30, 0xC0	; 192
     7f8:	f8 e0       	ldi	r31, 0x08	; 8
     7fa:	83 81       	ldd	r24, Z+3	; 0x03
     7fc:	80 93 71 50 	sts	0x5071, r24
	SPICS(FALSE);
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     806:	cc 23       	and	r28, r28
     808:	19 f0       	breq	.+6      	; 0x810 <set_filter+0xb2>
     80a:	80 e0       	ldi	r24, 0x00	; 0
     80c:	0e 94 40 1b 	call	0x3680	; 0x3680 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     810:	dd 23       	and	r29, r29
     812:	19 f0       	breq	.+6      	; 0x81a <set_filter+0xbc>
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	0e 94 4c 1b 	call	0x3698	; 0x3698 <upperMuxCS>
	SPIDisable();
     81a:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
}
     81e:	df 91       	pop	r29
     820:	cf 91       	pop	r28
     822:	08 95       	ret

00000824 <ADCPower>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void ADCPower(uint8_t on) {
     824:	0f 93       	push	r16
     826:	1f 93       	push	r17
     828:	cf 93       	push	r28
     82a:	df 93       	push	r29
	
	if (on) {
     82c:	88 23       	and	r24, r24
     82e:	09 f4       	brne	.+2      	; 0x832 <ADCPower+0xe>
     830:	46 c0       	rjmp	.+140    	; 0x8be <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     832:	00 e0       	ldi	r16, 0x00	; 0
     834:	16 e0       	ldi	r17, 0x06	; 6
     836:	8e ed       	ldi	r24, 0xDE	; 222
     838:	d8 01       	movw	r26, r16
     83a:	11 96       	adiw	r26, 0x01	; 1
     83c:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     83e:	c0 e2       	ldi	r28, 0x20	; 32
     840:	d6 e0       	ldi	r29, 0x06	; 6
     842:	4e e0       	ldi	r20, 0x0E	; 14
     844:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     846:	e0 e4       	ldi	r30, 0x40	; 64
     848:	f6 e0       	ldi	r31, 0x06	; 6
     84a:	63 e0       	ldi	r22, 0x03	; 3
     84c:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     84e:	80 e8       	ldi	r24, 0x80	; 128
     850:	96 e0       	ldi	r25, 0x06	; 6
     852:	50 e1       	ldi	r21, 0x10	; 16
     854:	dc 01       	movw	r26, r24
     856:	11 96       	adiw	r26, 0x01	; 1
     858:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     85a:	20 ea       	ldi	r18, 0xA0	; 160
     85c:	36 e0       	ldi	r19, 0x06	; 6
     85e:	d9 01       	movw	r26, r18
     860:	11 96       	adiw	r26, 0x01	; 1
     862:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     864:	7e e9       	ldi	r23, 0x9E	; 158
     866:	d8 01       	movw	r26, r16
     868:	15 96       	adiw	r26, 0x05	; 5
     86a:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     86c:	78 e0       	ldi	r23, 0x08	; 8
     86e:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     870:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     872:	ec 01       	movw	r28, r24
     874:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     876:	d9 01       	movw	r26, r18
     878:	15 96       	adiw	r26, 0x05	; 5
     87a:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     87c:	10 92 81 50 	sts	0x5081, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     880:	8f ef       	ldi	r24, 0xFF	; 255
     882:	93 ec       	ldi	r25, 0xC3	; 195
     884:	a9 e0       	ldi	r26, 0x09	; 9
     886:	81 50       	subi	r24, 0x01	; 1
     888:	90 40       	sbci	r25, 0x00	; 0
     88a:	a0 40       	sbci	r26, 0x00	; 0
     88c:	e1 f7       	brne	.-8      	; 0x886 <ADCPower+0x62>
     88e:	00 c0       	rjmp	.+0      	; 0x890 <ADCPower+0x6c>
     890:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     892:	80 e4       	ldi	r24, 0x40	; 64
     894:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     896:	10 92 82 50 	sts	0x5082, r1
     89a:	10 92 d6 50 	sts	0x50D6, r1
     89e:	10 92 d6 23 	sts	0x23D6, r1
     8a2:	10 92 7a 50 	sts	0x507A, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     8a6:	8f ef       	ldi	r24, 0xFF	; 255
     8a8:	61 e0       	ldi	r22, 0x01	; 1
     8aa:	0e 94 95 1c 	call	0x392a	; 0x392a <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     8ae:	8f ef       	ldi	r24, 0xFF	; 255
     8b0:	61 e0       	ldi	r22, 0x01	; 1
     8b2:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     8b6:	8f ef       	ldi	r24, 0xFF	; 255
     8b8:	0e 94 af 03 	call	0x75e	; 0x75e <set_filter>
     8bc:	32 c0       	rjmp	.+100    	; 0x922 <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     8be:	00 e0       	ldi	r16, 0x00	; 0
     8c0:	16 e0       	ldi	r17, 0x06	; 6
     8c2:	7e ed       	ldi	r23, 0xDE	; 222
     8c4:	d8 01       	movw	r26, r16
     8c6:	16 96       	adiw	r26, 0x06	; 6
     8c8:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     8ca:	a0 e2       	ldi	r26, 0x20	; 32
     8cc:	b6 e0       	ldi	r27, 0x06	; 6
     8ce:	4e e0       	ldi	r20, 0x0E	; 14
     8d0:	16 96       	adiw	r26, 0x06	; 6
     8d2:	4c 93       	st	X, r20
     8d4:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     8d6:	20 e4       	ldi	r18, 0x40	; 64
     8d8:	36 e0       	ldi	r19, 0x06	; 6
     8da:	63 e0       	ldi	r22, 0x03	; 3
     8dc:	e9 01       	movw	r28, r18
     8de:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     8e0:	c0 e8       	ldi	r28, 0x80	; 128
     8e2:	d6 e0       	ldi	r29, 0x06	; 6
     8e4:	50 e1       	ldi	r21, 0x10	; 16
     8e6:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     8e8:	80 ea       	ldi	r24, 0xA0	; 160
     8ea:	96 e0       	ldi	r25, 0x06	; 6
     8ec:	fc 01       	movw	r30, r24
     8ee:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     8f0:	f8 01       	movw	r30, r16
     8f2:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     8f4:	12 96       	adiw	r26, 0x02	; 2
     8f6:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     8f8:	d9 01       	movw	r26, r18
     8fa:	12 96       	adiw	r26, 0x02	; 2
     8fc:	6c 93       	st	X, r22
     8fe:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     900:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     902:	ec 01       	movw	r28, r24
     904:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     906:	80 e4       	ldi	r24, 0x40	; 64
     908:	12 96       	adiw	r26, 0x02	; 2
     90a:	8c 93       	st	X, r24
     90c:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     90e:	10 92 82 50 	sts	0x5082, r1
     912:	10 92 d6 50 	sts	0x50D6, r1
     916:	10 92 d6 23 	sts	0x23D6, r1
     91a:	10 92 7a 50 	sts	0x507A, r1
		channelStatus = 0x00;
     91e:	10 92 81 50 	sts	0x5081, r1
		
	}
}
     922:	df 91       	pop	r29
     924:	cf 91       	pop	r28
     926:	1f 91       	pop	r17
     928:	0f 91       	pop	r16
     92a:	08 95       	ret

0000092c <CO_collectBatt>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     92c:	4f 92       	push	r4
     92e:	5f 92       	push	r5
     930:	6f 92       	push	r6
     932:	7f 92       	push	r7
     934:	8f 92       	push	r8
     936:	9f 92       	push	r9
     938:	af 92       	push	r10
     93a:	bf 92       	push	r11
     93c:	ef 92       	push	r14
     93e:	ff 92       	push	r15
     940:	0f 93       	push	r16
     942:	1f 93       	push	r17
     944:	cf 93       	push	r28
     946:	df 93       	push	r29
     948:	cd b7       	in	r28, 0x3d	; 61
     94a:	de b7       	in	r29, 0x3e	; 62
     94c:	2b 97       	sbiw	r28, 0x0b	; 11
     94e:	cd bf       	out	0x3d, r28	; 61
     950:	de bf       	out	0x3e, r29	; 62
     952:	8e 83       	std	Y+6, r24	; 0x06
     954:	9f 83       	std	Y+7, r25	; 0x07
     956:	68 87       	std	Y+8, r22	; 0x08
     958:	79 87       	std	Y+9, r23	; 0x09
     95a:	4a 87       	std	Y+10, r20	; 0x0a
     95c:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     95e:	81 e0       	ldi	r24, 0x01	; 1
     960:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     964:	84 e0       	ldi	r24, 0x04	; 4
     966:	60 e0       	ldi	r22, 0x00	; 0
     968:	0e 94 95 1c 	call	0x392a	; 0x392a <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     96c:	84 e0       	ldi	r24, 0x04	; 4
     96e:	60 e0       	ldi	r22, 0x00	; 0
     970:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
     974:	2f ef       	ldi	r18, 0xFF	; 255
     976:	33 ec       	ldi	r19, 0xC3	; 195
     978:	49 e0       	ldi	r20, 0x09	; 9
     97a:	21 50       	subi	r18, 0x01	; 1
     97c:	30 40       	sbci	r19, 0x00	; 0
     97e:	40 40       	sbci	r20, 0x00	; 0
     980:	e1 f7       	brne	.-8      	; 0x97a <CO_collectBatt+0x4e>
     982:	00 c0       	rjmp	.+0      	; 0x984 <CO_collectBatt+0x58>
     984:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     986:	80 e4       	ldi	r24, 0x40	; 64
     988:	92 e0       	ldi	r25, 0x02	; 2
     98a:	0e 94 c7 13 	call	0x278e	; 0x278e <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     98e:	00 e4       	ldi	r16, 0x40	; 64
     990:	12 e0       	ldi	r17, 0x02	; 2
     992:	d8 01       	movw	r26, r16
     994:	11 96       	adiw	r26, 0x01	; 1
     996:	8c 91       	ld	r24, X
     998:	11 97       	sbiw	r26, 0x01	; 1
     99a:	89 7e       	andi	r24, 0xE9	; 233
     99c:	11 96       	adiw	r26, 0x01	; 1
     99e:	8c 93       	st	X, r24
     9a0:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     9a2:	14 96       	adiw	r26, 0x04	; 4
     9a4:	8c 91       	ld	r24, X
     9a6:	14 97       	sbiw	r26, 0x04	; 4
     9a8:	88 7f       	andi	r24, 0xF8	; 248
     9aa:	83 60       	ori	r24, 0x03	; 3
     9ac:	14 96       	adiw	r26, 0x04	; 4
     9ae:	8c 93       	st	X, r24
     9b0:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     9b2:	12 96       	adiw	r26, 0x02	; 2
     9b4:	8c 91       	ld	r24, X
     9b6:	12 97       	sbiw	r26, 0x02	; 2
     9b8:	8f 7c       	andi	r24, 0xCF	; 207
     9ba:	12 96       	adiw	r26, 0x02	; 2
     9bc:	8c 93       	st	X, r24
     9be:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     9c0:	0f 2e       	mov	r0, r31
     9c2:	f0 e6       	ldi	r31, 0x60	; 96
     9c4:	ef 2e       	mov	r14, r31
     9c6:	f2 e0       	ldi	r31, 0x02	; 2
     9c8:	ff 2e       	mov	r15, r31
     9ca:	f0 2d       	mov	r31, r0
     9cc:	f7 01       	movw	r30, r14
     9ce:	80 81       	ld	r24, Z
     9d0:	80 7e       	andi	r24, 0xE0	; 224
     9d2:	81 60       	ori	r24, 0x01	; 1
     9d4:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     9d6:	89 e0       	ldi	r24, 0x09	; 9
     9d8:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
     9da:	8c 91       	ld	r24, X
     9dc:	81 60       	ori	r24, 0x01	; 1
     9de:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     9e0:	80 e4       	ldi	r24, 0x40	; 64
     9e2:	92 e0       	ldi	r25, 0x02	; 2
     9e4:	0e 94 4c 13 	call	0x2698	; 0x2698 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     9e8:	80 e4       	ldi	r24, 0x40	; 64
     9ea:	92 e0       	ldi	r25, 0x02	; 2
     9ec:	60 e6       	ldi	r22, 0x60	; 96
     9ee:	72 e0       	ldi	r23, 0x02	; 2
     9f0:	40 e0       	ldi	r20, 0x00	; 0
     9f2:	0e 94 56 13 	call	0x26ac	; 0x26ac <ADC_Offset_Get_Unsigned>
     9f6:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
     9f8:	d8 01       	movw	r26, r16
     9fa:	8c 91       	ld	r24, X
     9fc:	8e 7f       	andi	r24, 0xFE	; 254
     9fe:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     a00:	f7 01       	movw	r30, r14
     a02:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     a04:	13 96       	adiw	r26, 0x03	; 3
     a06:	8c 91       	ld	r24, X
     a08:	13 97       	sbiw	r26, 0x03	; 3
     a0a:	8f 73       	andi	r24, 0x3F	; 63
     a0c:	13 96       	adiw	r26, 0x03	; 3
     a0e:	8c 93       	st	X, r24
     a10:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     a12:	8c 91       	ld	r24, X
     a14:	81 60       	ori	r24, 0x01	; 1
     a16:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     a18:	80 e4       	ldi	r24, 0x40	; 64
     a1a:	92 e0       	ldi	r25, 0x02	; 2
     a1c:	0e 94 4c 13 	call	0x2698	; 0x2698 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     a20:	d8 01       	movw	r26, r16
     a22:	11 96       	adiw	r26, 0x01	; 1
     a24:	8c 91       	ld	r24, X
     a26:	11 97       	sbiw	r26, 0x01	; 1
     a28:	88 60       	ori	r24, 0x08	; 8
     a2a:	11 96       	adiw	r26, 0x01	; 1
     a2c:	8c 93       	st	X, r24
     a2e:	ee 24       	eor	r14, r14
     a30:	ff 24       	eor	r15, r15
     a32:	68 94       	set
     a34:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     a36:	44 24       	eor	r4, r4
     a38:	55 24       	eor	r5, r5
     a3a:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     a3c:	20 e0       	ldi	r18, 0x00	; 0
     a3e:	30 e1       	ldi	r19, 0x10	; 16
     a40:	40 e0       	ldi	r20, 0x00	; 0
     a42:	50 e0       	ldi	r21, 0x00	; 0
     a44:	2a 83       	std	Y+2, r18	; 0x02
     a46:	3b 83       	std	Y+3, r19	; 0x03
     a48:	4c 83       	std	Y+4, r20	; 0x04
     a4a:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     a4c:	88 24       	eor	r8, r8
     a4e:	99 24       	eor	r9, r9
     a50:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     a52:	00 e6       	ldi	r16, 0x60	; 96
     a54:	12 e0       	ldi	r17, 0x02	; 2
     a56:	d8 01       	movw	r26, r16
     a58:	13 96       	adiw	r26, 0x03	; 3
     a5a:	8c 91       	ld	r24, X
     a5c:	13 97       	sbiw	r26, 0x03	; 3
     a5e:	80 ff       	sbrs	r24, 0
     a60:	fa cf       	rjmp	.-12     	; 0xa56 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a62:	69 81       	ldd	r22, Y+1	; 0x01
     a64:	c8 01       	movw	r24, r16
     a66:	0e 94 28 13 	call	0x2650	; 0x2650 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
     a6a:	a0 e0       	ldi	r26, 0x00	; 0
     a6c:	b0 e0       	ldi	r27, 0x00	; 0
     a6e:	88 0e       	add	r8, r24
     a70:	99 1e       	adc	r9, r25
     a72:	aa 1e       	adc	r10, r26
     a74:	bb 1e       	adc	r11, r27
     a76:	48 16       	cp	r4, r24
     a78:	59 06       	cpc	r5, r25
     a7a:	6a 06       	cpc	r6, r26
     a7c:	7b 06       	cpc	r7, r27
     a7e:	10 f4       	brcc	.+4      	; 0xa84 <CO_collectBatt+0x158>
     a80:	2c 01       	movw	r4, r24
     a82:	3d 01       	movw	r6, r26
     a84:	2a 81       	ldd	r18, Y+2	; 0x02
     a86:	3b 81       	ldd	r19, Y+3	; 0x03
     a88:	4c 81       	ldd	r20, Y+4	; 0x04
     a8a:	5d 81       	ldd	r21, Y+5	; 0x05
     a8c:	82 17       	cp	r24, r18
     a8e:	93 07       	cpc	r25, r19
     a90:	a4 07       	cpc	r26, r20
     a92:	b5 07       	cpc	r27, r21
     a94:	20 f4       	brcc	.+8      	; 0xa9e <CO_collectBatt+0x172>
     a96:	8a 83       	std	Y+2, r24	; 0x02
     a98:	9b 83       	std	Y+3, r25	; 0x03
     a9a:	ac 83       	std	Y+4, r26	; 0x04
     a9c:	bd 83       	std	Y+5, r27	; 0x05
     a9e:	08 94       	sec
     aa0:	e1 08       	sbc	r14, r1
     aa2:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     aa4:	e1 14       	cp	r14, r1
     aa6:	f1 04       	cpc	r15, r1
     aa8:	b1 f6       	brne	.-84     	; 0xa56 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     aaa:	e0 e4       	ldi	r30, 0x40	; 64
     aac:	f2 e0       	ldi	r31, 0x02	; 2
     aae:	81 81       	ldd	r24, Z+1	; 0x01
     ab0:	87 7f       	andi	r24, 0xF7	; 247
     ab2:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
     ab4:	80 81       	ld	r24, Z
     ab6:	8e 7f       	andi	r24, 0xFE	; 254
     ab8:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     aba:	84 e0       	ldi	r24, 0x04	; 4
     abc:	60 e0       	ldi	r22, 0x00	; 0
     abe:	0e 94 3d 1c 	call	0x387a	; 0x387a <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
     ac8:	c5 01       	movw	r24, r10
     aca:	b4 01       	movw	r22, r8
     acc:	05 2e       	mov	r0, r21
     ace:	5a e0       	ldi	r21, 0x0A	; 10
     ad0:	96 95       	lsr	r25
     ad2:	87 95       	ror	r24
     ad4:	77 95       	ror	r23
     ad6:	67 95       	ror	r22
     ad8:	5a 95       	dec	r21
     ada:	d1 f7       	brne	.-12     	; 0xad0 <CO_collectBatt+0x1a4>
     adc:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     ade:	28 ee       	ldi	r18, 0xE8	; 232
     ae0:	33 e0       	ldi	r19, 0x03	; 3
     ae2:	40 e0       	ldi	r20, 0x00	; 0
     ae4:	50 e0       	ldi	r21, 0x00	; 0
     ae6:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
     aea:	0f 2e       	mov	r0, r31
     aec:	ff ef       	ldi	r31, 0xFF	; 255
     aee:	8f 2e       	mov	r8, r31
     af0:	ff e0       	ldi	r31, 0x0F	; 15
     af2:	9f 2e       	mov	r9, r31
     af4:	f0 e0       	ldi	r31, 0x00	; 0
     af6:	af 2e       	mov	r10, r31
     af8:	f0 e0       	ldi	r31, 0x00	; 0
     afa:	bf 2e       	mov	r11, r31
     afc:	f0 2d       	mov	r31, r0
     afe:	a5 01       	movw	r20, r10
     b00:	94 01       	movw	r18, r8
     b02:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
     b06:	c9 01       	movw	r24, r18
     b08:	c2 97       	sbiw	r24, 0x32	; 50
     b0a:	ae 81       	ldd	r26, Y+6	; 0x06
     b0c:	bf 81       	ldd	r27, Y+7	; 0x07
     b0e:	8d 93       	st	X+, r24
     b10:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     b12:	c3 01       	movw	r24, r6
     b14:	b2 01       	movw	r22, r4
     b16:	28 ee       	ldi	r18, 0xE8	; 232
     b18:	33 e0       	ldi	r19, 0x03	; 3
     b1a:	40 e0       	ldi	r20, 0x00	; 0
     b1c:	50 e0       	ldi	r21, 0x00	; 0
     b1e:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
     b22:	a5 01       	movw	r20, r10
     b24:	94 01       	movw	r18, r8
     b26:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
     b2a:	c9 01       	movw	r24, r18
     b2c:	c2 97       	sbiw	r24, 0x32	; 50
     b2e:	ea 85       	ldd	r30, Y+10	; 0x0a
     b30:	fb 85       	ldd	r31, Y+11	; 0x0b
     b32:	80 83       	st	Z, r24
     b34:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     b36:	6a 81       	ldd	r22, Y+2	; 0x02
     b38:	7b 81       	ldd	r23, Y+3	; 0x03
     b3a:	8c 81       	ldd	r24, Y+4	; 0x04
     b3c:	9d 81       	ldd	r25, Y+5	; 0x05
     b3e:	28 ee       	ldi	r18, 0xE8	; 232
     b40:	33 e0       	ldi	r19, 0x03	; 3
     b42:	40 e0       	ldi	r20, 0x00	; 0
     b44:	50 e0       	ldi	r21, 0x00	; 0
     b46:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
     b4a:	a5 01       	movw	r20, r10
     b4c:	94 01       	movw	r18, r8
     b4e:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
     b52:	22 53       	subi	r18, 0x32	; 50
     b54:	30 40       	sbci	r19, 0x00	; 0
     b56:	a8 85       	ldd	r26, Y+8	; 0x08
     b58:	b9 85       	ldd	r27, Y+9	; 0x09
     b5a:	2d 93       	st	X+, r18
     b5c:	3c 93       	st	X, r19
     b5e:	11 97       	sbiw	r26, 0x01	; 1
}
     b60:	2b 96       	adiw	r28, 0x0b	; 11
     b62:	cd bf       	out	0x3d, r28	; 61
     b64:	de bf       	out	0x3e, r29	; 62
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	1f 91       	pop	r17
     b6c:	0f 91       	pop	r16
     b6e:	ff 90       	pop	r15
     b70:	ef 90       	pop	r14
     b72:	bf 90       	pop	r11
     b74:	af 90       	pop	r10
     b76:	9f 90       	pop	r9
     b78:	8f 90       	pop	r8
     b7a:	7f 90       	pop	r7
     b7c:	6f 90       	pop	r6
     b7e:	5f 90       	pop	r5
     b80:	4f 90       	pop	r4
     b82:	08 95       	ret

00000b84 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     b84:	4f 92       	push	r4
     b86:	5f 92       	push	r5
     b88:	6f 92       	push	r6
     b8a:	7f 92       	push	r7
     b8c:	8f 92       	push	r8
     b8e:	9f 92       	push	r9
     b90:	af 92       	push	r10
     b92:	bf 92       	push	r11
     b94:	ef 92       	push	r14
     b96:	ff 92       	push	r15
     b98:	0f 93       	push	r16
     b9a:	1f 93       	push	r17
     b9c:	cf 93       	push	r28
     b9e:	df 93       	push	r29
     ba0:	cd b7       	in	r28, 0x3d	; 61
     ba2:	de b7       	in	r29, 0x3e	; 62
     ba4:	2b 97       	sbiw	r28, 0x0b	; 11
     ba6:	cd bf       	out	0x3d, r28	; 61
     ba8:	de bf       	out	0x3e, r29	; 62
     baa:	8e 83       	std	Y+6, r24	; 0x06
     bac:	9f 83       	std	Y+7, r25	; 0x07
     bae:	68 87       	std	Y+8, r22	; 0x08
     bb0:	79 87       	std	Y+9, r23	; 0x09
     bb2:	4a 87       	std	Y+10, r20	; 0x0a
     bb4:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     bb6:	81 e0       	ldi	r24, 0x01	; 1
     bb8:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	92 e0       	ldi	r25, 0x02	; 2
     bc0:	0e 94 c7 13 	call	0x278e	; 0x278e <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     bc4:	00 e0       	ldi	r16, 0x00	; 0
     bc6:	12 e0       	ldi	r17, 0x02	; 2
     bc8:	d8 01       	movw	r26, r16
     bca:	11 96       	adiw	r26, 0x01	; 1
     bcc:	8c 91       	ld	r24, X
     bce:	11 97       	sbiw	r26, 0x01	; 1
     bd0:	89 7e       	andi	r24, 0xE9	; 233
     bd2:	11 96       	adiw	r26, 0x01	; 1
     bd4:	8c 93       	st	X, r24
     bd6:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     bd8:	14 96       	adiw	r26, 0x04	; 4
     bda:	8c 91       	ld	r24, X
     bdc:	14 97       	sbiw	r26, 0x04	; 4
     bde:	88 7f       	andi	r24, 0xF8	; 248
     be0:	83 60       	ori	r24, 0x03	; 3
     be2:	14 96       	adiw	r26, 0x04	; 4
     be4:	8c 93       	st	X, r24
     be6:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     be8:	12 96       	adiw	r26, 0x02	; 2
     bea:	8c 91       	ld	r24, X
     bec:	12 97       	sbiw	r26, 0x02	; 2
     bee:	8f 7c       	andi	r24, 0xCF	; 207
     bf0:	12 96       	adiw	r26, 0x02	; 2
     bf2:	8c 93       	st	X, r24
     bf4:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     bf6:	0f 2e       	mov	r0, r31
     bf8:	f0 e2       	ldi	r31, 0x20	; 32
     bfa:	ef 2e       	mov	r14, r31
     bfc:	f2 e0       	ldi	r31, 0x02	; 2
     bfe:	ff 2e       	mov	r15, r31
     c00:	f0 2d       	mov	r31, r0
     c02:	f7 01       	movw	r30, r14
     c04:	80 81       	ld	r24, Z
     c06:	80 7e       	andi	r24, 0xE0	; 224
     c08:	81 60       	ori	r24, 0x01	; 1
     c0a:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     c0c:	89 e0       	ldi	r24, 0x09	; 9
     c0e:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     c10:	8c 91       	ld	r24, X
     c12:	81 60       	ori	r24, 0x01	; 1
     c14:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     c16:	80 e0       	ldi	r24, 0x00	; 0
     c18:	92 e0       	ldi	r25, 0x02	; 2
     c1a:	0e 94 4c 13 	call	0x2698	; 0x2698 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	92 e0       	ldi	r25, 0x02	; 2
     c22:	60 e2       	ldi	r22, 0x20	; 32
     c24:	72 e0       	ldi	r23, 0x02	; 2
     c26:	40 e0       	ldi	r20, 0x00	; 0
     c28:	0e 94 56 13 	call	0x26ac	; 0x26ac <ADC_Offset_Get_Unsigned>
     c2c:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     c2e:	d8 01       	movw	r26, r16
     c30:	8c 91       	ld	r24, X
     c32:	8e 7f       	andi	r24, 0xFE	; 254
     c34:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     c36:	f7 01       	movw	r30, r14
     c38:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     c3a:	13 96       	adiw	r26, 0x03	; 3
     c3c:	8c 91       	ld	r24, X
     c3e:	13 97       	sbiw	r26, 0x03	; 3
     c40:	8f 73       	andi	r24, 0x3F	; 63
     c42:	13 96       	adiw	r26, 0x03	; 3
     c44:	8c 93       	st	X, r24
     c46:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     c48:	8c 91       	ld	r24, X
     c4a:	81 60       	ori	r24, 0x01	; 1
     c4c:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     c4e:	80 e0       	ldi	r24, 0x00	; 0
     c50:	92 e0       	ldi	r25, 0x02	; 2
     c52:	0e 94 4c 13 	call	0x2698	; 0x2698 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     c56:	d8 01       	movw	r26, r16
     c58:	11 96       	adiw	r26, 0x01	; 1
     c5a:	8c 91       	ld	r24, X
     c5c:	11 97       	sbiw	r26, 0x01	; 1
     c5e:	88 60       	ori	r24, 0x08	; 8
     c60:	11 96       	adiw	r26, 0x01	; 1
     c62:	8c 93       	st	X, r24
     c64:	ee 24       	eor	r14, r14
     c66:	ff 24       	eor	r15, r15
     c68:	68 94       	set
     c6a:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     c6c:	44 24       	eor	r4, r4
     c6e:	55 24       	eor	r5, r5
     c70:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     c72:	20 e0       	ldi	r18, 0x00	; 0
     c74:	30 e1       	ldi	r19, 0x10	; 16
     c76:	40 e0       	ldi	r20, 0x00	; 0
     c78:	50 e0       	ldi	r21, 0x00	; 0
     c7a:	2a 83       	std	Y+2, r18	; 0x02
     c7c:	3b 83       	std	Y+3, r19	; 0x03
     c7e:	4c 83       	std	Y+4, r20	; 0x04
     c80:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     c82:	88 24       	eor	r8, r8
     c84:	99 24       	eor	r9, r9
     c86:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     c88:	00 e2       	ldi	r16, 0x20	; 32
     c8a:	12 e0       	ldi	r17, 0x02	; 2
     c8c:	d8 01       	movw	r26, r16
     c8e:	13 96       	adiw	r26, 0x03	; 3
     c90:	8c 91       	ld	r24, X
     c92:	13 97       	sbiw	r26, 0x03	; 3
     c94:	80 ff       	sbrs	r24, 0
     c96:	fa cf       	rjmp	.-12     	; 0xc8c <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     c98:	69 81       	ldd	r22, Y+1	; 0x01
     c9a:	c8 01       	movw	r24, r16
     c9c:	0e 94 28 13 	call	0x2650	; 0x2650 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
     ca0:	a0 e0       	ldi	r26, 0x00	; 0
     ca2:	b0 e0       	ldi	r27, 0x00	; 0
     ca4:	88 0e       	add	r8, r24
     ca6:	99 1e       	adc	r9, r25
     ca8:	aa 1e       	adc	r10, r26
     caa:	bb 1e       	adc	r11, r27
     cac:	48 16       	cp	r4, r24
     cae:	59 06       	cpc	r5, r25
     cb0:	6a 06       	cpc	r6, r26
     cb2:	7b 06       	cpc	r7, r27
     cb4:	10 f4       	brcc	.+4      	; 0xcba <CO_collectTemp+0x136>
     cb6:	2c 01       	movw	r4, r24
     cb8:	3d 01       	movw	r6, r26
     cba:	2a 81       	ldd	r18, Y+2	; 0x02
     cbc:	3b 81       	ldd	r19, Y+3	; 0x03
     cbe:	4c 81       	ldd	r20, Y+4	; 0x04
     cc0:	5d 81       	ldd	r21, Y+5	; 0x05
     cc2:	82 17       	cp	r24, r18
     cc4:	93 07       	cpc	r25, r19
     cc6:	a4 07       	cpc	r26, r20
     cc8:	b5 07       	cpc	r27, r21
     cca:	20 f4       	brcc	.+8      	; 0xcd4 <CO_collectTemp+0x150>
     ccc:	8a 83       	std	Y+2, r24	; 0x02
     cce:	9b 83       	std	Y+3, r25	; 0x03
     cd0:	ac 83       	std	Y+4, r26	; 0x04
     cd2:	bd 83       	std	Y+5, r27	; 0x05
     cd4:	08 94       	sec
     cd6:	e1 08       	sbc	r14, r1
     cd8:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     cda:	e1 14       	cp	r14, r1
     cdc:	f1 04       	cpc	r15, r1
     cde:	b1 f6       	brne	.-84     	; 0xc8c <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     ce0:	e0 e0       	ldi	r30, 0x00	; 0
     ce2:	f2 e0       	ldi	r31, 0x02	; 2
     ce4:	81 81       	ldd	r24, Z+1	; 0x01
     ce6:	87 7f       	andi	r24, 0xF7	; 247
     ce8:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     cea:	80 81       	ld	r24, Z
     cec:	82 60       	ori	r24, 0x02	; 2
     cee:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
     cf0:	80 81       	ld	r24, Z
     cf2:	8e 7f       	andi	r24, 0xFE	; 254
     cf4:	80 83       	st	Z, r24

	ADCPower(FALSE);
     cf6:	80 e0       	ldi	r24, 0x00	; 0
     cf8:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>

	average = sum / NUM_SAMPLES;
     cfc:	c5 01       	movw	r24, r10
     cfe:	b4 01       	movw	r22, r8
     d00:	05 2e       	mov	r0, r21
     d02:	5a e0       	ldi	r21, 0x0A	; 10
     d04:	96 95       	lsr	r25
     d06:	87 95       	ror	r24
     d08:	77 95       	ror	r23
     d0a:	67 95       	ror	r22
     d0c:	5a 95       	dec	r21
     d0e:	d1 f7       	brne	.-12     	; 0xd04 <CO_collectTemp+0x180>
     d10:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     d12:	28 ee       	ldi	r18, 0xE8	; 232
     d14:	33 e0       	ldi	r19, 0x03	; 3
     d16:	40 e0       	ldi	r20, 0x00	; 0
     d18:	50 e0       	ldi	r21, 0x00	; 0
     d1a:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
     d1e:	0f 2e       	mov	r0, r31
     d20:	ff ef       	ldi	r31, 0xFF	; 255
     d22:	8f 2e       	mov	r8, r31
     d24:	ff e0       	ldi	r31, 0x0F	; 15
     d26:	9f 2e       	mov	r9, r31
     d28:	f0 e0       	ldi	r31, 0x00	; 0
     d2a:	af 2e       	mov	r10, r31
     d2c:	f0 e0       	ldi	r31, 0x00	; 0
     d2e:	bf 2e       	mov	r11, r31
     d30:	f0 2d       	mov	r31, r0
     d32:	a5 01       	movw	r20, r10
     d34:	94 01       	movw	r18, r8
     d36:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
     d3a:	c9 01       	movw	r24, r18
     d3c:	c2 97       	sbiw	r24, 0x32	; 50
     d3e:	ae 81       	ldd	r26, Y+6	; 0x06
     d40:	bf 81       	ldd	r27, Y+7	; 0x07
     d42:	8d 93       	st	X+, r24
     d44:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     d46:	c3 01       	movw	r24, r6
     d48:	b2 01       	movw	r22, r4
     d4a:	28 ee       	ldi	r18, 0xE8	; 232
     d4c:	33 e0       	ldi	r19, 0x03	; 3
     d4e:	40 e0       	ldi	r20, 0x00	; 0
     d50:	50 e0       	ldi	r21, 0x00	; 0
     d52:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
     d56:	a5 01       	movw	r20, r10
     d58:	94 01       	movw	r18, r8
     d5a:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
     d5e:	c9 01       	movw	r24, r18
     d60:	c2 97       	sbiw	r24, 0x32	; 50
     d62:	ea 85       	ldd	r30, Y+10	; 0x0a
     d64:	fb 85       	ldd	r31, Y+11	; 0x0b
     d66:	80 83       	st	Z, r24
     d68:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     d6a:	6a 81       	ldd	r22, Y+2	; 0x02
     d6c:	7b 81       	ldd	r23, Y+3	; 0x03
     d6e:	8c 81       	ldd	r24, Y+4	; 0x04
     d70:	9d 81       	ldd	r25, Y+5	; 0x05
     d72:	28 ee       	ldi	r18, 0xE8	; 232
     d74:	33 e0       	ldi	r19, 0x03	; 3
     d76:	40 e0       	ldi	r20, 0x00	; 0
     d78:	50 e0       	ldi	r21, 0x00	; 0
     d7a:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
     d7e:	a5 01       	movw	r20, r10
     d80:	94 01       	movw	r18, r8
     d82:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
     d86:	22 53       	subi	r18, 0x32	; 50
     d88:	30 40       	sbci	r19, 0x00	; 0
     d8a:	a8 85       	ldd	r26, Y+8	; 0x08
     d8c:	b9 85       	ldd	r27, Y+9	; 0x09
     d8e:	2d 93       	st	X+, r18
     d90:	3c 93       	st	X, r19
     d92:	11 97       	sbiw	r26, 0x01	; 1
}
     d94:	2b 96       	adiw	r28, 0x0b	; 11
     d96:	cd bf       	out	0x3d, r28	; 61
     d98:	de bf       	out	0x3e, r29	; 62
     d9a:	df 91       	pop	r29
     d9c:	cf 91       	pop	r28
     d9e:	1f 91       	pop	r17
     da0:	0f 91       	pop	r16
     da2:	ff 90       	pop	r15
     da4:	ef 90       	pop	r14
     da6:	bf 90       	pop	r11
     da8:	af 90       	pop	r10
     daa:	9f 90       	pop	r9
     dac:	8f 90       	pop	r8
     dae:	7f 90       	pop	r7
     db0:	6f 90       	pop	r6
     db2:	5f 90       	pop	r5
     db4:	4f 90       	pop	r4
     db6:	08 95       	ret

00000db8 <enableADCMUX>:
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	
	if(on) {
     db8:	88 23       	and	r24, r24
     dba:	31 f0       	breq	.+12     	; 0xdc8 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
     dbc:	e0 e0       	ldi	r30, 0x00	; 0
     dbe:	f6 e0       	ldi	r31, 0x06	; 6
     dc0:	80 e2       	ldi	r24, 0x20	; 32
     dc2:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
     dc4:	85 83       	std	Z+5, r24	; 0x05
     dc6:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
     dc8:	e0 e0       	ldi	r30, 0x00	; 0
     dca:	f6 e0       	ldi	r31, 0x06	; 6
     dcc:	80 e2       	ldi	r24, 0x20	; 32
     dce:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     dd0:	82 83       	std	Z+2, r24	; 0x02
     dd2:	08 95       	ret

00000dd4 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
     dd4:	1f 92       	push	r1
     dd6:	0f 92       	push	r0
     dd8:	0f b6       	in	r0, 0x3f	; 63
     dda:	0f 92       	push	r0
     ddc:	0b b6       	in	r0, 0x3b	; 59
     dde:	0f 92       	push	r0
     de0:	11 24       	eor	r1, r1
     de2:	2f 93       	push	r18
     de4:	3f 93       	push	r19
     de6:	4f 93       	push	r20
     de8:	5f 93       	push	r21
     dea:	6f 93       	push	r22
     dec:	7f 93       	push	r23
     dee:	8f 93       	push	r24
     df0:	9f 93       	push	r25
     df2:	af 93       	push	r26
     df4:	bf 93       	push	r27
     df6:	ef 93       	push	r30
     df8:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     dfa:	e0 e4       	ldi	r30, 0x40	; 64
     dfc:	fa e0       	ldi	r31, 0x0A	; 10
     dfe:	80 81       	ld	r24, Z
     e00:	80 7f       	andi	r24, 0xF0	; 240
     e02:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e04:	a0 e0       	ldi	r26, 0x00	; 0
     e06:	b8 e0       	ldi	r27, 0x08	; 8
     e08:	8c 91       	ld	r24, X
     e0a:	80 7f       	andi	r24, 0xF0	; 240
     e0c:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e0e:	a0 e0       	ldi	r26, 0x00	; 0
     e10:	b9 e0       	ldi	r27, 0x09	; 9
     e12:	8c 91       	ld	r24, X
     e14:	80 7f       	andi	r24, 0xF0	; 240
     e16:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e18:	80 81       	ld	r24, Z
     e1a:	80 7f       	andi	r24, 0xF0	; 240
     e1c:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
     e26:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	enableADCMUX(FALSE);
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	80 93 d5 50 	sts	0x50D5, r24
	DataAvailable = 1;
     e36:	80 93 d5 21 	sts	0x21D5, r24
}
     e3a:	ff 91       	pop	r31
     e3c:	ef 91       	pop	r30
     e3e:	bf 91       	pop	r27
     e40:	af 91       	pop	r26
     e42:	9f 91       	pop	r25
     e44:	8f 91       	pop	r24
     e46:	7f 91       	pop	r23
     e48:	6f 91       	pop	r22
     e4a:	5f 91       	pop	r21
     e4c:	4f 91       	pop	r20
     e4e:	3f 91       	pop	r19
     e50:	2f 91       	pop	r18
     e52:	0f 90       	pop	r0
     e54:	0b be       	out	0x3b, r0	; 59
     e56:	0f 90       	pop	r0
     e58:	0f be       	out	0x3f, r0	; 63
     e5a:	0f 90       	pop	r0
     e5c:	1f 90       	pop	r1
     e5e:	18 95       	reti

00000e60 <ADC_Stop_Sampling>:
//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e60:	e0 e4       	ldi	r30, 0x40	; 64
     e62:	fa e0       	ldi	r31, 0x0A	; 10
     e64:	80 81       	ld	r24, Z
     e66:	80 7f       	andi	r24, 0xF0	; 240
     e68:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e6a:	a0 e0       	ldi	r26, 0x00	; 0
     e6c:	b8 e0       	ldi	r27, 0x08	; 8
     e6e:	8c 91       	ld	r24, X
     e70:	80 7f       	andi	r24, 0xF0	; 240
     e72:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e74:	a0 e0       	ldi	r26, 0x00	; 0
     e76:	b9 e0       	ldi	r27, 0x09	; 9
     e78:	8c 91       	ld	r24, X
     e7a:	80 7f       	andi	r24, 0xF0	; 240
     e7c:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e7e:	80 81       	ld	r24, Z
     e80:	80 7f       	andi	r24, 0xF0	; 240
     e82:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
     e8c:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	enableADCMUX(FALSE);
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <enableADCMUX>
	ADC_Sampling_Finished = 1;
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	80 93 d5 50 	sts	0x50D5, r24
	DataAvailable = 1;
     e9c:	80 93 d5 21 	sts	0x21D5, r24
}
     ea0:	08 95       	ret

00000ea2 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
	
	if(ADC_Sampling_Finished){
     ea2:	80 91 d5 50 	lds	r24, 0x50D5
     ea6:	88 23       	and	r24, r24
     ea8:	49 f0       	breq	.+18     	; 0xebc <ADC_Get_Num_Samples+0x1a>
		uint16_t count;
		count = TCC1.CNT;
     eaa:	e0 e4       	ldi	r30, 0x40	; 64
     eac:	f8 e0       	ldi	r31, 0x08	; 8
     eae:	80 a1       	lds	r24, 0x40
     eb0:	91 a1       	lds	r25, 0x41
		if(count == 0) count = TCC1.PER;
     eb2:	00 97       	sbiw	r24, 0x00	; 0
     eb4:	29 f4       	brne	.+10     	; 0xec0 <ADC_Get_Num_Samples+0x1e>
     eb6:	86 a1       	lds	r24, 0x46
     eb8:	97 a1       	lds	r25, 0x47
     eba:	08 95       	ret
		return count;
	}
	else return 0;		
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	90 e0       	ldi	r25, 0x00	; 0
}
     ec0:	08 95       	ret

00000ec2 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
     ec2:	e0 ea       	ldi	r30, 0xA0	; 160
     ec4:	f6 e0       	ldi	r31, 0x06	; 6
     ec6:	13 86       	std	Z+11, r1	; 0x0b
}
     ec8:	08 95       	ret

00000eca <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
     eca:	81 e0       	ldi	r24, 0x01	; 1
     ecc:	e0 ea       	ldi	r30, 0xA0	; 160
     ece:	f6 e0       	ldi	r31, 0x06	; 6
     ed0:	83 87       	std	Z+11, r24	; 0x0b
}	
     ed2:	08 95       	ret

00000ed4 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
     ed4:	1f 92       	push	r1
     ed6:	0f 92       	push	r0
     ed8:	0f b6       	in	r0, 0x3f	; 63
     eda:	0f 92       	push	r0
     edc:	0b b6       	in	r0, 0x3b	; 59
     ede:	0f 92       	push	r0
     ee0:	11 24       	eor	r1, r1
     ee2:	6f 92       	push	r6
     ee4:	7f 92       	push	r7
     ee6:	8f 92       	push	r8
     ee8:	9f 92       	push	r9
     eea:	af 92       	push	r10
     eec:	bf 92       	push	r11
     eee:	cf 92       	push	r12
     ef0:	df 92       	push	r13
     ef2:	ef 92       	push	r14
     ef4:	ff 92       	push	r15
     ef6:	0f 93       	push	r16
     ef8:	1f 93       	push	r17
     efa:	2f 93       	push	r18
     efc:	3f 93       	push	r19
     efe:	4f 93       	push	r20
     f00:	5f 93       	push	r21
     f02:	6f 93       	push	r22
     f04:	7f 93       	push	r23
     f06:	8f 93       	push	r24
     f08:	9f 93       	push	r25
     f0a:	af 93       	push	r26
     f0c:	bf 93       	push	r27
     f0e:	ef 93       	push	r30
     f10:	ff 93       	push	r31
     f12:	cf 93       	push	r28
     f14:	df 93       	push	r29
     f16:	00 d0       	rcall	.+0      	; 0xf18 <__vector_104+0x44>
     f18:	0f 92       	push	r0
     f1a:	cd b7       	in	r28, 0x3d	; 61
     f1c:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	if (discardCount < ADC_DISCARD) {
     f1e:	80 91 5d 40 	lds	r24, 0x405D
     f22:	88 23       	and	r24, r24
     f24:	8c f0       	brlt	.+34     	; 0xf48 <__vector_104+0x74>
		discardCount++;
     f26:	80 91 5d 40 	lds	r24, 0x405D
     f2a:	8f 5f       	subi	r24, 0xFF	; 255
     f2c:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
     f30:	80 91 5d 40 	lds	r24, 0x405D
     f34:	80 38       	cpi	r24, 0x80	; 128
     f36:	09 f0       	breq	.+2      	; 0xf3a <__vector_104+0x66>
     f38:	c4 c0       	rjmp	.+392    	; 0x10c2 <__vector_104+0x1ee>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
     f3a:	e0 e4       	ldi	r30, 0x40	; 64
     f3c:	f8 e0       	ldi	r31, 0x08	; 8
     f3e:	80 81       	ld	r24, Z
     f40:	80 7f       	andi	r24, 0xF0	; 240
     f42:	89 60       	ori	r24, 0x09	; 9
     f44:	80 83       	st	Z, r24
     f46:	bd c0       	rjmp	.+378    	; 0x10c2 <__vector_104+0x1ee>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
     f4e:	82 e0       	ldi	r24, 0x02	; 2
     f50:	e0 ea       	ldi	r30, 0xA0	; 160
     f52:	f6 e0       	ldi	r31, 0x06	; 6
     f54:	86 83       	std	Z+6, r24	; 0x06
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     f5a:	e0 ec       	ldi	r30, 0xC0	; 192
     f5c:	f8 e0       	ldi	r31, 0x08	; 8
     f5e:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
     f60:	25 e6       	ldi	r18, 0x65	; 101
     f62:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     f64:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
     f66:	42 81       	ldd	r20, Z+2	; 0x02
     f68:	44 23       	and	r20, r20
     f6a:	ec f7       	brge	.-6      	; 0xf66 <__vector_104+0x92>
			SPIBuffer[bufIndex] = SPIC.DATA;
     f6c:	43 81       	ldd	r20, Z+3	; 0x03
     f6e:	d9 01       	movw	r26, r18
     f70:	a8 0f       	add	r26, r24
     f72:	b9 1f       	adc	r27, r25
     f74:	4c 93       	st	X, r20
     f76:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     f78:	83 30       	cpi	r24, 0x03	; 3
     f7a:	91 05       	cpc	r25, r1
     f7c:	99 f7       	brne	.-26     	; 0xf64 <__vector_104+0x90>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
     f7e:	82 e0       	ldi	r24, 0x02	; 2
     f80:	e0 ea       	ldi	r30, 0xA0	; 160
     f82:	f6 e0       	ldi	r31, 0x06	; 6
     f84:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
     f8c:	80 91 65 50 	lds	r24, 0x5065
     f90:	88 23       	and	r24, r24
     f92:	1c f4       	brge	.+6      	; 0xf9a <__vector_104+0xc6>
     f94:	8f ef       	ldi	r24, 0xFF	; 255
     f96:	8c 83       	std	Y+4, r24	; 0x04
     f98:	01 c0       	rjmp	.+2      	; 0xf9c <__vector_104+0xc8>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
     f9a:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
     f9c:	80 91 65 50 	lds	r24, 0x5065
     fa0:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
     fa2:	80 91 66 50 	lds	r24, 0x5066
     fa6:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
     fa8:	80 91 67 50 	lds	r24, 0x5067
     fac:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
     fae:	89 81       	ldd	r24, Y+1	; 0x01
     fb0:	9a 81       	ldd	r25, Y+2	; 0x02
     fb2:	ab 81       	ldd	r26, Y+3	; 0x03
     fb4:	bc 81       	ldd	r27, Y+4	; 0x04
     fb6:	ac 01       	movw	r20, r24
     fb8:	bd 01       	movw	r22, r26
     fba:	77 0f       	add	r23, r23
     fbc:	44 0b       	sbc	r20, r20
     fbe:	54 2f       	mov	r21, r20
     fc0:	ba 01       	movw	r22, r20
     fc2:	80 93 a6 50 	sts	0x50A6, r24
     fc6:	90 93 a7 50 	sts	0x50A7, r25
     fca:	a0 93 a8 50 	sts	0x50A8, r26
     fce:	b0 93 a9 50 	sts	0x50A9, r27
     fd2:	40 93 aa 50 	sts	0x50AA, r20
     fd6:	40 93 ab 50 	sts	0x50AB, r20
     fda:	40 93 ac 50 	sts	0x50AC, r20
     fde:	40 93 ad 50 	sts	0x50AD, r20
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
     fe2:	80 90 74 50 	lds	r8, 0x5074
     fe6:	90 90 75 50 	lds	r9, 0x5075
     fea:	a0 90 76 50 	lds	r10, 0x5076
     fee:	b0 90 77 50 	lds	r11, 0x5077
     ff2:	20 91 a6 50 	lds	r18, 0x50A6
     ff6:	30 91 a7 50 	lds	r19, 0x50A7
     ffa:	40 91 a8 50 	lds	r20, 0x50A8
     ffe:	50 91 a9 50 	lds	r21, 0x50A9
    1002:	60 91 aa 50 	lds	r22, 0x50AA
    1006:	70 91 ab 50 	lds	r23, 0x50AB
    100a:	80 91 ac 50 	lds	r24, 0x50AC
    100e:	90 91 ad 50 	lds	r25, 0x50AD
    1012:	f4 01       	movw	r30, r8
    1014:	ee 0f       	add	r30, r30
    1016:	ff 1f       	adc	r31, r31
    1018:	ee 0f       	add	r30, r30
    101a:	ff 1f       	adc	r31, r31
    101c:	60 90 72 50 	lds	r6, 0x5072
    1020:	70 90 73 50 	lds	r7, 0x5073
    1024:	6e 0e       	add	r6, r30
    1026:	7f 1e       	adc	r7, r31
    1028:	0f 2e       	mov	r0, r31
    102a:	f0 ea       	ldi	r31, 0xA0	; 160
    102c:	af 2e       	mov	r10, r31
    102e:	f0 2d       	mov	r31, r0
    1030:	0f 2e       	mov	r0, r31
    1032:	f5 e2       	ldi	r31, 0x25	; 37
    1034:	bf 2e       	mov	r11, r31
    1036:	f0 2d       	mov	r31, r0
    1038:	0f 2e       	mov	r0, r31
    103a:	f6 e2       	ldi	r31, 0x26	; 38
    103c:	cf 2e       	mov	r12, r31
    103e:	f0 2d       	mov	r31, r0
    1040:	dd 24       	eor	r13, r13
    1042:	ee 24       	eor	r14, r14
    1044:	ff 24       	eor	r15, r15
    1046:	00 e0       	ldi	r16, 0x00	; 0
    1048:	10 e0       	ldi	r17, 0x00	; 0
    104a:	0e 94 16 2d 	call	0x5a2c	; 0x5a2c <__muldi3>
    104e:	aa 24       	eor	r10, r10
    1050:	aa 94       	dec	r10
    1052:	bb 24       	eor	r11, r11
    1054:	ba 94       	dec	r11
    1056:	0f 2e       	mov	r0, r31
    1058:	ff e7       	ldi	r31, 0x7F	; 127
    105a:	cf 2e       	mov	r12, r31
    105c:	f0 2d       	mov	r31, r0
    105e:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <__divdi3>
    1062:	01 e0       	ldi	r16, 0x01	; 1
    1064:	0e 94 e9 2d 	call	0x5bd2	; 0x5bd2 <__ashldi3>
    1068:	0f 2e       	mov	r0, r31
    106a:	f3 e0       	ldi	r31, 0x03	; 3
    106c:	af 2e       	mov	r10, r31
    106e:	f0 2d       	mov	r31, r0
    1070:	bb 24       	eor	r11, r11
    1072:	cc 24       	eor	r12, r12
    1074:	00 e0       	ldi	r16, 0x00	; 0
    1076:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <__divdi3>
    107a:	82 2e       	mov	r8, r18
    107c:	93 2e       	mov	r9, r19
    107e:	a4 2e       	mov	r10, r20
    1080:	b5 2e       	mov	r11, r21
    1082:	b0 94       	com	r11
    1084:	a0 94       	com	r10
    1086:	90 94       	com	r9
    1088:	80 94       	com	r8
    108a:	81 1c       	adc	r8, r1
    108c:	91 1c       	adc	r9, r1
    108e:	a1 1c       	adc	r10, r1
    1090:	b1 1c       	adc	r11, r1
    1092:	f3 01       	movw	r30, r6
    1094:	80 82       	st	Z, r8
    1096:	91 82       	std	Z+1, r9	; 0x01
    1098:	a2 82       	std	Z+2, r10	; 0x02
    109a:	b3 82       	std	Z+3, r11	; 0x03
		sampleCount++;
    109c:	80 91 74 50 	lds	r24, 0x5074
    10a0:	90 91 75 50 	lds	r25, 0x5075
    10a4:	a0 91 76 50 	lds	r26, 0x5076
    10a8:	b0 91 77 50 	lds	r27, 0x5077
    10ac:	01 96       	adiw	r24, 0x01	; 1
    10ae:	a1 1d       	adc	r26, r1
    10b0:	b1 1d       	adc	r27, r1
    10b2:	80 93 74 50 	sts	0x5074, r24
    10b6:	90 93 75 50 	sts	0x5075, r25
    10ba:	a0 93 76 50 	sts	0x5076, r26
    10be:	b0 93 77 50 	sts	0x5077, r27
	}
}
    10c2:	24 96       	adiw	r28, 0x04	; 4
    10c4:	cd bf       	out	0x3d, r28	; 61
    10c6:	de bf       	out	0x3e, r29	; 62
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	ff 91       	pop	r31
    10ce:	ef 91       	pop	r30
    10d0:	bf 91       	pop	r27
    10d2:	af 91       	pop	r26
    10d4:	9f 91       	pop	r25
    10d6:	8f 91       	pop	r24
    10d8:	7f 91       	pop	r23
    10da:	6f 91       	pop	r22
    10dc:	5f 91       	pop	r21
    10de:	4f 91       	pop	r20
    10e0:	3f 91       	pop	r19
    10e2:	2f 91       	pop	r18
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	ff 90       	pop	r15
    10ea:	ef 90       	pop	r14
    10ec:	df 90       	pop	r13
    10ee:	cf 90       	pop	r12
    10f0:	bf 90       	pop	r11
    10f2:	af 90       	pop	r10
    10f4:	9f 90       	pop	r9
    10f6:	8f 90       	pop	r8
    10f8:	7f 90       	pop	r7
    10fa:	6f 90       	pop	r6
    10fc:	0f 90       	pop	r0
    10fe:	0b be       	out	0x3b, r0	; 59
    1100:	0f 90       	pop	r0
    1102:	0f be       	out	0x3f, r0	; 63
    1104:	0f 90       	pop	r0
    1106:	1f 90       	pop	r1
    1108:	18 95       	reti

0000110a <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    110a:	88 23       	and	r24, r24
    110c:	49 f0       	breq	.+18     	; 0x1120 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    110e:	80 e2       	ldi	r24, 0x20	; 32
    1110:	60 e0       	ldi	r22, 0x00	; 0
    1112:	0e 94 95 1c 	call	0x392a	; 0x392a <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1116:	80 e2       	ldi	r24, 0x20	; 32
    1118:	60 e0       	ldi	r22, 0x00	; 0
    111a:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
    111e:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1120:	80 e2       	ldi	r24, 0x20	; 32
    1122:	60 e0       	ldi	r22, 0x00	; 0
    1124:	0e 94 3d 1c 	call	0x387a	; 0x387a <PortEx_DIRCLR>
    1128:	08 95       	ret

0000112a <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    112a:	1f 92       	push	r1
    112c:	0f 92       	push	r0
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	0f 92       	push	r0
    1132:	0b b6       	in	r0, 0x3b	; 59
    1134:	0f 92       	push	r0
    1136:	11 24       	eor	r1, r1
    1138:	ff 92       	push	r15
    113a:	0f 93       	push	r16
    113c:	1f 93       	push	r17
    113e:	2f 93       	push	r18
    1140:	3f 93       	push	r19
    1142:	4f 93       	push	r20
    1144:	5f 93       	push	r21
    1146:	6f 93       	push	r22
    1148:	7f 93       	push	r23
    114a:	8f 93       	push	r24
    114c:	9f 93       	push	r25
    114e:	af 93       	push	r26
    1150:	bf 93       	push	r27
    1152:	ef 93       	push	r30
    1154:	ff 93       	push	r31
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	cd b7       	in	r28, 0x3d	; 61
    115c:	de b7       	in	r29, 0x3e	; 62
    115e:	28 97       	sbiw	r28, 0x08	; 8
    1160:	cd bf       	out	0x3d, r28	; 61
    1162:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1164:	19 82       	std	Y+1, r1	; 0x01
    1166:	1a 82       	std	Y+2, r1	; 0x02
    1168:	1b 82       	std	Y+3, r1	; 0x03
    116a:	1c 82       	std	Y+4, r1	; 0x04
    116c:	20 e0       	ldi	r18, 0x00	; 0
    116e:	30 e0       	ldi	r19, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1170:	05 e6       	ldi	r16, 0x65	; 101
    1172:	10 e5       	ldi	r17, 0x50	; 80
    1174:	ff 24       	eor	r15, r15
    1176:	fa 94       	dec	r15
    1178:	c9 01       	movw	r24, r18
    117a:	f8 01       	movw	r30, r16
    117c:	e2 0f       	add	r30, r18
    117e:	f3 1f       	adc	r31, r19
    1180:	40 81       	ld	r20, Z
    1182:	44 23       	and	r20, r20
    1184:	14 f4       	brge	.+4      	; 0x118a <__vector_14+0x60>
    1186:	f8 86       	std	Y+8, r15	; 0x08
    1188:	01 c0       	rjmp	.+2      	; 0x118c <__vector_14+0x62>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    118a:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    118c:	80 0f       	add	r24, r16
    118e:	91 1f       	adc	r25, r17
    1190:	fc 01       	movw	r30, r24
    1192:	80 81       	ld	r24, Z
    1194:	8f 83       	std	Y+7, r24	; 0x07
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1196:	f9 01       	movw	r30, r18
    1198:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    119a:	e0 0f       	add	r30, r16
    119c:	f1 1f       	adc	r31, r17
    119e:	80 81       	ld	r24, Z
    11a0:	8e 83       	std	Y+6, r24	; 0x06
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    11a2:	f9 01       	movw	r30, r18
    11a4:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    11a6:	e0 0f       	add	r30, r16
    11a8:	f1 1f       	adc	r31, r17
    11aa:	80 81       	ld	r24, Z
    11ac:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    11ae:	49 81       	ldd	r20, Y+1	; 0x01
    11b0:	5a 81       	ldd	r21, Y+2	; 0x02
    11b2:	6b 81       	ldd	r22, Y+3	; 0x03
    11b4:	7c 81       	ldd	r23, Y+4	; 0x04
    11b6:	8d 81       	ldd	r24, Y+5	; 0x05
    11b8:	9e 81       	ldd	r25, Y+6	; 0x06
    11ba:	af 81       	ldd	r26, Y+7	; 0x07
    11bc:	b8 85       	ldd	r27, Y+8	; 0x08
    11be:	84 0f       	add	r24, r20
    11c0:	95 1f       	adc	r25, r21
    11c2:	a6 1f       	adc	r26, r22
    11c4:	b7 1f       	adc	r27, r23
    11c6:	89 83       	std	Y+1, r24	; 0x01
    11c8:	9a 83       	std	Y+2, r25	; 0x02
    11ca:	ab 83       	std	Y+3, r26	; 0x03
    11cc:	bc 83       	std	Y+4, r27	; 0x04
    11ce:	2d 5f       	subi	r18, 0xFD	; 253
    11d0:	3f 4f       	sbci	r19, 0xFF	; 255
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    11d2:	2c 30       	cpi	r18, 0x0C	; 12
    11d4:	31 05       	cpc	r19, r1
    11d6:	81 f6       	brne	.-96     	; 0x1178 <__vector_14+0x4e>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    11d8:	69 81       	ldd	r22, Y+1	; 0x01
    11da:	7a 81       	ldd	r23, Y+2	; 0x02
    11dc:	8b 81       	ldd	r24, Y+3	; 0x03
    11de:	9c 81       	ldd	r25, Y+4	; 0x04
    11e0:	24 e0       	ldi	r18, 0x04	; 4
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	40 e0       	ldi	r20, 0x00	; 0
    11e6:	50 e0       	ldi	r21, 0x00	; 0
    11e8:	0e 94 30 38 	call	0x7060	; 0x7060 <__divmodsi4>
    11ec:	29 83       	std	Y+1, r18	; 0x01
    11ee:	3a 83       	std	Y+2, r19	; 0x02
    11f0:	4b 83       	std	Y+3, r20	; 0x03
    11f2:	5c 83       	std	Y+4, r21	; 0x04
	ADC_BUFFER[sampleCount] = currentSample;
    11f4:	80 91 74 50 	lds	r24, 0x5074
    11f8:	90 91 75 50 	lds	r25, 0x5075
    11fc:	a0 91 76 50 	lds	r26, 0x5076
    1200:	b0 91 77 50 	lds	r27, 0x5077
    1204:	4d 81       	ldd	r20, Y+5	; 0x05
    1206:	5e 81       	ldd	r21, Y+6	; 0x06
    1208:	6f 81       	ldd	r22, Y+7	; 0x07
    120a:	78 85       	ldd	r23, Y+8	; 0x08
    120c:	88 0f       	add	r24, r24
    120e:	99 1f       	adc	r25, r25
    1210:	88 0f       	add	r24, r24
    1212:	99 1f       	adc	r25, r25
    1214:	20 91 72 50 	lds	r18, 0x5072
    1218:	30 91 73 50 	lds	r19, 0x5073
    121c:	82 0f       	add	r24, r18
    121e:	93 1f       	adc	r25, r19
    1220:	fc 01       	movw	r30, r24
    1222:	40 83       	st	Z, r20
    1224:	51 83       	std	Z+1, r21	; 0x01
    1226:	62 83       	std	Z+2, r22	; 0x02
    1228:	73 83       	std	Z+3, r23	; 0x03
	sampleCount++;
    122a:	80 91 74 50 	lds	r24, 0x5074
    122e:	90 91 75 50 	lds	r25, 0x5075
    1232:	a0 91 76 50 	lds	r26, 0x5076
    1236:	b0 91 77 50 	lds	r27, 0x5077
    123a:	01 96       	adiw	r24, 0x01	; 1
    123c:	a1 1d       	adc	r26, r1
    123e:	b1 1d       	adc	r27, r1
    1240:	80 93 74 50 	sts	0x5074, r24
    1244:	90 93 75 50 	sts	0x5075, r25
    1248:	a0 93 76 50 	sts	0x5076, r26
    124c:	b0 93 77 50 	sts	0x5077, r27

}
    1250:	28 96       	adiw	r28, 0x08	; 8
    1252:	cd bf       	out	0x3d, r28	; 61
    1254:	de bf       	out	0x3e, r29	; 62
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	ff 91       	pop	r31
    125c:	ef 91       	pop	r30
    125e:	bf 91       	pop	r27
    1260:	af 91       	pop	r26
    1262:	9f 91       	pop	r25
    1264:	8f 91       	pop	r24
    1266:	7f 91       	pop	r23
    1268:	6f 91       	pop	r22
    126a:	5f 91       	pop	r21
    126c:	4f 91       	pop	r20
    126e:	3f 91       	pop	r19
    1270:	2f 91       	pop	r18
    1272:	1f 91       	pop	r17
    1274:	0f 91       	pop	r16
    1276:	ff 90       	pop	r15
    1278:	0f 90       	pop	r0
    127a:	0b be       	out	0x3b, r0	; 59
    127c:	0f 90       	pop	r0
    127e:	0f be       	out	0x3f, r0	; 63
    1280:	0f 90       	pop	r0
    1282:	1f 90       	pop	r1
    1284:	18 95       	reti

00001286 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1286:	1f 92       	push	r1
    1288:	0f 92       	push	r0
    128a:	0f b6       	in	r0, 0x3f	; 63
    128c:	0f 92       	push	r0
    128e:	0b b6       	in	r0, 0x3b	; 59
    1290:	0f 92       	push	r0
    1292:	11 24       	eor	r1, r1
    1294:	ff 92       	push	r15
    1296:	0f 93       	push	r16
    1298:	1f 93       	push	r17
    129a:	2f 93       	push	r18
    129c:	3f 93       	push	r19
    129e:	4f 93       	push	r20
    12a0:	5f 93       	push	r21
    12a2:	6f 93       	push	r22
    12a4:	7f 93       	push	r23
    12a6:	8f 93       	push	r24
    12a8:	9f 93       	push	r25
    12aa:	af 93       	push	r26
    12ac:	bf 93       	push	r27
    12ae:	ef 93       	push	r30
    12b0:	ff 93       	push	r31
    12b2:	cf 93       	push	r28
    12b4:	df 93       	push	r29
    12b6:	cd b7       	in	r28, 0x3d	; 61
    12b8:	de b7       	in	r29, 0x3e	; 62
    12ba:	28 97       	sbiw	r28, 0x08	; 8
    12bc:	cd bf       	out	0x3d, r28	; 61
    12be:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    12c0:	19 82       	std	Y+1, r1	; 0x01
    12c2:	1a 82       	std	Y+2, r1	; 0x02
    12c4:	1b 82       	std	Y+3, r1	; 0x03
    12c6:	1c 82       	std	Y+4, r1	; 0x04
    12c8:	20 e0       	ldi	r18, 0x00	; 0
    12ca:	30 e0       	ldi	r19, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    12cc:	05 e6       	ldi	r16, 0x65	; 101
    12ce:	10 e5       	ldi	r17, 0x50	; 80
    12d0:	ff 24       	eor	r15, r15
    12d2:	fa 94       	dec	r15
    12d4:	c9 01       	movw	r24, r18
    12d6:	f8 01       	movw	r30, r16
    12d8:	e2 0f       	add	r30, r18
    12da:	f3 1f       	adc	r31, r19
    12dc:	40 81       	ld	r20, Z
    12de:	44 23       	and	r20, r20
    12e0:	14 f4       	brge	.+4      	; 0x12e6 <__vector_77+0x60>
    12e2:	f8 86       	std	Y+8, r15	; 0x08
    12e4:	01 c0       	rjmp	.+2      	; 0x12e8 <__vector_77+0x62>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    12e6:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    12e8:	80 0f       	add	r24, r16
    12ea:	91 1f       	adc	r25, r17
    12ec:	fc 01       	movw	r30, r24
    12ee:	80 81       	ld	r24, Z
    12f0:	8f 83       	std	Y+7, r24	; 0x07
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    12f2:	f9 01       	movw	r30, r18
    12f4:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    12f6:	e0 0f       	add	r30, r16
    12f8:	f1 1f       	adc	r31, r17
    12fa:	80 81       	ld	r24, Z
    12fc:	8e 83       	std	Y+6, r24	; 0x06
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    12fe:	f9 01       	movw	r30, r18
    1300:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1302:	e0 0f       	add	r30, r16
    1304:	f1 1f       	adc	r31, r17
    1306:	80 81       	ld	r24, Z
    1308:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    130a:	49 81       	ldd	r20, Y+1	; 0x01
    130c:	5a 81       	ldd	r21, Y+2	; 0x02
    130e:	6b 81       	ldd	r22, Y+3	; 0x03
    1310:	7c 81       	ldd	r23, Y+4	; 0x04
    1312:	8d 81       	ldd	r24, Y+5	; 0x05
    1314:	9e 81       	ldd	r25, Y+6	; 0x06
    1316:	af 81       	ldd	r26, Y+7	; 0x07
    1318:	b8 85       	ldd	r27, Y+8	; 0x08
    131a:	84 0f       	add	r24, r20
    131c:	95 1f       	adc	r25, r21
    131e:	a6 1f       	adc	r26, r22
    1320:	b7 1f       	adc	r27, r23
    1322:	89 83       	std	Y+1, r24	; 0x01
    1324:	9a 83       	std	Y+2, r25	; 0x02
    1326:	ab 83       	std	Y+3, r26	; 0x03
    1328:	bc 83       	std	Y+4, r27	; 0x04
    132a:	2d 5f       	subi	r18, 0xFD	; 253
    132c:	3f 4f       	sbci	r19, 0xFF	; 255
ISR(TCD0_OVF_vect) {

	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    132e:	2c 30       	cpi	r18, 0x0C	; 12
    1330:	31 05       	cpc	r19, r1
    1332:	81 f6       	brne	.-96     	; 0x12d4 <__vector_77+0x4e>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1334:	69 81       	ldd	r22, Y+1	; 0x01
    1336:	7a 81       	ldd	r23, Y+2	; 0x02
    1338:	8b 81       	ldd	r24, Y+3	; 0x03
    133a:	9c 81       	ldd	r25, Y+4	; 0x04
    133c:	24 e0       	ldi	r18, 0x04	; 4
    133e:	30 e0       	ldi	r19, 0x00	; 0
    1340:	40 e0       	ldi	r20, 0x00	; 0
    1342:	50 e0       	ldi	r21, 0x00	; 0
    1344:	0e 94 30 38 	call	0x7060	; 0x7060 <__divmodsi4>
    1348:	29 83       	std	Y+1, r18	; 0x01
    134a:	3a 83       	std	Y+2, r19	; 0x02
    134c:	4b 83       	std	Y+3, r20	; 0x03
    134e:	5c 83       	std	Y+4, r21	; 0x04
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    1350:	80 91 74 50 	lds	r24, 0x5074
    1354:	90 91 75 50 	lds	r25, 0x5075
    1358:	a0 91 76 50 	lds	r26, 0x5076
    135c:	b0 91 77 50 	lds	r27, 0x5077
    1360:	49 81       	ldd	r20, Y+1	; 0x01
    1362:	5a 81       	ldd	r21, Y+2	; 0x02
    1364:	6b 81       	ldd	r22, Y+3	; 0x03
    1366:	7c 81       	ldd	r23, Y+4	; 0x04
    1368:	88 0f       	add	r24, r24
    136a:	99 1f       	adc	r25, r25
    136c:	88 0f       	add	r24, r24
    136e:	99 1f       	adc	r25, r25
    1370:	20 91 72 50 	lds	r18, 0x5072
    1374:	30 91 73 50 	lds	r19, 0x5073
    1378:	82 0f       	add	r24, r18
    137a:	93 1f       	adc	r25, r19
    137c:	fc 01       	movw	r30, r24
    137e:	40 83       	st	Z, r20
    1380:	51 83       	std	Z+1, r21	; 0x01
    1382:	62 83       	std	Z+2, r22	; 0x02
    1384:	73 83       	std	Z+3, r23	; 0x03
	sampleCount++;
    1386:	80 91 74 50 	lds	r24, 0x5074
    138a:	90 91 75 50 	lds	r25, 0x5075
    138e:	a0 91 76 50 	lds	r26, 0x5076
    1392:	b0 91 77 50 	lds	r27, 0x5077
    1396:	01 96       	adiw	r24, 0x01	; 1
    1398:	a1 1d       	adc	r26, r1
    139a:	b1 1d       	adc	r27, r1
    139c:	80 93 74 50 	sts	0x5074, r24
    13a0:	90 93 75 50 	sts	0x5075, r25
    13a4:	a0 93 76 50 	sts	0x5076, r26
    13a8:	b0 93 77 50 	sts	0x5077, r27
}
    13ac:	28 96       	adiw	r28, 0x08	; 8
    13ae:	cd bf       	out	0x3d, r28	; 61
    13b0:	de bf       	out	0x3e, r29	; 62
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	ff 91       	pop	r31
    13b8:	ef 91       	pop	r30
    13ba:	bf 91       	pop	r27
    13bc:	af 91       	pop	r26
    13be:	9f 91       	pop	r25
    13c0:	8f 91       	pop	r24
    13c2:	7f 91       	pop	r23
    13c4:	6f 91       	pop	r22
    13c6:	5f 91       	pop	r21
    13c8:	4f 91       	pop	r20
    13ca:	3f 91       	pop	r19
    13cc:	2f 91       	pop	r18
    13ce:	1f 91       	pop	r17
    13d0:	0f 91       	pop	r16
    13d2:	ff 90       	pop	r15
    13d4:	0f 90       	pop	r0
    13d6:	0b be       	out	0x3b, r0	; 59
    13d8:	0f 90       	pop	r0
    13da:	0f be       	out	0x3f, r0	; 63
    13dc:	0f 90       	pop	r0
    13de:	1f 90       	pop	r1
    13e0:	18 95       	reti

000013e2 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    13e2:	82 e0       	ldi	r24, 0x02	; 2
    13e4:	e0 ea       	ldi	r30, 0xA0	; 160
    13e6:	f6 e0       	ldi	r31, 0x06	; 6
    13e8:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    13ea:	8a ea       	ldi	r24, 0xAA	; 170
    13ec:	e0 ec       	ldi	r30, 0xC0	; 192
    13ee:	f8 e0       	ldi	r31, 0x08	; 8
    13f0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    13f2:	82 81       	ldd	r24, Z+2	; 0x02
    13f4:	88 23       	and	r24, r24
    13f6:	ec f7       	brge	.-6      	; 0x13f2 <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    13f8:	90 91 ce 50 	lds	r25, 0x50CE
    13fc:	e0 ec       	ldi	r30, 0xC0	; 192
    13fe:	f8 e0       	ldi	r31, 0x08	; 8
    1400:	83 81       	ldd	r24, Z+3	; 0x03
    1402:	a5 e6       	ldi	r26, 0x65	; 101
    1404:	b0 e5       	ldi	r27, 0x50	; 80
    1406:	a9 0f       	add	r26, r25
    1408:	b1 1d       	adc	r27, r1
    140a:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    140c:	8a ea       	ldi	r24, 0xAA	; 170
    140e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1410:	82 81       	ldd	r24, Z+2	; 0x02
    1412:	88 23       	and	r24, r24
    1414:	ec f7       	brge	.-6      	; 0x1410 <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    1416:	a0 91 ce 50 	lds	r26, 0x50CE
    141a:	b0 e0       	ldi	r27, 0x00	; 0
    141c:	e0 ec       	ldi	r30, 0xC0	; 192
    141e:	f8 e0       	ldi	r31, 0x08	; 8
    1420:	83 81       	ldd	r24, Z+3	; 0x03
    1422:	aa 59       	subi	r26, 0x9A	; 154
    1424:	bf 4a       	sbci	r27, 0xAF	; 175
    1426:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1428:	8a ea       	ldi	r24, 0xAA	; 170
    142a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    142c:	82 81       	ldd	r24, Z+2	; 0x02
    142e:	88 23       	and	r24, r24
    1430:	ec f7       	brge	.-6      	; 0x142c <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    1432:	e0 91 ce 50 	lds	r30, 0x50CE
    1436:	f0 e0       	ldi	r31, 0x00	; 0
    1438:	a0 ec       	ldi	r26, 0xC0	; 192
    143a:	b8 e0       	ldi	r27, 0x08	; 8
    143c:	13 96       	adiw	r26, 0x03	; 3
    143e:	8c 91       	ld	r24, X
    1440:	13 97       	sbiw	r26, 0x03	; 3
    1442:	e9 59       	subi	r30, 0x99	; 153
    1444:	ff 4a       	sbci	r31, 0xAF	; 175
    1446:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1448:	82 e0       	ldi	r24, 0x02	; 2
    144a:	e0 ea       	ldi	r30, 0xA0	; 160
    144c:	f6 e0       	ldi	r31, 0x06	; 6
    144e:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    1450:	80 91 ce 50 	lds	r24, 0x50CE
    1454:	8d 5f       	subi	r24, 0xFD	; 253
    1456:	80 93 ce 50 	sts	0x50CE, r24
}
    145a:	08 95       	ret

0000145c <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    145c:	1f 92       	push	r1
    145e:	0f 92       	push	r0
    1460:	0f b6       	in	r0, 0x3f	; 63
    1462:	0f 92       	push	r0
    1464:	0b b6       	in	r0, 0x3b	; 59
    1466:	0f 92       	push	r0
    1468:	11 24       	eor	r1, r1
    146a:	2f 93       	push	r18
    146c:	3f 93       	push	r19
    146e:	4f 93       	push	r20
    1470:	5f 93       	push	r21
    1472:	6f 93       	push	r22
    1474:	7f 93       	push	r23
    1476:	8f 93       	push	r24
    1478:	9f 93       	push	r25
    147a:	af 93       	push	r26
    147c:	bf 93       	push	r27
    147e:	ef 93       	push	r30
    1480:	ff 93       	push	r31
	sampleCurrentChannel();
    1482:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
	SPICount = 0;
    1486:	10 92 ce 50 	sts	0x50CE, r1
}
    148a:	ff 91       	pop	r31
    148c:	ef 91       	pop	r30
    148e:	bf 91       	pop	r27
    1490:	af 91       	pop	r26
    1492:	9f 91       	pop	r25
    1494:	8f 91       	pop	r24
    1496:	7f 91       	pop	r23
    1498:	6f 91       	pop	r22
    149a:	5f 91       	pop	r21
    149c:	4f 91       	pop	r20
    149e:	3f 91       	pop	r19
    14a0:	2f 91       	pop	r18
    14a2:	0f 90       	pop	r0
    14a4:	0b be       	out	0x3b, r0	; 59
    14a6:	0f 90       	pop	r0
    14a8:	0f be       	out	0x3f, r0	; 63
    14aa:	0f 90       	pop	r0
    14ac:	1f 90       	pop	r1
    14ae:	18 95       	reti

000014b0 <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    14b0:	1f 92       	push	r1
    14b2:	0f 92       	push	r0
    14b4:	0f b6       	in	r0, 0x3f	; 63
    14b6:	0f 92       	push	r0
    14b8:	0b b6       	in	r0, 0x3b	; 59
    14ba:	0f 92       	push	r0
    14bc:	11 24       	eor	r1, r1
    14be:	2f 93       	push	r18
    14c0:	3f 93       	push	r19
    14c2:	4f 93       	push	r20
    14c4:	5f 93       	push	r21
    14c6:	6f 93       	push	r22
    14c8:	7f 93       	push	r23
    14ca:	8f 93       	push	r24
    14cc:	9f 93       	push	r25
    14ce:	af 93       	push	r26
    14d0:	bf 93       	push	r27
    14d2:	ef 93       	push	r30
    14d4:	ff 93       	push	r31
	sampleCurrentChannel();
    14d6:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
}
    14da:	ff 91       	pop	r31
    14dc:	ef 91       	pop	r30
    14de:	bf 91       	pop	r27
    14e0:	af 91       	pop	r26
    14e2:	9f 91       	pop	r25
    14e4:	8f 91       	pop	r24
    14e6:	7f 91       	pop	r23
    14e8:	6f 91       	pop	r22
    14ea:	5f 91       	pop	r21
    14ec:	4f 91       	pop	r20
    14ee:	3f 91       	pop	r19
    14f0:	2f 91       	pop	r18
    14f2:	0f 90       	pop	r0
    14f4:	0b be       	out	0x3b, r0	; 59
    14f6:	0f 90       	pop	r0
    14f8:	0f be       	out	0x3f, r0	; 63
    14fa:	0f 90       	pop	r0
    14fc:	1f 90       	pop	r1
    14fe:	18 95       	reti

00001500 <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    1500:	1f 92       	push	r1
    1502:	0f 92       	push	r0
    1504:	0f b6       	in	r0, 0x3f	; 63
    1506:	0f 92       	push	r0
    1508:	0b b6       	in	r0, 0x3b	; 59
    150a:	0f 92       	push	r0
    150c:	11 24       	eor	r1, r1
    150e:	2f 93       	push	r18
    1510:	3f 93       	push	r19
    1512:	4f 93       	push	r20
    1514:	5f 93       	push	r21
    1516:	6f 93       	push	r22
    1518:	7f 93       	push	r23
    151a:	8f 93       	push	r24
    151c:	9f 93       	push	r25
    151e:	af 93       	push	r26
    1520:	bf 93       	push	r27
    1522:	ef 93       	push	r30
    1524:	ff 93       	push	r31
	sampleCurrentChannel();
    1526:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
}
    152a:	ff 91       	pop	r31
    152c:	ef 91       	pop	r30
    152e:	bf 91       	pop	r27
    1530:	af 91       	pop	r26
    1532:	9f 91       	pop	r25
    1534:	8f 91       	pop	r24
    1536:	7f 91       	pop	r23
    1538:	6f 91       	pop	r22
    153a:	5f 91       	pop	r21
    153c:	4f 91       	pop	r20
    153e:	3f 91       	pop	r19
    1540:	2f 91       	pop	r18
    1542:	0f 90       	pop	r0
    1544:	0b be       	out	0x3b, r0	; 59
    1546:	0f 90       	pop	r0
    1548:	0f be       	out	0x3f, r0	; 63
    154a:	0f 90       	pop	r0
    154c:	1f 90       	pop	r1
    154e:	18 95       	reti

00001550 <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    1550:	1f 92       	push	r1
    1552:	0f 92       	push	r0
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	0f 92       	push	r0
    1558:	0b b6       	in	r0, 0x3b	; 59
    155a:	0f 92       	push	r0
    155c:	11 24       	eor	r1, r1
    155e:	2f 93       	push	r18
    1560:	3f 93       	push	r19
    1562:	4f 93       	push	r20
    1564:	5f 93       	push	r21
    1566:	6f 93       	push	r22
    1568:	7f 93       	push	r23
    156a:	8f 93       	push	r24
    156c:	9f 93       	push	r25
    156e:	af 93       	push	r26
    1570:	bf 93       	push	r27
    1572:	ef 93       	push	r30
    1574:	ff 93       	push	r31
	sampleCurrentChannel();
    1576:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
}
    157a:	ff 91       	pop	r31
    157c:	ef 91       	pop	r30
    157e:	bf 91       	pop	r27
    1580:	af 91       	pop	r26
    1582:	9f 91       	pop	r25
    1584:	8f 91       	pop	r24
    1586:	7f 91       	pop	r23
    1588:	6f 91       	pop	r22
    158a:	5f 91       	pop	r21
    158c:	4f 91       	pop	r20
    158e:	3f 91       	pop	r19
    1590:	2f 91       	pop	r18
    1592:	0f 90       	pop	r0
    1594:	0b be       	out	0x3b, r0	; 59
    1596:	0f 90       	pop	r0
    1598:	0f be       	out	0x3f, r0	; 63
    159a:	0f 90       	pop	r0
    159c:	1f 90       	pop	r1
    159e:	18 95       	reti

000015a0 <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    15a0:	1f 92       	push	r1
    15a2:	0f 92       	push	r0
    15a4:	0f b6       	in	r0, 0x3f	; 63
    15a6:	0f 92       	push	r0
    15a8:	0b b6       	in	r0, 0x3b	; 59
    15aa:	0f 92       	push	r0
    15ac:	11 24       	eor	r1, r1
    15ae:	2f 93       	push	r18
    15b0:	3f 93       	push	r19
    15b2:	4f 93       	push	r20
    15b4:	5f 93       	push	r21
    15b6:	6f 93       	push	r22
    15b8:	7f 93       	push	r23
    15ba:	8f 93       	push	r24
    15bc:	9f 93       	push	r25
    15be:	af 93       	push	r26
    15c0:	bf 93       	push	r27
    15c2:	ef 93       	push	r30
    15c4:	ff 93       	push	r31
	sampleCurrentChannel();
    15c6:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
	SPICount = 0;
    15ca:	10 92 ce 50 	sts	0x50CE, r1
	if(PORTB.OUT & PIN1_bm) {
    15ce:	e0 e2       	ldi	r30, 0x20	; 32
    15d0:	f6 e0       	ldi	r31, 0x06	; 6
    15d2:	84 81       	ldd	r24, Z+4	; 0x04
    15d4:	81 ff       	sbrs	r24, 1
    15d6:	0f c0       	rjmp	.+30     	; 0x15f6 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    15d8:	e0 e0       	ldi	r30, 0x00	; 0
    15da:	f6 e0       	ldi	r31, 0x06	; 6
    15dc:	84 81       	ldd	r24, Z+4	; 0x04
    15de:	86 ff       	sbrs	r24, 6
    15e0:	05 c0       	rjmp	.+10     	; 0x15ec <__vector_19+0x4c>
    15e2:	82 e0       	ldi	r24, 0x02	; 2
    15e4:	e0 e2       	ldi	r30, 0x20	; 32
    15e6:	f6 e0       	ldi	r31, 0x06	; 6
    15e8:	87 83       	std	Z+7, r24	; 0x07
    15ea:	0d c0       	rjmp	.+26     	; 0x1606 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    15ec:	80 e4       	ldi	r24, 0x40	; 64
    15ee:	e0 e0       	ldi	r30, 0x00	; 0
    15f0:	f6 e0       	ldi	r31, 0x06	; 6
    15f2:	87 83       	std	Z+7, r24	; 0x07
    15f4:	08 c0       	rjmp	.+16     	; 0x1606 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    15f6:	80 e4       	ldi	r24, 0x40	; 64
    15f8:	e0 e0       	ldi	r30, 0x00	; 0
    15fa:	f6 e0       	ldi	r31, 0x06	; 6
    15fc:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    15fe:	82 e0       	ldi	r24, 0x02	; 2
    1600:	e0 e2       	ldi	r30, 0x20	; 32
    1602:	f6 e0       	ldi	r31, 0x06	; 6
    1604:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    1606:	ff 91       	pop	r31
    1608:	ef 91       	pop	r30
    160a:	bf 91       	pop	r27
    160c:	af 91       	pop	r26
    160e:	9f 91       	pop	r25
    1610:	8f 91       	pop	r24
    1612:	7f 91       	pop	r23
    1614:	6f 91       	pop	r22
    1616:	5f 91       	pop	r21
    1618:	4f 91       	pop	r20
    161a:	3f 91       	pop	r19
    161c:	2f 91       	pop	r18
    161e:	0f 90       	pop	r0
    1620:	0b be       	out	0x3b, r0	; 59
    1622:	0f 90       	pop	r0
    1624:	0f be       	out	0x3f, r0	; 63
    1626:	0f 90       	pop	r0
    1628:	1f 90       	pop	r1
    162a:	18 95       	reti

0000162c <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    162c:	1f 92       	push	r1
    162e:	0f 92       	push	r0
    1630:	0f b6       	in	r0, 0x3f	; 63
    1632:	0f 92       	push	r0
    1634:	0b b6       	in	r0, 0x3b	; 59
    1636:	0f 92       	push	r0
    1638:	11 24       	eor	r1, r1
    163a:	2f 93       	push	r18
    163c:	3f 93       	push	r19
    163e:	4f 93       	push	r20
    1640:	5f 93       	push	r21
    1642:	6f 93       	push	r22
    1644:	7f 93       	push	r23
    1646:	8f 93       	push	r24
    1648:	9f 93       	push	r25
    164a:	af 93       	push	r26
    164c:	bf 93       	push	r27
    164e:	ef 93       	push	r30
    1650:	ff 93       	push	r31
	sampleCurrentChannel();
    1652:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
}
    1656:	ff 91       	pop	r31
    1658:	ef 91       	pop	r30
    165a:	bf 91       	pop	r27
    165c:	af 91       	pop	r26
    165e:	9f 91       	pop	r25
    1660:	8f 91       	pop	r24
    1662:	7f 91       	pop	r23
    1664:	6f 91       	pop	r22
    1666:	5f 91       	pop	r21
    1668:	4f 91       	pop	r20
    166a:	3f 91       	pop	r19
    166c:	2f 91       	pop	r18
    166e:	0f 90       	pop	r0
    1670:	0b be       	out	0x3b, r0	; 59
    1672:	0f 90       	pop	r0
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	0f 90       	pop	r0
    1678:	1f 90       	pop	r1
    167a:	18 95       	reti

0000167c <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    167c:	1f 92       	push	r1
    167e:	0f 92       	push	r0
    1680:	0f b6       	in	r0, 0x3f	; 63
    1682:	0f 92       	push	r0
    1684:	0b b6       	in	r0, 0x3b	; 59
    1686:	0f 92       	push	r0
    1688:	11 24       	eor	r1, r1
    168a:	2f 93       	push	r18
    168c:	3f 93       	push	r19
    168e:	4f 93       	push	r20
    1690:	5f 93       	push	r21
    1692:	6f 93       	push	r22
    1694:	7f 93       	push	r23
    1696:	8f 93       	push	r24
    1698:	9f 93       	push	r25
    169a:	af 93       	push	r26
    169c:	bf 93       	push	r27
    169e:	ef 93       	push	r30
    16a0:	ff 93       	push	r31
	sampleCurrentChannel();
    16a2:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
}
    16a6:	ff 91       	pop	r31
    16a8:	ef 91       	pop	r30
    16aa:	bf 91       	pop	r27
    16ac:	af 91       	pop	r26
    16ae:	9f 91       	pop	r25
    16b0:	8f 91       	pop	r24
    16b2:	7f 91       	pop	r23
    16b4:	6f 91       	pop	r22
    16b6:	5f 91       	pop	r21
    16b8:	4f 91       	pop	r20
    16ba:	3f 91       	pop	r19
    16bc:	2f 91       	pop	r18
    16be:	0f 90       	pop	r0
    16c0:	0b be       	out	0x3b, r0	; 59
    16c2:	0f 90       	pop	r0
    16c4:	0f be       	out	0x3f, r0	; 63
    16c6:	0f 90       	pop	r0
    16c8:	1f 90       	pop	r1
    16ca:	18 95       	reti

000016cc <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    16cc:	1f 92       	push	r1
    16ce:	0f 92       	push	r0
    16d0:	0f b6       	in	r0, 0x3f	; 63
    16d2:	0f 92       	push	r0
    16d4:	0b b6       	in	r0, 0x3b	; 59
    16d6:	0f 92       	push	r0
    16d8:	11 24       	eor	r1, r1
    16da:	2f 93       	push	r18
    16dc:	3f 93       	push	r19
    16de:	4f 93       	push	r20
    16e0:	5f 93       	push	r21
    16e2:	6f 93       	push	r22
    16e4:	7f 93       	push	r23
    16e6:	8f 93       	push	r24
    16e8:	9f 93       	push	r25
    16ea:	af 93       	push	r26
    16ec:	bf 93       	push	r27
    16ee:	ef 93       	push	r30
    16f0:	ff 93       	push	r31
	sampleCurrentChannel();
    16f2:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <sampleCurrentChannel>
}
    16f6:	ff 91       	pop	r31
    16f8:	ef 91       	pop	r30
    16fa:	bf 91       	pop	r27
    16fc:	af 91       	pop	r26
    16fe:	9f 91       	pop	r25
    1700:	8f 91       	pop	r24
    1702:	7f 91       	pop	r23
    1704:	6f 91       	pop	r22
    1706:	5f 91       	pop	r21
    1708:	4f 91       	pop	r20
    170a:	3f 91       	pop	r19
    170c:	2f 91       	pop	r18
    170e:	0f 90       	pop	r0
    1710:	0b be       	out	0x3b, r0	; 59
    1712:	0f 90       	pop	r0
    1714:	0f be       	out	0x3f, r0	; 63
    1716:	0f 90       	pop	r0
    1718:	1f 90       	pop	r1
    171a:	18 95       	reti

0000171c <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    171c:	ff 92       	push	r15
    171e:	0f 93       	push	r16
    1720:	1f 93       	push	r17
    1722:	cf 93       	push	r28
    1724:	df 93       	push	r29
    1726:	cd b7       	in	r28, 0x3d	; 61
    1728:	de b7       	in	r29, 0x3e	; 62
    172a:	28 97       	sbiw	r28, 0x08	; 8
    172c:	cd bf       	out	0x3d, r28	; 61
    172e:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1730:	19 82       	std	Y+1, r1	; 0x01
    1732:	1a 82       	std	Y+2, r1	; 0x02
    1734:	1b 82       	std	Y+3, r1	; 0x03
    1736:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    1738:	80 91 74 50 	lds	r24, 0x5074
    173c:	90 91 75 50 	lds	r25, 0x5075
    1740:	a0 91 76 50 	lds	r26, 0x5076
    1744:	b0 91 77 50 	lds	r27, 0x5077
    1748:	01 96       	adiw	r24, 0x01	; 1
    174a:	a1 1d       	adc	r26, r1
    174c:	b1 1d       	adc	r27, r1
    174e:	80 93 74 50 	sts	0x5074, r24
    1752:	90 93 75 50 	sts	0x5075, r25
    1756:	a0 93 76 50 	sts	0x5076, r26
    175a:	b0 93 77 50 	sts	0x5077, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    175e:	80 ed       	ldi	r24, 0xD0	; 208
    1760:	80 93 c0 08 	sts	0x08C0, r24
    1764:	20 e0       	ldi	r18, 0x00	; 0
    1766:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1768:	05 e6       	ldi	r16, 0x65	; 101
    176a:	10 e5       	ldi	r17, 0x50	; 80
    176c:	ff 24       	eor	r15, r15
    176e:	fa 94       	dec	r15
    1770:	c9 01       	movw	r24, r18
    1772:	f8 01       	movw	r30, r16
    1774:	e2 0f       	add	r30, r18
    1776:	f3 1f       	adc	r31, r19
    1778:	40 81       	ld	r20, Z
    177a:	44 23       	and	r20, r20
    177c:	14 f4       	brge	.+4      	; 0x1782 <writeSE2FRAM+0x66>
    177e:	f8 86       	std	Y+8, r15	; 0x08
    1780:	01 c0       	rjmp	.+2      	; 0x1784 <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1782:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1784:	80 0f       	add	r24, r16
    1786:	91 1f       	adc	r25, r17
    1788:	fc 01       	movw	r30, r24
    178a:	80 81       	ld	r24, Z
    178c:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    178e:	f9 01       	movw	r30, r18
    1790:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1792:	e0 0f       	add	r30, r16
    1794:	f1 1f       	adc	r31, r17
    1796:	80 81       	ld	r24, Z
    1798:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    179a:	f9 01       	movw	r30, r18
    179c:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    179e:	e0 0f       	add	r30, r16
    17a0:	f1 1f       	adc	r31, r17
    17a2:	80 81       	ld	r24, Z
    17a4:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    17a6:	49 81       	ldd	r20, Y+1	; 0x01
    17a8:	5a 81       	ldd	r21, Y+2	; 0x02
    17aa:	6b 81       	ldd	r22, Y+3	; 0x03
    17ac:	7c 81       	ldd	r23, Y+4	; 0x04
    17ae:	8d 81       	ldd	r24, Y+5	; 0x05
    17b0:	9e 81       	ldd	r25, Y+6	; 0x06
    17b2:	af 81       	ldd	r26, Y+7	; 0x07
    17b4:	b8 85       	ldd	r27, Y+8	; 0x08
    17b6:	84 0f       	add	r24, r20
    17b8:	95 1f       	adc	r25, r21
    17ba:	a6 1f       	adc	r26, r22
    17bc:	b7 1f       	adc	r27, r23
    17be:	89 83       	std	Y+1, r24	; 0x01
    17c0:	9a 83       	std	Y+2, r25	; 0x02
    17c2:	ab 83       	std	Y+3, r26	; 0x03
    17c4:	bc 83       	std	Y+4, r27	; 0x04
    17c6:	2d 5f       	subi	r18, 0xFD	; 253
    17c8:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    17ca:	2c 30       	cpi	r18, 0x0C	; 12
    17cc:	31 05       	cpc	r19, r1
    17ce:	81 f6       	brne	.-96     	; 0x1770 <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    17d0:	69 81       	ldd	r22, Y+1	; 0x01
    17d2:	7a 81       	ldd	r23, Y+2	; 0x02
    17d4:	8b 81       	ldd	r24, Y+3	; 0x03
    17d6:	9c 81       	ldd	r25, Y+4	; 0x04
    17d8:	24 e0       	ldi	r18, 0x04	; 4
    17da:	30 e0       	ldi	r19, 0x00	; 0
    17dc:	40 e0       	ldi	r20, 0x00	; 0
    17de:	50 e0       	ldi	r21, 0x00	; 0
    17e0:	0e 94 30 38 	call	0x7060	; 0x7060 <__divmodsi4>
    17e4:	29 83       	std	Y+1, r18	; 0x01
    17e6:	3a 83       	std	Y+2, r19	; 0x02
    17e8:	4b 83       	std	Y+3, r20	; 0x03
    17ea:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    17ec:	29 81       	ldd	r18, Y+1	; 0x01
    17ee:	87 e6       	ldi	r24, 0x67	; 103
    17f0:	90 e5       	ldi	r25, 0x50	; 80
    17f2:	20 93 67 50 	sts	0x5067, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    17f6:	2a 81       	ldd	r18, Y+2	; 0x02
    17f8:	fc 01       	movw	r30, r24
    17fa:	31 97       	sbiw	r30, 0x01	; 1
    17fc:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    17fe:	2b 81       	ldd	r18, Y+3	; 0x03
    1800:	02 97       	sbiw	r24, 0x02	; 2
    1802:	fc 01       	movw	r30, r24
    1804:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1806:	80 e1       	ldi	r24, 0x10	; 16
    1808:	e0 e4       	ldi	r30, 0x40	; 64
    180a:	f6 e0       	ldi	r31, 0x06	; 6
    180c:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    180e:	88 e0       	ldi	r24, 0x08	; 8
    1810:	e0 e2       	ldi	r30, 0x20	; 32
    1812:	f6 e0       	ldi	r31, 0x06	; 6
    1814:	86 83       	std	Z+6, r24	; 0x06
	nop();
    1816:	00 00       	nop
	SPIC.DATA = FR_WREN;
    1818:	86 e0       	ldi	r24, 0x06	; 6
    181a:	e0 ec       	ldi	r30, 0xC0	; 192
    181c:	f8 e0       	ldi	r31, 0x08	; 8
    181e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1820:	82 81       	ldd	r24, Z+2	; 0x02
    1822:	88 23       	and	r24, r24
    1824:	ec f7       	brge	.-6      	; 0x1820 <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    1826:	e0 ec       	ldi	r30, 0xC0	; 192
    1828:	f8 e0       	ldi	r31, 0x08	; 8
    182a:	83 81       	ldd	r24, Z+3	; 0x03
    182c:	80 93 71 50 	sts	0x5071, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    1830:	a0 e2       	ldi	r26, 0x20	; 32
    1832:	b6 e0       	ldi	r27, 0x06	; 6
    1834:	88 e0       	ldi	r24, 0x08	; 8
    1836:	15 96       	adiw	r26, 0x05	; 5
    1838:	8c 93       	st	X, r24
    183a:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    183c:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    183e:	16 96       	adiw	r26, 0x06	; 6
    1840:	8c 93       	st	X, r24
    1842:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    1844:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    1846:	82 e0       	ldi	r24, 0x02	; 2
    1848:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    184a:	82 81       	ldd	r24, Z+2	; 0x02
    184c:	88 23       	and	r24, r24
    184e:	ec f7       	brge	.-6      	; 0x184a <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    1850:	e0 ec       	ldi	r30, 0xC0	; 192
    1852:	f8 e0       	ldi	r31, 0x08	; 8
    1854:	83 81       	ldd	r24, Z+3	; 0x03
    1856:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    185a:	80 91 58 40 	lds	r24, 0x4058
    185e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1860:	82 81       	ldd	r24, Z+2	; 0x02
    1862:	88 23       	and	r24, r24
    1864:	ec f7       	brge	.-6      	; 0x1860 <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    1866:	e0 ec       	ldi	r30, 0xC0	; 192
    1868:	f8 e0       	ldi	r31, 0x08	; 8
    186a:	83 81       	ldd	r24, Z+3	; 0x03
    186c:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1870:	80 91 57 40 	lds	r24, 0x4057
    1874:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1876:	82 81       	ldd	r24, Z+2	; 0x02
    1878:	88 23       	and	r24, r24
    187a:	ec f7       	brge	.-6      	; 0x1876 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    187c:	e0 ec       	ldi	r30, 0xC0	; 192
    187e:	f8 e0       	ldi	r31, 0x08	; 8
    1880:	83 81       	ldd	r24, Z+3	; 0x03
    1882:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[0];
    1886:	80 91 65 50 	lds	r24, 0x5065
    188a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    188c:	82 81       	ldd	r24, Z+2	; 0x02
    188e:	88 23       	and	r24, r24
    1890:	ec f7       	brge	.-6      	; 0x188c <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    1892:	e0 ec       	ldi	r30, 0xC0	; 192
    1894:	f8 e0       	ldi	r31, 0x08	; 8
    1896:	83 81       	ldd	r24, Z+3	; 0x03
    1898:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[1];
    189c:	80 91 66 50 	lds	r24, 0x5066
    18a0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    18a2:	82 81       	ldd	r24, Z+2	; 0x02
    18a4:	88 23       	and	r24, r24
    18a6:	ec f7       	brge	.-6      	; 0x18a2 <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    18a8:	e0 ec       	ldi	r30, 0xC0	; 192
    18aa:	f8 e0       	ldi	r31, 0x08	; 8
    18ac:	83 81       	ldd	r24, Z+3	; 0x03
    18ae:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[2];
    18b2:	80 91 67 50 	lds	r24, 0x5067
    18b6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    18b8:	82 81       	ldd	r24, Z+2	; 0x02
    18ba:	88 23       	and	r24, r24
    18bc:	ec f7       	brge	.-6      	; 0x18b8 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    18be:	a0 ec       	ldi	r26, 0xC0	; 192
    18c0:	b8 e0       	ldi	r27, 0x08	; 8
    18c2:	13 96       	adiw	r26, 0x03	; 3
    18c4:	8c 91       	ld	r24, X
    18c6:	13 97       	sbiw	r26, 0x03	; 3
    18c8:	80 93 71 50 	sts	0x5071, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    18cc:	88 e0       	ldi	r24, 0x08	; 8
    18ce:	e0 e2       	ldi	r30, 0x20	; 32
    18d0:	f6 e0       	ldi	r31, 0x06	; 6
    18d2:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    18d4:	e0 e4       	ldi	r30, 0x40	; 64
    18d6:	f6 e0       	ldi	r31, 0x06	; 6
    18d8:	80 e1       	ldi	r24, 0x10	; 16
    18da:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    18dc:	94 e5       	ldi	r25, 0x54	; 84
    18de:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    18e0:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    18e2:	80 91 57 40 	lds	r24, 0x4057
    18e6:	90 91 58 40 	lds	r25, 0x4058
    18ea:	03 96       	adiw	r24, 0x03	; 3
    18ec:	80 93 57 40 	sts	0x4057, r24
    18f0:	90 93 58 40 	sts	0x4058, r25
	checksumADC[0] += SPIBuffer[0];
    18f4:	80 91 3b 21 	lds	r24, 0x213B
    18f8:	e5 e6       	ldi	r30, 0x65	; 101
    18fa:	f0 e5       	ldi	r31, 0x50	; 80
    18fc:	90 81       	ld	r25, Z
    18fe:	89 0f       	add	r24, r25
    1900:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[1] += SPIBuffer[1];
    1904:	80 91 3c 21 	lds	r24, 0x213C
    1908:	91 81       	ldd	r25, Z+1	; 0x01
    190a:	89 0f       	add	r24, r25
    190c:	80 93 3c 21 	sts	0x213C, r24
	checksumADC[2] += SPIBuffer[2];
    1910:	80 91 3d 21 	lds	r24, 0x213D
    1914:	92 81       	ldd	r25, Z+2	; 0x02
    1916:	89 0f       	add	r24, r25
    1918:	80 93 3d 21 	sts	0x213D, r24
}
    191c:	28 96       	adiw	r28, 0x08	; 8
    191e:	cd bf       	out	0x3d, r28	; 61
    1920:	de bf       	out	0x3e, r29	; 62
    1922:	df 91       	pop	r29
    1924:	cf 91       	pop	r28
    1926:	1f 91       	pop	r17
    1928:	0f 91       	pop	r16
    192a:	ff 90       	pop	r15
    192c:	08 95       	ret

0000192e <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    192e:	2f 92       	push	r2
    1930:	3f 92       	push	r3
    1932:	4f 92       	push	r4
    1934:	5f 92       	push	r5
    1936:	6f 92       	push	r6
    1938:	7f 92       	push	r7
    193a:	8f 92       	push	r8
    193c:	9f 92       	push	r9
    193e:	af 92       	push	r10
    1940:	bf 92       	push	r11
    1942:	cf 92       	push	r12
    1944:	df 92       	push	r13
    1946:	ef 92       	push	r14
    1948:	ff 92       	push	r15
    194a:	0f 93       	push	r16
    194c:	1f 93       	push	r17
    194e:	cf 93       	push	r28
    1950:	df 93       	push	r29
    1952:	00 d0       	rcall	.+0      	; 0x1954 <calcChecksumFRAM+0x26>
    1954:	0f 92       	push	r0
    1956:	cd b7       	in	r28, 0x3d	; 61
    1958:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    195a:	eb e9       	ldi	r30, 0x9B	; 155
    195c:	f0 e5       	ldi	r31, 0x50	; 80
    195e:	10 92 9b 50 	sts	0x509B, r1
    1962:	10 92 9c 50 	sts	0x509C, r1
    1966:	10 92 9d 50 	sts	0x509D, r1
    196a:	10 92 9e 50 	sts	0x509E, r1
    196e:	10 92 9f 50 	sts	0x509F, r1
    1972:	10 92 a0 50 	sts	0x50A0, r1
    1976:	10 92 a1 50 	sts	0x50A1, r1
    197a:	10 92 a2 50 	sts	0x50A2, r1
    197e:	df 01       	movw	r26, r30
    1980:	18 97       	sbiw	r26, 0x08	; 8
    1982:	1c 92       	st	X, r1
    1984:	11 96       	adiw	r26, 0x01	; 1
    1986:	1c 92       	st	X, r1
    1988:	11 97       	sbiw	r26, 0x01	; 1
    198a:	12 96       	adiw	r26, 0x02	; 2
    198c:	1c 92       	st	X, r1
    198e:	12 97       	sbiw	r26, 0x02	; 2
    1990:	13 96       	adiw	r26, 0x03	; 3
    1992:	1c 92       	st	X, r1
    1994:	13 97       	sbiw	r26, 0x03	; 3
    1996:	14 96       	adiw	r26, 0x04	; 4
    1998:	1c 92       	st	X, r1
    199a:	14 97       	sbiw	r26, 0x04	; 4
    199c:	15 96       	adiw	r26, 0x05	; 5
    199e:	1c 92       	st	X, r1
    19a0:	15 97       	sbiw	r26, 0x05	; 5
    19a2:	16 96       	adiw	r26, 0x06	; 6
    19a4:	1c 92       	st	X, r1
    19a6:	16 97       	sbiw	r26, 0x06	; 6
    19a8:	17 96       	adiw	r26, 0x07	; 7
    19aa:	1c 92       	st	X, r1
    19ac:	70 97       	sbiw	r30, 0x10	; 16
    19ae:	10 82       	st	Z, r1
    19b0:	11 82       	std	Z+1, r1	; 0x01
    19b2:	12 82       	std	Z+2, r1	; 0x02
    19b4:	13 82       	std	Z+3, r1	; 0x03
    19b6:	14 82       	std	Z+4, r1	; 0x04
    19b8:	15 82       	std	Z+5, r1	; 0x05
    19ba:	16 82       	std	Z+6, r1	; 0x06
    19bc:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    19be:	8a e3       	ldi	r24, 0x3A	; 58
    19c0:	91 e2       	ldi	r25, 0x21	; 33
    19c2:	10 92 3a 21 	sts	0x213A, r1
    19c6:	fc 01       	movw	r30, r24
    19c8:	31 97       	sbiw	r30, 0x01	; 1
    19ca:	10 82       	st	Z, r1
    19cc:	02 97       	sbiw	r24, 0x02	; 2
    19ce:	dc 01       	movw	r26, r24
    19d0:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    19d2:	10 92 57 40 	sts	0x4057, r1
    19d6:	10 92 58 40 	sts	0x4058, r1
    19da:	e9 e0       	ldi	r30, 0x09	; 9
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	e9 83       	std	Y+1, r30	; 0x01
    19e0:	fa 83       	std	Y+2, r31	; 0x02
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    19e2:	99 24       	eor	r9, r9
    19e4:	9a 94       	dec	r9
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    19e6:	0f 2e       	mov	r0, r31
    19e8:	fb e9       	ldi	r31, 0x9B	; 155
    19ea:	ef 2e       	mov	r14, r31
    19ec:	f0 e5       	ldi	r31, 0x50	; 80
    19ee:	ff 2e       	mov	r15, r31
    19f0:	f0 2d       	mov	r31, r0
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    19f2:	0f 2e       	mov	r0, r31
    19f4:	f3 e9       	ldi	r31, 0x93	; 147
    19f6:	cf 2e       	mov	r12, r31
    19f8:	f0 e5       	ldi	r31, 0x50	; 80
    19fa:	df 2e       	mov	r13, r31
    19fc:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    19fe:	0f 2e       	mov	r0, r31
    1a00:	fb e8       	ldi	r31, 0x8B	; 139
    1a02:	af 2e       	mov	r10, r31
    1a04:	f0 e5       	ldi	r31, 0x50	; 80
    1a06:	bf 2e       	mov	r11, r31
    1a08:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    1a0a:	81 e7       	ldi	r24, 0x71	; 113
    1a0c:	9c e1       	ldi	r25, 0x1C	; 28
    1a0e:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    1a12:	80 91 57 40 	lds	r24, 0x4057
    1a16:	90 91 58 40 	lds	r25, 0x4058
    1a1a:	8f 58       	subi	r24, 0x8F	; 143
    1a1c:	93 4e       	sbci	r25, 0xE3	; 227
    1a1e:	80 93 57 40 	sts	0x4057, r24
    1a22:	90 93 58 40 	sts	0x4058, r25
    1a26:	0f ed       	ldi	r16, 0xDF	; 223
    1a28:	13 e2       	ldi	r17, 0x23	; 35
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1a2a:	80 e0       	ldi	r24, 0x00	; 0
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1a2e:	0f 2e       	mov	r0, r31
    1a30:	f9 e0       	ldi	r31, 0x09	; 9
    1a32:	2f 2e       	mov	r2, r31
    1a34:	33 24       	eor	r3, r3
    1a36:	f0 2d       	mov	r31, r0
    1a38:	8b 83       	std	Y+3, r24	; 0x03
    1a3a:	9c 83       	std	Y+4, r25	; 0x04
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a40:	63 e0       	ldi	r22, 0x03	; 3
    1a42:	70 e0       	ldi	r23, 0x00	; 0
    1a44:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodhi4>
    1a48:	9c 01       	movw	r18, r24
    1a4a:	e8 e3       	ldi	r30, 0x38	; 56
    1a4c:	f1 e2       	ldi	r31, 0x21	; 33
    1a4e:	e8 0f       	add	r30, r24
    1a50:	f9 1f       	adc	r31, r25
    1a52:	90 81       	ld	r25, Z
	checksumADC[1] += SPIBuffer[1];
	checksumADC[2] += SPIBuffer[2];
}

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1a54:	a8 01       	movw	r20, r16
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1a56:	d8 01       	movw	r26, r16
    1a58:	8c 91       	ld	r24, X
    1a5a:	98 0f       	add	r25, r24
    1a5c:	90 83       	st	Z, r25
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    1a5e:	21 15       	cp	r18, r1
    1a60:	31 05       	cpc	r19, r1
    1a62:	19 f5       	brne	.+70     	; 0x1aaa <calcChecksumFRAM+0x17c>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1a64:	88 23       	and	r24, r24
    1a66:	6c f4       	brge	.+26     	; 0x1a82 <calcChecksumFRAM+0x154>
    1a68:	e0 91 63 50 	lds	r30, 0x5063
    1a6c:	f0 91 64 50 	lds	r31, 0x5064
    1a70:	10 82       	st	Z, r1
    1a72:	11 82       	std	Z+1, r1	; 0x01
    1a74:	12 82       	std	Z+2, r1	; 0x02
    1a76:	93 82       	std	Z+3, r9	; 0x03
    1a78:	94 82       	std	Z+4, r9	; 0x04
    1a7a:	95 82       	std	Z+5, r9	; 0x05
    1a7c:	96 82       	std	Z+6, r9	; 0x06
    1a7e:	97 82       	std	Z+7, r9	; 0x07
    1a80:	0c c0       	rjmp	.+24     	; 0x1a9a <calcChecksumFRAM+0x16c>
				else *temp64 = 0x0000000000000000;
    1a82:	e0 91 63 50 	lds	r30, 0x5063
    1a86:	f0 91 64 50 	lds	r31, 0x5064
    1a8a:	10 82       	st	Z, r1
    1a8c:	11 82       	std	Z+1, r1	; 0x01
    1a8e:	12 82       	std	Z+2, r1	; 0x02
    1a90:	13 82       	std	Z+3, r1	; 0x03
    1a92:	14 82       	std	Z+4, r1	; 0x04
    1a94:	15 82       	std	Z+5, r1	; 0x05
    1a96:	16 82       	std	Z+6, r1	; 0x06
    1a98:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    1a9a:	fa 01       	movw	r30, r20
    1a9c:	80 81       	ld	r24, Z
    1a9e:	e0 91 63 50 	lds	r30, 0x5063
    1aa2:	f0 91 64 50 	lds	r31, 0x5064
    1aa6:	82 83       	std	Z+2, r24	; 0x02
    1aa8:	10 c0       	rjmp	.+32     	; 0x1aca <calcChecksumFRAM+0x19c>
			} else if(k%3 == 1) {
    1aaa:	21 30       	cpi	r18, 0x01	; 1
    1aac:	31 05       	cpc	r19, r1
    1aae:	31 f4       	brne	.+12     	; 0x1abc <calcChecksumFRAM+0x18e>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    1ab0:	e0 91 63 50 	lds	r30, 0x5063
    1ab4:	f0 91 64 50 	lds	r31, 0x5064
    1ab8:	81 83       	std	Z+1, r24	; 0x01
    1aba:	07 c0       	rjmp	.+14     	; 0x1aca <calcChecksumFRAM+0x19c>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    1abc:	e0 91 63 50 	lds	r30, 0x5063
    1ac0:	f0 91 64 50 	lds	r31, 0x5064
    1ac4:	d8 01       	movw	r26, r16
    1ac6:	8c 91       	ld	r24, X
    1ac8:	80 83       	st	Z, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1aca:	8b 81       	ldd	r24, Y+3	; 0x03
    1acc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ace:	b1 01       	movw	r22, r2
    1ad0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodhi4>
    1ad4:	82 30       	cpi	r24, 0x02	; 2
    1ad6:	91 05       	cpc	r25, r1
    1ad8:	09 f0       	breq	.+2      	; 0x1adc <calcChecksumFRAM+0x1ae>
    1ada:	76 c0       	rjmp	.+236    	; 0x1bc8 <calcChecksumFRAM+0x29a>
    1adc:	f5 01       	movw	r30, r10
    1ade:	60 81       	ld	r22, Z
    1ae0:	51 81       	ldd	r21, Z+1	; 0x01
    1ae2:	42 81       	ldd	r20, Z+2	; 0x02
    1ae4:	33 81       	ldd	r19, Z+3	; 0x03
    1ae6:	24 81       	ldd	r18, Z+4	; 0x04
    1ae8:	95 81       	ldd	r25, Z+5	; 0x05
    1aea:	86 81       	ldd	r24, Z+6	; 0x06
    1aec:	47 80       	ldd	r4, Z+7	; 0x07
    1aee:	e0 91 63 50 	lds	r30, 0x5063
    1af2:	f0 91 64 50 	lds	r31, 0x5064
    1af6:	70 81       	ld	r23, Z
    1af8:	a1 81       	ldd	r26, Z+1	; 0x01
    1afa:	b2 81       	ldd	r27, Z+2	; 0x02
    1afc:	83 80       	ldd	r8, Z+3	; 0x03
    1afe:	74 80       	ldd	r7, Z+4	; 0x04
    1b00:	65 80       	ldd	r6, Z+5	; 0x05
    1b02:	56 80       	ldd	r5, Z+6	; 0x06
    1b04:	e7 81       	ldd	r30, Z+7	; 0x07
    1b06:	76 0f       	add	r23, r22
    1b08:	f1 e0       	ldi	r31, 0x01	; 1
    1b0a:	76 17       	cp	r23, r22
    1b0c:	08 f0       	brcs	.+2      	; 0x1b10 <calcChecksumFRAM+0x1e2>
    1b0e:	f0 e0       	ldi	r31, 0x00	; 0
    1b10:	a5 0f       	add	r26, r21
    1b12:	61 e0       	ldi	r22, 0x01	; 1
    1b14:	a5 17       	cp	r26, r21
    1b16:	08 f0       	brcs	.+2      	; 0x1b1a <calcChecksumFRAM+0x1ec>
    1b18:	60 e0       	ldi	r22, 0x00	; 0
    1b1a:	fa 0f       	add	r31, r26
    1b1c:	51 e0       	ldi	r21, 0x01	; 1
    1b1e:	fa 17       	cp	r31, r26
    1b20:	08 f0       	brcs	.+2      	; 0x1b24 <calcChecksumFRAM+0x1f6>
    1b22:	50 e0       	ldi	r21, 0x00	; 0
    1b24:	65 2b       	or	r22, r21
    1b26:	b4 0f       	add	r27, r20
    1b28:	51 e0       	ldi	r21, 0x01	; 1
    1b2a:	b4 17       	cp	r27, r20
    1b2c:	08 f0       	brcs	.+2      	; 0x1b30 <calcChecksumFRAM+0x202>
    1b2e:	50 e0       	ldi	r21, 0x00	; 0
    1b30:	6b 0f       	add	r22, r27
    1b32:	41 e0       	ldi	r20, 0x01	; 1
    1b34:	6b 17       	cp	r22, r27
    1b36:	08 f0       	brcs	.+2      	; 0x1b3a <calcChecksumFRAM+0x20c>
    1b38:	40 e0       	ldi	r20, 0x00	; 0
    1b3a:	54 2b       	or	r21, r20
    1b3c:	83 0e       	add	r8, r19
    1b3e:	41 e0       	ldi	r20, 0x01	; 1
    1b40:	83 16       	cp	r8, r19
    1b42:	08 f0       	brcs	.+2      	; 0x1b46 <calcChecksumFRAM+0x218>
    1b44:	40 e0       	ldi	r20, 0x00	; 0
    1b46:	58 0d       	add	r21, r8
    1b48:	31 e0       	ldi	r19, 0x01	; 1
    1b4a:	58 15       	cp	r21, r8
    1b4c:	08 f0       	brcs	.+2      	; 0x1b50 <calcChecksumFRAM+0x222>
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	43 2b       	or	r20, r19
    1b52:	72 0e       	add	r7, r18
    1b54:	31 e0       	ldi	r19, 0x01	; 1
    1b56:	72 16       	cp	r7, r18
    1b58:	08 f0       	brcs	.+2      	; 0x1b5c <calcChecksumFRAM+0x22e>
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	47 0d       	add	r20, r7
    1b5e:	21 e0       	ldi	r18, 0x01	; 1
    1b60:	47 15       	cp	r20, r7
    1b62:	08 f0       	brcs	.+2      	; 0x1b66 <calcChecksumFRAM+0x238>
    1b64:	20 e0       	ldi	r18, 0x00	; 0
    1b66:	32 2b       	or	r19, r18
    1b68:	69 0e       	add	r6, r25
    1b6a:	21 e0       	ldi	r18, 0x01	; 1
    1b6c:	69 16       	cp	r6, r25
    1b6e:	08 f0       	brcs	.+2      	; 0x1b72 <calcChecksumFRAM+0x244>
    1b70:	20 e0       	ldi	r18, 0x00	; 0
    1b72:	36 0d       	add	r19, r6
    1b74:	91 e0       	ldi	r25, 0x01	; 1
    1b76:	36 15       	cp	r19, r6
    1b78:	08 f0       	brcs	.+2      	; 0x1b7c <calcChecksumFRAM+0x24e>
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	29 2b       	or	r18, r25
    1b7e:	58 0e       	add	r5, r24
    1b80:	91 e0       	ldi	r25, 0x01	; 1
    1b82:	58 16       	cp	r5, r24
    1b84:	08 f0       	brcs	.+2      	; 0x1b88 <calcChecksumFRAM+0x25a>
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	25 0d       	add	r18, r5
    1b8a:	81 e0       	ldi	r24, 0x01	; 1
    1b8c:	25 15       	cp	r18, r5
    1b8e:	08 f0       	brcs	.+2      	; 0x1b92 <calcChecksumFRAM+0x264>
    1b90:	80 e0       	ldi	r24, 0x00	; 0
    1b92:	98 2b       	or	r25, r24
    1b94:	e4 0d       	add	r30, r4
    1b96:	9e 0f       	add	r25, r30
    1b98:	d5 01       	movw	r26, r10
    1b9a:	7c 93       	st	X, r23
    1b9c:	11 96       	adiw	r26, 0x01	; 1
    1b9e:	fc 93       	st	X, r31
    1ba0:	11 97       	sbiw	r26, 0x01	; 1
    1ba2:	12 96       	adiw	r26, 0x02	; 2
    1ba4:	6c 93       	st	X, r22
    1ba6:	12 97       	sbiw	r26, 0x02	; 2
    1ba8:	13 96       	adiw	r26, 0x03	; 3
    1baa:	5c 93       	st	X, r21
    1bac:	13 97       	sbiw	r26, 0x03	; 3
    1bae:	14 96       	adiw	r26, 0x04	; 4
    1bb0:	4c 93       	st	X, r20
    1bb2:	14 97       	sbiw	r26, 0x04	; 4
    1bb4:	15 96       	adiw	r26, 0x05	; 5
    1bb6:	3c 93       	st	X, r19
    1bb8:	15 97       	sbiw	r26, 0x05	; 5
    1bba:	16 96       	adiw	r26, 0x06	; 6
    1bbc:	2c 93       	st	X, r18
    1bbe:	16 97       	sbiw	r26, 0x06	; 6
    1bc0:	17 96       	adiw	r26, 0x07	; 7
    1bc2:	9c 93       	st	X, r25
    1bc4:	17 97       	sbiw	r26, 0x07	; 7
    1bc6:	f3 c0       	rjmp	.+486    	; 0x1dae <calcChecksumFRAM+0x480>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    1bc8:	85 30       	cpi	r24, 0x05	; 5
    1bca:	91 05       	cpc	r25, r1
    1bcc:	09 f0       	breq	.+2      	; 0x1bd0 <calcChecksumFRAM+0x2a2>
    1bce:	76 c0       	rjmp	.+236    	; 0x1cbc <calcChecksumFRAM+0x38e>
    1bd0:	f6 01       	movw	r30, r12
    1bd2:	60 81       	ld	r22, Z
    1bd4:	51 81       	ldd	r21, Z+1	; 0x01
    1bd6:	42 81       	ldd	r20, Z+2	; 0x02
    1bd8:	33 81       	ldd	r19, Z+3	; 0x03
    1bda:	24 81       	ldd	r18, Z+4	; 0x04
    1bdc:	95 81       	ldd	r25, Z+5	; 0x05
    1bde:	86 81       	ldd	r24, Z+6	; 0x06
    1be0:	47 80       	ldd	r4, Z+7	; 0x07
    1be2:	e0 91 63 50 	lds	r30, 0x5063
    1be6:	f0 91 64 50 	lds	r31, 0x5064
    1bea:	70 81       	ld	r23, Z
    1bec:	a1 81       	ldd	r26, Z+1	; 0x01
    1bee:	b2 81       	ldd	r27, Z+2	; 0x02
    1bf0:	83 80       	ldd	r8, Z+3	; 0x03
    1bf2:	74 80       	ldd	r7, Z+4	; 0x04
    1bf4:	65 80       	ldd	r6, Z+5	; 0x05
    1bf6:	56 80       	ldd	r5, Z+6	; 0x06
    1bf8:	e7 81       	ldd	r30, Z+7	; 0x07
    1bfa:	76 0f       	add	r23, r22
    1bfc:	f1 e0       	ldi	r31, 0x01	; 1
    1bfe:	76 17       	cp	r23, r22
    1c00:	08 f0       	brcs	.+2      	; 0x1c04 <calcChecksumFRAM+0x2d6>
    1c02:	f0 e0       	ldi	r31, 0x00	; 0
    1c04:	a5 0f       	add	r26, r21
    1c06:	61 e0       	ldi	r22, 0x01	; 1
    1c08:	a5 17       	cp	r26, r21
    1c0a:	08 f0       	brcs	.+2      	; 0x1c0e <calcChecksumFRAM+0x2e0>
    1c0c:	60 e0       	ldi	r22, 0x00	; 0
    1c0e:	fa 0f       	add	r31, r26
    1c10:	51 e0       	ldi	r21, 0x01	; 1
    1c12:	fa 17       	cp	r31, r26
    1c14:	08 f0       	brcs	.+2      	; 0x1c18 <calcChecksumFRAM+0x2ea>
    1c16:	50 e0       	ldi	r21, 0x00	; 0
    1c18:	65 2b       	or	r22, r21
    1c1a:	b4 0f       	add	r27, r20
    1c1c:	51 e0       	ldi	r21, 0x01	; 1
    1c1e:	b4 17       	cp	r27, r20
    1c20:	08 f0       	brcs	.+2      	; 0x1c24 <calcChecksumFRAM+0x2f6>
    1c22:	50 e0       	ldi	r21, 0x00	; 0
    1c24:	6b 0f       	add	r22, r27
    1c26:	41 e0       	ldi	r20, 0x01	; 1
    1c28:	6b 17       	cp	r22, r27
    1c2a:	08 f0       	brcs	.+2      	; 0x1c2e <calcChecksumFRAM+0x300>
    1c2c:	40 e0       	ldi	r20, 0x00	; 0
    1c2e:	54 2b       	or	r21, r20
    1c30:	83 0e       	add	r8, r19
    1c32:	41 e0       	ldi	r20, 0x01	; 1
    1c34:	83 16       	cp	r8, r19
    1c36:	08 f0       	brcs	.+2      	; 0x1c3a <calcChecksumFRAM+0x30c>
    1c38:	40 e0       	ldi	r20, 0x00	; 0
    1c3a:	58 0d       	add	r21, r8
    1c3c:	31 e0       	ldi	r19, 0x01	; 1
    1c3e:	58 15       	cp	r21, r8
    1c40:	08 f0       	brcs	.+2      	; 0x1c44 <calcChecksumFRAM+0x316>
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	43 2b       	or	r20, r19
    1c46:	72 0e       	add	r7, r18
    1c48:	31 e0       	ldi	r19, 0x01	; 1
    1c4a:	72 16       	cp	r7, r18
    1c4c:	08 f0       	brcs	.+2      	; 0x1c50 <calcChecksumFRAM+0x322>
    1c4e:	30 e0       	ldi	r19, 0x00	; 0
    1c50:	47 0d       	add	r20, r7
    1c52:	21 e0       	ldi	r18, 0x01	; 1
    1c54:	47 15       	cp	r20, r7
    1c56:	08 f0       	brcs	.+2      	; 0x1c5a <calcChecksumFRAM+0x32c>
    1c58:	20 e0       	ldi	r18, 0x00	; 0
    1c5a:	32 2b       	or	r19, r18
    1c5c:	69 0e       	add	r6, r25
    1c5e:	21 e0       	ldi	r18, 0x01	; 1
    1c60:	69 16       	cp	r6, r25
    1c62:	08 f0       	brcs	.+2      	; 0x1c66 <calcChecksumFRAM+0x338>
    1c64:	20 e0       	ldi	r18, 0x00	; 0
    1c66:	36 0d       	add	r19, r6
    1c68:	91 e0       	ldi	r25, 0x01	; 1
    1c6a:	36 15       	cp	r19, r6
    1c6c:	08 f0       	brcs	.+2      	; 0x1c70 <calcChecksumFRAM+0x342>
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	29 2b       	or	r18, r25
    1c72:	58 0e       	add	r5, r24
    1c74:	91 e0       	ldi	r25, 0x01	; 1
    1c76:	58 16       	cp	r5, r24
    1c78:	08 f0       	brcs	.+2      	; 0x1c7c <calcChecksumFRAM+0x34e>
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	25 0d       	add	r18, r5
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	25 15       	cp	r18, r5
    1c82:	08 f0       	brcs	.+2      	; 0x1c86 <calcChecksumFRAM+0x358>
    1c84:	80 e0       	ldi	r24, 0x00	; 0
    1c86:	98 2b       	or	r25, r24
    1c88:	e4 0d       	add	r30, r4
    1c8a:	9e 0f       	add	r25, r30
    1c8c:	d6 01       	movw	r26, r12
    1c8e:	7c 93       	st	X, r23
    1c90:	11 96       	adiw	r26, 0x01	; 1
    1c92:	fc 93       	st	X, r31
    1c94:	11 97       	sbiw	r26, 0x01	; 1
    1c96:	12 96       	adiw	r26, 0x02	; 2
    1c98:	6c 93       	st	X, r22
    1c9a:	12 97       	sbiw	r26, 0x02	; 2
    1c9c:	13 96       	adiw	r26, 0x03	; 3
    1c9e:	5c 93       	st	X, r21
    1ca0:	13 97       	sbiw	r26, 0x03	; 3
    1ca2:	14 96       	adiw	r26, 0x04	; 4
    1ca4:	4c 93       	st	X, r20
    1ca6:	14 97       	sbiw	r26, 0x04	; 4
    1ca8:	15 96       	adiw	r26, 0x05	; 5
    1caa:	3c 93       	st	X, r19
    1cac:	15 97       	sbiw	r26, 0x05	; 5
    1cae:	16 96       	adiw	r26, 0x06	; 6
    1cb0:	2c 93       	st	X, r18
    1cb2:	16 97       	sbiw	r26, 0x06	; 6
    1cb4:	17 96       	adiw	r26, 0x07	; 7
    1cb6:	9c 93       	st	X, r25
    1cb8:	17 97       	sbiw	r26, 0x07	; 7
    1cba:	79 c0       	rjmp	.+242    	; 0x1dae <calcChecksumFRAM+0x480>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    1cbc:	88 30       	cpi	r24, 0x08	; 8
    1cbe:	91 05       	cpc	r25, r1
    1cc0:	09 f0       	breq	.+2      	; 0x1cc4 <calcChecksumFRAM+0x396>
    1cc2:	75 c0       	rjmp	.+234    	; 0x1dae <calcChecksumFRAM+0x480>
    1cc4:	f7 01       	movw	r30, r14
    1cc6:	60 81       	ld	r22, Z
    1cc8:	51 81       	ldd	r21, Z+1	; 0x01
    1cca:	42 81       	ldd	r20, Z+2	; 0x02
    1ccc:	33 81       	ldd	r19, Z+3	; 0x03
    1cce:	24 81       	ldd	r18, Z+4	; 0x04
    1cd0:	95 81       	ldd	r25, Z+5	; 0x05
    1cd2:	86 81       	ldd	r24, Z+6	; 0x06
    1cd4:	47 80       	ldd	r4, Z+7	; 0x07
    1cd6:	e0 91 63 50 	lds	r30, 0x5063
    1cda:	f0 91 64 50 	lds	r31, 0x5064
    1cde:	70 81       	ld	r23, Z
    1ce0:	a1 81       	ldd	r26, Z+1	; 0x01
    1ce2:	b2 81       	ldd	r27, Z+2	; 0x02
    1ce4:	83 80       	ldd	r8, Z+3	; 0x03
    1ce6:	74 80       	ldd	r7, Z+4	; 0x04
    1ce8:	65 80       	ldd	r6, Z+5	; 0x05
    1cea:	56 80       	ldd	r5, Z+6	; 0x06
    1cec:	e7 81       	ldd	r30, Z+7	; 0x07
    1cee:	76 0f       	add	r23, r22
    1cf0:	f1 e0       	ldi	r31, 0x01	; 1
    1cf2:	76 17       	cp	r23, r22
    1cf4:	08 f0       	brcs	.+2      	; 0x1cf8 <calcChecksumFRAM+0x3ca>
    1cf6:	f0 e0       	ldi	r31, 0x00	; 0
    1cf8:	a5 0f       	add	r26, r21
    1cfa:	61 e0       	ldi	r22, 0x01	; 1
    1cfc:	a5 17       	cp	r26, r21
    1cfe:	08 f0       	brcs	.+2      	; 0x1d02 <calcChecksumFRAM+0x3d4>
    1d00:	60 e0       	ldi	r22, 0x00	; 0
    1d02:	fa 0f       	add	r31, r26
    1d04:	51 e0       	ldi	r21, 0x01	; 1
    1d06:	fa 17       	cp	r31, r26
    1d08:	08 f0       	brcs	.+2      	; 0x1d0c <calcChecksumFRAM+0x3de>
    1d0a:	50 e0       	ldi	r21, 0x00	; 0
    1d0c:	65 2b       	or	r22, r21
    1d0e:	b4 0f       	add	r27, r20
    1d10:	51 e0       	ldi	r21, 0x01	; 1
    1d12:	b4 17       	cp	r27, r20
    1d14:	08 f0       	brcs	.+2      	; 0x1d18 <calcChecksumFRAM+0x3ea>
    1d16:	50 e0       	ldi	r21, 0x00	; 0
    1d18:	6b 0f       	add	r22, r27
    1d1a:	41 e0       	ldi	r20, 0x01	; 1
    1d1c:	6b 17       	cp	r22, r27
    1d1e:	08 f0       	brcs	.+2      	; 0x1d22 <calcChecksumFRAM+0x3f4>
    1d20:	40 e0       	ldi	r20, 0x00	; 0
    1d22:	54 2b       	or	r21, r20
    1d24:	83 0e       	add	r8, r19
    1d26:	41 e0       	ldi	r20, 0x01	; 1
    1d28:	83 16       	cp	r8, r19
    1d2a:	08 f0       	brcs	.+2      	; 0x1d2e <calcChecksumFRAM+0x400>
    1d2c:	40 e0       	ldi	r20, 0x00	; 0
    1d2e:	58 0d       	add	r21, r8
    1d30:	31 e0       	ldi	r19, 0x01	; 1
    1d32:	58 15       	cp	r21, r8
    1d34:	08 f0       	brcs	.+2      	; 0x1d38 <calcChecksumFRAM+0x40a>
    1d36:	30 e0       	ldi	r19, 0x00	; 0
    1d38:	43 2b       	or	r20, r19
    1d3a:	72 0e       	add	r7, r18
    1d3c:	31 e0       	ldi	r19, 0x01	; 1
    1d3e:	72 16       	cp	r7, r18
    1d40:	08 f0       	brcs	.+2      	; 0x1d44 <calcChecksumFRAM+0x416>
    1d42:	30 e0       	ldi	r19, 0x00	; 0
    1d44:	47 0d       	add	r20, r7
    1d46:	21 e0       	ldi	r18, 0x01	; 1
    1d48:	47 15       	cp	r20, r7
    1d4a:	08 f0       	brcs	.+2      	; 0x1d4e <calcChecksumFRAM+0x420>
    1d4c:	20 e0       	ldi	r18, 0x00	; 0
    1d4e:	32 2b       	or	r19, r18
    1d50:	69 0e       	add	r6, r25
    1d52:	21 e0       	ldi	r18, 0x01	; 1
    1d54:	69 16       	cp	r6, r25
    1d56:	08 f0       	brcs	.+2      	; 0x1d5a <calcChecksumFRAM+0x42c>
    1d58:	20 e0       	ldi	r18, 0x00	; 0
    1d5a:	36 0d       	add	r19, r6
    1d5c:	91 e0       	ldi	r25, 0x01	; 1
    1d5e:	36 15       	cp	r19, r6
    1d60:	08 f0       	brcs	.+2      	; 0x1d64 <calcChecksumFRAM+0x436>
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	29 2b       	or	r18, r25
    1d66:	58 0e       	add	r5, r24
    1d68:	91 e0       	ldi	r25, 0x01	; 1
    1d6a:	58 16       	cp	r5, r24
    1d6c:	08 f0       	brcs	.+2      	; 0x1d70 <calcChecksumFRAM+0x442>
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	25 0d       	add	r18, r5
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	25 15       	cp	r18, r5
    1d76:	08 f0       	brcs	.+2      	; 0x1d7a <calcChecksumFRAM+0x44c>
    1d78:	80 e0       	ldi	r24, 0x00	; 0
    1d7a:	98 2b       	or	r25, r24
    1d7c:	e4 0d       	add	r30, r4
    1d7e:	9e 0f       	add	r25, r30
    1d80:	d7 01       	movw	r26, r14
    1d82:	7c 93       	st	X, r23
    1d84:	11 96       	adiw	r26, 0x01	; 1
    1d86:	fc 93       	st	X, r31
    1d88:	11 97       	sbiw	r26, 0x01	; 1
    1d8a:	12 96       	adiw	r26, 0x02	; 2
    1d8c:	6c 93       	st	X, r22
    1d8e:	12 97       	sbiw	r26, 0x02	; 2
    1d90:	13 96       	adiw	r26, 0x03	; 3
    1d92:	5c 93       	st	X, r21
    1d94:	13 97       	sbiw	r26, 0x03	; 3
    1d96:	14 96       	adiw	r26, 0x04	; 4
    1d98:	4c 93       	st	X, r20
    1d9a:	14 97       	sbiw	r26, 0x04	; 4
    1d9c:	15 96       	adiw	r26, 0x05	; 5
    1d9e:	3c 93       	st	X, r19
    1da0:	15 97       	sbiw	r26, 0x05	; 5
    1da2:	16 96       	adiw	r26, 0x06	; 6
    1da4:	2c 93       	st	X, r18
    1da6:	16 97       	sbiw	r26, 0x06	; 6
    1da8:	17 96       	adiw	r26, 0x07	; 7
    1daa:	9c 93       	st	X, r25
    1dac:	17 97       	sbiw	r26, 0x07	; 7
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1dae:	eb 81       	ldd	r30, Y+3	; 0x03
    1db0:	fc 81       	ldd	r31, Y+4	; 0x04
    1db2:	31 96       	adiw	r30, 0x01	; 1
    1db4:	eb 83       	std	Y+3, r30	; 0x03
    1db6:	fc 83       	std	Y+4, r31	; 0x04
    1db8:	0f 5f       	subi	r16, 0xFF	; 255
    1dba:	1f 4f       	sbci	r17, 0xFF	; 255
    1dbc:	2c e1       	ldi	r18, 0x1C	; 28
    1dbe:	e1 37       	cpi	r30, 0x71	; 113
    1dc0:	f2 07       	cpc	r31, r18
    1dc2:	09 f0       	breq	.+2      	; 0x1dc6 <calcChecksumFRAM+0x498>
    1dc4:	3b ce       	rjmp	.-906    	; 0x1a3c <calcChecksumFRAM+0x10e>
    1dc6:	89 81       	ldd	r24, Y+1	; 0x01
    1dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dca:	01 97       	sbiw	r24, 0x01	; 1
    1dcc:	89 83       	std	Y+1, r24	; 0x01
    1dce:	9a 83       	std	Y+2, r25	; 0x02
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    1dd0:	00 97       	sbiw	r24, 0x00	; 0
    1dd2:	09 f0       	breq	.+2      	; 0x1dd6 <calcChecksumFRAM+0x4a8>
    1dd4:	1a ce       	rjmp	.-972    	; 0x1a0a <calcChecksumFRAM+0xdc>
			
		}
		
	}
	
}
    1dd6:	24 96       	adiw	r28, 0x04	; 4
    1dd8:	cd bf       	out	0x3d, r28	; 61
    1dda:	de bf       	out	0x3e, r29	; 62
    1ddc:	df 91       	pop	r29
    1dde:	cf 91       	pop	r28
    1de0:	1f 91       	pop	r17
    1de2:	0f 91       	pop	r16
    1de4:	ff 90       	pop	r15
    1de6:	ef 90       	pop	r14
    1de8:	df 90       	pop	r13
    1dea:	cf 90       	pop	r12
    1dec:	bf 90       	pop	r11
    1dee:	af 90       	pop	r10
    1df0:	9f 90       	pop	r9
    1df2:	8f 90       	pop	r8
    1df4:	7f 90       	pop	r7
    1df6:	6f 90       	pop	r6
    1df8:	5f 90       	pop	r5
    1dfa:	4f 90       	pop	r4
    1dfc:	3f 90       	pop	r3
    1dfe:	2f 90       	pop	r2
    1e00:	08 95       	ret

00001e02 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    1e02:	2f 92       	push	r2
    1e04:	3f 92       	push	r3
    1e06:	4f 92       	push	r4
    1e08:	5f 92       	push	r5
    1e0a:	6f 92       	push	r6
    1e0c:	7f 92       	push	r7
    1e0e:	8f 92       	push	r8
    1e10:	9f 92       	push	r9
    1e12:	af 92       	push	r10
    1e14:	bf 92       	push	r11
    1e16:	cf 92       	push	r12
    1e18:	df 92       	push	r13
    1e1a:	ef 92       	push	r14
    1e1c:	ff 92       	push	r15
    1e1e:	0f 93       	push	r16
    1e20:	1f 93       	push	r17
    1e22:	cf 93       	push	r28
    1e24:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    1e26:	10 92 57 40 	sts	0x4057, r1
    1e2a:	10 92 58 40 	sts	0x4058, r1
	sampleCount = 0;
    1e2e:	10 92 74 50 	sts	0x5074, r1
    1e32:	10 92 75 50 	sts	0x5075, r1
    1e36:	10 92 76 50 	sts	0x5076, r1
    1e3a:	10 92 77 50 	sts	0x5077, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1e3e:	8d e3       	ldi	r24, 0x3D	; 61
    1e40:	91 e2       	ldi	r25, 0x21	; 33
    1e42:	10 92 3d 21 	sts	0x213D, r1
    1e46:	fc 01       	movw	r30, r24
    1e48:	31 97       	sbiw	r30, 0x01	; 1
    1e4a:	10 82       	st	Z, r1
    1e4c:	02 97       	sbiw	r24, 0x02	; 2
    1e4e:	dc 01       	movw	r26, r24
    1e50:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    1e52:	81 e0       	ldi	r24, 0x01	; 1
    1e54:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    1e58:	84 e0       	ldi	r24, 0x04	; 4
    1e5a:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1e5e:	80 ed       	ldi	r24, 0xD0	; 208
    1e60:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    1e64:	8d e0       	ldi	r24, 0x0D	; 13
    1e66:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[1] = 0xF3;
    1e6a:	83 ef       	ldi	r24, 0xF3	; 243
    1e6c:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[2] = 0x57;
    1e70:	87 e5       	ldi	r24, 0x57	; 87
    1e72:	80 93 67 50 	sts	0x5067, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    1e76:	80 91 74 50 	lds	r24, 0x5074
    1e7a:	90 91 75 50 	lds	r25, 0x5075
    1e7e:	a0 91 76 50 	lds	r26, 0x5076
    1e82:	b0 91 77 50 	lds	r27, 0x5077
    1e86:	83 35       	cpi	r24, 0x53	; 83
    1e88:	e5 e5       	ldi	r30, 0x55	; 85
    1e8a:	9e 07       	cpc	r25, r30
    1e8c:	e0 e0       	ldi	r30, 0x00	; 0
    1e8e:	ae 07       	cpc	r26, r30
    1e90:	e0 e0       	ldi	r30, 0x00	; 0
    1e92:	be 07       	cpc	r27, r30
    1e94:	08 f0       	brcs	.+2      	; 0x1e98 <FRAMWriteKnowns+0x96>
    1e96:	cc c0       	rjmp	.+408    	; 0x2030 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1e98:	0f 2e       	mov	r0, r31
    1e9a:	f0 e4       	ldi	r31, 0x40	; 64
    1e9c:	ef 2e       	mov	r14, r31
    1e9e:	f6 e0       	ldi	r31, 0x06	; 6
    1ea0:	ff 2e       	mov	r15, r31
    1ea2:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1ea4:	40 e2       	ldi	r20, 0x20	; 32
    1ea6:	56 e0       	ldi	r21, 0x06	; 6
    1ea8:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    1eaa:	e0 ec       	ldi	r30, 0xC0	; 192
    1eac:	f8 e0       	ldi	r31, 0x08	; 8
    1eae:	0f 2e       	mov	r0, r31
    1eb0:	f6 e0       	ldi	r31, 0x06	; 6
    1eb2:	7f 2e       	mov	r7, r31
    1eb4:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    1eb6:	c1 e7       	ldi	r28, 0x71	; 113
    1eb8:	d0 e5       	ldi	r29, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    1eba:	66 24       	eor	r6, r6
    1ebc:	68 94       	set
    1ebe:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1ec0:	0f 2e       	mov	r0, r31
    1ec2:	f7 e5       	ldi	r31, 0x57	; 87
    1ec4:	cf 2e       	mov	r12, r31
    1ec6:	f0 e4       	ldi	r31, 0x40	; 64
    1ec8:	df 2e       	mov	r13, r31
    1eca:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    1ecc:	8e 01       	movw	r16, r28
    1ece:	0c 50       	subi	r16, 0x0C	; 12
    1ed0:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    1ed2:	0f 2e       	mov	r0, r31
    1ed4:	f5 ef       	ldi	r31, 0xF5	; 245
    1ed6:	4f 2e       	mov	r4, r31
    1ed8:	ff ef       	ldi	r31, 0xFF	; 255
    1eda:	5f 2e       	mov	r5, r31
    1edc:	f0 2d       	mov	r31, r0
    1ede:	4c 0e       	add	r4, r28
    1ee0:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    1ee2:	0f 2e       	mov	r0, r31
    1ee4:	f6 ef       	ldi	r31, 0xF6	; 246
    1ee6:	2f 2e       	mov	r2, r31
    1ee8:	ff ef       	ldi	r31, 0xFF	; 255
    1eea:	3f 2e       	mov	r3, r31
    1eec:	f0 2d       	mov	r31, r0
    1eee:	2c 0e       	add	r2, r28
    1ef0:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    1ef2:	6b e3       	ldi	r22, 0x3B	; 59
    1ef4:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    1ef6:	5b 01       	movw	r10, r22
    1ef8:	08 94       	sec
    1efa:	a1 1c       	adc	r10, r1
    1efc:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    1efe:	88 24       	eor	r8, r8
    1f00:	99 24       	eor	r9, r9
    1f02:	68 94       	set
    1f04:	81 f8       	bld	r8, 1
    1f06:	86 0e       	add	r8, r22
    1f08:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1f0a:	30 e1       	ldi	r19, 0x10	; 16
    1f0c:	d7 01       	movw	r26, r14
    1f0e:	16 96       	adiw	r26, 0x06	; 6
    1f10:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1f12:	da 01       	movw	r26, r20
    1f14:	16 96       	adiw	r26, 0x06	; 6
    1f16:	2c 93       	st	X, r18
    1f18:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    1f1a:	00 00       	nop
		SPIC.DATA = FR_WREN;
    1f1c:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f1e:	82 81       	ldd	r24, Z+2	; 0x02
    1f20:	88 23       	and	r24, r24
    1f22:	ec f7       	brge	.-6      	; 0x1f1e <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    1f24:	83 81       	ldd	r24, Z+3	; 0x03
    1f26:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    1f28:	da 01       	movw	r26, r20
    1f2a:	15 96       	adiw	r26, 0x05	; 5
    1f2c:	2c 93       	st	X, r18
    1f2e:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    1f30:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1f32:	16 96       	adiw	r26, 0x06	; 6
    1f34:	2c 93       	st	X, r18
    1f36:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    1f38:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    1f3a:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f3c:	82 81       	ldd	r24, Z+2	; 0x02
    1f3e:	88 23       	and	r24, r24
    1f40:	ec f7       	brge	.-6      	; 0x1f3c <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    1f42:	83 81       	ldd	r24, Z+3	; 0x03
    1f44:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1f46:	d6 01       	movw	r26, r12
    1f48:	11 96       	adiw	r26, 0x01	; 1
    1f4a:	8c 91       	ld	r24, X
    1f4c:	11 97       	sbiw	r26, 0x01	; 1
    1f4e:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f50:	82 81       	ldd	r24, Z+2	; 0x02
    1f52:	88 23       	and	r24, r24
    1f54:	ec f7       	brge	.-6      	; 0x1f50 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    1f56:	83 81       	ldd	r24, Z+3	; 0x03
    1f58:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1f5a:	d6 01       	movw	r26, r12
    1f5c:	8c 91       	ld	r24, X
    1f5e:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f60:	82 81       	ldd	r24, Z+2	; 0x02
    1f62:	88 23       	and	r24, r24
    1f64:	ec f7       	brge	.-6      	; 0x1f60 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    1f66:	83 81       	ldd	r24, Z+3	; 0x03
    1f68:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    1f6a:	d8 01       	movw	r26, r16
    1f6c:	8c 91       	ld	r24, X
    1f6e:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f70:	82 81       	ldd	r24, Z+2	; 0x02
    1f72:	88 23       	and	r24, r24
    1f74:	ec f7       	brge	.-6      	; 0x1f70 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    1f76:	83 81       	ldd	r24, Z+3	; 0x03
    1f78:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    1f7a:	d2 01       	movw	r26, r4
    1f7c:	8c 91       	ld	r24, X
    1f7e:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f80:	82 81       	ldd	r24, Z+2	; 0x02
    1f82:	88 23       	and	r24, r24
    1f84:	ec f7       	brge	.-6      	; 0x1f80 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    1f86:	83 81       	ldd	r24, Z+3	; 0x03
    1f88:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    1f8a:	d1 01       	movw	r26, r2
    1f8c:	8c 91       	ld	r24, X
    1f8e:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1f90:	82 81       	ldd	r24, Z+2	; 0x02
    1f92:	88 23       	and	r24, r24
    1f94:	ec f7       	brge	.-6      	; 0x1f90 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    1f96:	83 81       	ldd	r24, Z+3	; 0x03
    1f98:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    1f9a:	da 01       	movw	r26, r20
    1f9c:	15 96       	adiw	r26, 0x05	; 5
    1f9e:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1fa0:	30 e1       	ldi	r19, 0x10	; 16
    1fa2:	d7 01       	movw	r26, r14
    1fa4:	15 96       	adiw	r26, 0x05	; 5
    1fa6:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    1fa8:	80 91 57 40 	lds	r24, 0x4057
    1fac:	90 91 58 40 	lds	r25, 0x4058
    1fb0:	03 96       	adiw	r24, 0x03	; 3
    1fb2:	80 93 57 40 	sts	0x4057, r24
    1fb6:	90 93 58 40 	sts	0x4058, r25
		checksumADC[0] += SPIBuffer[0];
    1fba:	db 01       	movw	r26, r22
    1fbc:	8c 91       	ld	r24, X
    1fbe:	d8 01       	movw	r26, r16
    1fc0:	9c 91       	ld	r25, X
    1fc2:	89 0f       	add	r24, r25
    1fc4:	db 01       	movw	r26, r22
    1fc6:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    1fc8:	d5 01       	movw	r26, r10
    1fca:	8c 91       	ld	r24, X
    1fcc:	a6 e6       	ldi	r26, 0x66	; 102
    1fce:	b0 e5       	ldi	r27, 0x50	; 80
    1fd0:	9c 91       	ld	r25, X
    1fd2:	89 0f       	add	r24, r25
    1fd4:	d5 01       	movw	r26, r10
    1fd6:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    1fd8:	d4 01       	movw	r26, r8
    1fda:	8c 91       	ld	r24, X
    1fdc:	a7 e6       	ldi	r26, 0x67	; 103
    1fde:	b0 e5       	ldi	r27, 0x50	; 80
    1fe0:	9c 91       	ld	r25, X
    1fe2:	89 0f       	add	r24, r25
    1fe4:	d4 01       	movw	r26, r8
    1fe6:	8c 93       	st	X, r24
		
		sampleCount++;
    1fe8:	80 91 74 50 	lds	r24, 0x5074
    1fec:	90 91 75 50 	lds	r25, 0x5075
    1ff0:	a0 91 76 50 	lds	r26, 0x5076
    1ff4:	b0 91 77 50 	lds	r27, 0x5077
    1ff8:	01 96       	adiw	r24, 0x01	; 1
    1ffa:	a1 1d       	adc	r26, r1
    1ffc:	b1 1d       	adc	r27, r1
    1ffe:	80 93 74 50 	sts	0x5074, r24
    2002:	90 93 75 50 	sts	0x5075, r25
    2006:	a0 93 76 50 	sts	0x5076, r26
    200a:	b0 93 77 50 	sts	0x5077, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    200e:	80 91 74 50 	lds	r24, 0x5074
    2012:	90 91 75 50 	lds	r25, 0x5075
    2016:	a0 91 76 50 	lds	r26, 0x5076
    201a:	b0 91 77 50 	lds	r27, 0x5077
    201e:	83 35       	cpi	r24, 0x53	; 83
    2020:	35 e5       	ldi	r19, 0x55	; 85
    2022:	93 07       	cpc	r25, r19
    2024:	30 e0       	ldi	r19, 0x00	; 0
    2026:	a3 07       	cpc	r26, r19
    2028:	30 e0       	ldi	r19, 0x00	; 0
    202a:	b3 07       	cpc	r27, r19
    202c:	08 f4       	brcc	.+2      	; 0x2030 <FRAMWriteKnowns+0x22e>
    202e:	6d cf       	rjmp	.-294    	; 0x1f0a <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2030:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	ADCPower(FALSE);
    2034:	80 e0       	ldi	r24, 0x00	; 0
    2036:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
}
    203a:	df 91       	pop	r29
    203c:	cf 91       	pop	r28
    203e:	1f 91       	pop	r17
    2040:	0f 91       	pop	r16
    2042:	ff 90       	pop	r15
    2044:	ef 90       	pop	r14
    2046:	df 90       	pop	r13
    2048:	cf 90       	pop	r12
    204a:	bf 90       	pop	r11
    204c:	af 90       	pop	r10
    204e:	9f 90       	pop	r9
    2050:	8f 90       	pop	r8
    2052:	7f 90       	pop	r7
    2054:	6f 90       	pop	r6
    2056:	5f 90       	pop	r5
    2058:	4f 90       	pop	r4
    205a:	3f 90       	pop	r3
    205c:	2f 90       	pop	r2
    205e:	08 95       	ret

00002060 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2060:	80 ff       	sbrs	r24, 0
    2062:	05 c0       	rjmp	.+10     	; 0x206e <setADCInput+0xe>
    2064:	20 e4       	ldi	r18, 0x40	; 64
    2066:	e0 e0       	ldi	r30, 0x00	; 0
    2068:	f6 e0       	ldi	r31, 0x06	; 6
    206a:	25 83       	std	Z+5, r18	; 0x05
    206c:	04 c0       	rjmp	.+8      	; 0x2076 <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    206e:	20 e4       	ldi	r18, 0x40	; 64
    2070:	e0 e0       	ldi	r30, 0x00	; 0
    2072:	f6 e0       	ldi	r31, 0x06	; 6
    2074:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2076:	81 ff       	sbrs	r24, 1
    2078:	05 c0       	rjmp	.+10     	; 0x2084 <setADCInput+0x24>
    207a:	22 e0       	ldi	r18, 0x02	; 2
    207c:	e0 e2       	ldi	r30, 0x20	; 32
    207e:	f6 e0       	ldi	r31, 0x06	; 6
    2080:	25 83       	std	Z+5, r18	; 0x05
    2082:	04 c0       	rjmp	.+8      	; 0x208c <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2084:	22 e0       	ldi	r18, 0x02	; 2
    2086:	e0 e2       	ldi	r30, 0x20	; 32
    2088:	f6 e0       	ldi	r31, 0x06	; 6
    208a:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    208c:	82 ff       	sbrs	r24, 2
    208e:	05 c0       	rjmp	.+10     	; 0x209a <setADCInput+0x3a>
    2090:	84 e0       	ldi	r24, 0x04	; 4
    2092:	e0 e2       	ldi	r30, 0x20	; 32
    2094:	f6 e0       	ldi	r31, 0x06	; 6
    2096:	85 83       	std	Z+5, r24	; 0x05
    2098:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    209a:	84 e0       	ldi	r24, 0x04	; 4
    209c:	e0 e2       	ldi	r30, 0x20	; 32
    209e:	f6 e0       	ldi	r31, 0x06	; 6
    20a0:	86 83       	std	Z+6, r24	; 0x06
    20a2:	08 95       	ret

000020a4 <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    20a4:	2f 92       	push	r2
    20a6:	3f 92       	push	r3
    20a8:	4f 92       	push	r4
    20aa:	5f 92       	push	r5
    20ac:	7f 92       	push	r7
    20ae:	8f 92       	push	r8
    20b0:	9f 92       	push	r9
    20b2:	af 92       	push	r10
    20b4:	bf 92       	push	r11
    20b6:	cf 92       	push	r12
    20b8:	df 92       	push	r13
    20ba:	ef 92       	push	r14
    20bc:	ff 92       	push	r15
    20be:	0f 93       	push	r16
    20c0:	1f 93       	push	r17
    20c2:	cf 93       	push	r28
    20c4:	df 93       	push	r29
    20c6:	cd b7       	in	r28, 0x3d	; 61
    20c8:	de b7       	in	r29, 0x3e	; 62
    20ca:	18 2f       	mov	r17, r24
    20cc:	76 2e       	mov	r7, r22
    20ce:	f4 2e       	mov	r15, r20
    20d0:	19 01       	movw	r2, r18
	
	ADC_BUFFER=DataArray;
    20d2:	89 8d       	ldd	r24, Y+25	; 0x19
    20d4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    20d6:	80 93 72 50 	sts	0x5072, r24
    20da:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    20de:	10 92 d5 50 	sts	0x50D5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    20e2:	81 e0       	ldi	r24, 0x01	; 1
    20e4:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    20e8:	81 2f       	mov	r24, r17
    20ea:	6f 2d       	mov	r22, r15
    20ec:	0e 94 76 03 	call	0x6ec	; 0x6ec <set_ampGain>
	set_filter(filterConfig);
    20f0:	87 2d       	mov	r24, r7
    20f2:	0e 94 af 03 	call	0x75e	; 0x75e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    20f6:	8e 2d       	mov	r24, r14
    20f8:	0e 94 85 08 	call	0x110a	; 0x110a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    20fc:	84 e0       	ldi	r24, 0x04	; 4
    20fe:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2102:	84 e5       	ldi	r24, 0x54	; 84
    2104:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2108:	81 e0       	ldi	r24, 0x01	; 1
    210a:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <enableADCMUX>
	setADCInput(channel);
    210e:	81 2f       	mov	r24, r17
    2110:	0e 94 30 10 	call	0x2060	; 0x2060 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2114:	e0 ea       	ldi	r30, 0xA0	; 160
    2116:	f6 e0       	ldi	r31, 0x06	; 6
    2118:	22 e0       	ldi	r18, 0x02	; 2
    211a:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    211c:	77 24       	eor	r7, r7
    211e:	73 94       	inc	r7
    2120:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2122:	0f 2e       	mov	r0, r31
    2124:	f0 e8       	ldi	r31, 0x80	; 128
    2126:	4f 2e       	mov	r4, r31
    2128:	f1 e0       	ldi	r31, 0x01	; 1
    212a:	5f 2e       	mov	r5, r31
    212c:	f0 2d       	mov	r31, r0
    212e:	88 e7       	ldi	r24, 0x78	; 120
    2130:	d2 01       	movw	r26, r4
    2132:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2134:	e0 e0       	ldi	r30, 0x00	; 0
    2136:	f9 e0       	ldi	r31, 0x09	; 9
    2138:	80 ef       	ldi	r24, 0xF0	; 240
    213a:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    213c:	c0 a6       	lds	r28, 0xb0
    213e:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2140:	a2 a6       	lds	r26, 0xb2
    2142:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2144:	84 a6       	lds	r24, 0xb4
    2146:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2148:	8d 89       	ldd	r24, Y+21	; 0x15
    214a:	9e 89       	ldd	r25, Y+22	; 0x16
    214c:	86 a7       	lds	r24, 0x76
    214e:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2150:	80 2f       	mov	r24, r16
    2152:	90 e0       	ldi	r25, 0x00	; 0
    2154:	01 97       	sbiw	r24, 0x01	; 1
    2156:	86 a3       	lds	r24, 0x56
    2158:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    215a:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    215c:	8f ef       	ldi	r24, 0xFF	; 255
    215e:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2160:	80 81       	ld	r24, Z
    2162:	80 7f       	andi	r24, 0xF0	; 240
    2164:	88 60       	ori	r24, 0x08	; 8
    2166:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2168:	10 92 74 50 	sts	0x5074, r1
    216c:	10 92 75 50 	sts	0x5075, r1
    2170:	10 92 76 50 	sts	0x5076, r1
    2174:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    2178:	10 92 ce 50 	sts	0x50CE, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    217c:	e0 ea       	ldi	r30, 0xA0	; 160
    217e:	f0 e0       	ldi	r31, 0x00	; 0
    2180:	82 81       	ldd	r24, Z+2	; 0x02
    2182:	86 60       	ori	r24, 0x06	; 6
    2184:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2186:	78 94       	sei

	SPICS(TRUE);
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    218e:	80 e2       	ldi	r24, 0x20	; 32
    2190:	e0 e8       	ldi	r30, 0x80	; 128
    2192:	f6 e0       	ldi	r31, 0x06	; 6
    2194:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2196:	00 e4       	ldi	r16, 0x40	; 64
    2198:	1a e0       	ldi	r17, 0x0A	; 10
    219a:	83 e2       	ldi	r24, 0x23	; 35
    219c:	f8 01       	movw	r30, r16
    219e:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    21a0:	61 01       	movw	r12, r2
    21a2:	ee 24       	eor	r14, r14
    21a4:	ff 24       	eor	r15, r15
    21a6:	60 e8       	ldi	r22, 0x80	; 128
    21a8:	74 e8       	ldi	r23, 0x84	; 132
    21aa:	8e e1       	ldi	r24, 0x1E	; 30
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	a7 01       	movw	r20, r14
    21b0:	96 01       	movw	r18, r12
    21b2:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    21b6:	d8 01       	movw	r26, r16
    21b8:	96 96       	adiw	r26, 0x26	; 38
    21ba:	2d 93       	st	X+, r18
    21bc:	3c 93       	st	X, r19
    21be:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    21c0:	60 e4       	ldi	r22, 0x40	; 64
    21c2:	72 e4       	ldi	r23, 0x42	; 66
    21c4:	8f e0       	ldi	r24, 0x0F	; 15
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	a7 01       	movw	r20, r14
    21ca:	96 01       	movw	r18, r12
    21cc:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    21d0:	f8 01       	movw	r30, r16
    21d2:	22 af       	sts	0x72, r18
    21d4:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    21d6:	e0 e4       	ldi	r30, 0x40	; 64
    21d8:	f8 e0       	ldi	r31, 0x08	; 8
    21da:	8f 89       	ldd	r24, Y+23	; 0x17
    21dc:	98 8d       	ldd	r25, Y+24	; 0x18
    21de:	86 a3       	lds	r24, 0x56
    21e0:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    21e2:	80 ed       	ldi	r24, 0xD0	; 208
    21e4:	d2 01       	movw	r26, r4
    21e6:	11 96       	adiw	r26, 0x01	; 1
    21e8:	8c 93       	st	X, r24
    21ea:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to med lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    21ec:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    21ee:	80 81       	ld	r24, Z
    21f0:	80 7f       	andi	r24, 0xF0	; 240
    21f2:	89 60       	ori	r24, 0x09	; 9
    21f4:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    21f6:	f8 01       	movw	r30, r16
    21f8:	80 81       	ld	r24, Z
    21fa:	80 7f       	andi	r24, 0xF0	; 240
    21fc:	81 60       	ori	r24, 0x01	; 1
    21fe:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2200:	df 91       	pop	r29
    2202:	cf 91       	pop	r28
    2204:	1f 91       	pop	r17
    2206:	0f 91       	pop	r16
    2208:	ff 90       	pop	r15
    220a:	ef 90       	pop	r14
    220c:	df 90       	pop	r13
    220e:	cf 90       	pop	r12
    2210:	bf 90       	pop	r11
    2212:	af 90       	pop	r10
    2214:	9f 90       	pop	r9
    2216:	8f 90       	pop	r8
    2218:	7f 90       	pop	r7
    221a:	5f 90       	pop	r5
    221c:	4f 90       	pop	r4
    221e:	3f 90       	pop	r3
    2220:	2f 90       	pop	r2
    2222:	08 95       	ret

00002224 <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2224:	2f 92       	push	r2
    2226:	3f 92       	push	r3
    2228:	4f 92       	push	r4
    222a:	5f 92       	push	r5
    222c:	6f 92       	push	r6
    222e:	7f 92       	push	r7
    2230:	8f 92       	push	r8
    2232:	9f 92       	push	r9
    2234:	af 92       	push	r10
    2236:	bf 92       	push	r11
    2238:	cf 92       	push	r12
    223a:	df 92       	push	r13
    223c:	ef 92       	push	r14
    223e:	ff 92       	push	r15
    2240:	0f 93       	push	r16
    2242:	cf 93       	push	r28
    2244:	df 93       	push	r29
    2246:	cd b7       	in	r28, 0x3d	; 61
    2248:	de b7       	in	r29, 0x3e	; 62
    224a:	96 2f       	mov	r25, r22
    224c:	1a 01       	movw	r2, r20
    224e:	52 2f       	mov	r21, r18
    2250:	70 2f       	mov	r23, r16
    2252:	d7 01       	movw	r26, r14
    2254:	36 01       	movw	r6, r12
    2256:	25 01       	movw	r4, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2258:	00 d0       	rcall	.+0      	; 0x225a <CO_collectSeismic1Channel+0x36>
    225a:	00 d0       	rcall	.+0      	; 0x225c <CO_collectSeismic1Channel+0x38>
    225c:	2d b7       	in	r18, 0x3d	; 61
    225e:	3e b7       	in	r19, 0x3e	; 62
    2260:	2f 5f       	subi	r18, 0xFF	; 255
    2262:	3f 4f       	sbci	r19, 0xFF	; 255
    2264:	ed b7       	in	r30, 0x3d	; 61
    2266:	fe b7       	in	r31, 0x3e	; 62
    2268:	81 82       	std	Z+1, r8	; 0x01
    226a:	92 82       	std	Z+2, r9	; 0x02
    226c:	8d 88       	ldd	r8, Y+21	; 0x15
    226e:	9e 88       	ldd	r9, Y+22	; 0x16
    2270:	f9 01       	movw	r30, r18
    2272:	82 82       	std	Z+2, r8	; 0x02
    2274:	93 82       	std	Z+3, r9	; 0x03
    2276:	8f 88       	ldd	r8, Y+23	; 0x17
    2278:	98 8c       	ldd	r9, Y+24	; 0x18
    227a:	84 82       	std	Z+4, r8	; 0x04
    227c:	95 82       	std	Z+5, r9	; 0x05
    227e:	64 ec       	ldi	r22, 0xC4	; 196
    2280:	49 2f       	mov	r20, r25
    2282:	91 01       	movw	r18, r2
    2284:	05 2f       	mov	r16, r21
    2286:	e7 2e       	mov	r14, r23
    2288:	6d 01       	movw	r12, r26
    228a:	53 01       	movw	r10, r6
    228c:	42 01       	movw	r8, r4
    228e:	0e 94 52 10 	call	0x20a4	; 0x20a4 <CO_collectSeismic1Channel_ext>
    2292:	8d b7       	in	r24, 0x3d	; 61
    2294:	9e b7       	in	r25, 0x3e	; 62
    2296:	06 96       	adiw	r24, 0x06	; 6
    2298:	8d bf       	out	0x3d, r24	; 61
    229a:	9e bf       	out	0x3e, r25	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    229c:	df 91       	pop	r29
    229e:	cf 91       	pop	r28
    22a0:	0f 91       	pop	r16
    22a2:	ff 90       	pop	r15
    22a4:	ef 90       	pop	r14
    22a6:	df 90       	pop	r13
    22a8:	cf 90       	pop	r12
    22aa:	bf 90       	pop	r11
    22ac:	af 90       	pop	r10
    22ae:	9f 90       	pop	r9
    22b0:	8f 90       	pop	r8
    22b2:	7f 90       	pop	r7
    22b4:	6f 90       	pop	r6
    22b6:	5f 90       	pop	r5
    22b8:	4f 90       	pop	r4
    22ba:	3f 90       	pop	r3
    22bc:	2f 90       	pop	r2
    22be:	08 95       	ret

000022c0 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    22c0:	2f 92       	push	r2
    22c2:	3f 92       	push	r3
    22c4:	5f 92       	push	r5
    22c6:	6f 92       	push	r6
    22c8:	7f 92       	push	r7
    22ca:	8f 92       	push	r8
    22cc:	9f 92       	push	r9
    22ce:	af 92       	push	r10
    22d0:	bf 92       	push	r11
    22d2:	cf 92       	push	r12
    22d4:	df 92       	push	r13
    22d6:	ef 92       	push	r14
    22d8:	ff 92       	push	r15
    22da:	0f 93       	push	r16
    22dc:	1f 93       	push	r17
    22de:	cf 93       	push	r28
    22e0:	df 93       	push	r29
    22e2:	0f 92       	push	r0
    22e4:	0f 92       	push	r0
    22e6:	cd b7       	in	r28, 0x3d	; 61
    22e8:	de b7       	in	r29, 0x3e	; 62
    22ea:	18 2f       	mov	r17, r24
    22ec:	3b 01       	movw	r6, r22
    22ee:	49 83       	std	Y+1, r20	; 0x01
    22f0:	5a 83       	std	Y+2, r21	; 0x02
    22f2:	52 2e       	mov	r5, r18
	
	ADC_BUFFER = DataArray;
    22f4:	89 8d       	ldd	r24, Y+25	; 0x19
    22f6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    22f8:	80 93 72 50 	sts	0x5072, r24
    22fc:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    2300:	10 92 d5 50 	sts	0x50D5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2304:	81 e0       	ldi	r24, 0x01	; 1
    2306:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    230a:	85 e0       	ldi	r24, 0x05	; 5
    230c:	d3 01       	movw	r26, r6
    230e:	6c 91       	ld	r22, X
    2310:	0e 94 76 03 	call	0x6ec	; 0x6ec <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2314:	86 e0       	ldi	r24, 0x06	; 6
    2316:	f3 01       	movw	r30, r6
    2318:	61 81       	ldd	r22, Z+1	; 0x01
    231a:	0e 94 76 03 	call	0x6ec	; 0x6ec <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    231e:	87 e0       	ldi	r24, 0x07	; 7
    2320:	d3 01       	movw	r26, r6
    2322:	12 96       	adiw	r26, 0x02	; 2
    2324:	6c 91       	ld	r22, X
    2326:	0e 94 76 03 	call	0x6ec	; 0x6ec <set_ampGain>
	set_filter(filterConfig);
    232a:	81 2f       	mov	r24, r17
    232c:	0e 94 af 03 	call	0x75e	; 0x75e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2330:	80 2f       	mov	r24, r16
    2332:	0e 94 85 08 	call	0x110a	; 0x110a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2336:	84 e0       	ldi	r24, 0x04	; 4
    2338:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    233c:	84 e5       	ldi	r24, 0x54	; 84
    233e:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2348:	85 e0       	ldi	r24, 0x05	; 5
    234a:	0e 94 30 10 	call	0x2060	; 0x2060 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    234e:	e0 ea       	ldi	r30, 0xA0	; 160
    2350:	f6 e0       	ldi	r31, 0x06	; 6
    2352:	22 e0       	ldi	r18, 0x02	; 2
    2354:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2356:	66 24       	eor	r6, r6
    2358:	63 94       	inc	r6
    235a:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    235c:	0f 2e       	mov	r0, r31
    235e:	f0 e8       	ldi	r31, 0x80	; 128
    2360:	2f 2e       	mov	r2, r31
    2362:	f1 e0       	ldi	r31, 0x01	; 1
    2364:	3f 2e       	mov	r3, r31
    2366:	f0 2d       	mov	r31, r0
    2368:	88 e7       	ldi	r24, 0x78	; 120
    236a:	f1 01       	movw	r30, r2
    236c:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    236e:	e0 e0       	ldi	r30, 0x00	; 0
    2370:	f8 e0       	ldi	r31, 0x08	; 8
    2372:	80 ef       	ldi	r24, 0xF0	; 240
    2374:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2376:	e0 a6       	lds	r30, 0xb0
    2378:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    237a:	c2 a6       	lds	r28, 0xb2
    237c:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    237e:	a4 a6       	lds	r26, 0xb4
    2380:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2382:	86 a6       	lds	r24, 0xb6
    2384:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2386:	85 2d       	mov	r24, r5
    2388:	90 e0       	ldi	r25, 0x00	; 0
    238a:	01 97       	sbiw	r24, 0x01	; 1
    238c:	86 a3       	lds	r24, 0x56
    238e:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2390:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2392:	8f ef       	ldi	r24, 0xFF	; 255
    2394:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2396:	80 81       	ld	r24, Z
    2398:	80 7f       	andi	r24, 0xF0	; 240
    239a:	88 60       	ori	r24, 0x08	; 8
    239c:	80 83       	st	Z, r24

	sampleCount = 0;
    239e:	10 92 74 50 	sts	0x5074, r1
    23a2:	10 92 75 50 	sts	0x5075, r1
    23a6:	10 92 76 50 	sts	0x5076, r1
    23aa:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    23ae:	10 92 ce 50 	sts	0x50CE, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    23b2:	8d e3       	ldi	r24, 0x3D	; 61
    23b4:	91 e2       	ldi	r25, 0x21	; 33
    23b6:	10 92 3d 21 	sts	0x213D, r1
    23ba:	fc 01       	movw	r30, r24
    23bc:	31 97       	sbiw	r30, 0x01	; 1
    23be:	10 82       	st	Z, r1
    23c0:	02 97       	sbiw	r24, 0x02	; 2
    23c2:	dc 01       	movw	r26, r24
    23c4:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    23c6:	e0 ea       	ldi	r30, 0xA0	; 160
    23c8:	f0 e0       	ldi	r31, 0x00	; 0
    23ca:	82 81       	ldd	r24, Z+2	; 0x02
    23cc:	86 60       	ori	r24, 0x06	; 6
    23ce:	82 83       	std	Z+2, r24	; 0x02
	sei();
    23d0:	78 94       	sei

	SPICS(TRUE);
    23d2:	81 e0       	ldi	r24, 0x01	; 1
    23d4:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    23d8:	80 e2       	ldi	r24, 0x20	; 32
    23da:	e0 e8       	ldi	r30, 0x80	; 128
    23dc:	f6 e0       	ldi	r31, 0x06	; 6
    23de:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    23e0:	00 e4       	ldi	r16, 0x40	; 64
    23e2:	1a e0       	ldi	r17, 0x0A	; 10
    23e4:	83 e2       	ldi	r24, 0x23	; 35
    23e6:	f8 01       	movw	r30, r16
    23e8:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    23ea:	89 81       	ldd	r24, Y+1	; 0x01
    23ec:	9a 81       	ldd	r25, Y+2	; 0x02
    23ee:	6c 01       	movw	r12, r24
    23f0:	ee 24       	eor	r14, r14
    23f2:	ff 24       	eor	r15, r15
    23f4:	60 e8       	ldi	r22, 0x80	; 128
    23f6:	74 e8       	ldi	r23, 0x84	; 132
    23f8:	8e e1       	ldi	r24, 0x1E	; 30
    23fa:	90 e0       	ldi	r25, 0x00	; 0
    23fc:	a7 01       	movw	r20, r14
    23fe:	96 01       	movw	r18, r12
    2400:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    2404:	d8 01       	movw	r26, r16
    2406:	96 96       	adiw	r26, 0x26	; 38
    2408:	2d 93       	st	X+, r18
    240a:	3c 93       	st	X, r19
    240c:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    240e:	60 e4       	ldi	r22, 0x40	; 64
    2410:	72 e4       	ldi	r23, 0x42	; 66
    2412:	8f e0       	ldi	r24, 0x0F	; 15
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	a7 01       	movw	r20, r14
    2418:	96 01       	movw	r18, r12
    241a:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    241e:	f8 01       	movw	r30, r16
    2420:	22 af       	sts	0x72, r18
    2422:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2424:	e0 e4       	ldi	r30, 0x40	; 64
    2426:	f8 e0       	ldi	r31, 0x08	; 8
    2428:	8f 89       	ldd	r24, Y+23	; 0x17
    242a:	98 8d       	ldd	r25, Y+24	; 0x18
    242c:	86 a3       	lds	r24, 0x56
    242e:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2430:	80 ec       	ldi	r24, 0xC0	; 192
    2432:	d1 01       	movw	r26, r2
    2434:	11 96       	adiw	r26, 0x01	; 1
    2436:	8c 93       	st	X, r24
    2438:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to med lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    243a:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    243c:	80 81       	ld	r24, Z
    243e:	80 7f       	andi	r24, 0xF0	; 240
    2440:	89 60       	ori	r24, 0x09	; 9
    2442:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2444:	f8 01       	movw	r30, r16
    2446:	80 81       	ld	r24, Z
    2448:	80 7f       	andi	r24, 0xF0	; 240
    244a:	81 60       	ori	r24, 0x01	; 1
    244c:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    244e:	0f 90       	pop	r0
    2450:	0f 90       	pop	r0
    2452:	df 91       	pop	r29
    2454:	cf 91       	pop	r28
    2456:	1f 91       	pop	r17
    2458:	0f 91       	pop	r16
    245a:	ff 90       	pop	r15
    245c:	ef 90       	pop	r14
    245e:	df 90       	pop	r13
    2460:	cf 90       	pop	r12
    2462:	bf 90       	pop	r11
    2464:	af 90       	pop	r10
    2466:	9f 90       	pop	r9
    2468:	8f 90       	pop	r8
    246a:	7f 90       	pop	r7
    246c:	6f 90       	pop	r6
    246e:	5f 90       	pop	r5
    2470:	3f 90       	pop	r3
    2472:	2f 90       	pop	r2
    2474:	08 95       	ret

00002476 <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2476:	2f 92       	push	r2
    2478:	3f 92       	push	r3
    247a:	4f 92       	push	r4
    247c:	5f 92       	push	r5
    247e:	6f 92       	push	r6
    2480:	7f 92       	push	r7
    2482:	8f 92       	push	r8
    2484:	9f 92       	push	r9
    2486:	af 92       	push	r10
    2488:	bf 92       	push	r11
    248a:	cf 92       	push	r12
    248c:	df 92       	push	r13
    248e:	ef 92       	push	r14
    2490:	ff 92       	push	r15
    2492:	0f 93       	push	r16
    2494:	1f 93       	push	r17
    2496:	cf 93       	push	r28
    2498:	df 93       	push	r29
    249a:	00 d0       	rcall	.+0      	; 0x249c <CO_collectSeismic3Axises+0x26>
    249c:	0f 92       	push	r0
    249e:	cd b7       	in	r28, 0x3d	; 61
    24a0:	de b7       	in	r29, 0x3e	; 62
    24a2:	8b 83       	std	Y+3, r24	; 0x03
    24a4:	9c 83       	std	Y+4, r25	; 0x04
    24a6:	db 01       	movw	r26, r22
    24a8:	94 2f       	mov	r25, r20
    24aa:	32 2f       	mov	r19, r18
    24ac:	38 01       	movw	r6, r16
    24ae:	27 01       	movw	r4, r14
    24b0:	16 01       	movw	r2, r12
    24b2:	a9 82       	std	Y+1, r10	; 0x01
    24b4:	ba 82       	std	Y+2, r11	; 0x02
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    24b6:	00 d0       	rcall	.+0      	; 0x24b8 <CO_collectSeismic3Axises+0x42>
    24b8:	0f 92       	push	r0
    24ba:	ed b7       	in	r30, 0x3d	; 61
    24bc:	fe b7       	in	r31, 0x3e	; 62
    24be:	81 82       	std	Z+1, r8	; 0x01
    24c0:	92 82       	std	Z+2, r9	; 0x02
    24c2:	4a 8d       	ldd	r20, Y+26	; 0x1a
    24c4:	5b 8d       	ldd	r21, Y+27	; 0x1b
    24c6:	43 83       	std	Z+3, r20	; 0x03
    24c8:	54 83       	std	Z+4, r21	; 0x04
    24ca:	84 ec       	ldi	r24, 0xC4	; 196
    24cc:	6b 81       	ldd	r22, Y+3	; 0x03
    24ce:	7c 81       	ldd	r23, Y+4	; 0x04
    24d0:	ad 01       	movw	r20, r26
    24d2:	29 2f       	mov	r18, r25
    24d4:	03 2f       	mov	r16, r19
    24d6:	73 01       	movw	r14, r6
    24d8:	62 01       	movw	r12, r4
    24da:	51 01       	movw	r10, r2
    24dc:	89 80       	ldd	r8, Y+1	; 0x01
    24de:	9a 80       	ldd	r9, Y+2	; 0x02
    24e0:	0e 94 60 11 	call	0x22c0	; 0x22c0 <CO_collectSeismic3Axises_ext>
    24e4:	0f 90       	pop	r0
    24e6:	0f 90       	pop	r0
    24e8:	0f 90       	pop	r0
    24ea:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    24ec:	24 96       	adiw	r28, 0x04	; 4
    24ee:	cd bf       	out	0x3d, r28	; 61
    24f0:	de bf       	out	0x3e, r29	; 62
    24f2:	df 91       	pop	r29
    24f4:	cf 91       	pop	r28
    24f6:	1f 91       	pop	r17
    24f8:	0f 91       	pop	r16
    24fa:	ff 90       	pop	r15
    24fc:	ef 90       	pop	r14
    24fe:	df 90       	pop	r13
    2500:	cf 90       	pop	r12
    2502:	bf 90       	pop	r11
    2504:	af 90       	pop	r10
    2506:	9f 90       	pop	r9
    2508:	8f 90       	pop	r8
    250a:	7f 90       	pop	r7
    250c:	6f 90       	pop	r6
    250e:	5f 90       	pop	r5
    2510:	4f 90       	pop	r4
    2512:	3f 90       	pop	r3
    2514:	2f 90       	pop	r2
    2516:	08 95       	ret

00002518 <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2518:	8f 92       	push	r8
    251a:	9f 92       	push	r9
    251c:	af 92       	push	r10
    251e:	bf 92       	push	r11
    2520:	df 92       	push	r13
    2522:	ef 92       	push	r14
    2524:	ff 92       	push	r15
    2526:	0f 93       	push	r16
    2528:	1f 93       	push	r17
    252a:	cf 93       	push	r28
    252c:	df 93       	push	r29
    252e:	c8 2f       	mov	r28, r24
    2530:	d6 2e       	mov	r13, r22
    2532:	d4 2f       	mov	r29, r20
    2534:	59 01       	movw	r10, r18
    2536:	48 01       	movw	r8, r16


	uint16_t period;
	ADC_BUFFER = DataArray;
    2538:	e0 92 72 50 	sts	0x5072, r14
    253c:	f0 92 73 50 	sts	0x5073, r15
	ADC_Sampling_Finished = 0;
    2540:	10 92 d5 50 	sts	0x50D5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2544:	81 e0       	ldi	r24, 0x01	; 1
    2546:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    254a:	8c 2f       	mov	r24, r28
    254c:	6d 2f       	mov	r22, r29
    254e:	0e 94 76 03 	call	0x6ec	; 0x6ec <set_ampGain>
	set_filter(filterConfig);
    2552:	8d 2d       	mov	r24, r13
    2554:	0e 94 af 03 	call	0x75e	; 0x75e <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    2558:	8c 2f       	mov	r24, r28
    255a:	85 50       	subi	r24, 0x05	; 5
    255c:	83 30       	cpi	r24, 0x03	; 3
    255e:	18 f4       	brcc	.+6      	; 0x2566 <CO_collectADC_ext+0x4e>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	0e 94 85 08 	call	0x110a	; 0x110a <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2566:	81 e0       	ldi	r24, 0x01	; 1
    2568:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <enableADCMUX>
	setADCInput(channel);
    256c:	8c 2f       	mov	r24, r28
    256e:	0e 94 30 10 	call	0x2060	; 0x2060 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2572:	84 e0       	ldi	r24, 0x04	; 4
    2574:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2578:	84 e5       	ldi	r24, 0x54	; 84
    257a:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    257e:	e0 ea       	ldi	r30, 0xA0	; 160
    2580:	f6 e0       	ldi	r31, 0x06	; 6
    2582:	dd 24       	eor	r13, r13
    2584:	d3 94       	inc	r13
    2586:	d2 82       	std	Z+2, r13	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2588:	82 e0       	ldi	r24, 0x02	; 2
    258a:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    258c:	d2 86       	std	Z+10, r13	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    258e:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2590:	80 e2       	ldi	r24, 0x20	; 32
    2592:	e0 e8       	ldi	r30, 0x80	; 128
    2594:	f6 e0       	ldi	r31, 0x06	; 6
    2596:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2598:	c0 e4       	ldi	r28, 0x40	; 64
    259a:	da e0       	ldi	r29, 0x0A	; 10
    259c:	83 e2       	ldi	r24, 0x23	; 35
    259e:	89 83       	std	Y+1, r24	; 0x01
	// set period
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    25a0:	95 01       	movw	r18, r10
    25a2:	40 e0       	ldi	r20, 0x00	; 0
    25a4:	50 e0       	ldi	r21, 0x00	; 0
    25a6:	60 e8       	ldi	r22, 0x80	; 128
    25a8:	74 e8       	ldi	r23, 0x84	; 132
    25aa:	8e e1       	ldi	r24, 0x1E	; 30
    25ac:	90 e0       	ldi	r25, 0x00	; 0
    25ae:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    25b2:	89 01       	movw	r16, r18
    25b4:	9a 01       	movw	r18, r20
    25b6:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    25b8:	0e a3       	lds	r16, 0x5e
    25ba:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    25bc:	96 95       	lsr	r25
    25be:	87 95       	ror	r24
    25c0:	8a af       	sts	0x7a, r24
    25c2:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    25c4:	e0 e4       	ldi	r30, 0x40	; 64
    25c6:	f8 e0       	ldi	r31, 0x08	; 8
    25c8:	86 a2       	lds	r24, 0x96
    25ca:	97 a2       	lds	r25, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    25cc:	88 e7       	ldi	r24, 0x78	; 120
    25ce:	a0 e8       	ldi	r26, 0x80	; 128
    25d0:	b1 e0       	ldi	r27, 0x01	; 1
    25d2:	11 96       	adiw	r26, 0x01	; 1
    25d4:	8c 93       	st	X, r24
    25d6:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    25d8:	d6 82       	std	Z+6, r13	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    25da:	88 81       	ld	r24, Y
    25dc:	80 7f       	andi	r24, 0xF0	; 240
    25de:	81 60       	ori	r24, 0x01	; 1
    25e0:	88 83       	st	Y, r24
	
	sampleCount = 0;
    25e2:	10 92 74 50 	sts	0x5074, r1
    25e6:	10 92 75 50 	sts	0x5075, r1
    25ea:	10 92 76 50 	sts	0x5076, r1
    25ee:	10 92 77 50 	sts	0x5077, r1
	discardCount = 0;
    25f2:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    25f6:	e0 ea       	ldi	r30, 0xA0	; 160
    25f8:	f0 e0       	ldi	r31, 0x00	; 0
    25fa:	82 81       	ldd	r24, Z+2	; 0x02
    25fc:	81 60       	ori	r24, 0x01	; 1
    25fe:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2600:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2602:	df 91       	pop	r29
    2604:	cf 91       	pop	r28
    2606:	1f 91       	pop	r17
    2608:	0f 91       	pop	r16
    260a:	ff 90       	pop	r15
    260c:	ef 90       	pop	r14
    260e:	df 90       	pop	r13
    2610:	bf 90       	pop	r11
    2612:	af 90       	pop	r10
    2614:	9f 90       	pop	r9
    2616:	8f 90       	pop	r8
    2618:	08 95       	ret

0000261a <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    261a:	ef 92       	push	r14
    261c:	ff 92       	push	r15
    261e:	0f 93       	push	r16
    2620:	1f 93       	push	r17
    2622:	96 2f       	mov	r25, r22
    2624:	fa 01       	movw	r30, r20
    2626:	d9 01       	movw	r26, r18
    2628:	78 01       	movw	r14, r16
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    262a:	64 ec       	ldi	r22, 0xC4	; 196
    262c:	49 2f       	mov	r20, r25
    262e:	9f 01       	movw	r18, r30
    2630:	8d 01       	movw	r16, r26
    2632:	0e 94 8c 12 	call	0x2518	; 0x2518 <CO_collectADC_ext>
}
    2636:	1f 91       	pop	r17
    2638:	0f 91       	pop	r16
    263a:	ff 90       	pop	r15
    263c:	ef 90       	pop	r14
    263e:	08 95       	ret

00002640 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2640:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2642:	81 e0       	ldi	r24, 0x01	; 1
    2644:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2646:	84 81       	ldd	r24, Z+4	; 0x04
    2648:	95 81       	ldd	r25, Z+5	; 0x05
    264a:	86 1b       	sub	r24, r22
    264c:	91 09       	sbc	r25, r1

	return answer;
}
    264e:	08 95       	ret

00002650 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2650:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2652:	81 e0       	ldi	r24, 0x01	; 1
    2654:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2656:	84 81       	ldd	r24, Z+4	; 0x04
    2658:	95 81       	ldd	r25, Z+5	; 0x05
    265a:	77 27       	eor	r23, r23
    265c:	67 fd       	sbrc	r22, 7
    265e:	70 95       	com	r23
    2660:	86 1b       	sub	r24, r22
    2662:	97 0b       	sbc	r25, r23

	return answer;
}
    2664:	08 95       	ret

00002666 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2666:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2668:	81 e0       	ldi	r24, 0x01	; 1
    266a:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    266c:	84 81       	ldd	r24, Z+4	; 0x04
    266e:	95 81       	ldd	r25, Z+5	; 0x05
}
    2670:	08 95       	ret

00002672 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2672:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2674:	81 e0       	ldi	r24, 0x01	; 1
    2676:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2678:	84 81       	ldd	r24, Z+4	; 0x04
}
    267a:	08 95       	ret

0000267c <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    267c:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2682:	85 81       	ldd	r24, Z+5	; 0x05
}
    2684:	08 95       	ret

00002686 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2686:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2688:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    268a:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    268c:	9a e2       	ldi	r25, 0x2A	; 42
    268e:	9a 95       	dec	r25
    2690:	f1 f7       	brne	.-4      	; 0x268e <ADC_Wait_8MHz+0x8>
    2692:	00 c0       	rjmp	.+0      	; 0x2694 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2694:	84 83       	std	Z+4, r24	; 0x04
}
    2696:	08 95       	ret

00002698 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2698:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    269a:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    269c:	91 e0       	ldi	r25, 0x01	; 1
    269e:	94 83       	std	Z+4, r25	; 0x04
    26a0:	95 e5       	ldi	r25, 0x55	; 85
    26a2:	9a 95       	dec	r25
    26a4:	f1 f7       	brne	.-4      	; 0x26a2 <ADC_Wait_32MHz+0xa>
    26a6:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    26a8:	84 83       	std	Z+4, r24	; 0x04
}
    26aa:	08 95       	ret

000026ac <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    26ac:	ef 92       	push	r14
    26ae:	ff 92       	push	r15
    26b0:	0f 93       	push	r16
    26b2:	1f 93       	push	r17
    26b4:	cf 93       	push	r28
    26b6:	df 93       	push	r29
    26b8:	eb 01       	movw	r28, r22
    if (oversampling)
    26ba:	44 23       	and	r20, r20
    26bc:	c9 f0       	breq	.+50     	; 0x26f0 <ADC_Offset_Get_Unsigned+0x44>
    26be:	04 e0       	ldi	r16, 0x04	; 4
    26c0:	10 e0       	ldi	r17, 0x00	; 0
    26c2:	ee 24       	eor	r14, r14
    26c4:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    26c6:	88 81       	ld	r24, Y
    26c8:	80 68       	ori	r24, 0x80	; 128
    26ca:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    26cc:	8b 81       	ldd	r24, Y+3	; 0x03
    26ce:	80 ff       	sbrs	r24, 0
    26d0:	fd cf       	rjmp	.-6      	; 0x26cc <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    26d2:	ce 01       	movw	r24, r28
    26d4:	60 e0       	ldi	r22, 0x00	; 0
    26d6:	0e 94 20 13 	call	0x2640	; 0x2640 <ADC_ResultCh_GetWord_Unsigned>
    26da:	e8 0e       	add	r14, r24
    26dc:	f9 1e       	adc	r15, r25
    26de:	01 50       	subi	r16, 0x01	; 1
    26e0:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    26e2:	89 f7       	brne	.-30     	; 0x26c6 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    26e4:	c7 01       	movw	r24, r14
    26e6:	96 95       	lsr	r25
    26e8:	87 95       	ror	r24
    26ea:	96 95       	lsr	r25
    26ec:	87 95       	ror	r24
    26ee:	09 c0       	rjmp	.+18     	; 0x2702 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    26f0:	88 81       	ld	r24, Y
    26f2:	80 68       	ori	r24, 0x80	; 128
    26f4:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    26f6:	8b 81       	ldd	r24, Y+3	; 0x03
    26f8:	80 ff       	sbrs	r24, 0
    26fa:	fd cf       	rjmp	.-6      	; 0x26f6 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    26fc:	ce 01       	movw	r24, r28
    26fe:	0e 94 33 13 	call	0x2666	; 0x2666 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    2702:	df 91       	pop	r29
    2704:	cf 91       	pop	r28
    2706:	1f 91       	pop	r17
    2708:	0f 91       	pop	r16
    270a:	ff 90       	pop	r15
    270c:	ef 90       	pop	r14
    270e:	08 95       	ret

00002710 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2710:	ef 92       	push	r14
    2712:	ff 92       	push	r15
    2714:	0f 93       	push	r16
    2716:	1f 93       	push	r17
    2718:	cf 93       	push	r28
    271a:	df 93       	push	r29
    271c:	eb 01       	movw	r28, r22
    if (oversampling)
    271e:	44 23       	and	r20, r20
    2720:	e1 f0       	breq	.+56     	; 0x275a <ADC_Offset_Get_Signed+0x4a>
    2722:	04 e0       	ldi	r16, 0x04	; 4
    2724:	10 e0       	ldi	r17, 0x00	; 0
    2726:	ee 24       	eor	r14, r14
    2728:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    272a:	88 81       	ld	r24, Y
    272c:	80 68       	ori	r24, 0x80	; 128
    272e:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2730:	8b 81       	ldd	r24, Y+3	; 0x03
    2732:	80 ff       	sbrs	r24, 0
    2734:	fd cf       	rjmp	.-6      	; 0x2730 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2736:	ce 01       	movw	r24, r28
    2738:	60 e0       	ldi	r22, 0x00	; 0
    273a:	0e 94 28 13 	call	0x2650	; 0x2650 <ADC_ResultCh_GetWord_Signed>
    273e:	e8 0e       	add	r14, r24
    2740:	f9 1e       	adc	r15, r25
    2742:	01 50       	subi	r16, 0x01	; 1
    2744:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2746:	89 f7       	brne	.-30     	; 0x272a <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    2748:	c7 01       	movw	r24, r14
    274a:	99 23       	and	r25, r25
    274c:	0c f4       	brge	.+2      	; 0x2750 <ADC_Offset_Get_Signed+0x40>
    274e:	03 96       	adiw	r24, 0x03	; 3
    2750:	95 95       	asr	r25
    2752:	87 95       	ror	r24
    2754:	95 95       	asr	r25
    2756:	87 95       	ror	r24
    2758:	0a c0       	rjmp	.+20     	; 0x276e <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    275a:	88 81       	ld	r24, Y
    275c:	80 68       	ori	r24, 0x80	; 128
    275e:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2760:	8b 81       	ldd	r24, Y+3	; 0x03
    2762:	80 ff       	sbrs	r24, 0
    2764:	fd cf       	rjmp	.-6      	; 0x2760 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2766:	ce 01       	movw	r24, r28
    2768:	60 e0       	ldi	r22, 0x00	; 0
    276a:	0e 94 28 13 	call	0x2650	; 0x2650 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    276e:	df 91       	pop	r29
    2770:	cf 91       	pop	r28
    2772:	1f 91       	pop	r17
    2774:	0f 91       	pop	r16
    2776:	ff 90       	pop	r15
    2778:	ef 90       	pop	r14
    277a:	08 95       	ret

0000277c <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    277c:	aa ec       	ldi	r26, 0xCA	; 202
    277e:	b1 e0       	ldi	r27, 0x01	; 1
    2780:	92 e0       	ldi	r25, 0x02	; 2
    2782:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    2784:	e8 2f       	mov	r30, r24
    2786:	f0 e0       	ldi	r31, 0x00	; 0
    2788:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    278a:	1c 92       	st	X, r1

	return result;
}
    278c:	08 95       	ret

0000278e <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    278e:	cf 93       	push	r28
    2790:	df 93       	push	r29
    2792:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    2794:	82 e0       	ldi	r24, 0x02	; 2
    2796:	c0 30       	cpi	r28, 0x00	; 0
    2798:	d8 07       	cpc	r29, r24
    279a:	59 f4       	brne	.+22     	; 0x27b2 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    279c:	80 e2       	ldi	r24, 0x20	; 32
    279e:	0e 94 be 13 	call	0x277c	; 0x277c <SP_ReadCalibrationByte>
    27a2:	c0 e0       	ldi	r28, 0x00	; 0
    27a4:	d2 e0       	ldi	r29, 0x02	; 2
    27a6:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    27a8:	81 e2       	ldi	r24, 0x21	; 33
    27aa:	0e 94 be 13 	call	0x277c	; 0x277c <SP_ReadCalibrationByte>
    27ae:	8d 87       	std	Y+13, r24	; 0x0d
    27b0:	08 c0       	rjmp	.+16     	; 0x27c2 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    27b2:	84 e2       	ldi	r24, 0x24	; 36
    27b4:	0e 94 be 13 	call	0x277c	; 0x277c <SP_ReadCalibrationByte>
    27b8:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    27ba:	85 e2       	ldi	r24, 0x25	; 37
    27bc:	0e 94 be 13 	call	0x277c	; 0x277c <SP_ReadCalibrationByte>
    27c0:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    27c2:	df 91       	pop	r29
    27c4:	cf 91       	pop	r28
    27c6:	08 95       	ret

000027c8 <radio_msg_received_int_enable>:
	radio_msg_received_int_enable();
}

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    27c8:	e0 e8       	ldi	r30, 0x80	; 128
    27ca:	f6 e0       	ldi	r31, 0x06	; 6
    27cc:	84 e0       	ldi	r24, 0x04	; 4
    27ce:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    27d0:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    27d2:	92 e0       	ldi	r25, 0x02	; 2
    27d4:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    27d6:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    27d8:	83 e0       	ldi	r24, 0x03	; 3
    27da:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    27dc:	e0 ea       	ldi	r30, 0xA0	; 160
    27de:	f0 e0       	ldi	r31, 0x00	; 0
    27e0:	82 81       	ldd	r24, Z+2	; 0x02
    27e2:	84 60       	ori	r24, 0x04	; 4
    27e4:	82 83       	std	Z+2, r24	; 0x02
	sei();
    27e6:	78 94       	sei
}
    27e8:	08 95       	ret

000027ea <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    27ea:	84 e1       	ldi	r24, 0x14	; 20
    27ec:	ee e3       	ldi	r30, 0x3E	; 62
    27ee:	f1 e2       	ldi	r31, 0x21	; 33
    27f0:	df 01       	movw	r26, r30
    27f2:	1d 92       	st	X+, r1
    27f4:	8a 95       	dec	r24
    27f6:	e9 f7       	brne	.-6      	; 0x27f2 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    27f8:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <chb_get_short_addr>
    27fc:	80 93 3e 21 	sts	0x213E, r24
    2800:	90 93 3f 21 	sts	0x213F, r25
    chb_drvr_init();
    2804:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <chb_drvr_init>
	radio_msg_received_int_enable();
    2808:	0e 94 e4 13 	call	0x27c8	; 0x27c8 <radio_msg_received_int_enable>
}
    280c:	08 95       	ret

0000280e <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    280e:	8e e3       	ldi	r24, 0x3E	; 62
    2810:	91 e2       	ldi	r25, 0x21	; 33
    2812:	08 95       	ret

00002814 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    2814:	2f 92       	push	r2
    2816:	3f 92       	push	r3
    2818:	4f 92       	push	r4
    281a:	5f 92       	push	r5
    281c:	6f 92       	push	r6
    281e:	7f 92       	push	r7
    2820:	8f 92       	push	r8
    2822:	9f 92       	push	r9
    2824:	af 92       	push	r10
    2826:	bf 92       	push	r11
    2828:	cf 92       	push	r12
    282a:	df 92       	push	r13
    282c:	ef 92       	push	r14
    282e:	ff 92       	push	r15
    2830:	0f 93       	push	r16
    2832:	1f 93       	push	r17
    2834:	cf 93       	push	r28
    2836:	df 93       	push	r29
    2838:	cd b7       	in	r28, 0x3d	; 61
    283a:	de b7       	in	r29, 0x3e	; 62
    283c:	2e 97       	sbiw	r28, 0x0e	; 14
    283e:	cd bf       	out	0x3d, r28	; 61
    2840:	de bf       	out	0x3e, r29	; 62
    2842:	8b 87       	std	Y+11, r24	; 0x0b
    2844:	9c 87       	std	Y+12, r25	; 0x0c
    2846:	6d 87       	std	Y+13, r22	; 0x0d
    2848:	7e 87       	std	Y+14, r23	; 0x0e
    284a:	49 01       	movw	r8, r18
    284c:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    284e:	21 15       	cp	r18, r1
    2850:	31 05       	cpc	r19, r1
    2852:	41 05       	cpc	r20, r1
    2854:	51 05       	cpc	r21, r1
    2856:	09 f4       	brne	.+2      	; 0x285a <chb_write+0x46>
    2858:	88 c0       	rjmp	.+272    	; 0x296a <chb_write+0x156>
{
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    285a:	ee 24       	eor	r14, r14
                 pcb.txd_noack++;
				 rtry++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    285c:	0f 2e       	mov	r0, r31
    285e:	f9 e4       	ldi	r31, 0x49	; 73
    2860:	6f 2e       	mov	r6, r31
    2862:	f1 e2       	ldi	r31, 0x21	; 33
    2864:	7f 2e       	mov	r7, r31
    2866:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2868:	0f 2e       	mov	r0, r31
    286a:	f5 e4       	ldi	r31, 0x45	; 69
    286c:	4f 2e       	mov	r4, r31
    286e:	f1 e2       	ldi	r31, 0x21	; 33
    2870:	5f 2e       	mov	r5, r31
    2872:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2874:	0f 2e       	mov	r0, r31
    2876:	f7 e4       	ldi	r31, 0x47	; 71
    2878:	2f 2e       	mov	r2, r31
    287a:	f1 e2       	ldi	r31, 0x21	; 33
    287c:	3f 2e       	mov	r3, r31
    287e:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    2880:	f8 2c       	mov	r15, r8
    2882:	25 e6       	ldi	r18, 0x65	; 101
    2884:	82 16       	cp	r8, r18
    2886:	91 04       	cpc	r9, r1
    2888:	a1 04       	cpc	r10, r1
    288a:	b1 04       	cpc	r11, r1
    288c:	20 f0       	brcs	.+8      	; 0x2896 <chb_write+0x82>
    288e:	0f 2e       	mov	r0, r31
    2890:	f4 e6       	ldi	r31, 0x64	; 100
    2892:	ff 2e       	mov	r15, r31
    2894:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    2896:	8f 2d       	mov	r24, r15
    2898:	85 5f       	subi	r24, 0xF5	; 245
    289a:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    289c:	8b 85       	ldd	r24, Y+11	; 0x0b
    289e:	9c 85       	ldd	r25, Y+12	; 0x0c
    28a0:	ef ef       	ldi	r30, 0xFF	; 255
    28a2:	8f 3f       	cpi	r24, 0xFF	; 255
    28a4:	9e 07       	cpc	r25, r30
    28a6:	11 f0       	breq	.+4      	; 0x28ac <chb_write+0x98>
    28a8:	81 e6       	ldi	r24, 0x61	; 97
    28aa:	01 c0       	rjmp	.+2      	; 0x28ae <chb_write+0x9a>
    28ac:	81 e4       	ldi	r24, 0x41	; 65
    28ae:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    28b0:	88 e9       	ldi	r24, 0x98	; 152
    28b2:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
    28b4:	e0 e4       	ldi	r30, 0x40	; 64
    28b6:	f1 e2       	ldi	r31, 0x21	; 33
    28b8:	80 81       	ld	r24, Z
    28ba:	8c 83       	std	Y+4, r24	; 0x04
    28bc:	8f 5f       	subi	r24, 0xFF	; 255
    28be:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    28c0:	84 e3       	ldi	r24, 0x34	; 52
    28c2:	92 e1       	ldi	r25, 0x12	; 18
    28c4:	8d 83       	std	Y+5, r24	; 0x05
    28c6:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    28c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    28ca:	9c 85       	ldd	r25, Y+12	; 0x0c
    28cc:	8f 83       	std	Y+7, r24	; 0x07
    28ce:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    28d0:	32 97       	sbiw	r30, 0x02	; 2
    28d2:	80 81       	ld	r24, Z
    28d4:	91 81       	ldd	r25, Z+1	; 0x01
    28d6:	89 87       	std	Y+9, r24	; 0x09
    28d8:	9a 87       	std	Y+10, r25	; 0x0a
        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
    28da:	00 e0       	ldi	r16, 0x00	; 0
    28dc:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    28de:	cd 84       	ldd	r12, Y+13	; 0x0d
    28e0:	de 84       	ldd	r13, Y+14	; 0x0e
    28e2:	ce 0c       	add	r12, r14
    28e4:	d1 1c       	adc	r13, r1
    28e6:	ce 01       	movw	r24, r28
    28e8:	01 96       	adiw	r24, 0x01	; 1
    28ea:	b6 01       	movw	r22, r12
    28ec:	4f 2d       	mov	r20, r15
    28ee:	0e 94 f8 16 	call	0x2df0	; 0x2df0 <chb_tx>
    28f2:	28 2f       	mov	r18, r24

             switch (status)
    28f4:	83 30       	cpi	r24, 0x03	; 3
    28f6:	c9 f0       	breq	.+50     	; 0x292a <chb_write+0x116>
    28f8:	84 30       	cpi	r24, 0x04	; 4
    28fa:	18 f4       	brcc	.+6      	; 0x2902 <chb_write+0xee>
    28fc:	81 30       	cpi	r24, 0x01	; 1
    28fe:	e9 f4       	brne	.+58     	; 0x293a <chb_write+0x126>
    2900:	04 c0       	rjmp	.+8      	; 0x290a <chb_write+0xf6>
    2902:	85 30       	cpi	r24, 0x05	; 5
    2904:	49 f0       	breq	.+18     	; 0x2918 <chb_write+0x104>
    2906:	80 34       	cpi	r24, 0x40	; 64
    2908:	c1 f4       	brne	.+48     	; 0x293a <chb_write+0x126>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    290a:	f2 01       	movw	r30, r4
    290c:	80 81       	ld	r24, Z
    290e:	91 81       	ldd	r25, Z+1	; 0x01
    2910:	01 96       	adiw	r24, 0x01	; 1
    2912:	80 83       	st	Z, r24
    2914:	91 83       	std	Z+1, r25	; 0x01
                 break;
    2916:	11 c0       	rjmp	.+34     	; 0x293a <chb_write+0x126>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2918:	f1 01       	movw	r30, r2
    291a:	80 81       	ld	r24, Z
    291c:	91 81       	ldd	r25, Z+1	; 0x01
    291e:	01 96       	adiw	r24, 0x01	; 1
    2920:	80 83       	st	Z, r24
    2922:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2924:	0f 5f       	subi	r16, 0xFF	; 255
    2926:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
    2928:	08 c0       	rjmp	.+16     	; 0x293a <chb_write+0x126>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    292a:	f3 01       	movw	r30, r6
    292c:	80 81       	ld	r24, Z
    292e:	91 81       	ldd	r25, Z+1	; 0x01
    2930:	01 96       	adiw	r24, 0x01	; 1
    2932:	80 83       	st	Z, r24
    2934:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2936:	0f 5f       	subi	r16, 0xFF	; 255
    2938:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
 
             default:
                 break;
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    293a:	10 16       	cp	r1, r16
    293c:	11 06       	cpc	r1, r17
    293e:	24 f4       	brge	.+8      	; 0x2948 <chb_write+0x134>
    2940:	fa e6       	ldi	r31, 0x6A	; 106
    2942:	fa 95       	dec	r31
    2944:	f1 f7       	brne	.-4      	; 0x2942 <chb_write+0x12e>
    2946:	00 c0       	rjmp	.+0      	; 0x2948 <chb_write+0x134>
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    2948:	04 31       	cpi	r16, 0x14	; 20
    294a:	11 05       	cpc	r17, r1
    294c:	79 f0       	breq	.+30     	; 0x296c <chb_write+0x158>
		} while(status != CHB_SUCCESS);			
    294e:	22 23       	and	r18, r18
    2950:	51 f6       	brne	.-108    	; 0x28e6 <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
    2952:	ef 0c       	add	r14, r15
        len = len - frm_len;
    2954:	8f 18       	sub	r8, r15
    2956:	91 08       	sbc	r9, r1
    2958:	a1 08       	sbc	r10, r1
    295a:	b1 08       	sbc	r11, r1
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    295c:	81 14       	cp	r8, r1
    295e:	91 04       	cpc	r9, r1
    2960:	a1 04       	cpc	r10, r1
    2962:	b1 04       	cpc	r11, r1
    2964:	09 f0       	breq	.+2      	; 0x2968 <chb_write+0x154>
    2966:	8c cf       	rjmp	.-232    	; 0x2880 <chb_write+0x6c>
    2968:	01 c0       	rjmp	.+2      	; 0x296c <chb_write+0x158>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    296a:	20 e0       	ldi	r18, 0x00	; 0
}
    296c:	82 2f       	mov	r24, r18
    296e:	2e 96       	adiw	r28, 0x0e	; 14
    2970:	cd bf       	out	0x3d, r28	; 61
    2972:	de bf       	out	0x3e, r29	; 62
    2974:	df 91       	pop	r29
    2976:	cf 91       	pop	r28
    2978:	1f 91       	pop	r17
    297a:	0f 91       	pop	r16
    297c:	ff 90       	pop	r15
    297e:	ef 90       	pop	r14
    2980:	df 90       	pop	r13
    2982:	cf 90       	pop	r12
    2984:	bf 90       	pop	r11
    2986:	af 90       	pop	r10
    2988:	9f 90       	pop	r9
    298a:	8f 90       	pop	r8
    298c:	7f 90       	pop	r7
    298e:	6f 90       	pop	r6
    2990:	5f 90       	pop	r5
    2992:	4f 90       	pop	r4
    2994:	3f 90       	pop	r3
    2996:	2f 90       	pop	r2
    2998:	08 95       	ret

0000299a <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    299a:	df 92       	push	r13
    299c:	ef 92       	push	r14
    299e:	ff 92       	push	r15
    29a0:	0f 93       	push	r16
    29a2:	1f 93       	push	r17
    29a4:	cf 93       	push	r28
    29a6:	df 93       	push	r29
    29a8:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    29aa:	0e 94 48 15 	call	0x2a90	; 0x2a90 <chb_buf_read>
    29ae:	d8 2e       	mov	r13, r24
    29b0:	88 23       	and	r24, r24
    29b2:	0c f4       	brge	.+2      	; 0x29b6 <chb_read+0x1c>
    29b4:	46 c0       	rjmp	.+140    	; 0x2a42 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    29b6:	f7 01       	movw	r30, r14
    29b8:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    29ba:	88 23       	and	r24, r24
    29bc:	71 f0       	breq	.+28     	; 0x29da <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    29be:	e7 01       	movw	r28, r14
    29c0:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    29c2:	87 01       	movw	r16, r14
    29c4:	09 5f       	subi	r16, 0xF9	; 249
    29c6:	1f 4f       	sbci	r17, 0xFF	; 255
    29c8:	81 50       	subi	r24, 0x01	; 1
    29ca:	08 0f       	add	r16, r24
    29cc:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    29ce:	0e 94 48 15 	call	0x2a90	; 0x2a90 <chb_buf_read>
    29d2:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    29d4:	c0 17       	cp	r28, r16
    29d6:	d1 07       	cpc	r29, r17
    29d8:	d1 f7       	brne	.-12     	; 0x29ce <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    29da:	f7 01       	movw	r30, r14
    29dc:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    29de:	83 85       	ldd	r24, Z+11	; 0x0b
    29e0:	94 85       	ldd	r25, Z+12	; 0x0c
    29e2:	83 83       	std	Z+3, r24	; 0x03
    29e4:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    29e6:	85 85       	ldd	r24, Z+13	; 0x0d
    29e8:	96 85       	ldd	r25, Z+14	; 0x0e
    29ea:	81 83       	std	Z+1, r24	; 0x01
    29ec:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    29ee:	0e 94 5f 15 	call	0x2abe	; 0x2abe <chb_buf_get_len>
    29f2:	88 23       	and	r24, r24
    29f4:	11 f4       	brne	.+4      	; 0x29fa <chb_read+0x60>
    {
        pcb.data_rcv = false;
    29f6:	10 92 41 21 	sts	0x2141, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    29fa:	80 91 13 20 	lds	r24, 0x2013
    29fe:	c8 17       	cp	r28, r24
    2a00:	51 f4       	brne	.+20     	; 0x2a16 <chb_read+0x7c>
    2a02:	f7 01       	movw	r30, r14
    2a04:	21 81       	ldd	r18, Z+1	; 0x01
    2a06:	32 81       	ldd	r19, Z+2	; 0x02
    2a08:	80 91 14 20 	lds	r24, 0x2014
    2a0c:	90 91 15 20 	lds	r25, 0x2015
    2a10:	28 17       	cp	r18, r24
    2a12:	39 07       	cpc	r19, r25
    2a14:	c1 f0       	breq	.+48     	; 0x2a46 <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    2a16:	c0 93 13 20 	sts	0x2013, r28
        prev_src_addr = rx->src_addr;
    2a1a:	f7 01       	movw	r30, r14
    2a1c:	81 81       	ldd	r24, Z+1	; 0x01
    2a1e:	92 81       	ldd	r25, Z+2	; 0x02
    2a20:	80 93 14 20 	sts	0x2014, r24
    2a24:	90 93 15 20 	sts	0x2015, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    2a28:	b7 01       	movw	r22, r14
    2a2a:	61 5f       	subi	r22, 0xF1	; 241
    2a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a2e:	4d 2d       	mov	r20, r13
    2a30:	50 e0       	ldi	r21, 0x00	; 0
    2a32:	49 50       	subi	r20, 0x09	; 9
    2a34:	50 40       	sbci	r21, 0x00	; 0
    2a36:	c7 01       	movw	r24, r14
    2a38:	0e 94 83 38 	call	0x7106	; 0x7106 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2a3c:	8d 2d       	mov	r24, r13
    2a3e:	8b 50       	subi	r24, 0x0B	; 11
    2a40:	03 c0       	rjmp	.+6      	; 0x2a48 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2a42:	80 e0       	ldi	r24, 0x00	; 0
    2a44:	01 c0       	rjmp	.+2      	; 0x2a48 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    2a46:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    2a48:	df 91       	pop	r29
    2a4a:	cf 91       	pop	r28
    2a4c:	1f 91       	pop	r17
    2a4e:	0f 91       	pop	r16
    2a50:	ff 90       	pop	r15
    2a52:	ef 90       	pop	r14
    2a54:	df 90       	pop	r13
    2a56:	08 95       	ret

00002a58 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    2a58:	10 92 52 21 	sts	0x2152, r1
    wr_ptr = 0;
    2a5c:	10 92 53 21 	sts	0x2153, r1
    len = 0;
    2a60:	10 92 54 21 	sts	0x2154, r1
}
    2a64:	08 95       	ret

00002a66 <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    2a66:	20 91 53 21 	lds	r18, 0x2153
    2a6a:	30 e0       	ldi	r19, 0x00	; 0
    2a6c:	f9 01       	movw	r30, r18
    2a6e:	eb 5a       	subi	r30, 0xAB	; 171
    2a70:	fe 4d       	sbci	r31, 0xDE	; 222
    2a72:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2a74:	c9 01       	movw	r24, r18
    2a76:	01 96       	adiw	r24, 0x01	; 1
    2a78:	60 e8       	ldi	r22, 0x80	; 128
    2a7a:	70 e0       	ldi	r23, 0x00	; 0
    2a7c:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    2a80:	80 93 53 21 	sts	0x2153, r24
    len++;
    2a84:	80 91 54 21 	lds	r24, 0x2154
    2a88:	8f 5f       	subi	r24, 0xFF	; 255
    2a8a:	80 93 54 21 	sts	0x2154, r24
}
    2a8e:	08 95       	ret

00002a90 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    2a90:	20 91 52 21 	lds	r18, 0x2152
    2a94:	30 e0       	ldi	r19, 0x00	; 0
    2a96:	f9 01       	movw	r30, r18
    2a98:	eb 5a       	subi	r30, 0xAB	; 171
    2a9a:	fe 4d       	sbci	r31, 0xDE	; 222
    2a9c:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    2a9e:	2f 5f       	subi	r18, 0xFF	; 255
    2aa0:	3f 4f       	sbci	r19, 0xFF	; 255
    2aa2:	c9 01       	movw	r24, r18
    2aa4:	60 e8       	ldi	r22, 0x80	; 128
    2aa6:	70 e0       	ldi	r23, 0x00	; 0
    2aa8:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    2aac:	80 93 52 21 	sts	0x2152, r24
    len--;
    2ab0:	80 91 54 21 	lds	r24, 0x2154
    2ab4:	81 50       	subi	r24, 0x01	; 1
    2ab6:	80 93 54 21 	sts	0x2154, r24
    return data;
}
    2aba:	84 2f       	mov	r24, r20
    2abc:	08 95       	ret

00002abe <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    2abe:	80 91 54 21 	lds	r24, 0x2154
    2ac2:	08 95       	ret

00002ac4 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    2ac4:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    2ac6:	80 e0       	ldi	r24, 0x00	; 0
    2ac8:	90 e0       	ldi	r25, 0x00	; 0
    2aca:	48 e0       	ldi	r20, 0x08	; 8
    2acc:	50 e0       	ldi	r21, 0x00	; 0
    2ace:	0e 94 cb 19 	call	0x3396	; 0x3396 <chb_eeprom_read>
}
    2ad2:	08 95       	ret

00002ad4 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    2ad4:	cf 93       	push	r28
    2ad6:	df 93       	push	r29
    2ad8:	0f 92       	push	r0
    2ada:	0f 92       	push	r0
    2adc:	cd b7       	in	r28, 0x3d	; 61
    2ade:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    2ae0:	89 e0       	ldi	r24, 0x09	; 9
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	be 01       	movw	r22, r28
    2ae6:	6f 5f       	subi	r22, 0xFF	; 255
    2ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    2aea:	42 e0       	ldi	r20, 0x02	; 2
    2aec:	50 e0       	ldi	r21, 0x00	; 0
    2aee:	0e 94 cb 19 	call	0x3396	; 0x3396 <chb_eeprom_read>
    return *(U16 *)addr;
}
    2af2:	89 81       	ldd	r24, Y+1	; 0x01
    2af4:	9a 81       	ldd	r25, Y+2	; 0x02
    2af6:	0f 90       	pop	r0
    2af8:	0f 90       	pop	r0
    2afa:	df 91       	pop	r29
    2afc:	cf 91       	pop	r28
    2afe:	08 95       	ret

00002b00 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    2b00:	88 23       	and	r24, r24
    2b02:	29 f0       	breq	.+10     	; 0x2b0e <RadioCS+0xe>
    2b04:	80 e1       	ldi	r24, 0x10	; 16
    2b06:	e0 e6       	ldi	r30, 0x60	; 96
    2b08:	f6 e0       	ldi	r31, 0x06	; 6
    2b0a:	86 83       	std	Z+6, r24	; 0x06
    2b0c:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    2b0e:	80 e1       	ldi	r24, 0x10	; 16
    2b10:	e0 e6       	ldi	r30, 0x60	; 96
    2b12:	f6 e0       	ldi	r31, 0x06	; 6
    2b14:	85 83       	std	Z+5, r24	; 0x05
    2b16:	08 95       	ret

00002b18 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    2b18:	df 92       	push	r13
    2b1a:	ef 92       	push	r14
    2b1c:	ff 92       	push	r15
    2b1e:	0f 93       	push	r16
    2b20:	1f 93       	push	r17
    2b22:	cf 93       	push	r28
    2b24:	df 93       	push	r29
    2b26:	8c 01       	movw	r16, r24
    2b28:	c6 2f       	mov	r28, r22
    2b2a:	7a 01       	movw	r14, r20
    2b2c:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    2b2e:	82 2f       	mov	r24, r18
    2b30:	90 e0       	ldi	r25, 0x00	; 0
    2b32:	86 0f       	add	r24, r22
    2b34:	91 1d       	adc	r25, r1
    2b36:	80 38       	cpi	r24, 0x80	; 128
    2b38:	91 05       	cpc	r25, r1
    2b3a:	8c f5       	brge	.+98     	; 0x2b9e <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    2b3c:	8f b7       	in	r24, 0x3f	; 63
    2b3e:	80 93 56 40 	sts	0x4056, r24
    2b42:	f8 94       	cli
    RadioCS(TRUE); 
    2b44:	81 e0       	ldi	r24, 0x01	; 1
    2b46:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    2b4a:	80 e6       	ldi	r24, 0x60	; 96
    2b4c:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2b50:	cc 23       	and	r28, r28
    2b52:	79 f0       	breq	.+30     	; 0x2b72 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2b54:	c8 01       	movw	r24, r16
    2b56:	01 96       	adiw	r24, 0x01	; 1
    2b58:	c1 50       	subi	r28, 0x01	; 1
    2b5a:	9c 01       	movw	r18, r24
    2b5c:	2c 0f       	add	r18, r28
    2b5e:	31 1d       	adc	r19, r1
    2b60:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    2b62:	f8 01       	movw	r30, r16
    2b64:	81 91       	ld	r24, Z+
    2b66:	8f 01       	movw	r16, r30
    2b68:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2b6c:	0c 17       	cp	r16, r28
    2b6e:	1d 07       	cpc	r17, r29
    2b70:	c1 f7       	brne	.-16     	; 0x2b62 <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2b72:	dd 20       	and	r13, r13
    2b74:	69 f0       	breq	.+26     	; 0x2b90 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2b76:	e7 01       	movw	r28, r14
    2b78:	21 96       	adiw	r28, 0x01	; 1
    2b7a:	da 94       	dec	r13
    2b7c:	cd 0d       	add	r28, r13
    2b7e:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    2b80:	f7 01       	movw	r30, r14
    2b82:	81 91       	ld	r24, Z+
    2b84:	7f 01       	movw	r14, r30
    2b86:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2b8a:	ec 16       	cp	r14, r28
    2b8c:	fd 06       	cpc	r15, r29
    2b8e:	c1 f7       	brne	.-16     	; 0x2b80 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    2b90:	80 e0       	ldi	r24, 0x00	; 0
    2b92:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>
    CHB_LEAVE_CRIT();
    2b96:	80 91 56 40 	lds	r24, 0x4056
    2b9a:	8f bf       	out	0x3f, r24	; 63
    2b9c:	78 94       	sei
}
    2b9e:	df 91       	pop	r29
    2ba0:	cf 91       	pop	r28
    2ba2:	1f 91       	pop	r17
    2ba4:	0f 91       	pop	r16
    2ba6:	ff 90       	pop	r15
    2ba8:	ef 90       	pop	r14
    2baa:	df 90       	pop	r13
    2bac:	08 95       	ret

00002bae <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    2bae:	cf 93       	push	r28
    2bb0:	df 93       	push	r29
    2bb2:	d8 2f       	mov	r29, r24
    2bb4:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    2bb6:	8f b7       	in	r24, 0x3f	; 63
    2bb8:	80 93 56 40 	sts	0x4056, r24
    2bbc:	f8 94       	cli
    RadioCS(TRUE);
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    2bc4:	8d 2f       	mov	r24, r29
    2bc6:	80 6c       	ori	r24, 0xC0	; 192
    2bc8:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    2bcc:	8c 2f       	mov	r24, r28
    2bce:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>

    RadioCS(FALSE);
    2bd2:	80 e0       	ldi	r24, 0x00	; 0
    2bd4:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>
    CHB_LEAVE_CRIT();
    2bd8:	80 91 56 40 	lds	r24, 0x4056
    2bdc:	8f bf       	out	0x3f, r24	; 63
    2bde:	78 94       	sei
}
    2be0:	df 91       	pop	r29
    2be2:	cf 91       	pop	r28
    2be4:	08 95       	ret

00002be6 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    2be6:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    2be8:	85 e0       	ldi	r24, 0x05	; 5
    2bea:	0e 94 d7 15 	call	0x2bae	; 0x2bae <chb_reg_write>
}
    2bee:	08 95       	ret

00002bf0 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    2bf0:	0f 93       	push	r16
    2bf2:	1f 93       	push	r17
    2bf4:	cf 93       	push	r28
    2bf6:	df 93       	push	r29
    2bf8:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    2bfa:	c6 2f       	mov	r28, r22
    2bfc:	d7 2f       	mov	r29, r23
    2bfe:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    2c00:	69 91       	ld	r22, Y+
    2c02:	81 2f       	mov	r24, r17
    2c04:	80 0f       	add	r24, r16
    2c06:	0e 94 d7 15 	call	0x2bae	; 0x2bae <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    2c0a:	1f 5f       	subi	r17, 0xFF	; 255
    2c0c:	18 30       	cpi	r17, 0x08	; 8
    2c0e:	c1 f7       	brne	.-16     	; 0x2c00 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	1f 91       	pop	r17
    2c16:	0f 91       	pop	r16
    2c18:	08 95       	ret

00002c1a <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    2c1a:	cf 93       	push	r28
    2c1c:	df 93       	push	r29
    2c1e:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    2c20:	80 e0       	ldi	r24, 0x00	; 0
    2c22:	90 e0       	ldi	r25, 0x00	; 0
    2c24:	be 01       	movw	r22, r28
    2c26:	48 e0       	ldi	r20, 0x08	; 8
    2c28:	50 e0       	ldi	r21, 0x00	; 0
    2c2a:	0e 94 68 19 	call	0x32d0	; 0x32d0 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    2c2e:	84 e2       	ldi	r24, 0x24	; 36
    2c30:	be 01       	movw	r22, r28
    2c32:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <chb_reg_write64>
}
    2c36:	df 91       	pop	r29
    2c38:	cf 91       	pop	r28
    2c3a:	08 95       	ret

00002c3c <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    2c3c:	cf 93       	push	r28
    2c3e:	df 93       	push	r29
    2c40:	c8 2f       	mov	r28, r24
    2c42:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    2c44:	0e 94 d7 15 	call	0x2bae	; 0x2bae <chb_reg_write>
    2c48:	8c 2f       	mov	r24, r28
    2c4a:	8f 5f       	subi	r24, 0xFF	; 255
    2c4c:	6d 2f       	mov	r22, r29
    2c4e:	0e 94 d7 15 	call	0x2bae	; 0x2bae <chb_reg_write>
    }
}
    2c52:	df 91       	pop	r29
    2c54:	cf 91       	pop	r28
    2c56:	08 95       	ret

00002c58 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    2c58:	0f 93       	push	r16
    2c5a:	1f 93       	push	r17
    2c5c:	cf 93       	push	r28
    2c5e:	df 93       	push	r29
    2c60:	0f 92       	push	r0
    2c62:	0f 92       	push	r0
    2c64:	cd b7       	in	r28, 0x3d	; 61
    2c66:	de b7       	in	r29, 0x3e	; 62
    2c68:	89 83       	std	Y+1, r24	; 0x01
    2c6a:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    2c6c:	0e 94 07 14 	call	0x280e	; 0x280e <chb_get_pcb>
    2c70:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    2c72:	89 e0       	ldi	r24, 0x09	; 9
    2c74:	90 e0       	ldi	r25, 0x00	; 0
    2c76:	be 01       	movw	r22, r28
    2c78:	6f 5f       	subi	r22, 0xFF	; 255
    2c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c7c:	42 e0       	ldi	r20, 0x02	; 2
    2c7e:	50 e0       	ldi	r21, 0x00	; 0
    2c80:	0e 94 68 19 	call	0x32d0	; 0x32d0 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    2c84:	69 81       	ldd	r22, Y+1	; 0x01
    2c86:	7a 81       	ldd	r23, Y+2	; 0x02
    2c88:	80 e2       	ldi	r24, 0x20	; 32
    2c8a:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <chb_reg_write16>
    pcb->src_addr = addr;
    2c8e:	89 81       	ldd	r24, Y+1	; 0x01
    2c90:	9a 81       	ldd	r25, Y+2	; 0x02
    2c92:	f8 01       	movw	r30, r16
    2c94:	80 83       	st	Z, r24
    2c96:	91 83       	std	Z+1, r25	; 0x01
}
    2c98:	0f 90       	pop	r0
    2c9a:	0f 90       	pop	r0
    2c9c:	df 91       	pop	r29
    2c9e:	cf 91       	pop	r28
    2ca0:	1f 91       	pop	r17
    2ca2:	0f 91       	pop	r16
    2ca4:	08 95       	ret

00002ca6 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    2ca6:	cf 93       	push	r28
    2ca8:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    2caa:	8f b7       	in	r24, 0x3f	; 63
    2cac:	80 93 56 40 	sts	0x4056, r24
    2cb0:	f8 94       	cli
    RadioCS(TRUE);
    2cb2:	81 e0       	ldi	r24, 0x01	; 1
    2cb4:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    2cb8:	8c 2f       	mov	r24, r28
    2cba:	80 68       	ori	r24, 0x80	; 128
    2cbc:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    val = SPID_write(val);
    2cc0:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    2cc4:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    2cc6:	80 e0       	ldi	r24, 0x00	; 0
    2cc8:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>
    CHB_LEAVE_CRIT();
    2ccc:	80 91 56 40 	lds	r24, 0x4056
    2cd0:	8f bf       	out	0x3f, r24	; 63
    2cd2:	78 94       	sei

    return val;
}
    2cd4:	8c 2f       	mov	r24, r28
    2cd6:	cf 91       	pop	r28
    2cd8:	08 95       	ret

00002cda <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    2cda:	81 e0       	ldi	r24, 0x01	; 1
    2cdc:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
}
    2ce0:	8f 71       	andi	r24, 0x1F	; 31
    2ce2:	08 95       	ret

00002ce4 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    2ce4:	1f 93       	push	r17
    2ce6:	cf 93       	push	r28
    2ce8:	df 93       	push	r29
    2cea:	c8 2f       	mov	r28, r24
    2cec:	16 2f       	mov	r17, r22
    2cee:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    2cf0:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    2cf4:	6d 2f       	mov	r22, r29
    2cf6:	60 95       	com	r22
    2cf8:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    2cfa:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    2cfc:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    2cfe:	8c 2f       	mov	r24, r28
    2d00:	0e 94 d7 15 	call	0x2bae	; 0x2bae <chb_reg_write>
}
    2d04:	df 91       	pop	r29
    2d06:	cf 91       	pop	r28
    2d08:	1f 91       	pop	r17
    2d0a:	08 95       	ret

00002d0c <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    2d0c:	cf 93       	push	r28
    2d0e:	df 93       	push	r29
    2d10:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    2d12:	80 91 64 06 	lds	r24, 0x0664
    2d16:	81 fd       	sbrc	r24, 1
    2d18:	4b c0       	rjmp	.+150    	; 0x2db0 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    2d1a:	0e 94 6d 16 	call	0x2cda	; 0x2cda <chb_get_state>
    2d1e:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    2d20:	81 51       	subi	r24, 0x11	; 17
    2d22:	82 30       	cpi	r24, 0x02	; 2
    2d24:	20 f0       	brcs	.+8      	; 0x2d2e <chb_set_state+0x22>
    2d26:	c1 30       	cpi	r28, 0x01	; 1
    2d28:	11 f0       	breq	.+4      	; 0x2d2e <chb_set_state+0x22>
    2d2a:	c2 30       	cpi	r28, 0x02	; 2
    2d2c:	21 f4       	brne	.+8      	; 0x2d36 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    2d2e:	0e 94 6d 16 	call	0x2cda	; 0x2cda <chb_get_state>
    2d32:	8c 17       	cp	r24, r28
    2d34:	e1 f3       	breq	.-8      	; 0x2d2e <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    2d36:	d6 31       	cpi	r29, 0x16	; 22
    2d38:	f9 f0       	breq	.+62     	; 0x2d78 <chb_set_state+0x6c>
    2d3a:	d9 31       	cpi	r29, 0x19	; 25
    2d3c:	89 f0       	breq	.+34     	; 0x2d60 <chb_set_state+0x54>
    2d3e:	d8 30       	cpi	r29, 0x08	; 8
    2d40:	31 f5       	brne	.+76     	; 0x2d8e <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    2d42:	e4 e6       	ldi	r30, 0x64	; 100
    2d44:	f6 e0       	ldi	r31, 0x06	; 6
    2d46:	80 81       	ld	r24, Z
    2d48:	8d 7f       	andi	r24, 0xFD	; 253
    2d4a:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    2d4c:	82 e0       	ldi	r24, 0x02	; 2
    2d4e:	63 e0       	ldi	r22, 0x03	; 3
    2d50:	4f e1       	ldi	r20, 0x1F	; 31
    2d52:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
    2d56:	8a e0       	ldi	r24, 0x0A	; 10
    2d58:	8a 95       	dec	r24
    2d5a:	f1 f7       	brne	.-4      	; 0x2d58 <chb_set_state+0x4c>
    2d5c:	00 c0       	rjmp	.+0      	; 0x2d5e <chb_set_state+0x52>
    2d5e:	17 c0       	rjmp	.+46     	; 0x2d8e <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    2d60:	c6 31       	cpi	r28, 0x16	; 22
    2d62:	a9 f4       	brne	.+42     	; 0x2d8e <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    2d64:	82 e0       	ldi	r24, 0x02	; 2
    2d66:	69 e0       	ldi	r22, 0x09	; 9
    2d68:	4f e1       	ldi	r20, 0x1F	; 31
    2d6a:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
    2d6e:	9a e0       	ldi	r25, 0x0A	; 10
    2d70:	9a 95       	dec	r25
    2d72:	f1 f7       	brne	.-4      	; 0x2d70 <chb_set_state+0x64>
    2d74:	00 c0       	rjmp	.+0      	; 0x2d76 <chb_set_state+0x6a>
    2d76:	0b c0       	rjmp	.+22     	; 0x2d8e <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    2d78:	c9 31       	cpi	r28, 0x19	; 25
    2d7a:	49 f4       	brne	.+18     	; 0x2d8e <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    2d7c:	82 e0       	ldi	r24, 0x02	; 2
    2d7e:	69 e0       	ldi	r22, 0x09	; 9
    2d80:	4f e1       	ldi	r20, 0x1F	; 31
    2d82:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
    2d86:	8a e0       	ldi	r24, 0x0A	; 10
    2d88:	8a 95       	dec	r24
    2d8a:	f1 f7       	brne	.-4      	; 0x2d88 <chb_set_state+0x7c>
    2d8c:	00 c0       	rjmp	.+0      	; 0x2d8e <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    2d8e:	82 e0       	ldi	r24, 0x02	; 2
    2d90:	6d 2f       	mov	r22, r29
    2d92:	4f e1       	ldi	r20, 0x1F	; 31
    2d94:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
    2d98:	8f e6       	ldi	r24, 0x6F	; 111
    2d9a:	93 e0       	ldi	r25, 0x03	; 3
    2d9c:	01 97       	sbiw	r24, 0x01	; 1
    2d9e:	f1 f7       	brne	.-4      	; 0x2d9c <chb_set_state+0x90>
    2da0:	00 c0       	rjmp	.+0      	; 0x2da2 <chb_set_state+0x96>
    2da2:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    2da4:	0e 94 6d 16 	call	0x2cda	; 0x2cda <chb_get_state>
    2da8:	8d 17       	cp	r24, r29
    2daa:	21 f4       	brne	.+8      	; 0x2db4 <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    2dac:	80 e4       	ldi	r24, 0x40	; 64
    2dae:	03 c0       	rjmp	.+6      	; 0x2db6 <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    2db0:	84 e4       	ldi	r24, 0x44	; 68
    2db2:	01 c0       	rjmp	.+2      	; 0x2db6 <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    2db4:	83 e4       	ldi	r24, 0x43	; 67
}
    2db6:	df 91       	pop	r29
    2db8:	cf 91       	pop	r28
    2dba:	08 95       	ret

00002dbc <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    2dbc:	88 23       	and	r24, r24
    2dbe:	49 f0       	breq	.+18     	; 0x2dd2 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    2dc0:	88 e0       	ldi	r24, 0x08	; 8
    2dc2:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    2dc6:	e4 e6       	ldi	r30, 0x64	; 100
    2dc8:	f6 e0       	ldi	r31, 0x06	; 6
    2dca:	80 81       	ld	r24, Z
    2dcc:	82 60       	ori	r24, 0x02	; 2
    2dce:	80 83       	st	Z, r24
    2dd0:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    2dd2:	e4 e6       	ldi	r30, 0x64	; 100
    2dd4:	f6 e0       	ldi	r31, 0x06	; 6
    2dd6:	80 81       	ld	r24, Z
    2dd8:	8d 7f       	andi	r24, 0xFD	; 253
    2dda:	80 83       	st	Z, r24
    2ddc:	8f e7       	ldi	r24, 0x7F	; 127
    2dde:	97 e0       	ldi	r25, 0x07	; 7
    2de0:	01 97       	sbiw	r24, 0x01	; 1
    2de2:	f1 f7       	brne	.-4      	; 0x2de0 <chb_sleep+0x24>
    2de4:	00 c0       	rjmp	.+0      	; 0x2de6 <chb_sleep+0x2a>
    2de6:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    2de8:	86 e1       	ldi	r24, 0x16	; 22
    2dea:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <chb_set_state>
    2dee:	08 95       	ret

00002df0 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    2df0:	cf 92       	push	r12
    2df2:	df 92       	push	r13
    2df4:	ef 92       	push	r14
    2df6:	ff 92       	push	r15
    2df8:	0f 93       	push	r16
    2dfa:	1f 93       	push	r17
    2dfc:	cf 93       	push	r28
    2dfe:	df 93       	push	r29
    2e00:	7c 01       	movw	r14, r24
    2e02:	6b 01       	movw	r12, r22
    2e04:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    2e06:	0e 94 6d 16 	call	0x2cda	; 0x2cda <chb_get_state>
    2e0a:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    2e0c:	0e 94 07 14 	call	0x280e	; 0x280e <chb_get_pcb>
    2e10:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    2e12:	12 30       	cpi	r17, 0x02	; 2
    2e14:	f1 f0       	breq	.+60     	; 0x2e52 <chb_tx+0x62>
    2e16:	12 31       	cpi	r17, 0x12	; 18
    2e18:	f1 f0       	breq	.+60     	; 0x2e56 <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    2e1a:	88 e0       	ldi	r24, 0x08	; 8
    2e1c:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    2e20:	89 e1       	ldi	r24, 0x19	; 25
    2e22:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    2e26:	c7 01       	movw	r24, r14
    2e28:	6a e0       	ldi	r22, 0x0A	; 10
    2e2a:	a6 01       	movw	r20, r12
    2e2c:	20 2f       	mov	r18, r16
    2e2e:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    2e32:	82 e0       	ldi	r24, 0x02	; 2
    2e34:	62 e0       	ldi	r22, 0x02	; 2
    2e36:	4f e1       	ldi	r20, 0x1F	; 31
    2e38:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    2e3c:	8c 81       	ldd	r24, Y+4	; 0x04
    2e3e:	88 23       	and	r24, r24
    2e40:	e9 f3       	breq	.-6      	; 0x2e3c <chb_tx+0x4c>
    pcb->tx_end = false;
    2e42:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    2e44:	82 e0       	ldi	r24, 0x02	; 2
    2e46:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    2e4a:	82 95       	swap	r24
    2e4c:	86 95       	lsr	r24
    2e4e:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    2e50:	03 c0       	rjmp	.+6      	; 0x2e58 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    2e52:	84 e4       	ldi	r24, 0x44	; 68
    2e54:	01 c0       	rjmp	.+2      	; 0x2e58 <chb_tx+0x68>
    2e56:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    2e58:	df 91       	pop	r29
    2e5a:	cf 91       	pop	r28
    2e5c:	1f 91       	pop	r17
    2e5e:	0f 91       	pop	r16
    2e60:	ff 90       	pop	r15
    2e62:	ef 90       	pop	r14
    2e64:	df 90       	pop	r13
    2e66:	cf 90       	pop	r12
    2e68:	08 95       	ret

00002e6a <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    2e6a:	81 30       	cpi	r24, 0x01	; 1
    2e6c:	91 f0       	breq	.+36     	; 0x2e92 <chb_set_mode+0x28>
    2e6e:	81 30       	cpi	r24, 0x01	; 1
    2e70:	28 f0       	brcs	.+10     	; 0x2e7c <chb_set_mode+0x12>
    2e72:	82 30       	cpi	r24, 0x02	; 2
    2e74:	c9 f0       	breq	.+50     	; 0x2ea8 <chb_set_mode+0x3e>
    2e76:	83 30       	cpi	r24, 0x03	; 3
    2e78:	61 f5       	brne	.+88     	; 0x2ed2 <chb_set_mode+0x68>
    2e7a:	21 c0       	rjmp	.+66     	; 0x2ebe <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    2e7c:	8c e0       	ldi	r24, 0x0C	; 12
    2e7e:	68 e0       	ldi	r22, 0x08	; 8
    2e80:	4f e3       	ldi	r20, 0x3F	; 63
    2e82:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2e86:	86 e1       	ldi	r24, 0x16	; 22
    2e88:	62 e0       	ldi	r22, 0x02	; 2
    2e8a:	43 e0       	ldi	r20, 0x03	; 3
    2e8c:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
        break;
    2e90:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    2e92:	8c e0       	ldi	r24, 0x0C	; 12
    2e94:	6c e0       	ldi	r22, 0x0C	; 12
    2e96:	4f e3       	ldi	r20, 0x3F	; 63
    2e98:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2e9c:	86 e1       	ldi	r24, 0x16	; 22
    2e9e:	62 e0       	ldi	r22, 0x02	; 2
    2ea0:	43 e0       	ldi	r20, 0x03	; 3
    2ea2:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
        break;
    2ea6:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    2ea8:	8c e0       	ldi	r24, 0x0C	; 12
    2eaa:	6c e1       	ldi	r22, 0x1C	; 28
    2eac:	4f e3       	ldi	r20, 0x3F	; 63
    2eae:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2eb2:	86 e1       	ldi	r24, 0x16	; 22
    2eb4:	62 e0       	ldi	r22, 0x02	; 2
    2eb6:	43 e0       	ldi	r20, 0x03	; 3
    2eb8:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
        break;
    2ebc:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    2ebe:	8c e0       	ldi	r24, 0x0C	; 12
    2ec0:	60 e0       	ldi	r22, 0x00	; 0
    2ec2:	4f e3       	ldi	r20, 0x3F	; 63
    2ec4:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    2ec8:	86 e1       	ldi	r24, 0x16	; 22
    2eca:	63 e0       	ldi	r22, 0x03	; 3
    2ecc:	43 e0       	ldi	r20, 0x03	; 3
    2ece:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
    2ed2:	08 95       	ret

00002ed4 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    2ed4:	cf 93       	push	r28
    2ed6:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    2ed8:	88 e0       	ldi	r24, 0x08	; 8
    2eda:	6c 2f       	mov	r22, r28
    2edc:	4f e1       	ldi	r20, 0x1F	; 31
    2ede:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    2ee2:	0e 94 6d 16 	call	0x2cda	; 0x2cda <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    2ee6:	86 30       	cpi	r24, 0x06	; 6
    2ee8:	11 f0       	breq	.+4      	; 0x2eee <chb_set_channel+0x1a>
    2eea:	89 30       	cpi	r24, 0x09	; 9
    2eec:	31 f4       	brne	.+12     	; 0x2efa <chb_set_channel+0x26>
    2eee:	8f e6       	ldi	r24, 0x6F	; 111
    2ef0:	93 e0       	ldi	r25, 0x03	; 3
    2ef2:	01 97       	sbiw	r24, 0x01	; 1
    2ef4:	f1 f7       	brne	.-4      	; 0x2ef2 <chb_set_channel+0x1e>
    2ef6:	00 c0       	rjmp	.+0      	; 0x2ef8 <chb_set_channel+0x24>
    2ef8:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    2efa:	88 e0       	ldi	r24, 0x08	; 8
    2efc:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    2f00:	90 e0       	ldi	r25, 0x00	; 0
    2f02:	8f 71       	andi	r24, 0x1F	; 31
    2f04:	90 70       	andi	r25, 0x00	; 0
    2f06:	6c 2f       	mov	r22, r28
    2f08:	70 e0       	ldi	r23, 0x00	; 0
    2f0a:	86 17       	cp	r24, r22
    2f0c:	97 07       	cpc	r25, r23
    2f0e:	11 f4       	brne	.+4      	; 0x2f14 <chb_set_channel+0x40>
    2f10:	80 e4       	ldi	r24, 0x40	; 64
    2f12:	01 c0       	rjmp	.+2      	; 0x2f16 <chb_set_channel+0x42>
    2f14:	83 e4       	ldi	r24, 0x43	; 67
}
    2f16:	cf 91       	pop	r28
    2f18:	08 95       	ret

00002f1a <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    2f1a:	cf 93       	push	r28
    2f1c:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    2f1e:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    2f22:	8c 2b       	or	r24, r28
    2f24:	8f 5f       	subi	r24, 0xFF	; 255
    2f26:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    }
    return val;
}
    2f2a:	80 e0       	ldi	r24, 0x00	; 0
    2f2c:	90 e0       	ldi	r25, 0x00	; 0
    2f2e:	cf 91       	pop	r28
    2f30:	08 95       	ret

00002f32 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    2f32:	e4 e6       	ldi	r30, 0x64	; 100
    2f34:	f6 e0       	ldi	r31, 0x06	; 6
    2f36:	80 81       	ld	r24, Z
    2f38:	81 60       	ori	r24, 0x01	; 1
    2f3a:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    2f3c:	80 81       	ld	r24, Z
    2f3e:	8d 7f       	andi	r24, 0xFD	; 253
    2f40:	80 83       	st	Z, r24
    2f42:	8f ed       	ldi	r24, 0xDF	; 223
    2f44:	9b e0       	ldi	r25, 0x0B	; 11
    2f46:	01 97       	sbiw	r24, 0x01	; 1
    2f48:	f1 f7       	brne	.-4      	; 0x2f46 <chb_reset+0x14>
    2f4a:	00 c0       	rjmp	.+0      	; 0x2f4c <chb_reset+0x1a>
    2f4c:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    2f4e:	80 81       	ld	r24, Z
    2f50:	8e 7f       	andi	r24, 0xFE	; 254
    2f52:	80 83       	st	Z, r24
    2f54:	9a e0       	ldi	r25, 0x0A	; 10
    2f56:	9a 95       	dec	r25
    2f58:	f1 f7       	brne	.-4      	; 0x2f56 <chb_reset+0x24>
    2f5a:	00 c0       	rjmp	.+0      	; 0x2f5c <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    2f5c:	80 81       	ld	r24, Z
    2f5e:	81 60       	ori	r24, 0x01	; 1
    2f60:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    2f62:	8d e1       	ldi	r24, 0x1D	; 29
    2f64:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    2f68:	81 30       	cpi	r24, 0x01	; 1
    2f6a:	d9 f7       	brne	.-10     	; 0x2f62 <chb_reset+0x30>
    2f6c:	8c e1       	ldi	r24, 0x1C	; 28
    2f6e:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    2f72:	87 30       	cpi	r24, 0x07	; 7
    2f74:	b1 f7       	brne	.-20     	; 0x2f62 <chb_reset+0x30>
            break;
        }
    }
	

}
    2f76:	08 95       	ret

00002f78 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    2f78:	0f 93       	push	r16
    2f7a:	1f 93       	push	r17
    2f7c:	cf 93       	push	r28
    2f7e:	df 93       	push	r29
    2f80:	cd b7       	in	r28, 0x3d	; 61
    2f82:	de b7       	in	r29, 0x3e	; 62
    2f84:	ea 97       	sbiw	r28, 0x3a	; 58
    2f86:	cd bf       	out	0x3d, r28	; 61
    2f88:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    2f8a:	0e 94 03 1a 	call	0x3406	; 0x3406 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    2f8e:	e0 e6       	ldi	r30, 0x60	; 96
    2f90:	f6 e0       	ldi	r31, 0x06	; 6
    2f92:	80 81       	ld	r24, Z
    2f94:	82 60       	ori	r24, 0x02	; 2
    2f96:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    2f98:	80 81       	ld	r24, Z
    2f9a:	81 60       	ori	r24, 0x01	; 1
    2f9c:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    2f9e:	0e 94 99 17 	call	0x2f32	; 0x2f32 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    2fa2:	8e e0       	ldi	r24, 0x0E	; 14
    2fa4:	60 e0       	ldi	r22, 0x00	; 0
    2fa6:	0e 94 d7 15 	call	0x2bae	; 0x2bae <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    2faa:	82 e0       	ldi	r24, 0x02	; 2
    2fac:	63 e0       	ldi	r22, 0x03	; 3
    2fae:	4f e1       	ldi	r20, 0x1F	; 31
    2fb0:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    2fb4:	81 e0       	ldi	r24, 0x01	; 1
    2fb6:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    2fba:	8f 71       	andi	r24, 0x1F	; 31
    2fbc:	88 30       	cpi	r24, 0x08	; 8
    2fbe:	d1 f7       	brne	.-12     	; 0x2fb4 <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    2fc0:	8e e2       	ldi	r24, 0x2E	; 46
    2fc2:	60 e4       	ldi	r22, 0x40	; 64
    2fc4:	40 ec       	ldi	r20, 0xC0	; 192
    2fc6:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    2fca:	8e e0       	ldi	r24, 0x0E	; 14
    2fcc:	6c e0       	ldi	r22, 0x0C	; 12
    2fce:	0e 94 d7 15 	call	0x2bae	; 0x2bae <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    2fd2:	84 e0       	ldi	r24, 0x04	; 4
    2fd4:	60 e2       	ldi	r22, 0x20	; 32
    2fd6:	40 e2       	ldi	r20, 0x20	; 32
    2fd8:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    2fdc:	81 e0       	ldi	r24, 0x01	; 1
    2fde:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    2fe2:	81 e0       	ldi	r24, 0x01	; 1
    2fe4:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    2fe8:	86 e1       	ldi	r24, 0x16	; 22
    2fea:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    2fee:	82 e2       	ldi	r24, 0x22	; 34
    2ff0:	64 e3       	ldi	r22, 0x34	; 52
    2ff2:	72 e1       	ldi	r23, 0x12	; 18
    2ff4:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    2ff8:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <chb_get_short_addr>
    2ffc:	bc 01       	movw	r22, r24
    2ffe:	80 e2       	ldi	r24, 0x20	; 32
    3000:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3004:	ce 01       	movw	r24, r28
    3006:	01 96       	adiw	r24, 0x01	; 1
    3008:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    300c:	84 e2       	ldi	r24, 0x24	; 36
    300e:	be 01       	movw	r22, r28
    3010:	6f 5f       	subi	r22, 0xFF	; 255
    3012:	7f 4f       	sbci	r23, 0xFF	; 255
    3014:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3018:	e2 e7       	ldi	r30, 0x72	; 114
    301a:	f6 e0       	ldi	r31, 0x06	; 6
    301c:	80 81       	ld	r24, Z
    301e:	81 60       	ori	r24, 0x01	; 1
    3020:	80 83       	st	Z, r24
    3022:	e9 e6       	ldi	r30, 0x69	; 105
    3024:	f6 e0       	ldi	r31, 0x06	; 6
    3026:	80 81       	ld	r24, Z
    3028:	83 60       	ori	r24, 0x03	; 3
    302a:	80 83       	st	Z, r24
    302c:	ea e6       	ldi	r30, 0x6A	; 106
    302e:	f6 e0       	ldi	r31, 0x06	; 6
    3030:	80 81       	ld	r24, Z
    3032:	84 60       	ori	r24, 0x04	; 4
    3034:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3036:	e0 ea       	ldi	r30, 0xA0	; 160
    3038:	f0 e0       	ldi	r31, 0x00	; 0
    303a:	82 81       	ldd	r24, Z+2	; 0x02
    303c:	87 60       	ori	r24, 0x07	; 7
    303e:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3040:	0e 94 6d 16 	call	0x2cda	; 0x2cda <chb_get_state>
    3044:	86 31       	cpi	r24, 0x16	; 22
    3046:	91 f0       	breq	.+36     	; 0x306c <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3048:	8e 01       	movw	r16, r28
    304a:	07 5f       	subi	r16, 0xF7	; 247
    304c:	1f 4f       	sbci	r17, 0xFF	; 255
    304e:	c8 01       	movw	r24, r16
    3050:	68 ee       	ldi	r22, 0xE8	; 232
    3052:	71 e0       	ldi	r23, 0x01	; 1
    3054:	0e 94 7c 38 	call	0x70f8	; 0x70f8 <strcpy_P>
        printf(buf);
    3058:	0f 92       	push	r0
    305a:	0f 92       	push	r0
    305c:	ed b7       	in	r30, 0x3d	; 61
    305e:	fe b7       	in	r31, 0x3e	; 62
    3060:	01 83       	std	Z+1, r16	; 0x01
    3062:	12 83       	std	Z+2, r17	; 0x02
    3064:	0e 94 cf 38 	call	0x719e	; 0x719e <printf>
    3068:	0f 90       	pop	r0
    306a:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    306c:	ea 96       	adiw	r28, 0x3a	; 58
    306e:	cd bf       	out	0x3d, r28	; 61
    3070:	de bf       	out	0x3e, r29	; 62
    3072:	df 91       	pop	r29
    3074:	cf 91       	pop	r28
    3076:	1f 91       	pop	r17
    3078:	0f 91       	pop	r16
    307a:	08 95       	ret

0000307c <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    307c:	1f 92       	push	r1
    307e:	0f 92       	push	r0
    3080:	0f b6       	in	r0, 0x3f	; 63
    3082:	0f 92       	push	r0
    3084:	0b b6       	in	r0, 0x3b	; 59
    3086:	0f 92       	push	r0
    3088:	11 24       	eor	r1, r1
    308a:	4f 92       	push	r4
    308c:	5f 92       	push	r5
    308e:	6f 92       	push	r6
    3090:	7f 92       	push	r7
    3092:	8f 92       	push	r8
    3094:	9f 92       	push	r9
    3096:	af 92       	push	r10
    3098:	bf 92       	push	r11
    309a:	cf 92       	push	r12
    309c:	df 92       	push	r13
    309e:	ef 92       	push	r14
    30a0:	ff 92       	push	r15
    30a2:	0f 93       	push	r16
    30a4:	1f 93       	push	r17
    30a6:	2f 93       	push	r18
    30a8:	3f 93       	push	r19
    30aa:	4f 93       	push	r20
    30ac:	5f 93       	push	r21
    30ae:	6f 93       	push	r22
    30b0:	7f 93       	push	r23
    30b2:	8f 93       	push	r24
    30b4:	9f 93       	push	r25
    30b6:	af 93       	push	r26
    30b8:	bf 93       	push	r27
    30ba:	ef 93       	push	r30
    30bc:	ff 93       	push	r31
    30be:	cf 93       	push	r28
    30c0:	df 93       	push	r29
    30c2:	cd b7       	in	r28, 0x3d	; 61
    30c4:	de b7       	in	r29, 0x3e	; 62
    30c6:	e2 97       	sbiw	r28, 0x32	; 50
    30c8:	cd bf       	out	0x3d, r28	; 61
    30ca:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    30cc:	0e 94 07 14 	call	0x280e	; 0x280e <chb_get_pcb>
    30d0:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    30d2:	8f b7       	in	r24, 0x3f	; 63
    30d4:	80 93 56 40 	sts	0x4056, r24
    30d8:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    30da:	81 e0       	ldi	r24, 0x01	; 1
    30dc:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    30e0:	8f e8       	ldi	r24, 0x8F	; 143
    30e2:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    intp_src = SPID_write(0);
    30e6:	80 e0       	ldi	r24, 0x00	; 0
    30e8:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    30ec:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    30ee:	80 e0       	ldi	r24, 0x00	; 0
    30f0:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>

    while (intp_src)
    30f4:	11 23       	and	r17, r17
    30f6:	09 f4       	brne	.+2      	; 0x30fa <__vector_64+0x7e>
    30f8:	be c0       	rjmp	.+380    	; 0x3276 <__vector_64+0x1fa>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    30fa:	aa 24       	eor	r10, r10
    30fc:	bb 24       	eor	r11, r11
    30fe:	68 94       	set
    3100:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3102:	0f 2e       	mov	r0, r31
    3104:	f8 e0       	ldi	r31, 0x08	; 8
    3106:	6f 2e       	mov	r6, r31
    3108:	f2 e0       	ldi	r31, 0x02	; 2
    310a:	7f 2e       	mov	r7, r31
    310c:	f0 2d       	mov	r31, r0
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    310e:	0f 2e       	mov	r0, r31
    3110:	f0 e8       	ldi	r31, 0x80	; 128
    3112:	8f 2e       	mov	r8, r31
    3114:	f6 e0       	ldi	r31, 0x06	; 6
    3116:	9f 2e       	mov	r9, r31
    3118:	f0 2d       	mov	r31, r0
    311a:	cc 24       	eor	r12, r12
    311c:	68 94       	set
    311e:	c2 f8       	bld	r12, 2
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3120:	12 ff       	sbrs	r17, 2
    3122:	02 c0       	rjmp	.+4      	; 0x3128 <__vector_64+0xac>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3124:	1b 7f       	andi	r17, 0xFB	; 251
    3126:	a4 c0       	rjmp	.+328    	; 0x3270 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3128:	13 ff       	sbrs	r17, 3
    312a:	89 c0       	rjmp	.+274    	; 0x323e <__vector_64+0x1c2>
        {
            state = chb_get_state();
    312c:	0e 94 6d 16 	call	0x2cda	; 0x2cda <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3130:	86 30       	cpi	r24, 0x06	; 6
    3132:	29 f0       	breq	.+10     	; 0x313e <__vector_64+0xc2>
    3134:	86 31       	cpi	r24, 0x16	; 22
    3136:	19 f0       	breq	.+6      	; 0x313e <__vector_64+0xc2>
    3138:	81 31       	cpi	r24, 0x11	; 17
    313a:	09 f0       	breq	.+2      	; 0x313e <__vector_64+0xc2>
    313c:	76 c0       	rjmp	.+236    	; 0x322a <__vector_64+0x1ae>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    313e:	88 e0       	ldi	r24, 0x08	; 8
    3140:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3144:	87 e0       	ldi	r24, 0x07	; 7
    3146:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    314a:	f7 01       	movw	r30, r14
    314c:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    314e:	86 e0       	ldi	r24, 0x06	; 6
    3150:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
    3154:	88 1f       	adc	r24, r24
    3156:	88 27       	eor	r24, r24
    3158:	88 1f       	adc	r24, r24
    315a:	f7 01       	movw	r30, r14
    315c:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    315e:	88 23       	and	r24, r24
    3160:	09 f4       	brne	.+2      	; 0x3164 <__vector_64+0xe8>
    3162:	66 c0       	rjmp	.+204    	; 0x3230 <__vector_64+0x1b4>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3164:	8f b7       	in	r24, 0x3f	; 63
    3166:	80 93 56 40 	sts	0x4056, r24
    316a:	f8 94       	cli
    RadioCS(TRUE);
    316c:	81 e0       	ldi	r24, 0x01	; 1
    316e:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3172:	80 e2       	ldi	r24, 0x20	; 32
    3174:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    len = SPID_write(0);
    3178:	80 e0       	ldi	r24, 0x00	; 0
    317a:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
    317e:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3180:	83 50       	subi	r24, 0x03	; 3
    3182:	8d 37       	cpi	r24, 0x7D	; 125
    3184:	08 f0       	brcs	.+2      	; 0x3188 <__vector_64+0x10c>
    3186:	41 c0       	rjmp	.+130    	; 0x320a <__vector_64+0x18e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3188:	0e 94 5f 15 	call	0x2abe	; 0x2abe <chb_buf_get_len>
    318c:	2d 2d       	mov	r18, r13
    318e:	30 e0       	ldi	r19, 0x00	; 0
    3190:	a5 01       	movw	r20, r10
    3192:	48 1b       	sub	r20, r24
    3194:	51 09       	sbc	r21, r1
    3196:	24 17       	cp	r18, r20
    3198:	35 07       	cpc	r19, r21
    319a:	94 f4       	brge	.+36     	; 0x31c0 <__vector_64+0x144>
        {
            chb_buf_write(len);
    319c:	8d 2d       	mov	r24, r13
    319e:	0e 94 33 15 	call	0x2a66	; 0x2a66 <chb_buf_write>
            
            for (i=0; i<len; i++)
    31a2:	dd 20       	and	r13, r13
    31a4:	49 f0       	breq	.+18     	; 0x31b8 <__vector_64+0x13c>
    31a6:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    31a8:	80 e0       	ldi	r24, 0x00	; 0
    31aa:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
                chb_buf_write(data);
    31ae:	0e 94 33 15 	call	0x2a66	; 0x2a66 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    31b2:	0f 5f       	subi	r16, 0xFF	; 255
    31b4:	0d 15       	cp	r16, r13
    31b6:	c1 f7       	brne	.-16     	; 0x31a8 <__vector_64+0x12c>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    31b8:	f4 01       	movw	r30, r8
    31ba:	c5 82       	std	Z+5, r12	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    31bc:	c6 82       	std	Z+6, r12	; 0x06
    31be:	25 c0       	rjmp	.+74     	; 0x320a <__vector_64+0x18e>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    31c0:	0e 94 07 14 	call	0x280e	; 0x280e <chb_get_pcb>
    31c4:	2c 01       	movw	r4, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    31c6:	dd 20       	and	r13, r13
    31c8:	39 f0       	breq	.+14     	; 0x31d8 <__vector_64+0x15c>
    31ca:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    31cc:	80 e0       	ldi	r24, 0x00	; 0
    31ce:	0e 94 16 1a 	call	0x342c	; 0x342c <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    31d2:	0f 5f       	subi	r16, 0xFF	; 255
    31d4:	0d 15       	cp	r16, r13
    31d6:	d1 f7       	brne	.-12     	; 0x31cc <__vector_64+0x150>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    31d8:	f2 01       	movw	r30, r4
    31da:	85 85       	ldd	r24, Z+13	; 0x0d
    31dc:	96 85       	ldd	r25, Z+14	; 0x0e
    31de:	01 96       	adiw	r24, 0x01	; 1
    31e0:	85 87       	std	Z+13, r24	; 0x0d
    31e2:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    31e4:	ce 01       	movw	r24, r28
    31e6:	01 96       	adiw	r24, 0x01	; 1
    31e8:	b3 01       	movw	r22, r6
    31ea:	0e 94 7c 38 	call	0x70f8	; 0x70f8 <strcpy_P>
            printf(buf);
    31ee:	0f 92       	push	r0
    31f0:	0f 92       	push	r0
    31f2:	41 e0       	ldi	r20, 0x01	; 1
    31f4:	50 e0       	ldi	r21, 0x00	; 0
    31f6:	4c 0f       	add	r20, r28
    31f8:	5d 1f       	adc	r21, r29
    31fa:	ed b7       	in	r30, 0x3d	; 61
    31fc:	fe b7       	in	r31, 0x3e	; 62
    31fe:	41 83       	std	Z+1, r20	; 0x01
    3200:	52 83       	std	Z+2, r21	; 0x02
    3202:	0e 94 cf 38 	call	0x719e	; 0x719e <printf>
    3206:	0f 90       	pop	r0
    3208:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    320a:	80 e0       	ldi	r24, 0x00	; 0
    320c:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RadioCS>
    CHB_LEAVE_CRIT();
    3210:	80 91 56 40 	lds	r24, 0x4056
    3214:	8f bf       	out	0x3f, r24	; 63
    3216:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3218:	f7 01       	movw	r30, r14
    321a:	85 81       	ldd	r24, Z+5	; 0x05
    321c:	96 81       	ldd	r25, Z+6	; 0x06
    321e:	01 96       	adiw	r24, 0x01	; 1
    3220:	85 83       	std	Z+5, r24	; 0x05
    3222:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3224:	81 e0       	ldi	r24, 0x01	; 1
    3226:	83 83       	std	Z+3, r24	; 0x03
    3228:	03 c0       	rjmp	.+6      	; 0x3230 <__vector_64+0x1b4>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    322a:	81 e0       	ldi	r24, 0x01	; 1
    322c:	f7 01       	movw	r30, r14
    322e:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3230:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3232:	86 e1       	ldi	r24, 0x16	; 22
    3234:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <chb_set_state>
    3238:	80 34       	cpi	r24, 0x40	; 64
    323a:	d9 f7       	brne	.-10     	; 0x3232 <__vector_64+0x1b6>
    323c:	19 c0       	rjmp	.+50     	; 0x3270 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    323e:	16 ff       	sbrs	r17, 6
    3240:	08 c0       	rjmp	.+16     	; 0x3252 <__vector_64+0x1d6>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3242:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3244:	f7 01       	movw	r30, r14
    3246:	87 85       	ldd	r24, Z+15	; 0x0f
    3248:	90 89       	ldd	r25, Z+16	; 0x10
    324a:	01 96       	adiw	r24, 0x01	; 1
    324c:	87 87       	std	Z+15, r24	; 0x0f
    324e:	90 8b       	std	Z+16, r25	; 0x10
    3250:	0f c0       	rjmp	.+30     	; 0x3270 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3252:	11 ff       	sbrs	r17, 1
    3254:	02 c0       	rjmp	.+4      	; 0x325a <__vector_64+0x1de>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3256:	1d 7f       	andi	r17, 0xFD	; 253
    3258:	0b c0       	rjmp	.+22     	; 0x3270 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    325a:	10 ff       	sbrs	r17, 0
    325c:	02 c0       	rjmp	.+4      	; 0x3262 <__vector_64+0x1e6>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    325e:	1e 7f       	andi	r17, 0xFE	; 254
    3260:	07 c0       	rjmp	.+14     	; 0x3270 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3262:	11 23       	and	r17, r17
    3264:	2c f4       	brge	.+10     	; 0x3270 <__vector_64+0x1f4>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3266:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    3268:	f7 01       	movw	r30, r14
    326a:	81 89       	ldd	r24, Z+17	; 0x11
    326c:	8f 5f       	subi	r24, 0xFF	; 255
    326e:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3270:	11 23       	and	r17, r17
    3272:	09 f0       	breq	.+2      	; 0x3276 <__vector_64+0x1fa>
    3274:	55 cf       	rjmp	.-342    	; 0x3120 <__vector_64+0xa4>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3276:	80 91 56 40 	lds	r24, 0x4056
    327a:	8f bf       	out	0x3f, r24	; 63
    327c:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    327e:	8f e0       	ldi	r24, 0x0F	; 15
    3280:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <chb_reg_read>
}
    3284:	e2 96       	adiw	r28, 0x32	; 50
    3286:	cd bf       	out	0x3d, r28	; 61
    3288:	de bf       	out	0x3e, r29	; 62
    328a:	df 91       	pop	r29
    328c:	cf 91       	pop	r28
    328e:	ff 91       	pop	r31
    3290:	ef 91       	pop	r30
    3292:	bf 91       	pop	r27
    3294:	af 91       	pop	r26
    3296:	9f 91       	pop	r25
    3298:	8f 91       	pop	r24
    329a:	7f 91       	pop	r23
    329c:	6f 91       	pop	r22
    329e:	5f 91       	pop	r21
    32a0:	4f 91       	pop	r20
    32a2:	3f 91       	pop	r19
    32a4:	2f 91       	pop	r18
    32a6:	1f 91       	pop	r17
    32a8:	0f 91       	pop	r16
    32aa:	ff 90       	pop	r15
    32ac:	ef 90       	pop	r14
    32ae:	df 90       	pop	r13
    32b0:	cf 90       	pop	r12
    32b2:	bf 90       	pop	r11
    32b4:	af 90       	pop	r10
    32b6:	9f 90       	pop	r9
    32b8:	8f 90       	pop	r8
    32ba:	7f 90       	pop	r7
    32bc:	6f 90       	pop	r6
    32be:	5f 90       	pop	r5
    32c0:	4f 90       	pop	r4
    32c2:	0f 90       	pop	r0
    32c4:	0b be       	out	0x3b, r0	; 59
    32c6:	0f 90       	pop	r0
    32c8:	0f be       	out	0x3f, r0	; 63
    32ca:	0f 90       	pop	r0
    32cc:	1f 90       	pop	r1
    32ce:	18 95       	reti

000032d0 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    32d0:	0f 93       	push	r16
    32d2:	1f 93       	push	r17
    32d4:	cf 93       	push	r28
    32d6:	df 93       	push	r29
    32d8:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    32da:	e0 ec       	ldi	r30, 0xC0	; 192
    32dc:	f1 e0       	ldi	r31, 0x01	; 1
    32de:	84 85       	ldd	r24, Z+12	; 0x0c
    32e0:	87 7f       	andi	r24, 0xF7	; 247
    32e2:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    32e4:	41 15       	cp	r20, r1
    32e6:	51 05       	cpc	r21, r1
    32e8:	09 f4       	brne	.+2      	; 0x32ec <chb_eeprom_write+0x1c>
    32ea:	50 c0       	rjmp	.+160    	; 0x338c <chb_eeprom_write+0xbc>
    32ec:	e0 e0       	ldi	r30, 0x00	; 0
    32ee:	f0 e0       	ldi	r31, 0x00	; 0
    32f0:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    32f2:	a0 ec       	ldi	r26, 0xC0	; 192
    32f4:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    32f6:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    32f8:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    32fa:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    32fc:	cf 01       	movw	r24, r30
    32fe:	80 0f       	add	r24, r16
    3300:	91 1f       	adc	r25, r17
    3302:	e6 0f       	add	r30, r22
    3304:	f7 1f       	adc	r31, r23
    3306:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3308:	1f 96       	adiw	r26, 0x0f	; 15
    330a:	ec 91       	ld	r30, X
    330c:	1f 97       	sbiw	r26, 0x0f	; 15
    330e:	ee 23       	and	r30, r30
    3310:	dc f3       	brlt	.-10     	; 0x3308 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3312:	1f 96       	adiw	r26, 0x0f	; 15
    3314:	ec 91       	ld	r30, X
    3316:	1f 97       	sbiw	r26, 0x0f	; 15
    3318:	e1 ff       	sbrs	r30, 1
    331a:	11 c0       	rjmp	.+34     	; 0x333e <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    331c:	1a 96       	adiw	r26, 0x0a	; 10
    331e:	dc 93       	st	X, r29
    3320:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3322:	ef 93       	push	r30
    3324:	ff 93       	push	r31
    3326:	0f 93       	push	r16
    3328:	2f 93       	push	r18
    332a:	eb ec       	ldi	r30, 0xCB	; 203
    332c:	f1 e0       	ldi	r31, 0x01	; 1
    332e:	08 ed       	ldi	r16, 0xD8	; 216
    3330:	21 e0       	ldi	r18, 0x01	; 1
    3332:	04 bf       	out	0x34, r16	; 52
    3334:	20 83       	st	Z, r18
    3336:	2f 91       	pop	r18
    3338:	0f 91       	pop	r16
    333a:	ff 91       	pop	r31
    333c:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    333e:	1a 96       	adiw	r26, 0x0a	; 10
    3340:	cc 93       	st	X, r28
    3342:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3344:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3346:	89 2f       	mov	r24, r25
    3348:	8f 71       	andi	r24, 0x1F	; 31
    334a:	11 96       	adiw	r26, 0x01	; 1
    334c:	8c 93       	st	X, r24
    334e:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3350:	12 96       	adiw	r26, 0x02	; 2
    3352:	1c 92       	st	X, r1
    3354:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3356:	14 96       	adiw	r26, 0x04	; 4
    3358:	fc 93       	st	X, r31
    335a:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    335c:	1a 96       	adiw	r26, 0x0a	; 10
    335e:	3c 93       	st	X, r19
    3360:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3362:	ef 93       	push	r30
    3364:	ff 93       	push	r31
    3366:	0f 93       	push	r16
    3368:	2f 93       	push	r18
    336a:	eb ec       	ldi	r30, 0xCB	; 203
    336c:	f1 e0       	ldi	r31, 0x01	; 1
    336e:	08 ed       	ldi	r16, 0xD8	; 216
    3370:	21 e0       	ldi	r18, 0x01	; 1
    3372:	04 bf       	out	0x34, r16	; 52
    3374:	20 83       	st	Z, r18
    3376:	2f 91       	pop	r18
    3378:	0f 91       	pop	r16
    337a:	ff 91       	pop	r31
    337c:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    337e:	2f 5f       	subi	r18, 0xFF	; 255
    3380:	e2 2f       	mov	r30, r18
    3382:	f0 e0       	ldi	r31, 0x00	; 0
    3384:	e4 17       	cp	r30, r20
    3386:	f5 07       	cpc	r31, r21
    3388:	08 f4       	brcc	.+2      	; 0x338c <chb_eeprom_write+0xbc>
    338a:	b8 cf       	rjmp	.-144    	; 0x32fc <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    338c:	df 91       	pop	r29
    338e:	cf 91       	pop	r28
    3390:	1f 91       	pop	r17
    3392:	0f 91       	pop	r16
    3394:	08 95       	ret

00003396 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3396:	1f 93       	push	r17
    3398:	cf 93       	push	r28
    339a:	df 93       	push	r29
    339c:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    339e:	e0 ec       	ldi	r30, 0xC0	; 192
    33a0:	f1 e0       	ldi	r31, 0x01	; 1
    33a2:	84 85       	ldd	r24, Z+12	; 0x0c
    33a4:	87 7f       	andi	r24, 0xF7	; 247
    33a6:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    33a8:	41 15       	cp	r20, r1
    33aa:	51 05       	cpc	r21, r1
    33ac:	41 f1       	breq	.+80     	; 0x33fe <chb_eeprom_read+0x68>
    33ae:	80 e0       	ldi	r24, 0x00	; 0
    33b0:	90 e0       	ldi	r25, 0x00	; 0
    33b2:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    33b4:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    33b6:	db 01       	movw	r26, r22
    33b8:	a8 0f       	add	r26, r24
    33ba:	b9 1f       	adc	r27, r25
    33bc:	82 0f       	add	r24, r18
    33be:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    33c0:	17 85       	ldd	r17, Z+15	; 0x0f
    33c2:	11 23       	and	r17, r17
    33c4:	ec f3       	brlt	.-6      	; 0x33c0 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    33c6:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    33c8:	89 2f       	mov	r24, r25
    33ca:	8f 71       	andi	r24, 0x1F	; 31
    33cc:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    33ce:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    33d0:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    33d2:	ef 93       	push	r30
    33d4:	ff 93       	push	r31
    33d6:	0f 93       	push	r16
    33d8:	2f 93       	push	r18
    33da:	eb ec       	ldi	r30, 0xCB	; 203
    33dc:	f1 e0       	ldi	r31, 0x01	; 1
    33de:	08 ed       	ldi	r16, 0xD8	; 216
    33e0:	21 e0       	ldi	r18, 0x01	; 1
    33e2:	04 bf       	out	0x34, r16	; 52
    33e4:	20 83       	st	Z, r18
    33e6:	2f 91       	pop	r18
    33e8:	0f 91       	pop	r16
    33ea:	ff 91       	pop	r31
    33ec:	ef 91       	pop	r30

    return NVM.DATA0;
    33ee:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    33f0:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    33f2:	cf 5f       	subi	r28, 0xFF	; 255
    33f4:	8c 2f       	mov	r24, r28
    33f6:	90 e0       	ldi	r25, 0x00	; 0
    33f8:	84 17       	cp	r24, r20
    33fa:	95 07       	cpc	r25, r21
    33fc:	e0 f2       	brcs	.-72     	; 0x33b6 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    33fe:	df 91       	pop	r29
    3400:	cf 91       	pop	r28
    3402:	1f 91       	pop	r17
    3404:	08 95       	ret

00003406 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3406:	e0 e6       	ldi	r30, 0x60	; 96
    3408:	f6 e0       	ldi	r31, 0x06	; 6
    340a:	80 81       	ld	r24, Z
    340c:	80 6b       	ori	r24, 0xB0	; 176
    340e:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3410:	e4 e6       	ldi	r30, 0x64	; 100
    3412:	f6 e0       	ldi	r31, 0x06	; 6
    3414:	80 81       	ld	r24, Z
    3416:	80 61       	ori	r24, 0x10	; 16
    3418:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    341a:	a0 ec       	ldi	r26, 0xC0	; 192
    341c:	b9 e0       	ldi	r27, 0x09	; 9
    341e:	8c 91       	ld	r24, X
    3420:	81 65       	ori	r24, 0x51	; 81
    3422:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3424:	80 81       	ld	r24, Z
    3426:	80 61       	ori	r24, 0x10	; 16
    3428:	80 83       	st	Z, r24
}
    342a:	08 95       	ret

0000342c <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    342c:	e0 ec       	ldi	r30, 0xC0	; 192
    342e:	f9 e0       	ldi	r31, 0x09	; 9
    3430:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3432:	82 81       	ldd	r24, Z+2	; 0x02
    3434:	88 23       	and	r24, r24
    3436:	ec f7       	brge	.-6      	; 0x3432 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3438:	e0 ec       	ldi	r30, 0xC0	; 192
    343a:	f9 e0       	ldi	r31, 0x09	; 9
    343c:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    343e:	08 95       	ret

00003440 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3440:	0f 93       	push	r16
    3442:	cf 93       	push	r28
    3444:	df 93       	push	r29
    3446:	0f 92       	push	r0
    3448:	cd b7       	in	r28, 0x3d	; 61
    344a:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    344c:	2f b7       	in	r18, 0x3f	; 63
    344e:	29 83       	std	Y+1, r18	; 0x01
    3450:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3452:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3454:	fc 01       	movw	r30, r24
    3456:	08 ed       	ldi	r16, 0xD8	; 216
    3458:	04 bf       	out	0x34, r16	; 52
    345a:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    345c:	89 81       	ldd	r24, Y+1	; 0x01
    345e:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3460:	0f 90       	pop	r0
    3462:	df 91       	pop	r29
    3464:	cf 91       	pop	r28
    3466:	0f 91       	pop	r16
    3468:	08 95       	ret

0000346a <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    346a:	66 23       	and	r22, r22
    346c:	11 f0       	breq	.+4      	; 0x3472 <CLKSYS_XOSC_Config+0x8>
    346e:	90 e2       	ldi	r25, 0x20	; 32
    3470:	01 c0       	rjmp	.+2      	; 0x3474 <CLKSYS_XOSC_Config+0xa>
    3472:	90 e0       	ldi	r25, 0x00	; 0
    3474:	84 2b       	or	r24, r20
    3476:	89 2b       	or	r24, r25
    3478:	e0 e5       	ldi	r30, 0x50	; 80
    347a:	f0 e0       	ldi	r31, 0x00	; 0
    347c:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    347e:	08 95       	ret

00003480 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3480:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3482:	86 2b       	or	r24, r22
    3484:	e0 e5       	ldi	r30, 0x50	; 80
    3486:	f0 e0       	ldi	r31, 0x00	; 0
    3488:	85 83       	std	Z+5, r24	; 0x05
}
    348a:	08 95       	ret

0000348c <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    348c:	e0 e5       	ldi	r30, 0x50	; 80
    348e:	f0 e0       	ldi	r31, 0x00	; 0
    3490:	90 81       	ld	r25, Z
    3492:	28 2f       	mov	r18, r24
    3494:	20 95       	com	r18
    3496:	92 23       	and	r25, r18
    3498:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    349a:	90 81       	ld	r25, Z
	return clkEnabled;
}
    349c:	89 23       	and	r24, r25
    349e:	08 95       	ret

000034a0 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    34a0:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    34a2:	81 e4       	ldi	r24, 0x41	; 65
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	0e 94 20 1a 	call	0x3440	; 0x3440 <CCPWrite>
}
    34aa:	08 95       	ret

000034ac <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    34ac:	1f 93       	push	r17
    34ae:	cf 93       	push	r28
    34b0:	df 93       	push	r29
    34b2:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    34b4:	c0 e4       	ldi	r28, 0x40	; 64
    34b6:	d0 e0       	ldi	r29, 0x00	; 0
    34b8:	68 81       	ld	r22, Y
    34ba:	68 7f       	andi	r22, 0xF8	; 248
    34bc:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    34be:	80 e4       	ldi	r24, 0x40	; 64
    34c0:	90 e0       	ldi	r25, 0x00	; 0
    34c2:	0e 94 20 1a 	call	0x3440	; 0x3440 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    34c6:	88 81       	ld	r24, Y
	return clkCtrl;
}
    34c8:	81 23       	and	r24, r17
    34ca:	df 91       	pop	r29
    34cc:	cf 91       	pop	r28
    34ce:	1f 91       	pop	r17
    34d0:	08 95       	ret

000034d2 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    34d2:	e0 e4       	ldi	r30, 0x40	; 64
    34d4:	f0 e0       	ldi	r31, 0x00	; 0
    34d6:	93 81       	ldd	r25, Z+3	; 0x03
    34d8:	91 7f       	andi	r25, 0xF1	; 241
    34da:	91 60       	ori	r25, 0x01	; 1
    34dc:	89 2b       	or	r24, r25
    34de:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    34e0:	08 95       	ret

000034e2 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    34e2:	e0 e5       	ldi	r30, 0x50	; 80
    34e4:	f0 e0       	ldi	r31, 0x00	; 0
    34e6:	26 81       	ldd	r18, Z+6	; 0x06
    34e8:	98 2f       	mov	r25, r24
    34ea:	38 2f       	mov	r19, r24
    34ec:	30 95       	com	r19
    34ee:	23 23       	and	r18, r19
    34f0:	66 23       	and	r22, r22
    34f2:	09 f4       	brne	.+2      	; 0x34f6 <CLKSYS_AutoCalibration_Enable+0x14>
    34f4:	90 e0       	ldi	r25, 0x00	; 0
    34f6:	92 2b       	or	r25, r18
    34f8:	e0 e5       	ldi	r30, 0x50	; 80
    34fa:	f0 e0       	ldi	r31, 0x00	; 0
    34fc:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    34fe:	81 30       	cpi	r24, 0x01	; 1
    3500:	31 f4       	brne	.+12     	; 0x350e <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3502:	e8 e6       	ldi	r30, 0x68	; 104
    3504:	f0 e0       	ldi	r31, 0x00	; 0
    3506:	80 81       	ld	r24, Z
    3508:	81 60       	ori	r24, 0x01	; 1
    350a:	80 83       	st	Z, r24
    350c:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    350e:	82 30       	cpi	r24, 0x02	; 2
    3510:	29 f4       	brne	.+10     	; 0x351c <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3512:	e0 e6       	ldi	r30, 0x60	; 96
    3514:	f0 e0       	ldi	r31, 0x00	; 0
    3516:	80 81       	ld	r24, Z
    3518:	81 60       	ori	r24, 0x01	; 1
    351a:	80 83       	st	Z, r24
    351c:	08 95       	ret

0000351e <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    351e:	83 e5       	ldi	r24, 0x53	; 83
    3520:	90 e0       	ldi	r25, 0x00	; 0
    3522:	63 e0       	ldi	r22, 0x03	; 3
    3524:	0e 94 20 1a 	call	0x3440	; 0x3440 <CCPWrite>
}
    3528:	08 95       	ret

0000352a <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    352a:	82 e4       	ldi	r24, 0x42	; 66
    352c:	90 e0       	ldi	r25, 0x00	; 0
    352e:	61 e0       	ldi	r22, 0x01	; 1
    3530:	0e 94 20 1a 	call	0x3440	; 0x3440 <CCPWrite>
}
    3534:	08 95       	ret

00003536 <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    3536:	80 ec       	ldi	r24, 0xC0	; 192
    3538:	60 e0       	ldi	r22, 0x00	; 0
    353a:	4b e0       	ldi	r20, 0x0B	; 11
    353c:	0e 94 35 1a 	call	0x346a	; 0x346a <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    3540:	e0 e5       	ldi	r30, 0x50	; 80
    3542:	f0 e0       	ldi	r31, 0x00	; 0
    3544:	80 81       	ld	r24, Z
    3546:	88 60       	ori	r24, 0x08	; 8
    3548:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    354a:	81 81       	ldd	r24, Z+1	; 0x01
    354c:	83 ff       	sbrs	r24, 3
    354e:	fd cf       	rjmp	.-6      	; 0x354a <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    3550:	80 ec       	ldi	r24, 0xC0	; 192
    3552:	62 e0       	ldi	r22, 0x02	; 2
    3554:	0e 94 40 1a 	call	0x3480	; 0x3480 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    3558:	e0 e5       	ldi	r30, 0x50	; 80
    355a:	f0 e0       	ldi	r31, 0x00	; 0
    355c:	80 81       	ld	r24, Z
    355e:	80 61       	ori	r24, 0x10	; 16
    3560:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    3562:	81 81       	ldd	r24, Z+1	; 0x01
    3564:	84 ff       	sbrs	r24, 4
    3566:	fd cf       	rjmp	.-6      	; 0x3562 <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    3568:	84 e0       	ldi	r24, 0x04	; 4
    356a:	0e 94 56 1a 	call	0x34ac	; 0x34ac <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    356e:	81 e0       	ldi	r24, 0x01	; 1
    3570:	0e 94 46 1a 	call	0x348c	; 0x348c <CLKSYS_Disable>
}
    3574:	08 95       	ret

00003576 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3576:	e0 e5       	ldi	r30, 0x50	; 80
    3578:	f0 e0       	ldi	r31, 0x00	; 0
    357a:	80 81       	ld	r24, Z
    357c:	82 60       	ori	r24, 0x02	; 2
    357e:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    3580:	80 e0       	ldi	r24, 0x00	; 0
    3582:	61 e0       	ldi	r22, 0x01	; 1
    3584:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3588:	e0 e5       	ldi	r30, 0x50	; 80
    358a:	f0 e0       	ldi	r31, 0x00	; 0
    358c:	81 81       	ldd	r24, Z+1	; 0x01
    358e:	81 ff       	sbrs	r24, 1
    3590:	fd cf       	rjmp	.-6      	; 0x358c <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3592:	81 e0       	ldi	r24, 0x01	; 1
    3594:	0e 94 56 1a 	call	0x34ac	; 0x34ac <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3598:	81 e0       	ldi	r24, 0x01	; 1
    359a:	0e 94 46 1a 	call	0x348c	; 0x348c <CLKSYS_Disable>
	
}
    359e:	08 95       	ret

000035a0 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    35a0:	e0 e5       	ldi	r30, 0x50	; 80
    35a2:	f0 e0       	ldi	r31, 0x00	; 0
    35a4:	80 81       	ld	r24, Z
    35a6:	82 60       	ori	r24, 0x02	; 2
    35a8:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    35aa:	80 e0       	ldi	r24, 0x00	; 0
    35ac:	60 e0       	ldi	r22, 0x00	; 0
    35ae:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    35b2:	e0 e5       	ldi	r30, 0x50	; 80
    35b4:	f0 e0       	ldi	r31, 0x00	; 0
    35b6:	81 81       	ldd	r24, Z+1	; 0x01
    35b8:	81 ff       	sbrs	r24, 1
    35ba:	fd cf       	rjmp	.-6      	; 0x35b6 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    35bc:	81 e0       	ldi	r24, 0x01	; 1
    35be:	0e 94 56 1a 	call	0x34ac	; 0x34ac <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    35c2:	81 e0       	ldi	r24, 0x01	; 1
    35c4:	0e 94 46 1a 	call	0x348c	; 0x348c <CLKSYS_Disable>
	
}
    35c8:	08 95       	ret

000035ca <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    35ca:	88 23       	and	r24, r24
    35cc:	29 f0       	breq	.+10     	; 0x35d8 <portExCS+0xe>
    35ce:	88 e0       	ldi	r24, 0x08	; 8
    35d0:	e0 e0       	ldi	r30, 0x00	; 0
    35d2:	f6 e0       	ldi	r31, 0x06	; 6
    35d4:	86 83       	std	Z+6, r24	; 0x06
    35d6:	04 c0       	rjmp	.+8      	; 0x35e0 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    35d8:	88 e0       	ldi	r24, 0x08	; 8
    35da:	e0 e0       	ldi	r30, 0x00	; 0
    35dc:	f6 e0       	ldi	r31, 0x06	; 6
    35de:	85 83       	std	Z+5, r24	; 0x05
    35e0:	8a e6       	ldi	r24, 0x6A	; 106
    35e2:	8a 95       	dec	r24
    35e4:	f1 f7       	brne	.-4      	; 0x35e2 <portExCS+0x18>
    35e6:	00 c0       	rjmp	.+0      	; 0x35e8 <portExCS+0x1e>
	}
	_delay_us(10);
}
    35e8:	08 95       	ret

000035ea <Ext1Power>:
*/


void Ext1Power(uint8_t on) {
	
	if (on) {
    35ea:	88 23       	and	r24, r24
    35ec:	79 f0       	breq	.+30     	; 0x360c <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    35ee:	e0 ea       	ldi	r30, 0xA0	; 160
    35f0:	f6 e0       	ldi	r31, 0x06	; 6
    35f2:	80 e2       	ldi	r24, 0x20	; 32
    35f4:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    35f6:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    35f8:	8f ef       	ldi	r24, 0xFF	; 255
    35fa:	93 ec       	ldi	r25, 0xC3	; 195
    35fc:	a9 e0       	ldi	r26, 0x09	; 9
    35fe:	81 50       	subi	r24, 0x01	; 1
    3600:	90 40       	sbci	r25, 0x00	; 0
    3602:	a0 40       	sbci	r26, 0x00	; 0
    3604:	e1 f7       	brne	.-8      	; 0x35fe <Ext1Power+0x14>
    3606:	00 c0       	rjmp	.+0      	; 0x3608 <Ext1Power+0x1e>
    3608:	00 00       	nop
    360a:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    360c:	e0 ea       	ldi	r30, 0xA0	; 160
    360e:	f6 e0       	ldi	r31, 0x06	; 6
    3610:	80 e2       	ldi	r24, 0x20	; 32
    3612:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    3614:	82 83       	std	Z+2, r24	; 0x02
    3616:	08 95       	ret

00003618 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
    3618:	88 23       	and	r24, r24
    361a:	79 f0       	breq	.+30     	; 0x363a <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    361c:	e0 ea       	ldi	r30, 0xA0	; 160
    361e:	f6 e0       	ldi	r31, 0x06	; 6
    3620:	80 e4       	ldi	r24, 0x40	; 64
    3622:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    3624:	85 83       	std	Z+5, r24	; 0x05
    3626:	8f ef       	ldi	r24, 0xFF	; 255
    3628:	93 ec       	ldi	r25, 0xC3	; 195
    362a:	a9 e0       	ldi	r26, 0x09	; 9
    362c:	81 50       	subi	r24, 0x01	; 1
    362e:	90 40       	sbci	r25, 0x00	; 0
    3630:	a0 40       	sbci	r26, 0x00	; 0
    3632:	e1 f7       	brne	.-8      	; 0x362c <Ext2Power+0x14>
    3634:	00 c0       	rjmp	.+0      	; 0x3636 <Ext2Power+0x1e>
    3636:	00 00       	nop
    3638:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    363a:	e0 ea       	ldi	r30, 0xA0	; 160
    363c:	f6 e0       	ldi	r31, 0x06	; 6
    363e:	80 e4       	ldi	r24, 0x40	; 64
    3640:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    3642:	82 83       	std	Z+2, r24	; 0x02
    3644:	08 95       	ret

00003646 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
    3646:	88 23       	and	r24, r24
    3648:	79 f0       	breq	.+30     	; 0x3668 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    364a:	e0 ea       	ldi	r30, 0xA0	; 160
    364c:	f6 e0       	ldi	r31, 0x06	; 6
    364e:	80 e8       	ldi	r24, 0x80	; 128
    3650:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    3652:	85 83       	std	Z+5, r24	; 0x05
    3654:	8f ef       	ldi	r24, 0xFF	; 255
    3656:	93 ec       	ldi	r25, 0xC3	; 195
    3658:	a9 e0       	ldi	r26, 0x09	; 9
    365a:	81 50       	subi	r24, 0x01	; 1
    365c:	90 40       	sbci	r25, 0x00	; 0
    365e:	a0 40       	sbci	r26, 0x00	; 0
    3660:	e1 f7       	brne	.-8      	; 0x365a <HVPower+0x14>
    3662:	00 c0       	rjmp	.+0      	; 0x3664 <HVPower+0x1e>
    3664:	00 00       	nop
    3666:	05 c0       	rjmp	.+10     	; 0x3672 <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    3668:	e0 ea       	ldi	r30, 0xA0	; 160
    366a:	f6 e0       	ldi	r31, 0x06	; 6
    366c:	80 e8       	ldi	r24, 0x80	; 128
    366e:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    3670:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3672:	af e3       	ldi	r26, 0x3F	; 63
    3674:	bf e1       	ldi	r27, 0x1F	; 31
    3676:	11 97       	sbiw	r26, 0x01	; 1
    3678:	f1 f7       	brne	.-4      	; 0x3676 <HVPower+0x30>
    367a:	00 c0       	rjmp	.+0      	; 0x367c <HVPower+0x36>
    367c:	00 00       	nop
	}
	_delay_us(1000);
}
    367e:	08 95       	ret

00003680 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    3680:	88 23       	and	r24, r24
    3682:	29 f0       	breq	.+10     	; 0x368e <lowerMuxCS+0xe>
    3684:	80 e1       	ldi	r24, 0x10	; 16
    3686:	e0 e8       	ldi	r30, 0x80	; 128
    3688:	f6 e0       	ldi	r31, 0x06	; 6
    368a:	86 83       	std	Z+6, r24	; 0x06
    368c:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    368e:	80 e1       	ldi	r24, 0x10	; 16
    3690:	e0 e8       	ldi	r30, 0x80	; 128
    3692:	f6 e0       	ldi	r31, 0x06	; 6
    3694:	85 83       	std	Z+5, r24	; 0x05
    3696:	08 95       	ret

00003698 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    3698:	88 23       	and	r24, r24
    369a:	29 f0       	breq	.+10     	; 0x36a6 <upperMuxCS+0xe>
    369c:	82 e0       	ldi	r24, 0x02	; 2
    369e:	e0 e4       	ldi	r30, 0x40	; 64
    36a0:	f6 e0       	ldi	r31, 0x06	; 6
    36a2:	86 83       	std	Z+6, r24	; 0x06
    36a4:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    36a6:	82 e0       	ldi	r24, 0x02	; 2
    36a8:	e0 e4       	ldi	r30, 0x40	; 64
    36aa:	f6 e0       	ldi	r31, 0x06	; 6
    36ac:	85 83       	std	Z+5, r24	; 0x05
    36ae:	08 95       	ret

000036b0 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    36b0:	e0 e4       	ldi	r30, 0x40	; 64
    36b2:	f6 e0       	ldi	r31, 0x06	; 6
    36b4:	90 e1       	ldi	r25, 0x10	; 16
    36b6:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    36b8:	28 e3       	ldi	r18, 0x38	; 56
    36ba:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    36bc:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    36be:	81 65       	ori	r24, 0x51	; 81
    36c0:	a0 ec       	ldi	r26, 0xC0	; 192
    36c2:	b8 e0       	ldi	r27, 0x08	; 8
    36c4:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    36c6:	11 96       	adiw	r26, 0x01	; 1
    36c8:	1c 92       	st	X, r1
    36ca:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    36cc:	80 ea       	ldi	r24, 0xA0	; 160
    36ce:	81 83       	std	Z+1, r24	; 0x01

	
}
    36d0:	08 95       	ret

000036d2 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    36d2:	e0 e4       	ldi	r30, 0x40	; 64
    36d4:	f6 e0       	ldi	r31, 0x06	; 6
    36d6:	90 e1       	ldi	r25, 0x10	; 16
    36d8:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    36da:	28 e3       	ldi	r18, 0x38	; 56
    36dc:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    36de:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    36e0:	80 65       	ori	r24, 0x50	; 80
    36e2:	68 2b       	or	r22, r24
    36e4:	a0 ec       	ldi	r26, 0xC0	; 192
    36e6:	b8 e0       	ldi	r27, 0x08	; 8
    36e8:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    36ea:	11 96       	adiw	r26, 0x01	; 1
    36ec:	1c 92       	st	X, r1
    36ee:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    36f0:	80 ea       	ldi	r24, 0xA0	; 160
    36f2:	81 83       	std	Z+1, r24	; 0x01
}
    36f4:	08 95       	ret

000036f6 <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    36f6:	88 23       	and	r24, r24
    36f8:	29 f0       	breq	.+10     	; 0x3704 <SPICS+0xe>
    36fa:	80 e1       	ldi	r24, 0x10	; 16
    36fc:	e0 e4       	ldi	r30, 0x40	; 64
    36fe:	f6 e0       	ldi	r31, 0x06	; 6
    3700:	86 83       	std	Z+6, r24	; 0x06
    3702:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    3704:	80 e1       	ldi	r24, 0x10	; 16
    3706:	e0 e4       	ldi	r30, 0x40	; 64
    3708:	f6 e0       	ldi	r31, 0x06	; 6
    370a:	85 83       	std	Z+5, r24	; 0x05
    370c:	08 95       	ret

0000370e <SPIDisable>:
	}	
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
    370e:	e0 e4       	ldi	r30, 0x40	; 64
    3710:	f6 e0       	ldi	r31, 0x06	; 6
    3712:	80 e1       	ldi	r24, 0x10	; 16
    3714:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    3716:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    371a:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    371c:	80 eb       	ldi	r24, 0xB0	; 176
    371e:	82 83       	std	Z+2, r24	; 0x02

}
    3720:	08 95       	ret

00003722 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3722:	cf 93       	push	r28
    3724:	df 93       	push	r29
    3726:	c8 2f       	mov	r28, r24
    3728:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    372a:	80 e0       	ldi	r24, 0x00	; 0
    372c:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    3730:	81 e0       	ldi	r24, 0x01	; 1
    3732:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	portExCS(TRUE);
    3736:	81 e0       	ldi	r24, 0x01	; 1
    3738:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    373c:	dd 23       	and	r29, r29
    373e:	89 f0       	breq	.+34     	; 0x3762 <PortEx_OUTCLR+0x40>
    3740:	80 91 d6 23 	lds	r24, 0x23D6
    3744:	c0 95       	com	r28
    3746:	c8 23       	and	r28, r24
    3748:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    374c:	80 e4       	ldi	r24, 0x40	; 64
    374e:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3752:	84 e1       	ldi	r24, 0x14	; 20
    3754:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3758:	80 91 d6 23 	lds	r24, 0x23D6
    375c:	80 93 67 50 	sts	0x5067, r24
    3760:	10 c0       	rjmp	.+32     	; 0x3782 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    3762:	80 91 82 50 	lds	r24, 0x5082
    3766:	c0 95       	com	r28
    3768:	c8 23       	and	r28, r24
    376a:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    376e:	80 e4       	ldi	r24, 0x40	; 64
    3770:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3774:	85 e1       	ldi	r24, 0x15	; 21
    3776:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    377a:	80 91 82 50 	lds	r24, 0x5082
    377e:	80 93 67 50 	sts	0x5067, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3782:	80 e0       	ldi	r24, 0x00	; 0
    3784:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3786:	25 e6       	ldi	r18, 0x65	; 101
    3788:	30 e5       	ldi	r19, 0x50	; 80
    378a:	a0 ec       	ldi	r26, 0xC0	; 192
    378c:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    378e:	c1 e7       	ldi	r28, 0x71	; 113
    3790:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3792:	f9 01       	movw	r30, r18
    3794:	e8 0f       	add	r30, r24
    3796:	f9 1f       	adc	r31, r25
    3798:	40 81       	ld	r20, Z
    379a:	13 96       	adiw	r26, 0x03	; 3
    379c:	4c 93       	st	X, r20
    379e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    37a0:	12 96       	adiw	r26, 0x02	; 2
    37a2:	4c 91       	ld	r20, X
    37a4:	12 97       	sbiw	r26, 0x02	; 2
    37a6:	44 23       	and	r20, r20
    37a8:	dc f7       	brge	.-10     	; 0x37a0 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    37aa:	13 96       	adiw	r26, 0x03	; 3
    37ac:	4c 91       	ld	r20, X
    37ae:	13 97       	sbiw	r26, 0x03	; 3
    37b0:	48 83       	st	Y, r20
    37b2:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    37b4:	83 30       	cpi	r24, 0x03	; 3
    37b6:	91 05       	cpc	r25, r1
    37b8:	61 f7       	brne	.-40     	; 0x3792 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    37ba:	80 e0       	ldi	r24, 0x00	; 0
    37bc:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	portExCS(FALSE);
    37c0:	80 e0       	ldi	r24, 0x00	; 0
    37c2:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>
	SPIDisable();
    37c6:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
}
    37ca:	df 91       	pop	r29
    37cc:	cf 91       	pop	r28
    37ce:	08 95       	ret

000037d0 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    37d0:	cf 93       	push	r28
    37d2:	df 93       	push	r29
    37d4:	c8 2f       	mov	r28, r24
    37d6:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    37d8:	80 e0       	ldi	r24, 0x00	; 0
    37da:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    37de:	81 e0       	ldi	r24, 0x01	; 1
    37e0:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	portExCS(TRUE);
    37e4:	81 e0       	ldi	r24, 0x01	; 1
    37e6:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    37ea:	dd 23       	and	r29, r29
    37ec:	81 f0       	breq	.+32     	; 0x380e <PortEx_OUTSET+0x3e>
    37ee:	80 91 d6 23 	lds	r24, 0x23D6
    37f2:	c8 2b       	or	r28, r24
    37f4:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    37f8:	80 e4       	ldi	r24, 0x40	; 64
    37fa:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    37fe:	84 e1       	ldi	r24, 0x14	; 20
    3800:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3804:	80 91 d6 23 	lds	r24, 0x23D6
    3808:	80 93 67 50 	sts	0x5067, r24
    380c:	0f c0       	rjmp	.+30     	; 0x382c <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    380e:	80 91 82 50 	lds	r24, 0x5082
    3812:	c8 2b       	or	r28, r24
    3814:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3818:	80 e4       	ldi	r24, 0x40	; 64
    381a:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    381e:	85 e1       	ldi	r24, 0x15	; 21
    3820:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3824:	80 91 82 50 	lds	r24, 0x5082
    3828:	80 93 67 50 	sts	0x5067, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    382c:	80 e0       	ldi	r24, 0x00	; 0
    382e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3830:	25 e6       	ldi	r18, 0x65	; 101
    3832:	30 e5       	ldi	r19, 0x50	; 80
    3834:	a0 ec       	ldi	r26, 0xC0	; 192
    3836:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3838:	c1 e7       	ldi	r28, 0x71	; 113
    383a:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    383c:	f9 01       	movw	r30, r18
    383e:	e8 0f       	add	r30, r24
    3840:	f9 1f       	adc	r31, r25
    3842:	40 81       	ld	r20, Z
    3844:	13 96       	adiw	r26, 0x03	; 3
    3846:	4c 93       	st	X, r20
    3848:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    384a:	12 96       	adiw	r26, 0x02	; 2
    384c:	4c 91       	ld	r20, X
    384e:	12 97       	sbiw	r26, 0x02	; 2
    3850:	44 23       	and	r20, r20
    3852:	dc f7       	brge	.-10     	; 0x384a <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3854:	13 96       	adiw	r26, 0x03	; 3
    3856:	4c 91       	ld	r20, X
    3858:	13 97       	sbiw	r26, 0x03	; 3
    385a:	48 83       	st	Y, r20
    385c:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    385e:	83 30       	cpi	r24, 0x03	; 3
    3860:	91 05       	cpc	r25, r1
    3862:	61 f7       	brne	.-40     	; 0x383c <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3864:	80 e0       	ldi	r24, 0x00	; 0
    3866:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	portExCS(FALSE);
    386a:	80 e0       	ldi	r24, 0x00	; 0
    386c:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>
	SPIDisable();
    3870:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
}
    3874:	df 91       	pop	r29
    3876:	cf 91       	pop	r28
    3878:	08 95       	ret

0000387a <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    387a:	cf 93       	push	r28
    387c:	df 93       	push	r29
    387e:	c8 2f       	mov	r28, r24
    3880:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3882:	80 e0       	ldi	r24, 0x00	; 0
    3884:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    3888:	81 e0       	ldi	r24, 0x01	; 1
    388a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	portExCS(TRUE);
    388e:	81 e0       	ldi	r24, 0x01	; 1
    3890:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    3894:	dd 23       	and	r29, r29
    3896:	89 f0       	breq	.+34     	; 0x38ba <PortEx_DIRCLR+0x40>
    3898:	80 91 7a 50 	lds	r24, 0x507A
    389c:	80 95       	com	r24
    389e:	c8 23       	and	r28, r24
    38a0:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    38a4:	80 e4       	ldi	r24, 0x40	; 64
    38a6:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    38aa:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    38ae:	80 91 7a 50 	lds	r24, 0x507A
    38b2:	80 95       	com	r24
    38b4:	80 93 67 50 	sts	0x5067, r24
    38b8:	11 c0       	rjmp	.+34     	; 0x38dc <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    38ba:	80 91 d6 50 	lds	r24, 0x50D6
    38be:	80 95       	com	r24
    38c0:	c8 23       	and	r28, r24
    38c2:	c0 93 d6 50 	sts	0x50D6, r28
	
	SPIBuffer[0] = PS_WRITE;
    38c6:	80 e4       	ldi	r24, 0x40	; 64
    38c8:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    38cc:	81 e0       	ldi	r24, 0x01	; 1
    38ce:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    38d2:	80 91 d6 50 	lds	r24, 0x50D6
    38d6:	80 95       	com	r24
    38d8:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    38dc:	80 e0       	ldi	r24, 0x00	; 0
    38de:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    38e0:	25 e6       	ldi	r18, 0x65	; 101
    38e2:	30 e5       	ldi	r19, 0x50	; 80
    38e4:	a0 ec       	ldi	r26, 0xC0	; 192
    38e6:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    38e8:	c1 e7       	ldi	r28, 0x71	; 113
    38ea:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    38ec:	f9 01       	movw	r30, r18
    38ee:	e8 0f       	add	r30, r24
    38f0:	f9 1f       	adc	r31, r25
    38f2:	40 81       	ld	r20, Z
    38f4:	13 96       	adiw	r26, 0x03	; 3
    38f6:	4c 93       	st	X, r20
    38f8:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    38fa:	12 96       	adiw	r26, 0x02	; 2
    38fc:	4c 91       	ld	r20, X
    38fe:	12 97       	sbiw	r26, 0x02	; 2
    3900:	44 23       	and	r20, r20
    3902:	dc f7       	brge	.-10     	; 0x38fa <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    3904:	13 96       	adiw	r26, 0x03	; 3
    3906:	4c 91       	ld	r20, X
    3908:	13 97       	sbiw	r26, 0x03	; 3
    390a:	48 83       	st	Y, r20
    390c:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    390e:	83 30       	cpi	r24, 0x03	; 3
    3910:	91 05       	cpc	r25, r1
    3912:	61 f7       	brne	.-40     	; 0x38ec <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3914:	80 e0       	ldi	r24, 0x00	; 0
    3916:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	portExCS(FALSE);
    391a:	80 e0       	ldi	r24, 0x00	; 0
    391c:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>
	SPIDisable();
    3920:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
}
    3924:	df 91       	pop	r29
    3926:	cf 91       	pop	r28
    3928:	08 95       	ret

0000392a <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    392a:	cf 93       	push	r28
    392c:	df 93       	push	r29
    392e:	c8 2f       	mov	r28, r24
    3930:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3932:	80 e0       	ldi	r24, 0x00	; 0
    3934:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    3938:	81 e0       	ldi	r24, 0x01	; 1
    393a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	portExCS(TRUE);
    393e:	81 e0       	ldi	r24, 0x01	; 1
    3940:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    3944:	dd 23       	and	r29, r29
    3946:	81 f0       	breq	.+32     	; 0x3968 <PortEx_DIRSET+0x3e>
    3948:	80 91 7a 50 	lds	r24, 0x507A
    394c:	c8 2b       	or	r28, r24
    394e:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3952:	80 e4       	ldi	r24, 0x40	; 64
    3954:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3958:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    395c:	80 91 7a 50 	lds	r24, 0x507A
    3960:	80 95       	com	r24
    3962:	80 93 67 50 	sts	0x5067, r24
    3966:	10 c0       	rjmp	.+32     	; 0x3988 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    3968:	80 91 d6 50 	lds	r24, 0x50D6
    396c:	c8 2b       	or	r28, r24
    396e:	c0 93 d6 50 	sts	0x50D6, r28
	
	SPIBuffer[0] = PS_WRITE;
    3972:	80 e4       	ldi	r24, 0x40	; 64
    3974:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3978:	81 e0       	ldi	r24, 0x01	; 1
    397a:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    397e:	80 91 d6 50 	lds	r24, 0x50D6
    3982:	80 95       	com	r24
    3984:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3988:	80 e0       	ldi	r24, 0x00	; 0
    398a:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    398c:	25 e6       	ldi	r18, 0x65	; 101
    398e:	30 e5       	ldi	r19, 0x50	; 80
    3990:	a0 ec       	ldi	r26, 0xC0	; 192
    3992:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3994:	c1 e7       	ldi	r28, 0x71	; 113
    3996:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3998:	f9 01       	movw	r30, r18
    399a:	e8 0f       	add	r30, r24
    399c:	f9 1f       	adc	r31, r25
    399e:	40 81       	ld	r20, Z
    39a0:	13 96       	adiw	r26, 0x03	; 3
    39a2:	4c 93       	st	X, r20
    39a4:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    39a6:	12 96       	adiw	r26, 0x02	; 2
    39a8:	4c 91       	ld	r20, X
    39aa:	12 97       	sbiw	r26, 0x02	; 2
    39ac:	44 23       	and	r20, r20
    39ae:	dc f7       	brge	.-10     	; 0x39a6 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    39b0:	13 96       	adiw	r26, 0x03	; 3
    39b2:	4c 91       	ld	r20, X
    39b4:	13 97       	sbiw	r26, 0x03	; 3
    39b6:	48 83       	st	Y, r20
    39b8:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    39ba:	83 30       	cpi	r24, 0x03	; 3
    39bc:	91 05       	cpc	r25, r1
    39be:	61 f7       	brne	.-40     	; 0x3998 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    39c0:	80 e0       	ldi	r24, 0x00	; 0
    39c2:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <portExCS>
	SPICS(FALSE);
    39c6:	80 e0       	ldi	r24, 0x00	; 0
    39c8:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    39cc:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>


}
    39d0:	df 91       	pop	r29
    39d2:	cf 91       	pop	r28
    39d4:	08 95       	ret

000039d6 <readFRAM>:

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    39d6:	0f 93       	push	r16
    39d8:	1f 93       	push	r17
    39da:	cf 93       	push	r28
    39dc:	df 93       	push	r29
    39de:	8c 01       	movw	r16, r24
	
	SPIInit(SPI_MODE_0_gc);
    39e0:	80 e0       	ldi	r24, 0x00	; 0
    39e2:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    39e6:	c0 ec       	ldi	r28, 0xC0	; 192
    39e8:	d8 e0       	ldi	r29, 0x08	; 8
    39ea:	80 ed       	ldi	r24, 0xD0	; 208
    39ec:	88 83       	st	Y, r24
	SPICS(TRUE);
    39ee:	81 e0       	ldi	r24, 0x01	; 1
    39f0:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    39f4:	88 e0       	ldi	r24, 0x08	; 8
    39f6:	e0 e2       	ldi	r30, 0x20	; 32
    39f8:	f6 e0       	ldi	r31, 0x06	; 6
    39fa:	86 83       	std	Z+6, r24	; 0x06
	nop();
    39fc:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    39fe:	83 e0       	ldi	r24, 0x03	; 3
    3a00:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3a02:	e0 ec       	ldi	r30, 0xC0	; 192
    3a04:	f8 e0       	ldi	r31, 0x08	; 8
    3a06:	82 81       	ldd	r24, Z+2	; 0x02
    3a08:	88 23       	and	r24, r24
    3a0a:	ec f7       	brge	.-6      	; 0x3a06 <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    3a0c:	e0 ec       	ldi	r30, 0xC0	; 192
    3a0e:	f8 e0       	ldi	r31, 0x08	; 8
    3a10:	83 81       	ldd	r24, Z+3	; 0x03
    3a12:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    3a16:	80 91 58 40 	lds	r24, 0x4058
    3a1a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3a1c:	82 81       	ldd	r24, Z+2	; 0x02
    3a1e:	88 23       	and	r24, r24
    3a20:	ec f7       	brge	.-6      	; 0x3a1c <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    3a22:	e0 ec       	ldi	r30, 0xC0	; 192
    3a24:	f8 e0       	ldi	r31, 0x08	; 8
    3a26:	83 81       	ldd	r24, Z+3	; 0x03
    3a28:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    3a2c:	80 91 57 40 	lds	r24, 0x4057
    3a30:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3a32:	82 81       	ldd	r24, Z+2	; 0x02
    3a34:	88 23       	and	r24, r24
    3a36:	ec f7       	brge	.-6      	; 0x3a32 <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3a38:	e0 ec       	ldi	r30, 0xC0	; 192
    3a3a:	f8 e0       	ldi	r31, 0x08	; 8
    3a3c:	83 81       	ldd	r24, Z+3	; 0x03
    3a3e:	80 93 71 50 	sts	0x5071, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3a42:	01 15       	cp	r16, r1
    3a44:	11 05       	cpc	r17, r1
    3a46:	b1 f0       	breq	.+44     	; 0x3a74 <readFRAM+0x9e>
    3a48:	ef ed       	ldi	r30, 0xDF	; 223
    3a4a:	f3 e2       	ldi	r31, 0x23	; 35

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3a4c:	0e 0f       	add	r16, r30
    3a4e:	1f 1f       	adc	r17, r31
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    3a50:	a0 ec       	ldi	r26, 0xC0	; 192
    3a52:	b8 e0       	ldi	r27, 0x08	; 8
    3a54:	9a ea       	ldi	r25, 0xAA	; 170
    3a56:	13 96       	adiw	r26, 0x03	; 3
    3a58:	9c 93       	st	X, r25
    3a5a:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3a5c:	12 96       	adiw	r26, 0x02	; 2
    3a5e:	8c 91       	ld	r24, X
    3a60:	12 97       	sbiw	r26, 0x02	; 2
    3a62:	88 23       	and	r24, r24
    3a64:	dc f7       	brge	.-10     	; 0x3a5c <readFRAM+0x86>
		FRAMReadBuffer[i] = SPIC.DATA;
    3a66:	13 96       	adiw	r26, 0x03	; 3
    3a68:	8c 91       	ld	r24, X
    3a6a:	13 97       	sbiw	r26, 0x03	; 3
    3a6c:	81 93       	st	Z+, r24
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3a6e:	e0 17       	cp	r30, r16
    3a70:	f1 07       	cpc	r31, r17
    3a72:	89 f7       	brne	.-30     	; 0x3a56 <readFRAM+0x80>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    3a74:	88 e0       	ldi	r24, 0x08	; 8
    3a76:	e0 e2       	ldi	r30, 0x20	; 32
    3a78:	f6 e0       	ldi	r31, 0x06	; 6
    3a7a:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    3a7c:	80 e0       	ldi	r24, 0x00	; 0
    3a7e:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    3a82:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>

}
    3a86:	df 91       	pop	r29
    3a88:	cf 91       	pop	r28
    3a8a:	1f 91       	pop	r17
    3a8c:	0f 91       	pop	r16
    3a8e:	08 95       	ret

00003a90 <FRAMTest3Channel>:
//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3a90:	81 e0       	ldi	r24, 0x01	; 1
    3a92:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
    3a96:	8f ec       	ldi	r24, 0xCF	; 207
    3a98:	97 e0       	ldi	r25, 0x07	; 7
    3a9a:	01 97       	sbiw	r24, 0x01	; 1
    3a9c:	f1 f7       	brne	.-4      	; 0x3a9a <FRAMTest3Channel+0xa>
    3a9e:	00 c0       	rjmp	.+0      	; 0x3aa0 <FRAMTest3Channel+0x10>
    3aa0:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3aa2:	0e 94 97 0c 	call	0x192e	; 0x192e <calcChecksumFRAM>

	ADCPower(FALSE);
    3aa6:	80 e0       	ldi	r24, 0x00	; 0
    3aa8:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	
}
    3aac:	08 95       	ret

00003aae <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3aae:	81 e0       	ldi	r24, 0x01	; 1
    3ab0:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
    3ab4:	8f ec       	ldi	r24, 0xCF	; 207
    3ab6:	97 e0       	ldi	r25, 0x07	; 7
    3ab8:	01 97       	sbiw	r24, 0x01	; 1
    3aba:	f1 f7       	brne	.-4      	; 0x3ab8 <FRAMTest1Channel+0xa>
    3abc:	00 c0       	rjmp	.+0      	; 0x3abe <FRAMTest1Channel+0x10>
    3abe:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3ac0:	0e 94 97 0c 	call	0x192e	; 0x192e <calcChecksumFRAM>

	ADCPower(FALSE);
    3ac4:	80 e0       	ldi	r24, 0x00	; 0
    3ac6:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>

}
    3aca:	08 95       	ret

00003acc <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
	
	FRAMWriteKnowns();
    3acc:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <FRAMWriteKnowns>
	ADCPower(TRUE);
    3ad0:	81 e0       	ldi	r24, 0x01	; 1
    3ad2:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
    3ad6:	8f ec       	ldi	r24, 0xCF	; 207
    3ad8:	97 e0       	ldi	r25, 0x07	; 7
    3ada:	01 97       	sbiw	r24, 0x01	; 1
    3adc:	f1 f7       	brne	.-4      	; 0x3ada <FRAMWriteKnownsCheck+0xe>
    3ade:	00 c0       	rjmp	.+0      	; 0x3ae0 <FRAMWriteKnownsCheck+0x14>
    3ae0:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    3ae2:	0e 94 97 0c 	call	0x192e	; 0x192e <calcChecksumFRAM>

	ADCPower(FALSE);
    3ae6:	80 e0       	ldi	r24, 0x00	; 0
    3ae8:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>

}
    3aec:	08 95       	ret

00003aee <checkMote>:

//random function for testing stuff	
void checkMote(){
	
	ADCPower(TRUE);
    3aee:	81 e0       	ldi	r24, 0x01	; 1
    3af0:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	Ext1Power(TRUE);
    3af4:	81 e0       	ldi	r24, 0x01	; 1
    3af6:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3afa:	8f ef       	ldi	r24, 0xFF	; 255
    3afc:	93 ec       	ldi	r25, 0xC3	; 195
    3afe:	a9 e0       	ldi	r26, 0x09	; 9
    3b00:	81 50       	subi	r24, 0x01	; 1
    3b02:	90 40       	sbci	r25, 0x00	; 0
    3b04:	a0 40       	sbci	r26, 0x00	; 0
    3b06:	e1 f7       	brne	.-8      	; 0x3b00 <checkMote+0x12>
    3b08:	00 c0       	rjmp	.+0      	; 0x3b0a <checkMote+0x1c>
    3b0a:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3b0c:	88 e0       	ldi	r24, 0x08	; 8
    3b0e:	60 e0       	ldi	r22, 0x00	; 0
    3b10:	0e 94 95 1c 	call	0x392a	; 0x392a <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3b14:	88 e0       	ldi	r24, 0x08	; 8
    3b16:	60 e0       	ldi	r22, 0x00	; 0
    3b18:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
    3b1c:	8a ea       	ldi	r24, 0xAA	; 170
    3b1e:	96 ee       	ldi	r25, 0xE6	; 230
    3b20:	a6 e9       	ldi	r26, 0x96	; 150
    3b22:	b1 e0       	ldi	r27, 0x01	; 1
    3b24:	81 50       	subi	r24, 0x01	; 1
    3b26:	90 40       	sbci	r25, 0x00	; 0
    3b28:	a0 40       	sbci	r26, 0x00	; 0
    3b2a:	b0 40       	sbci	r27, 0x00	; 0
    3b2c:	d9 f7       	brne	.-10     	; 0x3b24 <checkMote+0x36>
    3b2e:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3b30:	88 e0       	ldi	r24, 0x08	; 8
    3b32:	60 e0       	ldi	r22, 0x00	; 0
    3b34:	0e 94 91 1b 	call	0x3722	; 0x3722 <PortEx_OUTCLR>
    3b38:	8a ea       	ldi	r24, 0xAA	; 170
    3b3a:	96 ee       	ldi	r25, 0xE6	; 230
    3b3c:	a6 e9       	ldi	r26, 0x96	; 150
    3b3e:	b1 e0       	ldi	r27, 0x01	; 1
    3b40:	81 50       	subi	r24, 0x01	; 1
    3b42:	90 40       	sbci	r25, 0x00	; 0
    3b44:	a0 40       	sbci	r26, 0x00	; 0
    3b46:	b0 40       	sbci	r27, 0x00	; 0
    3b48:	d9 f7       	brne	.-10     	; 0x3b40 <checkMote+0x52>
    3b4a:	00 00       	nop
    3b4c:	e3 cf       	rjmp	.-58     	; 0x3b14 <checkMote+0x26>

00003b4e <SD_write_and_read_knowns>:
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3b4e:	0f 93       	push	r16
    3b50:	1f 93       	push	r17
    3b52:	cf 93       	push	r28
    3b54:	df 93       	push	r29
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3b56:	0f ed       	ldi	r16, 0xDF	; 223
    3b58:	13 e2       	ldi	r17, 0x23	; 35
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3b5a:	f8 01       	movw	r30, r16
    3b5c:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3b5e:	81 93       	st	Z+, r24
    3b60:	8f 5f       	subi	r24, 0xFF	; 255
    3b62:	88 31       	cpi	r24, 0x18	; 24
    3b64:	e1 f7       	brne	.-8      	; 0x3b5e <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    3b66:	cf ed       	ldi	r28, 0xDF	; 223
    3b68:	d3 e2       	ldi	r29, 0x23	; 35
    3b6a:	64 e1       	ldi	r22, 0x14	; 20
    3b6c:	70 e0       	ldi	r23, 0x00	; 0
    3b6e:	80 e0       	ldi	r24, 0x00	; 0
    3b70:	90 e0       	ldi	r25, 0x00	; 0
    3b72:	ae 01       	movw	r20, r28
    3b74:	28 e1       	ldi	r18, 0x18	; 24
    3b76:	30 e0       	ldi	r19, 0x00	; 0
    3b78:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SD_write_block>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3b7c:	68 96       	adiw	r28, 0x18	; 24
    3b7e:	f8 01       	movw	r30, r16
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    3b80:	11 92       	st	Z+, r1
    3b82:	ec 17       	cp	r30, r28
    3b84:	fd 07       	cpc	r31, r29
    3b86:	e1 f7       	brne	.-8      	; 0x3b80 <SD_write_and_read_knowns+0x32>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    3b88:	64 e1       	ldi	r22, 0x14	; 20
    3b8a:	70 e0       	ldi	r23, 0x00	; 0
    3b8c:	80 e0       	ldi	r24, 0x00	; 0
    3b8e:	90 e0       	ldi	r25, 0x00	; 0
    3b90:	4f ed       	ldi	r20, 0xDF	; 223
    3b92:	53 e2       	ldi	r21, 0x23	; 35
    3b94:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
    3b98:	f8 01       	movw	r30, r16
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3b9a:	20 e0       	ldi	r18, 0x00	; 0
    3b9c:	30 e0       	ldi	r19, 0x00	; 0
    3b9e:	c4 e6       	ldi	r28, 0x64	; 100
    3ba0:	d0 e0       	ldi	r29, 0x00	; 0
    3ba2:	c9 01       	movw	r24, r18
    3ba4:	be 01       	movw	r22, r28
    3ba6:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    3baa:	81 93       	st	Z+, r24
    3bac:	2f 5f       	subi	r18, 0xFF	; 255
    3bae:	3f 4f       	sbci	r19, 0xFF	; 255
    3bb0:	84 e0       	ldi	r24, 0x04	; 4
    3bb2:	22 3e       	cpi	r18, 0xE2	; 226
    3bb4:	38 07       	cpc	r19, r24
    3bb6:	a9 f7       	brne	.-22     	; 0x3ba2 <SD_write_and_read_knowns+0x54>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    3bb8:	60 e5       	ldi	r22, 0x50	; 80
    3bba:	70 e0       	ldi	r23, 0x00	; 0
    3bbc:	80 e0       	ldi	r24, 0x00	; 0
    3bbe:	90 e0       	ldi	r25, 0x00	; 0
    3bc0:	4f ed       	ldi	r20, 0xDF	; 223
    3bc2:	53 e2       	ldi	r21, 0x23	; 35
    3bc4:	22 ee       	ldi	r18, 0xE2	; 226
    3bc6:	34 e0       	ldi	r19, 0x04	; 4
    3bc8:	0e 94 f1 2a 	call	0x55e2	; 0x55e2 <SD_write_multiple_blocks>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3bcc:	81 ec       	ldi	r24, 0xC1	; 193
    3bce:	98 e2       	ldi	r25, 0x28	; 40
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    3bd0:	f8 01       	movw	r30, r16
    3bd2:	11 92       	st	Z+, r1
    3bd4:	8f 01       	movw	r16, r30
    3bd6:	e8 17       	cp	r30, r24
    3bd8:	f9 07       	cpc	r31, r25
    3bda:	d1 f7       	brne	.-12     	; 0x3bd0 <SD_write_and_read_knowns+0x82>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    3bdc:	60 e5       	ldi	r22, 0x50	; 80
    3bde:	70 e0       	ldi	r23, 0x00	; 0
    3be0:	80 e0       	ldi	r24, 0x00	; 0
    3be2:	90 e0       	ldi	r25, 0x00	; 0
    3be4:	4f ed       	ldi	r20, 0xDF	; 223
    3be6:	53 e2       	ldi	r21, 0x23	; 35
    3be8:	23 e0       	ldi	r18, 0x03	; 3
    3bea:	30 e0       	ldi	r19, 0x00	; 0
    3bec:	0e 94 4b 2c 	call	0x5896	; 0x5896 <SD_read_multiple_blocks>
}
    3bf0:	df 91       	pop	r29
    3bf2:	cf 91       	pop	r28
    3bf4:	1f 91       	pop	r17
    3bf6:	0f 91       	pop	r16
    3bf8:	08 95       	ret

00003bfa <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    3bfa:	0f 93       	push	r16
    3bfc:	1f 93       	push	r17
    3bfe:	cf 93       	push	r28
    3c00:	df 93       	push	r29
    3c02:	0f ed       	ldi	r16, 0xDF	; 223
    3c04:	13 e2       	ldi	r17, 0x23	; 35
    3c06:	f8 01       	movw	r30, r16
    3c08:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3c0a:	81 93       	st	Z+, r24
    3c0c:	8f 5f       	subi	r24, 0xFF	; 255
    3c0e:	88 31       	cpi	r24, 0x18	; 24
    3c10:	e1 f7       	brne	.-8      	; 0x3c0a <SD_write_and_read_knowns_FAT+0x10>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    3c12:	cf ed       	ldi	r28, 0xDF	; 223
    3c14:	d3 e2       	ldi	r29, 0x23	; 35
    3c16:	86 e1       	ldi	r24, 0x16	; 22
    3c18:	90 e2       	ldi	r25, 0x20	; 32
    3c1a:	be 01       	movw	r22, r28
    3c1c:	20 e0       	ldi	r18, 0x00	; 0
    3c1e:	32 e0       	ldi	r19, 0x02	; 2
    3c20:	40 e0       	ldi	r20, 0x00	; 0
    3c22:	50 e0       	ldi	r21, 0x00	; 0
    3c24:	0e 94 c2 25 	call	0x4b84	; 0x4b84 <writeFile>
    3c28:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
}

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    3c2c:	68 96       	adiw	r28, 0x18	; 24
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    3c2e:	f8 01       	movw	r30, r16
    3c30:	11 92       	st	Z+, r1
    3c32:	8f 01       	movw	r16, r30
    3c34:	ec 17       	cp	r30, r28
    3c36:	fd 07       	cpc	r31, r29
    3c38:	d1 f7       	brne	.-12     	; 0x3c2e <SD_write_and_read_knowns_FAT+0x34>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    3c3a:	80 e0       	ldi	r24, 0x00	; 0
    3c3c:	66 e1       	ldi	r22, 0x16	; 22
    3c3e:	70 e2       	ldi	r23, 0x20	; 32
    3c40:	0e 94 46 25 	call	0x4a8c	; 0x4a8c <readFile>
    3c44:	80 93 a3 50 	sts	0x50A3, r24
}
    3c48:	df 91       	pop	r29
    3c4a:	cf 91       	pop	r28
    3c4c:	1f 91       	pop	r17
    3c4e:	0f 91       	pop	r16
    3c50:	08 95       	ret

00003c52 <chibi_test_radio>:


//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    3c52:	0e 94 f5 13 	call	0x27ea	; 0x27ea <chb_init>
	chb_set_short_addr(0x0002);
    3c56:	82 e0       	ldi	r24, 0x02	; 2
    3c58:	90 e0       	ldi	r25, 0x00	; 0
    3c5a:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    3c5e:	00 00       	nop
    3c60:	fe cf       	rjmp	.-4      	; 0x3c5e <chibi_test_radio+0xc>

00003c62 <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    3c62:	cf 93       	push	r28
    3c64:	df 93       	push	r29
	
	SD_init();
    3c66:	0e 94 fb 28 	call	0x51f6	; 0x51f6 <SD_init>
	getBootSectorData();
    3c6a:	0e 94 db 20 	call	0x41b6	; 0x41b6 <getBootSectorData>
    3c6e:	ef ed       	ldi	r30, 0xDF	; 223
    3c70:	f3 e2       	ldi	r31, 0x23	; 35
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    3c72:	20 e0       	ldi	r18, 0x00	; 0
    3c74:	30 e0       	ldi	r19, 0x00	; 0
    3c76:	c9 e7       	ldi	r28, 0x79	; 121
    3c78:	d0 e0       	ldi	r29, 0x00	; 0
    3c7a:	c9 01       	movw	r24, r18
    3c7c:	be 01       	movw	r22, r28
    3c7e:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    3c82:	81 93       	st	Z+, r24
    3c84:	2f 5f       	subi	r18, 0xFF	; 255
    3c86:	3f 4f       	sbci	r19, 0xFF	; 255
    3c88:	82 e0       	ldi	r24, 0x02	; 2
    3c8a:	20 30       	cpi	r18, 0x00	; 0
    3c8c:	38 07       	cpc	r19, r24
    3c8e:	a9 f7       	brne	.-22     	; 0x3c7a <TestCard+0x18>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    3c90:	86 e1       	ldi	r24, 0x16	; 22
    3c92:	90 e2       	ldi	r25, 0x20	; 32
    3c94:	6f ed       	ldi	r22, 0xDF	; 223
    3c96:	73 e2       	ldi	r23, 0x23	; 35
    3c98:	20 e0       	ldi	r18, 0x00	; 0
    3c9a:	32 e0       	ldi	r19, 0x02	; 2
    3c9c:	40 e0       	ldi	r20, 0x00	; 0
    3c9e:	50 e0       	ldi	r21, 0x00	; 0
    3ca0:	0e 94 c2 25 	call	0x4b84	; 0x4b84 <writeFile>
	nop();
    3ca4:	00 00       	nop
}
    3ca6:	df 91       	pop	r29
    3ca8:	cf 91       	pop	r28
    3caa:	08 95       	ret

00003cac <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    3cac:	1f 92       	push	r1
    3cae:	0f 92       	push	r0
    3cb0:	0f b6       	in	r0, 0x3f	; 63
    3cb2:	0f 92       	push	r0
    3cb4:	0b b6       	in	r0, 0x3b	; 59
    3cb6:	0f 92       	push	r0
    3cb8:	11 24       	eor	r1, r1
    3cba:	2f 93       	push	r18
    3cbc:	3f 93       	push	r19
    3cbe:	4f 93       	push	r20
    3cc0:	5f 93       	push	r21
    3cc2:	6f 93       	push	r22
    3cc4:	7f 93       	push	r23
    3cc6:	8f 93       	push	r24
    3cc8:	9f 93       	push	r25
    3cca:	af 93       	push	r26
    3ccc:	bf 93       	push	r27
    3cce:	ef 93       	push	r30
    3cd0:	ff 93       	push	r31
	
	chb_rx_data_t* msg = NULL;
	switch (RadioMonitorMode) {
    3cd2:	80 91 5e 40 	lds	r24, 0x405E
    3cd6:	81 30       	cpi	r24, 0x01	; 1
    3cd8:	21 f0       	breq	.+8      	; 0x3ce2 <__vector_43+0x36>
    3cda:	82 30       	cpi	r24, 0x02	; 2
    3cdc:	09 f0       	breq	.+2      	; 0x3ce0 <__vector_43+0x34>
    3cde:	72 c0       	rjmp	.+228    	; 0x3dc4 <__vector_43+0x118>
    3ce0:	55 c0       	rjmp	.+170    	; 0x3d8c <__vector_43+0xe0>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    3ce2:	80 e0       	ldi	r24, 0x00	; 0
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	0e 94 cd 14 	call	0x299a	; 0x299a <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    3cea:	85 e0       	ldi	r24, 0x05	; 5
    3cec:	90 e0       	ldi	r25, 0x00	; 0
    3cee:	6e e1       	ldi	r22, 0x1E	; 30
    3cf0:	70 e2       	ldi	r23, 0x20	; 32
    3cf2:	45 e0       	ldi	r20, 0x05	; 5
    3cf4:	50 e0       	ldi	r21, 0x00	; 0
    3cf6:	0e 94 a0 38 	call	0x7140	; 0x7140 <strncmp>
    3cfa:	28 2f       	mov	r18, r24
    3cfc:	39 2f       	mov	r19, r25
    3cfe:	21 15       	cp	r18, r1
    3d00:	31 05       	cpc	r19, r1
    3d02:	51 f4       	brne	.+20     	; 0x3d18 <__vector_43+0x6c>
				MotesReadyToSynch++;
    3d04:	80 91 78 50 	lds	r24, 0x5078
    3d08:	90 91 79 50 	lds	r25, 0x5079
    3d0c:	01 96       	adiw	r24, 0x01	; 1
    3d0e:	80 93 78 50 	sts	0x5078, r24
    3d12:	90 93 79 50 	sts	0x5079, r25
    3d16:	56 c0       	rjmp	.+172    	; 0x3dc4 <__vector_43+0x118>
    3d18:	e5 e0       	ldi	r30, 0x05	; 5
    3d1a:	f0 e0       	ldi	r31, 0x00	; 0
    3d1c:	af ed       	ldi	r26, 0xDF	; 223
    3d1e:	b3 e2       	ldi	r27, 0x23	; 35
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    3d20:	81 91       	ld	r24, Z+
    3d22:	8d 93       	st	X+, r24
    3d24:	e5 38       	cpi	r30, 0x85	; 133
    3d26:	f1 05       	cpc	r31, r1
    3d28:	d9 f7       	brne	.-10     	; 0x3d20 <__vector_43+0x74>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    3d2a:	80 91 ca 50 	lds	r24, 0x50CA
    3d2e:	90 91 cb 50 	lds	r25, 0x50CB
    3d32:	a0 91 cc 50 	lds	r26, 0x50CC
    3d36:	b0 91 cd 50 	lds	r27, 0x50CD
    3d3a:	80 58       	subi	r24, 0x80	; 128
    3d3c:	9f 4f       	sbci	r25, 0xFF	; 255
    3d3e:	af 4f       	sbci	r26, 0xFF	; 255
    3d40:	bf 4f       	sbci	r27, 0xFF	; 255
    3d42:	80 93 ca 50 	sts	0x50CA, r24
    3d46:	90 93 cb 50 	sts	0x50CB, r25
    3d4a:	a0 93 cc 50 	sts	0x50CC, r26
    3d4e:	b0 93 cd 50 	sts	0x50CD, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    3d52:	80 91 ca 50 	lds	r24, 0x50CA
    3d56:	90 91 cb 50 	lds	r25, 0x50CB
    3d5a:	a0 91 cc 50 	lds	r26, 0x50CC
    3d5e:	b0 91 cd 50 	lds	r27, 0x50CD
    3d62:	80 58       	subi	r24, 0x80	; 128
    3d64:	9f 4f       	sbci	r25, 0xFF	; 255
    3d66:	af 4f       	sbci	r26, 0xFF	; 255
    3d68:	bf 4f       	sbci	r27, 0xFF	; 255
    3d6a:	81 37       	cpi	r24, 0x71	; 113
    3d6c:	2c e1       	ldi	r18, 0x1C	; 28
    3d6e:	92 07       	cpc	r25, r18
    3d70:	20 e0       	ldi	r18, 0x00	; 0
    3d72:	a2 07       	cpc	r26, r18
    3d74:	20 e0       	ldi	r18, 0x00	; 0
    3d76:	b2 07       	cpc	r27, r18
    3d78:	28 f1       	brcs	.+74     	; 0x3dc4 <__vector_43+0x118>
    3d7a:	10 92 ca 50 	sts	0x50CA, r1
    3d7e:	10 92 cb 50 	sts	0x50CB, r1
    3d82:	10 92 cc 50 	sts	0x50CC, r1
    3d86:	10 92 cd 50 	sts	0x50CD, r1
    3d8a:	1c c0       	rjmp	.+56     	; 0x3dc4 <__vector_43+0x118>
			}			
			break;
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    3d8c:	80 e0       	ldi	r24, 0x00	; 0
    3d8e:	90 e0       	ldi	r25, 0x00	; 0
    3d90:	0e 94 cd 14 	call	0x299a	; 0x299a <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    3d94:	85 e0       	ldi	r24, 0x05	; 5
    3d96:	90 e0       	ldi	r25, 0x00	; 0
    3d98:	64 e2       	ldi	r22, 0x24	; 36
    3d9a:	70 e2       	ldi	r23, 0x20	; 32
    3d9c:	4e e0       	ldi	r20, 0x0E	; 14
    3d9e:	50 e0       	ldi	r21, 0x00	; 0
    3da0:	0e 94 a0 38 	call	0x7140	; 0x7140 <strncmp>
    3da4:	28 2f       	mov	r18, r24
    3da6:	39 2f       	mov	r19, r25
    3da8:	21 15       	cp	r18, r1
    3daa:	31 05       	cpc	r19, r1
    3dac:	59 f4       	brne	.+22     	; 0x3dc4 <__vector_43+0x118>
				RadioMonitorMode = SYNCHED;
    3dae:	83 e0       	ldi	r24, 0x03	; 3
    3db0:	80 93 5e 40 	sts	0x405E, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    3db4:	89 e0       	ldi	r24, 0x09	; 9
    3db6:	80 93 40 09 	sts	0x0940, r24
				TCC1.CTRLA = 0x01;  
    3dba:	81 e0       	ldi	r24, 0x01	; 1
    3dbc:	80 93 40 08 	sts	0x0840, r24
				ADC_Resume_Sampling();	//resume sampling with the adc
    3dc0:	0e 94 65 07 	call	0xeca	; 0xeca <ADC_Resume_Sampling>
			}
			break;
		default:
			break;
	}
}
    3dc4:	ff 91       	pop	r31
    3dc6:	ef 91       	pop	r30
    3dc8:	bf 91       	pop	r27
    3dca:	af 91       	pop	r26
    3dcc:	9f 91       	pop	r25
    3dce:	8f 91       	pop	r24
    3dd0:	7f 91       	pop	r23
    3dd2:	6f 91       	pop	r22
    3dd4:	5f 91       	pop	r21
    3dd6:	4f 91       	pop	r20
    3dd8:	3f 91       	pop	r19
    3dda:	2f 91       	pop	r18
    3ddc:	0f 90       	pop	r0
    3dde:	0b be       	out	0x3b, r0	; 59
    3de0:	0f 90       	pop	r0
    3de2:	0f be       	out	0x3f, r0	; 63
    3de4:	0f 90       	pop	r0
    3de6:	1f 90       	pop	r1
    3de8:	18 95       	reti

00003dea <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    3dea:	2f 92       	push	r2
    3dec:	3f 92       	push	r3
    3dee:	4f 92       	push	r4
    3df0:	5f 92       	push	r5
    3df2:	6f 92       	push	r6
    3df4:	7f 92       	push	r7
    3df6:	8f 92       	push	r8
    3df8:	9f 92       	push	r9
    3dfa:	af 92       	push	r10
    3dfc:	bf 92       	push	r11
    3dfe:	cf 92       	push	r12
    3e00:	df 92       	push	r13
    3e02:	ef 92       	push	r14
    3e04:	ff 92       	push	r15
    3e06:	0f 93       	push	r16
    3e08:	1f 93       	push	r17
    3e0a:	cf 93       	push	r28
    3e0c:	df 93       	push	r29
    3e0e:	cd b7       	in	r28, 0x3d	; 61
    3e10:	de b7       	in	r29, 0x3e	; 62
    3e12:	64 97       	sbiw	r28, 0x14	; 20
    3e14:	cd bf       	out	0x3d, r28	; 61
    3e16:	de bf       	out	0x3e, r29	; 62
    3e18:	2a 01       	movw	r4, r20
    3e1a:	3b 01       	movw	r6, r22
    3e1c:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    3e1e:	f9 01       	movw	r30, r18
    3e20:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    3e22:	41 15       	cp	r20, r1
    3e24:	51 05       	cpc	r21, r1
    3e26:	61 05       	cpc	r22, r1
    3e28:	71 05       	cpc	r23, r1
    3e2a:	09 f4       	brne	.+2      	; 0x3e2e <DeciToString+0x44>
    3e2c:	4d c0       	rjmp	.+154    	; 0x3ec8 <DeciToString+0xde>
    3e2e:	88 2e       	mov	r8, r24
    3e30:	99 2e       	mov	r9, r25
    3e32:	cc 24       	eor	r12, r12
    3e34:	dd 24       	eor	r13, r13
    3e36:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    3e38:	5e 01       	movw	r10, r28
    3e3a:	08 94       	sec
    3e3c:	a1 1c       	adc	r10, r1
    3e3e:	b1 1c       	adc	r11, r1
    3e40:	0f 2e       	mov	r0, r31
    3e42:	f3 e3       	ldi	r31, 0x33	; 51
    3e44:	2f 2e       	mov	r2, r31
    3e46:	f0 e2       	ldi	r31, 0x20	; 32
    3e48:	3f 2e       	mov	r3, r31
    3e4a:	f0 2d       	mov	r31, r0
    3e4c:	f4 01       	movw	r30, r8
    3e4e:	81 91       	ld	r24, Z+
    3e50:	91 91       	ld	r25, Z+
    3e52:	a1 91       	ld	r26, Z+
    3e54:	b1 91       	ld	r27, Z+
    3e56:	4f 01       	movw	r8, r30
    3e58:	2d b7       	in	r18, 0x3d	; 61
    3e5a:	3e b7       	in	r19, 0x3e	; 62
    3e5c:	28 50       	subi	r18, 0x08	; 8
    3e5e:	30 40       	sbci	r19, 0x00	; 0
    3e60:	2d bf       	out	0x3d, r18	; 61
    3e62:	3e bf       	out	0x3e, r19	; 62
    3e64:	2f 5f       	subi	r18, 0xFF	; 255
    3e66:	3f 4f       	sbci	r19, 0xFF	; 255
    3e68:	ed b7       	in	r30, 0x3d	; 61
    3e6a:	fe b7       	in	r31, 0x3e	; 62
    3e6c:	a1 82       	std	Z+1, r10	; 0x01
    3e6e:	b2 82       	std	Z+2, r11	; 0x02
    3e70:	f9 01       	movw	r30, r18
    3e72:	22 82       	std	Z+2, r2	; 0x02
    3e74:	33 82       	std	Z+3, r3	; 0x03
    3e76:	84 83       	std	Z+4, r24	; 0x04
    3e78:	95 83       	std	Z+5, r25	; 0x05
    3e7a:	a6 83       	std	Z+6, r26	; 0x06
    3e7c:	b7 83       	std	Z+7, r27	; 0x07
    3e7e:	0e 94 e1 38 	call	0x71c2	; 0x71c2 <sprintf>
		strcat(ReturnString,b);
    3e82:	2d b7       	in	r18, 0x3d	; 61
    3e84:	3e b7       	in	r19, 0x3e	; 62
    3e86:	28 5f       	subi	r18, 0xF8	; 248
    3e88:	3f 4f       	sbci	r19, 0xFF	; 255
    3e8a:	2d bf       	out	0x3d, r18	; 61
    3e8c:	3e bf       	out	0x3e, r19	; 62
    3e8e:	c8 01       	movw	r24, r16
    3e90:	b5 01       	movw	r22, r10
    3e92:	0e 94 95 38 	call	0x712a	; 0x712a <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    3e96:	a0 2f       	mov	r26, r16
    3e98:	b1 2f       	mov	r27, r17
    3e9a:	fd 01       	movw	r30, r26
    3e9c:	01 90       	ld	r0, Z+
    3e9e:	00 20       	and	r0, r0
    3ea0:	e9 f7       	brne	.-6      	; 0x3e9c <DeciToString+0xb2>
    3ea2:	31 97       	sbiw	r30, 0x01	; 1
    3ea4:	ea 1b       	sub	r30, r26
    3ea6:	fb 0b       	sbc	r31, r27
    3ea8:	e0 0f       	add	r30, r16
    3eaa:	f1 1f       	adc	r31, r17
    3eac:	8a e0       	ldi	r24, 0x0A	; 10
    3eae:	90 e0       	ldi	r25, 0x00	; 0
    3eb0:	80 83       	st	Z, r24
    3eb2:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    3eb4:	08 94       	sec
    3eb6:	c1 1c       	adc	r12, r1
    3eb8:	d1 1c       	adc	r13, r1
    3eba:	e1 1c       	adc	r14, r1
    3ebc:	f1 1c       	adc	r15, r1
    3ebe:	c4 14       	cp	r12, r4
    3ec0:	d5 04       	cpc	r13, r5
    3ec2:	e6 04       	cpc	r14, r6
    3ec4:	f7 04       	cpc	r15, r7
    3ec6:	11 f6       	brne	.-124    	; 0x3e4c <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    3ec8:	64 96       	adiw	r28, 0x14	; 20
    3eca:	cd bf       	out	0x3d, r28	; 61
    3ecc:	de bf       	out	0x3e, r29	; 62
    3ece:	df 91       	pop	r29
    3ed0:	cf 91       	pop	r28
    3ed2:	1f 91       	pop	r17
    3ed4:	0f 91       	pop	r16
    3ed6:	ff 90       	pop	r15
    3ed8:	ef 90       	pop	r14
    3eda:	df 90       	pop	r13
    3edc:	cf 90       	pop	r12
    3ede:	bf 90       	pop	r11
    3ee0:	af 90       	pop	r10
    3ee2:	9f 90       	pop	r9
    3ee4:	8f 90       	pop	r8
    3ee6:	7f 90       	pop	r7
    3ee8:	6f 90       	pop	r6
    3eea:	5f 90       	pop	r5
    3eec:	4f 90       	pop	r4
    3eee:	3f 90       	pop	r3
    3ef0:	2f 90       	pop	r2
    3ef2:	08 95       	ret

00003ef4 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    3ef4:	cf 92       	push	r12
    3ef6:	df 92       	push	r13
    3ef8:	ef 92       	push	r14
    3efa:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3efc:	20 91 7b 50 	lds	r18, 0x507B
    3f00:	30 91 7c 50 	lds	r19, 0x507C
    3f04:	c0 90 db 23 	lds	r12, 0x23DB
    3f08:	d0 90 dc 23 	lds	r13, 0x23DC
    3f0c:	e0 90 dd 23 	lds	r14, 0x23DD
    3f10:	f0 90 de 23 	lds	r15, 0x23DE
    3f14:	62 50       	subi	r22, 0x02	; 2
    3f16:	70 40       	sbci	r23, 0x00	; 0
    3f18:	80 40       	sbci	r24, 0x00	; 0
    3f1a:	90 40       	sbci	r25, 0x00	; 0
    3f1c:	40 e0       	ldi	r20, 0x00	; 0
    3f1e:	50 e0       	ldi	r21, 0x00	; 0
    3f20:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    3f24:	dc 01       	movw	r26, r24
    3f26:	cb 01       	movw	r24, r22
    3f28:	c8 0e       	add	r12, r24
    3f2a:	d9 1e       	adc	r13, r25
    3f2c:	ea 1e       	adc	r14, r26
    3f2e:	fb 1e       	adc	r15, r27
}
    3f30:	6c 2d       	mov	r22, r12
    3f32:	7d 2d       	mov	r23, r13
    3f34:	8e 2d       	mov	r24, r14
    3f36:	9f 2d       	mov	r25, r15
    3f38:	ff 90       	pop	r15
    3f3a:	ef 90       	pop	r14
    3f3c:	df 90       	pop	r13
    3f3e:	cf 90       	pop	r12
    3f40:	08 95       	ret

00003f42 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    3f42:	3f 92       	push	r3
    3f44:	4f 92       	push	r4
    3f46:	5f 92       	push	r5
    3f48:	6f 92       	push	r6
    3f4a:	7f 92       	push	r7
    3f4c:	8f 92       	push	r8
    3f4e:	9f 92       	push	r9
    3f50:	af 92       	push	r10
    3f52:	bf 92       	push	r11
    3f54:	cf 92       	push	r12
    3f56:	df 92       	push	r13
    3f58:	ef 92       	push	r14
    3f5a:	ff 92       	push	r15
    3f5c:	0f 93       	push	r16
    3f5e:	1f 93       	push	r17
    3f60:	cf 93       	push	r28
    3f62:	df 93       	push	r29
    3f64:	00 d0       	rcall	.+0      	; 0x3f66 <getSetNextCluster+0x24>
    3f66:	0f 92       	push	r0
    3f68:	cd b7       	in	r28, 0x3d	; 61
    3f6a:	de b7       	in	r29, 0x3e	; 62
    3f6c:	dc 01       	movw	r26, r24
    3f6e:	cb 01       	movw	r24, r22
    3f70:	34 2e       	mov	r3, r20
    3f72:	09 83       	std	Y+1, r16	; 0x01
    3f74:	1a 83       	std	Y+2, r17	; 0x02
    3f76:	2b 83       	std	Y+3, r18	; 0x03
    3f78:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    3f7a:	80 90 83 50 	lds	r8, 0x5083
    3f7e:	90 90 84 50 	lds	r9, 0x5084
    3f82:	2c 01       	movw	r4, r24
    3f84:	3d 01       	movw	r6, r26
    3f86:	44 0c       	add	r4, r4
    3f88:	55 1c       	adc	r5, r5
    3f8a:	66 1c       	adc	r6, r6
    3f8c:	77 1c       	adc	r7, r7
    3f8e:	44 0c       	add	r4, r4
    3f90:	55 1c       	adc	r5, r5
    3f92:	66 1c       	adc	r6, r6
    3f94:	77 1c       	adc	r7, r7
    3f96:	20 91 54 40 	lds	r18, 0x4054
    3f9a:	30 91 55 40 	lds	r19, 0x4055
    3f9e:	aa 24       	eor	r10, r10
    3fa0:	bb 24       	eor	r11, r11
    3fa2:	80 91 7d 50 	lds	r24, 0x507D
    3fa6:	90 91 7e 50 	lds	r25, 0x507E
    3faa:	a0 91 7f 50 	lds	r26, 0x507F
    3fae:	b0 91 80 50 	lds	r27, 0x5080
    3fb2:	88 0e       	add	r8, r24
    3fb4:	99 1e       	adc	r9, r25
    3fb6:	aa 1e       	adc	r10, r26
    3fb8:	bb 1e       	adc	r11, r27
    3fba:	40 e0       	ldi	r20, 0x00	; 0
    3fbc:	50 e0       	ldi	r21, 0x00	; 0
    3fbe:	c3 01       	movw	r24, r6
    3fc0:	b2 01       	movw	r22, r4
    3fc2:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    3fc6:	69 01       	movw	r12, r18
    3fc8:	7a 01       	movw	r14, r20
    3fca:	c8 0c       	add	r12, r8
    3fcc:	d9 1c       	adc	r13, r9
    3fce:	ea 1c       	adc	r14, r10
    3fd0:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3fd2:	00 91 54 40 	lds	r16, 0x4054
    3fd6:	10 91 55 40 	lds	r17, 0x4055

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    3fda:	c7 01       	movw	r24, r14
    3fdc:	b6 01       	movw	r22, r12
    3fde:	46 ed       	ldi	r20, 0xD6	; 214
    3fe0:	51 e2       	ldi	r21, 0x21	; 33
    3fe2:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3fe6:	98 01       	movw	r18, r16
    3fe8:	40 e0       	ldi	r20, 0x00	; 0
    3fea:	50 e0       	ldi	r21, 0x00	; 0
    3fec:	c3 01       	movw	r24, r6
    3fee:	b2 01       	movw	r22, r4
    3ff0:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    3ff4:	6a 52       	subi	r22, 0x2A	; 42
    3ff6:	7e 4d       	sbci	r23, 0xDE	; 222

if(get_set == GET)
    3ff8:	33 20       	and	r3, r3
    3ffa:	41 f4       	brne	.+16     	; 0x400c <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    3ffc:	db 01       	movw	r26, r22
    3ffe:	0d 91       	ld	r16, X+
    4000:	1d 91       	ld	r17, X+
    4002:	2d 91       	ld	r18, X+
    4004:	3c 91       	ld	r19, X
    4006:	13 97       	sbiw	r26, 0x03	; 3
    4008:	3f 70       	andi	r19, 0x0F	; 15
    400a:	14 c0       	rjmp	.+40     	; 0x4034 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	9a 81       	ldd	r25, Y+2	; 0x02
    4010:	ab 81       	ldd	r26, Y+3	; 0x03
    4012:	bc 81       	ldd	r27, Y+4	; 0x04
    4014:	fb 01       	movw	r30, r22
    4016:	80 83       	st	Z, r24
    4018:	91 83       	std	Z+1, r25	; 0x01
    401a:	a2 83       	std	Z+2, r26	; 0x02
    401c:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    401e:	c7 01       	movw	r24, r14
    4020:	b6 01       	movw	r22, r12
    4022:	46 ed       	ldi	r20, 0xD6	; 214
    4024:	51 e2       	ldi	r21, 0x21	; 33
    4026:	20 e0       	ldi	r18, 0x00	; 0
    4028:	32 e0       	ldi	r19, 0x02	; 2
    402a:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SD_write_block>

return (0);
    402e:	00 e0       	ldi	r16, 0x00	; 0
    4030:	10 e0       	ldi	r17, 0x00	; 0
    4032:	98 01       	movw	r18, r16
}
    4034:	60 2f       	mov	r22, r16
    4036:	71 2f       	mov	r23, r17
    4038:	82 2f       	mov	r24, r18
    403a:	93 2f       	mov	r25, r19
    403c:	24 96       	adiw	r28, 0x04	; 4
    403e:	cd bf       	out	0x3d, r28	; 61
    4040:	de bf       	out	0x3e, r29	; 62
    4042:	df 91       	pop	r29
    4044:	cf 91       	pop	r28
    4046:	1f 91       	pop	r17
    4048:	0f 91       	pop	r16
    404a:	ff 90       	pop	r15
    404c:	ef 90       	pop	r14
    404e:	df 90       	pop	r13
    4050:	cf 90       	pop	r12
    4052:	bf 90       	pop	r11
    4054:	af 90       	pop	r10
    4056:	9f 90       	pop	r9
    4058:	8f 90       	pop	r8
    405a:	7f 90       	pop	r7
    405c:	6f 90       	pop	r6
    405e:	5f 90       	pop	r5
    4060:	4f 90       	pop	r4
    4062:	3f 90       	pop	r3
    4064:	08 95       	ret

00004066 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    4066:	cf 92       	push	r12
    4068:	df 92       	push	r13
    406a:	ef 92       	push	r14
    406c:	ff 92       	push	r15
    406e:	0f 93       	push	r16
    4070:	1f 93       	push	r17
    4072:	cf 93       	push	r28
    4074:	c8 2f       	mov	r28, r24
    4076:	06 2f       	mov	r16, r22
    4078:	69 01       	movw	r12, r18
    407a:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    407c:	80 91 7d 50 	lds	r24, 0x507D
    4080:	90 91 7e 50 	lds	r25, 0x507E
    4084:	a0 91 7f 50 	lds	r26, 0x507F
    4088:	b0 91 80 50 	lds	r27, 0x5080
    408c:	bc 01       	movw	r22, r24
    408e:	cd 01       	movw	r24, r26
    4090:	6f 5f       	subi	r22, 0xFF	; 255
    4092:	7f 4f       	sbci	r23, 0xFF	; 255
    4094:	8f 4f       	sbci	r24, 0xFF	; 255
    4096:	9f 4f       	sbci	r25, 0xFF	; 255
    4098:	46 ed       	ldi	r20, 0xD6	; 214
    409a:	51 e2       	ldi	r21, 0x21	; 33
    409c:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    40a0:	80 91 d6 21 	lds	r24, 0x21D6
    40a4:	90 91 d7 21 	lds	r25, 0x21D7
    40a8:	a0 91 d8 21 	lds	r26, 0x21D8
    40ac:	b0 91 d9 21 	lds	r27, 0x21D9
    40b0:	82 35       	cpi	r24, 0x52	; 82
    40b2:	22 e5       	ldi	r18, 0x52	; 82
    40b4:	92 07       	cpc	r25, r18
    40b6:	21 e6       	ldi	r18, 0x61	; 97
    40b8:	a2 07       	cpc	r26, r18
    40ba:	21 e4       	ldi	r18, 0x41	; 65
    40bc:	b2 07       	cpc	r27, r18
    40be:	09 f0       	breq	.+2      	; 0x40c2 <getSetFreeCluster+0x5c>
    40c0:	63 c0       	rjmp	.+198    	; 0x4188 <getSetFreeCluster+0x122>
    40c2:	80 91 ba 23 	lds	r24, 0x23BA
    40c6:	90 91 bb 23 	lds	r25, 0x23BB
    40ca:	a0 91 bc 23 	lds	r26, 0x23BC
    40ce:	b0 91 bd 23 	lds	r27, 0x23BD
    40d2:	82 37       	cpi	r24, 0x72	; 114
    40d4:	22 e7       	ldi	r18, 0x72	; 114
    40d6:	92 07       	cpc	r25, r18
    40d8:	21 e4       	ldi	r18, 0x41	; 65
    40da:	a2 07       	cpc	r26, r18
    40dc:	21 e6       	ldi	r18, 0x61	; 97
    40de:	b2 07       	cpc	r27, r18
    40e0:	09 f0       	breq	.+2      	; 0x40e4 <getSetFreeCluster+0x7e>
    40e2:	56 c0       	rjmp	.+172    	; 0x4190 <getSetFreeCluster+0x12a>
    40e4:	80 91 d2 23 	lds	r24, 0x23D2
    40e8:	90 91 d3 23 	lds	r25, 0x23D3
    40ec:	a0 91 d4 23 	lds	r26, 0x23D4
    40f0:	b0 91 d5 23 	lds	r27, 0x23D5
    40f4:	80 30       	cpi	r24, 0x00	; 0
    40f6:	20 e0       	ldi	r18, 0x00	; 0
    40f8:	92 07       	cpc	r25, r18
    40fa:	25 e5       	ldi	r18, 0x55	; 85
    40fc:	a2 07       	cpc	r26, r18
    40fe:	2a ea       	ldi	r18, 0xAA	; 170
    4100:	b2 07       	cpc	r27, r18
    4102:	09 f0       	breq	.+2      	; 0x4106 <getSetFreeCluster+0xa0>
    4104:	49 c0       	rjmp	.+146    	; 0x4198 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4106:	00 23       	and	r16, r16
    4108:	a1 f4       	brne	.+40     	; 0x4132 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    410a:	c1 30       	cpi	r28, 0x01	; 1
    410c:	49 f4       	brne	.+18     	; 0x4120 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    410e:	00 91 be 23 	lds	r16, 0x23BE
    4112:	10 91 bf 23 	lds	r17, 0x23BF
    4116:	20 91 c0 23 	lds	r18, 0x23C0
    411a:	30 91 c1 23 	lds	r19, 0x23C1
    411e:	3f c0       	rjmp	.+126    	; 0x419e <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    4120:	00 91 c2 23 	lds	r16, 0x23C2
    4124:	10 91 c3 23 	lds	r17, 0x23C3
    4128:	20 91 c4 23 	lds	r18, 0x23C4
    412c:	30 91 c5 23 	lds	r19, 0x23C5
    4130:	36 c0       	rjmp	.+108    	; 0x419e <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4132:	c1 30       	cpi	r28, 0x01	; 1
    4134:	49 f4       	brne	.+18     	; 0x4148 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    4136:	c0 92 be 23 	sts	0x23BE, r12
    413a:	d0 92 bf 23 	sts	0x23BF, r13
    413e:	e0 92 c0 23 	sts	0x23C0, r14
    4142:	f0 92 c1 23 	sts	0x23C1, r15
    4146:	08 c0       	rjmp	.+16     	; 0x4158 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    4148:	c0 92 c2 23 	sts	0x23C2, r12
    414c:	d0 92 c3 23 	sts	0x23C3, r13
    4150:	e0 92 c4 23 	sts	0x23C4, r14
    4154:	f0 92 c5 23 	sts	0x23C5, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4158:	80 91 7d 50 	lds	r24, 0x507D
    415c:	90 91 7e 50 	lds	r25, 0x507E
    4160:	a0 91 7f 50 	lds	r26, 0x507F
    4164:	b0 91 80 50 	lds	r27, 0x5080
    4168:	bc 01       	movw	r22, r24
    416a:	cd 01       	movw	r24, r26
    416c:	6f 5f       	subi	r22, 0xFF	; 255
    416e:	7f 4f       	sbci	r23, 0xFF	; 255
    4170:	8f 4f       	sbci	r24, 0xFF	; 255
    4172:	9f 4f       	sbci	r25, 0xFF	; 255
    4174:	46 ed       	ldi	r20, 0xD6	; 214
    4176:	51 e2       	ldi	r21, 0x21	; 33
    4178:	20 e0       	ldi	r18, 0x00	; 0
    417a:	32 e0       	ldi	r19, 0x02	; 2
    417c:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SD_write_block>
 }
 return 0xffffffff;
    4180:	0f ef       	ldi	r16, 0xFF	; 255
    4182:	1f ef       	ldi	r17, 0xFF	; 255
    4184:	98 01       	movw	r18, r16
    4186:	0b c0       	rjmp	.+22     	; 0x419e <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    4188:	0f ef       	ldi	r16, 0xFF	; 255
    418a:	1f ef       	ldi	r17, 0xFF	; 255
    418c:	98 01       	movw	r18, r16
    418e:	07 c0       	rjmp	.+14     	; 0x419e <getSetFreeCluster+0x138>
    4190:	0f ef       	ldi	r16, 0xFF	; 255
    4192:	1f ef       	ldi	r17, 0xFF	; 255
    4194:	98 01       	movw	r18, r16
    4196:	03 c0       	rjmp	.+6      	; 0x419e <getSetFreeCluster+0x138>
    4198:	0f ef       	ldi	r16, 0xFF	; 255
    419a:	1f ef       	ldi	r17, 0xFF	; 255
    419c:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    419e:	60 2f       	mov	r22, r16
    41a0:	71 2f       	mov	r23, r17
    41a2:	82 2f       	mov	r24, r18
    41a4:	93 2f       	mov	r25, r19
    41a6:	cf 91       	pop	r28
    41a8:	1f 91       	pop	r17
    41aa:	0f 91       	pop	r16
    41ac:	ff 90       	pop	r15
    41ae:	ef 90       	pop	r14
    41b0:	df 90       	pop	r13
    41b2:	cf 90       	pop	r12
    41b4:	08 95       	ret

000041b6 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    41b6:	ef 92       	push	r14
    41b8:	ff 92       	push	r15
    41ba:	0f 93       	push	r16
    41bc:	1f 93       	push	r17
    41be:	cf 93       	push	r28
    41c0:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    41c2:	10 92 7d 50 	sts	0x507D, r1
    41c6:	10 92 7e 50 	sts	0x507E, r1
    41ca:	10 92 7f 50 	sts	0x507F, r1
    41ce:	10 92 80 50 	sts	0x5080, r1

SD_read_block(0,SDBuffer);
    41d2:	60 e0       	ldi	r22, 0x00	; 0
    41d4:	70 e0       	ldi	r23, 0x00	; 0
    41d6:	cb 01       	movw	r24, r22
    41d8:	46 ed       	ldi	r20, 0xD6	; 214
    41da:	51 e2       	ldi	r21, 0x21	; 33
    41dc:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    41e0:	80 91 d6 21 	lds	r24, 0x21D6
    41e4:	89 3e       	cpi	r24, 0xE9	; 233
    41e6:	31 f1       	breq	.+76     	; 0x4234 <getBootSectorData+0x7e>
    41e8:	8b 3e       	cpi	r24, 0xEB	; 235
    41ea:	21 f1       	breq	.+72     	; 0x4234 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    41ec:	80 91 d4 23 	lds	r24, 0x23D4
    41f0:	90 91 d5 23 	lds	r25, 0x23D5
    41f4:	2a ea       	ldi	r18, 0xAA	; 170
    41f6:	85 35       	cpi	r24, 0x55	; 85
    41f8:	92 07       	cpc	r25, r18
    41fa:	09 f0       	breq	.+2      	; 0x41fe <getBootSectorData+0x48>
    41fc:	b7 c0       	rjmp	.+366    	; 0x436c <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    41fe:	60 91 9c 23 	lds	r22, 0x239C
    4202:	70 91 9d 23 	lds	r23, 0x239D
    4206:	80 91 9e 23 	lds	r24, 0x239E
    420a:	90 91 9f 23 	lds	r25, 0x239F
    420e:	60 93 7d 50 	sts	0x507D, r22
    4212:	70 93 7e 50 	sts	0x507E, r23
    4216:	80 93 7f 50 	sts	0x507F, r24
    421a:	90 93 80 50 	sts	0x5080, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    421e:	46 ed       	ldi	r20, 0xD6	; 214
    4220:	51 e2       	ldi	r21, 0x21	; 33
    4222:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4226:	80 91 d6 21 	lds	r24, 0x21D6
    422a:	89 3e       	cpi	r24, 0xE9	; 233
    422c:	19 f0       	breq	.+6      	; 0x4234 <getBootSectorData+0x7e>
    422e:	8b 3e       	cpi	r24, 0xEB	; 235
    4230:	09 f0       	breq	.+2      	; 0x4234 <getBootSectorData+0x7e>
    4232:	9e c0       	rjmp	.+316    	; 0x4370 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4234:	80 91 e1 21 	lds	r24, 0x21E1
    4238:	90 91 e2 21 	lds	r25, 0x21E2
    423c:	80 93 54 40 	sts	0x4054, r24
    4240:	90 93 55 40 	sts	0x4055, r25
sectorPerCluster = bpb->sectorPerCluster;
    4244:	80 91 e3 21 	lds	r24, 0x21E3
    4248:	90 e0       	ldi	r25, 0x00	; 0
    424a:	80 93 7b 50 	sts	0x507B, r24
    424e:	90 93 7c 50 	sts	0x507C, r25
reservedSectorCount = bpb->reservedSectorCount;
    4252:	e0 90 e4 21 	lds	r14, 0x21E4
    4256:	f0 90 e5 21 	lds	r15, 0x21E5
    425a:	e0 92 83 50 	sts	0x5083, r14
    425e:	f0 92 84 50 	sts	0x5084, r15
rootCluster = bpb->rootCluster;
    4262:	80 91 02 22 	lds	r24, 0x2202
    4266:	90 91 03 22 	lds	r25, 0x2203
    426a:	a0 91 04 22 	lds	r26, 0x2204
    426e:	b0 91 05 22 	lds	r27, 0x2205
    4272:	80 93 5f 40 	sts	0x405F, r24
    4276:	90 93 60 40 	sts	0x4060, r25
    427a:	a0 93 61 40 	sts	0x4061, r26
    427e:	b0 93 62 40 	sts	0x4062, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    4282:	c0 91 83 50 	lds	r28, 0x5083
    4286:	d0 91 84 50 	lds	r29, 0x5084
    428a:	60 91 e6 21 	lds	r22, 0x21E6
    428e:	70 e0       	ldi	r23, 0x00	; 0
    4290:	80 e0       	ldi	r24, 0x00	; 0
    4292:	90 e0       	ldi	r25, 0x00	; 0
    4294:	20 91 fa 21 	lds	r18, 0x21FA
    4298:	30 91 fb 21 	lds	r19, 0x21FB
    429c:	40 91 fc 21 	lds	r20, 0x21FC
    42a0:	50 91 fd 21 	lds	r21, 0x21FD
    42a4:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    42a8:	8b 01       	movw	r16, r22
    42aa:	9c 01       	movw	r18, r24
    42ac:	ae 01       	movw	r20, r28
    42ae:	60 e0       	ldi	r22, 0x00	; 0
    42b0:	70 e0       	ldi	r23, 0x00	; 0
    42b2:	80 91 f2 21 	lds	r24, 0x21F2
    42b6:	90 91 f3 21 	lds	r25, 0x21F3
    42ba:	a0 91 f4 21 	lds	r26, 0x21F4
    42be:	b0 91 f5 21 	lds	r27, 0x21F5
    42c2:	84 0f       	add	r24, r20
    42c4:	95 1f       	adc	r25, r21
    42c6:	a6 1f       	adc	r26, r22
    42c8:	b7 1f       	adc	r27, r23
    42ca:	80 0f       	add	r24, r16
    42cc:	91 1f       	adc	r25, r17
    42ce:	a2 1f       	adc	r26, r18
    42d0:	b3 1f       	adc	r27, r19
    42d2:	80 93 db 23 	sts	0x23DB, r24
    42d6:	90 93 dc 23 	sts	0x23DC, r25
    42da:	a0 93 dd 23 	sts	0x23DD, r26
    42de:	b0 93 de 23 	sts	0x23DE, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    42e2:	e0 91 7b 50 	lds	r30, 0x507B
    42e6:	f0 91 7c 50 	lds	r31, 0x507C
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    42ea:	c7 01       	movw	r24, r14
    42ec:	a0 e0       	ldi	r26, 0x00	; 0
    42ee:	b0 e0       	ldi	r27, 0x00	; 0
    42f0:	40 91 f6 21 	lds	r20, 0x21F6
    42f4:	50 91 f7 21 	lds	r21, 0x21F7
    42f8:	60 91 f8 21 	lds	r22, 0x21F8
    42fc:	70 91 f9 21 	lds	r23, 0x21F9
    4300:	48 1b       	sub	r20, r24
    4302:	59 0b       	sbc	r21, r25
    4304:	6a 0b       	sbc	r22, r26
    4306:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4308:	cb 01       	movw	r24, r22
    430a:	ba 01       	movw	r22, r20
    430c:	60 1b       	sub	r22, r16
    430e:	71 0b       	sbc	r23, r17
    4310:	82 0b       	sbc	r24, r18
    4312:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4314:	9f 01       	movw	r18, r30
    4316:	40 e0       	ldi	r20, 0x00	; 0
    4318:	50 e0       	ldi	r21, 0x00	; 0
    431a:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    431e:	20 93 59 40 	sts	0x4059, r18
    4322:	30 93 5a 40 	sts	0x405A, r19
    4326:	40 93 5b 40 	sts	0x405B, r20
    432a:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    432e:	81 e0       	ldi	r24, 0x01	; 1
    4330:	60 e0       	ldi	r22, 0x00	; 0
    4332:	20 e0       	ldi	r18, 0x00	; 0
    4334:	30 e0       	ldi	r19, 0x00	; 0
    4336:	a9 01       	movw	r20, r18
    4338:	0e 94 33 20 	call	0x4066	; 0x4066 <getSetFreeCluster>
    433c:	ab 01       	movw	r20, r22
    433e:	bc 01       	movw	r22, r24
    4340:	80 91 59 40 	lds	r24, 0x4059
    4344:	90 91 5a 40 	lds	r25, 0x405A
    4348:	a0 91 5b 40 	lds	r26, 0x405B
    434c:	b0 91 5c 40 	lds	r27, 0x405C
    4350:	84 17       	cp	r24, r20
    4352:	95 07       	cpc	r25, r21
    4354:	a6 07       	cpc	r26, r22
    4356:	b7 07       	cpc	r27, r23
    4358:	20 f4       	brcc	.+8      	; 0x4362 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    435a:	10 92 cf 50 	sts	0x50CF, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    435e:	80 e0       	ldi	r24, 0x00	; 0
    4360:	08 c0       	rjmp	.+16     	; 0x4372 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4362:	81 e0       	ldi	r24, 0x01	; 1
    4364:	80 93 cf 50 	sts	0x50CF, r24
return 0;
    4368:	80 e0       	ldi	r24, 0x00	; 0
    436a:	03 c0       	rjmp	.+6      	; 0x4372 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    436c:	81 e0       	ldi	r24, 0x01	; 1
    436e:	01 c0       	rjmp	.+2      	; 0x4372 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4370:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4372:	df 91       	pop	r29
    4374:	cf 91       	pop	r28
    4376:	1f 91       	pop	r17
    4378:	0f 91       	pop	r16
    437a:	ff 90       	pop	r15
    437c:	ef 90       	pop	r14
    437e:	08 95       	ret

00004380 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4380:	0f 93       	push	r16
    4382:	1f 93       	push	r17
    4384:	cf 93       	push	r28
    4386:	df 93       	push	r29
    4388:	cd b7       	in	r28, 0x3d	; 61
    438a:	de b7       	in	r29, 0x3e	; 62
    438c:	2b 97       	sbiw	r28, 0x0b	; 11
    438e:	cd bf       	out	0x3d, r28	; 61
    4390:	de bf       	out	0x3e, r29	; 62
    4392:	78 2f       	mov	r23, r24
    4394:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4396:	e8 2f       	mov	r30, r24
    4398:	f9 2f       	mov	r31, r25
    439a:	df 01       	movw	r26, r30
    439c:	0d 90       	ld	r0, X+
    439e:	00 20       	and	r0, r0
    43a0:	e9 f7       	brne	.-6      	; 0x439c <convertFileName+0x1c>
    43a2:	11 97       	sbiw	r26, 0x01	; 1
    43a4:	ae 1b       	sub	r26, r30
    43a6:	bf 0b       	sbc	r27, r31
    43a8:	a0 31       	cpi	r26, 0x10	; 16
    43aa:	b1 05       	cpc	r27, r1
    43ac:	08 f0       	brcs	.+2      	; 0x43b0 <convertFileName+0x30>
    43ae:	9c c0       	rjmp	.+312    	; 0x44e8 <convertFileName+0x168>
    43b0:	28 2f       	mov	r18, r24
    43b2:	39 2f       	mov	r19, r25
    43b4:	0b eb       	ldi	r16, 0xBB	; 187
    43b6:	10 e5       	ldi	r17, 0x50	; 80
    43b8:	a8 01       	movw	r20, r16
    43ba:	80 e0       	ldi	r24, 0x00	; 0
    43bc:	90 e0       	ldi	r25, 0x00	; 0
    43be:	07 c0       	rjmp	.+14     	; 0x43ce <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    43c0:	d9 01       	movw	r26, r18
    43c2:	ed 91       	ld	r30, X+
    43c4:	9d 01       	movw	r18, r26
    43c6:	da 01       	movw	r26, r20
    43c8:	ed 93       	st	X+, r30
    43ca:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    43cc:	01 96       	adiw	r24, 0x01	; 1
    43ce:	a7 2f       	mov	r26, r23
    43d0:	b6 2f       	mov	r27, r22
    43d2:	fd 01       	movw	r30, r26
    43d4:	01 90       	ld	r0, Z+
    43d6:	00 20       	and	r0, r0
    43d8:	e9 f7       	brne	.-6      	; 0x43d4 <convertFileName+0x54>
    43da:	31 97       	sbiw	r30, 0x01	; 1
    43dc:	ea 1b       	sub	r30, r26
    43de:	fb 0b       	sbc	r31, r27
    43e0:	8e 17       	cp	r24, r30
    43e2:	9f 07       	cpc	r25, r31
    43e4:	68 f3       	brcs	.-38     	; 0x43c0 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    43e6:	8f 30       	cpi	r24, 0x0F	; 15
    43e8:	91 05       	cpc	r25, r1
    43ea:	54 f4       	brge	.+20     	; 0x4400 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    43ec:	fc 01       	movw	r30, r24
    43ee:	e5 54       	subi	r30, 0x45	; 69
    43f0:	ff 4a       	sbci	r31, 0xAF	; 175
    43f2:	8a ec       	ldi	r24, 0xCA	; 202
    43f4:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    43f6:	20 e2       	ldi	r18, 0x20	; 32
    43f8:	21 93       	st	Z+, r18
    43fa:	e8 17       	cp	r30, r24
    43fc:	f9 07       	cpc	r31, r25
    43fe:	e1 f7       	brne	.-8      	; 0x43f8 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4400:	80 91 bb 50 	lds	r24, 0x50BB
    4404:	8e 32       	cpi	r24, 0x2E	; 46
    4406:	91 f0       	breq	.+36     	; 0x442c <convertFileName+0xac>
    4408:	ec eb       	ldi	r30, 0xBC	; 188
    440a:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    440c:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    440e:	81 91       	ld	r24, Z+
    4410:	8e 32       	cpi	r24, 0x2E	; 46
    4412:	21 f0       	breq	.+8      	; 0x441c <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4414:	2f 5f       	subi	r18, 0xFF	; 255
    4416:	2c 30       	cpi	r18, 0x0C	; 12
    4418:	d1 f7       	brne	.-12     	; 0x440e <convertFileName+0x8e>
    441a:	05 c0       	rjmp	.+10     	; 0x4426 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    441c:	82 2f       	mov	r24, r18
    441e:	89 50       	subi	r24, 0x09	; 9
    4420:	83 30       	cpi	r24, 0x03	; 3
    4422:	08 f4       	brcc	.+2      	; 0x4426 <convertFileName+0xa6>
    4424:	63 c0       	rjmp	.+198    	; 0x44ec <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4426:	22 23       	and	r18, r18
    4428:	29 f4       	brne	.+10     	; 0x4434 <convertFileName+0xb4>
    442a:	01 c0       	rjmp	.+2      	; 0x442e <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    442c:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    442e:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    4430:	90 e2       	ldi	r25, 0x20	; 32
    4432:	10 c0       	rjmp	.+32     	; 0x4454 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4434:	de 01       	movw	r26, r28
    4436:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4438:	82 2f       	mov	r24, r18
    443a:	81 50       	subi	r24, 0x01	; 1
    443c:	90 e0       	ldi	r25, 0x00	; 0
    443e:	84 54       	subi	r24, 0x44	; 68
    4440:	9f 4a       	sbci	r25, 0xAF	; 175
    4442:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    4444:	31 91       	ld	r19, Z+
    4446:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4448:	e8 17       	cp	r30, r24
    444a:	f9 07       	cpc	r31, r25
    444c:	d9 f7       	brne	.-10     	; 0x4444 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    444e:	28 30       	cpi	r18, 0x08	; 8
    4450:	70 f3       	brcs	.-36     	; 0x442e <convertFileName+0xae>
    4452:	0a c0       	rjmp	.+20     	; 0x4468 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    4454:	e1 e0       	ldi	r30, 0x01	; 1
    4456:	f0 e0       	ldi	r31, 0x00	; 0
    4458:	ec 0f       	add	r30, r28
    445a:	fd 1f       	adc	r31, r29
    445c:	e8 0f       	add	r30, r24
    445e:	f1 1d       	adc	r31, r1
    4460:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4462:	8f 5f       	subi	r24, 0xFF	; 255
    4464:	88 30       	cpi	r24, 0x08	; 8
    4466:	b0 f3       	brcs	.-20     	; 0x4454 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4468:	2c 30       	cpi	r18, 0x0C	; 12
    446a:	09 f0       	breq	.+2      	; 0x446e <convertFileName+0xee>
    446c:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    446e:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4470:	8b eb       	ldi	r24, 0xBB	; 187
    4472:	90 e5       	ldi	r25, 0x50	; 80
    4474:	fc 01       	movw	r30, r24
    4476:	e2 0f       	add	r30, r18
    4478:	f1 1d       	adc	r31, r1
    447a:	40 81       	ld	r20, Z
    447c:	44 23       	and	r20, r20
    447e:	19 f4       	brne	.+6      	; 0x4486 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4480:	3b 30       	cpi	r19, 0x0B	; 11
    4482:	50 f0       	brcs	.+20     	; 0x4498 <convertFileName+0x118>
    4484:	15 c0       	rjmp	.+42     	; 0x44b0 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    4486:	e1 e0       	ldi	r30, 0x01	; 1
    4488:	f0 e0       	ldi	r31, 0x00	; 0
    448a:	ec 0f       	add	r30, r28
    448c:	fd 1f       	adc	r31, r29
    448e:	e3 0f       	add	r30, r19
    4490:	f1 1d       	adc	r31, r1
    4492:	40 83       	st	Z, r20
    4494:	2f 5f       	subi	r18, 0xFF	; 255
    4496:	0c c0       	rjmp	.+24     	; 0x44b0 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4498:	80 e2       	ldi	r24, 0x20	; 32
    449a:	e1 e0       	ldi	r30, 0x01	; 1
    449c:	f0 e0       	ldi	r31, 0x00	; 0
    449e:	ec 0f       	add	r30, r28
    44a0:	fd 1f       	adc	r31, r29
    44a2:	e3 0f       	add	r30, r19
    44a4:	f1 1d       	adc	r31, r1
    44a6:	80 83       	st	Z, r24
    44a8:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    44aa:	3b 30       	cpi	r19, 0x0B	; 11
    44ac:	b1 f7       	brne	.-20     	; 0x449a <convertFileName+0x11a>
    44ae:	03 c0       	rjmp	.+6      	; 0x44b6 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    44b0:	3f 5f       	subi	r19, 0xFF	; 255
    44b2:	3b 30       	cpi	r19, 0x0B	; 11
    44b4:	f8 f2       	brcs	.-66     	; 0x4474 <convertFileName+0xf4>
    44b6:	de 01       	movw	r26, r28
    44b8:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    44ba:	ce 01       	movw	r24, r28
    44bc:	0c 96       	adiw	r24, 0x0c	; 12
    44be:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    44c0:	20 81       	ld	r18, Z
    44c2:	32 2f       	mov	r19, r18
    44c4:	31 56       	subi	r19, 0x61	; 97
    44c6:	3a 31       	cpi	r19, 0x1A	; 26
    44c8:	10 f4       	brcc	.+4      	; 0x44ce <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    44ca:	20 52       	subi	r18, 0x20	; 32
    44cc:	20 83       	st	Z, r18
    44ce:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    44d0:	e8 17       	cp	r30, r24
    44d2:	f9 07       	cpc	r31, r25
    44d4:	a9 f7       	brne	.-22     	; 0x44c0 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    44d6:	2d 91       	ld	r18, X+
    44d8:	f8 01       	movw	r30, r16
    44da:	21 93       	st	Z+, r18
    44dc:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    44de:	a8 17       	cp	r26, r24
    44e0:	b9 07       	cpc	r27, r25
    44e2:	c9 f7       	brne	.-14     	; 0x44d6 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    44e4:	80 e0       	ldi	r24, 0x00	; 0
    44e6:	03 c0       	rjmp	.+6      	; 0x44ee <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    44e8:	81 e0       	ldi	r24, 0x01	; 1
    44ea:	01 c0       	rjmp	.+2      	; 0x44ee <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    44ec:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    44ee:	2b 96       	adiw	r28, 0x0b	; 11
    44f0:	cd bf       	out	0x3d, r28	; 61
    44f2:	de bf       	out	0x3e, r29	; 62
    44f4:	df 91       	pop	r29
    44f6:	cf 91       	pop	r28
    44f8:	1f 91       	pop	r17
    44fa:	0f 91       	pop	r16
    44fc:	08 95       	ret

000044fe <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    44fe:	4f 92       	push	r4
    4500:	5f 92       	push	r5
    4502:	6f 92       	push	r6
    4504:	7f 92       	push	r7
    4506:	8f 92       	push	r8
    4508:	9f 92       	push	r9
    450a:	af 92       	push	r10
    450c:	bf 92       	push	r11
    450e:	cf 92       	push	r12
    4510:	df 92       	push	r13
    4512:	ef 92       	push	r14
    4514:	ff 92       	push	r15
    4516:	cf 93       	push	r28
    4518:	df 93       	push	r29
    451a:	2b 01       	movw	r4, r22
    451c:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    451e:	20 e8       	ldi	r18, 0x80	; 128
    4520:	3f ef       	ldi	r19, 0xFF	; 255
    4522:	4f ef       	ldi	r20, 0xFF	; 255
    4524:	5f ef       	ldi	r21, 0xFF	; 255
    4526:	42 22       	and	r4, r18
    4528:	53 22       	and	r5, r19
    452a:	64 22       	and	r6, r20
    452c:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    452e:	80 91 59 40 	lds	r24, 0x4059
    4532:	90 91 5a 40 	lds	r25, 0x405A
    4536:	a0 91 5b 40 	lds	r26, 0x405B
    453a:	b0 91 5c 40 	lds	r27, 0x405C
    453e:	48 16       	cp	r4, r24
    4540:	59 06       	cpc	r5, r25
    4542:	6a 06       	cpc	r6, r26
    4544:	7b 06       	cpc	r7, r27
    4546:	08 f0       	brcs	.+2      	; 0x454a <searchNextFreeCluster+0x4c>
    4548:	77 c0       	rjmp	.+238    	; 0x4638 <searchNextFreeCluster+0x13a>
    454a:	53 01       	movw	r10, r6
    454c:	42 01       	movw	r8, r4
    454e:	88 0c       	add	r8, r8
    4550:	99 1c       	adc	r9, r9
    4552:	aa 1c       	adc	r10, r10
    4554:	bb 1c       	adc	r11, r11
    4556:	88 0c       	add	r8, r8
    4558:	99 1c       	adc	r9, r9
    455a:	aa 1c       	adc	r10, r10
    455c:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    455e:	c6 ed       	ldi	r28, 0xD6	; 214
    4560:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4562:	c0 90 83 50 	lds	r12, 0x5083
    4566:	d0 90 84 50 	lds	r13, 0x5084
    456a:	20 91 54 40 	lds	r18, 0x4054
    456e:	30 91 55 40 	lds	r19, 0x4055
    4572:	ee 24       	eor	r14, r14
    4574:	ff 24       	eor	r15, r15
    4576:	80 91 7d 50 	lds	r24, 0x507D
    457a:	90 91 7e 50 	lds	r25, 0x507E
    457e:	a0 91 7f 50 	lds	r26, 0x507F
    4582:	b0 91 80 50 	lds	r27, 0x5080
    4586:	c8 0e       	add	r12, r24
    4588:	d9 1e       	adc	r13, r25
    458a:	ea 1e       	adc	r14, r26
    458c:	fb 1e       	adc	r15, r27
    458e:	40 e0       	ldi	r20, 0x00	; 0
    4590:	50 e0       	ldi	r21, 0x00	; 0
    4592:	c5 01       	movw	r24, r10
    4594:	b4 01       	movw	r22, r8
    4596:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    459a:	c7 01       	movw	r24, r14
    459c:	b6 01       	movw	r22, r12
    459e:	62 0f       	add	r22, r18
    45a0:	73 1f       	adc	r23, r19
    45a2:	84 1f       	adc	r24, r20
    45a4:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    45a6:	ae 01       	movw	r20, r28
    45a8:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    45ac:	88 81       	ld	r24, Y
    45ae:	99 81       	ldd	r25, Y+1	; 0x01
    45b0:	aa 81       	ldd	r26, Y+2	; 0x02
    45b2:	bb 81       	ldd	r27, Y+3	; 0x03
    45b4:	bf 70       	andi	r27, 0x0F	; 15
    45b6:	00 97       	sbiw	r24, 0x00	; 0
    45b8:	a1 05       	cpc	r26, r1
    45ba:	b1 05       	cpc	r27, r1
    45bc:	99 f0       	breq	.+38     	; 0x45e4 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45be:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    45c0:	e2 2f       	mov	r30, r18
    45c2:	f0 e0       	ldi	r31, 0x00	; 0
    45c4:	ee 0f       	add	r30, r30
    45c6:	ff 1f       	adc	r31, r31
    45c8:	ee 0f       	add	r30, r30
    45ca:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    45cc:	ea 52       	subi	r30, 0x2A	; 42
    45ce:	fe 4d       	sbci	r31, 0xDE	; 222
    45d0:	80 81       	ld	r24, Z
    45d2:	91 81       	ldd	r25, Z+1	; 0x01
    45d4:	a2 81       	ldd	r26, Z+2	; 0x02
    45d6:	b3 81       	ldd	r27, Z+3	; 0x03
    45d8:	bf 70       	andi	r27, 0x0F	; 15
    45da:	00 97       	sbiw	r24, 0x00	; 0
    45dc:	a1 05       	cpc	r26, r1
    45de:	b1 05       	cpc	r27, r1
    45e0:	39 f4       	brne	.+14     	; 0x45f0 <searchNextFreeCluster+0xf2>
    45e2:	01 c0       	rjmp	.+2      	; 0x45e6 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45e4:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    45e6:	42 0e       	add	r4, r18
    45e8:	51 1c       	adc	r5, r1
    45ea:	61 1c       	adc	r6, r1
    45ec:	71 1c       	adc	r7, r1
    45ee:	27 c0       	rjmp	.+78     	; 0x463e <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45f0:	2f 5f       	subi	r18, 0xFF	; 255
    45f2:	32 f7       	brpl	.-52     	; 0x45c0 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    45f4:	80 e8       	ldi	r24, 0x80	; 128
    45f6:	90 e0       	ldi	r25, 0x00	; 0
    45f8:	a0 e0       	ldi	r26, 0x00	; 0
    45fa:	b0 e0       	ldi	r27, 0x00	; 0
    45fc:	48 0e       	add	r4, r24
    45fe:	59 1e       	adc	r5, r25
    4600:	6a 1e       	adc	r6, r26
    4602:	7b 1e       	adc	r7, r27
    4604:	80 91 59 40 	lds	r24, 0x4059
    4608:	90 91 5a 40 	lds	r25, 0x405A
    460c:	a0 91 5b 40 	lds	r26, 0x405B
    4610:	b0 91 5c 40 	lds	r27, 0x405C
    4614:	20 e0       	ldi	r18, 0x00	; 0
    4616:	32 e0       	ldi	r19, 0x02	; 2
    4618:	40 e0       	ldi	r20, 0x00	; 0
    461a:	50 e0       	ldi	r21, 0x00	; 0
    461c:	82 0e       	add	r8, r18
    461e:	93 1e       	adc	r9, r19
    4620:	a4 1e       	adc	r10, r20
    4622:	b5 1e       	adc	r11, r21
    4624:	48 16       	cp	r4, r24
    4626:	59 06       	cpc	r5, r25
    4628:	6a 06       	cpc	r6, r26
    462a:	7b 06       	cpc	r7, r27
    462c:	08 f4       	brcc	.+2      	; 0x4630 <searchNextFreeCluster+0x132>
    462e:	99 cf       	rjmp	.-206    	; 0x4562 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4630:	44 24       	eor	r4, r4
    4632:	55 24       	eor	r5, r5
    4634:	32 01       	movw	r6, r4
    4636:	03 c0       	rjmp	.+6      	; 0x463e <searchNextFreeCluster+0x140>
    4638:	44 24       	eor	r4, r4
    463a:	55 24       	eor	r5, r5
    463c:	32 01       	movw	r6, r4
}
    463e:	64 2d       	mov	r22, r4
    4640:	75 2d       	mov	r23, r5
    4642:	86 2d       	mov	r24, r6
    4644:	97 2d       	mov	r25, r7
    4646:	df 91       	pop	r29
    4648:	cf 91       	pop	r28
    464a:	ff 90       	pop	r15
    464c:	ef 90       	pop	r14
    464e:	df 90       	pop	r13
    4650:	cf 90       	pop	r12
    4652:	bf 90       	pop	r11
    4654:	af 90       	pop	r10
    4656:	9f 90       	pop	r9
    4658:	8f 90       	pop	r8
    465a:	7f 90       	pop	r7
    465c:	6f 90       	pop	r6
    465e:	5f 90       	pop	r5
    4660:	4f 90       	pop	r4
    4662:	08 95       	ret

00004664 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4664:	cf 92       	push	r12
    4666:	df 92       	push	r13
    4668:	ef 92       	push	r14
    466a:	ff 92       	push	r15
    466c:	cf 93       	push	r28
    466e:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4670:	db 01       	movw	r26, r22
    4672:	ca 01       	movw	r24, r20
    4674:	91 70       	andi	r25, 0x01	; 1
    4676:	a0 70       	andi	r26, 0x00	; 0
    4678:	b0 70       	andi	r27, 0x00	; 0
    467a:	00 97       	sbiw	r24, 0x00	; 0
    467c:	a1 05       	cpc	r26, r1
    467e:	b1 05       	cpc	r27, r1
    4680:	51 f4       	brne	.+20     	; 0x4696 <freeMemoryUpdate+0x32>
    4682:	03 2e       	mov	r0, r19
    4684:	39 e0       	ldi	r19, 0x09	; 9
    4686:	76 95       	lsr	r23
    4688:	67 95       	ror	r22
    468a:	57 95       	ror	r21
    468c:	47 95       	ror	r20
    468e:	3a 95       	dec	r19
    4690:	d1 f7       	brne	.-12     	; 0x4686 <freeMemoryUpdate+0x22>
    4692:	30 2d       	mov	r19, r0
    4694:	0d c0       	rjmp	.+26     	; 0x46b0 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4696:	03 2e       	mov	r0, r19
    4698:	39 e0       	ldi	r19, 0x09	; 9
    469a:	76 95       	lsr	r23
    469c:	67 95       	ror	r22
    469e:	57 95       	ror	r21
    46a0:	47 95       	ror	r20
    46a2:	3a 95       	dec	r19
    46a4:	d1 f7       	brne	.-12     	; 0x469a <freeMemoryUpdate+0x36>
    46a6:	30 2d       	mov	r19, r0
    46a8:	4f 5f       	subi	r20, 0xFF	; 255
    46aa:	5f 4f       	sbci	r21, 0xFF	; 255
    46ac:	6f 4f       	sbci	r22, 0xFF	; 255
    46ae:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    46b0:	db 01       	movw	r26, r22
    46b2:	ca 01       	movw	r24, r20
    46b4:	87 70       	andi	r24, 0x07	; 7
    46b6:	90 70       	andi	r25, 0x00	; 0
    46b8:	a0 70       	andi	r26, 0x00	; 0
    46ba:	b0 70       	andi	r27, 0x00	; 0
    46bc:	00 97       	sbiw	r24, 0x00	; 0
    46be:	a1 05       	cpc	r26, r1
    46c0:	b1 05       	cpc	r27, r1
    46c2:	59 f4       	brne	.+22     	; 0x46da <freeMemoryUpdate+0x76>
    46c4:	6a 01       	movw	r12, r20
    46c6:	7b 01       	movw	r14, r22
    46c8:	68 94       	set
    46ca:	12 f8       	bld	r1, 2
    46cc:	f6 94       	lsr	r15
    46ce:	e7 94       	ror	r14
    46d0:	d7 94       	ror	r13
    46d2:	c7 94       	ror	r12
    46d4:	16 94       	lsr	r1
    46d6:	d1 f7       	brne	.-12     	; 0x46cc <freeMemoryUpdate+0x68>
    46d8:	0f c0       	rjmp	.+30     	; 0x46f8 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    46da:	6a 01       	movw	r12, r20
    46dc:	7b 01       	movw	r14, r22
    46de:	68 94       	set
    46e0:	12 f8       	bld	r1, 2
    46e2:	f6 94       	lsr	r15
    46e4:	e7 94       	ror	r14
    46e6:	d7 94       	ror	r13
    46e8:	c7 94       	ror	r12
    46ea:	16 94       	lsr	r1
    46ec:	d1 f7       	brne	.-12     	; 0x46e2 <freeMemoryUpdate+0x7e>
    46ee:	08 94       	sec
    46f0:	c1 1c       	adc	r12, r1
    46f2:	d1 1c       	adc	r13, r1
    46f4:	e1 1c       	adc	r14, r1
    46f6:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    46f8:	80 91 cf 50 	lds	r24, 0x50CF
    46fc:	88 23       	and	r24, r24
    46fe:	d1 f0       	breq	.+52     	; 0x4734 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4700:	81 e0       	ldi	r24, 0x01	; 1
    4702:	60 e0       	ldi	r22, 0x00	; 0
    4704:	20 e0       	ldi	r18, 0x00	; 0
    4706:	30 e0       	ldi	r19, 0x00	; 0
    4708:	a9 01       	movw	r20, r18
    470a:	0e 94 33 20 	call	0x4066	; 0x4066 <getSetFreeCluster>
	if(flag == ADD)
    470e:	cc 23       	and	r28, r28
    4710:	39 f4       	brne	.+14     	; 0x4720 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4712:	9b 01       	movw	r18, r22
    4714:	ac 01       	movw	r20, r24
    4716:	2c 0d       	add	r18, r12
    4718:	3d 1d       	adc	r19, r13
    471a:	4e 1d       	adc	r20, r14
    471c:	5f 1d       	adc	r21, r15
    471e:	06 c0       	rjmp	.+12     	; 0x472c <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4720:	9b 01       	movw	r18, r22
    4722:	ac 01       	movw	r20, r24
    4724:	2c 19       	sub	r18, r12
    4726:	3d 09       	sbc	r19, r13
    4728:	4e 09       	sbc	r20, r14
    472a:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    472c:	81 e0       	ldi	r24, 0x01	; 1
    472e:	61 e0       	ldi	r22, 0x01	; 1
    4730:	0e 94 33 20 	call	0x4066	; 0x4066 <getSetFreeCluster>
  }
}
    4734:	cf 91       	pop	r28
    4736:	ff 90       	pop	r15
    4738:	ef 90       	pop	r14
    473a:	df 90       	pop	r13
    473c:	cf 90       	pop	r12
    473e:	08 95       	ret

00004740 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4740:	2f 92       	push	r2
    4742:	3f 92       	push	r3
    4744:	4f 92       	push	r4
    4746:	5f 92       	push	r5
    4748:	6f 92       	push	r6
    474a:	7f 92       	push	r7
    474c:	8f 92       	push	r8
    474e:	9f 92       	push	r9
    4750:	af 92       	push	r10
    4752:	bf 92       	push	r11
    4754:	cf 92       	push	r12
    4756:	df 92       	push	r13
    4758:	ef 92       	push	r14
    475a:	ff 92       	push	r15
    475c:	0f 93       	push	r16
    475e:	1f 93       	push	r17
    4760:	cf 93       	push	r28
    4762:	df 93       	push	r29
    4764:	cd b7       	in	r28, 0x3d	; 61
    4766:	de b7       	in	r29, 0x3e	; 62
    4768:	2c 97       	sbiw	r28, 0x0c	; 12
    476a:	cd bf       	out	0x3d, r28	; 61
    476c:	de bf       	out	0x3e, r29	; 62
    476e:	88 2e       	mov	r8, r24
    4770:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4772:	80 91 5f 40 	lds	r24, 0x405F
    4776:	90 91 60 40 	lds	r25, 0x4060
    477a:	a0 91 61 40 	lds	r26, 0x4061
    477e:	b0 91 62 40 	lds	r27, 0x4062
    4782:	89 87       	std	Y+9, r24	; 0x09
    4784:	9a 87       	std	Y+10, r25	; 0x0a
    4786:	ab 87       	std	Y+11, r26	; 0x0b
    4788:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    478a:	0f 2e       	mov	r0, r31
    478c:	f6 ed       	ldi	r31, 0xD6	; 214
    478e:	2f 2e       	mov	r2, r31
    4790:	f1 e2       	ldi	r31, 0x21	; 33
    4792:	3f 2e       	mov	r3, r31
    4794:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4796:	c8 2c       	mov	r12, r8
    4798:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    479a:	d2 2c       	mov	r13, r2
    479c:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    479e:	5b 01       	movw	r10, r22
    47a0:	08 94       	sec
    47a2:	a1 1c       	adc	r10, r1
    47a4:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    47a6:	69 85       	ldd	r22, Y+9	; 0x09
    47a8:	7a 85       	ldd	r23, Y+10	; 0x0a
    47aa:	8b 85       	ldd	r24, Y+11	; 0x0b
    47ac:	9c 85       	ldd	r25, Y+12	; 0x0c
    47ae:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <getFirstSector>
    47b2:	6d 83       	std	Y+5, r22	; 0x05
    47b4:	7e 83       	std	Y+6, r23	; 0x06
    47b6:	8f 83       	std	Y+7, r24	; 0x07
    47b8:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    47ba:	80 91 7b 50 	lds	r24, 0x507B
    47be:	90 91 7c 50 	lds	r25, 0x507C
    47c2:	00 97       	sbiw	r24, 0x00	; 0
    47c4:	09 f4       	brne	.+2      	; 0x47c8 <findFiles+0x88>
    47c6:	13 c1       	rjmp	.+550    	; 0x49ee <findFiles+0x2ae>
    47c8:	44 24       	eor	r4, r4
    47ca:	55 24       	eor	r5, r5
    47cc:	32 01       	movw	r6, r4
    47ce:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    47d0:	8d 81       	ldd	r24, Y+5	; 0x05
    47d2:	9e 81       	ldd	r25, Y+6	; 0x06
    47d4:	af 81       	ldd	r26, Y+7	; 0x07
    47d6:	b8 85       	ldd	r27, Y+8	; 0x08
    47d8:	84 0d       	add	r24, r4
    47da:	95 1d       	adc	r25, r5
    47dc:	a6 1d       	adc	r26, r6
    47de:	b7 1d       	adc	r27, r7
    47e0:	89 83       	std	Y+1, r24	; 0x01
    47e2:	9a 83       	std	Y+2, r25	; 0x02
    47e4:	ab 83       	std	Y+3, r26	; 0x03
    47e6:	bc 83       	std	Y+4, r27	; 0x04
    47e8:	bc 01       	movw	r22, r24
    47ea:	cd 01       	movw	r24, r26
    47ec:	4d 2d       	mov	r20, r13
    47ee:	59 2d       	mov	r21, r9
    47f0:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    47f4:	80 91 54 40 	lds	r24, 0x4054
    47f8:	90 91 55 40 	lds	r25, 0x4055
    47fc:	00 97       	sbiw	r24, 0x00	; 0
    47fe:	09 f4       	brne	.+2      	; 0x4802 <findFiles+0xc2>
    4800:	e4 c0       	rjmp	.+456    	; 0x49ca <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4802:	d1 01       	movw	r26, r2
    4804:	8c 91       	ld	r24, X
    4806:	88 23       	and	r24, r24
    4808:	09 f4       	brne	.+2      	; 0x480c <findFiles+0xcc>
    480a:	10 c1       	rjmp	.+544    	; 0x4a2c <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    480c:	4d 2d       	mov	r20, r13
    480e:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4810:	20 e0       	ldi	r18, 0x00	; 0
    4812:	30 e0       	ldi	r19, 0x00	; 0
    4814:	08 c0       	rjmp	.+16     	; 0x4826 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4816:	a9 01       	movw	r20, r18
    4818:	4a 52       	subi	r20, 0x2A	; 42
    481a:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    481c:	fa 01       	movw	r30, r20
    481e:	80 81       	ld	r24, Z
    4820:	88 23       	and	r24, r24
    4822:	09 f4       	brne	.+2      	; 0x4826 <findFiles+0xe6>
    4824:	06 c1       	rjmp	.+524    	; 0x4a32 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4826:	85 3e       	cpi	r24, 0xE5	; 229
    4828:	09 f4       	brne	.+2      	; 0x482c <findFiles+0xec>
    482a:	c5 c0       	rjmp	.+394    	; 0x49b6 <findFiles+0x276>
    482c:	da 01       	movw	r26, r20
    482e:	1b 96       	adiw	r26, 0x0b	; 11
    4830:	8c 91       	ld	r24, X
    4832:	1b 97       	sbiw	r26, 0x0b	; 11
    4834:	8f 30       	cpi	r24, 0x0F	; 15
    4836:	09 f4       	brne	.+2      	; 0x483a <findFiles+0xfa>
    4838:	be c0       	rjmp	.+380    	; 0x49b6 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    483a:	12 30       	cpi	r17, 0x02	; 2
    483c:	08 f0       	brcs	.+2      	; 0x4840 <findFiles+0x100>
    483e:	fc c0       	rjmp	.+504    	; 0x4a38 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4840:	9c 91       	ld	r25, X
    4842:	f7 01       	movw	r30, r14
    4844:	80 81       	ld	r24, Z
    4846:	98 17       	cp	r25, r24
    4848:	09 f0       	breq	.+2      	; 0x484c <findFiles+0x10c>
    484a:	b5 c0       	rjmp	.+362    	; 0x49b6 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    484c:	fa 01       	movw	r30, r20
    484e:	31 96       	adiw	r30, 0x01	; 1
    4850:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4852:	81 e0       	ldi	r24, 0x01	; 1
    4854:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4856:	41 91       	ld	r20, Z+
    4858:	9d 91       	ld	r25, X+
    485a:	49 17       	cp	r20, r25
    485c:	31 f4       	brne	.+12     	; 0x486a <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    485e:	8f 5f       	subi	r24, 0xFF	; 255
    4860:	8b 30       	cpi	r24, 0x0B	; 11
    4862:	c9 f7       	brne	.-14     	; 0x4856 <findFiles+0x116>
    4864:	8b 01       	movw	r16, r22
    4866:	6b 01       	movw	r12, r22
    4868:	05 c0       	rjmp	.+10     	; 0x4874 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    486a:	8b 30       	cpi	r24, 0x0B	; 11
    486c:	09 f0       	breq	.+2      	; 0x4870 <findFiles+0x130>
    486e:	a3 c0       	rjmp	.+326    	; 0x49b6 <findFiles+0x276>
    4870:	8b 01       	movw	r16, r22
    4872:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4874:	f1 e0       	ldi	r31, 0x01	; 1
    4876:	8f 16       	cp	r8, r31
    4878:	09 f0       	breq	.+2      	; 0x487c <findFiles+0x13c>
    487a:	41 c0       	rjmp	.+130    	; 0x48fe <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    487c:	89 81       	ldd	r24, Y+1	; 0x01
    487e:	9a 81       	ldd	r25, Y+2	; 0x02
    4880:	ab 81       	ldd	r26, Y+3	; 0x03
    4882:	bc 81       	ldd	r27, Y+4	; 0x04
    4884:	80 93 d1 50 	sts	0x50D1, r24
    4888:	90 93 d2 50 	sts	0x50D2, r25
    488c:	a0 93 d3 50 	sts	0x50D3, r26
    4890:	b0 93 d4 50 	sts	0x50D4, r27
				appendFileLocation = i;
    4894:	c9 01       	movw	r24, r18
    4896:	a0 e0       	ldi	r26, 0x00	; 0
    4898:	b0 e0       	ldi	r27, 0x00	; 0
    489a:	80 93 d7 23 	sts	0x23D7, r24
    489e:	90 93 d8 23 	sts	0x23D8, r25
    48a2:	a0 93 d9 23 	sts	0x23D9, r26
    48a6:	b0 93 da 23 	sts	0x23DA, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    48aa:	d6 01       	movw	r26, r12
    48ac:	54 96       	adiw	r26, 0x14	; 20
    48ae:	4d 91       	ld	r20, X+
    48b0:	5c 91       	ld	r21, X
    48b2:	55 97       	sbiw	r26, 0x15	; 21
    48b4:	60 e0       	ldi	r22, 0x00	; 0
    48b6:	70 e0       	ldi	r23, 0x00	; 0
    48b8:	ba 01       	movw	r22, r20
    48ba:	55 27       	eor	r21, r21
    48bc:	44 27       	eor	r20, r20
    48be:	5a 96       	adiw	r26, 0x1a	; 26
    48c0:	8d 91       	ld	r24, X+
    48c2:	9c 91       	ld	r25, X
    48c4:	5b 97       	sbiw	r26, 0x1b	; 27
    48c6:	a0 e0       	ldi	r26, 0x00	; 0
    48c8:	b0 e0       	ldi	r27, 0x00	; 0
    48ca:	84 2b       	or	r24, r20
    48cc:	95 2b       	or	r25, r21
    48ce:	a6 2b       	or	r26, r22
    48d0:	b7 2b       	or	r27, r23
    48d2:	80 93 87 50 	sts	0x5087, r24
    48d6:	90 93 88 50 	sts	0x5088, r25
    48da:	a0 93 89 50 	sts	0x5089, r26
    48de:	b0 93 8a 50 	sts	0x508A, r27
				fileSize = dir->fileSize;
    48e2:	f6 01       	movw	r30, r12
    48e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    48e6:	95 8d       	ldd	r25, Z+29	; 0x1d
    48e8:	a6 8d       	ldd	r26, Z+30	; 0x1e
    48ea:	b7 8d       	ldd	r27, Z+31	; 0x1f
    48ec:	80 93 50 40 	sts	0x4050, r24
    48f0:	90 93 51 40 	sts	0x4051, r25
    48f4:	a0 93 52 40 	sts	0x4052, r26
    48f8:	b0 93 53 40 	sts	0x4053, r27
			    return (dir);
    48fc:	a5 c0       	rjmp	.+330    	; 0x4a48 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    48fe:	d6 01       	movw	r26, r12
    4900:	54 96       	adiw	r26, 0x14	; 20
    4902:	8d 91       	ld	r24, X+
    4904:	9c 91       	ld	r25, X
    4906:	55 97       	sbiw	r26, 0x15	; 21
    4908:	a0 e0       	ldi	r26, 0x00	; 0
    490a:	b0 e0       	ldi	r27, 0x00	; 0
    490c:	3c 01       	movw	r6, r24
    490e:	55 24       	eor	r5, r5
    4910:	44 24       	eor	r4, r4
    4912:	f6 01       	movw	r30, r12
    4914:	82 8d       	ldd	r24, Z+26	; 0x1a
    4916:	93 8d       	ldd	r25, Z+27	; 0x1b
    4918:	a0 e0       	ldi	r26, 0x00	; 0
    491a:	b0 e0       	ldi	r27, 0x00	; 0
    491c:	48 2a       	or	r4, r24
    491e:	59 2a       	or	r5, r25
    4920:	6a 2a       	or	r6, r26
    4922:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4924:	85 ee       	ldi	r24, 0xE5	; 229
    4926:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4928:	69 81       	ldd	r22, Y+1	; 0x01
    492a:	7a 81       	ldd	r23, Y+2	; 0x02
    492c:	8b 81       	ldd	r24, Y+3	; 0x03
    492e:	9c 81       	ldd	r25, Y+4	; 0x04
    4930:	46 ed       	ldi	r20, 0xD6	; 214
    4932:	51 e2       	ldi	r21, 0x21	; 33
    4934:	20 e0       	ldi	r18, 0x00	; 0
    4936:	32 e0       	ldi	r19, 0x02	; 2
    4938:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    493c:	d6 01       	movw	r26, r12
    493e:	5c 96       	adiw	r26, 0x1c	; 28
    4940:	4d 91       	ld	r20, X+
    4942:	5d 91       	ld	r21, X+
    4944:	6d 91       	ld	r22, X+
    4946:	7c 91       	ld	r23, X
    4948:	5f 97       	sbiw	r26, 0x1f	; 31
    494a:	80 e0       	ldi	r24, 0x00	; 0
    494c:	0e 94 32 23 	call	0x4664	; 0x4664 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4950:	82 e0       	ldi	r24, 0x02	; 2
    4952:	60 e0       	ldi	r22, 0x00	; 0
    4954:	20 e0       	ldi	r18, 0x00	; 0
    4956:	30 e0       	ldi	r19, 0x00	; 0
    4958:	a9 01       	movw	r20, r18
    495a:	0e 94 33 20 	call	0x4066	; 0x4066 <getSetFreeCluster>
    495e:	dc 01       	movw	r26, r24
    4960:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4962:	48 16       	cp	r4, r24
    4964:	59 06       	cpc	r5, r25
    4966:	6a 06       	cpc	r6, r26
    4968:	7b 06       	cpc	r7, r27
    496a:	30 f4       	brcc	.+12     	; 0x4978 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    496c:	82 e0       	ldi	r24, 0x02	; 2
    496e:	61 e0       	ldi	r22, 0x01	; 1
    4970:	a3 01       	movw	r20, r6
    4972:	92 01       	movw	r18, r4
    4974:	0e 94 33 20 	call	0x4066	; 0x4066 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4978:	c3 01       	movw	r24, r6
    497a:	b2 01       	movw	r22, r4
    497c:	40 e0       	ldi	r20, 0x00	; 0
    497e:	00 e0       	ldi	r16, 0x00	; 0
    4980:	10 e0       	ldi	r17, 0x00	; 0
    4982:	98 01       	movw	r18, r16
    4984:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
    4988:	6b 01       	movw	r12, r22
    498a:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    498c:	c3 01       	movw	r24, r6
    498e:	b2 01       	movw	r22, r4
    4990:	41 e0       	ldi	r20, 0x01	; 1
    4992:	00 e0       	ldi	r16, 0x00	; 0
    4994:	10 e0       	ldi	r17, 0x00	; 0
    4996:	98 01       	movw	r18, r16
    4998:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    499c:	b7 ef       	ldi	r27, 0xF7	; 247
    499e:	cb 16       	cp	r12, r27
    49a0:	bf ef       	ldi	r27, 0xFF	; 255
    49a2:	db 06       	cpc	r13, r27
    49a4:	bf ef       	ldi	r27, 0xFF	; 255
    49a6:	eb 06       	cpc	r14, r27
    49a8:	bf e0       	ldi	r27, 0x0F	; 15
    49aa:	fb 06       	cpc	r15, r27
    49ac:	08 f0       	brcs	.+2      	; 0x49b0 <findFiles+0x270>
    49ae:	47 c0       	rjmp	.+142    	; 0x4a3e <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    49b0:	26 01       	movw	r4, r12
    49b2:	37 01       	movw	r6, r14
    49b4:	e1 cf       	rjmp	.-62     	; 0x4978 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    49b6:	20 5e       	subi	r18, 0xE0	; 224
    49b8:	3f 4f       	sbci	r19, 0xFF	; 255
    49ba:	80 91 54 40 	lds	r24, 0x4054
    49be:	90 91 55 40 	lds	r25, 0x4055
    49c2:	28 17       	cp	r18, r24
    49c4:	39 07       	cpc	r19, r25
    49c6:	08 f4       	brcc	.+2      	; 0x49ca <findFiles+0x28a>
    49c8:	26 cf       	rjmp	.-436    	; 0x4816 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    49ca:	08 94       	sec
    49cc:	41 1c       	adc	r4, r1
    49ce:	51 1c       	adc	r5, r1
    49d0:	61 1c       	adc	r6, r1
    49d2:	71 1c       	adc	r7, r1
    49d4:	80 91 7b 50 	lds	r24, 0x507B
    49d8:	90 91 7c 50 	lds	r25, 0x507C
    49dc:	a0 e0       	ldi	r26, 0x00	; 0
    49de:	b0 e0       	ldi	r27, 0x00	; 0
    49e0:	48 16       	cp	r4, r24
    49e2:	59 06       	cpc	r5, r25
    49e4:	6a 06       	cpc	r6, r26
    49e6:	7b 06       	cpc	r7, r27
    49e8:	08 f4       	brcc	.+2      	; 0x49ec <findFiles+0x2ac>
    49ea:	f2 ce       	rjmp	.-540    	; 0x47d0 <findFiles+0x90>
    49ec:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    49ee:	69 85       	ldd	r22, Y+9	; 0x09
    49f0:	7a 85       	ldd	r23, Y+10	; 0x0a
    49f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    49f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    49f6:	40 e0       	ldi	r20, 0x00	; 0
    49f8:	00 e0       	ldi	r16, 0x00	; 0
    49fa:	10 e0       	ldi	r17, 0x00	; 0
    49fc:	98 01       	movw	r18, r16
    49fe:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
    4a02:	69 87       	std	Y+9, r22	; 0x09
    4a04:	7a 87       	std	Y+10, r23	; 0x0a
    4a06:	8b 87       	std	Y+11, r24	; 0x0b
    4a08:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4a0a:	67 3f       	cpi	r22, 0xF7	; 247
    4a0c:	ef ef       	ldi	r30, 0xFF	; 255
    4a0e:	7e 07       	cpc	r23, r30
    4a10:	ef ef       	ldi	r30, 0xFF	; 255
    4a12:	8e 07       	cpc	r24, r30
    4a14:	ef e0       	ldi	r30, 0x0F	; 15
    4a16:	9e 07       	cpc	r25, r30
    4a18:	a8 f4       	brcc	.+42     	; 0x4a44 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4a1a:	61 15       	cp	r22, r1
    4a1c:	71 05       	cpc	r23, r1
    4a1e:	81 05       	cpc	r24, r1
    4a20:	91 05       	cpc	r25, r1
    4a22:	09 f0       	breq	.+2      	; 0x4a26 <findFiles+0x2e6>
    4a24:	c0 ce       	rjmp	.-640    	; 0x47a6 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4a26:	00 e0       	ldi	r16, 0x00	; 0
    4a28:	10 e0       	ldi	r17, 0x00	; 0
    4a2a:	0e c0       	rjmp	.+28     	; 0x4a48 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4a2c:	00 e0       	ldi	r16, 0x00	; 0
    4a2e:	10 e0       	ldi	r17, 0x00	; 0
    4a30:	0b c0       	rjmp	.+22     	; 0x4a48 <findFiles+0x308>
    4a32:	00 e0       	ldi	r16, 0x00	; 0
    4a34:	10 e0       	ldi	r17, 0x00	; 0
    4a36:	08 c0       	rjmp	.+16     	; 0x4a48 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4a38:	00 e0       	ldi	r16, 0x00	; 0
    4a3a:	10 e0       	ldi	r17, 0x00	; 0
    4a3c:	05 c0       	rjmp	.+10     	; 0x4a48 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4a3e:	00 e0       	ldi	r16, 0x00	; 0
    4a40:	10 e0       	ldi	r17, 0x00	; 0
    4a42:	02 c0       	rjmp	.+4      	; 0x4a48 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4a44:	00 e0       	ldi	r16, 0x00	; 0
    4a46:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4a48:	80 2f       	mov	r24, r16
    4a4a:	91 2f       	mov	r25, r17
    4a4c:	2c 96       	adiw	r28, 0x0c	; 12
    4a4e:	cd bf       	out	0x3d, r28	; 61
    4a50:	de bf       	out	0x3e, r29	; 62
    4a52:	df 91       	pop	r29
    4a54:	cf 91       	pop	r28
    4a56:	1f 91       	pop	r17
    4a58:	0f 91       	pop	r16
    4a5a:	ff 90       	pop	r15
    4a5c:	ef 90       	pop	r14
    4a5e:	df 90       	pop	r13
    4a60:	cf 90       	pop	r12
    4a62:	bf 90       	pop	r11
    4a64:	af 90       	pop	r10
    4a66:	9f 90       	pop	r9
    4a68:	8f 90       	pop	r8
    4a6a:	7f 90       	pop	r7
    4a6c:	6f 90       	pop	r6
    4a6e:	5f 90       	pop	r5
    4a70:	4f 90       	pop	r4
    4a72:	3f 90       	pop	r3
    4a74:	2f 90       	pop	r2
    4a76:	08 95       	ret

00004a78 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4a78:	0e 94 c0 21 	call	0x4380	; 0x4380 <convertFileName>
  if(error) return;
    4a7c:	88 23       	and	r24, r24
    4a7e:	29 f4       	brne	.+10     	; 0x4a8a <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4a80:	82 e0       	ldi	r24, 0x02	; 2
    4a82:	6b eb       	ldi	r22, 0xBB	; 187
    4a84:	70 e5       	ldi	r23, 0x50	; 80
    4a86:	0e 94 a0 23 	call	0x4740	; 0x4740 <findFiles>
    4a8a:	08 95       	ret

00004a8c <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4a8c:	4f 92       	push	r4
    4a8e:	5f 92       	push	r5
    4a90:	6f 92       	push	r6
    4a92:	7f 92       	push	r7
    4a94:	af 92       	push	r10
    4a96:	bf 92       	push	r11
    4a98:	cf 92       	push	r12
    4a9a:	df 92       	push	r13
    4a9c:	ef 92       	push	r14
    4a9e:	ff 92       	push	r15
    4aa0:	0f 93       	push	r16
    4aa2:	1f 93       	push	r17
    4aa4:	cf 93       	push	r28
    4aa6:	c8 2f       	mov	r28, r24
    4aa8:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4aaa:	0e 94 c0 21 	call	0x4380	; 0x4380 <convertFileName>
if(error) return 2;
    4aae:	88 23       	and	r24, r24
    4ab0:	09 f0       	breq	.+2      	; 0x4ab4 <readFile+0x28>
    4ab2:	57 c0       	rjmp	.+174    	; 0x4b62 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4ab4:	81 e0       	ldi	r24, 0x01	; 1
    4ab6:	6b eb       	ldi	r22, 0xBB	; 187
    4ab8:	70 e5       	ldi	r23, 0x50	; 80
    4aba:	0e 94 a0 23 	call	0x4740	; 0x4740 <findFiles>
    4abe:	fc 01       	movw	r30, r24
if(dir == 0) 
    4ac0:	00 97       	sbiw	r24, 0x00	; 0
    4ac2:	31 f4       	brne	.+12     	; 0x4ad0 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4ac4:	81 e0       	ldi	r24, 0x01	; 1
    4ac6:	cc 23       	and	r28, r28
    4ac8:	09 f4       	brne	.+2      	; 0x4acc <readFile+0x40>
    4aca:	4e c0       	rjmp	.+156    	; 0x4b68 <readFile+0xdc>
    4acc:	80 e0       	ldi	r24, 0x00	; 0
    4ace:	4c c0       	rjmp	.+152    	; 0x4b68 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4ad0:	c1 30       	cpi	r28, 0x01	; 1
    4ad2:	09 f4       	brne	.+2      	; 0x4ad6 <readFile+0x4a>
    4ad4:	48 c0       	rjmp	.+144    	; 0x4b66 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4ad6:	44 88       	ldd	r4, Z+20	; 0x14
    4ad8:	55 88       	ldd	r5, Z+21	; 0x15
    4ada:	66 24       	eor	r6, r6
    4adc:	77 24       	eor	r7, r7
    4ade:	32 01       	movw	r6, r4
    4ae0:	55 24       	eor	r5, r5
    4ae2:	44 24       	eor	r4, r4
    4ae4:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ae6:	93 8d       	ldd	r25, Z+27	; 0x1b
    4ae8:	a0 e0       	ldi	r26, 0x00	; 0
    4aea:	b0 e0       	ldi	r27, 0x00	; 0
    4aec:	48 2a       	or	r4, r24
    4aee:	59 2a       	or	r5, r25
    4af0:	6a 2a       	or	r6, r26
    4af2:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4af4:	0f 2e       	mov	r0, r31
    4af6:	ff ed       	ldi	r31, 0xDF	; 223
    4af8:	af 2e       	mov	r10, r31
    4afa:	f3 e2       	ldi	r31, 0x23	; 35
    4afc:	bf 2e       	mov	r11, r31
    4afe:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4b00:	c3 01       	movw	r24, r6
    4b02:	b2 01       	movw	r22, r4
    4b04:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <getFirstSector>
    4b08:	6b 01       	movw	r12, r22
    4b0a:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4b0c:	80 91 7b 50 	lds	r24, 0x507B
    4b10:	90 91 7c 50 	lds	r25, 0x507C
    4b14:	00 97       	sbiw	r24, 0x00	; 0
    4b16:	a1 f0       	breq	.+40     	; 0x4b40 <readFile+0xb4>
    4b18:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4b1a:	c7 01       	movw	r24, r14
    4b1c:	b6 01       	movw	r22, r12
    4b1e:	6c 0f       	add	r22, r28
    4b20:	71 1d       	adc	r23, r1
    4b22:	81 1d       	adc	r24, r1
    4b24:	91 1d       	adc	r25, r1
    4b26:	a5 01       	movw	r20, r10
    4b28:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4b2c:	cf 5f       	subi	r28, 0xFF	; 255
    4b2e:	80 91 7b 50 	lds	r24, 0x507B
    4b32:	90 91 7c 50 	lds	r25, 0x507C
    4b36:	2c 2f       	mov	r18, r28
    4b38:	30 e0       	ldi	r19, 0x00	; 0
    4b3a:	28 17       	cp	r18, r24
    4b3c:	39 07       	cpc	r19, r25
    4b3e:	68 f3       	brcs	.-38     	; 0x4b1a <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4b40:	c3 01       	movw	r24, r6
    4b42:	b2 01       	movw	r22, r4
    4b44:	40 e0       	ldi	r20, 0x00	; 0
    4b46:	00 e0       	ldi	r16, 0x00	; 0
    4b48:	10 e0       	ldi	r17, 0x00	; 0
    4b4a:	98 01       	movw	r18, r16
    4b4c:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
    4b50:	2b 01       	movw	r4, r22
    4b52:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4b54:	61 15       	cp	r22, r1
    4b56:	71 05       	cpc	r23, r1
    4b58:	81 05       	cpc	r24, r1
    4b5a:	91 05       	cpc	r25, r1
    4b5c:	89 f6       	brne	.-94     	; 0x4b00 <readFile+0x74>
	  return 0;}
    4b5e:	80 e0       	ldi	r24, 0x00	; 0
    4b60:	03 c0       	rjmp	.+6      	; 0x4b68 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4b62:	82 e0       	ldi	r24, 0x02	; 2
    4b64:	01 c0       	rjmp	.+2      	; 0x4b68 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4b66:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4b68:	cf 91       	pop	r28
    4b6a:	1f 91       	pop	r17
    4b6c:	0f 91       	pop	r16
    4b6e:	ff 90       	pop	r15
    4b70:	ef 90       	pop	r14
    4b72:	df 90       	pop	r13
    4b74:	cf 90       	pop	r12
    4b76:	bf 90       	pop	r11
    4b78:	af 90       	pop	r10
    4b7a:	7f 90       	pop	r7
    4b7c:	6f 90       	pop	r6
    4b7e:	5f 90       	pop	r5
    4b80:	4f 90       	pop	r4
    4b82:	08 95       	ret

00004b84 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4b84:	2f 92       	push	r2
    4b86:	3f 92       	push	r3
    4b88:	4f 92       	push	r4
    4b8a:	5f 92       	push	r5
    4b8c:	6f 92       	push	r6
    4b8e:	7f 92       	push	r7
    4b90:	8f 92       	push	r8
    4b92:	9f 92       	push	r9
    4b94:	af 92       	push	r10
    4b96:	bf 92       	push	r11
    4b98:	cf 92       	push	r12
    4b9a:	df 92       	push	r13
    4b9c:	ef 92       	push	r14
    4b9e:	ff 92       	push	r15
    4ba0:	0f 93       	push	r16
    4ba2:	1f 93       	push	r17
    4ba4:	cf 93       	push	r28
    4ba6:	df 93       	push	r29
    4ba8:	cd b7       	in	r28, 0x3d	; 61
    4baa:	de b7       	in	r29, 0x3e	; 62
    4bac:	60 97       	sbiw	r28, 0x10	; 16
    4bae:	cd bf       	out	0x3d, r28	; 61
    4bb0:	de bf       	out	0x3e, r29	; 62
    4bb2:	fc 01       	movw	r30, r24
    4bb4:	6d 83       	std	Y+5, r22	; 0x05
    4bb6:	7e 83       	std	Y+6, r23	; 0x06
    4bb8:	49 01       	movw	r8, r18
    4bba:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4bbc:	81 e0       	ldi	r24, 0x01	; 1
    4bbe:	bf 01       	movw	r22, r30
    4bc0:	0e 94 46 25 	call	0x4a8c	; 0x4a8c <readFile>

if(j == 1) 
    4bc4:	81 30       	cpi	r24, 0x01	; 1
    4bc6:	09 f0       	breq	.+2      	; 0x4bca <writeFile+0x46>
    4bc8:	7b c0       	rjmp	.+246    	; 0x4cc0 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4bca:	00 91 87 50 	lds	r16, 0x5087
    4bce:	10 91 88 50 	lds	r17, 0x5088
    4bd2:	20 91 89 50 	lds	r18, 0x5089
    4bd6:	30 91 8a 50 	lds	r19, 0x508A
    4bda:	09 83       	std	Y+1, r16	; 0x01
    4bdc:	1a 83       	std	Y+2, r17	; 0x02
    4bde:	2b 83       	std	Y+3, r18	; 0x03
    4be0:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4be2:	cc 24       	eor	r12, r12
    4be4:	dd 24       	eor	r13, r13
    4be6:	76 01       	movw	r14, r12
    4be8:	24 01       	movw	r4, r8
    4bea:	35 01       	movw	r6, r10
    4bec:	48 01       	movw	r8, r16
    4bee:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4bf0:	c5 01       	movw	r24, r10
    4bf2:	b4 01       	movw	r22, r8
    4bf4:	40 e0       	ldi	r20, 0x00	; 0
    4bf6:	00 e0       	ldi	r16, 0x00	; 0
    4bf8:	10 e0       	ldi	r17, 0x00	; 0
    4bfa:	98 01       	movw	r18, r16
    4bfc:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
    4c00:	dc 01       	movw	r26, r24
    4c02:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4c04:	8f 3f       	cpi	r24, 0xFF	; 255
    4c06:	1f ef       	ldi	r17, 0xFF	; 255
    4c08:	91 07       	cpc	r25, r17
    4c0a:	1f ef       	ldi	r17, 0xFF	; 255
    4c0c:	a1 07       	cpc	r26, r17
    4c0e:	1f ef       	ldi	r17, 0xFF	; 255
    4c10:	b1 07       	cpc	r27, r17
    4c12:	41 f0       	breq	.+16     	; 0x4c24 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4c14:	08 94       	sec
    4c16:	c1 1c       	adc	r12, r1
    4c18:	d1 1c       	adc	r13, r1
    4c1a:	e1 1c       	adc	r14, r1
    4c1c:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4c1e:	4c 01       	movw	r8, r24
    4c20:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4c22:	e6 cf       	rjmp	.-52     	; 0x4bf0 <writeFile+0x6c>
    4c24:	89 82       	std	Y+1, r8	; 0x01
    4c26:	9a 82       	std	Y+2, r9	; 0x02
    4c28:	ab 82       	std	Y+3, r10	; 0x03
    4c2a:	bc 82       	std	Y+4, r11	; 0x04
    4c2c:	53 01       	movw	r10, r6
    4c2e:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4c30:	20 91 7b 50 	lds	r18, 0x507B
    4c34:	30 91 7c 50 	lds	r19, 0x507C
    4c38:	80 91 54 40 	lds	r24, 0x4054
    4c3c:	90 91 55 40 	lds	r25, 0x4055
    4c40:	60 90 54 40 	lds	r6, 0x4054
    4c44:	70 90 55 40 	lds	r7, 0x4055
    4c48:	bc 01       	movw	r22, r24
    4c4a:	80 e0       	ldi	r24, 0x00	; 0
    4c4c:	90 e0       	ldi	r25, 0x00	; 0
    4c4e:	40 e0       	ldi	r20, 0x00	; 0
    4c50:	50 e0       	ldi	r21, 0x00	; 0
    4c52:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    4c56:	a7 01       	movw	r20, r14
    4c58:	96 01       	movw	r18, r12
    4c5a:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    4c5e:	dc 01       	movw	r26, r24
    4c60:	cb 01       	movw	r24, r22
    4c62:	40 91 50 40 	lds	r20, 0x4050
    4c66:	50 91 51 40 	lds	r21, 0x4051
    4c6a:	60 91 52 40 	lds	r22, 0x4052
    4c6e:	70 91 53 40 	lds	r23, 0x4053
    4c72:	8a 01       	movw	r16, r20
    4c74:	9b 01       	movw	r18, r22
    4c76:	08 1b       	sub	r16, r24
    4c78:	19 0b       	sbc	r17, r25
    4c7a:	2a 0b       	sbc	r18, r26
    4c7c:	3b 0b       	sbc	r19, r27
    4c7e:	c9 01       	movw	r24, r18
    4c80:	b8 01       	movw	r22, r16
    4c82:	93 01       	movw	r18, r6
    4c84:	40 e0       	ldi	r20, 0x00	; 0
    4c86:	50 e0       	ldi	r21, 0x00	; 0
    4c88:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    4c8c:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4c8e:	69 81       	ldd	r22, Y+1	; 0x01
    4c90:	7a 81       	ldd	r23, Y+2	; 0x02
    4c92:	8b 81       	ldd	r24, Y+3	; 0x03
    4c94:	9c 81       	ldd	r25, Y+4	; 0x04
    4c96:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <getFirstSector>
    4c9a:	dc 01       	movw	r26, r24
    4c9c:	cb 01       	movw	r24, r22
    4c9e:	20 2e       	mov	r2, r16
    4ca0:	33 24       	eor	r3, r3
    4ca2:	28 0e       	add	r2, r24
    4ca4:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4ca6:	b1 01       	movw	r22, r2
    4ca8:	80 e0       	ldi	r24, 0x00	; 0
    4caa:	90 e0       	ldi	r25, 0x00	; 0
    4cac:	46 ed       	ldi	r20, 0xD6	; 214
    4cae:	51 e2       	ldi	r21, 0x21	; 33
    4cb0:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4cb4:	1f 86       	std	Y+15, r1	; 0x0f
    4cb6:	18 8a       	std	Y+16, r1	; 0x10
    4cb8:	19 86       	std	Y+9, r1	; 0x09
    4cba:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4cbc:	11 e0       	ldi	r17, 0x01	; 1
    4cbe:	4c c0       	rjmp	.+152    	; 0x4d58 <writeFile+0x1d4>
}
else if(j == 2) 
    4cc0:	82 30       	cpi	r24, 0x02	; 2
    4cc2:	09 f4       	brne	.+2      	; 0x4cc6 <writeFile+0x142>
    4cc4:	0c c2       	rjmp	.+1048   	; 0x50de <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4cc6:	82 e0       	ldi	r24, 0x02	; 2
    4cc8:	60 e0       	ldi	r22, 0x00	; 0
    4cca:	20 e0       	ldi	r18, 0x00	; 0
    4ccc:	30 e0       	ldi	r19, 0x00	; 0
    4cce:	a9 01       	movw	r20, r18
    4cd0:	0e 94 33 20 	call	0x4066	; 0x4066 <getSetFreeCluster>
  if(cluster > totalClusters)
    4cd4:	00 91 59 40 	lds	r16, 0x4059
    4cd8:	10 91 5a 40 	lds	r17, 0x405A
    4cdc:	20 91 5b 40 	lds	r18, 0x405B
    4ce0:	30 91 5c 40 	lds	r19, 0x405C
    4ce4:	06 17       	cp	r16, r22
    4ce6:	17 07       	cpc	r17, r23
    4ce8:	28 07       	cpc	r18, r24
    4cea:	39 07       	cpc	r19, r25
    4cec:	40 f4       	brcc	.+16     	; 0x4cfe <writeFile+0x17a>
     cluster = rootCluster;
    4cee:	60 91 5f 40 	lds	r22, 0x405F
    4cf2:	70 91 60 40 	lds	r23, 0x4060
    4cf6:	80 91 61 40 	lds	r24, 0x4061
    4cfa:	90 91 62 40 	lds	r25, 0x4062

  cluster = searchNextFreeCluster(cluster);
    4cfe:	0e 94 7f 22 	call	0x44fe	; 0x44fe <searchNextFreeCluster>
    4d02:	69 83       	std	Y+1, r22	; 0x01
    4d04:	7a 83       	std	Y+2, r23	; 0x02
    4d06:	8b 83       	std	Y+3, r24	; 0x03
    4d08:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4d0a:	61 15       	cp	r22, r1
    4d0c:	71 05       	cpc	r23, r1
    4d0e:	81 05       	cpc	r24, r1
    4d10:	91 05       	cpc	r25, r1
    4d12:	09 f4       	brne	.+2      	; 0x4d16 <writeFile+0x192>
    4d14:	e6 c1       	rjmp	.+972    	; 0x50e2 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4d16:	41 e0       	ldi	r20, 0x01	; 1
    4d18:	0f ef       	ldi	r16, 0xFF	; 255
    4d1a:	1f ef       	ldi	r17, 0xFF	; 255
    4d1c:	98 01       	movw	r18, r16
    4d1e:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4d22:	2b 81       	ldd	r18, Y+3	; 0x03
    4d24:	3c 81       	ldd	r19, Y+4	; 0x04
    4d26:	29 87       	std	Y+9, r18	; 0x09
    4d28:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4d2a:	89 81       	ldd	r24, Y+1	; 0x01
    4d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d2e:	8f 87       	std	Y+15, r24	; 0x0f
    4d30:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4d32:	10 92 50 40 	sts	0x4050, r1
    4d36:	10 92 51 40 	sts	0x4051, r1
    4d3a:	10 92 52 40 	sts	0x4052, r1
    4d3e:	10 92 53 40 	sts	0x4053, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4d42:	69 81       	ldd	r22, Y+1	; 0x01
    4d44:	7a 81       	ldd	r23, Y+2	; 0x02
    4d46:	8b 81       	ldd	r24, Y+3	; 0x03
    4d48:	9c 81       	ldd	r25, Y+4	; 0x04
    4d4a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <getFirstSector>
    4d4e:	dc 01       	movw	r26, r24
    4d50:	cb 01       	movw	r24, r22
    4d52:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4d54:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4d56:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4d58:	81 14       	cp	r8, r1
    4d5a:	91 04       	cpc	r9, r1
    4d5c:	a1 04       	cpc	r10, r1
    4d5e:	b1 04       	cpc	r11, r1
    4d60:	09 f4       	brne	.+2      	; 0x4d64 <writeFile+0x1e0>
    4d62:	8d c0       	rjmp	.+282    	; 0x4e7e <writeFile+0x2fa>
    4d64:	44 24       	eor	r4, r4
    4d66:	55 24       	eor	r5, r5
    4d68:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4d6a:	c0 2e       	mov	r12, r16
    4d6c:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4d6e:	90 e0       	ldi	r25, 0x00	; 0
    4d70:	89 16       	cp	r8, r25
    4d72:	92 e0       	ldi	r25, 0x02	; 2
    4d74:	99 06       	cpc	r9, r25
    4d76:	90 e0       	ldi	r25, 0x00	; 0
    4d78:	a9 06       	cpc	r10, r25
    4d7a:	90 e0       	ldi	r25, 0x00	; 0
    4d7c:	b9 06       	cpc	r11, r25
    4d7e:	88 f0       	brcs	.+34     	; 0x4da2 <writeFile+0x21e>
		 writtenData += 512;
    4d80:	00 e0       	ldi	r16, 0x00	; 0
    4d82:	12 e0       	ldi	r17, 0x02	; 2
    4d84:	20 e0       	ldi	r18, 0x00	; 0
    4d86:	30 e0       	ldi	r19, 0x00	; 0
    4d88:	40 0e       	add	r4, r16
    4d8a:	51 1e       	adc	r5, r17
    4d8c:	62 1e       	adc	r6, r18
    4d8e:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4d90:	80 e0       	ldi	r24, 0x00	; 0
    4d92:	9e ef       	ldi	r25, 0xFE	; 254
    4d94:	af ef       	ldi	r26, 0xFF	; 255
    4d96:	bf ef       	ldi	r27, 0xFF	; 255
    4d98:	88 0e       	add	r8, r24
    4d9a:	99 1e       	adc	r9, r25
    4d9c:	aa 1e       	adc	r10, r26
    4d9e:	bb 1e       	adc	r11, r27
    4da0:	0c c0       	rjmp	.+24     	; 0x4dba <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4da2:	48 0c       	add	r4, r8
    4da4:	59 1c       	adc	r5, r9
    4da6:	6a 1c       	adc	r6, r10
    4da8:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4daa:	95 01       	movw	r18, r10
    4dac:	84 01       	movw	r16, r8
    4dae:	11 70       	andi	r17, 0x01	; 1
    4db0:	20 70       	andi	r18, 0x00	; 0
    4db2:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4db4:	88 24       	eor	r8, r8
    4db6:	99 24       	eor	r9, r9
    4db8:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4dba:	80 91 50 40 	lds	r24, 0x4050
    4dbe:	90 91 51 40 	lds	r25, 0x4051
    4dc2:	a0 91 52 40 	lds	r26, 0x4052
    4dc6:	b0 91 53 40 	lds	r27, 0x4053
    4dca:	80 50       	subi	r24, 0x00	; 0
    4dcc:	9e 4f       	sbci	r25, 0xFE	; 254
    4dce:	af 4f       	sbci	r26, 0xFF	; 255
    4dd0:	bf 4f       	sbci	r27, 0xFF	; 255
    4dd2:	80 93 50 40 	sts	0x4050, r24
    4dd6:	90 93 51 40 	sts	0x4051, r25
    4dda:	a0 93 52 40 	sts	0x4052, r26
    4dde:	b0 93 53 40 	sts	0x4053, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4de2:	b1 01       	movw	r22, r2
    4de4:	80 e0       	ldi	r24, 0x00	; 0
    4de6:	90 e0       	ldi	r25, 0x00	; 0
    4de8:	a2 01       	movw	r20, r4
    4dea:	40 1b       	sub	r20, r16
    4dec:	51 0b       	sbc	r21, r17
    4dee:	ad 81       	ldd	r26, Y+5	; 0x05
    4df0:	be 81       	ldd	r27, Y+6	; 0x06
    4df2:	4a 0f       	add	r20, r26
    4df4:	5b 1f       	adc	r21, r27
    4df6:	98 01       	movw	r18, r16
    4df8:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SD_write_block>
	j++;
    4dfc:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4dfe:	20 91 7b 50 	lds	r18, 0x507B
    4e02:	30 91 7c 50 	lds	r19, 0x507C
    4e06:	8c 2d       	mov	r24, r12
    4e08:	90 e0       	ldi	r25, 0x00	; 0
    4e0a:	82 17       	cp	r24, r18
    4e0c:	93 07       	cpc	r25, r19
    4e0e:	29 f5       	brne	.+74     	; 0x4e5a <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4e10:	69 81       	ldd	r22, Y+1	; 0x01
    4e12:	7a 81       	ldd	r23, Y+2	; 0x02
    4e14:	8b 81       	ldd	r24, Y+3	; 0x03
    4e16:	9c 81       	ldd	r25, Y+4	; 0x04
    4e18:	0e 94 7f 22 	call	0x44fe	; 0x44fe <searchNextFreeCluster>
    4e1c:	6b 01       	movw	r12, r22
    4e1e:	7c 01       	movw	r14, r24
		if(cluster == 0){
    4e20:	61 15       	cp	r22, r1
    4e22:	71 05       	cpc	r23, r1
    4e24:	81 05       	cpc	r24, r1
    4e26:	91 05       	cpc	r25, r1
    4e28:	09 f4       	brne	.+2      	; 0x4e2c <writeFile+0x2a8>
    4e2a:	5d c1       	rjmp	.+698    	; 0x50e6 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    4e2c:	69 81       	ldd	r22, Y+1	; 0x01
    4e2e:	7a 81       	ldd	r23, Y+2	; 0x02
    4e30:	8b 81       	ldd	r24, Y+3	; 0x03
    4e32:	9c 81       	ldd	r25, Y+4	; 0x04
    4e34:	41 e0       	ldi	r20, 0x01	; 1
    4e36:	97 01       	movw	r18, r14
    4e38:	86 01       	movw	r16, r12
    4e3a:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    4e3e:	c7 01       	movw	r24, r14
    4e40:	b6 01       	movw	r22, r12
    4e42:	41 e0       	ldi	r20, 0x01	; 1
    4e44:	0f ef       	ldi	r16, 0xFF	; 255
    4e46:	1f ef       	ldi	r17, 0xFF	; 255
    4e48:	98 01       	movw	r18, r16
    4e4a:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4e4e:	c9 82       	std	Y+1, r12	; 0x01
    4e50:	da 82       	std	Y+2, r13	; 0x02
    4e52:	eb 82       	std	Y+3, r14	; 0x03
    4e54:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    4e56:	cc 24       	eor	r12, r12
    4e58:	03 c0       	rjmp	.+6      	; 0x4e60 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    4e5a:	08 94       	sec
    4e5c:	21 1c       	adc	r2, r1
    4e5e:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    4e60:	82 e0       	ldi	r24, 0x02	; 2
    4e62:	61 e0       	ldi	r22, 0x01	; 1
    4e64:	29 81       	ldd	r18, Y+1	; 0x01
    4e66:	3a 81       	ldd	r19, Y+2	; 0x02
    4e68:	4b 81       	ldd	r20, Y+3	; 0x03
    4e6a:	5c 81       	ldd	r21, Y+4	; 0x04
    4e6c:	0e 94 33 20 	call	0x4066	; 0x4066 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4e70:	81 14       	cp	r8, r1
    4e72:	91 04       	cpc	r9, r1
    4e74:	a1 04       	cpc	r10, r1
    4e76:	b1 04       	cpc	r11, r1
    4e78:	09 f0       	breq	.+2      	; 0x4e7c <writeFile+0x2f8>
    4e7a:	79 cf       	rjmp	.-270    	; 0x4d6e <writeFile+0x1ea>
    4e7c:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    4e7e:	11 23       	and	r17, r17
    4e80:	09 f4       	brne	.+2      	; 0x4e84 <writeFile+0x300>
    4e82:	3f c0       	rjmp	.+126    	; 0x4f02 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    4e84:	60 91 d1 50 	lds	r22, 0x50D1
    4e88:	70 91 d2 50 	lds	r23, 0x50D2
    4e8c:	80 91 d3 50 	lds	r24, 0x50D3
    4e90:	90 91 d4 50 	lds	r25, 0x50D4
    4e94:	06 ed       	ldi	r16, 0xD6	; 214
    4e96:	11 e2       	ldi	r17, 0x21	; 33
    4e98:	a8 01       	movw	r20, r16
    4e9a:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4e9e:	e0 91 d7 23 	lds	r30, 0x23D7
    4ea2:	f0 91 d8 23 	lds	r31, 0x23D8
    4ea6:	e0 0f       	add	r30, r16
    4ea8:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4eaa:	12 8a       	std	Z+18, r1	; 0x12
    4eac:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4eae:	80 91 50 40 	lds	r24, 0x4050
    4eb2:	90 91 51 40 	lds	r25, 0x4051
    4eb6:	a0 91 52 40 	lds	r26, 0x4052
    4eba:	b0 91 53 40 	lds	r27, 0x4053
    4ebe:	44 8d       	ldd	r20, Z+28	; 0x1c
    4ec0:	55 8d       	ldd	r21, Z+29	; 0x1d
    4ec2:	66 8d       	ldd	r22, Z+30	; 0x1e
    4ec4:	77 8d       	ldd	r23, Z+31	; 0x1f
    4ec6:	6c 01       	movw	r12, r24
    4ec8:	7d 01       	movw	r14, r26
    4eca:	c4 1a       	sub	r12, r20
    4ecc:	d5 0a       	sbc	r13, r21
    4ece:	e6 0a       	sbc	r14, r22
    4ed0:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4ed2:	84 8f       	std	Z+28, r24	; 0x1c
    4ed4:	95 8f       	std	Z+29, r25	; 0x1d
    4ed6:	a6 8f       	std	Z+30, r26	; 0x1e
    4ed8:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4eda:	60 91 d1 50 	lds	r22, 0x50D1
    4ede:	70 91 d2 50 	lds	r23, 0x50D2
    4ee2:	80 91 d3 50 	lds	r24, 0x50D3
    4ee6:	90 91 d4 50 	lds	r25, 0x50D4
    4eea:	a8 01       	movw	r20, r16
    4eec:	20 e0       	ldi	r18, 0x00	; 0
    4eee:	32 e0       	ldi	r19, 0x02	; 2
    4ef0:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    4ef4:	81 e0       	ldi	r24, 0x01	; 1
    4ef6:	b7 01       	movw	r22, r14
    4ef8:	a6 01       	movw	r20, r12
    4efa:	0e 94 32 23 	call	0x4664	; 0x4664 <freeMemoryUpdate>

 //File appended!
  return 0;
    4efe:	80 e0       	ldi	r24, 0x00	; 0
    4f00:	f9 c0       	rjmp	.+498    	; 0x50f4 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    4f02:	00 91 5f 40 	lds	r16, 0x405F
    4f06:	10 91 60 40 	lds	r17, 0x4060
    4f0a:	20 91 61 40 	lds	r18, 0x4061
    4f0e:	30 91 62 40 	lds	r19, 0x4062
    4f12:	0b 87       	std	Y+11, r16	; 0x0b
    4f14:	1c 87       	std	Y+12, r17	; 0x0c
    4f16:	2d 87       	std	Y+13, r18	; 0x0d
    4f18:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4f1a:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4f1c:	8b eb       	ldi	r24, 0xBB	; 187
    4f1e:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4f20:	0f 2e       	mov	r0, r31
    4f22:	fb e0       	ldi	r31, 0x0B	; 11
    4f24:	af 2e       	mov	r10, r31
    4f26:	bb 24       	eor	r11, r11
    4f28:	f0 2d       	mov	r31, r0
    4f2a:	a8 0e       	add	r10, r24
    4f2c:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4f2e:	88 24       	eor	r8, r8
    4f30:	68 94       	set
    4f32:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4f34:	0f 2e       	mov	r0, r31
    4f36:	f6 ed       	ldi	r31, 0xD6	; 214
    4f38:	4f 2e       	mov	r4, r31
    4f3a:	f1 e2       	ldi	r31, 0x21	; 33
    4f3c:	5f 2e       	mov	r5, r31
    4f3e:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4f40:	28 2e       	mov	r2, r24
    4f42:	99 2e       	mov	r9, r25
    4f44:	37 2c       	mov	r3, r7
    4f46:	6f 84       	ldd	r6, Y+15	; 0x0f
    4f48:	78 88       	ldd	r7, Y+16	; 0x10
    4f4a:	04 c0       	rjmp	.+8      	; 0x4f54 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    4f4c:	cb 86       	std	Y+11, r12	; 0x0b
    4f4e:	dc 86       	std	Y+12, r13	; 0x0c
    4f50:	ed 86       	std	Y+13, r14	; 0x0d
    4f52:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    4f54:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f56:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f58:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f5a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f5c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <getFirstSector>
    4f60:	6d 83       	std	Y+5, r22	; 0x05
    4f62:	7e 83       	std	Y+6, r23	; 0x06
    4f64:	8f 83       	std	Y+7, r24	; 0x07
    4f66:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4f68:	80 91 7b 50 	lds	r24, 0x507B
    4f6c:	90 91 7c 50 	lds	r25, 0x507C
    4f70:	00 97       	sbiw	r24, 0x00	; 0
    4f72:	09 f4       	brne	.+2      	; 0x4f76 <writeFile+0x3f2>
    4f74:	77 c0       	rjmp	.+238    	; 0x5064 <writeFile+0x4e0>
    4f76:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4f78:	cd 80       	ldd	r12, Y+5	; 0x05
    4f7a:	de 80       	ldd	r13, Y+6	; 0x06
    4f7c:	ef 80       	ldd	r14, Y+7	; 0x07
    4f7e:	f8 84       	ldd	r15, Y+8	; 0x08
    4f80:	19 81       	ldd	r17, Y+1	; 0x01
    4f82:	c1 0e       	add	r12, r17
    4f84:	d1 1c       	adc	r13, r1
    4f86:	e1 1c       	adc	r14, r1
    4f88:	f1 1c       	adc	r15, r1
    4f8a:	c7 01       	movw	r24, r14
    4f8c:	b6 01       	movw	r22, r12
    4f8e:	a2 01       	movw	r20, r4
    4f90:	0e 94 8a 2a 	call	0x5514	; 0x5514 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    4f94:	80 91 54 40 	lds	r24, 0x4054
    4f98:	90 91 55 40 	lds	r25, 0x4055
    4f9c:	00 97       	sbiw	r24, 0x00	; 0
    4f9e:	09 f4       	brne	.+2      	; 0x4fa2 <writeFile+0x41e>
    4fa0:	54 c0       	rjmp	.+168    	; 0x504a <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4fa2:	33 20       	and	r3, r3
    4fa4:	09 f0       	breq	.+2      	; 0x4fa8 <writeFile+0x424>
    4fa6:	a1 c0       	rjmp	.+322    	; 0x50ea <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4fa8:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4faa:	00 e0       	ldi	r16, 0x00	; 0
    4fac:	10 e0       	ldi	r17, 0x00	; 0
    4fae:	06 c0       	rjmp	.+12     	; 0x4fbc <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4fb0:	a8 01       	movw	r20, r16
    4fb2:	4a 52       	subi	r20, 0x2A	; 42
    4fb4:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4fb6:	22 23       	and	r18, r18
    4fb8:	09 f0       	breq	.+2      	; 0x4fbc <writeFile+0x438>
    4fba:	99 c0       	rjmp	.+306    	; 0x50ee <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4fbc:	da 01       	movw	r26, r20
    4fbe:	8c 91       	ld	r24, X
    4fc0:	88 23       	and	r24, r24
    4fc2:	21 f4       	brne	.+8      	; 0x4fcc <writeFile+0x448>
    4fc4:	e2 2d       	mov	r30, r2
    4fc6:	f9 2d       	mov	r31, r9
    4fc8:	da 01       	movw	r26, r20
    4fca:	04 c0       	rjmp	.+8      	; 0x4fd4 <writeFile+0x450>
    4fcc:	85 3e       	cpi	r24, 0xE5	; 229
    4fce:	d1 f3       	breq	.-12     	; 0x4fc4 <writeFile+0x440>
    4fd0:	23 2d       	mov	r18, r3
    4fd2:	30 c0       	rjmp	.+96     	; 0x5034 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    4fd4:	81 91       	ld	r24, Z+
    4fd6:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    4fd8:	ea 15       	cp	r30, r10
    4fda:	fb 05       	cpc	r31, r11
    4fdc:	d9 f7       	brne	.-10     	; 0x4fd4 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4fde:	fa 01       	movw	r30, r20
    4fe0:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    4fe2:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    4fe4:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    4fe6:	12 8a       	std	Z+18, r1	; 0x12
    4fe8:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    4fea:	29 85       	ldd	r18, Y+9	; 0x09
    4fec:	3a 85       	ldd	r19, Y+10	; 0x0a
    4fee:	24 8b       	std	Z+20, r18	; 0x14
    4ff0:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    4ff2:	62 8e       	std	Z+26, r6	; 0x1a
    4ff4:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    4ff6:	80 91 50 40 	lds	r24, 0x4050
    4ffa:	90 91 51 40 	lds	r25, 0x4051
    4ffe:	a0 91 52 40 	lds	r26, 0x4052
    5002:	b0 91 53 40 	lds	r27, 0x4053
    5006:	84 8f       	std	Z+28, r24	; 0x1c
    5008:	95 8f       	std	Z+29, r25	; 0x1d
    500a:	a6 8f       	std	Z+30, r26	; 0x1e
    500c:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    500e:	c7 01       	movw	r24, r14
    5010:	b6 01       	movw	r22, r12
    5012:	a2 01       	movw	r20, r4
    5014:	20 e0       	ldi	r18, 0x00	; 0
    5016:	32 e0       	ldi	r19, 0x02	; 2
    5018:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    501c:	40 91 50 40 	lds	r20, 0x4050
    5020:	50 91 51 40 	lds	r21, 0x4051
    5024:	60 91 52 40 	lds	r22, 0x4052
    5028:	70 91 53 40 	lds	r23, 0x4053
    502c:	81 e0       	ldi	r24, 0x01	; 1
    502e:	0e 94 32 23 	call	0x4664	; 0x4664 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    5032:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5034:	00 5e       	subi	r16, 0xE0	; 224
    5036:	1f 4f       	sbci	r17, 0xFF	; 255
    5038:	80 91 54 40 	lds	r24, 0x4054
    503c:	90 91 55 40 	lds	r25, 0x4055
    5040:	08 17       	cp	r16, r24
    5042:	19 07       	cpc	r17, r25
    5044:	08 f4       	brcc	.+2      	; 0x5048 <writeFile+0x4c4>
    5046:	b4 cf       	rjmp	.-152    	; 0x4fb0 <writeFile+0x42c>
    5048:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    504a:	09 81       	ldd	r16, Y+1	; 0x01
    504c:	0f 5f       	subi	r16, 0xFF	; 255
    504e:	09 83       	std	Y+1, r16	; 0x01
    5050:	20 91 7b 50 	lds	r18, 0x507B
    5054:	30 91 7c 50 	lds	r19, 0x507C
    5058:	80 2f       	mov	r24, r16
    505a:	90 e0       	ldi	r25, 0x00	; 0
    505c:	82 17       	cp	r24, r18
    505e:	93 07       	cpc	r25, r19
    5060:	08 f4       	brcc	.+2      	; 0x5064 <writeFile+0x4e0>
    5062:	8a cf       	rjmp	.-236    	; 0x4f78 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    5064:	6b 85       	ldd	r22, Y+11	; 0x0b
    5066:	7c 85       	ldd	r23, Y+12	; 0x0c
    5068:	8d 85       	ldd	r24, Y+13	; 0x0d
    506a:	9e 85       	ldd	r25, Y+14	; 0x0e
    506c:	40 e0       	ldi	r20, 0x00	; 0
    506e:	00 e0       	ldi	r16, 0x00	; 0
    5070:	10 e0       	ldi	r17, 0x00	; 0
    5072:	98 01       	movw	r18, r16
    5074:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
    5078:	6b 01       	movw	r12, r22
    507a:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    507c:	67 3f       	cpi	r22, 0xF7	; 247
    507e:	1f ef       	ldi	r17, 0xFF	; 255
    5080:	71 07       	cpc	r23, r17
    5082:	1f ef       	ldi	r17, 0xFF	; 255
    5084:	81 07       	cpc	r24, r17
    5086:	1f e0       	ldi	r17, 0x0F	; 15
    5088:	91 07       	cpc	r25, r17
    508a:	08 f1       	brcs	.+66     	; 0x50ce <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    508c:	6f 3f       	cpi	r22, 0xFF	; 255
    508e:	2f ef       	ldi	r18, 0xFF	; 255
    5090:	72 07       	cpc	r23, r18
    5092:	2f ef       	ldi	r18, 0xFF	; 255
    5094:	82 07       	cpc	r24, r18
    5096:	2f ef       	ldi	r18, 0xFF	; 255
    5098:	92 07       	cpc	r25, r18
    509a:	59 f5       	brne	.+86     	; 0x50f2 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    509c:	6b 85       	ldd	r22, Y+11	; 0x0b
    509e:	7c 85       	ldd	r23, Y+12	; 0x0c
    50a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    50a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    50a4:	0e 94 7f 22 	call	0x44fe	; 0x44fe <searchNextFreeCluster>
    50a8:	6b 01       	movw	r12, r22
    50aa:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    50ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    50ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    50b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    50b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    50b4:	41 e0       	ldi	r20, 0x01	; 1
    50b6:	97 01       	movw	r18, r14
    50b8:	86 01       	movw	r16, r12
    50ba:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    50be:	c7 01       	movw	r24, r14
    50c0:	b6 01       	movw	r22, r12
    50c2:	41 e0       	ldi	r20, 0x01	; 1
    50c4:	0f ef       	ldi	r16, 0xFF	; 255
    50c6:	1f ef       	ldi	r17, 0xFF	; 255
    50c8:	98 01       	movw	r18, r16
    50ca:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    50ce:	c1 14       	cp	r12, r1
    50d0:	d1 04       	cpc	r13, r1
    50d2:	e1 04       	cpc	r14, r1
    50d4:	f1 04       	cpc	r15, r1
    50d6:	09 f0       	breq	.+2      	; 0x50da <writeFile+0x556>
    50d8:	39 cf       	rjmp	.-398    	; 0x4f4c <writeFile+0x3c8>
	   return 4;
    50da:	84 e0       	ldi	r24, 0x04	; 4
    50dc:	0b c0       	rjmp	.+22     	; 0x50f4 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    50de:	81 e0       	ldi	r24, 0x01	; 1
    50e0:	09 c0       	rjmp	.+18     	; 0x50f4 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    50e2:	82 e0       	ldi	r24, 0x02	; 2
    50e4:	07 c0       	rjmp	.+14     	; 0x50f4 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    50e6:	82 e0       	ldi	r24, 0x02	; 2
    50e8:	05 c0       	rjmp	.+10     	; 0x50f4 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    50ea:	80 e0       	ldi	r24, 0x00	; 0
    50ec:	03 c0       	rjmp	.+6      	; 0x50f4 <writeFile+0x570>
    50ee:	80 e0       	ldi	r24, 0x00	; 0
    50f0:	01 c0       	rjmp	.+2      	; 0x50f4 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    50f2:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    50f4:	60 96       	adiw	r28, 0x10	; 16
    50f6:	cd bf       	out	0x3d, r28	; 61
    50f8:	de bf       	out	0x3e, r29	; 62
    50fa:	df 91       	pop	r29
    50fc:	cf 91       	pop	r28
    50fe:	1f 91       	pop	r17
    5100:	0f 91       	pop	r16
    5102:	ff 90       	pop	r15
    5104:	ef 90       	pop	r14
    5106:	df 90       	pop	r13
    5108:	cf 90       	pop	r12
    510a:	bf 90       	pop	r11
    510c:	af 90       	pop	r10
    510e:	9f 90       	pop	r9
    5110:	8f 90       	pop	r8
    5112:	7f 90       	pop	r7
    5114:	6f 90       	pop	r6
    5116:	5f 90       	pop	r5
    5118:	4f 90       	pop	r4
    511a:	3f 90       	pop	r3
    511c:	2f 90       	pop	r2
    511e:	08 95       	ret

00005120 <SPI_write>:
}	

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    5120:	e0 ec       	ldi	r30, 0xC0	; 192
    5122:	f8 e0       	ldi	r31, 0x08	; 8
    5124:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5126:	82 81       	ldd	r24, Z+2	; 0x02
    5128:	88 23       	and	r24, r24
    512a:	ec f7       	brge	.-6      	; 0x5126 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    512c:	e0 ec       	ldi	r30, 0xC0	; 192
    512e:	f8 e0       	ldi	r31, 0x08	; 8
    5130:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    5132:	08 95       	ret

00005134 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    5134:	8f 92       	push	r8
    5136:	9f 92       	push	r9
    5138:	af 92       	push	r10
    513a:	bf 92       	push	r11
    513c:	cf 92       	push	r12
    513e:	df 92       	push	r13
    5140:	ef 92       	push	r14
    5142:	ff 92       	push	r15
    5144:	0f 93       	push	r16
    5146:	1f 93       	push	r17
    5148:	cf 93       	push	r28
    514a:	df 93       	push	r29
    514c:	84 2e       	mov	r8, r20
    514e:	a5 2e       	mov	r10, r21
    5150:	c6 2e       	mov	r12, r22
    5152:	c7 2f       	mov	r28, r23
    5154:	d2 2f       	mov	r29, r18
    5156:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    5158:	80 64       	ori	r24, 0x40	; 64
    515a:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    515e:	8c 2f       	mov	r24, r28
    5160:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    5164:	8c 2d       	mov	r24, r12
    5166:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    516a:	8a 2d       	mov	r24, r10
    516c:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5170:	88 2d       	mov	r24, r8
    5172:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
	SPI_write(crc);
    5176:	8d 2f       	mov	r24, r29
    5178:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
	
	for(int i=0; i<read; i++){
    517c:	10 16       	cp	r1, r16
    517e:	11 06       	cpc	r1, r17
    5180:	64 f5       	brge	.+88     	; 0x51da <SD_command+0xa6>
    5182:	00 e0       	ldi	r16, 0x00	; 0
    5184:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    5186:	0f 2e       	mov	r0, r31
    5188:	fd e0       	ldi	r31, 0x0D	; 13
    518a:	cf 2e       	mov	r12, r31
    518c:	dd 24       	eor	r13, r13
    518e:	f0 2d       	mov	r31, r0
    5190:	0f 2e       	mov	r0, r31
    5192:	fe ea       	ldi	r31, 0xAE	; 174
    5194:	af 2e       	mov	r10, r31
    5196:	f0 e5       	ldi	r31, 0x50	; 80
    5198:	bf 2e       	mov	r11, r31
    519a:	f0 2d       	mov	r31, r0
    519c:	c8 01       	movw	r24, r16
    519e:	b6 01       	movw	r22, r12
    51a0:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    51a4:	ec 01       	movw	r28, r24
    51a6:	8f ef       	ldi	r24, 0xFF	; 255
    51a8:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    51ac:	f5 01       	movw	r30, r10
    51ae:	ec 0f       	add	r30, r28
    51b0:	fd 1f       	adc	r31, r29
    51b2:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    51b4:	80 81       	ld	r24, Z
    51b6:	8f 3f       	cpi	r24, 0xFF	; 255
    51b8:	49 f0       	breq	.+18     	; 0x51cc <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    51ba:	fe 01       	movw	r30, r28
    51bc:	e2 55       	subi	r30, 0x52	; 82
    51be:	ff 4a       	sbci	r31, 0xAF	; 175
    51c0:	80 81       	ld	r24, Z
    51c2:	80 93 af 50 	sts	0x50AF, r24
			return Buffer[1];
    51c6:	80 91 af 50 	lds	r24, 0x50AF
    51ca:	08 c0       	rjmp	.+16     	; 0x51dc <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    51cc:	0f 5f       	subi	r16, 0xFF	; 255
    51ce:	1f 4f       	sbci	r17, 0xFF	; 255
    51d0:	0e 15       	cp	r16, r14
    51d2:	1f 05       	cpc	r17, r15
    51d4:	19 f7       	brne	.-58     	; 0x519c <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    51d6:	8f ef       	ldi	r24, 0xFF	; 255
    51d8:	01 c0       	rjmp	.+2      	; 0x51dc <SD_command+0xa8>
    51da:	8f ef       	ldi	r24, 0xFF	; 255
}
    51dc:	df 91       	pop	r29
    51de:	cf 91       	pop	r28
    51e0:	1f 91       	pop	r17
    51e2:	0f 91       	pop	r16
    51e4:	ff 90       	pop	r15
    51e6:	ef 90       	pop	r14
    51e8:	df 90       	pop	r13
    51ea:	cf 90       	pop	r12
    51ec:	bf 90       	pop	r11
    51ee:	af 90       	pop	r10
    51f0:	9f 90       	pop	r9
    51f2:	8f 90       	pop	r8
    51f4:	08 95       	ret

000051f6 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    51f6:	ff 92       	push	r15
    51f8:	0f 93       	push	r16
    51fa:	1f 93       	push	r17
    51fc:	cf 93       	push	r28
    51fe:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    5200:	81 e0       	ldi	r24, 0x01	; 1
    5202:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    5206:	81 e0       	ldi	r24, 0x01	; 1
    5208:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <Ext1Power>
    520c:	8f ef       	ldi	r24, 0xFF	; 255
    520e:	93 ec       	ldi	r25, 0xC3	; 195
    5210:	a9 e0       	ldi	r26, 0x09	; 9
    5212:	81 50       	subi	r24, 0x01	; 1
    5214:	90 40       	sbci	r25, 0x00	; 0
    5216:	a0 40       	sbci	r26, 0x00	; 0
    5218:	e1 f7       	brne	.-8      	; 0x5212 <SD_init+0x1c>
    521a:	00 c0       	rjmp	.+0      	; 0x521c <SD_init+0x26>
    521c:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    521e:	88 e0       	ldi	r24, 0x08	; 8
    5220:	60 e0       	ldi	r22, 0x00	; 0
    5222:	0e 94 95 1c 	call	0x392a	; 0x392a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5226:	88 e0       	ldi	r24, 0x08	; 8
    5228:	60 e0       	ldi	r22, 0x00	; 0
    522a:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    522e:	80 e0       	ldi	r24, 0x00	; 0
    5230:	63 e0       	ldi	r22, 0x03	; 3
    5232:	0e 94 69 1b 	call	0x36d2	; 0x36d2 <SPIInit2>
	SPICS(TRUE);
    5236:	81 e0       	ldi	r24, 0x01	; 1
    5238:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
    523c:	8a e0       	ldi	r24, 0x0A	; 10
    523e:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    5240:	e0 ec       	ldi	r30, 0xC0	; 192
    5242:	f8 e0       	ldi	r31, 0x08	; 8
    5244:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    5246:	aa eb       	ldi	r26, 0xBA	; 186
    5248:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    524a:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    524c:	22 81       	ldd	r18, Z+2	; 0x02
    524e:	22 23       	and	r18, r18
    5250:	ec f7       	brge	.-6      	; 0x524c <SD_init+0x56>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    5252:	23 81       	ldd	r18, Z+3	; 0x03
    5254:	2c 93       	st	X, r18
    5256:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    5258:	c1 f7       	brne	.-16     	; 0x524a <SD_init+0x54>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    525a:	80 e0       	ldi	r24, 0x00	; 0
    525c:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    5260:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5264:	88 e0       	ldi	r24, 0x08	; 8
    5266:	60 e0       	ldi	r22, 0x00	; 0
    5268:	0e 94 91 1b 	call	0x3722	; 0x3722 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    526c:	80 e0       	ldi	r24, 0x00	; 0
    526e:	63 e0       	ldi	r22, 0x03	; 3
    5270:	0e 94 69 1b 	call	0x36d2	; 0x36d2 <SPIInit2>
	SPICS(TRUE);
    5274:	81 e0       	ldi	r24, 0x01	; 1
    5276:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    527a:	cb e0       	ldi	r28, 0x0B	; 11
    527c:	d0 e0       	ldi	r29, 0x00	; 0
    527e:	02 c0       	rjmp	.+4      	; 0x5284 <SD_init+0x8e>
    5280:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    5282:	69 f0       	breq	.+26     	; 0x529e <SD_init+0xa8>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    5284:	80 e0       	ldi	r24, 0x00	; 0
    5286:	40 e0       	ldi	r20, 0x00	; 0
    5288:	50 e0       	ldi	r21, 0x00	; 0
    528a:	ba 01       	movw	r22, r20
    528c:	25 e9       	ldi	r18, 0x95	; 149
    528e:	08 e0       	ldi	r16, 0x08	; 8
    5290:	10 e0       	ldi	r17, 0x00	; 0
    5292:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
    5296:	81 30       	cpi	r24, 0x01	; 1
    5298:	99 f7       	brne	.-26     	; 0x5280 <SD_init+0x8a>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    529a:	ff 24       	eor	r15, r15
    529c:	02 c0       	rjmp	.+4      	; 0x52a2 <SD_init+0xac>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    529e:	ff 24       	eor	r15, r15
    52a0:	f3 94       	inc	r15
    52a2:	8f ef       	ldi	r24, 0xFF	; 255
    52a4:	93 ec       	ldi	r25, 0xC3	; 195
    52a6:	a9 e0       	ldi	r26, 0x09	; 9
    52a8:	81 50       	subi	r24, 0x01	; 1
    52aa:	90 40       	sbci	r25, 0x00	; 0
    52ac:	a0 40       	sbci	r26, 0x00	; 0
    52ae:	e1 f7       	brne	.-8      	; 0x52a8 <SD_init+0xb2>
    52b0:	00 c0       	rjmp	.+0      	; 0x52b2 <SD_init+0xbc>
    52b2:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    52b4:	cb e0       	ldi	r28, 0x0B	; 11
    52b6:	d0 e0       	ldi	r29, 0x00	; 0
    52b8:	02 c0       	rjmp	.+4      	; 0x52be <SD_init+0xc8>
    52ba:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    52bc:	69 f0       	breq	.+26     	; 0x52d8 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    52be:	88 e0       	ldi	r24, 0x08	; 8
    52c0:	4a ea       	ldi	r20, 0xAA	; 170
    52c2:	51 e0       	ldi	r21, 0x01	; 1
    52c4:	60 e0       	ldi	r22, 0x00	; 0
    52c6:	70 e0       	ldi	r23, 0x00	; 0
    52c8:	27 e8       	ldi	r18, 0x87	; 135
    52ca:	08 e0       	ldi	r16, 0x08	; 8
    52cc:	10 e0       	ldi	r17, 0x00	; 0
    52ce:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
    52d2:	81 30       	cpi	r24, 0x01	; 1
    52d4:	91 f7       	brne	.-28     	; 0x52ba <SD_init+0xc4>
    52d6:	02 c0       	rjmp	.+4      	; 0x52dc <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    52d8:	ff 24       	eor	r15, r15
    52da:	f3 94       	inc	r15
    52dc:	c2 e0       	ldi	r28, 0x02	; 2
    52de:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    52e0:	0e ea       	ldi	r16, 0xAE	; 174
    52e2:	10 e5       	ldi	r17, 0x50	; 80
    52e4:	8f ef       	ldi	r24, 0xFF	; 255
    52e6:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    52ea:	f8 01       	movw	r30, r16
    52ec:	ec 0f       	add	r30, r28
    52ee:	fd 1f       	adc	r31, r29
    52f0:	80 83       	st	Z, r24
    52f2:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    52f4:	c6 30       	cpi	r28, 0x06	; 6
    52f6:	d1 05       	cpc	r29, r1
    52f8:	a9 f7       	brne	.-22     	; 0x52e4 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    52fa:	80 91 b2 50 	lds	r24, 0x50B2
    52fe:	81 30       	cpi	r24, 0x01	; 1
    5300:	29 f4       	brne	.+10     	; 0x530c <SD_init+0x116>
    5302:	80 91 b3 50 	lds	r24, 0x50B3
    5306:	8a 3a       	cpi	r24, 0xAA	; 170
    5308:	21 f4       	brne	.+8      	; 0x5312 <SD_init+0x11c>
    530a:	05 c0       	rjmp	.+10     	; 0x5316 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    530c:	ff 24       	eor	r15, r15
    530e:	f3 94       	inc	r15
    5310:	02 c0       	rjmp	.+4      	; 0x5316 <SD_init+0x120>
    5312:	ff 24       	eor	r15, r15
    5314:	f3 94       	inc	r15
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    5316:	cf ea       	ldi	r28, 0xAF	; 175
    5318:	d0 e5       	ldi	r29, 0x50	; 80
		//broken card or voltage out of operating range bounds
		errorCode = 1;
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    531a:	87 e3       	ldi	r24, 0x37	; 55
    531c:	40 e0       	ldi	r20, 0x00	; 0
    531e:	50 e0       	ldi	r21, 0x00	; 0
    5320:	ba 01       	movw	r22, r20
    5322:	2f ef       	ldi	r18, 0xFF	; 255
    5324:	08 e0       	ldi	r16, 0x08	; 8
    5326:	10 e0       	ldi	r17, 0x00	; 0
    5328:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    532c:	81 e0       	ldi	r24, 0x01	; 1
    532e:	40 e0       	ldi	r20, 0x00	; 0
    5330:	50 e0       	ldi	r21, 0x00	; 0
    5332:	60 e0       	ldi	r22, 0x00	; 0
    5334:	70 e4       	ldi	r23, 0x40	; 64
    5336:	2f ef       	ldi	r18, 0xFF	; 255
    5338:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
	} while(Buffer[1]!= 0x00);
    533c:	88 81       	ld	r24, Y
    533e:	88 23       	and	r24, r24
    5340:	61 f7       	brne	.-40     	; 0x531a <SD_init+0x124>
    5342:	cb e0       	ldi	r28, 0x0B	; 11
    5344:	d0 e0       	ldi	r29, 0x00	; 0
    5346:	02 c0       	rjmp	.+4      	; 0x534c <SD_init+0x156>
    5348:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    534a:	61 f0       	breq	.+24     	; 0x5364 <SD_init+0x16e>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    534c:	8a e3       	ldi	r24, 0x3A	; 58
    534e:	40 e0       	ldi	r20, 0x00	; 0
    5350:	50 e0       	ldi	r21, 0x00	; 0
    5352:	ba 01       	movw	r22, r20
    5354:	2f ef       	ldi	r18, 0xFF	; 255
    5356:	08 e0       	ldi	r16, 0x08	; 8
    5358:	10 e0       	ldi	r17, 0x00	; 0
    535a:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
    535e:	88 23       	and	r24, r24
    5360:	99 f7       	brne	.-26     	; 0x5348 <SD_init+0x152>
    5362:	02 c0       	rjmp	.+4      	; 0x5368 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5364:	ff 24       	eor	r15, r15
    5366:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5368:	c0 e0       	ldi	r28, 0x00	; 0
    536a:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    536c:	0e ea       	ldi	r16, 0xAE	; 174
    536e:	10 e5       	ldi	r17, 0x50	; 80
    5370:	8f ef       	ldi	r24, 0xFF	; 255
    5372:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5376:	f8 01       	movw	r30, r16
    5378:	ec 0f       	add	r30, r28
    537a:	fd 1f       	adc	r31, r29
    537c:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    537e:	21 96       	adiw	r28, 0x01	; 1
    5380:	c4 30       	cpi	r28, 0x04	; 4
    5382:	d1 05       	cpc	r29, r1
    5384:	a9 f7       	brne	.-22     	; 0x5370 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5386:	80 91 ae 50 	lds	r24, 0x50AE
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    538a:	80 e0       	ldi	r24, 0x00	; 0
    538c:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    5390:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5394:	88 e0       	ldi	r24, 0x08	; 8
    5396:	60 e0       	ldi	r22, 0x00	; 0
    5398:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
	return errorCode;	
}	
    539c:	8f 2d       	mov	r24, r15
    539e:	df 91       	pop	r29
    53a0:	cf 91       	pop	r28
    53a2:	1f 91       	pop	r17
    53a4:	0f 91       	pop	r16
    53a6:	ff 90       	pop	r15
    53a8:	08 95       	ret

000053aa <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    53aa:	6f 92       	push	r6
    53ac:	7f 92       	push	r7
    53ae:	8f 92       	push	r8
    53b0:	9f 92       	push	r9
    53b2:	af 92       	push	r10
    53b4:	bf 92       	push	r11
    53b6:	cf 92       	push	r12
    53b8:	df 92       	push	r13
    53ba:	ef 92       	push	r14
    53bc:	ff 92       	push	r15
    53be:	0f 93       	push	r16
    53c0:	1f 93       	push	r17
    53c2:	cf 93       	push	r28
    53c4:	df 93       	push	r29
    53c6:	4b 01       	movw	r8, r22
    53c8:	5c 01       	movw	r10, r24
    53ca:	74 2e       	mov	r7, r20
    53cc:	65 2e       	mov	r6, r21
    53ce:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    53d0:	88 e0       	ldi	r24, 0x08	; 8
    53d2:	60 e0       	ldi	r22, 0x00	; 0
    53d4:	0e 94 91 1b 	call	0x3722	; 0x3722 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    53d8:	80 e0       	ldi	r24, 0x00	; 0
    53da:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    53de:	81 e0       	ldi	r24, 0x01	; 1
    53e0:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    53e4:	80 e0       	ldi	r24, 0x00	; 0
    53e6:	92 e0       	ldi	r25, 0x02	; 2
    53e8:	7c 01       	movw	r14, r24
    53ea:	ec 18       	sub	r14, r12
    53ec:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    53ee:	80 e0       	ldi	r24, 0x00	; 0
    53f0:	e8 16       	cp	r14, r24
    53f2:	82 e0       	ldi	r24, 0x02	; 2
    53f4:	f8 06       	cpc	r15, r24
    53f6:	11 f4       	brne	.+4      	; 0x53fc <SD_write_block+0x52>
    53f8:	ee 24       	eor	r14, r14
    53fa:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    53fc:	cb e0       	ldi	r28, 0x0B	; 11
    53fe:	d0 e0       	ldi	r29, 0x00	; 0
    5400:	03 c0       	rjmp	.+6      	; 0x5408 <SD_write_block+0x5e>
    5402:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    5404:	09 f4       	brne	.+2      	; 0x5408 <SD_write_block+0x5e>
    5406:	ff cf       	rjmp	.-2      	; 0x5406 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5408:	88 e1       	ldi	r24, 0x18	; 24
    540a:	b5 01       	movw	r22, r10
    540c:	a4 01       	movw	r20, r8
    540e:	2f ef       	ldi	r18, 0xFF	; 255
    5410:	08 e0       	ldi	r16, 0x08	; 8
    5412:	10 e0       	ldi	r17, 0x00	; 0
    5414:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
    5418:	88 23       	and	r24, r24
    541a:	99 f7       	brne	.-26     	; 0x5402 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    541c:	8f ef       	ldi	r24, 0xFF	; 255
    541e:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5422:	80 93 ae 50 	sts	0x50AE, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    5426:	8e ef       	ldi	r24, 0xFE	; 254
    5428:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    542c:	1c 14       	cp	r1, r12
    542e:	1d 04       	cpc	r1, r13
    5430:	bc f4       	brge	.+46     	; 0x5460 <SD_write_block+0xb6>
    5432:	87 2c       	mov	r8, r7
    5434:	96 2c       	mov	r9, r6
    5436:	00 e0       	ldi	r16, 0x00	; 0
    5438:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    543a:	c8 01       	movw	r24, r16
    543c:	6d e0       	ldi	r22, 0x0D	; 13
    543e:	70 e0       	ldi	r23, 0x00	; 0
    5440:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    5444:	ec 01       	movw	r28, r24
    5446:	f4 01       	movw	r30, r8
    5448:	81 91       	ld	r24, Z+
    544a:	4f 01       	movw	r8, r30
    544c:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5450:	c2 55       	subi	r28, 0x52	; 82
    5452:	df 4a       	sbci	r29, 0xAF	; 175
    5454:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5456:	0f 5f       	subi	r16, 0xFF	; 255
    5458:	1f 4f       	sbci	r17, 0xFF	; 255
    545a:	0c 15       	cp	r16, r12
    545c:	1d 05       	cpc	r17, r13
    545e:	69 f7       	brne	.-38     	; 0x543a <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5460:	1e 14       	cp	r1, r14
    5462:	1f 04       	cpc	r1, r15
    5464:	ec f4       	brge	.+58     	; 0x54a0 <SD_write_block+0xf6>
    5466:	00 e0       	ldi	r16, 0x00	; 0
    5468:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    546a:	0f 2e       	mov	r0, r31
    546c:	fd e0       	ldi	r31, 0x0D	; 13
    546e:	cf 2e       	mov	r12, r31
    5470:	dd 24       	eor	r13, r13
    5472:	f0 2d       	mov	r31, r0
    5474:	0f 2e       	mov	r0, r31
    5476:	fe ea       	ldi	r31, 0xAE	; 174
    5478:	8f 2e       	mov	r8, r31
    547a:	f0 e5       	ldi	r31, 0x50	; 80
    547c:	9f 2e       	mov	r9, r31
    547e:	f0 2d       	mov	r31, r0
    5480:	c8 01       	movw	r24, r16
    5482:	b6 01       	movw	r22, r12
    5484:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    5488:	ec 01       	movw	r28, r24
    548a:	80 e0       	ldi	r24, 0x00	; 0
    548c:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5490:	c8 0d       	add	r28, r8
    5492:	d9 1d       	adc	r29, r9
    5494:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5496:	0f 5f       	subi	r16, 0xFF	; 255
    5498:	1f 4f       	sbci	r17, 0xFF	; 255
    549a:	0e 15       	cp	r16, r14
    549c:	1f 05       	cpc	r17, r15
    549e:	81 f7       	brne	.-32     	; 0x5480 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    54a0:	8f ef       	ldi	r24, 0xFF	; 255
    54a2:	80 93 ae 50 	sts	0x50AE, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    54a6:	c0 e0       	ldi	r28, 0x00	; 0
    54a8:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    54aa:	0e ea       	ldi	r16, 0xAE	; 174
    54ac:	10 e5       	ldi	r17, 0x50	; 80
    54ae:	8f ef       	ldi	r24, 0xFF	; 255
    54b0:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    54b4:	f8 01       	movw	r30, r16
    54b6:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    54b8:	21 96       	adiw	r28, 0x01	; 1
    54ba:	c2 30       	cpi	r28, 0x02	; 2
    54bc:	d1 05       	cpc	r29, r1
    54be:	bc f3       	brlt	.-18     	; 0x54ae <SD_write_block+0x104>
    54c0:	80 81       	ld	r24, Z
    54c2:	8f 3f       	cpi	r24, 0xFF	; 255
    54c4:	a1 f3       	breq	.-24     	; 0x54ae <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    54c6:	80 91 ae 50 	lds	r24, 0x50AE
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    54ca:	80 91 ae 50 	lds	r24, 0x50AE
    54ce:	8f 3f       	cpi	r24, 0xFF	; 255
    54d0:	49 f0       	breq	.+18     	; 0x54e4 <SD_write_block+0x13a>
    54d2:	ce ea       	ldi	r28, 0xAE	; 174
    54d4:	d0 e5       	ldi	r29, 0x50	; 80
    54d6:	8f ef       	ldi	r24, 0xFF	; 255
    54d8:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    54dc:	88 83       	st	Y, r24
    54de:	88 81       	ld	r24, Y
    54e0:	8f 3f       	cpi	r24, 0xFF	; 255
    54e2:	c9 f7       	brne	.-14     	; 0x54d6 <SD_write_block+0x12c>
	SPICS(FALSE);
    54e4:	80 e0       	ldi	r24, 0x00	; 0
    54e6:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    54ea:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    54ee:	88 e0       	ldi	r24, 0x08	; 8
    54f0:	60 e0       	ldi	r22, 0x00	; 0
    54f2:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
}
    54f6:	df 91       	pop	r29
    54f8:	cf 91       	pop	r28
    54fa:	1f 91       	pop	r17
    54fc:	0f 91       	pop	r16
    54fe:	ff 90       	pop	r15
    5500:	ef 90       	pop	r14
    5502:	df 90       	pop	r13
    5504:	cf 90       	pop	r12
    5506:	bf 90       	pop	r11
    5508:	af 90       	pop	r10
    550a:	9f 90       	pop	r9
    550c:	8f 90       	pop	r8
    550e:	7f 90       	pop	r7
    5510:	6f 90       	pop	r6
    5512:	08 95       	ret

00005514 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    5514:	af 92       	push	r10
    5516:	bf 92       	push	r11
    5518:	cf 92       	push	r12
    551a:	df 92       	push	r13
    551c:	ef 92       	push	r14
    551e:	ff 92       	push	r15
    5520:	0f 93       	push	r16
    5522:	1f 93       	push	r17
    5524:	cf 93       	push	r28
    5526:	df 93       	push	r29
    5528:	6b 01       	movw	r12, r22
    552a:	7c 01       	movw	r14, r24
    552c:	b4 2e       	mov	r11, r20
    552e:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5530:	88 e0       	ldi	r24, 0x08	; 8
    5532:	60 e0       	ldi	r22, 0x00	; 0
    5534:	0e 94 91 1b 	call	0x3722	; 0x3722 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5538:	80 e0       	ldi	r24, 0x00	; 0
    553a:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    553e:	81 e0       	ldi	r24, 0x01	; 1
    5540:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5544:	cb e0       	ldi	r28, 0x0B	; 11
    5546:	d0 e0       	ldi	r29, 0x00	; 0
    5548:	03 c0       	rjmp	.+6      	; 0x5550 <SD_read_block+0x3c>
    554a:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    554c:	09 f4       	brne	.+2      	; 0x5550 <SD_read_block+0x3c>
    554e:	ff cf       	rjmp	.-2      	; 0x554e <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5550:	81 e1       	ldi	r24, 0x11	; 17
    5552:	b7 01       	movw	r22, r14
    5554:	a6 01       	movw	r20, r12
    5556:	2f ef       	ldi	r18, 0xFF	; 255
    5558:	08 e0       	ldi	r16, 0x08	; 8
    555a:	10 e0       	ldi	r17, 0x00	; 0
    555c:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
    5560:	88 23       	and	r24, r24
    5562:	99 f7       	brne	.-26     	; 0x554a <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5564:	80 91 ae 50 	lds	r24, 0x50AE
    5568:	8e 3f       	cpi	r24, 0xFE	; 254
    556a:	49 f0       	breq	.+18     	; 0x557e <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    556c:	ce ea       	ldi	r28, 0xAE	; 174
    556e:	d0 e5       	ldi	r29, 0x50	; 80
    5570:	8f ef       	ldi	r24, 0xFF	; 255
    5572:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5576:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5578:	88 81       	ld	r24, Y
    557a:	8e 3f       	cpi	r24, 0xFE	; 254
    557c:	c9 f7       	brne	.-14     	; 0x5570 <SD_read_block+0x5c>
    557e:	0b 2d       	mov	r16, r11
    5580:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5582:	c0 e0       	ldi	r28, 0x00	; 0
    5584:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5586:	8f ef       	ldi	r24, 0xFF	; 255
    5588:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    558c:	f8 01       	movw	r30, r16
    558e:	81 93       	st	Z+, r24
    5590:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5592:	21 96       	adiw	r28, 0x01	; 1
    5594:	f2 e0       	ldi	r31, 0x02	; 2
    5596:	c0 30       	cpi	r28, 0x00	; 0
    5598:	df 07       	cpc	r29, r31
    559a:	a9 f7       	brne	.-22     	; 0x5586 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    559c:	10 92 ba 50 	sts	0x50BA, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    55a0:	80 91 ba 50 	lds	r24, 0x50BA
    55a4:	8f 3f       	cpi	r24, 0xFF	; 255
    55a6:	49 f0       	breq	.+18     	; 0x55ba <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    55a8:	ca eb       	ldi	r28, 0xBA	; 186
    55aa:	d0 e5       	ldi	r29, 0x50	; 80
    55ac:	8f ef       	ldi	r24, 0xFF	; 255
    55ae:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    55b2:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    55b4:	88 81       	ld	r24, Y
    55b6:	8f 3f       	cpi	r24, 0xFF	; 255
    55b8:	c9 f7       	brne	.-14     	; 0x55ac <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    55ba:	80 e0       	ldi	r24, 0x00	; 0
    55bc:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    55c0:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    55c4:	88 e0       	ldi	r24, 0x08	; 8
    55c6:	60 e0       	ldi	r22, 0x00	; 0
    55c8:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
}
    55cc:	df 91       	pop	r29
    55ce:	cf 91       	pop	r28
    55d0:	1f 91       	pop	r17
    55d2:	0f 91       	pop	r16
    55d4:	ff 90       	pop	r15
    55d6:	ef 90       	pop	r14
    55d8:	df 90       	pop	r13
    55da:	cf 90       	pop	r12
    55dc:	bf 90       	pop	r11
    55de:	af 90       	pop	r10
    55e0:	08 95       	ret

000055e2 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    55e2:	2f 92       	push	r2
    55e4:	3f 92       	push	r3
    55e6:	4f 92       	push	r4
    55e8:	5f 92       	push	r5
    55ea:	6f 92       	push	r6
    55ec:	7f 92       	push	r7
    55ee:	8f 92       	push	r8
    55f0:	9f 92       	push	r9
    55f2:	af 92       	push	r10
    55f4:	bf 92       	push	r11
    55f6:	cf 92       	push	r12
    55f8:	df 92       	push	r13
    55fa:	ef 92       	push	r14
    55fc:	ff 92       	push	r15
    55fe:	0f 93       	push	r16
    5600:	1f 93       	push	r17
    5602:	cf 93       	push	r28
    5604:	df 93       	push	r29
    5606:	cd b7       	in	r28, 0x3d	; 61
    5608:	de b7       	in	r29, 0x3e	; 62
    560a:	2a 97       	sbiw	r28, 0x0a	; 10
    560c:	cd bf       	out	0x3d, r28	; 61
    560e:	de bf       	out	0x3e, r29	; 62
    5610:	6b 01       	movw	r12, r22
    5612:	7c 01       	movw	r14, r24
    5614:	4f 83       	std	Y+7, r20	; 0x07
    5616:	58 87       	std	Y+8, r21	; 0x08
    5618:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    561a:	88 e0       	ldi	r24, 0x08	; 8
    561c:	60 e0       	ldi	r22, 0x00	; 0
    561e:	0e 94 91 1b 	call	0x3722	; 0x3722 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5622:	80 e0       	ldi	r24, 0x00	; 0
    5624:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    5628:	81 e0       	ldi	r24, 0x01	; 1
    562a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    562e:	c8 01       	movw	r24, r16
    5630:	11 23       	and	r17, r17
    5632:	14 f4       	brge	.+4      	; 0x5638 <SD_write_multiple_blocks+0x56>
    5634:	81 50       	subi	r24, 0x01	; 1
    5636:	9e 4f       	sbci	r25, 0xFE	; 254
    5638:	9c 01       	movw	r18, r24
    563a:	23 2f       	mov	r18, r19
    563c:	33 0f       	add	r19, r19
    563e:	33 0b       	sbc	r19, r19
    5640:	25 95       	asr	r18
    5642:	2b 83       	std	Y+3, r18	; 0x03
    5644:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5646:	20 e0       	ldi	r18, 0x00	; 0
    5648:	32 e0       	ldi	r19, 0x02	; 2
    564a:	c8 01       	movw	r24, r16
    564c:	b9 01       	movw	r22, r18
    564e:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    5652:	29 01       	movw	r4, r18
    5654:	48 1a       	sub	r4, r24
    5656:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5658:	30 e0       	ldi	r19, 0x00	; 0
    565a:	43 16       	cp	r4, r19
    565c:	32 e0       	ldi	r19, 0x02	; 2
    565e:	53 06       	cpc	r5, r19
    5660:	31 f0       	breq	.+12     	; 0x566e <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5662:	8b 81       	ldd	r24, Y+3	; 0x03
    5664:	9c 81       	ldd	r25, Y+4	; 0x04
    5666:	01 96       	adiw	r24, 0x01	; 1
    5668:	8b 83       	std	Y+3, r24	; 0x03
    566a:	9c 83       	std	Y+4, r25	; 0x04
    566c:	02 c0       	rjmp	.+4      	; 0x5672 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    566e:	44 24       	eor	r4, r4
    5670:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5672:	89 e1       	ldi	r24, 0x19	; 25
    5674:	b7 01       	movw	r22, r14
    5676:	a6 01       	movw	r20, r12
    5678:	2f ef       	ldi	r18, 0xFF	; 255
    567a:	08 e0       	ldi	r16, 0x08	; 8
    567c:	10 e0       	ldi	r17, 0x00	; 0
    567e:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
    5682:	88 23       	and	r24, r24
    5684:	b1 f7       	brne	.-20     	; 0x5672 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5686:	eb 81       	ldd	r30, Y+3	; 0x03
    5688:	fc 81       	ldd	r31, Y+4	; 0x04
    568a:	1e 16       	cp	r1, r30
    568c:	1f 06       	cpc	r1, r31
    568e:	0c f0       	brlt	.+2      	; 0x5692 <SD_write_multiple_blocks+0xb0>
    5690:	ac c0       	rjmp	.+344    	; 0x57ea <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5692:	31 97       	sbiw	r30, 0x01	; 1
    5694:	ed 83       	std	Y+5, r30	; 0x05
    5696:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5698:	9f 01       	movw	r18, r30
    569a:	32 2f       	mov	r19, r18
    569c:	22 27       	eor	r18, r18
    569e:	33 0f       	add	r19, r19
    56a0:	8f 81       	ldd	r24, Y+7	; 0x07
    56a2:	98 85       	ldd	r25, Y+8	; 0x08
    56a4:	89 83       	std	Y+1, r24	; 0x01
    56a6:	9a 83       	std	Y+2, r25	; 0x02
    56a8:	66 24       	eor	r6, r6
    56aa:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    56ac:	0f 2e       	mov	r0, r31
    56ae:	ff ea       	ldi	r31, 0xAF	; 175
    56b0:	8f 2e       	mov	r8, r31
    56b2:	f0 e5       	ldi	r31, 0x50	; 80
    56b4:	9f 2e       	mov	r9, r31
    56b6:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    56b8:	0f 2e       	mov	r0, r31
    56ba:	fc e0       	ldi	r31, 0x0C	; 12
    56bc:	cf 2e       	mov	r12, r31
    56be:	dd 24       	eor	r13, r13
    56c0:	f0 2d       	mov	r31, r0
    56c2:	0f 2e       	mov	r0, r31
    56c4:	fe ea       	ldi	r31, 0xAE	; 174
    56c6:	af 2e       	mov	r10, r31
    56c8:	f0 e5       	ldi	r31, 0x50	; 80
    56ca:	bf 2e       	mov	r11, r31
    56cc:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    56ce:	80 e0       	ldi	r24, 0x00	; 0
    56d0:	92 e0       	ldi	r25, 0x02	; 2
    56d2:	1c 01       	movw	r2, r24
    56d4:	24 18       	sub	r2, r4
    56d6:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    56d8:	ef 81       	ldd	r30, Y+7	; 0x07
    56da:	f8 85       	ldd	r31, Y+8	; 0x08
    56dc:	e2 0f       	add	r30, r18
    56de:	f3 1f       	adc	r31, r19
    56e0:	ef 83       	std	Y+7, r30	; 0x07
    56e2:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    56e4:	8f ef       	ldi	r24, 0xFF	; 255
    56e6:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    56ea:	f4 01       	movw	r30, r8
    56ec:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    56ee:	8c ef       	ldi	r24, 0xFC	; 252
    56f0:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    56f4:	f4 01       	movw	r30, r8
    56f6:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    56f8:	2d 81       	ldd	r18, Y+5	; 0x05
    56fa:	3e 81       	ldd	r19, Y+6	; 0x06
    56fc:	26 15       	cp	r18, r6
    56fe:	37 05       	cpc	r19, r7
    5700:	09 f0       	breq	.+2      	; 0x5704 <SD_write_multiple_blocks+0x122>
    5702:	41 c0       	rjmp	.+130    	; 0x5786 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5704:	12 14       	cp	r1, r2
    5706:	13 04       	cpc	r1, r3
    5708:	cc f4       	brge	.+50     	; 0x573c <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    570a:	ef 80       	ldd	r14, Y+7	; 0x07
    570c:	f8 84       	ldd	r15, Y+8	; 0x08
    570e:	00 e0       	ldi	r16, 0x00	; 0
    5710:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5712:	c8 01       	movw	r24, r16
    5714:	b6 01       	movw	r22, r12
    5716:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    571a:	89 87       	std	Y+9, r24	; 0x09
    571c:	9a 87       	std	Y+10, r25	; 0x0a
    571e:	f7 01       	movw	r30, r14
    5720:	81 91       	ld	r24, Z+
    5722:	7f 01       	movw	r14, r30
    5724:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5728:	e9 85       	ldd	r30, Y+9	; 0x09
    572a:	fa 85       	ldd	r31, Y+10	; 0x0a
    572c:	ea 0d       	add	r30, r10
    572e:	fb 1d       	adc	r31, r11
    5730:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5732:	0f 5f       	subi	r16, 0xFF	; 255
    5734:	1f 4f       	sbci	r17, 0xFF	; 255
    5736:	02 15       	cp	r16, r2
    5738:	13 05       	cpc	r17, r3
    573a:	59 f7       	brne	.-42     	; 0x5712 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    573c:	14 14       	cp	r1, r4
    573e:	15 04       	cpc	r1, r5
    5740:	9c f4       	brge	.+38     	; 0x5768 <SD_write_multiple_blocks+0x186>
    5742:	00 e0       	ldi	r16, 0x00	; 0
    5744:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5746:	c8 01       	movw	r24, r16
    5748:	b6 01       	movw	r22, r12
    574a:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    574e:	7c 01       	movw	r14, r24
    5750:	80 e0       	ldi	r24, 0x00	; 0
    5752:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5756:	f5 01       	movw	r30, r10
    5758:	ee 0d       	add	r30, r14
    575a:	ff 1d       	adc	r31, r15
    575c:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    575e:	0f 5f       	subi	r16, 0xFF	; 255
    5760:	1f 4f       	sbci	r17, 0xFF	; 255
    5762:	04 15       	cp	r16, r4
    5764:	15 05       	cpc	r17, r5
    5766:	79 f7       	brne	.-34     	; 0x5746 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5768:	8f ef       	ldi	r24, 0xFF	; 255
    576a:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    576e:	f4 01       	movw	r30, r8
    5770:	80 83       	st	Z, r24
    5772:	8f ef       	ldi	r24, 0xFF	; 255
    5774:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5778:	f4 01       	movw	r30, r8
    577a:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    577c:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    577e:	80 81       	ld	r24, Z
    5780:	8f 3f       	cpi	r24, 0xFF	; 255
    5782:	e1 f4       	brne	.+56     	; 0x57bc <SD_write_multiple_blocks+0x1da>
    5784:	23 c0       	rjmp	.+70     	; 0x57cc <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5786:	e9 80       	ldd	r14, Y+1	; 0x01
    5788:	fa 80       	ldd	r15, Y+2	; 0x02
    578a:	00 e0       	ldi	r16, 0x00	; 0
    578c:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    578e:	c8 01       	movw	r24, r16
    5790:	b6 01       	movw	r22, r12
    5792:	0e 94 fb 37 	call	0x6ff6	; 0x6ff6 <__divmodhi4>
    5796:	89 87       	std	Y+9, r24	; 0x09
    5798:	9a 87       	std	Y+10, r25	; 0x0a
    579a:	f7 01       	movw	r30, r14
    579c:	81 91       	ld	r24, Z+
    579e:	7f 01       	movw	r14, r30
    57a0:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    57a4:	e9 85       	ldd	r30, Y+9	; 0x09
    57a6:	fa 85       	ldd	r31, Y+10	; 0x0a
    57a8:	ea 0d       	add	r30, r10
    57aa:	fb 1d       	adc	r31, r11
    57ac:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    57ae:	0f 5f       	subi	r16, 0xFF	; 255
    57b0:	1f 4f       	sbci	r17, 0xFF	; 255
    57b2:	f2 e0       	ldi	r31, 0x02	; 2
    57b4:	00 30       	cpi	r16, 0x00	; 0
    57b6:	1f 07       	cpc	r17, r31
    57b8:	51 f7       	brne	.-44     	; 0x578e <SD_write_multiple_blocks+0x1ac>
    57ba:	d6 cf       	rjmp	.-84     	; 0x5768 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    57bc:	8f ef       	ldi	r24, 0xFF	; 255
    57be:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    57c2:	f4 01       	movw	r30, r8
    57c4:	80 83       	st	Z, r24
    57c6:	80 81       	ld	r24, Z
    57c8:	8f 3f       	cpi	r24, 0xFF	; 255
    57ca:	c1 f7       	brne	.-16     	; 0x57bc <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    57cc:	08 94       	sec
    57ce:	61 1c       	adc	r6, r1
    57d0:	71 1c       	adc	r7, r1
    57d2:	29 81       	ldd	r18, Y+1	; 0x01
    57d4:	3a 81       	ldd	r19, Y+2	; 0x02
    57d6:	20 50       	subi	r18, 0x00	; 0
    57d8:	3e 4f       	sbci	r19, 0xFE	; 254
    57da:	29 83       	std	Y+1, r18	; 0x01
    57dc:	3a 83       	std	Y+2, r19	; 0x02
    57de:	8b 81       	ldd	r24, Y+3	; 0x03
    57e0:	9c 81       	ldd	r25, Y+4	; 0x04
    57e2:	68 16       	cp	r6, r24
    57e4:	79 06       	cpc	r7, r25
    57e6:	09 f0       	breq	.+2      	; 0x57ea <SD_write_multiple_blocks+0x208>
    57e8:	7d cf       	rjmp	.-262    	; 0x56e4 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    57ea:	ee 24       	eor	r14, r14
    57ec:	ff 24       	eor	r15, r15
    57ee:	68 94       	set
    57f0:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    57f2:	0f ea       	ldi	r16, 0xAF	; 175
    57f4:	10 e5       	ldi	r17, 0x50	; 80
    57f6:	8f ef       	ldi	r24, 0xFF	; 255
    57f8:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    57fc:	f8 01       	movw	r30, r16
    57fe:	80 83       	st	Z, r24
    5800:	08 94       	sec
    5802:	e1 08       	sbc	r14, r1
    5804:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5806:	e1 14       	cp	r14, r1
    5808:	f1 04       	cpc	r15, r1
    580a:	a9 f7       	brne	.-22     	; 0x57f6 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    580c:	8d ef       	ldi	r24, 0xFD	; 253
    580e:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5812:	80 93 af 50 	sts	0x50AF, r24
    5816:	ee 24       	eor	r14, r14
    5818:	ff 24       	eor	r15, r15
    581a:	68 94       	set
    581c:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    581e:	0f ea       	ldi	r16, 0xAF	; 175
    5820:	10 e5       	ldi	r17, 0x50	; 80
    5822:	8f ef       	ldi	r24, 0xFF	; 255
    5824:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5828:	f8 01       	movw	r30, r16
    582a:	80 83       	st	Z, r24
    582c:	08 94       	sec
    582e:	e1 08       	sbc	r14, r1
    5830:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5832:	e1 14       	cp	r14, r1
    5834:	f1 04       	cpc	r15, r1
    5836:	a9 f7       	brne	.-22     	; 0x5822 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5838:	10 92 af 50 	sts	0x50AF, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    583c:	80 91 af 50 	lds	r24, 0x50AF
    5840:	8f 3f       	cpi	r24, 0xFF	; 255
    5842:	51 f0       	breq	.+20     	; 0x5858 <SD_write_multiple_blocks+0x276>
    5844:	0f ea       	ldi	r16, 0xAF	; 175
    5846:	10 e5       	ldi	r17, 0x50	; 80
    5848:	8f ef       	ldi	r24, 0xFF	; 255
    584a:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    584e:	f8 01       	movw	r30, r16
    5850:	80 83       	st	Z, r24
    5852:	80 81       	ld	r24, Z
    5854:	8f 3f       	cpi	r24, 0xFF	; 255
    5856:	c1 f7       	brne	.-16     	; 0x5848 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5858:	80 e0       	ldi	r24, 0x00	; 0
    585a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    585e:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5862:	88 e0       	ldi	r24, 0x08	; 8
    5864:	60 e0       	ldi	r22, 0x00	; 0
    5866:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
}
    586a:	2a 96       	adiw	r28, 0x0a	; 10
    586c:	cd bf       	out	0x3d, r28	; 61
    586e:	de bf       	out	0x3e, r29	; 62
    5870:	df 91       	pop	r29
    5872:	cf 91       	pop	r28
    5874:	1f 91       	pop	r17
    5876:	0f 91       	pop	r16
    5878:	ff 90       	pop	r15
    587a:	ef 90       	pop	r14
    587c:	df 90       	pop	r13
    587e:	cf 90       	pop	r12
    5880:	bf 90       	pop	r11
    5882:	af 90       	pop	r10
    5884:	9f 90       	pop	r9
    5886:	8f 90       	pop	r8
    5888:	7f 90       	pop	r7
    588a:	6f 90       	pop	r6
    588c:	5f 90       	pop	r5
    588e:	4f 90       	pop	r4
    5890:	3f 90       	pop	r3
    5892:	2f 90       	pop	r2
    5894:	08 95       	ret

00005896 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5896:	2f 92       	push	r2
    5898:	3f 92       	push	r3
    589a:	4f 92       	push	r4
    589c:	5f 92       	push	r5
    589e:	6f 92       	push	r6
    58a0:	7f 92       	push	r7
    58a2:	8f 92       	push	r8
    58a4:	9f 92       	push	r9
    58a6:	af 92       	push	r10
    58a8:	bf 92       	push	r11
    58aa:	cf 92       	push	r12
    58ac:	df 92       	push	r13
    58ae:	ef 92       	push	r14
    58b0:	ff 92       	push	r15
    58b2:	0f 93       	push	r16
    58b4:	1f 93       	push	r17
    58b6:	cf 93       	push	r28
    58b8:	df 93       	push	r29
    58ba:	6b 01       	movw	r12, r22
    58bc:	7c 01       	movw	r14, r24
    58be:	c4 2f       	mov	r28, r20
    58c0:	85 2e       	mov	r8, r21
    58c2:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    58c4:	88 e0       	ldi	r24, 0x08	; 8
    58c6:	60 e0       	ldi	r22, 0x00	; 0
    58c8:	0e 94 91 1b 	call	0x3722	; 0x3722 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    58cc:	80 e0       	ldi	r24, 0x00	; 0
    58ce:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    58d2:	81 e0       	ldi	r24, 0x01	; 1
    58d4:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    58d8:	82 e1       	ldi	r24, 0x12	; 18
    58da:	b7 01       	movw	r22, r14
    58dc:	a6 01       	movw	r20, r12
    58de:	2f ef       	ldi	r18, 0xFF	; 255
    58e0:	08 e0       	ldi	r16, 0x08	; 8
    58e2:	10 e0       	ldi	r17, 0x00	; 0
    58e4:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
    58e8:	88 23       	and	r24, r24
    58ea:	b1 f7       	brne	.-20     	; 0x58d8 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    58ec:	16 14       	cp	r1, r6
    58ee:	17 04       	cpc	r1, r7
    58f0:	0c f0       	brlt	.+2      	; 0x58f4 <SD_read_multiple_blocks+0x5e>
    58f2:	46 c0       	rjmp	.+140    	; 0x5980 <SD_read_multiple_blocks+0xea>
    58f4:	ac 2e       	mov	r10, r28
    58f6:	b8 2c       	mov	r11, r8
    58f8:	88 24       	eor	r8, r8
    58fa:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    58fc:	0f 2e       	mov	r0, r31
    58fe:	ff ea       	ldi	r31, 0xAF	; 175
    5900:	cf 2e       	mov	r12, r31
    5902:	f0 e5       	ldi	r31, 0x50	; 80
    5904:	df 2e       	mov	r13, r31
    5906:	f0 2d       	mov	r31, r0
    5908:	ff 24       	eor	r15, r15
    590a:	fa 94       	dec	r15
    590c:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    590e:	0f 2e       	mov	r0, r31
    5910:	fe ea       	ldi	r31, 0xAE	; 174
    5912:	4f 2e       	mov	r4, r31
    5914:	f0 e5       	ldi	r31, 0x50	; 80
    5916:	5f 2e       	mov	r5, r31
    5918:	f0 2d       	mov	r31, r0
    591a:	12 01       	movw	r2, r4
    591c:	08 94       	sec
    591e:	21 1c       	adc	r2, r1
    5920:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5922:	f6 01       	movw	r30, r12
    5924:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5926:	80 81       	ld	r24, Z
    5928:	8e 3f       	cpi	r24, 0xFE	; 254
    592a:	41 f0       	breq	.+16     	; 0x593c <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    592c:	8f 2d       	mov	r24, r15
    592e:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5932:	f6 01       	movw	r30, r12
    5934:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5936:	80 81       	ld	r24, Z
    5938:	8e 3f       	cpi	r24, 0xFE	; 254
    593a:	c1 f7       	brne	.-16     	; 0x592c <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    593c:	85 01       	movw	r16, r10
    593e:	c0 e0       	ldi	r28, 0x00	; 0
    5940:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5942:	8f 2d       	mov	r24, r15
    5944:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5948:	f8 01       	movw	r30, r16
    594a:	81 93       	st	Z+, r24
    594c:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    594e:	21 96       	adiw	r28, 0x01	; 1
    5950:	f2 e0       	ldi	r31, 0x02	; 2
    5952:	c0 30       	cpi	r28, 0x00	; 0
    5954:	df 07       	cpc	r29, r31
    5956:	a9 f7       	brne	.-22     	; 0x5942 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5958:	8f 2d       	mov	r24, r15
    595a:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    595e:	f2 01       	movw	r30, r4
    5960:	80 83       	st	Z, r24
    5962:	8f 2d       	mov	r24, r15
    5964:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5968:	f1 01       	movw	r30, r2
    596a:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    596c:	08 94       	sec
    596e:	81 1c       	adc	r8, r1
    5970:	91 1c       	adc	r9, r1
    5972:	80 e0       	ldi	r24, 0x00	; 0
    5974:	92 e0       	ldi	r25, 0x02	; 2
    5976:	a8 0e       	add	r10, r24
    5978:	b9 1e       	adc	r11, r25
    597a:	86 14       	cp	r8, r6
    597c:	97 04       	cpc	r9, r7
    597e:	89 f6       	brne	.-94     	; 0x5922 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5980:	8c e0       	ldi	r24, 0x0C	; 12
    5982:	40 e0       	ldi	r20, 0x00	; 0
    5984:	50 e0       	ldi	r21, 0x00	; 0
    5986:	ba 01       	movw	r22, r20
    5988:	2f ef       	ldi	r18, 0xFF	; 255
    598a:	08 e0       	ldi	r16, 0x08	; 8
    598c:	10 e0       	ldi	r17, 0x00	; 0
    598e:	0e 94 9a 28 	call	0x5134	; 0x5134 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5992:	8f ef       	ldi	r24, 0xFF	; 255
    5994:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    5998:	80 93 ae 50 	sts	0x50AE, r24
	Buffer[1] = FILLER_BYTE;
    599c:	10 92 af 50 	sts	0x50AF, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    59a0:	80 91 af 50 	lds	r24, 0x50AF
    59a4:	8f 3f       	cpi	r24, 0xFF	; 255
    59a6:	49 f0       	breq	.+18     	; 0x59ba <SD_read_multiple_blocks+0x124>
    59a8:	cf ea       	ldi	r28, 0xAF	; 175
    59aa:	d0 e5       	ldi	r29, 0x50	; 80
    59ac:	8f ef       	ldi	r24, 0xFF	; 255
    59ae:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
    59b2:	88 83       	st	Y, r24
    59b4:	88 81       	ld	r24, Y
    59b6:	8f 3f       	cpi	r24, 0xFF	; 255
    59b8:	c9 f7       	brne	.-14     	; 0x59ac <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    59ba:	80 e0       	ldi	r24, 0x00	; 0
    59bc:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    59c0:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    59c4:	88 e0       	ldi	r24, 0x08	; 8
    59c6:	60 e0       	ldi	r22, 0x00	; 0
    59c8:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
}
    59cc:	df 91       	pop	r29
    59ce:	cf 91       	pop	r28
    59d0:	1f 91       	pop	r17
    59d2:	0f 91       	pop	r16
    59d4:	ff 90       	pop	r15
    59d6:	ef 90       	pop	r14
    59d8:	df 90       	pop	r13
    59da:	cf 90       	pop	r12
    59dc:	bf 90       	pop	r11
    59de:	af 90       	pop	r10
    59e0:	9f 90       	pop	r9
    59e2:	8f 90       	pop	r8
    59e4:	7f 90       	pop	r7
    59e6:	6f 90       	pop	r6
    59e8:	5f 90       	pop	r5
    59ea:	4f 90       	pop	r4
    59ec:	3f 90       	pop	r3
    59ee:	2f 90       	pop	r2
    59f0:	08 95       	ret

000059f2 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    59f2:	88 e0       	ldi	r24, 0x08	; 8
    59f4:	60 e0       	ldi	r22, 0x00	; 0
    59f6:	0e 94 95 1c 	call	0x392a	; 0x392a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    59fa:	88 e0       	ldi	r24, 0x08	; 8
    59fc:	60 e0       	ldi	r22, 0x00	; 0
    59fe:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5a02:	80 e0       	ldi	r24, 0x00	; 0
    5a04:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <SPIInit>
	SPICS(TRUE);
    5a08:	81 e0       	ldi	r24, 0x01	; 1
    5a0a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5a0e:	8f ef       	ldi	r24, 0xFF	; 255
    5a10:	0e 94 90 28 	call	0x5120	; 0x5120 <SPI_write>
	SPICS(FALSE);	//stop spi
    5a14:	80 e0       	ldi	r24, 0x00	; 0
    5a16:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <SPICS>
	SPIDisable();
    5a1a:	0e 94 87 1b 	call	0x370e	; 0x370e <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5a1e:	80 e0       	ldi	r24, 0x00	; 0
    5a20:	0e 94 12 04 	call	0x824	; 0x824 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5a24:	80 e0       	ldi	r24, 0x00	; 0
    5a26:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <Ext1Power>
}
    5a2a:	08 95       	ret

00005a2c <__muldi3>:
    5a2c:	a0 e3       	ldi	r26, 0x30	; 48
    5a2e:	b0 e0       	ldi	r27, 0x00	; 0
    5a30:	ec e1       	ldi	r30, 0x1C	; 28
    5a32:	fd e2       	ldi	r31, 0x2D	; 45
    5a34:	0c 94 4d 38 	jmp	0x709a	; 0x709a <__prologue_saves__+0x4>
    5a38:	29 8f       	std	Y+25, r18	; 0x19
    5a3a:	3a 8f       	std	Y+26, r19	; 0x1a
    5a3c:	4b 8f       	std	Y+27, r20	; 0x1b
    5a3e:	5c 8f       	std	Y+28, r21	; 0x1c
    5a40:	6d 8f       	std	Y+29, r22	; 0x1d
    5a42:	7e 8f       	std	Y+30, r23	; 0x1e
    5a44:	8f 8f       	std	Y+31, r24	; 0x1f
    5a46:	98 a3       	lds	r25, 0x58
    5a48:	a9 8a       	std	Y+17, r10	; 0x11
    5a4a:	ba 8a       	std	Y+18, r11	; 0x12
    5a4c:	cb 8a       	std	Y+19, r12	; 0x13
    5a4e:	dc 8a       	std	Y+20, r13	; 0x14
    5a50:	ed 8a       	std	Y+21, r14	; 0x15
    5a52:	fe 8a       	std	Y+22, r15	; 0x16
    5a54:	0f 8b       	std	Y+23, r16	; 0x17
    5a56:	18 8f       	std	Y+24, r17	; 0x18
    5a58:	09 8d       	ldd	r16, Y+25	; 0x19
    5a5a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5a5c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5a5e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5a60:	09 a3       	lds	r16, 0x59
    5a62:	1a a3       	lds	r17, 0x5a
    5a64:	2b a3       	lds	r18, 0x5b
    5a66:	3c a3       	lds	r19, 0x5c
    5a68:	68 01       	movw	r12, r16
    5a6a:	79 01       	movw	r14, r18
    5a6c:	8f ef       	ldi	r24, 0xFF	; 255
    5a6e:	9f ef       	ldi	r25, 0xFF	; 255
    5a70:	a0 e0       	ldi	r26, 0x00	; 0
    5a72:	b0 e0       	ldi	r27, 0x00	; 0
    5a74:	c8 22       	and	r12, r24
    5a76:	d9 22       	and	r13, r25
    5a78:	ea 22       	and	r14, r26
    5a7a:	fb 22       	and	r15, r27
    5a7c:	89 01       	movw	r16, r18
    5a7e:	22 27       	eor	r18, r18
    5a80:	33 27       	eor	r19, r19
    5a82:	09 a7       	lds	r16, 0x79
    5a84:	1a a7       	lds	r17, 0x7a
    5a86:	2b a7       	lds	r18, 0x7b
    5a88:	3c a7       	lds	r19, 0x7c
    5a8a:	09 89       	ldd	r16, Y+17	; 0x11
    5a8c:	1a 89       	ldd	r17, Y+18	; 0x12
    5a8e:	2b 89       	ldd	r18, Y+19	; 0x13
    5a90:	3c 89       	ldd	r19, Y+20	; 0x14
    5a92:	0d a3       	lds	r16, 0x5d
    5a94:	1e a3       	lds	r17, 0x5e
    5a96:	2f a3       	lds	r18, 0x5f
    5a98:	38 a7       	lds	r19, 0x78
    5a9a:	48 01       	movw	r8, r16
    5a9c:	59 01       	movw	r10, r18
    5a9e:	88 22       	and	r8, r24
    5aa0:	99 22       	and	r9, r25
    5aa2:	aa 22       	and	r10, r26
    5aa4:	bb 22       	and	r11, r27
    5aa6:	29 01       	movw	r4, r18
    5aa8:	66 24       	eor	r6, r6
    5aaa:	77 24       	eor	r7, r7
    5aac:	c5 01       	movw	r24, r10
    5aae:	b4 01       	movw	r22, r8
    5ab0:	a7 01       	movw	r20, r14
    5ab2:	96 01       	movw	r18, r12
    5ab4:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    5ab8:	6d a7       	lds	r22, 0x7d
    5aba:	7e a7       	lds	r23, 0x7e
    5abc:	8f a7       	lds	r24, 0x7f
    5abe:	98 ab       	sts	0x58, r25
    5ac0:	c3 01       	movw	r24, r6
    5ac2:	b2 01       	movw	r22, r4
    5ac4:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    5ac8:	6b 01       	movw	r12, r22
    5aca:	7c 01       	movw	r14, r24
    5acc:	c5 01       	movw	r24, r10
    5ace:	b4 01       	movw	r22, r8
    5ad0:	29 a5       	lds	r18, 0x69
    5ad2:	3a a5       	lds	r19, 0x6a
    5ad4:	4b a5       	lds	r20, 0x6b
    5ad6:	5c a5       	lds	r21, 0x6c
    5ad8:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    5adc:	4b 01       	movw	r8, r22
    5ade:	5c 01       	movw	r10, r24
    5ae0:	c3 01       	movw	r24, r6
    5ae2:	b2 01       	movw	r22, r4
    5ae4:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    5ae8:	ab 01       	movw	r20, r22
    5aea:	bc 01       	movw	r22, r24
    5aec:	c8 0c       	add	r12, r8
    5aee:	d9 1c       	adc	r13, r9
    5af0:	ea 1c       	adc	r14, r10
    5af2:	fb 1c       	adc	r15, r11
    5af4:	0d a5       	lds	r16, 0x6d
    5af6:	1e a5       	lds	r17, 0x6e
    5af8:	2f a5       	lds	r18, 0x6f
    5afa:	38 a9       	sts	0x48, r19
    5afc:	c9 01       	movw	r24, r18
    5afe:	aa 27       	eor	r26, r26
    5b00:	bb 27       	eor	r27, r27
    5b02:	c8 0e       	add	r12, r24
    5b04:	d9 1e       	adc	r13, r25
    5b06:	ea 1e       	adc	r14, r26
    5b08:	fb 1e       	adc	r15, r27
    5b0a:	c8 14       	cp	r12, r8
    5b0c:	d9 04       	cpc	r13, r9
    5b0e:	ea 04       	cpc	r14, r10
    5b10:	fb 04       	cpc	r15, r11
    5b12:	20 f4       	brcc	.+8      	; 0x5b1c <__muldi3+0xf0>
    5b14:	40 50       	subi	r20, 0x00	; 0
    5b16:	50 40       	sbci	r21, 0x00	; 0
    5b18:	6f 4f       	sbci	r22, 0xFF	; 255
    5b1a:	7f 4f       	sbci	r23, 0xFF	; 255
    5b1c:	c7 01       	movw	r24, r14
    5b1e:	aa 27       	eor	r26, r26
    5b20:	bb 27       	eor	r27, r27
    5b22:	84 0f       	add	r24, r20
    5b24:	95 1f       	adc	r25, r21
    5b26:	a6 1f       	adc	r26, r22
    5b28:	b7 1f       	adc	r27, r23
    5b2a:	8d 83       	std	Y+5, r24	; 0x05
    5b2c:	9e 83       	std	Y+6, r25	; 0x06
    5b2e:	af 83       	std	Y+7, r26	; 0x07
    5b30:	b8 87       	std	Y+8, r27	; 0x08
    5b32:	76 01       	movw	r14, r12
    5b34:	dd 24       	eor	r13, r13
    5b36:	cc 24       	eor	r12, r12
    5b38:	4d a5       	lds	r20, 0x6d
    5b3a:	5e a5       	lds	r21, 0x6e
    5b3c:	6f a5       	lds	r22, 0x6f
    5b3e:	78 a9       	sts	0x48, r23
    5b40:	60 70       	andi	r22, 0x00	; 0
    5b42:	70 70       	andi	r23, 0x00	; 0
    5b44:	c4 0e       	add	r12, r20
    5b46:	d5 1e       	adc	r13, r21
    5b48:	e6 1e       	adc	r14, r22
    5b4a:	f7 1e       	adc	r15, r23
    5b4c:	c9 82       	std	Y+1, r12	; 0x01
    5b4e:	da 82       	std	Y+2, r13	; 0x02
    5b50:	eb 82       	std	Y+3, r14	; 0x03
    5b52:	fc 82       	std	Y+4, r15	; 0x04
    5b54:	1c 2d       	mov	r17, r12
    5b56:	0a 81       	ldd	r16, Y+2	; 0x02
    5b58:	8b 80       	ldd	r8, Y+3	; 0x03
    5b5a:	4c 80       	ldd	r4, Y+4	; 0x04
    5b5c:	8d 87       	std	Y+13, r24	; 0x0d
    5b5e:	8e 81       	ldd	r24, Y+6	; 0x06
    5b60:	8e 87       	std	Y+14, r24	; 0x0e
    5b62:	8f 81       	ldd	r24, Y+7	; 0x07
    5b64:	8f 87       	std	Y+15, r24	; 0x0f
    5b66:	88 85       	ldd	r24, Y+8	; 0x08
    5b68:	88 8b       	std	Y+16, r24	; 0x10
    5b6a:	2d 89       	ldd	r18, Y+21	; 0x15
    5b6c:	3e 89       	ldd	r19, Y+22	; 0x16
    5b6e:	4f 89       	ldd	r20, Y+23	; 0x17
    5b70:	58 8d       	ldd	r21, Y+24	; 0x18
    5b72:	69 a1       	lds	r22, 0x49
    5b74:	7a a1       	lds	r23, 0x4a
    5b76:	8b a1       	lds	r24, 0x4b
    5b78:	9c a1       	lds	r25, 0x4c
    5b7a:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    5b7e:	6b 01       	movw	r12, r22
    5b80:	7c 01       	movw	r14, r24
    5b82:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5b84:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5b86:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5b88:	58 a1       	lds	r21, 0x48
    5b8a:	6d a1       	lds	r22, 0x4d
    5b8c:	7e a1       	lds	r23, 0x4e
    5b8e:	8f a1       	lds	r24, 0x4f
    5b90:	98 a5       	lds	r25, 0x68
    5b92:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    5b96:	dc 01       	movw	r26, r24
    5b98:	cb 01       	movw	r24, r22
    5b9a:	c8 0e       	add	r12, r24
    5b9c:	d9 1e       	adc	r13, r25
    5b9e:	ea 1e       	adc	r14, r26
    5ba0:	fb 1e       	adc	r15, r27
    5ba2:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ba4:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ba6:	af 85       	ldd	r26, Y+15	; 0x0f
    5ba8:	b8 89       	ldd	r27, Y+16	; 0x10
    5baa:	8c 0d       	add	r24, r12
    5bac:	9d 1d       	adc	r25, r13
    5bae:	ae 1d       	adc	r26, r14
    5bb0:	bf 1d       	adc	r27, r15
    5bb2:	8d 87       	std	Y+13, r24	; 0x0d
    5bb4:	9e 87       	std	Y+14, r25	; 0x0e
    5bb6:	af 87       	std	Y+15, r26	; 0x0f
    5bb8:	b8 8b       	std	Y+16, r27	; 0x10
    5bba:	68 2f       	mov	r22, r24
    5bbc:	7e 85       	ldd	r23, Y+14	; 0x0e
    5bbe:	21 2f       	mov	r18, r17
    5bc0:	30 2f       	mov	r19, r16
    5bc2:	48 2d       	mov	r20, r8
    5bc4:	54 2d       	mov	r21, r4
    5bc6:	8f 85       	ldd	r24, Y+15	; 0x0f
    5bc8:	98 89       	ldd	r25, Y+16	; 0x10
    5bca:	e0 96       	adiw	r28, 0x30	; 48
    5bcc:	e0 e1       	ldi	r30, 0x10	; 16
    5bce:	0c 94 66 38 	jmp	0x70cc	; 0x70cc <__epilogue_restores__+0x4>

00005bd2 <__ashldi3>:
    5bd2:	cf 92       	push	r12
    5bd4:	df 92       	push	r13
    5bd6:	ef 92       	push	r14
    5bd8:	ff 92       	push	r15
    5bda:	0f 93       	push	r16
    5bdc:	cf 93       	push	r28
    5bde:	df 93       	push	r29
    5be0:	cd b7       	in	r28, 0x3d	; 61
    5be2:	de b7       	in	r29, 0x3e	; 62
    5be4:	60 97       	sbiw	r28, 0x10	; 16
    5be6:	cd bf       	out	0x3d, r28	; 61
    5be8:	de bf       	out	0x3e, r29	; 62
    5bea:	00 23       	and	r16, r16
    5bec:	09 f4       	brne	.+2      	; 0x5bf0 <__ashldi3+0x1e>
    5bee:	5a c0       	rjmp	.+180    	; 0x5ca4 <__ashldi3+0xd2>
    5bf0:	29 87       	std	Y+9, r18	; 0x09
    5bf2:	3a 87       	std	Y+10, r19	; 0x0a
    5bf4:	4b 87       	std	Y+11, r20	; 0x0b
    5bf6:	5c 87       	std	Y+12, r21	; 0x0c
    5bf8:	6d 87       	std	Y+13, r22	; 0x0d
    5bfa:	7e 87       	std	Y+14, r23	; 0x0e
    5bfc:	8f 87       	std	Y+15, r24	; 0x0f
    5bfe:	98 8b       	std	Y+16, r25	; 0x10
    5c00:	80 e2       	ldi	r24, 0x20	; 32
    5c02:	80 1b       	sub	r24, r16
    5c04:	49 85       	ldd	r20, Y+9	; 0x09
    5c06:	5a 85       	ldd	r21, Y+10	; 0x0a
    5c08:	6b 85       	ldd	r22, Y+11	; 0x0b
    5c0a:	7c 85       	ldd	r23, Y+12	; 0x0c
    5c0c:	18 16       	cp	r1, r24
    5c0e:	b4 f0       	brlt	.+44     	; 0x5c3c <__ashldi3+0x6a>
    5c10:	19 82       	std	Y+1, r1	; 0x01
    5c12:	1a 82       	std	Y+2, r1	; 0x02
    5c14:	1b 82       	std	Y+3, r1	; 0x03
    5c16:	1c 82       	std	Y+4, r1	; 0x04
    5c18:	99 27       	eor	r25, r25
    5c1a:	87 fd       	sbrc	r24, 7
    5c1c:	90 95       	com	r25
    5c1e:	90 95       	com	r25
    5c20:	81 95       	neg	r24
    5c22:	9f 4f       	sbci	r25, 0xFF	; 255
    5c24:	04 c0       	rjmp	.+8      	; 0x5c2e <__ashldi3+0x5c>
    5c26:	44 0f       	add	r20, r20
    5c28:	55 1f       	adc	r21, r21
    5c2a:	66 1f       	adc	r22, r22
    5c2c:	77 1f       	adc	r23, r23
    5c2e:	8a 95       	dec	r24
    5c30:	d2 f7       	brpl	.-12     	; 0x5c26 <__ashldi3+0x54>
    5c32:	4d 83       	std	Y+5, r20	; 0x05
    5c34:	5e 83       	std	Y+6, r21	; 0x06
    5c36:	6f 83       	std	Y+7, r22	; 0x07
    5c38:	78 87       	std	Y+8, r23	; 0x08
    5c3a:	2c c0       	rjmp	.+88     	; 0x5c94 <__ashldi3+0xc2>
    5c3c:	6a 01       	movw	r12, r20
    5c3e:	7b 01       	movw	r14, r22
    5c40:	00 2e       	mov	r0, r16
    5c42:	04 c0       	rjmp	.+8      	; 0x5c4c <__ashldi3+0x7a>
    5c44:	cc 0c       	add	r12, r12
    5c46:	dd 1c       	adc	r13, r13
    5c48:	ee 1c       	adc	r14, r14
    5c4a:	ff 1c       	adc	r15, r15
    5c4c:	0a 94       	dec	r0
    5c4e:	d2 f7       	brpl	.-12     	; 0x5c44 <__ashldi3+0x72>
    5c50:	c9 82       	std	Y+1, r12	; 0x01
    5c52:	da 82       	std	Y+2, r13	; 0x02
    5c54:	eb 82       	std	Y+3, r14	; 0x03
    5c56:	fc 82       	std	Y+4, r15	; 0x04
    5c58:	6a 01       	movw	r12, r20
    5c5a:	7b 01       	movw	r14, r22
    5c5c:	04 c0       	rjmp	.+8      	; 0x5c66 <__ashldi3+0x94>
    5c5e:	f6 94       	lsr	r15
    5c60:	e7 94       	ror	r14
    5c62:	d7 94       	ror	r13
    5c64:	c7 94       	ror	r12
    5c66:	8a 95       	dec	r24
    5c68:	d2 f7       	brpl	.-12     	; 0x5c5e <__ashldi3+0x8c>
    5c6a:	d7 01       	movw	r26, r14
    5c6c:	c6 01       	movw	r24, r12
    5c6e:	4d 85       	ldd	r20, Y+13	; 0x0d
    5c70:	5e 85       	ldd	r21, Y+14	; 0x0e
    5c72:	6f 85       	ldd	r22, Y+15	; 0x0f
    5c74:	78 89       	ldd	r23, Y+16	; 0x10
    5c76:	04 c0       	rjmp	.+8      	; 0x5c80 <__ashldi3+0xae>
    5c78:	44 0f       	add	r20, r20
    5c7a:	55 1f       	adc	r21, r21
    5c7c:	66 1f       	adc	r22, r22
    5c7e:	77 1f       	adc	r23, r23
    5c80:	0a 95       	dec	r16
    5c82:	d2 f7       	brpl	.-12     	; 0x5c78 <__ashldi3+0xa6>
    5c84:	84 2b       	or	r24, r20
    5c86:	95 2b       	or	r25, r21
    5c88:	a6 2b       	or	r26, r22
    5c8a:	b7 2b       	or	r27, r23
    5c8c:	8d 83       	std	Y+5, r24	; 0x05
    5c8e:	9e 83       	std	Y+6, r25	; 0x06
    5c90:	af 83       	std	Y+7, r26	; 0x07
    5c92:	b8 87       	std	Y+8, r27	; 0x08
    5c94:	29 81       	ldd	r18, Y+1	; 0x01
    5c96:	3a 81       	ldd	r19, Y+2	; 0x02
    5c98:	4b 81       	ldd	r20, Y+3	; 0x03
    5c9a:	5c 81       	ldd	r21, Y+4	; 0x04
    5c9c:	6d 81       	ldd	r22, Y+5	; 0x05
    5c9e:	7e 81       	ldd	r23, Y+6	; 0x06
    5ca0:	8f 81       	ldd	r24, Y+7	; 0x07
    5ca2:	98 85       	ldd	r25, Y+8	; 0x08
    5ca4:	60 96       	adiw	r28, 0x10	; 16
    5ca6:	cd bf       	out	0x3d, r28	; 61
    5ca8:	de bf       	out	0x3e, r29	; 62
    5caa:	df 91       	pop	r29
    5cac:	cf 91       	pop	r28
    5cae:	0f 91       	pop	r16
    5cb0:	ff 90       	pop	r15
    5cb2:	ef 90       	pop	r14
    5cb4:	df 90       	pop	r13
    5cb6:	cf 90       	pop	r12
    5cb8:	08 95       	ret

00005cba <__divdi3>:
    5cba:	a8 e4       	ldi	r26, 0x48	; 72
    5cbc:	b0 e0       	ldi	r27, 0x00	; 0
    5cbe:	e3 e6       	ldi	r30, 0x63	; 99
    5cc0:	fe e2       	ldi	r31, 0x2E	; 46
    5cc2:	0c 94 4c 38 	jmp	0x7098	; 0x7098 <__prologue_saves__+0x2>
    5cc6:	f5 01       	movw	r30, r10
    5cc8:	29 a3       	lds	r18, 0x59
    5cca:	3a a3       	lds	r19, 0x5a
    5ccc:	4b a3       	lds	r20, 0x5b
    5cce:	5c a3       	lds	r21, 0x5c
    5cd0:	6d a3       	lds	r22, 0x5d
    5cd2:	7e a3       	lds	r23, 0x5e
    5cd4:	8f a3       	lds	r24, 0x5f
    5cd6:	98 a7       	lds	r25, 0x78
    5cd8:	a9 8e       	std	Y+25, r10	; 0x19
    5cda:	fa 8f       	std	Y+26, r31	; 0x1a
    5cdc:	cb 8e       	std	Y+27, r12	; 0x1b
    5cde:	dc 8e       	std	Y+28, r13	; 0x1c
    5ce0:	ed 8e       	std	Y+29, r14	; 0x1d
    5ce2:	fe 8e       	std	Y+30, r15	; 0x1e
    5ce4:	0f 8f       	std	Y+31, r16	; 0x1f
    5ce6:	18 a3       	lds	r17, 0x58
    5ce8:	8d a0       	lds	r24, 0x8d
    5cea:	9e a0       	lds	r25, 0x8e
    5cec:	af a0       	lds	r26, 0x8f
    5cee:	b8 a4       	lds	r27, 0xa8
    5cf0:	b7 fe       	sbrs	r11, 7
    5cf2:	67 c0       	rjmp	.+206    	; 0x5dc2 <__divdi3+0x108>
    5cf4:	21 95       	neg	r18
    5cf6:	b1 e0       	ldi	r27, 0x01	; 1
    5cf8:	12 16       	cp	r1, r18
    5cfa:	08 f0       	brcs	.+2      	; 0x5cfe <__divdi3+0x44>
    5cfc:	b0 e0       	ldi	r27, 0x00	; 0
    5cfe:	31 95       	neg	r19
    5d00:	a1 e0       	ldi	r26, 0x01	; 1
    5d02:	13 16       	cp	r1, r19
    5d04:	08 f0       	brcs	.+2      	; 0x5d08 <__divdi3+0x4e>
    5d06:	a0 e0       	ldi	r26, 0x00	; 0
    5d08:	b3 2e       	mov	r11, r19
    5d0a:	bb 1a       	sub	r11, r27
    5d0c:	bb 2d       	mov	r27, r11
    5d0e:	88 24       	eor	r8, r8
    5d10:	83 94       	inc	r8
    5d12:	3b 15       	cp	r19, r11
    5d14:	08 f0       	brcs	.+2      	; 0x5d18 <__divdi3+0x5e>
    5d16:	88 24       	eor	r8, r8
    5d18:	a8 29       	or	r26, r8
    5d1a:	41 95       	neg	r20
    5d1c:	31 e0       	ldi	r19, 0x01	; 1
    5d1e:	14 16       	cp	r1, r20
    5d20:	08 f0       	brcs	.+2      	; 0x5d24 <__divdi3+0x6a>
    5d22:	30 e0       	ldi	r19, 0x00	; 0
    5d24:	b4 2e       	mov	r11, r20
    5d26:	ba 1a       	sub	r11, r26
    5d28:	ab 2d       	mov	r26, r11
    5d2a:	88 24       	eor	r8, r8
    5d2c:	83 94       	inc	r8
    5d2e:	4b 15       	cp	r20, r11
    5d30:	08 f0       	brcs	.+2      	; 0x5d34 <__divdi3+0x7a>
    5d32:	88 24       	eor	r8, r8
    5d34:	38 29       	or	r19, r8
    5d36:	51 95       	neg	r21
    5d38:	41 e0       	ldi	r20, 0x01	; 1
    5d3a:	15 16       	cp	r1, r21
    5d3c:	08 f0       	brcs	.+2      	; 0x5d40 <__divdi3+0x86>
    5d3e:	40 e0       	ldi	r20, 0x00	; 0
    5d40:	45 2e       	mov	r4, r21
    5d42:	43 1a       	sub	r4, r19
    5d44:	31 e0       	ldi	r19, 0x01	; 1
    5d46:	54 15       	cp	r21, r4
    5d48:	08 f0       	brcs	.+2      	; 0x5d4c <__divdi3+0x92>
    5d4a:	30 e0       	ldi	r19, 0x00	; 0
    5d4c:	43 2b       	or	r20, r19
    5d4e:	61 95       	neg	r22
    5d50:	31 e0       	ldi	r19, 0x01	; 1
    5d52:	16 16       	cp	r1, r22
    5d54:	08 f0       	brcs	.+2      	; 0x5d58 <__divdi3+0x9e>
    5d56:	30 e0       	ldi	r19, 0x00	; 0
    5d58:	86 2e       	mov	r8, r22
    5d5a:	84 1a       	sub	r8, r20
    5d5c:	41 e0       	ldi	r20, 0x01	; 1
    5d5e:	68 15       	cp	r22, r8
    5d60:	08 f0       	brcs	.+2      	; 0x5d64 <__divdi3+0xaa>
    5d62:	40 e0       	ldi	r20, 0x00	; 0
    5d64:	34 2b       	or	r19, r20
    5d66:	71 95       	neg	r23
    5d68:	41 e0       	ldi	r20, 0x01	; 1
    5d6a:	17 16       	cp	r1, r23
    5d6c:	08 f0       	brcs	.+2      	; 0x5d70 <__divdi3+0xb6>
    5d6e:	40 e0       	ldi	r20, 0x00	; 0
    5d70:	57 2f       	mov	r21, r23
    5d72:	53 1b       	sub	r21, r19
    5d74:	31 e0       	ldi	r19, 0x01	; 1
    5d76:	75 17       	cp	r23, r21
    5d78:	08 f0       	brcs	.+2      	; 0x5d7c <__divdi3+0xc2>
    5d7a:	30 e0       	ldi	r19, 0x00	; 0
    5d7c:	43 2b       	or	r20, r19
    5d7e:	81 95       	neg	r24
    5d80:	31 e0       	ldi	r19, 0x01	; 1
    5d82:	18 16       	cp	r1, r24
    5d84:	08 f0       	brcs	.+2      	; 0x5d88 <__divdi3+0xce>
    5d86:	30 e0       	ldi	r19, 0x00	; 0
    5d88:	68 2f       	mov	r22, r24
    5d8a:	64 1b       	sub	r22, r20
    5d8c:	46 2f       	mov	r20, r22
    5d8e:	61 e0       	ldi	r22, 0x01	; 1
    5d90:	84 17       	cp	r24, r20
    5d92:	08 f0       	brcs	.+2      	; 0x5d96 <__divdi3+0xdc>
    5d94:	60 e0       	ldi	r22, 0x00	; 0
    5d96:	36 2b       	or	r19, r22
    5d98:	91 95       	neg	r25
    5d9a:	93 1b       	sub	r25, r19
    5d9c:	29 a3       	lds	r18, 0x59
    5d9e:	ba a3       	lds	r27, 0x5a
    5da0:	ab a3       	lds	r26, 0x5b
    5da2:	4c a2       	lds	r20, 0x9c
    5da4:	8d a2       	lds	r24, 0x9d
    5da6:	5e a3       	lds	r21, 0x5e
    5da8:	4f a3       	lds	r20, 0x5f
    5daa:	98 a7       	lds	r25, 0x78
    5dac:	8f ef       	ldi	r24, 0xFF	; 255
    5dae:	9f ef       	ldi	r25, 0xFF	; 255
    5db0:	af ef       	ldi	r26, 0xFF	; 255
    5db2:	bf ef       	ldi	r27, 0xFF	; 255
    5db4:	25 96       	adiw	r28, 0x05	; 5
    5db6:	8c af       	sts	0x7c, r24
    5db8:	9d af       	sts	0x7d, r25
    5dba:	ae af       	sts	0x7e, r26
    5dbc:	bf af       	sts	0x7f, r27
    5dbe:	25 97       	sbiw	r28, 0x05	; 5
    5dc0:	06 c0       	rjmp	.+12     	; 0x5dce <__divdi3+0x114>
    5dc2:	25 96       	adiw	r28, 0x05	; 5
    5dc4:	1c ae       	sts	0xbc, r17
    5dc6:	1d ae       	sts	0xbd, r17
    5dc8:	1e ae       	sts	0xbe, r17
    5dca:	1f ae       	sts	0xbf, r17
    5dcc:	25 97       	sbiw	r28, 0x05	; 5
    5dce:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5dd0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5dd2:	af 8d       	ldd	r26, Y+31	; 0x1f
    5dd4:	b8 a1       	lds	r27, 0x48
    5dd6:	b7 ff       	sbrs	r27, 7
    5dd8:	68 c0       	rjmp	.+208    	; 0x5eaa <__divdi3+0x1f0>
    5dda:	25 96       	adiw	r28, 0x05	; 5
    5ddc:	2c ad       	sts	0x6c, r18
    5dde:	3d ad       	sts	0x6d, r19
    5de0:	4e ad       	sts	0x6e, r20
    5de2:	5f ad       	sts	0x6f, r21
    5de4:	25 97       	sbiw	r28, 0x05	; 5
    5de6:	20 95       	com	r18
    5de8:	30 95       	com	r19
    5dea:	40 95       	com	r20
    5dec:	50 95       	com	r21
    5dee:	25 96       	adiw	r28, 0x05	; 5
    5df0:	2c af       	sts	0x7c, r18
    5df2:	3d af       	sts	0x7d, r19
    5df4:	4e af       	sts	0x7e, r20
    5df6:	5f af       	sts	0x7f, r21
    5df8:	25 97       	sbiw	r28, 0x05	; 5
    5dfa:	e1 95       	neg	r30
    5dfc:	81 e0       	ldi	r24, 0x01	; 1
    5dfe:	1e 16       	cp	r1, r30
    5e00:	08 f0       	brcs	.+2      	; 0x5e04 <__divdi3+0x14a>
    5e02:	80 e0       	ldi	r24, 0x00	; 0
    5e04:	f1 95       	neg	r31
    5e06:	91 e0       	ldi	r25, 0x01	; 1
    5e08:	1f 16       	cp	r1, r31
    5e0a:	08 f0       	brcs	.+2      	; 0x5e0e <__divdi3+0x154>
    5e0c:	90 e0       	ldi	r25, 0x00	; 0
    5e0e:	4f 2f       	mov	r20, r31
    5e10:	48 1b       	sub	r20, r24
    5e12:	81 e0       	ldi	r24, 0x01	; 1
    5e14:	f4 17       	cp	r31, r20
    5e16:	08 f0       	brcs	.+2      	; 0x5e1a <__divdi3+0x160>
    5e18:	80 e0       	ldi	r24, 0x00	; 0
    5e1a:	98 2b       	or	r25, r24
    5e1c:	c1 94       	neg	r12
    5e1e:	81 e0       	ldi	r24, 0x01	; 1
    5e20:	1c 14       	cp	r1, r12
    5e22:	08 f0       	brcs	.+2      	; 0x5e26 <__divdi3+0x16c>
    5e24:	80 e0       	ldi	r24, 0x00	; 0
    5e26:	6c 2d       	mov	r22, r12
    5e28:	69 1b       	sub	r22, r25
    5e2a:	91 e0       	ldi	r25, 0x01	; 1
    5e2c:	c6 16       	cp	r12, r22
    5e2e:	08 f0       	brcs	.+2      	; 0x5e32 <__divdi3+0x178>
    5e30:	90 e0       	ldi	r25, 0x00	; 0
    5e32:	89 2b       	or	r24, r25
    5e34:	d1 94       	neg	r13
    5e36:	91 e0       	ldi	r25, 0x01	; 1
    5e38:	1d 14       	cp	r1, r13
    5e3a:	08 f0       	brcs	.+2      	; 0x5e3e <__divdi3+0x184>
    5e3c:	90 e0       	ldi	r25, 0x00	; 0
    5e3e:	5d 2d       	mov	r21, r13
    5e40:	58 1b       	sub	r21, r24
    5e42:	81 e0       	ldi	r24, 0x01	; 1
    5e44:	d5 16       	cp	r13, r21
    5e46:	08 f0       	brcs	.+2      	; 0x5e4a <__divdi3+0x190>
    5e48:	80 e0       	ldi	r24, 0x00	; 0
    5e4a:	98 2b       	or	r25, r24
    5e4c:	e1 94       	neg	r14
    5e4e:	81 e0       	ldi	r24, 0x01	; 1
    5e50:	1e 14       	cp	r1, r14
    5e52:	08 f0       	brcs	.+2      	; 0x5e56 <__divdi3+0x19c>
    5e54:	80 e0       	ldi	r24, 0x00	; 0
    5e56:	3e 2d       	mov	r19, r14
    5e58:	39 1b       	sub	r19, r25
    5e5a:	91 e0       	ldi	r25, 0x01	; 1
    5e5c:	e3 16       	cp	r14, r19
    5e5e:	08 f0       	brcs	.+2      	; 0x5e62 <__divdi3+0x1a8>
    5e60:	90 e0       	ldi	r25, 0x00	; 0
    5e62:	89 2b       	or	r24, r25
    5e64:	f1 94       	neg	r15
    5e66:	91 e0       	ldi	r25, 0x01	; 1
    5e68:	1f 14       	cp	r1, r15
    5e6a:	08 f0       	brcs	.+2      	; 0x5e6e <__divdi3+0x1b4>
    5e6c:	90 e0       	ldi	r25, 0x00	; 0
    5e6e:	2f 2d       	mov	r18, r15
    5e70:	28 1b       	sub	r18, r24
    5e72:	81 e0       	ldi	r24, 0x01	; 1
    5e74:	f2 16       	cp	r15, r18
    5e76:	08 f0       	brcs	.+2      	; 0x5e7a <__divdi3+0x1c0>
    5e78:	80 e0       	ldi	r24, 0x00	; 0
    5e7a:	98 2b       	or	r25, r24
    5e7c:	01 95       	neg	r16
    5e7e:	81 e0       	ldi	r24, 0x01	; 1
    5e80:	10 16       	cp	r1, r16
    5e82:	08 f0       	brcs	.+2      	; 0x5e86 <__divdi3+0x1cc>
    5e84:	80 e0       	ldi	r24, 0x00	; 0
    5e86:	70 2f       	mov	r23, r16
    5e88:	79 1b       	sub	r23, r25
    5e8a:	97 2f       	mov	r25, r23
    5e8c:	71 e0       	ldi	r23, 0x01	; 1
    5e8e:	09 17       	cp	r16, r25
    5e90:	08 f0       	brcs	.+2      	; 0x5e94 <__divdi3+0x1da>
    5e92:	70 e0       	ldi	r23, 0x00	; 0
    5e94:	87 2b       	or	r24, r23
    5e96:	11 95       	neg	r17
    5e98:	18 1b       	sub	r17, r24
    5e9a:	e9 8f       	std	Y+25, r30	; 0x19
    5e9c:	4a 8f       	std	Y+26, r20	; 0x1a
    5e9e:	6b 8f       	std	Y+27, r22	; 0x1b
    5ea0:	5c 8f       	std	Y+28, r21	; 0x1c
    5ea2:	3d 8f       	std	Y+29, r19	; 0x1d
    5ea4:	2e 8f       	std	Y+30, r18	; 0x1e
    5ea6:	9f 8f       	std	Y+31, r25	; 0x1f
    5ea8:	18 a3       	lds	r17, 0x58
    5eaa:	79 8d       	ldd	r23, Y+25	; 0x19
    5eac:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5eae:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5eb0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5eb2:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5eb4:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5eb6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5eb8:	88 a1       	lds	r24, 0x48
    5eba:	e9 a1       	lds	r30, 0x49
    5ebc:	e9 8b       	std	Y+17, r30	; 0x11
    5ebe:	ea a1       	lds	r30, 0x4a
    5ec0:	ea 8b       	std	Y+18, r30	; 0x12
    5ec2:	eb a1       	lds	r30, 0x4b
    5ec4:	eb 8b       	std	Y+19, r30	; 0x13
    5ec6:	ec a1       	lds	r30, 0x4c
    5ec8:	ec 8b       	std	Y+20, r30	; 0x14
    5eca:	ed a1       	lds	r30, 0x4d
    5ecc:	ed 8b       	std	Y+21, r30	; 0x15
    5ece:	ee a1       	lds	r30, 0x4e
    5ed0:	ee 8b       	std	Y+22, r30	; 0x16
    5ed2:	ef a1       	lds	r30, 0x4f
    5ed4:	ef 8b       	std	Y+23, r30	; 0x17
    5ed6:	e8 a5       	lds	r30, 0x68
    5ed8:	e8 8f       	std	Y+24, r30	; 0x18
    5eda:	79 87       	std	Y+9, r23	; 0x09
    5edc:	6a 87       	std	Y+10, r22	; 0x0a
    5ede:	5b 87       	std	Y+11, r21	; 0x0b
    5ee0:	4c 87       	std	Y+12, r20	; 0x0c
    5ee2:	3d 87       	std	Y+13, r19	; 0x0d
    5ee4:	2e 87       	std	Y+14, r18	; 0x0e
    5ee6:	9f 87       	std	Y+15, r25	; 0x0f
    5ee8:	88 8b       	std	Y+16, r24	; 0x10
    5eea:	89 84       	ldd	r8, Y+9	; 0x09
    5eec:	9a 84       	ldd	r9, Y+10	; 0x0a
    5eee:	ab 84       	ldd	r10, Y+11	; 0x0b
    5ef0:	bc 84       	ldd	r11, Y+12	; 0x0c
    5ef2:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ef4:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ef6:	af 85       	ldd	r26, Y+15	; 0x0f
    5ef8:	b8 89       	ldd	r27, Y+16	; 0x10
    5efa:	e9 88       	ldd	r14, Y+17	; 0x11
    5efc:	fa 88       	ldd	r15, Y+18	; 0x12
    5efe:	0b 89       	ldd	r16, Y+19	; 0x13
    5f00:	1c 89       	ldd	r17, Y+20	; 0x14
    5f02:	ed aa       	sts	0x9d, r30
    5f04:	fe aa       	sts	0x9e, r31
    5f06:	0f ab       	sts	0x5f, r16
    5f08:	18 af       	sts	0x78, r17
    5f0a:	cd 88       	ldd	r12, Y+21	; 0x15
    5f0c:	de 88       	ldd	r13, Y+22	; 0x16
    5f0e:	ef 88       	ldd	r14, Y+23	; 0x17
    5f10:	f8 8c       	ldd	r15, Y+24	; 0x18
    5f12:	00 97       	sbiw	r24, 0x00	; 0
    5f14:	a1 05       	cpc	r26, r1
    5f16:	b1 05       	cpc	r27, r1
    5f18:	09 f0       	breq	.+2      	; 0x5f1c <__divdi3+0x262>
    5f1a:	bd c3       	rjmp	.+1914   	; 0x6696 <__stack+0x697>
    5f1c:	c8 14       	cp	r12, r8
    5f1e:	d9 04       	cpc	r13, r9
    5f20:	ea 04       	cpc	r14, r10
    5f22:	fb 04       	cpc	r15, r11
    5f24:	08 f0       	brcs	.+2      	; 0x5f28 <__divdi3+0x26e>
    5f26:	4d c1       	rjmp	.+666    	; 0x61c2 <__stack+0x1c3>
    5f28:	00 e0       	ldi	r16, 0x00	; 0
    5f2a:	80 16       	cp	r8, r16
    5f2c:	00 e0       	ldi	r16, 0x00	; 0
    5f2e:	90 06       	cpc	r9, r16
    5f30:	01 e0       	ldi	r16, 0x01	; 1
    5f32:	a0 06       	cpc	r10, r16
    5f34:	00 e0       	ldi	r16, 0x00	; 0
    5f36:	b0 06       	cpc	r11, r16
    5f38:	58 f4       	brcc	.+22     	; 0x5f50 <__divdi3+0x296>
    5f3a:	1f ef       	ldi	r17, 0xFF	; 255
    5f3c:	81 16       	cp	r8, r17
    5f3e:	91 04       	cpc	r9, r1
    5f40:	a1 04       	cpc	r10, r1
    5f42:	b1 04       	cpc	r11, r1
    5f44:	09 f0       	breq	.+2      	; 0x5f48 <__divdi3+0x28e>
    5f46:	90 f4       	brcc	.+36     	; 0x5f6c <__divdi3+0x2b2>
    5f48:	80 e0       	ldi	r24, 0x00	; 0
    5f4a:	90 e0       	ldi	r25, 0x00	; 0
    5f4c:	dc 01       	movw	r26, r24
    5f4e:	17 c0       	rjmp	.+46     	; 0x5f7e <__divdi3+0x2c4>
    5f50:	20 e0       	ldi	r18, 0x00	; 0
    5f52:	82 16       	cp	r8, r18
    5f54:	20 e0       	ldi	r18, 0x00	; 0
    5f56:	92 06       	cpc	r9, r18
    5f58:	20 e0       	ldi	r18, 0x00	; 0
    5f5a:	a2 06       	cpc	r10, r18
    5f5c:	21 e0       	ldi	r18, 0x01	; 1
    5f5e:	b2 06       	cpc	r11, r18
    5f60:	50 f4       	brcc	.+20     	; 0x5f76 <__divdi3+0x2bc>
    5f62:	80 e1       	ldi	r24, 0x10	; 16
    5f64:	90 e0       	ldi	r25, 0x00	; 0
    5f66:	a0 e0       	ldi	r26, 0x00	; 0
    5f68:	b0 e0       	ldi	r27, 0x00	; 0
    5f6a:	09 c0       	rjmp	.+18     	; 0x5f7e <__divdi3+0x2c4>
    5f6c:	88 e0       	ldi	r24, 0x08	; 8
    5f6e:	90 e0       	ldi	r25, 0x00	; 0
    5f70:	a0 e0       	ldi	r26, 0x00	; 0
    5f72:	b0 e0       	ldi	r27, 0x00	; 0
    5f74:	04 c0       	rjmp	.+8      	; 0x5f7e <__divdi3+0x2c4>
    5f76:	88 e1       	ldi	r24, 0x18	; 24
    5f78:	90 e0       	ldi	r25, 0x00	; 0
    5f7a:	a0 e0       	ldi	r26, 0x00	; 0
    5f7c:	b0 e0       	ldi	r27, 0x00	; 0
    5f7e:	b5 01       	movw	r22, r10
    5f80:	a4 01       	movw	r20, r8
    5f82:	08 2e       	mov	r0, r24
    5f84:	04 c0       	rjmp	.+8      	; 0x5f8e <__divdi3+0x2d4>
    5f86:	76 95       	lsr	r23
    5f88:	67 95       	ror	r22
    5f8a:	57 95       	ror	r21
    5f8c:	47 95       	ror	r20
    5f8e:	0a 94       	dec	r0
    5f90:	d2 f7       	brpl	.-12     	; 0x5f86 <__divdi3+0x2cc>
    5f92:	fa 01       	movw	r30, r20
    5f94:	e9 5c       	subi	r30, 0xC9	; 201
    5f96:	ff 4d       	sbci	r31, 0xDF	; 223
    5f98:	20 81       	ld	r18, Z
    5f9a:	40 e2       	ldi	r20, 0x20	; 32
    5f9c:	50 e0       	ldi	r21, 0x00	; 0
    5f9e:	60 e0       	ldi	r22, 0x00	; 0
    5fa0:	70 e0       	ldi	r23, 0x00	; 0
    5fa2:	48 1b       	sub	r20, r24
    5fa4:	59 0b       	sbc	r21, r25
    5fa6:	6a 0b       	sbc	r22, r26
    5fa8:	7b 0b       	sbc	r23, r27
    5faa:	42 1b       	sub	r20, r18
    5fac:	51 09       	sbc	r21, r1
    5fae:	61 09       	sbc	r22, r1
    5fb0:	71 09       	sbc	r23, r1
    5fb2:	41 15       	cp	r20, r1
    5fb4:	51 05       	cpc	r21, r1
    5fb6:	61 05       	cpc	r22, r1
    5fb8:	71 05       	cpc	r23, r1
    5fba:	a1 f1       	breq	.+104    	; 0x6024 <__stack+0x25>
    5fbc:	04 2e       	mov	r0, r20
    5fbe:	04 c0       	rjmp	.+8      	; 0x5fc8 <__divdi3+0x30e>
    5fc0:	88 0c       	add	r8, r8
    5fc2:	99 1c       	adc	r9, r9
    5fc4:	aa 1c       	adc	r10, r10
    5fc6:	bb 1c       	adc	r11, r11
    5fc8:	0a 94       	dec	r0
    5fca:	d2 f7       	brpl	.-12     	; 0x5fc0 <__divdi3+0x306>
    5fcc:	97 01       	movw	r18, r14
    5fce:	86 01       	movw	r16, r12
    5fd0:	04 2e       	mov	r0, r20
    5fd2:	04 c0       	rjmp	.+8      	; 0x5fdc <__divdi3+0x322>
    5fd4:	00 0f       	add	r16, r16
    5fd6:	11 1f       	adc	r17, r17
    5fd8:	22 1f       	adc	r18, r18
    5fda:	33 1f       	adc	r19, r19
    5fdc:	0a 94       	dec	r0
    5fde:	d2 f7       	brpl	.-12     	; 0x5fd4 <__divdi3+0x31a>
    5fe0:	80 e2       	ldi	r24, 0x20	; 32
    5fe2:	90 e0       	ldi	r25, 0x00	; 0
    5fe4:	84 1b       	sub	r24, r20
    5fe6:	95 0b       	sbc	r25, r21
    5fe8:	cd a8       	sts	0x8d, r28
    5fea:	de a8       	sts	0x8e, r29
    5fec:	ef a8       	sts	0x8f, r30
    5fee:	f8 ac       	sts	0xa8, r31
    5ff0:	04 c0       	rjmp	.+8      	; 0x5ffa <__divdi3+0x340>
    5ff2:	f6 94       	lsr	r15
    5ff4:	e7 94       	ror	r14
    5ff6:	d7 94       	ror	r13
    5ff8:	c7 94       	ror	r12
    5ffa:	8a 95       	dec	r24
    5ffc:	d2 f7       	brpl	.-12     	; 0x5ff2 <__divdi3+0x338>
    5ffe:	c0 2a       	or	r12, r16
    6000:	d1 2a       	or	r13, r17
    6002:	e2 2a       	or	r14, r18
    6004:	f3 2a       	or	r15, r19
    6006:	0d a9       	sts	0x4d, r16
    6008:	1e a9       	sts	0x4e, r17
    600a:	2f a9       	sts	0x4f, r18
    600c:	38 ad       	sts	0x68, r19
    600e:	04 c0       	rjmp	.+8      	; 0x6018 <__stack+0x19>
    6010:	00 0f       	add	r16, r16
    6012:	11 1f       	adc	r17, r17
    6014:	22 1f       	adc	r18, r18
    6016:	33 1f       	adc	r19, r19
    6018:	4a 95       	dec	r20
    601a:	d2 f7       	brpl	.-12     	; 0x6010 <__stack+0x11>
    601c:	0d ab       	sts	0x5d, r16
    601e:	1e ab       	sts	0x5e, r17
    6020:	2f ab       	sts	0x5f, r18
    6022:	38 af       	sts	0x78, r19
    6024:	25 01       	movw	r4, r10
    6026:	66 24       	eor	r6, r6
    6028:	77 24       	eor	r7, r7
    602a:	95 01       	movw	r18, r10
    602c:	84 01       	movw	r16, r8
    602e:	20 70       	andi	r18, 0x00	; 0
    6030:	30 70       	andi	r19, 0x00	; 0
    6032:	09 ab       	sts	0x59, r16
    6034:	1a ab       	sts	0x5a, r17
    6036:	2b ab       	sts	0x5b, r18
    6038:	3c ab       	sts	0x5c, r19
    603a:	c7 01       	movw	r24, r14
    603c:	b6 01       	movw	r22, r12
    603e:	a3 01       	movw	r20, r6
    6040:	92 01       	movw	r18, r4
    6042:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6046:	2d a7       	lds	r18, 0x7d
    6048:	3e a7       	lds	r19, 0x7e
    604a:	4f a7       	lds	r20, 0x7f
    604c:	58 ab       	sts	0x58, r21
    604e:	69 a7       	lds	r22, 0x79
    6050:	7a a7       	lds	r23, 0x7a
    6052:	8b a7       	lds	r24, 0x7b
    6054:	9c a7       	lds	r25, 0x7c
    6056:	c7 01       	movw	r24, r14
    6058:	b6 01       	movw	r22, r12
    605a:	a3 01       	movw	r20, r6
    605c:	92 01       	movw	r18, r4
    605e:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6062:	ca 01       	movw	r24, r20
    6064:	b9 01       	movw	r22, r18
    6066:	29 a9       	sts	0x49, r18
    6068:	3a a9       	sts	0x4a, r19
    606a:	4b a9       	sts	0x4b, r20
    606c:	5c a9       	sts	0x4c, r21
    606e:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    6072:	ab 01       	movw	r20, r22
    6074:	bc 01       	movw	r22, r24
    6076:	09 a5       	lds	r16, 0x69
    6078:	1a a5       	lds	r17, 0x6a
    607a:	2b a5       	lds	r18, 0x6b
    607c:	3c a5       	lds	r19, 0x6c
    607e:	78 01       	movw	r14, r16
    6080:	dd 24       	eor	r13, r13
    6082:	cc 24       	eor	r12, r12
    6084:	0d a9       	sts	0x4d, r16
    6086:	1e a9       	sts	0x4e, r17
    6088:	2f a9       	sts	0x4f, r18
    608a:	38 ad       	sts	0x68, r19
    608c:	c9 01       	movw	r24, r18
    608e:	aa 27       	eor	r26, r26
    6090:	bb 27       	eor	r27, r27
    6092:	c8 2a       	or	r12, r24
    6094:	d9 2a       	or	r13, r25
    6096:	ea 2a       	or	r14, r26
    6098:	fb 2a       	or	r15, r27
    609a:	0d a5       	lds	r16, 0x6d
    609c:	1e a5       	lds	r17, 0x6e
    609e:	2f a5       	lds	r18, 0x6f
    60a0:	38 a9       	sts	0x48, r19
    60a2:	c4 16       	cp	r12, r20
    60a4:	d5 06       	cpc	r13, r21
    60a6:	e6 06       	cpc	r14, r22
    60a8:	f7 06       	cpc	r15, r23
    60aa:	38 f5       	brcc	.+78     	; 0x60fa <__stack+0xfb>
    60ac:	01 50       	subi	r16, 0x01	; 1
    60ae:	10 40       	sbci	r17, 0x00	; 0
    60b0:	20 40       	sbci	r18, 0x00	; 0
    60b2:	30 40       	sbci	r19, 0x00	; 0
    60b4:	09 a7       	lds	r16, 0x79
    60b6:	1a a7       	lds	r17, 0x7a
    60b8:	2b a7       	lds	r18, 0x7b
    60ba:	3c a7       	lds	r19, 0x7c
    60bc:	c8 0c       	add	r12, r8
    60be:	d9 1c       	adc	r13, r9
    60c0:	ea 1c       	adc	r14, r10
    60c2:	fb 1c       	adc	r15, r11
    60c4:	c8 14       	cp	r12, r8
    60c6:	d9 04       	cpc	r13, r9
    60c8:	ea 04       	cpc	r14, r10
    60ca:	fb 04       	cpc	r15, r11
    60cc:	d0 f0       	brcs	.+52     	; 0x6102 <__stack+0x103>
    60ce:	c4 16       	cp	r12, r20
    60d0:	d5 06       	cpc	r13, r21
    60d2:	e6 06       	cpc	r14, r22
    60d4:	f7 06       	cpc	r15, r23
    60d6:	a8 f4       	brcc	.+42     	; 0x6102 <__stack+0x103>
    60d8:	0d a5       	lds	r16, 0x6d
    60da:	1e a5       	lds	r17, 0x6e
    60dc:	2f a5       	lds	r18, 0x6f
    60de:	38 a9       	sts	0x48, r19
    60e0:	02 50       	subi	r16, 0x02	; 2
    60e2:	10 40       	sbci	r17, 0x00	; 0
    60e4:	20 40       	sbci	r18, 0x00	; 0
    60e6:	30 40       	sbci	r19, 0x00	; 0
    60e8:	09 a7       	lds	r16, 0x79
    60ea:	1a a7       	lds	r17, 0x7a
    60ec:	2b a7       	lds	r18, 0x7b
    60ee:	3c a7       	lds	r19, 0x7c
    60f0:	c8 0c       	add	r12, r8
    60f2:	d9 1c       	adc	r13, r9
    60f4:	ea 1c       	adc	r14, r10
    60f6:	fb 1c       	adc	r15, r11
    60f8:	04 c0       	rjmp	.+8      	; 0x6102 <__stack+0x103>
    60fa:	09 a7       	lds	r16, 0x79
    60fc:	1a a7       	lds	r17, 0x7a
    60fe:	2b a7       	lds	r18, 0x7b
    6100:	3c a7       	lds	r19, 0x7c
    6102:	c4 1a       	sub	r12, r20
    6104:	d5 0a       	sbc	r13, r21
    6106:	e6 0a       	sbc	r14, r22
    6108:	f7 0a       	sbc	r15, r23
    610a:	c7 01       	movw	r24, r14
    610c:	b6 01       	movw	r22, r12
    610e:	a3 01       	movw	r20, r6
    6110:	92 01       	movw	r18, r4
    6112:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6116:	2d a7       	lds	r18, 0x7d
    6118:	3e a7       	lds	r19, 0x7e
    611a:	4f a7       	lds	r20, 0x7f
    611c:	58 ab       	sts	0x58, r21
    611e:	69 af       	sts	0x79, r22
    6120:	7a af       	sts	0x7a, r23
    6122:	8b af       	sts	0x7b, r24
    6124:	9c af       	sts	0x7c, r25
    6126:	c7 01       	movw	r24, r14
    6128:	b6 01       	movw	r22, r12
    612a:	a3 01       	movw	r20, r6
    612c:	92 01       	movw	r18, r4
    612e:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6132:	ca 01       	movw	r24, r20
    6134:	b9 01       	movw	r22, r18
    6136:	29 a9       	sts	0x49, r18
    6138:	3a a9       	sts	0x4a, r19
    613a:	4b a9       	sts	0x4b, r20
    613c:	5c a9       	sts	0x4c, r21
    613e:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    6142:	6b 01       	movw	r12, r22
    6144:	7c 01       	movw	r14, r24
    6146:	49 ad       	sts	0x69, r20
    6148:	5a ad       	sts	0x6a, r21
    614a:	6b ad       	sts	0x6b, r22
    614c:	7c ad       	sts	0x6c, r23
    614e:	9a 01       	movw	r18, r20
    6150:	11 27       	eor	r17, r17
    6152:	00 27       	eor	r16, r16
    6154:	4d a9       	sts	0x4d, r20
    6156:	5e a9       	sts	0x4e, r21
    6158:	6f a9       	sts	0x4f, r22
    615a:	78 ad       	sts	0x68, r23
    615c:	60 70       	andi	r22, 0x00	; 0
    615e:	70 70       	andi	r23, 0x00	; 0
    6160:	04 2b       	or	r16, r20
    6162:	15 2b       	or	r17, r21
    6164:	26 2b       	or	r18, r22
    6166:	37 2b       	or	r19, r23
    6168:	8d a5       	lds	r24, 0x6d
    616a:	9e a5       	lds	r25, 0x6e
    616c:	af a5       	lds	r26, 0x6f
    616e:	b8 a9       	sts	0x48, r27
    6170:	0c 15       	cp	r16, r12
    6172:	1d 05       	cpc	r17, r13
    6174:	2e 05       	cpc	r18, r14
    6176:	3f 05       	cpc	r19, r15
    6178:	c0 f4       	brcc	.+48     	; 0x61aa <__stack+0x1ab>
    617a:	01 97       	sbiw	r24, 0x01	; 1
    617c:	a1 09       	sbc	r26, r1
    617e:	b1 09       	sbc	r27, r1
    6180:	08 0d       	add	r16, r8
    6182:	19 1d       	adc	r17, r9
    6184:	2a 1d       	adc	r18, r10
    6186:	3b 1d       	adc	r19, r11
    6188:	08 15       	cp	r16, r8
    618a:	19 05       	cpc	r17, r9
    618c:	2a 05       	cpc	r18, r10
    618e:	3b 05       	cpc	r19, r11
    6190:	60 f0       	brcs	.+24     	; 0x61aa <__stack+0x1ab>
    6192:	0c 15       	cp	r16, r12
    6194:	1d 05       	cpc	r17, r13
    6196:	2e 05       	cpc	r18, r14
    6198:	3f 05       	cpc	r19, r15
    619a:	38 f4       	brcc	.+14     	; 0x61aa <__stack+0x1ab>
    619c:	8d a5       	lds	r24, 0x6d
    619e:	9e a5       	lds	r25, 0x6e
    61a0:	af a5       	lds	r26, 0x6f
    61a2:	b8 a9       	sts	0x48, r27
    61a4:	02 97       	sbiw	r24, 0x02	; 2
    61a6:	a1 09       	sbc	r26, r1
    61a8:	b1 09       	sbc	r27, r1
    61aa:	09 a5       	lds	r16, 0x69
    61ac:	1a a5       	lds	r17, 0x6a
    61ae:	2b a5       	lds	r18, 0x6b
    61b0:	3c a5       	lds	r19, 0x6c
    61b2:	78 01       	movw	r14, r16
    61b4:	dd 24       	eor	r13, r13
    61b6:	cc 24       	eor	r12, r12
    61b8:	c8 2a       	or	r12, r24
    61ba:	d9 2a       	or	r13, r25
    61bc:	ea 2a       	or	r14, r26
    61be:	fb 2a       	or	r15, r27
    61c0:	b7 c4       	rjmp	.+2414   	; 0x6b30 <__stack+0xb31>
    61c2:	81 14       	cp	r8, r1
    61c4:	91 04       	cpc	r9, r1
    61c6:	a1 04       	cpc	r10, r1
    61c8:	b1 04       	cpc	r11, r1
    61ca:	51 f4       	brne	.+20     	; 0x61e0 <__stack+0x1e1>
    61cc:	61 e0       	ldi	r22, 0x01	; 1
    61ce:	70 e0       	ldi	r23, 0x00	; 0
    61d0:	80 e0       	ldi	r24, 0x00	; 0
    61d2:	90 e0       	ldi	r25, 0x00	; 0
    61d4:	a5 01       	movw	r20, r10
    61d6:	94 01       	movw	r18, r8
    61d8:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    61dc:	49 01       	movw	r8, r18
    61de:	5a 01       	movw	r10, r20
    61e0:	10 e0       	ldi	r17, 0x00	; 0
    61e2:	81 16       	cp	r8, r17
    61e4:	10 e0       	ldi	r17, 0x00	; 0
    61e6:	91 06       	cpc	r9, r17
    61e8:	11 e0       	ldi	r17, 0x01	; 1
    61ea:	a1 06       	cpc	r10, r17
    61ec:	10 e0       	ldi	r17, 0x00	; 0
    61ee:	b1 06       	cpc	r11, r17
    61f0:	58 f4       	brcc	.+22     	; 0x6208 <__stack+0x209>
    61f2:	2f ef       	ldi	r18, 0xFF	; 255
    61f4:	82 16       	cp	r8, r18
    61f6:	91 04       	cpc	r9, r1
    61f8:	a1 04       	cpc	r10, r1
    61fa:	b1 04       	cpc	r11, r1
    61fc:	09 f0       	breq	.+2      	; 0x6200 <__stack+0x201>
    61fe:	90 f4       	brcc	.+36     	; 0x6224 <__stack+0x225>
    6200:	80 e0       	ldi	r24, 0x00	; 0
    6202:	90 e0       	ldi	r25, 0x00	; 0
    6204:	dc 01       	movw	r26, r24
    6206:	17 c0       	rjmp	.+46     	; 0x6236 <__stack+0x237>
    6208:	30 e0       	ldi	r19, 0x00	; 0
    620a:	83 16       	cp	r8, r19
    620c:	30 e0       	ldi	r19, 0x00	; 0
    620e:	93 06       	cpc	r9, r19
    6210:	30 e0       	ldi	r19, 0x00	; 0
    6212:	a3 06       	cpc	r10, r19
    6214:	31 e0       	ldi	r19, 0x01	; 1
    6216:	b3 06       	cpc	r11, r19
    6218:	50 f4       	brcc	.+20     	; 0x622e <__stack+0x22f>
    621a:	80 e1       	ldi	r24, 0x10	; 16
    621c:	90 e0       	ldi	r25, 0x00	; 0
    621e:	a0 e0       	ldi	r26, 0x00	; 0
    6220:	b0 e0       	ldi	r27, 0x00	; 0
    6222:	09 c0       	rjmp	.+18     	; 0x6236 <__stack+0x237>
    6224:	88 e0       	ldi	r24, 0x08	; 8
    6226:	90 e0       	ldi	r25, 0x00	; 0
    6228:	a0 e0       	ldi	r26, 0x00	; 0
    622a:	b0 e0       	ldi	r27, 0x00	; 0
    622c:	04 c0       	rjmp	.+8      	; 0x6236 <__stack+0x237>
    622e:	88 e1       	ldi	r24, 0x18	; 24
    6230:	90 e0       	ldi	r25, 0x00	; 0
    6232:	a0 e0       	ldi	r26, 0x00	; 0
    6234:	b0 e0       	ldi	r27, 0x00	; 0
    6236:	b5 01       	movw	r22, r10
    6238:	a4 01       	movw	r20, r8
    623a:	08 2e       	mov	r0, r24
    623c:	04 c0       	rjmp	.+8      	; 0x6246 <__stack+0x247>
    623e:	76 95       	lsr	r23
    6240:	67 95       	ror	r22
    6242:	57 95       	ror	r21
    6244:	47 95       	ror	r20
    6246:	0a 94       	dec	r0
    6248:	d2 f7       	brpl	.-12     	; 0x623e <__stack+0x23f>
    624a:	fa 01       	movw	r30, r20
    624c:	e9 5c       	subi	r30, 0xC9	; 201
    624e:	ff 4d       	sbci	r31, 0xDF	; 223
    6250:	20 81       	ld	r18, Z
    6252:	ac 01       	movw	r20, r24
    6254:	bd 01       	movw	r22, r26
    6256:	42 0f       	add	r20, r18
    6258:	51 1d       	adc	r21, r1
    625a:	61 1d       	adc	r22, r1
    625c:	71 1d       	adc	r23, r1
    625e:	80 e2       	ldi	r24, 0x20	; 32
    6260:	90 e0       	ldi	r25, 0x00	; 0
    6262:	a0 e0       	ldi	r26, 0x00	; 0
    6264:	b0 e0       	ldi	r27, 0x00	; 0
    6266:	84 1b       	sub	r24, r20
    6268:	95 0b       	sbc	r25, r21
    626a:	a6 0b       	sbc	r26, r22
    626c:	b7 0b       	sbc	r27, r23
    626e:	51 f4       	brne	.+20     	; 0x6284 <__stack+0x285>
    6270:	c8 18       	sub	r12, r8
    6272:	d9 08       	sbc	r13, r9
    6274:	ea 08       	sbc	r14, r10
    6276:	fb 08       	sbc	r15, r11
    6278:	f1 e0       	ldi	r31, 0x01	; 1
    627a:	4f 2e       	mov	r4, r31
    627c:	51 2c       	mov	r5, r1
    627e:	61 2c       	mov	r6, r1
    6280:	71 2c       	mov	r7, r1
    6282:	28 c1       	rjmp	.+592    	; 0x64d4 <__stack+0x4d5>
    6284:	08 2e       	mov	r0, r24
    6286:	04 c0       	rjmp	.+8      	; 0x6290 <__stack+0x291>
    6288:	88 0c       	add	r8, r8
    628a:	99 1c       	adc	r9, r9
    628c:	aa 1c       	adc	r10, r10
    628e:	bb 1c       	adc	r11, r11
    6290:	0a 94       	dec	r0
    6292:	d2 f7       	brpl	.-12     	; 0x6288 <__stack+0x289>
    6294:	97 01       	movw	r18, r14
    6296:	86 01       	movw	r16, r12
    6298:	04 2e       	mov	r0, r20
    629a:	04 c0       	rjmp	.+8      	; 0x62a4 <__stack+0x2a5>
    629c:	36 95       	lsr	r19
    629e:	27 95       	ror	r18
    62a0:	17 95       	ror	r17
    62a2:	07 95       	ror	r16
    62a4:	0a 94       	dec	r0
    62a6:	d2 f7       	brpl	.-12     	; 0x629c <__stack+0x29d>
    62a8:	09 ab       	sts	0x59, r16
    62aa:	1a ab       	sts	0x5a, r17
    62ac:	2b ab       	sts	0x5b, r18
    62ae:	3c ab       	sts	0x5c, r19
    62b0:	97 01       	movw	r18, r14
    62b2:	86 01       	movw	r16, r12
    62b4:	08 2e       	mov	r0, r24
    62b6:	04 c0       	rjmp	.+8      	; 0x62c0 <__stack+0x2c1>
    62b8:	00 0f       	add	r16, r16
    62ba:	11 1f       	adc	r17, r17
    62bc:	22 1f       	adc	r18, r18
    62be:	33 1f       	adc	r19, r19
    62c0:	0a 94       	dec	r0
    62c2:	d2 f7       	brpl	.-12     	; 0x62b8 <__stack+0x2b9>
    62c4:	0d a7       	lds	r16, 0x7d
    62c6:	1e a7       	lds	r17, 0x7e
    62c8:	2f a7       	lds	r18, 0x7f
    62ca:	38 ab       	sts	0x58, r19
    62cc:	ed a8       	sts	0x8d, r30
    62ce:	fe a8       	sts	0x8e, r31
    62d0:	0f a9       	sts	0x4f, r16
    62d2:	18 ad       	sts	0x68, r17
    62d4:	04 c0       	rjmp	.+8      	; 0x62de <__stack+0x2df>
    62d6:	16 95       	lsr	r17
    62d8:	07 95       	ror	r16
    62da:	f7 94       	ror	r15
    62dc:	e7 94       	ror	r14
    62de:	4a 95       	dec	r20
    62e0:	d2 f7       	brpl	.-12     	; 0x62d6 <__stack+0x2d7>
    62e2:	b8 01       	movw	r22, r16
    62e4:	a7 01       	movw	r20, r14
    62e6:	0d a5       	lds	r16, 0x6d
    62e8:	1e a5       	lds	r17, 0x6e
    62ea:	2f a5       	lds	r18, 0x6f
    62ec:	38 a9       	sts	0x48, r19
    62ee:	04 2b       	or	r16, r20
    62f0:	15 2b       	or	r17, r21
    62f2:	26 2b       	or	r18, r22
    62f4:	37 2b       	or	r19, r23
    62f6:	0d a7       	lds	r16, 0x7d
    62f8:	1e a7       	lds	r17, 0x7e
    62fa:	2f a7       	lds	r18, 0x7f
    62fc:	38 ab       	sts	0x58, r19
    62fe:	ed a8       	sts	0x8d, r30
    6300:	fe a8       	sts	0x8e, r31
    6302:	0f a9       	sts	0x4f, r16
    6304:	18 ad       	sts	0x68, r17
    6306:	04 c0       	rjmp	.+8      	; 0x6310 <__stack+0x311>
    6308:	ee 0c       	add	r14, r14
    630a:	ff 1c       	adc	r15, r15
    630c:	00 1f       	adc	r16, r16
    630e:	11 1f       	adc	r17, r17
    6310:	8a 95       	dec	r24
    6312:	d2 f7       	brpl	.-12     	; 0x6308 <__stack+0x309>
    6314:	ed aa       	sts	0x9d, r30
    6316:	fe aa       	sts	0x9e, r31
    6318:	0f ab       	sts	0x5f, r16
    631a:	18 af       	sts	0x78, r17
    631c:	25 01       	movw	r4, r10
    631e:	66 24       	eor	r6, r6
    6320:	77 24       	eor	r7, r7
    6322:	95 01       	movw	r18, r10
    6324:	84 01       	movw	r16, r8
    6326:	20 70       	andi	r18, 0x00	; 0
    6328:	30 70       	andi	r19, 0x00	; 0
    632a:	09 af       	sts	0x79, r16
    632c:	1a af       	sts	0x7a, r17
    632e:	2b af       	sts	0x7b, r18
    6330:	3c af       	sts	0x7c, r19
    6332:	69 a9       	sts	0x49, r22
    6334:	7a a9       	sts	0x4a, r23
    6336:	8b a9       	sts	0x4b, r24
    6338:	9c a9       	sts	0x4c, r25
    633a:	a3 01       	movw	r20, r6
    633c:	92 01       	movw	r18, r4
    633e:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6342:	29 a7       	lds	r18, 0x79
    6344:	3a a7       	lds	r19, 0x7a
    6346:	4b a7       	lds	r20, 0x7b
    6348:	5c a7       	lds	r21, 0x7c
    634a:	6b 01       	movw	r12, r22
    634c:	7c 01       	movw	r14, r24
    634e:	69 a9       	sts	0x49, r22
    6350:	7a a9       	sts	0x4a, r23
    6352:	8b a9       	sts	0x4b, r24
    6354:	9c a9       	sts	0x4c, r25
    6356:	a3 01       	movw	r20, r6
    6358:	92 01       	movw	r18, r4
    635a:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    635e:	ca 01       	movw	r24, r20
    6360:	b9 01       	movw	r22, r18
    6362:	29 ad       	sts	0x69, r18
    6364:	3a ad       	sts	0x6a, r19
    6366:	4b ad       	sts	0x6b, r20
    6368:	5c ad       	sts	0x6c, r21
    636a:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    636e:	ab 01       	movw	r20, r22
    6370:	bc 01       	movw	r22, r24
    6372:	76 01       	movw	r14, r12
    6374:	dd 24       	eor	r13, r13
    6376:	cc 24       	eor	r12, r12
    6378:	0d a5       	lds	r16, 0x6d
    637a:	1e a5       	lds	r17, 0x6e
    637c:	2f a5       	lds	r18, 0x6f
    637e:	38 a9       	sts	0x48, r19
    6380:	c9 01       	movw	r24, r18
    6382:	aa 27       	eor	r26, r26
    6384:	bb 27       	eor	r27, r27
    6386:	c8 2a       	or	r12, r24
    6388:	d9 2a       	or	r13, r25
    638a:	ea 2a       	or	r14, r26
    638c:	fb 2a       	or	r15, r27
    638e:	09 a5       	lds	r16, 0x69
    6390:	1a a5       	lds	r17, 0x6a
    6392:	2b a5       	lds	r18, 0x6b
    6394:	3c a5       	lds	r19, 0x6c
    6396:	c4 16       	cp	r12, r20
    6398:	d5 06       	cpc	r13, r21
    639a:	e6 06       	cpc	r14, r22
    639c:	f7 06       	cpc	r15, r23
    639e:	38 f5       	brcc	.+78     	; 0x63ee <__stack+0x3ef>
    63a0:	01 50       	subi	r16, 0x01	; 1
    63a2:	10 40       	sbci	r17, 0x00	; 0
    63a4:	20 40       	sbci	r18, 0x00	; 0
    63a6:	30 40       	sbci	r19, 0x00	; 0
    63a8:	09 ab       	sts	0x59, r16
    63aa:	1a ab       	sts	0x5a, r17
    63ac:	2b ab       	sts	0x5b, r18
    63ae:	3c ab       	sts	0x5c, r19
    63b0:	c8 0c       	add	r12, r8
    63b2:	d9 1c       	adc	r13, r9
    63b4:	ea 1c       	adc	r14, r10
    63b6:	fb 1c       	adc	r15, r11
    63b8:	c8 14       	cp	r12, r8
    63ba:	d9 04       	cpc	r13, r9
    63bc:	ea 04       	cpc	r14, r10
    63be:	fb 04       	cpc	r15, r11
    63c0:	d0 f0       	brcs	.+52     	; 0x63f6 <__stack+0x3f7>
    63c2:	c4 16       	cp	r12, r20
    63c4:	d5 06       	cpc	r13, r21
    63c6:	e6 06       	cpc	r14, r22
    63c8:	f7 06       	cpc	r15, r23
    63ca:	a8 f4       	brcc	.+42     	; 0x63f6 <__stack+0x3f7>
    63cc:	09 a5       	lds	r16, 0x69
    63ce:	1a a5       	lds	r17, 0x6a
    63d0:	2b a5       	lds	r18, 0x6b
    63d2:	3c a5       	lds	r19, 0x6c
    63d4:	02 50       	subi	r16, 0x02	; 2
    63d6:	10 40       	sbci	r17, 0x00	; 0
    63d8:	20 40       	sbci	r18, 0x00	; 0
    63da:	30 40       	sbci	r19, 0x00	; 0
    63dc:	09 ab       	sts	0x59, r16
    63de:	1a ab       	sts	0x5a, r17
    63e0:	2b ab       	sts	0x5b, r18
    63e2:	3c ab       	sts	0x5c, r19
    63e4:	c8 0c       	add	r12, r8
    63e6:	d9 1c       	adc	r13, r9
    63e8:	ea 1c       	adc	r14, r10
    63ea:	fb 1c       	adc	r15, r11
    63ec:	04 c0       	rjmp	.+8      	; 0x63f6 <__stack+0x3f7>
    63ee:	09 ab       	sts	0x59, r16
    63f0:	1a ab       	sts	0x5a, r17
    63f2:	2b ab       	sts	0x5b, r18
    63f4:	3c ab       	sts	0x5c, r19
    63f6:	c4 1a       	sub	r12, r20
    63f8:	d5 0a       	sbc	r13, r21
    63fa:	e6 0a       	sbc	r14, r22
    63fc:	f7 0a       	sbc	r15, r23
    63fe:	c7 01       	movw	r24, r14
    6400:	b6 01       	movw	r22, r12
    6402:	a3 01       	movw	r20, r6
    6404:	92 01       	movw	r18, r4
    6406:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    640a:	29 a7       	lds	r18, 0x79
    640c:	3a a7       	lds	r19, 0x7a
    640e:	4b a7       	lds	r20, 0x7b
    6410:	5c a7       	lds	r21, 0x7c
    6412:	21 96       	adiw	r28, 0x01	; 1
    6414:	6c af       	sts	0x7c, r22
    6416:	7d af       	sts	0x7d, r23
    6418:	8e af       	sts	0x7e, r24
    641a:	9f af       	sts	0x7f, r25
    641c:	21 97       	sbiw	r28, 0x01	; 1
    641e:	c7 01       	movw	r24, r14
    6420:	b6 01       	movw	r22, r12
    6422:	a3 01       	movw	r20, r6
    6424:	92 01       	movw	r18, r4
    6426:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    642a:	ca 01       	movw	r24, r20
    642c:	b9 01       	movw	r22, r18
    642e:	29 ad       	sts	0x69, r18
    6430:	3a ad       	sts	0x6a, r19
    6432:	4b ad       	sts	0x6b, r20
    6434:	5c ad       	sts	0x6c, r21
    6436:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    643a:	8b 01       	movw	r16, r22
    643c:	9c 01       	movw	r18, r24
    643e:	21 96       	adiw	r28, 0x01	; 1
    6440:	4c ad       	sts	0x6c, r20
    6442:	5d ad       	sts	0x6d, r21
    6444:	6e ad       	sts	0x6e, r22
    6446:	7f ad       	sts	0x6f, r23
    6448:	21 97       	sbiw	r28, 0x01	; 1
    644a:	da 01       	movw	r26, r20
    644c:	99 27       	eor	r25, r25
    644e:	88 27       	eor	r24, r24
    6450:	4d a5       	lds	r20, 0x6d
    6452:	5e a5       	lds	r21, 0x6e
    6454:	6f a5       	lds	r22, 0x6f
    6456:	78 a9       	sts	0x48, r23
    6458:	60 70       	andi	r22, 0x00	; 0
    645a:	70 70       	andi	r23, 0x00	; 0
    645c:	84 2b       	or	r24, r20
    645e:	95 2b       	or	r25, r21
    6460:	a6 2b       	or	r26, r22
    6462:	b7 2b       	or	r27, r23
    6464:	49 a5       	lds	r20, 0x69
    6466:	5a a5       	lds	r21, 0x6a
    6468:	6b a5       	lds	r22, 0x6b
    646a:	7c a5       	lds	r23, 0x6c
    646c:	80 17       	cp	r24, r16
    646e:	91 07       	cpc	r25, r17
    6470:	a2 07       	cpc	r26, r18
    6472:	b3 07       	cpc	r27, r19
    6474:	f0 f4       	brcc	.+60     	; 0x64b2 <__stack+0x4b3>
    6476:	41 50       	subi	r20, 0x01	; 1
    6478:	50 40       	sbci	r21, 0x00	; 0
    647a:	60 40       	sbci	r22, 0x00	; 0
    647c:	70 40       	sbci	r23, 0x00	; 0
    647e:	88 0d       	add	r24, r8
    6480:	99 1d       	adc	r25, r9
    6482:	aa 1d       	adc	r26, r10
    6484:	bb 1d       	adc	r27, r11
    6486:	88 15       	cp	r24, r8
    6488:	99 05       	cpc	r25, r9
    648a:	aa 05       	cpc	r26, r10
    648c:	bb 05       	cpc	r27, r11
    648e:	88 f0       	brcs	.+34     	; 0x64b2 <__stack+0x4b3>
    6490:	80 17       	cp	r24, r16
    6492:	91 07       	cpc	r25, r17
    6494:	a2 07       	cpc	r26, r18
    6496:	b3 07       	cpc	r27, r19
    6498:	60 f4       	brcc	.+24     	; 0x64b2 <__stack+0x4b3>
    649a:	49 a5       	lds	r20, 0x69
    649c:	5a a5       	lds	r21, 0x6a
    649e:	6b a5       	lds	r22, 0x6b
    64a0:	7c a5       	lds	r23, 0x6c
    64a2:	42 50       	subi	r20, 0x02	; 2
    64a4:	50 40       	sbci	r21, 0x00	; 0
    64a6:	60 40       	sbci	r22, 0x00	; 0
    64a8:	70 40       	sbci	r23, 0x00	; 0
    64aa:	88 0d       	add	r24, r8
    64ac:	99 1d       	adc	r25, r9
    64ae:	aa 1d       	adc	r26, r10
    64b0:	bb 1d       	adc	r27, r11
    64b2:	6c 01       	movw	r12, r24
    64b4:	7d 01       	movw	r14, r26
    64b6:	c0 1a       	sub	r12, r16
    64b8:	d1 0a       	sbc	r13, r17
    64ba:	e2 0a       	sbc	r14, r18
    64bc:	f3 0a       	sbc	r15, r19
    64be:	09 a9       	sts	0x49, r16
    64c0:	1a a9       	sts	0x4a, r17
    64c2:	2b a9       	sts	0x4b, r18
    64c4:	3c a9       	sts	0x4c, r19
    64c6:	38 01       	movw	r6, r16
    64c8:	55 24       	eor	r5, r5
    64ca:	44 24       	eor	r4, r4
    64cc:	44 2a       	or	r4, r20
    64ce:	55 2a       	or	r5, r21
    64d0:	66 2a       	or	r6, r22
    64d2:	77 2a       	or	r7, r23
    64d4:	85 01       	movw	r16, r10
    64d6:	22 27       	eor	r18, r18
    64d8:	33 27       	eor	r19, r19
    64da:	0d a7       	lds	r16, 0x7d
    64dc:	1e a7       	lds	r17, 0x7e
    64de:	2f a7       	lds	r18, 0x7f
    64e0:	38 ab       	sts	0x58, r19
    64e2:	95 01       	movw	r18, r10
    64e4:	84 01       	movw	r16, r8
    64e6:	20 70       	andi	r18, 0x00	; 0
    64e8:	30 70       	andi	r19, 0x00	; 0
    64ea:	09 af       	sts	0x79, r16
    64ec:	1a af       	sts	0x7a, r17
    64ee:	2b af       	sts	0x7b, r18
    64f0:	3c af       	sts	0x7c, r19
    64f2:	c7 01       	movw	r24, r14
    64f4:	b6 01       	movw	r22, r12
    64f6:	2d a5       	lds	r18, 0x6d
    64f8:	3e a5       	lds	r19, 0x6e
    64fa:	4f a5       	lds	r20, 0x6f
    64fc:	58 a9       	sts	0x48, r21
    64fe:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6502:	29 a7       	lds	r18, 0x79
    6504:	3a a7       	lds	r19, 0x7a
    6506:	4b a7       	lds	r20, 0x7b
    6508:	5c a7       	lds	r21, 0x7c
    650a:	69 ab       	sts	0x59, r22
    650c:	7a ab       	sts	0x5a, r23
    650e:	8b ab       	sts	0x5b, r24
    6510:	9c ab       	sts	0x5c, r25
    6512:	c7 01       	movw	r24, r14
    6514:	b6 01       	movw	r22, r12
    6516:	2d a5       	lds	r18, 0x6d
    6518:	3e a5       	lds	r19, 0x6e
    651a:	4f a5       	lds	r20, 0x6f
    651c:	58 a9       	sts	0x48, r21
    651e:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6522:	ca 01       	movw	r24, r20
    6524:	b9 01       	movw	r22, r18
    6526:	29 ad       	sts	0x69, r18
    6528:	3a ad       	sts	0x6a, r19
    652a:	4b ad       	sts	0x6b, r20
    652c:	5c ad       	sts	0x6c, r21
    652e:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    6532:	ab 01       	movw	r20, r22
    6534:	bc 01       	movw	r22, r24
    6536:	09 a9       	sts	0x49, r16
    6538:	1a a9       	sts	0x4a, r17
    653a:	2b a9       	sts	0x4b, r18
    653c:	3c a9       	sts	0x4c, r19
    653e:	78 01       	movw	r14, r16
    6540:	dd 24       	eor	r13, r13
    6542:	cc 24       	eor	r12, r12
    6544:	0d a9       	sts	0x4d, r16
    6546:	1e a9       	sts	0x4e, r17
    6548:	2f a9       	sts	0x4f, r18
    654a:	38 ad       	sts	0x68, r19
    654c:	c9 01       	movw	r24, r18
    654e:	aa 27       	eor	r26, r26
    6550:	bb 27       	eor	r27, r27
    6552:	c8 2a       	or	r12, r24
    6554:	d9 2a       	or	r13, r25
    6556:	ea 2a       	or	r14, r26
    6558:	fb 2a       	or	r15, r27
    655a:	09 a5       	lds	r16, 0x69
    655c:	1a a5       	lds	r17, 0x6a
    655e:	2b a5       	lds	r18, 0x6b
    6560:	3c a5       	lds	r19, 0x6c
    6562:	c4 16       	cp	r12, r20
    6564:	d5 06       	cpc	r13, r21
    6566:	e6 06       	cpc	r14, r22
    6568:	f7 06       	cpc	r15, r23
    656a:	38 f5       	brcc	.+78     	; 0x65ba <__stack+0x5bb>
    656c:	01 50       	subi	r16, 0x01	; 1
    656e:	10 40       	sbci	r17, 0x00	; 0
    6570:	20 40       	sbci	r18, 0x00	; 0
    6572:	30 40       	sbci	r19, 0x00	; 0
    6574:	09 ab       	sts	0x59, r16
    6576:	1a ab       	sts	0x5a, r17
    6578:	2b ab       	sts	0x5b, r18
    657a:	3c ab       	sts	0x5c, r19
    657c:	c8 0c       	add	r12, r8
    657e:	d9 1c       	adc	r13, r9
    6580:	ea 1c       	adc	r14, r10
    6582:	fb 1c       	adc	r15, r11
    6584:	c8 14       	cp	r12, r8
    6586:	d9 04       	cpc	r13, r9
    6588:	ea 04       	cpc	r14, r10
    658a:	fb 04       	cpc	r15, r11
    658c:	d0 f0       	brcs	.+52     	; 0x65c2 <__stack+0x5c3>
    658e:	c4 16       	cp	r12, r20
    6590:	d5 06       	cpc	r13, r21
    6592:	e6 06       	cpc	r14, r22
    6594:	f7 06       	cpc	r15, r23
    6596:	a8 f4       	brcc	.+42     	; 0x65c2 <__stack+0x5c3>
    6598:	09 a5       	lds	r16, 0x69
    659a:	1a a5       	lds	r17, 0x6a
    659c:	2b a5       	lds	r18, 0x6b
    659e:	3c a5       	lds	r19, 0x6c
    65a0:	02 50       	subi	r16, 0x02	; 2
    65a2:	10 40       	sbci	r17, 0x00	; 0
    65a4:	20 40       	sbci	r18, 0x00	; 0
    65a6:	30 40       	sbci	r19, 0x00	; 0
    65a8:	09 ab       	sts	0x59, r16
    65aa:	1a ab       	sts	0x5a, r17
    65ac:	2b ab       	sts	0x5b, r18
    65ae:	3c ab       	sts	0x5c, r19
    65b0:	c8 0c       	add	r12, r8
    65b2:	d9 1c       	adc	r13, r9
    65b4:	ea 1c       	adc	r14, r10
    65b6:	fb 1c       	adc	r15, r11
    65b8:	04 c0       	rjmp	.+8      	; 0x65c2 <__stack+0x5c3>
    65ba:	09 ab       	sts	0x59, r16
    65bc:	1a ab       	sts	0x5a, r17
    65be:	2b ab       	sts	0x5b, r18
    65c0:	3c ab       	sts	0x5c, r19
    65c2:	c4 1a       	sub	r12, r20
    65c4:	d5 0a       	sbc	r13, r21
    65c6:	e6 0a       	sbc	r14, r22
    65c8:	f7 0a       	sbc	r15, r23
    65ca:	c7 01       	movw	r24, r14
    65cc:	b6 01       	movw	r22, r12
    65ce:	2d a5       	lds	r18, 0x6d
    65d0:	3e a5       	lds	r19, 0x6e
    65d2:	4f a5       	lds	r20, 0x6f
    65d4:	58 a9       	sts	0x48, r21
    65d6:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    65da:	29 a7       	lds	r18, 0x79
    65dc:	3a a7       	lds	r19, 0x7a
    65de:	4b a7       	lds	r20, 0x7b
    65e0:	5c a7       	lds	r21, 0x7c
    65e2:	21 96       	adiw	r28, 0x01	; 1
    65e4:	6c af       	sts	0x7c, r22
    65e6:	7d af       	sts	0x7d, r23
    65e8:	8e af       	sts	0x7e, r24
    65ea:	9f af       	sts	0x7f, r25
    65ec:	21 97       	sbiw	r28, 0x01	; 1
    65ee:	c7 01       	movw	r24, r14
    65f0:	b6 01       	movw	r22, r12
    65f2:	2d a5       	lds	r18, 0x6d
    65f4:	3e a5       	lds	r19, 0x6e
    65f6:	4f a5       	lds	r20, 0x6f
    65f8:	58 a9       	sts	0x48, r21
    65fa:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    65fe:	ca 01       	movw	r24, r20
    6600:	b9 01       	movw	r22, r18
    6602:	29 ad       	sts	0x69, r18
    6604:	3a ad       	sts	0x6a, r19
    6606:	4b ad       	sts	0x6b, r20
    6608:	5c ad       	sts	0x6c, r21
    660a:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    660e:	8b 01       	movw	r16, r22
    6610:	9c 01       	movw	r18, r24
    6612:	21 96       	adiw	r28, 0x01	; 1
    6614:	4c ad       	sts	0x6c, r20
    6616:	5d ad       	sts	0x6d, r21
    6618:	6e ad       	sts	0x6e, r22
    661a:	7f ad       	sts	0x6f, r23
    661c:	21 97       	sbiw	r28, 0x01	; 1
    661e:	da 01       	movw	r26, r20
    6620:	99 27       	eor	r25, r25
    6622:	88 27       	eor	r24, r24
    6624:	4d a9       	sts	0x4d, r20
    6626:	5e a9       	sts	0x4e, r21
    6628:	6f a9       	sts	0x4f, r22
    662a:	78 ad       	sts	0x68, r23
    662c:	60 70       	andi	r22, 0x00	; 0
    662e:	70 70       	andi	r23, 0x00	; 0
    6630:	84 2b       	or	r24, r20
    6632:	95 2b       	or	r25, r21
    6634:	a6 2b       	or	r26, r22
    6636:	b7 2b       	or	r27, r23
    6638:	49 a5       	lds	r20, 0x69
    663a:	5a a5       	lds	r21, 0x6a
    663c:	6b a5       	lds	r22, 0x6b
    663e:	7c a5       	lds	r23, 0x6c
    6640:	80 17       	cp	r24, r16
    6642:	91 07       	cpc	r25, r17
    6644:	a2 07       	cpc	r26, r18
    6646:	b3 07       	cpc	r27, r19
    6648:	d0 f4       	brcc	.+52     	; 0x667e <__stack+0x67f>
    664a:	41 50       	subi	r20, 0x01	; 1
    664c:	50 40       	sbci	r21, 0x00	; 0
    664e:	60 40       	sbci	r22, 0x00	; 0
    6650:	70 40       	sbci	r23, 0x00	; 0
    6652:	88 0d       	add	r24, r8
    6654:	99 1d       	adc	r25, r9
    6656:	aa 1d       	adc	r26, r10
    6658:	bb 1d       	adc	r27, r11
    665a:	88 15       	cp	r24, r8
    665c:	99 05       	cpc	r25, r9
    665e:	aa 05       	cpc	r26, r10
    6660:	bb 05       	cpc	r27, r11
    6662:	68 f0       	brcs	.+26     	; 0x667e <__stack+0x67f>
    6664:	80 17       	cp	r24, r16
    6666:	91 07       	cpc	r25, r17
    6668:	a2 07       	cpc	r26, r18
    666a:	b3 07       	cpc	r27, r19
    666c:	40 f4       	brcc	.+16     	; 0x667e <__stack+0x67f>
    666e:	49 a5       	lds	r20, 0x69
    6670:	5a a5       	lds	r21, 0x6a
    6672:	6b a5       	lds	r22, 0x6b
    6674:	7c a5       	lds	r23, 0x6c
    6676:	42 50       	subi	r20, 0x02	; 2
    6678:	50 40       	sbci	r21, 0x00	; 0
    667a:	60 40       	sbci	r22, 0x00	; 0
    667c:	70 40       	sbci	r23, 0x00	; 0
    667e:	09 a9       	sts	0x49, r16
    6680:	1a a9       	sts	0x4a, r17
    6682:	2b a9       	sts	0x4b, r18
    6684:	3c a9       	sts	0x4c, r19
    6686:	78 01       	movw	r14, r16
    6688:	dd 24       	eor	r13, r13
    668a:	cc 24       	eor	r12, r12
    668c:	c4 2a       	or	r12, r20
    668e:	d5 2a       	or	r13, r21
    6690:	e6 2a       	or	r14, r22
    6692:	f7 2a       	or	r15, r23
    6694:	50 c2       	rjmp	.+1184   	; 0x6b36 <__stack+0xb37>
    6696:	c8 16       	cp	r12, r24
    6698:	d9 06       	cpc	r13, r25
    669a:	ea 06       	cpc	r14, r26
    669c:	fb 06       	cpc	r15, r27
    669e:	08 f4       	brcc	.+2      	; 0x66a2 <__stack+0x6a3>
    66a0:	37 c2       	rjmp	.+1134   	; 0x6b10 <__stack+0xb11>
    66a2:	80 30       	cpi	r24, 0x00	; 0
    66a4:	10 e0       	ldi	r17, 0x00	; 0
    66a6:	91 07       	cpc	r25, r17
    66a8:	11 e0       	ldi	r17, 0x01	; 1
    66aa:	a1 07       	cpc	r26, r17
    66ac:	10 e0       	ldi	r17, 0x00	; 0
    66ae:	b1 07       	cpc	r27, r17
    66b0:	50 f4       	brcc	.+20     	; 0x66c6 <__stack+0x6c7>
    66b2:	8f 3f       	cpi	r24, 0xFF	; 255
    66b4:	91 05       	cpc	r25, r1
    66b6:	a1 05       	cpc	r26, r1
    66b8:	b1 05       	cpc	r27, r1
    66ba:	09 f0       	breq	.+2      	; 0x66be <__stack+0x6bf>
    66bc:	88 f4       	brcc	.+34     	; 0x66e0 <__stack+0x6e1>
    66be:	00 e0       	ldi	r16, 0x00	; 0
    66c0:	10 e0       	ldi	r17, 0x00	; 0
    66c2:	98 01       	movw	r18, r16
    66c4:	16 c0       	rjmp	.+44     	; 0x66f2 <__stack+0x6f3>
    66c6:	80 30       	cpi	r24, 0x00	; 0
    66c8:	20 e0       	ldi	r18, 0x00	; 0
    66ca:	92 07       	cpc	r25, r18
    66cc:	20 e0       	ldi	r18, 0x00	; 0
    66ce:	a2 07       	cpc	r26, r18
    66d0:	21 e0       	ldi	r18, 0x01	; 1
    66d2:	b2 07       	cpc	r27, r18
    66d4:	50 f4       	brcc	.+20     	; 0x66ea <__stack+0x6eb>
    66d6:	00 e1       	ldi	r16, 0x10	; 16
    66d8:	10 e0       	ldi	r17, 0x00	; 0
    66da:	20 e0       	ldi	r18, 0x00	; 0
    66dc:	30 e0       	ldi	r19, 0x00	; 0
    66de:	09 c0       	rjmp	.+18     	; 0x66f2 <__stack+0x6f3>
    66e0:	08 e0       	ldi	r16, 0x08	; 8
    66e2:	10 e0       	ldi	r17, 0x00	; 0
    66e4:	20 e0       	ldi	r18, 0x00	; 0
    66e6:	30 e0       	ldi	r19, 0x00	; 0
    66e8:	04 c0       	rjmp	.+8      	; 0x66f2 <__stack+0x6f3>
    66ea:	08 e1       	ldi	r16, 0x18	; 24
    66ec:	10 e0       	ldi	r17, 0x00	; 0
    66ee:	20 e0       	ldi	r18, 0x00	; 0
    66f0:	30 e0       	ldi	r19, 0x00	; 0
    66f2:	ac 01       	movw	r20, r24
    66f4:	bd 01       	movw	r22, r26
    66f6:	00 2e       	mov	r0, r16
    66f8:	04 c0       	rjmp	.+8      	; 0x6702 <__stack+0x703>
    66fa:	76 95       	lsr	r23
    66fc:	67 95       	ror	r22
    66fe:	57 95       	ror	r21
    6700:	47 95       	ror	r20
    6702:	0a 94       	dec	r0
    6704:	d2 f7       	brpl	.-12     	; 0x66fa <__stack+0x6fb>
    6706:	fa 01       	movw	r30, r20
    6708:	e9 5c       	subi	r30, 0xC9	; 201
    670a:	ff 4d       	sbci	r31, 0xDF	; 223
    670c:	40 81       	ld	r20, Z
    670e:	04 0f       	add	r16, r20
    6710:	11 1d       	adc	r17, r1
    6712:	21 1d       	adc	r18, r1
    6714:	31 1d       	adc	r19, r1
    6716:	40 e2       	ldi	r20, 0x20	; 32
    6718:	50 e0       	ldi	r21, 0x00	; 0
    671a:	60 e0       	ldi	r22, 0x00	; 0
    671c:	70 e0       	ldi	r23, 0x00	; 0
    671e:	40 1b       	sub	r20, r16
    6720:	51 0b       	sbc	r21, r17
    6722:	62 0b       	sbc	r22, r18
    6724:	73 0b       	sbc	r23, r19
    6726:	a1 f4       	brne	.+40     	; 0x6750 <__stack+0x751>
    6728:	8c 15       	cp	r24, r12
    672a:	9d 05       	cpc	r25, r13
    672c:	ae 05       	cpc	r26, r14
    672e:	bf 05       	cpc	r27, r15
    6730:	08 f4       	brcc	.+2      	; 0x6734 <__stack+0x735>
    6732:	f5 c1       	rjmp	.+1002   	; 0x6b1e <__stack+0xb1f>
    6734:	ed a8       	sts	0x8d, r30
    6736:	fe a8       	sts	0x8e, r31
    6738:	0f a9       	sts	0x4f, r16
    673a:	18 ad       	sts	0x68, r17
    673c:	44 24       	eor	r4, r4
    673e:	55 24       	eor	r5, r5
    6740:	32 01       	movw	r6, r4
    6742:	e8 14       	cp	r14, r8
    6744:	f9 04       	cpc	r15, r9
    6746:	0a 05       	cpc	r16, r10
    6748:	1b 05       	cpc	r17, r11
    674a:	08 f0       	brcs	.+2      	; 0x674e <__stack+0x74f>
    674c:	eb c1       	rjmp	.+982    	; 0x6b24 <__stack+0xb25>
    674e:	e3 c1       	rjmp	.+966    	; 0x6b16 <__stack+0xb17>
    6750:	34 2e       	mov	r3, r20
    6752:	2c 01       	movw	r4, r24
    6754:	3d 01       	movw	r6, r26
    6756:	04 c0       	rjmp	.+8      	; 0x6760 <__stack+0x761>
    6758:	44 0c       	add	r4, r4
    675a:	55 1c       	adc	r5, r5
    675c:	66 1c       	adc	r6, r6
    675e:	77 1c       	adc	r7, r7
    6760:	4a 95       	dec	r20
    6762:	d2 f7       	brpl	.-12     	; 0x6758 <__stack+0x759>
    6764:	d5 01       	movw	r26, r10
    6766:	c4 01       	movw	r24, r8
    6768:	00 2e       	mov	r0, r16
    676a:	04 c0       	rjmp	.+8      	; 0x6774 <__stack+0x775>
    676c:	b6 95       	lsr	r27
    676e:	a7 95       	ror	r26
    6770:	97 95       	ror	r25
    6772:	87 95       	ror	r24
    6774:	0a 94       	dec	r0
    6776:	d2 f7       	brpl	.-12     	; 0x676c <__stack+0x76d>
    6778:	48 2a       	or	r4, r24
    677a:	59 2a       	or	r5, r25
    677c:	6a 2a       	or	r6, r26
    677e:	7b 2a       	or	r7, r27
    6780:	a5 01       	movw	r20, r10
    6782:	94 01       	movw	r18, r8
    6784:	03 2c       	mov	r0, r3
    6786:	04 c0       	rjmp	.+8      	; 0x6790 <__stack+0x791>
    6788:	22 0f       	add	r18, r18
    678a:	33 1f       	adc	r19, r19
    678c:	44 1f       	adc	r20, r20
    678e:	55 1f       	adc	r21, r21
    6790:	0a 94       	dec	r0
    6792:	d2 f7       	brpl	.-12     	; 0x6788 <__stack+0x789>
    6794:	29 af       	sts	0x79, r18
    6796:	3a af       	sts	0x7a, r19
    6798:	4b af       	sts	0x7b, r20
    679a:	5c af       	sts	0x7c, r21
    679c:	b7 01       	movw	r22, r14
    679e:	a6 01       	movw	r20, r12
    67a0:	00 2e       	mov	r0, r16
    67a2:	04 c0       	rjmp	.+8      	; 0x67ac <__stack+0x7ad>
    67a4:	76 95       	lsr	r23
    67a6:	67 95       	ror	r22
    67a8:	57 95       	ror	r21
    67aa:	47 95       	ror	r20
    67ac:	0a 94       	dec	r0
    67ae:	d2 f7       	brpl	.-12     	; 0x67a4 <__stack+0x7a5>
    67b0:	49 ab       	sts	0x59, r20
    67b2:	5a ab       	sts	0x5a, r21
    67b4:	6b ab       	sts	0x5b, r22
    67b6:	7c ab       	sts	0x5c, r23
    67b8:	c7 01       	movw	r24, r14
    67ba:	b6 01       	movw	r22, r12
    67bc:	03 2c       	mov	r0, r3
    67be:	04 c0       	rjmp	.+8      	; 0x67c8 <__stack+0x7c9>
    67c0:	66 0f       	add	r22, r22
    67c2:	77 1f       	adc	r23, r23
    67c4:	88 1f       	adc	r24, r24
    67c6:	99 1f       	adc	r25, r25
    67c8:	0a 94       	dec	r0
    67ca:	d2 f7       	brpl	.-12     	; 0x67c0 <__stack+0x7c1>
    67cc:	6d a7       	lds	r22, 0x7d
    67ce:	7e a7       	lds	r23, 0x7e
    67d0:	8f a7       	lds	r24, 0x7f
    67d2:	98 ab       	sts	0x58, r25
    67d4:	8d a9       	sts	0x4d, r24
    67d6:	9e a9       	sts	0x4e, r25
    67d8:	af a9       	sts	0x4f, r26
    67da:	b8 ad       	sts	0x68, r27
    67dc:	04 c0       	rjmp	.+8      	; 0x67e6 <__stack+0x7e7>
    67de:	b6 95       	lsr	r27
    67e0:	a7 95       	ror	r26
    67e2:	97 95       	ror	r25
    67e4:	87 95       	ror	r24
    67e6:	0a 95       	dec	r16
    67e8:	d2 f7       	brpl	.-12     	; 0x67de <__stack+0x7df>
    67ea:	4d a5       	lds	r20, 0x6d
    67ec:	5e a5       	lds	r21, 0x6e
    67ee:	6f a5       	lds	r22, 0x6f
    67f0:	78 a9       	sts	0x48, r23
    67f2:	48 2b       	or	r20, r24
    67f4:	59 2b       	or	r21, r25
    67f6:	6a 2b       	or	r22, r26
    67f8:	7b 2b       	or	r23, r27
    67fa:	4d a7       	lds	r20, 0x7d
    67fc:	5e a7       	lds	r21, 0x7e
    67fe:	6f a7       	lds	r22, 0x7f
    6800:	78 ab       	sts	0x58, r23
    6802:	43 01       	movw	r8, r6
    6804:	aa 24       	eor	r10, r10
    6806:	bb 24       	eor	r11, r11
    6808:	93 01       	movw	r18, r6
    680a:	82 01       	movw	r16, r4
    680c:	20 70       	andi	r18, 0x00	; 0
    680e:	30 70       	andi	r19, 0x00	; 0
    6810:	21 96       	adiw	r28, 0x01	; 1
    6812:	0c af       	sts	0x7c, r16
    6814:	1d af       	sts	0x7d, r17
    6816:	2e af       	sts	0x7e, r18
    6818:	3f af       	sts	0x7f, r19
    681a:	21 97       	sbiw	r28, 0x01	; 1
    681c:	69 a9       	sts	0x49, r22
    681e:	7a a9       	sts	0x4a, r23
    6820:	8b a9       	sts	0x4b, r24
    6822:	9c a9       	sts	0x4c, r25
    6824:	a5 01       	movw	r20, r10
    6826:	94 01       	movw	r18, r8
    6828:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    682c:	29 a7       	lds	r18, 0x79
    682e:	3a a7       	lds	r19, 0x7a
    6830:	4b a7       	lds	r20, 0x7b
    6832:	5c a7       	lds	r21, 0x7c
    6834:	6b 01       	movw	r12, r22
    6836:	7c 01       	movw	r14, r24
    6838:	69 a9       	sts	0x49, r22
    683a:	7a a9       	sts	0x4a, r23
    683c:	8b a9       	sts	0x4b, r24
    683e:	9c a9       	sts	0x4c, r25
    6840:	a5 01       	movw	r20, r10
    6842:	94 01       	movw	r18, r8
    6844:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6848:	ca 01       	movw	r24, r20
    684a:	b9 01       	movw	r22, r18
    684c:	21 96       	adiw	r28, 0x01	; 1
    684e:	2c ad       	sts	0x6c, r18
    6850:	3d ad       	sts	0x6d, r19
    6852:	4e ad       	sts	0x6e, r20
    6854:	5f ad       	sts	0x6f, r21
    6856:	21 97       	sbiw	r28, 0x01	; 1
    6858:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    685c:	dc 01       	movw	r26, r24
    685e:	cb 01       	movw	r24, r22
    6860:	76 01       	movw	r14, r12
    6862:	dd 24       	eor	r13, r13
    6864:	cc 24       	eor	r12, r12
    6866:	0d a5       	lds	r16, 0x6d
    6868:	1e a5       	lds	r17, 0x6e
    686a:	2f a5       	lds	r18, 0x6f
    686c:	38 a9       	sts	0x48, r19
    686e:	a9 01       	movw	r20, r18
    6870:	66 27       	eor	r22, r22
    6872:	77 27       	eor	r23, r23
    6874:	c4 2a       	or	r12, r20
    6876:	d5 2a       	or	r13, r21
    6878:	e6 2a       	or	r14, r22
    687a:	f7 2a       	or	r15, r23
    687c:	09 a5       	lds	r16, 0x69
    687e:	1a a5       	lds	r17, 0x6a
    6880:	2b a5       	lds	r18, 0x6b
    6882:	3c a5       	lds	r19, 0x6c
    6884:	c8 16       	cp	r12, r24
    6886:	d9 06       	cpc	r13, r25
    6888:	ea 06       	cpc	r14, r26
    688a:	fb 06       	cpc	r15, r27
    688c:	38 f5       	brcc	.+78     	; 0x68dc <__stack+0x8dd>
    688e:	01 50       	subi	r16, 0x01	; 1
    6890:	10 40       	sbci	r17, 0x00	; 0
    6892:	20 40       	sbci	r18, 0x00	; 0
    6894:	30 40       	sbci	r19, 0x00	; 0
    6896:	09 ab       	sts	0x59, r16
    6898:	1a ab       	sts	0x5a, r17
    689a:	2b ab       	sts	0x5b, r18
    689c:	3c ab       	sts	0x5c, r19
    689e:	c4 0c       	add	r12, r4
    68a0:	d5 1c       	adc	r13, r5
    68a2:	e6 1c       	adc	r14, r6
    68a4:	f7 1c       	adc	r15, r7
    68a6:	c4 14       	cp	r12, r4
    68a8:	d5 04       	cpc	r13, r5
    68aa:	e6 04       	cpc	r14, r6
    68ac:	f7 04       	cpc	r15, r7
    68ae:	d0 f0       	brcs	.+52     	; 0x68e4 <__stack+0x8e5>
    68b0:	c8 16       	cp	r12, r24
    68b2:	d9 06       	cpc	r13, r25
    68b4:	ea 06       	cpc	r14, r26
    68b6:	fb 06       	cpc	r15, r27
    68b8:	a8 f4       	brcc	.+42     	; 0x68e4 <__stack+0x8e5>
    68ba:	09 a5       	lds	r16, 0x69
    68bc:	1a a5       	lds	r17, 0x6a
    68be:	2b a5       	lds	r18, 0x6b
    68c0:	3c a5       	lds	r19, 0x6c
    68c2:	02 50       	subi	r16, 0x02	; 2
    68c4:	10 40       	sbci	r17, 0x00	; 0
    68c6:	20 40       	sbci	r18, 0x00	; 0
    68c8:	30 40       	sbci	r19, 0x00	; 0
    68ca:	09 ab       	sts	0x59, r16
    68cc:	1a ab       	sts	0x5a, r17
    68ce:	2b ab       	sts	0x5b, r18
    68d0:	3c ab       	sts	0x5c, r19
    68d2:	c4 0c       	add	r12, r4
    68d4:	d5 1c       	adc	r13, r5
    68d6:	e6 1c       	adc	r14, r6
    68d8:	f7 1c       	adc	r15, r7
    68da:	04 c0       	rjmp	.+8      	; 0x68e4 <__stack+0x8e5>
    68dc:	09 ab       	sts	0x59, r16
    68de:	1a ab       	sts	0x5a, r17
    68e0:	2b ab       	sts	0x5b, r18
    68e2:	3c ab       	sts	0x5c, r19
    68e4:	c8 1a       	sub	r12, r24
    68e6:	d9 0a       	sbc	r13, r25
    68e8:	ea 0a       	sbc	r14, r26
    68ea:	fb 0a       	sbc	r15, r27
    68ec:	c7 01       	movw	r24, r14
    68ee:	b6 01       	movw	r22, r12
    68f0:	a5 01       	movw	r20, r10
    68f2:	94 01       	movw	r18, r8
    68f4:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    68f8:	29 a7       	lds	r18, 0x79
    68fa:	3a a7       	lds	r19, 0x7a
    68fc:	4b a7       	lds	r20, 0x7b
    68fe:	5c a7       	lds	r21, 0x7c
    6900:	29 96       	adiw	r28, 0x09	; 9
    6902:	6c af       	sts	0x7c, r22
    6904:	7d af       	sts	0x7d, r23
    6906:	8e af       	sts	0x7e, r24
    6908:	9f af       	sts	0x7f, r25
    690a:	29 97       	sbiw	r28, 0x09	; 9
    690c:	c7 01       	movw	r24, r14
    690e:	b6 01       	movw	r22, r12
    6910:	a5 01       	movw	r20, r10
    6912:	94 01       	movw	r18, r8
    6914:	0e 94 0e 38 	call	0x701c	; 0x701c <__udivmodsi4>
    6918:	ca 01       	movw	r24, r20
    691a:	b9 01       	movw	r22, r18
    691c:	21 96       	adiw	r28, 0x01	; 1
    691e:	2c ad       	sts	0x6c, r18
    6920:	3d ad       	sts	0x6d, r19
    6922:	4e ad       	sts	0x6e, r20
    6924:	5f ad       	sts	0x6f, r21
    6926:	21 97       	sbiw	r28, 0x01	; 1
    6928:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    692c:	4b 01       	movw	r8, r22
    692e:	5c 01       	movw	r10, r24
    6930:	29 96       	adiw	r28, 0x09	; 9
    6932:	4c ad       	sts	0x6c, r20
    6934:	5d ad       	sts	0x6d, r21
    6936:	6e ad       	sts	0x6e, r22
    6938:	7f ad       	sts	0x6f, r23
    693a:	29 97       	sbiw	r28, 0x09	; 9
    693c:	9a 01       	movw	r18, r20
    693e:	11 27       	eor	r17, r17
    6940:	00 27       	eor	r16, r16
    6942:	8d a5       	lds	r24, 0x6d
    6944:	9e a5       	lds	r25, 0x6e
    6946:	af a5       	lds	r26, 0x6f
    6948:	b8 a9       	sts	0x48, r27
    694a:	a0 70       	andi	r26, 0x00	; 0
    694c:	b0 70       	andi	r27, 0x00	; 0
    694e:	08 2b       	or	r16, r24
    6950:	19 2b       	or	r17, r25
    6952:	2a 2b       	or	r18, r26
    6954:	3b 2b       	or	r19, r27
    6956:	89 a5       	lds	r24, 0x69
    6958:	9a a5       	lds	r25, 0x6a
    695a:	ab a5       	lds	r26, 0x6b
    695c:	bc a5       	lds	r27, 0x6c
    695e:	08 15       	cp	r16, r8
    6960:	19 05       	cpc	r17, r9
    6962:	2a 05       	cpc	r18, r10
    6964:	3b 05       	cpc	r19, r11
    6966:	e0 f4       	brcc	.+56     	; 0x69a0 <__stack+0x9a1>
    6968:	01 97       	sbiw	r24, 0x01	; 1
    696a:	a1 09       	sbc	r26, r1
    696c:	b1 09       	sbc	r27, r1
    696e:	04 0d       	add	r16, r4
    6970:	15 1d       	adc	r17, r5
    6972:	26 1d       	adc	r18, r6
    6974:	37 1d       	adc	r19, r7
    6976:	04 15       	cp	r16, r4
    6978:	15 05       	cpc	r17, r5
    697a:	26 05       	cpc	r18, r6
    697c:	37 05       	cpc	r19, r7
    697e:	80 f0       	brcs	.+32     	; 0x69a0 <__stack+0x9a1>
    6980:	08 15       	cp	r16, r8
    6982:	19 05       	cpc	r17, r9
    6984:	2a 05       	cpc	r18, r10
    6986:	3b 05       	cpc	r19, r11
    6988:	58 f4       	brcc	.+22     	; 0x69a0 <__stack+0x9a1>
    698a:	89 a5       	lds	r24, 0x69
    698c:	9a a5       	lds	r25, 0x6a
    698e:	ab a5       	lds	r26, 0x6b
    6990:	bc a5       	lds	r27, 0x6c
    6992:	02 97       	sbiw	r24, 0x02	; 2
    6994:	a1 09       	sbc	r26, r1
    6996:	b1 09       	sbc	r27, r1
    6998:	04 0d       	add	r16, r4
    699a:	15 1d       	adc	r17, r5
    699c:	26 1d       	adc	r18, r6
    699e:	37 1d       	adc	r19, r7
    69a0:	b9 01       	movw	r22, r18
    69a2:	a8 01       	movw	r20, r16
    69a4:	48 19       	sub	r20, r8
    69a6:	59 09       	sbc	r21, r9
    69a8:	6a 09       	sbc	r22, r10
    69aa:	7b 09       	sbc	r23, r11
    69ac:	4d a7       	lds	r20, 0x7d
    69ae:	5e a7       	lds	r21, 0x7e
    69b0:	6f a7       	lds	r22, 0x7f
    69b2:	78 ab       	sts	0x58, r23
    69b4:	09 a9       	sts	0x49, r16
    69b6:	1a a9       	sts	0x4a, r17
    69b8:	2b a9       	sts	0x4b, r18
    69ba:	3c a9       	sts	0x4c, r19
    69bc:	78 01       	movw	r14, r16
    69be:	dd 24       	eor	r13, r13
    69c0:	cc 24       	eor	r12, r12
    69c2:	c8 2a       	or	r12, r24
    69c4:	d9 2a       	or	r13, r25
    69c6:	ea 2a       	or	r14, r26
    69c8:	fb 2a       	or	r15, r27
    69ca:	ff ef       	ldi	r31, 0xFF	; 255
    69cc:	8f 2e       	mov	r8, r31
    69ce:	ff ef       	ldi	r31, 0xFF	; 255
    69d0:	9f 2e       	mov	r9, r31
    69d2:	a1 2c       	mov	r10, r1
    69d4:	b1 2c       	mov	r11, r1
    69d6:	8c 20       	and	r8, r12
    69d8:	9d 20       	and	r9, r13
    69da:	ae 20       	and	r10, r14
    69dc:	bf 20       	and	r11, r15
    69de:	87 01       	movw	r16, r14
    69e0:	22 27       	eor	r18, r18
    69e2:	33 27       	eor	r19, r19
    69e4:	09 a7       	lds	r16, 0x79
    69e6:	1a a7       	lds	r17, 0x7a
    69e8:	2b a7       	lds	r18, 0x7b
    69ea:	3c a7       	lds	r19, 0x7c
    69ec:	49 ac       	sts	0xa9, r20
    69ee:	5a ac       	sts	0xaa, r21
    69f0:	6b ac       	sts	0xab, r22
    69f2:	7c ac       	sts	0xac, r23
    69f4:	2f ef       	ldi	r18, 0xFF	; 255
    69f6:	3f ef       	ldi	r19, 0xFF	; 255
    69f8:	40 e0       	ldi	r20, 0x00	; 0
    69fa:	50 e0       	ldi	r21, 0x00	; 0
    69fc:	42 22       	and	r4, r18
    69fe:	53 22       	and	r5, r19
    6a00:	64 22       	and	r6, r20
    6a02:	75 22       	and	r7, r21
    6a04:	29 ad       	sts	0x69, r18
    6a06:	3a ad       	sts	0x6a, r19
    6a08:	4b ad       	sts	0x6b, r20
    6a0a:	5c ad       	sts	0x6c, r21
    6a0c:	8a 01       	movw	r16, r20
    6a0e:	22 27       	eor	r18, r18
    6a10:	33 27       	eor	r19, r19
    6a12:	09 ab       	sts	0x59, r16
    6a14:	1a ab       	sts	0x5a, r17
    6a16:	2b ab       	sts	0x5b, r18
    6a18:	3c ab       	sts	0x5c, r19
    6a1a:	c5 01       	movw	r24, r10
    6a1c:	b4 01       	movw	r22, r8
    6a1e:	a3 01       	movw	r20, r6
    6a20:	92 01       	movw	r18, r4
    6a22:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    6a26:	69 af       	sts	0x79, r22
    6a28:	7a af       	sts	0x7a, r23
    6a2a:	8b af       	sts	0x7b, r24
    6a2c:	9c af       	sts	0x7c, r25
    6a2e:	c5 01       	movw	r24, r10
    6a30:	b4 01       	movw	r22, r8
    6a32:	29 a9       	sts	0x49, r18
    6a34:	3a a9       	sts	0x4a, r19
    6a36:	4b a9       	sts	0x4b, r20
    6a38:	5c a9       	sts	0x4c, r21
    6a3a:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    6a3e:	4b 01       	movw	r8, r22
    6a40:	5c 01       	movw	r10, r24
    6a42:	69 a5       	lds	r22, 0x69
    6a44:	7a a5       	lds	r23, 0x6a
    6a46:	8b a5       	lds	r24, 0x6b
    6a48:	9c a5       	lds	r25, 0x6c
    6a4a:	a3 01       	movw	r20, r6
    6a4c:	92 01       	movw	r18, r4
    6a4e:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    6a52:	2b 01       	movw	r4, r22
    6a54:	3c 01       	movw	r6, r24
    6a56:	69 a5       	lds	r22, 0x69
    6a58:	7a a5       	lds	r23, 0x6a
    6a5a:	8b a5       	lds	r24, 0x6b
    6a5c:	9c a5       	lds	r25, 0x6c
    6a5e:	29 a9       	sts	0x49, r18
    6a60:	3a a9       	sts	0x4a, r19
    6a62:	4b a9       	sts	0x4b, r20
    6a64:	5c a9       	sts	0x4c, r21
    6a66:	0e 94 c8 37 	call	0x6f90	; 0x6f90 <__mulsi3>
    6a6a:	ab 01       	movw	r20, r22
    6a6c:	bc 01       	movw	r22, r24
    6a6e:	84 0c       	add	r8, r4
    6a70:	95 1c       	adc	r9, r5
    6a72:	a6 1c       	adc	r10, r6
    6a74:	b7 1c       	adc	r11, r7
    6a76:	09 ad       	sts	0x69, r16
    6a78:	1a ad       	sts	0x6a, r17
    6a7a:	2b ad       	sts	0x6b, r18
    6a7c:	3c ad       	sts	0x6c, r19
    6a7e:	c9 01       	movw	r24, r18
    6a80:	aa 27       	eor	r26, r26
    6a82:	bb 27       	eor	r27, r27
    6a84:	88 0e       	add	r8, r24
    6a86:	99 1e       	adc	r9, r25
    6a88:	aa 1e       	adc	r10, r26
    6a8a:	bb 1e       	adc	r11, r27
    6a8c:	84 14       	cp	r8, r4
    6a8e:	95 04       	cpc	r9, r5
    6a90:	a6 04       	cpc	r10, r6
    6a92:	b7 04       	cpc	r11, r7
    6a94:	20 f4       	brcc	.+8      	; 0x6a9e <__stack+0xa9f>
    6a96:	40 50       	subi	r20, 0x00	; 0
    6a98:	50 40       	sbci	r21, 0x00	; 0
    6a9a:	6f 4f       	sbci	r22, 0xFF	; 255
    6a9c:	7f 4f       	sbci	r23, 0xFF	; 255
    6a9e:	c5 01       	movw	r24, r10
    6aa0:	aa 27       	eor	r26, r26
    6aa2:	bb 27       	eor	r27, r27
    6aa4:	84 0f       	add	r24, r20
    6aa6:	95 1f       	adc	r25, r21
    6aa8:	a6 1f       	adc	r26, r22
    6aaa:	b7 1f       	adc	r27, r23
    6aac:	0d a5       	lds	r16, 0x6d
    6aae:	1e a5       	lds	r17, 0x6e
    6ab0:	2f a5       	lds	r18, 0x6f
    6ab2:	38 a9       	sts	0x48, r19
    6ab4:	08 17       	cp	r16, r24
    6ab6:	19 07       	cpc	r17, r25
    6ab8:	2a 07       	cpc	r18, r26
    6aba:	3b 07       	cpc	r19, r27
    6abc:	18 f1       	brcs	.+70     	; 0x6b04 <__stack+0xb05>
    6abe:	80 17       	cp	r24, r16
    6ac0:	91 07       	cpc	r25, r17
    6ac2:	a2 07       	cpc	r26, r18
    6ac4:	b3 07       	cpc	r27, r19
    6ac6:	a1 f5       	brne	.+104    	; 0x6b30 <__stack+0xb31>
    6ac8:	54 01       	movw	r10, r8
    6aca:	99 24       	eor	r9, r9
    6acc:	88 24       	eor	r8, r8
    6ace:	89 ad       	sts	0x69, r24
    6ad0:	9a ad       	sts	0x6a, r25
    6ad2:	ab ad       	sts	0x6b, r26
    6ad4:	bc ad       	sts	0x6c, r27
    6ad6:	a0 70       	andi	r26, 0x00	; 0
    6ad8:	b0 70       	andi	r27, 0x00	; 0
    6ada:	88 0e       	add	r8, r24
    6adc:	99 1e       	adc	r9, r25
    6ade:	aa 1e       	adc	r10, r26
    6ae0:	bb 1e       	adc	r11, r27
    6ae2:	4d a9       	sts	0x4d, r20
    6ae4:	5e a9       	sts	0x4e, r21
    6ae6:	6f a9       	sts	0x4f, r22
    6ae8:	78 ad       	sts	0x68, r23
    6aea:	03 2c       	mov	r0, r3
    6aec:	04 c0       	rjmp	.+8      	; 0x6af6 <__stack+0xaf7>
    6aee:	44 0f       	add	r20, r20
    6af0:	55 1f       	adc	r21, r21
    6af2:	66 1f       	adc	r22, r22
    6af4:	77 1f       	adc	r23, r23
    6af6:	0a 94       	dec	r0
    6af8:	d2 f7       	brpl	.-12     	; 0x6aee <__stack+0xaef>
    6afa:	48 15       	cp	r20, r8
    6afc:	59 05       	cpc	r21, r9
    6afe:	6a 05       	cpc	r22, r10
    6b00:	7b 05       	cpc	r23, r11
    6b02:	b0 f4       	brcc	.+44     	; 0x6b30 <__stack+0xb31>
    6b04:	08 94       	sec
    6b06:	c1 08       	sbc	r12, r1
    6b08:	d1 08       	sbc	r13, r1
    6b0a:	e1 08       	sbc	r14, r1
    6b0c:	f1 08       	sbc	r15, r1
    6b0e:	10 c0       	rjmp	.+32     	; 0x6b30 <__stack+0xb31>
    6b10:	44 24       	eor	r4, r4
    6b12:	55 24       	eor	r5, r5
    6b14:	32 01       	movw	r6, r4
    6b16:	cc 24       	eor	r12, r12
    6b18:	dd 24       	eor	r13, r13
    6b1a:	76 01       	movw	r14, r12
    6b1c:	0c c0       	rjmp	.+24     	; 0x6b36 <__stack+0xb37>
    6b1e:	44 24       	eor	r4, r4
    6b20:	55 24       	eor	r5, r5
    6b22:	32 01       	movw	r6, r4
    6b24:	81 e0       	ldi	r24, 0x01	; 1
    6b26:	c8 2e       	mov	r12, r24
    6b28:	d1 2c       	mov	r13, r1
    6b2a:	e1 2c       	mov	r14, r1
    6b2c:	f1 2c       	mov	r15, r1
    6b2e:	03 c0       	rjmp	.+6      	; 0x6b36 <__stack+0xb37>
    6b30:	44 24       	eor	r4, r4
    6b32:	55 24       	eor	r5, r5
    6b34:	32 01       	movw	r6, r4
    6b36:	fe 01       	movw	r30, r28
    6b38:	31 96       	adiw	r30, 0x01	; 1
    6b3a:	88 e0       	ldi	r24, 0x08	; 8
    6b3c:	df 01       	movw	r26, r30
    6b3e:	1d 92       	st	X+, r1
    6b40:	8a 95       	dec	r24
    6b42:	e9 f7       	brne	.-6      	; 0x6b3e <__stack+0xb3f>
    6b44:	c9 82       	std	Y+1, r12	; 0x01
    6b46:	da 82       	std	Y+2, r13	; 0x02
    6b48:	eb 82       	std	Y+3, r14	; 0x03
    6b4a:	fc 82       	std	Y+4, r15	; 0x04
    6b4c:	4d 82       	std	Y+5, r4	; 0x05
    6b4e:	5e 82       	std	Y+6, r5	; 0x06
    6b50:	6f 82       	std	Y+7, r6	; 0x07
    6b52:	78 86       	std	Y+8, r7	; 0x08
    6b54:	2c 2d       	mov	r18, r12
    6b56:	3a 81       	ldd	r19, Y+2	; 0x02
    6b58:	4b 81       	ldd	r20, Y+3	; 0x03
    6b5a:	5c 81       	ldd	r21, Y+4	; 0x04
    6b5c:	64 2d       	mov	r22, r4
    6b5e:	7e 81       	ldd	r23, Y+6	; 0x06
    6b60:	8f 81       	ldd	r24, Y+7	; 0x07
    6b62:	98 85       	ldd	r25, Y+8	; 0x08
    6b64:	25 96       	adiw	r28, 0x05	; 5
    6b66:	ec ac       	sts	0xac, r30
    6b68:	fd ac       	sts	0xad, r31
    6b6a:	0e ad       	sts	0x6e, r16
    6b6c:	1f ad       	sts	0x6f, r17
    6b6e:	25 97       	sbiw	r28, 0x05	; 5
    6b70:	e1 14       	cp	r14, r1
    6b72:	f1 04       	cpc	r15, r1
    6b74:	01 05       	cpc	r16, r1
    6b76:	11 05       	cpc	r17, r1
    6b78:	09 f4       	brne	.+2      	; 0x6b7c <__stack+0xb7d>
    6b7a:	56 c0       	rjmp	.+172    	; 0x6c28 <__stack+0xc29>
    6b7c:	21 95       	neg	r18
    6b7e:	e1 e0       	ldi	r30, 0x01	; 1
    6b80:	12 16       	cp	r1, r18
    6b82:	08 f0       	brcs	.+2      	; 0x6b86 <__stack+0xb87>
    6b84:	e0 e0       	ldi	r30, 0x00	; 0
    6b86:	31 95       	neg	r19
    6b88:	f1 e0       	ldi	r31, 0x01	; 1
    6b8a:	13 16       	cp	r1, r19
    6b8c:	08 f0       	brcs	.+2      	; 0x6b90 <__stack+0xb91>
    6b8e:	f0 e0       	ldi	r31, 0x00	; 0
    6b90:	03 2f       	mov	r16, r19
    6b92:	0e 1b       	sub	r16, r30
    6b94:	e1 e0       	ldi	r30, 0x01	; 1
    6b96:	30 17       	cp	r19, r16
    6b98:	08 f0       	brcs	.+2      	; 0x6b9c <__stack+0xb9d>
    6b9a:	e0 e0       	ldi	r30, 0x00	; 0
    6b9c:	fe 2b       	or	r31, r30
    6b9e:	41 95       	neg	r20
    6ba0:	e1 e0       	ldi	r30, 0x01	; 1
    6ba2:	14 16       	cp	r1, r20
    6ba4:	08 f0       	brcs	.+2      	; 0x6ba8 <__stack+0xba9>
    6ba6:	e0 e0       	ldi	r30, 0x00	; 0
    6ba8:	14 2f       	mov	r17, r20
    6baa:	1f 1b       	sub	r17, r31
    6bac:	31 e0       	ldi	r19, 0x01	; 1
    6bae:	41 17       	cp	r20, r17
    6bb0:	08 f0       	brcs	.+2      	; 0x6bb4 <__stack+0xbb5>
    6bb2:	30 e0       	ldi	r19, 0x00	; 0
    6bb4:	e3 2b       	or	r30, r19
    6bb6:	51 95       	neg	r21
    6bb8:	f1 e0       	ldi	r31, 0x01	; 1
    6bba:	15 16       	cp	r1, r21
    6bbc:	08 f0       	brcs	.+2      	; 0x6bc0 <__stack+0xbc1>
    6bbe:	f0 e0       	ldi	r31, 0x00	; 0
    6bc0:	b5 2f       	mov	r27, r21
    6bc2:	be 1b       	sub	r27, r30
    6bc4:	31 e0       	ldi	r19, 0x01	; 1
    6bc6:	5b 17       	cp	r21, r27
    6bc8:	08 f0       	brcs	.+2      	; 0x6bcc <__stack+0xbcd>
    6bca:	30 e0       	ldi	r19, 0x00	; 0
    6bcc:	f3 2b       	or	r31, r19
    6bce:	61 95       	neg	r22
    6bd0:	e1 e0       	ldi	r30, 0x01	; 1
    6bd2:	16 16       	cp	r1, r22
    6bd4:	08 f0       	brcs	.+2      	; 0x6bd8 <__stack+0xbd9>
    6bd6:	e0 e0       	ldi	r30, 0x00	; 0
    6bd8:	46 2e       	mov	r4, r22
    6bda:	4f 1a       	sub	r4, r31
    6bdc:	31 e0       	ldi	r19, 0x01	; 1
    6bde:	64 15       	cp	r22, r4
    6be0:	08 f0       	brcs	.+2      	; 0x6be4 <__stack+0xbe5>
    6be2:	30 e0       	ldi	r19, 0x00	; 0
    6be4:	e3 2b       	or	r30, r19
    6be6:	71 95       	neg	r23
    6be8:	f1 e0       	ldi	r31, 0x01	; 1
    6bea:	17 16       	cp	r1, r23
    6bec:	08 f0       	brcs	.+2      	; 0x6bf0 <__stack+0xbf1>
    6bee:	f0 e0       	ldi	r31, 0x00	; 0
    6bf0:	a7 2f       	mov	r26, r23
    6bf2:	ae 1b       	sub	r26, r30
    6bf4:	31 e0       	ldi	r19, 0x01	; 1
    6bf6:	7a 17       	cp	r23, r26
    6bf8:	08 f0       	brcs	.+2      	; 0x6bfc <__stack+0xbfd>
    6bfa:	30 e0       	ldi	r19, 0x00	; 0
    6bfc:	f3 2b       	or	r31, r19
    6bfe:	81 95       	neg	r24
    6c00:	e1 e0       	ldi	r30, 0x01	; 1
    6c02:	18 16       	cp	r1, r24
    6c04:	08 f0       	brcs	.+2      	; 0x6c08 <__stack+0xc09>
    6c06:	e0 e0       	ldi	r30, 0x00	; 0
    6c08:	f8 2e       	mov	r15, r24
    6c0a:	ff 1a       	sub	r15, r31
    6c0c:	ff 2d       	mov	r31, r15
    6c0e:	31 e0       	ldi	r19, 0x01	; 1
    6c10:	8f 15       	cp	r24, r15
    6c12:	08 f0       	brcs	.+2      	; 0x6c16 <__stack+0xc17>
    6c14:	30 e0       	ldi	r19, 0x00	; 0
    6c16:	e3 2b       	or	r30, r19
    6c18:	91 95       	neg	r25
    6c1a:	30 2f       	mov	r19, r16
    6c1c:	41 2f       	mov	r20, r17
    6c1e:	5b 2f       	mov	r21, r27
    6c20:	64 2d       	mov	r22, r4
    6c22:	7a 2f       	mov	r23, r26
    6c24:	8f 2f       	mov	r24, r31
    6c26:	9e 1b       	sub	r25, r30
    6c28:	c8 5b       	subi	r28, 0xB8	; 184
    6c2a:	df 4f       	sbci	r29, 0xFF	; 255
    6c2c:	e1 e1       	ldi	r30, 0x11	; 17
    6c2e:	0c 94 65 38 	jmp	0x70ca	; 0x70ca <__epilogue_restores__+0x2>

00006c32 <__subsf3>:
    6c32:	50 58       	subi	r21, 0x80	; 128

00006c34 <__addsf3>:
    6c34:	bb 27       	eor	r27, r27
    6c36:	aa 27       	eor	r26, r26
    6c38:	0e d0       	rcall	.+28     	; 0x6c56 <__addsf3x>
    6c3a:	48 c1       	rjmp	.+656    	; 0x6ecc <__fp_round>
    6c3c:	39 d1       	rcall	.+626    	; 0x6eb0 <__fp_pscA>
    6c3e:	30 f0       	brcs	.+12     	; 0x6c4c <__addsf3+0x18>
    6c40:	3e d1       	rcall	.+636    	; 0x6ebe <__fp_pscB>
    6c42:	20 f0       	brcs	.+8      	; 0x6c4c <__addsf3+0x18>
    6c44:	31 f4       	brne	.+12     	; 0x6c52 <__addsf3+0x1e>
    6c46:	9f 3f       	cpi	r25, 0xFF	; 255
    6c48:	11 f4       	brne	.+4      	; 0x6c4e <__addsf3+0x1a>
    6c4a:	1e f4       	brtc	.+6      	; 0x6c52 <__addsf3+0x1e>
    6c4c:	2e c1       	rjmp	.+604    	; 0x6eaa <__fp_nan>
    6c4e:	0e f4       	brtc	.+2      	; 0x6c52 <__addsf3+0x1e>
    6c50:	e0 95       	com	r30
    6c52:	e7 fb       	bst	r30, 7
    6c54:	24 c1       	rjmp	.+584    	; 0x6e9e <__fp_inf>

00006c56 <__addsf3x>:
    6c56:	e9 2f       	mov	r30, r25
    6c58:	4a d1       	rcall	.+660    	; 0x6eee <__fp_split3>
    6c5a:	80 f3       	brcs	.-32     	; 0x6c3c <__addsf3+0x8>
    6c5c:	ba 17       	cp	r27, r26
    6c5e:	62 07       	cpc	r22, r18
    6c60:	73 07       	cpc	r23, r19
    6c62:	84 07       	cpc	r24, r20
    6c64:	95 07       	cpc	r25, r21
    6c66:	18 f0       	brcs	.+6      	; 0x6c6e <__addsf3x+0x18>
    6c68:	71 f4       	brne	.+28     	; 0x6c86 <__addsf3x+0x30>
    6c6a:	9e f5       	brtc	.+102    	; 0x6cd2 <__addsf3x+0x7c>
    6c6c:	62 c1       	rjmp	.+708    	; 0x6f32 <__fp_zero>
    6c6e:	0e f4       	brtc	.+2      	; 0x6c72 <__addsf3x+0x1c>
    6c70:	e0 95       	com	r30
    6c72:	0b 2e       	mov	r0, r27
    6c74:	ba 2f       	mov	r27, r26
    6c76:	a0 2d       	mov	r26, r0
    6c78:	0b 01       	movw	r0, r22
    6c7a:	b9 01       	movw	r22, r18
    6c7c:	90 01       	movw	r18, r0
    6c7e:	0c 01       	movw	r0, r24
    6c80:	ca 01       	movw	r24, r20
    6c82:	a0 01       	movw	r20, r0
    6c84:	11 24       	eor	r1, r1
    6c86:	ff 27       	eor	r31, r31
    6c88:	59 1b       	sub	r21, r25
    6c8a:	99 f0       	breq	.+38     	; 0x6cb2 <__addsf3x+0x5c>
    6c8c:	59 3f       	cpi	r21, 0xF9	; 249
    6c8e:	50 f4       	brcc	.+20     	; 0x6ca4 <__addsf3x+0x4e>
    6c90:	50 3e       	cpi	r21, 0xE0	; 224
    6c92:	68 f1       	brcs	.+90     	; 0x6cee <__addsf3x+0x98>
    6c94:	1a 16       	cp	r1, r26
    6c96:	f0 40       	sbci	r31, 0x00	; 0
    6c98:	a2 2f       	mov	r26, r18
    6c9a:	23 2f       	mov	r18, r19
    6c9c:	34 2f       	mov	r19, r20
    6c9e:	44 27       	eor	r20, r20
    6ca0:	58 5f       	subi	r21, 0xF8	; 248
    6ca2:	f3 cf       	rjmp	.-26     	; 0x6c8a <__addsf3x+0x34>
    6ca4:	46 95       	lsr	r20
    6ca6:	37 95       	ror	r19
    6ca8:	27 95       	ror	r18
    6caa:	a7 95       	ror	r26
    6cac:	f0 40       	sbci	r31, 0x00	; 0
    6cae:	53 95       	inc	r21
    6cb0:	c9 f7       	brne	.-14     	; 0x6ca4 <__addsf3x+0x4e>
    6cb2:	7e f4       	brtc	.+30     	; 0x6cd2 <__addsf3x+0x7c>
    6cb4:	1f 16       	cp	r1, r31
    6cb6:	ba 0b       	sbc	r27, r26
    6cb8:	62 0b       	sbc	r22, r18
    6cba:	73 0b       	sbc	r23, r19
    6cbc:	84 0b       	sbc	r24, r20
    6cbe:	ba f0       	brmi	.+46     	; 0x6cee <__addsf3x+0x98>
    6cc0:	91 50       	subi	r25, 0x01	; 1
    6cc2:	a1 f0       	breq	.+40     	; 0x6cec <__addsf3x+0x96>
    6cc4:	ff 0f       	add	r31, r31
    6cc6:	bb 1f       	adc	r27, r27
    6cc8:	66 1f       	adc	r22, r22
    6cca:	77 1f       	adc	r23, r23
    6ccc:	88 1f       	adc	r24, r24
    6cce:	c2 f7       	brpl	.-16     	; 0x6cc0 <__addsf3x+0x6a>
    6cd0:	0e c0       	rjmp	.+28     	; 0x6cee <__addsf3x+0x98>
    6cd2:	ba 0f       	add	r27, r26
    6cd4:	62 1f       	adc	r22, r18
    6cd6:	73 1f       	adc	r23, r19
    6cd8:	84 1f       	adc	r24, r20
    6cda:	48 f4       	brcc	.+18     	; 0x6cee <__addsf3x+0x98>
    6cdc:	87 95       	ror	r24
    6cde:	77 95       	ror	r23
    6ce0:	67 95       	ror	r22
    6ce2:	b7 95       	ror	r27
    6ce4:	f7 95       	ror	r31
    6ce6:	9e 3f       	cpi	r25, 0xFE	; 254
    6ce8:	08 f0       	brcs	.+2      	; 0x6cec <__addsf3x+0x96>
    6cea:	b3 cf       	rjmp	.-154    	; 0x6c52 <__addsf3+0x1e>
    6cec:	93 95       	inc	r25
    6cee:	88 0f       	add	r24, r24
    6cf0:	08 f0       	brcs	.+2      	; 0x6cf4 <__addsf3x+0x9e>
    6cf2:	99 27       	eor	r25, r25
    6cf4:	ee 0f       	add	r30, r30
    6cf6:	97 95       	ror	r25
    6cf8:	87 95       	ror	r24
    6cfa:	08 95       	ret

00006cfc <__divsf3>:
    6cfc:	0c d0       	rcall	.+24     	; 0x6d16 <__divsf3x>
    6cfe:	e6 c0       	rjmp	.+460    	; 0x6ecc <__fp_round>
    6d00:	de d0       	rcall	.+444    	; 0x6ebe <__fp_pscB>
    6d02:	40 f0       	brcs	.+16     	; 0x6d14 <__divsf3+0x18>
    6d04:	d5 d0       	rcall	.+426    	; 0x6eb0 <__fp_pscA>
    6d06:	30 f0       	brcs	.+12     	; 0x6d14 <__divsf3+0x18>
    6d08:	21 f4       	brne	.+8      	; 0x6d12 <__divsf3+0x16>
    6d0a:	5f 3f       	cpi	r21, 0xFF	; 255
    6d0c:	19 f0       	breq	.+6      	; 0x6d14 <__divsf3+0x18>
    6d0e:	c7 c0       	rjmp	.+398    	; 0x6e9e <__fp_inf>
    6d10:	51 11       	cpse	r21, r1
    6d12:	10 c1       	rjmp	.+544    	; 0x6f34 <__fp_szero>
    6d14:	ca c0       	rjmp	.+404    	; 0x6eaa <__fp_nan>

00006d16 <__divsf3x>:
    6d16:	eb d0       	rcall	.+470    	; 0x6eee <__fp_split3>
    6d18:	98 f3       	brcs	.-26     	; 0x6d00 <__divsf3+0x4>

00006d1a <__divsf3_pse>:
    6d1a:	99 23       	and	r25, r25
    6d1c:	c9 f3       	breq	.-14     	; 0x6d10 <__divsf3+0x14>
    6d1e:	55 23       	and	r21, r21
    6d20:	b1 f3       	breq	.-20     	; 0x6d0e <__divsf3+0x12>
    6d22:	95 1b       	sub	r25, r21
    6d24:	55 0b       	sbc	r21, r21
    6d26:	bb 27       	eor	r27, r27
    6d28:	aa 27       	eor	r26, r26
    6d2a:	62 17       	cp	r22, r18
    6d2c:	73 07       	cpc	r23, r19
    6d2e:	84 07       	cpc	r24, r20
    6d30:	38 f0       	brcs	.+14     	; 0x6d40 <__divsf3_pse+0x26>
    6d32:	9f 5f       	subi	r25, 0xFF	; 255
    6d34:	5f 4f       	sbci	r21, 0xFF	; 255
    6d36:	22 0f       	add	r18, r18
    6d38:	33 1f       	adc	r19, r19
    6d3a:	44 1f       	adc	r20, r20
    6d3c:	aa 1f       	adc	r26, r26
    6d3e:	a9 f3       	breq	.-22     	; 0x6d2a <__divsf3_pse+0x10>
    6d40:	33 d0       	rcall	.+102    	; 0x6da8 <__divsf3_pse+0x8e>
    6d42:	0e 2e       	mov	r0, r30
    6d44:	3a f0       	brmi	.+14     	; 0x6d54 <__divsf3_pse+0x3a>
    6d46:	e0 e8       	ldi	r30, 0x80	; 128
    6d48:	30 d0       	rcall	.+96     	; 0x6daa <__divsf3_pse+0x90>
    6d4a:	91 50       	subi	r25, 0x01	; 1
    6d4c:	50 40       	sbci	r21, 0x00	; 0
    6d4e:	e6 95       	lsr	r30
    6d50:	00 1c       	adc	r0, r0
    6d52:	ca f7       	brpl	.-14     	; 0x6d46 <__divsf3_pse+0x2c>
    6d54:	29 d0       	rcall	.+82     	; 0x6da8 <__divsf3_pse+0x8e>
    6d56:	fe 2f       	mov	r31, r30
    6d58:	27 d0       	rcall	.+78     	; 0x6da8 <__divsf3_pse+0x8e>
    6d5a:	66 0f       	add	r22, r22
    6d5c:	77 1f       	adc	r23, r23
    6d5e:	88 1f       	adc	r24, r24
    6d60:	bb 1f       	adc	r27, r27
    6d62:	26 17       	cp	r18, r22
    6d64:	37 07       	cpc	r19, r23
    6d66:	48 07       	cpc	r20, r24
    6d68:	ab 07       	cpc	r26, r27
    6d6a:	b0 e8       	ldi	r27, 0x80	; 128
    6d6c:	09 f0       	breq	.+2      	; 0x6d70 <__divsf3_pse+0x56>
    6d6e:	bb 0b       	sbc	r27, r27
    6d70:	80 2d       	mov	r24, r0
    6d72:	bf 01       	movw	r22, r30
    6d74:	ff 27       	eor	r31, r31
    6d76:	93 58       	subi	r25, 0x83	; 131
    6d78:	5f 4f       	sbci	r21, 0xFF	; 255
    6d7a:	2a f0       	brmi	.+10     	; 0x6d86 <__divsf3_pse+0x6c>
    6d7c:	9e 3f       	cpi	r25, 0xFE	; 254
    6d7e:	51 05       	cpc	r21, r1
    6d80:	68 f0       	brcs	.+26     	; 0x6d9c <__divsf3_pse+0x82>
    6d82:	8d c0       	rjmp	.+282    	; 0x6e9e <__fp_inf>
    6d84:	d7 c0       	rjmp	.+430    	; 0x6f34 <__fp_szero>
    6d86:	5f 3f       	cpi	r21, 0xFF	; 255
    6d88:	ec f3       	brlt	.-6      	; 0x6d84 <__divsf3_pse+0x6a>
    6d8a:	98 3e       	cpi	r25, 0xE8	; 232
    6d8c:	dc f3       	brlt	.-10     	; 0x6d84 <__divsf3_pse+0x6a>
    6d8e:	86 95       	lsr	r24
    6d90:	77 95       	ror	r23
    6d92:	67 95       	ror	r22
    6d94:	b7 95       	ror	r27
    6d96:	f7 95       	ror	r31
    6d98:	9f 5f       	subi	r25, 0xFF	; 255
    6d9a:	c9 f7       	brne	.-14     	; 0x6d8e <__divsf3_pse+0x74>
    6d9c:	88 0f       	add	r24, r24
    6d9e:	91 1d       	adc	r25, r1
    6da0:	96 95       	lsr	r25
    6da2:	87 95       	ror	r24
    6da4:	97 f9       	bld	r25, 7
    6da6:	08 95       	ret
    6da8:	e1 e0       	ldi	r30, 0x01	; 1
    6daa:	66 0f       	add	r22, r22
    6dac:	77 1f       	adc	r23, r23
    6dae:	88 1f       	adc	r24, r24
    6db0:	bb 1f       	adc	r27, r27
    6db2:	62 17       	cp	r22, r18
    6db4:	73 07       	cpc	r23, r19
    6db6:	84 07       	cpc	r24, r20
    6db8:	ba 07       	cpc	r27, r26
    6dba:	20 f0       	brcs	.+8      	; 0x6dc4 <__divsf3_pse+0xaa>
    6dbc:	62 1b       	sub	r22, r18
    6dbe:	73 0b       	sbc	r23, r19
    6dc0:	84 0b       	sbc	r24, r20
    6dc2:	ba 0b       	sbc	r27, r26
    6dc4:	ee 1f       	adc	r30, r30
    6dc6:	88 f7       	brcc	.-30     	; 0x6daa <__divsf3_pse+0x90>
    6dc8:	e0 95       	com	r30
    6dca:	08 95       	ret

00006dcc <__fixunssfsi>:
    6dcc:	98 d0       	rcall	.+304    	; 0x6efe <__fp_splitA>
    6dce:	88 f0       	brcs	.+34     	; 0x6df2 <__fixunssfsi+0x26>
    6dd0:	9f 57       	subi	r25, 0x7F	; 127
    6dd2:	90 f0       	brcs	.+36     	; 0x6df8 <__fixunssfsi+0x2c>
    6dd4:	b9 2f       	mov	r27, r25
    6dd6:	99 27       	eor	r25, r25
    6dd8:	b7 51       	subi	r27, 0x17	; 23
    6dda:	a0 f0       	brcs	.+40     	; 0x6e04 <__fixunssfsi+0x38>
    6ddc:	d1 f0       	breq	.+52     	; 0x6e12 <__fixunssfsi+0x46>
    6dde:	66 0f       	add	r22, r22
    6de0:	77 1f       	adc	r23, r23
    6de2:	88 1f       	adc	r24, r24
    6de4:	99 1f       	adc	r25, r25
    6de6:	1a f0       	brmi	.+6      	; 0x6dee <__fixunssfsi+0x22>
    6de8:	ba 95       	dec	r27
    6dea:	c9 f7       	brne	.-14     	; 0x6dde <__fixunssfsi+0x12>
    6dec:	12 c0       	rjmp	.+36     	; 0x6e12 <__fixunssfsi+0x46>
    6dee:	b1 30       	cpi	r27, 0x01	; 1
    6df0:	81 f0       	breq	.+32     	; 0x6e12 <__fixunssfsi+0x46>
    6df2:	9f d0       	rcall	.+318    	; 0x6f32 <__fp_zero>
    6df4:	b1 e0       	ldi	r27, 0x01	; 1
    6df6:	08 95       	ret
    6df8:	9c c0       	rjmp	.+312    	; 0x6f32 <__fp_zero>
    6dfa:	67 2f       	mov	r22, r23
    6dfc:	78 2f       	mov	r23, r24
    6dfe:	88 27       	eor	r24, r24
    6e00:	b8 5f       	subi	r27, 0xF8	; 248
    6e02:	39 f0       	breq	.+14     	; 0x6e12 <__fixunssfsi+0x46>
    6e04:	b9 3f       	cpi	r27, 0xF9	; 249
    6e06:	cc f3       	brlt	.-14     	; 0x6dfa <__fixunssfsi+0x2e>
    6e08:	86 95       	lsr	r24
    6e0a:	77 95       	ror	r23
    6e0c:	67 95       	ror	r22
    6e0e:	b3 95       	inc	r27
    6e10:	d9 f7       	brne	.-10     	; 0x6e08 <__fixunssfsi+0x3c>
    6e12:	3e f4       	brtc	.+14     	; 0x6e22 <__fixunssfsi+0x56>
    6e14:	90 95       	com	r25
    6e16:	80 95       	com	r24
    6e18:	70 95       	com	r23
    6e1a:	61 95       	neg	r22
    6e1c:	7f 4f       	sbci	r23, 0xFF	; 255
    6e1e:	8f 4f       	sbci	r24, 0xFF	; 255
    6e20:	9f 4f       	sbci	r25, 0xFF	; 255
    6e22:	08 95       	ret

00006e24 <__floatunsisf>:
    6e24:	e8 94       	clt
    6e26:	09 c0       	rjmp	.+18     	; 0x6e3a <__floatsisf+0x12>

00006e28 <__floatsisf>:
    6e28:	97 fb       	bst	r25, 7
    6e2a:	3e f4       	brtc	.+14     	; 0x6e3a <__floatsisf+0x12>
    6e2c:	90 95       	com	r25
    6e2e:	80 95       	com	r24
    6e30:	70 95       	com	r23
    6e32:	61 95       	neg	r22
    6e34:	7f 4f       	sbci	r23, 0xFF	; 255
    6e36:	8f 4f       	sbci	r24, 0xFF	; 255
    6e38:	9f 4f       	sbci	r25, 0xFF	; 255
    6e3a:	99 23       	and	r25, r25
    6e3c:	a9 f0       	breq	.+42     	; 0x6e68 <__floatsisf+0x40>
    6e3e:	f9 2f       	mov	r31, r25
    6e40:	96 e9       	ldi	r25, 0x96	; 150
    6e42:	bb 27       	eor	r27, r27
    6e44:	93 95       	inc	r25
    6e46:	f6 95       	lsr	r31
    6e48:	87 95       	ror	r24
    6e4a:	77 95       	ror	r23
    6e4c:	67 95       	ror	r22
    6e4e:	b7 95       	ror	r27
    6e50:	f1 11       	cpse	r31, r1
    6e52:	f8 cf       	rjmp	.-16     	; 0x6e44 <__floatsisf+0x1c>
    6e54:	fa f4       	brpl	.+62     	; 0x6e94 <__floatsisf+0x6c>
    6e56:	bb 0f       	add	r27, r27
    6e58:	11 f4       	brne	.+4      	; 0x6e5e <__floatsisf+0x36>
    6e5a:	60 ff       	sbrs	r22, 0
    6e5c:	1b c0       	rjmp	.+54     	; 0x6e94 <__floatsisf+0x6c>
    6e5e:	6f 5f       	subi	r22, 0xFF	; 255
    6e60:	7f 4f       	sbci	r23, 0xFF	; 255
    6e62:	8f 4f       	sbci	r24, 0xFF	; 255
    6e64:	9f 4f       	sbci	r25, 0xFF	; 255
    6e66:	16 c0       	rjmp	.+44     	; 0x6e94 <__floatsisf+0x6c>
    6e68:	88 23       	and	r24, r24
    6e6a:	11 f0       	breq	.+4      	; 0x6e70 <__floatsisf+0x48>
    6e6c:	96 e9       	ldi	r25, 0x96	; 150
    6e6e:	11 c0       	rjmp	.+34     	; 0x6e92 <__floatsisf+0x6a>
    6e70:	77 23       	and	r23, r23
    6e72:	21 f0       	breq	.+8      	; 0x6e7c <__floatsisf+0x54>
    6e74:	9e e8       	ldi	r25, 0x8E	; 142
    6e76:	87 2f       	mov	r24, r23
    6e78:	76 2f       	mov	r23, r22
    6e7a:	05 c0       	rjmp	.+10     	; 0x6e86 <__floatsisf+0x5e>
    6e7c:	66 23       	and	r22, r22
    6e7e:	71 f0       	breq	.+28     	; 0x6e9c <__floatsisf+0x74>
    6e80:	96 e8       	ldi	r25, 0x86	; 134
    6e82:	86 2f       	mov	r24, r22
    6e84:	70 e0       	ldi	r23, 0x00	; 0
    6e86:	60 e0       	ldi	r22, 0x00	; 0
    6e88:	2a f0       	brmi	.+10     	; 0x6e94 <__floatsisf+0x6c>
    6e8a:	9a 95       	dec	r25
    6e8c:	66 0f       	add	r22, r22
    6e8e:	77 1f       	adc	r23, r23
    6e90:	88 1f       	adc	r24, r24
    6e92:	da f7       	brpl	.-10     	; 0x6e8a <__floatsisf+0x62>
    6e94:	88 0f       	add	r24, r24
    6e96:	96 95       	lsr	r25
    6e98:	87 95       	ror	r24
    6e9a:	97 f9       	bld	r25, 7
    6e9c:	08 95       	ret

00006e9e <__fp_inf>:
    6e9e:	97 f9       	bld	r25, 7
    6ea0:	9f 67       	ori	r25, 0x7F	; 127
    6ea2:	80 e8       	ldi	r24, 0x80	; 128
    6ea4:	70 e0       	ldi	r23, 0x00	; 0
    6ea6:	60 e0       	ldi	r22, 0x00	; 0
    6ea8:	08 95       	ret

00006eaa <__fp_nan>:
    6eaa:	9f ef       	ldi	r25, 0xFF	; 255
    6eac:	80 ec       	ldi	r24, 0xC0	; 192
    6eae:	08 95       	ret

00006eb0 <__fp_pscA>:
    6eb0:	00 24       	eor	r0, r0
    6eb2:	0a 94       	dec	r0
    6eb4:	16 16       	cp	r1, r22
    6eb6:	17 06       	cpc	r1, r23
    6eb8:	18 06       	cpc	r1, r24
    6eba:	09 06       	cpc	r0, r25
    6ebc:	08 95       	ret

00006ebe <__fp_pscB>:
    6ebe:	00 24       	eor	r0, r0
    6ec0:	0a 94       	dec	r0
    6ec2:	12 16       	cp	r1, r18
    6ec4:	13 06       	cpc	r1, r19
    6ec6:	14 06       	cpc	r1, r20
    6ec8:	05 06       	cpc	r0, r21
    6eca:	08 95       	ret

00006ecc <__fp_round>:
    6ecc:	09 2e       	mov	r0, r25
    6ece:	03 94       	inc	r0
    6ed0:	00 0c       	add	r0, r0
    6ed2:	11 f4       	brne	.+4      	; 0x6ed8 <__fp_round+0xc>
    6ed4:	88 23       	and	r24, r24
    6ed6:	52 f0       	brmi	.+20     	; 0x6eec <__fp_round+0x20>
    6ed8:	bb 0f       	add	r27, r27
    6eda:	40 f4       	brcc	.+16     	; 0x6eec <__fp_round+0x20>
    6edc:	bf 2b       	or	r27, r31
    6ede:	11 f4       	brne	.+4      	; 0x6ee4 <__fp_round+0x18>
    6ee0:	60 ff       	sbrs	r22, 0
    6ee2:	04 c0       	rjmp	.+8      	; 0x6eec <__fp_round+0x20>
    6ee4:	6f 5f       	subi	r22, 0xFF	; 255
    6ee6:	7f 4f       	sbci	r23, 0xFF	; 255
    6ee8:	8f 4f       	sbci	r24, 0xFF	; 255
    6eea:	9f 4f       	sbci	r25, 0xFF	; 255
    6eec:	08 95       	ret

00006eee <__fp_split3>:
    6eee:	57 fd       	sbrc	r21, 7
    6ef0:	90 58       	subi	r25, 0x80	; 128
    6ef2:	44 0f       	add	r20, r20
    6ef4:	55 1f       	adc	r21, r21
    6ef6:	59 f0       	breq	.+22     	; 0x6f0e <__fp_splitA+0x10>
    6ef8:	5f 3f       	cpi	r21, 0xFF	; 255
    6efa:	71 f0       	breq	.+28     	; 0x6f18 <__fp_splitA+0x1a>
    6efc:	47 95       	ror	r20

00006efe <__fp_splitA>:
    6efe:	88 0f       	add	r24, r24
    6f00:	97 fb       	bst	r25, 7
    6f02:	99 1f       	adc	r25, r25
    6f04:	61 f0       	breq	.+24     	; 0x6f1e <__fp_splitA+0x20>
    6f06:	9f 3f       	cpi	r25, 0xFF	; 255
    6f08:	79 f0       	breq	.+30     	; 0x6f28 <__fp_splitA+0x2a>
    6f0a:	87 95       	ror	r24
    6f0c:	08 95       	ret
    6f0e:	12 16       	cp	r1, r18
    6f10:	13 06       	cpc	r1, r19
    6f12:	14 06       	cpc	r1, r20
    6f14:	55 1f       	adc	r21, r21
    6f16:	f2 cf       	rjmp	.-28     	; 0x6efc <__fp_split3+0xe>
    6f18:	46 95       	lsr	r20
    6f1a:	f1 df       	rcall	.-30     	; 0x6efe <__fp_splitA>
    6f1c:	08 c0       	rjmp	.+16     	; 0x6f2e <__fp_splitA+0x30>
    6f1e:	16 16       	cp	r1, r22
    6f20:	17 06       	cpc	r1, r23
    6f22:	18 06       	cpc	r1, r24
    6f24:	99 1f       	adc	r25, r25
    6f26:	f1 cf       	rjmp	.-30     	; 0x6f0a <__fp_splitA+0xc>
    6f28:	86 95       	lsr	r24
    6f2a:	71 05       	cpc	r23, r1
    6f2c:	61 05       	cpc	r22, r1
    6f2e:	08 94       	sec
    6f30:	08 95       	ret

00006f32 <__fp_zero>:
    6f32:	e8 94       	clt

00006f34 <__fp_szero>:
    6f34:	bb 27       	eor	r27, r27
    6f36:	66 27       	eor	r22, r22
    6f38:	77 27       	eor	r23, r23
    6f3a:	cb 01       	movw	r24, r22
    6f3c:	97 f9       	bld	r25, 7
    6f3e:	08 95       	ret

00006f40 <__gesf2>:
    6f40:	03 d0       	rcall	.+6      	; 0x6f48 <__fp_cmp>
    6f42:	08 f4       	brcc	.+2      	; 0x6f46 <__gesf2+0x6>
    6f44:	8f ef       	ldi	r24, 0xFF	; 255
    6f46:	08 95       	ret

00006f48 <__fp_cmp>:
    6f48:	99 0f       	add	r25, r25
    6f4a:	00 08       	sbc	r0, r0
    6f4c:	55 0f       	add	r21, r21
    6f4e:	aa 0b       	sbc	r26, r26
    6f50:	e0 e8       	ldi	r30, 0x80	; 128
    6f52:	fe ef       	ldi	r31, 0xFE	; 254
    6f54:	16 16       	cp	r1, r22
    6f56:	17 06       	cpc	r1, r23
    6f58:	e8 07       	cpc	r30, r24
    6f5a:	f9 07       	cpc	r31, r25
    6f5c:	c0 f0       	brcs	.+48     	; 0x6f8e <__fp_cmp+0x46>
    6f5e:	12 16       	cp	r1, r18
    6f60:	13 06       	cpc	r1, r19
    6f62:	e4 07       	cpc	r30, r20
    6f64:	f5 07       	cpc	r31, r21
    6f66:	98 f0       	brcs	.+38     	; 0x6f8e <__fp_cmp+0x46>
    6f68:	62 1b       	sub	r22, r18
    6f6a:	73 0b       	sbc	r23, r19
    6f6c:	84 0b       	sbc	r24, r20
    6f6e:	95 0b       	sbc	r25, r21
    6f70:	39 f4       	brne	.+14     	; 0x6f80 <__fp_cmp+0x38>
    6f72:	0a 26       	eor	r0, r26
    6f74:	61 f0       	breq	.+24     	; 0x6f8e <__fp_cmp+0x46>
    6f76:	23 2b       	or	r18, r19
    6f78:	24 2b       	or	r18, r20
    6f7a:	25 2b       	or	r18, r21
    6f7c:	21 f4       	brne	.+8      	; 0x6f86 <__fp_cmp+0x3e>
    6f7e:	08 95       	ret
    6f80:	0a 26       	eor	r0, r26
    6f82:	09 f4       	brne	.+2      	; 0x6f86 <__fp_cmp+0x3e>
    6f84:	a1 40       	sbci	r26, 0x01	; 1
    6f86:	a6 95       	lsr	r26
    6f88:	8f ef       	ldi	r24, 0xFF	; 255
    6f8a:	81 1d       	adc	r24, r1
    6f8c:	81 1d       	adc	r24, r1
    6f8e:	08 95       	ret

00006f90 <__mulsi3>:
    6f90:	62 9f       	mul	r22, r18
    6f92:	d0 01       	movw	r26, r0
    6f94:	73 9f       	mul	r23, r19
    6f96:	f0 01       	movw	r30, r0
    6f98:	82 9f       	mul	r24, r18
    6f9a:	e0 0d       	add	r30, r0
    6f9c:	f1 1d       	adc	r31, r1
    6f9e:	64 9f       	mul	r22, r20
    6fa0:	e0 0d       	add	r30, r0
    6fa2:	f1 1d       	adc	r31, r1
    6fa4:	92 9f       	mul	r25, r18
    6fa6:	f0 0d       	add	r31, r0
    6fa8:	83 9f       	mul	r24, r19
    6faa:	f0 0d       	add	r31, r0
    6fac:	74 9f       	mul	r23, r20
    6fae:	f0 0d       	add	r31, r0
    6fb0:	65 9f       	mul	r22, r21
    6fb2:	f0 0d       	add	r31, r0
    6fb4:	99 27       	eor	r25, r25
    6fb6:	72 9f       	mul	r23, r18
    6fb8:	b0 0d       	add	r27, r0
    6fba:	e1 1d       	adc	r30, r1
    6fbc:	f9 1f       	adc	r31, r25
    6fbe:	63 9f       	mul	r22, r19
    6fc0:	b0 0d       	add	r27, r0
    6fc2:	e1 1d       	adc	r30, r1
    6fc4:	f9 1f       	adc	r31, r25
    6fc6:	bd 01       	movw	r22, r26
    6fc8:	cf 01       	movw	r24, r30
    6fca:	11 24       	eor	r1, r1
    6fcc:	08 95       	ret

00006fce <__udivmodhi4>:
    6fce:	aa 1b       	sub	r26, r26
    6fd0:	bb 1b       	sub	r27, r27
    6fd2:	51 e1       	ldi	r21, 0x11	; 17
    6fd4:	07 c0       	rjmp	.+14     	; 0x6fe4 <__udivmodhi4_ep>

00006fd6 <__udivmodhi4_loop>:
    6fd6:	aa 1f       	adc	r26, r26
    6fd8:	bb 1f       	adc	r27, r27
    6fda:	a6 17       	cp	r26, r22
    6fdc:	b7 07       	cpc	r27, r23
    6fde:	10 f0       	brcs	.+4      	; 0x6fe4 <__udivmodhi4_ep>
    6fe0:	a6 1b       	sub	r26, r22
    6fe2:	b7 0b       	sbc	r27, r23

00006fe4 <__udivmodhi4_ep>:
    6fe4:	88 1f       	adc	r24, r24
    6fe6:	99 1f       	adc	r25, r25
    6fe8:	5a 95       	dec	r21
    6fea:	a9 f7       	brne	.-22     	; 0x6fd6 <__udivmodhi4_loop>
    6fec:	80 95       	com	r24
    6fee:	90 95       	com	r25
    6ff0:	bc 01       	movw	r22, r24
    6ff2:	cd 01       	movw	r24, r26
    6ff4:	08 95       	ret

00006ff6 <__divmodhi4>:
    6ff6:	97 fb       	bst	r25, 7
    6ff8:	09 2e       	mov	r0, r25
    6ffa:	07 26       	eor	r0, r23
    6ffc:	0a d0       	rcall	.+20     	; 0x7012 <__divmodhi4_neg1>
    6ffe:	77 fd       	sbrc	r23, 7
    7000:	04 d0       	rcall	.+8      	; 0x700a <__divmodhi4_neg2>
    7002:	e5 df       	rcall	.-54     	; 0x6fce <__udivmodhi4>
    7004:	06 d0       	rcall	.+12     	; 0x7012 <__divmodhi4_neg1>
    7006:	00 20       	and	r0, r0
    7008:	1a f4       	brpl	.+6      	; 0x7010 <__divmodhi4_exit>

0000700a <__divmodhi4_neg2>:
    700a:	70 95       	com	r23
    700c:	61 95       	neg	r22
    700e:	7f 4f       	sbci	r23, 0xFF	; 255

00007010 <__divmodhi4_exit>:
    7010:	08 95       	ret

00007012 <__divmodhi4_neg1>:
    7012:	f6 f7       	brtc	.-4      	; 0x7010 <__divmodhi4_exit>
    7014:	90 95       	com	r25
    7016:	81 95       	neg	r24
    7018:	9f 4f       	sbci	r25, 0xFF	; 255
    701a:	08 95       	ret

0000701c <__udivmodsi4>:
    701c:	a1 e2       	ldi	r26, 0x21	; 33
    701e:	1a 2e       	mov	r1, r26
    7020:	aa 1b       	sub	r26, r26
    7022:	bb 1b       	sub	r27, r27
    7024:	fd 01       	movw	r30, r26
    7026:	0d c0       	rjmp	.+26     	; 0x7042 <__udivmodsi4_ep>

00007028 <__udivmodsi4_loop>:
    7028:	aa 1f       	adc	r26, r26
    702a:	bb 1f       	adc	r27, r27
    702c:	ee 1f       	adc	r30, r30
    702e:	ff 1f       	adc	r31, r31
    7030:	a2 17       	cp	r26, r18
    7032:	b3 07       	cpc	r27, r19
    7034:	e4 07       	cpc	r30, r20
    7036:	f5 07       	cpc	r31, r21
    7038:	20 f0       	brcs	.+8      	; 0x7042 <__udivmodsi4_ep>
    703a:	a2 1b       	sub	r26, r18
    703c:	b3 0b       	sbc	r27, r19
    703e:	e4 0b       	sbc	r30, r20
    7040:	f5 0b       	sbc	r31, r21

00007042 <__udivmodsi4_ep>:
    7042:	66 1f       	adc	r22, r22
    7044:	77 1f       	adc	r23, r23
    7046:	88 1f       	adc	r24, r24
    7048:	99 1f       	adc	r25, r25
    704a:	1a 94       	dec	r1
    704c:	69 f7       	brne	.-38     	; 0x7028 <__udivmodsi4_loop>
    704e:	60 95       	com	r22
    7050:	70 95       	com	r23
    7052:	80 95       	com	r24
    7054:	90 95       	com	r25
    7056:	9b 01       	movw	r18, r22
    7058:	ac 01       	movw	r20, r24
    705a:	bd 01       	movw	r22, r26
    705c:	cf 01       	movw	r24, r30
    705e:	08 95       	ret

00007060 <__divmodsi4>:
    7060:	97 fb       	bst	r25, 7
    7062:	09 2e       	mov	r0, r25
    7064:	05 26       	eor	r0, r21
    7066:	0e d0       	rcall	.+28     	; 0x7084 <__divmodsi4_neg1>
    7068:	57 fd       	sbrc	r21, 7
    706a:	04 d0       	rcall	.+8      	; 0x7074 <__divmodsi4_neg2>
    706c:	d7 df       	rcall	.-82     	; 0x701c <__udivmodsi4>
    706e:	0a d0       	rcall	.+20     	; 0x7084 <__divmodsi4_neg1>
    7070:	00 1c       	adc	r0, r0
    7072:	38 f4       	brcc	.+14     	; 0x7082 <__divmodsi4_exit>

00007074 <__divmodsi4_neg2>:
    7074:	50 95       	com	r21
    7076:	40 95       	com	r20
    7078:	30 95       	com	r19
    707a:	21 95       	neg	r18
    707c:	3f 4f       	sbci	r19, 0xFF	; 255
    707e:	4f 4f       	sbci	r20, 0xFF	; 255
    7080:	5f 4f       	sbci	r21, 0xFF	; 255

00007082 <__divmodsi4_exit>:
    7082:	08 95       	ret

00007084 <__divmodsi4_neg1>:
    7084:	f6 f7       	brtc	.-4      	; 0x7082 <__divmodsi4_exit>
    7086:	90 95       	com	r25
    7088:	80 95       	com	r24
    708a:	70 95       	com	r23
    708c:	61 95       	neg	r22
    708e:	7f 4f       	sbci	r23, 0xFF	; 255
    7090:	8f 4f       	sbci	r24, 0xFF	; 255
    7092:	9f 4f       	sbci	r25, 0xFF	; 255
    7094:	08 95       	ret

00007096 <__prologue_saves__>:
    7096:	2f 92       	push	r2
    7098:	3f 92       	push	r3
    709a:	4f 92       	push	r4
    709c:	5f 92       	push	r5
    709e:	6f 92       	push	r6
    70a0:	7f 92       	push	r7
    70a2:	8f 92       	push	r8
    70a4:	9f 92       	push	r9
    70a6:	af 92       	push	r10
    70a8:	bf 92       	push	r11
    70aa:	cf 92       	push	r12
    70ac:	df 92       	push	r13
    70ae:	ef 92       	push	r14
    70b0:	ff 92       	push	r15
    70b2:	0f 93       	push	r16
    70b4:	1f 93       	push	r17
    70b6:	cf 93       	push	r28
    70b8:	df 93       	push	r29
    70ba:	cd b7       	in	r28, 0x3d	; 61
    70bc:	de b7       	in	r29, 0x3e	; 62
    70be:	ca 1b       	sub	r28, r26
    70c0:	db 0b       	sbc	r29, r27
    70c2:	cd bf       	out	0x3d, r28	; 61
    70c4:	de bf       	out	0x3e, r29	; 62
    70c6:	19 94       	eijmp

000070c8 <__epilogue_restores__>:
    70c8:	2a 88       	ldd	r2, Y+18	; 0x12
    70ca:	39 88       	ldd	r3, Y+17	; 0x11
    70cc:	48 88       	ldd	r4, Y+16	; 0x10
    70ce:	5f 84       	ldd	r5, Y+15	; 0x0f
    70d0:	6e 84       	ldd	r6, Y+14	; 0x0e
    70d2:	7d 84       	ldd	r7, Y+13	; 0x0d
    70d4:	8c 84       	ldd	r8, Y+12	; 0x0c
    70d6:	9b 84       	ldd	r9, Y+11	; 0x0b
    70d8:	aa 84       	ldd	r10, Y+10	; 0x0a
    70da:	b9 84       	ldd	r11, Y+9	; 0x09
    70dc:	c8 84       	ldd	r12, Y+8	; 0x08
    70de:	df 80       	ldd	r13, Y+7	; 0x07
    70e0:	ee 80       	ldd	r14, Y+6	; 0x06
    70e2:	fd 80       	ldd	r15, Y+5	; 0x05
    70e4:	0c 81       	ldd	r16, Y+4	; 0x04
    70e6:	1b 81       	ldd	r17, Y+3	; 0x03
    70e8:	aa 81       	ldd	r26, Y+2	; 0x02
    70ea:	b9 81       	ldd	r27, Y+1	; 0x01
    70ec:	ce 0f       	add	r28, r30
    70ee:	d1 1d       	adc	r29, r1
    70f0:	cd bf       	out	0x3d, r28	; 61
    70f2:	de bf       	out	0x3e, r29	; 62
    70f4:	ed 01       	movw	r28, r26
    70f6:	08 95       	ret

000070f8 <strcpy_P>:
    70f8:	fb 01       	movw	r30, r22
    70fa:	dc 01       	movw	r26, r24
    70fc:	05 90       	lpm	r0, Z+
    70fe:	0d 92       	st	X+, r0
    7100:	00 20       	and	r0, r0
    7102:	e1 f7       	brne	.-8      	; 0x70fc <strcpy_P+0x4>
    7104:	08 95       	ret

00007106 <memmove>:
    7106:	68 17       	cp	r22, r24
    7108:	79 07       	cpc	r23, r25
    710a:	68 f4       	brcc	.+26     	; 0x7126 <memmove+0x20>
    710c:	fb 01       	movw	r30, r22
    710e:	dc 01       	movw	r26, r24
    7110:	e4 0f       	add	r30, r20
    7112:	f5 1f       	adc	r31, r21
    7114:	a4 0f       	add	r26, r20
    7116:	b5 1f       	adc	r27, r21
    7118:	02 c0       	rjmp	.+4      	; 0x711e <memmove+0x18>
    711a:	02 90       	ld	r0, -Z
    711c:	0e 92       	st	-X, r0
    711e:	41 50       	subi	r20, 0x01	; 1
    7120:	50 40       	sbci	r21, 0x00	; 0
    7122:	d8 f7       	brcc	.-10     	; 0x711a <memmove+0x14>
    7124:	08 95       	ret
    7126:	0c 94 16 3b 	jmp	0x762c	; 0x762c <memcpy>

0000712a <strcat>:
    712a:	fb 01       	movw	r30, r22
    712c:	dc 01       	movw	r26, r24
    712e:	0d 90       	ld	r0, X+
    7130:	00 20       	and	r0, r0
    7132:	e9 f7       	brne	.-6      	; 0x712e <strcat+0x4>
    7134:	11 97       	sbiw	r26, 0x01	; 1
    7136:	01 90       	ld	r0, Z+
    7138:	0d 92       	st	X+, r0
    713a:	00 20       	and	r0, r0
    713c:	e1 f7       	brne	.-8      	; 0x7136 <strcat+0xc>
    713e:	08 95       	ret

00007140 <strncmp>:
    7140:	fb 01       	movw	r30, r22
    7142:	dc 01       	movw	r26, r24
    7144:	41 50       	subi	r20, 0x01	; 1
    7146:	50 40       	sbci	r21, 0x00	; 0
    7148:	30 f0       	brcs	.+12     	; 0x7156 <strncmp+0x16>
    714a:	8d 91       	ld	r24, X+
    714c:	01 90       	ld	r0, Z+
    714e:	80 19       	sub	r24, r0
    7150:	19 f4       	brne	.+6      	; 0x7158 <strncmp+0x18>
    7152:	00 20       	and	r0, r0
    7154:	b9 f7       	brne	.-18     	; 0x7144 <strncmp+0x4>
    7156:	88 1b       	sub	r24, r24
    7158:	99 0b       	sbc	r25, r25
    715a:	08 95       	ret

0000715c <itoa>:
    715c:	fb 01       	movw	r30, r22
    715e:	9f 01       	movw	r18, r30
    7160:	e8 94       	clt
    7162:	42 30       	cpi	r20, 0x02	; 2
    7164:	c4 f0       	brlt	.+48     	; 0x7196 <itoa+0x3a>
    7166:	45 32       	cpi	r20, 0x25	; 37
    7168:	b4 f4       	brge	.+44     	; 0x7196 <itoa+0x3a>
    716a:	4a 30       	cpi	r20, 0x0A	; 10
    716c:	29 f4       	brne	.+10     	; 0x7178 <itoa+0x1c>
    716e:	97 fb       	bst	r25, 7
    7170:	1e f4       	brtc	.+6      	; 0x7178 <itoa+0x1c>
    7172:	90 95       	com	r25
    7174:	81 95       	neg	r24
    7176:	9f 4f       	sbci	r25, 0xFF	; 255
    7178:	64 2f       	mov	r22, r20
    717a:	77 27       	eor	r23, r23
    717c:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__udivmodhi4>
    7180:	80 5d       	subi	r24, 0xD0	; 208
    7182:	8a 33       	cpi	r24, 0x3A	; 58
    7184:	0c f0       	brlt	.+2      	; 0x7188 <itoa+0x2c>
    7186:	89 5d       	subi	r24, 0xD9	; 217
    7188:	81 93       	st	Z+, r24
    718a:	cb 01       	movw	r24, r22
    718c:	00 97       	sbiw	r24, 0x00	; 0
    718e:	a1 f7       	brne	.-24     	; 0x7178 <itoa+0x1c>
    7190:	16 f4       	brtc	.+4      	; 0x7196 <itoa+0x3a>
    7192:	5d e2       	ldi	r21, 0x2D	; 45
    7194:	51 93       	st	Z+, r21
    7196:	10 82       	st	Z, r1
    7198:	c9 01       	movw	r24, r18
    719a:	0c 94 2a 3b 	jmp	0x7654	; 0x7654 <strrev>

0000719e <printf>:
    719e:	cf 93       	push	r28
    71a0:	df 93       	push	r29
    71a2:	cd b7       	in	r28, 0x3d	; 61
    71a4:	de b7       	in	r29, 0x3e	; 62
    71a6:	fe 01       	movw	r30, r28
    71a8:	36 96       	adiw	r30, 0x06	; 6
    71aa:	61 91       	ld	r22, Z+
    71ac:	71 91       	ld	r23, Z+
    71ae:	80 91 e1 50 	lds	r24, 0x50E1
    71b2:	90 91 e2 50 	lds	r25, 0x50E2
    71b6:	af 01       	movw	r20, r30
    71b8:	0e 94 0a 39 	call	0x7214	; 0x7214 <vfprintf>
    71bc:	df 91       	pop	r29
    71be:	cf 91       	pop	r28
    71c0:	08 95       	ret

000071c2 <sprintf>:
    71c2:	0f 93       	push	r16
    71c4:	1f 93       	push	r17
    71c6:	cf 93       	push	r28
    71c8:	df 93       	push	r29
    71ca:	cd b7       	in	r28, 0x3d	; 61
    71cc:	de b7       	in	r29, 0x3e	; 62
    71ce:	2e 97       	sbiw	r28, 0x0e	; 14
    71d0:	cd bf       	out	0x3d, r28	; 61
    71d2:	de bf       	out	0x3e, r29	; 62
    71d4:	0e 89       	ldd	r16, Y+22	; 0x16
    71d6:	1f 89       	ldd	r17, Y+23	; 0x17
    71d8:	86 e0       	ldi	r24, 0x06	; 6
    71da:	8c 83       	std	Y+4, r24	; 0x04
    71dc:	09 83       	std	Y+1, r16	; 0x01
    71de:	1a 83       	std	Y+2, r17	; 0x02
    71e0:	8f ef       	ldi	r24, 0xFF	; 255
    71e2:	9f e7       	ldi	r25, 0x7F	; 127
    71e4:	8d 83       	std	Y+5, r24	; 0x05
    71e6:	9e 83       	std	Y+6, r25	; 0x06
    71e8:	ae 01       	movw	r20, r28
    71ea:	46 5e       	subi	r20, 0xE6	; 230
    71ec:	5f 4f       	sbci	r21, 0xFF	; 255
    71ee:	ce 01       	movw	r24, r28
    71f0:	01 96       	adiw	r24, 0x01	; 1
    71f2:	68 8d       	ldd	r22, Y+24	; 0x18
    71f4:	79 8d       	ldd	r23, Y+25	; 0x19
    71f6:	0e 94 0a 39 	call	0x7214	; 0x7214 <vfprintf>
    71fa:	ef 81       	ldd	r30, Y+7	; 0x07
    71fc:	f8 85       	ldd	r31, Y+8	; 0x08
    71fe:	e0 0f       	add	r30, r16
    7200:	f1 1f       	adc	r31, r17
    7202:	10 82       	st	Z, r1
    7204:	2e 96       	adiw	r28, 0x0e	; 14
    7206:	cd bf       	out	0x3d, r28	; 61
    7208:	de bf       	out	0x3e, r29	; 62
    720a:	df 91       	pop	r29
    720c:	cf 91       	pop	r28
    720e:	1f 91       	pop	r17
    7210:	0f 91       	pop	r16
    7212:	08 95       	ret

00007214 <vfprintf>:
    7214:	2f 92       	push	r2
    7216:	3f 92       	push	r3
    7218:	4f 92       	push	r4
    721a:	5f 92       	push	r5
    721c:	6f 92       	push	r6
    721e:	7f 92       	push	r7
    7220:	8f 92       	push	r8
    7222:	9f 92       	push	r9
    7224:	af 92       	push	r10
    7226:	bf 92       	push	r11
    7228:	cf 92       	push	r12
    722a:	df 92       	push	r13
    722c:	ef 92       	push	r14
    722e:	ff 92       	push	r15
    7230:	0f 93       	push	r16
    7232:	1f 93       	push	r17
    7234:	cf 93       	push	r28
    7236:	df 93       	push	r29
    7238:	cd b7       	in	r28, 0x3d	; 61
    723a:	de b7       	in	r29, 0x3e	; 62
    723c:	2d 97       	sbiw	r28, 0x0d	; 13
    723e:	cd bf       	out	0x3d, r28	; 61
    7240:	de bf       	out	0x3e, r29	; 62
    7242:	3c 01       	movw	r6, r24
    7244:	6c 87       	std	Y+12, r22	; 0x0c
    7246:	7d 87       	std	Y+13, r23	; 0x0d
    7248:	5a 01       	movw	r10, r20
    724a:	fc 01       	movw	r30, r24
    724c:	16 82       	std	Z+6, r1	; 0x06
    724e:	17 82       	std	Z+7, r1	; 0x07
    7250:	83 81       	ldd	r24, Z+3	; 0x03
    7252:	81 ff       	sbrs	r24, 1
    7254:	c8 c1       	rjmp	.+912    	; 0x75e6 <vfprintf+0x3d2>
    7256:	2e 01       	movw	r4, r28
    7258:	08 94       	sec
    725a:	41 1c       	adc	r4, r1
    725c:	51 1c       	adc	r5, r1
    725e:	f3 01       	movw	r30, r6
    7260:	93 81       	ldd	r25, Z+3	; 0x03
    7262:	ec 85       	ldd	r30, Y+12	; 0x0c
    7264:	fd 85       	ldd	r31, Y+13	; 0x0d
    7266:	93 fd       	sbrc	r25, 3
    7268:	85 91       	lpm	r24, Z+
    726a:	93 ff       	sbrs	r25, 3
    726c:	81 91       	ld	r24, Z+
    726e:	ec 87       	std	Y+12, r30	; 0x0c
    7270:	fd 87       	std	Y+13, r31	; 0x0d
    7272:	88 23       	and	r24, r24
    7274:	09 f4       	brne	.+2      	; 0x7278 <vfprintf+0x64>
    7276:	b3 c1       	rjmp	.+870    	; 0x75de <vfprintf+0x3ca>
    7278:	85 32       	cpi	r24, 0x25	; 37
    727a:	41 f4       	brne	.+16     	; 0x728c <vfprintf+0x78>
    727c:	93 fd       	sbrc	r25, 3
    727e:	85 91       	lpm	r24, Z+
    7280:	93 ff       	sbrs	r25, 3
    7282:	81 91       	ld	r24, Z+
    7284:	ec 87       	std	Y+12, r30	; 0x0c
    7286:	fd 87       	std	Y+13, r31	; 0x0d
    7288:	85 32       	cpi	r24, 0x25	; 37
    728a:	29 f4       	brne	.+10     	; 0x7296 <vfprintf+0x82>
    728c:	90 e0       	ldi	r25, 0x00	; 0
    728e:	b3 01       	movw	r22, r6
    7290:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    7294:	e4 cf       	rjmp	.-56     	; 0x725e <vfprintf+0x4a>
    7296:	ff 24       	eor	r15, r15
    7298:	ee 24       	eor	r14, r14
    729a:	10 e0       	ldi	r17, 0x00	; 0
    729c:	10 32       	cpi	r17, 0x20	; 32
    729e:	b0 f4       	brcc	.+44     	; 0x72cc <vfprintf+0xb8>
    72a0:	8b 32       	cpi	r24, 0x2B	; 43
    72a2:	69 f0       	breq	.+26     	; 0x72be <vfprintf+0xaa>
    72a4:	8c 32       	cpi	r24, 0x2C	; 44
    72a6:	28 f4       	brcc	.+10     	; 0x72b2 <vfprintf+0x9e>
    72a8:	80 32       	cpi	r24, 0x20	; 32
    72aa:	51 f0       	breq	.+20     	; 0x72c0 <vfprintf+0xac>
    72ac:	83 32       	cpi	r24, 0x23	; 35
    72ae:	71 f4       	brne	.+28     	; 0x72cc <vfprintf+0xb8>
    72b0:	0b c0       	rjmp	.+22     	; 0x72c8 <vfprintf+0xb4>
    72b2:	8d 32       	cpi	r24, 0x2D	; 45
    72b4:	39 f0       	breq	.+14     	; 0x72c4 <vfprintf+0xb0>
    72b6:	80 33       	cpi	r24, 0x30	; 48
    72b8:	49 f4       	brne	.+18     	; 0x72cc <vfprintf+0xb8>
    72ba:	11 60       	ori	r17, 0x01	; 1
    72bc:	2c c0       	rjmp	.+88     	; 0x7316 <vfprintf+0x102>
    72be:	12 60       	ori	r17, 0x02	; 2
    72c0:	14 60       	ori	r17, 0x04	; 4
    72c2:	29 c0       	rjmp	.+82     	; 0x7316 <vfprintf+0x102>
    72c4:	18 60       	ori	r17, 0x08	; 8
    72c6:	27 c0       	rjmp	.+78     	; 0x7316 <vfprintf+0x102>
    72c8:	10 61       	ori	r17, 0x10	; 16
    72ca:	25 c0       	rjmp	.+74     	; 0x7316 <vfprintf+0x102>
    72cc:	17 fd       	sbrc	r17, 7
    72ce:	2e c0       	rjmp	.+92     	; 0x732c <vfprintf+0x118>
    72d0:	28 2f       	mov	r18, r24
    72d2:	20 53       	subi	r18, 0x30	; 48
    72d4:	2a 30       	cpi	r18, 0x0A	; 10
    72d6:	98 f4       	brcc	.+38     	; 0x72fe <vfprintf+0xea>
    72d8:	16 ff       	sbrs	r17, 6
    72da:	08 c0       	rjmp	.+16     	; 0x72ec <vfprintf+0xd8>
    72dc:	8f 2d       	mov	r24, r15
    72de:	88 0f       	add	r24, r24
    72e0:	f8 2e       	mov	r15, r24
    72e2:	ff 0c       	add	r15, r15
    72e4:	ff 0c       	add	r15, r15
    72e6:	f8 0e       	add	r15, r24
    72e8:	f2 0e       	add	r15, r18
    72ea:	15 c0       	rjmp	.+42     	; 0x7316 <vfprintf+0x102>
    72ec:	8e 2d       	mov	r24, r14
    72ee:	88 0f       	add	r24, r24
    72f0:	e8 2e       	mov	r14, r24
    72f2:	ee 0c       	add	r14, r14
    72f4:	ee 0c       	add	r14, r14
    72f6:	e8 0e       	add	r14, r24
    72f8:	e2 0e       	add	r14, r18
    72fa:	10 62       	ori	r17, 0x20	; 32
    72fc:	0c c0       	rjmp	.+24     	; 0x7316 <vfprintf+0x102>
    72fe:	8e 32       	cpi	r24, 0x2E	; 46
    7300:	21 f4       	brne	.+8      	; 0x730a <vfprintf+0xf6>
    7302:	16 fd       	sbrc	r17, 6
    7304:	6c c1       	rjmp	.+728    	; 0x75de <vfprintf+0x3ca>
    7306:	10 64       	ori	r17, 0x40	; 64
    7308:	06 c0       	rjmp	.+12     	; 0x7316 <vfprintf+0x102>
    730a:	8c 36       	cpi	r24, 0x6C	; 108
    730c:	11 f4       	brne	.+4      	; 0x7312 <vfprintf+0xfe>
    730e:	10 68       	ori	r17, 0x80	; 128
    7310:	02 c0       	rjmp	.+4      	; 0x7316 <vfprintf+0x102>
    7312:	88 36       	cpi	r24, 0x68	; 104
    7314:	59 f4       	brne	.+22     	; 0x732c <vfprintf+0x118>
    7316:	ec 85       	ldd	r30, Y+12	; 0x0c
    7318:	fd 85       	ldd	r31, Y+13	; 0x0d
    731a:	93 fd       	sbrc	r25, 3
    731c:	85 91       	lpm	r24, Z+
    731e:	93 ff       	sbrs	r25, 3
    7320:	81 91       	ld	r24, Z+
    7322:	ec 87       	std	Y+12, r30	; 0x0c
    7324:	fd 87       	std	Y+13, r31	; 0x0d
    7326:	88 23       	and	r24, r24
    7328:	09 f0       	breq	.+2      	; 0x732c <vfprintf+0x118>
    732a:	b8 cf       	rjmp	.-144    	; 0x729c <vfprintf+0x88>
    732c:	98 2f       	mov	r25, r24
    732e:	95 54       	subi	r25, 0x45	; 69
    7330:	93 30       	cpi	r25, 0x03	; 3
    7332:	18 f0       	brcs	.+6      	; 0x733a <vfprintf+0x126>
    7334:	90 52       	subi	r25, 0x20	; 32
    7336:	93 30       	cpi	r25, 0x03	; 3
    7338:	38 f4       	brcc	.+14     	; 0x7348 <vfprintf+0x134>
    733a:	24 e0       	ldi	r18, 0x04	; 4
    733c:	30 e0       	ldi	r19, 0x00	; 0
    733e:	a2 0e       	add	r10, r18
    7340:	b3 1e       	adc	r11, r19
    7342:	3f e3       	ldi	r19, 0x3F	; 63
    7344:	39 83       	std	Y+1, r19	; 0x01
    7346:	0f c0       	rjmp	.+30     	; 0x7366 <vfprintf+0x152>
    7348:	83 36       	cpi	r24, 0x63	; 99
    734a:	31 f0       	breq	.+12     	; 0x7358 <vfprintf+0x144>
    734c:	83 37       	cpi	r24, 0x73	; 115
    734e:	81 f0       	breq	.+32     	; 0x7370 <vfprintf+0x15c>
    7350:	83 35       	cpi	r24, 0x53	; 83
    7352:	09 f0       	breq	.+2      	; 0x7356 <vfprintf+0x142>
    7354:	5a c0       	rjmp	.+180    	; 0x740a <vfprintf+0x1f6>
    7356:	22 c0       	rjmp	.+68     	; 0x739c <vfprintf+0x188>
    7358:	f5 01       	movw	r30, r10
    735a:	80 81       	ld	r24, Z
    735c:	89 83       	std	Y+1, r24	; 0x01
    735e:	22 e0       	ldi	r18, 0x02	; 2
    7360:	30 e0       	ldi	r19, 0x00	; 0
    7362:	a2 0e       	add	r10, r18
    7364:	b3 1e       	adc	r11, r19
    7366:	21 e0       	ldi	r18, 0x01	; 1
    7368:	c2 2e       	mov	r12, r18
    736a:	d1 2c       	mov	r13, r1
    736c:	42 01       	movw	r8, r4
    736e:	14 c0       	rjmp	.+40     	; 0x7398 <vfprintf+0x184>
    7370:	92 e0       	ldi	r25, 0x02	; 2
    7372:	29 2e       	mov	r2, r25
    7374:	31 2c       	mov	r3, r1
    7376:	2a 0c       	add	r2, r10
    7378:	3b 1c       	adc	r3, r11
    737a:	f5 01       	movw	r30, r10
    737c:	80 80       	ld	r8, Z
    737e:	91 80       	ldd	r9, Z+1	; 0x01
    7380:	16 ff       	sbrs	r17, 6
    7382:	03 c0       	rjmp	.+6      	; 0x738a <vfprintf+0x176>
    7384:	6f 2d       	mov	r22, r15
    7386:	70 e0       	ldi	r23, 0x00	; 0
    7388:	02 c0       	rjmp	.+4      	; 0x738e <vfprintf+0x17a>
    738a:	6f ef       	ldi	r22, 0xFF	; 255
    738c:	7f ef       	ldi	r23, 0xFF	; 255
    738e:	c4 01       	movw	r24, r8
    7390:	0e 94 1f 3b 	call	0x763e	; 0x763e <strnlen>
    7394:	6c 01       	movw	r12, r24
    7396:	51 01       	movw	r10, r2
    7398:	1f 77       	andi	r17, 0x7F	; 127
    739a:	15 c0       	rjmp	.+42     	; 0x73c6 <vfprintf+0x1b2>
    739c:	82 e0       	ldi	r24, 0x02	; 2
    739e:	28 2e       	mov	r2, r24
    73a0:	31 2c       	mov	r3, r1
    73a2:	2a 0c       	add	r2, r10
    73a4:	3b 1c       	adc	r3, r11
    73a6:	f5 01       	movw	r30, r10
    73a8:	80 80       	ld	r8, Z
    73aa:	91 80       	ldd	r9, Z+1	; 0x01
    73ac:	16 ff       	sbrs	r17, 6
    73ae:	03 c0       	rjmp	.+6      	; 0x73b6 <vfprintf+0x1a2>
    73b0:	6f 2d       	mov	r22, r15
    73b2:	70 e0       	ldi	r23, 0x00	; 0
    73b4:	02 c0       	rjmp	.+4      	; 0x73ba <vfprintf+0x1a6>
    73b6:	6f ef       	ldi	r22, 0xFF	; 255
    73b8:	7f ef       	ldi	r23, 0xFF	; 255
    73ba:	c4 01       	movw	r24, r8
    73bc:	0e 94 0b 3b 	call	0x7616	; 0x7616 <strnlen_P>
    73c0:	6c 01       	movw	r12, r24
    73c2:	10 68       	ori	r17, 0x80	; 128
    73c4:	51 01       	movw	r10, r2
    73c6:	13 fd       	sbrc	r17, 3
    73c8:	1c c0       	rjmp	.+56     	; 0x7402 <vfprintf+0x1ee>
    73ca:	06 c0       	rjmp	.+12     	; 0x73d8 <vfprintf+0x1c4>
    73cc:	80 e2       	ldi	r24, 0x20	; 32
    73ce:	90 e0       	ldi	r25, 0x00	; 0
    73d0:	b3 01       	movw	r22, r6
    73d2:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    73d6:	ea 94       	dec	r14
    73d8:	8e 2d       	mov	r24, r14
    73da:	90 e0       	ldi	r25, 0x00	; 0
    73dc:	c8 16       	cp	r12, r24
    73de:	d9 06       	cpc	r13, r25
    73e0:	a8 f3       	brcs	.-22     	; 0x73cc <vfprintf+0x1b8>
    73e2:	0f c0       	rjmp	.+30     	; 0x7402 <vfprintf+0x1ee>
    73e4:	f4 01       	movw	r30, r8
    73e6:	17 fd       	sbrc	r17, 7
    73e8:	85 91       	lpm	r24, Z+
    73ea:	17 ff       	sbrs	r17, 7
    73ec:	81 91       	ld	r24, Z+
    73ee:	4f 01       	movw	r8, r30
    73f0:	90 e0       	ldi	r25, 0x00	; 0
    73f2:	b3 01       	movw	r22, r6
    73f4:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    73f8:	e1 10       	cpse	r14, r1
    73fa:	ea 94       	dec	r14
    73fc:	08 94       	sec
    73fe:	c1 08       	sbc	r12, r1
    7400:	d1 08       	sbc	r13, r1
    7402:	c1 14       	cp	r12, r1
    7404:	d1 04       	cpc	r13, r1
    7406:	71 f7       	brne	.-36     	; 0x73e4 <vfprintf+0x1d0>
    7408:	e7 c0       	rjmp	.+462    	; 0x75d8 <vfprintf+0x3c4>
    740a:	84 36       	cpi	r24, 0x64	; 100
    740c:	11 f0       	breq	.+4      	; 0x7412 <vfprintf+0x1fe>
    740e:	89 36       	cpi	r24, 0x69	; 105
    7410:	51 f5       	brne	.+84     	; 0x7466 <vfprintf+0x252>
    7412:	f5 01       	movw	r30, r10
    7414:	17 ff       	sbrs	r17, 7
    7416:	07 c0       	rjmp	.+14     	; 0x7426 <vfprintf+0x212>
    7418:	80 81       	ld	r24, Z
    741a:	91 81       	ldd	r25, Z+1	; 0x01
    741c:	a2 81       	ldd	r26, Z+2	; 0x02
    741e:	b3 81       	ldd	r27, Z+3	; 0x03
    7420:	24 e0       	ldi	r18, 0x04	; 4
    7422:	30 e0       	ldi	r19, 0x00	; 0
    7424:	08 c0       	rjmp	.+16     	; 0x7436 <vfprintf+0x222>
    7426:	80 81       	ld	r24, Z
    7428:	91 81       	ldd	r25, Z+1	; 0x01
    742a:	aa 27       	eor	r26, r26
    742c:	97 fd       	sbrc	r25, 7
    742e:	a0 95       	com	r26
    7430:	ba 2f       	mov	r27, r26
    7432:	22 e0       	ldi	r18, 0x02	; 2
    7434:	30 e0       	ldi	r19, 0x00	; 0
    7436:	a2 0e       	add	r10, r18
    7438:	b3 1e       	adc	r11, r19
    743a:	01 2f       	mov	r16, r17
    743c:	0f 76       	andi	r16, 0x6F	; 111
    743e:	b7 ff       	sbrs	r27, 7
    7440:	08 c0       	rjmp	.+16     	; 0x7452 <vfprintf+0x23e>
    7442:	b0 95       	com	r27
    7444:	a0 95       	com	r26
    7446:	90 95       	com	r25
    7448:	81 95       	neg	r24
    744a:	9f 4f       	sbci	r25, 0xFF	; 255
    744c:	af 4f       	sbci	r26, 0xFF	; 255
    744e:	bf 4f       	sbci	r27, 0xFF	; 255
    7450:	00 68       	ori	r16, 0x80	; 128
    7452:	bc 01       	movw	r22, r24
    7454:	cd 01       	movw	r24, r26
    7456:	a2 01       	movw	r20, r4
    7458:	2a e0       	ldi	r18, 0x0A	; 10
    745a:	30 e0       	ldi	r19, 0x00	; 0
    745c:	0e 94 66 3b 	call	0x76cc	; 0x76cc <__ultoa_invert>
    7460:	d8 2e       	mov	r13, r24
    7462:	d4 18       	sub	r13, r4
    7464:	3f c0       	rjmp	.+126    	; 0x74e4 <vfprintf+0x2d0>
    7466:	85 37       	cpi	r24, 0x75	; 117
    7468:	21 f4       	brne	.+8      	; 0x7472 <vfprintf+0x25e>
    746a:	1f 7e       	andi	r17, 0xEF	; 239
    746c:	2a e0       	ldi	r18, 0x0A	; 10
    746e:	30 e0       	ldi	r19, 0x00	; 0
    7470:	20 c0       	rjmp	.+64     	; 0x74b2 <vfprintf+0x29e>
    7472:	19 7f       	andi	r17, 0xF9	; 249
    7474:	8f 36       	cpi	r24, 0x6F	; 111
    7476:	a9 f0       	breq	.+42     	; 0x74a2 <vfprintf+0x28e>
    7478:	80 37       	cpi	r24, 0x70	; 112
    747a:	20 f4       	brcc	.+8      	; 0x7484 <vfprintf+0x270>
    747c:	88 35       	cpi	r24, 0x58	; 88
    747e:	09 f0       	breq	.+2      	; 0x7482 <vfprintf+0x26e>
    7480:	ae c0       	rjmp	.+348    	; 0x75de <vfprintf+0x3ca>
    7482:	0b c0       	rjmp	.+22     	; 0x749a <vfprintf+0x286>
    7484:	80 37       	cpi	r24, 0x70	; 112
    7486:	21 f0       	breq	.+8      	; 0x7490 <vfprintf+0x27c>
    7488:	88 37       	cpi	r24, 0x78	; 120
    748a:	09 f0       	breq	.+2      	; 0x748e <vfprintf+0x27a>
    748c:	a8 c0       	rjmp	.+336    	; 0x75de <vfprintf+0x3ca>
    748e:	01 c0       	rjmp	.+2      	; 0x7492 <vfprintf+0x27e>
    7490:	10 61       	ori	r17, 0x10	; 16
    7492:	14 ff       	sbrs	r17, 4
    7494:	09 c0       	rjmp	.+18     	; 0x74a8 <vfprintf+0x294>
    7496:	14 60       	ori	r17, 0x04	; 4
    7498:	07 c0       	rjmp	.+14     	; 0x74a8 <vfprintf+0x294>
    749a:	14 ff       	sbrs	r17, 4
    749c:	08 c0       	rjmp	.+16     	; 0x74ae <vfprintf+0x29a>
    749e:	16 60       	ori	r17, 0x06	; 6
    74a0:	06 c0       	rjmp	.+12     	; 0x74ae <vfprintf+0x29a>
    74a2:	28 e0       	ldi	r18, 0x08	; 8
    74a4:	30 e0       	ldi	r19, 0x00	; 0
    74a6:	05 c0       	rjmp	.+10     	; 0x74b2 <vfprintf+0x29e>
    74a8:	20 e1       	ldi	r18, 0x10	; 16
    74aa:	30 e0       	ldi	r19, 0x00	; 0
    74ac:	02 c0       	rjmp	.+4      	; 0x74b2 <vfprintf+0x29e>
    74ae:	20 e1       	ldi	r18, 0x10	; 16
    74b0:	32 e0       	ldi	r19, 0x02	; 2
    74b2:	f5 01       	movw	r30, r10
    74b4:	17 ff       	sbrs	r17, 7
    74b6:	07 c0       	rjmp	.+14     	; 0x74c6 <vfprintf+0x2b2>
    74b8:	60 81       	ld	r22, Z
    74ba:	71 81       	ldd	r23, Z+1	; 0x01
    74bc:	82 81       	ldd	r24, Z+2	; 0x02
    74be:	93 81       	ldd	r25, Z+3	; 0x03
    74c0:	44 e0       	ldi	r20, 0x04	; 4
    74c2:	50 e0       	ldi	r21, 0x00	; 0
    74c4:	06 c0       	rjmp	.+12     	; 0x74d2 <vfprintf+0x2be>
    74c6:	60 81       	ld	r22, Z
    74c8:	71 81       	ldd	r23, Z+1	; 0x01
    74ca:	80 e0       	ldi	r24, 0x00	; 0
    74cc:	90 e0       	ldi	r25, 0x00	; 0
    74ce:	42 e0       	ldi	r20, 0x02	; 2
    74d0:	50 e0       	ldi	r21, 0x00	; 0
    74d2:	a4 0e       	add	r10, r20
    74d4:	b5 1e       	adc	r11, r21
    74d6:	a2 01       	movw	r20, r4
    74d8:	0e 94 66 3b 	call	0x76cc	; 0x76cc <__ultoa_invert>
    74dc:	d8 2e       	mov	r13, r24
    74de:	d4 18       	sub	r13, r4
    74e0:	01 2f       	mov	r16, r17
    74e2:	0f 77       	andi	r16, 0x7F	; 127
    74e4:	06 ff       	sbrs	r16, 6
    74e6:	09 c0       	rjmp	.+18     	; 0x74fa <vfprintf+0x2e6>
    74e8:	0e 7f       	andi	r16, 0xFE	; 254
    74ea:	df 14       	cp	r13, r15
    74ec:	30 f4       	brcc	.+12     	; 0x74fa <vfprintf+0x2e6>
    74ee:	04 ff       	sbrs	r16, 4
    74f0:	06 c0       	rjmp	.+12     	; 0x74fe <vfprintf+0x2ea>
    74f2:	02 fd       	sbrc	r16, 2
    74f4:	04 c0       	rjmp	.+8      	; 0x74fe <vfprintf+0x2ea>
    74f6:	0f 7e       	andi	r16, 0xEF	; 239
    74f8:	02 c0       	rjmp	.+4      	; 0x74fe <vfprintf+0x2ea>
    74fa:	1d 2d       	mov	r17, r13
    74fc:	01 c0       	rjmp	.+2      	; 0x7500 <vfprintf+0x2ec>
    74fe:	1f 2d       	mov	r17, r15
    7500:	80 2f       	mov	r24, r16
    7502:	90 e0       	ldi	r25, 0x00	; 0
    7504:	04 ff       	sbrs	r16, 4
    7506:	0c c0       	rjmp	.+24     	; 0x7520 <vfprintf+0x30c>
    7508:	fe 01       	movw	r30, r28
    750a:	ed 0d       	add	r30, r13
    750c:	f1 1d       	adc	r31, r1
    750e:	20 81       	ld	r18, Z
    7510:	20 33       	cpi	r18, 0x30	; 48
    7512:	11 f4       	brne	.+4      	; 0x7518 <vfprintf+0x304>
    7514:	09 7e       	andi	r16, 0xE9	; 233
    7516:	09 c0       	rjmp	.+18     	; 0x752a <vfprintf+0x316>
    7518:	02 ff       	sbrs	r16, 2
    751a:	06 c0       	rjmp	.+12     	; 0x7528 <vfprintf+0x314>
    751c:	1e 5f       	subi	r17, 0xFE	; 254
    751e:	05 c0       	rjmp	.+10     	; 0x752a <vfprintf+0x316>
    7520:	86 78       	andi	r24, 0x86	; 134
    7522:	90 70       	andi	r25, 0x00	; 0
    7524:	00 97       	sbiw	r24, 0x00	; 0
    7526:	09 f0       	breq	.+2      	; 0x752a <vfprintf+0x316>
    7528:	1f 5f       	subi	r17, 0xFF	; 255
    752a:	80 2e       	mov	r8, r16
    752c:	99 24       	eor	r9, r9
    752e:	03 fd       	sbrc	r16, 3
    7530:	12 c0       	rjmp	.+36     	; 0x7556 <vfprintf+0x342>
    7532:	00 ff       	sbrs	r16, 0
    7534:	0d c0       	rjmp	.+26     	; 0x7550 <vfprintf+0x33c>
    7536:	fd 2c       	mov	r15, r13
    7538:	1e 15       	cp	r17, r14
    753a:	50 f4       	brcc	.+20     	; 0x7550 <vfprintf+0x33c>
    753c:	fe 0c       	add	r15, r14
    753e:	f1 1a       	sub	r15, r17
    7540:	1e 2d       	mov	r17, r14
    7542:	06 c0       	rjmp	.+12     	; 0x7550 <vfprintf+0x33c>
    7544:	80 e2       	ldi	r24, 0x20	; 32
    7546:	90 e0       	ldi	r25, 0x00	; 0
    7548:	b3 01       	movw	r22, r6
    754a:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    754e:	1f 5f       	subi	r17, 0xFF	; 255
    7550:	1e 15       	cp	r17, r14
    7552:	c0 f3       	brcs	.-16     	; 0x7544 <vfprintf+0x330>
    7554:	04 c0       	rjmp	.+8      	; 0x755e <vfprintf+0x34a>
    7556:	1e 15       	cp	r17, r14
    7558:	10 f4       	brcc	.+4      	; 0x755e <vfprintf+0x34a>
    755a:	e1 1a       	sub	r14, r17
    755c:	01 c0       	rjmp	.+2      	; 0x7560 <vfprintf+0x34c>
    755e:	ee 24       	eor	r14, r14
    7560:	84 fe       	sbrs	r8, 4
    7562:	0f c0       	rjmp	.+30     	; 0x7582 <vfprintf+0x36e>
    7564:	80 e3       	ldi	r24, 0x30	; 48
    7566:	90 e0       	ldi	r25, 0x00	; 0
    7568:	b3 01       	movw	r22, r6
    756a:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    756e:	82 fe       	sbrs	r8, 2
    7570:	1f c0       	rjmp	.+62     	; 0x75b0 <vfprintf+0x39c>
    7572:	81 fe       	sbrs	r8, 1
    7574:	03 c0       	rjmp	.+6      	; 0x757c <vfprintf+0x368>
    7576:	88 e5       	ldi	r24, 0x58	; 88
    7578:	90 e0       	ldi	r25, 0x00	; 0
    757a:	10 c0       	rjmp	.+32     	; 0x759c <vfprintf+0x388>
    757c:	88 e7       	ldi	r24, 0x78	; 120
    757e:	90 e0       	ldi	r25, 0x00	; 0
    7580:	0d c0       	rjmp	.+26     	; 0x759c <vfprintf+0x388>
    7582:	c4 01       	movw	r24, r8
    7584:	86 78       	andi	r24, 0x86	; 134
    7586:	90 70       	andi	r25, 0x00	; 0
    7588:	00 97       	sbiw	r24, 0x00	; 0
    758a:	91 f0       	breq	.+36     	; 0x75b0 <vfprintf+0x39c>
    758c:	81 fc       	sbrc	r8, 1
    758e:	02 c0       	rjmp	.+4      	; 0x7594 <vfprintf+0x380>
    7590:	80 e2       	ldi	r24, 0x20	; 32
    7592:	01 c0       	rjmp	.+2      	; 0x7596 <vfprintf+0x382>
    7594:	8b e2       	ldi	r24, 0x2B	; 43
    7596:	07 fd       	sbrc	r16, 7
    7598:	8d e2       	ldi	r24, 0x2D	; 45
    759a:	90 e0       	ldi	r25, 0x00	; 0
    759c:	b3 01       	movw	r22, r6
    759e:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    75a2:	06 c0       	rjmp	.+12     	; 0x75b0 <vfprintf+0x39c>
    75a4:	80 e3       	ldi	r24, 0x30	; 48
    75a6:	90 e0       	ldi	r25, 0x00	; 0
    75a8:	b3 01       	movw	r22, r6
    75aa:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    75ae:	fa 94       	dec	r15
    75b0:	df 14       	cp	r13, r15
    75b2:	c0 f3       	brcs	.-16     	; 0x75a4 <vfprintf+0x390>
    75b4:	da 94       	dec	r13
    75b6:	f2 01       	movw	r30, r4
    75b8:	ed 0d       	add	r30, r13
    75ba:	f1 1d       	adc	r31, r1
    75bc:	80 81       	ld	r24, Z
    75be:	90 e0       	ldi	r25, 0x00	; 0
    75c0:	b3 01       	movw	r22, r6
    75c2:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    75c6:	dd 20       	and	r13, r13
    75c8:	a9 f7       	brne	.-22     	; 0x75b4 <vfprintf+0x3a0>
    75ca:	06 c0       	rjmp	.+12     	; 0x75d8 <vfprintf+0x3c4>
    75cc:	80 e2       	ldi	r24, 0x20	; 32
    75ce:	90 e0       	ldi	r25, 0x00	; 0
    75d0:	b3 01       	movw	r22, r6
    75d2:	0e 94 3a 3b 	call	0x7674	; 0x7674 <fputc>
    75d6:	ea 94       	dec	r14
    75d8:	ee 20       	and	r14, r14
    75da:	c1 f7       	brne	.-16     	; 0x75cc <vfprintf+0x3b8>
    75dc:	40 ce       	rjmp	.-896    	; 0x725e <vfprintf+0x4a>
    75de:	f3 01       	movw	r30, r6
    75e0:	86 81       	ldd	r24, Z+6	; 0x06
    75e2:	97 81       	ldd	r25, Z+7	; 0x07
    75e4:	02 c0       	rjmp	.+4      	; 0x75ea <vfprintf+0x3d6>
    75e6:	8f ef       	ldi	r24, 0xFF	; 255
    75e8:	9f ef       	ldi	r25, 0xFF	; 255
    75ea:	2d 96       	adiw	r28, 0x0d	; 13
    75ec:	cd bf       	out	0x3d, r28	; 61
    75ee:	de bf       	out	0x3e, r29	; 62
    75f0:	df 91       	pop	r29
    75f2:	cf 91       	pop	r28
    75f4:	1f 91       	pop	r17
    75f6:	0f 91       	pop	r16
    75f8:	ff 90       	pop	r15
    75fa:	ef 90       	pop	r14
    75fc:	df 90       	pop	r13
    75fe:	cf 90       	pop	r12
    7600:	bf 90       	pop	r11
    7602:	af 90       	pop	r10
    7604:	9f 90       	pop	r9
    7606:	8f 90       	pop	r8
    7608:	7f 90       	pop	r7
    760a:	6f 90       	pop	r6
    760c:	5f 90       	pop	r5
    760e:	4f 90       	pop	r4
    7610:	3f 90       	pop	r3
    7612:	2f 90       	pop	r2
    7614:	08 95       	ret

00007616 <strnlen_P>:
    7616:	fc 01       	movw	r30, r24
    7618:	05 90       	lpm	r0, Z+
    761a:	61 50       	subi	r22, 0x01	; 1
    761c:	70 40       	sbci	r23, 0x00	; 0
    761e:	01 10       	cpse	r0, r1
    7620:	d8 f7       	brcc	.-10     	; 0x7618 <strnlen_P+0x2>
    7622:	80 95       	com	r24
    7624:	90 95       	com	r25
    7626:	8e 0f       	add	r24, r30
    7628:	9f 1f       	adc	r25, r31
    762a:	08 95       	ret

0000762c <memcpy>:
    762c:	fb 01       	movw	r30, r22
    762e:	dc 01       	movw	r26, r24
    7630:	02 c0       	rjmp	.+4      	; 0x7636 <memcpy+0xa>
    7632:	01 90       	ld	r0, Z+
    7634:	0d 92       	st	X+, r0
    7636:	41 50       	subi	r20, 0x01	; 1
    7638:	50 40       	sbci	r21, 0x00	; 0
    763a:	d8 f7       	brcc	.-10     	; 0x7632 <memcpy+0x6>
    763c:	08 95       	ret

0000763e <strnlen>:
    763e:	fc 01       	movw	r30, r24
    7640:	61 50       	subi	r22, 0x01	; 1
    7642:	70 40       	sbci	r23, 0x00	; 0
    7644:	01 90       	ld	r0, Z+
    7646:	01 10       	cpse	r0, r1
    7648:	d8 f7       	brcc	.-10     	; 0x7640 <strnlen+0x2>
    764a:	80 95       	com	r24
    764c:	90 95       	com	r25
    764e:	8e 0f       	add	r24, r30
    7650:	9f 1f       	adc	r25, r31
    7652:	08 95       	ret

00007654 <strrev>:
    7654:	dc 01       	movw	r26, r24
    7656:	fc 01       	movw	r30, r24
    7658:	67 2f       	mov	r22, r23
    765a:	71 91       	ld	r23, Z+
    765c:	77 23       	and	r23, r23
    765e:	e1 f7       	brne	.-8      	; 0x7658 <strrev+0x4>
    7660:	32 97       	sbiw	r30, 0x02	; 2
    7662:	04 c0       	rjmp	.+8      	; 0x766c <strrev+0x18>
    7664:	7c 91       	ld	r23, X
    7666:	6d 93       	st	X+, r22
    7668:	70 83       	st	Z, r23
    766a:	62 91       	ld	r22, -Z
    766c:	ae 17       	cp	r26, r30
    766e:	bf 07       	cpc	r27, r31
    7670:	c8 f3       	brcs	.-14     	; 0x7664 <strrev+0x10>
    7672:	08 95       	ret

00007674 <fputc>:
    7674:	0f 93       	push	r16
    7676:	1f 93       	push	r17
    7678:	cf 93       	push	r28
    767a:	df 93       	push	r29
    767c:	8c 01       	movw	r16, r24
    767e:	eb 01       	movw	r28, r22
    7680:	8b 81       	ldd	r24, Y+3	; 0x03
    7682:	81 ff       	sbrs	r24, 1
    7684:	1b c0       	rjmp	.+54     	; 0x76bc <fputc+0x48>
    7686:	82 ff       	sbrs	r24, 2
    7688:	0d c0       	rjmp	.+26     	; 0x76a4 <fputc+0x30>
    768a:	2e 81       	ldd	r18, Y+6	; 0x06
    768c:	3f 81       	ldd	r19, Y+7	; 0x07
    768e:	8c 81       	ldd	r24, Y+4	; 0x04
    7690:	9d 81       	ldd	r25, Y+5	; 0x05
    7692:	28 17       	cp	r18, r24
    7694:	39 07       	cpc	r19, r25
    7696:	64 f4       	brge	.+24     	; 0x76b0 <fputc+0x3c>
    7698:	e8 81       	ld	r30, Y
    769a:	f9 81       	ldd	r31, Y+1	; 0x01
    769c:	01 93       	st	Z+, r16
    769e:	e8 83       	st	Y, r30
    76a0:	f9 83       	std	Y+1, r31	; 0x01
    76a2:	06 c0       	rjmp	.+12     	; 0x76b0 <fputc+0x3c>
    76a4:	e8 85       	ldd	r30, Y+8	; 0x08
    76a6:	f9 85       	ldd	r31, Y+9	; 0x09
    76a8:	80 2f       	mov	r24, r16
    76aa:	19 95       	eicall
    76ac:	00 97       	sbiw	r24, 0x00	; 0
    76ae:	31 f4       	brne	.+12     	; 0x76bc <fputc+0x48>
    76b0:	8e 81       	ldd	r24, Y+6	; 0x06
    76b2:	9f 81       	ldd	r25, Y+7	; 0x07
    76b4:	01 96       	adiw	r24, 0x01	; 1
    76b6:	8e 83       	std	Y+6, r24	; 0x06
    76b8:	9f 83       	std	Y+7, r25	; 0x07
    76ba:	02 c0       	rjmp	.+4      	; 0x76c0 <fputc+0x4c>
    76bc:	0f ef       	ldi	r16, 0xFF	; 255
    76be:	1f ef       	ldi	r17, 0xFF	; 255
    76c0:	c8 01       	movw	r24, r16
    76c2:	df 91       	pop	r29
    76c4:	cf 91       	pop	r28
    76c6:	1f 91       	pop	r17
    76c8:	0f 91       	pop	r16
    76ca:	08 95       	ret

000076cc <__ultoa_invert>:
    76cc:	fa 01       	movw	r30, r20
    76ce:	aa 27       	eor	r26, r26
    76d0:	28 30       	cpi	r18, 0x08	; 8
    76d2:	51 f1       	breq	.+84     	; 0x7728 <__ultoa_invert+0x5c>
    76d4:	20 31       	cpi	r18, 0x10	; 16
    76d6:	81 f1       	breq	.+96     	; 0x7738 <__ultoa_invert+0x6c>
    76d8:	e8 94       	clt
    76da:	6f 93       	push	r22
    76dc:	6e 7f       	andi	r22, 0xFE	; 254
    76de:	6e 5f       	subi	r22, 0xFE	; 254
    76e0:	7f 4f       	sbci	r23, 0xFF	; 255
    76e2:	8f 4f       	sbci	r24, 0xFF	; 255
    76e4:	9f 4f       	sbci	r25, 0xFF	; 255
    76e6:	af 4f       	sbci	r26, 0xFF	; 255
    76e8:	b1 e0       	ldi	r27, 0x01	; 1
    76ea:	3e d0       	rcall	.+124    	; 0x7768 <__ultoa_invert+0x9c>
    76ec:	b4 e0       	ldi	r27, 0x04	; 4
    76ee:	3c d0       	rcall	.+120    	; 0x7768 <__ultoa_invert+0x9c>
    76f0:	67 0f       	add	r22, r23
    76f2:	78 1f       	adc	r23, r24
    76f4:	89 1f       	adc	r24, r25
    76f6:	9a 1f       	adc	r25, r26
    76f8:	a1 1d       	adc	r26, r1
    76fa:	68 0f       	add	r22, r24
    76fc:	79 1f       	adc	r23, r25
    76fe:	8a 1f       	adc	r24, r26
    7700:	91 1d       	adc	r25, r1
    7702:	a1 1d       	adc	r26, r1
    7704:	6a 0f       	add	r22, r26
    7706:	71 1d       	adc	r23, r1
    7708:	81 1d       	adc	r24, r1
    770a:	91 1d       	adc	r25, r1
    770c:	a1 1d       	adc	r26, r1
    770e:	20 d0       	rcall	.+64     	; 0x7750 <__ultoa_invert+0x84>
    7710:	09 f4       	brne	.+2      	; 0x7714 <__ultoa_invert+0x48>
    7712:	68 94       	set
    7714:	3f 91       	pop	r19
    7716:	2a e0       	ldi	r18, 0x0A	; 10
    7718:	26 9f       	mul	r18, r22
    771a:	11 24       	eor	r1, r1
    771c:	30 19       	sub	r19, r0
    771e:	30 5d       	subi	r19, 0xD0	; 208
    7720:	31 93       	st	Z+, r19
    7722:	de f6       	brtc	.-74     	; 0x76da <__ultoa_invert+0xe>
    7724:	cf 01       	movw	r24, r30
    7726:	08 95       	ret
    7728:	46 2f       	mov	r20, r22
    772a:	47 70       	andi	r20, 0x07	; 7
    772c:	40 5d       	subi	r20, 0xD0	; 208
    772e:	41 93       	st	Z+, r20
    7730:	b3 e0       	ldi	r27, 0x03	; 3
    7732:	0f d0       	rcall	.+30     	; 0x7752 <__ultoa_invert+0x86>
    7734:	c9 f7       	brne	.-14     	; 0x7728 <__ultoa_invert+0x5c>
    7736:	f6 cf       	rjmp	.-20     	; 0x7724 <__ultoa_invert+0x58>
    7738:	46 2f       	mov	r20, r22
    773a:	4f 70       	andi	r20, 0x0F	; 15
    773c:	40 5d       	subi	r20, 0xD0	; 208
    773e:	4a 33       	cpi	r20, 0x3A	; 58
    7740:	18 f0       	brcs	.+6      	; 0x7748 <__ultoa_invert+0x7c>
    7742:	49 5d       	subi	r20, 0xD9	; 217
    7744:	31 fd       	sbrc	r19, 1
    7746:	40 52       	subi	r20, 0x20	; 32
    7748:	41 93       	st	Z+, r20
    774a:	02 d0       	rcall	.+4      	; 0x7750 <__ultoa_invert+0x84>
    774c:	a9 f7       	brne	.-22     	; 0x7738 <__ultoa_invert+0x6c>
    774e:	ea cf       	rjmp	.-44     	; 0x7724 <__ultoa_invert+0x58>
    7750:	b4 e0       	ldi	r27, 0x04	; 4
    7752:	a6 95       	lsr	r26
    7754:	97 95       	ror	r25
    7756:	87 95       	ror	r24
    7758:	77 95       	ror	r23
    775a:	67 95       	ror	r22
    775c:	ba 95       	dec	r27
    775e:	c9 f7       	brne	.-14     	; 0x7752 <__ultoa_invert+0x86>
    7760:	00 97       	sbiw	r24, 0x00	; 0
    7762:	61 05       	cpc	r22, r1
    7764:	71 05       	cpc	r23, r1
    7766:	08 95       	ret
    7768:	9b 01       	movw	r18, r22
    776a:	ac 01       	movw	r20, r24
    776c:	0a 2e       	mov	r0, r26
    776e:	06 94       	lsr	r0
    7770:	57 95       	ror	r21
    7772:	47 95       	ror	r20
    7774:	37 95       	ror	r19
    7776:	27 95       	ror	r18
    7778:	ba 95       	dec	r27
    777a:	c9 f7       	brne	.-14     	; 0x776e <__ultoa_invert+0xa2>
    777c:	62 0f       	add	r22, r18
    777e:	73 1f       	adc	r23, r19
    7780:	84 1f       	adc	r24, r20
    7782:	95 1f       	adc	r25, r21
    7784:	a0 1d       	adc	r26, r0
    7786:	08 95       	ret

00007788 <_exit>:
    7788:	f8 94       	cli

0000778a <__stop_program>:
    778a:	ff cf       	rjmp	.-2      	; 0x778a <__stop_program>
