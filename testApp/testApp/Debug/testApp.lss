
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007c72  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00802000  00007c72  00007d06  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa5  00802138  00802138  00007e3e  2**0
                  ALLOC
  3 .stab         000029b8  00000000  00000000  00007e40  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2d  00000000  00000000  0000a7f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000400  00000000  00000000  0000b228  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cad2  00000000  00000000  0000b628  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000268f  00000000  00000000  000180fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000554e  00000000  00000000  0001a789  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ca4  00000000  00000000  0001fcd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004689  00000000  00000000  0002197c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000082e5  00000000  00000000  00026005  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b166  00000000  00000000  0002e2ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000190  00000000  00000000  00189450  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 ac 08 	jmp	0x1158	; 0x1158 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 71 0d 	jmp	0x1ae2	; 0x1ae2 <__vector_16>
      44:	0c 94 49 0d 	jmp	0x1a92	; 0x1a92 <__vector_17>
      48:	0c 94 21 0d 	jmp	0x1a42	; 0x1a42 <__vector_18>
      4c:	0c 94 db 0c 	jmp	0x19b6	; 0x19b6 <__vector_19>
      50:	0c 94 fe 06 	jmp	0xdfc	; 0xdfc <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 61 20 	jmp	0x40c2	; 0x40c2 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 49 1a 	jmp	0x3492	; 0x3492 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 54 0a 	jmp	0x14a8	; 0x14a8 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 b3 0c 	jmp	0x1966	; 0x1966 <__vector_79>
     140:	0c 94 8b 0c 	jmp	0x1916	; 0x1916 <__vector_80>
     144:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__vector_81>
     148:	0c 94 39 0c 	jmp	0x1872	; 0x1872 <__vector_82>
     14c:	0c 94 1c 03 	jmp	0x638	; 0x638 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 90 07 	jmp	0xf20	; 0xf20 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e2 e7       	ldi	r30, 0x72	; 114
     244:	fc e7       	ldi	r31, 0x7C	; 124
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 33       	cpi	r26, 0x38	; 56
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e3       	ldi	r26, 0x38	; 56
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ad 3d       	cpi	r26, 0xDD	; 221
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 01 02 	call	0x402	; 0x402 <main>
     26a:	0c 94 37 3e 	jmp	0x7c6e	; 0x7c6e <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	6b 01       	movw	r12, r22
     284:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     286:	dc 01       	movw	r26, r24
     288:	cb 01       	movw	r24, r22
     28a:	88 55       	subi	r24, 0x58	; 88
     28c:	92 40       	sbci	r25, 0x02	; 2
     28e:	a0 40       	sbci	r26, 0x00	; 0
     290:	b0 40       	sbci	r27, 0x00	; 0
     292:	89 3e       	cpi	r24, 0xE9	; 233
     294:	2f e3       	ldi	r18, 0x3F	; 63
     296:	92 07       	cpc	r25, r18
     298:	2f e0       	ldi	r18, 0x0F	; 15
     29a:	a2 07       	cpc	r26, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	b2 07       	cpc	r27, r18
     2a0:	08 f0       	brcs	.+2      	; 0x2a4 <StartSerial+0x32>
     2a2:	5c c0       	rjmp	.+184    	; 0x35c <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2a4:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2a8:	e0 e4       	ldi	r30, 0x40	; 64
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2b0:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2b2:	84 e0       	ldi	r24, 0x04	; 4
     2b4:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2b6:	cc 0c       	add	r12, r12
     2b8:	dd 1c       	adc	r13, r13
     2ba:	ee 1c       	adc	r14, r14
     2bc:	ff 1c       	adc	r15, r15
     2be:	cc 0c       	add	r12, r12
     2c0:	dd 1c       	adc	r13, r13
     2c2:	ee 1c       	adc	r14, r14
     2c4:	ff 1c       	adc	r15, r15
     2c6:	c7 01       	movw	r24, r14
     2c8:	b6 01       	movw	r22, r12
     2ca:	66 0f       	add	r22, r22
     2cc:	77 1f       	adc	r23, r23
     2ce:	88 1f       	adc	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	66 0f       	add	r22, r22
     2d4:	77 1f       	adc	r23, r23
     2d6:	88 1f       	adc	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	0e 94 85 39 	call	0x730a	; 0x730a <__floatunsisf>
     2de:	9b 01       	movw	r18, r22
     2e0:	ac 01       	movw	r20, r24
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	74 e2       	ldi	r23, 0x24	; 36
     2e6:	84 ef       	ldi	r24, 0xF4	; 244
     2e8:	9b e4       	ldi	r25, 0x4B	; 75
     2ea:	0e 94 f1 38 	call	0x71e2	; 0x71e2 <__divsf3>
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	40 e8       	ldi	r20, 0x80	; 128
     2f4:	5f e3       	ldi	r21, 0x3F	; 63
     2f6:	0e 94 8c 38 	call	0x7118	; 0x7118 <__subsf3>
     2fa:	c6 2f       	mov	r28, r22
     2fc:	d7 2f       	mov	r29, r23
     2fe:	18 2f       	mov	r17, r24
     300:	09 2f       	mov	r16, r25
     302:	86 2f       	mov	r24, r22
     304:	9d 2f       	mov	r25, r29
     306:	a1 2f       	mov	r26, r17
     308:	b0 2f       	mov	r27, r16
     30a:	bc 01       	movw	r22, r24
     30c:	cd 01       	movw	r24, r26
     30e:	0e 94 59 39 	call	0x72b2	; 0x72b2 <__fixunssfsi>
     312:	6b 01       	movw	r12, r22
     314:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 85 39 	call	0x730a	; 0x730a <__floatunsisf>
     31e:	9b 01       	movw	r18, r22
     320:	ac 01       	movw	r20, r24
     322:	8c 2f       	mov	r24, r28
     324:	9d 2f       	mov	r25, r29
     326:	a1 2f       	mov	r26, r17
     328:	b0 2f       	mov	r27, r16
     32a:	bc 01       	movw	r22, r24
     32c:	cd 01       	movw	r24, r26
     32e:	0e 94 8c 38 	call	0x7118	; 0x7118 <__subsf3>
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	40 e0       	ldi	r20, 0x00	; 0
     338:	5f e3       	ldi	r21, 0x3F	; 63
     33a:	0e 94 13 3a 	call	0x7426	; 0x7426 <__gesf2>
     33e:	88 23       	and	r24, r24
     340:	1c f0       	brlt	.+6      	; 0x348 <StartSerial+0xd6>
     342:	08 94       	sec
     344:	c1 1c       	adc	r12, r1
     346:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     348:	e0 ea       	ldi	r30, 0xA0	; 160
     34a:	f8 e0       	ldi	r31, 0x08	; 8
     34c:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     34e:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     354:	88 e1       	ldi	r24, 0x18	; 24
     356:	84 83       	std	Z+4, r24	; 0x04
	return true;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	01 c0       	rjmp	.+2      	; 0x35e <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     35c:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	1f 91       	pop	r17
     364:	0f 91       	pop	r16
     366:	ff 90       	pop	r15
     368:	ef 90       	pop	r14
     36a:	df 90       	pop	r13
     36c:	cf 90       	pop	r12
     36e:	08 95       	ret

00000370 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     370:	e0 ea       	ldi	r30, 0xA0	; 160
     372:	f8 e0       	ldi	r31, 0x08	; 8
     374:	91 81       	ldd	r25, Z+1	; 0x01
     376:	95 ff       	sbrs	r25, 5
     378:	fd cf       	rjmp	.-6      	; 0x374 <SerialWriteByte+0x4>
		//wait
	}
	//incremented byte
	USARTC0.DATA = byte;
     37a:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     37e:	08 95       	ret

00000380 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     380:	e0 ea       	ldi	r30, 0xA0	; 160
     382:	f8 e0       	ldi	r31, 0x08	; 8
     384:	81 81       	ldd	r24, Z+1	; 0x01
     386:	88 23       	and	r24, r24
     388:	ec f7       	brge	.-6      	; 0x384 <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     38a:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     38e:	08 95       	ret

00000390 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     390:	8f 92       	push	r8
     392:	9f 92       	push	r9
     394:	af 92       	push	r10
     396:	bf 92       	push	r11
     398:	cf 92       	push	r12
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	6a 01       	movw	r12, r20
     3a6:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     3a8:	41 15       	cp	r20, r1
     3aa:	51 05       	cpc	r21, r1
     3ac:	61 05       	cpc	r22, r1
     3ae:	71 05       	cpc	r23, r1
     3b0:	91 f0       	breq	.+36     	; 0x3d6 <SerialWriteBuffer+0x46>
     3b2:	c8 2f       	mov	r28, r24
     3b4:	d9 2f       	mov	r29, r25
     3b6:	88 24       	eor	r8, r8
     3b8:	99 24       	eor	r9, r9
     3ba:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     3bc:	89 91       	ld	r24, Y+
     3be:	0e 94 b8 01 	call	0x370	; 0x370 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     3c2:	08 94       	sec
     3c4:	81 1c       	adc	r8, r1
     3c6:	91 1c       	adc	r9, r1
     3c8:	a1 1c       	adc	r10, r1
     3ca:	b1 1c       	adc	r11, r1
     3cc:	8c 14       	cp	r8, r12
     3ce:	9d 04       	cpc	r9, r13
     3d0:	ae 04       	cpc	r10, r14
     3d2:	bf 04       	cpc	r11, r15
     3d4:	99 f7       	brne	.-26     	; 0x3bc <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	ff 90       	pop	r15
     3dc:	ef 90       	pop	r14
     3de:	df 90       	pop	r13
     3e0:	cf 90       	pop	r12
     3e2:	bf 90       	pop	r11
     3e4:	af 90       	pop	r10
     3e6:	9f 90       	pop	r9
     3e8:	8f 90       	pop	r8
     3ea:	08 95       	ret

000003ec <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     3ec:	e0 ea       	ldi	r30, 0xA0	; 160
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	84 81       	ldd	r24, Z+4	; 0x04
     3f2:	87 7e       	andi	r24, 0xE7	; 231
     3f4:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     3f6:	e0 e4       	ldi	r30, 0x40	; 64
     3f8:	f6 e0       	ldi	r31, 0x06	; 6
     3fa:	88 e0       	ldi	r24, 0x08	; 8
     3fc:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     3fe:	82 83       	std	Z+2, r24	; 0x02
     400:	08 95       	ret

00000402 <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
     40a:	68 97       	sbiw	r28, 0x18	; 24
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 6000;
	volatile uint32_t samples = 0;
     410:	19 82       	std	Y+1, r1	; 0x01
     412:	1a 82       	std	Y+2, r1	; 0x02
     414:	1b 82       	std	Y+3, r1	; 0x03
     416:	1c 82       	std	Y+4, r1	; 0x04
	DataAvailable = 0;
     418:	10 92 d5 21 	sts	0x21D5, r1
	ADC_Sampling_Finished = 1;
     41c:	81 e0       	ldi	r24, 0x01	; 1
     41e:	80 93 cd 50 	sts	0x50CD, r24
	uint8_t RadioMessageBuffer[20];
	set_32MHz();
     422:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <set_32MHz>
	chb_init();
     426:	0e 94 00 16 	call	0x2c00	; 0x2c00 <chb_init>
	chb_set_channel(1);
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	0e 94 75 19 	call	0x32ea	; 0x32ea <chb_set_channel>
	chb_set_short_addr(0x0002);
     430:	82 e0       	ldi	r24, 0x02	; 2
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 37 18 	call	0x306e	; 0x306e <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     438:	0e 94 12 16 	call	0x2c24	; 0x2c24 <chb_get_pcb>
     43c:	3c 01       	movw	r6, r24

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 6000;
     43e:	0f 2e       	mov	r0, r31
     440:	f0 e7       	ldi	r31, 0x70	; 112
     442:	4f 2e       	mov	r4, r31
     444:	f7 e1       	ldi	r31, 0x17	; 23
     446:	5f 2e       	mov	r5, r31
     448:	f0 2d       	mov	r31, r0
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     44a:	10 e0       	ldi	r17, 0x00	; 0
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
						//CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     44c:	0f 2e       	mov	r0, r31
     44e:	ff ed       	ldi	r31, 0xDF	; 223
     450:	2f 2e       	mov	r2, r31
     452:	f3 e2       	ldi	r31, 0x23	; 35
     454:	3f 2e       	mov	r3, r31
     456:	f0 2d       	mov	r31, r0
     458:	01 c0       	rjmp	.+2      	; 0x45c <main+0x5a>
					switch(RadioMessageBuffer[1]){
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     45a:	11 e0       	ldi	r17, 0x01	; 1
	chb_init();
	chb_set_channel(1);
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
     45c:	f3 01       	movw	r30, r6
     45e:	83 81       	ldd	r24, Z+3	; 0x03
     460:	88 23       	and	r24, r24
     462:	e1 f3       	breq	.-8      	; 0x45c <main+0x5a>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     464:	ce 01       	movw	r24, r28
     466:	05 96       	adiw	r24, 0x05	; 5
     468:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <chb_read>
			
			if(length == 1){
     46c:	81 30       	cpi	r24, 0x01	; 1
     46e:	b1 f7       	brne	.-20     	; 0x45c <main+0x5a>
				switch ( RadioMessageBuffer[0])
     470:	8d 81       	ldd	r24, Y+5	; 0x05
     472:	82 35       	cpi	r24, 0x52	; 82
     474:	71 f0       	breq	.+28     	; 0x492 <main+0x90>
     476:	83 35       	cpi	r24, 0x53	; 83
     478:	30 f4       	brcc	.+12     	; 0x486 <main+0x84>
     47a:	86 34       	cpi	r24, 0x46	; 70
     47c:	09 f4       	brne	.+2      	; 0x480 <main+0x7e>
     47e:	65 c0       	rjmp	.+202    	; 0x54a <main+0x148>
     480:	87 34       	cpi	r24, 0x47	; 71
     482:	61 f7       	brne	.-40     	; 0x45c <main+0x5a>
     484:	30 c0       	rjmp	.+96     	; 0x4e6 <main+0xe4>
     486:	83 35       	cpi	r24, 0x53	; 83
     488:	09 f4       	brne	.+2      	; 0x48c <main+0x8a>
     48a:	62 c0       	rjmp	.+196    	; 0x550 <main+0x14e>
     48c:	84 35       	cpi	r24, 0x54	; 84
     48e:	31 f7       	brne	.-52     	; 0x45c <main+0x5a>
     490:	67 c0       	rjmp	.+206    	; 0x560 <main+0x15e>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     492:	80 91 cd 50 	lds	r24, 0x50CD
     496:	88 23       	and	r24, r24
     498:	09 f3       	breq	.-62     	; 0x45c <main+0x5a>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     49a:	00 d0       	rcall	.+0      	; 0x49c <main+0x9a>
     49c:	0f 92       	push	r0
     49e:	8c e1       	ldi	r24, 0x1C	; 28
     4a0:	97 e0       	ldi	r25, 0x07	; 7
     4a2:	ed b7       	in	r30, 0x3d	; 61
     4a4:	fe b7       	in	r31, 0x3e	; 62
     4a6:	81 83       	std	Z+1, r24	; 0x01
     4a8:	92 83       	std	Z+2, r25	; 0x02
     4aa:	23 82       	std	Z+3, r2	; 0x03
     4ac:	34 82       	std	Z+4, r3	; 0x04
     4ae:	87 e0       	ldi	r24, 0x07	; 7
     4b0:	61 2f       	mov	r22, r17
     4b2:	a2 01       	movw	r20, r4
     4b4:	26 e0       	ldi	r18, 0x06	; 6
     4b6:	01 e0       	ldi	r16, 0x01	; 1
     4b8:	ee 24       	eor	r14, r14
     4ba:	ff 24       	eor	r15, r15
     4bc:	e3 94       	inc	r14
     4be:	cc 24       	eor	r12, r12
     4c0:	dd 24       	eor	r13, r13
     4c2:	68 94       	set
     4c4:	c1 f8       	bld	r12, 1
     4c6:	0f 2e       	mov	r0, r31
     4c8:	f3 e0       	ldi	r31, 0x03	; 3
     4ca:	af 2e       	mov	r10, r31
     4cc:	bb 24       	eor	r11, r11
     4ce:	f0 2d       	mov	r31, r0
     4d0:	88 24       	eor	r8, r8
     4d2:	99 24       	eor	r9, r9
     4d4:	68 94       	set
     4d6:	82 f8       	bld	r8, 2
     4d8:	0e 94 1d 13 	call	0x263a	; 0x263a <CO_collectSeismic1Channel>
     4dc:	0f 90       	pop	r0
     4de:	0f 90       	pop	r0
     4e0:	0f 90       	pop	r0
     4e2:	0f 90       	pop	r0
     4e4:	bb cf       	rjmp	.-138    	; 0x45c <main+0x5a>
					}						
					break;
				case 'G':
					//set gain to what is specified
					switch(RadioMessageBuffer[1]){
     4e6:	8e 81       	ldd	r24, Y+6	; 0x06
     4e8:	88 30       	cpi	r24, 0x08	; 8
     4ea:	d1 f0       	breq	.+52     	; 0x520 <main+0x11e>
     4ec:	89 30       	cpi	r24, 0x09	; 9
     4ee:	40 f4       	brcc	.+16     	; 0x500 <main+0xfe>
     4f0:	82 30       	cpi	r24, 0x02	; 2
     4f2:	09 f4       	brne	.+2      	; 0x4f6 <main+0xf4>
     4f4:	b2 cf       	rjmp	.-156    	; 0x45a <main+0x58>
     4f6:	84 30       	cpi	r24, 0x04	; 4
     4f8:	89 f0       	breq	.+34     	; 0x51c <main+0x11a>
     4fa:	81 30       	cpi	r24, 0x01	; 1
     4fc:	d9 f4       	brne	.+54     	; 0x534 <main+0x132>
     4fe:	0c c0       	rjmp	.+24     	; 0x518 <main+0x116>
     500:	80 32       	cpi	r24, 0x20	; 32
     502:	91 f0       	breq	.+36     	; 0x528 <main+0x126>
     504:	81 32       	cpi	r24, 0x21	; 33
     506:	18 f4       	brcc	.+6      	; 0x50e <main+0x10c>
     508:	80 31       	cpi	r24, 0x10	; 16
     50a:	a1 f4       	brne	.+40     	; 0x534 <main+0x132>
     50c:	0b c0       	rjmp	.+22     	; 0x524 <main+0x122>
     50e:	80 34       	cpi	r24, 0x40	; 64
     510:	69 f0       	breq	.+26     	; 0x52c <main+0x12a>
     512:	80 38       	cpi	r24, 0x80	; 128
     514:	79 f4       	brne	.+30     	; 0x534 <main+0x132>
     516:	0c c0       	rjmp	.+24     	; 0x530 <main+0x12e>
						case 1:
							gain = GAIN_1_gc;
     518:	10 e0       	ldi	r17, 0x00	; 0
     51a:	a0 cf       	rjmp	.-192    	; 0x45c <main+0x5a>
							break;
						case 2:
							gain = GAIN_2_gc;
							break;
						case 4:
							gain = GAIN_4_gc;
     51c:	12 e0       	ldi	r17, 0x02	; 2
							break;
     51e:	9e cf       	rjmp	.-196    	; 0x45c <main+0x5a>
						case 8:
							gain = GAIN_8_gc;
     520:	13 e0       	ldi	r17, 0x03	; 3
							break;
     522:	9c cf       	rjmp	.-200    	; 0x45c <main+0x5a>
						case 16:
							gain = GAIN_16_gc;
     524:	14 e0       	ldi	r17, 0x04	; 4
							break;
     526:	9a cf       	rjmp	.-204    	; 0x45c <main+0x5a>
						case 32:
							gain = GAIN_32_gc;
     528:	15 e0       	ldi	r17, 0x05	; 5
							break;
     52a:	98 cf       	rjmp	.-208    	; 0x45c <main+0x5a>
						case 64:
							gain = GAIN_64_gc;
     52c:	16 e0       	ldi	r17, 0x06	; 6
							break;
     52e:	96 cf       	rjmp	.-212    	; 0x45c <main+0x5a>
						case 128:
							gain = GAIN_128_gc;
     530:	17 e0       	ldi	r17, 0x07	; 7
							break;
     532:	94 cf       	rjmp	.-216    	; 0x45c <main+0x5a>
						default:
							chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	60 e0       	ldi	r22, 0x00	; 0
     53a:	70 e2       	ldi	r23, 0x20	; 32
     53c:	2c e0       	ldi	r18, 0x0C	; 12
     53e:	30 e0       	ldi	r19, 0x00	; 0
     540:	40 e0       	ldi	r20, 0x00	; 0
     542:	50 e0       	ldi	r21, 0x00	; 0
     544:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <chb_write>
							break;
     548:	89 cf       	rjmp	.-238    	; 0x45c <main+0x5a>
					}					
					break;
				case 'F':
					//set sampling frequency to what is specified
					freq = *(uint16_t*)(RadioMessageBuffer+1);
     54a:	4e 80       	ldd	r4, Y+6	; 0x06
     54c:	5f 80       	ldd	r5, Y+7	; 0x07
					break;
     54e:	86 cf       	rjmp	.-244    	; 0x45c <main+0x5a>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     550:	80 91 cd 50 	lds	r24, 0x50CD
     554:	88 23       	and	r24, r24
     556:	09 f0       	breq	.+2      	; 0x55a <main+0x158>
     558:	81 cf       	rjmp	.-254    	; 0x45c <main+0x5a>
						ADC_Stop_Sampling();
     55a:	0e 94 44 07 	call	0xe88	; 0xe88 <ADC_Stop_Sampling>
     55e:	7e cf       	rjmp	.-260    	; 0x45c <main+0x5a>
					}
					//otherwise, the ADC has finished sampling on its own and the data will be transmitted after this switch statement
					break;
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     560:	80 91 cd 50 	lds	r24, 0x50CD
     564:	88 23       	and	r24, r24
     566:	09 f4       	brne	.+2      	; 0x56a <main+0x168>
     568:	79 cf       	rjmp	.-270    	; 0x45c <main+0x5a>
     56a:	80 91 d5 21 	lds	r24, 0x21D5
     56e:	88 23       	and	r24, r24
     570:	09 f4       	brne	.+2      	; 0x574 <main+0x172>
     572:	74 cf       	rjmp	.-280    	; 0x45c <main+0x5a>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     574:	0e 94 65 07 	call	0xeca	; 0xeca <ADC_Get_Num_Samples>
     578:	a0 e0       	ldi	r26, 0x00	; 0
     57a:	b0 e0       	ldi	r27, 0x00	; 0
     57c:	89 83       	std	Y+1, r24	; 0x01
     57e:	9a 83       	std	Y+2, r25	; 0x02
     580:	ab 83       	std	Y+3, r26	; 0x03
     582:	bc 83       	std	Y+4, r27	; 0x04
						if(samples > 0) chb_write(0x0000,FRAMReadBuffer,samples*4);
     584:	89 81       	ldd	r24, Y+1	; 0x01
     586:	9a 81       	ldd	r25, Y+2	; 0x02
     588:	ab 81       	ldd	r26, Y+3	; 0x03
     58a:	bc 81       	ldd	r27, Y+4	; 0x04
     58c:	00 97       	sbiw	r24, 0x00	; 0
     58e:	a1 05       	cpc	r26, r1
     590:	b1 05       	cpc	r27, r1
     592:	99 f0       	breq	.+38     	; 0x5ba <main+0x1b8>
     594:	89 81       	ldd	r24, Y+1	; 0x01
     596:	9a 81       	ldd	r25, Y+2	; 0x02
     598:	ab 81       	ldd	r26, Y+3	; 0x03
     59a:	bc 81       	ldd	r27, Y+4	; 0x04
     59c:	9c 01       	movw	r18, r24
     59e:	ad 01       	movw	r20, r26
     5a0:	22 0f       	add	r18, r18
     5a2:	33 1f       	adc	r19, r19
     5a4:	44 1f       	adc	r20, r20
     5a6:	55 1f       	adc	r21, r21
     5a8:	22 0f       	add	r18, r18
     5aa:	33 1f       	adc	r19, r19
     5ac:	44 1f       	adc	r20, r20
     5ae:	55 1f       	adc	r21, r21
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	b1 01       	movw	r22, r2
     5b6:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <chb_write>
						DataAvailable = 0;
     5ba:	10 92 d5 21 	sts	0x21D5, r1
						samples = 0;
     5be:	19 82       	std	Y+1, r1	; 0x01
     5c0:	1a 82       	std	Y+2, r1	; 0x02
     5c2:	1b 82       	std	Y+3, r1	; 0x03
     5c4:	1c 82       	std	Y+4, r1	; 0x04
     5c6:	4a cf       	rjmp	.-364    	; 0x45c <main+0x5a>

000005c8 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     5c8:	0f 93       	push	r16
     5ca:	1f 93       	push	r17
     5cc:	cf 93       	push	r28
     5ce:	8c 01       	movw	r16, r24
	moteID = 1;
     5d0:	c1 e0       	ldi	r28, 0x01	; 1
     5d2:	c0 93 c8 50 	sts	0x50C8, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     5d6:	83 e0       	ldi	r24, 0x03	; 3
     5d8:	80 93 5e 40 	sts	0x405E, r24
	chb_init();
     5dc:	0e 94 00 16 	call	0x2c00	; 0x2c00 <chb_init>
	chb_set_short_addr(moteID);
     5e0:	80 91 c8 50 	lds	r24, 0x50C8
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	0e 94 37 18 	call	0x306e	; 0x306e <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     5ea:	88 ec       	ldi	r24, 0xC8	; 200
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     5f2:	e0 e4       	ldi	r30, 0x40	; 64
     5f4:	f9 e0       	ldi	r31, 0x09	; 9
     5f6:	89 e0       	ldi	r24, 0x09	; 9
     5f8:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     5fa:	82 e0       	ldi	r24, 0x02	; 2
     5fc:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     5fe:	24 ef       	ldi	r18, 0xF4	; 244
     600:	31 e0       	ldi	r19, 0x01	; 1
     602:	02 9f       	mul	r16, r18
     604:	c0 01       	movw	r24, r0
     606:	03 9f       	mul	r16, r19
     608:	90 0d       	add	r25, r0
     60a:	12 9f       	mul	r17, r18
     60c:	90 0d       	add	r25, r0
     60e:	11 24       	eor	r1, r1
     610:	86 a3       	lds	r24, 0x56
     612:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     614:	e0 e4       	ldi	r30, 0x40	; 64
     616:	f8 e0       	ldi	r31, 0x08	; 8
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	9a ef       	ldi	r25, 0xFA	; 250
     61c:	86 a3       	lds	r24, 0x56
     61e:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     620:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     622:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     624:	e0 ea       	ldi	r30, 0xA0	; 160
     626:	f0 e0       	ldi	r31, 0x00	; 0
     628:	82 81       	ldd	r24, Z+2	; 0x02
     62a:	87 60       	ori	r24, 0x07	; 7
     62c:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     62e:	78 94       	sei
}
     630:	cf 91       	pop	r28
     632:	1f 91       	pop	r17
     634:	0f 91       	pop	r16
     636:	08 95       	ret

00000638 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     638:	78 94       	sei
     63a:	1f 92       	push	r1
     63c:	0f 92       	push	r0
     63e:	0f b6       	in	r0, 0x3f	; 63
     640:	0f 92       	push	r0
     642:	0b b6       	in	r0, 0x3b	; 59
     644:	0f 92       	push	r0
     646:	11 24       	eor	r1, r1
     648:	ef 92       	push	r14
     64a:	ff 92       	push	r15
     64c:	0f 93       	push	r16
     64e:	1f 93       	push	r17
     650:	2f 93       	push	r18
     652:	3f 93       	push	r19
     654:	4f 93       	push	r20
     656:	5f 93       	push	r21
     658:	6f 93       	push	r22
     65a:	7f 93       	push	r23
     65c:	8f 93       	push	r24
     65e:	9f 93       	push	r25
     660:	af 93       	push	r26
     662:	bf 93       	push	r27
     664:	ef 93       	push	r30
     666:	ff 93       	push	r31
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	cd b7       	in	r28, 0x3d	; 61
     66e:	de b7       	in	r29, 0x3e	; 62
     670:	28 97       	sbiw	r28, 0x08	; 8
     672:	cd bf       	out	0x3d, r28	; 61
     674:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     676:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
     67a:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     67e:	82 e0       	ldi	r24, 0x02	; 2
     680:	80 93 5e 40 	sts	0x405E, r24
	char message[8];
	strcpy(message,"reset");
     684:	de 01       	movw	r26, r28
     686:	11 96       	adiw	r26, 0x01	; 1
     688:	ed e0       	ldi	r30, 0x0D	; 13
     68a:	f0 e2       	ldi	r31, 0x20	; 32
     68c:	86 e0       	ldi	r24, 0x06	; 6
     68e:	01 90       	ld	r0, Z+
     690:	0d 92       	st	X+, r0
     692:	81 50       	subi	r24, 0x01	; 1
     694:	e1 f7       	brne	.-8      	; 0x68e <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
     696:	0f ec       	ldi	r16, 0xCF	; 207
     698:	10 e5       	ldi	r17, 0x50	; 80
     69a:	80 91 c8 50 	lds	r24, 0x50C8
     69e:	90 e0       	ldi	r25, 0x00	; 0
     6a0:	b8 01       	movw	r22, r16
     6a2:	4a e0       	ldi	r20, 0x0A	; 10
     6a4:	50 e0       	ldi	r21, 0x00	; 0
     6a6:	0e 94 21 3b 	call	0x7642	; 0x7642 <itoa>
	strcat(message,buff);
     6aa:	7e 01       	movw	r14, r28
     6ac:	08 94       	sec
     6ae:	e1 1c       	adc	r14, r1
     6b0:	f1 1c       	adc	r15, r1
     6b2:	c7 01       	movw	r24, r14
     6b4:	b8 01       	movw	r22, r16
     6b6:	0e 94 08 3b 	call	0x7610	; 0x7610 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     6ba:	0e 94 87 07 	call	0xf0e	; 0xf0e <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     6be:	f7 01       	movw	r30, r14
     6c0:	01 90       	ld	r0, Z+
     6c2:	00 20       	and	r0, r0
     6c4:	e9 f7       	brne	.-6      	; 0x6c0 <__vector_83+0x88>
     6c6:	31 97       	sbiw	r30, 0x01	; 1
     6c8:	ee 19       	sub	r30, r14
     6ca:	ff 09       	sbc	r31, r15
     6cc:	9f 01       	movw	r18, r30
     6ce:	40 e0       	ldi	r20, 0x00	; 0
     6d0:	50 e0       	ldi	r21, 0x00	; 0
     6d2:	80 e0       	ldi	r24, 0x00	; 0
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	b7 01       	movw	r22, r14
     6d8:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <chb_write>
}	
     6dc:	28 96       	adiw	r28, 0x08	; 8
     6de:	cd bf       	out	0x3d, r28	; 61
     6e0:	de bf       	out	0x3e, r29	; 62
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	ff 91       	pop	r31
     6e8:	ef 91       	pop	r30
     6ea:	bf 91       	pop	r27
     6ec:	af 91       	pop	r26
     6ee:	9f 91       	pop	r25
     6f0:	8f 91       	pop	r24
     6f2:	7f 91       	pop	r23
     6f4:	6f 91       	pop	r22
     6f6:	5f 91       	pop	r21
     6f8:	4f 91       	pop	r20
     6fa:	3f 91       	pop	r19
     6fc:	2f 91       	pop	r18
     6fe:	1f 91       	pop	r17
     700:	0f 91       	pop	r16
     702:	ff 90       	pop	r15
     704:	ef 90       	pop	r14
     706:	0f 90       	pop	r0
     708:	0b be       	out	0x3b, r0	; 59
     70a:	0f 90       	pop	r0
     70c:	0f be       	out	0x3f, r0	; 63
     70e:	0f 90       	pop	r0
     710:	1f 90       	pop	r1
     712:	18 95       	reti

00000714 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     714:	cf 93       	push	r28
     716:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     718:	21 e0       	ldi	r18, 0x01	; 1
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	a9 01       	movw	r20, r18
     71e:	02 c0       	rjmp	.+4      	; 0x724 <set_ampGain+0x10>
     720:	44 0f       	add	r20, r20
     722:	55 1f       	adc	r21, r21
     724:	8a 95       	dec	r24
     726:	e2 f7       	brpl	.-8      	; 0x720 <set_ampGain+0xc>
     728:	ca 01       	movw	r24, r20
     72a:	61 e0       	ldi	r22, 0x01	; 1
     72c:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     730:	c0 ff       	sbrs	r28, 0
     732:	05 c0       	rjmp	.+10     	; 0x73e <set_ampGain+0x2a>
     734:	80 e4       	ldi	r24, 0x40	; 64
     736:	e0 e0       	ldi	r30, 0x00	; 0
     738:	f6 e0       	ldi	r31, 0x06	; 6
     73a:	85 83       	std	Z+5, r24	; 0x05
     73c:	04 c0       	rjmp	.+8      	; 0x746 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
     73e:	80 e4       	ldi	r24, 0x40	; 64
     740:	e0 e0       	ldi	r30, 0x00	; 0
     742:	f6 e0       	ldi	r31, 0x06	; 6
     744:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     746:	c1 ff       	sbrs	r28, 1
     748:	05 c0       	rjmp	.+10     	; 0x754 <set_ampGain+0x40>
     74a:	82 e0       	ldi	r24, 0x02	; 2
     74c:	e0 e2       	ldi	r30, 0x20	; 32
     74e:	f6 e0       	ldi	r31, 0x06	; 6
     750:	85 83       	std	Z+5, r24	; 0x05
     752:	04 c0       	rjmp	.+8      	; 0x75c <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
     754:	82 e0       	ldi	r24, 0x02	; 2
     756:	e0 e2       	ldi	r30, 0x20	; 32
     758:	f6 e0       	ldi	r31, 0x06	; 6
     75a:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     75c:	c2 ff       	sbrs	r28, 2
     75e:	05 c0       	rjmp	.+10     	; 0x76a <set_ampGain+0x56>
     760:	84 e0       	ldi	r24, 0x04	; 4
     762:	e0 e2       	ldi	r30, 0x20	; 32
     764:	f6 e0       	ldi	r31, 0x06	; 6
     766:	85 83       	std	Z+5, r24	; 0x05
     768:	04 c0       	rjmp	.+8      	; 0x772 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
     76a:	84 e0       	ldi	r24, 0x04	; 4
     76c:	e0 e2       	ldi	r30, 0x20	; 32
     76e:	f6 e0       	ldi	r31, 0x06	; 6
     770:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     772:	5a e0       	ldi	r21, 0x0A	; 10
     774:	5a 95       	dec	r21
     776:	f1 f7       	brne	.-4      	; 0x774 <set_ampGain+0x60>
     778:	00 c0       	rjmp	.+0      	; 0x77a <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     77a:	8f ef       	ldi	r24, 0xFF	; 255
     77c:	61 e0       	ldi	r22, 0x01	; 1
     77e:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     78a:	c8 2f       	mov	r28, r24
     78c:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     78e:	d8 2f       	mov	r29, r24
     790:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     792:	28 2f       	mov	r18, r24
     794:	30 e0       	ldi	r19, 0x00	; 0
     796:	a9 01       	movw	r20, r18
     798:	45 70       	andi	r20, 0x05	; 5
     79a:	50 70       	andi	r21, 0x00	; 0
     79c:	41 15       	cp	r20, r1
     79e:	51 05       	cpc	r21, r1
     7a0:	49 f0       	breq	.+18     	; 0x7b4 <set_filter+0x2e>
     7a2:	90 91 81 50 	lds	r25, 0x5081
     7a6:	48 2f       	mov	r20, r24
     7a8:	42 95       	swap	r20
     7aa:	4f 70       	andi	r20, 0x0F	; 15
     7ac:	90 7f       	andi	r25, 0xF0	; 240
     7ae:	94 2b       	or	r25, r20
     7b0:	90 93 81 50 	sts	0x5081, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     7b4:	2a 70       	andi	r18, 0x0A	; 10
     7b6:	30 70       	andi	r19, 0x00	; 0
     7b8:	21 15       	cp	r18, r1
     7ba:	31 05       	cpc	r19, r1
     7bc:	39 f0       	breq	.+14     	; 0x7cc <set_filter+0x46>
     7be:	90 91 81 50 	lds	r25, 0x5081
     7c2:	80 7f       	andi	r24, 0xF0	; 240
     7c4:	9f 70       	andi	r25, 0x0F	; 15
     7c6:	89 2b       	or	r24, r25
     7c8:	80 93 81 50 	sts	0x5081, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     7cc:	84 e0       	ldi	r24, 0x04	; 4
     7ce:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     7d2:	80 91 81 50 	lds	r24, 0x5081
     7d6:	80 93 65 50 	sts	0x5065, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     7da:	cc 23       	and	r28, r28
     7dc:	19 f0       	breq	.+6      	; 0x7e4 <set_filter+0x5e>
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     7e4:	dd 23       	and	r29, r29
     7e6:	19 f0       	breq	.+6      	; 0x7ee <set_filter+0x68>
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	0e 94 57 1d 	call	0x3aae	; 0x3aae <upperMuxCS>

	SPICS(TRUE);
     7ee:	81 e0       	ldi	r24, 0x01	; 1
     7f0:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     7f4:	8f ef       	ldi	r24, 0xFF	; 255
     7f6:	e0 ec       	ldi	r30, 0xC0	; 192
     7f8:	f8 e0       	ldi	r31, 0x08	; 8
     7fa:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     7fc:	82 81       	ldd	r24, Z+2	; 0x02
     7fe:	88 23       	and	r24, r24
     800:	ec f7       	brge	.-6      	; 0x7fc <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     802:	e0 ec       	ldi	r30, 0xC0	; 192
     804:	f8 e0       	ldi	r31, 0x08	; 8
     806:	83 81       	ldd	r24, Z+3	; 0x03
     808:	80 93 71 50 	sts	0x5071, r24

	nop();
     80c:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     80e:	a1 e7       	ldi	r26, 0x71	; 113
     810:	b0 e5       	ldi	r27, 0x50	; 80
     812:	1c 97       	sbiw	r26, 0x0c	; 12
     814:	8c 91       	ld	r24, X
     816:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     818:	82 81       	ldd	r24, Z+2	; 0x02
     81a:	88 23       	and	r24, r24
     81c:	ec f7       	brge	.-6      	; 0x818 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     81e:	e0 ec       	ldi	r30, 0xC0	; 192
     820:	f8 e0       	ldi	r31, 0x08	; 8
     822:	83 81       	ldd	r24, Z+3	; 0x03
     824:	80 93 71 50 	sts	0x5071, r24
	SPICS(FALSE);
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     82e:	cc 23       	and	r28, r28
     830:	19 f0       	breq	.+6      	; 0x838 <set_filter+0xb2>
     832:	80 e0       	ldi	r24, 0x00	; 0
     834:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     838:	dd 23       	and	r29, r29
     83a:	19 f0       	breq	.+6      	; 0x842 <set_filter+0xbc>
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	0e 94 57 1d 	call	0x3aae	; 0x3aae <upperMuxCS>
	SPIDisable();
     842:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
}
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	08 95       	ret

0000084c <ADCPower>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void ADCPower(uint8_t on) {
     84c:	0f 93       	push	r16
     84e:	1f 93       	push	r17
     850:	cf 93       	push	r28
     852:	df 93       	push	r29
	
	if (on) {
     854:	88 23       	and	r24, r24
     856:	09 f4       	brne	.+2      	; 0x85a <ADCPower+0xe>
     858:	46 c0       	rjmp	.+140    	; 0x8e6 <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     85a:	00 e0       	ldi	r16, 0x00	; 0
     85c:	16 e0       	ldi	r17, 0x06	; 6
     85e:	8e ed       	ldi	r24, 0xDE	; 222
     860:	d8 01       	movw	r26, r16
     862:	11 96       	adiw	r26, 0x01	; 1
     864:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     866:	c0 e2       	ldi	r28, 0x20	; 32
     868:	d6 e0       	ldi	r29, 0x06	; 6
     86a:	4e e0       	ldi	r20, 0x0E	; 14
     86c:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     86e:	e0 e4       	ldi	r30, 0x40	; 64
     870:	f6 e0       	ldi	r31, 0x06	; 6
     872:	63 e0       	ldi	r22, 0x03	; 3
     874:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     876:	80 e8       	ldi	r24, 0x80	; 128
     878:	96 e0       	ldi	r25, 0x06	; 6
     87a:	50 e1       	ldi	r21, 0x10	; 16
     87c:	dc 01       	movw	r26, r24
     87e:	11 96       	adiw	r26, 0x01	; 1
     880:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     882:	20 ea       	ldi	r18, 0xA0	; 160
     884:	36 e0       	ldi	r19, 0x06	; 6
     886:	d9 01       	movw	r26, r18
     888:	11 96       	adiw	r26, 0x01	; 1
     88a:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     88c:	7e e9       	ldi	r23, 0x9E	; 158
     88e:	d8 01       	movw	r26, r16
     890:	15 96       	adiw	r26, 0x05	; 5
     892:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     894:	78 e0       	ldi	r23, 0x08	; 8
     896:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     898:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     89a:	ec 01       	movw	r28, r24
     89c:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     89e:	d9 01       	movw	r26, r18
     8a0:	15 96       	adiw	r26, 0x05	; 5
     8a2:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     8a4:	10 92 81 50 	sts	0x5081, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     8a8:	8f ef       	ldi	r24, 0xFF	; 255
     8aa:	93 ec       	ldi	r25, 0xC3	; 195
     8ac:	a9 e0       	ldi	r26, 0x09	; 9
     8ae:	81 50       	subi	r24, 0x01	; 1
     8b0:	90 40       	sbci	r25, 0x00	; 0
     8b2:	a0 40       	sbci	r26, 0x00	; 0
     8b4:	e1 f7       	brne	.-8      	; 0x8ae <ADCPower+0x62>
     8b6:	00 c0       	rjmp	.+0      	; 0x8b8 <ADCPower+0x6c>
     8b8:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     8ba:	80 e4       	ldi	r24, 0x40	; 64
     8bc:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     8be:	10 92 82 50 	sts	0x5082, r1
     8c2:	10 92 ce 50 	sts	0x50CE, r1
     8c6:	10 92 d6 23 	sts	0x23D6, r1
     8ca:	10 92 7a 50 	sts	0x507A, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     8ce:	8f ef       	ldi	r24, 0xFF	; 255
     8d0:	61 e0       	ldi	r22, 0x01	; 1
     8d2:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     8d6:	8f ef       	ldi	r24, 0xFF	; 255
     8d8:	61 e0       	ldi	r22, 0x01	; 1
     8da:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     8de:	8f ef       	ldi	r24, 0xFF	; 255
     8e0:	0e 94 c3 03 	call	0x786	; 0x786 <set_filter>
     8e4:	32 c0       	rjmp	.+100    	; 0x94a <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     8e6:	00 e0       	ldi	r16, 0x00	; 0
     8e8:	16 e0       	ldi	r17, 0x06	; 6
     8ea:	7e ed       	ldi	r23, 0xDE	; 222
     8ec:	d8 01       	movw	r26, r16
     8ee:	16 96       	adiw	r26, 0x06	; 6
     8f0:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     8f2:	a0 e2       	ldi	r26, 0x20	; 32
     8f4:	b6 e0       	ldi	r27, 0x06	; 6
     8f6:	4e e0       	ldi	r20, 0x0E	; 14
     8f8:	16 96       	adiw	r26, 0x06	; 6
     8fa:	4c 93       	st	X, r20
     8fc:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     8fe:	20 e4       	ldi	r18, 0x40	; 64
     900:	36 e0       	ldi	r19, 0x06	; 6
     902:	63 e0       	ldi	r22, 0x03	; 3
     904:	e9 01       	movw	r28, r18
     906:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     908:	c0 e8       	ldi	r28, 0x80	; 128
     90a:	d6 e0       	ldi	r29, 0x06	; 6
     90c:	50 e1       	ldi	r21, 0x10	; 16
     90e:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     910:	80 ea       	ldi	r24, 0xA0	; 160
     912:	96 e0       	ldi	r25, 0x06	; 6
     914:	fc 01       	movw	r30, r24
     916:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     918:	f8 01       	movw	r30, r16
     91a:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     91c:	12 96       	adiw	r26, 0x02	; 2
     91e:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     920:	d9 01       	movw	r26, r18
     922:	12 96       	adiw	r26, 0x02	; 2
     924:	6c 93       	st	X, r22
     926:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     928:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     92a:	ec 01       	movw	r28, r24
     92c:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     92e:	80 e4       	ldi	r24, 0x40	; 64
     930:	12 96       	adiw	r26, 0x02	; 2
     932:	8c 93       	st	X, r24
     934:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     936:	10 92 82 50 	sts	0x5082, r1
     93a:	10 92 ce 50 	sts	0x50CE, r1
     93e:	10 92 d6 23 	sts	0x23D6, r1
     942:	10 92 7a 50 	sts	0x507A, r1
		channelStatus = 0x00;
     946:	10 92 81 50 	sts	0x5081, r1
		
	}
}
     94a:	df 91       	pop	r29
     94c:	cf 91       	pop	r28
     94e:	1f 91       	pop	r17
     950:	0f 91       	pop	r16
     952:	08 95       	ret

00000954 <CO_collectBatt>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     954:	4f 92       	push	r4
     956:	5f 92       	push	r5
     958:	6f 92       	push	r6
     95a:	7f 92       	push	r7
     95c:	8f 92       	push	r8
     95e:	9f 92       	push	r9
     960:	af 92       	push	r10
     962:	bf 92       	push	r11
     964:	ef 92       	push	r14
     966:	ff 92       	push	r15
     968:	0f 93       	push	r16
     96a:	1f 93       	push	r17
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	2b 97       	sbiw	r28, 0x0b	; 11
     976:	cd bf       	out	0x3d, r28	; 61
     978:	de bf       	out	0x3e, r29	; 62
     97a:	8e 83       	std	Y+6, r24	; 0x06
     97c:	9f 83       	std	Y+7, r25	; 0x07
     97e:	68 87       	std	Y+8, r22	; 0x08
     980:	79 87       	std	Y+9, r23	; 0x09
     982:	4a 87       	std	Y+10, r20	; 0x0a
     984:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     98c:	84 e0       	ldi	r24, 0x04	; 4
     98e:	60 e0       	ldi	r22, 0x00	; 0
     990:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     994:	84 e0       	ldi	r24, 0x04	; 4
     996:	60 e0       	ldi	r22, 0x00	; 0
     998:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
     99c:	2f ef       	ldi	r18, 0xFF	; 255
     99e:	33 ec       	ldi	r19, 0xC3	; 195
     9a0:	49 e0       	ldi	r20, 0x09	; 9
     9a2:	21 50       	subi	r18, 0x01	; 1
     9a4:	30 40       	sbci	r19, 0x00	; 0
     9a6:	40 40       	sbci	r20, 0x00	; 0
     9a8:	e1 f7       	brne	.-8      	; 0x9a2 <CO_collectBatt+0x4e>
     9aa:	00 c0       	rjmp	.+0      	; 0x9ac <CO_collectBatt+0x58>
     9ac:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     9ae:	80 e4       	ldi	r24, 0x40	; 64
     9b0:	92 e0       	ldi	r25, 0x02	; 2
     9b2:	0e 94 d2 15 	call	0x2ba4	; 0x2ba4 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     9b6:	00 e4       	ldi	r16, 0x40	; 64
     9b8:	12 e0       	ldi	r17, 0x02	; 2
     9ba:	d8 01       	movw	r26, r16
     9bc:	11 96       	adiw	r26, 0x01	; 1
     9be:	8c 91       	ld	r24, X
     9c0:	11 97       	sbiw	r26, 0x01	; 1
     9c2:	89 7e       	andi	r24, 0xE9	; 233
     9c4:	11 96       	adiw	r26, 0x01	; 1
     9c6:	8c 93       	st	X, r24
     9c8:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     9ca:	14 96       	adiw	r26, 0x04	; 4
     9cc:	8c 91       	ld	r24, X
     9ce:	14 97       	sbiw	r26, 0x04	; 4
     9d0:	88 7f       	andi	r24, 0xF8	; 248
     9d2:	83 60       	ori	r24, 0x03	; 3
     9d4:	14 96       	adiw	r26, 0x04	; 4
     9d6:	8c 93       	st	X, r24
     9d8:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     9da:	12 96       	adiw	r26, 0x02	; 2
     9dc:	8c 91       	ld	r24, X
     9de:	12 97       	sbiw	r26, 0x02	; 2
     9e0:	8f 7c       	andi	r24, 0xCF	; 207
     9e2:	12 96       	adiw	r26, 0x02	; 2
     9e4:	8c 93       	st	X, r24
     9e6:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     9e8:	0f 2e       	mov	r0, r31
     9ea:	f0 e6       	ldi	r31, 0x60	; 96
     9ec:	ef 2e       	mov	r14, r31
     9ee:	f2 e0       	ldi	r31, 0x02	; 2
     9f0:	ff 2e       	mov	r15, r31
     9f2:	f0 2d       	mov	r31, r0
     9f4:	f7 01       	movw	r30, r14
     9f6:	80 81       	ld	r24, Z
     9f8:	80 7e       	andi	r24, 0xE0	; 224
     9fa:	81 60       	ori	r24, 0x01	; 1
     9fc:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     9fe:	89 e0       	ldi	r24, 0x09	; 9
     a00:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
     a02:	8c 91       	ld	r24, X
     a04:	81 60       	ori	r24, 0x01	; 1
     a06:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     a08:	80 e4       	ldi	r24, 0x40	; 64
     a0a:	92 e0       	ldi	r25, 0x02	; 2
     a0c:	0e 94 57 15 	call	0x2aae	; 0x2aae <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     a10:	80 e4       	ldi	r24, 0x40	; 64
     a12:	92 e0       	ldi	r25, 0x02	; 2
     a14:	60 e6       	ldi	r22, 0x60	; 96
     a16:	72 e0       	ldi	r23, 0x02	; 2
     a18:	40 e0       	ldi	r20, 0x00	; 0
     a1a:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <ADC_Offset_Get_Unsigned>
     a1e:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
     a20:	d8 01       	movw	r26, r16
     a22:	8c 91       	ld	r24, X
     a24:	8e 7f       	andi	r24, 0xFE	; 254
     a26:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     a28:	f7 01       	movw	r30, r14
     a2a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     a2c:	13 96       	adiw	r26, 0x03	; 3
     a2e:	8c 91       	ld	r24, X
     a30:	13 97       	sbiw	r26, 0x03	; 3
     a32:	8f 73       	andi	r24, 0x3F	; 63
     a34:	13 96       	adiw	r26, 0x03	; 3
     a36:	8c 93       	st	X, r24
     a38:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     a3a:	8c 91       	ld	r24, X
     a3c:	81 60       	ori	r24, 0x01	; 1
     a3e:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     a40:	80 e4       	ldi	r24, 0x40	; 64
     a42:	92 e0       	ldi	r25, 0x02	; 2
     a44:	0e 94 57 15 	call	0x2aae	; 0x2aae <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     a48:	d8 01       	movw	r26, r16
     a4a:	11 96       	adiw	r26, 0x01	; 1
     a4c:	8c 91       	ld	r24, X
     a4e:	11 97       	sbiw	r26, 0x01	; 1
     a50:	88 60       	ori	r24, 0x08	; 8
     a52:	11 96       	adiw	r26, 0x01	; 1
     a54:	8c 93       	st	X, r24
     a56:	ee 24       	eor	r14, r14
     a58:	ff 24       	eor	r15, r15
     a5a:	68 94       	set
     a5c:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     a5e:	44 24       	eor	r4, r4
     a60:	55 24       	eor	r5, r5
     a62:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     a64:	20 e0       	ldi	r18, 0x00	; 0
     a66:	30 e1       	ldi	r19, 0x10	; 16
     a68:	40 e0       	ldi	r20, 0x00	; 0
     a6a:	50 e0       	ldi	r21, 0x00	; 0
     a6c:	2a 83       	std	Y+2, r18	; 0x02
     a6e:	3b 83       	std	Y+3, r19	; 0x03
     a70:	4c 83       	std	Y+4, r20	; 0x04
     a72:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     a74:	88 24       	eor	r8, r8
     a76:	99 24       	eor	r9, r9
     a78:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     a7a:	00 e6       	ldi	r16, 0x60	; 96
     a7c:	12 e0       	ldi	r17, 0x02	; 2
     a7e:	d8 01       	movw	r26, r16
     a80:	13 96       	adiw	r26, 0x03	; 3
     a82:	8c 91       	ld	r24, X
     a84:	13 97       	sbiw	r26, 0x03	; 3
     a86:	80 ff       	sbrs	r24, 0
     a88:	fa cf       	rjmp	.-12     	; 0xa7e <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a8a:	69 81       	ldd	r22, Y+1	; 0x01
     a8c:	c8 01       	movw	r24, r16
     a8e:	0e 94 33 15 	call	0x2a66	; 0x2a66 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
     a92:	a0 e0       	ldi	r26, 0x00	; 0
     a94:	b0 e0       	ldi	r27, 0x00	; 0
     a96:	88 0e       	add	r8, r24
     a98:	99 1e       	adc	r9, r25
     a9a:	aa 1e       	adc	r10, r26
     a9c:	bb 1e       	adc	r11, r27
     a9e:	48 16       	cp	r4, r24
     aa0:	59 06       	cpc	r5, r25
     aa2:	6a 06       	cpc	r6, r26
     aa4:	7b 06       	cpc	r7, r27
     aa6:	10 f4       	brcc	.+4      	; 0xaac <CO_collectBatt+0x158>
     aa8:	2c 01       	movw	r4, r24
     aaa:	3d 01       	movw	r6, r26
     aac:	2a 81       	ldd	r18, Y+2	; 0x02
     aae:	3b 81       	ldd	r19, Y+3	; 0x03
     ab0:	4c 81       	ldd	r20, Y+4	; 0x04
     ab2:	5d 81       	ldd	r21, Y+5	; 0x05
     ab4:	82 17       	cp	r24, r18
     ab6:	93 07       	cpc	r25, r19
     ab8:	a4 07       	cpc	r26, r20
     aba:	b5 07       	cpc	r27, r21
     abc:	20 f4       	brcc	.+8      	; 0xac6 <CO_collectBatt+0x172>
     abe:	8a 83       	std	Y+2, r24	; 0x02
     ac0:	9b 83       	std	Y+3, r25	; 0x03
     ac2:	ac 83       	std	Y+4, r26	; 0x04
     ac4:	bd 83       	std	Y+5, r27	; 0x05
     ac6:	08 94       	sec
     ac8:	e1 08       	sbc	r14, r1
     aca:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     acc:	e1 14       	cp	r14, r1
     ace:	f1 04       	cpc	r15, r1
     ad0:	b1 f6       	brne	.-84     	; 0xa7e <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     ad2:	e0 e4       	ldi	r30, 0x40	; 64
     ad4:	f2 e0       	ldi	r31, 0x02	; 2
     ad6:	81 81       	ldd	r24, Z+1	; 0x01
     ad8:	87 7f       	andi	r24, 0xF7	; 247
     ada:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
     adc:	80 81       	ld	r24, Z
     ade:	8e 7f       	andi	r24, 0xFE	; 254
     ae0:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     ae2:	84 e0       	ldi	r24, 0x04	; 4
     ae4:	60 e0       	ldi	r22, 0x00	; 0
     ae6:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     aea:	80 e0       	ldi	r24, 0x00	; 0
     aec:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
     af0:	c5 01       	movw	r24, r10
     af2:	b4 01       	movw	r22, r8
     af4:	05 2e       	mov	r0, r21
     af6:	5a e0       	ldi	r21, 0x0A	; 10
     af8:	96 95       	lsr	r25
     afa:	87 95       	ror	r24
     afc:	77 95       	ror	r23
     afe:	67 95       	ror	r22
     b00:	5a 95       	dec	r21
     b02:	d1 f7       	brne	.-12     	; 0xaf8 <CO_collectBatt+0x1a4>
     b04:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b06:	28 ee       	ldi	r18, 0xE8	; 232
     b08:	33 e0       	ldi	r19, 0x03	; 3
     b0a:	40 e0       	ldi	r20, 0x00	; 0
     b0c:	50 e0       	ldi	r21, 0x00	; 0
     b0e:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
     b12:	0f 2e       	mov	r0, r31
     b14:	ff ef       	ldi	r31, 0xFF	; 255
     b16:	8f 2e       	mov	r8, r31
     b18:	ff e0       	ldi	r31, 0x0F	; 15
     b1a:	9f 2e       	mov	r9, r31
     b1c:	f0 e0       	ldi	r31, 0x00	; 0
     b1e:	af 2e       	mov	r10, r31
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	bf 2e       	mov	r11, r31
     b24:	f0 2d       	mov	r31, r0
     b26:	a5 01       	movw	r20, r10
     b28:	94 01       	movw	r18, r8
     b2a:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
     b2e:	c9 01       	movw	r24, r18
     b30:	c2 97       	sbiw	r24, 0x32	; 50
     b32:	ae 81       	ldd	r26, Y+6	; 0x06
     b34:	bf 81       	ldd	r27, Y+7	; 0x07
     b36:	8d 93       	st	X+, r24
     b38:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     b3a:	c3 01       	movw	r24, r6
     b3c:	b2 01       	movw	r22, r4
     b3e:	28 ee       	ldi	r18, 0xE8	; 232
     b40:	33 e0       	ldi	r19, 0x03	; 3
     b42:	40 e0       	ldi	r20, 0x00	; 0
     b44:	50 e0       	ldi	r21, 0x00	; 0
     b46:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
     b4a:	a5 01       	movw	r20, r10
     b4c:	94 01       	movw	r18, r8
     b4e:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
     b52:	c9 01       	movw	r24, r18
     b54:	c2 97       	sbiw	r24, 0x32	; 50
     b56:	ea 85       	ldd	r30, Y+10	; 0x0a
     b58:	fb 85       	ldd	r31, Y+11	; 0x0b
     b5a:	80 83       	st	Z, r24
     b5c:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     b5e:	6a 81       	ldd	r22, Y+2	; 0x02
     b60:	7b 81       	ldd	r23, Y+3	; 0x03
     b62:	8c 81       	ldd	r24, Y+4	; 0x04
     b64:	9d 81       	ldd	r25, Y+5	; 0x05
     b66:	28 ee       	ldi	r18, 0xE8	; 232
     b68:	33 e0       	ldi	r19, 0x03	; 3
     b6a:	40 e0       	ldi	r20, 0x00	; 0
     b6c:	50 e0       	ldi	r21, 0x00	; 0
     b6e:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
     b72:	a5 01       	movw	r20, r10
     b74:	94 01       	movw	r18, r8
     b76:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
     b7a:	22 53       	subi	r18, 0x32	; 50
     b7c:	30 40       	sbci	r19, 0x00	; 0
     b7e:	a8 85       	ldd	r26, Y+8	; 0x08
     b80:	b9 85       	ldd	r27, Y+9	; 0x09
     b82:	2d 93       	st	X+, r18
     b84:	3c 93       	st	X, r19
     b86:	11 97       	sbiw	r26, 0x01	; 1
}
     b88:	2b 96       	adiw	r28, 0x0b	; 11
     b8a:	cd bf       	out	0x3d, r28	; 61
     b8c:	de bf       	out	0x3e, r29	; 62
     b8e:	df 91       	pop	r29
     b90:	cf 91       	pop	r28
     b92:	1f 91       	pop	r17
     b94:	0f 91       	pop	r16
     b96:	ff 90       	pop	r15
     b98:	ef 90       	pop	r14
     b9a:	bf 90       	pop	r11
     b9c:	af 90       	pop	r10
     b9e:	9f 90       	pop	r9
     ba0:	8f 90       	pop	r8
     ba2:	7f 90       	pop	r7
     ba4:	6f 90       	pop	r6
     ba6:	5f 90       	pop	r5
     ba8:	4f 90       	pop	r4
     baa:	08 95       	ret

00000bac <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     bac:	4f 92       	push	r4
     bae:	5f 92       	push	r5
     bb0:	6f 92       	push	r6
     bb2:	7f 92       	push	r7
     bb4:	8f 92       	push	r8
     bb6:	9f 92       	push	r9
     bb8:	af 92       	push	r10
     bba:	bf 92       	push	r11
     bbc:	ef 92       	push	r14
     bbe:	ff 92       	push	r15
     bc0:	0f 93       	push	r16
     bc2:	1f 93       	push	r17
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	cd b7       	in	r28, 0x3d	; 61
     bca:	de b7       	in	r29, 0x3e	; 62
     bcc:	2b 97       	sbiw	r28, 0x0b	; 11
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	de bf       	out	0x3e, r29	; 62
     bd2:	8e 83       	std	Y+6, r24	; 0x06
     bd4:	9f 83       	std	Y+7, r25	; 0x07
     bd6:	68 87       	std	Y+8, r22	; 0x08
     bd8:	79 87       	std	Y+9, r23	; 0x09
     bda:	4a 87       	std	Y+10, r20	; 0x0a
     bdc:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     bde:	81 e0       	ldi	r24, 0x01	; 1
     be0:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     be4:	80 e0       	ldi	r24, 0x00	; 0
     be6:	92 e0       	ldi	r25, 0x02	; 2
     be8:	0e 94 d2 15 	call	0x2ba4	; 0x2ba4 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     bec:	00 e0       	ldi	r16, 0x00	; 0
     bee:	12 e0       	ldi	r17, 0x02	; 2
     bf0:	d8 01       	movw	r26, r16
     bf2:	11 96       	adiw	r26, 0x01	; 1
     bf4:	8c 91       	ld	r24, X
     bf6:	11 97       	sbiw	r26, 0x01	; 1
     bf8:	89 7e       	andi	r24, 0xE9	; 233
     bfa:	11 96       	adiw	r26, 0x01	; 1
     bfc:	8c 93       	st	X, r24
     bfe:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     c00:	14 96       	adiw	r26, 0x04	; 4
     c02:	8c 91       	ld	r24, X
     c04:	14 97       	sbiw	r26, 0x04	; 4
     c06:	88 7f       	andi	r24, 0xF8	; 248
     c08:	83 60       	ori	r24, 0x03	; 3
     c0a:	14 96       	adiw	r26, 0x04	; 4
     c0c:	8c 93       	st	X, r24
     c0e:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     c10:	12 96       	adiw	r26, 0x02	; 2
     c12:	8c 91       	ld	r24, X
     c14:	12 97       	sbiw	r26, 0x02	; 2
     c16:	8f 7c       	andi	r24, 0xCF	; 207
     c18:	12 96       	adiw	r26, 0x02	; 2
     c1a:	8c 93       	st	X, r24
     c1c:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     c1e:	0f 2e       	mov	r0, r31
     c20:	f0 e2       	ldi	r31, 0x20	; 32
     c22:	ef 2e       	mov	r14, r31
     c24:	f2 e0       	ldi	r31, 0x02	; 2
     c26:	ff 2e       	mov	r15, r31
     c28:	f0 2d       	mov	r31, r0
     c2a:	f7 01       	movw	r30, r14
     c2c:	80 81       	ld	r24, Z
     c2e:	80 7e       	andi	r24, 0xE0	; 224
     c30:	81 60       	ori	r24, 0x01	; 1
     c32:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     c34:	89 e0       	ldi	r24, 0x09	; 9
     c36:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     c38:	8c 91       	ld	r24, X
     c3a:	81 60       	ori	r24, 0x01	; 1
     c3c:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	92 e0       	ldi	r25, 0x02	; 2
     c42:	0e 94 57 15 	call	0x2aae	; 0x2aae <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	92 e0       	ldi	r25, 0x02	; 2
     c4a:	60 e2       	ldi	r22, 0x20	; 32
     c4c:	72 e0       	ldi	r23, 0x02	; 2
     c4e:	40 e0       	ldi	r20, 0x00	; 0
     c50:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <ADC_Offset_Get_Unsigned>
     c54:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     c56:	d8 01       	movw	r26, r16
     c58:	8c 91       	ld	r24, X
     c5a:	8e 7f       	andi	r24, 0xFE	; 254
     c5c:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     c5e:	f7 01       	movw	r30, r14
     c60:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     c62:	13 96       	adiw	r26, 0x03	; 3
     c64:	8c 91       	ld	r24, X
     c66:	13 97       	sbiw	r26, 0x03	; 3
     c68:	8f 73       	andi	r24, 0x3F	; 63
     c6a:	13 96       	adiw	r26, 0x03	; 3
     c6c:	8c 93       	st	X, r24
     c6e:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     c70:	8c 91       	ld	r24, X
     c72:	81 60       	ori	r24, 0x01	; 1
     c74:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     c76:	80 e0       	ldi	r24, 0x00	; 0
     c78:	92 e0       	ldi	r25, 0x02	; 2
     c7a:	0e 94 57 15 	call	0x2aae	; 0x2aae <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     c7e:	d8 01       	movw	r26, r16
     c80:	11 96       	adiw	r26, 0x01	; 1
     c82:	8c 91       	ld	r24, X
     c84:	11 97       	sbiw	r26, 0x01	; 1
     c86:	88 60       	ori	r24, 0x08	; 8
     c88:	11 96       	adiw	r26, 0x01	; 1
     c8a:	8c 93       	st	X, r24
     c8c:	ee 24       	eor	r14, r14
     c8e:	ff 24       	eor	r15, r15
     c90:	68 94       	set
     c92:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     c94:	44 24       	eor	r4, r4
     c96:	55 24       	eor	r5, r5
     c98:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     c9a:	20 e0       	ldi	r18, 0x00	; 0
     c9c:	30 e1       	ldi	r19, 0x10	; 16
     c9e:	40 e0       	ldi	r20, 0x00	; 0
     ca0:	50 e0       	ldi	r21, 0x00	; 0
     ca2:	2a 83       	std	Y+2, r18	; 0x02
     ca4:	3b 83       	std	Y+3, r19	; 0x03
     ca6:	4c 83       	std	Y+4, r20	; 0x04
     ca8:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     caa:	88 24       	eor	r8, r8
     cac:	99 24       	eor	r9, r9
     cae:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     cb0:	00 e2       	ldi	r16, 0x20	; 32
     cb2:	12 e0       	ldi	r17, 0x02	; 2
     cb4:	d8 01       	movw	r26, r16
     cb6:	13 96       	adiw	r26, 0x03	; 3
     cb8:	8c 91       	ld	r24, X
     cba:	13 97       	sbiw	r26, 0x03	; 3
     cbc:	80 ff       	sbrs	r24, 0
     cbe:	fa cf       	rjmp	.-12     	; 0xcb4 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     cc0:	69 81       	ldd	r22, Y+1	; 0x01
     cc2:	c8 01       	movw	r24, r16
     cc4:	0e 94 33 15 	call	0x2a66	; 0x2a66 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
     cc8:	a0 e0       	ldi	r26, 0x00	; 0
     cca:	b0 e0       	ldi	r27, 0x00	; 0
     ccc:	88 0e       	add	r8, r24
     cce:	99 1e       	adc	r9, r25
     cd0:	aa 1e       	adc	r10, r26
     cd2:	bb 1e       	adc	r11, r27
     cd4:	48 16       	cp	r4, r24
     cd6:	59 06       	cpc	r5, r25
     cd8:	6a 06       	cpc	r6, r26
     cda:	7b 06       	cpc	r7, r27
     cdc:	10 f4       	brcc	.+4      	; 0xce2 <CO_collectTemp+0x136>
     cde:	2c 01       	movw	r4, r24
     ce0:	3d 01       	movw	r6, r26
     ce2:	2a 81       	ldd	r18, Y+2	; 0x02
     ce4:	3b 81       	ldd	r19, Y+3	; 0x03
     ce6:	4c 81       	ldd	r20, Y+4	; 0x04
     ce8:	5d 81       	ldd	r21, Y+5	; 0x05
     cea:	82 17       	cp	r24, r18
     cec:	93 07       	cpc	r25, r19
     cee:	a4 07       	cpc	r26, r20
     cf0:	b5 07       	cpc	r27, r21
     cf2:	20 f4       	brcc	.+8      	; 0xcfc <CO_collectTemp+0x150>
     cf4:	8a 83       	std	Y+2, r24	; 0x02
     cf6:	9b 83       	std	Y+3, r25	; 0x03
     cf8:	ac 83       	std	Y+4, r26	; 0x04
     cfa:	bd 83       	std	Y+5, r27	; 0x05
     cfc:	08 94       	sec
     cfe:	e1 08       	sbc	r14, r1
     d00:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     d02:	e1 14       	cp	r14, r1
     d04:	f1 04       	cpc	r15, r1
     d06:	b1 f6       	brne	.-84     	; 0xcb4 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     d08:	e0 e0       	ldi	r30, 0x00	; 0
     d0a:	f2 e0       	ldi	r31, 0x02	; 2
     d0c:	81 81       	ldd	r24, Z+1	; 0x01
     d0e:	87 7f       	andi	r24, 0xF7	; 247
     d10:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     d12:	80 81       	ld	r24, Z
     d14:	82 60       	ori	r24, 0x02	; 2
     d16:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
     d18:	80 81       	ld	r24, Z
     d1a:	8e 7f       	andi	r24, 0xFE	; 254
     d1c:	80 83       	st	Z, r24

	ADCPower(FALSE);
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>

	average = sum / NUM_SAMPLES;
     d24:	c5 01       	movw	r24, r10
     d26:	b4 01       	movw	r22, r8
     d28:	05 2e       	mov	r0, r21
     d2a:	5a e0       	ldi	r21, 0x0A	; 10
     d2c:	96 95       	lsr	r25
     d2e:	87 95       	ror	r24
     d30:	77 95       	ror	r23
     d32:	67 95       	ror	r22
     d34:	5a 95       	dec	r21
     d36:	d1 f7       	brne	.-12     	; 0xd2c <CO_collectTemp+0x180>
     d38:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     d3a:	28 ee       	ldi	r18, 0xE8	; 232
     d3c:	33 e0       	ldi	r19, 0x03	; 3
     d3e:	40 e0       	ldi	r20, 0x00	; 0
     d40:	50 e0       	ldi	r21, 0x00	; 0
     d42:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
     d46:	0f 2e       	mov	r0, r31
     d48:	ff ef       	ldi	r31, 0xFF	; 255
     d4a:	8f 2e       	mov	r8, r31
     d4c:	ff e0       	ldi	r31, 0x0F	; 15
     d4e:	9f 2e       	mov	r9, r31
     d50:	f0 e0       	ldi	r31, 0x00	; 0
     d52:	af 2e       	mov	r10, r31
     d54:	f0 e0       	ldi	r31, 0x00	; 0
     d56:	bf 2e       	mov	r11, r31
     d58:	f0 2d       	mov	r31, r0
     d5a:	a5 01       	movw	r20, r10
     d5c:	94 01       	movw	r18, r8
     d5e:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
     d62:	c9 01       	movw	r24, r18
     d64:	c2 97       	sbiw	r24, 0x32	; 50
     d66:	ae 81       	ldd	r26, Y+6	; 0x06
     d68:	bf 81       	ldd	r27, Y+7	; 0x07
     d6a:	8d 93       	st	X+, r24
     d6c:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     d6e:	c3 01       	movw	r24, r6
     d70:	b2 01       	movw	r22, r4
     d72:	28 ee       	ldi	r18, 0xE8	; 232
     d74:	33 e0       	ldi	r19, 0x03	; 3
     d76:	40 e0       	ldi	r20, 0x00	; 0
     d78:	50 e0       	ldi	r21, 0x00	; 0
     d7a:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
     d7e:	a5 01       	movw	r20, r10
     d80:	94 01       	movw	r18, r8
     d82:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
     d86:	c9 01       	movw	r24, r18
     d88:	c2 97       	sbiw	r24, 0x32	; 50
     d8a:	ea 85       	ldd	r30, Y+10	; 0x0a
     d8c:	fb 85       	ldd	r31, Y+11	; 0x0b
     d8e:	80 83       	st	Z, r24
     d90:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     d92:	6a 81       	ldd	r22, Y+2	; 0x02
     d94:	7b 81       	ldd	r23, Y+3	; 0x03
     d96:	8c 81       	ldd	r24, Y+4	; 0x04
     d98:	9d 81       	ldd	r25, Y+5	; 0x05
     d9a:	28 ee       	ldi	r18, 0xE8	; 232
     d9c:	33 e0       	ldi	r19, 0x03	; 3
     d9e:	40 e0       	ldi	r20, 0x00	; 0
     da0:	50 e0       	ldi	r21, 0x00	; 0
     da2:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
     da6:	a5 01       	movw	r20, r10
     da8:	94 01       	movw	r18, r8
     daa:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
     dae:	22 53       	subi	r18, 0x32	; 50
     db0:	30 40       	sbci	r19, 0x00	; 0
     db2:	a8 85       	ldd	r26, Y+8	; 0x08
     db4:	b9 85       	ldd	r27, Y+9	; 0x09
     db6:	2d 93       	st	X+, r18
     db8:	3c 93       	st	X, r19
     dba:	11 97       	sbiw	r26, 0x01	; 1
}
     dbc:	2b 96       	adiw	r28, 0x0b	; 11
     dbe:	cd bf       	out	0x3d, r28	; 61
     dc0:	de bf       	out	0x3e, r29	; 62
     dc2:	df 91       	pop	r29
     dc4:	cf 91       	pop	r28
     dc6:	1f 91       	pop	r17
     dc8:	0f 91       	pop	r16
     dca:	ff 90       	pop	r15
     dcc:	ef 90       	pop	r14
     dce:	bf 90       	pop	r11
     dd0:	af 90       	pop	r10
     dd2:	9f 90       	pop	r9
     dd4:	8f 90       	pop	r8
     dd6:	7f 90       	pop	r7
     dd8:	6f 90       	pop	r6
     dda:	5f 90       	pop	r5
     ddc:	4f 90       	pop	r4
     dde:	08 95       	ret

00000de0 <enableADCMUX>:
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	
	if(on) {
     de0:	88 23       	and	r24, r24
     de2:	31 f0       	breq	.+12     	; 0xdf0 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
     de4:	e0 e0       	ldi	r30, 0x00	; 0
     de6:	f6 e0       	ldi	r31, 0x06	; 6
     de8:	80 e2       	ldi	r24, 0x20	; 32
     dea:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
     dec:	85 83       	std	Z+5, r24	; 0x05
     dee:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
     df0:	e0 e0       	ldi	r30, 0x00	; 0
     df2:	f6 e0       	ldi	r31, 0x06	; 6
     df4:	80 e2       	ldi	r24, 0x20	; 32
     df6:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     df8:	82 83       	std	Z+2, r24	; 0x02
     dfa:	08 95       	ret

00000dfc <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
     dfc:	1f 92       	push	r1
     dfe:	0f 92       	push	r0
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	0f 92       	push	r0
     e04:	0b b6       	in	r0, 0x3b	; 59
     e06:	0f 92       	push	r0
     e08:	11 24       	eor	r1, r1
     e0a:	2f 93       	push	r18
     e0c:	3f 93       	push	r19
     e0e:	4f 93       	push	r20
     e10:	5f 93       	push	r21
     e12:	6f 93       	push	r22
     e14:	7f 93       	push	r23
     e16:	8f 93       	push	r24
     e18:	9f 93       	push	r25
     e1a:	af 93       	push	r26
     e1c:	bf 93       	push	r27
     e1e:	ef 93       	push	r30
     e20:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e22:	e0 e4       	ldi	r30, 0x40	; 64
     e24:	fa e0       	ldi	r31, 0x0A	; 10
     e26:	80 81       	ld	r24, Z
     e28:	80 7f       	andi	r24, 0xF0	; 240
     e2a:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e2c:	a0 e0       	ldi	r26, 0x00	; 0
     e2e:	b8 e0       	ldi	r27, 0x08	; 8
     e30:	8c 91       	ld	r24, X
     e32:	80 7f       	andi	r24, 0xF0	; 240
     e34:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e36:	a0 e0       	ldi	r26, 0x00	; 0
     e38:	b9 e0       	ldi	r27, 0x09	; 9
     e3a:	8c 91       	ld	r24, X
     e3c:	80 7f       	andi	r24, 0xF0	; 240
     e3e:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e40:	80 81       	ld	r24, Z
     e42:	80 7f       	andi	r24, 0xF0	; 240
     e44:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     e48:	80 e0       	ldi	r24, 0x00	; 0
     e4a:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
     e4e:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	enableADCMUX(FALSE);
     e52:	80 e0       	ldi	r24, 0x00	; 0
     e54:	0e 94 f0 06 	call	0xde0	; 0xde0 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
     e58:	81 e0       	ldi	r24, 0x01	; 1
     e5a:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     e5e:	80 93 d5 21 	sts	0x21D5, r24
}
     e62:	ff 91       	pop	r31
     e64:	ef 91       	pop	r30
     e66:	bf 91       	pop	r27
     e68:	af 91       	pop	r26
     e6a:	9f 91       	pop	r25
     e6c:	8f 91       	pop	r24
     e6e:	7f 91       	pop	r23
     e70:	6f 91       	pop	r22
     e72:	5f 91       	pop	r21
     e74:	4f 91       	pop	r20
     e76:	3f 91       	pop	r19
     e78:	2f 91       	pop	r18
     e7a:	0f 90       	pop	r0
     e7c:	0b be       	out	0x3b, r0	; 59
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	0f 90       	pop	r0
     e84:	1f 90       	pop	r1
     e86:	18 95       	reti

00000e88 <ADC_Stop_Sampling>:
//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e88:	e0 e4       	ldi	r30, 0x40	; 64
     e8a:	fa e0       	ldi	r31, 0x0A	; 10
     e8c:	80 81       	ld	r24, Z
     e8e:	80 7f       	andi	r24, 0xF0	; 240
     e90:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e92:	a0 e0       	ldi	r26, 0x00	; 0
     e94:	b8 e0       	ldi	r27, 0x08	; 8
     e96:	8c 91       	ld	r24, X
     e98:	80 7f       	andi	r24, 0xF0	; 240
     e9a:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e9c:	a0 e0       	ldi	r26, 0x00	; 0
     e9e:	b9 e0       	ldi	r27, 0x09	; 9
     ea0:	8c 91       	ld	r24, X
     ea2:	80 7f       	andi	r24, 0xF0	; 240
     ea4:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     ea6:	80 81       	ld	r24, Z
     ea8:	80 7f       	andi	r24, 0xF0	; 240
     eaa:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
     eb4:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	enableADCMUX(FALSE);
     eb8:	80 e0       	ldi	r24, 0x00	; 0
     eba:	0e 94 f0 06 	call	0xde0	; 0xde0 <enableADCMUX>
	ADC_Sampling_Finished = 1;
     ebe:	81 e0       	ldi	r24, 0x01	; 1
     ec0:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     ec4:	80 93 d5 21 	sts	0x21D5, r24
}
     ec8:	08 95       	ret

00000eca <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
     eca:	cf 93       	push	r28
     ecc:	df 93       	push	r29
     ece:	0f 92       	push	r0
     ed0:	0f 92       	push	r0
     ed2:	cd b7       	in	r28, 0x3d	; 61
     ed4:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
     ed6:	80 91 cd 50 	lds	r24, 0x50CD
     eda:	88 23       	and	r24, r24
     edc:	89 f0       	breq	.+34     	; 0xf00 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
     ede:	e0 e4       	ldi	r30, 0x40	; 64
     ee0:	f8 e0       	ldi	r31, 0x08	; 8
     ee2:	80 a1       	lds	r24, 0x40
     ee4:	91 a1       	lds	r25, 0x41
     ee6:	89 83       	std	Y+1, r24	; 0x01
     ee8:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
     eea:	89 81       	ldd	r24, Y+1	; 0x01
     eec:	9a 81       	ldd	r25, Y+2	; 0x02
     eee:	00 97       	sbiw	r24, 0x00	; 0
     ef0:	21 f4       	brne	.+8      	; 0xefa <ADC_Get_Num_Samples+0x30>
     ef2:	86 a1       	lds	r24, 0x46
     ef4:	97 a1       	lds	r25, 0x47
     ef6:	89 83       	std	Y+1, r24	; 0x01
     ef8:	9a 83       	std	Y+2, r25	; 0x02
		return count;
     efa:	89 81       	ldd	r24, Y+1	; 0x01
     efc:	9a 81       	ldd	r25, Y+2	; 0x02
     efe:	02 c0       	rjmp	.+4      	; 0xf04 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
     f00:	80 e0       	ldi	r24, 0x00	; 0
     f02:	90 e0       	ldi	r25, 0x00	; 0
}
     f04:	0f 90       	pop	r0
     f06:	0f 90       	pop	r0
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	08 95       	ret

00000f0e <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
     f0e:	e0 ea       	ldi	r30, 0xA0	; 160
     f10:	f6 e0       	ldi	r31, 0x06	; 6
     f12:	13 86       	std	Z+11, r1	; 0x0b
}
     f14:	08 95       	ret

00000f16 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
     f16:	81 e0       	ldi	r24, 0x01	; 1
     f18:	e0 ea       	ldi	r30, 0xA0	; 160
     f1a:	f6 e0       	ldi	r31, 0x06	; 6
     f1c:	83 87       	std	Z+11, r24	; 0x0b
}	
     f1e:	08 95       	ret

00000f20 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
     f20:	1f 92       	push	r1
     f22:	0f 92       	push	r0
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	0f 92       	push	r0
     f28:	0b b6       	in	r0, 0x3b	; 59
     f2a:	0f 92       	push	r0
     f2c:	11 24       	eor	r1, r1
     f2e:	6f 92       	push	r6
     f30:	7f 92       	push	r7
     f32:	8f 92       	push	r8
     f34:	9f 92       	push	r9
     f36:	af 92       	push	r10
     f38:	bf 92       	push	r11
     f3a:	cf 92       	push	r12
     f3c:	df 92       	push	r13
     f3e:	ef 92       	push	r14
     f40:	ff 92       	push	r15
     f42:	0f 93       	push	r16
     f44:	1f 93       	push	r17
     f46:	2f 93       	push	r18
     f48:	3f 93       	push	r19
     f4a:	4f 93       	push	r20
     f4c:	5f 93       	push	r21
     f4e:	6f 93       	push	r22
     f50:	7f 93       	push	r23
     f52:	8f 93       	push	r24
     f54:	9f 93       	push	r25
     f56:	af 93       	push	r26
     f58:	bf 93       	push	r27
     f5a:	ef 93       	push	r30
     f5c:	ff 93       	push	r31
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	cd b7       	in	r28, 0x3d	; 61
     f64:	de b7       	in	r29, 0x3e	; 62
     f66:	2c 97       	sbiw	r28, 0x0c	; 12
     f68:	cd bf       	out	0x3d, r28	; 61
     f6a:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
     f6c:	80 91 5d 40 	lds	r24, 0x405D
     f70:	88 23       	and	r24, r24
     f72:	8c f0       	brlt	.+34     	; 0xf96 <__vector_104+0x76>
		discardCount++;
     f74:	80 91 5d 40 	lds	r24, 0x405D
     f78:	8f 5f       	subi	r24, 0xFF	; 255
     f7a:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
     f7e:	80 91 5d 40 	lds	r24, 0x405D
     f82:	80 38       	cpi	r24, 0x80	; 128
     f84:	09 f0       	breq	.+2      	; 0xf88 <__vector_104+0x68>
     f86:	b4 c0       	rjmp	.+360    	; 0x10f0 <__vector_104+0x1d0>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
     f88:	e0 e4       	ldi	r30, 0x40	; 64
     f8a:	f8 e0       	ldi	r31, 0x08	; 8
     f8c:	80 81       	ld	r24, Z
     f8e:	80 7f       	andi	r24, 0xF0	; 240
     f90:	89 60       	ori	r24, 0x09	; 9
     f92:	80 83       	st	Z, r24
     f94:	ad c0       	rjmp	.+346    	; 0x10f0 <__vector_104+0x1d0>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
     f9c:	82 e0       	ldi	r24, 0x02	; 2
     f9e:	e0 ea       	ldi	r30, 0xA0	; 160
     fa0:	f6 e0       	ldi	r31, 0x06	; 6
     fa2:	86 83       	std	Z+6, r24	; 0x06
     fa4:	80 e0       	ldi	r24, 0x00	; 0
     fa6:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     fa8:	e0 ec       	ldi	r30, 0xC0	; 192
     faa:	f8 e0       	ldi	r31, 0x08	; 8
     fac:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
     fae:	25 e6       	ldi	r18, 0x65	; 101
     fb0:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     fb2:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
     fb4:	42 81       	ldd	r20, Z+2	; 0x02
     fb6:	44 23       	and	r20, r20
     fb8:	ec f7       	brge	.-6      	; 0xfb4 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
     fba:	43 81       	ldd	r20, Z+3	; 0x03
     fbc:	d9 01       	movw	r26, r18
     fbe:	a8 0f       	add	r26, r24
     fc0:	b9 1f       	adc	r27, r25
     fc2:	4c 93       	st	X, r20
     fc4:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     fc6:	83 30       	cpi	r24, 0x03	; 3
     fc8:	91 05       	cpc	r25, r1
     fca:	99 f7       	brne	.-26     	; 0xfb2 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
     fcc:	82 e0       	ldi	r24, 0x02	; 2
     fce:	e0 ea       	ldi	r30, 0xA0	; 160
     fd0:	f6 e0       	ldi	r31, 0x06	; 6
     fd2:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
     fd4:	80 e0       	ldi	r24, 0x00	; 0
     fd6:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
     fda:	80 91 65 50 	lds	r24, 0x5065
     fde:	88 23       	and	r24, r24
     fe0:	1c f4       	brge	.+6      	; 0xfe8 <__vector_104+0xc8>
     fe2:	8f ef       	ldi	r24, 0xFF	; 255
     fe4:	8c 83       	std	Y+4, r24	; 0x04
     fe6:	01 c0       	rjmp	.+2      	; 0xfea <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
     fe8:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
     fea:	80 91 65 50 	lds	r24, 0x5065
     fee:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
     ff0:	80 91 66 50 	lds	r24, 0x5066
     ff4:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
     ff6:	80 91 67 50 	lds	r24, 0x5067
     ffa:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
     ffc:	89 81       	ldd	r24, Y+1	; 0x01
     ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    1000:	ab 81       	ldd	r26, Y+3	; 0x03
    1002:	bc 81       	ldd	r27, Y+4	; 0x04
    1004:	ac 01       	movw	r20, r24
    1006:	bd 01       	movw	r22, r26
    1008:	77 0f       	add	r23, r23
    100a:	44 0b       	sbc	r20, r20
    100c:	54 2f       	mov	r21, r20
    100e:	ba 01       	movw	r22, r20
    1010:	8d 83       	std	Y+5, r24	; 0x05
    1012:	9e 83       	std	Y+6, r25	; 0x06
    1014:	af 83       	std	Y+7, r26	; 0x07
    1016:	b8 87       	std	Y+8, r27	; 0x08
    1018:	49 87       	std	Y+9, r20	; 0x09
    101a:	4a 87       	std	Y+10, r20	; 0x0a
    101c:	4b 87       	std	Y+11, r20	; 0x0b
    101e:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1020:	80 90 74 50 	lds	r8, 0x5074
    1024:	90 90 75 50 	lds	r9, 0x5075
    1028:	a0 90 76 50 	lds	r10, 0x5076
    102c:	b0 90 77 50 	lds	r11, 0x5077
    1030:	2d 81       	ldd	r18, Y+5	; 0x05
    1032:	3e 81       	ldd	r19, Y+6	; 0x06
    1034:	4f 81       	ldd	r20, Y+7	; 0x07
    1036:	58 85       	ldd	r21, Y+8	; 0x08
    1038:	69 85       	ldd	r22, Y+9	; 0x09
    103a:	7a 85       	ldd	r23, Y+10	; 0x0a
    103c:	8b 85       	ldd	r24, Y+11	; 0x0b
    103e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1040:	f4 01       	movw	r30, r8
    1042:	ee 0f       	add	r30, r30
    1044:	ff 1f       	adc	r31, r31
    1046:	ee 0f       	add	r30, r30
    1048:	ff 1f       	adc	r31, r31
    104a:	60 90 72 50 	lds	r6, 0x5072
    104e:	70 90 73 50 	lds	r7, 0x5073
    1052:	6e 0e       	add	r6, r30
    1054:	7f 1e       	adc	r7, r31
    1056:	0f 2e       	mov	r0, r31
    1058:	f0 ea       	ldi	r31, 0xA0	; 160
    105a:	af 2e       	mov	r10, r31
    105c:	f0 2d       	mov	r31, r0
    105e:	0f 2e       	mov	r0, r31
    1060:	f5 e2       	ldi	r31, 0x25	; 37
    1062:	bf 2e       	mov	r11, r31
    1064:	f0 2d       	mov	r31, r0
    1066:	0f 2e       	mov	r0, r31
    1068:	f6 e2       	ldi	r31, 0x26	; 38
    106a:	cf 2e       	mov	r12, r31
    106c:	f0 2d       	mov	r31, r0
    106e:	dd 24       	eor	r13, r13
    1070:	ee 24       	eor	r14, r14
    1072:	ff 24       	eor	r15, r15
    1074:	00 e0       	ldi	r16, 0x00	; 0
    1076:	10 e0       	ldi	r17, 0x00	; 0
    1078:	0e 94 21 2f 	call	0x5e42	; 0x5e42 <__muldi3>
    107c:	aa 24       	eor	r10, r10
    107e:	aa 94       	dec	r10
    1080:	bb 24       	eor	r11, r11
    1082:	ba 94       	dec	r11
    1084:	0f 2e       	mov	r0, r31
    1086:	ff e7       	ldi	r31, 0x7F	; 127
    1088:	cf 2e       	mov	r12, r31
    108a:	f0 2d       	mov	r31, r0
    108c:	0e 94 d0 30 	call	0x61a0	; 0x61a0 <__divdi3>
    1090:	01 e0       	ldi	r16, 0x01	; 1
    1092:	0e 94 f4 2f 	call	0x5fe8	; 0x5fe8 <__ashldi3>
    1096:	0f 2e       	mov	r0, r31
    1098:	f3 e0       	ldi	r31, 0x03	; 3
    109a:	af 2e       	mov	r10, r31
    109c:	f0 2d       	mov	r31, r0
    109e:	bb 24       	eor	r11, r11
    10a0:	cc 24       	eor	r12, r12
    10a2:	00 e0       	ldi	r16, 0x00	; 0
    10a4:	0e 94 d0 30 	call	0x61a0	; 0x61a0 <__divdi3>
    10a8:	82 2e       	mov	r8, r18
    10aa:	93 2e       	mov	r9, r19
    10ac:	a4 2e       	mov	r10, r20
    10ae:	b5 2e       	mov	r11, r21
    10b0:	b0 94       	com	r11
    10b2:	a0 94       	com	r10
    10b4:	90 94       	com	r9
    10b6:	80 94       	com	r8
    10b8:	81 1c       	adc	r8, r1
    10ba:	91 1c       	adc	r9, r1
    10bc:	a1 1c       	adc	r10, r1
    10be:	b1 1c       	adc	r11, r1
    10c0:	f3 01       	movw	r30, r6
    10c2:	80 82       	st	Z, r8
    10c4:	91 82       	std	Z+1, r9	; 0x01
    10c6:	a2 82       	std	Z+2, r10	; 0x02
    10c8:	b3 82       	std	Z+3, r11	; 0x03
		sampleCount++;
    10ca:	80 91 74 50 	lds	r24, 0x5074
    10ce:	90 91 75 50 	lds	r25, 0x5075
    10d2:	a0 91 76 50 	lds	r26, 0x5076
    10d6:	b0 91 77 50 	lds	r27, 0x5077
    10da:	01 96       	adiw	r24, 0x01	; 1
    10dc:	a1 1d       	adc	r26, r1
    10de:	b1 1d       	adc	r27, r1
    10e0:	80 93 74 50 	sts	0x5074, r24
    10e4:	90 93 75 50 	sts	0x5075, r25
    10e8:	a0 93 76 50 	sts	0x5076, r26
    10ec:	b0 93 77 50 	sts	0x5077, r27
	}
}
    10f0:	2c 96       	adiw	r28, 0x0c	; 12
    10f2:	cd bf       	out	0x3d, r28	; 61
    10f4:	de bf       	out	0x3e, r29	; 62
    10f6:	df 91       	pop	r29
    10f8:	cf 91       	pop	r28
    10fa:	ff 91       	pop	r31
    10fc:	ef 91       	pop	r30
    10fe:	bf 91       	pop	r27
    1100:	af 91       	pop	r26
    1102:	9f 91       	pop	r25
    1104:	8f 91       	pop	r24
    1106:	7f 91       	pop	r23
    1108:	6f 91       	pop	r22
    110a:	5f 91       	pop	r21
    110c:	4f 91       	pop	r20
    110e:	3f 91       	pop	r19
    1110:	2f 91       	pop	r18
    1112:	1f 91       	pop	r17
    1114:	0f 91       	pop	r16
    1116:	ff 90       	pop	r15
    1118:	ef 90       	pop	r14
    111a:	df 90       	pop	r13
    111c:	cf 90       	pop	r12
    111e:	bf 90       	pop	r11
    1120:	af 90       	pop	r10
    1122:	9f 90       	pop	r9
    1124:	8f 90       	pop	r8
    1126:	7f 90       	pop	r7
    1128:	6f 90       	pop	r6
    112a:	0f 90       	pop	r0
    112c:	0b be       	out	0x3b, r0	; 59
    112e:	0f 90       	pop	r0
    1130:	0f be       	out	0x3f, r0	; 63
    1132:	0f 90       	pop	r0
    1134:	1f 90       	pop	r1
    1136:	18 95       	reti

00001138 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1138:	88 23       	and	r24, r24
    113a:	49 f0       	breq	.+18     	; 0x114e <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    113c:	80 e2       	ldi	r24, 0x20	; 32
    113e:	60 e0       	ldi	r22, 0x00	; 0
    1140:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1144:	80 e2       	ldi	r24, 0x20	; 32
    1146:	60 e0       	ldi	r22, 0x00	; 0
    1148:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
    114c:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    114e:	80 e2       	ldi	r24, 0x20	; 32
    1150:	60 e0       	ldi	r22, 0x00	; 0
    1152:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <PortEx_DIRCLR>
    1156:	08 95       	ret

00001158 <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1158:	1f 92       	push	r1
    115a:	0f 92       	push	r0
    115c:	0f b6       	in	r0, 0x3f	; 63
    115e:	0f 92       	push	r0
    1160:	0b b6       	in	r0, 0x3b	; 59
    1162:	0f 92       	push	r0
    1164:	11 24       	eor	r1, r1
    1166:	6f 92       	push	r6
    1168:	7f 92       	push	r7
    116a:	8f 92       	push	r8
    116c:	9f 92       	push	r9
    116e:	af 92       	push	r10
    1170:	bf 92       	push	r11
    1172:	cf 92       	push	r12
    1174:	df 92       	push	r13
    1176:	ef 92       	push	r14
    1178:	ff 92       	push	r15
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	2f 93       	push	r18
    1180:	3f 93       	push	r19
    1182:	4f 93       	push	r20
    1184:	5f 93       	push	r21
    1186:	6f 93       	push	r22
    1188:	7f 93       	push	r23
    118a:	8f 93       	push	r24
    118c:	9f 93       	push	r25
    118e:	af 93       	push	r26
    1190:	bf 93       	push	r27
    1192:	ef 93       	push	r30
    1194:	ff 93       	push	r31
    1196:	cf 93       	push	r28
    1198:	df 93       	push	r29
    119a:	cd b7       	in	r28, 0x3d	; 61
    119c:	de b7       	in	r29, 0x3e	; 62
    119e:	2c 97       	sbiw	r28, 0x0c	; 12
    11a0:	cd bf       	out	0x3d, r28	; 61
    11a2:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    11a4:	19 82       	std	Y+1, r1	; 0x01
    11a6:	1a 82       	std	Y+2, r1	; 0x02
    11a8:	1b 82       	std	Y+3, r1	; 0x03
    11aa:	1c 82       	std	Y+4, r1	; 0x04
    11ac:	1d 82       	std	Y+5, r1	; 0x05
    11ae:	1e 82       	std	Y+6, r1	; 0x06
    11b0:	1f 82       	std	Y+7, r1	; 0x07
    11b2:	18 86       	std	Y+8, r1	; 0x08
    11b4:	80 e0       	ldi	r24, 0x00	; 0
    11b6:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    11b8:	25 e6       	ldi	r18, 0x65	; 101
    11ba:	30 e5       	ldi	r19, 0x50	; 80
    11bc:	aa 24       	eor	r10, r10
    11be:	aa 94       	dec	r10
    11c0:	ac 01       	movw	r20, r24
    11c2:	f9 01       	movw	r30, r18
    11c4:	e8 0f       	add	r30, r24
    11c6:	f9 1f       	adc	r31, r25
    11c8:	60 81       	ld	r22, Z
    11ca:	66 23       	and	r22, r22
    11cc:	14 f4       	brge	.+4      	; 0x11d2 <__vector_14+0x7a>
    11ce:	ac 86       	std	Y+12, r10	; 0x0c
    11d0:	01 c0       	rjmp	.+2      	; 0x11d4 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    11d2:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    11d4:	42 0f       	add	r20, r18
    11d6:	53 1f       	adc	r21, r19
    11d8:	fa 01       	movw	r30, r20
    11da:	40 81       	ld	r20, Z
    11dc:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    11de:	fc 01       	movw	r30, r24
    11e0:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    11e2:	e2 0f       	add	r30, r18
    11e4:	f3 1f       	adc	r31, r19
    11e6:	40 81       	ld	r20, Z
    11e8:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    11ea:	fc 01       	movw	r30, r24
    11ec:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    11ee:	e2 0f       	add	r30, r18
    11f0:	f3 1f       	adc	r31, r19
    11f2:	40 81       	ld	r20, Z
    11f4:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    11f6:	49 85       	ldd	r20, Y+9	; 0x09
    11f8:	5a 85       	ldd	r21, Y+10	; 0x0a
    11fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    11fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    11fe:	b9 80       	ldd	r11, Y+1	; 0x01
    1200:	ca 80       	ldd	r12, Y+2	; 0x02
    1202:	db 80       	ldd	r13, Y+3	; 0x03
    1204:	ec 80       	ldd	r14, Y+4	; 0x04
    1206:	fd 80       	ldd	r15, Y+5	; 0x05
    1208:	0e 81       	ldd	r16, Y+6	; 0x06
    120a:	1f 81       	ldd	r17, Y+7	; 0x07
    120c:	88 84       	ldd	r8, Y+8	; 0x08
    120e:	b4 2f       	mov	r27, r20
    1210:	a5 2f       	mov	r26, r21
    1212:	f6 2f       	mov	r31, r22
    1214:	e7 2f       	mov	r30, r23
    1216:	77 0f       	add	r23, r23
    1218:	44 0b       	sbc	r20, r20
    121a:	54 2f       	mov	r21, r20
    121c:	ba 01       	movw	r22, r20
    121e:	64 2e       	mov	r6, r20
    1220:	74 2e       	mov	r7, r20
    1222:	94 2e       	mov	r9, r20
    1224:	bb 0e       	add	r11, r27
    1226:	61 e0       	ldi	r22, 0x01	; 1
    1228:	bb 16       	cp	r11, r27
    122a:	08 f0       	brcs	.+2      	; 0x122e <__vector_14+0xd6>
    122c:	60 e0       	ldi	r22, 0x00	; 0
    122e:	ca 0e       	add	r12, r26
    1230:	51 e0       	ldi	r21, 0x01	; 1
    1232:	ca 16       	cp	r12, r26
    1234:	08 f0       	brcs	.+2      	; 0x1238 <__vector_14+0xe0>
    1236:	50 e0       	ldi	r21, 0x00	; 0
    1238:	a6 2f       	mov	r26, r22
    123a:	ac 0d       	add	r26, r12
    123c:	61 e0       	ldi	r22, 0x01	; 1
    123e:	ac 15       	cp	r26, r12
    1240:	08 f0       	brcs	.+2      	; 0x1244 <__vector_14+0xec>
    1242:	60 e0       	ldi	r22, 0x00	; 0
    1244:	56 2b       	or	r21, r22
    1246:	df 0e       	add	r13, r31
    1248:	61 e0       	ldi	r22, 0x01	; 1
    124a:	df 16       	cp	r13, r31
    124c:	08 f0       	brcs	.+2      	; 0x1250 <__vector_14+0xf8>
    124e:	60 e0       	ldi	r22, 0x00	; 0
    1250:	f5 2f       	mov	r31, r21
    1252:	fd 0d       	add	r31, r13
    1254:	51 e0       	ldi	r21, 0x01	; 1
    1256:	fd 15       	cp	r31, r13
    1258:	08 f0       	brcs	.+2      	; 0x125c <__vector_14+0x104>
    125a:	50 e0       	ldi	r21, 0x00	; 0
    125c:	65 2b       	or	r22, r21
    125e:	ee 0e       	add	r14, r30
    1260:	51 e0       	ldi	r21, 0x01	; 1
    1262:	ee 16       	cp	r14, r30
    1264:	08 f0       	brcs	.+2      	; 0x1268 <__vector_14+0x110>
    1266:	50 e0       	ldi	r21, 0x00	; 0
    1268:	e6 2f       	mov	r30, r22
    126a:	ee 0d       	add	r30, r14
    126c:	61 e0       	ldi	r22, 0x01	; 1
    126e:	ee 15       	cp	r30, r14
    1270:	08 f0       	brcs	.+2      	; 0x1274 <__vector_14+0x11c>
    1272:	60 e0       	ldi	r22, 0x00	; 0
    1274:	56 2b       	or	r21, r22
    1276:	f6 0c       	add	r15, r6
    1278:	71 e0       	ldi	r23, 0x01	; 1
    127a:	f6 14       	cp	r15, r6
    127c:	08 f0       	brcs	.+2      	; 0x1280 <__vector_14+0x128>
    127e:	70 e0       	ldi	r23, 0x00	; 0
    1280:	b5 2f       	mov	r27, r21
    1282:	bf 0d       	add	r27, r15
    1284:	51 e0       	ldi	r21, 0x01	; 1
    1286:	bf 15       	cp	r27, r15
    1288:	08 f0       	brcs	.+2      	; 0x128c <__vector_14+0x134>
    128a:	50 e0       	ldi	r21, 0x00	; 0
    128c:	75 2b       	or	r23, r21
    128e:	07 0d       	add	r16, r7
    1290:	61 e0       	ldi	r22, 0x01	; 1
    1292:	07 15       	cp	r16, r7
    1294:	08 f0       	brcs	.+2      	; 0x1298 <__vector_14+0x140>
    1296:	60 e0       	ldi	r22, 0x00	; 0
    1298:	70 0f       	add	r23, r16
    129a:	51 e0       	ldi	r21, 0x01	; 1
    129c:	70 17       	cp	r23, r16
    129e:	08 f0       	brcs	.+2      	; 0x12a2 <__vector_14+0x14a>
    12a0:	50 e0       	ldi	r21, 0x00	; 0
    12a2:	65 2b       	or	r22, r21
    12a4:	19 0d       	add	r17, r9
    12a6:	51 e0       	ldi	r21, 0x01	; 1
    12a8:	19 15       	cp	r17, r9
    12aa:	08 f0       	brcs	.+2      	; 0x12ae <__vector_14+0x156>
    12ac:	50 e0       	ldi	r21, 0x00	; 0
    12ae:	61 0f       	add	r22, r17
    12b0:	01 e0       	ldi	r16, 0x01	; 1
    12b2:	61 17       	cp	r22, r17
    12b4:	08 f0       	brcs	.+2      	; 0x12b8 <__vector_14+0x160>
    12b6:	00 e0       	ldi	r16, 0x00	; 0
    12b8:	50 2b       	or	r21, r16
    12ba:	48 0d       	add	r20, r8
    12bc:	54 0f       	add	r21, r20
    12be:	b9 82       	std	Y+1, r11	; 0x01
    12c0:	aa 83       	std	Y+2, r26	; 0x02
    12c2:	fb 83       	std	Y+3, r31	; 0x03
    12c4:	ec 83       	std	Y+4, r30	; 0x04
    12c6:	bd 83       	std	Y+5, r27	; 0x05
    12c8:	7e 83       	std	Y+6, r23	; 0x06
    12ca:	6f 83       	std	Y+7, r22	; 0x07
    12cc:	58 87       	std	Y+8, r21	; 0x08
    12ce:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    12d0:	8c 30       	cpi	r24, 0x0C	; 12
    12d2:	91 05       	cpc	r25, r1
    12d4:	09 f0       	breq	.+2      	; 0x12d8 <__vector_14+0x180>
    12d6:	74 cf       	rjmp	.-280    	; 0x11c0 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    12d8:	e9 80       	ldd	r14, Y+1	; 0x01
    12da:	fa 80       	ldd	r15, Y+2	; 0x02
    12dc:	0b 81       	ldd	r16, Y+3	; 0x03
    12de:	1c 81       	ldd	r17, Y+4	; 0x04
    12e0:	bd 81       	ldd	r27, Y+5	; 0x05
    12e2:	ae 81       	ldd	r26, Y+6	; 0x06
    12e4:	ff 81       	ldd	r31, Y+7	; 0x07
    12e6:	e8 85       	ldd	r30, Y+8	; 0x08
    12e8:	2e 2d       	mov	r18, r14
    12ea:	3f 2d       	mov	r19, r15
    12ec:	40 2f       	mov	r20, r16
    12ee:	51 2f       	mov	r21, r17
    12f0:	6b 2f       	mov	r22, r27
    12f2:	7a 2f       	mov	r23, r26
    12f4:	8f 2f       	mov	r24, r31
    12f6:	9e 2f       	mov	r25, r30
    12f8:	ee 23       	and	r30, r30
    12fa:	0c f0       	brlt	.+2      	; 0x12fe <__vector_14+0x1a6>
    12fc:	4a c0       	rjmp	.+148    	; 0x1392 <__vector_14+0x23a>
    12fe:	93 e0       	ldi	r25, 0x03	; 3
    1300:	e9 0e       	add	r14, r25
    1302:	91 e0       	ldi	r25, 0x01	; 1
    1304:	e2 16       	cp	r14, r18
    1306:	08 f0       	brcs	.+2      	; 0x130a <__vector_14+0x1b2>
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	21 e0       	ldi	r18, 0x01	; 1
    130c:	f3 16       	cp	r15, r19
    130e:	08 f0       	brcs	.+2      	; 0x1312 <__vector_14+0x1ba>
    1310:	20 e0       	ldi	r18, 0x00	; 0
    1312:	39 2f       	mov	r19, r25
    1314:	3f 0d       	add	r19, r15
    1316:	91 e0       	ldi	r25, 0x01	; 1
    1318:	3f 15       	cp	r19, r15
    131a:	08 f0       	brcs	.+2      	; 0x131e <__vector_14+0x1c6>
    131c:	90 e0       	ldi	r25, 0x00	; 0
    131e:	29 2b       	or	r18, r25
    1320:	91 e0       	ldi	r25, 0x01	; 1
    1322:	04 17       	cp	r16, r20
    1324:	08 f0       	brcs	.+2      	; 0x1328 <__vector_14+0x1d0>
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	42 2f       	mov	r20, r18
    132a:	40 0f       	add	r20, r16
    132c:	21 e0       	ldi	r18, 0x01	; 1
    132e:	40 17       	cp	r20, r16
    1330:	08 f0       	brcs	.+2      	; 0x1334 <__vector_14+0x1dc>
    1332:	20 e0       	ldi	r18, 0x00	; 0
    1334:	92 2b       	or	r25, r18
    1336:	21 e0       	ldi	r18, 0x01	; 1
    1338:	15 17       	cp	r17, r21
    133a:	08 f0       	brcs	.+2      	; 0x133e <__vector_14+0x1e6>
    133c:	20 e0       	ldi	r18, 0x00	; 0
    133e:	59 2f       	mov	r21, r25
    1340:	51 0f       	add	r21, r17
    1342:	91 e0       	ldi	r25, 0x01	; 1
    1344:	51 17       	cp	r21, r17
    1346:	08 f0       	brcs	.+2      	; 0x134a <__vector_14+0x1f2>
    1348:	90 e0       	ldi	r25, 0x00	; 0
    134a:	29 2b       	or	r18, r25
    134c:	91 e0       	ldi	r25, 0x01	; 1
    134e:	b6 17       	cp	r27, r22
    1350:	08 f0       	brcs	.+2      	; 0x1354 <__vector_14+0x1fc>
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	62 2f       	mov	r22, r18
    1356:	6b 0f       	add	r22, r27
    1358:	21 e0       	ldi	r18, 0x01	; 1
    135a:	6b 17       	cp	r22, r27
    135c:	08 f0       	brcs	.+2      	; 0x1360 <__vector_14+0x208>
    135e:	20 e0       	ldi	r18, 0x00	; 0
    1360:	92 2b       	or	r25, r18
    1362:	21 e0       	ldi	r18, 0x01	; 1
    1364:	a7 17       	cp	r26, r23
    1366:	08 f0       	brcs	.+2      	; 0x136a <__vector_14+0x212>
    1368:	20 e0       	ldi	r18, 0x00	; 0
    136a:	79 2f       	mov	r23, r25
    136c:	7a 0f       	add	r23, r26
    136e:	91 e0       	ldi	r25, 0x01	; 1
    1370:	7a 17       	cp	r23, r26
    1372:	08 f0       	brcs	.+2      	; 0x1376 <__vector_14+0x21e>
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	29 2b       	or	r18, r25
    1378:	91 e0       	ldi	r25, 0x01	; 1
    137a:	f8 17       	cp	r31, r24
    137c:	08 f0       	brcs	.+2      	; 0x1380 <__vector_14+0x228>
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	82 2f       	mov	r24, r18
    1382:	8f 0f       	add	r24, r31
    1384:	21 e0       	ldi	r18, 0x01	; 1
    1386:	8f 17       	cp	r24, r31
    1388:	08 f0       	brcs	.+2      	; 0x138c <__vector_14+0x234>
    138a:	20 e0       	ldi	r18, 0x00	; 0
    138c:	92 2b       	or	r25, r18
    138e:	2e 2d       	mov	r18, r14
    1390:	9e 0f       	add	r25, r30
    1392:	02 e0       	ldi	r16, 0x02	; 2
    1394:	0e 94 68 30 	call	0x60d0	; 0x60d0 <__ashrdi3>
    1398:	29 83       	std	Y+1, r18	; 0x01
    139a:	3a 83       	std	Y+2, r19	; 0x02
    139c:	4b 83       	std	Y+3, r20	; 0x03
    139e:	5c 83       	std	Y+4, r21	; 0x04
    13a0:	6d 83       	std	Y+5, r22	; 0x05
    13a2:	7e 83       	std	Y+6, r23	; 0x06
    13a4:	8f 83       	std	Y+7, r24	; 0x07
    13a6:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    13a8:	80 90 74 50 	lds	r8, 0x5074
    13ac:	90 90 75 50 	lds	r9, 0x5075
    13b0:	a0 90 76 50 	lds	r10, 0x5076
    13b4:	b0 90 77 50 	lds	r11, 0x5077
    13b8:	29 81       	ldd	r18, Y+1	; 0x01
    13ba:	3a 81       	ldd	r19, Y+2	; 0x02
    13bc:	4b 81       	ldd	r20, Y+3	; 0x03
    13be:	5c 81       	ldd	r21, Y+4	; 0x04
    13c0:	6d 81       	ldd	r22, Y+5	; 0x05
    13c2:	7e 81       	ldd	r23, Y+6	; 0x06
    13c4:	8f 81       	ldd	r24, Y+7	; 0x07
    13c6:	98 85       	ldd	r25, Y+8	; 0x08
    13c8:	f4 01       	movw	r30, r8
    13ca:	ee 0f       	add	r30, r30
    13cc:	ff 1f       	adc	r31, r31
    13ce:	ee 0f       	add	r30, r30
    13d0:	ff 1f       	adc	r31, r31
    13d2:	80 90 72 50 	lds	r8, 0x5072
    13d6:	90 90 73 50 	lds	r9, 0x5073
    13da:	8e 0e       	add	r8, r30
    13dc:	9f 1e       	adc	r9, r31
    13de:	0f 2e       	mov	r0, r31
    13e0:	f0 ea       	ldi	r31, 0xA0	; 160
    13e2:	af 2e       	mov	r10, r31
    13e4:	f0 2d       	mov	r31, r0
    13e6:	0f 2e       	mov	r0, r31
    13e8:	f5 e2       	ldi	r31, 0x25	; 37
    13ea:	bf 2e       	mov	r11, r31
    13ec:	f0 2d       	mov	r31, r0
    13ee:	0f 2e       	mov	r0, r31
    13f0:	f6 e2       	ldi	r31, 0x26	; 38
    13f2:	cf 2e       	mov	r12, r31
    13f4:	f0 2d       	mov	r31, r0
    13f6:	dd 24       	eor	r13, r13
    13f8:	ee 24       	eor	r14, r14
    13fa:	ff 24       	eor	r15, r15
    13fc:	00 e0       	ldi	r16, 0x00	; 0
    13fe:	10 e0       	ldi	r17, 0x00	; 0
    1400:	0e 94 21 2f 	call	0x5e42	; 0x5e42 <__muldi3>
    1404:	aa 24       	eor	r10, r10
    1406:	aa 94       	dec	r10
    1408:	bb 24       	eor	r11, r11
    140a:	ba 94       	dec	r11
    140c:	0f 2e       	mov	r0, r31
    140e:	ff e7       	ldi	r31, 0x7F	; 127
    1410:	cf 2e       	mov	r12, r31
    1412:	f0 2d       	mov	r31, r0
    1414:	0e 94 d0 30 	call	0x61a0	; 0x61a0 <__divdi3>
    1418:	01 e0       	ldi	r16, 0x01	; 1
    141a:	0e 94 f4 2f 	call	0x5fe8	; 0x5fe8 <__ashldi3>
    141e:	0f 2e       	mov	r0, r31
    1420:	f3 e0       	ldi	r31, 0x03	; 3
    1422:	af 2e       	mov	r10, r31
    1424:	f0 2d       	mov	r31, r0
    1426:	bb 24       	eor	r11, r11
    1428:	cc 24       	eor	r12, r12
    142a:	00 e0       	ldi	r16, 0x00	; 0
    142c:	0e 94 d0 30 	call	0x61a0	; 0x61a0 <__divdi3>
    1430:	f4 01       	movw	r30, r8
    1432:	20 83       	st	Z, r18
    1434:	31 83       	std	Z+1, r19	; 0x01
    1436:	42 83       	std	Z+2, r20	; 0x02
    1438:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    143a:	80 91 74 50 	lds	r24, 0x5074
    143e:	90 91 75 50 	lds	r25, 0x5075
    1442:	a0 91 76 50 	lds	r26, 0x5076
    1446:	b0 91 77 50 	lds	r27, 0x5077
    144a:	01 96       	adiw	r24, 0x01	; 1
    144c:	a1 1d       	adc	r26, r1
    144e:	b1 1d       	adc	r27, r1
    1450:	80 93 74 50 	sts	0x5074, r24
    1454:	90 93 75 50 	sts	0x5075, r25
    1458:	a0 93 76 50 	sts	0x5076, r26
    145c:	b0 93 77 50 	sts	0x5077, r27

}
    1460:	2c 96       	adiw	r28, 0x0c	; 12
    1462:	cd bf       	out	0x3d, r28	; 61
    1464:	de bf       	out	0x3e, r29	; 62
    1466:	df 91       	pop	r29
    1468:	cf 91       	pop	r28
    146a:	ff 91       	pop	r31
    146c:	ef 91       	pop	r30
    146e:	bf 91       	pop	r27
    1470:	af 91       	pop	r26
    1472:	9f 91       	pop	r25
    1474:	8f 91       	pop	r24
    1476:	7f 91       	pop	r23
    1478:	6f 91       	pop	r22
    147a:	5f 91       	pop	r21
    147c:	4f 91       	pop	r20
    147e:	3f 91       	pop	r19
    1480:	2f 91       	pop	r18
    1482:	1f 91       	pop	r17
    1484:	0f 91       	pop	r16
    1486:	ff 90       	pop	r15
    1488:	ef 90       	pop	r14
    148a:	df 90       	pop	r13
    148c:	cf 90       	pop	r12
    148e:	bf 90       	pop	r11
    1490:	af 90       	pop	r10
    1492:	9f 90       	pop	r9
    1494:	8f 90       	pop	r8
    1496:	7f 90       	pop	r7
    1498:	6f 90       	pop	r6
    149a:	0f 90       	pop	r0
    149c:	0b be       	out	0x3b, r0	; 59
    149e:	0f 90       	pop	r0
    14a0:	0f be       	out	0x3f, r0	; 63
    14a2:	0f 90       	pop	r0
    14a4:	1f 90       	pop	r1
    14a6:	18 95       	reti

000014a8 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    14a8:	1f 92       	push	r1
    14aa:	0f 92       	push	r0
    14ac:	0f b6       	in	r0, 0x3f	; 63
    14ae:	0f 92       	push	r0
    14b0:	0b b6       	in	r0, 0x3b	; 59
    14b2:	0f 92       	push	r0
    14b4:	11 24       	eor	r1, r1
    14b6:	6f 92       	push	r6
    14b8:	7f 92       	push	r7
    14ba:	8f 92       	push	r8
    14bc:	9f 92       	push	r9
    14be:	af 92       	push	r10
    14c0:	bf 92       	push	r11
    14c2:	cf 92       	push	r12
    14c4:	df 92       	push	r13
    14c6:	ef 92       	push	r14
    14c8:	ff 92       	push	r15
    14ca:	0f 93       	push	r16
    14cc:	1f 93       	push	r17
    14ce:	2f 93       	push	r18
    14d0:	3f 93       	push	r19
    14d2:	4f 93       	push	r20
    14d4:	5f 93       	push	r21
    14d6:	6f 93       	push	r22
    14d8:	7f 93       	push	r23
    14da:	8f 93       	push	r24
    14dc:	9f 93       	push	r25
    14de:	af 93       	push	r26
    14e0:	bf 93       	push	r27
    14e2:	ef 93       	push	r30
    14e4:	ff 93       	push	r31
    14e6:	cf 93       	push	r28
    14e8:	df 93       	push	r29
    14ea:	cd b7       	in	r28, 0x3d	; 61
    14ec:	de b7       	in	r29, 0x3e	; 62
    14ee:	2c 97       	sbiw	r28, 0x0c	; 12
    14f0:	cd bf       	out	0x3d, r28	; 61
    14f2:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    14f4:	19 82       	std	Y+1, r1	; 0x01
    14f6:	1a 82       	std	Y+2, r1	; 0x02
    14f8:	1b 82       	std	Y+3, r1	; 0x03
    14fa:	1c 82       	std	Y+4, r1	; 0x04
    14fc:	1d 82       	std	Y+5, r1	; 0x05
    14fe:	1e 82       	std	Y+6, r1	; 0x06
    1500:	1f 82       	std	Y+7, r1	; 0x07
    1502:	18 86       	std	Y+8, r1	; 0x08
    1504:	80 e0       	ldi	r24, 0x00	; 0
    1506:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1508:	25 e6       	ldi	r18, 0x65	; 101
    150a:	30 e5       	ldi	r19, 0x50	; 80
    150c:	aa 24       	eor	r10, r10
    150e:	aa 94       	dec	r10
    1510:	ac 01       	movw	r20, r24
    1512:	f9 01       	movw	r30, r18
    1514:	e8 0f       	add	r30, r24
    1516:	f9 1f       	adc	r31, r25
    1518:	60 81       	ld	r22, Z
    151a:	66 23       	and	r22, r22
    151c:	14 f4       	brge	.+4      	; 0x1522 <__vector_77+0x7a>
    151e:	ac 86       	std	Y+12, r10	; 0x0c
    1520:	01 c0       	rjmp	.+2      	; 0x1524 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1522:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1524:	42 0f       	add	r20, r18
    1526:	53 1f       	adc	r21, r19
    1528:	fa 01       	movw	r30, r20
    152a:	40 81       	ld	r20, Z
    152c:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    152e:	fc 01       	movw	r30, r24
    1530:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1532:	e2 0f       	add	r30, r18
    1534:	f3 1f       	adc	r31, r19
    1536:	40 81       	ld	r20, Z
    1538:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    153a:	fc 01       	movw	r30, r24
    153c:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    153e:	e2 0f       	add	r30, r18
    1540:	f3 1f       	adc	r31, r19
    1542:	40 81       	ld	r20, Z
    1544:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1546:	49 85       	ldd	r20, Y+9	; 0x09
    1548:	5a 85       	ldd	r21, Y+10	; 0x0a
    154a:	6b 85       	ldd	r22, Y+11	; 0x0b
    154c:	7c 85       	ldd	r23, Y+12	; 0x0c
    154e:	b9 80       	ldd	r11, Y+1	; 0x01
    1550:	ca 80       	ldd	r12, Y+2	; 0x02
    1552:	db 80       	ldd	r13, Y+3	; 0x03
    1554:	ec 80       	ldd	r14, Y+4	; 0x04
    1556:	fd 80       	ldd	r15, Y+5	; 0x05
    1558:	0e 81       	ldd	r16, Y+6	; 0x06
    155a:	1f 81       	ldd	r17, Y+7	; 0x07
    155c:	88 84       	ldd	r8, Y+8	; 0x08
    155e:	b4 2f       	mov	r27, r20
    1560:	a5 2f       	mov	r26, r21
    1562:	f6 2f       	mov	r31, r22
    1564:	e7 2f       	mov	r30, r23
    1566:	77 0f       	add	r23, r23
    1568:	44 0b       	sbc	r20, r20
    156a:	54 2f       	mov	r21, r20
    156c:	ba 01       	movw	r22, r20
    156e:	64 2e       	mov	r6, r20
    1570:	74 2e       	mov	r7, r20
    1572:	94 2e       	mov	r9, r20
    1574:	bb 0e       	add	r11, r27
    1576:	61 e0       	ldi	r22, 0x01	; 1
    1578:	bb 16       	cp	r11, r27
    157a:	08 f0       	brcs	.+2      	; 0x157e <__vector_77+0xd6>
    157c:	60 e0       	ldi	r22, 0x00	; 0
    157e:	ca 0e       	add	r12, r26
    1580:	51 e0       	ldi	r21, 0x01	; 1
    1582:	ca 16       	cp	r12, r26
    1584:	08 f0       	brcs	.+2      	; 0x1588 <__vector_77+0xe0>
    1586:	50 e0       	ldi	r21, 0x00	; 0
    1588:	a6 2f       	mov	r26, r22
    158a:	ac 0d       	add	r26, r12
    158c:	61 e0       	ldi	r22, 0x01	; 1
    158e:	ac 15       	cp	r26, r12
    1590:	08 f0       	brcs	.+2      	; 0x1594 <__vector_77+0xec>
    1592:	60 e0       	ldi	r22, 0x00	; 0
    1594:	56 2b       	or	r21, r22
    1596:	df 0e       	add	r13, r31
    1598:	61 e0       	ldi	r22, 0x01	; 1
    159a:	df 16       	cp	r13, r31
    159c:	08 f0       	brcs	.+2      	; 0x15a0 <__vector_77+0xf8>
    159e:	60 e0       	ldi	r22, 0x00	; 0
    15a0:	f5 2f       	mov	r31, r21
    15a2:	fd 0d       	add	r31, r13
    15a4:	51 e0       	ldi	r21, 0x01	; 1
    15a6:	fd 15       	cp	r31, r13
    15a8:	08 f0       	brcs	.+2      	; 0x15ac <__vector_77+0x104>
    15aa:	50 e0       	ldi	r21, 0x00	; 0
    15ac:	65 2b       	or	r22, r21
    15ae:	ee 0e       	add	r14, r30
    15b0:	51 e0       	ldi	r21, 0x01	; 1
    15b2:	ee 16       	cp	r14, r30
    15b4:	08 f0       	brcs	.+2      	; 0x15b8 <__vector_77+0x110>
    15b6:	50 e0       	ldi	r21, 0x00	; 0
    15b8:	e6 2f       	mov	r30, r22
    15ba:	ee 0d       	add	r30, r14
    15bc:	61 e0       	ldi	r22, 0x01	; 1
    15be:	ee 15       	cp	r30, r14
    15c0:	08 f0       	brcs	.+2      	; 0x15c4 <__vector_77+0x11c>
    15c2:	60 e0       	ldi	r22, 0x00	; 0
    15c4:	56 2b       	or	r21, r22
    15c6:	f6 0c       	add	r15, r6
    15c8:	71 e0       	ldi	r23, 0x01	; 1
    15ca:	f6 14       	cp	r15, r6
    15cc:	08 f0       	brcs	.+2      	; 0x15d0 <__vector_77+0x128>
    15ce:	70 e0       	ldi	r23, 0x00	; 0
    15d0:	b5 2f       	mov	r27, r21
    15d2:	bf 0d       	add	r27, r15
    15d4:	51 e0       	ldi	r21, 0x01	; 1
    15d6:	bf 15       	cp	r27, r15
    15d8:	08 f0       	brcs	.+2      	; 0x15dc <__vector_77+0x134>
    15da:	50 e0       	ldi	r21, 0x00	; 0
    15dc:	75 2b       	or	r23, r21
    15de:	07 0d       	add	r16, r7
    15e0:	61 e0       	ldi	r22, 0x01	; 1
    15e2:	07 15       	cp	r16, r7
    15e4:	08 f0       	brcs	.+2      	; 0x15e8 <__vector_77+0x140>
    15e6:	60 e0       	ldi	r22, 0x00	; 0
    15e8:	70 0f       	add	r23, r16
    15ea:	51 e0       	ldi	r21, 0x01	; 1
    15ec:	70 17       	cp	r23, r16
    15ee:	08 f0       	brcs	.+2      	; 0x15f2 <__vector_77+0x14a>
    15f0:	50 e0       	ldi	r21, 0x00	; 0
    15f2:	65 2b       	or	r22, r21
    15f4:	19 0d       	add	r17, r9
    15f6:	51 e0       	ldi	r21, 0x01	; 1
    15f8:	19 15       	cp	r17, r9
    15fa:	08 f0       	brcs	.+2      	; 0x15fe <__vector_77+0x156>
    15fc:	50 e0       	ldi	r21, 0x00	; 0
    15fe:	61 0f       	add	r22, r17
    1600:	01 e0       	ldi	r16, 0x01	; 1
    1602:	61 17       	cp	r22, r17
    1604:	08 f0       	brcs	.+2      	; 0x1608 <__vector_77+0x160>
    1606:	00 e0       	ldi	r16, 0x00	; 0
    1608:	50 2b       	or	r21, r16
    160a:	48 0d       	add	r20, r8
    160c:	54 0f       	add	r21, r20
    160e:	b9 82       	std	Y+1, r11	; 0x01
    1610:	aa 83       	std	Y+2, r26	; 0x02
    1612:	fb 83       	std	Y+3, r31	; 0x03
    1614:	ec 83       	std	Y+4, r30	; 0x04
    1616:	bd 83       	std	Y+5, r27	; 0x05
    1618:	7e 83       	std	Y+6, r23	; 0x06
    161a:	6f 83       	std	Y+7, r22	; 0x07
    161c:	58 87       	std	Y+8, r21	; 0x08
    161e:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1620:	8c 30       	cpi	r24, 0x0C	; 12
    1622:	91 05       	cpc	r25, r1
    1624:	09 f0       	breq	.+2      	; 0x1628 <__vector_77+0x180>
    1626:	74 cf       	rjmp	.-280    	; 0x1510 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1628:	e9 80       	ldd	r14, Y+1	; 0x01
    162a:	fa 80       	ldd	r15, Y+2	; 0x02
    162c:	0b 81       	ldd	r16, Y+3	; 0x03
    162e:	1c 81       	ldd	r17, Y+4	; 0x04
    1630:	bd 81       	ldd	r27, Y+5	; 0x05
    1632:	ae 81       	ldd	r26, Y+6	; 0x06
    1634:	ff 81       	ldd	r31, Y+7	; 0x07
    1636:	e8 85       	ldd	r30, Y+8	; 0x08
    1638:	2e 2d       	mov	r18, r14
    163a:	3f 2d       	mov	r19, r15
    163c:	40 2f       	mov	r20, r16
    163e:	51 2f       	mov	r21, r17
    1640:	6b 2f       	mov	r22, r27
    1642:	7a 2f       	mov	r23, r26
    1644:	8f 2f       	mov	r24, r31
    1646:	9e 2f       	mov	r25, r30
    1648:	ee 23       	and	r30, r30
    164a:	0c f0       	brlt	.+2      	; 0x164e <__vector_77+0x1a6>
    164c:	4a c0       	rjmp	.+148    	; 0x16e2 <__vector_77+0x23a>
    164e:	93 e0       	ldi	r25, 0x03	; 3
    1650:	e9 0e       	add	r14, r25
    1652:	91 e0       	ldi	r25, 0x01	; 1
    1654:	e2 16       	cp	r14, r18
    1656:	08 f0       	brcs	.+2      	; 0x165a <__vector_77+0x1b2>
    1658:	90 e0       	ldi	r25, 0x00	; 0
    165a:	21 e0       	ldi	r18, 0x01	; 1
    165c:	f3 16       	cp	r15, r19
    165e:	08 f0       	brcs	.+2      	; 0x1662 <__vector_77+0x1ba>
    1660:	20 e0       	ldi	r18, 0x00	; 0
    1662:	39 2f       	mov	r19, r25
    1664:	3f 0d       	add	r19, r15
    1666:	91 e0       	ldi	r25, 0x01	; 1
    1668:	3f 15       	cp	r19, r15
    166a:	08 f0       	brcs	.+2      	; 0x166e <__vector_77+0x1c6>
    166c:	90 e0       	ldi	r25, 0x00	; 0
    166e:	29 2b       	or	r18, r25
    1670:	91 e0       	ldi	r25, 0x01	; 1
    1672:	04 17       	cp	r16, r20
    1674:	08 f0       	brcs	.+2      	; 0x1678 <__vector_77+0x1d0>
    1676:	90 e0       	ldi	r25, 0x00	; 0
    1678:	42 2f       	mov	r20, r18
    167a:	40 0f       	add	r20, r16
    167c:	21 e0       	ldi	r18, 0x01	; 1
    167e:	40 17       	cp	r20, r16
    1680:	08 f0       	brcs	.+2      	; 0x1684 <__vector_77+0x1dc>
    1682:	20 e0       	ldi	r18, 0x00	; 0
    1684:	92 2b       	or	r25, r18
    1686:	21 e0       	ldi	r18, 0x01	; 1
    1688:	15 17       	cp	r17, r21
    168a:	08 f0       	brcs	.+2      	; 0x168e <__vector_77+0x1e6>
    168c:	20 e0       	ldi	r18, 0x00	; 0
    168e:	59 2f       	mov	r21, r25
    1690:	51 0f       	add	r21, r17
    1692:	91 e0       	ldi	r25, 0x01	; 1
    1694:	51 17       	cp	r21, r17
    1696:	08 f0       	brcs	.+2      	; 0x169a <__vector_77+0x1f2>
    1698:	90 e0       	ldi	r25, 0x00	; 0
    169a:	29 2b       	or	r18, r25
    169c:	91 e0       	ldi	r25, 0x01	; 1
    169e:	b6 17       	cp	r27, r22
    16a0:	08 f0       	brcs	.+2      	; 0x16a4 <__vector_77+0x1fc>
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	62 2f       	mov	r22, r18
    16a6:	6b 0f       	add	r22, r27
    16a8:	21 e0       	ldi	r18, 0x01	; 1
    16aa:	6b 17       	cp	r22, r27
    16ac:	08 f0       	brcs	.+2      	; 0x16b0 <__vector_77+0x208>
    16ae:	20 e0       	ldi	r18, 0x00	; 0
    16b0:	92 2b       	or	r25, r18
    16b2:	21 e0       	ldi	r18, 0x01	; 1
    16b4:	a7 17       	cp	r26, r23
    16b6:	08 f0       	brcs	.+2      	; 0x16ba <__vector_77+0x212>
    16b8:	20 e0       	ldi	r18, 0x00	; 0
    16ba:	79 2f       	mov	r23, r25
    16bc:	7a 0f       	add	r23, r26
    16be:	91 e0       	ldi	r25, 0x01	; 1
    16c0:	7a 17       	cp	r23, r26
    16c2:	08 f0       	brcs	.+2      	; 0x16c6 <__vector_77+0x21e>
    16c4:	90 e0       	ldi	r25, 0x00	; 0
    16c6:	29 2b       	or	r18, r25
    16c8:	91 e0       	ldi	r25, 0x01	; 1
    16ca:	f8 17       	cp	r31, r24
    16cc:	08 f0       	brcs	.+2      	; 0x16d0 <__vector_77+0x228>
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	82 2f       	mov	r24, r18
    16d2:	8f 0f       	add	r24, r31
    16d4:	21 e0       	ldi	r18, 0x01	; 1
    16d6:	8f 17       	cp	r24, r31
    16d8:	08 f0       	brcs	.+2      	; 0x16dc <__vector_77+0x234>
    16da:	20 e0       	ldi	r18, 0x00	; 0
    16dc:	92 2b       	or	r25, r18
    16de:	2e 2d       	mov	r18, r14
    16e0:	9e 0f       	add	r25, r30
    16e2:	02 e0       	ldi	r16, 0x02	; 2
    16e4:	0e 94 68 30 	call	0x60d0	; 0x60d0 <__ashrdi3>
    16e8:	29 83       	std	Y+1, r18	; 0x01
    16ea:	3a 83       	std	Y+2, r19	; 0x02
    16ec:	4b 83       	std	Y+3, r20	; 0x03
    16ee:	5c 83       	std	Y+4, r21	; 0x04
    16f0:	6d 83       	std	Y+5, r22	; 0x05
    16f2:	7e 83       	std	Y+6, r23	; 0x06
    16f4:	8f 83       	std	Y+7, r24	; 0x07
    16f6:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    16f8:	80 90 74 50 	lds	r8, 0x5074
    16fc:	90 90 75 50 	lds	r9, 0x5075
    1700:	a0 90 76 50 	lds	r10, 0x5076
    1704:	b0 90 77 50 	lds	r11, 0x5077
    1708:	29 81       	ldd	r18, Y+1	; 0x01
    170a:	3a 81       	ldd	r19, Y+2	; 0x02
    170c:	4b 81       	ldd	r20, Y+3	; 0x03
    170e:	5c 81       	ldd	r21, Y+4	; 0x04
    1710:	6d 81       	ldd	r22, Y+5	; 0x05
    1712:	7e 81       	ldd	r23, Y+6	; 0x06
    1714:	8f 81       	ldd	r24, Y+7	; 0x07
    1716:	98 85       	ldd	r25, Y+8	; 0x08
    1718:	f4 01       	movw	r30, r8
    171a:	ee 0f       	add	r30, r30
    171c:	ff 1f       	adc	r31, r31
    171e:	ee 0f       	add	r30, r30
    1720:	ff 1f       	adc	r31, r31
    1722:	80 90 72 50 	lds	r8, 0x5072
    1726:	90 90 73 50 	lds	r9, 0x5073
    172a:	8e 0e       	add	r8, r30
    172c:	9f 1e       	adc	r9, r31
    172e:	0f 2e       	mov	r0, r31
    1730:	f0 ea       	ldi	r31, 0xA0	; 160
    1732:	af 2e       	mov	r10, r31
    1734:	f0 2d       	mov	r31, r0
    1736:	0f 2e       	mov	r0, r31
    1738:	f5 e2       	ldi	r31, 0x25	; 37
    173a:	bf 2e       	mov	r11, r31
    173c:	f0 2d       	mov	r31, r0
    173e:	0f 2e       	mov	r0, r31
    1740:	f6 e2       	ldi	r31, 0x26	; 38
    1742:	cf 2e       	mov	r12, r31
    1744:	f0 2d       	mov	r31, r0
    1746:	dd 24       	eor	r13, r13
    1748:	ee 24       	eor	r14, r14
    174a:	ff 24       	eor	r15, r15
    174c:	00 e0       	ldi	r16, 0x00	; 0
    174e:	10 e0       	ldi	r17, 0x00	; 0
    1750:	0e 94 21 2f 	call	0x5e42	; 0x5e42 <__muldi3>
    1754:	aa 24       	eor	r10, r10
    1756:	aa 94       	dec	r10
    1758:	bb 24       	eor	r11, r11
    175a:	ba 94       	dec	r11
    175c:	0f 2e       	mov	r0, r31
    175e:	ff e7       	ldi	r31, 0x7F	; 127
    1760:	cf 2e       	mov	r12, r31
    1762:	f0 2d       	mov	r31, r0
    1764:	0e 94 d0 30 	call	0x61a0	; 0x61a0 <__divdi3>
    1768:	01 e0       	ldi	r16, 0x01	; 1
    176a:	0e 94 f4 2f 	call	0x5fe8	; 0x5fe8 <__ashldi3>
    176e:	0f 2e       	mov	r0, r31
    1770:	f3 e0       	ldi	r31, 0x03	; 3
    1772:	af 2e       	mov	r10, r31
    1774:	f0 2d       	mov	r31, r0
    1776:	bb 24       	eor	r11, r11
    1778:	cc 24       	eor	r12, r12
    177a:	00 e0       	ldi	r16, 0x00	; 0
    177c:	0e 94 d0 30 	call	0x61a0	; 0x61a0 <__divdi3>
    1780:	f4 01       	movw	r30, r8
    1782:	20 83       	st	Z, r18
    1784:	31 83       	std	Z+1, r19	; 0x01
    1786:	42 83       	std	Z+2, r20	; 0x02
    1788:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    178a:	80 91 74 50 	lds	r24, 0x5074
    178e:	90 91 75 50 	lds	r25, 0x5075
    1792:	a0 91 76 50 	lds	r26, 0x5076
    1796:	b0 91 77 50 	lds	r27, 0x5077
    179a:	01 96       	adiw	r24, 0x01	; 1
    179c:	a1 1d       	adc	r26, r1
    179e:	b1 1d       	adc	r27, r1
    17a0:	80 93 74 50 	sts	0x5074, r24
    17a4:	90 93 75 50 	sts	0x5075, r25
    17a8:	a0 93 76 50 	sts	0x5076, r26
    17ac:	b0 93 77 50 	sts	0x5077, r27
}
    17b0:	2c 96       	adiw	r28, 0x0c	; 12
    17b2:	cd bf       	out	0x3d, r28	; 61
    17b4:	de bf       	out	0x3e, r29	; 62
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
    17ba:	ff 91       	pop	r31
    17bc:	ef 91       	pop	r30
    17be:	bf 91       	pop	r27
    17c0:	af 91       	pop	r26
    17c2:	9f 91       	pop	r25
    17c4:	8f 91       	pop	r24
    17c6:	7f 91       	pop	r23
    17c8:	6f 91       	pop	r22
    17ca:	5f 91       	pop	r21
    17cc:	4f 91       	pop	r20
    17ce:	3f 91       	pop	r19
    17d0:	2f 91       	pop	r18
    17d2:	1f 91       	pop	r17
    17d4:	0f 91       	pop	r16
    17d6:	ff 90       	pop	r15
    17d8:	ef 90       	pop	r14
    17da:	df 90       	pop	r13
    17dc:	cf 90       	pop	r12
    17de:	bf 90       	pop	r11
    17e0:	af 90       	pop	r10
    17e2:	9f 90       	pop	r9
    17e4:	8f 90       	pop	r8
    17e6:	7f 90       	pop	r7
    17e8:	6f 90       	pop	r6
    17ea:	0f 90       	pop	r0
    17ec:	0b be       	out	0x3b, r0	; 59
    17ee:	0f 90       	pop	r0
    17f0:	0f be       	out	0x3f, r0	; 63
    17f2:	0f 90       	pop	r0
    17f4:	1f 90       	pop	r1
    17f6:	18 95       	reti

000017f8 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    17f8:	82 e0       	ldi	r24, 0x02	; 2
    17fa:	e0 ea       	ldi	r30, 0xA0	; 160
    17fc:	f6 e0       	ldi	r31, 0x06	; 6
    17fe:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1800:	8a ea       	ldi	r24, 0xAA	; 170
    1802:	e0 ec       	ldi	r30, 0xC0	; 192
    1804:	f8 e0       	ldi	r31, 0x08	; 8
    1806:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1808:	82 81       	ldd	r24, Z+2	; 0x02
    180a:	88 23       	and	r24, r24
    180c:	ec f7       	brge	.-6      	; 0x1808 <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    180e:	90 91 c6 50 	lds	r25, 0x50C6
    1812:	e0 ec       	ldi	r30, 0xC0	; 192
    1814:	f8 e0       	ldi	r31, 0x08	; 8
    1816:	83 81       	ldd	r24, Z+3	; 0x03
    1818:	a5 e6       	ldi	r26, 0x65	; 101
    181a:	b0 e5       	ldi	r27, 0x50	; 80
    181c:	a9 0f       	add	r26, r25
    181e:	b1 1d       	adc	r27, r1
    1820:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1822:	8a ea       	ldi	r24, 0xAA	; 170
    1824:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1826:	82 81       	ldd	r24, Z+2	; 0x02
    1828:	88 23       	and	r24, r24
    182a:	ec f7       	brge	.-6      	; 0x1826 <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    182c:	a0 91 c6 50 	lds	r26, 0x50C6
    1830:	b0 e0       	ldi	r27, 0x00	; 0
    1832:	e0 ec       	ldi	r30, 0xC0	; 192
    1834:	f8 e0       	ldi	r31, 0x08	; 8
    1836:	83 81       	ldd	r24, Z+3	; 0x03
    1838:	aa 59       	subi	r26, 0x9A	; 154
    183a:	bf 4a       	sbci	r27, 0xAF	; 175
    183c:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    183e:	8a ea       	ldi	r24, 0xAA	; 170
    1840:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1842:	82 81       	ldd	r24, Z+2	; 0x02
    1844:	88 23       	and	r24, r24
    1846:	ec f7       	brge	.-6      	; 0x1842 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    1848:	e0 91 c6 50 	lds	r30, 0x50C6
    184c:	f0 e0       	ldi	r31, 0x00	; 0
    184e:	a0 ec       	ldi	r26, 0xC0	; 192
    1850:	b8 e0       	ldi	r27, 0x08	; 8
    1852:	13 96       	adiw	r26, 0x03	; 3
    1854:	8c 91       	ld	r24, X
    1856:	13 97       	sbiw	r26, 0x03	; 3
    1858:	e9 59       	subi	r30, 0x99	; 153
    185a:	ff 4a       	sbci	r31, 0xAF	; 175
    185c:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    185e:	82 e0       	ldi	r24, 0x02	; 2
    1860:	e0 ea       	ldi	r30, 0xA0	; 160
    1862:	f6 e0       	ldi	r31, 0x06	; 6
    1864:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    1866:	80 91 c6 50 	lds	r24, 0x50C6
    186a:	8d 5f       	subi	r24, 0xFD	; 253
    186c:	80 93 c6 50 	sts	0x50C6, r24
}
    1870:	08 95       	ret

00001872 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    1872:	1f 92       	push	r1
    1874:	0f 92       	push	r0
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	0f 92       	push	r0
    187a:	0b b6       	in	r0, 0x3b	; 59
    187c:	0f 92       	push	r0
    187e:	11 24       	eor	r1, r1
    1880:	2f 93       	push	r18
    1882:	3f 93       	push	r19
    1884:	4f 93       	push	r20
    1886:	5f 93       	push	r21
    1888:	6f 93       	push	r22
    188a:	7f 93       	push	r23
    188c:	8f 93       	push	r24
    188e:	9f 93       	push	r25
    1890:	af 93       	push	r26
    1892:	bf 93       	push	r27
    1894:	ef 93       	push	r30
    1896:	ff 93       	push	r31
	sampleCurrentChannel();
    1898:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
	SPICount = 0;
    189c:	10 92 c6 50 	sts	0x50C6, r1
}
    18a0:	ff 91       	pop	r31
    18a2:	ef 91       	pop	r30
    18a4:	bf 91       	pop	r27
    18a6:	af 91       	pop	r26
    18a8:	9f 91       	pop	r25
    18aa:	8f 91       	pop	r24
    18ac:	7f 91       	pop	r23
    18ae:	6f 91       	pop	r22
    18b0:	5f 91       	pop	r21
    18b2:	4f 91       	pop	r20
    18b4:	3f 91       	pop	r19
    18b6:	2f 91       	pop	r18
    18b8:	0f 90       	pop	r0
    18ba:	0b be       	out	0x3b, r0	; 59
    18bc:	0f 90       	pop	r0
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	0f 90       	pop	r0
    18c2:	1f 90       	pop	r1
    18c4:	18 95       	reti

000018c6 <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    18c6:	1f 92       	push	r1
    18c8:	0f 92       	push	r0
    18ca:	0f b6       	in	r0, 0x3f	; 63
    18cc:	0f 92       	push	r0
    18ce:	0b b6       	in	r0, 0x3b	; 59
    18d0:	0f 92       	push	r0
    18d2:	11 24       	eor	r1, r1
    18d4:	2f 93       	push	r18
    18d6:	3f 93       	push	r19
    18d8:	4f 93       	push	r20
    18da:	5f 93       	push	r21
    18dc:	6f 93       	push	r22
    18de:	7f 93       	push	r23
    18e0:	8f 93       	push	r24
    18e2:	9f 93       	push	r25
    18e4:	af 93       	push	r26
    18e6:	bf 93       	push	r27
    18e8:	ef 93       	push	r30
    18ea:	ff 93       	push	r31
	sampleCurrentChannel();
    18ec:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
}
    18f0:	ff 91       	pop	r31
    18f2:	ef 91       	pop	r30
    18f4:	bf 91       	pop	r27
    18f6:	af 91       	pop	r26
    18f8:	9f 91       	pop	r25
    18fa:	8f 91       	pop	r24
    18fc:	7f 91       	pop	r23
    18fe:	6f 91       	pop	r22
    1900:	5f 91       	pop	r21
    1902:	4f 91       	pop	r20
    1904:	3f 91       	pop	r19
    1906:	2f 91       	pop	r18
    1908:	0f 90       	pop	r0
    190a:	0b be       	out	0x3b, r0	; 59
    190c:	0f 90       	pop	r0
    190e:	0f be       	out	0x3f, r0	; 63
    1910:	0f 90       	pop	r0
    1912:	1f 90       	pop	r1
    1914:	18 95       	reti

00001916 <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    1916:	1f 92       	push	r1
    1918:	0f 92       	push	r0
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	0f 92       	push	r0
    191e:	0b b6       	in	r0, 0x3b	; 59
    1920:	0f 92       	push	r0
    1922:	11 24       	eor	r1, r1
    1924:	2f 93       	push	r18
    1926:	3f 93       	push	r19
    1928:	4f 93       	push	r20
    192a:	5f 93       	push	r21
    192c:	6f 93       	push	r22
    192e:	7f 93       	push	r23
    1930:	8f 93       	push	r24
    1932:	9f 93       	push	r25
    1934:	af 93       	push	r26
    1936:	bf 93       	push	r27
    1938:	ef 93       	push	r30
    193a:	ff 93       	push	r31
	sampleCurrentChannel();
    193c:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
}
    1940:	ff 91       	pop	r31
    1942:	ef 91       	pop	r30
    1944:	bf 91       	pop	r27
    1946:	af 91       	pop	r26
    1948:	9f 91       	pop	r25
    194a:	8f 91       	pop	r24
    194c:	7f 91       	pop	r23
    194e:	6f 91       	pop	r22
    1950:	5f 91       	pop	r21
    1952:	4f 91       	pop	r20
    1954:	3f 91       	pop	r19
    1956:	2f 91       	pop	r18
    1958:	0f 90       	pop	r0
    195a:	0b be       	out	0x3b, r0	; 59
    195c:	0f 90       	pop	r0
    195e:	0f be       	out	0x3f, r0	; 63
    1960:	0f 90       	pop	r0
    1962:	1f 90       	pop	r1
    1964:	18 95       	reti

00001966 <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    1966:	1f 92       	push	r1
    1968:	0f 92       	push	r0
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	0f 92       	push	r0
    196e:	0b b6       	in	r0, 0x3b	; 59
    1970:	0f 92       	push	r0
    1972:	11 24       	eor	r1, r1
    1974:	2f 93       	push	r18
    1976:	3f 93       	push	r19
    1978:	4f 93       	push	r20
    197a:	5f 93       	push	r21
    197c:	6f 93       	push	r22
    197e:	7f 93       	push	r23
    1980:	8f 93       	push	r24
    1982:	9f 93       	push	r25
    1984:	af 93       	push	r26
    1986:	bf 93       	push	r27
    1988:	ef 93       	push	r30
    198a:	ff 93       	push	r31
	sampleCurrentChannel();
    198c:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
}
    1990:	ff 91       	pop	r31
    1992:	ef 91       	pop	r30
    1994:	bf 91       	pop	r27
    1996:	af 91       	pop	r26
    1998:	9f 91       	pop	r25
    199a:	8f 91       	pop	r24
    199c:	7f 91       	pop	r23
    199e:	6f 91       	pop	r22
    19a0:	5f 91       	pop	r21
    19a2:	4f 91       	pop	r20
    19a4:	3f 91       	pop	r19
    19a6:	2f 91       	pop	r18
    19a8:	0f 90       	pop	r0
    19aa:	0b be       	out	0x3b, r0	; 59
    19ac:	0f 90       	pop	r0
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	0f 90       	pop	r0
    19b2:	1f 90       	pop	r1
    19b4:	18 95       	reti

000019b6 <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    19b6:	1f 92       	push	r1
    19b8:	0f 92       	push	r0
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	0f 92       	push	r0
    19be:	0b b6       	in	r0, 0x3b	; 59
    19c0:	0f 92       	push	r0
    19c2:	11 24       	eor	r1, r1
    19c4:	2f 93       	push	r18
    19c6:	3f 93       	push	r19
    19c8:	4f 93       	push	r20
    19ca:	5f 93       	push	r21
    19cc:	6f 93       	push	r22
    19ce:	7f 93       	push	r23
    19d0:	8f 93       	push	r24
    19d2:	9f 93       	push	r25
    19d4:	af 93       	push	r26
    19d6:	bf 93       	push	r27
    19d8:	ef 93       	push	r30
    19da:	ff 93       	push	r31
	sampleCurrentChannel();
    19dc:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
	SPICount = 0;
    19e0:	10 92 c6 50 	sts	0x50C6, r1
	if(PORTB.OUT & PIN1_bm) {
    19e4:	e0 e2       	ldi	r30, 0x20	; 32
    19e6:	f6 e0       	ldi	r31, 0x06	; 6
    19e8:	84 81       	ldd	r24, Z+4	; 0x04
    19ea:	81 ff       	sbrs	r24, 1
    19ec:	0f c0       	rjmp	.+30     	; 0x1a0c <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    19ee:	e0 e0       	ldi	r30, 0x00	; 0
    19f0:	f6 e0       	ldi	r31, 0x06	; 6
    19f2:	84 81       	ldd	r24, Z+4	; 0x04
    19f4:	86 ff       	sbrs	r24, 6
    19f6:	05 c0       	rjmp	.+10     	; 0x1a02 <__vector_19+0x4c>
    19f8:	82 e0       	ldi	r24, 0x02	; 2
    19fa:	e0 e2       	ldi	r30, 0x20	; 32
    19fc:	f6 e0       	ldi	r31, 0x06	; 6
    19fe:	87 83       	std	Z+7, r24	; 0x07
    1a00:	0d c0       	rjmp	.+26     	; 0x1a1c <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    1a02:	80 e4       	ldi	r24, 0x40	; 64
    1a04:	e0 e0       	ldi	r30, 0x00	; 0
    1a06:	f6 e0       	ldi	r31, 0x06	; 6
    1a08:	87 83       	std	Z+7, r24	; 0x07
    1a0a:	08 c0       	rjmp	.+16     	; 0x1a1c <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    1a0c:	80 e4       	ldi	r24, 0x40	; 64
    1a0e:	e0 e0       	ldi	r30, 0x00	; 0
    1a10:	f6 e0       	ldi	r31, 0x06	; 6
    1a12:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    1a14:	82 e0       	ldi	r24, 0x02	; 2
    1a16:	e0 e2       	ldi	r30, 0x20	; 32
    1a18:	f6 e0       	ldi	r31, 0x06	; 6
    1a1a:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    1a1c:	ff 91       	pop	r31
    1a1e:	ef 91       	pop	r30
    1a20:	bf 91       	pop	r27
    1a22:	af 91       	pop	r26
    1a24:	9f 91       	pop	r25
    1a26:	8f 91       	pop	r24
    1a28:	7f 91       	pop	r23
    1a2a:	6f 91       	pop	r22
    1a2c:	5f 91       	pop	r21
    1a2e:	4f 91       	pop	r20
    1a30:	3f 91       	pop	r19
    1a32:	2f 91       	pop	r18
    1a34:	0f 90       	pop	r0
    1a36:	0b be       	out	0x3b, r0	; 59
    1a38:	0f 90       	pop	r0
    1a3a:	0f be       	out	0x3f, r0	; 63
    1a3c:	0f 90       	pop	r0
    1a3e:	1f 90       	pop	r1
    1a40:	18 95       	reti

00001a42 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    1a42:	1f 92       	push	r1
    1a44:	0f 92       	push	r0
    1a46:	0f b6       	in	r0, 0x3f	; 63
    1a48:	0f 92       	push	r0
    1a4a:	0b b6       	in	r0, 0x3b	; 59
    1a4c:	0f 92       	push	r0
    1a4e:	11 24       	eor	r1, r1
    1a50:	2f 93       	push	r18
    1a52:	3f 93       	push	r19
    1a54:	4f 93       	push	r20
    1a56:	5f 93       	push	r21
    1a58:	6f 93       	push	r22
    1a5a:	7f 93       	push	r23
    1a5c:	8f 93       	push	r24
    1a5e:	9f 93       	push	r25
    1a60:	af 93       	push	r26
    1a62:	bf 93       	push	r27
    1a64:	ef 93       	push	r30
    1a66:	ff 93       	push	r31
	sampleCurrentChannel();
    1a68:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
}
    1a6c:	ff 91       	pop	r31
    1a6e:	ef 91       	pop	r30
    1a70:	bf 91       	pop	r27
    1a72:	af 91       	pop	r26
    1a74:	9f 91       	pop	r25
    1a76:	8f 91       	pop	r24
    1a78:	7f 91       	pop	r23
    1a7a:	6f 91       	pop	r22
    1a7c:	5f 91       	pop	r21
    1a7e:	4f 91       	pop	r20
    1a80:	3f 91       	pop	r19
    1a82:	2f 91       	pop	r18
    1a84:	0f 90       	pop	r0
    1a86:	0b be       	out	0x3b, r0	; 59
    1a88:	0f 90       	pop	r0
    1a8a:	0f be       	out	0x3f, r0	; 63
    1a8c:	0f 90       	pop	r0
    1a8e:	1f 90       	pop	r1
    1a90:	18 95       	reti

00001a92 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    1a92:	1f 92       	push	r1
    1a94:	0f 92       	push	r0
    1a96:	0f b6       	in	r0, 0x3f	; 63
    1a98:	0f 92       	push	r0
    1a9a:	0b b6       	in	r0, 0x3b	; 59
    1a9c:	0f 92       	push	r0
    1a9e:	11 24       	eor	r1, r1
    1aa0:	2f 93       	push	r18
    1aa2:	3f 93       	push	r19
    1aa4:	4f 93       	push	r20
    1aa6:	5f 93       	push	r21
    1aa8:	6f 93       	push	r22
    1aaa:	7f 93       	push	r23
    1aac:	8f 93       	push	r24
    1aae:	9f 93       	push	r25
    1ab0:	af 93       	push	r26
    1ab2:	bf 93       	push	r27
    1ab4:	ef 93       	push	r30
    1ab6:	ff 93       	push	r31
	sampleCurrentChannel();
    1ab8:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
}
    1abc:	ff 91       	pop	r31
    1abe:	ef 91       	pop	r30
    1ac0:	bf 91       	pop	r27
    1ac2:	af 91       	pop	r26
    1ac4:	9f 91       	pop	r25
    1ac6:	8f 91       	pop	r24
    1ac8:	7f 91       	pop	r23
    1aca:	6f 91       	pop	r22
    1acc:	5f 91       	pop	r21
    1ace:	4f 91       	pop	r20
    1ad0:	3f 91       	pop	r19
    1ad2:	2f 91       	pop	r18
    1ad4:	0f 90       	pop	r0
    1ad6:	0b be       	out	0x3b, r0	; 59
    1ad8:	0f 90       	pop	r0
    1ada:	0f be       	out	0x3f, r0	; 63
    1adc:	0f 90       	pop	r0
    1ade:	1f 90       	pop	r1
    1ae0:	18 95       	reti

00001ae2 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    1ae2:	1f 92       	push	r1
    1ae4:	0f 92       	push	r0
    1ae6:	0f b6       	in	r0, 0x3f	; 63
    1ae8:	0f 92       	push	r0
    1aea:	0b b6       	in	r0, 0x3b	; 59
    1aec:	0f 92       	push	r0
    1aee:	11 24       	eor	r1, r1
    1af0:	2f 93       	push	r18
    1af2:	3f 93       	push	r19
    1af4:	4f 93       	push	r20
    1af6:	5f 93       	push	r21
    1af8:	6f 93       	push	r22
    1afa:	7f 93       	push	r23
    1afc:	8f 93       	push	r24
    1afe:	9f 93       	push	r25
    1b00:	af 93       	push	r26
    1b02:	bf 93       	push	r27
    1b04:	ef 93       	push	r30
    1b06:	ff 93       	push	r31
	sampleCurrentChannel();
    1b08:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <sampleCurrentChannel>
}
    1b0c:	ff 91       	pop	r31
    1b0e:	ef 91       	pop	r30
    1b10:	bf 91       	pop	r27
    1b12:	af 91       	pop	r26
    1b14:	9f 91       	pop	r25
    1b16:	8f 91       	pop	r24
    1b18:	7f 91       	pop	r23
    1b1a:	6f 91       	pop	r22
    1b1c:	5f 91       	pop	r21
    1b1e:	4f 91       	pop	r20
    1b20:	3f 91       	pop	r19
    1b22:	2f 91       	pop	r18
    1b24:	0f 90       	pop	r0
    1b26:	0b be       	out	0x3b, r0	; 59
    1b28:	0f 90       	pop	r0
    1b2a:	0f be       	out	0x3f, r0	; 63
    1b2c:	0f 90       	pop	r0
    1b2e:	1f 90       	pop	r1
    1b30:	18 95       	reti

00001b32 <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1b32:	ff 92       	push	r15
    1b34:	0f 93       	push	r16
    1b36:	1f 93       	push	r17
    1b38:	cf 93       	push	r28
    1b3a:	df 93       	push	r29
    1b3c:	cd b7       	in	r28, 0x3d	; 61
    1b3e:	de b7       	in	r29, 0x3e	; 62
    1b40:	28 97       	sbiw	r28, 0x08	; 8
    1b42:	cd bf       	out	0x3d, r28	; 61
    1b44:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1b46:	19 82       	std	Y+1, r1	; 0x01
    1b48:	1a 82       	std	Y+2, r1	; 0x02
    1b4a:	1b 82       	std	Y+3, r1	; 0x03
    1b4c:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    1b4e:	80 91 74 50 	lds	r24, 0x5074
    1b52:	90 91 75 50 	lds	r25, 0x5075
    1b56:	a0 91 76 50 	lds	r26, 0x5076
    1b5a:	b0 91 77 50 	lds	r27, 0x5077
    1b5e:	01 96       	adiw	r24, 0x01	; 1
    1b60:	a1 1d       	adc	r26, r1
    1b62:	b1 1d       	adc	r27, r1
    1b64:	80 93 74 50 	sts	0x5074, r24
    1b68:	90 93 75 50 	sts	0x5075, r25
    1b6c:	a0 93 76 50 	sts	0x5076, r26
    1b70:	b0 93 77 50 	sts	0x5077, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1b74:	80 ed       	ldi	r24, 0xD0	; 208
    1b76:	80 93 c0 08 	sts	0x08C0, r24
    1b7a:	20 e0       	ldi	r18, 0x00	; 0
    1b7c:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1b7e:	05 e6       	ldi	r16, 0x65	; 101
    1b80:	10 e5       	ldi	r17, 0x50	; 80
    1b82:	ff 24       	eor	r15, r15
    1b84:	fa 94       	dec	r15
    1b86:	c9 01       	movw	r24, r18
    1b88:	f8 01       	movw	r30, r16
    1b8a:	e2 0f       	add	r30, r18
    1b8c:	f3 1f       	adc	r31, r19
    1b8e:	40 81       	ld	r20, Z
    1b90:	44 23       	and	r20, r20
    1b92:	14 f4       	brge	.+4      	; 0x1b98 <writeSE2FRAM+0x66>
    1b94:	f8 86       	std	Y+8, r15	; 0x08
    1b96:	01 c0       	rjmp	.+2      	; 0x1b9a <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1b98:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1b9a:	80 0f       	add	r24, r16
    1b9c:	91 1f       	adc	r25, r17
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	80 81       	ld	r24, Z
    1ba2:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1ba4:	f9 01       	movw	r30, r18
    1ba6:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1ba8:	e0 0f       	add	r30, r16
    1baa:	f1 1f       	adc	r31, r17
    1bac:	80 81       	ld	r24, Z
    1bae:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1bb0:	f9 01       	movw	r30, r18
    1bb2:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1bb4:	e0 0f       	add	r30, r16
    1bb6:	f1 1f       	adc	r31, r17
    1bb8:	80 81       	ld	r24, Z
    1bba:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    1bbc:	49 81       	ldd	r20, Y+1	; 0x01
    1bbe:	5a 81       	ldd	r21, Y+2	; 0x02
    1bc0:	6b 81       	ldd	r22, Y+3	; 0x03
    1bc2:	7c 81       	ldd	r23, Y+4	; 0x04
    1bc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc6:	9e 81       	ldd	r25, Y+6	; 0x06
    1bc8:	af 81       	ldd	r26, Y+7	; 0x07
    1bca:	b8 85       	ldd	r27, Y+8	; 0x08
    1bcc:	84 0f       	add	r24, r20
    1bce:	95 1f       	adc	r25, r21
    1bd0:	a6 1f       	adc	r26, r22
    1bd2:	b7 1f       	adc	r27, r23
    1bd4:	89 83       	std	Y+1, r24	; 0x01
    1bd6:	9a 83       	std	Y+2, r25	; 0x02
    1bd8:	ab 83       	std	Y+3, r26	; 0x03
    1bda:	bc 83       	std	Y+4, r27	; 0x04
    1bdc:	2d 5f       	subi	r18, 0xFD	; 253
    1bde:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    1be0:	2c 30       	cpi	r18, 0x0C	; 12
    1be2:	31 05       	cpc	r19, r1
    1be4:	81 f6       	brne	.-96     	; 0x1b86 <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    1be6:	69 81       	ldd	r22, Y+1	; 0x01
    1be8:	7a 81       	ldd	r23, Y+2	; 0x02
    1bea:	8b 81       	ldd	r24, Y+3	; 0x03
    1bec:	9c 81       	ldd	r25, Y+4	; 0x04
    1bee:	24 e0       	ldi	r18, 0x04	; 4
    1bf0:	30 e0       	ldi	r19, 0x00	; 0
    1bf2:	40 e0       	ldi	r20, 0x00	; 0
    1bf4:	50 e0       	ldi	r21, 0x00	; 0
    1bf6:	0e 94 a3 3a 	call	0x7546	; 0x7546 <__divmodsi4>
    1bfa:	29 83       	std	Y+1, r18	; 0x01
    1bfc:	3a 83       	std	Y+2, r19	; 0x02
    1bfe:	4b 83       	std	Y+3, r20	; 0x03
    1c00:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    1c02:	29 81       	ldd	r18, Y+1	; 0x01
    1c04:	87 e6       	ldi	r24, 0x67	; 103
    1c06:	90 e5       	ldi	r25, 0x50	; 80
    1c08:	20 93 67 50 	sts	0x5067, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    1c0c:	2a 81       	ldd	r18, Y+2	; 0x02
    1c0e:	fc 01       	movw	r30, r24
    1c10:	31 97       	sbiw	r30, 0x01	; 1
    1c12:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    1c14:	2b 81       	ldd	r18, Y+3	; 0x03
    1c16:	02 97       	sbiw	r24, 0x02	; 2
    1c18:	fc 01       	movw	r30, r24
    1c1a:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1c1c:	80 e1       	ldi	r24, 0x10	; 16
    1c1e:	e0 e4       	ldi	r30, 0x40	; 64
    1c20:	f6 e0       	ldi	r31, 0x06	; 6
    1c22:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1c24:	88 e0       	ldi	r24, 0x08	; 8
    1c26:	e0 e2       	ldi	r30, 0x20	; 32
    1c28:	f6 e0       	ldi	r31, 0x06	; 6
    1c2a:	86 83       	std	Z+6, r24	; 0x06
	nop();
    1c2c:	00 00       	nop
	SPIC.DATA = FR_WREN;
    1c2e:	86 e0       	ldi	r24, 0x06	; 6
    1c30:	e0 ec       	ldi	r30, 0xC0	; 192
    1c32:	f8 e0       	ldi	r31, 0x08	; 8
    1c34:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1c36:	82 81       	ldd	r24, Z+2	; 0x02
    1c38:	88 23       	and	r24, r24
    1c3a:	ec f7       	brge	.-6      	; 0x1c36 <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    1c3c:	e0 ec       	ldi	r30, 0xC0	; 192
    1c3e:	f8 e0       	ldi	r31, 0x08	; 8
    1c40:	83 81       	ldd	r24, Z+3	; 0x03
    1c42:	80 93 71 50 	sts	0x5071, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    1c46:	a0 e2       	ldi	r26, 0x20	; 32
    1c48:	b6 e0       	ldi	r27, 0x06	; 6
    1c4a:	88 e0       	ldi	r24, 0x08	; 8
    1c4c:	15 96       	adiw	r26, 0x05	; 5
    1c4e:	8c 93       	st	X, r24
    1c50:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    1c52:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1c54:	16 96       	adiw	r26, 0x06	; 6
    1c56:	8c 93       	st	X, r24
    1c58:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    1c5a:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    1c5c:	82 e0       	ldi	r24, 0x02	; 2
    1c5e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1c60:	82 81       	ldd	r24, Z+2	; 0x02
    1c62:	88 23       	and	r24, r24
    1c64:	ec f7       	brge	.-6      	; 0x1c60 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    1c66:	e0 ec       	ldi	r30, 0xC0	; 192
    1c68:	f8 e0       	ldi	r31, 0x08	; 8
    1c6a:	83 81       	ldd	r24, Z+3	; 0x03
    1c6c:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1c70:	80 91 58 40 	lds	r24, 0x4058
    1c74:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1c76:	82 81       	ldd	r24, Z+2	; 0x02
    1c78:	88 23       	and	r24, r24
    1c7a:	ec f7       	brge	.-6      	; 0x1c76 <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    1c7c:	e0 ec       	ldi	r30, 0xC0	; 192
    1c7e:	f8 e0       	ldi	r31, 0x08	; 8
    1c80:	83 81       	ldd	r24, Z+3	; 0x03
    1c82:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1c86:	80 91 57 40 	lds	r24, 0x4057
    1c8a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1c8c:	82 81       	ldd	r24, Z+2	; 0x02
    1c8e:	88 23       	and	r24, r24
    1c90:	ec f7       	brge	.-6      	; 0x1c8c <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    1c92:	e0 ec       	ldi	r30, 0xC0	; 192
    1c94:	f8 e0       	ldi	r31, 0x08	; 8
    1c96:	83 81       	ldd	r24, Z+3	; 0x03
    1c98:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[0];
    1c9c:	80 91 65 50 	lds	r24, 0x5065
    1ca0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1ca2:	82 81       	ldd	r24, Z+2	; 0x02
    1ca4:	88 23       	and	r24, r24
    1ca6:	ec f7       	brge	.-6      	; 0x1ca2 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    1ca8:	e0 ec       	ldi	r30, 0xC0	; 192
    1caa:	f8 e0       	ldi	r31, 0x08	; 8
    1cac:	83 81       	ldd	r24, Z+3	; 0x03
    1cae:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[1];
    1cb2:	80 91 66 50 	lds	r24, 0x5066
    1cb6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1cb8:	82 81       	ldd	r24, Z+2	; 0x02
    1cba:	88 23       	and	r24, r24
    1cbc:	ec f7       	brge	.-6      	; 0x1cb8 <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    1cbe:	e0 ec       	ldi	r30, 0xC0	; 192
    1cc0:	f8 e0       	ldi	r31, 0x08	; 8
    1cc2:	83 81       	ldd	r24, Z+3	; 0x03
    1cc4:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[2];
    1cc8:	80 91 67 50 	lds	r24, 0x5067
    1ccc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1cce:	82 81       	ldd	r24, Z+2	; 0x02
    1cd0:	88 23       	and	r24, r24
    1cd2:	ec f7       	brge	.-6      	; 0x1cce <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    1cd4:	a0 ec       	ldi	r26, 0xC0	; 192
    1cd6:	b8 e0       	ldi	r27, 0x08	; 8
    1cd8:	13 96       	adiw	r26, 0x03	; 3
    1cda:	8c 91       	ld	r24, X
    1cdc:	13 97       	sbiw	r26, 0x03	; 3
    1cde:	80 93 71 50 	sts	0x5071, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    1ce2:	88 e0       	ldi	r24, 0x08	; 8
    1ce4:	e0 e2       	ldi	r30, 0x20	; 32
    1ce6:	f6 e0       	ldi	r31, 0x06	; 6
    1ce8:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1cea:	e0 e4       	ldi	r30, 0x40	; 64
    1cec:	f6 e0       	ldi	r31, 0x06	; 6
    1cee:	80 e1       	ldi	r24, 0x10	; 16
    1cf0:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1cf2:	94 e5       	ldi	r25, 0x54	; 84
    1cf4:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1cf6:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    1cf8:	80 91 57 40 	lds	r24, 0x4057
    1cfc:	90 91 58 40 	lds	r25, 0x4058
    1d00:	03 96       	adiw	r24, 0x03	; 3
    1d02:	80 93 57 40 	sts	0x4057, r24
    1d06:	90 93 58 40 	sts	0x4058, r25
	checksumADC[0] += SPIBuffer[0];
    1d0a:	80 91 3b 21 	lds	r24, 0x213B
    1d0e:	e5 e6       	ldi	r30, 0x65	; 101
    1d10:	f0 e5       	ldi	r31, 0x50	; 80
    1d12:	90 81       	ld	r25, Z
    1d14:	89 0f       	add	r24, r25
    1d16:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[1] += SPIBuffer[1];
    1d1a:	80 91 3c 21 	lds	r24, 0x213C
    1d1e:	91 81       	ldd	r25, Z+1	; 0x01
    1d20:	89 0f       	add	r24, r25
    1d22:	80 93 3c 21 	sts	0x213C, r24
	checksumADC[2] += SPIBuffer[2];
    1d26:	80 91 3d 21 	lds	r24, 0x213D
    1d2a:	92 81       	ldd	r25, Z+2	; 0x02
    1d2c:	89 0f       	add	r24, r25
    1d2e:	80 93 3d 21 	sts	0x213D, r24
}
    1d32:	28 96       	adiw	r28, 0x08	; 8
    1d34:	cd bf       	out	0x3d, r28	; 61
    1d36:	de bf       	out	0x3e, r29	; 62
    1d38:	df 91       	pop	r29
    1d3a:	cf 91       	pop	r28
    1d3c:	1f 91       	pop	r17
    1d3e:	0f 91       	pop	r16
    1d40:	ff 90       	pop	r15
    1d42:	08 95       	ret

00001d44 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1d44:	2f 92       	push	r2
    1d46:	3f 92       	push	r3
    1d48:	4f 92       	push	r4
    1d4a:	5f 92       	push	r5
    1d4c:	6f 92       	push	r6
    1d4e:	7f 92       	push	r7
    1d50:	8f 92       	push	r8
    1d52:	9f 92       	push	r9
    1d54:	af 92       	push	r10
    1d56:	bf 92       	push	r11
    1d58:	cf 92       	push	r12
    1d5a:	df 92       	push	r13
    1d5c:	ef 92       	push	r14
    1d5e:	ff 92       	push	r15
    1d60:	0f 93       	push	r16
    1d62:	1f 93       	push	r17
    1d64:	cf 93       	push	r28
    1d66:	df 93       	push	r29
    1d68:	00 d0       	rcall	.+0      	; 0x1d6a <calcChecksumFRAM+0x26>
    1d6a:	0f 92       	push	r0
    1d6c:	cd b7       	in	r28, 0x3d	; 61
    1d6e:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    1d70:	eb e9       	ldi	r30, 0x9B	; 155
    1d72:	f0 e5       	ldi	r31, 0x50	; 80
    1d74:	10 92 9b 50 	sts	0x509B, r1
    1d78:	10 92 9c 50 	sts	0x509C, r1
    1d7c:	10 92 9d 50 	sts	0x509D, r1
    1d80:	10 92 9e 50 	sts	0x509E, r1
    1d84:	10 92 9f 50 	sts	0x509F, r1
    1d88:	10 92 a0 50 	sts	0x50A0, r1
    1d8c:	10 92 a1 50 	sts	0x50A1, r1
    1d90:	10 92 a2 50 	sts	0x50A2, r1
    1d94:	df 01       	movw	r26, r30
    1d96:	18 97       	sbiw	r26, 0x08	; 8
    1d98:	1c 92       	st	X, r1
    1d9a:	11 96       	adiw	r26, 0x01	; 1
    1d9c:	1c 92       	st	X, r1
    1d9e:	11 97       	sbiw	r26, 0x01	; 1
    1da0:	12 96       	adiw	r26, 0x02	; 2
    1da2:	1c 92       	st	X, r1
    1da4:	12 97       	sbiw	r26, 0x02	; 2
    1da6:	13 96       	adiw	r26, 0x03	; 3
    1da8:	1c 92       	st	X, r1
    1daa:	13 97       	sbiw	r26, 0x03	; 3
    1dac:	14 96       	adiw	r26, 0x04	; 4
    1dae:	1c 92       	st	X, r1
    1db0:	14 97       	sbiw	r26, 0x04	; 4
    1db2:	15 96       	adiw	r26, 0x05	; 5
    1db4:	1c 92       	st	X, r1
    1db6:	15 97       	sbiw	r26, 0x05	; 5
    1db8:	16 96       	adiw	r26, 0x06	; 6
    1dba:	1c 92       	st	X, r1
    1dbc:	16 97       	sbiw	r26, 0x06	; 6
    1dbe:	17 96       	adiw	r26, 0x07	; 7
    1dc0:	1c 92       	st	X, r1
    1dc2:	70 97       	sbiw	r30, 0x10	; 16
    1dc4:	10 82       	st	Z, r1
    1dc6:	11 82       	std	Z+1, r1	; 0x01
    1dc8:	12 82       	std	Z+2, r1	; 0x02
    1dca:	13 82       	std	Z+3, r1	; 0x03
    1dcc:	14 82       	std	Z+4, r1	; 0x04
    1dce:	15 82       	std	Z+5, r1	; 0x05
    1dd0:	16 82       	std	Z+6, r1	; 0x06
    1dd2:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    1dd4:	8a e3       	ldi	r24, 0x3A	; 58
    1dd6:	91 e2       	ldi	r25, 0x21	; 33
    1dd8:	10 92 3a 21 	sts	0x213A, r1
    1ddc:	fc 01       	movw	r30, r24
    1dde:	31 97       	sbiw	r30, 0x01	; 1
    1de0:	10 82       	st	Z, r1
    1de2:	02 97       	sbiw	r24, 0x02	; 2
    1de4:	dc 01       	movw	r26, r24
    1de6:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    1de8:	10 92 57 40 	sts	0x4057, r1
    1dec:	10 92 58 40 	sts	0x4058, r1
    1df0:	e9 e0       	ldi	r30, 0x09	; 9
    1df2:	f0 e0       	ldi	r31, 0x00	; 0
    1df4:	e9 83       	std	Y+1, r30	; 0x01
    1df6:	fa 83       	std	Y+2, r31	; 0x02
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1df8:	99 24       	eor	r9, r9
    1dfa:	9a 94       	dec	r9
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    1dfc:	0f 2e       	mov	r0, r31
    1dfe:	fb e9       	ldi	r31, 0x9B	; 155
    1e00:	ef 2e       	mov	r14, r31
    1e02:	f0 e5       	ldi	r31, 0x50	; 80
    1e04:	ff 2e       	mov	r15, r31
    1e06:	f0 2d       	mov	r31, r0
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    1e08:	0f 2e       	mov	r0, r31
    1e0a:	f3 e9       	ldi	r31, 0x93	; 147
    1e0c:	cf 2e       	mov	r12, r31
    1e0e:	f0 e5       	ldi	r31, 0x50	; 80
    1e10:	df 2e       	mov	r13, r31
    1e12:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1e14:	0f 2e       	mov	r0, r31
    1e16:	fb e8       	ldi	r31, 0x8B	; 139
    1e18:	af 2e       	mov	r10, r31
    1e1a:	f0 e5       	ldi	r31, 0x50	; 80
    1e1c:	bf 2e       	mov	r11, r31
    1e1e:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    1e20:	81 e7       	ldi	r24, 0x71	; 113
    1e22:	9c e1       	ldi	r25, 0x1C	; 28
    1e24:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    1e28:	80 91 57 40 	lds	r24, 0x4057
    1e2c:	90 91 58 40 	lds	r25, 0x4058
    1e30:	8f 58       	subi	r24, 0x8F	; 143
    1e32:	93 4e       	sbci	r25, 0xE3	; 227
    1e34:	80 93 57 40 	sts	0x4057, r24
    1e38:	90 93 58 40 	sts	0x4058, r25
    1e3c:	0f ed       	ldi	r16, 0xDF	; 223
    1e3e:	13 e2       	ldi	r17, 0x23	; 35
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1e40:	80 e0       	ldi	r24, 0x00	; 0
    1e42:	90 e0       	ldi	r25, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1e44:	0f 2e       	mov	r0, r31
    1e46:	f9 e0       	ldi	r31, 0x09	; 9
    1e48:	2f 2e       	mov	r2, r31
    1e4a:	33 24       	eor	r3, r3
    1e4c:	f0 2d       	mov	r31, r0
    1e4e:	8b 83       	std	Y+3, r24	; 0x03
    1e50:	9c 83       	std	Y+4, r25	; 0x04
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1e52:	8b 81       	ldd	r24, Y+3	; 0x03
    1e54:	9c 81       	ldd	r25, Y+4	; 0x04
    1e56:	63 e0       	ldi	r22, 0x03	; 3
    1e58:	70 e0       	ldi	r23, 0x00	; 0
    1e5a:	0e 94 5a 3a 	call	0x74b4	; 0x74b4 <__udivmodhi4>
    1e5e:	9c 01       	movw	r18, r24
    1e60:	e8 e3       	ldi	r30, 0x38	; 56
    1e62:	f1 e2       	ldi	r31, 0x21	; 33
    1e64:	e8 0f       	add	r30, r24
    1e66:	f9 1f       	adc	r31, r25
    1e68:	90 81       	ld	r25, Z
	checksumADC[1] += SPIBuffer[1];
	checksumADC[2] += SPIBuffer[2];
}

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1e6a:	a8 01       	movw	r20, r16
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1e6c:	d8 01       	movw	r26, r16
    1e6e:	8c 91       	ld	r24, X
    1e70:	98 0f       	add	r25, r24
    1e72:	90 83       	st	Z, r25
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    1e74:	21 15       	cp	r18, r1
    1e76:	31 05       	cpc	r19, r1
    1e78:	19 f5       	brne	.+70     	; 0x1ec0 <calcChecksumFRAM+0x17c>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1e7a:	88 23       	and	r24, r24
    1e7c:	6c f4       	brge	.+26     	; 0x1e98 <calcChecksumFRAM+0x154>
    1e7e:	e0 91 63 50 	lds	r30, 0x5063
    1e82:	f0 91 64 50 	lds	r31, 0x5064
    1e86:	10 82       	st	Z, r1
    1e88:	11 82       	std	Z+1, r1	; 0x01
    1e8a:	12 82       	std	Z+2, r1	; 0x02
    1e8c:	93 82       	std	Z+3, r9	; 0x03
    1e8e:	94 82       	std	Z+4, r9	; 0x04
    1e90:	95 82       	std	Z+5, r9	; 0x05
    1e92:	96 82       	std	Z+6, r9	; 0x06
    1e94:	97 82       	std	Z+7, r9	; 0x07
    1e96:	0c c0       	rjmp	.+24     	; 0x1eb0 <calcChecksumFRAM+0x16c>
				else *temp64 = 0x0000000000000000;
    1e98:	e0 91 63 50 	lds	r30, 0x5063
    1e9c:	f0 91 64 50 	lds	r31, 0x5064
    1ea0:	10 82       	st	Z, r1
    1ea2:	11 82       	std	Z+1, r1	; 0x01
    1ea4:	12 82       	std	Z+2, r1	; 0x02
    1ea6:	13 82       	std	Z+3, r1	; 0x03
    1ea8:	14 82       	std	Z+4, r1	; 0x04
    1eaa:	15 82       	std	Z+5, r1	; 0x05
    1eac:	16 82       	std	Z+6, r1	; 0x06
    1eae:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    1eb0:	fa 01       	movw	r30, r20
    1eb2:	80 81       	ld	r24, Z
    1eb4:	e0 91 63 50 	lds	r30, 0x5063
    1eb8:	f0 91 64 50 	lds	r31, 0x5064
    1ebc:	82 83       	std	Z+2, r24	; 0x02
    1ebe:	10 c0       	rjmp	.+32     	; 0x1ee0 <calcChecksumFRAM+0x19c>
			} else if(k%3 == 1) {
    1ec0:	21 30       	cpi	r18, 0x01	; 1
    1ec2:	31 05       	cpc	r19, r1
    1ec4:	31 f4       	brne	.+12     	; 0x1ed2 <calcChecksumFRAM+0x18e>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    1ec6:	e0 91 63 50 	lds	r30, 0x5063
    1eca:	f0 91 64 50 	lds	r31, 0x5064
    1ece:	81 83       	std	Z+1, r24	; 0x01
    1ed0:	07 c0       	rjmp	.+14     	; 0x1ee0 <calcChecksumFRAM+0x19c>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    1ed2:	e0 91 63 50 	lds	r30, 0x5063
    1ed6:	f0 91 64 50 	lds	r31, 0x5064
    1eda:	d8 01       	movw	r26, r16
    1edc:	8c 91       	ld	r24, X
    1ede:	80 83       	st	Z, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1ee0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee4:	b1 01       	movw	r22, r2
    1ee6:	0e 94 5a 3a 	call	0x74b4	; 0x74b4 <__udivmodhi4>
    1eea:	82 30       	cpi	r24, 0x02	; 2
    1eec:	91 05       	cpc	r25, r1
    1eee:	09 f0       	breq	.+2      	; 0x1ef2 <calcChecksumFRAM+0x1ae>
    1ef0:	76 c0       	rjmp	.+236    	; 0x1fde <calcChecksumFRAM+0x29a>
    1ef2:	f5 01       	movw	r30, r10
    1ef4:	60 81       	ld	r22, Z
    1ef6:	51 81       	ldd	r21, Z+1	; 0x01
    1ef8:	42 81       	ldd	r20, Z+2	; 0x02
    1efa:	33 81       	ldd	r19, Z+3	; 0x03
    1efc:	24 81       	ldd	r18, Z+4	; 0x04
    1efe:	95 81       	ldd	r25, Z+5	; 0x05
    1f00:	86 81       	ldd	r24, Z+6	; 0x06
    1f02:	47 80       	ldd	r4, Z+7	; 0x07
    1f04:	e0 91 63 50 	lds	r30, 0x5063
    1f08:	f0 91 64 50 	lds	r31, 0x5064
    1f0c:	70 81       	ld	r23, Z
    1f0e:	a1 81       	ldd	r26, Z+1	; 0x01
    1f10:	b2 81       	ldd	r27, Z+2	; 0x02
    1f12:	83 80       	ldd	r8, Z+3	; 0x03
    1f14:	74 80       	ldd	r7, Z+4	; 0x04
    1f16:	65 80       	ldd	r6, Z+5	; 0x05
    1f18:	56 80       	ldd	r5, Z+6	; 0x06
    1f1a:	e7 81       	ldd	r30, Z+7	; 0x07
    1f1c:	76 0f       	add	r23, r22
    1f1e:	f1 e0       	ldi	r31, 0x01	; 1
    1f20:	76 17       	cp	r23, r22
    1f22:	08 f0       	brcs	.+2      	; 0x1f26 <calcChecksumFRAM+0x1e2>
    1f24:	f0 e0       	ldi	r31, 0x00	; 0
    1f26:	a5 0f       	add	r26, r21
    1f28:	61 e0       	ldi	r22, 0x01	; 1
    1f2a:	a5 17       	cp	r26, r21
    1f2c:	08 f0       	brcs	.+2      	; 0x1f30 <calcChecksumFRAM+0x1ec>
    1f2e:	60 e0       	ldi	r22, 0x00	; 0
    1f30:	fa 0f       	add	r31, r26
    1f32:	51 e0       	ldi	r21, 0x01	; 1
    1f34:	fa 17       	cp	r31, r26
    1f36:	08 f0       	brcs	.+2      	; 0x1f3a <calcChecksumFRAM+0x1f6>
    1f38:	50 e0       	ldi	r21, 0x00	; 0
    1f3a:	65 2b       	or	r22, r21
    1f3c:	b4 0f       	add	r27, r20
    1f3e:	51 e0       	ldi	r21, 0x01	; 1
    1f40:	b4 17       	cp	r27, r20
    1f42:	08 f0       	brcs	.+2      	; 0x1f46 <calcChecksumFRAM+0x202>
    1f44:	50 e0       	ldi	r21, 0x00	; 0
    1f46:	6b 0f       	add	r22, r27
    1f48:	41 e0       	ldi	r20, 0x01	; 1
    1f4a:	6b 17       	cp	r22, r27
    1f4c:	08 f0       	brcs	.+2      	; 0x1f50 <calcChecksumFRAM+0x20c>
    1f4e:	40 e0       	ldi	r20, 0x00	; 0
    1f50:	54 2b       	or	r21, r20
    1f52:	83 0e       	add	r8, r19
    1f54:	41 e0       	ldi	r20, 0x01	; 1
    1f56:	83 16       	cp	r8, r19
    1f58:	08 f0       	brcs	.+2      	; 0x1f5c <calcChecksumFRAM+0x218>
    1f5a:	40 e0       	ldi	r20, 0x00	; 0
    1f5c:	58 0d       	add	r21, r8
    1f5e:	31 e0       	ldi	r19, 0x01	; 1
    1f60:	58 15       	cp	r21, r8
    1f62:	08 f0       	brcs	.+2      	; 0x1f66 <calcChecksumFRAM+0x222>
    1f64:	30 e0       	ldi	r19, 0x00	; 0
    1f66:	43 2b       	or	r20, r19
    1f68:	72 0e       	add	r7, r18
    1f6a:	31 e0       	ldi	r19, 0x01	; 1
    1f6c:	72 16       	cp	r7, r18
    1f6e:	08 f0       	brcs	.+2      	; 0x1f72 <calcChecksumFRAM+0x22e>
    1f70:	30 e0       	ldi	r19, 0x00	; 0
    1f72:	47 0d       	add	r20, r7
    1f74:	21 e0       	ldi	r18, 0x01	; 1
    1f76:	47 15       	cp	r20, r7
    1f78:	08 f0       	brcs	.+2      	; 0x1f7c <calcChecksumFRAM+0x238>
    1f7a:	20 e0       	ldi	r18, 0x00	; 0
    1f7c:	32 2b       	or	r19, r18
    1f7e:	69 0e       	add	r6, r25
    1f80:	21 e0       	ldi	r18, 0x01	; 1
    1f82:	69 16       	cp	r6, r25
    1f84:	08 f0       	brcs	.+2      	; 0x1f88 <calcChecksumFRAM+0x244>
    1f86:	20 e0       	ldi	r18, 0x00	; 0
    1f88:	36 0d       	add	r19, r6
    1f8a:	91 e0       	ldi	r25, 0x01	; 1
    1f8c:	36 15       	cp	r19, r6
    1f8e:	08 f0       	brcs	.+2      	; 0x1f92 <calcChecksumFRAM+0x24e>
    1f90:	90 e0       	ldi	r25, 0x00	; 0
    1f92:	29 2b       	or	r18, r25
    1f94:	58 0e       	add	r5, r24
    1f96:	91 e0       	ldi	r25, 0x01	; 1
    1f98:	58 16       	cp	r5, r24
    1f9a:	08 f0       	brcs	.+2      	; 0x1f9e <calcChecksumFRAM+0x25a>
    1f9c:	90 e0       	ldi	r25, 0x00	; 0
    1f9e:	25 0d       	add	r18, r5
    1fa0:	81 e0       	ldi	r24, 0x01	; 1
    1fa2:	25 15       	cp	r18, r5
    1fa4:	08 f0       	brcs	.+2      	; 0x1fa8 <calcChecksumFRAM+0x264>
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	98 2b       	or	r25, r24
    1faa:	e4 0d       	add	r30, r4
    1fac:	9e 0f       	add	r25, r30
    1fae:	d5 01       	movw	r26, r10
    1fb0:	7c 93       	st	X, r23
    1fb2:	11 96       	adiw	r26, 0x01	; 1
    1fb4:	fc 93       	st	X, r31
    1fb6:	11 97       	sbiw	r26, 0x01	; 1
    1fb8:	12 96       	adiw	r26, 0x02	; 2
    1fba:	6c 93       	st	X, r22
    1fbc:	12 97       	sbiw	r26, 0x02	; 2
    1fbe:	13 96       	adiw	r26, 0x03	; 3
    1fc0:	5c 93       	st	X, r21
    1fc2:	13 97       	sbiw	r26, 0x03	; 3
    1fc4:	14 96       	adiw	r26, 0x04	; 4
    1fc6:	4c 93       	st	X, r20
    1fc8:	14 97       	sbiw	r26, 0x04	; 4
    1fca:	15 96       	adiw	r26, 0x05	; 5
    1fcc:	3c 93       	st	X, r19
    1fce:	15 97       	sbiw	r26, 0x05	; 5
    1fd0:	16 96       	adiw	r26, 0x06	; 6
    1fd2:	2c 93       	st	X, r18
    1fd4:	16 97       	sbiw	r26, 0x06	; 6
    1fd6:	17 96       	adiw	r26, 0x07	; 7
    1fd8:	9c 93       	st	X, r25
    1fda:	17 97       	sbiw	r26, 0x07	; 7
    1fdc:	f3 c0       	rjmp	.+486    	; 0x21c4 <calcChecksumFRAM+0x480>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    1fde:	85 30       	cpi	r24, 0x05	; 5
    1fe0:	91 05       	cpc	r25, r1
    1fe2:	09 f0       	breq	.+2      	; 0x1fe6 <calcChecksumFRAM+0x2a2>
    1fe4:	76 c0       	rjmp	.+236    	; 0x20d2 <calcChecksumFRAM+0x38e>
    1fe6:	f6 01       	movw	r30, r12
    1fe8:	60 81       	ld	r22, Z
    1fea:	51 81       	ldd	r21, Z+1	; 0x01
    1fec:	42 81       	ldd	r20, Z+2	; 0x02
    1fee:	33 81       	ldd	r19, Z+3	; 0x03
    1ff0:	24 81       	ldd	r18, Z+4	; 0x04
    1ff2:	95 81       	ldd	r25, Z+5	; 0x05
    1ff4:	86 81       	ldd	r24, Z+6	; 0x06
    1ff6:	47 80       	ldd	r4, Z+7	; 0x07
    1ff8:	e0 91 63 50 	lds	r30, 0x5063
    1ffc:	f0 91 64 50 	lds	r31, 0x5064
    2000:	70 81       	ld	r23, Z
    2002:	a1 81       	ldd	r26, Z+1	; 0x01
    2004:	b2 81       	ldd	r27, Z+2	; 0x02
    2006:	83 80       	ldd	r8, Z+3	; 0x03
    2008:	74 80       	ldd	r7, Z+4	; 0x04
    200a:	65 80       	ldd	r6, Z+5	; 0x05
    200c:	56 80       	ldd	r5, Z+6	; 0x06
    200e:	e7 81       	ldd	r30, Z+7	; 0x07
    2010:	76 0f       	add	r23, r22
    2012:	f1 e0       	ldi	r31, 0x01	; 1
    2014:	76 17       	cp	r23, r22
    2016:	08 f0       	brcs	.+2      	; 0x201a <calcChecksumFRAM+0x2d6>
    2018:	f0 e0       	ldi	r31, 0x00	; 0
    201a:	a5 0f       	add	r26, r21
    201c:	61 e0       	ldi	r22, 0x01	; 1
    201e:	a5 17       	cp	r26, r21
    2020:	08 f0       	brcs	.+2      	; 0x2024 <calcChecksumFRAM+0x2e0>
    2022:	60 e0       	ldi	r22, 0x00	; 0
    2024:	fa 0f       	add	r31, r26
    2026:	51 e0       	ldi	r21, 0x01	; 1
    2028:	fa 17       	cp	r31, r26
    202a:	08 f0       	brcs	.+2      	; 0x202e <calcChecksumFRAM+0x2ea>
    202c:	50 e0       	ldi	r21, 0x00	; 0
    202e:	65 2b       	or	r22, r21
    2030:	b4 0f       	add	r27, r20
    2032:	51 e0       	ldi	r21, 0x01	; 1
    2034:	b4 17       	cp	r27, r20
    2036:	08 f0       	brcs	.+2      	; 0x203a <calcChecksumFRAM+0x2f6>
    2038:	50 e0       	ldi	r21, 0x00	; 0
    203a:	6b 0f       	add	r22, r27
    203c:	41 e0       	ldi	r20, 0x01	; 1
    203e:	6b 17       	cp	r22, r27
    2040:	08 f0       	brcs	.+2      	; 0x2044 <calcChecksumFRAM+0x300>
    2042:	40 e0       	ldi	r20, 0x00	; 0
    2044:	54 2b       	or	r21, r20
    2046:	83 0e       	add	r8, r19
    2048:	41 e0       	ldi	r20, 0x01	; 1
    204a:	83 16       	cp	r8, r19
    204c:	08 f0       	brcs	.+2      	; 0x2050 <calcChecksumFRAM+0x30c>
    204e:	40 e0       	ldi	r20, 0x00	; 0
    2050:	58 0d       	add	r21, r8
    2052:	31 e0       	ldi	r19, 0x01	; 1
    2054:	58 15       	cp	r21, r8
    2056:	08 f0       	brcs	.+2      	; 0x205a <calcChecksumFRAM+0x316>
    2058:	30 e0       	ldi	r19, 0x00	; 0
    205a:	43 2b       	or	r20, r19
    205c:	72 0e       	add	r7, r18
    205e:	31 e0       	ldi	r19, 0x01	; 1
    2060:	72 16       	cp	r7, r18
    2062:	08 f0       	brcs	.+2      	; 0x2066 <calcChecksumFRAM+0x322>
    2064:	30 e0       	ldi	r19, 0x00	; 0
    2066:	47 0d       	add	r20, r7
    2068:	21 e0       	ldi	r18, 0x01	; 1
    206a:	47 15       	cp	r20, r7
    206c:	08 f0       	brcs	.+2      	; 0x2070 <calcChecksumFRAM+0x32c>
    206e:	20 e0       	ldi	r18, 0x00	; 0
    2070:	32 2b       	or	r19, r18
    2072:	69 0e       	add	r6, r25
    2074:	21 e0       	ldi	r18, 0x01	; 1
    2076:	69 16       	cp	r6, r25
    2078:	08 f0       	brcs	.+2      	; 0x207c <calcChecksumFRAM+0x338>
    207a:	20 e0       	ldi	r18, 0x00	; 0
    207c:	36 0d       	add	r19, r6
    207e:	91 e0       	ldi	r25, 0x01	; 1
    2080:	36 15       	cp	r19, r6
    2082:	08 f0       	brcs	.+2      	; 0x2086 <calcChecksumFRAM+0x342>
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	29 2b       	or	r18, r25
    2088:	58 0e       	add	r5, r24
    208a:	91 e0       	ldi	r25, 0x01	; 1
    208c:	58 16       	cp	r5, r24
    208e:	08 f0       	brcs	.+2      	; 0x2092 <calcChecksumFRAM+0x34e>
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	25 0d       	add	r18, r5
    2094:	81 e0       	ldi	r24, 0x01	; 1
    2096:	25 15       	cp	r18, r5
    2098:	08 f0       	brcs	.+2      	; 0x209c <calcChecksumFRAM+0x358>
    209a:	80 e0       	ldi	r24, 0x00	; 0
    209c:	98 2b       	or	r25, r24
    209e:	e4 0d       	add	r30, r4
    20a0:	9e 0f       	add	r25, r30
    20a2:	d6 01       	movw	r26, r12
    20a4:	7c 93       	st	X, r23
    20a6:	11 96       	adiw	r26, 0x01	; 1
    20a8:	fc 93       	st	X, r31
    20aa:	11 97       	sbiw	r26, 0x01	; 1
    20ac:	12 96       	adiw	r26, 0x02	; 2
    20ae:	6c 93       	st	X, r22
    20b0:	12 97       	sbiw	r26, 0x02	; 2
    20b2:	13 96       	adiw	r26, 0x03	; 3
    20b4:	5c 93       	st	X, r21
    20b6:	13 97       	sbiw	r26, 0x03	; 3
    20b8:	14 96       	adiw	r26, 0x04	; 4
    20ba:	4c 93       	st	X, r20
    20bc:	14 97       	sbiw	r26, 0x04	; 4
    20be:	15 96       	adiw	r26, 0x05	; 5
    20c0:	3c 93       	st	X, r19
    20c2:	15 97       	sbiw	r26, 0x05	; 5
    20c4:	16 96       	adiw	r26, 0x06	; 6
    20c6:	2c 93       	st	X, r18
    20c8:	16 97       	sbiw	r26, 0x06	; 6
    20ca:	17 96       	adiw	r26, 0x07	; 7
    20cc:	9c 93       	st	X, r25
    20ce:	17 97       	sbiw	r26, 0x07	; 7
    20d0:	79 c0       	rjmp	.+242    	; 0x21c4 <calcChecksumFRAM+0x480>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    20d2:	88 30       	cpi	r24, 0x08	; 8
    20d4:	91 05       	cpc	r25, r1
    20d6:	09 f0       	breq	.+2      	; 0x20da <calcChecksumFRAM+0x396>
    20d8:	75 c0       	rjmp	.+234    	; 0x21c4 <calcChecksumFRAM+0x480>
    20da:	f7 01       	movw	r30, r14
    20dc:	60 81       	ld	r22, Z
    20de:	51 81       	ldd	r21, Z+1	; 0x01
    20e0:	42 81       	ldd	r20, Z+2	; 0x02
    20e2:	33 81       	ldd	r19, Z+3	; 0x03
    20e4:	24 81       	ldd	r18, Z+4	; 0x04
    20e6:	95 81       	ldd	r25, Z+5	; 0x05
    20e8:	86 81       	ldd	r24, Z+6	; 0x06
    20ea:	47 80       	ldd	r4, Z+7	; 0x07
    20ec:	e0 91 63 50 	lds	r30, 0x5063
    20f0:	f0 91 64 50 	lds	r31, 0x5064
    20f4:	70 81       	ld	r23, Z
    20f6:	a1 81       	ldd	r26, Z+1	; 0x01
    20f8:	b2 81       	ldd	r27, Z+2	; 0x02
    20fa:	83 80       	ldd	r8, Z+3	; 0x03
    20fc:	74 80       	ldd	r7, Z+4	; 0x04
    20fe:	65 80       	ldd	r6, Z+5	; 0x05
    2100:	56 80       	ldd	r5, Z+6	; 0x06
    2102:	e7 81       	ldd	r30, Z+7	; 0x07
    2104:	76 0f       	add	r23, r22
    2106:	f1 e0       	ldi	r31, 0x01	; 1
    2108:	76 17       	cp	r23, r22
    210a:	08 f0       	brcs	.+2      	; 0x210e <calcChecksumFRAM+0x3ca>
    210c:	f0 e0       	ldi	r31, 0x00	; 0
    210e:	a5 0f       	add	r26, r21
    2110:	61 e0       	ldi	r22, 0x01	; 1
    2112:	a5 17       	cp	r26, r21
    2114:	08 f0       	brcs	.+2      	; 0x2118 <calcChecksumFRAM+0x3d4>
    2116:	60 e0       	ldi	r22, 0x00	; 0
    2118:	fa 0f       	add	r31, r26
    211a:	51 e0       	ldi	r21, 0x01	; 1
    211c:	fa 17       	cp	r31, r26
    211e:	08 f0       	brcs	.+2      	; 0x2122 <calcChecksumFRAM+0x3de>
    2120:	50 e0       	ldi	r21, 0x00	; 0
    2122:	65 2b       	or	r22, r21
    2124:	b4 0f       	add	r27, r20
    2126:	51 e0       	ldi	r21, 0x01	; 1
    2128:	b4 17       	cp	r27, r20
    212a:	08 f0       	brcs	.+2      	; 0x212e <calcChecksumFRAM+0x3ea>
    212c:	50 e0       	ldi	r21, 0x00	; 0
    212e:	6b 0f       	add	r22, r27
    2130:	41 e0       	ldi	r20, 0x01	; 1
    2132:	6b 17       	cp	r22, r27
    2134:	08 f0       	brcs	.+2      	; 0x2138 <calcChecksumFRAM+0x3f4>
    2136:	40 e0       	ldi	r20, 0x00	; 0
    2138:	54 2b       	or	r21, r20
    213a:	83 0e       	add	r8, r19
    213c:	41 e0       	ldi	r20, 0x01	; 1
    213e:	83 16       	cp	r8, r19
    2140:	08 f0       	brcs	.+2      	; 0x2144 <calcChecksumFRAM+0x400>
    2142:	40 e0       	ldi	r20, 0x00	; 0
    2144:	58 0d       	add	r21, r8
    2146:	31 e0       	ldi	r19, 0x01	; 1
    2148:	58 15       	cp	r21, r8
    214a:	08 f0       	brcs	.+2      	; 0x214e <calcChecksumFRAM+0x40a>
    214c:	30 e0       	ldi	r19, 0x00	; 0
    214e:	43 2b       	or	r20, r19
    2150:	72 0e       	add	r7, r18
    2152:	31 e0       	ldi	r19, 0x01	; 1
    2154:	72 16       	cp	r7, r18
    2156:	08 f0       	brcs	.+2      	; 0x215a <calcChecksumFRAM+0x416>
    2158:	30 e0       	ldi	r19, 0x00	; 0
    215a:	47 0d       	add	r20, r7
    215c:	21 e0       	ldi	r18, 0x01	; 1
    215e:	47 15       	cp	r20, r7
    2160:	08 f0       	brcs	.+2      	; 0x2164 <calcChecksumFRAM+0x420>
    2162:	20 e0       	ldi	r18, 0x00	; 0
    2164:	32 2b       	or	r19, r18
    2166:	69 0e       	add	r6, r25
    2168:	21 e0       	ldi	r18, 0x01	; 1
    216a:	69 16       	cp	r6, r25
    216c:	08 f0       	brcs	.+2      	; 0x2170 <calcChecksumFRAM+0x42c>
    216e:	20 e0       	ldi	r18, 0x00	; 0
    2170:	36 0d       	add	r19, r6
    2172:	91 e0       	ldi	r25, 0x01	; 1
    2174:	36 15       	cp	r19, r6
    2176:	08 f0       	brcs	.+2      	; 0x217a <calcChecksumFRAM+0x436>
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	29 2b       	or	r18, r25
    217c:	58 0e       	add	r5, r24
    217e:	91 e0       	ldi	r25, 0x01	; 1
    2180:	58 16       	cp	r5, r24
    2182:	08 f0       	brcs	.+2      	; 0x2186 <calcChecksumFRAM+0x442>
    2184:	90 e0       	ldi	r25, 0x00	; 0
    2186:	25 0d       	add	r18, r5
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	25 15       	cp	r18, r5
    218c:	08 f0       	brcs	.+2      	; 0x2190 <calcChecksumFRAM+0x44c>
    218e:	80 e0       	ldi	r24, 0x00	; 0
    2190:	98 2b       	or	r25, r24
    2192:	e4 0d       	add	r30, r4
    2194:	9e 0f       	add	r25, r30
    2196:	d7 01       	movw	r26, r14
    2198:	7c 93       	st	X, r23
    219a:	11 96       	adiw	r26, 0x01	; 1
    219c:	fc 93       	st	X, r31
    219e:	11 97       	sbiw	r26, 0x01	; 1
    21a0:	12 96       	adiw	r26, 0x02	; 2
    21a2:	6c 93       	st	X, r22
    21a4:	12 97       	sbiw	r26, 0x02	; 2
    21a6:	13 96       	adiw	r26, 0x03	; 3
    21a8:	5c 93       	st	X, r21
    21aa:	13 97       	sbiw	r26, 0x03	; 3
    21ac:	14 96       	adiw	r26, 0x04	; 4
    21ae:	4c 93       	st	X, r20
    21b0:	14 97       	sbiw	r26, 0x04	; 4
    21b2:	15 96       	adiw	r26, 0x05	; 5
    21b4:	3c 93       	st	X, r19
    21b6:	15 97       	sbiw	r26, 0x05	; 5
    21b8:	16 96       	adiw	r26, 0x06	; 6
    21ba:	2c 93       	st	X, r18
    21bc:	16 97       	sbiw	r26, 0x06	; 6
    21be:	17 96       	adiw	r26, 0x07	; 7
    21c0:	9c 93       	st	X, r25
    21c2:	17 97       	sbiw	r26, 0x07	; 7
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    21c4:	eb 81       	ldd	r30, Y+3	; 0x03
    21c6:	fc 81       	ldd	r31, Y+4	; 0x04
    21c8:	31 96       	adiw	r30, 0x01	; 1
    21ca:	eb 83       	std	Y+3, r30	; 0x03
    21cc:	fc 83       	std	Y+4, r31	; 0x04
    21ce:	0f 5f       	subi	r16, 0xFF	; 255
    21d0:	1f 4f       	sbci	r17, 0xFF	; 255
    21d2:	2c e1       	ldi	r18, 0x1C	; 28
    21d4:	e1 37       	cpi	r30, 0x71	; 113
    21d6:	f2 07       	cpc	r31, r18
    21d8:	09 f0       	breq	.+2      	; 0x21dc <calcChecksumFRAM+0x498>
    21da:	3b ce       	rjmp	.-906    	; 0x1e52 <calcChecksumFRAM+0x10e>
    21dc:	89 81       	ldd	r24, Y+1	; 0x01
    21de:	9a 81       	ldd	r25, Y+2	; 0x02
    21e0:	01 97       	sbiw	r24, 0x01	; 1
    21e2:	89 83       	std	Y+1, r24	; 0x01
    21e4:	9a 83       	std	Y+2, r25	; 0x02
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    21e6:	00 97       	sbiw	r24, 0x00	; 0
    21e8:	09 f0       	breq	.+2      	; 0x21ec <calcChecksumFRAM+0x4a8>
    21ea:	1a ce       	rjmp	.-972    	; 0x1e20 <calcChecksumFRAM+0xdc>
			
		}
		
	}
	
}
    21ec:	24 96       	adiw	r28, 0x04	; 4
    21ee:	cd bf       	out	0x3d, r28	; 61
    21f0:	de bf       	out	0x3e, r29	; 62
    21f2:	df 91       	pop	r29
    21f4:	cf 91       	pop	r28
    21f6:	1f 91       	pop	r17
    21f8:	0f 91       	pop	r16
    21fa:	ff 90       	pop	r15
    21fc:	ef 90       	pop	r14
    21fe:	df 90       	pop	r13
    2200:	cf 90       	pop	r12
    2202:	bf 90       	pop	r11
    2204:	af 90       	pop	r10
    2206:	9f 90       	pop	r9
    2208:	8f 90       	pop	r8
    220a:	7f 90       	pop	r7
    220c:	6f 90       	pop	r6
    220e:	5f 90       	pop	r5
    2210:	4f 90       	pop	r4
    2212:	3f 90       	pop	r3
    2214:	2f 90       	pop	r2
    2216:	08 95       	ret

00002218 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    2218:	2f 92       	push	r2
    221a:	3f 92       	push	r3
    221c:	4f 92       	push	r4
    221e:	5f 92       	push	r5
    2220:	6f 92       	push	r6
    2222:	7f 92       	push	r7
    2224:	8f 92       	push	r8
    2226:	9f 92       	push	r9
    2228:	af 92       	push	r10
    222a:	bf 92       	push	r11
    222c:	cf 92       	push	r12
    222e:	df 92       	push	r13
    2230:	ef 92       	push	r14
    2232:	ff 92       	push	r15
    2234:	0f 93       	push	r16
    2236:	1f 93       	push	r17
    2238:	cf 93       	push	r28
    223a:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    223c:	10 92 57 40 	sts	0x4057, r1
    2240:	10 92 58 40 	sts	0x4058, r1
	sampleCount = 0;
    2244:	10 92 74 50 	sts	0x5074, r1
    2248:	10 92 75 50 	sts	0x5075, r1
    224c:	10 92 76 50 	sts	0x5076, r1
    2250:	10 92 77 50 	sts	0x5077, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2254:	8d e3       	ldi	r24, 0x3D	; 61
    2256:	91 e2       	ldi	r25, 0x21	; 33
    2258:	10 92 3d 21 	sts	0x213D, r1
    225c:	fc 01       	movw	r30, r24
    225e:	31 97       	sbiw	r30, 0x01	; 1
    2260:	10 82       	st	Z, r1
    2262:	02 97       	sbiw	r24, 0x02	; 2
    2264:	dc 01       	movw	r26, r24
    2266:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    2268:	81 e0       	ldi	r24, 0x01	; 1
    226a:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    226e:	84 e0       	ldi	r24, 0x04	; 4
    2270:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2274:	80 ed       	ldi	r24, 0xD0	; 208
    2276:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    227a:	8d e0       	ldi	r24, 0x0D	; 13
    227c:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[1] = 0xF3;
    2280:	83 ef       	ldi	r24, 0xF3	; 243
    2282:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[2] = 0x57;
    2286:	87 e5       	ldi	r24, 0x57	; 87
    2288:	80 93 67 50 	sts	0x5067, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    228c:	80 91 74 50 	lds	r24, 0x5074
    2290:	90 91 75 50 	lds	r25, 0x5075
    2294:	a0 91 76 50 	lds	r26, 0x5076
    2298:	b0 91 77 50 	lds	r27, 0x5077
    229c:	83 35       	cpi	r24, 0x53	; 83
    229e:	e5 e5       	ldi	r30, 0x55	; 85
    22a0:	9e 07       	cpc	r25, r30
    22a2:	e0 e0       	ldi	r30, 0x00	; 0
    22a4:	ae 07       	cpc	r26, r30
    22a6:	e0 e0       	ldi	r30, 0x00	; 0
    22a8:	be 07       	cpc	r27, r30
    22aa:	08 f0       	brcs	.+2      	; 0x22ae <FRAMWriteKnowns+0x96>
    22ac:	cc c0       	rjmp	.+408    	; 0x2446 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    22ae:	0f 2e       	mov	r0, r31
    22b0:	f0 e4       	ldi	r31, 0x40	; 64
    22b2:	ef 2e       	mov	r14, r31
    22b4:	f6 e0       	ldi	r31, 0x06	; 6
    22b6:	ff 2e       	mov	r15, r31
    22b8:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    22ba:	40 e2       	ldi	r20, 0x20	; 32
    22bc:	56 e0       	ldi	r21, 0x06	; 6
    22be:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    22c0:	e0 ec       	ldi	r30, 0xC0	; 192
    22c2:	f8 e0       	ldi	r31, 0x08	; 8
    22c4:	0f 2e       	mov	r0, r31
    22c6:	f6 e0       	ldi	r31, 0x06	; 6
    22c8:	7f 2e       	mov	r7, r31
    22ca:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    22cc:	c1 e7       	ldi	r28, 0x71	; 113
    22ce:	d0 e5       	ldi	r29, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    22d0:	66 24       	eor	r6, r6
    22d2:	68 94       	set
    22d4:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    22d6:	0f 2e       	mov	r0, r31
    22d8:	f7 e5       	ldi	r31, 0x57	; 87
    22da:	cf 2e       	mov	r12, r31
    22dc:	f0 e4       	ldi	r31, 0x40	; 64
    22de:	df 2e       	mov	r13, r31
    22e0:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    22e2:	8e 01       	movw	r16, r28
    22e4:	0c 50       	subi	r16, 0x0C	; 12
    22e6:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    22e8:	0f 2e       	mov	r0, r31
    22ea:	f5 ef       	ldi	r31, 0xF5	; 245
    22ec:	4f 2e       	mov	r4, r31
    22ee:	ff ef       	ldi	r31, 0xFF	; 255
    22f0:	5f 2e       	mov	r5, r31
    22f2:	f0 2d       	mov	r31, r0
    22f4:	4c 0e       	add	r4, r28
    22f6:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    22f8:	0f 2e       	mov	r0, r31
    22fa:	f6 ef       	ldi	r31, 0xF6	; 246
    22fc:	2f 2e       	mov	r2, r31
    22fe:	ff ef       	ldi	r31, 0xFF	; 255
    2300:	3f 2e       	mov	r3, r31
    2302:	f0 2d       	mov	r31, r0
    2304:	2c 0e       	add	r2, r28
    2306:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2308:	6b e3       	ldi	r22, 0x3B	; 59
    230a:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    230c:	5b 01       	movw	r10, r22
    230e:	08 94       	sec
    2310:	a1 1c       	adc	r10, r1
    2312:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2314:	88 24       	eor	r8, r8
    2316:	99 24       	eor	r9, r9
    2318:	68 94       	set
    231a:	81 f8       	bld	r8, 1
    231c:	86 0e       	add	r8, r22
    231e:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2320:	30 e1       	ldi	r19, 0x10	; 16
    2322:	d7 01       	movw	r26, r14
    2324:	16 96       	adiw	r26, 0x06	; 6
    2326:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2328:	da 01       	movw	r26, r20
    232a:	16 96       	adiw	r26, 0x06	; 6
    232c:	2c 93       	st	X, r18
    232e:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2330:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2332:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2334:	82 81       	ldd	r24, Z+2	; 0x02
    2336:	88 23       	and	r24, r24
    2338:	ec f7       	brge	.-6      	; 0x2334 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    233a:	83 81       	ldd	r24, Z+3	; 0x03
    233c:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    233e:	da 01       	movw	r26, r20
    2340:	15 96       	adiw	r26, 0x05	; 5
    2342:	2c 93       	st	X, r18
    2344:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2346:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2348:	16 96       	adiw	r26, 0x06	; 6
    234a:	2c 93       	st	X, r18
    234c:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    234e:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2350:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2352:	82 81       	ldd	r24, Z+2	; 0x02
    2354:	88 23       	and	r24, r24
    2356:	ec f7       	brge	.-6      	; 0x2352 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    2358:	83 81       	ldd	r24, Z+3	; 0x03
    235a:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    235c:	d6 01       	movw	r26, r12
    235e:	11 96       	adiw	r26, 0x01	; 1
    2360:	8c 91       	ld	r24, X
    2362:	11 97       	sbiw	r26, 0x01	; 1
    2364:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2366:	82 81       	ldd	r24, Z+2	; 0x02
    2368:	88 23       	and	r24, r24
    236a:	ec f7       	brge	.-6      	; 0x2366 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    236c:	83 81       	ldd	r24, Z+3	; 0x03
    236e:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2370:	d6 01       	movw	r26, r12
    2372:	8c 91       	ld	r24, X
    2374:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2376:	82 81       	ldd	r24, Z+2	; 0x02
    2378:	88 23       	and	r24, r24
    237a:	ec f7       	brge	.-6      	; 0x2376 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    237c:	83 81       	ldd	r24, Z+3	; 0x03
    237e:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2380:	d8 01       	movw	r26, r16
    2382:	8c 91       	ld	r24, X
    2384:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2386:	82 81       	ldd	r24, Z+2	; 0x02
    2388:	88 23       	and	r24, r24
    238a:	ec f7       	brge	.-6      	; 0x2386 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    238c:	83 81       	ldd	r24, Z+3	; 0x03
    238e:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2390:	d2 01       	movw	r26, r4
    2392:	8c 91       	ld	r24, X
    2394:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2396:	82 81       	ldd	r24, Z+2	; 0x02
    2398:	88 23       	and	r24, r24
    239a:	ec f7       	brge	.-6      	; 0x2396 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    239c:	83 81       	ldd	r24, Z+3	; 0x03
    239e:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    23a0:	d1 01       	movw	r26, r2
    23a2:	8c 91       	ld	r24, X
    23a4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23a6:	82 81       	ldd	r24, Z+2	; 0x02
    23a8:	88 23       	and	r24, r24
    23aa:	ec f7       	brge	.-6      	; 0x23a6 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    23ac:	83 81       	ldd	r24, Z+3	; 0x03
    23ae:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    23b0:	da 01       	movw	r26, r20
    23b2:	15 96       	adiw	r26, 0x05	; 5
    23b4:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    23b6:	30 e1       	ldi	r19, 0x10	; 16
    23b8:	d7 01       	movw	r26, r14
    23ba:	15 96       	adiw	r26, 0x05	; 5
    23bc:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    23be:	80 91 57 40 	lds	r24, 0x4057
    23c2:	90 91 58 40 	lds	r25, 0x4058
    23c6:	03 96       	adiw	r24, 0x03	; 3
    23c8:	80 93 57 40 	sts	0x4057, r24
    23cc:	90 93 58 40 	sts	0x4058, r25
		checksumADC[0] += SPIBuffer[0];
    23d0:	db 01       	movw	r26, r22
    23d2:	8c 91       	ld	r24, X
    23d4:	d8 01       	movw	r26, r16
    23d6:	9c 91       	ld	r25, X
    23d8:	89 0f       	add	r24, r25
    23da:	db 01       	movw	r26, r22
    23dc:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    23de:	d5 01       	movw	r26, r10
    23e0:	8c 91       	ld	r24, X
    23e2:	a6 e6       	ldi	r26, 0x66	; 102
    23e4:	b0 e5       	ldi	r27, 0x50	; 80
    23e6:	9c 91       	ld	r25, X
    23e8:	89 0f       	add	r24, r25
    23ea:	d5 01       	movw	r26, r10
    23ec:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    23ee:	d4 01       	movw	r26, r8
    23f0:	8c 91       	ld	r24, X
    23f2:	a7 e6       	ldi	r26, 0x67	; 103
    23f4:	b0 e5       	ldi	r27, 0x50	; 80
    23f6:	9c 91       	ld	r25, X
    23f8:	89 0f       	add	r24, r25
    23fa:	d4 01       	movw	r26, r8
    23fc:	8c 93       	st	X, r24
		
		sampleCount++;
    23fe:	80 91 74 50 	lds	r24, 0x5074
    2402:	90 91 75 50 	lds	r25, 0x5075
    2406:	a0 91 76 50 	lds	r26, 0x5076
    240a:	b0 91 77 50 	lds	r27, 0x5077
    240e:	01 96       	adiw	r24, 0x01	; 1
    2410:	a1 1d       	adc	r26, r1
    2412:	b1 1d       	adc	r27, r1
    2414:	80 93 74 50 	sts	0x5074, r24
    2418:	90 93 75 50 	sts	0x5075, r25
    241c:	a0 93 76 50 	sts	0x5076, r26
    2420:	b0 93 77 50 	sts	0x5077, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2424:	80 91 74 50 	lds	r24, 0x5074
    2428:	90 91 75 50 	lds	r25, 0x5075
    242c:	a0 91 76 50 	lds	r26, 0x5076
    2430:	b0 91 77 50 	lds	r27, 0x5077
    2434:	83 35       	cpi	r24, 0x53	; 83
    2436:	35 e5       	ldi	r19, 0x55	; 85
    2438:	93 07       	cpc	r25, r19
    243a:	30 e0       	ldi	r19, 0x00	; 0
    243c:	a3 07       	cpc	r26, r19
    243e:	30 e0       	ldi	r19, 0x00	; 0
    2440:	b3 07       	cpc	r27, r19
    2442:	08 f4       	brcc	.+2      	; 0x2446 <FRAMWriteKnowns+0x22e>
    2444:	6d cf       	rjmp	.-294    	; 0x2320 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2446:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	ADCPower(FALSE);
    244a:	80 e0       	ldi	r24, 0x00	; 0
    244c:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
}
    2450:	df 91       	pop	r29
    2452:	cf 91       	pop	r28
    2454:	1f 91       	pop	r17
    2456:	0f 91       	pop	r16
    2458:	ff 90       	pop	r15
    245a:	ef 90       	pop	r14
    245c:	df 90       	pop	r13
    245e:	cf 90       	pop	r12
    2460:	bf 90       	pop	r11
    2462:	af 90       	pop	r10
    2464:	9f 90       	pop	r9
    2466:	8f 90       	pop	r8
    2468:	7f 90       	pop	r7
    246a:	6f 90       	pop	r6
    246c:	5f 90       	pop	r5
    246e:	4f 90       	pop	r4
    2470:	3f 90       	pop	r3
    2472:	2f 90       	pop	r2
    2474:	08 95       	ret

00002476 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2476:	80 ff       	sbrs	r24, 0
    2478:	05 c0       	rjmp	.+10     	; 0x2484 <setADCInput+0xe>
    247a:	20 e4       	ldi	r18, 0x40	; 64
    247c:	e0 e0       	ldi	r30, 0x00	; 0
    247e:	f6 e0       	ldi	r31, 0x06	; 6
    2480:	25 83       	std	Z+5, r18	; 0x05
    2482:	04 c0       	rjmp	.+8      	; 0x248c <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2484:	20 e4       	ldi	r18, 0x40	; 64
    2486:	e0 e0       	ldi	r30, 0x00	; 0
    2488:	f6 e0       	ldi	r31, 0x06	; 6
    248a:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    248c:	81 ff       	sbrs	r24, 1
    248e:	05 c0       	rjmp	.+10     	; 0x249a <setADCInput+0x24>
    2490:	22 e0       	ldi	r18, 0x02	; 2
    2492:	e0 e2       	ldi	r30, 0x20	; 32
    2494:	f6 e0       	ldi	r31, 0x06	; 6
    2496:	25 83       	std	Z+5, r18	; 0x05
    2498:	04 c0       	rjmp	.+8      	; 0x24a2 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    249a:	22 e0       	ldi	r18, 0x02	; 2
    249c:	e0 e2       	ldi	r30, 0x20	; 32
    249e:	f6 e0       	ldi	r31, 0x06	; 6
    24a0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    24a2:	82 ff       	sbrs	r24, 2
    24a4:	05 c0       	rjmp	.+10     	; 0x24b0 <setADCInput+0x3a>
    24a6:	84 e0       	ldi	r24, 0x04	; 4
    24a8:	e0 e2       	ldi	r30, 0x20	; 32
    24aa:	f6 e0       	ldi	r31, 0x06	; 6
    24ac:	85 83       	std	Z+5, r24	; 0x05
    24ae:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    24b0:	84 e0       	ldi	r24, 0x04	; 4
    24b2:	e0 e2       	ldi	r30, 0x20	; 32
    24b4:	f6 e0       	ldi	r31, 0x06	; 6
    24b6:	86 83       	std	Z+6, r24	; 0x06
    24b8:	08 95       	ret

000024ba <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    24ba:	2f 92       	push	r2
    24bc:	3f 92       	push	r3
    24be:	4f 92       	push	r4
    24c0:	5f 92       	push	r5
    24c2:	7f 92       	push	r7
    24c4:	8f 92       	push	r8
    24c6:	9f 92       	push	r9
    24c8:	af 92       	push	r10
    24ca:	bf 92       	push	r11
    24cc:	cf 92       	push	r12
    24ce:	df 92       	push	r13
    24d0:	ef 92       	push	r14
    24d2:	ff 92       	push	r15
    24d4:	0f 93       	push	r16
    24d6:	1f 93       	push	r17
    24d8:	cf 93       	push	r28
    24da:	df 93       	push	r29
    24dc:	cd b7       	in	r28, 0x3d	; 61
    24de:	de b7       	in	r29, 0x3e	; 62
    24e0:	18 2f       	mov	r17, r24
    24e2:	76 2e       	mov	r7, r22
    24e4:	f4 2e       	mov	r15, r20
    24e6:	19 01       	movw	r2, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER=DataArray;
    24e8:	89 8d       	ldd	r24, Y+25	; 0x19
    24ea:	9a 8d       	ldd	r25, Y+26	; 0x1a
    24ec:	80 93 72 50 	sts	0x5072, r24
    24f0:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    24f4:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    24f8:	81 e0       	ldi	r24, 0x01	; 1
    24fa:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    24fe:	81 2f       	mov	r24, r17
    2500:	6f 2d       	mov	r22, r15
    2502:	0e 94 8a 03 	call	0x714	; 0x714 <set_ampGain>
	set_filter(filterConfig);
    2506:	87 2d       	mov	r24, r7
    2508:	0e 94 c3 03 	call	0x786	; 0x786 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    250c:	8e 2d       	mov	r24, r14
    250e:	0e 94 9c 08 	call	0x1138	; 0x1138 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2512:	84 e0       	ldi	r24, 0x04	; 4
    2514:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2518:	84 e5       	ldi	r24, 0x54	; 84
    251a:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	0e 94 f0 06 	call	0xde0	; 0xde0 <enableADCMUX>
	setADCInput(channel);
    2524:	81 2f       	mov	r24, r17
    2526:	0e 94 3b 12 	call	0x2476	; 0x2476 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    252a:	e0 ea       	ldi	r30, 0xA0	; 160
    252c:	f6 e0       	ldi	r31, 0x06	; 6
    252e:	22 e0       	ldi	r18, 0x02	; 2
    2530:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2532:	77 24       	eor	r7, r7
    2534:	73 94       	inc	r7
    2536:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2538:	0f 2e       	mov	r0, r31
    253a:	f0 e8       	ldi	r31, 0x80	; 128
    253c:	4f 2e       	mov	r4, r31
    253e:	f1 e0       	ldi	r31, 0x01	; 1
    2540:	5f 2e       	mov	r5, r31
    2542:	f0 2d       	mov	r31, r0
    2544:	88 e7       	ldi	r24, 0x78	; 120
    2546:	d2 01       	movw	r26, r4
    2548:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    254a:	e0 e0       	ldi	r30, 0x00	; 0
    254c:	f9 e0       	ldi	r31, 0x09	; 9
    254e:	80 ef       	ldi	r24, 0xF0	; 240
    2550:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2552:	c0 a6       	lds	r28, 0xb0
    2554:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2556:	a2 a6       	lds	r26, 0xb2
    2558:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    255a:	84 a6       	lds	r24, 0xb4
    255c:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    255e:	8d 89       	ldd	r24, Y+21	; 0x15
    2560:	9e 89       	ldd	r25, Y+22	; 0x16
    2562:	86 a7       	lds	r24, 0x76
    2564:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2566:	80 2f       	mov	r24, r16
    2568:	90 e0       	ldi	r25, 0x00	; 0
    256a:	01 97       	sbiw	r24, 0x01	; 1
    256c:	86 a3       	lds	r24, 0x56
    256e:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2570:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2572:	8f ef       	ldi	r24, 0xFF	; 255
    2574:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2576:	80 81       	ld	r24, Z
    2578:	80 7f       	andi	r24, 0xF0	; 240
    257a:	88 60       	ori	r24, 0x08	; 8
    257c:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    257e:	10 92 74 50 	sts	0x5074, r1
    2582:	10 92 75 50 	sts	0x5075, r1
    2586:	10 92 76 50 	sts	0x5076, r1
    258a:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    258e:	10 92 c6 50 	sts	0x50C6, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2592:	e0 ea       	ldi	r30, 0xA0	; 160
    2594:	f0 e0       	ldi	r31, 0x00	; 0
    2596:	82 81       	ldd	r24, Z+2	; 0x02
    2598:	87 60       	ori	r24, 0x07	; 7
    259a:	82 83       	std	Z+2, r24	; 0x02
	sei();
    259c:	78 94       	sei

	SPICS(TRUE);
    259e:	81 e0       	ldi	r24, 0x01	; 1
    25a0:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    25a4:	80 e2       	ldi	r24, 0x20	; 32
    25a6:	e0 e8       	ldi	r30, 0x80	; 128
    25a8:	f6 e0       	ldi	r31, 0x06	; 6
    25aa:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    25ac:	00 e4       	ldi	r16, 0x40	; 64
    25ae:	1a e0       	ldi	r17, 0x0A	; 10
    25b0:	83 e2       	ldi	r24, 0x23	; 35
    25b2:	f8 01       	movw	r30, r16
    25b4:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    25b6:	61 01       	movw	r12, r2
    25b8:	ee 24       	eor	r14, r14
    25ba:	ff 24       	eor	r15, r15
    25bc:	60 e8       	ldi	r22, 0x80	; 128
    25be:	74 e8       	ldi	r23, 0x84	; 132
    25c0:	8e e1       	ldi	r24, 0x1E	; 30
    25c2:	90 e0       	ldi	r25, 0x00	; 0
    25c4:	a7 01       	movw	r20, r14
    25c6:	96 01       	movw	r18, r12
    25c8:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    25cc:	d8 01       	movw	r26, r16
    25ce:	96 96       	adiw	r26, 0x26	; 38
    25d0:	2d 93       	st	X+, r18
    25d2:	3c 93       	st	X, r19
    25d4:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    25d6:	60 e4       	ldi	r22, 0x40	; 64
    25d8:	72 e4       	ldi	r23, 0x42	; 66
    25da:	8f e0       	ldi	r24, 0x0F	; 15
    25dc:	90 e0       	ldi	r25, 0x00	; 0
    25de:	a7 01       	movw	r20, r14
    25e0:	96 01       	movw	r18, r12
    25e2:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    25e6:	f8 01       	movw	r30, r16
    25e8:	22 af       	sts	0x72, r18
    25ea:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    25ec:	e0 e4       	ldi	r30, 0x40	; 64
    25ee:	f8 e0       	ldi	r31, 0x08	; 8
    25f0:	8f 89       	ldd	r24, Y+23	; 0x17
    25f2:	98 8d       	ldd	r25, Y+24	; 0x18
    25f4:	86 a3       	lds	r24, 0x56
    25f6:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    25f8:	80 ed       	ldi	r24, 0xD0	; 208
    25fa:	d2 01       	movw	r26, r4
    25fc:	11 96       	adiw	r26, 0x01	; 1
    25fe:	8c 93       	st	X, r24
    2600:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2602:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2604:	80 81       	ld	r24, Z
    2606:	80 7f       	andi	r24, 0xF0	; 240
    2608:	89 60       	ori	r24, 0x09	; 9
    260a:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    260c:	f8 01       	movw	r30, r16
    260e:	80 81       	ld	r24, Z
    2610:	80 7f       	andi	r24, 0xF0	; 240
    2612:	81 60       	ori	r24, 0x01	; 1
    2614:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2616:	df 91       	pop	r29
    2618:	cf 91       	pop	r28
    261a:	1f 91       	pop	r17
    261c:	0f 91       	pop	r16
    261e:	ff 90       	pop	r15
    2620:	ef 90       	pop	r14
    2622:	df 90       	pop	r13
    2624:	cf 90       	pop	r12
    2626:	bf 90       	pop	r11
    2628:	af 90       	pop	r10
    262a:	9f 90       	pop	r9
    262c:	8f 90       	pop	r8
    262e:	7f 90       	pop	r7
    2630:	5f 90       	pop	r5
    2632:	4f 90       	pop	r4
    2634:	3f 90       	pop	r3
    2636:	2f 90       	pop	r2
    2638:	08 95       	ret

0000263a <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    263a:	2f 92       	push	r2
    263c:	3f 92       	push	r3
    263e:	4f 92       	push	r4
    2640:	5f 92       	push	r5
    2642:	6f 92       	push	r6
    2644:	7f 92       	push	r7
    2646:	8f 92       	push	r8
    2648:	9f 92       	push	r9
    264a:	af 92       	push	r10
    264c:	bf 92       	push	r11
    264e:	cf 92       	push	r12
    2650:	df 92       	push	r13
    2652:	ef 92       	push	r14
    2654:	ff 92       	push	r15
    2656:	0f 93       	push	r16
    2658:	cf 93       	push	r28
    265a:	df 93       	push	r29
    265c:	cd b7       	in	r28, 0x3d	; 61
    265e:	de b7       	in	r29, 0x3e	; 62
    2660:	96 2f       	mov	r25, r22
    2662:	1a 01       	movw	r2, r20
    2664:	52 2f       	mov	r21, r18
    2666:	70 2f       	mov	r23, r16
    2668:	d7 01       	movw	r26, r14
    266a:	36 01       	movw	r6, r12
    266c:	25 01       	movw	r4, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    266e:	00 d0       	rcall	.+0      	; 0x2670 <CO_collectSeismic1Channel+0x36>
    2670:	00 d0       	rcall	.+0      	; 0x2672 <CO_collectSeismic1Channel+0x38>
    2672:	2d b7       	in	r18, 0x3d	; 61
    2674:	3e b7       	in	r19, 0x3e	; 62
    2676:	2f 5f       	subi	r18, 0xFF	; 255
    2678:	3f 4f       	sbci	r19, 0xFF	; 255
    267a:	ed b7       	in	r30, 0x3d	; 61
    267c:	fe b7       	in	r31, 0x3e	; 62
    267e:	81 82       	std	Z+1, r8	; 0x01
    2680:	92 82       	std	Z+2, r9	; 0x02
    2682:	8d 88       	ldd	r8, Y+21	; 0x15
    2684:	9e 88       	ldd	r9, Y+22	; 0x16
    2686:	f9 01       	movw	r30, r18
    2688:	82 82       	std	Z+2, r8	; 0x02
    268a:	93 82       	std	Z+3, r9	; 0x03
    268c:	8f 88       	ldd	r8, Y+23	; 0x17
    268e:	98 8c       	ldd	r9, Y+24	; 0x18
    2690:	84 82       	std	Z+4, r8	; 0x04
    2692:	95 82       	std	Z+5, r9	; 0x05
    2694:	64 ec       	ldi	r22, 0xC4	; 196
    2696:	49 2f       	mov	r20, r25
    2698:	91 01       	movw	r18, r2
    269a:	05 2f       	mov	r16, r21
    269c:	e7 2e       	mov	r14, r23
    269e:	6d 01       	movw	r12, r26
    26a0:	53 01       	movw	r10, r6
    26a2:	42 01       	movw	r8, r4
    26a4:	0e 94 5d 12 	call	0x24ba	; 0x24ba <CO_collectSeismic1Channel_ext>
    26a8:	8d b7       	in	r24, 0x3d	; 61
    26aa:	9e b7       	in	r25, 0x3e	; 62
    26ac:	06 96       	adiw	r24, 0x06	; 6
    26ae:	8d bf       	out	0x3d, r24	; 61
    26b0:	9e bf       	out	0x3e, r25	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    26b2:	df 91       	pop	r29
    26b4:	cf 91       	pop	r28
    26b6:	0f 91       	pop	r16
    26b8:	ff 90       	pop	r15
    26ba:	ef 90       	pop	r14
    26bc:	df 90       	pop	r13
    26be:	cf 90       	pop	r12
    26c0:	bf 90       	pop	r11
    26c2:	af 90       	pop	r10
    26c4:	9f 90       	pop	r9
    26c6:	8f 90       	pop	r8
    26c8:	7f 90       	pop	r7
    26ca:	6f 90       	pop	r6
    26cc:	5f 90       	pop	r5
    26ce:	4f 90       	pop	r4
    26d0:	3f 90       	pop	r3
    26d2:	2f 90       	pop	r2
    26d4:	08 95       	ret

000026d6 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    26d6:	2f 92       	push	r2
    26d8:	3f 92       	push	r3
    26da:	5f 92       	push	r5
    26dc:	6f 92       	push	r6
    26de:	7f 92       	push	r7
    26e0:	8f 92       	push	r8
    26e2:	9f 92       	push	r9
    26e4:	af 92       	push	r10
    26e6:	bf 92       	push	r11
    26e8:	cf 92       	push	r12
    26ea:	df 92       	push	r13
    26ec:	ef 92       	push	r14
    26ee:	ff 92       	push	r15
    26f0:	0f 93       	push	r16
    26f2:	1f 93       	push	r17
    26f4:	cf 93       	push	r28
    26f6:	df 93       	push	r29
    26f8:	0f 92       	push	r0
    26fa:	0f 92       	push	r0
    26fc:	cd b7       	in	r28, 0x3d	; 61
    26fe:	de b7       	in	r29, 0x3e	; 62
    2700:	18 2f       	mov	r17, r24
    2702:	3b 01       	movw	r6, r22
    2704:	49 83       	std	Y+1, r20	; 0x01
    2706:	5a 83       	std	Y+2, r21	; 0x02
    2708:	52 2e       	mov	r5, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER = DataArray;
    270a:	89 8d       	ldd	r24, Y+25	; 0x19
    270c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    270e:	80 93 72 50 	sts	0x5072, r24
    2712:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    2716:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2720:	85 e0       	ldi	r24, 0x05	; 5
    2722:	d3 01       	movw	r26, r6
    2724:	6c 91       	ld	r22, X
    2726:	0e 94 8a 03 	call	0x714	; 0x714 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    272a:	86 e0       	ldi	r24, 0x06	; 6
    272c:	f3 01       	movw	r30, r6
    272e:	61 81       	ldd	r22, Z+1	; 0x01
    2730:	0e 94 8a 03 	call	0x714	; 0x714 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2734:	87 e0       	ldi	r24, 0x07	; 7
    2736:	d3 01       	movw	r26, r6
    2738:	12 96       	adiw	r26, 0x02	; 2
    273a:	6c 91       	ld	r22, X
    273c:	0e 94 8a 03 	call	0x714	; 0x714 <set_ampGain>
	set_filter(filterConfig);
    2740:	81 2f       	mov	r24, r17
    2742:	0e 94 c3 03 	call	0x786	; 0x786 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2746:	80 2f       	mov	r24, r16
    2748:	0e 94 9c 08 	call	0x1138	; 0x1138 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    274c:	84 e0       	ldi	r24, 0x04	; 4
    274e:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2752:	84 e5       	ldi	r24, 0x54	; 84
    2754:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2758:	81 e0       	ldi	r24, 0x01	; 1
    275a:	0e 94 f0 06 	call	0xde0	; 0xde0 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    275e:	85 e0       	ldi	r24, 0x05	; 5
    2760:	0e 94 3b 12 	call	0x2476	; 0x2476 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2764:	e0 ea       	ldi	r30, 0xA0	; 160
    2766:	f6 e0       	ldi	r31, 0x06	; 6
    2768:	22 e0       	ldi	r18, 0x02	; 2
    276a:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    276c:	66 24       	eor	r6, r6
    276e:	63 94       	inc	r6
    2770:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2772:	0f 2e       	mov	r0, r31
    2774:	f0 e8       	ldi	r31, 0x80	; 128
    2776:	2f 2e       	mov	r2, r31
    2778:	f1 e0       	ldi	r31, 0x01	; 1
    277a:	3f 2e       	mov	r3, r31
    277c:	f0 2d       	mov	r31, r0
    277e:	88 e7       	ldi	r24, 0x78	; 120
    2780:	f1 01       	movw	r30, r2
    2782:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2784:	e0 e0       	ldi	r30, 0x00	; 0
    2786:	f8 e0       	ldi	r31, 0x08	; 8
    2788:	80 ef       	ldi	r24, 0xF0	; 240
    278a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    278c:	e0 a6       	lds	r30, 0xb0
    278e:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2790:	c2 a6       	lds	r28, 0xb2
    2792:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2794:	a4 a6       	lds	r26, 0xb4
    2796:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2798:	86 a6       	lds	r24, 0xb6
    279a:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    279c:	85 2d       	mov	r24, r5
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	01 97       	sbiw	r24, 0x01	; 1
    27a2:	86 a3       	lds	r24, 0x56
    27a4:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    27a6:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    27a8:	8f ef       	ldi	r24, 0xFF	; 255
    27aa:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    27ac:	80 81       	ld	r24, Z
    27ae:	80 7f       	andi	r24, 0xF0	; 240
    27b0:	88 60       	ori	r24, 0x08	; 8
    27b2:	80 83       	st	Z, r24

	sampleCount = 0;
    27b4:	10 92 74 50 	sts	0x5074, r1
    27b8:	10 92 75 50 	sts	0x5075, r1
    27bc:	10 92 76 50 	sts	0x5076, r1
    27c0:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    27c4:	10 92 c6 50 	sts	0x50C6, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    27c8:	8d e3       	ldi	r24, 0x3D	; 61
    27ca:	91 e2       	ldi	r25, 0x21	; 33
    27cc:	10 92 3d 21 	sts	0x213D, r1
    27d0:	fc 01       	movw	r30, r24
    27d2:	31 97       	sbiw	r30, 0x01	; 1
    27d4:	10 82       	st	Z, r1
    27d6:	02 97       	sbiw	r24, 0x02	; 2
    27d8:	dc 01       	movw	r26, r24
    27da:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    27dc:	e0 ea       	ldi	r30, 0xA0	; 160
    27de:	f0 e0       	ldi	r31, 0x00	; 0
    27e0:	82 81       	ldd	r24, Z+2	; 0x02
    27e2:	87 60       	ori	r24, 0x07	; 7
    27e4:	82 83       	std	Z+2, r24	; 0x02
	sei();
    27e6:	78 94       	sei

	SPICS(TRUE);
    27e8:	81 e0       	ldi	r24, 0x01	; 1
    27ea:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    27ee:	80 e2       	ldi	r24, 0x20	; 32
    27f0:	e0 e8       	ldi	r30, 0x80	; 128
    27f2:	f6 e0       	ldi	r31, 0x06	; 6
    27f4:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    27f6:	00 e4       	ldi	r16, 0x40	; 64
    27f8:	1a e0       	ldi	r17, 0x0A	; 10
    27fa:	83 e2       	ldi	r24, 0x23	; 35
    27fc:	f8 01       	movw	r30, r16
    27fe:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2800:	89 81       	ldd	r24, Y+1	; 0x01
    2802:	9a 81       	ldd	r25, Y+2	; 0x02
    2804:	6c 01       	movw	r12, r24
    2806:	ee 24       	eor	r14, r14
    2808:	ff 24       	eor	r15, r15
    280a:	60 e8       	ldi	r22, 0x80	; 128
    280c:	74 e8       	ldi	r23, 0x84	; 132
    280e:	8e e1       	ldi	r24, 0x1E	; 30
    2810:	90 e0       	ldi	r25, 0x00	; 0
    2812:	a7 01       	movw	r20, r14
    2814:	96 01       	movw	r18, r12
    2816:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    281a:	d8 01       	movw	r26, r16
    281c:	96 96       	adiw	r26, 0x26	; 38
    281e:	2d 93       	st	X+, r18
    2820:	3c 93       	st	X, r19
    2822:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2824:	60 e4       	ldi	r22, 0x40	; 64
    2826:	72 e4       	ldi	r23, 0x42	; 66
    2828:	8f e0       	ldi	r24, 0x0F	; 15
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	a7 01       	movw	r20, r14
    282e:	96 01       	movw	r18, r12
    2830:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    2834:	f8 01       	movw	r30, r16
    2836:	22 af       	sts	0x72, r18
    2838:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    283a:	e0 e4       	ldi	r30, 0x40	; 64
    283c:	f8 e0       	ldi	r31, 0x08	; 8
    283e:	8f 89       	ldd	r24, Y+23	; 0x17
    2840:	98 8d       	ldd	r25, Y+24	; 0x18
    2842:	86 a3       	lds	r24, 0x56
    2844:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2846:	80 ec       	ldi	r24, 0xC0	; 192
    2848:	d1 01       	movw	r26, r2
    284a:	11 96       	adiw	r26, 0x01	; 1
    284c:	8c 93       	st	X, r24
    284e:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2850:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2852:	80 81       	ld	r24, Z
    2854:	80 7f       	andi	r24, 0xF0	; 240
    2856:	89 60       	ori	r24, 0x09	; 9
    2858:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    285a:	f8 01       	movw	r30, r16
    285c:	80 81       	ld	r24, Z
    285e:	80 7f       	andi	r24, 0xF0	; 240
    2860:	81 60       	ori	r24, 0x01	; 1
    2862:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2864:	0f 90       	pop	r0
    2866:	0f 90       	pop	r0
    2868:	df 91       	pop	r29
    286a:	cf 91       	pop	r28
    286c:	1f 91       	pop	r17
    286e:	0f 91       	pop	r16
    2870:	ff 90       	pop	r15
    2872:	ef 90       	pop	r14
    2874:	df 90       	pop	r13
    2876:	cf 90       	pop	r12
    2878:	bf 90       	pop	r11
    287a:	af 90       	pop	r10
    287c:	9f 90       	pop	r9
    287e:	8f 90       	pop	r8
    2880:	7f 90       	pop	r7
    2882:	6f 90       	pop	r6
    2884:	5f 90       	pop	r5
    2886:	3f 90       	pop	r3
    2888:	2f 90       	pop	r2
    288a:	08 95       	ret

0000288c <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    288c:	2f 92       	push	r2
    288e:	3f 92       	push	r3
    2890:	4f 92       	push	r4
    2892:	5f 92       	push	r5
    2894:	6f 92       	push	r6
    2896:	7f 92       	push	r7
    2898:	8f 92       	push	r8
    289a:	9f 92       	push	r9
    289c:	af 92       	push	r10
    289e:	bf 92       	push	r11
    28a0:	cf 92       	push	r12
    28a2:	df 92       	push	r13
    28a4:	ef 92       	push	r14
    28a6:	ff 92       	push	r15
    28a8:	0f 93       	push	r16
    28aa:	1f 93       	push	r17
    28ac:	cf 93       	push	r28
    28ae:	df 93       	push	r29
    28b0:	00 d0       	rcall	.+0      	; 0x28b2 <CO_collectSeismic3Axises+0x26>
    28b2:	0f 92       	push	r0
    28b4:	cd b7       	in	r28, 0x3d	; 61
    28b6:	de b7       	in	r29, 0x3e	; 62
    28b8:	8b 83       	std	Y+3, r24	; 0x03
    28ba:	9c 83       	std	Y+4, r25	; 0x04
    28bc:	db 01       	movw	r26, r22
    28be:	94 2f       	mov	r25, r20
    28c0:	32 2f       	mov	r19, r18
    28c2:	38 01       	movw	r6, r16
    28c4:	27 01       	movw	r4, r14
    28c6:	16 01       	movw	r2, r12
    28c8:	a9 82       	std	Y+1, r10	; 0x01
    28ca:	ba 82       	std	Y+2, r11	; 0x02
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    28cc:	00 d0       	rcall	.+0      	; 0x28ce <CO_collectSeismic3Axises+0x42>
    28ce:	0f 92       	push	r0
    28d0:	ed b7       	in	r30, 0x3d	; 61
    28d2:	fe b7       	in	r31, 0x3e	; 62
    28d4:	81 82       	std	Z+1, r8	; 0x01
    28d6:	92 82       	std	Z+2, r9	; 0x02
    28d8:	4a 8d       	ldd	r20, Y+26	; 0x1a
    28da:	5b 8d       	ldd	r21, Y+27	; 0x1b
    28dc:	43 83       	std	Z+3, r20	; 0x03
    28de:	54 83       	std	Z+4, r21	; 0x04
    28e0:	84 ec       	ldi	r24, 0xC4	; 196
    28e2:	6b 81       	ldd	r22, Y+3	; 0x03
    28e4:	7c 81       	ldd	r23, Y+4	; 0x04
    28e6:	ad 01       	movw	r20, r26
    28e8:	29 2f       	mov	r18, r25
    28ea:	03 2f       	mov	r16, r19
    28ec:	73 01       	movw	r14, r6
    28ee:	62 01       	movw	r12, r4
    28f0:	51 01       	movw	r10, r2
    28f2:	89 80       	ldd	r8, Y+1	; 0x01
    28f4:	9a 80       	ldd	r9, Y+2	; 0x02
    28f6:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <CO_collectSeismic3Axises_ext>
    28fa:	0f 90       	pop	r0
    28fc:	0f 90       	pop	r0
    28fe:	0f 90       	pop	r0
    2900:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    2902:	24 96       	adiw	r28, 0x04	; 4
    2904:	cd bf       	out	0x3d, r28	; 61
    2906:	de bf       	out	0x3e, r29	; 62
    2908:	df 91       	pop	r29
    290a:	cf 91       	pop	r28
    290c:	1f 91       	pop	r17
    290e:	0f 91       	pop	r16
    2910:	ff 90       	pop	r15
    2912:	ef 90       	pop	r14
    2914:	df 90       	pop	r13
    2916:	cf 90       	pop	r12
    2918:	bf 90       	pop	r11
    291a:	af 90       	pop	r10
    291c:	9f 90       	pop	r9
    291e:	8f 90       	pop	r8
    2920:	7f 90       	pop	r7
    2922:	6f 90       	pop	r6
    2924:	5f 90       	pop	r5
    2926:	4f 90       	pop	r4
    2928:	3f 90       	pop	r3
    292a:	2f 90       	pop	r2
    292c:	08 95       	ret

0000292e <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    292e:	8f 92       	push	r8
    2930:	9f 92       	push	r9
    2932:	af 92       	push	r10
    2934:	bf 92       	push	r11
    2936:	df 92       	push	r13
    2938:	ef 92       	push	r14
    293a:	ff 92       	push	r15
    293c:	0f 93       	push	r16
    293e:	1f 93       	push	r17
    2940:	cf 93       	push	r28
    2942:	df 93       	push	r29
    2944:	c8 2f       	mov	r28, r24
    2946:	d6 2e       	mov	r13, r22
    2948:	d4 2f       	mov	r29, r20
    294a:	59 01       	movw	r10, r18
    294c:	48 01       	movw	r8, r16
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif

	uint16_t period;
	ADC_BUFFER = DataArray;
    294e:	e0 92 72 50 	sts	0x5072, r14
    2952:	f0 92 73 50 	sts	0x5073, r15
	ADC_Sampling_Finished = 0;
    2956:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    295a:	81 e0       	ldi	r24, 0x01	; 1
    295c:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    2960:	8c 2f       	mov	r24, r28
    2962:	6d 2f       	mov	r22, r29
    2964:	0e 94 8a 03 	call	0x714	; 0x714 <set_ampGain>
	set_filter(filterConfig);
    2968:	8d 2d       	mov	r24, r13
    296a:	0e 94 c3 03 	call	0x786	; 0x786 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    296e:	8c 2f       	mov	r24, r28
    2970:	85 50       	subi	r24, 0x05	; 5
    2972:	83 30       	cpi	r24, 0x03	; 3
    2974:	18 f4       	brcc	.+6      	; 0x297c <CO_collectADC_ext+0x4e>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2976:	81 e0       	ldi	r24, 0x01	; 1
    2978:	0e 94 9c 08 	call	0x1138	; 0x1138 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    297c:	81 e0       	ldi	r24, 0x01	; 1
    297e:	0e 94 f0 06 	call	0xde0	; 0xde0 <enableADCMUX>
	setADCInput(channel);
    2982:	8c 2f       	mov	r24, r28
    2984:	0e 94 3b 12 	call	0x2476	; 0x2476 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2988:	84 e0       	ldi	r24, 0x04	; 4
    298a:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    298e:	84 e5       	ldi	r24, 0x54	; 84
    2990:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2994:	e0 ea       	ldi	r30, 0xA0	; 160
    2996:	f6 e0       	ldi	r31, 0x06	; 6
    2998:	dd 24       	eor	r13, r13
    299a:	d3 94       	inc	r13
    299c:	d2 82       	std	Z+2, r13	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    299e:	82 e0       	ldi	r24, 0x02	; 2
    29a0:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    29a2:	d2 86       	std	Z+10, r13	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    29a4:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    29a6:	80 e2       	ldi	r24, 0x20	; 32
    29a8:	e0 e8       	ldi	r30, 0x80	; 128
    29aa:	f6 e0       	ldi	r31, 0x06	; 6
    29ac:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    29ae:	c0 e4       	ldi	r28, 0x40	; 64
    29b0:	da e0       	ldi	r29, 0x0A	; 10
    29b2:	83 e2       	ldi	r24, 0x23	; 35
    29b4:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    29b6:	95 01       	movw	r18, r10
    29b8:	40 e0       	ldi	r20, 0x00	; 0
    29ba:	50 e0       	ldi	r21, 0x00	; 0
    29bc:	60 e8       	ldi	r22, 0x80	; 128
    29be:	74 e8       	ldi	r23, 0x84	; 132
    29c0:	8e e1       	ldi	r24, 0x1E	; 30
    29c2:	90 e0       	ldi	r25, 0x00	; 0
    29c4:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    29c8:	89 01       	movw	r16, r18
    29ca:	9a 01       	movw	r18, r20
    29cc:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    29ce:	0e a3       	lds	r16, 0x5e
    29d0:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    29d2:	96 95       	lsr	r25
    29d4:	87 95       	ror	r24
    29d6:	8a af       	sts	0x7a, r24
    29d8:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    29da:	e0 e4       	ldi	r30, 0x40	; 64
    29dc:	f8 e0       	ldi	r31, 0x08	; 8
    29de:	86 a2       	lds	r24, 0x96
    29e0:	97 a2       	lds	r25, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    29e2:	88 e7       	ldi	r24, 0x78	; 120
    29e4:	a0 e8       	ldi	r26, 0x80	; 128
    29e6:	b1 e0       	ldi	r27, 0x01	; 1
    29e8:	11 96       	adiw	r26, 0x01	; 1
    29ea:	8c 93       	st	X, r24
    29ec:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    29ee:	d6 82       	std	Z+6, r13	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    29f0:	88 81       	ld	r24, Y
    29f2:	80 7f       	andi	r24, 0xF0	; 240
    29f4:	81 60       	ori	r24, 0x01	; 1
    29f6:	88 83       	st	Y, r24
	
	sampleCount = 0;
    29f8:	10 92 74 50 	sts	0x5074, r1
    29fc:	10 92 75 50 	sts	0x5075, r1
    2a00:	10 92 76 50 	sts	0x5076, r1
    2a04:	10 92 77 50 	sts	0x5077, r1
	discardCount = 0;
    2a08:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2a0c:	e0 ea       	ldi	r30, 0xA0	; 160
    2a0e:	f0 e0       	ldi	r31, 0x00	; 0
    2a10:	82 81       	ldd	r24, Z+2	; 0x02
    2a12:	83 60       	ori	r24, 0x03	; 3
    2a14:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2a16:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2a18:	df 91       	pop	r29
    2a1a:	cf 91       	pop	r28
    2a1c:	1f 91       	pop	r17
    2a1e:	0f 91       	pop	r16
    2a20:	ff 90       	pop	r15
    2a22:	ef 90       	pop	r14
    2a24:	df 90       	pop	r13
    2a26:	bf 90       	pop	r11
    2a28:	af 90       	pop	r10
    2a2a:	9f 90       	pop	r9
    2a2c:	8f 90       	pop	r8
    2a2e:	08 95       	ret

00002a30 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2a30:	ef 92       	push	r14
    2a32:	ff 92       	push	r15
    2a34:	0f 93       	push	r16
    2a36:	1f 93       	push	r17
    2a38:	96 2f       	mov	r25, r22
    2a3a:	fa 01       	movw	r30, r20
    2a3c:	d9 01       	movw	r26, r18
    2a3e:	78 01       	movw	r14, r16
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    2a40:	64 ec       	ldi	r22, 0xC4	; 196
    2a42:	49 2f       	mov	r20, r25
    2a44:	9f 01       	movw	r18, r30
    2a46:	8d 01       	movw	r16, r26
    2a48:	0e 94 97 14 	call	0x292e	; 0x292e <CO_collectADC_ext>
}
    2a4c:	1f 91       	pop	r17
    2a4e:	0f 91       	pop	r16
    2a50:	ff 90       	pop	r15
    2a52:	ef 90       	pop	r14
    2a54:	08 95       	ret

00002a56 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2a56:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2a5c:	84 81       	ldd	r24, Z+4	; 0x04
    2a5e:	95 81       	ldd	r25, Z+5	; 0x05
    2a60:	86 1b       	sub	r24, r22
    2a62:	91 09       	sbc	r25, r1

	return answer;
}
    2a64:	08 95       	ret

00002a66 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2a66:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2a68:	81 e0       	ldi	r24, 0x01	; 1
    2a6a:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2a6c:	84 81       	ldd	r24, Z+4	; 0x04
    2a6e:	95 81       	ldd	r25, Z+5	; 0x05
    2a70:	77 27       	eor	r23, r23
    2a72:	67 fd       	sbrc	r22, 7
    2a74:	70 95       	com	r23
    2a76:	86 1b       	sub	r24, r22
    2a78:	97 0b       	sbc	r25, r23

	return answer;
}
    2a7a:	08 95       	ret

00002a7c <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2a7c:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2a7e:	81 e0       	ldi	r24, 0x01	; 1
    2a80:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    2a82:	84 81       	ldd	r24, Z+4	; 0x04
    2a84:	95 81       	ldd	r25, Z+5	; 0x05
}
    2a86:	08 95       	ret

00002a88 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2a88:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2a8a:	81 e0       	ldi	r24, 0x01	; 1
    2a8c:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2a8e:	84 81       	ldd	r24, Z+4	; 0x04
}
    2a90:	08 95       	ret

00002a92 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    2a92:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2a94:	81 e0       	ldi	r24, 0x01	; 1
    2a96:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2a98:	85 81       	ldd	r24, Z+5	; 0x05
}
    2a9a:	08 95       	ret

00002a9c <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2a9c:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2a9e:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    2aa0:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2aa2:	9a e2       	ldi	r25, 0x2A	; 42
    2aa4:	9a 95       	dec	r25
    2aa6:	f1 f7       	brne	.-4      	; 0x2aa4 <ADC_Wait_8MHz+0x8>
    2aa8:	00 c0       	rjmp	.+0      	; 0x2aaa <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2aaa:	84 83       	std	Z+4, r24	; 0x04
}
    2aac:	08 95       	ret

00002aae <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2aae:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2ab0:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    2ab2:	91 e0       	ldi	r25, 0x01	; 1
    2ab4:	94 83       	std	Z+4, r25	; 0x04
    2ab6:	95 e5       	ldi	r25, 0x55	; 85
    2ab8:	9a 95       	dec	r25
    2aba:	f1 f7       	brne	.-4      	; 0x2ab8 <ADC_Wait_32MHz+0xa>
    2abc:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2abe:	84 83       	std	Z+4, r24	; 0x04
}
    2ac0:	08 95       	ret

00002ac2 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2ac2:	ef 92       	push	r14
    2ac4:	ff 92       	push	r15
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	eb 01       	movw	r28, r22
    if (oversampling)
    2ad0:	44 23       	and	r20, r20
    2ad2:	c9 f0       	breq	.+50     	; 0x2b06 <ADC_Offset_Get_Unsigned+0x44>
    2ad4:	04 e0       	ldi	r16, 0x04	; 4
    2ad6:	10 e0       	ldi	r17, 0x00	; 0
    2ad8:	ee 24       	eor	r14, r14
    2ada:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2adc:	88 81       	ld	r24, Y
    2ade:	80 68       	ori	r24, 0x80	; 128
    2ae0:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	80 ff       	sbrs	r24, 0
    2ae6:	fd cf       	rjmp	.-6      	; 0x2ae2 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    2ae8:	ce 01       	movw	r24, r28
    2aea:	60 e0       	ldi	r22, 0x00	; 0
    2aec:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <ADC_ResultCh_GetWord_Unsigned>
    2af0:	e8 0e       	add	r14, r24
    2af2:	f9 1e       	adc	r15, r25
    2af4:	01 50       	subi	r16, 0x01	; 1
    2af6:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    2af8:	89 f7       	brne	.-30     	; 0x2adc <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    2afa:	c7 01       	movw	r24, r14
    2afc:	96 95       	lsr	r25
    2afe:	87 95       	ror	r24
    2b00:	96 95       	lsr	r25
    2b02:	87 95       	ror	r24
    2b04:	09 c0       	rjmp	.+18     	; 0x2b18 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2b06:	88 81       	ld	r24, Y
    2b08:	80 68       	ori	r24, 0x80	; 128
    2b0a:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0e:	80 ff       	sbrs	r24, 0
    2b10:	fd cf       	rjmp	.-6      	; 0x2b0c <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    2b12:	ce 01       	movw	r24, r28
    2b14:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    2b18:	df 91       	pop	r29
    2b1a:	cf 91       	pop	r28
    2b1c:	1f 91       	pop	r17
    2b1e:	0f 91       	pop	r16
    2b20:	ff 90       	pop	r15
    2b22:	ef 90       	pop	r14
    2b24:	08 95       	ret

00002b26 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2b26:	ef 92       	push	r14
    2b28:	ff 92       	push	r15
    2b2a:	0f 93       	push	r16
    2b2c:	1f 93       	push	r17
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	eb 01       	movw	r28, r22
    if (oversampling)
    2b34:	44 23       	and	r20, r20
    2b36:	e1 f0       	breq	.+56     	; 0x2b70 <ADC_Offset_Get_Signed+0x4a>
    2b38:	04 e0       	ldi	r16, 0x04	; 4
    2b3a:	10 e0       	ldi	r17, 0x00	; 0
    2b3c:	ee 24       	eor	r14, r14
    2b3e:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2b40:	88 81       	ld	r24, Y
    2b42:	80 68       	ori	r24, 0x80	; 128
    2b44:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2b46:	8b 81       	ldd	r24, Y+3	; 0x03
    2b48:	80 ff       	sbrs	r24, 0
    2b4a:	fd cf       	rjmp	.-6      	; 0x2b46 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2b4c:	ce 01       	movw	r24, r28
    2b4e:	60 e0       	ldi	r22, 0x00	; 0
    2b50:	0e 94 33 15 	call	0x2a66	; 0x2a66 <ADC_ResultCh_GetWord_Signed>
    2b54:	e8 0e       	add	r14, r24
    2b56:	f9 1e       	adc	r15, r25
    2b58:	01 50       	subi	r16, 0x01	; 1
    2b5a:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2b5c:	89 f7       	brne	.-30     	; 0x2b40 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    2b5e:	c7 01       	movw	r24, r14
    2b60:	99 23       	and	r25, r25
    2b62:	0c f4       	brge	.+2      	; 0x2b66 <ADC_Offset_Get_Signed+0x40>
    2b64:	03 96       	adiw	r24, 0x03	; 3
    2b66:	95 95       	asr	r25
    2b68:	87 95       	ror	r24
    2b6a:	95 95       	asr	r25
    2b6c:	87 95       	ror	r24
    2b6e:	0a c0       	rjmp	.+20     	; 0x2b84 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2b70:	88 81       	ld	r24, Y
    2b72:	80 68       	ori	r24, 0x80	; 128
    2b74:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2b76:	8b 81       	ldd	r24, Y+3	; 0x03
    2b78:	80 ff       	sbrs	r24, 0
    2b7a:	fd cf       	rjmp	.-6      	; 0x2b76 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2b7c:	ce 01       	movw	r24, r28
    2b7e:	60 e0       	ldi	r22, 0x00	; 0
    2b80:	0e 94 33 15 	call	0x2a66	; 0x2a66 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    2b84:	df 91       	pop	r29
    2b86:	cf 91       	pop	r28
    2b88:	1f 91       	pop	r17
    2b8a:	0f 91       	pop	r16
    2b8c:	ff 90       	pop	r15
    2b8e:	ef 90       	pop	r14
    2b90:	08 95       	ret

00002b92 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    2b92:	aa ec       	ldi	r26, 0xCA	; 202
    2b94:	b1 e0       	ldi	r27, 0x01	; 1
    2b96:	92 e0       	ldi	r25, 0x02	; 2
    2b98:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    2b9a:	e8 2f       	mov	r30, r24
    2b9c:	f0 e0       	ldi	r31, 0x00	; 0
    2b9e:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    2ba0:	1c 92       	st	X, r1

	return result;
}
    2ba2:	08 95       	ret

00002ba4 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    2ba4:	cf 93       	push	r28
    2ba6:	df 93       	push	r29
    2ba8:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    2baa:	82 e0       	ldi	r24, 0x02	; 2
    2bac:	c0 30       	cpi	r28, 0x00	; 0
    2bae:	d8 07       	cpc	r29, r24
    2bb0:	59 f4       	brne	.+22     	; 0x2bc8 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    2bb2:	80 e2       	ldi	r24, 0x20	; 32
    2bb4:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <SP_ReadCalibrationByte>
    2bb8:	c0 e0       	ldi	r28, 0x00	; 0
    2bba:	d2 e0       	ldi	r29, 0x02	; 2
    2bbc:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    2bbe:	81 e2       	ldi	r24, 0x21	; 33
    2bc0:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <SP_ReadCalibrationByte>
    2bc4:	8d 87       	std	Y+13, r24	; 0x0d
    2bc6:	08 c0       	rjmp	.+16     	; 0x2bd8 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    2bc8:	84 e2       	ldi	r24, 0x24	; 36
    2bca:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <SP_ReadCalibrationByte>
    2bce:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    2bd0:	85 e2       	ldi	r24, 0x25	; 37
    2bd2:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <SP_ReadCalibrationByte>
    2bd6:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    2bd8:	df 91       	pop	r29
    2bda:	cf 91       	pop	r28
    2bdc:	08 95       	ret

00002bde <radio_msg_received_int_enable>:
	radio_msg_received_int_enable();
}

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    2bde:	e0 e8       	ldi	r30, 0x80	; 128
    2be0:	f6 e0       	ldi	r31, 0x06	; 6
    2be2:	84 e0       	ldi	r24, 0x04	; 4
    2be4:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    2be6:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2be8:	92 e0       	ldi	r25, 0x02	; 2
    2bea:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    2bec:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    2bee:	83 e0       	ldi	r24, 0x03	; 3
    2bf0:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    2bf2:	e0 ea       	ldi	r30, 0xA0	; 160
    2bf4:	f0 e0       	ldi	r31, 0x00	; 0
    2bf6:	82 81       	ldd	r24, Z+2	; 0x02
    2bf8:	84 60       	ori	r24, 0x04	; 4
    2bfa:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2bfc:	78 94       	sei
}
    2bfe:	08 95       	ret

00002c00 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    2c00:	84 e1       	ldi	r24, 0x14	; 20
    2c02:	ee e3       	ldi	r30, 0x3E	; 62
    2c04:	f1 e2       	ldi	r31, 0x21	; 33
    2c06:	df 01       	movw	r26, r30
    2c08:	1d 92       	st	X+, r1
    2c0a:	8a 95       	dec	r24
    2c0c:	e9 f7       	brne	.-6      	; 0x2c08 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    2c0e:	0e 94 75 17 	call	0x2eea	; 0x2eea <chb_get_short_addr>
    2c12:	80 93 3e 21 	sts	0x213E, r24
    2c16:	90 93 3f 21 	sts	0x213F, r25
    chb_drvr_init();
    2c1a:	0e 94 c7 19 	call	0x338e	; 0x338e <chb_drvr_init>
	radio_msg_received_int_enable();
    2c1e:	0e 94 ef 15 	call	0x2bde	; 0x2bde <radio_msg_received_int_enable>
}
    2c22:	08 95       	ret

00002c24 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    2c24:	8e e3       	ldi	r24, 0x3E	; 62
    2c26:	91 e2       	ldi	r25, 0x21	; 33
    2c28:	08 95       	ret

00002c2a <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    2c2a:	2f 92       	push	r2
    2c2c:	3f 92       	push	r3
    2c2e:	4f 92       	push	r4
    2c30:	5f 92       	push	r5
    2c32:	6f 92       	push	r6
    2c34:	7f 92       	push	r7
    2c36:	8f 92       	push	r8
    2c38:	9f 92       	push	r9
    2c3a:	af 92       	push	r10
    2c3c:	bf 92       	push	r11
    2c3e:	cf 92       	push	r12
    2c40:	df 92       	push	r13
    2c42:	ef 92       	push	r14
    2c44:	ff 92       	push	r15
    2c46:	0f 93       	push	r16
    2c48:	1f 93       	push	r17
    2c4a:	cf 93       	push	r28
    2c4c:	df 93       	push	r29
    2c4e:	cd b7       	in	r28, 0x3d	; 61
    2c50:	de b7       	in	r29, 0x3e	; 62
    2c52:	2e 97       	sbiw	r28, 0x0e	; 14
    2c54:	cd bf       	out	0x3d, r28	; 61
    2c56:	de bf       	out	0x3e, r29	; 62
    2c58:	8b 87       	std	Y+11, r24	; 0x0b
    2c5a:	9c 87       	std	Y+12, r25	; 0x0c
    2c5c:	6d 87       	std	Y+13, r22	; 0x0d
    2c5e:	7e 87       	std	Y+14, r23	; 0x0e
    2c60:	49 01       	movw	r8, r18
    2c62:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2c64:	21 15       	cp	r18, r1
    2c66:	31 05       	cpc	r19, r1
    2c68:	41 05       	cpc	r20, r1
    2c6a:	51 05       	cpc	r21, r1
    2c6c:	09 f4       	brne	.+2      	; 0x2c70 <chb_write+0x46>
    2c6e:	88 c0       	rjmp	.+272    	; 0x2d80 <chb_write+0x156>
{
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    2c70:	ee 24       	eor	r14, r14
                 pcb.txd_noack++;
				 rtry++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2c72:	0f 2e       	mov	r0, r31
    2c74:	f9 e4       	ldi	r31, 0x49	; 73
    2c76:	6f 2e       	mov	r6, r31
    2c78:	f1 e2       	ldi	r31, 0x21	; 33
    2c7a:	7f 2e       	mov	r7, r31
    2c7c:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2c7e:	0f 2e       	mov	r0, r31
    2c80:	f5 e4       	ldi	r31, 0x45	; 69
    2c82:	4f 2e       	mov	r4, r31
    2c84:	f1 e2       	ldi	r31, 0x21	; 33
    2c86:	5f 2e       	mov	r5, r31
    2c88:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2c8a:	0f 2e       	mov	r0, r31
    2c8c:	f7 e4       	ldi	r31, 0x47	; 71
    2c8e:	2f 2e       	mov	r2, r31
    2c90:	f1 e2       	ldi	r31, 0x21	; 33
    2c92:	3f 2e       	mov	r3, r31
    2c94:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    2c96:	f8 2c       	mov	r15, r8
    2c98:	25 e6       	ldi	r18, 0x65	; 101
    2c9a:	82 16       	cp	r8, r18
    2c9c:	91 04       	cpc	r9, r1
    2c9e:	a1 04       	cpc	r10, r1
    2ca0:	b1 04       	cpc	r11, r1
    2ca2:	20 f0       	brcs	.+8      	; 0x2cac <chb_write+0x82>
    2ca4:	0f 2e       	mov	r0, r31
    2ca6:	f4 e6       	ldi	r31, 0x64	; 100
    2ca8:	ff 2e       	mov	r15, r31
    2caa:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    2cac:	8f 2d       	mov	r24, r15
    2cae:	85 5f       	subi	r24, 0xF5	; 245
    2cb0:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    2cb2:	8b 85       	ldd	r24, Y+11	; 0x0b
    2cb4:	9c 85       	ldd	r25, Y+12	; 0x0c
    2cb6:	ef ef       	ldi	r30, 0xFF	; 255
    2cb8:	8f 3f       	cpi	r24, 0xFF	; 255
    2cba:	9e 07       	cpc	r25, r30
    2cbc:	11 f0       	breq	.+4      	; 0x2cc2 <chb_write+0x98>
    2cbe:	81 e6       	ldi	r24, 0x61	; 97
    2cc0:	01 c0       	rjmp	.+2      	; 0x2cc4 <chb_write+0x9a>
    2cc2:	81 e4       	ldi	r24, 0x41	; 65
    2cc4:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    2cc6:	88 e9       	ldi	r24, 0x98	; 152
    2cc8:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
    2cca:	e0 e4       	ldi	r30, 0x40	; 64
    2ccc:	f1 e2       	ldi	r31, 0x21	; 33
    2cce:	80 81       	ld	r24, Z
    2cd0:	8c 83       	std	Y+4, r24	; 0x04
    2cd2:	8f 5f       	subi	r24, 0xFF	; 255
    2cd4:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    2cd6:	84 e3       	ldi	r24, 0x34	; 52
    2cd8:	92 e1       	ldi	r25, 0x12	; 18
    2cda:	8d 83       	std	Y+5, r24	; 0x05
    2cdc:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    2cde:	8b 85       	ldd	r24, Y+11	; 0x0b
    2ce0:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ce2:	8f 83       	std	Y+7, r24	; 0x07
    2ce4:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    2ce6:	32 97       	sbiw	r30, 0x02	; 2
    2ce8:	80 81       	ld	r24, Z
    2cea:	91 81       	ldd	r25, Z+1	; 0x01
    2cec:	89 87       	std	Y+9, r24	; 0x09
    2cee:	9a 87       	std	Y+10, r25	; 0x0a
        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
    2cf0:	00 e0       	ldi	r16, 0x00	; 0
    2cf2:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    2cf4:	cd 84       	ldd	r12, Y+13	; 0x0d
    2cf6:	de 84       	ldd	r13, Y+14	; 0x0e
    2cf8:	ce 0c       	add	r12, r14
    2cfa:	d1 1c       	adc	r13, r1
    2cfc:	ce 01       	movw	r24, r28
    2cfe:	01 96       	adiw	r24, 0x01	; 1
    2d00:	b6 01       	movw	r22, r12
    2d02:	4f 2d       	mov	r20, r15
    2d04:	0e 94 03 19 	call	0x3206	; 0x3206 <chb_tx>
    2d08:	28 2f       	mov	r18, r24

             switch (status)
    2d0a:	83 30       	cpi	r24, 0x03	; 3
    2d0c:	c9 f0       	breq	.+50     	; 0x2d40 <chb_write+0x116>
    2d0e:	84 30       	cpi	r24, 0x04	; 4
    2d10:	18 f4       	brcc	.+6      	; 0x2d18 <chb_write+0xee>
    2d12:	81 30       	cpi	r24, 0x01	; 1
    2d14:	e9 f4       	brne	.+58     	; 0x2d50 <chb_write+0x126>
    2d16:	04 c0       	rjmp	.+8      	; 0x2d20 <chb_write+0xf6>
    2d18:	85 30       	cpi	r24, 0x05	; 5
    2d1a:	49 f0       	breq	.+18     	; 0x2d2e <chb_write+0x104>
    2d1c:	80 34       	cpi	r24, 0x40	; 64
    2d1e:	c1 f4       	brne	.+48     	; 0x2d50 <chb_write+0x126>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2d20:	f2 01       	movw	r30, r4
    2d22:	80 81       	ld	r24, Z
    2d24:	91 81       	ldd	r25, Z+1	; 0x01
    2d26:	01 96       	adiw	r24, 0x01	; 1
    2d28:	80 83       	st	Z, r24
    2d2a:	91 83       	std	Z+1, r25	; 0x01
                 break;
    2d2c:	11 c0       	rjmp	.+34     	; 0x2d50 <chb_write+0x126>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2d2e:	f1 01       	movw	r30, r2
    2d30:	80 81       	ld	r24, Z
    2d32:	91 81       	ldd	r25, Z+1	; 0x01
    2d34:	01 96       	adiw	r24, 0x01	; 1
    2d36:	80 83       	st	Z, r24
    2d38:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2d3a:	0f 5f       	subi	r16, 0xFF	; 255
    2d3c:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
    2d3e:	08 c0       	rjmp	.+16     	; 0x2d50 <chb_write+0x126>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2d40:	f3 01       	movw	r30, r6
    2d42:	80 81       	ld	r24, Z
    2d44:	91 81       	ldd	r25, Z+1	; 0x01
    2d46:	01 96       	adiw	r24, 0x01	; 1
    2d48:	80 83       	st	Z, r24
    2d4a:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2d4c:	0f 5f       	subi	r16, 0xFF	; 255
    2d4e:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
 
             default:
                 break;
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    2d50:	10 16       	cp	r1, r16
    2d52:	11 06       	cpc	r1, r17
    2d54:	24 f4       	brge	.+8      	; 0x2d5e <chb_write+0x134>
    2d56:	fa e6       	ldi	r31, 0x6A	; 106
    2d58:	fa 95       	dec	r31
    2d5a:	f1 f7       	brne	.-4      	; 0x2d58 <chb_write+0x12e>
    2d5c:	00 c0       	rjmp	.+0      	; 0x2d5e <chb_write+0x134>
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    2d5e:	04 31       	cpi	r16, 0x14	; 20
    2d60:	11 05       	cpc	r17, r1
    2d62:	79 f0       	breq	.+30     	; 0x2d82 <chb_write+0x158>
		} while(status != CHB_SUCCESS);			
    2d64:	22 23       	and	r18, r18
    2d66:	51 f6       	brne	.-108    	; 0x2cfc <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
    2d68:	ef 0c       	add	r14, r15
        len = len - frm_len;
    2d6a:	8f 18       	sub	r8, r15
    2d6c:	91 08       	sbc	r9, r1
    2d6e:	a1 08       	sbc	r10, r1
    2d70:	b1 08       	sbc	r11, r1
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2d72:	81 14       	cp	r8, r1
    2d74:	91 04       	cpc	r9, r1
    2d76:	a1 04       	cpc	r10, r1
    2d78:	b1 04       	cpc	r11, r1
    2d7a:	09 f0       	breq	.+2      	; 0x2d7e <chb_write+0x154>
    2d7c:	8c cf       	rjmp	.-232    	; 0x2c96 <chb_write+0x6c>
    2d7e:	01 c0       	rjmp	.+2      	; 0x2d82 <chb_write+0x158>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    2d80:	20 e0       	ldi	r18, 0x00	; 0
}
    2d82:	82 2f       	mov	r24, r18
    2d84:	2e 96       	adiw	r28, 0x0e	; 14
    2d86:	cd bf       	out	0x3d, r28	; 61
    2d88:	de bf       	out	0x3e, r29	; 62
    2d8a:	df 91       	pop	r29
    2d8c:	cf 91       	pop	r28
    2d8e:	1f 91       	pop	r17
    2d90:	0f 91       	pop	r16
    2d92:	ff 90       	pop	r15
    2d94:	ef 90       	pop	r14
    2d96:	df 90       	pop	r13
    2d98:	cf 90       	pop	r12
    2d9a:	bf 90       	pop	r11
    2d9c:	af 90       	pop	r10
    2d9e:	9f 90       	pop	r9
    2da0:	8f 90       	pop	r8
    2da2:	7f 90       	pop	r7
    2da4:	6f 90       	pop	r6
    2da6:	5f 90       	pop	r5
    2da8:	4f 90       	pop	r4
    2daa:	3f 90       	pop	r3
    2dac:	2f 90       	pop	r2
    2dae:	08 95       	ret

00002db0 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    2db0:	df 92       	push	r13
    2db2:	ef 92       	push	r14
    2db4:	ff 92       	push	r15
    2db6:	0f 93       	push	r16
    2db8:	1f 93       	push	r17
    2dba:	cf 93       	push	r28
    2dbc:	df 93       	push	r29
    2dbe:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    2dc0:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <chb_buf_read>
    2dc4:	d8 2e       	mov	r13, r24
    2dc6:	88 23       	and	r24, r24
    2dc8:	0c f4       	brge	.+2      	; 0x2dcc <chb_read+0x1c>
    2dca:	46 c0       	rjmp	.+140    	; 0x2e58 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    2dcc:	f7 01       	movw	r30, r14
    2dce:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2dd0:	88 23       	and	r24, r24
    2dd2:	71 f0       	breq	.+28     	; 0x2df0 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    2dd4:	e7 01       	movw	r28, r14
    2dd6:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    2dd8:	87 01       	movw	r16, r14
    2dda:	09 5f       	subi	r16, 0xF9	; 249
    2ddc:	1f 4f       	sbci	r17, 0xFF	; 255
    2dde:	81 50       	subi	r24, 0x01	; 1
    2de0:	08 0f       	add	r16, r24
    2de2:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    2de4:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <chb_buf_read>
    2de8:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2dea:	c0 17       	cp	r28, r16
    2dec:	d1 07       	cpc	r29, r17
    2dee:	d1 f7       	brne	.-12     	; 0x2de4 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    2df0:	f7 01       	movw	r30, r14
    2df2:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    2df4:	83 85       	ldd	r24, Z+11	; 0x0b
    2df6:	94 85       	ldd	r25, Z+12	; 0x0c
    2df8:	83 83       	std	Z+3, r24	; 0x03
    2dfa:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    2dfc:	85 85       	ldd	r24, Z+13	; 0x0d
    2dfe:	96 85       	ldd	r25, Z+14	; 0x0e
    2e00:	81 83       	std	Z+1, r24	; 0x01
    2e02:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    2e04:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <chb_buf_get_len>
    2e08:	88 23       	and	r24, r24
    2e0a:	11 f4       	brne	.+4      	; 0x2e10 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    2e0c:	10 92 41 21 	sts	0x2141, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    2e10:	80 91 13 20 	lds	r24, 0x2013
    2e14:	c8 17       	cp	r28, r24
    2e16:	51 f4       	brne	.+20     	; 0x2e2c <chb_read+0x7c>
    2e18:	f7 01       	movw	r30, r14
    2e1a:	21 81       	ldd	r18, Z+1	; 0x01
    2e1c:	32 81       	ldd	r19, Z+2	; 0x02
    2e1e:	80 91 14 20 	lds	r24, 0x2014
    2e22:	90 91 15 20 	lds	r25, 0x2015
    2e26:	28 17       	cp	r18, r24
    2e28:	39 07       	cpc	r19, r25
    2e2a:	c1 f0       	breq	.+48     	; 0x2e5c <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    2e2c:	c0 93 13 20 	sts	0x2013, r28
        prev_src_addr = rx->src_addr;
    2e30:	f7 01       	movw	r30, r14
    2e32:	81 81       	ldd	r24, Z+1	; 0x01
    2e34:	92 81       	ldd	r25, Z+2	; 0x02
    2e36:	80 93 14 20 	sts	0x2014, r24
    2e3a:	90 93 15 20 	sts	0x2015, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    2e3e:	b7 01       	movw	r22, r14
    2e40:	61 5f       	subi	r22, 0xF1	; 241
    2e42:	7f 4f       	sbci	r23, 0xFF	; 255
    2e44:	4d 2d       	mov	r20, r13
    2e46:	50 e0       	ldi	r21, 0x00	; 0
    2e48:	49 50       	subi	r20, 0x09	; 9
    2e4a:	50 40       	sbci	r21, 0x00	; 0
    2e4c:	c7 01       	movw	r24, r14
    2e4e:	0e 94 f6 3a 	call	0x75ec	; 0x75ec <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2e52:	8d 2d       	mov	r24, r13
    2e54:	8b 50       	subi	r24, 0x0B	; 11
    2e56:	03 c0       	rjmp	.+6      	; 0x2e5e <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2e58:	80 e0       	ldi	r24, 0x00	; 0
    2e5a:	01 c0       	rjmp	.+2      	; 0x2e5e <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    2e5c:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    2e5e:	df 91       	pop	r29
    2e60:	cf 91       	pop	r28
    2e62:	1f 91       	pop	r17
    2e64:	0f 91       	pop	r16
    2e66:	ff 90       	pop	r15
    2e68:	ef 90       	pop	r14
    2e6a:	df 90       	pop	r13
    2e6c:	08 95       	ret

00002e6e <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    2e6e:	10 92 52 21 	sts	0x2152, r1
    wr_ptr = 0;
    2e72:	10 92 53 21 	sts	0x2153, r1
    len = 0;
    2e76:	10 92 54 21 	sts	0x2154, r1
}
    2e7a:	08 95       	ret

00002e7c <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    2e7c:	20 91 53 21 	lds	r18, 0x2153
    2e80:	30 e0       	ldi	r19, 0x00	; 0
    2e82:	f9 01       	movw	r30, r18
    2e84:	eb 5a       	subi	r30, 0xAB	; 171
    2e86:	fe 4d       	sbci	r31, 0xDE	; 222
    2e88:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2e8a:	c9 01       	movw	r24, r18
    2e8c:	01 96       	adiw	r24, 0x01	; 1
    2e8e:	60 e8       	ldi	r22, 0x80	; 128
    2e90:	70 e0       	ldi	r23, 0x00	; 0
    2e92:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    2e96:	80 93 53 21 	sts	0x2153, r24
    len++;
    2e9a:	80 91 54 21 	lds	r24, 0x2154
    2e9e:	8f 5f       	subi	r24, 0xFF	; 255
    2ea0:	80 93 54 21 	sts	0x2154, r24
}
    2ea4:	08 95       	ret

00002ea6 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    2ea6:	20 91 52 21 	lds	r18, 0x2152
    2eaa:	30 e0       	ldi	r19, 0x00	; 0
    2eac:	f9 01       	movw	r30, r18
    2eae:	eb 5a       	subi	r30, 0xAB	; 171
    2eb0:	fe 4d       	sbci	r31, 0xDE	; 222
    2eb2:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    2eb4:	2f 5f       	subi	r18, 0xFF	; 255
    2eb6:	3f 4f       	sbci	r19, 0xFF	; 255
    2eb8:	c9 01       	movw	r24, r18
    2eba:	60 e8       	ldi	r22, 0x80	; 128
    2ebc:	70 e0       	ldi	r23, 0x00	; 0
    2ebe:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    2ec2:	80 93 52 21 	sts	0x2152, r24
    len--;
    2ec6:	80 91 54 21 	lds	r24, 0x2154
    2eca:	81 50       	subi	r24, 0x01	; 1
    2ecc:	80 93 54 21 	sts	0x2154, r24
    return data;
}
    2ed0:	84 2f       	mov	r24, r20
    2ed2:	08 95       	ret

00002ed4 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    2ed4:	80 91 54 21 	lds	r24, 0x2154
    2ed8:	08 95       	ret

00002eda <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    2eda:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    2edc:	80 e0       	ldi	r24, 0x00	; 0
    2ede:	90 e0       	ldi	r25, 0x00	; 0
    2ee0:	48 e0       	ldi	r20, 0x08	; 8
    2ee2:	50 e0       	ldi	r21, 0x00	; 0
    2ee4:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <chb_eeprom_read>
}
    2ee8:	08 95       	ret

00002eea <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    2eea:	cf 93       	push	r28
    2eec:	df 93       	push	r29
    2eee:	0f 92       	push	r0
    2ef0:	0f 92       	push	r0
    2ef2:	cd b7       	in	r28, 0x3d	; 61
    2ef4:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    2ef6:	89 e0       	ldi	r24, 0x09	; 9
    2ef8:	90 e0       	ldi	r25, 0x00	; 0
    2efa:	be 01       	movw	r22, r28
    2efc:	6f 5f       	subi	r22, 0xFF	; 255
    2efe:	7f 4f       	sbci	r23, 0xFF	; 255
    2f00:	42 e0       	ldi	r20, 0x02	; 2
    2f02:	50 e0       	ldi	r21, 0x00	; 0
    2f04:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <chb_eeprom_read>
    return *(U16 *)addr;
}
    2f08:	89 81       	ldd	r24, Y+1	; 0x01
    2f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f0c:	0f 90       	pop	r0
    2f0e:	0f 90       	pop	r0
    2f10:	df 91       	pop	r29
    2f12:	cf 91       	pop	r28
    2f14:	08 95       	ret

00002f16 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    2f16:	88 23       	and	r24, r24
    2f18:	29 f0       	breq	.+10     	; 0x2f24 <RadioCS+0xe>
    2f1a:	80 e1       	ldi	r24, 0x10	; 16
    2f1c:	e0 e6       	ldi	r30, 0x60	; 96
    2f1e:	f6 e0       	ldi	r31, 0x06	; 6
    2f20:	86 83       	std	Z+6, r24	; 0x06
    2f22:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    2f24:	80 e1       	ldi	r24, 0x10	; 16
    2f26:	e0 e6       	ldi	r30, 0x60	; 96
    2f28:	f6 e0       	ldi	r31, 0x06	; 6
    2f2a:	85 83       	std	Z+5, r24	; 0x05
    2f2c:	08 95       	ret

00002f2e <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    2f2e:	df 92       	push	r13
    2f30:	ef 92       	push	r14
    2f32:	ff 92       	push	r15
    2f34:	0f 93       	push	r16
    2f36:	1f 93       	push	r17
    2f38:	cf 93       	push	r28
    2f3a:	df 93       	push	r29
    2f3c:	8c 01       	movw	r16, r24
    2f3e:	c6 2f       	mov	r28, r22
    2f40:	7a 01       	movw	r14, r20
    2f42:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    2f44:	82 2f       	mov	r24, r18
    2f46:	90 e0       	ldi	r25, 0x00	; 0
    2f48:	86 0f       	add	r24, r22
    2f4a:	91 1d       	adc	r25, r1
    2f4c:	80 38       	cpi	r24, 0x80	; 128
    2f4e:	91 05       	cpc	r25, r1
    2f50:	8c f5       	brge	.+98     	; 0x2fb4 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    2f52:	8f b7       	in	r24, 0x3f	; 63
    2f54:	80 93 56 40 	sts	0x4056, r24
    2f58:	f8 94       	cli
    RadioCS(TRUE); 
    2f5a:	81 e0       	ldi	r24, 0x01	; 1
    2f5c:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    2f60:	80 e6       	ldi	r24, 0x60	; 96
    2f62:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2f66:	cc 23       	and	r28, r28
    2f68:	79 f0       	breq	.+30     	; 0x2f88 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2f6a:	c8 01       	movw	r24, r16
    2f6c:	01 96       	adiw	r24, 0x01	; 1
    2f6e:	c1 50       	subi	r28, 0x01	; 1
    2f70:	9c 01       	movw	r18, r24
    2f72:	2c 0f       	add	r18, r28
    2f74:	31 1d       	adc	r19, r1
    2f76:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    2f78:	f8 01       	movw	r30, r16
    2f7a:	81 91       	ld	r24, Z+
    2f7c:	8f 01       	movw	r16, r30
    2f7e:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2f82:	0c 17       	cp	r16, r28
    2f84:	1d 07       	cpc	r17, r29
    2f86:	c1 f7       	brne	.-16     	; 0x2f78 <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2f88:	dd 20       	and	r13, r13
    2f8a:	69 f0       	breq	.+26     	; 0x2fa6 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2f8c:	e7 01       	movw	r28, r14
    2f8e:	21 96       	adiw	r28, 0x01	; 1
    2f90:	da 94       	dec	r13
    2f92:	cd 0d       	add	r28, r13
    2f94:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    2f96:	f7 01       	movw	r30, r14
    2f98:	81 91       	ld	r24, Z+
    2f9a:	7f 01       	movw	r14, r30
    2f9c:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2fa0:	ec 16       	cp	r14, r28
    2fa2:	fd 06       	cpc	r15, r29
    2fa4:	c1 f7       	brne	.-16     	; 0x2f96 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    2fa6:	80 e0       	ldi	r24, 0x00	; 0
    2fa8:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>
    CHB_LEAVE_CRIT();
    2fac:	80 91 56 40 	lds	r24, 0x4056
    2fb0:	8f bf       	out	0x3f, r24	; 63
    2fb2:	78 94       	sei
}
    2fb4:	df 91       	pop	r29
    2fb6:	cf 91       	pop	r28
    2fb8:	1f 91       	pop	r17
    2fba:	0f 91       	pop	r16
    2fbc:	ff 90       	pop	r15
    2fbe:	ef 90       	pop	r14
    2fc0:	df 90       	pop	r13
    2fc2:	08 95       	ret

00002fc4 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    2fc4:	cf 93       	push	r28
    2fc6:	df 93       	push	r29
    2fc8:	d8 2f       	mov	r29, r24
    2fca:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    2fcc:	8f b7       	in	r24, 0x3f	; 63
    2fce:	80 93 56 40 	sts	0x4056, r24
    2fd2:	f8 94       	cli
    RadioCS(TRUE);
    2fd4:	81 e0       	ldi	r24, 0x01	; 1
    2fd6:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    2fda:	8d 2f       	mov	r24, r29
    2fdc:	80 6c       	ori	r24, 0xC0	; 192
    2fde:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    2fe2:	8c 2f       	mov	r24, r28
    2fe4:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>

    RadioCS(FALSE);
    2fe8:	80 e0       	ldi	r24, 0x00	; 0
    2fea:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>
    CHB_LEAVE_CRIT();
    2fee:	80 91 56 40 	lds	r24, 0x4056
    2ff2:	8f bf       	out	0x3f, r24	; 63
    2ff4:	78 94       	sei
}
    2ff6:	df 91       	pop	r29
    2ff8:	cf 91       	pop	r28
    2ffa:	08 95       	ret

00002ffc <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    2ffc:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    2ffe:	85 e0       	ldi	r24, 0x05	; 5
    3000:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <chb_reg_write>
}
    3004:	08 95       	ret

00003006 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    3006:	0f 93       	push	r16
    3008:	1f 93       	push	r17
    300a:	cf 93       	push	r28
    300c:	df 93       	push	r29
    300e:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    3010:	c6 2f       	mov	r28, r22
    3012:	d7 2f       	mov	r29, r23
    3014:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    3016:	69 91       	ld	r22, Y+
    3018:	81 2f       	mov	r24, r17
    301a:	80 0f       	add	r24, r16
    301c:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    3020:	1f 5f       	subi	r17, 0xFF	; 255
    3022:	18 30       	cpi	r17, 0x08	; 8
    3024:	c1 f7       	brne	.-16     	; 0x3016 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    3026:	df 91       	pop	r29
    3028:	cf 91       	pop	r28
    302a:	1f 91       	pop	r17
    302c:	0f 91       	pop	r16
    302e:	08 95       	ret

00003030 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3030:	cf 93       	push	r28
    3032:	df 93       	push	r29
    3034:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    3036:	80 e0       	ldi	r24, 0x00	; 0
    3038:	90 e0       	ldi	r25, 0x00	; 0
    303a:	be 01       	movw	r22, r28
    303c:	48 e0       	ldi	r20, 0x08	; 8
    303e:	50 e0       	ldi	r21, 0x00	; 0
    3040:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    3044:	84 e2       	ldi	r24, 0x24	; 36
    3046:	be 01       	movw	r22, r28
    3048:	0e 94 03 18 	call	0x3006	; 0x3006 <chb_reg_write64>
}
    304c:	df 91       	pop	r29
    304e:	cf 91       	pop	r28
    3050:	08 95       	ret

00003052 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3052:	cf 93       	push	r28
    3054:	df 93       	push	r29
    3056:	c8 2f       	mov	r28, r24
    3058:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    305a:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <chb_reg_write>
    305e:	8c 2f       	mov	r24, r28
    3060:	8f 5f       	subi	r24, 0xFF	; 255
    3062:	6d 2f       	mov	r22, r29
    3064:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <chb_reg_write>
    }
}
    3068:	df 91       	pop	r29
    306a:	cf 91       	pop	r28
    306c:	08 95       	ret

0000306e <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    306e:	0f 93       	push	r16
    3070:	1f 93       	push	r17
    3072:	cf 93       	push	r28
    3074:	df 93       	push	r29
    3076:	0f 92       	push	r0
    3078:	0f 92       	push	r0
    307a:	cd b7       	in	r28, 0x3d	; 61
    307c:	de b7       	in	r29, 0x3e	; 62
    307e:	89 83       	std	Y+1, r24	; 0x01
    3080:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3082:	0e 94 12 16 	call	0x2c24	; 0x2c24 <chb_get_pcb>
    3086:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    3088:	89 e0       	ldi	r24, 0x09	; 9
    308a:	90 e0       	ldi	r25, 0x00	; 0
    308c:	be 01       	movw	r22, r28
    308e:	6f 5f       	subi	r22, 0xFF	; 255
    3090:	7f 4f       	sbci	r23, 0xFF	; 255
    3092:	42 e0       	ldi	r20, 0x02	; 2
    3094:	50 e0       	ldi	r21, 0x00	; 0
    3096:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    309a:	69 81       	ldd	r22, Y+1	; 0x01
    309c:	7a 81       	ldd	r23, Y+2	; 0x02
    309e:	80 e2       	ldi	r24, 0x20	; 32
    30a0:	0e 94 29 18 	call	0x3052	; 0x3052 <chb_reg_write16>
    pcb->src_addr = addr;
    30a4:	89 81       	ldd	r24, Y+1	; 0x01
    30a6:	9a 81       	ldd	r25, Y+2	; 0x02
    30a8:	f8 01       	movw	r30, r16
    30aa:	80 83       	st	Z, r24
    30ac:	91 83       	std	Z+1, r25	; 0x01
}
    30ae:	0f 90       	pop	r0
    30b0:	0f 90       	pop	r0
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	1f 91       	pop	r17
    30b8:	0f 91       	pop	r16
    30ba:	08 95       	ret

000030bc <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    30bc:	cf 93       	push	r28
    30be:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    30c0:	8f b7       	in	r24, 0x3f	; 63
    30c2:	80 93 56 40 	sts	0x4056, r24
    30c6:	f8 94       	cli
    RadioCS(TRUE);
    30c8:	81 e0       	ldi	r24, 0x01	; 1
    30ca:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    30ce:	8c 2f       	mov	r24, r28
    30d0:	80 68       	ori	r24, 0x80	; 128
    30d2:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    val = SPID_write(val);
    30d6:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    30da:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    30dc:	80 e0       	ldi	r24, 0x00	; 0
    30de:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>
    CHB_LEAVE_CRIT();
    30e2:	80 91 56 40 	lds	r24, 0x4056
    30e6:	8f bf       	out	0x3f, r24	; 63
    30e8:	78 94       	sei

    return val;
}
    30ea:	8c 2f       	mov	r24, r28
    30ec:	cf 91       	pop	r28
    30ee:	08 95       	ret

000030f0 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    30f0:	81 e0       	ldi	r24, 0x01	; 1
    30f2:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
}
    30f6:	8f 71       	andi	r24, 0x1F	; 31
    30f8:	08 95       	ret

000030fa <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    30fa:	1f 93       	push	r17
    30fc:	cf 93       	push	r28
    30fe:	df 93       	push	r29
    3100:	c8 2f       	mov	r28, r24
    3102:	16 2f       	mov	r17, r22
    3104:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    3106:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    310a:	6d 2f       	mov	r22, r29
    310c:	60 95       	com	r22
    310e:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    3110:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3112:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    3114:	8c 2f       	mov	r24, r28
    3116:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <chb_reg_write>
}
    311a:	df 91       	pop	r29
    311c:	cf 91       	pop	r28
    311e:	1f 91       	pop	r17
    3120:	08 95       	ret

00003122 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3122:	cf 93       	push	r28
    3124:	df 93       	push	r29
    3126:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    3128:	80 91 64 06 	lds	r24, 0x0664
    312c:	81 fd       	sbrc	r24, 1
    312e:	4b c0       	rjmp	.+150    	; 0x31c6 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3130:	0e 94 78 18 	call	0x30f0	; 0x30f0 <chb_get_state>
    3134:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    3136:	81 51       	subi	r24, 0x11	; 17
    3138:	82 30       	cpi	r24, 0x02	; 2
    313a:	20 f0       	brcs	.+8      	; 0x3144 <chb_set_state+0x22>
    313c:	c1 30       	cpi	r28, 0x01	; 1
    313e:	11 f0       	breq	.+4      	; 0x3144 <chb_set_state+0x22>
    3140:	c2 30       	cpi	r28, 0x02	; 2
    3142:	21 f4       	brne	.+8      	; 0x314c <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    3144:	0e 94 78 18 	call	0x30f0	; 0x30f0 <chb_get_state>
    3148:	8c 17       	cp	r24, r28
    314a:	e1 f3       	breq	.-8      	; 0x3144 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    314c:	d6 31       	cpi	r29, 0x16	; 22
    314e:	f9 f0       	breq	.+62     	; 0x318e <chb_set_state+0x6c>
    3150:	d9 31       	cpi	r29, 0x19	; 25
    3152:	89 f0       	breq	.+34     	; 0x3176 <chb_set_state+0x54>
    3154:	d8 30       	cpi	r29, 0x08	; 8
    3156:	31 f5       	brne	.+76     	; 0x31a4 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    3158:	e4 e6       	ldi	r30, 0x64	; 100
    315a:	f6 e0       	ldi	r31, 0x06	; 6
    315c:	80 81       	ld	r24, Z
    315e:	8d 7f       	andi	r24, 0xFD	; 253
    3160:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3162:	82 e0       	ldi	r24, 0x02	; 2
    3164:	63 e0       	ldi	r22, 0x03	; 3
    3166:	4f e1       	ldi	r20, 0x1F	; 31
    3168:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
    316c:	8a e0       	ldi	r24, 0x0A	; 10
    316e:	8a 95       	dec	r24
    3170:	f1 f7       	brne	.-4      	; 0x316e <chb_set_state+0x4c>
    3172:	00 c0       	rjmp	.+0      	; 0x3174 <chb_set_state+0x52>
    3174:	17 c0       	rjmp	.+46     	; 0x31a4 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3176:	c6 31       	cpi	r28, 0x16	; 22
    3178:	a9 f4       	brne	.+42     	; 0x31a4 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    317a:	82 e0       	ldi	r24, 0x02	; 2
    317c:	69 e0       	ldi	r22, 0x09	; 9
    317e:	4f e1       	ldi	r20, 0x1F	; 31
    3180:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
    3184:	9a e0       	ldi	r25, 0x0A	; 10
    3186:	9a 95       	dec	r25
    3188:	f1 f7       	brne	.-4      	; 0x3186 <chb_set_state+0x64>
    318a:	00 c0       	rjmp	.+0      	; 0x318c <chb_set_state+0x6a>
    318c:	0b c0       	rjmp	.+22     	; 0x31a4 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    318e:	c9 31       	cpi	r28, 0x19	; 25
    3190:	49 f4       	brne	.+18     	; 0x31a4 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3192:	82 e0       	ldi	r24, 0x02	; 2
    3194:	69 e0       	ldi	r22, 0x09	; 9
    3196:	4f e1       	ldi	r20, 0x1F	; 31
    3198:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
    319c:	8a e0       	ldi	r24, 0x0A	; 10
    319e:	8a 95       	dec	r24
    31a0:	f1 f7       	brne	.-4      	; 0x319e <chb_set_state+0x7c>
    31a2:	00 c0       	rjmp	.+0      	; 0x31a4 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    31a4:	82 e0       	ldi	r24, 0x02	; 2
    31a6:	6d 2f       	mov	r22, r29
    31a8:	4f e1       	ldi	r20, 0x1F	; 31
    31aa:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
    31ae:	8f e6       	ldi	r24, 0x6F	; 111
    31b0:	93 e0       	ldi	r25, 0x03	; 3
    31b2:	01 97       	sbiw	r24, 0x01	; 1
    31b4:	f1 f7       	brne	.-4      	; 0x31b2 <chb_set_state+0x90>
    31b6:	00 c0       	rjmp	.+0      	; 0x31b8 <chb_set_state+0x96>
    31b8:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    31ba:	0e 94 78 18 	call	0x30f0	; 0x30f0 <chb_get_state>
    31be:	8d 17       	cp	r24, r29
    31c0:	21 f4       	brne	.+8      	; 0x31ca <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    31c2:	80 e4       	ldi	r24, 0x40	; 64
    31c4:	03 c0       	rjmp	.+6      	; 0x31cc <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    31c6:	84 e4       	ldi	r24, 0x44	; 68
    31c8:	01 c0       	rjmp	.+2      	; 0x31cc <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    31ca:	83 e4       	ldi	r24, 0x43	; 67
}
    31cc:	df 91       	pop	r29
    31ce:	cf 91       	pop	r28
    31d0:	08 95       	ret

000031d2 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    31d2:	88 23       	and	r24, r24
    31d4:	49 f0       	breq	.+18     	; 0x31e8 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    31d6:	88 e0       	ldi	r24, 0x08	; 8
    31d8:	0e 94 91 18 	call	0x3122	; 0x3122 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    31dc:	e4 e6       	ldi	r30, 0x64	; 100
    31de:	f6 e0       	ldi	r31, 0x06	; 6
    31e0:	80 81       	ld	r24, Z
    31e2:	82 60       	ori	r24, 0x02	; 2
    31e4:	80 83       	st	Z, r24
    31e6:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    31e8:	e4 e6       	ldi	r30, 0x64	; 100
    31ea:	f6 e0       	ldi	r31, 0x06	; 6
    31ec:	80 81       	ld	r24, Z
    31ee:	8d 7f       	andi	r24, 0xFD	; 253
    31f0:	80 83       	st	Z, r24
    31f2:	8f e7       	ldi	r24, 0x7F	; 127
    31f4:	97 e0       	ldi	r25, 0x07	; 7
    31f6:	01 97       	sbiw	r24, 0x01	; 1
    31f8:	f1 f7       	brne	.-4      	; 0x31f6 <chb_sleep+0x24>
    31fa:	00 c0       	rjmp	.+0      	; 0x31fc <chb_sleep+0x2a>
    31fc:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    31fe:	86 e1       	ldi	r24, 0x16	; 22
    3200:	0e 94 91 18 	call	0x3122	; 0x3122 <chb_set_state>
    3204:	08 95       	ret

00003206 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    3206:	cf 92       	push	r12
    3208:	df 92       	push	r13
    320a:	ef 92       	push	r14
    320c:	ff 92       	push	r15
    320e:	0f 93       	push	r16
    3210:	1f 93       	push	r17
    3212:	cf 93       	push	r28
    3214:	df 93       	push	r29
    3216:	7c 01       	movw	r14, r24
    3218:	6b 01       	movw	r12, r22
    321a:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    321c:	0e 94 78 18 	call	0x30f0	; 0x30f0 <chb_get_state>
    3220:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3222:	0e 94 12 16 	call	0x2c24	; 0x2c24 <chb_get_pcb>
    3226:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3228:	12 30       	cpi	r17, 0x02	; 2
    322a:	f1 f0       	breq	.+60     	; 0x3268 <chb_tx+0x62>
    322c:	12 31       	cpi	r17, 0x12	; 18
    322e:	f1 f0       	breq	.+60     	; 0x326c <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    3230:	88 e0       	ldi	r24, 0x08	; 8
    3232:	0e 94 91 18 	call	0x3122	; 0x3122 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    3236:	89 e1       	ldi	r24, 0x19	; 25
    3238:	0e 94 91 18 	call	0x3122	; 0x3122 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    323c:	c7 01       	movw	r24, r14
    323e:	6a e0       	ldi	r22, 0x0A	; 10
    3240:	a6 01       	movw	r20, r12
    3242:	20 2f       	mov	r18, r16
    3244:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3248:	82 e0       	ldi	r24, 0x02	; 2
    324a:	62 e0       	ldi	r22, 0x02	; 2
    324c:	4f e1       	ldi	r20, 0x1F	; 31
    324e:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3252:	8c 81       	ldd	r24, Y+4	; 0x04
    3254:	88 23       	and	r24, r24
    3256:	e9 f3       	breq	.-6      	; 0x3252 <chb_tx+0x4c>
    pcb->tx_end = false;
    3258:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    325a:	82 e0       	ldi	r24, 0x02	; 2
    325c:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    3260:	82 95       	swap	r24
    3262:	86 95       	lsr	r24
    3264:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3266:	03 c0       	rjmp	.+6      	; 0x326e <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3268:	84 e4       	ldi	r24, 0x44	; 68
    326a:	01 c0       	rjmp	.+2      	; 0x326e <chb_tx+0x68>
    326c:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    326e:	df 91       	pop	r29
    3270:	cf 91       	pop	r28
    3272:	1f 91       	pop	r17
    3274:	0f 91       	pop	r16
    3276:	ff 90       	pop	r15
    3278:	ef 90       	pop	r14
    327a:	df 90       	pop	r13
    327c:	cf 90       	pop	r12
    327e:	08 95       	ret

00003280 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3280:	81 30       	cpi	r24, 0x01	; 1
    3282:	91 f0       	breq	.+36     	; 0x32a8 <chb_set_mode+0x28>
    3284:	81 30       	cpi	r24, 0x01	; 1
    3286:	28 f0       	brcs	.+10     	; 0x3292 <chb_set_mode+0x12>
    3288:	82 30       	cpi	r24, 0x02	; 2
    328a:	c9 f0       	breq	.+50     	; 0x32be <chb_set_mode+0x3e>
    328c:	83 30       	cpi	r24, 0x03	; 3
    328e:	61 f5       	brne	.+88     	; 0x32e8 <chb_set_mode+0x68>
    3290:	21 c0       	rjmp	.+66     	; 0x32d4 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3292:	8c e0       	ldi	r24, 0x0C	; 12
    3294:	68 e0       	ldi	r22, 0x08	; 8
    3296:	4f e3       	ldi	r20, 0x3F	; 63
    3298:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    329c:	86 e1       	ldi	r24, 0x16	; 22
    329e:	62 e0       	ldi	r22, 0x02	; 2
    32a0:	43 e0       	ldi	r20, 0x03	; 3
    32a2:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
        break;
    32a6:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    32a8:	8c e0       	ldi	r24, 0x0C	; 12
    32aa:	6c e0       	ldi	r22, 0x0C	; 12
    32ac:	4f e3       	ldi	r20, 0x3F	; 63
    32ae:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    32b2:	86 e1       	ldi	r24, 0x16	; 22
    32b4:	62 e0       	ldi	r22, 0x02	; 2
    32b6:	43 e0       	ldi	r20, 0x03	; 3
    32b8:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
        break;
    32bc:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    32be:	8c e0       	ldi	r24, 0x0C	; 12
    32c0:	6c e1       	ldi	r22, 0x1C	; 28
    32c2:	4f e3       	ldi	r20, 0x3F	; 63
    32c4:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    32c8:	86 e1       	ldi	r24, 0x16	; 22
    32ca:	62 e0       	ldi	r22, 0x02	; 2
    32cc:	43 e0       	ldi	r20, 0x03	; 3
    32ce:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
        break;
    32d2:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    32d4:	8c e0       	ldi	r24, 0x0C	; 12
    32d6:	60 e0       	ldi	r22, 0x00	; 0
    32d8:	4f e3       	ldi	r20, 0x3F	; 63
    32da:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    32de:	86 e1       	ldi	r24, 0x16	; 22
    32e0:	63 e0       	ldi	r22, 0x03	; 3
    32e2:	43 e0       	ldi	r20, 0x03	; 3
    32e4:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
    32e8:	08 95       	ret

000032ea <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    32ea:	cf 93       	push	r28
    32ec:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    32ee:	88 e0       	ldi	r24, 0x08	; 8
    32f0:	6c 2f       	mov	r22, r28
    32f2:	4f e1       	ldi	r20, 0x1F	; 31
    32f4:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    32f8:	0e 94 78 18 	call	0x30f0	; 0x30f0 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    32fc:	86 30       	cpi	r24, 0x06	; 6
    32fe:	11 f0       	breq	.+4      	; 0x3304 <chb_set_channel+0x1a>
    3300:	89 30       	cpi	r24, 0x09	; 9
    3302:	31 f4       	brne	.+12     	; 0x3310 <chb_set_channel+0x26>
    3304:	8f e6       	ldi	r24, 0x6F	; 111
    3306:	93 e0       	ldi	r25, 0x03	; 3
    3308:	01 97       	sbiw	r24, 0x01	; 1
    330a:	f1 f7       	brne	.-4      	; 0x3308 <chb_set_channel+0x1e>
    330c:	00 c0       	rjmp	.+0      	; 0x330e <chb_set_channel+0x24>
    330e:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3310:	88 e0       	ldi	r24, 0x08	; 8
    3312:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    3316:	90 e0       	ldi	r25, 0x00	; 0
    3318:	8f 71       	andi	r24, 0x1F	; 31
    331a:	90 70       	andi	r25, 0x00	; 0
    331c:	6c 2f       	mov	r22, r28
    331e:	70 e0       	ldi	r23, 0x00	; 0
    3320:	86 17       	cp	r24, r22
    3322:	97 07       	cpc	r25, r23
    3324:	11 f4       	brne	.+4      	; 0x332a <chb_set_channel+0x40>
    3326:	80 e4       	ldi	r24, 0x40	; 64
    3328:	01 c0       	rjmp	.+2      	; 0x332c <chb_set_channel+0x42>
    332a:	83 e4       	ldi	r24, 0x43	; 67
}
    332c:	cf 91       	pop	r28
    332e:	08 95       	ret

00003330 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3330:	cf 93       	push	r28
    3332:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3334:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    3338:	8c 2b       	or	r24, r28
    333a:	8f 5f       	subi	r24, 0xFF	; 255
    333c:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    }
    return val;
}
    3340:	80 e0       	ldi	r24, 0x00	; 0
    3342:	90 e0       	ldi	r25, 0x00	; 0
    3344:	cf 91       	pop	r28
    3346:	08 95       	ret

00003348 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3348:	e4 e6       	ldi	r30, 0x64	; 100
    334a:	f6 e0       	ldi	r31, 0x06	; 6
    334c:	80 81       	ld	r24, Z
    334e:	81 60       	ori	r24, 0x01	; 1
    3350:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3352:	80 81       	ld	r24, Z
    3354:	8d 7f       	andi	r24, 0xFD	; 253
    3356:	80 83       	st	Z, r24
    3358:	8f ed       	ldi	r24, 0xDF	; 223
    335a:	9b e0       	ldi	r25, 0x0B	; 11
    335c:	01 97       	sbiw	r24, 0x01	; 1
    335e:	f1 f7       	brne	.-4      	; 0x335c <chb_reset+0x14>
    3360:	00 c0       	rjmp	.+0      	; 0x3362 <chb_reset+0x1a>
    3362:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3364:	80 81       	ld	r24, Z
    3366:	8e 7f       	andi	r24, 0xFE	; 254
    3368:	80 83       	st	Z, r24
    336a:	9a e0       	ldi	r25, 0x0A	; 10
    336c:	9a 95       	dec	r25
    336e:	f1 f7       	brne	.-4      	; 0x336c <chb_reset+0x24>
    3370:	00 c0       	rjmp	.+0      	; 0x3372 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3372:	80 81       	ld	r24, Z
    3374:	81 60       	ori	r24, 0x01	; 1
    3376:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3378:	8d e1       	ldi	r24, 0x1D	; 29
    337a:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    337e:	81 30       	cpi	r24, 0x01	; 1
    3380:	d9 f7       	brne	.-10     	; 0x3378 <chb_reset+0x30>
    3382:	8c e1       	ldi	r24, 0x1C	; 28
    3384:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    3388:	87 30       	cpi	r24, 0x07	; 7
    338a:	b1 f7       	brne	.-20     	; 0x3378 <chb_reset+0x30>
            break;
        }
    }
	

}
    338c:	08 95       	ret

0000338e <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    338e:	0f 93       	push	r16
    3390:	1f 93       	push	r17
    3392:	cf 93       	push	r28
    3394:	df 93       	push	r29
    3396:	cd b7       	in	r28, 0x3d	; 61
    3398:	de b7       	in	r29, 0x3e	; 62
    339a:	ea 97       	sbiw	r28, 0x3a	; 58
    339c:	cd bf       	out	0x3d, r28	; 61
    339e:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    33a0:	0e 94 0e 1c 	call	0x381c	; 0x381c <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    33a4:	e0 e6       	ldi	r30, 0x60	; 96
    33a6:	f6 e0       	ldi	r31, 0x06	; 6
    33a8:	80 81       	ld	r24, Z
    33aa:	82 60       	ori	r24, 0x02	; 2
    33ac:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    33ae:	80 81       	ld	r24, Z
    33b0:	81 60       	ori	r24, 0x01	; 1
    33b2:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    33b4:	0e 94 a4 19 	call	0x3348	; 0x3348 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    33b8:	8e e0       	ldi	r24, 0x0E	; 14
    33ba:	60 e0       	ldi	r22, 0x00	; 0
    33bc:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    33c0:	82 e0       	ldi	r24, 0x02	; 2
    33c2:	63 e0       	ldi	r22, 0x03	; 3
    33c4:	4f e1       	ldi	r20, 0x1F	; 31
    33c6:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    33ca:	81 e0       	ldi	r24, 0x01	; 1
    33cc:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    33d0:	8f 71       	andi	r24, 0x1F	; 31
    33d2:	88 30       	cpi	r24, 0x08	; 8
    33d4:	d1 f7       	brne	.-12     	; 0x33ca <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    33d6:	8e e2       	ldi	r24, 0x2E	; 46
    33d8:	60 e4       	ldi	r22, 0x40	; 64
    33da:	40 ec       	ldi	r20, 0xC0	; 192
    33dc:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    33e0:	8e e0       	ldi	r24, 0x0E	; 14
    33e2:	6c e0       	ldi	r22, 0x0C	; 12
    33e4:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    33e8:	84 e0       	ldi	r24, 0x04	; 4
    33ea:	60 e2       	ldi	r22, 0x20	; 32
    33ec:	40 e2       	ldi	r20, 0x20	; 32
    33ee:	0e 94 7d 18 	call	0x30fa	; 0x30fa <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    33f2:	81 e0       	ldi	r24, 0x01	; 1
    33f4:	0e 94 40 19 	call	0x3280	; 0x3280 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    33f8:	81 e0       	ldi	r24, 0x01	; 1
    33fa:	0e 94 75 19 	call	0x32ea	; 0x32ea <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    33fe:	86 e1       	ldi	r24, 0x16	; 22
    3400:	0e 94 91 18 	call	0x3122	; 0x3122 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3404:	82 e2       	ldi	r24, 0x22	; 34
    3406:	64 e3       	ldi	r22, 0x34	; 52
    3408:	72 e1       	ldi	r23, 0x12	; 18
    340a:	0e 94 29 18 	call	0x3052	; 0x3052 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    340e:	0e 94 75 17 	call	0x2eea	; 0x2eea <chb_get_short_addr>
    3412:	bc 01       	movw	r22, r24
    3414:	80 e2       	ldi	r24, 0x20	; 32
    3416:	0e 94 29 18 	call	0x3052	; 0x3052 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    341a:	ce 01       	movw	r24, r28
    341c:	01 96       	adiw	r24, 0x01	; 1
    341e:	0e 94 6d 17 	call	0x2eda	; 0x2eda <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3422:	84 e2       	ldi	r24, 0x24	; 36
    3424:	be 01       	movw	r22, r28
    3426:	6f 5f       	subi	r22, 0xFF	; 255
    3428:	7f 4f       	sbci	r23, 0xFF	; 255
    342a:	0e 94 03 18 	call	0x3006	; 0x3006 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    342e:	e2 e7       	ldi	r30, 0x72	; 114
    3430:	f6 e0       	ldi	r31, 0x06	; 6
    3432:	80 81       	ld	r24, Z
    3434:	81 60       	ori	r24, 0x01	; 1
    3436:	80 83       	st	Z, r24
    3438:	e9 e6       	ldi	r30, 0x69	; 105
    343a:	f6 e0       	ldi	r31, 0x06	; 6
    343c:	80 81       	ld	r24, Z
    343e:	83 60       	ori	r24, 0x03	; 3
    3440:	80 83       	st	Z, r24
    3442:	ea e6       	ldi	r30, 0x6A	; 106
    3444:	f6 e0       	ldi	r31, 0x06	; 6
    3446:	80 81       	ld	r24, Z
    3448:	84 60       	ori	r24, 0x04	; 4
    344a:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    344c:	e0 ea       	ldi	r30, 0xA0	; 160
    344e:	f0 e0       	ldi	r31, 0x00	; 0
    3450:	82 81       	ldd	r24, Z+2	; 0x02
    3452:	87 60       	ori	r24, 0x07	; 7
    3454:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3456:	0e 94 78 18 	call	0x30f0	; 0x30f0 <chb_get_state>
    345a:	86 31       	cpi	r24, 0x16	; 22
    345c:	91 f0       	breq	.+36     	; 0x3482 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    345e:	8e 01       	movw	r16, r28
    3460:	07 5f       	subi	r16, 0xF7	; 247
    3462:	1f 4f       	sbci	r17, 0xFF	; 255
    3464:	c8 01       	movw	r24, r16
    3466:	68 ee       	ldi	r22, 0xE8	; 232
    3468:	71 e0       	ldi	r23, 0x01	; 1
    346a:	0e 94 ef 3a 	call	0x75de	; 0x75de <strcpy_P>
        printf(buf);
    346e:	0f 92       	push	r0
    3470:	0f 92       	push	r0
    3472:	ed b7       	in	r30, 0x3d	; 61
    3474:	fe b7       	in	r31, 0x3e	; 62
    3476:	01 83       	std	Z+1, r16	; 0x01
    3478:	12 83       	std	Z+2, r17	; 0x02
    347a:	0e 94 42 3b 	call	0x7684	; 0x7684 <printf>
    347e:	0f 90       	pop	r0
    3480:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3482:	ea 96       	adiw	r28, 0x3a	; 58
    3484:	cd bf       	out	0x3d, r28	; 61
    3486:	de bf       	out	0x3e, r29	; 62
    3488:	df 91       	pop	r29
    348a:	cf 91       	pop	r28
    348c:	1f 91       	pop	r17
    348e:	0f 91       	pop	r16
    3490:	08 95       	ret

00003492 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3492:	1f 92       	push	r1
    3494:	0f 92       	push	r0
    3496:	0f b6       	in	r0, 0x3f	; 63
    3498:	0f 92       	push	r0
    349a:	0b b6       	in	r0, 0x3b	; 59
    349c:	0f 92       	push	r0
    349e:	11 24       	eor	r1, r1
    34a0:	4f 92       	push	r4
    34a2:	5f 92       	push	r5
    34a4:	6f 92       	push	r6
    34a6:	7f 92       	push	r7
    34a8:	8f 92       	push	r8
    34aa:	9f 92       	push	r9
    34ac:	af 92       	push	r10
    34ae:	bf 92       	push	r11
    34b0:	cf 92       	push	r12
    34b2:	df 92       	push	r13
    34b4:	ef 92       	push	r14
    34b6:	ff 92       	push	r15
    34b8:	0f 93       	push	r16
    34ba:	1f 93       	push	r17
    34bc:	2f 93       	push	r18
    34be:	3f 93       	push	r19
    34c0:	4f 93       	push	r20
    34c2:	5f 93       	push	r21
    34c4:	6f 93       	push	r22
    34c6:	7f 93       	push	r23
    34c8:	8f 93       	push	r24
    34ca:	9f 93       	push	r25
    34cc:	af 93       	push	r26
    34ce:	bf 93       	push	r27
    34d0:	ef 93       	push	r30
    34d2:	ff 93       	push	r31
    34d4:	cf 93       	push	r28
    34d6:	df 93       	push	r29
    34d8:	cd b7       	in	r28, 0x3d	; 61
    34da:	de b7       	in	r29, 0x3e	; 62
    34dc:	e2 97       	sbiw	r28, 0x32	; 50
    34de:	cd bf       	out	0x3d, r28	; 61
    34e0:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    34e2:	0e 94 12 16 	call	0x2c24	; 0x2c24 <chb_get_pcb>
    34e6:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    34e8:	8f b7       	in	r24, 0x3f	; 63
    34ea:	80 93 56 40 	sts	0x4056, r24
    34ee:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    34f0:	81 e0       	ldi	r24, 0x01	; 1
    34f2:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    34f6:	8f e8       	ldi	r24, 0x8F	; 143
    34f8:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    intp_src = SPID_write(0);
    34fc:	80 e0       	ldi	r24, 0x00	; 0
    34fe:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    3502:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3504:	80 e0       	ldi	r24, 0x00	; 0
    3506:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>

    while (intp_src)
    350a:	11 23       	and	r17, r17
    350c:	09 f4       	brne	.+2      	; 0x3510 <__vector_64+0x7e>
    350e:	be c0       	rjmp	.+380    	; 0x368c <__vector_64+0x1fa>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3510:	aa 24       	eor	r10, r10
    3512:	bb 24       	eor	r11, r11
    3514:	68 94       	set
    3516:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3518:	0f 2e       	mov	r0, r31
    351a:	f8 e0       	ldi	r31, 0x08	; 8
    351c:	6f 2e       	mov	r6, r31
    351e:	f2 e0       	ldi	r31, 0x02	; 2
    3520:	7f 2e       	mov	r7, r31
    3522:	f0 2d       	mov	r31, r0
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    3524:	0f 2e       	mov	r0, r31
    3526:	f0 e8       	ldi	r31, 0x80	; 128
    3528:	8f 2e       	mov	r8, r31
    352a:	f6 e0       	ldi	r31, 0x06	; 6
    352c:	9f 2e       	mov	r9, r31
    352e:	f0 2d       	mov	r31, r0
    3530:	cc 24       	eor	r12, r12
    3532:	68 94       	set
    3534:	c2 f8       	bld	r12, 2
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3536:	12 ff       	sbrs	r17, 2
    3538:	02 c0       	rjmp	.+4      	; 0x353e <__vector_64+0xac>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    353a:	1b 7f       	andi	r17, 0xFB	; 251
    353c:	a4 c0       	rjmp	.+328    	; 0x3686 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    353e:	13 ff       	sbrs	r17, 3
    3540:	89 c0       	rjmp	.+274    	; 0x3654 <__vector_64+0x1c2>
        {
            state = chb_get_state();
    3542:	0e 94 78 18 	call	0x30f0	; 0x30f0 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3546:	86 30       	cpi	r24, 0x06	; 6
    3548:	29 f0       	breq	.+10     	; 0x3554 <__vector_64+0xc2>
    354a:	86 31       	cpi	r24, 0x16	; 22
    354c:	19 f0       	breq	.+6      	; 0x3554 <__vector_64+0xc2>
    354e:	81 31       	cpi	r24, 0x11	; 17
    3550:	09 f0       	breq	.+2      	; 0x3554 <__vector_64+0xc2>
    3552:	76 c0       	rjmp	.+236    	; 0x3640 <__vector_64+0x1ae>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    3554:	88 e0       	ldi	r24, 0x08	; 8
    3556:	0e 94 91 18 	call	0x3122	; 0x3122 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    355a:	87 e0       	ldi	r24, 0x07	; 7
    355c:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    3560:	f7 01       	movw	r30, r14
    3562:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3564:	86 e0       	ldi	r24, 0x06	; 6
    3566:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
    356a:	88 1f       	adc	r24, r24
    356c:	88 27       	eor	r24, r24
    356e:	88 1f       	adc	r24, r24
    3570:	f7 01       	movw	r30, r14
    3572:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3574:	88 23       	and	r24, r24
    3576:	09 f4       	brne	.+2      	; 0x357a <__vector_64+0xe8>
    3578:	66 c0       	rjmp	.+204    	; 0x3646 <__vector_64+0x1b4>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    357a:	8f b7       	in	r24, 0x3f	; 63
    357c:	80 93 56 40 	sts	0x4056, r24
    3580:	f8 94       	cli
    RadioCS(TRUE);
    3582:	81 e0       	ldi	r24, 0x01	; 1
    3584:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3588:	80 e2       	ldi	r24, 0x20	; 32
    358a:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    len = SPID_write(0);
    358e:	80 e0       	ldi	r24, 0x00	; 0
    3590:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
    3594:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3596:	83 50       	subi	r24, 0x03	; 3
    3598:	8d 37       	cpi	r24, 0x7D	; 125
    359a:	08 f0       	brcs	.+2      	; 0x359e <__vector_64+0x10c>
    359c:	41 c0       	rjmp	.+130    	; 0x3620 <__vector_64+0x18e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    359e:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <chb_buf_get_len>
    35a2:	2d 2d       	mov	r18, r13
    35a4:	30 e0       	ldi	r19, 0x00	; 0
    35a6:	a5 01       	movw	r20, r10
    35a8:	48 1b       	sub	r20, r24
    35aa:	51 09       	sbc	r21, r1
    35ac:	24 17       	cp	r18, r20
    35ae:	35 07       	cpc	r19, r21
    35b0:	94 f4       	brge	.+36     	; 0x35d6 <__vector_64+0x144>
        {
            chb_buf_write(len);
    35b2:	8d 2d       	mov	r24, r13
    35b4:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <chb_buf_write>
            
            for (i=0; i<len; i++)
    35b8:	dd 20       	and	r13, r13
    35ba:	49 f0       	breq	.+18     	; 0x35ce <__vector_64+0x13c>
    35bc:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    35be:	80 e0       	ldi	r24, 0x00	; 0
    35c0:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
                chb_buf_write(data);
    35c4:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    35c8:	0f 5f       	subi	r16, 0xFF	; 255
    35ca:	0d 15       	cp	r16, r13
    35cc:	c1 f7       	brne	.-16     	; 0x35be <__vector_64+0x12c>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    35ce:	f4 01       	movw	r30, r8
    35d0:	c5 82       	std	Z+5, r12	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    35d2:	c6 82       	std	Z+6, r12	; 0x06
    35d4:	25 c0       	rjmp	.+74     	; 0x3620 <__vector_64+0x18e>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    35d6:	0e 94 12 16 	call	0x2c24	; 0x2c24 <chb_get_pcb>
    35da:	2c 01       	movw	r4, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    35dc:	dd 20       	and	r13, r13
    35de:	39 f0       	breq	.+14     	; 0x35ee <__vector_64+0x15c>
    35e0:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    35e2:	80 e0       	ldi	r24, 0x00	; 0
    35e4:	0e 94 21 1c 	call	0x3842	; 0x3842 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    35e8:	0f 5f       	subi	r16, 0xFF	; 255
    35ea:	0d 15       	cp	r16, r13
    35ec:	d1 f7       	brne	.-12     	; 0x35e2 <__vector_64+0x150>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    35ee:	f2 01       	movw	r30, r4
    35f0:	85 85       	ldd	r24, Z+13	; 0x0d
    35f2:	96 85       	ldd	r25, Z+14	; 0x0e
    35f4:	01 96       	adiw	r24, 0x01	; 1
    35f6:	85 87       	std	Z+13, r24	; 0x0d
    35f8:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    35fa:	ce 01       	movw	r24, r28
    35fc:	01 96       	adiw	r24, 0x01	; 1
    35fe:	b3 01       	movw	r22, r6
    3600:	0e 94 ef 3a 	call	0x75de	; 0x75de <strcpy_P>
            printf(buf);
    3604:	0f 92       	push	r0
    3606:	0f 92       	push	r0
    3608:	41 e0       	ldi	r20, 0x01	; 1
    360a:	50 e0       	ldi	r21, 0x00	; 0
    360c:	4c 0f       	add	r20, r28
    360e:	5d 1f       	adc	r21, r29
    3610:	ed b7       	in	r30, 0x3d	; 61
    3612:	fe b7       	in	r31, 0x3e	; 62
    3614:	41 83       	std	Z+1, r20	; 0x01
    3616:	52 83       	std	Z+2, r21	; 0x02
    3618:	0e 94 42 3b 	call	0x7684	; 0x7684 <printf>
    361c:	0f 90       	pop	r0
    361e:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3620:	80 e0       	ldi	r24, 0x00	; 0
    3622:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <RadioCS>
    CHB_LEAVE_CRIT();
    3626:	80 91 56 40 	lds	r24, 0x4056
    362a:	8f bf       	out	0x3f, r24	; 63
    362c:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    362e:	f7 01       	movw	r30, r14
    3630:	85 81       	ldd	r24, Z+5	; 0x05
    3632:	96 81       	ldd	r25, Z+6	; 0x06
    3634:	01 96       	adiw	r24, 0x01	; 1
    3636:	85 83       	std	Z+5, r24	; 0x05
    3638:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    363a:	81 e0       	ldi	r24, 0x01	; 1
    363c:	83 83       	std	Z+3, r24	; 0x03
    363e:	03 c0       	rjmp	.+6      	; 0x3646 <__vector_64+0x1b4>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    3640:	81 e0       	ldi	r24, 0x01	; 1
    3642:	f7 01       	movw	r30, r14
    3644:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3646:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3648:	86 e1       	ldi	r24, 0x16	; 22
    364a:	0e 94 91 18 	call	0x3122	; 0x3122 <chb_set_state>
    364e:	80 34       	cpi	r24, 0x40	; 64
    3650:	d9 f7       	brne	.-10     	; 0x3648 <__vector_64+0x1b6>
    3652:	19 c0       	rjmp	.+50     	; 0x3686 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3654:	16 ff       	sbrs	r17, 6
    3656:	08 c0       	rjmp	.+16     	; 0x3668 <__vector_64+0x1d6>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3658:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    365a:	f7 01       	movw	r30, r14
    365c:	87 85       	ldd	r24, Z+15	; 0x0f
    365e:	90 89       	ldd	r25, Z+16	; 0x10
    3660:	01 96       	adiw	r24, 0x01	; 1
    3662:	87 87       	std	Z+15, r24	; 0x0f
    3664:	90 8b       	std	Z+16, r25	; 0x10
    3666:	0f c0       	rjmp	.+30     	; 0x3686 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3668:	11 ff       	sbrs	r17, 1
    366a:	02 c0       	rjmp	.+4      	; 0x3670 <__vector_64+0x1de>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    366c:	1d 7f       	andi	r17, 0xFD	; 253
    366e:	0b c0       	rjmp	.+22     	; 0x3686 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3670:	10 ff       	sbrs	r17, 0
    3672:	02 c0       	rjmp	.+4      	; 0x3678 <__vector_64+0x1e6>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3674:	1e 7f       	andi	r17, 0xFE	; 254
    3676:	07 c0       	rjmp	.+14     	; 0x3686 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3678:	11 23       	and	r17, r17
    367a:	2c f4       	brge	.+10     	; 0x3686 <__vector_64+0x1f4>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    367c:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    367e:	f7 01       	movw	r30, r14
    3680:	81 89       	ldd	r24, Z+17	; 0x11
    3682:	8f 5f       	subi	r24, 0xFF	; 255
    3684:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3686:	11 23       	and	r17, r17
    3688:	09 f0       	breq	.+2      	; 0x368c <__vector_64+0x1fa>
    368a:	55 cf       	rjmp	.-342    	; 0x3536 <__vector_64+0xa4>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    368c:	80 91 56 40 	lds	r24, 0x4056
    3690:	8f bf       	out	0x3f, r24	; 63
    3692:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3694:	8f e0       	ldi	r24, 0x0F	; 15
    3696:	0e 94 5e 18 	call	0x30bc	; 0x30bc <chb_reg_read>
}
    369a:	e2 96       	adiw	r28, 0x32	; 50
    369c:	cd bf       	out	0x3d, r28	; 61
    369e:	de bf       	out	0x3e, r29	; 62
    36a0:	df 91       	pop	r29
    36a2:	cf 91       	pop	r28
    36a4:	ff 91       	pop	r31
    36a6:	ef 91       	pop	r30
    36a8:	bf 91       	pop	r27
    36aa:	af 91       	pop	r26
    36ac:	9f 91       	pop	r25
    36ae:	8f 91       	pop	r24
    36b0:	7f 91       	pop	r23
    36b2:	6f 91       	pop	r22
    36b4:	5f 91       	pop	r21
    36b6:	4f 91       	pop	r20
    36b8:	3f 91       	pop	r19
    36ba:	2f 91       	pop	r18
    36bc:	1f 91       	pop	r17
    36be:	0f 91       	pop	r16
    36c0:	ff 90       	pop	r15
    36c2:	ef 90       	pop	r14
    36c4:	df 90       	pop	r13
    36c6:	cf 90       	pop	r12
    36c8:	bf 90       	pop	r11
    36ca:	af 90       	pop	r10
    36cc:	9f 90       	pop	r9
    36ce:	8f 90       	pop	r8
    36d0:	7f 90       	pop	r7
    36d2:	6f 90       	pop	r6
    36d4:	5f 90       	pop	r5
    36d6:	4f 90       	pop	r4
    36d8:	0f 90       	pop	r0
    36da:	0b be       	out	0x3b, r0	; 59
    36dc:	0f 90       	pop	r0
    36de:	0f be       	out	0x3f, r0	; 63
    36e0:	0f 90       	pop	r0
    36e2:	1f 90       	pop	r1
    36e4:	18 95       	reti

000036e6 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    36e6:	0f 93       	push	r16
    36e8:	1f 93       	push	r17
    36ea:	cf 93       	push	r28
    36ec:	df 93       	push	r29
    36ee:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    36f0:	e0 ec       	ldi	r30, 0xC0	; 192
    36f2:	f1 e0       	ldi	r31, 0x01	; 1
    36f4:	84 85       	ldd	r24, Z+12	; 0x0c
    36f6:	87 7f       	andi	r24, 0xF7	; 247
    36f8:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    36fa:	41 15       	cp	r20, r1
    36fc:	51 05       	cpc	r21, r1
    36fe:	09 f4       	brne	.+2      	; 0x3702 <chb_eeprom_write+0x1c>
    3700:	50 c0       	rjmp	.+160    	; 0x37a2 <chb_eeprom_write+0xbc>
    3702:	e0 e0       	ldi	r30, 0x00	; 0
    3704:	f0 e0       	ldi	r31, 0x00	; 0
    3706:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3708:	a0 ec       	ldi	r26, 0xC0	; 192
    370a:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    370c:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    370e:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3710:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3712:	cf 01       	movw	r24, r30
    3714:	80 0f       	add	r24, r16
    3716:	91 1f       	adc	r25, r17
    3718:	e6 0f       	add	r30, r22
    371a:	f7 1f       	adc	r31, r23
    371c:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    371e:	1f 96       	adiw	r26, 0x0f	; 15
    3720:	ec 91       	ld	r30, X
    3722:	1f 97       	sbiw	r26, 0x0f	; 15
    3724:	ee 23       	and	r30, r30
    3726:	dc f3       	brlt	.-10     	; 0x371e <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3728:	1f 96       	adiw	r26, 0x0f	; 15
    372a:	ec 91       	ld	r30, X
    372c:	1f 97       	sbiw	r26, 0x0f	; 15
    372e:	e1 ff       	sbrs	r30, 1
    3730:	11 c0       	rjmp	.+34     	; 0x3754 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3732:	1a 96       	adiw	r26, 0x0a	; 10
    3734:	dc 93       	st	X, r29
    3736:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3738:	ef 93       	push	r30
    373a:	ff 93       	push	r31
    373c:	0f 93       	push	r16
    373e:	2f 93       	push	r18
    3740:	eb ec       	ldi	r30, 0xCB	; 203
    3742:	f1 e0       	ldi	r31, 0x01	; 1
    3744:	08 ed       	ldi	r16, 0xD8	; 216
    3746:	21 e0       	ldi	r18, 0x01	; 1
    3748:	04 bf       	out	0x34, r16	; 52
    374a:	20 83       	st	Z, r18
    374c:	2f 91       	pop	r18
    374e:	0f 91       	pop	r16
    3750:	ff 91       	pop	r31
    3752:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3754:	1a 96       	adiw	r26, 0x0a	; 10
    3756:	cc 93       	st	X, r28
    3758:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    375a:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    375c:	89 2f       	mov	r24, r25
    375e:	8f 71       	andi	r24, 0x1F	; 31
    3760:	11 96       	adiw	r26, 0x01	; 1
    3762:	8c 93       	st	X, r24
    3764:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3766:	12 96       	adiw	r26, 0x02	; 2
    3768:	1c 92       	st	X, r1
    376a:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    376c:	14 96       	adiw	r26, 0x04	; 4
    376e:	fc 93       	st	X, r31
    3770:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3772:	1a 96       	adiw	r26, 0x0a	; 10
    3774:	3c 93       	st	X, r19
    3776:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3778:	ef 93       	push	r30
    377a:	ff 93       	push	r31
    377c:	0f 93       	push	r16
    377e:	2f 93       	push	r18
    3780:	eb ec       	ldi	r30, 0xCB	; 203
    3782:	f1 e0       	ldi	r31, 0x01	; 1
    3784:	08 ed       	ldi	r16, 0xD8	; 216
    3786:	21 e0       	ldi	r18, 0x01	; 1
    3788:	04 bf       	out	0x34, r16	; 52
    378a:	20 83       	st	Z, r18
    378c:	2f 91       	pop	r18
    378e:	0f 91       	pop	r16
    3790:	ff 91       	pop	r31
    3792:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3794:	2f 5f       	subi	r18, 0xFF	; 255
    3796:	e2 2f       	mov	r30, r18
    3798:	f0 e0       	ldi	r31, 0x00	; 0
    379a:	e4 17       	cp	r30, r20
    379c:	f5 07       	cpc	r31, r21
    379e:	08 f4       	brcc	.+2      	; 0x37a2 <chb_eeprom_write+0xbc>
    37a0:	b8 cf       	rjmp	.-144    	; 0x3712 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    37a2:	df 91       	pop	r29
    37a4:	cf 91       	pop	r28
    37a6:	1f 91       	pop	r17
    37a8:	0f 91       	pop	r16
    37aa:	08 95       	ret

000037ac <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    37ac:	1f 93       	push	r17
    37ae:	cf 93       	push	r28
    37b0:	df 93       	push	r29
    37b2:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    37b4:	e0 ec       	ldi	r30, 0xC0	; 192
    37b6:	f1 e0       	ldi	r31, 0x01	; 1
    37b8:	84 85       	ldd	r24, Z+12	; 0x0c
    37ba:	87 7f       	andi	r24, 0xF7	; 247
    37bc:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    37be:	41 15       	cp	r20, r1
    37c0:	51 05       	cpc	r21, r1
    37c2:	41 f1       	breq	.+80     	; 0x3814 <chb_eeprom_read+0x68>
    37c4:	80 e0       	ldi	r24, 0x00	; 0
    37c6:	90 e0       	ldi	r25, 0x00	; 0
    37c8:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    37ca:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    37cc:	db 01       	movw	r26, r22
    37ce:	a8 0f       	add	r26, r24
    37d0:	b9 1f       	adc	r27, r25
    37d2:	82 0f       	add	r24, r18
    37d4:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    37d6:	17 85       	ldd	r17, Z+15	; 0x0f
    37d8:	11 23       	and	r17, r17
    37da:	ec f3       	brlt	.-6      	; 0x37d6 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    37dc:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    37de:	89 2f       	mov	r24, r25
    37e0:	8f 71       	andi	r24, 0x1F	; 31
    37e2:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    37e4:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    37e6:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    37e8:	ef 93       	push	r30
    37ea:	ff 93       	push	r31
    37ec:	0f 93       	push	r16
    37ee:	2f 93       	push	r18
    37f0:	eb ec       	ldi	r30, 0xCB	; 203
    37f2:	f1 e0       	ldi	r31, 0x01	; 1
    37f4:	08 ed       	ldi	r16, 0xD8	; 216
    37f6:	21 e0       	ldi	r18, 0x01	; 1
    37f8:	04 bf       	out	0x34, r16	; 52
    37fa:	20 83       	st	Z, r18
    37fc:	2f 91       	pop	r18
    37fe:	0f 91       	pop	r16
    3800:	ff 91       	pop	r31
    3802:	ef 91       	pop	r30

    return NVM.DATA0;
    3804:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3806:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3808:	cf 5f       	subi	r28, 0xFF	; 255
    380a:	8c 2f       	mov	r24, r28
    380c:	90 e0       	ldi	r25, 0x00	; 0
    380e:	84 17       	cp	r24, r20
    3810:	95 07       	cpc	r25, r21
    3812:	e0 f2       	brcs	.-72     	; 0x37cc <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3814:	df 91       	pop	r29
    3816:	cf 91       	pop	r28
    3818:	1f 91       	pop	r17
    381a:	08 95       	ret

0000381c <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    381c:	e0 e6       	ldi	r30, 0x60	; 96
    381e:	f6 e0       	ldi	r31, 0x06	; 6
    3820:	80 81       	ld	r24, Z
    3822:	80 6b       	ori	r24, 0xB0	; 176
    3824:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3826:	e4 e6       	ldi	r30, 0x64	; 100
    3828:	f6 e0       	ldi	r31, 0x06	; 6
    382a:	80 81       	ld	r24, Z
    382c:	80 61       	ori	r24, 0x10	; 16
    382e:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3830:	a0 ec       	ldi	r26, 0xC0	; 192
    3832:	b9 e0       	ldi	r27, 0x09	; 9
    3834:	8c 91       	ld	r24, X
    3836:	81 65       	ori	r24, 0x51	; 81
    3838:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    383a:	80 81       	ld	r24, Z
    383c:	80 61       	ori	r24, 0x10	; 16
    383e:	80 83       	st	Z, r24
}
    3840:	08 95       	ret

00003842 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3842:	e0 ec       	ldi	r30, 0xC0	; 192
    3844:	f9 e0       	ldi	r31, 0x09	; 9
    3846:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3848:	82 81       	ldd	r24, Z+2	; 0x02
    384a:	88 23       	and	r24, r24
    384c:	ec f7       	brge	.-6      	; 0x3848 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    384e:	e0 ec       	ldi	r30, 0xC0	; 192
    3850:	f9 e0       	ldi	r31, 0x09	; 9
    3852:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3854:	08 95       	ret

00003856 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3856:	0f 93       	push	r16
    3858:	cf 93       	push	r28
    385a:	df 93       	push	r29
    385c:	0f 92       	push	r0
    385e:	cd b7       	in	r28, 0x3d	; 61
    3860:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    3862:	2f b7       	in	r18, 0x3f	; 63
    3864:	29 83       	std	Y+1, r18	; 0x01
    3866:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3868:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    386a:	fc 01       	movw	r30, r24
    386c:	08 ed       	ldi	r16, 0xD8	; 216
    386e:	04 bf       	out	0x34, r16	; 52
    3870:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    3872:	89 81       	ldd	r24, Y+1	; 0x01
    3874:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3876:	0f 90       	pop	r0
    3878:	df 91       	pop	r29
    387a:	cf 91       	pop	r28
    387c:	0f 91       	pop	r16
    387e:	08 95       	ret

00003880 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    3880:	66 23       	and	r22, r22
    3882:	11 f0       	breq	.+4      	; 0x3888 <CLKSYS_XOSC_Config+0x8>
    3884:	90 e2       	ldi	r25, 0x20	; 32
    3886:	01 c0       	rjmp	.+2      	; 0x388a <CLKSYS_XOSC_Config+0xa>
    3888:	90 e0       	ldi	r25, 0x00	; 0
    388a:	84 2b       	or	r24, r20
    388c:	89 2b       	or	r24, r25
    388e:	e0 e5       	ldi	r30, 0x50	; 80
    3890:	f0 e0       	ldi	r31, 0x00	; 0
    3892:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3894:	08 95       	ret

00003896 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3896:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3898:	86 2b       	or	r24, r22
    389a:	e0 e5       	ldi	r30, 0x50	; 80
    389c:	f0 e0       	ldi	r31, 0x00	; 0
    389e:	85 83       	std	Z+5, r24	; 0x05
}
    38a0:	08 95       	ret

000038a2 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    38a2:	e0 e5       	ldi	r30, 0x50	; 80
    38a4:	f0 e0       	ldi	r31, 0x00	; 0
    38a6:	90 81       	ld	r25, Z
    38a8:	28 2f       	mov	r18, r24
    38aa:	20 95       	com	r18
    38ac:	92 23       	and	r25, r18
    38ae:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    38b0:	90 81       	ld	r25, Z
	return clkEnabled;
}
    38b2:	89 23       	and	r24, r25
    38b4:	08 95       	ret

000038b6 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    38b6:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    38b8:	81 e4       	ldi	r24, 0x41	; 65
    38ba:	90 e0       	ldi	r25, 0x00	; 0
    38bc:	0e 94 2b 1c 	call	0x3856	; 0x3856 <CCPWrite>
}
    38c0:	08 95       	ret

000038c2 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    38c2:	1f 93       	push	r17
    38c4:	cf 93       	push	r28
    38c6:	df 93       	push	r29
    38c8:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    38ca:	c0 e4       	ldi	r28, 0x40	; 64
    38cc:	d0 e0       	ldi	r29, 0x00	; 0
    38ce:	68 81       	ld	r22, Y
    38d0:	68 7f       	andi	r22, 0xF8	; 248
    38d2:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    38d4:	80 e4       	ldi	r24, 0x40	; 64
    38d6:	90 e0       	ldi	r25, 0x00	; 0
    38d8:	0e 94 2b 1c 	call	0x3856	; 0x3856 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    38dc:	88 81       	ld	r24, Y
	return clkCtrl;
}
    38de:	81 23       	and	r24, r17
    38e0:	df 91       	pop	r29
    38e2:	cf 91       	pop	r28
    38e4:	1f 91       	pop	r17
    38e6:	08 95       	ret

000038e8 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    38e8:	e0 e4       	ldi	r30, 0x40	; 64
    38ea:	f0 e0       	ldi	r31, 0x00	; 0
    38ec:	93 81       	ldd	r25, Z+3	; 0x03
    38ee:	91 7f       	andi	r25, 0xF1	; 241
    38f0:	91 60       	ori	r25, 0x01	; 1
    38f2:	89 2b       	or	r24, r25
    38f4:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    38f6:	08 95       	ret

000038f8 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    38f8:	e0 e5       	ldi	r30, 0x50	; 80
    38fa:	f0 e0       	ldi	r31, 0x00	; 0
    38fc:	26 81       	ldd	r18, Z+6	; 0x06
    38fe:	98 2f       	mov	r25, r24
    3900:	38 2f       	mov	r19, r24
    3902:	30 95       	com	r19
    3904:	23 23       	and	r18, r19
    3906:	66 23       	and	r22, r22
    3908:	09 f4       	brne	.+2      	; 0x390c <CLKSYS_AutoCalibration_Enable+0x14>
    390a:	90 e0       	ldi	r25, 0x00	; 0
    390c:	92 2b       	or	r25, r18
    390e:	e0 e5       	ldi	r30, 0x50	; 80
    3910:	f0 e0       	ldi	r31, 0x00	; 0
    3912:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3914:	81 30       	cpi	r24, 0x01	; 1
    3916:	31 f4       	brne	.+12     	; 0x3924 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3918:	e8 e6       	ldi	r30, 0x68	; 104
    391a:	f0 e0       	ldi	r31, 0x00	; 0
    391c:	80 81       	ld	r24, Z
    391e:	81 60       	ori	r24, 0x01	; 1
    3920:	80 83       	st	Z, r24
    3922:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3924:	82 30       	cpi	r24, 0x02	; 2
    3926:	29 f4       	brne	.+10     	; 0x3932 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3928:	e0 e6       	ldi	r30, 0x60	; 96
    392a:	f0 e0       	ldi	r31, 0x00	; 0
    392c:	80 81       	ld	r24, Z
    392e:	81 60       	ori	r24, 0x01	; 1
    3930:	80 83       	st	Z, r24
    3932:	08 95       	ret

00003934 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3934:	83 e5       	ldi	r24, 0x53	; 83
    3936:	90 e0       	ldi	r25, 0x00	; 0
    3938:	63 e0       	ldi	r22, 0x03	; 3
    393a:	0e 94 2b 1c 	call	0x3856	; 0x3856 <CCPWrite>
}
    393e:	08 95       	ret

00003940 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    3940:	82 e4       	ldi	r24, 0x42	; 66
    3942:	90 e0       	ldi	r25, 0x00	; 0
    3944:	61 e0       	ldi	r22, 0x01	; 1
    3946:	0e 94 2b 1c 	call	0x3856	; 0x3856 <CCPWrite>
}
    394a:	08 95       	ret

0000394c <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    394c:	80 ec       	ldi	r24, 0xC0	; 192
    394e:	60 e0       	ldi	r22, 0x00	; 0
    3950:	4b e0       	ldi	r20, 0x0B	; 11
    3952:	0e 94 40 1c 	call	0x3880	; 0x3880 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    3956:	e0 e5       	ldi	r30, 0x50	; 80
    3958:	f0 e0       	ldi	r31, 0x00	; 0
    395a:	80 81       	ld	r24, Z
    395c:	88 60       	ori	r24, 0x08	; 8
    395e:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    3960:	81 81       	ldd	r24, Z+1	; 0x01
    3962:	83 ff       	sbrs	r24, 3
    3964:	fd cf       	rjmp	.-6      	; 0x3960 <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    3966:	80 ec       	ldi	r24, 0xC0	; 192
    3968:	62 e0       	ldi	r22, 0x02	; 2
    396a:	0e 94 4b 1c 	call	0x3896	; 0x3896 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    396e:	e0 e5       	ldi	r30, 0x50	; 80
    3970:	f0 e0       	ldi	r31, 0x00	; 0
    3972:	80 81       	ld	r24, Z
    3974:	80 61       	ori	r24, 0x10	; 16
    3976:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    3978:	81 81       	ldd	r24, Z+1	; 0x01
    397a:	84 ff       	sbrs	r24, 4
    397c:	fd cf       	rjmp	.-6      	; 0x3978 <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    397e:	84 e0       	ldi	r24, 0x04	; 4
    3980:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3984:	81 e0       	ldi	r24, 0x01	; 1
    3986:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <CLKSYS_Disable>
}
    398a:	08 95       	ret

0000398c <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    398c:	e0 e5       	ldi	r30, 0x50	; 80
    398e:	f0 e0       	ldi	r31, 0x00	; 0
    3990:	80 81       	ld	r24, Z
    3992:	82 60       	ori	r24, 0x02	; 2
    3994:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    3996:	80 e0       	ldi	r24, 0x00	; 0
    3998:	61 e0       	ldi	r22, 0x01	; 1
    399a:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    399e:	e0 e5       	ldi	r30, 0x50	; 80
    39a0:	f0 e0       	ldi	r31, 0x00	; 0
    39a2:	81 81       	ldd	r24, Z+1	; 0x01
    39a4:	81 ff       	sbrs	r24, 1
    39a6:	fd cf       	rjmp	.-6      	; 0x39a2 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    39a8:	81 e0       	ldi	r24, 0x01	; 1
    39aa:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    39ae:	81 e0       	ldi	r24, 0x01	; 1
    39b0:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <CLKSYS_Disable>
	
}
    39b4:	08 95       	ret

000039b6 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    39b6:	e0 e5       	ldi	r30, 0x50	; 80
    39b8:	f0 e0       	ldi	r31, 0x00	; 0
    39ba:	80 81       	ld	r24, Z
    39bc:	82 60       	ori	r24, 0x02	; 2
    39be:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    39c0:	80 e0       	ldi	r24, 0x00	; 0
    39c2:	60 e0       	ldi	r22, 0x00	; 0
    39c4:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    39c8:	e0 e5       	ldi	r30, 0x50	; 80
    39ca:	f0 e0       	ldi	r31, 0x00	; 0
    39cc:	81 81       	ldd	r24, Z+1	; 0x01
    39ce:	81 ff       	sbrs	r24, 1
    39d0:	fd cf       	rjmp	.-6      	; 0x39cc <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    39d2:	81 e0       	ldi	r24, 0x01	; 1
    39d4:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    39d8:	81 e0       	ldi	r24, 0x01	; 1
    39da:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <CLKSYS_Disable>
	
}
    39de:	08 95       	ret

000039e0 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    39e0:	88 23       	and	r24, r24
    39e2:	29 f0       	breq	.+10     	; 0x39ee <portExCS+0xe>
    39e4:	88 e0       	ldi	r24, 0x08	; 8
    39e6:	e0 e0       	ldi	r30, 0x00	; 0
    39e8:	f6 e0       	ldi	r31, 0x06	; 6
    39ea:	86 83       	std	Z+6, r24	; 0x06
    39ec:	04 c0       	rjmp	.+8      	; 0x39f6 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    39ee:	88 e0       	ldi	r24, 0x08	; 8
    39f0:	e0 e0       	ldi	r30, 0x00	; 0
    39f2:	f6 e0       	ldi	r31, 0x06	; 6
    39f4:	85 83       	std	Z+5, r24	; 0x05
    39f6:	8a e6       	ldi	r24, 0x6A	; 106
    39f8:	8a 95       	dec	r24
    39fa:	f1 f7       	brne	.-4      	; 0x39f8 <portExCS+0x18>
    39fc:	00 c0       	rjmp	.+0      	; 0x39fe <portExCS+0x1e>
	}
	_delay_us(10);
}
    39fe:	08 95       	ret

00003a00 <Ext1Power>:
*/


void Ext1Power(uint8_t on) {
	
	if (on) {
    3a00:	88 23       	and	r24, r24
    3a02:	79 f0       	breq	.+30     	; 0x3a22 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    3a04:	e0 ea       	ldi	r30, 0xA0	; 160
    3a06:	f6 e0       	ldi	r31, 0x06	; 6
    3a08:	80 e2       	ldi	r24, 0x20	; 32
    3a0a:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    3a0c:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3a0e:	8f ef       	ldi	r24, 0xFF	; 255
    3a10:	93 ec       	ldi	r25, 0xC3	; 195
    3a12:	a9 e0       	ldi	r26, 0x09	; 9
    3a14:	81 50       	subi	r24, 0x01	; 1
    3a16:	90 40       	sbci	r25, 0x00	; 0
    3a18:	a0 40       	sbci	r26, 0x00	; 0
    3a1a:	e1 f7       	brne	.-8      	; 0x3a14 <Ext1Power+0x14>
    3a1c:	00 c0       	rjmp	.+0      	; 0x3a1e <Ext1Power+0x1e>
    3a1e:	00 00       	nop
    3a20:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    3a22:	e0 ea       	ldi	r30, 0xA0	; 160
    3a24:	f6 e0       	ldi	r31, 0x06	; 6
    3a26:	80 e2       	ldi	r24, 0x20	; 32
    3a28:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    3a2a:	82 83       	std	Z+2, r24	; 0x02
    3a2c:	08 95       	ret

00003a2e <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
    3a2e:	88 23       	and	r24, r24
    3a30:	79 f0       	breq	.+30     	; 0x3a50 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    3a32:	e0 ea       	ldi	r30, 0xA0	; 160
    3a34:	f6 e0       	ldi	r31, 0x06	; 6
    3a36:	80 e4       	ldi	r24, 0x40	; 64
    3a38:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    3a3a:	85 83       	std	Z+5, r24	; 0x05
    3a3c:	8f ef       	ldi	r24, 0xFF	; 255
    3a3e:	93 ec       	ldi	r25, 0xC3	; 195
    3a40:	a9 e0       	ldi	r26, 0x09	; 9
    3a42:	81 50       	subi	r24, 0x01	; 1
    3a44:	90 40       	sbci	r25, 0x00	; 0
    3a46:	a0 40       	sbci	r26, 0x00	; 0
    3a48:	e1 f7       	brne	.-8      	; 0x3a42 <Ext2Power+0x14>
    3a4a:	00 c0       	rjmp	.+0      	; 0x3a4c <Ext2Power+0x1e>
    3a4c:	00 00       	nop
    3a4e:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    3a50:	e0 ea       	ldi	r30, 0xA0	; 160
    3a52:	f6 e0       	ldi	r31, 0x06	; 6
    3a54:	80 e4       	ldi	r24, 0x40	; 64
    3a56:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    3a58:	82 83       	std	Z+2, r24	; 0x02
    3a5a:	08 95       	ret

00003a5c <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
    3a5c:	88 23       	and	r24, r24
    3a5e:	79 f0       	breq	.+30     	; 0x3a7e <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    3a60:	e0 ea       	ldi	r30, 0xA0	; 160
    3a62:	f6 e0       	ldi	r31, 0x06	; 6
    3a64:	80 e8       	ldi	r24, 0x80	; 128
    3a66:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    3a68:	85 83       	std	Z+5, r24	; 0x05
    3a6a:	8f ef       	ldi	r24, 0xFF	; 255
    3a6c:	93 ec       	ldi	r25, 0xC3	; 195
    3a6e:	a9 e0       	ldi	r26, 0x09	; 9
    3a70:	81 50       	subi	r24, 0x01	; 1
    3a72:	90 40       	sbci	r25, 0x00	; 0
    3a74:	a0 40       	sbci	r26, 0x00	; 0
    3a76:	e1 f7       	brne	.-8      	; 0x3a70 <HVPower+0x14>
    3a78:	00 c0       	rjmp	.+0      	; 0x3a7a <HVPower+0x1e>
    3a7a:	00 00       	nop
    3a7c:	05 c0       	rjmp	.+10     	; 0x3a88 <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    3a7e:	e0 ea       	ldi	r30, 0xA0	; 160
    3a80:	f6 e0       	ldi	r31, 0x06	; 6
    3a82:	80 e8       	ldi	r24, 0x80	; 128
    3a84:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    3a86:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3a88:	af e3       	ldi	r26, 0x3F	; 63
    3a8a:	bf e1       	ldi	r27, 0x1F	; 31
    3a8c:	11 97       	sbiw	r26, 0x01	; 1
    3a8e:	f1 f7       	brne	.-4      	; 0x3a8c <HVPower+0x30>
    3a90:	00 c0       	rjmp	.+0      	; 0x3a92 <HVPower+0x36>
    3a92:	00 00       	nop
	}
	_delay_us(1000);
}
    3a94:	08 95       	ret

00003a96 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    3a96:	88 23       	and	r24, r24
    3a98:	29 f0       	breq	.+10     	; 0x3aa4 <lowerMuxCS+0xe>
    3a9a:	80 e1       	ldi	r24, 0x10	; 16
    3a9c:	e0 e8       	ldi	r30, 0x80	; 128
    3a9e:	f6 e0       	ldi	r31, 0x06	; 6
    3aa0:	86 83       	std	Z+6, r24	; 0x06
    3aa2:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    3aa4:	80 e1       	ldi	r24, 0x10	; 16
    3aa6:	e0 e8       	ldi	r30, 0x80	; 128
    3aa8:	f6 e0       	ldi	r31, 0x06	; 6
    3aaa:	85 83       	std	Z+5, r24	; 0x05
    3aac:	08 95       	ret

00003aae <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    3aae:	88 23       	and	r24, r24
    3ab0:	29 f0       	breq	.+10     	; 0x3abc <upperMuxCS+0xe>
    3ab2:	82 e0       	ldi	r24, 0x02	; 2
    3ab4:	e0 e4       	ldi	r30, 0x40	; 64
    3ab6:	f6 e0       	ldi	r31, 0x06	; 6
    3ab8:	86 83       	std	Z+6, r24	; 0x06
    3aba:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    3abc:	82 e0       	ldi	r24, 0x02	; 2
    3abe:	e0 e4       	ldi	r30, 0x40	; 64
    3ac0:	f6 e0       	ldi	r31, 0x06	; 6
    3ac2:	85 83       	std	Z+5, r24	; 0x05
    3ac4:	08 95       	ret

00003ac6 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3ac6:	e0 e4       	ldi	r30, 0x40	; 64
    3ac8:	f6 e0       	ldi	r31, 0x06	; 6
    3aca:	90 e1       	ldi	r25, 0x10	; 16
    3acc:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3ace:	28 e3       	ldi	r18, 0x38	; 56
    3ad0:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3ad2:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    3ad4:	81 65       	ori	r24, 0x51	; 81
    3ad6:	a0 ec       	ldi	r26, 0xC0	; 192
    3ad8:	b8 e0       	ldi	r27, 0x08	; 8
    3ada:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3adc:	11 96       	adiw	r26, 0x01	; 1
    3ade:	1c 92       	st	X, r1
    3ae0:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3ae2:	80 ea       	ldi	r24, 0xA0	; 160
    3ae4:	81 83       	std	Z+1, r24	; 0x01

	
}
    3ae6:	08 95       	ret

00003ae8 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3ae8:	e0 e4       	ldi	r30, 0x40	; 64
    3aea:	f6 e0       	ldi	r31, 0x06	; 6
    3aec:	90 e1       	ldi	r25, 0x10	; 16
    3aee:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3af0:	28 e3       	ldi	r18, 0x38	; 56
    3af2:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3af4:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    3af6:	80 65       	ori	r24, 0x50	; 80
    3af8:	68 2b       	or	r22, r24
    3afa:	a0 ec       	ldi	r26, 0xC0	; 192
    3afc:	b8 e0       	ldi	r27, 0x08	; 8
    3afe:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3b00:	11 96       	adiw	r26, 0x01	; 1
    3b02:	1c 92       	st	X, r1
    3b04:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3b06:	80 ea       	ldi	r24, 0xA0	; 160
    3b08:	81 83       	std	Z+1, r24	; 0x01
}
    3b0a:	08 95       	ret

00003b0c <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    3b0c:	88 23       	and	r24, r24
    3b0e:	29 f0       	breq	.+10     	; 0x3b1a <SPICS+0xe>
    3b10:	80 e1       	ldi	r24, 0x10	; 16
    3b12:	e0 e4       	ldi	r30, 0x40	; 64
    3b14:	f6 e0       	ldi	r31, 0x06	; 6
    3b16:	86 83       	std	Z+6, r24	; 0x06
    3b18:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    3b1a:	80 e1       	ldi	r24, 0x10	; 16
    3b1c:	e0 e4       	ldi	r30, 0x40	; 64
    3b1e:	f6 e0       	ldi	r31, 0x06	; 6
    3b20:	85 83       	std	Z+5, r24	; 0x05
    3b22:	08 95       	ret

00003b24 <SPIDisable>:
	}	
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
    3b24:	e0 e4       	ldi	r30, 0x40	; 64
    3b26:	f6 e0       	ldi	r31, 0x06	; 6
    3b28:	80 e1       	ldi	r24, 0x10	; 16
    3b2a:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    3b2c:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    3b30:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    3b32:	80 eb       	ldi	r24, 0xB0	; 176
    3b34:	82 83       	std	Z+2, r24	; 0x02

}
    3b36:	08 95       	ret

00003b38 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3b38:	cf 93       	push	r28
    3b3a:	df 93       	push	r29
    3b3c:	c8 2f       	mov	r28, r24
    3b3e:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3b40:	80 e0       	ldi	r24, 0x00	; 0
    3b42:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    3b46:	81 e0       	ldi	r24, 0x01	; 1
    3b48:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	portExCS(TRUE);
    3b4c:	81 e0       	ldi	r24, 0x01	; 1
    3b4e:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    3b52:	dd 23       	and	r29, r29
    3b54:	89 f0       	breq	.+34     	; 0x3b78 <PortEx_OUTCLR+0x40>
    3b56:	80 91 d6 23 	lds	r24, 0x23D6
    3b5a:	c0 95       	com	r28
    3b5c:	c8 23       	and	r28, r24
    3b5e:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    3b62:	80 e4       	ldi	r24, 0x40	; 64
    3b64:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3b68:	84 e1       	ldi	r24, 0x14	; 20
    3b6a:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3b6e:	80 91 d6 23 	lds	r24, 0x23D6
    3b72:	80 93 67 50 	sts	0x5067, r24
    3b76:	10 c0       	rjmp	.+32     	; 0x3b98 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    3b78:	80 91 82 50 	lds	r24, 0x5082
    3b7c:	c0 95       	com	r28
    3b7e:	c8 23       	and	r28, r24
    3b80:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3b84:	80 e4       	ldi	r24, 0x40	; 64
    3b86:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3b8a:	85 e1       	ldi	r24, 0x15	; 21
    3b8c:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3b90:	80 91 82 50 	lds	r24, 0x5082
    3b94:	80 93 67 50 	sts	0x5067, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3b98:	80 e0       	ldi	r24, 0x00	; 0
    3b9a:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3b9c:	25 e6       	ldi	r18, 0x65	; 101
    3b9e:	30 e5       	ldi	r19, 0x50	; 80
    3ba0:	a0 ec       	ldi	r26, 0xC0	; 192
    3ba2:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3ba4:	c1 e7       	ldi	r28, 0x71	; 113
    3ba6:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3ba8:	f9 01       	movw	r30, r18
    3baa:	e8 0f       	add	r30, r24
    3bac:	f9 1f       	adc	r31, r25
    3bae:	40 81       	ld	r20, Z
    3bb0:	13 96       	adiw	r26, 0x03	; 3
    3bb2:	4c 93       	st	X, r20
    3bb4:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3bb6:	12 96       	adiw	r26, 0x02	; 2
    3bb8:	4c 91       	ld	r20, X
    3bba:	12 97       	sbiw	r26, 0x02	; 2
    3bbc:	44 23       	and	r20, r20
    3bbe:	dc f7       	brge	.-10     	; 0x3bb6 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    3bc0:	13 96       	adiw	r26, 0x03	; 3
    3bc2:	4c 91       	ld	r20, X
    3bc4:	13 97       	sbiw	r26, 0x03	; 3
    3bc6:	48 83       	st	Y, r20
    3bc8:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3bca:	83 30       	cpi	r24, 0x03	; 3
    3bcc:	91 05       	cpc	r25, r1
    3bce:	61 f7       	brne	.-40     	; 0x3ba8 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3bd0:	80 e0       	ldi	r24, 0x00	; 0
    3bd2:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	portExCS(FALSE);
    3bd6:	80 e0       	ldi	r24, 0x00	; 0
    3bd8:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>
	SPIDisable();
    3bdc:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
}
    3be0:	df 91       	pop	r29
    3be2:	cf 91       	pop	r28
    3be4:	08 95       	ret

00003be6 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3be6:	cf 93       	push	r28
    3be8:	df 93       	push	r29
    3bea:	c8 2f       	mov	r28, r24
    3bec:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3bee:	80 e0       	ldi	r24, 0x00	; 0
    3bf0:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    3bf4:	81 e0       	ldi	r24, 0x01	; 1
    3bf6:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	portExCS(TRUE);
    3bfa:	81 e0       	ldi	r24, 0x01	; 1
    3bfc:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    3c00:	dd 23       	and	r29, r29
    3c02:	81 f0       	breq	.+32     	; 0x3c24 <PortEx_OUTSET+0x3e>
    3c04:	80 91 d6 23 	lds	r24, 0x23D6
    3c08:	c8 2b       	or	r28, r24
    3c0a:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    3c0e:	80 e4       	ldi	r24, 0x40	; 64
    3c10:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3c14:	84 e1       	ldi	r24, 0x14	; 20
    3c16:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3c1a:	80 91 d6 23 	lds	r24, 0x23D6
    3c1e:	80 93 67 50 	sts	0x5067, r24
    3c22:	0f c0       	rjmp	.+30     	; 0x3c42 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    3c24:	80 91 82 50 	lds	r24, 0x5082
    3c28:	c8 2b       	or	r28, r24
    3c2a:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3c2e:	80 e4       	ldi	r24, 0x40	; 64
    3c30:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3c34:	85 e1       	ldi	r24, 0x15	; 21
    3c36:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3c3a:	80 91 82 50 	lds	r24, 0x5082
    3c3e:	80 93 67 50 	sts	0x5067, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3c42:	80 e0       	ldi	r24, 0x00	; 0
    3c44:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3c46:	25 e6       	ldi	r18, 0x65	; 101
    3c48:	30 e5       	ldi	r19, 0x50	; 80
    3c4a:	a0 ec       	ldi	r26, 0xC0	; 192
    3c4c:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3c4e:	c1 e7       	ldi	r28, 0x71	; 113
    3c50:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3c52:	f9 01       	movw	r30, r18
    3c54:	e8 0f       	add	r30, r24
    3c56:	f9 1f       	adc	r31, r25
    3c58:	40 81       	ld	r20, Z
    3c5a:	13 96       	adiw	r26, 0x03	; 3
    3c5c:	4c 93       	st	X, r20
    3c5e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3c60:	12 96       	adiw	r26, 0x02	; 2
    3c62:	4c 91       	ld	r20, X
    3c64:	12 97       	sbiw	r26, 0x02	; 2
    3c66:	44 23       	and	r20, r20
    3c68:	dc f7       	brge	.-10     	; 0x3c60 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3c6a:	13 96       	adiw	r26, 0x03	; 3
    3c6c:	4c 91       	ld	r20, X
    3c6e:	13 97       	sbiw	r26, 0x03	; 3
    3c70:	48 83       	st	Y, r20
    3c72:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3c74:	83 30       	cpi	r24, 0x03	; 3
    3c76:	91 05       	cpc	r25, r1
    3c78:	61 f7       	brne	.-40     	; 0x3c52 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3c7a:	80 e0       	ldi	r24, 0x00	; 0
    3c7c:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	portExCS(FALSE);
    3c80:	80 e0       	ldi	r24, 0x00	; 0
    3c82:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>
	SPIDisable();
    3c86:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
}
    3c8a:	df 91       	pop	r29
    3c8c:	cf 91       	pop	r28
    3c8e:	08 95       	ret

00003c90 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3c90:	cf 93       	push	r28
    3c92:	df 93       	push	r29
    3c94:	c8 2f       	mov	r28, r24
    3c96:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3c98:	80 e0       	ldi	r24, 0x00	; 0
    3c9a:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    3c9e:	81 e0       	ldi	r24, 0x01	; 1
    3ca0:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	portExCS(TRUE);
    3ca4:	81 e0       	ldi	r24, 0x01	; 1
    3ca6:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    3caa:	dd 23       	and	r29, r29
    3cac:	89 f0       	breq	.+34     	; 0x3cd0 <PortEx_DIRCLR+0x40>
    3cae:	80 91 7a 50 	lds	r24, 0x507A
    3cb2:	80 95       	com	r24
    3cb4:	c8 23       	and	r28, r24
    3cb6:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3cba:	80 e4       	ldi	r24, 0x40	; 64
    3cbc:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3cc0:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3cc4:	80 91 7a 50 	lds	r24, 0x507A
    3cc8:	80 95       	com	r24
    3cca:	80 93 67 50 	sts	0x5067, r24
    3cce:	11 c0       	rjmp	.+34     	; 0x3cf2 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    3cd0:	80 91 ce 50 	lds	r24, 0x50CE
    3cd4:	80 95       	com	r24
    3cd6:	c8 23       	and	r28, r24
    3cd8:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3cdc:	80 e4       	ldi	r24, 0x40	; 64
    3cde:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3ce2:	81 e0       	ldi	r24, 0x01	; 1
    3ce4:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3ce8:	80 91 ce 50 	lds	r24, 0x50CE
    3cec:	80 95       	com	r24
    3cee:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3cf2:	80 e0       	ldi	r24, 0x00	; 0
    3cf4:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3cf6:	25 e6       	ldi	r18, 0x65	; 101
    3cf8:	30 e5       	ldi	r19, 0x50	; 80
    3cfa:	a0 ec       	ldi	r26, 0xC0	; 192
    3cfc:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3cfe:	c1 e7       	ldi	r28, 0x71	; 113
    3d00:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3d02:	f9 01       	movw	r30, r18
    3d04:	e8 0f       	add	r30, r24
    3d06:	f9 1f       	adc	r31, r25
    3d08:	40 81       	ld	r20, Z
    3d0a:	13 96       	adiw	r26, 0x03	; 3
    3d0c:	4c 93       	st	X, r20
    3d0e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3d10:	12 96       	adiw	r26, 0x02	; 2
    3d12:	4c 91       	ld	r20, X
    3d14:	12 97       	sbiw	r26, 0x02	; 2
    3d16:	44 23       	and	r20, r20
    3d18:	dc f7       	brge	.-10     	; 0x3d10 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    3d1a:	13 96       	adiw	r26, 0x03	; 3
    3d1c:	4c 91       	ld	r20, X
    3d1e:	13 97       	sbiw	r26, 0x03	; 3
    3d20:	48 83       	st	Y, r20
    3d22:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3d24:	83 30       	cpi	r24, 0x03	; 3
    3d26:	91 05       	cpc	r25, r1
    3d28:	61 f7       	brne	.-40     	; 0x3d02 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3d2a:	80 e0       	ldi	r24, 0x00	; 0
    3d2c:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	portExCS(FALSE);
    3d30:	80 e0       	ldi	r24, 0x00	; 0
    3d32:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>
	SPIDisable();
    3d36:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
}
    3d3a:	df 91       	pop	r29
    3d3c:	cf 91       	pop	r28
    3d3e:	08 95       	ret

00003d40 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3d40:	cf 93       	push	r28
    3d42:	df 93       	push	r29
    3d44:	c8 2f       	mov	r28, r24
    3d46:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3d48:	80 e0       	ldi	r24, 0x00	; 0
    3d4a:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    3d4e:	81 e0       	ldi	r24, 0x01	; 1
    3d50:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	portExCS(TRUE);
    3d54:	81 e0       	ldi	r24, 0x01	; 1
    3d56:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    3d5a:	dd 23       	and	r29, r29
    3d5c:	81 f0       	breq	.+32     	; 0x3d7e <PortEx_DIRSET+0x3e>
    3d5e:	80 91 7a 50 	lds	r24, 0x507A
    3d62:	c8 2b       	or	r28, r24
    3d64:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3d68:	80 e4       	ldi	r24, 0x40	; 64
    3d6a:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3d6e:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3d72:	80 91 7a 50 	lds	r24, 0x507A
    3d76:	80 95       	com	r24
    3d78:	80 93 67 50 	sts	0x5067, r24
    3d7c:	10 c0       	rjmp	.+32     	; 0x3d9e <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    3d7e:	80 91 ce 50 	lds	r24, 0x50CE
    3d82:	c8 2b       	or	r28, r24
    3d84:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3d88:	80 e4       	ldi	r24, 0x40	; 64
    3d8a:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3d8e:	81 e0       	ldi	r24, 0x01	; 1
    3d90:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3d94:	80 91 ce 50 	lds	r24, 0x50CE
    3d98:	80 95       	com	r24
    3d9a:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3d9e:	80 e0       	ldi	r24, 0x00	; 0
    3da0:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3da2:	25 e6       	ldi	r18, 0x65	; 101
    3da4:	30 e5       	ldi	r19, 0x50	; 80
    3da6:	a0 ec       	ldi	r26, 0xC0	; 192
    3da8:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3daa:	c1 e7       	ldi	r28, 0x71	; 113
    3dac:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3dae:	f9 01       	movw	r30, r18
    3db0:	e8 0f       	add	r30, r24
    3db2:	f9 1f       	adc	r31, r25
    3db4:	40 81       	ld	r20, Z
    3db6:	13 96       	adiw	r26, 0x03	; 3
    3db8:	4c 93       	st	X, r20
    3dba:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    3dbc:	12 96       	adiw	r26, 0x02	; 2
    3dbe:	4c 91       	ld	r20, X
    3dc0:	12 97       	sbiw	r26, 0x02	; 2
    3dc2:	44 23       	and	r20, r20
    3dc4:	dc f7       	brge	.-10     	; 0x3dbc <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3dc6:	13 96       	adiw	r26, 0x03	; 3
    3dc8:	4c 91       	ld	r20, X
    3dca:	13 97       	sbiw	r26, 0x03	; 3
    3dcc:	48 83       	st	Y, r20
    3dce:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3dd0:	83 30       	cpi	r24, 0x03	; 3
    3dd2:	91 05       	cpc	r25, r1
    3dd4:	61 f7       	brne	.-40     	; 0x3dae <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    3dd6:	80 e0       	ldi	r24, 0x00	; 0
    3dd8:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <portExCS>
	SPICS(FALSE);
    3ddc:	80 e0       	ldi	r24, 0x00	; 0
    3dde:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    3de2:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>


}
    3de6:	df 91       	pop	r29
    3de8:	cf 91       	pop	r28
    3dea:	08 95       	ret

00003dec <readFRAM>:

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3dec:	0f 93       	push	r16
    3dee:	1f 93       	push	r17
    3df0:	cf 93       	push	r28
    3df2:	df 93       	push	r29
    3df4:	8c 01       	movw	r16, r24
	
	SPIInit(SPI_MODE_0_gc);
    3df6:	80 e0       	ldi	r24, 0x00	; 0
    3df8:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3dfc:	c0 ec       	ldi	r28, 0xC0	; 192
    3dfe:	d8 e0       	ldi	r29, 0x08	; 8
    3e00:	80 ed       	ldi	r24, 0xD0	; 208
    3e02:	88 83       	st	Y, r24
	SPICS(TRUE);
    3e04:	81 e0       	ldi	r24, 0x01	; 1
    3e06:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3e0a:	88 e0       	ldi	r24, 0x08	; 8
    3e0c:	e0 e2       	ldi	r30, 0x20	; 32
    3e0e:	f6 e0       	ldi	r31, 0x06	; 6
    3e10:	86 83       	std	Z+6, r24	; 0x06
	nop();
    3e12:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    3e14:	83 e0       	ldi	r24, 0x03	; 3
    3e16:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3e18:	e0 ec       	ldi	r30, 0xC0	; 192
    3e1a:	f8 e0       	ldi	r31, 0x08	; 8
    3e1c:	82 81       	ldd	r24, Z+2	; 0x02
    3e1e:	88 23       	and	r24, r24
    3e20:	ec f7       	brge	.-6      	; 0x3e1c <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    3e22:	e0 ec       	ldi	r30, 0xC0	; 192
    3e24:	f8 e0       	ldi	r31, 0x08	; 8
    3e26:	83 81       	ldd	r24, Z+3	; 0x03
    3e28:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    3e2c:	80 91 58 40 	lds	r24, 0x4058
    3e30:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3e32:	82 81       	ldd	r24, Z+2	; 0x02
    3e34:	88 23       	and	r24, r24
    3e36:	ec f7       	brge	.-6      	; 0x3e32 <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    3e38:	e0 ec       	ldi	r30, 0xC0	; 192
    3e3a:	f8 e0       	ldi	r31, 0x08	; 8
    3e3c:	83 81       	ldd	r24, Z+3	; 0x03
    3e3e:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    3e42:	80 91 57 40 	lds	r24, 0x4057
    3e46:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3e48:	82 81       	ldd	r24, Z+2	; 0x02
    3e4a:	88 23       	and	r24, r24
    3e4c:	ec f7       	brge	.-6      	; 0x3e48 <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3e4e:	e0 ec       	ldi	r30, 0xC0	; 192
    3e50:	f8 e0       	ldi	r31, 0x08	; 8
    3e52:	83 81       	ldd	r24, Z+3	; 0x03
    3e54:	80 93 71 50 	sts	0x5071, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3e58:	01 15       	cp	r16, r1
    3e5a:	11 05       	cpc	r17, r1
    3e5c:	b1 f0       	breq	.+44     	; 0x3e8a <readFRAM+0x9e>
    3e5e:	ef ed       	ldi	r30, 0xDF	; 223
    3e60:	f3 e2       	ldi	r31, 0x23	; 35

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3e62:	0e 0f       	add	r16, r30
    3e64:	1f 1f       	adc	r17, r31
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    3e66:	a0 ec       	ldi	r26, 0xC0	; 192
    3e68:	b8 e0       	ldi	r27, 0x08	; 8
    3e6a:	9a ea       	ldi	r25, 0xAA	; 170
    3e6c:	13 96       	adiw	r26, 0x03	; 3
    3e6e:	9c 93       	st	X, r25
    3e70:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3e72:	12 96       	adiw	r26, 0x02	; 2
    3e74:	8c 91       	ld	r24, X
    3e76:	12 97       	sbiw	r26, 0x02	; 2
    3e78:	88 23       	and	r24, r24
    3e7a:	dc f7       	brge	.-10     	; 0x3e72 <readFRAM+0x86>
		FRAMReadBuffer[i] = SPIC.DATA;
    3e7c:	13 96       	adiw	r26, 0x03	; 3
    3e7e:	8c 91       	ld	r24, X
    3e80:	13 97       	sbiw	r26, 0x03	; 3
    3e82:	81 93       	st	Z+, r24
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3e84:	e0 17       	cp	r30, r16
    3e86:	f1 07       	cpc	r31, r17
    3e88:	89 f7       	brne	.-30     	; 0x3e6c <readFRAM+0x80>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    3e8a:	88 e0       	ldi	r24, 0x08	; 8
    3e8c:	e0 e2       	ldi	r30, 0x20	; 32
    3e8e:	f6 e0       	ldi	r31, 0x06	; 6
    3e90:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    3e92:	80 e0       	ldi	r24, 0x00	; 0
    3e94:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    3e98:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>

}
    3e9c:	df 91       	pop	r29
    3e9e:	cf 91       	pop	r28
    3ea0:	1f 91       	pop	r17
    3ea2:	0f 91       	pop	r16
    3ea4:	08 95       	ret

00003ea6 <FRAMTest3Channel>:
//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3ea6:	81 e0       	ldi	r24, 0x01	; 1
    3ea8:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
    3eac:	8f ec       	ldi	r24, 0xCF	; 207
    3eae:	97 e0       	ldi	r25, 0x07	; 7
    3eb0:	01 97       	sbiw	r24, 0x01	; 1
    3eb2:	f1 f7       	brne	.-4      	; 0x3eb0 <FRAMTest3Channel+0xa>
    3eb4:	00 c0       	rjmp	.+0      	; 0x3eb6 <FRAMTest3Channel+0x10>
    3eb6:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3eb8:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <calcChecksumFRAM>

	ADCPower(FALSE);
    3ebc:	80 e0       	ldi	r24, 0x00	; 0
    3ebe:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	
}
    3ec2:	08 95       	ret

00003ec4 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3ec4:	81 e0       	ldi	r24, 0x01	; 1
    3ec6:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
    3eca:	8f ec       	ldi	r24, 0xCF	; 207
    3ecc:	97 e0       	ldi	r25, 0x07	; 7
    3ece:	01 97       	sbiw	r24, 0x01	; 1
    3ed0:	f1 f7       	brne	.-4      	; 0x3ece <FRAMTest1Channel+0xa>
    3ed2:	00 c0       	rjmp	.+0      	; 0x3ed4 <FRAMTest1Channel+0x10>
    3ed4:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3ed6:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <calcChecksumFRAM>

	ADCPower(FALSE);
    3eda:	80 e0       	ldi	r24, 0x00	; 0
    3edc:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>

}
    3ee0:	08 95       	ret

00003ee2 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
	
	FRAMWriteKnowns();
    3ee2:	0e 94 0c 11 	call	0x2218	; 0x2218 <FRAMWriteKnowns>
	ADCPower(TRUE);
    3ee6:	81 e0       	ldi	r24, 0x01	; 1
    3ee8:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
    3eec:	8f ec       	ldi	r24, 0xCF	; 207
    3eee:	97 e0       	ldi	r25, 0x07	; 7
    3ef0:	01 97       	sbiw	r24, 0x01	; 1
    3ef2:	f1 f7       	brne	.-4      	; 0x3ef0 <FRAMWriteKnownsCheck+0xe>
    3ef4:	00 c0       	rjmp	.+0      	; 0x3ef6 <FRAMWriteKnownsCheck+0x14>
    3ef6:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    3ef8:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <calcChecksumFRAM>

	ADCPower(FALSE);
    3efc:	80 e0       	ldi	r24, 0x00	; 0
    3efe:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>

}
    3f02:	08 95       	ret

00003f04 <checkMote>:

//random function for testing stuff	
void checkMote(){
	
	ADCPower(TRUE);
    3f04:	81 e0       	ldi	r24, 0x01	; 1
    3f06:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	Ext1Power(TRUE);
    3f0a:	81 e0       	ldi	r24, 0x01	; 1
    3f0c:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3f10:	8f ef       	ldi	r24, 0xFF	; 255
    3f12:	93 ec       	ldi	r25, 0xC3	; 195
    3f14:	a9 e0       	ldi	r26, 0x09	; 9
    3f16:	81 50       	subi	r24, 0x01	; 1
    3f18:	90 40       	sbci	r25, 0x00	; 0
    3f1a:	a0 40       	sbci	r26, 0x00	; 0
    3f1c:	e1 f7       	brne	.-8      	; 0x3f16 <checkMote+0x12>
    3f1e:	00 c0       	rjmp	.+0      	; 0x3f20 <checkMote+0x1c>
    3f20:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3f22:	88 e0       	ldi	r24, 0x08	; 8
    3f24:	60 e0       	ldi	r22, 0x00	; 0
    3f26:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3f2a:	88 e0       	ldi	r24, 0x08	; 8
    3f2c:	60 e0       	ldi	r22, 0x00	; 0
    3f2e:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
    3f32:	8a ea       	ldi	r24, 0xAA	; 170
    3f34:	96 ee       	ldi	r25, 0xE6	; 230
    3f36:	a6 e9       	ldi	r26, 0x96	; 150
    3f38:	b1 e0       	ldi	r27, 0x01	; 1
    3f3a:	81 50       	subi	r24, 0x01	; 1
    3f3c:	90 40       	sbci	r25, 0x00	; 0
    3f3e:	a0 40       	sbci	r26, 0x00	; 0
    3f40:	b0 40       	sbci	r27, 0x00	; 0
    3f42:	d9 f7       	brne	.-10     	; 0x3f3a <checkMote+0x36>
    3f44:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3f46:	88 e0       	ldi	r24, 0x08	; 8
    3f48:	60 e0       	ldi	r22, 0x00	; 0
    3f4a:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <PortEx_OUTCLR>
    3f4e:	8a ea       	ldi	r24, 0xAA	; 170
    3f50:	96 ee       	ldi	r25, 0xE6	; 230
    3f52:	a6 e9       	ldi	r26, 0x96	; 150
    3f54:	b1 e0       	ldi	r27, 0x01	; 1
    3f56:	81 50       	subi	r24, 0x01	; 1
    3f58:	90 40       	sbci	r25, 0x00	; 0
    3f5a:	a0 40       	sbci	r26, 0x00	; 0
    3f5c:	b0 40       	sbci	r27, 0x00	; 0
    3f5e:	d9 f7       	brne	.-10     	; 0x3f56 <checkMote+0x52>
    3f60:	00 00       	nop
    3f62:	e3 cf       	rjmp	.-58     	; 0x3f2a <checkMote+0x26>

00003f64 <SD_write_and_read_knowns>:
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3f64:	0f 93       	push	r16
    3f66:	1f 93       	push	r17
    3f68:	cf 93       	push	r28
    3f6a:	df 93       	push	r29
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3f6c:	0f ed       	ldi	r16, 0xDF	; 223
    3f6e:	13 e2       	ldi	r17, 0x23	; 35
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3f70:	f8 01       	movw	r30, r16
    3f72:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3f74:	81 93       	st	Z+, r24
    3f76:	8f 5f       	subi	r24, 0xFF	; 255
    3f78:	88 31       	cpi	r24, 0x18	; 24
    3f7a:	e1 f7       	brne	.-8      	; 0x3f74 <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    3f7c:	cf ed       	ldi	r28, 0xDF	; 223
    3f7e:	d3 e2       	ldi	r29, 0x23	; 35
    3f80:	64 e1       	ldi	r22, 0x14	; 20
    3f82:	70 e0       	ldi	r23, 0x00	; 0
    3f84:	80 e0       	ldi	r24, 0x00	; 0
    3f86:	90 e0       	ldi	r25, 0x00	; 0
    3f88:	ae 01       	movw	r20, r28
    3f8a:	28 e1       	ldi	r18, 0x18	; 24
    3f8c:	30 e0       	ldi	r19, 0x00	; 0
    3f8e:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <SD_write_block>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3f92:	68 96       	adiw	r28, 0x18	; 24
    3f94:	f8 01       	movw	r30, r16
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    3f96:	11 92       	st	Z+, r1
    3f98:	ec 17       	cp	r30, r28
    3f9a:	fd 07       	cpc	r31, r29
    3f9c:	e1 f7       	brne	.-8      	; 0x3f96 <SD_write_and_read_knowns+0x32>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    3f9e:	64 e1       	ldi	r22, 0x14	; 20
    3fa0:	70 e0       	ldi	r23, 0x00	; 0
    3fa2:	80 e0       	ldi	r24, 0x00	; 0
    3fa4:	90 e0       	ldi	r25, 0x00	; 0
    3fa6:	4f ed       	ldi	r20, 0xDF	; 223
    3fa8:	53 e2       	ldi	r21, 0x23	; 35
    3faa:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
    3fae:	f8 01       	movw	r30, r16
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3fb0:	20 e0       	ldi	r18, 0x00	; 0
    3fb2:	30 e0       	ldi	r19, 0x00	; 0
    3fb4:	c4 e6       	ldi	r28, 0x64	; 100
    3fb6:	d0 e0       	ldi	r29, 0x00	; 0
    3fb8:	c9 01       	movw	r24, r18
    3fba:	be 01       	movw	r22, r28
    3fbc:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    3fc0:	81 93       	st	Z+, r24
    3fc2:	2f 5f       	subi	r18, 0xFF	; 255
    3fc4:	3f 4f       	sbci	r19, 0xFF	; 255
    3fc6:	84 e0       	ldi	r24, 0x04	; 4
    3fc8:	22 3e       	cpi	r18, 0xE2	; 226
    3fca:	38 07       	cpc	r19, r24
    3fcc:	a9 f7       	brne	.-22     	; 0x3fb8 <SD_write_and_read_knowns+0x54>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    3fce:	60 e5       	ldi	r22, 0x50	; 80
    3fd0:	70 e0       	ldi	r23, 0x00	; 0
    3fd2:	80 e0       	ldi	r24, 0x00	; 0
    3fd4:	90 e0       	ldi	r25, 0x00	; 0
    3fd6:	4f ed       	ldi	r20, 0xDF	; 223
    3fd8:	53 e2       	ldi	r21, 0x23	; 35
    3fda:	22 ee       	ldi	r18, 0xE2	; 226
    3fdc:	34 e0       	ldi	r19, 0x04	; 4
    3fde:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <SD_write_multiple_blocks>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3fe2:	81 ec       	ldi	r24, 0xC1	; 193
    3fe4:	98 e2       	ldi	r25, 0x28	; 40
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    3fe6:	f8 01       	movw	r30, r16
    3fe8:	11 92       	st	Z+, r1
    3fea:	8f 01       	movw	r16, r30
    3fec:	e8 17       	cp	r30, r24
    3fee:	f9 07       	cpc	r31, r25
    3ff0:	d1 f7       	brne	.-12     	; 0x3fe6 <SD_write_and_read_knowns+0x82>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    3ff2:	60 e5       	ldi	r22, 0x50	; 80
    3ff4:	70 e0       	ldi	r23, 0x00	; 0
    3ff6:	80 e0       	ldi	r24, 0x00	; 0
    3ff8:	90 e0       	ldi	r25, 0x00	; 0
    3ffa:	4f ed       	ldi	r20, 0xDF	; 223
    3ffc:	53 e2       	ldi	r21, 0x23	; 35
    3ffe:	23 e0       	ldi	r18, 0x03	; 3
    4000:	30 e0       	ldi	r19, 0x00	; 0
    4002:	0e 94 56 2e 	call	0x5cac	; 0x5cac <SD_read_multiple_blocks>
}
    4006:	df 91       	pop	r29
    4008:	cf 91       	pop	r28
    400a:	1f 91       	pop	r17
    400c:	0f 91       	pop	r16
    400e:	08 95       	ret

00004010 <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    4010:	0f 93       	push	r16
    4012:	1f 93       	push	r17
    4014:	cf 93       	push	r28
    4016:	df 93       	push	r29
    4018:	0f ed       	ldi	r16, 0xDF	; 223
    401a:	13 e2       	ldi	r17, 0x23	; 35
    401c:	f8 01       	movw	r30, r16
    401e:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    4020:	81 93       	st	Z+, r24
    4022:	8f 5f       	subi	r24, 0xFF	; 255
    4024:	88 31       	cpi	r24, 0x18	; 24
    4026:	e1 f7       	brne	.-8      	; 0x4020 <SD_write_and_read_knowns_FAT+0x10>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    4028:	cf ed       	ldi	r28, 0xDF	; 223
    402a:	d3 e2       	ldi	r29, 0x23	; 35
    402c:	86 e1       	ldi	r24, 0x16	; 22
    402e:	90 e2       	ldi	r25, 0x20	; 32
    4030:	be 01       	movw	r22, r28
    4032:	20 e0       	ldi	r18, 0x00	; 0
    4034:	32 e0       	ldi	r19, 0x02	; 2
    4036:	40 e0       	ldi	r20, 0x00	; 0
    4038:	50 e0       	ldi	r21, 0x00	; 0
    403a:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <writeFile>
    403e:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
}

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    4042:	68 96       	adiw	r28, 0x18	; 24
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    4044:	f8 01       	movw	r30, r16
    4046:	11 92       	st	Z+, r1
    4048:	8f 01       	movw	r16, r30
    404a:	ec 17       	cp	r30, r28
    404c:	fd 07       	cpc	r31, r29
    404e:	d1 f7       	brne	.-12     	; 0x4044 <SD_write_and_read_knowns_FAT+0x34>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    4050:	80 e0       	ldi	r24, 0x00	; 0
    4052:	66 e1       	ldi	r22, 0x16	; 22
    4054:	70 e2       	ldi	r23, 0x20	; 32
    4056:	0e 94 51 27 	call	0x4ea2	; 0x4ea2 <readFile>
    405a:	80 93 a3 50 	sts	0x50A3, r24
}
    405e:	df 91       	pop	r29
    4060:	cf 91       	pop	r28
    4062:	1f 91       	pop	r17
    4064:	0f 91       	pop	r16
    4066:	08 95       	ret

00004068 <chibi_test_radio>:


//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    4068:	0e 94 00 16 	call	0x2c00	; 0x2c00 <chb_init>
	chb_set_short_addr(0x0002);
    406c:	82 e0       	ldi	r24, 0x02	; 2
    406e:	90 e0       	ldi	r25, 0x00	; 0
    4070:	0e 94 37 18 	call	0x306e	; 0x306e <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    4074:	00 00       	nop
    4076:	fe cf       	rjmp	.-4      	; 0x4074 <chibi_test_radio+0xc>

00004078 <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    4078:	cf 93       	push	r28
    407a:	df 93       	push	r29
	
	SD_init();
    407c:	0e 94 06 2b 	call	0x560c	; 0x560c <SD_init>
	getBootSectorData();
    4080:	0e 94 e6 22 	call	0x45cc	; 0x45cc <getBootSectorData>
    4084:	ef ed       	ldi	r30, 0xDF	; 223
    4086:	f3 e2       	ldi	r31, 0x23	; 35
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    4088:	20 e0       	ldi	r18, 0x00	; 0
    408a:	30 e0       	ldi	r19, 0x00	; 0
    408c:	c9 e7       	ldi	r28, 0x79	; 121
    408e:	d0 e0       	ldi	r29, 0x00	; 0
    4090:	c9 01       	movw	r24, r18
    4092:	be 01       	movw	r22, r28
    4094:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    4098:	81 93       	st	Z+, r24
    409a:	2f 5f       	subi	r18, 0xFF	; 255
    409c:	3f 4f       	sbci	r19, 0xFF	; 255
    409e:	82 e0       	ldi	r24, 0x02	; 2
    40a0:	20 30       	cpi	r18, 0x00	; 0
    40a2:	38 07       	cpc	r19, r24
    40a4:	a9 f7       	brne	.-22     	; 0x4090 <TestCard+0x18>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    40a6:	86 e1       	ldi	r24, 0x16	; 22
    40a8:	90 e2       	ldi	r25, 0x20	; 32
    40aa:	6f ed       	ldi	r22, 0xDF	; 223
    40ac:	73 e2       	ldi	r23, 0x23	; 35
    40ae:	20 e0       	ldi	r18, 0x00	; 0
    40b0:	32 e0       	ldi	r19, 0x02	; 2
    40b2:	40 e0       	ldi	r20, 0x00	; 0
    40b4:	50 e0       	ldi	r21, 0x00	; 0
    40b6:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <writeFile>
	nop();
    40ba:	00 00       	nop
}
    40bc:	df 91       	pop	r29
    40be:	cf 91       	pop	r28
    40c0:	08 95       	ret

000040c2 <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    40c2:	1f 92       	push	r1
    40c4:	0f 92       	push	r0
    40c6:	0f b6       	in	r0, 0x3f	; 63
    40c8:	0f 92       	push	r0
    40ca:	0b b6       	in	r0, 0x3b	; 59
    40cc:	0f 92       	push	r0
    40ce:	11 24       	eor	r1, r1
    40d0:	2f 93       	push	r18
    40d2:	3f 93       	push	r19
    40d4:	4f 93       	push	r20
    40d6:	5f 93       	push	r21
    40d8:	6f 93       	push	r22
    40da:	7f 93       	push	r23
    40dc:	8f 93       	push	r24
    40de:	9f 93       	push	r25
    40e0:	af 93       	push	r26
    40e2:	bf 93       	push	r27
    40e4:	ef 93       	push	r30
    40e6:	ff 93       	push	r31
	
	chb_rx_data_t* msg = NULL;
	switch (RadioMonitorMode) {
    40e8:	80 91 5e 40 	lds	r24, 0x405E
    40ec:	81 30       	cpi	r24, 0x01	; 1
    40ee:	21 f0       	breq	.+8      	; 0x40f8 <__vector_43+0x36>
    40f0:	82 30       	cpi	r24, 0x02	; 2
    40f2:	09 f0       	breq	.+2      	; 0x40f6 <__vector_43+0x34>
    40f4:	72 c0       	rjmp	.+228    	; 0x41da <__vector_43+0x118>
    40f6:	55 c0       	rjmp	.+170    	; 0x41a2 <__vector_43+0xe0>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    40f8:	80 e0       	ldi	r24, 0x00	; 0
    40fa:	90 e0       	ldi	r25, 0x00	; 0
    40fc:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    4100:	85 e0       	ldi	r24, 0x05	; 5
    4102:	90 e0       	ldi	r25, 0x00	; 0
    4104:	6e e1       	ldi	r22, 0x1E	; 30
    4106:	70 e2       	ldi	r23, 0x20	; 32
    4108:	45 e0       	ldi	r20, 0x05	; 5
    410a:	50 e0       	ldi	r21, 0x00	; 0
    410c:	0e 94 13 3b 	call	0x7626	; 0x7626 <strncmp>
    4110:	28 2f       	mov	r18, r24
    4112:	39 2f       	mov	r19, r25
    4114:	21 15       	cp	r18, r1
    4116:	31 05       	cpc	r19, r1
    4118:	51 f4       	brne	.+20     	; 0x412e <__vector_43+0x6c>
				MotesReadyToSynch++;
    411a:	80 91 78 50 	lds	r24, 0x5078
    411e:	90 91 79 50 	lds	r25, 0x5079
    4122:	01 96       	adiw	r24, 0x01	; 1
    4124:	80 93 78 50 	sts	0x5078, r24
    4128:	90 93 79 50 	sts	0x5079, r25
    412c:	56 c0       	rjmp	.+172    	; 0x41da <__vector_43+0x118>
    412e:	e5 e0       	ldi	r30, 0x05	; 5
    4130:	f0 e0       	ldi	r31, 0x00	; 0
    4132:	af ed       	ldi	r26, 0xDF	; 223
    4134:	b3 e2       	ldi	r27, 0x23	; 35
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    4136:	81 91       	ld	r24, Z+
    4138:	8d 93       	st	X+, r24
    413a:	e5 38       	cpi	r30, 0x85	; 133
    413c:	f1 05       	cpc	r31, r1
    413e:	d9 f7       	brne	.-10     	; 0x4136 <__vector_43+0x74>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    4140:	80 91 c2 50 	lds	r24, 0x50C2
    4144:	90 91 c3 50 	lds	r25, 0x50C3
    4148:	a0 91 c4 50 	lds	r26, 0x50C4
    414c:	b0 91 c5 50 	lds	r27, 0x50C5
    4150:	80 58       	subi	r24, 0x80	; 128
    4152:	9f 4f       	sbci	r25, 0xFF	; 255
    4154:	af 4f       	sbci	r26, 0xFF	; 255
    4156:	bf 4f       	sbci	r27, 0xFF	; 255
    4158:	80 93 c2 50 	sts	0x50C2, r24
    415c:	90 93 c3 50 	sts	0x50C3, r25
    4160:	a0 93 c4 50 	sts	0x50C4, r26
    4164:	b0 93 c5 50 	sts	0x50C5, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    4168:	80 91 c2 50 	lds	r24, 0x50C2
    416c:	90 91 c3 50 	lds	r25, 0x50C3
    4170:	a0 91 c4 50 	lds	r26, 0x50C4
    4174:	b0 91 c5 50 	lds	r27, 0x50C5
    4178:	80 58       	subi	r24, 0x80	; 128
    417a:	9f 4f       	sbci	r25, 0xFF	; 255
    417c:	af 4f       	sbci	r26, 0xFF	; 255
    417e:	bf 4f       	sbci	r27, 0xFF	; 255
    4180:	81 37       	cpi	r24, 0x71	; 113
    4182:	2c e1       	ldi	r18, 0x1C	; 28
    4184:	92 07       	cpc	r25, r18
    4186:	20 e0       	ldi	r18, 0x00	; 0
    4188:	a2 07       	cpc	r26, r18
    418a:	20 e0       	ldi	r18, 0x00	; 0
    418c:	b2 07       	cpc	r27, r18
    418e:	28 f1       	brcs	.+74     	; 0x41da <__vector_43+0x118>
    4190:	10 92 c2 50 	sts	0x50C2, r1
    4194:	10 92 c3 50 	sts	0x50C3, r1
    4198:	10 92 c4 50 	sts	0x50C4, r1
    419c:	10 92 c5 50 	sts	0x50C5, r1
    41a0:	1c c0       	rjmp	.+56     	; 0x41da <__vector_43+0x118>
			}			
			break;
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    41a2:	80 e0       	ldi	r24, 0x00	; 0
    41a4:	90 e0       	ldi	r25, 0x00	; 0
    41a6:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    41aa:	85 e0       	ldi	r24, 0x05	; 5
    41ac:	90 e0       	ldi	r25, 0x00	; 0
    41ae:	64 e2       	ldi	r22, 0x24	; 36
    41b0:	70 e2       	ldi	r23, 0x20	; 32
    41b2:	4e e0       	ldi	r20, 0x0E	; 14
    41b4:	50 e0       	ldi	r21, 0x00	; 0
    41b6:	0e 94 13 3b 	call	0x7626	; 0x7626 <strncmp>
    41ba:	28 2f       	mov	r18, r24
    41bc:	39 2f       	mov	r19, r25
    41be:	21 15       	cp	r18, r1
    41c0:	31 05       	cpc	r19, r1
    41c2:	59 f4       	brne	.+22     	; 0x41da <__vector_43+0x118>
				RadioMonitorMode = SYNCHED;
    41c4:	83 e0       	ldi	r24, 0x03	; 3
    41c6:	80 93 5e 40 	sts	0x405E, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    41ca:	89 e0       	ldi	r24, 0x09	; 9
    41cc:	80 93 40 09 	sts	0x0940, r24
				TCC1.CTRLA = 0x01;  
    41d0:	81 e0       	ldi	r24, 0x01	; 1
    41d2:	80 93 40 08 	sts	0x0840, r24
				ADC_Resume_Sampling();	//resume sampling with the adc
    41d6:	0e 94 8b 07 	call	0xf16	; 0xf16 <ADC_Resume_Sampling>
			}
			break;
		default:
			break;
	}
}
    41da:	ff 91       	pop	r31
    41dc:	ef 91       	pop	r30
    41de:	bf 91       	pop	r27
    41e0:	af 91       	pop	r26
    41e2:	9f 91       	pop	r25
    41e4:	8f 91       	pop	r24
    41e6:	7f 91       	pop	r23
    41e8:	6f 91       	pop	r22
    41ea:	5f 91       	pop	r21
    41ec:	4f 91       	pop	r20
    41ee:	3f 91       	pop	r19
    41f0:	2f 91       	pop	r18
    41f2:	0f 90       	pop	r0
    41f4:	0b be       	out	0x3b, r0	; 59
    41f6:	0f 90       	pop	r0
    41f8:	0f be       	out	0x3f, r0	; 63
    41fa:	0f 90       	pop	r0
    41fc:	1f 90       	pop	r1
    41fe:	18 95       	reti

00004200 <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    4200:	2f 92       	push	r2
    4202:	3f 92       	push	r3
    4204:	4f 92       	push	r4
    4206:	5f 92       	push	r5
    4208:	6f 92       	push	r6
    420a:	7f 92       	push	r7
    420c:	8f 92       	push	r8
    420e:	9f 92       	push	r9
    4210:	af 92       	push	r10
    4212:	bf 92       	push	r11
    4214:	cf 92       	push	r12
    4216:	df 92       	push	r13
    4218:	ef 92       	push	r14
    421a:	ff 92       	push	r15
    421c:	0f 93       	push	r16
    421e:	1f 93       	push	r17
    4220:	cf 93       	push	r28
    4222:	df 93       	push	r29
    4224:	cd b7       	in	r28, 0x3d	; 61
    4226:	de b7       	in	r29, 0x3e	; 62
    4228:	64 97       	sbiw	r28, 0x14	; 20
    422a:	cd bf       	out	0x3d, r28	; 61
    422c:	de bf       	out	0x3e, r29	; 62
    422e:	2a 01       	movw	r4, r20
    4230:	3b 01       	movw	r6, r22
    4232:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    4234:	f9 01       	movw	r30, r18
    4236:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    4238:	41 15       	cp	r20, r1
    423a:	51 05       	cpc	r21, r1
    423c:	61 05       	cpc	r22, r1
    423e:	71 05       	cpc	r23, r1
    4240:	09 f4       	brne	.+2      	; 0x4244 <DeciToString+0x44>
    4242:	4d c0       	rjmp	.+154    	; 0x42de <DeciToString+0xde>
    4244:	88 2e       	mov	r8, r24
    4246:	99 2e       	mov	r9, r25
    4248:	cc 24       	eor	r12, r12
    424a:	dd 24       	eor	r13, r13
    424c:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    424e:	5e 01       	movw	r10, r28
    4250:	08 94       	sec
    4252:	a1 1c       	adc	r10, r1
    4254:	b1 1c       	adc	r11, r1
    4256:	0f 2e       	mov	r0, r31
    4258:	f3 e3       	ldi	r31, 0x33	; 51
    425a:	2f 2e       	mov	r2, r31
    425c:	f0 e2       	ldi	r31, 0x20	; 32
    425e:	3f 2e       	mov	r3, r31
    4260:	f0 2d       	mov	r31, r0
    4262:	f4 01       	movw	r30, r8
    4264:	81 91       	ld	r24, Z+
    4266:	91 91       	ld	r25, Z+
    4268:	a1 91       	ld	r26, Z+
    426a:	b1 91       	ld	r27, Z+
    426c:	4f 01       	movw	r8, r30
    426e:	2d b7       	in	r18, 0x3d	; 61
    4270:	3e b7       	in	r19, 0x3e	; 62
    4272:	28 50       	subi	r18, 0x08	; 8
    4274:	30 40       	sbci	r19, 0x00	; 0
    4276:	2d bf       	out	0x3d, r18	; 61
    4278:	3e bf       	out	0x3e, r19	; 62
    427a:	2f 5f       	subi	r18, 0xFF	; 255
    427c:	3f 4f       	sbci	r19, 0xFF	; 255
    427e:	ed b7       	in	r30, 0x3d	; 61
    4280:	fe b7       	in	r31, 0x3e	; 62
    4282:	a1 82       	std	Z+1, r10	; 0x01
    4284:	b2 82       	std	Z+2, r11	; 0x02
    4286:	f9 01       	movw	r30, r18
    4288:	22 82       	std	Z+2, r2	; 0x02
    428a:	33 82       	std	Z+3, r3	; 0x03
    428c:	84 83       	std	Z+4, r24	; 0x04
    428e:	95 83       	std	Z+5, r25	; 0x05
    4290:	a6 83       	std	Z+6, r26	; 0x06
    4292:	b7 83       	std	Z+7, r27	; 0x07
    4294:	0e 94 54 3b 	call	0x76a8	; 0x76a8 <sprintf>
		strcat(ReturnString,b);
    4298:	2d b7       	in	r18, 0x3d	; 61
    429a:	3e b7       	in	r19, 0x3e	; 62
    429c:	28 5f       	subi	r18, 0xF8	; 248
    429e:	3f 4f       	sbci	r19, 0xFF	; 255
    42a0:	2d bf       	out	0x3d, r18	; 61
    42a2:	3e bf       	out	0x3e, r19	; 62
    42a4:	c8 01       	movw	r24, r16
    42a6:	b5 01       	movw	r22, r10
    42a8:	0e 94 08 3b 	call	0x7610	; 0x7610 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    42ac:	a0 2f       	mov	r26, r16
    42ae:	b1 2f       	mov	r27, r17
    42b0:	fd 01       	movw	r30, r26
    42b2:	01 90       	ld	r0, Z+
    42b4:	00 20       	and	r0, r0
    42b6:	e9 f7       	brne	.-6      	; 0x42b2 <DeciToString+0xb2>
    42b8:	31 97       	sbiw	r30, 0x01	; 1
    42ba:	ea 1b       	sub	r30, r26
    42bc:	fb 0b       	sbc	r31, r27
    42be:	e0 0f       	add	r30, r16
    42c0:	f1 1f       	adc	r31, r17
    42c2:	8a e0       	ldi	r24, 0x0A	; 10
    42c4:	90 e0       	ldi	r25, 0x00	; 0
    42c6:	80 83       	st	Z, r24
    42c8:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    42ca:	08 94       	sec
    42cc:	c1 1c       	adc	r12, r1
    42ce:	d1 1c       	adc	r13, r1
    42d0:	e1 1c       	adc	r14, r1
    42d2:	f1 1c       	adc	r15, r1
    42d4:	c4 14       	cp	r12, r4
    42d6:	d5 04       	cpc	r13, r5
    42d8:	e6 04       	cpc	r14, r6
    42da:	f7 04       	cpc	r15, r7
    42dc:	11 f6       	brne	.-124    	; 0x4262 <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    42de:	64 96       	adiw	r28, 0x14	; 20
    42e0:	cd bf       	out	0x3d, r28	; 61
    42e2:	de bf       	out	0x3e, r29	; 62
    42e4:	df 91       	pop	r29
    42e6:	cf 91       	pop	r28
    42e8:	1f 91       	pop	r17
    42ea:	0f 91       	pop	r16
    42ec:	ff 90       	pop	r15
    42ee:	ef 90       	pop	r14
    42f0:	df 90       	pop	r13
    42f2:	cf 90       	pop	r12
    42f4:	bf 90       	pop	r11
    42f6:	af 90       	pop	r10
    42f8:	9f 90       	pop	r9
    42fa:	8f 90       	pop	r8
    42fc:	7f 90       	pop	r7
    42fe:	6f 90       	pop	r6
    4300:	5f 90       	pop	r5
    4302:	4f 90       	pop	r4
    4304:	3f 90       	pop	r3
    4306:	2f 90       	pop	r2
    4308:	08 95       	ret

0000430a <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    430a:	cf 92       	push	r12
    430c:	df 92       	push	r13
    430e:	ef 92       	push	r14
    4310:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    4312:	20 91 7b 50 	lds	r18, 0x507B
    4316:	30 91 7c 50 	lds	r19, 0x507C
    431a:	c0 90 db 23 	lds	r12, 0x23DB
    431e:	d0 90 dc 23 	lds	r13, 0x23DC
    4322:	e0 90 dd 23 	lds	r14, 0x23DD
    4326:	f0 90 de 23 	lds	r15, 0x23DE
    432a:	62 50       	subi	r22, 0x02	; 2
    432c:	70 40       	sbci	r23, 0x00	; 0
    432e:	80 40       	sbci	r24, 0x00	; 0
    4330:	90 40       	sbci	r25, 0x00	; 0
    4332:	40 e0       	ldi	r20, 0x00	; 0
    4334:	50 e0       	ldi	r21, 0x00	; 0
    4336:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    433a:	dc 01       	movw	r26, r24
    433c:	cb 01       	movw	r24, r22
    433e:	c8 0e       	add	r12, r24
    4340:	d9 1e       	adc	r13, r25
    4342:	ea 1e       	adc	r14, r26
    4344:	fb 1e       	adc	r15, r27
}
    4346:	6c 2d       	mov	r22, r12
    4348:	7d 2d       	mov	r23, r13
    434a:	8e 2d       	mov	r24, r14
    434c:	9f 2d       	mov	r25, r15
    434e:	ff 90       	pop	r15
    4350:	ef 90       	pop	r14
    4352:	df 90       	pop	r13
    4354:	cf 90       	pop	r12
    4356:	08 95       	ret

00004358 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    4358:	3f 92       	push	r3
    435a:	4f 92       	push	r4
    435c:	5f 92       	push	r5
    435e:	6f 92       	push	r6
    4360:	7f 92       	push	r7
    4362:	8f 92       	push	r8
    4364:	9f 92       	push	r9
    4366:	af 92       	push	r10
    4368:	bf 92       	push	r11
    436a:	cf 92       	push	r12
    436c:	df 92       	push	r13
    436e:	ef 92       	push	r14
    4370:	ff 92       	push	r15
    4372:	0f 93       	push	r16
    4374:	1f 93       	push	r17
    4376:	cf 93       	push	r28
    4378:	df 93       	push	r29
    437a:	00 d0       	rcall	.+0      	; 0x437c <getSetNextCluster+0x24>
    437c:	0f 92       	push	r0
    437e:	cd b7       	in	r28, 0x3d	; 61
    4380:	de b7       	in	r29, 0x3e	; 62
    4382:	dc 01       	movw	r26, r24
    4384:	cb 01       	movw	r24, r22
    4386:	34 2e       	mov	r3, r20
    4388:	09 83       	std	Y+1, r16	; 0x01
    438a:	1a 83       	std	Y+2, r17	; 0x02
    438c:	2b 83       	std	Y+3, r18	; 0x03
    438e:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    4390:	80 90 83 50 	lds	r8, 0x5083
    4394:	90 90 84 50 	lds	r9, 0x5084
    4398:	2c 01       	movw	r4, r24
    439a:	3d 01       	movw	r6, r26
    439c:	44 0c       	add	r4, r4
    439e:	55 1c       	adc	r5, r5
    43a0:	66 1c       	adc	r6, r6
    43a2:	77 1c       	adc	r7, r7
    43a4:	44 0c       	add	r4, r4
    43a6:	55 1c       	adc	r5, r5
    43a8:	66 1c       	adc	r6, r6
    43aa:	77 1c       	adc	r7, r7
    43ac:	20 91 54 40 	lds	r18, 0x4054
    43b0:	30 91 55 40 	lds	r19, 0x4055
    43b4:	aa 24       	eor	r10, r10
    43b6:	bb 24       	eor	r11, r11
    43b8:	80 91 7d 50 	lds	r24, 0x507D
    43bc:	90 91 7e 50 	lds	r25, 0x507E
    43c0:	a0 91 7f 50 	lds	r26, 0x507F
    43c4:	b0 91 80 50 	lds	r27, 0x5080
    43c8:	88 0e       	add	r8, r24
    43ca:	99 1e       	adc	r9, r25
    43cc:	aa 1e       	adc	r10, r26
    43ce:	bb 1e       	adc	r11, r27
    43d0:	40 e0       	ldi	r20, 0x00	; 0
    43d2:	50 e0       	ldi	r21, 0x00	; 0
    43d4:	c3 01       	movw	r24, r6
    43d6:	b2 01       	movw	r22, r4
    43d8:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    43dc:	69 01       	movw	r12, r18
    43de:	7a 01       	movw	r14, r20
    43e0:	c8 0c       	add	r12, r8
    43e2:	d9 1c       	adc	r13, r9
    43e4:	ea 1c       	adc	r14, r10
    43e6:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    43e8:	00 91 54 40 	lds	r16, 0x4054
    43ec:	10 91 55 40 	lds	r17, 0x4055

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    43f0:	c7 01       	movw	r24, r14
    43f2:	b6 01       	movw	r22, r12
    43f4:	46 ed       	ldi	r20, 0xD6	; 214
    43f6:	51 e2       	ldi	r21, 0x21	; 33
    43f8:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    43fc:	98 01       	movw	r18, r16
    43fe:	40 e0       	ldi	r20, 0x00	; 0
    4400:	50 e0       	ldi	r21, 0x00	; 0
    4402:	c3 01       	movw	r24, r6
    4404:	b2 01       	movw	r22, r4
    4406:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    440a:	6a 52       	subi	r22, 0x2A	; 42
    440c:	7e 4d       	sbci	r23, 0xDE	; 222

if(get_set == GET)
    440e:	33 20       	and	r3, r3
    4410:	41 f4       	brne	.+16     	; 0x4422 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    4412:	db 01       	movw	r26, r22
    4414:	0d 91       	ld	r16, X+
    4416:	1d 91       	ld	r17, X+
    4418:	2d 91       	ld	r18, X+
    441a:	3c 91       	ld	r19, X
    441c:	13 97       	sbiw	r26, 0x03	; 3
    441e:	3f 70       	andi	r19, 0x0F	; 15
    4420:	14 c0       	rjmp	.+40     	; 0x444a <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4422:	89 81       	ldd	r24, Y+1	; 0x01
    4424:	9a 81       	ldd	r25, Y+2	; 0x02
    4426:	ab 81       	ldd	r26, Y+3	; 0x03
    4428:	bc 81       	ldd	r27, Y+4	; 0x04
    442a:	fb 01       	movw	r30, r22
    442c:	80 83       	st	Z, r24
    442e:	91 83       	std	Z+1, r25	; 0x01
    4430:	a2 83       	std	Z+2, r26	; 0x02
    4432:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    4434:	c7 01       	movw	r24, r14
    4436:	b6 01       	movw	r22, r12
    4438:	46 ed       	ldi	r20, 0xD6	; 214
    443a:	51 e2       	ldi	r21, 0x21	; 33
    443c:	20 e0       	ldi	r18, 0x00	; 0
    443e:	32 e0       	ldi	r19, 0x02	; 2
    4440:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <SD_write_block>

return (0);
    4444:	00 e0       	ldi	r16, 0x00	; 0
    4446:	10 e0       	ldi	r17, 0x00	; 0
    4448:	98 01       	movw	r18, r16
}
    444a:	60 2f       	mov	r22, r16
    444c:	71 2f       	mov	r23, r17
    444e:	82 2f       	mov	r24, r18
    4450:	93 2f       	mov	r25, r19
    4452:	24 96       	adiw	r28, 0x04	; 4
    4454:	cd bf       	out	0x3d, r28	; 61
    4456:	de bf       	out	0x3e, r29	; 62
    4458:	df 91       	pop	r29
    445a:	cf 91       	pop	r28
    445c:	1f 91       	pop	r17
    445e:	0f 91       	pop	r16
    4460:	ff 90       	pop	r15
    4462:	ef 90       	pop	r14
    4464:	df 90       	pop	r13
    4466:	cf 90       	pop	r12
    4468:	bf 90       	pop	r11
    446a:	af 90       	pop	r10
    446c:	9f 90       	pop	r9
    446e:	8f 90       	pop	r8
    4470:	7f 90       	pop	r7
    4472:	6f 90       	pop	r6
    4474:	5f 90       	pop	r5
    4476:	4f 90       	pop	r4
    4478:	3f 90       	pop	r3
    447a:	08 95       	ret

0000447c <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    447c:	cf 92       	push	r12
    447e:	df 92       	push	r13
    4480:	ef 92       	push	r14
    4482:	ff 92       	push	r15
    4484:	0f 93       	push	r16
    4486:	1f 93       	push	r17
    4488:	cf 93       	push	r28
    448a:	c8 2f       	mov	r28, r24
    448c:	06 2f       	mov	r16, r22
    448e:	69 01       	movw	r12, r18
    4490:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4492:	80 91 7d 50 	lds	r24, 0x507D
    4496:	90 91 7e 50 	lds	r25, 0x507E
    449a:	a0 91 7f 50 	lds	r26, 0x507F
    449e:	b0 91 80 50 	lds	r27, 0x5080
    44a2:	bc 01       	movw	r22, r24
    44a4:	cd 01       	movw	r24, r26
    44a6:	6f 5f       	subi	r22, 0xFF	; 255
    44a8:	7f 4f       	sbci	r23, 0xFF	; 255
    44aa:	8f 4f       	sbci	r24, 0xFF	; 255
    44ac:	9f 4f       	sbci	r25, 0xFF	; 255
    44ae:	46 ed       	ldi	r20, 0xD6	; 214
    44b0:	51 e2       	ldi	r21, 0x21	; 33
    44b2:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    44b6:	80 91 d6 21 	lds	r24, 0x21D6
    44ba:	90 91 d7 21 	lds	r25, 0x21D7
    44be:	a0 91 d8 21 	lds	r26, 0x21D8
    44c2:	b0 91 d9 21 	lds	r27, 0x21D9
    44c6:	82 35       	cpi	r24, 0x52	; 82
    44c8:	22 e5       	ldi	r18, 0x52	; 82
    44ca:	92 07       	cpc	r25, r18
    44cc:	21 e6       	ldi	r18, 0x61	; 97
    44ce:	a2 07       	cpc	r26, r18
    44d0:	21 e4       	ldi	r18, 0x41	; 65
    44d2:	b2 07       	cpc	r27, r18
    44d4:	09 f0       	breq	.+2      	; 0x44d8 <getSetFreeCluster+0x5c>
    44d6:	63 c0       	rjmp	.+198    	; 0x459e <getSetFreeCluster+0x122>
    44d8:	80 91 ba 23 	lds	r24, 0x23BA
    44dc:	90 91 bb 23 	lds	r25, 0x23BB
    44e0:	a0 91 bc 23 	lds	r26, 0x23BC
    44e4:	b0 91 bd 23 	lds	r27, 0x23BD
    44e8:	82 37       	cpi	r24, 0x72	; 114
    44ea:	22 e7       	ldi	r18, 0x72	; 114
    44ec:	92 07       	cpc	r25, r18
    44ee:	21 e4       	ldi	r18, 0x41	; 65
    44f0:	a2 07       	cpc	r26, r18
    44f2:	21 e6       	ldi	r18, 0x61	; 97
    44f4:	b2 07       	cpc	r27, r18
    44f6:	09 f0       	breq	.+2      	; 0x44fa <getSetFreeCluster+0x7e>
    44f8:	56 c0       	rjmp	.+172    	; 0x45a6 <getSetFreeCluster+0x12a>
    44fa:	80 91 d2 23 	lds	r24, 0x23D2
    44fe:	90 91 d3 23 	lds	r25, 0x23D3
    4502:	a0 91 d4 23 	lds	r26, 0x23D4
    4506:	b0 91 d5 23 	lds	r27, 0x23D5
    450a:	80 30       	cpi	r24, 0x00	; 0
    450c:	20 e0       	ldi	r18, 0x00	; 0
    450e:	92 07       	cpc	r25, r18
    4510:	25 e5       	ldi	r18, 0x55	; 85
    4512:	a2 07       	cpc	r26, r18
    4514:	2a ea       	ldi	r18, 0xAA	; 170
    4516:	b2 07       	cpc	r27, r18
    4518:	09 f0       	breq	.+2      	; 0x451c <getSetFreeCluster+0xa0>
    451a:	49 c0       	rjmp	.+146    	; 0x45ae <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    451c:	00 23       	and	r16, r16
    451e:	a1 f4       	brne	.+40     	; 0x4548 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4520:	c1 30       	cpi	r28, 0x01	; 1
    4522:	49 f4       	brne	.+18     	; 0x4536 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    4524:	00 91 be 23 	lds	r16, 0x23BE
    4528:	10 91 bf 23 	lds	r17, 0x23BF
    452c:	20 91 c0 23 	lds	r18, 0x23C0
    4530:	30 91 c1 23 	lds	r19, 0x23C1
    4534:	3f c0       	rjmp	.+126    	; 0x45b4 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    4536:	00 91 c2 23 	lds	r16, 0x23C2
    453a:	10 91 c3 23 	lds	r17, 0x23C3
    453e:	20 91 c4 23 	lds	r18, 0x23C4
    4542:	30 91 c5 23 	lds	r19, 0x23C5
    4546:	36 c0       	rjmp	.+108    	; 0x45b4 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4548:	c1 30       	cpi	r28, 0x01	; 1
    454a:	49 f4       	brne	.+18     	; 0x455e <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    454c:	c0 92 be 23 	sts	0x23BE, r12
    4550:	d0 92 bf 23 	sts	0x23BF, r13
    4554:	e0 92 c0 23 	sts	0x23C0, r14
    4558:	f0 92 c1 23 	sts	0x23C1, r15
    455c:	08 c0       	rjmp	.+16     	; 0x456e <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    455e:	c0 92 c2 23 	sts	0x23C2, r12
    4562:	d0 92 c3 23 	sts	0x23C3, r13
    4566:	e0 92 c4 23 	sts	0x23C4, r14
    456a:	f0 92 c5 23 	sts	0x23C5, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    456e:	80 91 7d 50 	lds	r24, 0x507D
    4572:	90 91 7e 50 	lds	r25, 0x507E
    4576:	a0 91 7f 50 	lds	r26, 0x507F
    457a:	b0 91 80 50 	lds	r27, 0x5080
    457e:	bc 01       	movw	r22, r24
    4580:	cd 01       	movw	r24, r26
    4582:	6f 5f       	subi	r22, 0xFF	; 255
    4584:	7f 4f       	sbci	r23, 0xFF	; 255
    4586:	8f 4f       	sbci	r24, 0xFF	; 255
    4588:	9f 4f       	sbci	r25, 0xFF	; 255
    458a:	46 ed       	ldi	r20, 0xD6	; 214
    458c:	51 e2       	ldi	r21, 0x21	; 33
    458e:	20 e0       	ldi	r18, 0x00	; 0
    4590:	32 e0       	ldi	r19, 0x02	; 2
    4592:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <SD_write_block>
 }
 return 0xffffffff;
    4596:	0f ef       	ldi	r16, 0xFF	; 255
    4598:	1f ef       	ldi	r17, 0xFF	; 255
    459a:	98 01       	movw	r18, r16
    459c:	0b c0       	rjmp	.+22     	; 0x45b4 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    459e:	0f ef       	ldi	r16, 0xFF	; 255
    45a0:	1f ef       	ldi	r17, 0xFF	; 255
    45a2:	98 01       	movw	r18, r16
    45a4:	07 c0       	rjmp	.+14     	; 0x45b4 <getSetFreeCluster+0x138>
    45a6:	0f ef       	ldi	r16, 0xFF	; 255
    45a8:	1f ef       	ldi	r17, 0xFF	; 255
    45aa:	98 01       	movw	r18, r16
    45ac:	03 c0       	rjmp	.+6      	; 0x45b4 <getSetFreeCluster+0x138>
    45ae:	0f ef       	ldi	r16, 0xFF	; 255
    45b0:	1f ef       	ldi	r17, 0xFF	; 255
    45b2:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    45b4:	60 2f       	mov	r22, r16
    45b6:	71 2f       	mov	r23, r17
    45b8:	82 2f       	mov	r24, r18
    45ba:	93 2f       	mov	r25, r19
    45bc:	cf 91       	pop	r28
    45be:	1f 91       	pop	r17
    45c0:	0f 91       	pop	r16
    45c2:	ff 90       	pop	r15
    45c4:	ef 90       	pop	r14
    45c6:	df 90       	pop	r13
    45c8:	cf 90       	pop	r12
    45ca:	08 95       	ret

000045cc <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    45cc:	ef 92       	push	r14
    45ce:	ff 92       	push	r15
    45d0:	0f 93       	push	r16
    45d2:	1f 93       	push	r17
    45d4:	cf 93       	push	r28
    45d6:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    45d8:	10 92 7d 50 	sts	0x507D, r1
    45dc:	10 92 7e 50 	sts	0x507E, r1
    45e0:	10 92 7f 50 	sts	0x507F, r1
    45e4:	10 92 80 50 	sts	0x5080, r1

SD_read_block(0,SDBuffer);
    45e8:	60 e0       	ldi	r22, 0x00	; 0
    45ea:	70 e0       	ldi	r23, 0x00	; 0
    45ec:	cb 01       	movw	r24, r22
    45ee:	46 ed       	ldi	r20, 0xD6	; 214
    45f0:	51 e2       	ldi	r21, 0x21	; 33
    45f2:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    45f6:	80 91 d6 21 	lds	r24, 0x21D6
    45fa:	89 3e       	cpi	r24, 0xE9	; 233
    45fc:	31 f1       	breq	.+76     	; 0x464a <getBootSectorData+0x7e>
    45fe:	8b 3e       	cpi	r24, 0xEB	; 235
    4600:	21 f1       	breq	.+72     	; 0x464a <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4602:	80 91 d4 23 	lds	r24, 0x23D4
    4606:	90 91 d5 23 	lds	r25, 0x23D5
    460a:	2a ea       	ldi	r18, 0xAA	; 170
    460c:	85 35       	cpi	r24, 0x55	; 85
    460e:	92 07       	cpc	r25, r18
    4610:	09 f0       	breq	.+2      	; 0x4614 <getBootSectorData+0x48>
    4612:	b7 c0       	rjmp	.+366    	; 0x4782 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    4614:	60 91 9c 23 	lds	r22, 0x239C
    4618:	70 91 9d 23 	lds	r23, 0x239D
    461c:	80 91 9e 23 	lds	r24, 0x239E
    4620:	90 91 9f 23 	lds	r25, 0x239F
    4624:	60 93 7d 50 	sts	0x507D, r22
    4628:	70 93 7e 50 	sts	0x507E, r23
    462c:	80 93 7f 50 	sts	0x507F, r24
    4630:	90 93 80 50 	sts	0x5080, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    4634:	46 ed       	ldi	r20, 0xD6	; 214
    4636:	51 e2       	ldi	r21, 0x21	; 33
    4638:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    463c:	80 91 d6 21 	lds	r24, 0x21D6
    4640:	89 3e       	cpi	r24, 0xE9	; 233
    4642:	19 f0       	breq	.+6      	; 0x464a <getBootSectorData+0x7e>
    4644:	8b 3e       	cpi	r24, 0xEB	; 235
    4646:	09 f0       	breq	.+2      	; 0x464a <getBootSectorData+0x7e>
    4648:	9e c0       	rjmp	.+316    	; 0x4786 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    464a:	80 91 e1 21 	lds	r24, 0x21E1
    464e:	90 91 e2 21 	lds	r25, 0x21E2
    4652:	80 93 54 40 	sts	0x4054, r24
    4656:	90 93 55 40 	sts	0x4055, r25
sectorPerCluster = bpb->sectorPerCluster;
    465a:	80 91 e3 21 	lds	r24, 0x21E3
    465e:	90 e0       	ldi	r25, 0x00	; 0
    4660:	80 93 7b 50 	sts	0x507B, r24
    4664:	90 93 7c 50 	sts	0x507C, r25
reservedSectorCount = bpb->reservedSectorCount;
    4668:	e0 90 e4 21 	lds	r14, 0x21E4
    466c:	f0 90 e5 21 	lds	r15, 0x21E5
    4670:	e0 92 83 50 	sts	0x5083, r14
    4674:	f0 92 84 50 	sts	0x5084, r15
rootCluster = bpb->rootCluster;
    4678:	80 91 02 22 	lds	r24, 0x2202
    467c:	90 91 03 22 	lds	r25, 0x2203
    4680:	a0 91 04 22 	lds	r26, 0x2204
    4684:	b0 91 05 22 	lds	r27, 0x2205
    4688:	80 93 5f 40 	sts	0x405F, r24
    468c:	90 93 60 40 	sts	0x4060, r25
    4690:	a0 93 61 40 	sts	0x4061, r26
    4694:	b0 93 62 40 	sts	0x4062, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    4698:	c0 91 83 50 	lds	r28, 0x5083
    469c:	d0 91 84 50 	lds	r29, 0x5084
    46a0:	60 91 e6 21 	lds	r22, 0x21E6
    46a4:	70 e0       	ldi	r23, 0x00	; 0
    46a6:	80 e0       	ldi	r24, 0x00	; 0
    46a8:	90 e0       	ldi	r25, 0x00	; 0
    46aa:	20 91 fa 21 	lds	r18, 0x21FA
    46ae:	30 91 fb 21 	lds	r19, 0x21FB
    46b2:	40 91 fc 21 	lds	r20, 0x21FC
    46b6:	50 91 fd 21 	lds	r21, 0x21FD
    46ba:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    46be:	8b 01       	movw	r16, r22
    46c0:	9c 01       	movw	r18, r24
    46c2:	ae 01       	movw	r20, r28
    46c4:	60 e0       	ldi	r22, 0x00	; 0
    46c6:	70 e0       	ldi	r23, 0x00	; 0
    46c8:	80 91 f2 21 	lds	r24, 0x21F2
    46cc:	90 91 f3 21 	lds	r25, 0x21F3
    46d0:	a0 91 f4 21 	lds	r26, 0x21F4
    46d4:	b0 91 f5 21 	lds	r27, 0x21F5
    46d8:	84 0f       	add	r24, r20
    46da:	95 1f       	adc	r25, r21
    46dc:	a6 1f       	adc	r26, r22
    46de:	b7 1f       	adc	r27, r23
    46e0:	80 0f       	add	r24, r16
    46e2:	91 1f       	adc	r25, r17
    46e4:	a2 1f       	adc	r26, r18
    46e6:	b3 1f       	adc	r27, r19
    46e8:	80 93 db 23 	sts	0x23DB, r24
    46ec:	90 93 dc 23 	sts	0x23DC, r25
    46f0:	a0 93 dd 23 	sts	0x23DD, r26
    46f4:	b0 93 de 23 	sts	0x23DE, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    46f8:	e0 91 7b 50 	lds	r30, 0x507B
    46fc:	f0 91 7c 50 	lds	r31, 0x507C
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4700:	c7 01       	movw	r24, r14
    4702:	a0 e0       	ldi	r26, 0x00	; 0
    4704:	b0 e0       	ldi	r27, 0x00	; 0
    4706:	40 91 f6 21 	lds	r20, 0x21F6
    470a:	50 91 f7 21 	lds	r21, 0x21F7
    470e:	60 91 f8 21 	lds	r22, 0x21F8
    4712:	70 91 f9 21 	lds	r23, 0x21F9
    4716:	48 1b       	sub	r20, r24
    4718:	59 0b       	sbc	r21, r25
    471a:	6a 0b       	sbc	r22, r26
    471c:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    471e:	cb 01       	movw	r24, r22
    4720:	ba 01       	movw	r22, r20
    4722:	60 1b       	sub	r22, r16
    4724:	71 0b       	sbc	r23, r17
    4726:	82 0b       	sbc	r24, r18
    4728:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    472a:	9f 01       	movw	r18, r30
    472c:	40 e0       	ldi	r20, 0x00	; 0
    472e:	50 e0       	ldi	r21, 0x00	; 0
    4730:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    4734:	20 93 59 40 	sts	0x4059, r18
    4738:	30 93 5a 40 	sts	0x405A, r19
    473c:	40 93 5b 40 	sts	0x405B, r20
    4740:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    4744:	81 e0       	ldi	r24, 0x01	; 1
    4746:	60 e0       	ldi	r22, 0x00	; 0
    4748:	20 e0       	ldi	r18, 0x00	; 0
    474a:	30 e0       	ldi	r19, 0x00	; 0
    474c:	a9 01       	movw	r20, r18
    474e:	0e 94 3e 22 	call	0x447c	; 0x447c <getSetFreeCluster>
    4752:	ab 01       	movw	r20, r22
    4754:	bc 01       	movw	r22, r24
    4756:	80 91 59 40 	lds	r24, 0x4059
    475a:	90 91 5a 40 	lds	r25, 0x405A
    475e:	a0 91 5b 40 	lds	r26, 0x405B
    4762:	b0 91 5c 40 	lds	r27, 0x405C
    4766:	84 17       	cp	r24, r20
    4768:	95 07       	cpc	r25, r21
    476a:	a6 07       	cpc	r26, r22
    476c:	b7 07       	cpc	r27, r23
    476e:	20 f4       	brcc	.+8      	; 0x4778 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4770:	10 92 c7 50 	sts	0x50C7, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4774:	80 e0       	ldi	r24, 0x00	; 0
    4776:	08 c0       	rjmp	.+16     	; 0x4788 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4778:	81 e0       	ldi	r24, 0x01	; 1
    477a:	80 93 c7 50 	sts	0x50C7, r24
return 0;
    477e:	80 e0       	ldi	r24, 0x00	; 0
    4780:	03 c0       	rjmp	.+6      	; 0x4788 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4782:	81 e0       	ldi	r24, 0x01	; 1
    4784:	01 c0       	rjmp	.+2      	; 0x4788 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4786:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4788:	df 91       	pop	r29
    478a:	cf 91       	pop	r28
    478c:	1f 91       	pop	r17
    478e:	0f 91       	pop	r16
    4790:	ff 90       	pop	r15
    4792:	ef 90       	pop	r14
    4794:	08 95       	ret

00004796 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4796:	0f 93       	push	r16
    4798:	1f 93       	push	r17
    479a:	cf 93       	push	r28
    479c:	df 93       	push	r29
    479e:	cd b7       	in	r28, 0x3d	; 61
    47a0:	de b7       	in	r29, 0x3e	; 62
    47a2:	2b 97       	sbiw	r28, 0x0b	; 11
    47a4:	cd bf       	out	0x3d, r28	; 61
    47a6:	de bf       	out	0x3e, r29	; 62
    47a8:	78 2f       	mov	r23, r24
    47aa:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    47ac:	e8 2f       	mov	r30, r24
    47ae:	f9 2f       	mov	r31, r25
    47b0:	df 01       	movw	r26, r30
    47b2:	0d 90       	ld	r0, X+
    47b4:	00 20       	and	r0, r0
    47b6:	e9 f7       	brne	.-6      	; 0x47b2 <convertFileName+0x1c>
    47b8:	11 97       	sbiw	r26, 0x01	; 1
    47ba:	ae 1b       	sub	r26, r30
    47bc:	bf 0b       	sbc	r27, r31
    47be:	a0 31       	cpi	r26, 0x10	; 16
    47c0:	b1 05       	cpc	r27, r1
    47c2:	08 f0       	brcs	.+2      	; 0x47c6 <convertFileName+0x30>
    47c4:	9c c0       	rjmp	.+312    	; 0x48fe <convertFileName+0x168>
    47c6:	28 2f       	mov	r18, r24
    47c8:	39 2f       	mov	r19, r25
    47ca:	03 eb       	ldi	r16, 0xB3	; 179
    47cc:	10 e5       	ldi	r17, 0x50	; 80
    47ce:	a8 01       	movw	r20, r16
    47d0:	80 e0       	ldi	r24, 0x00	; 0
    47d2:	90 e0       	ldi	r25, 0x00	; 0
    47d4:	07 c0       	rjmp	.+14     	; 0x47e4 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    47d6:	d9 01       	movw	r26, r18
    47d8:	ed 91       	ld	r30, X+
    47da:	9d 01       	movw	r18, r26
    47dc:	da 01       	movw	r26, r20
    47de:	ed 93       	st	X+, r30
    47e0:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    47e2:	01 96       	adiw	r24, 0x01	; 1
    47e4:	a7 2f       	mov	r26, r23
    47e6:	b6 2f       	mov	r27, r22
    47e8:	fd 01       	movw	r30, r26
    47ea:	01 90       	ld	r0, Z+
    47ec:	00 20       	and	r0, r0
    47ee:	e9 f7       	brne	.-6      	; 0x47ea <convertFileName+0x54>
    47f0:	31 97       	sbiw	r30, 0x01	; 1
    47f2:	ea 1b       	sub	r30, r26
    47f4:	fb 0b       	sbc	r31, r27
    47f6:	8e 17       	cp	r24, r30
    47f8:	9f 07       	cpc	r25, r31
    47fa:	68 f3       	brcs	.-38     	; 0x47d6 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    47fc:	8f 30       	cpi	r24, 0x0F	; 15
    47fe:	91 05       	cpc	r25, r1
    4800:	54 f4       	brge	.+20     	; 0x4816 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4802:	fc 01       	movw	r30, r24
    4804:	ed 54       	subi	r30, 0x4D	; 77
    4806:	ff 4a       	sbci	r31, 0xAF	; 175
    4808:	82 ec       	ldi	r24, 0xC2	; 194
    480a:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    480c:	20 e2       	ldi	r18, 0x20	; 32
    480e:	21 93       	st	Z+, r18
    4810:	e8 17       	cp	r30, r24
    4812:	f9 07       	cpc	r31, r25
    4814:	e1 f7       	brne	.-8      	; 0x480e <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4816:	80 91 b3 50 	lds	r24, 0x50B3
    481a:	8e 32       	cpi	r24, 0x2E	; 46
    481c:	91 f0       	breq	.+36     	; 0x4842 <convertFileName+0xac>
    481e:	e4 eb       	ldi	r30, 0xB4	; 180
    4820:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4822:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    4824:	81 91       	ld	r24, Z+
    4826:	8e 32       	cpi	r24, 0x2E	; 46
    4828:	21 f0       	breq	.+8      	; 0x4832 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    482a:	2f 5f       	subi	r18, 0xFF	; 255
    482c:	2c 30       	cpi	r18, 0x0C	; 12
    482e:	d1 f7       	brne	.-12     	; 0x4824 <convertFileName+0x8e>
    4830:	05 c0       	rjmp	.+10     	; 0x483c <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    4832:	82 2f       	mov	r24, r18
    4834:	89 50       	subi	r24, 0x09	; 9
    4836:	83 30       	cpi	r24, 0x03	; 3
    4838:	08 f4       	brcc	.+2      	; 0x483c <convertFileName+0xa6>
    483a:	63 c0       	rjmp	.+198    	; 0x4902 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    483c:	22 23       	and	r18, r18
    483e:	29 f4       	brne	.+10     	; 0x484a <convertFileName+0xb4>
    4840:	01 c0       	rjmp	.+2      	; 0x4844 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4842:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4844:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    4846:	90 e2       	ldi	r25, 0x20	; 32
    4848:	10 c0       	rjmp	.+32     	; 0x486a <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    484a:	de 01       	movw	r26, r28
    484c:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    484e:	82 2f       	mov	r24, r18
    4850:	81 50       	subi	r24, 0x01	; 1
    4852:	90 e0       	ldi	r25, 0x00	; 0
    4854:	8c 54       	subi	r24, 0x4C	; 76
    4856:	9f 4a       	sbci	r25, 0xAF	; 175
    4858:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    485a:	31 91       	ld	r19, Z+
    485c:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    485e:	e8 17       	cp	r30, r24
    4860:	f9 07       	cpc	r31, r25
    4862:	d9 f7       	brne	.-10     	; 0x485a <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4864:	28 30       	cpi	r18, 0x08	; 8
    4866:	70 f3       	brcs	.-36     	; 0x4844 <convertFileName+0xae>
    4868:	0a c0       	rjmp	.+20     	; 0x487e <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    486a:	e1 e0       	ldi	r30, 0x01	; 1
    486c:	f0 e0       	ldi	r31, 0x00	; 0
    486e:	ec 0f       	add	r30, r28
    4870:	fd 1f       	adc	r31, r29
    4872:	e8 0f       	add	r30, r24
    4874:	f1 1d       	adc	r31, r1
    4876:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4878:	8f 5f       	subi	r24, 0xFF	; 255
    487a:	88 30       	cpi	r24, 0x08	; 8
    487c:	b0 f3       	brcs	.-20     	; 0x486a <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    487e:	2c 30       	cpi	r18, 0x0C	; 12
    4880:	09 f0       	breq	.+2      	; 0x4884 <convertFileName+0xee>
    4882:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4884:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4886:	83 eb       	ldi	r24, 0xB3	; 179
    4888:	90 e5       	ldi	r25, 0x50	; 80
    488a:	fc 01       	movw	r30, r24
    488c:	e2 0f       	add	r30, r18
    488e:	f1 1d       	adc	r31, r1
    4890:	40 81       	ld	r20, Z
    4892:	44 23       	and	r20, r20
    4894:	19 f4       	brne	.+6      	; 0x489c <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4896:	3b 30       	cpi	r19, 0x0B	; 11
    4898:	50 f0       	brcs	.+20     	; 0x48ae <convertFileName+0x118>
    489a:	15 c0       	rjmp	.+42     	; 0x48c6 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    489c:	e1 e0       	ldi	r30, 0x01	; 1
    489e:	f0 e0       	ldi	r31, 0x00	; 0
    48a0:	ec 0f       	add	r30, r28
    48a2:	fd 1f       	adc	r31, r29
    48a4:	e3 0f       	add	r30, r19
    48a6:	f1 1d       	adc	r31, r1
    48a8:	40 83       	st	Z, r20
    48aa:	2f 5f       	subi	r18, 0xFF	; 255
    48ac:	0c c0       	rjmp	.+24     	; 0x48c6 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    48ae:	80 e2       	ldi	r24, 0x20	; 32
    48b0:	e1 e0       	ldi	r30, 0x01	; 1
    48b2:	f0 e0       	ldi	r31, 0x00	; 0
    48b4:	ec 0f       	add	r30, r28
    48b6:	fd 1f       	adc	r31, r29
    48b8:	e3 0f       	add	r30, r19
    48ba:	f1 1d       	adc	r31, r1
    48bc:	80 83       	st	Z, r24
    48be:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    48c0:	3b 30       	cpi	r19, 0x0B	; 11
    48c2:	b1 f7       	brne	.-20     	; 0x48b0 <convertFileName+0x11a>
    48c4:	03 c0       	rjmp	.+6      	; 0x48cc <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    48c6:	3f 5f       	subi	r19, 0xFF	; 255
    48c8:	3b 30       	cpi	r19, 0x0B	; 11
    48ca:	f8 f2       	brcs	.-66     	; 0x488a <convertFileName+0xf4>
    48cc:	de 01       	movw	r26, r28
    48ce:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    48d0:	ce 01       	movw	r24, r28
    48d2:	0c 96       	adiw	r24, 0x0c	; 12
    48d4:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    48d6:	20 81       	ld	r18, Z
    48d8:	32 2f       	mov	r19, r18
    48da:	31 56       	subi	r19, 0x61	; 97
    48dc:	3a 31       	cpi	r19, 0x1A	; 26
    48de:	10 f4       	brcc	.+4      	; 0x48e4 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    48e0:	20 52       	subi	r18, 0x20	; 32
    48e2:	20 83       	st	Z, r18
    48e4:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    48e6:	e8 17       	cp	r30, r24
    48e8:	f9 07       	cpc	r31, r25
    48ea:	a9 f7       	brne	.-22     	; 0x48d6 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    48ec:	2d 91       	ld	r18, X+
    48ee:	f8 01       	movw	r30, r16
    48f0:	21 93       	st	Z+, r18
    48f2:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    48f4:	a8 17       	cp	r26, r24
    48f6:	b9 07       	cpc	r27, r25
    48f8:	c9 f7       	brne	.-14     	; 0x48ec <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    48fa:	80 e0       	ldi	r24, 0x00	; 0
    48fc:	03 c0       	rjmp	.+6      	; 0x4904 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    48fe:	81 e0       	ldi	r24, 0x01	; 1
    4900:	01 c0       	rjmp	.+2      	; 0x4904 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4902:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    4904:	2b 96       	adiw	r28, 0x0b	; 11
    4906:	cd bf       	out	0x3d, r28	; 61
    4908:	de bf       	out	0x3e, r29	; 62
    490a:	df 91       	pop	r29
    490c:	cf 91       	pop	r28
    490e:	1f 91       	pop	r17
    4910:	0f 91       	pop	r16
    4912:	08 95       	ret

00004914 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4914:	4f 92       	push	r4
    4916:	5f 92       	push	r5
    4918:	6f 92       	push	r6
    491a:	7f 92       	push	r7
    491c:	8f 92       	push	r8
    491e:	9f 92       	push	r9
    4920:	af 92       	push	r10
    4922:	bf 92       	push	r11
    4924:	cf 92       	push	r12
    4926:	df 92       	push	r13
    4928:	ef 92       	push	r14
    492a:	ff 92       	push	r15
    492c:	cf 93       	push	r28
    492e:	df 93       	push	r29
    4930:	2b 01       	movw	r4, r22
    4932:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4934:	20 e8       	ldi	r18, 0x80	; 128
    4936:	3f ef       	ldi	r19, 0xFF	; 255
    4938:	4f ef       	ldi	r20, 0xFF	; 255
    493a:	5f ef       	ldi	r21, 0xFF	; 255
    493c:	42 22       	and	r4, r18
    493e:	53 22       	and	r5, r19
    4940:	64 22       	and	r6, r20
    4942:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4944:	80 91 59 40 	lds	r24, 0x4059
    4948:	90 91 5a 40 	lds	r25, 0x405A
    494c:	a0 91 5b 40 	lds	r26, 0x405B
    4950:	b0 91 5c 40 	lds	r27, 0x405C
    4954:	48 16       	cp	r4, r24
    4956:	59 06       	cpc	r5, r25
    4958:	6a 06       	cpc	r6, r26
    495a:	7b 06       	cpc	r7, r27
    495c:	08 f0       	brcs	.+2      	; 0x4960 <searchNextFreeCluster+0x4c>
    495e:	77 c0       	rjmp	.+238    	; 0x4a4e <searchNextFreeCluster+0x13a>
    4960:	53 01       	movw	r10, r6
    4962:	42 01       	movw	r8, r4
    4964:	88 0c       	add	r8, r8
    4966:	99 1c       	adc	r9, r9
    4968:	aa 1c       	adc	r10, r10
    496a:	bb 1c       	adc	r11, r11
    496c:	88 0c       	add	r8, r8
    496e:	99 1c       	adc	r9, r9
    4970:	aa 1c       	adc	r10, r10
    4972:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4974:	c6 ed       	ldi	r28, 0xD6	; 214
    4976:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4978:	c0 90 83 50 	lds	r12, 0x5083
    497c:	d0 90 84 50 	lds	r13, 0x5084
    4980:	20 91 54 40 	lds	r18, 0x4054
    4984:	30 91 55 40 	lds	r19, 0x4055
    4988:	ee 24       	eor	r14, r14
    498a:	ff 24       	eor	r15, r15
    498c:	80 91 7d 50 	lds	r24, 0x507D
    4990:	90 91 7e 50 	lds	r25, 0x507E
    4994:	a0 91 7f 50 	lds	r26, 0x507F
    4998:	b0 91 80 50 	lds	r27, 0x5080
    499c:	c8 0e       	add	r12, r24
    499e:	d9 1e       	adc	r13, r25
    49a0:	ea 1e       	adc	r14, r26
    49a2:	fb 1e       	adc	r15, r27
    49a4:	40 e0       	ldi	r20, 0x00	; 0
    49a6:	50 e0       	ldi	r21, 0x00	; 0
    49a8:	c5 01       	movw	r24, r10
    49aa:	b4 01       	movw	r22, r8
    49ac:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    49b0:	c7 01       	movw	r24, r14
    49b2:	b6 01       	movw	r22, r12
    49b4:	62 0f       	add	r22, r18
    49b6:	73 1f       	adc	r23, r19
    49b8:	84 1f       	adc	r24, r20
    49ba:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    49bc:	ae 01       	movw	r20, r28
    49be:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    49c2:	88 81       	ld	r24, Y
    49c4:	99 81       	ldd	r25, Y+1	; 0x01
    49c6:	aa 81       	ldd	r26, Y+2	; 0x02
    49c8:	bb 81       	ldd	r27, Y+3	; 0x03
    49ca:	bf 70       	andi	r27, 0x0F	; 15
    49cc:	00 97       	sbiw	r24, 0x00	; 0
    49ce:	a1 05       	cpc	r26, r1
    49d0:	b1 05       	cpc	r27, r1
    49d2:	99 f0       	breq	.+38     	; 0x49fa <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    49d4:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    49d6:	e2 2f       	mov	r30, r18
    49d8:	f0 e0       	ldi	r31, 0x00	; 0
    49da:	ee 0f       	add	r30, r30
    49dc:	ff 1f       	adc	r31, r31
    49de:	ee 0f       	add	r30, r30
    49e0:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    49e2:	ea 52       	subi	r30, 0x2A	; 42
    49e4:	fe 4d       	sbci	r31, 0xDE	; 222
    49e6:	80 81       	ld	r24, Z
    49e8:	91 81       	ldd	r25, Z+1	; 0x01
    49ea:	a2 81       	ldd	r26, Z+2	; 0x02
    49ec:	b3 81       	ldd	r27, Z+3	; 0x03
    49ee:	bf 70       	andi	r27, 0x0F	; 15
    49f0:	00 97       	sbiw	r24, 0x00	; 0
    49f2:	a1 05       	cpc	r26, r1
    49f4:	b1 05       	cpc	r27, r1
    49f6:	39 f4       	brne	.+14     	; 0x4a06 <searchNextFreeCluster+0xf2>
    49f8:	01 c0       	rjmp	.+2      	; 0x49fc <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    49fa:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    49fc:	42 0e       	add	r4, r18
    49fe:	51 1c       	adc	r5, r1
    4a00:	61 1c       	adc	r6, r1
    4a02:	71 1c       	adc	r7, r1
    4a04:	27 c0       	rjmp	.+78     	; 0x4a54 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4a06:	2f 5f       	subi	r18, 0xFF	; 255
    4a08:	32 f7       	brpl	.-52     	; 0x49d6 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4a0a:	80 e8       	ldi	r24, 0x80	; 128
    4a0c:	90 e0       	ldi	r25, 0x00	; 0
    4a0e:	a0 e0       	ldi	r26, 0x00	; 0
    4a10:	b0 e0       	ldi	r27, 0x00	; 0
    4a12:	48 0e       	add	r4, r24
    4a14:	59 1e       	adc	r5, r25
    4a16:	6a 1e       	adc	r6, r26
    4a18:	7b 1e       	adc	r7, r27
    4a1a:	80 91 59 40 	lds	r24, 0x4059
    4a1e:	90 91 5a 40 	lds	r25, 0x405A
    4a22:	a0 91 5b 40 	lds	r26, 0x405B
    4a26:	b0 91 5c 40 	lds	r27, 0x405C
    4a2a:	20 e0       	ldi	r18, 0x00	; 0
    4a2c:	32 e0       	ldi	r19, 0x02	; 2
    4a2e:	40 e0       	ldi	r20, 0x00	; 0
    4a30:	50 e0       	ldi	r21, 0x00	; 0
    4a32:	82 0e       	add	r8, r18
    4a34:	93 1e       	adc	r9, r19
    4a36:	a4 1e       	adc	r10, r20
    4a38:	b5 1e       	adc	r11, r21
    4a3a:	48 16       	cp	r4, r24
    4a3c:	59 06       	cpc	r5, r25
    4a3e:	6a 06       	cpc	r6, r26
    4a40:	7b 06       	cpc	r7, r27
    4a42:	08 f4       	brcc	.+2      	; 0x4a46 <searchNextFreeCluster+0x132>
    4a44:	99 cf       	rjmp	.-206    	; 0x4978 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4a46:	44 24       	eor	r4, r4
    4a48:	55 24       	eor	r5, r5
    4a4a:	32 01       	movw	r6, r4
    4a4c:	03 c0       	rjmp	.+6      	; 0x4a54 <searchNextFreeCluster+0x140>
    4a4e:	44 24       	eor	r4, r4
    4a50:	55 24       	eor	r5, r5
    4a52:	32 01       	movw	r6, r4
}
    4a54:	64 2d       	mov	r22, r4
    4a56:	75 2d       	mov	r23, r5
    4a58:	86 2d       	mov	r24, r6
    4a5a:	97 2d       	mov	r25, r7
    4a5c:	df 91       	pop	r29
    4a5e:	cf 91       	pop	r28
    4a60:	ff 90       	pop	r15
    4a62:	ef 90       	pop	r14
    4a64:	df 90       	pop	r13
    4a66:	cf 90       	pop	r12
    4a68:	bf 90       	pop	r11
    4a6a:	af 90       	pop	r10
    4a6c:	9f 90       	pop	r9
    4a6e:	8f 90       	pop	r8
    4a70:	7f 90       	pop	r7
    4a72:	6f 90       	pop	r6
    4a74:	5f 90       	pop	r5
    4a76:	4f 90       	pop	r4
    4a78:	08 95       	ret

00004a7a <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4a7a:	cf 92       	push	r12
    4a7c:	df 92       	push	r13
    4a7e:	ef 92       	push	r14
    4a80:	ff 92       	push	r15
    4a82:	cf 93       	push	r28
    4a84:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4a86:	db 01       	movw	r26, r22
    4a88:	ca 01       	movw	r24, r20
    4a8a:	91 70       	andi	r25, 0x01	; 1
    4a8c:	a0 70       	andi	r26, 0x00	; 0
    4a8e:	b0 70       	andi	r27, 0x00	; 0
    4a90:	00 97       	sbiw	r24, 0x00	; 0
    4a92:	a1 05       	cpc	r26, r1
    4a94:	b1 05       	cpc	r27, r1
    4a96:	51 f4       	brne	.+20     	; 0x4aac <freeMemoryUpdate+0x32>
    4a98:	03 2e       	mov	r0, r19
    4a9a:	39 e0       	ldi	r19, 0x09	; 9
    4a9c:	76 95       	lsr	r23
    4a9e:	67 95       	ror	r22
    4aa0:	57 95       	ror	r21
    4aa2:	47 95       	ror	r20
    4aa4:	3a 95       	dec	r19
    4aa6:	d1 f7       	brne	.-12     	; 0x4a9c <freeMemoryUpdate+0x22>
    4aa8:	30 2d       	mov	r19, r0
    4aaa:	0d c0       	rjmp	.+26     	; 0x4ac6 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4aac:	03 2e       	mov	r0, r19
    4aae:	39 e0       	ldi	r19, 0x09	; 9
    4ab0:	76 95       	lsr	r23
    4ab2:	67 95       	ror	r22
    4ab4:	57 95       	ror	r21
    4ab6:	47 95       	ror	r20
    4ab8:	3a 95       	dec	r19
    4aba:	d1 f7       	brne	.-12     	; 0x4ab0 <freeMemoryUpdate+0x36>
    4abc:	30 2d       	mov	r19, r0
    4abe:	4f 5f       	subi	r20, 0xFF	; 255
    4ac0:	5f 4f       	sbci	r21, 0xFF	; 255
    4ac2:	6f 4f       	sbci	r22, 0xFF	; 255
    4ac4:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4ac6:	db 01       	movw	r26, r22
    4ac8:	ca 01       	movw	r24, r20
    4aca:	87 70       	andi	r24, 0x07	; 7
    4acc:	90 70       	andi	r25, 0x00	; 0
    4ace:	a0 70       	andi	r26, 0x00	; 0
    4ad0:	b0 70       	andi	r27, 0x00	; 0
    4ad2:	00 97       	sbiw	r24, 0x00	; 0
    4ad4:	a1 05       	cpc	r26, r1
    4ad6:	b1 05       	cpc	r27, r1
    4ad8:	59 f4       	brne	.+22     	; 0x4af0 <freeMemoryUpdate+0x76>
    4ada:	6a 01       	movw	r12, r20
    4adc:	7b 01       	movw	r14, r22
    4ade:	68 94       	set
    4ae0:	12 f8       	bld	r1, 2
    4ae2:	f6 94       	lsr	r15
    4ae4:	e7 94       	ror	r14
    4ae6:	d7 94       	ror	r13
    4ae8:	c7 94       	ror	r12
    4aea:	16 94       	lsr	r1
    4aec:	d1 f7       	brne	.-12     	; 0x4ae2 <freeMemoryUpdate+0x68>
    4aee:	0f c0       	rjmp	.+30     	; 0x4b0e <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    4af0:	6a 01       	movw	r12, r20
    4af2:	7b 01       	movw	r14, r22
    4af4:	68 94       	set
    4af6:	12 f8       	bld	r1, 2
    4af8:	f6 94       	lsr	r15
    4afa:	e7 94       	ror	r14
    4afc:	d7 94       	ror	r13
    4afe:	c7 94       	ror	r12
    4b00:	16 94       	lsr	r1
    4b02:	d1 f7       	brne	.-12     	; 0x4af8 <freeMemoryUpdate+0x7e>
    4b04:	08 94       	sec
    4b06:	c1 1c       	adc	r12, r1
    4b08:	d1 1c       	adc	r13, r1
    4b0a:	e1 1c       	adc	r14, r1
    4b0c:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4b0e:	80 91 c7 50 	lds	r24, 0x50C7
    4b12:	88 23       	and	r24, r24
    4b14:	d1 f0       	breq	.+52     	; 0x4b4a <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4b16:	81 e0       	ldi	r24, 0x01	; 1
    4b18:	60 e0       	ldi	r22, 0x00	; 0
    4b1a:	20 e0       	ldi	r18, 0x00	; 0
    4b1c:	30 e0       	ldi	r19, 0x00	; 0
    4b1e:	a9 01       	movw	r20, r18
    4b20:	0e 94 3e 22 	call	0x447c	; 0x447c <getSetFreeCluster>
	if(flag == ADD)
    4b24:	cc 23       	and	r28, r28
    4b26:	39 f4       	brne	.+14     	; 0x4b36 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4b28:	9b 01       	movw	r18, r22
    4b2a:	ac 01       	movw	r20, r24
    4b2c:	2c 0d       	add	r18, r12
    4b2e:	3d 1d       	adc	r19, r13
    4b30:	4e 1d       	adc	r20, r14
    4b32:	5f 1d       	adc	r21, r15
    4b34:	06 c0       	rjmp	.+12     	; 0x4b42 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4b36:	9b 01       	movw	r18, r22
    4b38:	ac 01       	movw	r20, r24
    4b3a:	2c 19       	sub	r18, r12
    4b3c:	3d 09       	sbc	r19, r13
    4b3e:	4e 09       	sbc	r20, r14
    4b40:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4b42:	81 e0       	ldi	r24, 0x01	; 1
    4b44:	61 e0       	ldi	r22, 0x01	; 1
    4b46:	0e 94 3e 22 	call	0x447c	; 0x447c <getSetFreeCluster>
  }
}
    4b4a:	cf 91       	pop	r28
    4b4c:	ff 90       	pop	r15
    4b4e:	ef 90       	pop	r14
    4b50:	df 90       	pop	r13
    4b52:	cf 90       	pop	r12
    4b54:	08 95       	ret

00004b56 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4b56:	2f 92       	push	r2
    4b58:	3f 92       	push	r3
    4b5a:	4f 92       	push	r4
    4b5c:	5f 92       	push	r5
    4b5e:	6f 92       	push	r6
    4b60:	7f 92       	push	r7
    4b62:	8f 92       	push	r8
    4b64:	9f 92       	push	r9
    4b66:	af 92       	push	r10
    4b68:	bf 92       	push	r11
    4b6a:	cf 92       	push	r12
    4b6c:	df 92       	push	r13
    4b6e:	ef 92       	push	r14
    4b70:	ff 92       	push	r15
    4b72:	0f 93       	push	r16
    4b74:	1f 93       	push	r17
    4b76:	cf 93       	push	r28
    4b78:	df 93       	push	r29
    4b7a:	cd b7       	in	r28, 0x3d	; 61
    4b7c:	de b7       	in	r29, 0x3e	; 62
    4b7e:	2c 97       	sbiw	r28, 0x0c	; 12
    4b80:	cd bf       	out	0x3d, r28	; 61
    4b82:	de bf       	out	0x3e, r29	; 62
    4b84:	88 2e       	mov	r8, r24
    4b86:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4b88:	80 91 5f 40 	lds	r24, 0x405F
    4b8c:	90 91 60 40 	lds	r25, 0x4060
    4b90:	a0 91 61 40 	lds	r26, 0x4061
    4b94:	b0 91 62 40 	lds	r27, 0x4062
    4b98:	89 87       	std	Y+9, r24	; 0x09
    4b9a:	9a 87       	std	Y+10, r25	; 0x0a
    4b9c:	ab 87       	std	Y+11, r26	; 0x0b
    4b9e:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4ba0:	0f 2e       	mov	r0, r31
    4ba2:	f6 ed       	ldi	r31, 0xD6	; 214
    4ba4:	2f 2e       	mov	r2, r31
    4ba6:	f1 e2       	ldi	r31, 0x21	; 33
    4ba8:	3f 2e       	mov	r3, r31
    4baa:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4bac:	c8 2c       	mov	r12, r8
    4bae:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4bb0:	d2 2c       	mov	r13, r2
    4bb2:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4bb4:	5b 01       	movw	r10, r22
    4bb6:	08 94       	sec
    4bb8:	a1 1c       	adc	r10, r1
    4bba:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4bbc:	69 85       	ldd	r22, Y+9	; 0x09
    4bbe:	7a 85       	ldd	r23, Y+10	; 0x0a
    4bc0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bc2:	9c 85       	ldd	r25, Y+12	; 0x0c
    4bc4:	0e 94 85 21 	call	0x430a	; 0x430a <getFirstSector>
    4bc8:	6d 83       	std	Y+5, r22	; 0x05
    4bca:	7e 83       	std	Y+6, r23	; 0x06
    4bcc:	8f 83       	std	Y+7, r24	; 0x07
    4bce:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4bd0:	80 91 7b 50 	lds	r24, 0x507B
    4bd4:	90 91 7c 50 	lds	r25, 0x507C
    4bd8:	00 97       	sbiw	r24, 0x00	; 0
    4bda:	09 f4       	brne	.+2      	; 0x4bde <findFiles+0x88>
    4bdc:	13 c1       	rjmp	.+550    	; 0x4e04 <findFiles+0x2ae>
    4bde:	44 24       	eor	r4, r4
    4be0:	55 24       	eor	r5, r5
    4be2:	32 01       	movw	r6, r4
    4be4:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4be6:	8d 81       	ldd	r24, Y+5	; 0x05
    4be8:	9e 81       	ldd	r25, Y+6	; 0x06
    4bea:	af 81       	ldd	r26, Y+7	; 0x07
    4bec:	b8 85       	ldd	r27, Y+8	; 0x08
    4bee:	84 0d       	add	r24, r4
    4bf0:	95 1d       	adc	r25, r5
    4bf2:	a6 1d       	adc	r26, r6
    4bf4:	b7 1d       	adc	r27, r7
    4bf6:	89 83       	std	Y+1, r24	; 0x01
    4bf8:	9a 83       	std	Y+2, r25	; 0x02
    4bfa:	ab 83       	std	Y+3, r26	; 0x03
    4bfc:	bc 83       	std	Y+4, r27	; 0x04
    4bfe:	bc 01       	movw	r22, r24
    4c00:	cd 01       	movw	r24, r26
    4c02:	4d 2d       	mov	r20, r13
    4c04:	59 2d       	mov	r21, r9
    4c06:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4c0a:	80 91 54 40 	lds	r24, 0x4054
    4c0e:	90 91 55 40 	lds	r25, 0x4055
    4c12:	00 97       	sbiw	r24, 0x00	; 0
    4c14:	09 f4       	brne	.+2      	; 0x4c18 <findFiles+0xc2>
    4c16:	e4 c0       	rjmp	.+456    	; 0x4de0 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4c18:	d1 01       	movw	r26, r2
    4c1a:	8c 91       	ld	r24, X
    4c1c:	88 23       	and	r24, r24
    4c1e:	09 f4       	brne	.+2      	; 0x4c22 <findFiles+0xcc>
    4c20:	10 c1       	rjmp	.+544    	; 0x4e42 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4c22:	4d 2d       	mov	r20, r13
    4c24:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4c26:	20 e0       	ldi	r18, 0x00	; 0
    4c28:	30 e0       	ldi	r19, 0x00	; 0
    4c2a:	08 c0       	rjmp	.+16     	; 0x4c3c <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4c2c:	a9 01       	movw	r20, r18
    4c2e:	4a 52       	subi	r20, 0x2A	; 42
    4c30:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4c32:	fa 01       	movw	r30, r20
    4c34:	80 81       	ld	r24, Z
    4c36:	88 23       	and	r24, r24
    4c38:	09 f4       	brne	.+2      	; 0x4c3c <findFiles+0xe6>
    4c3a:	06 c1       	rjmp	.+524    	; 0x4e48 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4c3c:	85 3e       	cpi	r24, 0xE5	; 229
    4c3e:	09 f4       	brne	.+2      	; 0x4c42 <findFiles+0xec>
    4c40:	c5 c0       	rjmp	.+394    	; 0x4dcc <findFiles+0x276>
    4c42:	da 01       	movw	r26, r20
    4c44:	1b 96       	adiw	r26, 0x0b	; 11
    4c46:	8c 91       	ld	r24, X
    4c48:	1b 97       	sbiw	r26, 0x0b	; 11
    4c4a:	8f 30       	cpi	r24, 0x0F	; 15
    4c4c:	09 f4       	brne	.+2      	; 0x4c50 <findFiles+0xfa>
    4c4e:	be c0       	rjmp	.+380    	; 0x4dcc <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4c50:	12 30       	cpi	r17, 0x02	; 2
    4c52:	08 f0       	brcs	.+2      	; 0x4c56 <findFiles+0x100>
    4c54:	fc c0       	rjmp	.+504    	; 0x4e4e <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4c56:	9c 91       	ld	r25, X
    4c58:	f7 01       	movw	r30, r14
    4c5a:	80 81       	ld	r24, Z
    4c5c:	98 17       	cp	r25, r24
    4c5e:	09 f0       	breq	.+2      	; 0x4c62 <findFiles+0x10c>
    4c60:	b5 c0       	rjmp	.+362    	; 0x4dcc <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4c62:	fa 01       	movw	r30, r20
    4c64:	31 96       	adiw	r30, 0x01	; 1
    4c66:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4c68:	81 e0       	ldi	r24, 0x01	; 1
    4c6a:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4c6c:	41 91       	ld	r20, Z+
    4c6e:	9d 91       	ld	r25, X+
    4c70:	49 17       	cp	r20, r25
    4c72:	31 f4       	brne	.+12     	; 0x4c80 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4c74:	8f 5f       	subi	r24, 0xFF	; 255
    4c76:	8b 30       	cpi	r24, 0x0B	; 11
    4c78:	c9 f7       	brne	.-14     	; 0x4c6c <findFiles+0x116>
    4c7a:	8b 01       	movw	r16, r22
    4c7c:	6b 01       	movw	r12, r22
    4c7e:	05 c0       	rjmp	.+10     	; 0x4c8a <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4c80:	8b 30       	cpi	r24, 0x0B	; 11
    4c82:	09 f0       	breq	.+2      	; 0x4c86 <findFiles+0x130>
    4c84:	a3 c0       	rjmp	.+326    	; 0x4dcc <findFiles+0x276>
    4c86:	8b 01       	movw	r16, r22
    4c88:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4c8a:	f1 e0       	ldi	r31, 0x01	; 1
    4c8c:	8f 16       	cp	r8, r31
    4c8e:	09 f0       	breq	.+2      	; 0x4c92 <findFiles+0x13c>
    4c90:	41 c0       	rjmp	.+130    	; 0x4d14 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4c92:	89 81       	ldd	r24, Y+1	; 0x01
    4c94:	9a 81       	ldd	r25, Y+2	; 0x02
    4c96:	ab 81       	ldd	r26, Y+3	; 0x03
    4c98:	bc 81       	ldd	r27, Y+4	; 0x04
    4c9a:	80 93 c9 50 	sts	0x50C9, r24
    4c9e:	90 93 ca 50 	sts	0x50CA, r25
    4ca2:	a0 93 cb 50 	sts	0x50CB, r26
    4ca6:	b0 93 cc 50 	sts	0x50CC, r27
				appendFileLocation = i;
    4caa:	c9 01       	movw	r24, r18
    4cac:	a0 e0       	ldi	r26, 0x00	; 0
    4cae:	b0 e0       	ldi	r27, 0x00	; 0
    4cb0:	80 93 d7 23 	sts	0x23D7, r24
    4cb4:	90 93 d8 23 	sts	0x23D8, r25
    4cb8:	a0 93 d9 23 	sts	0x23D9, r26
    4cbc:	b0 93 da 23 	sts	0x23DA, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4cc0:	d6 01       	movw	r26, r12
    4cc2:	54 96       	adiw	r26, 0x14	; 20
    4cc4:	4d 91       	ld	r20, X+
    4cc6:	5c 91       	ld	r21, X
    4cc8:	55 97       	sbiw	r26, 0x15	; 21
    4cca:	60 e0       	ldi	r22, 0x00	; 0
    4ccc:	70 e0       	ldi	r23, 0x00	; 0
    4cce:	ba 01       	movw	r22, r20
    4cd0:	55 27       	eor	r21, r21
    4cd2:	44 27       	eor	r20, r20
    4cd4:	5a 96       	adiw	r26, 0x1a	; 26
    4cd6:	8d 91       	ld	r24, X+
    4cd8:	9c 91       	ld	r25, X
    4cda:	5b 97       	sbiw	r26, 0x1b	; 27
    4cdc:	a0 e0       	ldi	r26, 0x00	; 0
    4cde:	b0 e0       	ldi	r27, 0x00	; 0
    4ce0:	84 2b       	or	r24, r20
    4ce2:	95 2b       	or	r25, r21
    4ce4:	a6 2b       	or	r26, r22
    4ce6:	b7 2b       	or	r27, r23
    4ce8:	80 93 87 50 	sts	0x5087, r24
    4cec:	90 93 88 50 	sts	0x5088, r25
    4cf0:	a0 93 89 50 	sts	0x5089, r26
    4cf4:	b0 93 8a 50 	sts	0x508A, r27
				fileSize = dir->fileSize;
    4cf8:	f6 01       	movw	r30, r12
    4cfa:	84 8d       	ldd	r24, Z+28	; 0x1c
    4cfc:	95 8d       	ldd	r25, Z+29	; 0x1d
    4cfe:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4d00:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4d02:	80 93 50 40 	sts	0x4050, r24
    4d06:	90 93 51 40 	sts	0x4051, r25
    4d0a:	a0 93 52 40 	sts	0x4052, r26
    4d0e:	b0 93 53 40 	sts	0x4053, r27
			    return (dir);
    4d12:	a5 c0       	rjmp	.+330    	; 0x4e5e <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4d14:	d6 01       	movw	r26, r12
    4d16:	54 96       	adiw	r26, 0x14	; 20
    4d18:	8d 91       	ld	r24, X+
    4d1a:	9c 91       	ld	r25, X
    4d1c:	55 97       	sbiw	r26, 0x15	; 21
    4d1e:	a0 e0       	ldi	r26, 0x00	; 0
    4d20:	b0 e0       	ldi	r27, 0x00	; 0
    4d22:	3c 01       	movw	r6, r24
    4d24:	55 24       	eor	r5, r5
    4d26:	44 24       	eor	r4, r4
    4d28:	f6 01       	movw	r30, r12
    4d2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d2c:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d2e:	a0 e0       	ldi	r26, 0x00	; 0
    4d30:	b0 e0       	ldi	r27, 0x00	; 0
    4d32:	48 2a       	or	r4, r24
    4d34:	59 2a       	or	r5, r25
    4d36:	6a 2a       	or	r6, r26
    4d38:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4d3a:	85 ee       	ldi	r24, 0xE5	; 229
    4d3c:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4d3e:	69 81       	ldd	r22, Y+1	; 0x01
    4d40:	7a 81       	ldd	r23, Y+2	; 0x02
    4d42:	8b 81       	ldd	r24, Y+3	; 0x03
    4d44:	9c 81       	ldd	r25, Y+4	; 0x04
    4d46:	46 ed       	ldi	r20, 0xD6	; 214
    4d48:	51 e2       	ldi	r21, 0x21	; 33
    4d4a:	20 e0       	ldi	r18, 0x00	; 0
    4d4c:	32 e0       	ldi	r19, 0x02	; 2
    4d4e:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4d52:	d6 01       	movw	r26, r12
    4d54:	5c 96       	adiw	r26, 0x1c	; 28
    4d56:	4d 91       	ld	r20, X+
    4d58:	5d 91       	ld	r21, X+
    4d5a:	6d 91       	ld	r22, X+
    4d5c:	7c 91       	ld	r23, X
    4d5e:	5f 97       	sbiw	r26, 0x1f	; 31
    4d60:	80 e0       	ldi	r24, 0x00	; 0
    4d62:	0e 94 3d 25 	call	0x4a7a	; 0x4a7a <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4d66:	82 e0       	ldi	r24, 0x02	; 2
    4d68:	60 e0       	ldi	r22, 0x00	; 0
    4d6a:	20 e0       	ldi	r18, 0x00	; 0
    4d6c:	30 e0       	ldi	r19, 0x00	; 0
    4d6e:	a9 01       	movw	r20, r18
    4d70:	0e 94 3e 22 	call	0x447c	; 0x447c <getSetFreeCluster>
    4d74:	dc 01       	movw	r26, r24
    4d76:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4d78:	48 16       	cp	r4, r24
    4d7a:	59 06       	cpc	r5, r25
    4d7c:	6a 06       	cpc	r6, r26
    4d7e:	7b 06       	cpc	r7, r27
    4d80:	30 f4       	brcc	.+12     	; 0x4d8e <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4d82:	82 e0       	ldi	r24, 0x02	; 2
    4d84:	61 e0       	ldi	r22, 0x01	; 1
    4d86:	a3 01       	movw	r20, r6
    4d88:	92 01       	movw	r18, r4
    4d8a:	0e 94 3e 22 	call	0x447c	; 0x447c <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4d8e:	c3 01       	movw	r24, r6
    4d90:	b2 01       	movw	r22, r4
    4d92:	40 e0       	ldi	r20, 0x00	; 0
    4d94:	00 e0       	ldi	r16, 0x00	; 0
    4d96:	10 e0       	ldi	r17, 0x00	; 0
    4d98:	98 01       	movw	r18, r16
    4d9a:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
    4d9e:	6b 01       	movw	r12, r22
    4da0:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4da2:	c3 01       	movw	r24, r6
    4da4:	b2 01       	movw	r22, r4
    4da6:	41 e0       	ldi	r20, 0x01	; 1
    4da8:	00 e0       	ldi	r16, 0x00	; 0
    4daa:	10 e0       	ldi	r17, 0x00	; 0
    4dac:	98 01       	movw	r18, r16
    4dae:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4db2:	b7 ef       	ldi	r27, 0xF7	; 247
    4db4:	cb 16       	cp	r12, r27
    4db6:	bf ef       	ldi	r27, 0xFF	; 255
    4db8:	db 06       	cpc	r13, r27
    4dba:	bf ef       	ldi	r27, 0xFF	; 255
    4dbc:	eb 06       	cpc	r14, r27
    4dbe:	bf e0       	ldi	r27, 0x0F	; 15
    4dc0:	fb 06       	cpc	r15, r27
    4dc2:	08 f0       	brcs	.+2      	; 0x4dc6 <findFiles+0x270>
    4dc4:	47 c0       	rjmp	.+142    	; 0x4e54 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4dc6:	26 01       	movw	r4, r12
    4dc8:	37 01       	movw	r6, r14
    4dca:	e1 cf       	rjmp	.-62     	; 0x4d8e <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4dcc:	20 5e       	subi	r18, 0xE0	; 224
    4dce:	3f 4f       	sbci	r19, 0xFF	; 255
    4dd0:	80 91 54 40 	lds	r24, 0x4054
    4dd4:	90 91 55 40 	lds	r25, 0x4055
    4dd8:	28 17       	cp	r18, r24
    4dda:	39 07       	cpc	r19, r25
    4ddc:	08 f4       	brcc	.+2      	; 0x4de0 <findFiles+0x28a>
    4dde:	26 cf       	rjmp	.-436    	; 0x4c2c <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4de0:	08 94       	sec
    4de2:	41 1c       	adc	r4, r1
    4de4:	51 1c       	adc	r5, r1
    4de6:	61 1c       	adc	r6, r1
    4de8:	71 1c       	adc	r7, r1
    4dea:	80 91 7b 50 	lds	r24, 0x507B
    4dee:	90 91 7c 50 	lds	r25, 0x507C
    4df2:	a0 e0       	ldi	r26, 0x00	; 0
    4df4:	b0 e0       	ldi	r27, 0x00	; 0
    4df6:	48 16       	cp	r4, r24
    4df8:	59 06       	cpc	r5, r25
    4dfa:	6a 06       	cpc	r6, r26
    4dfc:	7b 06       	cpc	r7, r27
    4dfe:	08 f4       	brcc	.+2      	; 0x4e02 <findFiles+0x2ac>
    4e00:	f2 ce       	rjmp	.-540    	; 0x4be6 <findFiles+0x90>
    4e02:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4e04:	69 85       	ldd	r22, Y+9	; 0x09
    4e06:	7a 85       	ldd	r23, Y+10	; 0x0a
    4e08:	8b 85       	ldd	r24, Y+11	; 0x0b
    4e0a:	9c 85       	ldd	r25, Y+12	; 0x0c
    4e0c:	40 e0       	ldi	r20, 0x00	; 0
    4e0e:	00 e0       	ldi	r16, 0x00	; 0
    4e10:	10 e0       	ldi	r17, 0x00	; 0
    4e12:	98 01       	movw	r18, r16
    4e14:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
    4e18:	69 87       	std	Y+9, r22	; 0x09
    4e1a:	7a 87       	std	Y+10, r23	; 0x0a
    4e1c:	8b 87       	std	Y+11, r24	; 0x0b
    4e1e:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4e20:	67 3f       	cpi	r22, 0xF7	; 247
    4e22:	ef ef       	ldi	r30, 0xFF	; 255
    4e24:	7e 07       	cpc	r23, r30
    4e26:	ef ef       	ldi	r30, 0xFF	; 255
    4e28:	8e 07       	cpc	r24, r30
    4e2a:	ef e0       	ldi	r30, 0x0F	; 15
    4e2c:	9e 07       	cpc	r25, r30
    4e2e:	a8 f4       	brcc	.+42     	; 0x4e5a <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4e30:	61 15       	cp	r22, r1
    4e32:	71 05       	cpc	r23, r1
    4e34:	81 05       	cpc	r24, r1
    4e36:	91 05       	cpc	r25, r1
    4e38:	09 f0       	breq	.+2      	; 0x4e3c <findFiles+0x2e6>
    4e3a:	c0 ce       	rjmp	.-640    	; 0x4bbc <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4e3c:	00 e0       	ldi	r16, 0x00	; 0
    4e3e:	10 e0       	ldi	r17, 0x00	; 0
    4e40:	0e c0       	rjmp	.+28     	; 0x4e5e <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4e42:	00 e0       	ldi	r16, 0x00	; 0
    4e44:	10 e0       	ldi	r17, 0x00	; 0
    4e46:	0b c0       	rjmp	.+22     	; 0x4e5e <findFiles+0x308>
    4e48:	00 e0       	ldi	r16, 0x00	; 0
    4e4a:	10 e0       	ldi	r17, 0x00	; 0
    4e4c:	08 c0       	rjmp	.+16     	; 0x4e5e <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4e4e:	00 e0       	ldi	r16, 0x00	; 0
    4e50:	10 e0       	ldi	r17, 0x00	; 0
    4e52:	05 c0       	rjmp	.+10     	; 0x4e5e <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4e54:	00 e0       	ldi	r16, 0x00	; 0
    4e56:	10 e0       	ldi	r17, 0x00	; 0
    4e58:	02 c0       	rjmp	.+4      	; 0x4e5e <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4e5a:	00 e0       	ldi	r16, 0x00	; 0
    4e5c:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4e5e:	80 2f       	mov	r24, r16
    4e60:	91 2f       	mov	r25, r17
    4e62:	2c 96       	adiw	r28, 0x0c	; 12
    4e64:	cd bf       	out	0x3d, r28	; 61
    4e66:	de bf       	out	0x3e, r29	; 62
    4e68:	df 91       	pop	r29
    4e6a:	cf 91       	pop	r28
    4e6c:	1f 91       	pop	r17
    4e6e:	0f 91       	pop	r16
    4e70:	ff 90       	pop	r15
    4e72:	ef 90       	pop	r14
    4e74:	df 90       	pop	r13
    4e76:	cf 90       	pop	r12
    4e78:	bf 90       	pop	r11
    4e7a:	af 90       	pop	r10
    4e7c:	9f 90       	pop	r9
    4e7e:	8f 90       	pop	r8
    4e80:	7f 90       	pop	r7
    4e82:	6f 90       	pop	r6
    4e84:	5f 90       	pop	r5
    4e86:	4f 90       	pop	r4
    4e88:	3f 90       	pop	r3
    4e8a:	2f 90       	pop	r2
    4e8c:	08 95       	ret

00004e8e <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4e8e:	0e 94 cb 23 	call	0x4796	; 0x4796 <convertFileName>
  if(error) return;
    4e92:	88 23       	and	r24, r24
    4e94:	29 f4       	brne	.+10     	; 0x4ea0 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4e96:	82 e0       	ldi	r24, 0x02	; 2
    4e98:	63 eb       	ldi	r22, 0xB3	; 179
    4e9a:	70 e5       	ldi	r23, 0x50	; 80
    4e9c:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <findFiles>
    4ea0:	08 95       	ret

00004ea2 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4ea2:	4f 92       	push	r4
    4ea4:	5f 92       	push	r5
    4ea6:	6f 92       	push	r6
    4ea8:	7f 92       	push	r7
    4eaa:	af 92       	push	r10
    4eac:	bf 92       	push	r11
    4eae:	cf 92       	push	r12
    4eb0:	df 92       	push	r13
    4eb2:	ef 92       	push	r14
    4eb4:	ff 92       	push	r15
    4eb6:	0f 93       	push	r16
    4eb8:	1f 93       	push	r17
    4eba:	cf 93       	push	r28
    4ebc:	c8 2f       	mov	r28, r24
    4ebe:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4ec0:	0e 94 cb 23 	call	0x4796	; 0x4796 <convertFileName>
if(error) return 2;
    4ec4:	88 23       	and	r24, r24
    4ec6:	09 f0       	breq	.+2      	; 0x4eca <readFile+0x28>
    4ec8:	57 c0       	rjmp	.+174    	; 0x4f78 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4eca:	81 e0       	ldi	r24, 0x01	; 1
    4ecc:	63 eb       	ldi	r22, 0xB3	; 179
    4ece:	70 e5       	ldi	r23, 0x50	; 80
    4ed0:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <findFiles>
    4ed4:	fc 01       	movw	r30, r24
if(dir == 0) 
    4ed6:	00 97       	sbiw	r24, 0x00	; 0
    4ed8:	31 f4       	brne	.+12     	; 0x4ee6 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4eda:	81 e0       	ldi	r24, 0x01	; 1
    4edc:	cc 23       	and	r28, r28
    4ede:	09 f4       	brne	.+2      	; 0x4ee2 <readFile+0x40>
    4ee0:	4e c0       	rjmp	.+156    	; 0x4f7e <readFile+0xdc>
    4ee2:	80 e0       	ldi	r24, 0x00	; 0
    4ee4:	4c c0       	rjmp	.+152    	; 0x4f7e <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4ee6:	c1 30       	cpi	r28, 0x01	; 1
    4ee8:	09 f4       	brne	.+2      	; 0x4eec <readFile+0x4a>
    4eea:	48 c0       	rjmp	.+144    	; 0x4f7c <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4eec:	44 88       	ldd	r4, Z+20	; 0x14
    4eee:	55 88       	ldd	r5, Z+21	; 0x15
    4ef0:	66 24       	eor	r6, r6
    4ef2:	77 24       	eor	r7, r7
    4ef4:	32 01       	movw	r6, r4
    4ef6:	55 24       	eor	r5, r5
    4ef8:	44 24       	eor	r4, r4
    4efa:	82 8d       	ldd	r24, Z+26	; 0x1a
    4efc:	93 8d       	ldd	r25, Z+27	; 0x1b
    4efe:	a0 e0       	ldi	r26, 0x00	; 0
    4f00:	b0 e0       	ldi	r27, 0x00	; 0
    4f02:	48 2a       	or	r4, r24
    4f04:	59 2a       	or	r5, r25
    4f06:	6a 2a       	or	r6, r26
    4f08:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4f0a:	0f 2e       	mov	r0, r31
    4f0c:	ff ed       	ldi	r31, 0xDF	; 223
    4f0e:	af 2e       	mov	r10, r31
    4f10:	f3 e2       	ldi	r31, 0x23	; 35
    4f12:	bf 2e       	mov	r11, r31
    4f14:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4f16:	c3 01       	movw	r24, r6
    4f18:	b2 01       	movw	r22, r4
    4f1a:	0e 94 85 21 	call	0x430a	; 0x430a <getFirstSector>
    4f1e:	6b 01       	movw	r12, r22
    4f20:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4f22:	80 91 7b 50 	lds	r24, 0x507B
    4f26:	90 91 7c 50 	lds	r25, 0x507C
    4f2a:	00 97       	sbiw	r24, 0x00	; 0
    4f2c:	a1 f0       	breq	.+40     	; 0x4f56 <readFile+0xb4>
    4f2e:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4f30:	c7 01       	movw	r24, r14
    4f32:	b6 01       	movw	r22, r12
    4f34:	6c 0f       	add	r22, r28
    4f36:	71 1d       	adc	r23, r1
    4f38:	81 1d       	adc	r24, r1
    4f3a:	91 1d       	adc	r25, r1
    4f3c:	a5 01       	movw	r20, r10
    4f3e:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4f42:	cf 5f       	subi	r28, 0xFF	; 255
    4f44:	80 91 7b 50 	lds	r24, 0x507B
    4f48:	90 91 7c 50 	lds	r25, 0x507C
    4f4c:	2c 2f       	mov	r18, r28
    4f4e:	30 e0       	ldi	r19, 0x00	; 0
    4f50:	28 17       	cp	r18, r24
    4f52:	39 07       	cpc	r19, r25
    4f54:	68 f3       	brcs	.-38     	; 0x4f30 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4f56:	c3 01       	movw	r24, r6
    4f58:	b2 01       	movw	r22, r4
    4f5a:	40 e0       	ldi	r20, 0x00	; 0
    4f5c:	00 e0       	ldi	r16, 0x00	; 0
    4f5e:	10 e0       	ldi	r17, 0x00	; 0
    4f60:	98 01       	movw	r18, r16
    4f62:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
    4f66:	2b 01       	movw	r4, r22
    4f68:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4f6a:	61 15       	cp	r22, r1
    4f6c:	71 05       	cpc	r23, r1
    4f6e:	81 05       	cpc	r24, r1
    4f70:	91 05       	cpc	r25, r1
    4f72:	89 f6       	brne	.-94     	; 0x4f16 <readFile+0x74>
	  return 0;}
    4f74:	80 e0       	ldi	r24, 0x00	; 0
    4f76:	03 c0       	rjmp	.+6      	; 0x4f7e <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4f78:	82 e0       	ldi	r24, 0x02	; 2
    4f7a:	01 c0       	rjmp	.+2      	; 0x4f7e <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4f7c:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4f7e:	cf 91       	pop	r28
    4f80:	1f 91       	pop	r17
    4f82:	0f 91       	pop	r16
    4f84:	ff 90       	pop	r15
    4f86:	ef 90       	pop	r14
    4f88:	df 90       	pop	r13
    4f8a:	cf 90       	pop	r12
    4f8c:	bf 90       	pop	r11
    4f8e:	af 90       	pop	r10
    4f90:	7f 90       	pop	r7
    4f92:	6f 90       	pop	r6
    4f94:	5f 90       	pop	r5
    4f96:	4f 90       	pop	r4
    4f98:	08 95       	ret

00004f9a <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4f9a:	2f 92       	push	r2
    4f9c:	3f 92       	push	r3
    4f9e:	4f 92       	push	r4
    4fa0:	5f 92       	push	r5
    4fa2:	6f 92       	push	r6
    4fa4:	7f 92       	push	r7
    4fa6:	8f 92       	push	r8
    4fa8:	9f 92       	push	r9
    4faa:	af 92       	push	r10
    4fac:	bf 92       	push	r11
    4fae:	cf 92       	push	r12
    4fb0:	df 92       	push	r13
    4fb2:	ef 92       	push	r14
    4fb4:	ff 92       	push	r15
    4fb6:	0f 93       	push	r16
    4fb8:	1f 93       	push	r17
    4fba:	cf 93       	push	r28
    4fbc:	df 93       	push	r29
    4fbe:	cd b7       	in	r28, 0x3d	; 61
    4fc0:	de b7       	in	r29, 0x3e	; 62
    4fc2:	60 97       	sbiw	r28, 0x10	; 16
    4fc4:	cd bf       	out	0x3d, r28	; 61
    4fc6:	de bf       	out	0x3e, r29	; 62
    4fc8:	fc 01       	movw	r30, r24
    4fca:	6d 83       	std	Y+5, r22	; 0x05
    4fcc:	7e 83       	std	Y+6, r23	; 0x06
    4fce:	49 01       	movw	r8, r18
    4fd0:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4fd2:	81 e0       	ldi	r24, 0x01	; 1
    4fd4:	bf 01       	movw	r22, r30
    4fd6:	0e 94 51 27 	call	0x4ea2	; 0x4ea2 <readFile>

if(j == 1) 
    4fda:	81 30       	cpi	r24, 0x01	; 1
    4fdc:	09 f0       	breq	.+2      	; 0x4fe0 <writeFile+0x46>
    4fde:	7b c0       	rjmp	.+246    	; 0x50d6 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4fe0:	00 91 87 50 	lds	r16, 0x5087
    4fe4:	10 91 88 50 	lds	r17, 0x5088
    4fe8:	20 91 89 50 	lds	r18, 0x5089
    4fec:	30 91 8a 50 	lds	r19, 0x508A
    4ff0:	09 83       	std	Y+1, r16	; 0x01
    4ff2:	1a 83       	std	Y+2, r17	; 0x02
    4ff4:	2b 83       	std	Y+3, r18	; 0x03
    4ff6:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4ff8:	cc 24       	eor	r12, r12
    4ffa:	dd 24       	eor	r13, r13
    4ffc:	76 01       	movw	r14, r12
    4ffe:	24 01       	movw	r4, r8
    5000:	35 01       	movw	r6, r10
    5002:	48 01       	movw	r8, r16
    5004:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    5006:	c5 01       	movw	r24, r10
    5008:	b4 01       	movw	r22, r8
    500a:	40 e0       	ldi	r20, 0x00	; 0
    500c:	00 e0       	ldi	r16, 0x00	; 0
    500e:	10 e0       	ldi	r17, 0x00	; 0
    5010:	98 01       	movw	r18, r16
    5012:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
    5016:	dc 01       	movw	r26, r24
    5018:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    501a:	8f 3f       	cpi	r24, 0xFF	; 255
    501c:	1f ef       	ldi	r17, 0xFF	; 255
    501e:	91 07       	cpc	r25, r17
    5020:	1f ef       	ldi	r17, 0xFF	; 255
    5022:	a1 07       	cpc	r26, r17
    5024:	1f ef       	ldi	r17, 0xFF	; 255
    5026:	b1 07       	cpc	r27, r17
    5028:	41 f0       	breq	.+16     	; 0x503a <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    502a:	08 94       	sec
    502c:	c1 1c       	adc	r12, r1
    502e:	d1 1c       	adc	r13, r1
    5030:	e1 1c       	adc	r14, r1
    5032:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    5034:	4c 01       	movw	r8, r24
    5036:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    5038:	e6 cf       	rjmp	.-52     	; 0x5006 <writeFile+0x6c>
    503a:	89 82       	std	Y+1, r8	; 0x01
    503c:	9a 82       	std	Y+2, r9	; 0x02
    503e:	ab 82       	std	Y+3, r10	; 0x03
    5040:	bc 82       	std	Y+4, r11	; 0x04
    5042:	53 01       	movw	r10, r6
    5044:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    5046:	20 91 7b 50 	lds	r18, 0x507B
    504a:	30 91 7c 50 	lds	r19, 0x507C
    504e:	80 91 54 40 	lds	r24, 0x4054
    5052:	90 91 55 40 	lds	r25, 0x4055
    5056:	60 90 54 40 	lds	r6, 0x4054
    505a:	70 90 55 40 	lds	r7, 0x4055
    505e:	bc 01       	movw	r22, r24
    5060:	80 e0       	ldi	r24, 0x00	; 0
    5062:	90 e0       	ldi	r25, 0x00	; 0
    5064:	40 e0       	ldi	r20, 0x00	; 0
    5066:	50 e0       	ldi	r21, 0x00	; 0
    5068:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    506c:	a7 01       	movw	r20, r14
    506e:	96 01       	movw	r18, r12
    5070:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    5074:	dc 01       	movw	r26, r24
    5076:	cb 01       	movw	r24, r22
    5078:	40 91 50 40 	lds	r20, 0x4050
    507c:	50 91 51 40 	lds	r21, 0x4051
    5080:	60 91 52 40 	lds	r22, 0x4052
    5084:	70 91 53 40 	lds	r23, 0x4053
    5088:	8a 01       	movw	r16, r20
    508a:	9b 01       	movw	r18, r22
    508c:	08 1b       	sub	r16, r24
    508e:	19 0b       	sbc	r17, r25
    5090:	2a 0b       	sbc	r18, r26
    5092:	3b 0b       	sbc	r19, r27
    5094:	c9 01       	movw	r24, r18
    5096:	b8 01       	movw	r22, r16
    5098:	93 01       	movw	r18, r6
    509a:	40 e0       	ldi	r20, 0x00	; 0
    509c:	50 e0       	ldi	r21, 0x00	; 0
    509e:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    50a2:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    50a4:	69 81       	ldd	r22, Y+1	; 0x01
    50a6:	7a 81       	ldd	r23, Y+2	; 0x02
    50a8:	8b 81       	ldd	r24, Y+3	; 0x03
    50aa:	9c 81       	ldd	r25, Y+4	; 0x04
    50ac:	0e 94 85 21 	call	0x430a	; 0x430a <getFirstSector>
    50b0:	dc 01       	movw	r26, r24
    50b2:	cb 01       	movw	r24, r22
    50b4:	20 2e       	mov	r2, r16
    50b6:	33 24       	eor	r3, r3
    50b8:	28 0e       	add	r2, r24
    50ba:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    50bc:	b1 01       	movw	r22, r2
    50be:	80 e0       	ldi	r24, 0x00	; 0
    50c0:	90 e0       	ldi	r25, 0x00	; 0
    50c2:	46 ed       	ldi	r20, 0xD6	; 214
    50c4:	51 e2       	ldi	r21, 0x21	; 33
    50c6:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    50ca:	1f 86       	std	Y+15, r1	; 0x0f
    50cc:	18 8a       	std	Y+16, r1	; 0x10
    50ce:	19 86       	std	Y+9, r1	; 0x09
    50d0:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    50d2:	11 e0       	ldi	r17, 0x01	; 1
    50d4:	4c c0       	rjmp	.+152    	; 0x516e <writeFile+0x1d4>
}
else if(j == 2) 
    50d6:	82 30       	cpi	r24, 0x02	; 2
    50d8:	09 f4       	brne	.+2      	; 0x50dc <writeFile+0x142>
    50da:	0c c2       	rjmp	.+1048   	; 0x54f4 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    50dc:	82 e0       	ldi	r24, 0x02	; 2
    50de:	60 e0       	ldi	r22, 0x00	; 0
    50e0:	20 e0       	ldi	r18, 0x00	; 0
    50e2:	30 e0       	ldi	r19, 0x00	; 0
    50e4:	a9 01       	movw	r20, r18
    50e6:	0e 94 3e 22 	call	0x447c	; 0x447c <getSetFreeCluster>
  if(cluster > totalClusters)
    50ea:	00 91 59 40 	lds	r16, 0x4059
    50ee:	10 91 5a 40 	lds	r17, 0x405A
    50f2:	20 91 5b 40 	lds	r18, 0x405B
    50f6:	30 91 5c 40 	lds	r19, 0x405C
    50fa:	06 17       	cp	r16, r22
    50fc:	17 07       	cpc	r17, r23
    50fe:	28 07       	cpc	r18, r24
    5100:	39 07       	cpc	r19, r25
    5102:	40 f4       	brcc	.+16     	; 0x5114 <writeFile+0x17a>
     cluster = rootCluster;
    5104:	60 91 5f 40 	lds	r22, 0x405F
    5108:	70 91 60 40 	lds	r23, 0x4060
    510c:	80 91 61 40 	lds	r24, 0x4061
    5110:	90 91 62 40 	lds	r25, 0x4062

  cluster = searchNextFreeCluster(cluster);
    5114:	0e 94 8a 24 	call	0x4914	; 0x4914 <searchNextFreeCluster>
    5118:	69 83       	std	Y+1, r22	; 0x01
    511a:	7a 83       	std	Y+2, r23	; 0x02
    511c:	8b 83       	std	Y+3, r24	; 0x03
    511e:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    5120:	61 15       	cp	r22, r1
    5122:	71 05       	cpc	r23, r1
    5124:	81 05       	cpc	r24, r1
    5126:	91 05       	cpc	r25, r1
    5128:	09 f4       	brne	.+2      	; 0x512c <writeFile+0x192>
    512a:	e6 c1       	rjmp	.+972    	; 0x54f8 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    512c:	41 e0       	ldi	r20, 0x01	; 1
    512e:	0f ef       	ldi	r16, 0xFF	; 255
    5130:	1f ef       	ldi	r17, 0xFF	; 255
    5132:	98 01       	movw	r18, r16
    5134:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    5138:	2b 81       	ldd	r18, Y+3	; 0x03
    513a:	3c 81       	ldd	r19, Y+4	; 0x04
    513c:	29 87       	std	Y+9, r18	; 0x09
    513e:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    5140:	89 81       	ldd	r24, Y+1	; 0x01
    5142:	9a 81       	ldd	r25, Y+2	; 0x02
    5144:	8f 87       	std	Y+15, r24	; 0x0f
    5146:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    5148:	10 92 50 40 	sts	0x4050, r1
    514c:	10 92 51 40 	sts	0x4051, r1
    5150:	10 92 52 40 	sts	0x4052, r1
    5154:	10 92 53 40 	sts	0x4053, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    5158:	69 81       	ldd	r22, Y+1	; 0x01
    515a:	7a 81       	ldd	r23, Y+2	; 0x02
    515c:	8b 81       	ldd	r24, Y+3	; 0x03
    515e:	9c 81       	ldd	r25, Y+4	; 0x04
    5160:	0e 94 85 21 	call	0x430a	; 0x430a <getFirstSector>
    5164:	dc 01       	movw	r26, r24
    5166:	cb 01       	movw	r24, r22
    5168:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    516a:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    516c:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    516e:	81 14       	cp	r8, r1
    5170:	91 04       	cpc	r9, r1
    5172:	a1 04       	cpc	r10, r1
    5174:	b1 04       	cpc	r11, r1
    5176:	09 f4       	brne	.+2      	; 0x517a <writeFile+0x1e0>
    5178:	8d c0       	rjmp	.+282    	; 0x5294 <writeFile+0x2fa>
    517a:	44 24       	eor	r4, r4
    517c:	55 24       	eor	r5, r5
    517e:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    5180:	c0 2e       	mov	r12, r16
    5182:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    5184:	90 e0       	ldi	r25, 0x00	; 0
    5186:	89 16       	cp	r8, r25
    5188:	92 e0       	ldi	r25, 0x02	; 2
    518a:	99 06       	cpc	r9, r25
    518c:	90 e0       	ldi	r25, 0x00	; 0
    518e:	a9 06       	cpc	r10, r25
    5190:	90 e0       	ldi	r25, 0x00	; 0
    5192:	b9 06       	cpc	r11, r25
    5194:	88 f0       	brcs	.+34     	; 0x51b8 <writeFile+0x21e>
		 writtenData += 512;
    5196:	00 e0       	ldi	r16, 0x00	; 0
    5198:	12 e0       	ldi	r17, 0x02	; 2
    519a:	20 e0       	ldi	r18, 0x00	; 0
    519c:	30 e0       	ldi	r19, 0x00	; 0
    519e:	40 0e       	add	r4, r16
    51a0:	51 1e       	adc	r5, r17
    51a2:	62 1e       	adc	r6, r18
    51a4:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    51a6:	80 e0       	ldi	r24, 0x00	; 0
    51a8:	9e ef       	ldi	r25, 0xFE	; 254
    51aa:	af ef       	ldi	r26, 0xFF	; 255
    51ac:	bf ef       	ldi	r27, 0xFF	; 255
    51ae:	88 0e       	add	r8, r24
    51b0:	99 1e       	adc	r9, r25
    51b2:	aa 1e       	adc	r10, r26
    51b4:	bb 1e       	adc	r11, r27
    51b6:	0c c0       	rjmp	.+24     	; 0x51d0 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    51b8:	48 0c       	add	r4, r8
    51ba:	59 1c       	adc	r5, r9
    51bc:	6a 1c       	adc	r6, r10
    51be:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    51c0:	95 01       	movw	r18, r10
    51c2:	84 01       	movw	r16, r8
    51c4:	11 70       	andi	r17, 0x01	; 1
    51c6:	20 70       	andi	r18, 0x00	; 0
    51c8:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    51ca:	88 24       	eor	r8, r8
    51cc:	99 24       	eor	r9, r9
    51ce:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    51d0:	80 91 50 40 	lds	r24, 0x4050
    51d4:	90 91 51 40 	lds	r25, 0x4051
    51d8:	a0 91 52 40 	lds	r26, 0x4052
    51dc:	b0 91 53 40 	lds	r27, 0x4053
    51e0:	80 50       	subi	r24, 0x00	; 0
    51e2:	9e 4f       	sbci	r25, 0xFE	; 254
    51e4:	af 4f       	sbci	r26, 0xFF	; 255
    51e6:	bf 4f       	sbci	r27, 0xFF	; 255
    51e8:	80 93 50 40 	sts	0x4050, r24
    51ec:	90 93 51 40 	sts	0x4051, r25
    51f0:	a0 93 52 40 	sts	0x4052, r26
    51f4:	b0 93 53 40 	sts	0x4053, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    51f8:	b1 01       	movw	r22, r2
    51fa:	80 e0       	ldi	r24, 0x00	; 0
    51fc:	90 e0       	ldi	r25, 0x00	; 0
    51fe:	a2 01       	movw	r20, r4
    5200:	40 1b       	sub	r20, r16
    5202:	51 0b       	sbc	r21, r17
    5204:	ad 81       	ldd	r26, Y+5	; 0x05
    5206:	be 81       	ldd	r27, Y+6	; 0x06
    5208:	4a 0f       	add	r20, r26
    520a:	5b 1f       	adc	r21, r27
    520c:	98 01       	movw	r18, r16
    520e:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <SD_write_block>
	j++;
    5212:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    5214:	20 91 7b 50 	lds	r18, 0x507B
    5218:	30 91 7c 50 	lds	r19, 0x507C
    521c:	8c 2d       	mov	r24, r12
    521e:	90 e0       	ldi	r25, 0x00	; 0
    5220:	82 17       	cp	r24, r18
    5222:	93 07       	cpc	r25, r19
    5224:	29 f5       	brne	.+74     	; 0x5270 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5226:	69 81       	ldd	r22, Y+1	; 0x01
    5228:	7a 81       	ldd	r23, Y+2	; 0x02
    522a:	8b 81       	ldd	r24, Y+3	; 0x03
    522c:	9c 81       	ldd	r25, Y+4	; 0x04
    522e:	0e 94 8a 24 	call	0x4914	; 0x4914 <searchNextFreeCluster>
    5232:	6b 01       	movw	r12, r22
    5234:	7c 01       	movw	r14, r24
		if(cluster == 0){
    5236:	61 15       	cp	r22, r1
    5238:	71 05       	cpc	r23, r1
    523a:	81 05       	cpc	r24, r1
    523c:	91 05       	cpc	r25, r1
    523e:	09 f4       	brne	.+2      	; 0x5242 <writeFile+0x2a8>
    5240:	5d c1       	rjmp	.+698    	; 0x54fc <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    5242:	69 81       	ldd	r22, Y+1	; 0x01
    5244:	7a 81       	ldd	r23, Y+2	; 0x02
    5246:	8b 81       	ldd	r24, Y+3	; 0x03
    5248:	9c 81       	ldd	r25, Y+4	; 0x04
    524a:	41 e0       	ldi	r20, 0x01	; 1
    524c:	97 01       	movw	r18, r14
    524e:	86 01       	movw	r16, r12
    5250:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    5254:	c7 01       	movw	r24, r14
    5256:	b6 01       	movw	r22, r12
    5258:	41 e0       	ldi	r20, 0x01	; 1
    525a:	0f ef       	ldi	r16, 0xFF	; 255
    525c:	1f ef       	ldi	r17, 0xFF	; 255
    525e:	98 01       	movw	r18, r16
    5260:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5264:	c9 82       	std	Y+1, r12	; 0x01
    5266:	da 82       	std	Y+2, r13	; 0x02
    5268:	eb 82       	std	Y+3, r14	; 0x03
    526a:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    526c:	cc 24       	eor	r12, r12
    526e:	03 c0       	rjmp	.+6      	; 0x5276 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    5270:	08 94       	sec
    5272:	21 1c       	adc	r2, r1
    5274:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    5276:	82 e0       	ldi	r24, 0x02	; 2
    5278:	61 e0       	ldi	r22, 0x01	; 1
    527a:	29 81       	ldd	r18, Y+1	; 0x01
    527c:	3a 81       	ldd	r19, Y+2	; 0x02
    527e:	4b 81       	ldd	r20, Y+3	; 0x03
    5280:	5c 81       	ldd	r21, Y+4	; 0x04
    5282:	0e 94 3e 22 	call	0x447c	; 0x447c <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    5286:	81 14       	cp	r8, r1
    5288:	91 04       	cpc	r9, r1
    528a:	a1 04       	cpc	r10, r1
    528c:	b1 04       	cpc	r11, r1
    528e:	09 f0       	breq	.+2      	; 0x5292 <writeFile+0x2f8>
    5290:	79 cf       	rjmp	.-270    	; 0x5184 <writeFile+0x1ea>
    5292:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    5294:	11 23       	and	r17, r17
    5296:	09 f4       	brne	.+2      	; 0x529a <writeFile+0x300>
    5298:	3f c0       	rjmp	.+126    	; 0x5318 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    529a:	60 91 c9 50 	lds	r22, 0x50C9
    529e:	70 91 ca 50 	lds	r23, 0x50CA
    52a2:	80 91 cb 50 	lds	r24, 0x50CB
    52a6:	90 91 cc 50 	lds	r25, 0x50CC
    52aa:	06 ed       	ldi	r16, 0xD6	; 214
    52ac:	11 e2       	ldi	r17, 0x21	; 33
    52ae:	a8 01       	movw	r20, r16
    52b0:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    52b4:	e0 91 d7 23 	lds	r30, 0x23D7
    52b8:	f0 91 d8 23 	lds	r31, 0x23D8
    52bc:	e0 0f       	add	r30, r16
    52be:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    52c0:	12 8a       	std	Z+18, r1	; 0x12
    52c2:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    52c4:	80 91 50 40 	lds	r24, 0x4050
    52c8:	90 91 51 40 	lds	r25, 0x4051
    52cc:	a0 91 52 40 	lds	r26, 0x4052
    52d0:	b0 91 53 40 	lds	r27, 0x4053
    52d4:	44 8d       	ldd	r20, Z+28	; 0x1c
    52d6:	55 8d       	ldd	r21, Z+29	; 0x1d
    52d8:	66 8d       	ldd	r22, Z+30	; 0x1e
    52da:	77 8d       	ldd	r23, Z+31	; 0x1f
    52dc:	6c 01       	movw	r12, r24
    52de:	7d 01       	movw	r14, r26
    52e0:	c4 1a       	sub	r12, r20
    52e2:	d5 0a       	sbc	r13, r21
    52e4:	e6 0a       	sbc	r14, r22
    52e6:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    52e8:	84 8f       	std	Z+28, r24	; 0x1c
    52ea:	95 8f       	std	Z+29, r25	; 0x1d
    52ec:	a6 8f       	std	Z+30, r26	; 0x1e
    52ee:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    52f0:	60 91 c9 50 	lds	r22, 0x50C9
    52f4:	70 91 ca 50 	lds	r23, 0x50CA
    52f8:	80 91 cb 50 	lds	r24, 0x50CB
    52fc:	90 91 cc 50 	lds	r25, 0x50CC
    5300:	a8 01       	movw	r20, r16
    5302:	20 e0       	ldi	r18, 0x00	; 0
    5304:	32 e0       	ldi	r19, 0x02	; 2
    5306:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    530a:	81 e0       	ldi	r24, 0x01	; 1
    530c:	b7 01       	movw	r22, r14
    530e:	a6 01       	movw	r20, r12
    5310:	0e 94 3d 25 	call	0x4a7a	; 0x4a7a <freeMemoryUpdate>

 //File appended!
  return 0;
    5314:	80 e0       	ldi	r24, 0x00	; 0
    5316:	f9 c0       	rjmp	.+498    	; 0x550a <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    5318:	00 91 5f 40 	lds	r16, 0x405F
    531c:	10 91 60 40 	lds	r17, 0x4060
    5320:	20 91 61 40 	lds	r18, 0x4061
    5324:	30 91 62 40 	lds	r19, 0x4062
    5328:	0b 87       	std	Y+11, r16	; 0x0b
    532a:	1c 87       	std	Y+12, r17	; 0x0c
    532c:	2d 87       	std	Y+13, r18	; 0x0d
    532e:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    5330:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5332:	83 eb       	ldi	r24, 0xB3	; 179
    5334:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    5336:	0f 2e       	mov	r0, r31
    5338:	fb e0       	ldi	r31, 0x0B	; 11
    533a:	af 2e       	mov	r10, r31
    533c:	bb 24       	eor	r11, r11
    533e:	f0 2d       	mov	r31, r0
    5340:	a8 0e       	add	r10, r24
    5342:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    5344:	88 24       	eor	r8, r8
    5346:	68 94       	set
    5348:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    534a:	0f 2e       	mov	r0, r31
    534c:	f6 ed       	ldi	r31, 0xD6	; 214
    534e:	4f 2e       	mov	r4, r31
    5350:	f1 e2       	ldi	r31, 0x21	; 33
    5352:	5f 2e       	mov	r5, r31
    5354:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5356:	28 2e       	mov	r2, r24
    5358:	99 2e       	mov	r9, r25
    535a:	37 2c       	mov	r3, r7
    535c:	6f 84       	ldd	r6, Y+15	; 0x0f
    535e:	78 88       	ldd	r7, Y+16	; 0x10
    5360:	04 c0       	rjmp	.+8      	; 0x536a <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    5362:	cb 86       	std	Y+11, r12	; 0x0b
    5364:	dc 86       	std	Y+12, r13	; 0x0c
    5366:	ed 86       	std	Y+13, r14	; 0x0d
    5368:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    536a:	6b 85       	ldd	r22, Y+11	; 0x0b
    536c:	7c 85       	ldd	r23, Y+12	; 0x0c
    536e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5370:	9e 85       	ldd	r25, Y+14	; 0x0e
    5372:	0e 94 85 21 	call	0x430a	; 0x430a <getFirstSector>
    5376:	6d 83       	std	Y+5, r22	; 0x05
    5378:	7e 83       	std	Y+6, r23	; 0x06
    537a:	8f 83       	std	Y+7, r24	; 0x07
    537c:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    537e:	80 91 7b 50 	lds	r24, 0x507B
    5382:	90 91 7c 50 	lds	r25, 0x507C
    5386:	00 97       	sbiw	r24, 0x00	; 0
    5388:	09 f4       	brne	.+2      	; 0x538c <writeFile+0x3f2>
    538a:	77 c0       	rjmp	.+238    	; 0x547a <writeFile+0x4e0>
    538c:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    538e:	cd 80       	ldd	r12, Y+5	; 0x05
    5390:	de 80       	ldd	r13, Y+6	; 0x06
    5392:	ef 80       	ldd	r14, Y+7	; 0x07
    5394:	f8 84       	ldd	r15, Y+8	; 0x08
    5396:	19 81       	ldd	r17, Y+1	; 0x01
    5398:	c1 0e       	add	r12, r17
    539a:	d1 1c       	adc	r13, r1
    539c:	e1 1c       	adc	r14, r1
    539e:	f1 1c       	adc	r15, r1
    53a0:	c7 01       	movw	r24, r14
    53a2:	b6 01       	movw	r22, r12
    53a4:	a2 01       	movw	r20, r4
    53a6:	0e 94 95 2c 	call	0x592a	; 0x592a <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    53aa:	80 91 54 40 	lds	r24, 0x4054
    53ae:	90 91 55 40 	lds	r25, 0x4055
    53b2:	00 97       	sbiw	r24, 0x00	; 0
    53b4:	09 f4       	brne	.+2      	; 0x53b8 <writeFile+0x41e>
    53b6:	54 c0       	rjmp	.+168    	; 0x5460 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    53b8:	33 20       	and	r3, r3
    53ba:	09 f0       	breq	.+2      	; 0x53be <writeFile+0x424>
    53bc:	a1 c0       	rjmp	.+322    	; 0x5500 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    53be:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    53c0:	00 e0       	ldi	r16, 0x00	; 0
    53c2:	10 e0       	ldi	r17, 0x00	; 0
    53c4:	06 c0       	rjmp	.+12     	; 0x53d2 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    53c6:	a8 01       	movw	r20, r16
    53c8:	4a 52       	subi	r20, 0x2A	; 42
    53ca:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    53cc:	22 23       	and	r18, r18
    53ce:	09 f0       	breq	.+2      	; 0x53d2 <writeFile+0x438>
    53d0:	99 c0       	rjmp	.+306    	; 0x5504 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    53d2:	da 01       	movw	r26, r20
    53d4:	8c 91       	ld	r24, X
    53d6:	88 23       	and	r24, r24
    53d8:	21 f4       	brne	.+8      	; 0x53e2 <writeFile+0x448>
    53da:	e2 2d       	mov	r30, r2
    53dc:	f9 2d       	mov	r31, r9
    53de:	da 01       	movw	r26, r20
    53e0:	04 c0       	rjmp	.+8      	; 0x53ea <writeFile+0x450>
    53e2:	85 3e       	cpi	r24, 0xE5	; 229
    53e4:	d1 f3       	breq	.-12     	; 0x53da <writeFile+0x440>
    53e6:	23 2d       	mov	r18, r3
    53e8:	30 c0       	rjmp	.+96     	; 0x544a <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    53ea:	81 91       	ld	r24, Z+
    53ec:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    53ee:	ea 15       	cp	r30, r10
    53f0:	fb 05       	cpc	r31, r11
    53f2:	d9 f7       	brne	.-10     	; 0x53ea <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    53f4:	fa 01       	movw	r30, r20
    53f6:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    53f8:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    53fa:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    53fc:	12 8a       	std	Z+18, r1	; 0x12
    53fe:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    5400:	29 85       	ldd	r18, Y+9	; 0x09
    5402:	3a 85       	ldd	r19, Y+10	; 0x0a
    5404:	24 8b       	std	Z+20, r18	; 0x14
    5406:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    5408:	62 8e       	std	Z+26, r6	; 0x1a
    540a:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    540c:	80 91 50 40 	lds	r24, 0x4050
    5410:	90 91 51 40 	lds	r25, 0x4051
    5414:	a0 91 52 40 	lds	r26, 0x4052
    5418:	b0 91 53 40 	lds	r27, 0x4053
    541c:	84 8f       	std	Z+28, r24	; 0x1c
    541e:	95 8f       	std	Z+29, r25	; 0x1d
    5420:	a6 8f       	std	Z+30, r26	; 0x1e
    5422:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    5424:	c7 01       	movw	r24, r14
    5426:	b6 01       	movw	r22, r12
    5428:	a2 01       	movw	r20, r4
    542a:	20 e0       	ldi	r18, 0x00	; 0
    542c:	32 e0       	ldi	r19, 0x02	; 2
    542e:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    5432:	40 91 50 40 	lds	r20, 0x4050
    5436:	50 91 51 40 	lds	r21, 0x4051
    543a:	60 91 52 40 	lds	r22, 0x4052
    543e:	70 91 53 40 	lds	r23, 0x4053
    5442:	81 e0       	ldi	r24, 0x01	; 1
    5444:	0e 94 3d 25 	call	0x4a7a	; 0x4a7a <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    5448:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    544a:	00 5e       	subi	r16, 0xE0	; 224
    544c:	1f 4f       	sbci	r17, 0xFF	; 255
    544e:	80 91 54 40 	lds	r24, 0x4054
    5452:	90 91 55 40 	lds	r25, 0x4055
    5456:	08 17       	cp	r16, r24
    5458:	19 07       	cpc	r17, r25
    545a:	08 f4       	brcc	.+2      	; 0x545e <writeFile+0x4c4>
    545c:	b4 cf       	rjmp	.-152    	; 0x53c6 <writeFile+0x42c>
    545e:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    5460:	09 81       	ldd	r16, Y+1	; 0x01
    5462:	0f 5f       	subi	r16, 0xFF	; 255
    5464:	09 83       	std	Y+1, r16	; 0x01
    5466:	20 91 7b 50 	lds	r18, 0x507B
    546a:	30 91 7c 50 	lds	r19, 0x507C
    546e:	80 2f       	mov	r24, r16
    5470:	90 e0       	ldi	r25, 0x00	; 0
    5472:	82 17       	cp	r24, r18
    5474:	93 07       	cpc	r25, r19
    5476:	08 f4       	brcc	.+2      	; 0x547a <writeFile+0x4e0>
    5478:	8a cf       	rjmp	.-236    	; 0x538e <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    547a:	6b 85       	ldd	r22, Y+11	; 0x0b
    547c:	7c 85       	ldd	r23, Y+12	; 0x0c
    547e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5480:	9e 85       	ldd	r25, Y+14	; 0x0e
    5482:	40 e0       	ldi	r20, 0x00	; 0
    5484:	00 e0       	ldi	r16, 0x00	; 0
    5486:	10 e0       	ldi	r17, 0x00	; 0
    5488:	98 01       	movw	r18, r16
    548a:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
    548e:	6b 01       	movw	r12, r22
    5490:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5492:	67 3f       	cpi	r22, 0xF7	; 247
    5494:	1f ef       	ldi	r17, 0xFF	; 255
    5496:	71 07       	cpc	r23, r17
    5498:	1f ef       	ldi	r17, 0xFF	; 255
    549a:	81 07       	cpc	r24, r17
    549c:	1f e0       	ldi	r17, 0x0F	; 15
    549e:	91 07       	cpc	r25, r17
    54a0:	08 f1       	brcs	.+66     	; 0x54e4 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    54a2:	6f 3f       	cpi	r22, 0xFF	; 255
    54a4:	2f ef       	ldi	r18, 0xFF	; 255
    54a6:	72 07       	cpc	r23, r18
    54a8:	2f ef       	ldi	r18, 0xFF	; 255
    54aa:	82 07       	cpc	r24, r18
    54ac:	2f ef       	ldi	r18, 0xFF	; 255
    54ae:	92 07       	cpc	r25, r18
    54b0:	59 f5       	brne	.+86     	; 0x5508 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    54b2:	6b 85       	ldd	r22, Y+11	; 0x0b
    54b4:	7c 85       	ldd	r23, Y+12	; 0x0c
    54b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    54b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    54ba:	0e 94 8a 24 	call	0x4914	; 0x4914 <searchNextFreeCluster>
    54be:	6b 01       	movw	r12, r22
    54c0:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    54c2:	6b 85       	ldd	r22, Y+11	; 0x0b
    54c4:	7c 85       	ldd	r23, Y+12	; 0x0c
    54c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    54c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    54ca:	41 e0       	ldi	r20, 0x01	; 1
    54cc:	97 01       	movw	r18, r14
    54ce:	86 01       	movw	r16, r12
    54d0:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    54d4:	c7 01       	movw	r24, r14
    54d6:	b6 01       	movw	r22, r12
    54d8:	41 e0       	ldi	r20, 0x01	; 1
    54da:	0f ef       	ldi	r16, 0xFF	; 255
    54dc:	1f ef       	ldi	r17, 0xFF	; 255
    54de:	98 01       	movw	r18, r16
    54e0:	0e 94 ac 21 	call	0x4358	; 0x4358 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    54e4:	c1 14       	cp	r12, r1
    54e6:	d1 04       	cpc	r13, r1
    54e8:	e1 04       	cpc	r14, r1
    54ea:	f1 04       	cpc	r15, r1
    54ec:	09 f0       	breq	.+2      	; 0x54f0 <writeFile+0x556>
    54ee:	39 cf       	rjmp	.-398    	; 0x5362 <writeFile+0x3c8>
	   return 4;
    54f0:	84 e0       	ldi	r24, 0x04	; 4
    54f2:	0b c0       	rjmp	.+22     	; 0x550a <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    54f4:	81 e0       	ldi	r24, 0x01	; 1
    54f6:	09 c0       	rjmp	.+18     	; 0x550a <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    54f8:	82 e0       	ldi	r24, 0x02	; 2
    54fa:	07 c0       	rjmp	.+14     	; 0x550a <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    54fc:	82 e0       	ldi	r24, 0x02	; 2
    54fe:	05 c0       	rjmp	.+10     	; 0x550a <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    5500:	80 e0       	ldi	r24, 0x00	; 0
    5502:	03 c0       	rjmp	.+6      	; 0x550a <writeFile+0x570>
    5504:	80 e0       	ldi	r24, 0x00	; 0
    5506:	01 c0       	rjmp	.+2      	; 0x550a <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    5508:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    550a:	60 96       	adiw	r28, 0x10	; 16
    550c:	cd bf       	out	0x3d, r28	; 61
    550e:	de bf       	out	0x3e, r29	; 62
    5510:	df 91       	pop	r29
    5512:	cf 91       	pop	r28
    5514:	1f 91       	pop	r17
    5516:	0f 91       	pop	r16
    5518:	ff 90       	pop	r15
    551a:	ef 90       	pop	r14
    551c:	df 90       	pop	r13
    551e:	cf 90       	pop	r12
    5520:	bf 90       	pop	r11
    5522:	af 90       	pop	r10
    5524:	9f 90       	pop	r9
    5526:	8f 90       	pop	r8
    5528:	7f 90       	pop	r7
    552a:	6f 90       	pop	r6
    552c:	5f 90       	pop	r5
    552e:	4f 90       	pop	r4
    5530:	3f 90       	pop	r3
    5532:	2f 90       	pop	r2
    5534:	08 95       	ret

00005536 <SPI_write>:
}	

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    5536:	e0 ec       	ldi	r30, 0xC0	; 192
    5538:	f8 e0       	ldi	r31, 0x08	; 8
    553a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    553c:	82 81       	ldd	r24, Z+2	; 0x02
    553e:	88 23       	and	r24, r24
    5540:	ec f7       	brge	.-6      	; 0x553c <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    5542:	e0 ec       	ldi	r30, 0xC0	; 192
    5544:	f8 e0       	ldi	r31, 0x08	; 8
    5546:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    5548:	08 95       	ret

0000554a <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    554a:	8f 92       	push	r8
    554c:	9f 92       	push	r9
    554e:	af 92       	push	r10
    5550:	bf 92       	push	r11
    5552:	cf 92       	push	r12
    5554:	df 92       	push	r13
    5556:	ef 92       	push	r14
    5558:	ff 92       	push	r15
    555a:	0f 93       	push	r16
    555c:	1f 93       	push	r17
    555e:	cf 93       	push	r28
    5560:	df 93       	push	r29
    5562:	84 2e       	mov	r8, r20
    5564:	a5 2e       	mov	r10, r21
    5566:	c6 2e       	mov	r12, r22
    5568:	c7 2f       	mov	r28, r23
    556a:	d2 2f       	mov	r29, r18
    556c:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    556e:	80 64       	ori	r24, 0x40	; 64
    5570:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5574:	8c 2f       	mov	r24, r28
    5576:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    557a:	8c 2d       	mov	r24, r12
    557c:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    5580:	8a 2d       	mov	r24, r10
    5582:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5586:	88 2d       	mov	r24, r8
    5588:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
	SPI_write(crc);
    558c:	8d 2f       	mov	r24, r29
    558e:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
	
	for(int i=0; i<read; i++){
    5592:	10 16       	cp	r1, r16
    5594:	11 06       	cpc	r1, r17
    5596:	64 f5       	brge	.+88     	; 0x55f0 <SD_command+0xa6>
    5598:	00 e0       	ldi	r16, 0x00	; 0
    559a:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    559c:	0f 2e       	mov	r0, r31
    559e:	fd e0       	ldi	r31, 0x0D	; 13
    55a0:	cf 2e       	mov	r12, r31
    55a2:	dd 24       	eor	r13, r13
    55a4:	f0 2d       	mov	r31, r0
    55a6:	0f 2e       	mov	r0, r31
    55a8:	f6 ea       	ldi	r31, 0xA6	; 166
    55aa:	af 2e       	mov	r10, r31
    55ac:	f0 e5       	ldi	r31, 0x50	; 80
    55ae:	bf 2e       	mov	r11, r31
    55b0:	f0 2d       	mov	r31, r0
    55b2:	c8 01       	movw	r24, r16
    55b4:	b6 01       	movw	r22, r12
    55b6:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    55ba:	ec 01       	movw	r28, r24
    55bc:	8f ef       	ldi	r24, 0xFF	; 255
    55be:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    55c2:	f5 01       	movw	r30, r10
    55c4:	ec 0f       	add	r30, r28
    55c6:	fd 1f       	adc	r31, r29
    55c8:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    55ca:	80 81       	ld	r24, Z
    55cc:	8f 3f       	cpi	r24, 0xFF	; 255
    55ce:	49 f0       	breq	.+18     	; 0x55e2 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    55d0:	fe 01       	movw	r30, r28
    55d2:	ea 55       	subi	r30, 0x5A	; 90
    55d4:	ff 4a       	sbci	r31, 0xAF	; 175
    55d6:	80 81       	ld	r24, Z
    55d8:	80 93 a7 50 	sts	0x50A7, r24
			return Buffer[1];
    55dc:	80 91 a7 50 	lds	r24, 0x50A7
    55e0:	08 c0       	rjmp	.+16     	; 0x55f2 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    55e2:	0f 5f       	subi	r16, 0xFF	; 255
    55e4:	1f 4f       	sbci	r17, 0xFF	; 255
    55e6:	0e 15       	cp	r16, r14
    55e8:	1f 05       	cpc	r17, r15
    55ea:	19 f7       	brne	.-58     	; 0x55b2 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    55ec:	8f ef       	ldi	r24, 0xFF	; 255
    55ee:	01 c0       	rjmp	.+2      	; 0x55f2 <SD_command+0xa8>
    55f0:	8f ef       	ldi	r24, 0xFF	; 255
}
    55f2:	df 91       	pop	r29
    55f4:	cf 91       	pop	r28
    55f6:	1f 91       	pop	r17
    55f8:	0f 91       	pop	r16
    55fa:	ff 90       	pop	r15
    55fc:	ef 90       	pop	r14
    55fe:	df 90       	pop	r13
    5600:	cf 90       	pop	r12
    5602:	bf 90       	pop	r11
    5604:	af 90       	pop	r10
    5606:	9f 90       	pop	r9
    5608:	8f 90       	pop	r8
    560a:	08 95       	ret

0000560c <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    560c:	ff 92       	push	r15
    560e:	0f 93       	push	r16
    5610:	1f 93       	push	r17
    5612:	cf 93       	push	r28
    5614:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    5616:	81 e0       	ldi	r24, 0x01	; 1
    5618:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    561c:	81 e0       	ldi	r24, 0x01	; 1
    561e:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <Ext1Power>
    5622:	8f ef       	ldi	r24, 0xFF	; 255
    5624:	93 ec       	ldi	r25, 0xC3	; 195
    5626:	a9 e0       	ldi	r26, 0x09	; 9
    5628:	81 50       	subi	r24, 0x01	; 1
    562a:	90 40       	sbci	r25, 0x00	; 0
    562c:	a0 40       	sbci	r26, 0x00	; 0
    562e:	e1 f7       	brne	.-8      	; 0x5628 <SD_init+0x1c>
    5630:	00 c0       	rjmp	.+0      	; 0x5632 <SD_init+0x26>
    5632:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    5634:	88 e0       	ldi	r24, 0x08	; 8
    5636:	60 e0       	ldi	r22, 0x00	; 0
    5638:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    563c:	88 e0       	ldi	r24, 0x08	; 8
    563e:	60 e0       	ldi	r22, 0x00	; 0
    5640:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5644:	80 e0       	ldi	r24, 0x00	; 0
    5646:	63 e0       	ldi	r22, 0x03	; 3
    5648:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <SPIInit2>
	SPICS(TRUE);
    564c:	81 e0       	ldi	r24, 0x01	; 1
    564e:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
    5652:	8a e0       	ldi	r24, 0x0A	; 10
    5654:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    5656:	e0 ec       	ldi	r30, 0xC0	; 192
    5658:	f8 e0       	ldi	r31, 0x08	; 8
    565a:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    565c:	a2 eb       	ldi	r26, 0xB2	; 178
    565e:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    5660:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5662:	22 81       	ldd	r18, Z+2	; 0x02
    5664:	22 23       	and	r18, r18
    5666:	ec f7       	brge	.-6      	; 0x5662 <SD_init+0x56>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    5668:	23 81       	ldd	r18, Z+3	; 0x03
    566a:	2c 93       	st	X, r18
    566c:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    566e:	c1 f7       	brne	.-16     	; 0x5660 <SD_init+0x54>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    5670:	80 e0       	ldi	r24, 0x00	; 0
    5672:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    5676:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    567a:	88 e0       	ldi	r24, 0x08	; 8
    567c:	60 e0       	ldi	r22, 0x00	; 0
    567e:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5682:	80 e0       	ldi	r24, 0x00	; 0
    5684:	63 e0       	ldi	r22, 0x03	; 3
    5686:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <SPIInit2>
	SPICS(TRUE);
    568a:	81 e0       	ldi	r24, 0x01	; 1
    568c:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    5690:	cb e0       	ldi	r28, 0x0B	; 11
    5692:	d0 e0       	ldi	r29, 0x00	; 0
    5694:	02 c0       	rjmp	.+4      	; 0x569a <SD_init+0x8e>
    5696:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    5698:	69 f0       	breq	.+26     	; 0x56b4 <SD_init+0xa8>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    569a:	80 e0       	ldi	r24, 0x00	; 0
    569c:	40 e0       	ldi	r20, 0x00	; 0
    569e:	50 e0       	ldi	r21, 0x00	; 0
    56a0:	ba 01       	movw	r22, r20
    56a2:	25 e9       	ldi	r18, 0x95	; 149
    56a4:	08 e0       	ldi	r16, 0x08	; 8
    56a6:	10 e0       	ldi	r17, 0x00	; 0
    56a8:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
    56ac:	81 30       	cpi	r24, 0x01	; 1
    56ae:	99 f7       	brne	.-26     	; 0x5696 <SD_init+0x8a>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    56b0:	ff 24       	eor	r15, r15
    56b2:	02 c0       	rjmp	.+4      	; 0x56b8 <SD_init+0xac>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    56b4:	ff 24       	eor	r15, r15
    56b6:	f3 94       	inc	r15
    56b8:	8f ef       	ldi	r24, 0xFF	; 255
    56ba:	93 ec       	ldi	r25, 0xC3	; 195
    56bc:	a9 e0       	ldi	r26, 0x09	; 9
    56be:	81 50       	subi	r24, 0x01	; 1
    56c0:	90 40       	sbci	r25, 0x00	; 0
    56c2:	a0 40       	sbci	r26, 0x00	; 0
    56c4:	e1 f7       	brne	.-8      	; 0x56be <SD_init+0xb2>
    56c6:	00 c0       	rjmp	.+0      	; 0x56c8 <SD_init+0xbc>
    56c8:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    56ca:	cb e0       	ldi	r28, 0x0B	; 11
    56cc:	d0 e0       	ldi	r29, 0x00	; 0
    56ce:	02 c0       	rjmp	.+4      	; 0x56d4 <SD_init+0xc8>
    56d0:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    56d2:	69 f0       	breq	.+26     	; 0x56ee <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    56d4:	88 e0       	ldi	r24, 0x08	; 8
    56d6:	4a ea       	ldi	r20, 0xAA	; 170
    56d8:	51 e0       	ldi	r21, 0x01	; 1
    56da:	60 e0       	ldi	r22, 0x00	; 0
    56dc:	70 e0       	ldi	r23, 0x00	; 0
    56de:	27 e8       	ldi	r18, 0x87	; 135
    56e0:	08 e0       	ldi	r16, 0x08	; 8
    56e2:	10 e0       	ldi	r17, 0x00	; 0
    56e4:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
    56e8:	81 30       	cpi	r24, 0x01	; 1
    56ea:	91 f7       	brne	.-28     	; 0x56d0 <SD_init+0xc4>
    56ec:	02 c0       	rjmp	.+4      	; 0x56f2 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    56ee:	ff 24       	eor	r15, r15
    56f0:	f3 94       	inc	r15
    56f2:	c2 e0       	ldi	r28, 0x02	; 2
    56f4:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    56f6:	06 ea       	ldi	r16, 0xA6	; 166
    56f8:	10 e5       	ldi	r17, 0x50	; 80
    56fa:	8f ef       	ldi	r24, 0xFF	; 255
    56fc:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5700:	f8 01       	movw	r30, r16
    5702:	ec 0f       	add	r30, r28
    5704:	fd 1f       	adc	r31, r29
    5706:	80 83       	st	Z, r24
    5708:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    570a:	c6 30       	cpi	r28, 0x06	; 6
    570c:	d1 05       	cpc	r29, r1
    570e:	a9 f7       	brne	.-22     	; 0x56fa <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    5710:	80 91 aa 50 	lds	r24, 0x50AA
    5714:	81 30       	cpi	r24, 0x01	; 1
    5716:	29 f4       	brne	.+10     	; 0x5722 <SD_init+0x116>
    5718:	80 91 ab 50 	lds	r24, 0x50AB
    571c:	8a 3a       	cpi	r24, 0xAA	; 170
    571e:	21 f4       	brne	.+8      	; 0x5728 <SD_init+0x11c>
    5720:	05 c0       	rjmp	.+10     	; 0x572c <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    5722:	ff 24       	eor	r15, r15
    5724:	f3 94       	inc	r15
    5726:	02 c0       	rjmp	.+4      	; 0x572c <SD_init+0x120>
    5728:	ff 24       	eor	r15, r15
    572a:	f3 94       	inc	r15
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    572c:	c7 ea       	ldi	r28, 0xA7	; 167
    572e:	d0 e5       	ldi	r29, 0x50	; 80
		//broken card or voltage out of operating range bounds
		errorCode = 1;
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    5730:	87 e3       	ldi	r24, 0x37	; 55
    5732:	40 e0       	ldi	r20, 0x00	; 0
    5734:	50 e0       	ldi	r21, 0x00	; 0
    5736:	ba 01       	movw	r22, r20
    5738:	2f ef       	ldi	r18, 0xFF	; 255
    573a:	08 e0       	ldi	r16, 0x08	; 8
    573c:	10 e0       	ldi	r17, 0x00	; 0
    573e:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    5742:	81 e0       	ldi	r24, 0x01	; 1
    5744:	40 e0       	ldi	r20, 0x00	; 0
    5746:	50 e0       	ldi	r21, 0x00	; 0
    5748:	60 e0       	ldi	r22, 0x00	; 0
    574a:	70 e4       	ldi	r23, 0x40	; 64
    574c:	2f ef       	ldi	r18, 0xFF	; 255
    574e:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
	} while(Buffer[1]!= 0x00);
    5752:	88 81       	ld	r24, Y
    5754:	88 23       	and	r24, r24
    5756:	61 f7       	brne	.-40     	; 0x5730 <SD_init+0x124>
    5758:	cb e0       	ldi	r28, 0x0B	; 11
    575a:	d0 e0       	ldi	r29, 0x00	; 0
    575c:	02 c0       	rjmp	.+4      	; 0x5762 <SD_init+0x156>
    575e:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    5760:	61 f0       	breq	.+24     	; 0x577a <SD_init+0x16e>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    5762:	8a e3       	ldi	r24, 0x3A	; 58
    5764:	40 e0       	ldi	r20, 0x00	; 0
    5766:	50 e0       	ldi	r21, 0x00	; 0
    5768:	ba 01       	movw	r22, r20
    576a:	2f ef       	ldi	r18, 0xFF	; 255
    576c:	08 e0       	ldi	r16, 0x08	; 8
    576e:	10 e0       	ldi	r17, 0x00	; 0
    5770:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
    5774:	88 23       	and	r24, r24
    5776:	99 f7       	brne	.-26     	; 0x575e <SD_init+0x152>
    5778:	02 c0       	rjmp	.+4      	; 0x577e <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    577a:	ff 24       	eor	r15, r15
    577c:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    577e:	c0 e0       	ldi	r28, 0x00	; 0
    5780:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5782:	06 ea       	ldi	r16, 0xA6	; 166
    5784:	10 e5       	ldi	r17, 0x50	; 80
    5786:	8f ef       	ldi	r24, 0xFF	; 255
    5788:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    578c:	f8 01       	movw	r30, r16
    578e:	ec 0f       	add	r30, r28
    5790:	fd 1f       	adc	r31, r29
    5792:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5794:	21 96       	adiw	r28, 0x01	; 1
    5796:	c4 30       	cpi	r28, 0x04	; 4
    5798:	d1 05       	cpc	r29, r1
    579a:	a9 f7       	brne	.-22     	; 0x5786 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    579c:	80 91 a6 50 	lds	r24, 0x50A6
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    57a0:	80 e0       	ldi	r24, 0x00	; 0
    57a2:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    57a6:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    57aa:	88 e0       	ldi	r24, 0x08	; 8
    57ac:	60 e0       	ldi	r22, 0x00	; 0
    57ae:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
	return errorCode;	
}	
    57b2:	8f 2d       	mov	r24, r15
    57b4:	df 91       	pop	r29
    57b6:	cf 91       	pop	r28
    57b8:	1f 91       	pop	r17
    57ba:	0f 91       	pop	r16
    57bc:	ff 90       	pop	r15
    57be:	08 95       	ret

000057c0 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    57c0:	6f 92       	push	r6
    57c2:	7f 92       	push	r7
    57c4:	8f 92       	push	r8
    57c6:	9f 92       	push	r9
    57c8:	af 92       	push	r10
    57ca:	bf 92       	push	r11
    57cc:	cf 92       	push	r12
    57ce:	df 92       	push	r13
    57d0:	ef 92       	push	r14
    57d2:	ff 92       	push	r15
    57d4:	0f 93       	push	r16
    57d6:	1f 93       	push	r17
    57d8:	cf 93       	push	r28
    57da:	df 93       	push	r29
    57dc:	4b 01       	movw	r8, r22
    57de:	5c 01       	movw	r10, r24
    57e0:	74 2e       	mov	r7, r20
    57e2:	65 2e       	mov	r6, r21
    57e4:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    57e6:	88 e0       	ldi	r24, 0x08	; 8
    57e8:	60 e0       	ldi	r22, 0x00	; 0
    57ea:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    57ee:	80 e0       	ldi	r24, 0x00	; 0
    57f0:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    57f4:	81 e0       	ldi	r24, 0x01	; 1
    57f6:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    57fa:	80 e0       	ldi	r24, 0x00	; 0
    57fc:	92 e0       	ldi	r25, 0x02	; 2
    57fe:	7c 01       	movw	r14, r24
    5800:	ec 18       	sub	r14, r12
    5802:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5804:	80 e0       	ldi	r24, 0x00	; 0
    5806:	e8 16       	cp	r14, r24
    5808:	82 e0       	ldi	r24, 0x02	; 2
    580a:	f8 06       	cpc	r15, r24
    580c:	11 f4       	brne	.+4      	; 0x5812 <SD_write_block+0x52>
    580e:	ee 24       	eor	r14, r14
    5810:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5812:	cb e0       	ldi	r28, 0x0B	; 11
    5814:	d0 e0       	ldi	r29, 0x00	; 0
    5816:	03 c0       	rjmp	.+6      	; 0x581e <SD_write_block+0x5e>
    5818:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    581a:	09 f4       	brne	.+2      	; 0x581e <SD_write_block+0x5e>
    581c:	ff cf       	rjmp	.-2      	; 0x581c <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    581e:	88 e1       	ldi	r24, 0x18	; 24
    5820:	b5 01       	movw	r22, r10
    5822:	a4 01       	movw	r20, r8
    5824:	2f ef       	ldi	r18, 0xFF	; 255
    5826:	08 e0       	ldi	r16, 0x08	; 8
    5828:	10 e0       	ldi	r17, 0x00	; 0
    582a:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
    582e:	88 23       	and	r24, r24
    5830:	99 f7       	brne	.-26     	; 0x5818 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    5832:	8f ef       	ldi	r24, 0xFF	; 255
    5834:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5838:	80 93 a6 50 	sts	0x50A6, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    583c:	8e ef       	ldi	r24, 0xFE	; 254
    583e:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5842:	1c 14       	cp	r1, r12
    5844:	1d 04       	cpc	r1, r13
    5846:	bc f4       	brge	.+46     	; 0x5876 <SD_write_block+0xb6>
    5848:	87 2c       	mov	r8, r7
    584a:	96 2c       	mov	r9, r6
    584c:	00 e0       	ldi	r16, 0x00	; 0
    584e:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    5850:	c8 01       	movw	r24, r16
    5852:	6d e0       	ldi	r22, 0x0D	; 13
    5854:	70 e0       	ldi	r23, 0x00	; 0
    5856:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    585a:	ec 01       	movw	r28, r24
    585c:	f4 01       	movw	r30, r8
    585e:	81 91       	ld	r24, Z+
    5860:	4f 01       	movw	r8, r30
    5862:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5866:	ca 55       	subi	r28, 0x5A	; 90
    5868:	df 4a       	sbci	r29, 0xAF	; 175
    586a:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    586c:	0f 5f       	subi	r16, 0xFF	; 255
    586e:	1f 4f       	sbci	r17, 0xFF	; 255
    5870:	0c 15       	cp	r16, r12
    5872:	1d 05       	cpc	r17, r13
    5874:	69 f7       	brne	.-38     	; 0x5850 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5876:	1e 14       	cp	r1, r14
    5878:	1f 04       	cpc	r1, r15
    587a:	ec f4       	brge	.+58     	; 0x58b6 <SD_write_block+0xf6>
    587c:	00 e0       	ldi	r16, 0x00	; 0
    587e:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    5880:	0f 2e       	mov	r0, r31
    5882:	fd e0       	ldi	r31, 0x0D	; 13
    5884:	cf 2e       	mov	r12, r31
    5886:	dd 24       	eor	r13, r13
    5888:	f0 2d       	mov	r31, r0
    588a:	0f 2e       	mov	r0, r31
    588c:	f6 ea       	ldi	r31, 0xA6	; 166
    588e:	8f 2e       	mov	r8, r31
    5890:	f0 e5       	ldi	r31, 0x50	; 80
    5892:	9f 2e       	mov	r9, r31
    5894:	f0 2d       	mov	r31, r0
    5896:	c8 01       	movw	r24, r16
    5898:	b6 01       	movw	r22, r12
    589a:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    589e:	ec 01       	movw	r28, r24
    58a0:	80 e0       	ldi	r24, 0x00	; 0
    58a2:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    58a6:	c8 0d       	add	r28, r8
    58a8:	d9 1d       	adc	r29, r9
    58aa:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    58ac:	0f 5f       	subi	r16, 0xFF	; 255
    58ae:	1f 4f       	sbci	r17, 0xFF	; 255
    58b0:	0e 15       	cp	r16, r14
    58b2:	1f 05       	cpc	r17, r15
    58b4:	81 f7       	brne	.-32     	; 0x5896 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    58b6:	8f ef       	ldi	r24, 0xFF	; 255
    58b8:	80 93 a6 50 	sts	0x50A6, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    58bc:	c0 e0       	ldi	r28, 0x00	; 0
    58be:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    58c0:	06 ea       	ldi	r16, 0xA6	; 166
    58c2:	10 e5       	ldi	r17, 0x50	; 80
    58c4:	8f ef       	ldi	r24, 0xFF	; 255
    58c6:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    58ca:	f8 01       	movw	r30, r16
    58cc:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    58ce:	21 96       	adiw	r28, 0x01	; 1
    58d0:	c2 30       	cpi	r28, 0x02	; 2
    58d2:	d1 05       	cpc	r29, r1
    58d4:	bc f3       	brlt	.-18     	; 0x58c4 <SD_write_block+0x104>
    58d6:	80 81       	ld	r24, Z
    58d8:	8f 3f       	cpi	r24, 0xFF	; 255
    58da:	a1 f3       	breq	.-24     	; 0x58c4 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    58dc:	80 91 a6 50 	lds	r24, 0x50A6
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    58e0:	80 91 a6 50 	lds	r24, 0x50A6
    58e4:	8f 3f       	cpi	r24, 0xFF	; 255
    58e6:	49 f0       	breq	.+18     	; 0x58fa <SD_write_block+0x13a>
    58e8:	c6 ea       	ldi	r28, 0xA6	; 166
    58ea:	d0 e5       	ldi	r29, 0x50	; 80
    58ec:	8f ef       	ldi	r24, 0xFF	; 255
    58ee:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    58f2:	88 83       	st	Y, r24
    58f4:	88 81       	ld	r24, Y
    58f6:	8f 3f       	cpi	r24, 0xFF	; 255
    58f8:	c9 f7       	brne	.-14     	; 0x58ec <SD_write_block+0x12c>
	SPICS(FALSE);
    58fa:	80 e0       	ldi	r24, 0x00	; 0
    58fc:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    5900:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    5904:	88 e0       	ldi	r24, 0x08	; 8
    5906:	60 e0       	ldi	r22, 0x00	; 0
    5908:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
}
    590c:	df 91       	pop	r29
    590e:	cf 91       	pop	r28
    5910:	1f 91       	pop	r17
    5912:	0f 91       	pop	r16
    5914:	ff 90       	pop	r15
    5916:	ef 90       	pop	r14
    5918:	df 90       	pop	r13
    591a:	cf 90       	pop	r12
    591c:	bf 90       	pop	r11
    591e:	af 90       	pop	r10
    5920:	9f 90       	pop	r9
    5922:	8f 90       	pop	r8
    5924:	7f 90       	pop	r7
    5926:	6f 90       	pop	r6
    5928:	08 95       	ret

0000592a <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    592a:	af 92       	push	r10
    592c:	bf 92       	push	r11
    592e:	cf 92       	push	r12
    5930:	df 92       	push	r13
    5932:	ef 92       	push	r14
    5934:	ff 92       	push	r15
    5936:	0f 93       	push	r16
    5938:	1f 93       	push	r17
    593a:	cf 93       	push	r28
    593c:	df 93       	push	r29
    593e:	6b 01       	movw	r12, r22
    5940:	7c 01       	movw	r14, r24
    5942:	b4 2e       	mov	r11, r20
    5944:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5946:	88 e0       	ldi	r24, 0x08	; 8
    5948:	60 e0       	ldi	r22, 0x00	; 0
    594a:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    594e:	80 e0       	ldi	r24, 0x00	; 0
    5950:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    5954:	81 e0       	ldi	r24, 0x01	; 1
    5956:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    595a:	cb e0       	ldi	r28, 0x0B	; 11
    595c:	d0 e0       	ldi	r29, 0x00	; 0
    595e:	03 c0       	rjmp	.+6      	; 0x5966 <SD_read_block+0x3c>
    5960:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5962:	09 f4       	brne	.+2      	; 0x5966 <SD_read_block+0x3c>
    5964:	ff cf       	rjmp	.-2      	; 0x5964 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5966:	81 e1       	ldi	r24, 0x11	; 17
    5968:	b7 01       	movw	r22, r14
    596a:	a6 01       	movw	r20, r12
    596c:	2f ef       	ldi	r18, 0xFF	; 255
    596e:	08 e0       	ldi	r16, 0x08	; 8
    5970:	10 e0       	ldi	r17, 0x00	; 0
    5972:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
    5976:	88 23       	and	r24, r24
    5978:	99 f7       	brne	.-26     	; 0x5960 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    597a:	80 91 a6 50 	lds	r24, 0x50A6
    597e:	8e 3f       	cpi	r24, 0xFE	; 254
    5980:	49 f0       	breq	.+18     	; 0x5994 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5982:	c6 ea       	ldi	r28, 0xA6	; 166
    5984:	d0 e5       	ldi	r29, 0x50	; 80
    5986:	8f ef       	ldi	r24, 0xFF	; 255
    5988:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    598c:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    598e:	88 81       	ld	r24, Y
    5990:	8e 3f       	cpi	r24, 0xFE	; 254
    5992:	c9 f7       	brne	.-14     	; 0x5986 <SD_read_block+0x5c>
    5994:	0b 2d       	mov	r16, r11
    5996:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5998:	c0 e0       	ldi	r28, 0x00	; 0
    599a:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    599c:	8f ef       	ldi	r24, 0xFF	; 255
    599e:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    59a2:	f8 01       	movw	r30, r16
    59a4:	81 93       	st	Z+, r24
    59a6:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    59a8:	21 96       	adiw	r28, 0x01	; 1
    59aa:	f2 e0       	ldi	r31, 0x02	; 2
    59ac:	c0 30       	cpi	r28, 0x00	; 0
    59ae:	df 07       	cpc	r29, r31
    59b0:	a9 f7       	brne	.-22     	; 0x599c <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    59b2:	10 92 b2 50 	sts	0x50B2, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    59b6:	80 91 b2 50 	lds	r24, 0x50B2
    59ba:	8f 3f       	cpi	r24, 0xFF	; 255
    59bc:	49 f0       	breq	.+18     	; 0x59d0 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    59be:	c2 eb       	ldi	r28, 0xB2	; 178
    59c0:	d0 e5       	ldi	r29, 0x50	; 80
    59c2:	8f ef       	ldi	r24, 0xFF	; 255
    59c4:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    59c8:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    59ca:	88 81       	ld	r24, Y
    59cc:	8f 3f       	cpi	r24, 0xFF	; 255
    59ce:	c9 f7       	brne	.-14     	; 0x59c2 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    59d0:	80 e0       	ldi	r24, 0x00	; 0
    59d2:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    59d6:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    59da:	88 e0       	ldi	r24, 0x08	; 8
    59dc:	60 e0       	ldi	r22, 0x00	; 0
    59de:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
}
    59e2:	df 91       	pop	r29
    59e4:	cf 91       	pop	r28
    59e6:	1f 91       	pop	r17
    59e8:	0f 91       	pop	r16
    59ea:	ff 90       	pop	r15
    59ec:	ef 90       	pop	r14
    59ee:	df 90       	pop	r13
    59f0:	cf 90       	pop	r12
    59f2:	bf 90       	pop	r11
    59f4:	af 90       	pop	r10
    59f6:	08 95       	ret

000059f8 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    59f8:	2f 92       	push	r2
    59fa:	3f 92       	push	r3
    59fc:	4f 92       	push	r4
    59fe:	5f 92       	push	r5
    5a00:	6f 92       	push	r6
    5a02:	7f 92       	push	r7
    5a04:	8f 92       	push	r8
    5a06:	9f 92       	push	r9
    5a08:	af 92       	push	r10
    5a0a:	bf 92       	push	r11
    5a0c:	cf 92       	push	r12
    5a0e:	df 92       	push	r13
    5a10:	ef 92       	push	r14
    5a12:	ff 92       	push	r15
    5a14:	0f 93       	push	r16
    5a16:	1f 93       	push	r17
    5a18:	cf 93       	push	r28
    5a1a:	df 93       	push	r29
    5a1c:	cd b7       	in	r28, 0x3d	; 61
    5a1e:	de b7       	in	r29, 0x3e	; 62
    5a20:	2a 97       	sbiw	r28, 0x0a	; 10
    5a22:	cd bf       	out	0x3d, r28	; 61
    5a24:	de bf       	out	0x3e, r29	; 62
    5a26:	6b 01       	movw	r12, r22
    5a28:	7c 01       	movw	r14, r24
    5a2a:	4f 83       	std	Y+7, r20	; 0x07
    5a2c:	58 87       	std	Y+8, r21	; 0x08
    5a2e:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5a30:	88 e0       	ldi	r24, 0x08	; 8
    5a32:	60 e0       	ldi	r22, 0x00	; 0
    5a34:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5a38:	80 e0       	ldi	r24, 0x00	; 0
    5a3a:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    5a3e:	81 e0       	ldi	r24, 0x01	; 1
    5a40:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5a44:	c8 01       	movw	r24, r16
    5a46:	11 23       	and	r17, r17
    5a48:	14 f4       	brge	.+4      	; 0x5a4e <SD_write_multiple_blocks+0x56>
    5a4a:	81 50       	subi	r24, 0x01	; 1
    5a4c:	9e 4f       	sbci	r25, 0xFE	; 254
    5a4e:	9c 01       	movw	r18, r24
    5a50:	23 2f       	mov	r18, r19
    5a52:	33 0f       	add	r19, r19
    5a54:	33 0b       	sbc	r19, r19
    5a56:	25 95       	asr	r18
    5a58:	2b 83       	std	Y+3, r18	; 0x03
    5a5a:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5a5c:	20 e0       	ldi	r18, 0x00	; 0
    5a5e:	32 e0       	ldi	r19, 0x02	; 2
    5a60:	c8 01       	movw	r24, r16
    5a62:	b9 01       	movw	r22, r18
    5a64:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    5a68:	29 01       	movw	r4, r18
    5a6a:	48 1a       	sub	r4, r24
    5a6c:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5a6e:	30 e0       	ldi	r19, 0x00	; 0
    5a70:	43 16       	cp	r4, r19
    5a72:	32 e0       	ldi	r19, 0x02	; 2
    5a74:	53 06       	cpc	r5, r19
    5a76:	31 f0       	breq	.+12     	; 0x5a84 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5a78:	8b 81       	ldd	r24, Y+3	; 0x03
    5a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    5a7c:	01 96       	adiw	r24, 0x01	; 1
    5a7e:	8b 83       	std	Y+3, r24	; 0x03
    5a80:	9c 83       	std	Y+4, r25	; 0x04
    5a82:	02 c0       	rjmp	.+4      	; 0x5a88 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5a84:	44 24       	eor	r4, r4
    5a86:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5a88:	89 e1       	ldi	r24, 0x19	; 25
    5a8a:	b7 01       	movw	r22, r14
    5a8c:	a6 01       	movw	r20, r12
    5a8e:	2f ef       	ldi	r18, 0xFF	; 255
    5a90:	08 e0       	ldi	r16, 0x08	; 8
    5a92:	10 e0       	ldi	r17, 0x00	; 0
    5a94:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
    5a98:	88 23       	and	r24, r24
    5a9a:	b1 f7       	brne	.-20     	; 0x5a88 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    5a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    5aa0:	1e 16       	cp	r1, r30
    5aa2:	1f 06       	cpc	r1, r31
    5aa4:	0c f0       	brlt	.+2      	; 0x5aa8 <SD_write_multiple_blocks+0xb0>
    5aa6:	ac c0       	rjmp	.+344    	; 0x5c00 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5aa8:	31 97       	sbiw	r30, 0x01	; 1
    5aaa:	ed 83       	std	Y+5, r30	; 0x05
    5aac:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5aae:	9f 01       	movw	r18, r30
    5ab0:	32 2f       	mov	r19, r18
    5ab2:	22 27       	eor	r18, r18
    5ab4:	33 0f       	add	r19, r19
    5ab6:	8f 81       	ldd	r24, Y+7	; 0x07
    5ab8:	98 85       	ldd	r25, Y+8	; 0x08
    5aba:	89 83       	std	Y+1, r24	; 0x01
    5abc:	9a 83       	std	Y+2, r25	; 0x02
    5abe:	66 24       	eor	r6, r6
    5ac0:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5ac2:	0f 2e       	mov	r0, r31
    5ac4:	f7 ea       	ldi	r31, 0xA7	; 167
    5ac6:	8f 2e       	mov	r8, r31
    5ac8:	f0 e5       	ldi	r31, 0x50	; 80
    5aca:	9f 2e       	mov	r9, r31
    5acc:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5ace:	0f 2e       	mov	r0, r31
    5ad0:	fc e0       	ldi	r31, 0x0C	; 12
    5ad2:	cf 2e       	mov	r12, r31
    5ad4:	dd 24       	eor	r13, r13
    5ad6:	f0 2d       	mov	r31, r0
    5ad8:	0f 2e       	mov	r0, r31
    5ada:	f6 ea       	ldi	r31, 0xA6	; 166
    5adc:	af 2e       	mov	r10, r31
    5ade:	f0 e5       	ldi	r31, 0x50	; 80
    5ae0:	bf 2e       	mov	r11, r31
    5ae2:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5ae4:	80 e0       	ldi	r24, 0x00	; 0
    5ae6:	92 e0       	ldi	r25, 0x02	; 2
    5ae8:	1c 01       	movw	r2, r24
    5aea:	24 18       	sub	r2, r4
    5aec:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5aee:	ef 81       	ldd	r30, Y+7	; 0x07
    5af0:	f8 85       	ldd	r31, Y+8	; 0x08
    5af2:	e2 0f       	add	r30, r18
    5af4:	f3 1f       	adc	r31, r19
    5af6:	ef 83       	std	Y+7, r30	; 0x07
    5af8:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5afa:	8f ef       	ldi	r24, 0xFF	; 255
    5afc:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5b00:	f4 01       	movw	r30, r8
    5b02:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    5b04:	8c ef       	ldi	r24, 0xFC	; 252
    5b06:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5b0a:	f4 01       	movw	r30, r8
    5b0c:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    5b0e:	2d 81       	ldd	r18, Y+5	; 0x05
    5b10:	3e 81       	ldd	r19, Y+6	; 0x06
    5b12:	26 15       	cp	r18, r6
    5b14:	37 05       	cpc	r19, r7
    5b16:	09 f0       	breq	.+2      	; 0x5b1a <SD_write_multiple_blocks+0x122>
    5b18:	41 c0       	rjmp	.+130    	; 0x5b9c <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5b1a:	12 14       	cp	r1, r2
    5b1c:	13 04       	cpc	r1, r3
    5b1e:	cc f4       	brge	.+50     	; 0x5b52 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5b20:	ef 80       	ldd	r14, Y+7	; 0x07
    5b22:	f8 84       	ldd	r15, Y+8	; 0x08
    5b24:	00 e0       	ldi	r16, 0x00	; 0
    5b26:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5b28:	c8 01       	movw	r24, r16
    5b2a:	b6 01       	movw	r22, r12
    5b2c:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    5b30:	89 87       	std	Y+9, r24	; 0x09
    5b32:	9a 87       	std	Y+10, r25	; 0x0a
    5b34:	f7 01       	movw	r30, r14
    5b36:	81 91       	ld	r24, Z+
    5b38:	7f 01       	movw	r14, r30
    5b3a:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5b3e:	e9 85       	ldd	r30, Y+9	; 0x09
    5b40:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b42:	ea 0d       	add	r30, r10
    5b44:	fb 1d       	adc	r31, r11
    5b46:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5b48:	0f 5f       	subi	r16, 0xFF	; 255
    5b4a:	1f 4f       	sbci	r17, 0xFF	; 255
    5b4c:	02 15       	cp	r16, r2
    5b4e:	13 05       	cpc	r17, r3
    5b50:	59 f7       	brne	.-42     	; 0x5b28 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5b52:	14 14       	cp	r1, r4
    5b54:	15 04       	cpc	r1, r5
    5b56:	9c f4       	brge	.+38     	; 0x5b7e <SD_write_multiple_blocks+0x186>
    5b58:	00 e0       	ldi	r16, 0x00	; 0
    5b5a:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5b5c:	c8 01       	movw	r24, r16
    5b5e:	b6 01       	movw	r22, r12
    5b60:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    5b64:	7c 01       	movw	r14, r24
    5b66:	80 e0       	ldi	r24, 0x00	; 0
    5b68:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5b6c:	f5 01       	movw	r30, r10
    5b6e:	ee 0d       	add	r30, r14
    5b70:	ff 1d       	adc	r31, r15
    5b72:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5b74:	0f 5f       	subi	r16, 0xFF	; 255
    5b76:	1f 4f       	sbci	r17, 0xFF	; 255
    5b78:	04 15       	cp	r16, r4
    5b7a:	15 05       	cpc	r17, r5
    5b7c:	79 f7       	brne	.-34     	; 0x5b5c <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5b7e:	8f ef       	ldi	r24, 0xFF	; 255
    5b80:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5b84:	f4 01       	movw	r30, r8
    5b86:	80 83       	st	Z, r24
    5b88:	8f ef       	ldi	r24, 0xFF	; 255
    5b8a:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5b8e:	f4 01       	movw	r30, r8
    5b90:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5b92:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5b94:	80 81       	ld	r24, Z
    5b96:	8f 3f       	cpi	r24, 0xFF	; 255
    5b98:	e1 f4       	brne	.+56     	; 0x5bd2 <SD_write_multiple_blocks+0x1da>
    5b9a:	23 c0       	rjmp	.+70     	; 0x5be2 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5b9c:	e9 80       	ldd	r14, Y+1	; 0x01
    5b9e:	fa 80       	ldd	r15, Y+2	; 0x02
    5ba0:	00 e0       	ldi	r16, 0x00	; 0
    5ba2:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5ba4:	c8 01       	movw	r24, r16
    5ba6:	b6 01       	movw	r22, r12
    5ba8:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <__divmodhi4>
    5bac:	89 87       	std	Y+9, r24	; 0x09
    5bae:	9a 87       	std	Y+10, r25	; 0x0a
    5bb0:	f7 01       	movw	r30, r14
    5bb2:	81 91       	ld	r24, Z+
    5bb4:	7f 01       	movw	r14, r30
    5bb6:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5bba:	e9 85       	ldd	r30, Y+9	; 0x09
    5bbc:	fa 85       	ldd	r31, Y+10	; 0x0a
    5bbe:	ea 0d       	add	r30, r10
    5bc0:	fb 1d       	adc	r31, r11
    5bc2:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5bc4:	0f 5f       	subi	r16, 0xFF	; 255
    5bc6:	1f 4f       	sbci	r17, 0xFF	; 255
    5bc8:	f2 e0       	ldi	r31, 0x02	; 2
    5bca:	00 30       	cpi	r16, 0x00	; 0
    5bcc:	1f 07       	cpc	r17, r31
    5bce:	51 f7       	brne	.-44     	; 0x5ba4 <SD_write_multiple_blocks+0x1ac>
    5bd0:	d6 cf       	rjmp	.-84     	; 0x5b7e <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5bd2:	8f ef       	ldi	r24, 0xFF	; 255
    5bd4:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5bd8:	f4 01       	movw	r30, r8
    5bda:	80 83       	st	Z, r24
    5bdc:	80 81       	ld	r24, Z
    5bde:	8f 3f       	cpi	r24, 0xFF	; 255
    5be0:	c1 f7       	brne	.-16     	; 0x5bd2 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    5be2:	08 94       	sec
    5be4:	61 1c       	adc	r6, r1
    5be6:	71 1c       	adc	r7, r1
    5be8:	29 81       	ldd	r18, Y+1	; 0x01
    5bea:	3a 81       	ldd	r19, Y+2	; 0x02
    5bec:	20 50       	subi	r18, 0x00	; 0
    5bee:	3e 4f       	sbci	r19, 0xFE	; 254
    5bf0:	29 83       	std	Y+1, r18	; 0x01
    5bf2:	3a 83       	std	Y+2, r19	; 0x02
    5bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    5bf8:	68 16       	cp	r6, r24
    5bfa:	79 06       	cpc	r7, r25
    5bfc:	09 f0       	breq	.+2      	; 0x5c00 <SD_write_multiple_blocks+0x208>
    5bfe:	7d cf       	rjmp	.-262    	; 0x5afa <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5c00:	ee 24       	eor	r14, r14
    5c02:	ff 24       	eor	r15, r15
    5c04:	68 94       	set
    5c06:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5c08:	07 ea       	ldi	r16, 0xA7	; 167
    5c0a:	10 e5       	ldi	r17, 0x50	; 80
    5c0c:	8f ef       	ldi	r24, 0xFF	; 255
    5c0e:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5c12:	f8 01       	movw	r30, r16
    5c14:	80 83       	st	Z, r24
    5c16:	08 94       	sec
    5c18:	e1 08       	sbc	r14, r1
    5c1a:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5c1c:	e1 14       	cp	r14, r1
    5c1e:	f1 04       	cpc	r15, r1
    5c20:	a9 f7       	brne	.-22     	; 0x5c0c <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5c22:	8d ef       	ldi	r24, 0xFD	; 253
    5c24:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5c28:	80 93 a7 50 	sts	0x50A7, r24
    5c2c:	ee 24       	eor	r14, r14
    5c2e:	ff 24       	eor	r15, r15
    5c30:	68 94       	set
    5c32:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5c34:	07 ea       	ldi	r16, 0xA7	; 167
    5c36:	10 e5       	ldi	r17, 0x50	; 80
    5c38:	8f ef       	ldi	r24, 0xFF	; 255
    5c3a:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5c3e:	f8 01       	movw	r30, r16
    5c40:	80 83       	st	Z, r24
    5c42:	08 94       	sec
    5c44:	e1 08       	sbc	r14, r1
    5c46:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5c48:	e1 14       	cp	r14, r1
    5c4a:	f1 04       	cpc	r15, r1
    5c4c:	a9 f7       	brne	.-22     	; 0x5c38 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5c4e:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5c52:	80 91 a7 50 	lds	r24, 0x50A7
    5c56:	8f 3f       	cpi	r24, 0xFF	; 255
    5c58:	51 f0       	breq	.+20     	; 0x5c6e <SD_write_multiple_blocks+0x276>
    5c5a:	07 ea       	ldi	r16, 0xA7	; 167
    5c5c:	10 e5       	ldi	r17, 0x50	; 80
    5c5e:	8f ef       	ldi	r24, 0xFF	; 255
    5c60:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5c64:	f8 01       	movw	r30, r16
    5c66:	80 83       	st	Z, r24
    5c68:	80 81       	ld	r24, Z
    5c6a:	8f 3f       	cpi	r24, 0xFF	; 255
    5c6c:	c1 f7       	brne	.-16     	; 0x5c5e <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5c6e:	80 e0       	ldi	r24, 0x00	; 0
    5c70:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    5c74:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5c78:	88 e0       	ldi	r24, 0x08	; 8
    5c7a:	60 e0       	ldi	r22, 0x00	; 0
    5c7c:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
}
    5c80:	2a 96       	adiw	r28, 0x0a	; 10
    5c82:	cd bf       	out	0x3d, r28	; 61
    5c84:	de bf       	out	0x3e, r29	; 62
    5c86:	df 91       	pop	r29
    5c88:	cf 91       	pop	r28
    5c8a:	1f 91       	pop	r17
    5c8c:	0f 91       	pop	r16
    5c8e:	ff 90       	pop	r15
    5c90:	ef 90       	pop	r14
    5c92:	df 90       	pop	r13
    5c94:	cf 90       	pop	r12
    5c96:	bf 90       	pop	r11
    5c98:	af 90       	pop	r10
    5c9a:	9f 90       	pop	r9
    5c9c:	8f 90       	pop	r8
    5c9e:	7f 90       	pop	r7
    5ca0:	6f 90       	pop	r6
    5ca2:	5f 90       	pop	r5
    5ca4:	4f 90       	pop	r4
    5ca6:	3f 90       	pop	r3
    5ca8:	2f 90       	pop	r2
    5caa:	08 95       	ret

00005cac <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5cac:	2f 92       	push	r2
    5cae:	3f 92       	push	r3
    5cb0:	4f 92       	push	r4
    5cb2:	5f 92       	push	r5
    5cb4:	6f 92       	push	r6
    5cb6:	7f 92       	push	r7
    5cb8:	8f 92       	push	r8
    5cba:	9f 92       	push	r9
    5cbc:	af 92       	push	r10
    5cbe:	bf 92       	push	r11
    5cc0:	cf 92       	push	r12
    5cc2:	df 92       	push	r13
    5cc4:	ef 92       	push	r14
    5cc6:	ff 92       	push	r15
    5cc8:	0f 93       	push	r16
    5cca:	1f 93       	push	r17
    5ccc:	cf 93       	push	r28
    5cce:	df 93       	push	r29
    5cd0:	6b 01       	movw	r12, r22
    5cd2:	7c 01       	movw	r14, r24
    5cd4:	c4 2f       	mov	r28, r20
    5cd6:	85 2e       	mov	r8, r21
    5cd8:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5cda:	88 e0       	ldi	r24, 0x08	; 8
    5cdc:	60 e0       	ldi	r22, 0x00	; 0
    5cde:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5ce2:	80 e0       	ldi	r24, 0x00	; 0
    5ce4:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    5ce8:	81 e0       	ldi	r24, 0x01	; 1
    5cea:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5cee:	82 e1       	ldi	r24, 0x12	; 18
    5cf0:	b7 01       	movw	r22, r14
    5cf2:	a6 01       	movw	r20, r12
    5cf4:	2f ef       	ldi	r18, 0xFF	; 255
    5cf6:	08 e0       	ldi	r16, 0x08	; 8
    5cf8:	10 e0       	ldi	r17, 0x00	; 0
    5cfa:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
    5cfe:	88 23       	and	r24, r24
    5d00:	b1 f7       	brne	.-20     	; 0x5cee <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5d02:	16 14       	cp	r1, r6
    5d04:	17 04       	cpc	r1, r7
    5d06:	0c f0       	brlt	.+2      	; 0x5d0a <SD_read_multiple_blocks+0x5e>
    5d08:	46 c0       	rjmp	.+140    	; 0x5d96 <SD_read_multiple_blocks+0xea>
    5d0a:	ac 2e       	mov	r10, r28
    5d0c:	b8 2c       	mov	r11, r8
    5d0e:	88 24       	eor	r8, r8
    5d10:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5d12:	0f 2e       	mov	r0, r31
    5d14:	f7 ea       	ldi	r31, 0xA7	; 167
    5d16:	cf 2e       	mov	r12, r31
    5d18:	f0 e5       	ldi	r31, 0x50	; 80
    5d1a:	df 2e       	mov	r13, r31
    5d1c:	f0 2d       	mov	r31, r0
    5d1e:	ff 24       	eor	r15, r15
    5d20:	fa 94       	dec	r15
    5d22:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5d24:	0f 2e       	mov	r0, r31
    5d26:	f6 ea       	ldi	r31, 0xA6	; 166
    5d28:	4f 2e       	mov	r4, r31
    5d2a:	f0 e5       	ldi	r31, 0x50	; 80
    5d2c:	5f 2e       	mov	r5, r31
    5d2e:	f0 2d       	mov	r31, r0
    5d30:	12 01       	movw	r2, r4
    5d32:	08 94       	sec
    5d34:	21 1c       	adc	r2, r1
    5d36:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5d38:	f6 01       	movw	r30, r12
    5d3a:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5d3c:	80 81       	ld	r24, Z
    5d3e:	8e 3f       	cpi	r24, 0xFE	; 254
    5d40:	41 f0       	breq	.+16     	; 0x5d52 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5d42:	8f 2d       	mov	r24, r15
    5d44:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5d48:	f6 01       	movw	r30, r12
    5d4a:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5d4c:	80 81       	ld	r24, Z
    5d4e:	8e 3f       	cpi	r24, 0xFE	; 254
    5d50:	c1 f7       	brne	.-16     	; 0x5d42 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5d52:	85 01       	movw	r16, r10
    5d54:	c0 e0       	ldi	r28, 0x00	; 0
    5d56:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5d58:	8f 2d       	mov	r24, r15
    5d5a:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5d5e:	f8 01       	movw	r30, r16
    5d60:	81 93       	st	Z+, r24
    5d62:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5d64:	21 96       	adiw	r28, 0x01	; 1
    5d66:	f2 e0       	ldi	r31, 0x02	; 2
    5d68:	c0 30       	cpi	r28, 0x00	; 0
    5d6a:	df 07       	cpc	r29, r31
    5d6c:	a9 f7       	brne	.-22     	; 0x5d58 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5d6e:	8f 2d       	mov	r24, r15
    5d70:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5d74:	f2 01       	movw	r30, r4
    5d76:	80 83       	st	Z, r24
    5d78:	8f 2d       	mov	r24, r15
    5d7a:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5d7e:	f1 01       	movw	r30, r2
    5d80:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5d82:	08 94       	sec
    5d84:	81 1c       	adc	r8, r1
    5d86:	91 1c       	adc	r9, r1
    5d88:	80 e0       	ldi	r24, 0x00	; 0
    5d8a:	92 e0       	ldi	r25, 0x02	; 2
    5d8c:	a8 0e       	add	r10, r24
    5d8e:	b9 1e       	adc	r11, r25
    5d90:	86 14       	cp	r8, r6
    5d92:	97 04       	cpc	r9, r7
    5d94:	89 f6       	brne	.-94     	; 0x5d38 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5d96:	8c e0       	ldi	r24, 0x0C	; 12
    5d98:	40 e0       	ldi	r20, 0x00	; 0
    5d9a:	50 e0       	ldi	r21, 0x00	; 0
    5d9c:	ba 01       	movw	r22, r20
    5d9e:	2f ef       	ldi	r18, 0xFF	; 255
    5da0:	08 e0       	ldi	r16, 0x08	; 8
    5da2:	10 e0       	ldi	r17, 0x00	; 0
    5da4:	0e 94 a5 2a 	call	0x554a	; 0x554a <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5da8:	8f ef       	ldi	r24, 0xFF	; 255
    5daa:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5dae:	80 93 a6 50 	sts	0x50A6, r24
	Buffer[1] = FILLER_BYTE;
    5db2:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5db6:	80 91 a7 50 	lds	r24, 0x50A7
    5dba:	8f 3f       	cpi	r24, 0xFF	; 255
    5dbc:	49 f0       	breq	.+18     	; 0x5dd0 <SD_read_multiple_blocks+0x124>
    5dbe:	c7 ea       	ldi	r28, 0xA7	; 167
    5dc0:	d0 e5       	ldi	r29, 0x50	; 80
    5dc2:	8f ef       	ldi	r24, 0xFF	; 255
    5dc4:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
    5dc8:	88 83       	st	Y, r24
    5dca:	88 81       	ld	r24, Y
    5dcc:	8f 3f       	cpi	r24, 0xFF	; 255
    5dce:	c9 f7       	brne	.-14     	; 0x5dc2 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5dd0:	80 e0       	ldi	r24, 0x00	; 0
    5dd2:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    5dd6:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5dda:	88 e0       	ldi	r24, 0x08	; 8
    5ddc:	60 e0       	ldi	r22, 0x00	; 0
    5dde:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
}
    5de2:	df 91       	pop	r29
    5de4:	cf 91       	pop	r28
    5de6:	1f 91       	pop	r17
    5de8:	0f 91       	pop	r16
    5dea:	ff 90       	pop	r15
    5dec:	ef 90       	pop	r14
    5dee:	df 90       	pop	r13
    5df0:	cf 90       	pop	r12
    5df2:	bf 90       	pop	r11
    5df4:	af 90       	pop	r10
    5df6:	9f 90       	pop	r9
    5df8:	8f 90       	pop	r8
    5dfa:	7f 90       	pop	r7
    5dfc:	6f 90       	pop	r6
    5dfe:	5f 90       	pop	r5
    5e00:	4f 90       	pop	r4
    5e02:	3f 90       	pop	r3
    5e04:	2f 90       	pop	r2
    5e06:	08 95       	ret

00005e08 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5e08:	88 e0       	ldi	r24, 0x08	; 8
    5e0a:	60 e0       	ldi	r22, 0x00	; 0
    5e0c:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5e10:	88 e0       	ldi	r24, 0x08	; 8
    5e12:	60 e0       	ldi	r22, 0x00	; 0
    5e14:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5e18:	80 e0       	ldi	r24, 0x00	; 0
    5e1a:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <SPIInit>
	SPICS(TRUE);
    5e1e:	81 e0       	ldi	r24, 0x01	; 1
    5e20:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5e24:	8f ef       	ldi	r24, 0xFF	; 255
    5e26:	0e 94 9b 2a 	call	0x5536	; 0x5536 <SPI_write>
	SPICS(FALSE);	//stop spi
    5e2a:	80 e0       	ldi	r24, 0x00	; 0
    5e2c:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <SPICS>
	SPIDisable();
    5e30:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5e34:	80 e0       	ldi	r24, 0x00	; 0
    5e36:	0e 94 26 04 	call	0x84c	; 0x84c <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5e3a:	80 e0       	ldi	r24, 0x00	; 0
    5e3c:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <Ext1Power>
}
    5e40:	08 95       	ret

00005e42 <__muldi3>:
    5e42:	a0 e3       	ldi	r26, 0x30	; 48
    5e44:	b0 e0       	ldi	r27, 0x00	; 0
    5e46:	e7 e2       	ldi	r30, 0x27	; 39
    5e48:	ff e2       	ldi	r31, 0x2F	; 47
    5e4a:	0c 94 c0 3a 	jmp	0x7580	; 0x7580 <__prologue_saves__+0x4>
    5e4e:	29 8f       	std	Y+25, r18	; 0x19
    5e50:	3a 8f       	std	Y+26, r19	; 0x1a
    5e52:	4b 8f       	std	Y+27, r20	; 0x1b
    5e54:	5c 8f       	std	Y+28, r21	; 0x1c
    5e56:	6d 8f       	std	Y+29, r22	; 0x1d
    5e58:	7e 8f       	std	Y+30, r23	; 0x1e
    5e5a:	8f 8f       	std	Y+31, r24	; 0x1f
    5e5c:	98 a3       	lds	r25, 0x58
    5e5e:	a9 8a       	std	Y+17, r10	; 0x11
    5e60:	ba 8a       	std	Y+18, r11	; 0x12
    5e62:	cb 8a       	std	Y+19, r12	; 0x13
    5e64:	dc 8a       	std	Y+20, r13	; 0x14
    5e66:	ed 8a       	std	Y+21, r14	; 0x15
    5e68:	fe 8a       	std	Y+22, r15	; 0x16
    5e6a:	0f 8b       	std	Y+23, r16	; 0x17
    5e6c:	18 8f       	std	Y+24, r17	; 0x18
    5e6e:	09 8d       	ldd	r16, Y+25	; 0x19
    5e70:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5e72:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5e74:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5e76:	09 a3       	lds	r16, 0x59
    5e78:	1a a3       	lds	r17, 0x5a
    5e7a:	2b a3       	lds	r18, 0x5b
    5e7c:	3c a3       	lds	r19, 0x5c
    5e7e:	68 01       	movw	r12, r16
    5e80:	79 01       	movw	r14, r18
    5e82:	8f ef       	ldi	r24, 0xFF	; 255
    5e84:	9f ef       	ldi	r25, 0xFF	; 255
    5e86:	a0 e0       	ldi	r26, 0x00	; 0
    5e88:	b0 e0       	ldi	r27, 0x00	; 0
    5e8a:	c8 22       	and	r12, r24
    5e8c:	d9 22       	and	r13, r25
    5e8e:	ea 22       	and	r14, r26
    5e90:	fb 22       	and	r15, r27
    5e92:	89 01       	movw	r16, r18
    5e94:	22 27       	eor	r18, r18
    5e96:	33 27       	eor	r19, r19
    5e98:	09 a7       	lds	r16, 0x79
    5e9a:	1a a7       	lds	r17, 0x7a
    5e9c:	2b a7       	lds	r18, 0x7b
    5e9e:	3c a7       	lds	r19, 0x7c
    5ea0:	09 89       	ldd	r16, Y+17	; 0x11
    5ea2:	1a 89       	ldd	r17, Y+18	; 0x12
    5ea4:	2b 89       	ldd	r18, Y+19	; 0x13
    5ea6:	3c 89       	ldd	r19, Y+20	; 0x14
    5ea8:	0d a3       	lds	r16, 0x5d
    5eaa:	1e a3       	lds	r17, 0x5e
    5eac:	2f a3       	lds	r18, 0x5f
    5eae:	38 a7       	lds	r19, 0x78
    5eb0:	48 01       	movw	r8, r16
    5eb2:	59 01       	movw	r10, r18
    5eb4:	88 22       	and	r8, r24
    5eb6:	99 22       	and	r9, r25
    5eb8:	aa 22       	and	r10, r26
    5eba:	bb 22       	and	r11, r27
    5ebc:	29 01       	movw	r4, r18
    5ebe:	66 24       	eor	r6, r6
    5ec0:	77 24       	eor	r7, r7
    5ec2:	c5 01       	movw	r24, r10
    5ec4:	b4 01       	movw	r22, r8
    5ec6:	a7 01       	movw	r20, r14
    5ec8:	96 01       	movw	r18, r12
    5eca:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    5ece:	6d a7       	lds	r22, 0x7d
    5ed0:	7e a7       	lds	r23, 0x7e
    5ed2:	8f a7       	lds	r24, 0x7f
    5ed4:	98 ab       	sts	0x58, r25
    5ed6:	c3 01       	movw	r24, r6
    5ed8:	b2 01       	movw	r22, r4
    5eda:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    5ede:	6b 01       	movw	r12, r22
    5ee0:	7c 01       	movw	r14, r24
    5ee2:	c5 01       	movw	r24, r10
    5ee4:	b4 01       	movw	r22, r8
    5ee6:	29 a5       	lds	r18, 0x69
    5ee8:	3a a5       	lds	r19, 0x6a
    5eea:	4b a5       	lds	r20, 0x6b
    5eec:	5c a5       	lds	r21, 0x6c
    5eee:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    5ef2:	4b 01       	movw	r8, r22
    5ef4:	5c 01       	movw	r10, r24
    5ef6:	c3 01       	movw	r24, r6
    5ef8:	b2 01       	movw	r22, r4
    5efa:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    5efe:	ab 01       	movw	r20, r22
    5f00:	bc 01       	movw	r22, r24
    5f02:	c8 0c       	add	r12, r8
    5f04:	d9 1c       	adc	r13, r9
    5f06:	ea 1c       	adc	r14, r10
    5f08:	fb 1c       	adc	r15, r11
    5f0a:	0d a5       	lds	r16, 0x6d
    5f0c:	1e a5       	lds	r17, 0x6e
    5f0e:	2f a5       	lds	r18, 0x6f
    5f10:	38 a9       	sts	0x48, r19
    5f12:	c9 01       	movw	r24, r18
    5f14:	aa 27       	eor	r26, r26
    5f16:	bb 27       	eor	r27, r27
    5f18:	c8 0e       	add	r12, r24
    5f1a:	d9 1e       	adc	r13, r25
    5f1c:	ea 1e       	adc	r14, r26
    5f1e:	fb 1e       	adc	r15, r27
    5f20:	c8 14       	cp	r12, r8
    5f22:	d9 04       	cpc	r13, r9
    5f24:	ea 04       	cpc	r14, r10
    5f26:	fb 04       	cpc	r15, r11
    5f28:	20 f4       	brcc	.+8      	; 0x5f32 <__muldi3+0xf0>
    5f2a:	40 50       	subi	r20, 0x00	; 0
    5f2c:	50 40       	sbci	r21, 0x00	; 0
    5f2e:	6f 4f       	sbci	r22, 0xFF	; 255
    5f30:	7f 4f       	sbci	r23, 0xFF	; 255
    5f32:	c7 01       	movw	r24, r14
    5f34:	aa 27       	eor	r26, r26
    5f36:	bb 27       	eor	r27, r27
    5f38:	84 0f       	add	r24, r20
    5f3a:	95 1f       	adc	r25, r21
    5f3c:	a6 1f       	adc	r26, r22
    5f3e:	b7 1f       	adc	r27, r23
    5f40:	8d 83       	std	Y+5, r24	; 0x05
    5f42:	9e 83       	std	Y+6, r25	; 0x06
    5f44:	af 83       	std	Y+7, r26	; 0x07
    5f46:	b8 87       	std	Y+8, r27	; 0x08
    5f48:	76 01       	movw	r14, r12
    5f4a:	dd 24       	eor	r13, r13
    5f4c:	cc 24       	eor	r12, r12
    5f4e:	4d a5       	lds	r20, 0x6d
    5f50:	5e a5       	lds	r21, 0x6e
    5f52:	6f a5       	lds	r22, 0x6f
    5f54:	78 a9       	sts	0x48, r23
    5f56:	60 70       	andi	r22, 0x00	; 0
    5f58:	70 70       	andi	r23, 0x00	; 0
    5f5a:	c4 0e       	add	r12, r20
    5f5c:	d5 1e       	adc	r13, r21
    5f5e:	e6 1e       	adc	r14, r22
    5f60:	f7 1e       	adc	r15, r23
    5f62:	c9 82       	std	Y+1, r12	; 0x01
    5f64:	da 82       	std	Y+2, r13	; 0x02
    5f66:	eb 82       	std	Y+3, r14	; 0x03
    5f68:	fc 82       	std	Y+4, r15	; 0x04
    5f6a:	1c 2d       	mov	r17, r12
    5f6c:	0a 81       	ldd	r16, Y+2	; 0x02
    5f6e:	8b 80       	ldd	r8, Y+3	; 0x03
    5f70:	4c 80       	ldd	r4, Y+4	; 0x04
    5f72:	8d 87       	std	Y+13, r24	; 0x0d
    5f74:	8e 81       	ldd	r24, Y+6	; 0x06
    5f76:	8e 87       	std	Y+14, r24	; 0x0e
    5f78:	8f 81       	ldd	r24, Y+7	; 0x07
    5f7a:	8f 87       	std	Y+15, r24	; 0x0f
    5f7c:	88 85       	ldd	r24, Y+8	; 0x08
    5f7e:	88 8b       	std	Y+16, r24	; 0x10
    5f80:	2d 89       	ldd	r18, Y+21	; 0x15
    5f82:	3e 89       	ldd	r19, Y+22	; 0x16
    5f84:	4f 89       	ldd	r20, Y+23	; 0x17
    5f86:	58 8d       	ldd	r21, Y+24	; 0x18
    5f88:	69 a1       	lds	r22, 0x49
    5f8a:	7a a1       	lds	r23, 0x4a
    5f8c:	8b a1       	lds	r24, 0x4b
    5f8e:	9c a1       	lds	r25, 0x4c
    5f90:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    5f94:	6b 01       	movw	r12, r22
    5f96:	7c 01       	movw	r14, r24
    5f98:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5f9a:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5f9c:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5f9e:	58 a1       	lds	r21, 0x48
    5fa0:	6d a1       	lds	r22, 0x4d
    5fa2:	7e a1       	lds	r23, 0x4e
    5fa4:	8f a1       	lds	r24, 0x4f
    5fa6:	98 a5       	lds	r25, 0x68
    5fa8:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    5fac:	dc 01       	movw	r26, r24
    5fae:	cb 01       	movw	r24, r22
    5fb0:	c8 0e       	add	r12, r24
    5fb2:	d9 1e       	adc	r13, r25
    5fb4:	ea 1e       	adc	r14, r26
    5fb6:	fb 1e       	adc	r15, r27
    5fb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    5fba:	9e 85       	ldd	r25, Y+14	; 0x0e
    5fbc:	af 85       	ldd	r26, Y+15	; 0x0f
    5fbe:	b8 89       	ldd	r27, Y+16	; 0x10
    5fc0:	8c 0d       	add	r24, r12
    5fc2:	9d 1d       	adc	r25, r13
    5fc4:	ae 1d       	adc	r26, r14
    5fc6:	bf 1d       	adc	r27, r15
    5fc8:	8d 87       	std	Y+13, r24	; 0x0d
    5fca:	9e 87       	std	Y+14, r25	; 0x0e
    5fcc:	af 87       	std	Y+15, r26	; 0x0f
    5fce:	b8 8b       	std	Y+16, r27	; 0x10
    5fd0:	68 2f       	mov	r22, r24
    5fd2:	7e 85       	ldd	r23, Y+14	; 0x0e
    5fd4:	21 2f       	mov	r18, r17
    5fd6:	30 2f       	mov	r19, r16
    5fd8:	48 2d       	mov	r20, r8
    5fda:	54 2d       	mov	r21, r4
    5fdc:	8f 85       	ldd	r24, Y+15	; 0x0f
    5fde:	98 89       	ldd	r25, Y+16	; 0x10
    5fe0:	e0 96       	adiw	r28, 0x30	; 48
    5fe2:	e0 e1       	ldi	r30, 0x10	; 16
    5fe4:	0c 94 d9 3a 	jmp	0x75b2	; 0x75b2 <__epilogue_restores__+0x4>

00005fe8 <__ashldi3>:
    5fe8:	cf 92       	push	r12
    5fea:	df 92       	push	r13
    5fec:	ef 92       	push	r14
    5fee:	ff 92       	push	r15
    5ff0:	0f 93       	push	r16
    5ff2:	cf 93       	push	r28
    5ff4:	df 93       	push	r29
    5ff6:	cd b7       	in	r28, 0x3d	; 61
    5ff8:	de b7       	in	r29, 0x3e	; 62
    5ffa:	60 97       	sbiw	r28, 0x10	; 16
    5ffc:	cd bf       	out	0x3d, r28	; 61
    5ffe:	de bf       	out	0x3e, r29	; 62
    6000:	00 23       	and	r16, r16
    6002:	09 f4       	brne	.+2      	; 0x6006 <__stack+0x7>
    6004:	5a c0       	rjmp	.+180    	; 0x60ba <__stack+0xbb>
    6006:	29 87       	std	Y+9, r18	; 0x09
    6008:	3a 87       	std	Y+10, r19	; 0x0a
    600a:	4b 87       	std	Y+11, r20	; 0x0b
    600c:	5c 87       	std	Y+12, r21	; 0x0c
    600e:	6d 87       	std	Y+13, r22	; 0x0d
    6010:	7e 87       	std	Y+14, r23	; 0x0e
    6012:	8f 87       	std	Y+15, r24	; 0x0f
    6014:	98 8b       	std	Y+16, r25	; 0x10
    6016:	80 e2       	ldi	r24, 0x20	; 32
    6018:	80 1b       	sub	r24, r16
    601a:	49 85       	ldd	r20, Y+9	; 0x09
    601c:	5a 85       	ldd	r21, Y+10	; 0x0a
    601e:	6b 85       	ldd	r22, Y+11	; 0x0b
    6020:	7c 85       	ldd	r23, Y+12	; 0x0c
    6022:	18 16       	cp	r1, r24
    6024:	b4 f0       	brlt	.+44     	; 0x6052 <__stack+0x53>
    6026:	19 82       	std	Y+1, r1	; 0x01
    6028:	1a 82       	std	Y+2, r1	; 0x02
    602a:	1b 82       	std	Y+3, r1	; 0x03
    602c:	1c 82       	std	Y+4, r1	; 0x04
    602e:	99 27       	eor	r25, r25
    6030:	87 fd       	sbrc	r24, 7
    6032:	90 95       	com	r25
    6034:	90 95       	com	r25
    6036:	81 95       	neg	r24
    6038:	9f 4f       	sbci	r25, 0xFF	; 255
    603a:	04 c0       	rjmp	.+8      	; 0x6044 <__stack+0x45>
    603c:	44 0f       	add	r20, r20
    603e:	55 1f       	adc	r21, r21
    6040:	66 1f       	adc	r22, r22
    6042:	77 1f       	adc	r23, r23
    6044:	8a 95       	dec	r24
    6046:	d2 f7       	brpl	.-12     	; 0x603c <__stack+0x3d>
    6048:	4d 83       	std	Y+5, r20	; 0x05
    604a:	5e 83       	std	Y+6, r21	; 0x06
    604c:	6f 83       	std	Y+7, r22	; 0x07
    604e:	78 87       	std	Y+8, r23	; 0x08
    6050:	2c c0       	rjmp	.+88     	; 0x60aa <__stack+0xab>
    6052:	6a 01       	movw	r12, r20
    6054:	7b 01       	movw	r14, r22
    6056:	00 2e       	mov	r0, r16
    6058:	04 c0       	rjmp	.+8      	; 0x6062 <__stack+0x63>
    605a:	cc 0c       	add	r12, r12
    605c:	dd 1c       	adc	r13, r13
    605e:	ee 1c       	adc	r14, r14
    6060:	ff 1c       	adc	r15, r15
    6062:	0a 94       	dec	r0
    6064:	d2 f7       	brpl	.-12     	; 0x605a <__stack+0x5b>
    6066:	c9 82       	std	Y+1, r12	; 0x01
    6068:	da 82       	std	Y+2, r13	; 0x02
    606a:	eb 82       	std	Y+3, r14	; 0x03
    606c:	fc 82       	std	Y+4, r15	; 0x04
    606e:	6a 01       	movw	r12, r20
    6070:	7b 01       	movw	r14, r22
    6072:	04 c0       	rjmp	.+8      	; 0x607c <__stack+0x7d>
    6074:	f6 94       	lsr	r15
    6076:	e7 94       	ror	r14
    6078:	d7 94       	ror	r13
    607a:	c7 94       	ror	r12
    607c:	8a 95       	dec	r24
    607e:	d2 f7       	brpl	.-12     	; 0x6074 <__stack+0x75>
    6080:	d7 01       	movw	r26, r14
    6082:	c6 01       	movw	r24, r12
    6084:	4d 85       	ldd	r20, Y+13	; 0x0d
    6086:	5e 85       	ldd	r21, Y+14	; 0x0e
    6088:	6f 85       	ldd	r22, Y+15	; 0x0f
    608a:	78 89       	ldd	r23, Y+16	; 0x10
    608c:	04 c0       	rjmp	.+8      	; 0x6096 <__stack+0x97>
    608e:	44 0f       	add	r20, r20
    6090:	55 1f       	adc	r21, r21
    6092:	66 1f       	adc	r22, r22
    6094:	77 1f       	adc	r23, r23
    6096:	0a 95       	dec	r16
    6098:	d2 f7       	brpl	.-12     	; 0x608e <__stack+0x8f>
    609a:	84 2b       	or	r24, r20
    609c:	95 2b       	or	r25, r21
    609e:	a6 2b       	or	r26, r22
    60a0:	b7 2b       	or	r27, r23
    60a2:	8d 83       	std	Y+5, r24	; 0x05
    60a4:	9e 83       	std	Y+6, r25	; 0x06
    60a6:	af 83       	std	Y+7, r26	; 0x07
    60a8:	b8 87       	std	Y+8, r27	; 0x08
    60aa:	29 81       	ldd	r18, Y+1	; 0x01
    60ac:	3a 81       	ldd	r19, Y+2	; 0x02
    60ae:	4b 81       	ldd	r20, Y+3	; 0x03
    60b0:	5c 81       	ldd	r21, Y+4	; 0x04
    60b2:	6d 81       	ldd	r22, Y+5	; 0x05
    60b4:	7e 81       	ldd	r23, Y+6	; 0x06
    60b6:	8f 81       	ldd	r24, Y+7	; 0x07
    60b8:	98 85       	ldd	r25, Y+8	; 0x08
    60ba:	60 96       	adiw	r28, 0x10	; 16
    60bc:	cd bf       	out	0x3d, r28	; 61
    60be:	de bf       	out	0x3e, r29	; 62
    60c0:	df 91       	pop	r29
    60c2:	cf 91       	pop	r28
    60c4:	0f 91       	pop	r16
    60c6:	ff 90       	pop	r15
    60c8:	ef 90       	pop	r14
    60ca:	df 90       	pop	r13
    60cc:	cf 90       	pop	r12
    60ce:	08 95       	ret

000060d0 <__ashrdi3>:
    60d0:	0f 93       	push	r16
    60d2:	cf 93       	push	r28
    60d4:	df 93       	push	r29
    60d6:	cd b7       	in	r28, 0x3d	; 61
    60d8:	de b7       	in	r29, 0x3e	; 62
    60da:	60 97       	sbiw	r28, 0x10	; 16
    60dc:	cd bf       	out	0x3d, r28	; 61
    60de:	de bf       	out	0x3e, r29	; 62
    60e0:	00 23       	and	r16, r16
    60e2:	09 f4       	brne	.+2      	; 0x60e6 <__ashrdi3+0x16>
    60e4:	56 c0       	rjmp	.+172    	; 0x6192 <__ashrdi3+0xc2>
    60e6:	29 87       	std	Y+9, r18	; 0x09
    60e8:	3a 87       	std	Y+10, r19	; 0x0a
    60ea:	4b 87       	std	Y+11, r20	; 0x0b
    60ec:	5c 87       	std	Y+12, r21	; 0x0c
    60ee:	6d 87       	std	Y+13, r22	; 0x0d
    60f0:	7e 87       	std	Y+14, r23	; 0x0e
    60f2:	8f 87       	std	Y+15, r24	; 0x0f
    60f4:	98 8b       	std	Y+16, r25	; 0x10
    60f6:	20 e2       	ldi	r18, 0x20	; 32
    60f8:	20 1b       	sub	r18, r16
    60fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    60fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    60fe:	af 85       	ldd	r26, Y+15	; 0x0f
    6100:	b8 89       	ldd	r27, Y+16	; 0x10
    6102:	ac 01       	movw	r20, r24
    6104:	bd 01       	movw	r22, r26
    6106:	12 16       	cp	r1, r18
    6108:	b4 f0       	brlt	.+44     	; 0x6136 <__ashrdi3+0x66>
    610a:	77 0f       	add	r23, r23
    610c:	44 0b       	sbc	r20, r20
    610e:	54 2f       	mov	r21, r20
    6110:	ba 01       	movw	r22, r20
    6112:	4d 83       	std	Y+5, r20	; 0x05
    6114:	5e 83       	std	Y+6, r21	; 0x06
    6116:	6f 83       	std	Y+7, r22	; 0x07
    6118:	78 87       	std	Y+8, r23	; 0x08
    611a:	33 27       	eor	r19, r19
    611c:	27 fd       	sbrc	r18, 7
    611e:	30 95       	com	r19
    6120:	30 95       	com	r19
    6122:	21 95       	neg	r18
    6124:	3f 4f       	sbci	r19, 0xFF	; 255
    6126:	04 c0       	rjmp	.+8      	; 0x6130 <__ashrdi3+0x60>
    6128:	b5 95       	asr	r27
    612a:	a7 95       	ror	r26
    612c:	97 95       	ror	r25
    612e:	87 95       	ror	r24
    6130:	2a 95       	dec	r18
    6132:	d2 f7       	brpl	.-12     	; 0x6128 <__ashrdi3+0x58>
    6134:	22 c0       	rjmp	.+68     	; 0x617a <__ashrdi3+0xaa>
    6136:	00 2e       	mov	r0, r16
    6138:	04 c0       	rjmp	.+8      	; 0x6142 <__ashrdi3+0x72>
    613a:	75 95       	asr	r23
    613c:	67 95       	ror	r22
    613e:	57 95       	ror	r21
    6140:	47 95       	ror	r20
    6142:	0a 94       	dec	r0
    6144:	d2 f7       	brpl	.-12     	; 0x613a <__ashrdi3+0x6a>
    6146:	4d 83       	std	Y+5, r20	; 0x05
    6148:	5e 83       	std	Y+6, r21	; 0x06
    614a:	6f 83       	std	Y+7, r22	; 0x07
    614c:	78 87       	std	Y+8, r23	; 0x08
    614e:	04 c0       	rjmp	.+8      	; 0x6158 <__ashrdi3+0x88>
    6150:	88 0f       	add	r24, r24
    6152:	99 1f       	adc	r25, r25
    6154:	aa 1f       	adc	r26, r26
    6156:	bb 1f       	adc	r27, r27
    6158:	2a 95       	dec	r18
    615a:	d2 f7       	brpl	.-12     	; 0x6150 <__ashrdi3+0x80>
    615c:	49 85       	ldd	r20, Y+9	; 0x09
    615e:	5a 85       	ldd	r21, Y+10	; 0x0a
    6160:	6b 85       	ldd	r22, Y+11	; 0x0b
    6162:	7c 85       	ldd	r23, Y+12	; 0x0c
    6164:	04 c0       	rjmp	.+8      	; 0x616e <__ashrdi3+0x9e>
    6166:	76 95       	lsr	r23
    6168:	67 95       	ror	r22
    616a:	57 95       	ror	r21
    616c:	47 95       	ror	r20
    616e:	0a 95       	dec	r16
    6170:	d2 f7       	brpl	.-12     	; 0x6166 <__ashrdi3+0x96>
    6172:	84 2b       	or	r24, r20
    6174:	95 2b       	or	r25, r21
    6176:	a6 2b       	or	r26, r22
    6178:	b7 2b       	or	r27, r23
    617a:	89 83       	std	Y+1, r24	; 0x01
    617c:	9a 83       	std	Y+2, r25	; 0x02
    617e:	ab 83       	std	Y+3, r26	; 0x03
    6180:	bc 83       	std	Y+4, r27	; 0x04
    6182:	29 81       	ldd	r18, Y+1	; 0x01
    6184:	3a 81       	ldd	r19, Y+2	; 0x02
    6186:	4b 81       	ldd	r20, Y+3	; 0x03
    6188:	5c 81       	ldd	r21, Y+4	; 0x04
    618a:	6d 81       	ldd	r22, Y+5	; 0x05
    618c:	7e 81       	ldd	r23, Y+6	; 0x06
    618e:	8f 81       	ldd	r24, Y+7	; 0x07
    6190:	98 85       	ldd	r25, Y+8	; 0x08
    6192:	60 96       	adiw	r28, 0x10	; 16
    6194:	cd bf       	out	0x3d, r28	; 61
    6196:	de bf       	out	0x3e, r29	; 62
    6198:	df 91       	pop	r29
    619a:	cf 91       	pop	r28
    619c:	0f 91       	pop	r16
    619e:	08 95       	ret

000061a0 <__divdi3>:
    61a0:	a8 e4       	ldi	r26, 0x48	; 72
    61a2:	b0 e0       	ldi	r27, 0x00	; 0
    61a4:	e6 ed       	ldi	r30, 0xD6	; 214
    61a6:	f0 e3       	ldi	r31, 0x30	; 48
    61a8:	0c 94 bf 3a 	jmp	0x757e	; 0x757e <__prologue_saves__+0x2>
    61ac:	f5 01       	movw	r30, r10
    61ae:	29 a3       	lds	r18, 0x59
    61b0:	3a a3       	lds	r19, 0x5a
    61b2:	4b a3       	lds	r20, 0x5b
    61b4:	5c a3       	lds	r21, 0x5c
    61b6:	6d a3       	lds	r22, 0x5d
    61b8:	7e a3       	lds	r23, 0x5e
    61ba:	8f a3       	lds	r24, 0x5f
    61bc:	98 a7       	lds	r25, 0x78
    61be:	a9 8e       	std	Y+25, r10	; 0x19
    61c0:	fa 8f       	std	Y+26, r31	; 0x1a
    61c2:	cb 8e       	std	Y+27, r12	; 0x1b
    61c4:	dc 8e       	std	Y+28, r13	; 0x1c
    61c6:	ed 8e       	std	Y+29, r14	; 0x1d
    61c8:	fe 8e       	std	Y+30, r15	; 0x1e
    61ca:	0f 8f       	std	Y+31, r16	; 0x1f
    61cc:	18 a3       	lds	r17, 0x58
    61ce:	8d a0       	lds	r24, 0x8d
    61d0:	9e a0       	lds	r25, 0x8e
    61d2:	af a0       	lds	r26, 0x8f
    61d4:	b8 a4       	lds	r27, 0xa8
    61d6:	b7 fe       	sbrs	r11, 7
    61d8:	67 c0       	rjmp	.+206    	; 0x62a8 <__divdi3+0x108>
    61da:	21 95       	neg	r18
    61dc:	b1 e0       	ldi	r27, 0x01	; 1
    61de:	12 16       	cp	r1, r18
    61e0:	08 f0       	brcs	.+2      	; 0x61e4 <__divdi3+0x44>
    61e2:	b0 e0       	ldi	r27, 0x00	; 0
    61e4:	31 95       	neg	r19
    61e6:	a1 e0       	ldi	r26, 0x01	; 1
    61e8:	13 16       	cp	r1, r19
    61ea:	08 f0       	brcs	.+2      	; 0x61ee <__divdi3+0x4e>
    61ec:	a0 e0       	ldi	r26, 0x00	; 0
    61ee:	b3 2e       	mov	r11, r19
    61f0:	bb 1a       	sub	r11, r27
    61f2:	bb 2d       	mov	r27, r11
    61f4:	88 24       	eor	r8, r8
    61f6:	83 94       	inc	r8
    61f8:	3b 15       	cp	r19, r11
    61fa:	08 f0       	brcs	.+2      	; 0x61fe <__divdi3+0x5e>
    61fc:	88 24       	eor	r8, r8
    61fe:	a8 29       	or	r26, r8
    6200:	41 95       	neg	r20
    6202:	31 e0       	ldi	r19, 0x01	; 1
    6204:	14 16       	cp	r1, r20
    6206:	08 f0       	brcs	.+2      	; 0x620a <__divdi3+0x6a>
    6208:	30 e0       	ldi	r19, 0x00	; 0
    620a:	b4 2e       	mov	r11, r20
    620c:	ba 1a       	sub	r11, r26
    620e:	ab 2d       	mov	r26, r11
    6210:	88 24       	eor	r8, r8
    6212:	83 94       	inc	r8
    6214:	4b 15       	cp	r20, r11
    6216:	08 f0       	brcs	.+2      	; 0x621a <__divdi3+0x7a>
    6218:	88 24       	eor	r8, r8
    621a:	38 29       	or	r19, r8
    621c:	51 95       	neg	r21
    621e:	41 e0       	ldi	r20, 0x01	; 1
    6220:	15 16       	cp	r1, r21
    6222:	08 f0       	brcs	.+2      	; 0x6226 <__divdi3+0x86>
    6224:	40 e0       	ldi	r20, 0x00	; 0
    6226:	45 2e       	mov	r4, r21
    6228:	43 1a       	sub	r4, r19
    622a:	31 e0       	ldi	r19, 0x01	; 1
    622c:	54 15       	cp	r21, r4
    622e:	08 f0       	brcs	.+2      	; 0x6232 <__divdi3+0x92>
    6230:	30 e0       	ldi	r19, 0x00	; 0
    6232:	43 2b       	or	r20, r19
    6234:	61 95       	neg	r22
    6236:	31 e0       	ldi	r19, 0x01	; 1
    6238:	16 16       	cp	r1, r22
    623a:	08 f0       	brcs	.+2      	; 0x623e <__divdi3+0x9e>
    623c:	30 e0       	ldi	r19, 0x00	; 0
    623e:	86 2e       	mov	r8, r22
    6240:	84 1a       	sub	r8, r20
    6242:	41 e0       	ldi	r20, 0x01	; 1
    6244:	68 15       	cp	r22, r8
    6246:	08 f0       	brcs	.+2      	; 0x624a <__divdi3+0xaa>
    6248:	40 e0       	ldi	r20, 0x00	; 0
    624a:	34 2b       	or	r19, r20
    624c:	71 95       	neg	r23
    624e:	41 e0       	ldi	r20, 0x01	; 1
    6250:	17 16       	cp	r1, r23
    6252:	08 f0       	brcs	.+2      	; 0x6256 <__divdi3+0xb6>
    6254:	40 e0       	ldi	r20, 0x00	; 0
    6256:	57 2f       	mov	r21, r23
    6258:	53 1b       	sub	r21, r19
    625a:	31 e0       	ldi	r19, 0x01	; 1
    625c:	75 17       	cp	r23, r21
    625e:	08 f0       	brcs	.+2      	; 0x6262 <__divdi3+0xc2>
    6260:	30 e0       	ldi	r19, 0x00	; 0
    6262:	43 2b       	or	r20, r19
    6264:	81 95       	neg	r24
    6266:	31 e0       	ldi	r19, 0x01	; 1
    6268:	18 16       	cp	r1, r24
    626a:	08 f0       	brcs	.+2      	; 0x626e <__divdi3+0xce>
    626c:	30 e0       	ldi	r19, 0x00	; 0
    626e:	68 2f       	mov	r22, r24
    6270:	64 1b       	sub	r22, r20
    6272:	46 2f       	mov	r20, r22
    6274:	61 e0       	ldi	r22, 0x01	; 1
    6276:	84 17       	cp	r24, r20
    6278:	08 f0       	brcs	.+2      	; 0x627c <__divdi3+0xdc>
    627a:	60 e0       	ldi	r22, 0x00	; 0
    627c:	36 2b       	or	r19, r22
    627e:	91 95       	neg	r25
    6280:	93 1b       	sub	r25, r19
    6282:	29 a3       	lds	r18, 0x59
    6284:	ba a3       	lds	r27, 0x5a
    6286:	ab a3       	lds	r26, 0x5b
    6288:	4c a2       	lds	r20, 0x9c
    628a:	8d a2       	lds	r24, 0x9d
    628c:	5e a3       	lds	r21, 0x5e
    628e:	4f a3       	lds	r20, 0x5f
    6290:	98 a7       	lds	r25, 0x78
    6292:	8f ef       	ldi	r24, 0xFF	; 255
    6294:	9f ef       	ldi	r25, 0xFF	; 255
    6296:	af ef       	ldi	r26, 0xFF	; 255
    6298:	bf ef       	ldi	r27, 0xFF	; 255
    629a:	25 96       	adiw	r28, 0x05	; 5
    629c:	8c af       	sts	0x7c, r24
    629e:	9d af       	sts	0x7d, r25
    62a0:	ae af       	sts	0x7e, r26
    62a2:	bf af       	sts	0x7f, r27
    62a4:	25 97       	sbiw	r28, 0x05	; 5
    62a6:	06 c0       	rjmp	.+12     	; 0x62b4 <__divdi3+0x114>
    62a8:	25 96       	adiw	r28, 0x05	; 5
    62aa:	1c ae       	sts	0xbc, r17
    62ac:	1d ae       	sts	0xbd, r17
    62ae:	1e ae       	sts	0xbe, r17
    62b0:	1f ae       	sts	0xbf, r17
    62b2:	25 97       	sbiw	r28, 0x05	; 5
    62b4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    62b6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    62b8:	af 8d       	ldd	r26, Y+31	; 0x1f
    62ba:	b8 a1       	lds	r27, 0x48
    62bc:	b7 ff       	sbrs	r27, 7
    62be:	68 c0       	rjmp	.+208    	; 0x6390 <__divdi3+0x1f0>
    62c0:	25 96       	adiw	r28, 0x05	; 5
    62c2:	2c ad       	sts	0x6c, r18
    62c4:	3d ad       	sts	0x6d, r19
    62c6:	4e ad       	sts	0x6e, r20
    62c8:	5f ad       	sts	0x6f, r21
    62ca:	25 97       	sbiw	r28, 0x05	; 5
    62cc:	20 95       	com	r18
    62ce:	30 95       	com	r19
    62d0:	40 95       	com	r20
    62d2:	50 95       	com	r21
    62d4:	25 96       	adiw	r28, 0x05	; 5
    62d6:	2c af       	sts	0x7c, r18
    62d8:	3d af       	sts	0x7d, r19
    62da:	4e af       	sts	0x7e, r20
    62dc:	5f af       	sts	0x7f, r21
    62de:	25 97       	sbiw	r28, 0x05	; 5
    62e0:	e1 95       	neg	r30
    62e2:	81 e0       	ldi	r24, 0x01	; 1
    62e4:	1e 16       	cp	r1, r30
    62e6:	08 f0       	brcs	.+2      	; 0x62ea <__divdi3+0x14a>
    62e8:	80 e0       	ldi	r24, 0x00	; 0
    62ea:	f1 95       	neg	r31
    62ec:	91 e0       	ldi	r25, 0x01	; 1
    62ee:	1f 16       	cp	r1, r31
    62f0:	08 f0       	brcs	.+2      	; 0x62f4 <__divdi3+0x154>
    62f2:	90 e0       	ldi	r25, 0x00	; 0
    62f4:	4f 2f       	mov	r20, r31
    62f6:	48 1b       	sub	r20, r24
    62f8:	81 e0       	ldi	r24, 0x01	; 1
    62fa:	f4 17       	cp	r31, r20
    62fc:	08 f0       	brcs	.+2      	; 0x6300 <__divdi3+0x160>
    62fe:	80 e0       	ldi	r24, 0x00	; 0
    6300:	98 2b       	or	r25, r24
    6302:	c1 94       	neg	r12
    6304:	81 e0       	ldi	r24, 0x01	; 1
    6306:	1c 14       	cp	r1, r12
    6308:	08 f0       	brcs	.+2      	; 0x630c <__divdi3+0x16c>
    630a:	80 e0       	ldi	r24, 0x00	; 0
    630c:	6c 2d       	mov	r22, r12
    630e:	69 1b       	sub	r22, r25
    6310:	91 e0       	ldi	r25, 0x01	; 1
    6312:	c6 16       	cp	r12, r22
    6314:	08 f0       	brcs	.+2      	; 0x6318 <__divdi3+0x178>
    6316:	90 e0       	ldi	r25, 0x00	; 0
    6318:	89 2b       	or	r24, r25
    631a:	d1 94       	neg	r13
    631c:	91 e0       	ldi	r25, 0x01	; 1
    631e:	1d 14       	cp	r1, r13
    6320:	08 f0       	brcs	.+2      	; 0x6324 <__divdi3+0x184>
    6322:	90 e0       	ldi	r25, 0x00	; 0
    6324:	5d 2d       	mov	r21, r13
    6326:	58 1b       	sub	r21, r24
    6328:	81 e0       	ldi	r24, 0x01	; 1
    632a:	d5 16       	cp	r13, r21
    632c:	08 f0       	brcs	.+2      	; 0x6330 <__divdi3+0x190>
    632e:	80 e0       	ldi	r24, 0x00	; 0
    6330:	98 2b       	or	r25, r24
    6332:	e1 94       	neg	r14
    6334:	81 e0       	ldi	r24, 0x01	; 1
    6336:	1e 14       	cp	r1, r14
    6338:	08 f0       	brcs	.+2      	; 0x633c <__divdi3+0x19c>
    633a:	80 e0       	ldi	r24, 0x00	; 0
    633c:	3e 2d       	mov	r19, r14
    633e:	39 1b       	sub	r19, r25
    6340:	91 e0       	ldi	r25, 0x01	; 1
    6342:	e3 16       	cp	r14, r19
    6344:	08 f0       	brcs	.+2      	; 0x6348 <__divdi3+0x1a8>
    6346:	90 e0       	ldi	r25, 0x00	; 0
    6348:	89 2b       	or	r24, r25
    634a:	f1 94       	neg	r15
    634c:	91 e0       	ldi	r25, 0x01	; 1
    634e:	1f 14       	cp	r1, r15
    6350:	08 f0       	brcs	.+2      	; 0x6354 <__divdi3+0x1b4>
    6352:	90 e0       	ldi	r25, 0x00	; 0
    6354:	2f 2d       	mov	r18, r15
    6356:	28 1b       	sub	r18, r24
    6358:	81 e0       	ldi	r24, 0x01	; 1
    635a:	f2 16       	cp	r15, r18
    635c:	08 f0       	brcs	.+2      	; 0x6360 <__divdi3+0x1c0>
    635e:	80 e0       	ldi	r24, 0x00	; 0
    6360:	98 2b       	or	r25, r24
    6362:	01 95       	neg	r16
    6364:	81 e0       	ldi	r24, 0x01	; 1
    6366:	10 16       	cp	r1, r16
    6368:	08 f0       	brcs	.+2      	; 0x636c <__divdi3+0x1cc>
    636a:	80 e0       	ldi	r24, 0x00	; 0
    636c:	70 2f       	mov	r23, r16
    636e:	79 1b       	sub	r23, r25
    6370:	97 2f       	mov	r25, r23
    6372:	71 e0       	ldi	r23, 0x01	; 1
    6374:	09 17       	cp	r16, r25
    6376:	08 f0       	brcs	.+2      	; 0x637a <__divdi3+0x1da>
    6378:	70 e0       	ldi	r23, 0x00	; 0
    637a:	87 2b       	or	r24, r23
    637c:	11 95       	neg	r17
    637e:	18 1b       	sub	r17, r24
    6380:	e9 8f       	std	Y+25, r30	; 0x19
    6382:	4a 8f       	std	Y+26, r20	; 0x1a
    6384:	6b 8f       	std	Y+27, r22	; 0x1b
    6386:	5c 8f       	std	Y+28, r21	; 0x1c
    6388:	3d 8f       	std	Y+29, r19	; 0x1d
    638a:	2e 8f       	std	Y+30, r18	; 0x1e
    638c:	9f 8f       	std	Y+31, r25	; 0x1f
    638e:	18 a3       	lds	r17, 0x58
    6390:	79 8d       	ldd	r23, Y+25	; 0x19
    6392:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6394:	5b 8d       	ldd	r21, Y+27	; 0x1b
    6396:	4c 8d       	ldd	r20, Y+28	; 0x1c
    6398:	3d 8d       	ldd	r19, Y+29	; 0x1d
    639a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    639c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    639e:	88 a1       	lds	r24, 0x48
    63a0:	e9 a1       	lds	r30, 0x49
    63a2:	e9 8b       	std	Y+17, r30	; 0x11
    63a4:	ea a1       	lds	r30, 0x4a
    63a6:	ea 8b       	std	Y+18, r30	; 0x12
    63a8:	eb a1       	lds	r30, 0x4b
    63aa:	eb 8b       	std	Y+19, r30	; 0x13
    63ac:	ec a1       	lds	r30, 0x4c
    63ae:	ec 8b       	std	Y+20, r30	; 0x14
    63b0:	ed a1       	lds	r30, 0x4d
    63b2:	ed 8b       	std	Y+21, r30	; 0x15
    63b4:	ee a1       	lds	r30, 0x4e
    63b6:	ee 8b       	std	Y+22, r30	; 0x16
    63b8:	ef a1       	lds	r30, 0x4f
    63ba:	ef 8b       	std	Y+23, r30	; 0x17
    63bc:	e8 a5       	lds	r30, 0x68
    63be:	e8 8f       	std	Y+24, r30	; 0x18
    63c0:	79 87       	std	Y+9, r23	; 0x09
    63c2:	6a 87       	std	Y+10, r22	; 0x0a
    63c4:	5b 87       	std	Y+11, r21	; 0x0b
    63c6:	4c 87       	std	Y+12, r20	; 0x0c
    63c8:	3d 87       	std	Y+13, r19	; 0x0d
    63ca:	2e 87       	std	Y+14, r18	; 0x0e
    63cc:	9f 87       	std	Y+15, r25	; 0x0f
    63ce:	88 8b       	std	Y+16, r24	; 0x10
    63d0:	89 84       	ldd	r8, Y+9	; 0x09
    63d2:	9a 84       	ldd	r9, Y+10	; 0x0a
    63d4:	ab 84       	ldd	r10, Y+11	; 0x0b
    63d6:	bc 84       	ldd	r11, Y+12	; 0x0c
    63d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    63da:	9e 85       	ldd	r25, Y+14	; 0x0e
    63dc:	af 85       	ldd	r26, Y+15	; 0x0f
    63de:	b8 89       	ldd	r27, Y+16	; 0x10
    63e0:	e9 88       	ldd	r14, Y+17	; 0x11
    63e2:	fa 88       	ldd	r15, Y+18	; 0x12
    63e4:	0b 89       	ldd	r16, Y+19	; 0x13
    63e6:	1c 89       	ldd	r17, Y+20	; 0x14
    63e8:	ed aa       	sts	0x9d, r30
    63ea:	fe aa       	sts	0x9e, r31
    63ec:	0f ab       	sts	0x5f, r16
    63ee:	18 af       	sts	0x78, r17
    63f0:	cd 88       	ldd	r12, Y+21	; 0x15
    63f2:	de 88       	ldd	r13, Y+22	; 0x16
    63f4:	ef 88       	ldd	r14, Y+23	; 0x17
    63f6:	f8 8c       	ldd	r15, Y+24	; 0x18
    63f8:	00 97       	sbiw	r24, 0x00	; 0
    63fa:	a1 05       	cpc	r26, r1
    63fc:	b1 05       	cpc	r27, r1
    63fe:	09 f0       	breq	.+2      	; 0x6402 <__divdi3+0x262>
    6400:	bd c3       	rjmp	.+1914   	; 0x6b7c <__divdi3+0x9dc>
    6402:	c8 14       	cp	r12, r8
    6404:	d9 04       	cpc	r13, r9
    6406:	ea 04       	cpc	r14, r10
    6408:	fb 04       	cpc	r15, r11
    640a:	08 f0       	brcs	.+2      	; 0x640e <__divdi3+0x26e>
    640c:	4d c1       	rjmp	.+666    	; 0x66a8 <__divdi3+0x508>
    640e:	00 e0       	ldi	r16, 0x00	; 0
    6410:	80 16       	cp	r8, r16
    6412:	00 e0       	ldi	r16, 0x00	; 0
    6414:	90 06       	cpc	r9, r16
    6416:	01 e0       	ldi	r16, 0x01	; 1
    6418:	a0 06       	cpc	r10, r16
    641a:	00 e0       	ldi	r16, 0x00	; 0
    641c:	b0 06       	cpc	r11, r16
    641e:	58 f4       	brcc	.+22     	; 0x6436 <__divdi3+0x296>
    6420:	1f ef       	ldi	r17, 0xFF	; 255
    6422:	81 16       	cp	r8, r17
    6424:	91 04       	cpc	r9, r1
    6426:	a1 04       	cpc	r10, r1
    6428:	b1 04       	cpc	r11, r1
    642a:	09 f0       	breq	.+2      	; 0x642e <__divdi3+0x28e>
    642c:	90 f4       	brcc	.+36     	; 0x6452 <__divdi3+0x2b2>
    642e:	80 e0       	ldi	r24, 0x00	; 0
    6430:	90 e0       	ldi	r25, 0x00	; 0
    6432:	dc 01       	movw	r26, r24
    6434:	17 c0       	rjmp	.+46     	; 0x6464 <__divdi3+0x2c4>
    6436:	20 e0       	ldi	r18, 0x00	; 0
    6438:	82 16       	cp	r8, r18
    643a:	20 e0       	ldi	r18, 0x00	; 0
    643c:	92 06       	cpc	r9, r18
    643e:	20 e0       	ldi	r18, 0x00	; 0
    6440:	a2 06       	cpc	r10, r18
    6442:	21 e0       	ldi	r18, 0x01	; 1
    6444:	b2 06       	cpc	r11, r18
    6446:	50 f4       	brcc	.+20     	; 0x645c <__divdi3+0x2bc>
    6448:	80 e1       	ldi	r24, 0x10	; 16
    644a:	90 e0       	ldi	r25, 0x00	; 0
    644c:	a0 e0       	ldi	r26, 0x00	; 0
    644e:	b0 e0       	ldi	r27, 0x00	; 0
    6450:	09 c0       	rjmp	.+18     	; 0x6464 <__divdi3+0x2c4>
    6452:	88 e0       	ldi	r24, 0x08	; 8
    6454:	90 e0       	ldi	r25, 0x00	; 0
    6456:	a0 e0       	ldi	r26, 0x00	; 0
    6458:	b0 e0       	ldi	r27, 0x00	; 0
    645a:	04 c0       	rjmp	.+8      	; 0x6464 <__divdi3+0x2c4>
    645c:	88 e1       	ldi	r24, 0x18	; 24
    645e:	90 e0       	ldi	r25, 0x00	; 0
    6460:	a0 e0       	ldi	r26, 0x00	; 0
    6462:	b0 e0       	ldi	r27, 0x00	; 0
    6464:	b5 01       	movw	r22, r10
    6466:	a4 01       	movw	r20, r8
    6468:	08 2e       	mov	r0, r24
    646a:	04 c0       	rjmp	.+8      	; 0x6474 <__divdi3+0x2d4>
    646c:	76 95       	lsr	r23
    646e:	67 95       	ror	r22
    6470:	57 95       	ror	r21
    6472:	47 95       	ror	r20
    6474:	0a 94       	dec	r0
    6476:	d2 f7       	brpl	.-12     	; 0x646c <__divdi3+0x2cc>
    6478:	fa 01       	movw	r30, r20
    647a:	e9 5c       	subi	r30, 0xC9	; 201
    647c:	ff 4d       	sbci	r31, 0xDF	; 223
    647e:	20 81       	ld	r18, Z
    6480:	40 e2       	ldi	r20, 0x20	; 32
    6482:	50 e0       	ldi	r21, 0x00	; 0
    6484:	60 e0       	ldi	r22, 0x00	; 0
    6486:	70 e0       	ldi	r23, 0x00	; 0
    6488:	48 1b       	sub	r20, r24
    648a:	59 0b       	sbc	r21, r25
    648c:	6a 0b       	sbc	r22, r26
    648e:	7b 0b       	sbc	r23, r27
    6490:	42 1b       	sub	r20, r18
    6492:	51 09       	sbc	r21, r1
    6494:	61 09       	sbc	r22, r1
    6496:	71 09       	sbc	r23, r1
    6498:	41 15       	cp	r20, r1
    649a:	51 05       	cpc	r21, r1
    649c:	61 05       	cpc	r22, r1
    649e:	71 05       	cpc	r23, r1
    64a0:	a1 f1       	breq	.+104    	; 0x650a <__divdi3+0x36a>
    64a2:	04 2e       	mov	r0, r20
    64a4:	04 c0       	rjmp	.+8      	; 0x64ae <__divdi3+0x30e>
    64a6:	88 0c       	add	r8, r8
    64a8:	99 1c       	adc	r9, r9
    64aa:	aa 1c       	adc	r10, r10
    64ac:	bb 1c       	adc	r11, r11
    64ae:	0a 94       	dec	r0
    64b0:	d2 f7       	brpl	.-12     	; 0x64a6 <__divdi3+0x306>
    64b2:	97 01       	movw	r18, r14
    64b4:	86 01       	movw	r16, r12
    64b6:	04 2e       	mov	r0, r20
    64b8:	04 c0       	rjmp	.+8      	; 0x64c2 <__divdi3+0x322>
    64ba:	00 0f       	add	r16, r16
    64bc:	11 1f       	adc	r17, r17
    64be:	22 1f       	adc	r18, r18
    64c0:	33 1f       	adc	r19, r19
    64c2:	0a 94       	dec	r0
    64c4:	d2 f7       	brpl	.-12     	; 0x64ba <__divdi3+0x31a>
    64c6:	80 e2       	ldi	r24, 0x20	; 32
    64c8:	90 e0       	ldi	r25, 0x00	; 0
    64ca:	84 1b       	sub	r24, r20
    64cc:	95 0b       	sbc	r25, r21
    64ce:	cd a8       	sts	0x8d, r28
    64d0:	de a8       	sts	0x8e, r29
    64d2:	ef a8       	sts	0x8f, r30
    64d4:	f8 ac       	sts	0xa8, r31
    64d6:	04 c0       	rjmp	.+8      	; 0x64e0 <__divdi3+0x340>
    64d8:	f6 94       	lsr	r15
    64da:	e7 94       	ror	r14
    64dc:	d7 94       	ror	r13
    64de:	c7 94       	ror	r12
    64e0:	8a 95       	dec	r24
    64e2:	d2 f7       	brpl	.-12     	; 0x64d8 <__divdi3+0x338>
    64e4:	c0 2a       	or	r12, r16
    64e6:	d1 2a       	or	r13, r17
    64e8:	e2 2a       	or	r14, r18
    64ea:	f3 2a       	or	r15, r19
    64ec:	0d a9       	sts	0x4d, r16
    64ee:	1e a9       	sts	0x4e, r17
    64f0:	2f a9       	sts	0x4f, r18
    64f2:	38 ad       	sts	0x68, r19
    64f4:	04 c0       	rjmp	.+8      	; 0x64fe <__divdi3+0x35e>
    64f6:	00 0f       	add	r16, r16
    64f8:	11 1f       	adc	r17, r17
    64fa:	22 1f       	adc	r18, r18
    64fc:	33 1f       	adc	r19, r19
    64fe:	4a 95       	dec	r20
    6500:	d2 f7       	brpl	.-12     	; 0x64f6 <__divdi3+0x356>
    6502:	0d ab       	sts	0x5d, r16
    6504:	1e ab       	sts	0x5e, r17
    6506:	2f ab       	sts	0x5f, r18
    6508:	38 af       	sts	0x78, r19
    650a:	25 01       	movw	r4, r10
    650c:	66 24       	eor	r6, r6
    650e:	77 24       	eor	r7, r7
    6510:	95 01       	movw	r18, r10
    6512:	84 01       	movw	r16, r8
    6514:	20 70       	andi	r18, 0x00	; 0
    6516:	30 70       	andi	r19, 0x00	; 0
    6518:	09 ab       	sts	0x59, r16
    651a:	1a ab       	sts	0x5a, r17
    651c:	2b ab       	sts	0x5b, r18
    651e:	3c ab       	sts	0x5c, r19
    6520:	c7 01       	movw	r24, r14
    6522:	b6 01       	movw	r22, r12
    6524:	a3 01       	movw	r20, r6
    6526:	92 01       	movw	r18, r4
    6528:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    652c:	2d a7       	lds	r18, 0x7d
    652e:	3e a7       	lds	r19, 0x7e
    6530:	4f a7       	lds	r20, 0x7f
    6532:	58 ab       	sts	0x58, r21
    6534:	69 a7       	lds	r22, 0x79
    6536:	7a a7       	lds	r23, 0x7a
    6538:	8b a7       	lds	r24, 0x7b
    653a:	9c a7       	lds	r25, 0x7c
    653c:	c7 01       	movw	r24, r14
    653e:	b6 01       	movw	r22, r12
    6540:	a3 01       	movw	r20, r6
    6542:	92 01       	movw	r18, r4
    6544:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6548:	ca 01       	movw	r24, r20
    654a:	b9 01       	movw	r22, r18
    654c:	29 a9       	sts	0x49, r18
    654e:	3a a9       	sts	0x4a, r19
    6550:	4b a9       	sts	0x4b, r20
    6552:	5c a9       	sts	0x4c, r21
    6554:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6558:	ab 01       	movw	r20, r22
    655a:	bc 01       	movw	r22, r24
    655c:	09 a5       	lds	r16, 0x69
    655e:	1a a5       	lds	r17, 0x6a
    6560:	2b a5       	lds	r18, 0x6b
    6562:	3c a5       	lds	r19, 0x6c
    6564:	78 01       	movw	r14, r16
    6566:	dd 24       	eor	r13, r13
    6568:	cc 24       	eor	r12, r12
    656a:	0d a9       	sts	0x4d, r16
    656c:	1e a9       	sts	0x4e, r17
    656e:	2f a9       	sts	0x4f, r18
    6570:	38 ad       	sts	0x68, r19
    6572:	c9 01       	movw	r24, r18
    6574:	aa 27       	eor	r26, r26
    6576:	bb 27       	eor	r27, r27
    6578:	c8 2a       	or	r12, r24
    657a:	d9 2a       	or	r13, r25
    657c:	ea 2a       	or	r14, r26
    657e:	fb 2a       	or	r15, r27
    6580:	0d a5       	lds	r16, 0x6d
    6582:	1e a5       	lds	r17, 0x6e
    6584:	2f a5       	lds	r18, 0x6f
    6586:	38 a9       	sts	0x48, r19
    6588:	c4 16       	cp	r12, r20
    658a:	d5 06       	cpc	r13, r21
    658c:	e6 06       	cpc	r14, r22
    658e:	f7 06       	cpc	r15, r23
    6590:	38 f5       	brcc	.+78     	; 0x65e0 <__divdi3+0x440>
    6592:	01 50       	subi	r16, 0x01	; 1
    6594:	10 40       	sbci	r17, 0x00	; 0
    6596:	20 40       	sbci	r18, 0x00	; 0
    6598:	30 40       	sbci	r19, 0x00	; 0
    659a:	09 a7       	lds	r16, 0x79
    659c:	1a a7       	lds	r17, 0x7a
    659e:	2b a7       	lds	r18, 0x7b
    65a0:	3c a7       	lds	r19, 0x7c
    65a2:	c8 0c       	add	r12, r8
    65a4:	d9 1c       	adc	r13, r9
    65a6:	ea 1c       	adc	r14, r10
    65a8:	fb 1c       	adc	r15, r11
    65aa:	c8 14       	cp	r12, r8
    65ac:	d9 04       	cpc	r13, r9
    65ae:	ea 04       	cpc	r14, r10
    65b0:	fb 04       	cpc	r15, r11
    65b2:	d0 f0       	brcs	.+52     	; 0x65e8 <__divdi3+0x448>
    65b4:	c4 16       	cp	r12, r20
    65b6:	d5 06       	cpc	r13, r21
    65b8:	e6 06       	cpc	r14, r22
    65ba:	f7 06       	cpc	r15, r23
    65bc:	a8 f4       	brcc	.+42     	; 0x65e8 <__divdi3+0x448>
    65be:	0d a5       	lds	r16, 0x6d
    65c0:	1e a5       	lds	r17, 0x6e
    65c2:	2f a5       	lds	r18, 0x6f
    65c4:	38 a9       	sts	0x48, r19
    65c6:	02 50       	subi	r16, 0x02	; 2
    65c8:	10 40       	sbci	r17, 0x00	; 0
    65ca:	20 40       	sbci	r18, 0x00	; 0
    65cc:	30 40       	sbci	r19, 0x00	; 0
    65ce:	09 a7       	lds	r16, 0x79
    65d0:	1a a7       	lds	r17, 0x7a
    65d2:	2b a7       	lds	r18, 0x7b
    65d4:	3c a7       	lds	r19, 0x7c
    65d6:	c8 0c       	add	r12, r8
    65d8:	d9 1c       	adc	r13, r9
    65da:	ea 1c       	adc	r14, r10
    65dc:	fb 1c       	adc	r15, r11
    65de:	04 c0       	rjmp	.+8      	; 0x65e8 <__divdi3+0x448>
    65e0:	09 a7       	lds	r16, 0x79
    65e2:	1a a7       	lds	r17, 0x7a
    65e4:	2b a7       	lds	r18, 0x7b
    65e6:	3c a7       	lds	r19, 0x7c
    65e8:	c4 1a       	sub	r12, r20
    65ea:	d5 0a       	sbc	r13, r21
    65ec:	e6 0a       	sbc	r14, r22
    65ee:	f7 0a       	sbc	r15, r23
    65f0:	c7 01       	movw	r24, r14
    65f2:	b6 01       	movw	r22, r12
    65f4:	a3 01       	movw	r20, r6
    65f6:	92 01       	movw	r18, r4
    65f8:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    65fc:	2d a7       	lds	r18, 0x7d
    65fe:	3e a7       	lds	r19, 0x7e
    6600:	4f a7       	lds	r20, 0x7f
    6602:	58 ab       	sts	0x58, r21
    6604:	69 af       	sts	0x79, r22
    6606:	7a af       	sts	0x7a, r23
    6608:	8b af       	sts	0x7b, r24
    660a:	9c af       	sts	0x7c, r25
    660c:	c7 01       	movw	r24, r14
    660e:	b6 01       	movw	r22, r12
    6610:	a3 01       	movw	r20, r6
    6612:	92 01       	movw	r18, r4
    6614:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6618:	ca 01       	movw	r24, r20
    661a:	b9 01       	movw	r22, r18
    661c:	29 a9       	sts	0x49, r18
    661e:	3a a9       	sts	0x4a, r19
    6620:	4b a9       	sts	0x4b, r20
    6622:	5c a9       	sts	0x4c, r21
    6624:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6628:	6b 01       	movw	r12, r22
    662a:	7c 01       	movw	r14, r24
    662c:	49 ad       	sts	0x69, r20
    662e:	5a ad       	sts	0x6a, r21
    6630:	6b ad       	sts	0x6b, r22
    6632:	7c ad       	sts	0x6c, r23
    6634:	9a 01       	movw	r18, r20
    6636:	11 27       	eor	r17, r17
    6638:	00 27       	eor	r16, r16
    663a:	4d a9       	sts	0x4d, r20
    663c:	5e a9       	sts	0x4e, r21
    663e:	6f a9       	sts	0x4f, r22
    6640:	78 ad       	sts	0x68, r23
    6642:	60 70       	andi	r22, 0x00	; 0
    6644:	70 70       	andi	r23, 0x00	; 0
    6646:	04 2b       	or	r16, r20
    6648:	15 2b       	or	r17, r21
    664a:	26 2b       	or	r18, r22
    664c:	37 2b       	or	r19, r23
    664e:	8d a5       	lds	r24, 0x6d
    6650:	9e a5       	lds	r25, 0x6e
    6652:	af a5       	lds	r26, 0x6f
    6654:	b8 a9       	sts	0x48, r27
    6656:	0c 15       	cp	r16, r12
    6658:	1d 05       	cpc	r17, r13
    665a:	2e 05       	cpc	r18, r14
    665c:	3f 05       	cpc	r19, r15
    665e:	c0 f4       	brcc	.+48     	; 0x6690 <__divdi3+0x4f0>
    6660:	01 97       	sbiw	r24, 0x01	; 1
    6662:	a1 09       	sbc	r26, r1
    6664:	b1 09       	sbc	r27, r1
    6666:	08 0d       	add	r16, r8
    6668:	19 1d       	adc	r17, r9
    666a:	2a 1d       	adc	r18, r10
    666c:	3b 1d       	adc	r19, r11
    666e:	08 15       	cp	r16, r8
    6670:	19 05       	cpc	r17, r9
    6672:	2a 05       	cpc	r18, r10
    6674:	3b 05       	cpc	r19, r11
    6676:	60 f0       	brcs	.+24     	; 0x6690 <__divdi3+0x4f0>
    6678:	0c 15       	cp	r16, r12
    667a:	1d 05       	cpc	r17, r13
    667c:	2e 05       	cpc	r18, r14
    667e:	3f 05       	cpc	r19, r15
    6680:	38 f4       	brcc	.+14     	; 0x6690 <__divdi3+0x4f0>
    6682:	8d a5       	lds	r24, 0x6d
    6684:	9e a5       	lds	r25, 0x6e
    6686:	af a5       	lds	r26, 0x6f
    6688:	b8 a9       	sts	0x48, r27
    668a:	02 97       	sbiw	r24, 0x02	; 2
    668c:	a1 09       	sbc	r26, r1
    668e:	b1 09       	sbc	r27, r1
    6690:	09 a5       	lds	r16, 0x69
    6692:	1a a5       	lds	r17, 0x6a
    6694:	2b a5       	lds	r18, 0x6b
    6696:	3c a5       	lds	r19, 0x6c
    6698:	78 01       	movw	r14, r16
    669a:	dd 24       	eor	r13, r13
    669c:	cc 24       	eor	r12, r12
    669e:	c8 2a       	or	r12, r24
    66a0:	d9 2a       	or	r13, r25
    66a2:	ea 2a       	or	r14, r26
    66a4:	fb 2a       	or	r15, r27
    66a6:	b7 c4       	rjmp	.+2414   	; 0x7016 <__divdi3+0xe76>
    66a8:	81 14       	cp	r8, r1
    66aa:	91 04       	cpc	r9, r1
    66ac:	a1 04       	cpc	r10, r1
    66ae:	b1 04       	cpc	r11, r1
    66b0:	51 f4       	brne	.+20     	; 0x66c6 <__divdi3+0x526>
    66b2:	61 e0       	ldi	r22, 0x01	; 1
    66b4:	70 e0       	ldi	r23, 0x00	; 0
    66b6:	80 e0       	ldi	r24, 0x00	; 0
    66b8:	90 e0       	ldi	r25, 0x00	; 0
    66ba:	a5 01       	movw	r20, r10
    66bc:	94 01       	movw	r18, r8
    66be:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    66c2:	49 01       	movw	r8, r18
    66c4:	5a 01       	movw	r10, r20
    66c6:	10 e0       	ldi	r17, 0x00	; 0
    66c8:	81 16       	cp	r8, r17
    66ca:	10 e0       	ldi	r17, 0x00	; 0
    66cc:	91 06       	cpc	r9, r17
    66ce:	11 e0       	ldi	r17, 0x01	; 1
    66d0:	a1 06       	cpc	r10, r17
    66d2:	10 e0       	ldi	r17, 0x00	; 0
    66d4:	b1 06       	cpc	r11, r17
    66d6:	58 f4       	brcc	.+22     	; 0x66ee <__divdi3+0x54e>
    66d8:	2f ef       	ldi	r18, 0xFF	; 255
    66da:	82 16       	cp	r8, r18
    66dc:	91 04       	cpc	r9, r1
    66de:	a1 04       	cpc	r10, r1
    66e0:	b1 04       	cpc	r11, r1
    66e2:	09 f0       	breq	.+2      	; 0x66e6 <__divdi3+0x546>
    66e4:	90 f4       	brcc	.+36     	; 0x670a <__divdi3+0x56a>
    66e6:	80 e0       	ldi	r24, 0x00	; 0
    66e8:	90 e0       	ldi	r25, 0x00	; 0
    66ea:	dc 01       	movw	r26, r24
    66ec:	17 c0       	rjmp	.+46     	; 0x671c <__divdi3+0x57c>
    66ee:	30 e0       	ldi	r19, 0x00	; 0
    66f0:	83 16       	cp	r8, r19
    66f2:	30 e0       	ldi	r19, 0x00	; 0
    66f4:	93 06       	cpc	r9, r19
    66f6:	30 e0       	ldi	r19, 0x00	; 0
    66f8:	a3 06       	cpc	r10, r19
    66fa:	31 e0       	ldi	r19, 0x01	; 1
    66fc:	b3 06       	cpc	r11, r19
    66fe:	50 f4       	brcc	.+20     	; 0x6714 <__divdi3+0x574>
    6700:	80 e1       	ldi	r24, 0x10	; 16
    6702:	90 e0       	ldi	r25, 0x00	; 0
    6704:	a0 e0       	ldi	r26, 0x00	; 0
    6706:	b0 e0       	ldi	r27, 0x00	; 0
    6708:	09 c0       	rjmp	.+18     	; 0x671c <__divdi3+0x57c>
    670a:	88 e0       	ldi	r24, 0x08	; 8
    670c:	90 e0       	ldi	r25, 0x00	; 0
    670e:	a0 e0       	ldi	r26, 0x00	; 0
    6710:	b0 e0       	ldi	r27, 0x00	; 0
    6712:	04 c0       	rjmp	.+8      	; 0x671c <__divdi3+0x57c>
    6714:	88 e1       	ldi	r24, 0x18	; 24
    6716:	90 e0       	ldi	r25, 0x00	; 0
    6718:	a0 e0       	ldi	r26, 0x00	; 0
    671a:	b0 e0       	ldi	r27, 0x00	; 0
    671c:	b5 01       	movw	r22, r10
    671e:	a4 01       	movw	r20, r8
    6720:	08 2e       	mov	r0, r24
    6722:	04 c0       	rjmp	.+8      	; 0x672c <__divdi3+0x58c>
    6724:	76 95       	lsr	r23
    6726:	67 95       	ror	r22
    6728:	57 95       	ror	r21
    672a:	47 95       	ror	r20
    672c:	0a 94       	dec	r0
    672e:	d2 f7       	brpl	.-12     	; 0x6724 <__divdi3+0x584>
    6730:	fa 01       	movw	r30, r20
    6732:	e9 5c       	subi	r30, 0xC9	; 201
    6734:	ff 4d       	sbci	r31, 0xDF	; 223
    6736:	20 81       	ld	r18, Z
    6738:	ac 01       	movw	r20, r24
    673a:	bd 01       	movw	r22, r26
    673c:	42 0f       	add	r20, r18
    673e:	51 1d       	adc	r21, r1
    6740:	61 1d       	adc	r22, r1
    6742:	71 1d       	adc	r23, r1
    6744:	80 e2       	ldi	r24, 0x20	; 32
    6746:	90 e0       	ldi	r25, 0x00	; 0
    6748:	a0 e0       	ldi	r26, 0x00	; 0
    674a:	b0 e0       	ldi	r27, 0x00	; 0
    674c:	84 1b       	sub	r24, r20
    674e:	95 0b       	sbc	r25, r21
    6750:	a6 0b       	sbc	r26, r22
    6752:	b7 0b       	sbc	r27, r23
    6754:	51 f4       	brne	.+20     	; 0x676a <__divdi3+0x5ca>
    6756:	c8 18       	sub	r12, r8
    6758:	d9 08       	sbc	r13, r9
    675a:	ea 08       	sbc	r14, r10
    675c:	fb 08       	sbc	r15, r11
    675e:	f1 e0       	ldi	r31, 0x01	; 1
    6760:	4f 2e       	mov	r4, r31
    6762:	51 2c       	mov	r5, r1
    6764:	61 2c       	mov	r6, r1
    6766:	71 2c       	mov	r7, r1
    6768:	28 c1       	rjmp	.+592    	; 0x69ba <__divdi3+0x81a>
    676a:	08 2e       	mov	r0, r24
    676c:	04 c0       	rjmp	.+8      	; 0x6776 <__divdi3+0x5d6>
    676e:	88 0c       	add	r8, r8
    6770:	99 1c       	adc	r9, r9
    6772:	aa 1c       	adc	r10, r10
    6774:	bb 1c       	adc	r11, r11
    6776:	0a 94       	dec	r0
    6778:	d2 f7       	brpl	.-12     	; 0x676e <__divdi3+0x5ce>
    677a:	97 01       	movw	r18, r14
    677c:	86 01       	movw	r16, r12
    677e:	04 2e       	mov	r0, r20
    6780:	04 c0       	rjmp	.+8      	; 0x678a <__divdi3+0x5ea>
    6782:	36 95       	lsr	r19
    6784:	27 95       	ror	r18
    6786:	17 95       	ror	r17
    6788:	07 95       	ror	r16
    678a:	0a 94       	dec	r0
    678c:	d2 f7       	brpl	.-12     	; 0x6782 <__divdi3+0x5e2>
    678e:	09 ab       	sts	0x59, r16
    6790:	1a ab       	sts	0x5a, r17
    6792:	2b ab       	sts	0x5b, r18
    6794:	3c ab       	sts	0x5c, r19
    6796:	97 01       	movw	r18, r14
    6798:	86 01       	movw	r16, r12
    679a:	08 2e       	mov	r0, r24
    679c:	04 c0       	rjmp	.+8      	; 0x67a6 <__divdi3+0x606>
    679e:	00 0f       	add	r16, r16
    67a0:	11 1f       	adc	r17, r17
    67a2:	22 1f       	adc	r18, r18
    67a4:	33 1f       	adc	r19, r19
    67a6:	0a 94       	dec	r0
    67a8:	d2 f7       	brpl	.-12     	; 0x679e <__divdi3+0x5fe>
    67aa:	0d a7       	lds	r16, 0x7d
    67ac:	1e a7       	lds	r17, 0x7e
    67ae:	2f a7       	lds	r18, 0x7f
    67b0:	38 ab       	sts	0x58, r19
    67b2:	ed a8       	sts	0x8d, r30
    67b4:	fe a8       	sts	0x8e, r31
    67b6:	0f a9       	sts	0x4f, r16
    67b8:	18 ad       	sts	0x68, r17
    67ba:	04 c0       	rjmp	.+8      	; 0x67c4 <__divdi3+0x624>
    67bc:	16 95       	lsr	r17
    67be:	07 95       	ror	r16
    67c0:	f7 94       	ror	r15
    67c2:	e7 94       	ror	r14
    67c4:	4a 95       	dec	r20
    67c6:	d2 f7       	brpl	.-12     	; 0x67bc <__divdi3+0x61c>
    67c8:	b8 01       	movw	r22, r16
    67ca:	a7 01       	movw	r20, r14
    67cc:	0d a5       	lds	r16, 0x6d
    67ce:	1e a5       	lds	r17, 0x6e
    67d0:	2f a5       	lds	r18, 0x6f
    67d2:	38 a9       	sts	0x48, r19
    67d4:	04 2b       	or	r16, r20
    67d6:	15 2b       	or	r17, r21
    67d8:	26 2b       	or	r18, r22
    67da:	37 2b       	or	r19, r23
    67dc:	0d a7       	lds	r16, 0x7d
    67de:	1e a7       	lds	r17, 0x7e
    67e0:	2f a7       	lds	r18, 0x7f
    67e2:	38 ab       	sts	0x58, r19
    67e4:	ed a8       	sts	0x8d, r30
    67e6:	fe a8       	sts	0x8e, r31
    67e8:	0f a9       	sts	0x4f, r16
    67ea:	18 ad       	sts	0x68, r17
    67ec:	04 c0       	rjmp	.+8      	; 0x67f6 <__divdi3+0x656>
    67ee:	ee 0c       	add	r14, r14
    67f0:	ff 1c       	adc	r15, r15
    67f2:	00 1f       	adc	r16, r16
    67f4:	11 1f       	adc	r17, r17
    67f6:	8a 95       	dec	r24
    67f8:	d2 f7       	brpl	.-12     	; 0x67ee <__divdi3+0x64e>
    67fa:	ed aa       	sts	0x9d, r30
    67fc:	fe aa       	sts	0x9e, r31
    67fe:	0f ab       	sts	0x5f, r16
    6800:	18 af       	sts	0x78, r17
    6802:	25 01       	movw	r4, r10
    6804:	66 24       	eor	r6, r6
    6806:	77 24       	eor	r7, r7
    6808:	95 01       	movw	r18, r10
    680a:	84 01       	movw	r16, r8
    680c:	20 70       	andi	r18, 0x00	; 0
    680e:	30 70       	andi	r19, 0x00	; 0
    6810:	09 af       	sts	0x79, r16
    6812:	1a af       	sts	0x7a, r17
    6814:	2b af       	sts	0x7b, r18
    6816:	3c af       	sts	0x7c, r19
    6818:	69 a9       	sts	0x49, r22
    681a:	7a a9       	sts	0x4a, r23
    681c:	8b a9       	sts	0x4b, r24
    681e:	9c a9       	sts	0x4c, r25
    6820:	a3 01       	movw	r20, r6
    6822:	92 01       	movw	r18, r4
    6824:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6828:	29 a7       	lds	r18, 0x79
    682a:	3a a7       	lds	r19, 0x7a
    682c:	4b a7       	lds	r20, 0x7b
    682e:	5c a7       	lds	r21, 0x7c
    6830:	6b 01       	movw	r12, r22
    6832:	7c 01       	movw	r14, r24
    6834:	69 a9       	sts	0x49, r22
    6836:	7a a9       	sts	0x4a, r23
    6838:	8b a9       	sts	0x4b, r24
    683a:	9c a9       	sts	0x4c, r25
    683c:	a3 01       	movw	r20, r6
    683e:	92 01       	movw	r18, r4
    6840:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6844:	ca 01       	movw	r24, r20
    6846:	b9 01       	movw	r22, r18
    6848:	29 ad       	sts	0x69, r18
    684a:	3a ad       	sts	0x6a, r19
    684c:	4b ad       	sts	0x6b, r20
    684e:	5c ad       	sts	0x6c, r21
    6850:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6854:	ab 01       	movw	r20, r22
    6856:	bc 01       	movw	r22, r24
    6858:	76 01       	movw	r14, r12
    685a:	dd 24       	eor	r13, r13
    685c:	cc 24       	eor	r12, r12
    685e:	0d a5       	lds	r16, 0x6d
    6860:	1e a5       	lds	r17, 0x6e
    6862:	2f a5       	lds	r18, 0x6f
    6864:	38 a9       	sts	0x48, r19
    6866:	c9 01       	movw	r24, r18
    6868:	aa 27       	eor	r26, r26
    686a:	bb 27       	eor	r27, r27
    686c:	c8 2a       	or	r12, r24
    686e:	d9 2a       	or	r13, r25
    6870:	ea 2a       	or	r14, r26
    6872:	fb 2a       	or	r15, r27
    6874:	09 a5       	lds	r16, 0x69
    6876:	1a a5       	lds	r17, 0x6a
    6878:	2b a5       	lds	r18, 0x6b
    687a:	3c a5       	lds	r19, 0x6c
    687c:	c4 16       	cp	r12, r20
    687e:	d5 06       	cpc	r13, r21
    6880:	e6 06       	cpc	r14, r22
    6882:	f7 06       	cpc	r15, r23
    6884:	38 f5       	brcc	.+78     	; 0x68d4 <__divdi3+0x734>
    6886:	01 50       	subi	r16, 0x01	; 1
    6888:	10 40       	sbci	r17, 0x00	; 0
    688a:	20 40       	sbci	r18, 0x00	; 0
    688c:	30 40       	sbci	r19, 0x00	; 0
    688e:	09 ab       	sts	0x59, r16
    6890:	1a ab       	sts	0x5a, r17
    6892:	2b ab       	sts	0x5b, r18
    6894:	3c ab       	sts	0x5c, r19
    6896:	c8 0c       	add	r12, r8
    6898:	d9 1c       	adc	r13, r9
    689a:	ea 1c       	adc	r14, r10
    689c:	fb 1c       	adc	r15, r11
    689e:	c8 14       	cp	r12, r8
    68a0:	d9 04       	cpc	r13, r9
    68a2:	ea 04       	cpc	r14, r10
    68a4:	fb 04       	cpc	r15, r11
    68a6:	d0 f0       	brcs	.+52     	; 0x68dc <__divdi3+0x73c>
    68a8:	c4 16       	cp	r12, r20
    68aa:	d5 06       	cpc	r13, r21
    68ac:	e6 06       	cpc	r14, r22
    68ae:	f7 06       	cpc	r15, r23
    68b0:	a8 f4       	brcc	.+42     	; 0x68dc <__divdi3+0x73c>
    68b2:	09 a5       	lds	r16, 0x69
    68b4:	1a a5       	lds	r17, 0x6a
    68b6:	2b a5       	lds	r18, 0x6b
    68b8:	3c a5       	lds	r19, 0x6c
    68ba:	02 50       	subi	r16, 0x02	; 2
    68bc:	10 40       	sbci	r17, 0x00	; 0
    68be:	20 40       	sbci	r18, 0x00	; 0
    68c0:	30 40       	sbci	r19, 0x00	; 0
    68c2:	09 ab       	sts	0x59, r16
    68c4:	1a ab       	sts	0x5a, r17
    68c6:	2b ab       	sts	0x5b, r18
    68c8:	3c ab       	sts	0x5c, r19
    68ca:	c8 0c       	add	r12, r8
    68cc:	d9 1c       	adc	r13, r9
    68ce:	ea 1c       	adc	r14, r10
    68d0:	fb 1c       	adc	r15, r11
    68d2:	04 c0       	rjmp	.+8      	; 0x68dc <__divdi3+0x73c>
    68d4:	09 ab       	sts	0x59, r16
    68d6:	1a ab       	sts	0x5a, r17
    68d8:	2b ab       	sts	0x5b, r18
    68da:	3c ab       	sts	0x5c, r19
    68dc:	c4 1a       	sub	r12, r20
    68de:	d5 0a       	sbc	r13, r21
    68e0:	e6 0a       	sbc	r14, r22
    68e2:	f7 0a       	sbc	r15, r23
    68e4:	c7 01       	movw	r24, r14
    68e6:	b6 01       	movw	r22, r12
    68e8:	a3 01       	movw	r20, r6
    68ea:	92 01       	movw	r18, r4
    68ec:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    68f0:	29 a7       	lds	r18, 0x79
    68f2:	3a a7       	lds	r19, 0x7a
    68f4:	4b a7       	lds	r20, 0x7b
    68f6:	5c a7       	lds	r21, 0x7c
    68f8:	21 96       	adiw	r28, 0x01	; 1
    68fa:	6c af       	sts	0x7c, r22
    68fc:	7d af       	sts	0x7d, r23
    68fe:	8e af       	sts	0x7e, r24
    6900:	9f af       	sts	0x7f, r25
    6902:	21 97       	sbiw	r28, 0x01	; 1
    6904:	c7 01       	movw	r24, r14
    6906:	b6 01       	movw	r22, r12
    6908:	a3 01       	movw	r20, r6
    690a:	92 01       	movw	r18, r4
    690c:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6910:	ca 01       	movw	r24, r20
    6912:	b9 01       	movw	r22, r18
    6914:	29 ad       	sts	0x69, r18
    6916:	3a ad       	sts	0x6a, r19
    6918:	4b ad       	sts	0x6b, r20
    691a:	5c ad       	sts	0x6c, r21
    691c:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6920:	8b 01       	movw	r16, r22
    6922:	9c 01       	movw	r18, r24
    6924:	21 96       	adiw	r28, 0x01	; 1
    6926:	4c ad       	sts	0x6c, r20
    6928:	5d ad       	sts	0x6d, r21
    692a:	6e ad       	sts	0x6e, r22
    692c:	7f ad       	sts	0x6f, r23
    692e:	21 97       	sbiw	r28, 0x01	; 1
    6930:	da 01       	movw	r26, r20
    6932:	99 27       	eor	r25, r25
    6934:	88 27       	eor	r24, r24
    6936:	4d a5       	lds	r20, 0x6d
    6938:	5e a5       	lds	r21, 0x6e
    693a:	6f a5       	lds	r22, 0x6f
    693c:	78 a9       	sts	0x48, r23
    693e:	60 70       	andi	r22, 0x00	; 0
    6940:	70 70       	andi	r23, 0x00	; 0
    6942:	84 2b       	or	r24, r20
    6944:	95 2b       	or	r25, r21
    6946:	a6 2b       	or	r26, r22
    6948:	b7 2b       	or	r27, r23
    694a:	49 a5       	lds	r20, 0x69
    694c:	5a a5       	lds	r21, 0x6a
    694e:	6b a5       	lds	r22, 0x6b
    6950:	7c a5       	lds	r23, 0x6c
    6952:	80 17       	cp	r24, r16
    6954:	91 07       	cpc	r25, r17
    6956:	a2 07       	cpc	r26, r18
    6958:	b3 07       	cpc	r27, r19
    695a:	f0 f4       	brcc	.+60     	; 0x6998 <__divdi3+0x7f8>
    695c:	41 50       	subi	r20, 0x01	; 1
    695e:	50 40       	sbci	r21, 0x00	; 0
    6960:	60 40       	sbci	r22, 0x00	; 0
    6962:	70 40       	sbci	r23, 0x00	; 0
    6964:	88 0d       	add	r24, r8
    6966:	99 1d       	adc	r25, r9
    6968:	aa 1d       	adc	r26, r10
    696a:	bb 1d       	adc	r27, r11
    696c:	88 15       	cp	r24, r8
    696e:	99 05       	cpc	r25, r9
    6970:	aa 05       	cpc	r26, r10
    6972:	bb 05       	cpc	r27, r11
    6974:	88 f0       	brcs	.+34     	; 0x6998 <__divdi3+0x7f8>
    6976:	80 17       	cp	r24, r16
    6978:	91 07       	cpc	r25, r17
    697a:	a2 07       	cpc	r26, r18
    697c:	b3 07       	cpc	r27, r19
    697e:	60 f4       	brcc	.+24     	; 0x6998 <__divdi3+0x7f8>
    6980:	49 a5       	lds	r20, 0x69
    6982:	5a a5       	lds	r21, 0x6a
    6984:	6b a5       	lds	r22, 0x6b
    6986:	7c a5       	lds	r23, 0x6c
    6988:	42 50       	subi	r20, 0x02	; 2
    698a:	50 40       	sbci	r21, 0x00	; 0
    698c:	60 40       	sbci	r22, 0x00	; 0
    698e:	70 40       	sbci	r23, 0x00	; 0
    6990:	88 0d       	add	r24, r8
    6992:	99 1d       	adc	r25, r9
    6994:	aa 1d       	adc	r26, r10
    6996:	bb 1d       	adc	r27, r11
    6998:	6c 01       	movw	r12, r24
    699a:	7d 01       	movw	r14, r26
    699c:	c0 1a       	sub	r12, r16
    699e:	d1 0a       	sbc	r13, r17
    69a0:	e2 0a       	sbc	r14, r18
    69a2:	f3 0a       	sbc	r15, r19
    69a4:	09 a9       	sts	0x49, r16
    69a6:	1a a9       	sts	0x4a, r17
    69a8:	2b a9       	sts	0x4b, r18
    69aa:	3c a9       	sts	0x4c, r19
    69ac:	38 01       	movw	r6, r16
    69ae:	55 24       	eor	r5, r5
    69b0:	44 24       	eor	r4, r4
    69b2:	44 2a       	or	r4, r20
    69b4:	55 2a       	or	r5, r21
    69b6:	66 2a       	or	r6, r22
    69b8:	77 2a       	or	r7, r23
    69ba:	85 01       	movw	r16, r10
    69bc:	22 27       	eor	r18, r18
    69be:	33 27       	eor	r19, r19
    69c0:	0d a7       	lds	r16, 0x7d
    69c2:	1e a7       	lds	r17, 0x7e
    69c4:	2f a7       	lds	r18, 0x7f
    69c6:	38 ab       	sts	0x58, r19
    69c8:	95 01       	movw	r18, r10
    69ca:	84 01       	movw	r16, r8
    69cc:	20 70       	andi	r18, 0x00	; 0
    69ce:	30 70       	andi	r19, 0x00	; 0
    69d0:	09 af       	sts	0x79, r16
    69d2:	1a af       	sts	0x7a, r17
    69d4:	2b af       	sts	0x7b, r18
    69d6:	3c af       	sts	0x7c, r19
    69d8:	c7 01       	movw	r24, r14
    69da:	b6 01       	movw	r22, r12
    69dc:	2d a5       	lds	r18, 0x6d
    69de:	3e a5       	lds	r19, 0x6e
    69e0:	4f a5       	lds	r20, 0x6f
    69e2:	58 a9       	sts	0x48, r21
    69e4:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    69e8:	29 a7       	lds	r18, 0x79
    69ea:	3a a7       	lds	r19, 0x7a
    69ec:	4b a7       	lds	r20, 0x7b
    69ee:	5c a7       	lds	r21, 0x7c
    69f0:	69 ab       	sts	0x59, r22
    69f2:	7a ab       	sts	0x5a, r23
    69f4:	8b ab       	sts	0x5b, r24
    69f6:	9c ab       	sts	0x5c, r25
    69f8:	c7 01       	movw	r24, r14
    69fa:	b6 01       	movw	r22, r12
    69fc:	2d a5       	lds	r18, 0x6d
    69fe:	3e a5       	lds	r19, 0x6e
    6a00:	4f a5       	lds	r20, 0x6f
    6a02:	58 a9       	sts	0x48, r21
    6a04:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6a08:	ca 01       	movw	r24, r20
    6a0a:	b9 01       	movw	r22, r18
    6a0c:	29 ad       	sts	0x69, r18
    6a0e:	3a ad       	sts	0x6a, r19
    6a10:	4b ad       	sts	0x6b, r20
    6a12:	5c ad       	sts	0x6c, r21
    6a14:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6a18:	ab 01       	movw	r20, r22
    6a1a:	bc 01       	movw	r22, r24
    6a1c:	09 a9       	sts	0x49, r16
    6a1e:	1a a9       	sts	0x4a, r17
    6a20:	2b a9       	sts	0x4b, r18
    6a22:	3c a9       	sts	0x4c, r19
    6a24:	78 01       	movw	r14, r16
    6a26:	dd 24       	eor	r13, r13
    6a28:	cc 24       	eor	r12, r12
    6a2a:	0d a9       	sts	0x4d, r16
    6a2c:	1e a9       	sts	0x4e, r17
    6a2e:	2f a9       	sts	0x4f, r18
    6a30:	38 ad       	sts	0x68, r19
    6a32:	c9 01       	movw	r24, r18
    6a34:	aa 27       	eor	r26, r26
    6a36:	bb 27       	eor	r27, r27
    6a38:	c8 2a       	or	r12, r24
    6a3a:	d9 2a       	or	r13, r25
    6a3c:	ea 2a       	or	r14, r26
    6a3e:	fb 2a       	or	r15, r27
    6a40:	09 a5       	lds	r16, 0x69
    6a42:	1a a5       	lds	r17, 0x6a
    6a44:	2b a5       	lds	r18, 0x6b
    6a46:	3c a5       	lds	r19, 0x6c
    6a48:	c4 16       	cp	r12, r20
    6a4a:	d5 06       	cpc	r13, r21
    6a4c:	e6 06       	cpc	r14, r22
    6a4e:	f7 06       	cpc	r15, r23
    6a50:	38 f5       	brcc	.+78     	; 0x6aa0 <__divdi3+0x900>
    6a52:	01 50       	subi	r16, 0x01	; 1
    6a54:	10 40       	sbci	r17, 0x00	; 0
    6a56:	20 40       	sbci	r18, 0x00	; 0
    6a58:	30 40       	sbci	r19, 0x00	; 0
    6a5a:	09 ab       	sts	0x59, r16
    6a5c:	1a ab       	sts	0x5a, r17
    6a5e:	2b ab       	sts	0x5b, r18
    6a60:	3c ab       	sts	0x5c, r19
    6a62:	c8 0c       	add	r12, r8
    6a64:	d9 1c       	adc	r13, r9
    6a66:	ea 1c       	adc	r14, r10
    6a68:	fb 1c       	adc	r15, r11
    6a6a:	c8 14       	cp	r12, r8
    6a6c:	d9 04       	cpc	r13, r9
    6a6e:	ea 04       	cpc	r14, r10
    6a70:	fb 04       	cpc	r15, r11
    6a72:	d0 f0       	brcs	.+52     	; 0x6aa8 <__divdi3+0x908>
    6a74:	c4 16       	cp	r12, r20
    6a76:	d5 06       	cpc	r13, r21
    6a78:	e6 06       	cpc	r14, r22
    6a7a:	f7 06       	cpc	r15, r23
    6a7c:	a8 f4       	brcc	.+42     	; 0x6aa8 <__divdi3+0x908>
    6a7e:	09 a5       	lds	r16, 0x69
    6a80:	1a a5       	lds	r17, 0x6a
    6a82:	2b a5       	lds	r18, 0x6b
    6a84:	3c a5       	lds	r19, 0x6c
    6a86:	02 50       	subi	r16, 0x02	; 2
    6a88:	10 40       	sbci	r17, 0x00	; 0
    6a8a:	20 40       	sbci	r18, 0x00	; 0
    6a8c:	30 40       	sbci	r19, 0x00	; 0
    6a8e:	09 ab       	sts	0x59, r16
    6a90:	1a ab       	sts	0x5a, r17
    6a92:	2b ab       	sts	0x5b, r18
    6a94:	3c ab       	sts	0x5c, r19
    6a96:	c8 0c       	add	r12, r8
    6a98:	d9 1c       	adc	r13, r9
    6a9a:	ea 1c       	adc	r14, r10
    6a9c:	fb 1c       	adc	r15, r11
    6a9e:	04 c0       	rjmp	.+8      	; 0x6aa8 <__divdi3+0x908>
    6aa0:	09 ab       	sts	0x59, r16
    6aa2:	1a ab       	sts	0x5a, r17
    6aa4:	2b ab       	sts	0x5b, r18
    6aa6:	3c ab       	sts	0x5c, r19
    6aa8:	c4 1a       	sub	r12, r20
    6aaa:	d5 0a       	sbc	r13, r21
    6aac:	e6 0a       	sbc	r14, r22
    6aae:	f7 0a       	sbc	r15, r23
    6ab0:	c7 01       	movw	r24, r14
    6ab2:	b6 01       	movw	r22, r12
    6ab4:	2d a5       	lds	r18, 0x6d
    6ab6:	3e a5       	lds	r19, 0x6e
    6ab8:	4f a5       	lds	r20, 0x6f
    6aba:	58 a9       	sts	0x48, r21
    6abc:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6ac0:	29 a7       	lds	r18, 0x79
    6ac2:	3a a7       	lds	r19, 0x7a
    6ac4:	4b a7       	lds	r20, 0x7b
    6ac6:	5c a7       	lds	r21, 0x7c
    6ac8:	21 96       	adiw	r28, 0x01	; 1
    6aca:	6c af       	sts	0x7c, r22
    6acc:	7d af       	sts	0x7d, r23
    6ace:	8e af       	sts	0x7e, r24
    6ad0:	9f af       	sts	0x7f, r25
    6ad2:	21 97       	sbiw	r28, 0x01	; 1
    6ad4:	c7 01       	movw	r24, r14
    6ad6:	b6 01       	movw	r22, r12
    6ad8:	2d a5       	lds	r18, 0x6d
    6ada:	3e a5       	lds	r19, 0x6e
    6adc:	4f a5       	lds	r20, 0x6f
    6ade:	58 a9       	sts	0x48, r21
    6ae0:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6ae4:	ca 01       	movw	r24, r20
    6ae6:	b9 01       	movw	r22, r18
    6ae8:	29 ad       	sts	0x69, r18
    6aea:	3a ad       	sts	0x6a, r19
    6aec:	4b ad       	sts	0x6b, r20
    6aee:	5c ad       	sts	0x6c, r21
    6af0:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6af4:	8b 01       	movw	r16, r22
    6af6:	9c 01       	movw	r18, r24
    6af8:	21 96       	adiw	r28, 0x01	; 1
    6afa:	4c ad       	sts	0x6c, r20
    6afc:	5d ad       	sts	0x6d, r21
    6afe:	6e ad       	sts	0x6e, r22
    6b00:	7f ad       	sts	0x6f, r23
    6b02:	21 97       	sbiw	r28, 0x01	; 1
    6b04:	da 01       	movw	r26, r20
    6b06:	99 27       	eor	r25, r25
    6b08:	88 27       	eor	r24, r24
    6b0a:	4d a9       	sts	0x4d, r20
    6b0c:	5e a9       	sts	0x4e, r21
    6b0e:	6f a9       	sts	0x4f, r22
    6b10:	78 ad       	sts	0x68, r23
    6b12:	60 70       	andi	r22, 0x00	; 0
    6b14:	70 70       	andi	r23, 0x00	; 0
    6b16:	84 2b       	or	r24, r20
    6b18:	95 2b       	or	r25, r21
    6b1a:	a6 2b       	or	r26, r22
    6b1c:	b7 2b       	or	r27, r23
    6b1e:	49 a5       	lds	r20, 0x69
    6b20:	5a a5       	lds	r21, 0x6a
    6b22:	6b a5       	lds	r22, 0x6b
    6b24:	7c a5       	lds	r23, 0x6c
    6b26:	80 17       	cp	r24, r16
    6b28:	91 07       	cpc	r25, r17
    6b2a:	a2 07       	cpc	r26, r18
    6b2c:	b3 07       	cpc	r27, r19
    6b2e:	d0 f4       	brcc	.+52     	; 0x6b64 <__divdi3+0x9c4>
    6b30:	41 50       	subi	r20, 0x01	; 1
    6b32:	50 40       	sbci	r21, 0x00	; 0
    6b34:	60 40       	sbci	r22, 0x00	; 0
    6b36:	70 40       	sbci	r23, 0x00	; 0
    6b38:	88 0d       	add	r24, r8
    6b3a:	99 1d       	adc	r25, r9
    6b3c:	aa 1d       	adc	r26, r10
    6b3e:	bb 1d       	adc	r27, r11
    6b40:	88 15       	cp	r24, r8
    6b42:	99 05       	cpc	r25, r9
    6b44:	aa 05       	cpc	r26, r10
    6b46:	bb 05       	cpc	r27, r11
    6b48:	68 f0       	brcs	.+26     	; 0x6b64 <__divdi3+0x9c4>
    6b4a:	80 17       	cp	r24, r16
    6b4c:	91 07       	cpc	r25, r17
    6b4e:	a2 07       	cpc	r26, r18
    6b50:	b3 07       	cpc	r27, r19
    6b52:	40 f4       	brcc	.+16     	; 0x6b64 <__divdi3+0x9c4>
    6b54:	49 a5       	lds	r20, 0x69
    6b56:	5a a5       	lds	r21, 0x6a
    6b58:	6b a5       	lds	r22, 0x6b
    6b5a:	7c a5       	lds	r23, 0x6c
    6b5c:	42 50       	subi	r20, 0x02	; 2
    6b5e:	50 40       	sbci	r21, 0x00	; 0
    6b60:	60 40       	sbci	r22, 0x00	; 0
    6b62:	70 40       	sbci	r23, 0x00	; 0
    6b64:	09 a9       	sts	0x49, r16
    6b66:	1a a9       	sts	0x4a, r17
    6b68:	2b a9       	sts	0x4b, r18
    6b6a:	3c a9       	sts	0x4c, r19
    6b6c:	78 01       	movw	r14, r16
    6b6e:	dd 24       	eor	r13, r13
    6b70:	cc 24       	eor	r12, r12
    6b72:	c4 2a       	or	r12, r20
    6b74:	d5 2a       	or	r13, r21
    6b76:	e6 2a       	or	r14, r22
    6b78:	f7 2a       	or	r15, r23
    6b7a:	50 c2       	rjmp	.+1184   	; 0x701c <__divdi3+0xe7c>
    6b7c:	c8 16       	cp	r12, r24
    6b7e:	d9 06       	cpc	r13, r25
    6b80:	ea 06       	cpc	r14, r26
    6b82:	fb 06       	cpc	r15, r27
    6b84:	08 f4       	brcc	.+2      	; 0x6b88 <__divdi3+0x9e8>
    6b86:	37 c2       	rjmp	.+1134   	; 0x6ff6 <__divdi3+0xe56>
    6b88:	80 30       	cpi	r24, 0x00	; 0
    6b8a:	10 e0       	ldi	r17, 0x00	; 0
    6b8c:	91 07       	cpc	r25, r17
    6b8e:	11 e0       	ldi	r17, 0x01	; 1
    6b90:	a1 07       	cpc	r26, r17
    6b92:	10 e0       	ldi	r17, 0x00	; 0
    6b94:	b1 07       	cpc	r27, r17
    6b96:	50 f4       	brcc	.+20     	; 0x6bac <__divdi3+0xa0c>
    6b98:	8f 3f       	cpi	r24, 0xFF	; 255
    6b9a:	91 05       	cpc	r25, r1
    6b9c:	a1 05       	cpc	r26, r1
    6b9e:	b1 05       	cpc	r27, r1
    6ba0:	09 f0       	breq	.+2      	; 0x6ba4 <__divdi3+0xa04>
    6ba2:	88 f4       	brcc	.+34     	; 0x6bc6 <__divdi3+0xa26>
    6ba4:	00 e0       	ldi	r16, 0x00	; 0
    6ba6:	10 e0       	ldi	r17, 0x00	; 0
    6ba8:	98 01       	movw	r18, r16
    6baa:	16 c0       	rjmp	.+44     	; 0x6bd8 <__divdi3+0xa38>
    6bac:	80 30       	cpi	r24, 0x00	; 0
    6bae:	20 e0       	ldi	r18, 0x00	; 0
    6bb0:	92 07       	cpc	r25, r18
    6bb2:	20 e0       	ldi	r18, 0x00	; 0
    6bb4:	a2 07       	cpc	r26, r18
    6bb6:	21 e0       	ldi	r18, 0x01	; 1
    6bb8:	b2 07       	cpc	r27, r18
    6bba:	50 f4       	brcc	.+20     	; 0x6bd0 <__divdi3+0xa30>
    6bbc:	00 e1       	ldi	r16, 0x10	; 16
    6bbe:	10 e0       	ldi	r17, 0x00	; 0
    6bc0:	20 e0       	ldi	r18, 0x00	; 0
    6bc2:	30 e0       	ldi	r19, 0x00	; 0
    6bc4:	09 c0       	rjmp	.+18     	; 0x6bd8 <__divdi3+0xa38>
    6bc6:	08 e0       	ldi	r16, 0x08	; 8
    6bc8:	10 e0       	ldi	r17, 0x00	; 0
    6bca:	20 e0       	ldi	r18, 0x00	; 0
    6bcc:	30 e0       	ldi	r19, 0x00	; 0
    6bce:	04 c0       	rjmp	.+8      	; 0x6bd8 <__divdi3+0xa38>
    6bd0:	08 e1       	ldi	r16, 0x18	; 24
    6bd2:	10 e0       	ldi	r17, 0x00	; 0
    6bd4:	20 e0       	ldi	r18, 0x00	; 0
    6bd6:	30 e0       	ldi	r19, 0x00	; 0
    6bd8:	ac 01       	movw	r20, r24
    6bda:	bd 01       	movw	r22, r26
    6bdc:	00 2e       	mov	r0, r16
    6bde:	04 c0       	rjmp	.+8      	; 0x6be8 <__divdi3+0xa48>
    6be0:	76 95       	lsr	r23
    6be2:	67 95       	ror	r22
    6be4:	57 95       	ror	r21
    6be6:	47 95       	ror	r20
    6be8:	0a 94       	dec	r0
    6bea:	d2 f7       	brpl	.-12     	; 0x6be0 <__divdi3+0xa40>
    6bec:	fa 01       	movw	r30, r20
    6bee:	e9 5c       	subi	r30, 0xC9	; 201
    6bf0:	ff 4d       	sbci	r31, 0xDF	; 223
    6bf2:	40 81       	ld	r20, Z
    6bf4:	04 0f       	add	r16, r20
    6bf6:	11 1d       	adc	r17, r1
    6bf8:	21 1d       	adc	r18, r1
    6bfa:	31 1d       	adc	r19, r1
    6bfc:	40 e2       	ldi	r20, 0x20	; 32
    6bfe:	50 e0       	ldi	r21, 0x00	; 0
    6c00:	60 e0       	ldi	r22, 0x00	; 0
    6c02:	70 e0       	ldi	r23, 0x00	; 0
    6c04:	40 1b       	sub	r20, r16
    6c06:	51 0b       	sbc	r21, r17
    6c08:	62 0b       	sbc	r22, r18
    6c0a:	73 0b       	sbc	r23, r19
    6c0c:	a1 f4       	brne	.+40     	; 0x6c36 <__divdi3+0xa96>
    6c0e:	8c 15       	cp	r24, r12
    6c10:	9d 05       	cpc	r25, r13
    6c12:	ae 05       	cpc	r26, r14
    6c14:	bf 05       	cpc	r27, r15
    6c16:	08 f4       	brcc	.+2      	; 0x6c1a <__divdi3+0xa7a>
    6c18:	f5 c1       	rjmp	.+1002   	; 0x7004 <__divdi3+0xe64>
    6c1a:	ed a8       	sts	0x8d, r30
    6c1c:	fe a8       	sts	0x8e, r31
    6c1e:	0f a9       	sts	0x4f, r16
    6c20:	18 ad       	sts	0x68, r17
    6c22:	44 24       	eor	r4, r4
    6c24:	55 24       	eor	r5, r5
    6c26:	32 01       	movw	r6, r4
    6c28:	e8 14       	cp	r14, r8
    6c2a:	f9 04       	cpc	r15, r9
    6c2c:	0a 05       	cpc	r16, r10
    6c2e:	1b 05       	cpc	r17, r11
    6c30:	08 f0       	brcs	.+2      	; 0x6c34 <__divdi3+0xa94>
    6c32:	eb c1       	rjmp	.+982    	; 0x700a <__divdi3+0xe6a>
    6c34:	e3 c1       	rjmp	.+966    	; 0x6ffc <__divdi3+0xe5c>
    6c36:	34 2e       	mov	r3, r20
    6c38:	2c 01       	movw	r4, r24
    6c3a:	3d 01       	movw	r6, r26
    6c3c:	04 c0       	rjmp	.+8      	; 0x6c46 <__divdi3+0xaa6>
    6c3e:	44 0c       	add	r4, r4
    6c40:	55 1c       	adc	r5, r5
    6c42:	66 1c       	adc	r6, r6
    6c44:	77 1c       	adc	r7, r7
    6c46:	4a 95       	dec	r20
    6c48:	d2 f7       	brpl	.-12     	; 0x6c3e <__divdi3+0xa9e>
    6c4a:	d5 01       	movw	r26, r10
    6c4c:	c4 01       	movw	r24, r8
    6c4e:	00 2e       	mov	r0, r16
    6c50:	04 c0       	rjmp	.+8      	; 0x6c5a <__divdi3+0xaba>
    6c52:	b6 95       	lsr	r27
    6c54:	a7 95       	ror	r26
    6c56:	97 95       	ror	r25
    6c58:	87 95       	ror	r24
    6c5a:	0a 94       	dec	r0
    6c5c:	d2 f7       	brpl	.-12     	; 0x6c52 <__divdi3+0xab2>
    6c5e:	48 2a       	or	r4, r24
    6c60:	59 2a       	or	r5, r25
    6c62:	6a 2a       	or	r6, r26
    6c64:	7b 2a       	or	r7, r27
    6c66:	a5 01       	movw	r20, r10
    6c68:	94 01       	movw	r18, r8
    6c6a:	03 2c       	mov	r0, r3
    6c6c:	04 c0       	rjmp	.+8      	; 0x6c76 <__divdi3+0xad6>
    6c6e:	22 0f       	add	r18, r18
    6c70:	33 1f       	adc	r19, r19
    6c72:	44 1f       	adc	r20, r20
    6c74:	55 1f       	adc	r21, r21
    6c76:	0a 94       	dec	r0
    6c78:	d2 f7       	brpl	.-12     	; 0x6c6e <__divdi3+0xace>
    6c7a:	29 af       	sts	0x79, r18
    6c7c:	3a af       	sts	0x7a, r19
    6c7e:	4b af       	sts	0x7b, r20
    6c80:	5c af       	sts	0x7c, r21
    6c82:	b7 01       	movw	r22, r14
    6c84:	a6 01       	movw	r20, r12
    6c86:	00 2e       	mov	r0, r16
    6c88:	04 c0       	rjmp	.+8      	; 0x6c92 <__divdi3+0xaf2>
    6c8a:	76 95       	lsr	r23
    6c8c:	67 95       	ror	r22
    6c8e:	57 95       	ror	r21
    6c90:	47 95       	ror	r20
    6c92:	0a 94       	dec	r0
    6c94:	d2 f7       	brpl	.-12     	; 0x6c8a <__divdi3+0xaea>
    6c96:	49 ab       	sts	0x59, r20
    6c98:	5a ab       	sts	0x5a, r21
    6c9a:	6b ab       	sts	0x5b, r22
    6c9c:	7c ab       	sts	0x5c, r23
    6c9e:	c7 01       	movw	r24, r14
    6ca0:	b6 01       	movw	r22, r12
    6ca2:	03 2c       	mov	r0, r3
    6ca4:	04 c0       	rjmp	.+8      	; 0x6cae <__divdi3+0xb0e>
    6ca6:	66 0f       	add	r22, r22
    6ca8:	77 1f       	adc	r23, r23
    6caa:	88 1f       	adc	r24, r24
    6cac:	99 1f       	adc	r25, r25
    6cae:	0a 94       	dec	r0
    6cb0:	d2 f7       	brpl	.-12     	; 0x6ca6 <__divdi3+0xb06>
    6cb2:	6d a7       	lds	r22, 0x7d
    6cb4:	7e a7       	lds	r23, 0x7e
    6cb6:	8f a7       	lds	r24, 0x7f
    6cb8:	98 ab       	sts	0x58, r25
    6cba:	8d a9       	sts	0x4d, r24
    6cbc:	9e a9       	sts	0x4e, r25
    6cbe:	af a9       	sts	0x4f, r26
    6cc0:	b8 ad       	sts	0x68, r27
    6cc2:	04 c0       	rjmp	.+8      	; 0x6ccc <__divdi3+0xb2c>
    6cc4:	b6 95       	lsr	r27
    6cc6:	a7 95       	ror	r26
    6cc8:	97 95       	ror	r25
    6cca:	87 95       	ror	r24
    6ccc:	0a 95       	dec	r16
    6cce:	d2 f7       	brpl	.-12     	; 0x6cc4 <__divdi3+0xb24>
    6cd0:	4d a5       	lds	r20, 0x6d
    6cd2:	5e a5       	lds	r21, 0x6e
    6cd4:	6f a5       	lds	r22, 0x6f
    6cd6:	78 a9       	sts	0x48, r23
    6cd8:	48 2b       	or	r20, r24
    6cda:	59 2b       	or	r21, r25
    6cdc:	6a 2b       	or	r22, r26
    6cde:	7b 2b       	or	r23, r27
    6ce0:	4d a7       	lds	r20, 0x7d
    6ce2:	5e a7       	lds	r21, 0x7e
    6ce4:	6f a7       	lds	r22, 0x7f
    6ce6:	78 ab       	sts	0x58, r23
    6ce8:	43 01       	movw	r8, r6
    6cea:	aa 24       	eor	r10, r10
    6cec:	bb 24       	eor	r11, r11
    6cee:	93 01       	movw	r18, r6
    6cf0:	82 01       	movw	r16, r4
    6cf2:	20 70       	andi	r18, 0x00	; 0
    6cf4:	30 70       	andi	r19, 0x00	; 0
    6cf6:	21 96       	adiw	r28, 0x01	; 1
    6cf8:	0c af       	sts	0x7c, r16
    6cfa:	1d af       	sts	0x7d, r17
    6cfc:	2e af       	sts	0x7e, r18
    6cfe:	3f af       	sts	0x7f, r19
    6d00:	21 97       	sbiw	r28, 0x01	; 1
    6d02:	69 a9       	sts	0x49, r22
    6d04:	7a a9       	sts	0x4a, r23
    6d06:	8b a9       	sts	0x4b, r24
    6d08:	9c a9       	sts	0x4c, r25
    6d0a:	a5 01       	movw	r20, r10
    6d0c:	94 01       	movw	r18, r8
    6d0e:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6d12:	29 a7       	lds	r18, 0x79
    6d14:	3a a7       	lds	r19, 0x7a
    6d16:	4b a7       	lds	r20, 0x7b
    6d18:	5c a7       	lds	r21, 0x7c
    6d1a:	6b 01       	movw	r12, r22
    6d1c:	7c 01       	movw	r14, r24
    6d1e:	69 a9       	sts	0x49, r22
    6d20:	7a a9       	sts	0x4a, r23
    6d22:	8b a9       	sts	0x4b, r24
    6d24:	9c a9       	sts	0x4c, r25
    6d26:	a5 01       	movw	r20, r10
    6d28:	94 01       	movw	r18, r8
    6d2a:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6d2e:	ca 01       	movw	r24, r20
    6d30:	b9 01       	movw	r22, r18
    6d32:	21 96       	adiw	r28, 0x01	; 1
    6d34:	2c ad       	sts	0x6c, r18
    6d36:	3d ad       	sts	0x6d, r19
    6d38:	4e ad       	sts	0x6e, r20
    6d3a:	5f ad       	sts	0x6f, r21
    6d3c:	21 97       	sbiw	r28, 0x01	; 1
    6d3e:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6d42:	dc 01       	movw	r26, r24
    6d44:	cb 01       	movw	r24, r22
    6d46:	76 01       	movw	r14, r12
    6d48:	dd 24       	eor	r13, r13
    6d4a:	cc 24       	eor	r12, r12
    6d4c:	0d a5       	lds	r16, 0x6d
    6d4e:	1e a5       	lds	r17, 0x6e
    6d50:	2f a5       	lds	r18, 0x6f
    6d52:	38 a9       	sts	0x48, r19
    6d54:	a9 01       	movw	r20, r18
    6d56:	66 27       	eor	r22, r22
    6d58:	77 27       	eor	r23, r23
    6d5a:	c4 2a       	or	r12, r20
    6d5c:	d5 2a       	or	r13, r21
    6d5e:	e6 2a       	or	r14, r22
    6d60:	f7 2a       	or	r15, r23
    6d62:	09 a5       	lds	r16, 0x69
    6d64:	1a a5       	lds	r17, 0x6a
    6d66:	2b a5       	lds	r18, 0x6b
    6d68:	3c a5       	lds	r19, 0x6c
    6d6a:	c8 16       	cp	r12, r24
    6d6c:	d9 06       	cpc	r13, r25
    6d6e:	ea 06       	cpc	r14, r26
    6d70:	fb 06       	cpc	r15, r27
    6d72:	38 f5       	brcc	.+78     	; 0x6dc2 <__divdi3+0xc22>
    6d74:	01 50       	subi	r16, 0x01	; 1
    6d76:	10 40       	sbci	r17, 0x00	; 0
    6d78:	20 40       	sbci	r18, 0x00	; 0
    6d7a:	30 40       	sbci	r19, 0x00	; 0
    6d7c:	09 ab       	sts	0x59, r16
    6d7e:	1a ab       	sts	0x5a, r17
    6d80:	2b ab       	sts	0x5b, r18
    6d82:	3c ab       	sts	0x5c, r19
    6d84:	c4 0c       	add	r12, r4
    6d86:	d5 1c       	adc	r13, r5
    6d88:	e6 1c       	adc	r14, r6
    6d8a:	f7 1c       	adc	r15, r7
    6d8c:	c4 14       	cp	r12, r4
    6d8e:	d5 04       	cpc	r13, r5
    6d90:	e6 04       	cpc	r14, r6
    6d92:	f7 04       	cpc	r15, r7
    6d94:	d0 f0       	brcs	.+52     	; 0x6dca <__divdi3+0xc2a>
    6d96:	c8 16       	cp	r12, r24
    6d98:	d9 06       	cpc	r13, r25
    6d9a:	ea 06       	cpc	r14, r26
    6d9c:	fb 06       	cpc	r15, r27
    6d9e:	a8 f4       	brcc	.+42     	; 0x6dca <__divdi3+0xc2a>
    6da0:	09 a5       	lds	r16, 0x69
    6da2:	1a a5       	lds	r17, 0x6a
    6da4:	2b a5       	lds	r18, 0x6b
    6da6:	3c a5       	lds	r19, 0x6c
    6da8:	02 50       	subi	r16, 0x02	; 2
    6daa:	10 40       	sbci	r17, 0x00	; 0
    6dac:	20 40       	sbci	r18, 0x00	; 0
    6dae:	30 40       	sbci	r19, 0x00	; 0
    6db0:	09 ab       	sts	0x59, r16
    6db2:	1a ab       	sts	0x5a, r17
    6db4:	2b ab       	sts	0x5b, r18
    6db6:	3c ab       	sts	0x5c, r19
    6db8:	c4 0c       	add	r12, r4
    6dba:	d5 1c       	adc	r13, r5
    6dbc:	e6 1c       	adc	r14, r6
    6dbe:	f7 1c       	adc	r15, r7
    6dc0:	04 c0       	rjmp	.+8      	; 0x6dca <__divdi3+0xc2a>
    6dc2:	09 ab       	sts	0x59, r16
    6dc4:	1a ab       	sts	0x5a, r17
    6dc6:	2b ab       	sts	0x5b, r18
    6dc8:	3c ab       	sts	0x5c, r19
    6dca:	c8 1a       	sub	r12, r24
    6dcc:	d9 0a       	sbc	r13, r25
    6dce:	ea 0a       	sbc	r14, r26
    6dd0:	fb 0a       	sbc	r15, r27
    6dd2:	c7 01       	movw	r24, r14
    6dd4:	b6 01       	movw	r22, r12
    6dd6:	a5 01       	movw	r20, r10
    6dd8:	94 01       	movw	r18, r8
    6dda:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6dde:	29 a7       	lds	r18, 0x79
    6de0:	3a a7       	lds	r19, 0x7a
    6de2:	4b a7       	lds	r20, 0x7b
    6de4:	5c a7       	lds	r21, 0x7c
    6de6:	29 96       	adiw	r28, 0x09	; 9
    6de8:	6c af       	sts	0x7c, r22
    6dea:	7d af       	sts	0x7d, r23
    6dec:	8e af       	sts	0x7e, r24
    6dee:	9f af       	sts	0x7f, r25
    6df0:	29 97       	sbiw	r28, 0x09	; 9
    6df2:	c7 01       	movw	r24, r14
    6df4:	b6 01       	movw	r22, r12
    6df6:	a5 01       	movw	r20, r10
    6df8:	94 01       	movw	r18, r8
    6dfa:	0e 94 81 3a 	call	0x7502	; 0x7502 <__udivmodsi4>
    6dfe:	ca 01       	movw	r24, r20
    6e00:	b9 01       	movw	r22, r18
    6e02:	21 96       	adiw	r28, 0x01	; 1
    6e04:	2c ad       	sts	0x6c, r18
    6e06:	3d ad       	sts	0x6d, r19
    6e08:	4e ad       	sts	0x6e, r20
    6e0a:	5f ad       	sts	0x6f, r21
    6e0c:	21 97       	sbiw	r28, 0x01	; 1
    6e0e:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6e12:	4b 01       	movw	r8, r22
    6e14:	5c 01       	movw	r10, r24
    6e16:	29 96       	adiw	r28, 0x09	; 9
    6e18:	4c ad       	sts	0x6c, r20
    6e1a:	5d ad       	sts	0x6d, r21
    6e1c:	6e ad       	sts	0x6e, r22
    6e1e:	7f ad       	sts	0x6f, r23
    6e20:	29 97       	sbiw	r28, 0x09	; 9
    6e22:	9a 01       	movw	r18, r20
    6e24:	11 27       	eor	r17, r17
    6e26:	00 27       	eor	r16, r16
    6e28:	8d a5       	lds	r24, 0x6d
    6e2a:	9e a5       	lds	r25, 0x6e
    6e2c:	af a5       	lds	r26, 0x6f
    6e2e:	b8 a9       	sts	0x48, r27
    6e30:	a0 70       	andi	r26, 0x00	; 0
    6e32:	b0 70       	andi	r27, 0x00	; 0
    6e34:	08 2b       	or	r16, r24
    6e36:	19 2b       	or	r17, r25
    6e38:	2a 2b       	or	r18, r26
    6e3a:	3b 2b       	or	r19, r27
    6e3c:	89 a5       	lds	r24, 0x69
    6e3e:	9a a5       	lds	r25, 0x6a
    6e40:	ab a5       	lds	r26, 0x6b
    6e42:	bc a5       	lds	r27, 0x6c
    6e44:	08 15       	cp	r16, r8
    6e46:	19 05       	cpc	r17, r9
    6e48:	2a 05       	cpc	r18, r10
    6e4a:	3b 05       	cpc	r19, r11
    6e4c:	e0 f4       	brcc	.+56     	; 0x6e86 <__divdi3+0xce6>
    6e4e:	01 97       	sbiw	r24, 0x01	; 1
    6e50:	a1 09       	sbc	r26, r1
    6e52:	b1 09       	sbc	r27, r1
    6e54:	04 0d       	add	r16, r4
    6e56:	15 1d       	adc	r17, r5
    6e58:	26 1d       	adc	r18, r6
    6e5a:	37 1d       	adc	r19, r7
    6e5c:	04 15       	cp	r16, r4
    6e5e:	15 05       	cpc	r17, r5
    6e60:	26 05       	cpc	r18, r6
    6e62:	37 05       	cpc	r19, r7
    6e64:	80 f0       	brcs	.+32     	; 0x6e86 <__divdi3+0xce6>
    6e66:	08 15       	cp	r16, r8
    6e68:	19 05       	cpc	r17, r9
    6e6a:	2a 05       	cpc	r18, r10
    6e6c:	3b 05       	cpc	r19, r11
    6e6e:	58 f4       	brcc	.+22     	; 0x6e86 <__divdi3+0xce6>
    6e70:	89 a5       	lds	r24, 0x69
    6e72:	9a a5       	lds	r25, 0x6a
    6e74:	ab a5       	lds	r26, 0x6b
    6e76:	bc a5       	lds	r27, 0x6c
    6e78:	02 97       	sbiw	r24, 0x02	; 2
    6e7a:	a1 09       	sbc	r26, r1
    6e7c:	b1 09       	sbc	r27, r1
    6e7e:	04 0d       	add	r16, r4
    6e80:	15 1d       	adc	r17, r5
    6e82:	26 1d       	adc	r18, r6
    6e84:	37 1d       	adc	r19, r7
    6e86:	b9 01       	movw	r22, r18
    6e88:	a8 01       	movw	r20, r16
    6e8a:	48 19       	sub	r20, r8
    6e8c:	59 09       	sbc	r21, r9
    6e8e:	6a 09       	sbc	r22, r10
    6e90:	7b 09       	sbc	r23, r11
    6e92:	4d a7       	lds	r20, 0x7d
    6e94:	5e a7       	lds	r21, 0x7e
    6e96:	6f a7       	lds	r22, 0x7f
    6e98:	78 ab       	sts	0x58, r23
    6e9a:	09 a9       	sts	0x49, r16
    6e9c:	1a a9       	sts	0x4a, r17
    6e9e:	2b a9       	sts	0x4b, r18
    6ea0:	3c a9       	sts	0x4c, r19
    6ea2:	78 01       	movw	r14, r16
    6ea4:	dd 24       	eor	r13, r13
    6ea6:	cc 24       	eor	r12, r12
    6ea8:	c8 2a       	or	r12, r24
    6eaa:	d9 2a       	or	r13, r25
    6eac:	ea 2a       	or	r14, r26
    6eae:	fb 2a       	or	r15, r27
    6eb0:	ff ef       	ldi	r31, 0xFF	; 255
    6eb2:	8f 2e       	mov	r8, r31
    6eb4:	ff ef       	ldi	r31, 0xFF	; 255
    6eb6:	9f 2e       	mov	r9, r31
    6eb8:	a1 2c       	mov	r10, r1
    6eba:	b1 2c       	mov	r11, r1
    6ebc:	8c 20       	and	r8, r12
    6ebe:	9d 20       	and	r9, r13
    6ec0:	ae 20       	and	r10, r14
    6ec2:	bf 20       	and	r11, r15
    6ec4:	87 01       	movw	r16, r14
    6ec6:	22 27       	eor	r18, r18
    6ec8:	33 27       	eor	r19, r19
    6eca:	09 a7       	lds	r16, 0x79
    6ecc:	1a a7       	lds	r17, 0x7a
    6ece:	2b a7       	lds	r18, 0x7b
    6ed0:	3c a7       	lds	r19, 0x7c
    6ed2:	49 ac       	sts	0xa9, r20
    6ed4:	5a ac       	sts	0xaa, r21
    6ed6:	6b ac       	sts	0xab, r22
    6ed8:	7c ac       	sts	0xac, r23
    6eda:	2f ef       	ldi	r18, 0xFF	; 255
    6edc:	3f ef       	ldi	r19, 0xFF	; 255
    6ede:	40 e0       	ldi	r20, 0x00	; 0
    6ee0:	50 e0       	ldi	r21, 0x00	; 0
    6ee2:	42 22       	and	r4, r18
    6ee4:	53 22       	and	r5, r19
    6ee6:	64 22       	and	r6, r20
    6ee8:	75 22       	and	r7, r21
    6eea:	29 ad       	sts	0x69, r18
    6eec:	3a ad       	sts	0x6a, r19
    6eee:	4b ad       	sts	0x6b, r20
    6ef0:	5c ad       	sts	0x6c, r21
    6ef2:	8a 01       	movw	r16, r20
    6ef4:	22 27       	eor	r18, r18
    6ef6:	33 27       	eor	r19, r19
    6ef8:	09 ab       	sts	0x59, r16
    6efa:	1a ab       	sts	0x5a, r17
    6efc:	2b ab       	sts	0x5b, r18
    6efe:	3c ab       	sts	0x5c, r19
    6f00:	c5 01       	movw	r24, r10
    6f02:	b4 01       	movw	r22, r8
    6f04:	a3 01       	movw	r20, r6
    6f06:	92 01       	movw	r18, r4
    6f08:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6f0c:	69 af       	sts	0x79, r22
    6f0e:	7a af       	sts	0x7a, r23
    6f10:	8b af       	sts	0x7b, r24
    6f12:	9c af       	sts	0x7c, r25
    6f14:	c5 01       	movw	r24, r10
    6f16:	b4 01       	movw	r22, r8
    6f18:	29 a9       	sts	0x49, r18
    6f1a:	3a a9       	sts	0x4a, r19
    6f1c:	4b a9       	sts	0x4b, r20
    6f1e:	5c a9       	sts	0x4c, r21
    6f20:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6f24:	4b 01       	movw	r8, r22
    6f26:	5c 01       	movw	r10, r24
    6f28:	69 a5       	lds	r22, 0x69
    6f2a:	7a a5       	lds	r23, 0x6a
    6f2c:	8b a5       	lds	r24, 0x6b
    6f2e:	9c a5       	lds	r25, 0x6c
    6f30:	a3 01       	movw	r20, r6
    6f32:	92 01       	movw	r18, r4
    6f34:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6f38:	2b 01       	movw	r4, r22
    6f3a:	3c 01       	movw	r6, r24
    6f3c:	69 a5       	lds	r22, 0x69
    6f3e:	7a a5       	lds	r23, 0x6a
    6f40:	8b a5       	lds	r24, 0x6b
    6f42:	9c a5       	lds	r25, 0x6c
    6f44:	29 a9       	sts	0x49, r18
    6f46:	3a a9       	sts	0x4a, r19
    6f48:	4b a9       	sts	0x4b, r20
    6f4a:	5c a9       	sts	0x4c, r21
    6f4c:	0e 94 3b 3a 	call	0x7476	; 0x7476 <__mulsi3>
    6f50:	ab 01       	movw	r20, r22
    6f52:	bc 01       	movw	r22, r24
    6f54:	84 0c       	add	r8, r4
    6f56:	95 1c       	adc	r9, r5
    6f58:	a6 1c       	adc	r10, r6
    6f5a:	b7 1c       	adc	r11, r7
    6f5c:	09 ad       	sts	0x69, r16
    6f5e:	1a ad       	sts	0x6a, r17
    6f60:	2b ad       	sts	0x6b, r18
    6f62:	3c ad       	sts	0x6c, r19
    6f64:	c9 01       	movw	r24, r18
    6f66:	aa 27       	eor	r26, r26
    6f68:	bb 27       	eor	r27, r27
    6f6a:	88 0e       	add	r8, r24
    6f6c:	99 1e       	adc	r9, r25
    6f6e:	aa 1e       	adc	r10, r26
    6f70:	bb 1e       	adc	r11, r27
    6f72:	84 14       	cp	r8, r4
    6f74:	95 04       	cpc	r9, r5
    6f76:	a6 04       	cpc	r10, r6
    6f78:	b7 04       	cpc	r11, r7
    6f7a:	20 f4       	brcc	.+8      	; 0x6f84 <__divdi3+0xde4>
    6f7c:	40 50       	subi	r20, 0x00	; 0
    6f7e:	50 40       	sbci	r21, 0x00	; 0
    6f80:	6f 4f       	sbci	r22, 0xFF	; 255
    6f82:	7f 4f       	sbci	r23, 0xFF	; 255
    6f84:	c5 01       	movw	r24, r10
    6f86:	aa 27       	eor	r26, r26
    6f88:	bb 27       	eor	r27, r27
    6f8a:	84 0f       	add	r24, r20
    6f8c:	95 1f       	adc	r25, r21
    6f8e:	a6 1f       	adc	r26, r22
    6f90:	b7 1f       	adc	r27, r23
    6f92:	0d a5       	lds	r16, 0x6d
    6f94:	1e a5       	lds	r17, 0x6e
    6f96:	2f a5       	lds	r18, 0x6f
    6f98:	38 a9       	sts	0x48, r19
    6f9a:	08 17       	cp	r16, r24
    6f9c:	19 07       	cpc	r17, r25
    6f9e:	2a 07       	cpc	r18, r26
    6fa0:	3b 07       	cpc	r19, r27
    6fa2:	18 f1       	brcs	.+70     	; 0x6fea <__divdi3+0xe4a>
    6fa4:	80 17       	cp	r24, r16
    6fa6:	91 07       	cpc	r25, r17
    6fa8:	a2 07       	cpc	r26, r18
    6faa:	b3 07       	cpc	r27, r19
    6fac:	a1 f5       	brne	.+104    	; 0x7016 <__divdi3+0xe76>
    6fae:	54 01       	movw	r10, r8
    6fb0:	99 24       	eor	r9, r9
    6fb2:	88 24       	eor	r8, r8
    6fb4:	89 ad       	sts	0x69, r24
    6fb6:	9a ad       	sts	0x6a, r25
    6fb8:	ab ad       	sts	0x6b, r26
    6fba:	bc ad       	sts	0x6c, r27
    6fbc:	a0 70       	andi	r26, 0x00	; 0
    6fbe:	b0 70       	andi	r27, 0x00	; 0
    6fc0:	88 0e       	add	r8, r24
    6fc2:	99 1e       	adc	r9, r25
    6fc4:	aa 1e       	adc	r10, r26
    6fc6:	bb 1e       	adc	r11, r27
    6fc8:	4d a9       	sts	0x4d, r20
    6fca:	5e a9       	sts	0x4e, r21
    6fcc:	6f a9       	sts	0x4f, r22
    6fce:	78 ad       	sts	0x68, r23
    6fd0:	03 2c       	mov	r0, r3
    6fd2:	04 c0       	rjmp	.+8      	; 0x6fdc <__divdi3+0xe3c>
    6fd4:	44 0f       	add	r20, r20
    6fd6:	55 1f       	adc	r21, r21
    6fd8:	66 1f       	adc	r22, r22
    6fda:	77 1f       	adc	r23, r23
    6fdc:	0a 94       	dec	r0
    6fde:	d2 f7       	brpl	.-12     	; 0x6fd4 <__divdi3+0xe34>
    6fe0:	48 15       	cp	r20, r8
    6fe2:	59 05       	cpc	r21, r9
    6fe4:	6a 05       	cpc	r22, r10
    6fe6:	7b 05       	cpc	r23, r11
    6fe8:	b0 f4       	brcc	.+44     	; 0x7016 <__divdi3+0xe76>
    6fea:	08 94       	sec
    6fec:	c1 08       	sbc	r12, r1
    6fee:	d1 08       	sbc	r13, r1
    6ff0:	e1 08       	sbc	r14, r1
    6ff2:	f1 08       	sbc	r15, r1
    6ff4:	10 c0       	rjmp	.+32     	; 0x7016 <__divdi3+0xe76>
    6ff6:	44 24       	eor	r4, r4
    6ff8:	55 24       	eor	r5, r5
    6ffa:	32 01       	movw	r6, r4
    6ffc:	cc 24       	eor	r12, r12
    6ffe:	dd 24       	eor	r13, r13
    7000:	76 01       	movw	r14, r12
    7002:	0c c0       	rjmp	.+24     	; 0x701c <__divdi3+0xe7c>
    7004:	44 24       	eor	r4, r4
    7006:	55 24       	eor	r5, r5
    7008:	32 01       	movw	r6, r4
    700a:	81 e0       	ldi	r24, 0x01	; 1
    700c:	c8 2e       	mov	r12, r24
    700e:	d1 2c       	mov	r13, r1
    7010:	e1 2c       	mov	r14, r1
    7012:	f1 2c       	mov	r15, r1
    7014:	03 c0       	rjmp	.+6      	; 0x701c <__divdi3+0xe7c>
    7016:	44 24       	eor	r4, r4
    7018:	55 24       	eor	r5, r5
    701a:	32 01       	movw	r6, r4
    701c:	fe 01       	movw	r30, r28
    701e:	31 96       	adiw	r30, 0x01	; 1
    7020:	88 e0       	ldi	r24, 0x08	; 8
    7022:	df 01       	movw	r26, r30
    7024:	1d 92       	st	X+, r1
    7026:	8a 95       	dec	r24
    7028:	e9 f7       	brne	.-6      	; 0x7024 <__divdi3+0xe84>
    702a:	c9 82       	std	Y+1, r12	; 0x01
    702c:	da 82       	std	Y+2, r13	; 0x02
    702e:	eb 82       	std	Y+3, r14	; 0x03
    7030:	fc 82       	std	Y+4, r15	; 0x04
    7032:	4d 82       	std	Y+5, r4	; 0x05
    7034:	5e 82       	std	Y+6, r5	; 0x06
    7036:	6f 82       	std	Y+7, r6	; 0x07
    7038:	78 86       	std	Y+8, r7	; 0x08
    703a:	2c 2d       	mov	r18, r12
    703c:	3a 81       	ldd	r19, Y+2	; 0x02
    703e:	4b 81       	ldd	r20, Y+3	; 0x03
    7040:	5c 81       	ldd	r21, Y+4	; 0x04
    7042:	64 2d       	mov	r22, r4
    7044:	7e 81       	ldd	r23, Y+6	; 0x06
    7046:	8f 81       	ldd	r24, Y+7	; 0x07
    7048:	98 85       	ldd	r25, Y+8	; 0x08
    704a:	25 96       	adiw	r28, 0x05	; 5
    704c:	ec ac       	sts	0xac, r30
    704e:	fd ac       	sts	0xad, r31
    7050:	0e ad       	sts	0x6e, r16
    7052:	1f ad       	sts	0x6f, r17
    7054:	25 97       	sbiw	r28, 0x05	; 5
    7056:	e1 14       	cp	r14, r1
    7058:	f1 04       	cpc	r15, r1
    705a:	01 05       	cpc	r16, r1
    705c:	11 05       	cpc	r17, r1
    705e:	09 f4       	brne	.+2      	; 0x7062 <__divdi3+0xec2>
    7060:	56 c0       	rjmp	.+172    	; 0x710e <__divdi3+0xf6e>
    7062:	21 95       	neg	r18
    7064:	e1 e0       	ldi	r30, 0x01	; 1
    7066:	12 16       	cp	r1, r18
    7068:	08 f0       	brcs	.+2      	; 0x706c <__divdi3+0xecc>
    706a:	e0 e0       	ldi	r30, 0x00	; 0
    706c:	31 95       	neg	r19
    706e:	f1 e0       	ldi	r31, 0x01	; 1
    7070:	13 16       	cp	r1, r19
    7072:	08 f0       	brcs	.+2      	; 0x7076 <__divdi3+0xed6>
    7074:	f0 e0       	ldi	r31, 0x00	; 0
    7076:	03 2f       	mov	r16, r19
    7078:	0e 1b       	sub	r16, r30
    707a:	e1 e0       	ldi	r30, 0x01	; 1
    707c:	30 17       	cp	r19, r16
    707e:	08 f0       	brcs	.+2      	; 0x7082 <__divdi3+0xee2>
    7080:	e0 e0       	ldi	r30, 0x00	; 0
    7082:	fe 2b       	or	r31, r30
    7084:	41 95       	neg	r20
    7086:	e1 e0       	ldi	r30, 0x01	; 1
    7088:	14 16       	cp	r1, r20
    708a:	08 f0       	brcs	.+2      	; 0x708e <__divdi3+0xeee>
    708c:	e0 e0       	ldi	r30, 0x00	; 0
    708e:	14 2f       	mov	r17, r20
    7090:	1f 1b       	sub	r17, r31
    7092:	31 e0       	ldi	r19, 0x01	; 1
    7094:	41 17       	cp	r20, r17
    7096:	08 f0       	brcs	.+2      	; 0x709a <__divdi3+0xefa>
    7098:	30 e0       	ldi	r19, 0x00	; 0
    709a:	e3 2b       	or	r30, r19
    709c:	51 95       	neg	r21
    709e:	f1 e0       	ldi	r31, 0x01	; 1
    70a0:	15 16       	cp	r1, r21
    70a2:	08 f0       	brcs	.+2      	; 0x70a6 <__divdi3+0xf06>
    70a4:	f0 e0       	ldi	r31, 0x00	; 0
    70a6:	b5 2f       	mov	r27, r21
    70a8:	be 1b       	sub	r27, r30
    70aa:	31 e0       	ldi	r19, 0x01	; 1
    70ac:	5b 17       	cp	r21, r27
    70ae:	08 f0       	brcs	.+2      	; 0x70b2 <__divdi3+0xf12>
    70b0:	30 e0       	ldi	r19, 0x00	; 0
    70b2:	f3 2b       	or	r31, r19
    70b4:	61 95       	neg	r22
    70b6:	e1 e0       	ldi	r30, 0x01	; 1
    70b8:	16 16       	cp	r1, r22
    70ba:	08 f0       	brcs	.+2      	; 0x70be <__divdi3+0xf1e>
    70bc:	e0 e0       	ldi	r30, 0x00	; 0
    70be:	46 2e       	mov	r4, r22
    70c0:	4f 1a       	sub	r4, r31
    70c2:	31 e0       	ldi	r19, 0x01	; 1
    70c4:	64 15       	cp	r22, r4
    70c6:	08 f0       	brcs	.+2      	; 0x70ca <__divdi3+0xf2a>
    70c8:	30 e0       	ldi	r19, 0x00	; 0
    70ca:	e3 2b       	or	r30, r19
    70cc:	71 95       	neg	r23
    70ce:	f1 e0       	ldi	r31, 0x01	; 1
    70d0:	17 16       	cp	r1, r23
    70d2:	08 f0       	brcs	.+2      	; 0x70d6 <__divdi3+0xf36>
    70d4:	f0 e0       	ldi	r31, 0x00	; 0
    70d6:	a7 2f       	mov	r26, r23
    70d8:	ae 1b       	sub	r26, r30
    70da:	31 e0       	ldi	r19, 0x01	; 1
    70dc:	7a 17       	cp	r23, r26
    70de:	08 f0       	brcs	.+2      	; 0x70e2 <__divdi3+0xf42>
    70e0:	30 e0       	ldi	r19, 0x00	; 0
    70e2:	f3 2b       	or	r31, r19
    70e4:	81 95       	neg	r24
    70e6:	e1 e0       	ldi	r30, 0x01	; 1
    70e8:	18 16       	cp	r1, r24
    70ea:	08 f0       	brcs	.+2      	; 0x70ee <__divdi3+0xf4e>
    70ec:	e0 e0       	ldi	r30, 0x00	; 0
    70ee:	f8 2e       	mov	r15, r24
    70f0:	ff 1a       	sub	r15, r31
    70f2:	ff 2d       	mov	r31, r15
    70f4:	31 e0       	ldi	r19, 0x01	; 1
    70f6:	8f 15       	cp	r24, r15
    70f8:	08 f0       	brcs	.+2      	; 0x70fc <__divdi3+0xf5c>
    70fa:	30 e0       	ldi	r19, 0x00	; 0
    70fc:	e3 2b       	or	r30, r19
    70fe:	91 95       	neg	r25
    7100:	30 2f       	mov	r19, r16
    7102:	41 2f       	mov	r20, r17
    7104:	5b 2f       	mov	r21, r27
    7106:	64 2d       	mov	r22, r4
    7108:	7a 2f       	mov	r23, r26
    710a:	8f 2f       	mov	r24, r31
    710c:	9e 1b       	sub	r25, r30
    710e:	c8 5b       	subi	r28, 0xB8	; 184
    7110:	df 4f       	sbci	r29, 0xFF	; 255
    7112:	e1 e1       	ldi	r30, 0x11	; 17
    7114:	0c 94 d8 3a 	jmp	0x75b0	; 0x75b0 <__epilogue_restores__+0x2>

00007118 <__subsf3>:
    7118:	50 58       	subi	r21, 0x80	; 128

0000711a <__addsf3>:
    711a:	bb 27       	eor	r27, r27
    711c:	aa 27       	eor	r26, r26
    711e:	0e d0       	rcall	.+28     	; 0x713c <__addsf3x>
    7120:	48 c1       	rjmp	.+656    	; 0x73b2 <__fp_round>
    7122:	39 d1       	rcall	.+626    	; 0x7396 <__fp_pscA>
    7124:	30 f0       	brcs	.+12     	; 0x7132 <__addsf3+0x18>
    7126:	3e d1       	rcall	.+636    	; 0x73a4 <__fp_pscB>
    7128:	20 f0       	brcs	.+8      	; 0x7132 <__addsf3+0x18>
    712a:	31 f4       	brne	.+12     	; 0x7138 <__addsf3+0x1e>
    712c:	9f 3f       	cpi	r25, 0xFF	; 255
    712e:	11 f4       	brne	.+4      	; 0x7134 <__addsf3+0x1a>
    7130:	1e f4       	brtc	.+6      	; 0x7138 <__addsf3+0x1e>
    7132:	2e c1       	rjmp	.+604    	; 0x7390 <__fp_nan>
    7134:	0e f4       	brtc	.+2      	; 0x7138 <__addsf3+0x1e>
    7136:	e0 95       	com	r30
    7138:	e7 fb       	bst	r30, 7
    713a:	24 c1       	rjmp	.+584    	; 0x7384 <__fp_inf>

0000713c <__addsf3x>:
    713c:	e9 2f       	mov	r30, r25
    713e:	4a d1       	rcall	.+660    	; 0x73d4 <__fp_split3>
    7140:	80 f3       	brcs	.-32     	; 0x7122 <__addsf3+0x8>
    7142:	ba 17       	cp	r27, r26
    7144:	62 07       	cpc	r22, r18
    7146:	73 07       	cpc	r23, r19
    7148:	84 07       	cpc	r24, r20
    714a:	95 07       	cpc	r25, r21
    714c:	18 f0       	brcs	.+6      	; 0x7154 <__addsf3x+0x18>
    714e:	71 f4       	brne	.+28     	; 0x716c <__addsf3x+0x30>
    7150:	9e f5       	brtc	.+102    	; 0x71b8 <__addsf3x+0x7c>
    7152:	62 c1       	rjmp	.+708    	; 0x7418 <__fp_zero>
    7154:	0e f4       	brtc	.+2      	; 0x7158 <__addsf3x+0x1c>
    7156:	e0 95       	com	r30
    7158:	0b 2e       	mov	r0, r27
    715a:	ba 2f       	mov	r27, r26
    715c:	a0 2d       	mov	r26, r0
    715e:	0b 01       	movw	r0, r22
    7160:	b9 01       	movw	r22, r18
    7162:	90 01       	movw	r18, r0
    7164:	0c 01       	movw	r0, r24
    7166:	ca 01       	movw	r24, r20
    7168:	a0 01       	movw	r20, r0
    716a:	11 24       	eor	r1, r1
    716c:	ff 27       	eor	r31, r31
    716e:	59 1b       	sub	r21, r25
    7170:	99 f0       	breq	.+38     	; 0x7198 <__addsf3x+0x5c>
    7172:	59 3f       	cpi	r21, 0xF9	; 249
    7174:	50 f4       	brcc	.+20     	; 0x718a <__addsf3x+0x4e>
    7176:	50 3e       	cpi	r21, 0xE0	; 224
    7178:	68 f1       	brcs	.+90     	; 0x71d4 <__addsf3x+0x98>
    717a:	1a 16       	cp	r1, r26
    717c:	f0 40       	sbci	r31, 0x00	; 0
    717e:	a2 2f       	mov	r26, r18
    7180:	23 2f       	mov	r18, r19
    7182:	34 2f       	mov	r19, r20
    7184:	44 27       	eor	r20, r20
    7186:	58 5f       	subi	r21, 0xF8	; 248
    7188:	f3 cf       	rjmp	.-26     	; 0x7170 <__addsf3x+0x34>
    718a:	46 95       	lsr	r20
    718c:	37 95       	ror	r19
    718e:	27 95       	ror	r18
    7190:	a7 95       	ror	r26
    7192:	f0 40       	sbci	r31, 0x00	; 0
    7194:	53 95       	inc	r21
    7196:	c9 f7       	brne	.-14     	; 0x718a <__addsf3x+0x4e>
    7198:	7e f4       	brtc	.+30     	; 0x71b8 <__addsf3x+0x7c>
    719a:	1f 16       	cp	r1, r31
    719c:	ba 0b       	sbc	r27, r26
    719e:	62 0b       	sbc	r22, r18
    71a0:	73 0b       	sbc	r23, r19
    71a2:	84 0b       	sbc	r24, r20
    71a4:	ba f0       	brmi	.+46     	; 0x71d4 <__addsf3x+0x98>
    71a6:	91 50       	subi	r25, 0x01	; 1
    71a8:	a1 f0       	breq	.+40     	; 0x71d2 <__addsf3x+0x96>
    71aa:	ff 0f       	add	r31, r31
    71ac:	bb 1f       	adc	r27, r27
    71ae:	66 1f       	adc	r22, r22
    71b0:	77 1f       	adc	r23, r23
    71b2:	88 1f       	adc	r24, r24
    71b4:	c2 f7       	brpl	.-16     	; 0x71a6 <__addsf3x+0x6a>
    71b6:	0e c0       	rjmp	.+28     	; 0x71d4 <__addsf3x+0x98>
    71b8:	ba 0f       	add	r27, r26
    71ba:	62 1f       	adc	r22, r18
    71bc:	73 1f       	adc	r23, r19
    71be:	84 1f       	adc	r24, r20
    71c0:	48 f4       	brcc	.+18     	; 0x71d4 <__addsf3x+0x98>
    71c2:	87 95       	ror	r24
    71c4:	77 95       	ror	r23
    71c6:	67 95       	ror	r22
    71c8:	b7 95       	ror	r27
    71ca:	f7 95       	ror	r31
    71cc:	9e 3f       	cpi	r25, 0xFE	; 254
    71ce:	08 f0       	brcs	.+2      	; 0x71d2 <__addsf3x+0x96>
    71d0:	b3 cf       	rjmp	.-154    	; 0x7138 <__addsf3+0x1e>
    71d2:	93 95       	inc	r25
    71d4:	88 0f       	add	r24, r24
    71d6:	08 f0       	brcs	.+2      	; 0x71da <__addsf3x+0x9e>
    71d8:	99 27       	eor	r25, r25
    71da:	ee 0f       	add	r30, r30
    71dc:	97 95       	ror	r25
    71de:	87 95       	ror	r24
    71e0:	08 95       	ret

000071e2 <__divsf3>:
    71e2:	0c d0       	rcall	.+24     	; 0x71fc <__divsf3x>
    71e4:	e6 c0       	rjmp	.+460    	; 0x73b2 <__fp_round>
    71e6:	de d0       	rcall	.+444    	; 0x73a4 <__fp_pscB>
    71e8:	40 f0       	brcs	.+16     	; 0x71fa <__divsf3+0x18>
    71ea:	d5 d0       	rcall	.+426    	; 0x7396 <__fp_pscA>
    71ec:	30 f0       	brcs	.+12     	; 0x71fa <__divsf3+0x18>
    71ee:	21 f4       	brne	.+8      	; 0x71f8 <__divsf3+0x16>
    71f0:	5f 3f       	cpi	r21, 0xFF	; 255
    71f2:	19 f0       	breq	.+6      	; 0x71fa <__divsf3+0x18>
    71f4:	c7 c0       	rjmp	.+398    	; 0x7384 <__fp_inf>
    71f6:	51 11       	cpse	r21, r1
    71f8:	10 c1       	rjmp	.+544    	; 0x741a <__fp_szero>
    71fa:	ca c0       	rjmp	.+404    	; 0x7390 <__fp_nan>

000071fc <__divsf3x>:
    71fc:	eb d0       	rcall	.+470    	; 0x73d4 <__fp_split3>
    71fe:	98 f3       	brcs	.-26     	; 0x71e6 <__divsf3+0x4>

00007200 <__divsf3_pse>:
    7200:	99 23       	and	r25, r25
    7202:	c9 f3       	breq	.-14     	; 0x71f6 <__divsf3+0x14>
    7204:	55 23       	and	r21, r21
    7206:	b1 f3       	breq	.-20     	; 0x71f4 <__divsf3+0x12>
    7208:	95 1b       	sub	r25, r21
    720a:	55 0b       	sbc	r21, r21
    720c:	bb 27       	eor	r27, r27
    720e:	aa 27       	eor	r26, r26
    7210:	62 17       	cp	r22, r18
    7212:	73 07       	cpc	r23, r19
    7214:	84 07       	cpc	r24, r20
    7216:	38 f0       	brcs	.+14     	; 0x7226 <__divsf3_pse+0x26>
    7218:	9f 5f       	subi	r25, 0xFF	; 255
    721a:	5f 4f       	sbci	r21, 0xFF	; 255
    721c:	22 0f       	add	r18, r18
    721e:	33 1f       	adc	r19, r19
    7220:	44 1f       	adc	r20, r20
    7222:	aa 1f       	adc	r26, r26
    7224:	a9 f3       	breq	.-22     	; 0x7210 <__divsf3_pse+0x10>
    7226:	33 d0       	rcall	.+102    	; 0x728e <__divsf3_pse+0x8e>
    7228:	0e 2e       	mov	r0, r30
    722a:	3a f0       	brmi	.+14     	; 0x723a <__divsf3_pse+0x3a>
    722c:	e0 e8       	ldi	r30, 0x80	; 128
    722e:	30 d0       	rcall	.+96     	; 0x7290 <__divsf3_pse+0x90>
    7230:	91 50       	subi	r25, 0x01	; 1
    7232:	50 40       	sbci	r21, 0x00	; 0
    7234:	e6 95       	lsr	r30
    7236:	00 1c       	adc	r0, r0
    7238:	ca f7       	brpl	.-14     	; 0x722c <__divsf3_pse+0x2c>
    723a:	29 d0       	rcall	.+82     	; 0x728e <__divsf3_pse+0x8e>
    723c:	fe 2f       	mov	r31, r30
    723e:	27 d0       	rcall	.+78     	; 0x728e <__divsf3_pse+0x8e>
    7240:	66 0f       	add	r22, r22
    7242:	77 1f       	adc	r23, r23
    7244:	88 1f       	adc	r24, r24
    7246:	bb 1f       	adc	r27, r27
    7248:	26 17       	cp	r18, r22
    724a:	37 07       	cpc	r19, r23
    724c:	48 07       	cpc	r20, r24
    724e:	ab 07       	cpc	r26, r27
    7250:	b0 e8       	ldi	r27, 0x80	; 128
    7252:	09 f0       	breq	.+2      	; 0x7256 <__divsf3_pse+0x56>
    7254:	bb 0b       	sbc	r27, r27
    7256:	80 2d       	mov	r24, r0
    7258:	bf 01       	movw	r22, r30
    725a:	ff 27       	eor	r31, r31
    725c:	93 58       	subi	r25, 0x83	; 131
    725e:	5f 4f       	sbci	r21, 0xFF	; 255
    7260:	2a f0       	brmi	.+10     	; 0x726c <__divsf3_pse+0x6c>
    7262:	9e 3f       	cpi	r25, 0xFE	; 254
    7264:	51 05       	cpc	r21, r1
    7266:	68 f0       	brcs	.+26     	; 0x7282 <__divsf3_pse+0x82>
    7268:	8d c0       	rjmp	.+282    	; 0x7384 <__fp_inf>
    726a:	d7 c0       	rjmp	.+430    	; 0x741a <__fp_szero>
    726c:	5f 3f       	cpi	r21, 0xFF	; 255
    726e:	ec f3       	brlt	.-6      	; 0x726a <__divsf3_pse+0x6a>
    7270:	98 3e       	cpi	r25, 0xE8	; 232
    7272:	dc f3       	brlt	.-10     	; 0x726a <__divsf3_pse+0x6a>
    7274:	86 95       	lsr	r24
    7276:	77 95       	ror	r23
    7278:	67 95       	ror	r22
    727a:	b7 95       	ror	r27
    727c:	f7 95       	ror	r31
    727e:	9f 5f       	subi	r25, 0xFF	; 255
    7280:	c9 f7       	brne	.-14     	; 0x7274 <__divsf3_pse+0x74>
    7282:	88 0f       	add	r24, r24
    7284:	91 1d       	adc	r25, r1
    7286:	96 95       	lsr	r25
    7288:	87 95       	ror	r24
    728a:	97 f9       	bld	r25, 7
    728c:	08 95       	ret
    728e:	e1 e0       	ldi	r30, 0x01	; 1
    7290:	66 0f       	add	r22, r22
    7292:	77 1f       	adc	r23, r23
    7294:	88 1f       	adc	r24, r24
    7296:	bb 1f       	adc	r27, r27
    7298:	62 17       	cp	r22, r18
    729a:	73 07       	cpc	r23, r19
    729c:	84 07       	cpc	r24, r20
    729e:	ba 07       	cpc	r27, r26
    72a0:	20 f0       	brcs	.+8      	; 0x72aa <__divsf3_pse+0xaa>
    72a2:	62 1b       	sub	r22, r18
    72a4:	73 0b       	sbc	r23, r19
    72a6:	84 0b       	sbc	r24, r20
    72a8:	ba 0b       	sbc	r27, r26
    72aa:	ee 1f       	adc	r30, r30
    72ac:	88 f7       	brcc	.-30     	; 0x7290 <__divsf3_pse+0x90>
    72ae:	e0 95       	com	r30
    72b0:	08 95       	ret

000072b2 <__fixunssfsi>:
    72b2:	98 d0       	rcall	.+304    	; 0x73e4 <__fp_splitA>
    72b4:	88 f0       	brcs	.+34     	; 0x72d8 <__fixunssfsi+0x26>
    72b6:	9f 57       	subi	r25, 0x7F	; 127
    72b8:	90 f0       	brcs	.+36     	; 0x72de <__fixunssfsi+0x2c>
    72ba:	b9 2f       	mov	r27, r25
    72bc:	99 27       	eor	r25, r25
    72be:	b7 51       	subi	r27, 0x17	; 23
    72c0:	a0 f0       	brcs	.+40     	; 0x72ea <__fixunssfsi+0x38>
    72c2:	d1 f0       	breq	.+52     	; 0x72f8 <__fixunssfsi+0x46>
    72c4:	66 0f       	add	r22, r22
    72c6:	77 1f       	adc	r23, r23
    72c8:	88 1f       	adc	r24, r24
    72ca:	99 1f       	adc	r25, r25
    72cc:	1a f0       	brmi	.+6      	; 0x72d4 <__fixunssfsi+0x22>
    72ce:	ba 95       	dec	r27
    72d0:	c9 f7       	brne	.-14     	; 0x72c4 <__fixunssfsi+0x12>
    72d2:	12 c0       	rjmp	.+36     	; 0x72f8 <__fixunssfsi+0x46>
    72d4:	b1 30       	cpi	r27, 0x01	; 1
    72d6:	81 f0       	breq	.+32     	; 0x72f8 <__fixunssfsi+0x46>
    72d8:	9f d0       	rcall	.+318    	; 0x7418 <__fp_zero>
    72da:	b1 e0       	ldi	r27, 0x01	; 1
    72dc:	08 95       	ret
    72de:	9c c0       	rjmp	.+312    	; 0x7418 <__fp_zero>
    72e0:	67 2f       	mov	r22, r23
    72e2:	78 2f       	mov	r23, r24
    72e4:	88 27       	eor	r24, r24
    72e6:	b8 5f       	subi	r27, 0xF8	; 248
    72e8:	39 f0       	breq	.+14     	; 0x72f8 <__fixunssfsi+0x46>
    72ea:	b9 3f       	cpi	r27, 0xF9	; 249
    72ec:	cc f3       	brlt	.-14     	; 0x72e0 <__fixunssfsi+0x2e>
    72ee:	86 95       	lsr	r24
    72f0:	77 95       	ror	r23
    72f2:	67 95       	ror	r22
    72f4:	b3 95       	inc	r27
    72f6:	d9 f7       	brne	.-10     	; 0x72ee <__fixunssfsi+0x3c>
    72f8:	3e f4       	brtc	.+14     	; 0x7308 <__fixunssfsi+0x56>
    72fa:	90 95       	com	r25
    72fc:	80 95       	com	r24
    72fe:	70 95       	com	r23
    7300:	61 95       	neg	r22
    7302:	7f 4f       	sbci	r23, 0xFF	; 255
    7304:	8f 4f       	sbci	r24, 0xFF	; 255
    7306:	9f 4f       	sbci	r25, 0xFF	; 255
    7308:	08 95       	ret

0000730a <__floatunsisf>:
    730a:	e8 94       	clt
    730c:	09 c0       	rjmp	.+18     	; 0x7320 <__floatsisf+0x12>

0000730e <__floatsisf>:
    730e:	97 fb       	bst	r25, 7
    7310:	3e f4       	brtc	.+14     	; 0x7320 <__floatsisf+0x12>
    7312:	90 95       	com	r25
    7314:	80 95       	com	r24
    7316:	70 95       	com	r23
    7318:	61 95       	neg	r22
    731a:	7f 4f       	sbci	r23, 0xFF	; 255
    731c:	8f 4f       	sbci	r24, 0xFF	; 255
    731e:	9f 4f       	sbci	r25, 0xFF	; 255
    7320:	99 23       	and	r25, r25
    7322:	a9 f0       	breq	.+42     	; 0x734e <__floatsisf+0x40>
    7324:	f9 2f       	mov	r31, r25
    7326:	96 e9       	ldi	r25, 0x96	; 150
    7328:	bb 27       	eor	r27, r27
    732a:	93 95       	inc	r25
    732c:	f6 95       	lsr	r31
    732e:	87 95       	ror	r24
    7330:	77 95       	ror	r23
    7332:	67 95       	ror	r22
    7334:	b7 95       	ror	r27
    7336:	f1 11       	cpse	r31, r1
    7338:	f8 cf       	rjmp	.-16     	; 0x732a <__floatsisf+0x1c>
    733a:	fa f4       	brpl	.+62     	; 0x737a <__floatsisf+0x6c>
    733c:	bb 0f       	add	r27, r27
    733e:	11 f4       	brne	.+4      	; 0x7344 <__floatsisf+0x36>
    7340:	60 ff       	sbrs	r22, 0
    7342:	1b c0       	rjmp	.+54     	; 0x737a <__floatsisf+0x6c>
    7344:	6f 5f       	subi	r22, 0xFF	; 255
    7346:	7f 4f       	sbci	r23, 0xFF	; 255
    7348:	8f 4f       	sbci	r24, 0xFF	; 255
    734a:	9f 4f       	sbci	r25, 0xFF	; 255
    734c:	16 c0       	rjmp	.+44     	; 0x737a <__floatsisf+0x6c>
    734e:	88 23       	and	r24, r24
    7350:	11 f0       	breq	.+4      	; 0x7356 <__floatsisf+0x48>
    7352:	96 e9       	ldi	r25, 0x96	; 150
    7354:	11 c0       	rjmp	.+34     	; 0x7378 <__floatsisf+0x6a>
    7356:	77 23       	and	r23, r23
    7358:	21 f0       	breq	.+8      	; 0x7362 <__floatsisf+0x54>
    735a:	9e e8       	ldi	r25, 0x8E	; 142
    735c:	87 2f       	mov	r24, r23
    735e:	76 2f       	mov	r23, r22
    7360:	05 c0       	rjmp	.+10     	; 0x736c <__floatsisf+0x5e>
    7362:	66 23       	and	r22, r22
    7364:	71 f0       	breq	.+28     	; 0x7382 <__floatsisf+0x74>
    7366:	96 e8       	ldi	r25, 0x86	; 134
    7368:	86 2f       	mov	r24, r22
    736a:	70 e0       	ldi	r23, 0x00	; 0
    736c:	60 e0       	ldi	r22, 0x00	; 0
    736e:	2a f0       	brmi	.+10     	; 0x737a <__floatsisf+0x6c>
    7370:	9a 95       	dec	r25
    7372:	66 0f       	add	r22, r22
    7374:	77 1f       	adc	r23, r23
    7376:	88 1f       	adc	r24, r24
    7378:	da f7       	brpl	.-10     	; 0x7370 <__floatsisf+0x62>
    737a:	88 0f       	add	r24, r24
    737c:	96 95       	lsr	r25
    737e:	87 95       	ror	r24
    7380:	97 f9       	bld	r25, 7
    7382:	08 95       	ret

00007384 <__fp_inf>:
    7384:	97 f9       	bld	r25, 7
    7386:	9f 67       	ori	r25, 0x7F	; 127
    7388:	80 e8       	ldi	r24, 0x80	; 128
    738a:	70 e0       	ldi	r23, 0x00	; 0
    738c:	60 e0       	ldi	r22, 0x00	; 0
    738e:	08 95       	ret

00007390 <__fp_nan>:
    7390:	9f ef       	ldi	r25, 0xFF	; 255
    7392:	80 ec       	ldi	r24, 0xC0	; 192
    7394:	08 95       	ret

00007396 <__fp_pscA>:
    7396:	00 24       	eor	r0, r0
    7398:	0a 94       	dec	r0
    739a:	16 16       	cp	r1, r22
    739c:	17 06       	cpc	r1, r23
    739e:	18 06       	cpc	r1, r24
    73a0:	09 06       	cpc	r0, r25
    73a2:	08 95       	ret

000073a4 <__fp_pscB>:
    73a4:	00 24       	eor	r0, r0
    73a6:	0a 94       	dec	r0
    73a8:	12 16       	cp	r1, r18
    73aa:	13 06       	cpc	r1, r19
    73ac:	14 06       	cpc	r1, r20
    73ae:	05 06       	cpc	r0, r21
    73b0:	08 95       	ret

000073b2 <__fp_round>:
    73b2:	09 2e       	mov	r0, r25
    73b4:	03 94       	inc	r0
    73b6:	00 0c       	add	r0, r0
    73b8:	11 f4       	brne	.+4      	; 0x73be <__fp_round+0xc>
    73ba:	88 23       	and	r24, r24
    73bc:	52 f0       	brmi	.+20     	; 0x73d2 <__fp_round+0x20>
    73be:	bb 0f       	add	r27, r27
    73c0:	40 f4       	brcc	.+16     	; 0x73d2 <__fp_round+0x20>
    73c2:	bf 2b       	or	r27, r31
    73c4:	11 f4       	brne	.+4      	; 0x73ca <__fp_round+0x18>
    73c6:	60 ff       	sbrs	r22, 0
    73c8:	04 c0       	rjmp	.+8      	; 0x73d2 <__fp_round+0x20>
    73ca:	6f 5f       	subi	r22, 0xFF	; 255
    73cc:	7f 4f       	sbci	r23, 0xFF	; 255
    73ce:	8f 4f       	sbci	r24, 0xFF	; 255
    73d0:	9f 4f       	sbci	r25, 0xFF	; 255
    73d2:	08 95       	ret

000073d4 <__fp_split3>:
    73d4:	57 fd       	sbrc	r21, 7
    73d6:	90 58       	subi	r25, 0x80	; 128
    73d8:	44 0f       	add	r20, r20
    73da:	55 1f       	adc	r21, r21
    73dc:	59 f0       	breq	.+22     	; 0x73f4 <__fp_splitA+0x10>
    73de:	5f 3f       	cpi	r21, 0xFF	; 255
    73e0:	71 f0       	breq	.+28     	; 0x73fe <__fp_splitA+0x1a>
    73e2:	47 95       	ror	r20

000073e4 <__fp_splitA>:
    73e4:	88 0f       	add	r24, r24
    73e6:	97 fb       	bst	r25, 7
    73e8:	99 1f       	adc	r25, r25
    73ea:	61 f0       	breq	.+24     	; 0x7404 <__fp_splitA+0x20>
    73ec:	9f 3f       	cpi	r25, 0xFF	; 255
    73ee:	79 f0       	breq	.+30     	; 0x740e <__fp_splitA+0x2a>
    73f0:	87 95       	ror	r24
    73f2:	08 95       	ret
    73f4:	12 16       	cp	r1, r18
    73f6:	13 06       	cpc	r1, r19
    73f8:	14 06       	cpc	r1, r20
    73fa:	55 1f       	adc	r21, r21
    73fc:	f2 cf       	rjmp	.-28     	; 0x73e2 <__fp_split3+0xe>
    73fe:	46 95       	lsr	r20
    7400:	f1 df       	rcall	.-30     	; 0x73e4 <__fp_splitA>
    7402:	08 c0       	rjmp	.+16     	; 0x7414 <__fp_splitA+0x30>
    7404:	16 16       	cp	r1, r22
    7406:	17 06       	cpc	r1, r23
    7408:	18 06       	cpc	r1, r24
    740a:	99 1f       	adc	r25, r25
    740c:	f1 cf       	rjmp	.-30     	; 0x73f0 <__fp_splitA+0xc>
    740e:	86 95       	lsr	r24
    7410:	71 05       	cpc	r23, r1
    7412:	61 05       	cpc	r22, r1
    7414:	08 94       	sec
    7416:	08 95       	ret

00007418 <__fp_zero>:
    7418:	e8 94       	clt

0000741a <__fp_szero>:
    741a:	bb 27       	eor	r27, r27
    741c:	66 27       	eor	r22, r22
    741e:	77 27       	eor	r23, r23
    7420:	cb 01       	movw	r24, r22
    7422:	97 f9       	bld	r25, 7
    7424:	08 95       	ret

00007426 <__gesf2>:
    7426:	03 d0       	rcall	.+6      	; 0x742e <__fp_cmp>
    7428:	08 f4       	brcc	.+2      	; 0x742c <__gesf2+0x6>
    742a:	8f ef       	ldi	r24, 0xFF	; 255
    742c:	08 95       	ret

0000742e <__fp_cmp>:
    742e:	99 0f       	add	r25, r25
    7430:	00 08       	sbc	r0, r0
    7432:	55 0f       	add	r21, r21
    7434:	aa 0b       	sbc	r26, r26
    7436:	e0 e8       	ldi	r30, 0x80	; 128
    7438:	fe ef       	ldi	r31, 0xFE	; 254
    743a:	16 16       	cp	r1, r22
    743c:	17 06       	cpc	r1, r23
    743e:	e8 07       	cpc	r30, r24
    7440:	f9 07       	cpc	r31, r25
    7442:	c0 f0       	brcs	.+48     	; 0x7474 <__fp_cmp+0x46>
    7444:	12 16       	cp	r1, r18
    7446:	13 06       	cpc	r1, r19
    7448:	e4 07       	cpc	r30, r20
    744a:	f5 07       	cpc	r31, r21
    744c:	98 f0       	brcs	.+38     	; 0x7474 <__fp_cmp+0x46>
    744e:	62 1b       	sub	r22, r18
    7450:	73 0b       	sbc	r23, r19
    7452:	84 0b       	sbc	r24, r20
    7454:	95 0b       	sbc	r25, r21
    7456:	39 f4       	brne	.+14     	; 0x7466 <__fp_cmp+0x38>
    7458:	0a 26       	eor	r0, r26
    745a:	61 f0       	breq	.+24     	; 0x7474 <__fp_cmp+0x46>
    745c:	23 2b       	or	r18, r19
    745e:	24 2b       	or	r18, r20
    7460:	25 2b       	or	r18, r21
    7462:	21 f4       	brne	.+8      	; 0x746c <__fp_cmp+0x3e>
    7464:	08 95       	ret
    7466:	0a 26       	eor	r0, r26
    7468:	09 f4       	brne	.+2      	; 0x746c <__fp_cmp+0x3e>
    746a:	a1 40       	sbci	r26, 0x01	; 1
    746c:	a6 95       	lsr	r26
    746e:	8f ef       	ldi	r24, 0xFF	; 255
    7470:	81 1d       	adc	r24, r1
    7472:	81 1d       	adc	r24, r1
    7474:	08 95       	ret

00007476 <__mulsi3>:
    7476:	62 9f       	mul	r22, r18
    7478:	d0 01       	movw	r26, r0
    747a:	73 9f       	mul	r23, r19
    747c:	f0 01       	movw	r30, r0
    747e:	82 9f       	mul	r24, r18
    7480:	e0 0d       	add	r30, r0
    7482:	f1 1d       	adc	r31, r1
    7484:	64 9f       	mul	r22, r20
    7486:	e0 0d       	add	r30, r0
    7488:	f1 1d       	adc	r31, r1
    748a:	92 9f       	mul	r25, r18
    748c:	f0 0d       	add	r31, r0
    748e:	83 9f       	mul	r24, r19
    7490:	f0 0d       	add	r31, r0
    7492:	74 9f       	mul	r23, r20
    7494:	f0 0d       	add	r31, r0
    7496:	65 9f       	mul	r22, r21
    7498:	f0 0d       	add	r31, r0
    749a:	99 27       	eor	r25, r25
    749c:	72 9f       	mul	r23, r18
    749e:	b0 0d       	add	r27, r0
    74a0:	e1 1d       	adc	r30, r1
    74a2:	f9 1f       	adc	r31, r25
    74a4:	63 9f       	mul	r22, r19
    74a6:	b0 0d       	add	r27, r0
    74a8:	e1 1d       	adc	r30, r1
    74aa:	f9 1f       	adc	r31, r25
    74ac:	bd 01       	movw	r22, r26
    74ae:	cf 01       	movw	r24, r30
    74b0:	11 24       	eor	r1, r1
    74b2:	08 95       	ret

000074b4 <__udivmodhi4>:
    74b4:	aa 1b       	sub	r26, r26
    74b6:	bb 1b       	sub	r27, r27
    74b8:	51 e1       	ldi	r21, 0x11	; 17
    74ba:	07 c0       	rjmp	.+14     	; 0x74ca <__udivmodhi4_ep>

000074bc <__udivmodhi4_loop>:
    74bc:	aa 1f       	adc	r26, r26
    74be:	bb 1f       	adc	r27, r27
    74c0:	a6 17       	cp	r26, r22
    74c2:	b7 07       	cpc	r27, r23
    74c4:	10 f0       	brcs	.+4      	; 0x74ca <__udivmodhi4_ep>
    74c6:	a6 1b       	sub	r26, r22
    74c8:	b7 0b       	sbc	r27, r23

000074ca <__udivmodhi4_ep>:
    74ca:	88 1f       	adc	r24, r24
    74cc:	99 1f       	adc	r25, r25
    74ce:	5a 95       	dec	r21
    74d0:	a9 f7       	brne	.-22     	; 0x74bc <__udivmodhi4_loop>
    74d2:	80 95       	com	r24
    74d4:	90 95       	com	r25
    74d6:	bc 01       	movw	r22, r24
    74d8:	cd 01       	movw	r24, r26
    74da:	08 95       	ret

000074dc <__divmodhi4>:
    74dc:	97 fb       	bst	r25, 7
    74de:	09 2e       	mov	r0, r25
    74e0:	07 26       	eor	r0, r23
    74e2:	0a d0       	rcall	.+20     	; 0x74f8 <__divmodhi4_neg1>
    74e4:	77 fd       	sbrc	r23, 7
    74e6:	04 d0       	rcall	.+8      	; 0x74f0 <__divmodhi4_neg2>
    74e8:	e5 df       	rcall	.-54     	; 0x74b4 <__udivmodhi4>
    74ea:	06 d0       	rcall	.+12     	; 0x74f8 <__divmodhi4_neg1>
    74ec:	00 20       	and	r0, r0
    74ee:	1a f4       	brpl	.+6      	; 0x74f6 <__divmodhi4_exit>

000074f0 <__divmodhi4_neg2>:
    74f0:	70 95       	com	r23
    74f2:	61 95       	neg	r22
    74f4:	7f 4f       	sbci	r23, 0xFF	; 255

000074f6 <__divmodhi4_exit>:
    74f6:	08 95       	ret

000074f8 <__divmodhi4_neg1>:
    74f8:	f6 f7       	brtc	.-4      	; 0x74f6 <__divmodhi4_exit>
    74fa:	90 95       	com	r25
    74fc:	81 95       	neg	r24
    74fe:	9f 4f       	sbci	r25, 0xFF	; 255
    7500:	08 95       	ret

00007502 <__udivmodsi4>:
    7502:	a1 e2       	ldi	r26, 0x21	; 33
    7504:	1a 2e       	mov	r1, r26
    7506:	aa 1b       	sub	r26, r26
    7508:	bb 1b       	sub	r27, r27
    750a:	fd 01       	movw	r30, r26
    750c:	0d c0       	rjmp	.+26     	; 0x7528 <__udivmodsi4_ep>

0000750e <__udivmodsi4_loop>:
    750e:	aa 1f       	adc	r26, r26
    7510:	bb 1f       	adc	r27, r27
    7512:	ee 1f       	adc	r30, r30
    7514:	ff 1f       	adc	r31, r31
    7516:	a2 17       	cp	r26, r18
    7518:	b3 07       	cpc	r27, r19
    751a:	e4 07       	cpc	r30, r20
    751c:	f5 07       	cpc	r31, r21
    751e:	20 f0       	brcs	.+8      	; 0x7528 <__udivmodsi4_ep>
    7520:	a2 1b       	sub	r26, r18
    7522:	b3 0b       	sbc	r27, r19
    7524:	e4 0b       	sbc	r30, r20
    7526:	f5 0b       	sbc	r31, r21

00007528 <__udivmodsi4_ep>:
    7528:	66 1f       	adc	r22, r22
    752a:	77 1f       	adc	r23, r23
    752c:	88 1f       	adc	r24, r24
    752e:	99 1f       	adc	r25, r25
    7530:	1a 94       	dec	r1
    7532:	69 f7       	brne	.-38     	; 0x750e <__udivmodsi4_loop>
    7534:	60 95       	com	r22
    7536:	70 95       	com	r23
    7538:	80 95       	com	r24
    753a:	90 95       	com	r25
    753c:	9b 01       	movw	r18, r22
    753e:	ac 01       	movw	r20, r24
    7540:	bd 01       	movw	r22, r26
    7542:	cf 01       	movw	r24, r30
    7544:	08 95       	ret

00007546 <__divmodsi4>:
    7546:	97 fb       	bst	r25, 7
    7548:	09 2e       	mov	r0, r25
    754a:	05 26       	eor	r0, r21
    754c:	0e d0       	rcall	.+28     	; 0x756a <__divmodsi4_neg1>
    754e:	57 fd       	sbrc	r21, 7
    7550:	04 d0       	rcall	.+8      	; 0x755a <__divmodsi4_neg2>
    7552:	d7 df       	rcall	.-82     	; 0x7502 <__udivmodsi4>
    7554:	0a d0       	rcall	.+20     	; 0x756a <__divmodsi4_neg1>
    7556:	00 1c       	adc	r0, r0
    7558:	38 f4       	brcc	.+14     	; 0x7568 <__divmodsi4_exit>

0000755a <__divmodsi4_neg2>:
    755a:	50 95       	com	r21
    755c:	40 95       	com	r20
    755e:	30 95       	com	r19
    7560:	21 95       	neg	r18
    7562:	3f 4f       	sbci	r19, 0xFF	; 255
    7564:	4f 4f       	sbci	r20, 0xFF	; 255
    7566:	5f 4f       	sbci	r21, 0xFF	; 255

00007568 <__divmodsi4_exit>:
    7568:	08 95       	ret

0000756a <__divmodsi4_neg1>:
    756a:	f6 f7       	brtc	.-4      	; 0x7568 <__divmodsi4_exit>
    756c:	90 95       	com	r25
    756e:	80 95       	com	r24
    7570:	70 95       	com	r23
    7572:	61 95       	neg	r22
    7574:	7f 4f       	sbci	r23, 0xFF	; 255
    7576:	8f 4f       	sbci	r24, 0xFF	; 255
    7578:	9f 4f       	sbci	r25, 0xFF	; 255
    757a:	08 95       	ret

0000757c <__prologue_saves__>:
    757c:	2f 92       	push	r2
    757e:	3f 92       	push	r3
    7580:	4f 92       	push	r4
    7582:	5f 92       	push	r5
    7584:	6f 92       	push	r6
    7586:	7f 92       	push	r7
    7588:	8f 92       	push	r8
    758a:	9f 92       	push	r9
    758c:	af 92       	push	r10
    758e:	bf 92       	push	r11
    7590:	cf 92       	push	r12
    7592:	df 92       	push	r13
    7594:	ef 92       	push	r14
    7596:	ff 92       	push	r15
    7598:	0f 93       	push	r16
    759a:	1f 93       	push	r17
    759c:	cf 93       	push	r28
    759e:	df 93       	push	r29
    75a0:	cd b7       	in	r28, 0x3d	; 61
    75a2:	de b7       	in	r29, 0x3e	; 62
    75a4:	ca 1b       	sub	r28, r26
    75a6:	db 0b       	sbc	r29, r27
    75a8:	cd bf       	out	0x3d, r28	; 61
    75aa:	de bf       	out	0x3e, r29	; 62
    75ac:	19 94       	eijmp

000075ae <__epilogue_restores__>:
    75ae:	2a 88       	ldd	r2, Y+18	; 0x12
    75b0:	39 88       	ldd	r3, Y+17	; 0x11
    75b2:	48 88       	ldd	r4, Y+16	; 0x10
    75b4:	5f 84       	ldd	r5, Y+15	; 0x0f
    75b6:	6e 84       	ldd	r6, Y+14	; 0x0e
    75b8:	7d 84       	ldd	r7, Y+13	; 0x0d
    75ba:	8c 84       	ldd	r8, Y+12	; 0x0c
    75bc:	9b 84       	ldd	r9, Y+11	; 0x0b
    75be:	aa 84       	ldd	r10, Y+10	; 0x0a
    75c0:	b9 84       	ldd	r11, Y+9	; 0x09
    75c2:	c8 84       	ldd	r12, Y+8	; 0x08
    75c4:	df 80       	ldd	r13, Y+7	; 0x07
    75c6:	ee 80       	ldd	r14, Y+6	; 0x06
    75c8:	fd 80       	ldd	r15, Y+5	; 0x05
    75ca:	0c 81       	ldd	r16, Y+4	; 0x04
    75cc:	1b 81       	ldd	r17, Y+3	; 0x03
    75ce:	aa 81       	ldd	r26, Y+2	; 0x02
    75d0:	b9 81       	ldd	r27, Y+1	; 0x01
    75d2:	ce 0f       	add	r28, r30
    75d4:	d1 1d       	adc	r29, r1
    75d6:	cd bf       	out	0x3d, r28	; 61
    75d8:	de bf       	out	0x3e, r29	; 62
    75da:	ed 01       	movw	r28, r26
    75dc:	08 95       	ret

000075de <strcpy_P>:
    75de:	fb 01       	movw	r30, r22
    75e0:	dc 01       	movw	r26, r24
    75e2:	05 90       	lpm	r0, Z+
    75e4:	0d 92       	st	X+, r0
    75e6:	00 20       	and	r0, r0
    75e8:	e1 f7       	brne	.-8      	; 0x75e2 <strcpy_P+0x4>
    75ea:	08 95       	ret

000075ec <memmove>:
    75ec:	68 17       	cp	r22, r24
    75ee:	79 07       	cpc	r23, r25
    75f0:	68 f4       	brcc	.+26     	; 0x760c <memmove+0x20>
    75f2:	fb 01       	movw	r30, r22
    75f4:	dc 01       	movw	r26, r24
    75f6:	e4 0f       	add	r30, r20
    75f8:	f5 1f       	adc	r31, r21
    75fa:	a4 0f       	add	r26, r20
    75fc:	b5 1f       	adc	r27, r21
    75fe:	02 c0       	rjmp	.+4      	; 0x7604 <memmove+0x18>
    7600:	02 90       	ld	r0, -Z
    7602:	0e 92       	st	-X, r0
    7604:	41 50       	subi	r20, 0x01	; 1
    7606:	50 40       	sbci	r21, 0x00	; 0
    7608:	d8 f7       	brcc	.-10     	; 0x7600 <memmove+0x14>
    760a:	08 95       	ret
    760c:	0c 94 89 3d 	jmp	0x7b12	; 0x7b12 <memcpy>

00007610 <strcat>:
    7610:	fb 01       	movw	r30, r22
    7612:	dc 01       	movw	r26, r24
    7614:	0d 90       	ld	r0, X+
    7616:	00 20       	and	r0, r0
    7618:	e9 f7       	brne	.-6      	; 0x7614 <strcat+0x4>
    761a:	11 97       	sbiw	r26, 0x01	; 1
    761c:	01 90       	ld	r0, Z+
    761e:	0d 92       	st	X+, r0
    7620:	00 20       	and	r0, r0
    7622:	e1 f7       	brne	.-8      	; 0x761c <strcat+0xc>
    7624:	08 95       	ret

00007626 <strncmp>:
    7626:	fb 01       	movw	r30, r22
    7628:	dc 01       	movw	r26, r24
    762a:	41 50       	subi	r20, 0x01	; 1
    762c:	50 40       	sbci	r21, 0x00	; 0
    762e:	30 f0       	brcs	.+12     	; 0x763c <strncmp+0x16>
    7630:	8d 91       	ld	r24, X+
    7632:	01 90       	ld	r0, Z+
    7634:	80 19       	sub	r24, r0
    7636:	19 f4       	brne	.+6      	; 0x763e <strncmp+0x18>
    7638:	00 20       	and	r0, r0
    763a:	b9 f7       	brne	.-18     	; 0x762a <strncmp+0x4>
    763c:	88 1b       	sub	r24, r24
    763e:	99 0b       	sbc	r25, r25
    7640:	08 95       	ret

00007642 <itoa>:
    7642:	fb 01       	movw	r30, r22
    7644:	9f 01       	movw	r18, r30
    7646:	e8 94       	clt
    7648:	42 30       	cpi	r20, 0x02	; 2
    764a:	c4 f0       	brlt	.+48     	; 0x767c <itoa+0x3a>
    764c:	45 32       	cpi	r20, 0x25	; 37
    764e:	b4 f4       	brge	.+44     	; 0x767c <itoa+0x3a>
    7650:	4a 30       	cpi	r20, 0x0A	; 10
    7652:	29 f4       	brne	.+10     	; 0x765e <itoa+0x1c>
    7654:	97 fb       	bst	r25, 7
    7656:	1e f4       	brtc	.+6      	; 0x765e <itoa+0x1c>
    7658:	90 95       	com	r25
    765a:	81 95       	neg	r24
    765c:	9f 4f       	sbci	r25, 0xFF	; 255
    765e:	64 2f       	mov	r22, r20
    7660:	77 27       	eor	r23, r23
    7662:	0e 94 5a 3a 	call	0x74b4	; 0x74b4 <__udivmodhi4>
    7666:	80 5d       	subi	r24, 0xD0	; 208
    7668:	8a 33       	cpi	r24, 0x3A	; 58
    766a:	0c f0       	brlt	.+2      	; 0x766e <itoa+0x2c>
    766c:	89 5d       	subi	r24, 0xD9	; 217
    766e:	81 93       	st	Z+, r24
    7670:	cb 01       	movw	r24, r22
    7672:	00 97       	sbiw	r24, 0x00	; 0
    7674:	a1 f7       	brne	.-24     	; 0x765e <itoa+0x1c>
    7676:	16 f4       	brtc	.+4      	; 0x767c <itoa+0x3a>
    7678:	5d e2       	ldi	r21, 0x2D	; 45
    767a:	51 93       	st	Z+, r21
    767c:	10 82       	st	Z, r1
    767e:	c9 01       	movw	r24, r18
    7680:	0c 94 9d 3d 	jmp	0x7b3a	; 0x7b3a <strrev>

00007684 <printf>:
    7684:	cf 93       	push	r28
    7686:	df 93       	push	r29
    7688:	cd b7       	in	r28, 0x3d	; 61
    768a:	de b7       	in	r29, 0x3e	; 62
    768c:	fe 01       	movw	r30, r28
    768e:	36 96       	adiw	r30, 0x06	; 6
    7690:	61 91       	ld	r22, Z+
    7692:	71 91       	ld	r23, Z+
    7694:	80 91 d9 50 	lds	r24, 0x50D9
    7698:	90 91 da 50 	lds	r25, 0x50DA
    769c:	af 01       	movw	r20, r30
    769e:	0e 94 7d 3b 	call	0x76fa	; 0x76fa <vfprintf>
    76a2:	df 91       	pop	r29
    76a4:	cf 91       	pop	r28
    76a6:	08 95       	ret

000076a8 <sprintf>:
    76a8:	0f 93       	push	r16
    76aa:	1f 93       	push	r17
    76ac:	cf 93       	push	r28
    76ae:	df 93       	push	r29
    76b0:	cd b7       	in	r28, 0x3d	; 61
    76b2:	de b7       	in	r29, 0x3e	; 62
    76b4:	2e 97       	sbiw	r28, 0x0e	; 14
    76b6:	cd bf       	out	0x3d, r28	; 61
    76b8:	de bf       	out	0x3e, r29	; 62
    76ba:	0e 89       	ldd	r16, Y+22	; 0x16
    76bc:	1f 89       	ldd	r17, Y+23	; 0x17
    76be:	86 e0       	ldi	r24, 0x06	; 6
    76c0:	8c 83       	std	Y+4, r24	; 0x04
    76c2:	09 83       	std	Y+1, r16	; 0x01
    76c4:	1a 83       	std	Y+2, r17	; 0x02
    76c6:	8f ef       	ldi	r24, 0xFF	; 255
    76c8:	9f e7       	ldi	r25, 0x7F	; 127
    76ca:	8d 83       	std	Y+5, r24	; 0x05
    76cc:	9e 83       	std	Y+6, r25	; 0x06
    76ce:	ae 01       	movw	r20, r28
    76d0:	46 5e       	subi	r20, 0xE6	; 230
    76d2:	5f 4f       	sbci	r21, 0xFF	; 255
    76d4:	ce 01       	movw	r24, r28
    76d6:	01 96       	adiw	r24, 0x01	; 1
    76d8:	68 8d       	ldd	r22, Y+24	; 0x18
    76da:	79 8d       	ldd	r23, Y+25	; 0x19
    76dc:	0e 94 7d 3b 	call	0x76fa	; 0x76fa <vfprintf>
    76e0:	ef 81       	ldd	r30, Y+7	; 0x07
    76e2:	f8 85       	ldd	r31, Y+8	; 0x08
    76e4:	e0 0f       	add	r30, r16
    76e6:	f1 1f       	adc	r31, r17
    76e8:	10 82       	st	Z, r1
    76ea:	2e 96       	adiw	r28, 0x0e	; 14
    76ec:	cd bf       	out	0x3d, r28	; 61
    76ee:	de bf       	out	0x3e, r29	; 62
    76f0:	df 91       	pop	r29
    76f2:	cf 91       	pop	r28
    76f4:	1f 91       	pop	r17
    76f6:	0f 91       	pop	r16
    76f8:	08 95       	ret

000076fa <vfprintf>:
    76fa:	2f 92       	push	r2
    76fc:	3f 92       	push	r3
    76fe:	4f 92       	push	r4
    7700:	5f 92       	push	r5
    7702:	6f 92       	push	r6
    7704:	7f 92       	push	r7
    7706:	8f 92       	push	r8
    7708:	9f 92       	push	r9
    770a:	af 92       	push	r10
    770c:	bf 92       	push	r11
    770e:	cf 92       	push	r12
    7710:	df 92       	push	r13
    7712:	ef 92       	push	r14
    7714:	ff 92       	push	r15
    7716:	0f 93       	push	r16
    7718:	1f 93       	push	r17
    771a:	cf 93       	push	r28
    771c:	df 93       	push	r29
    771e:	cd b7       	in	r28, 0x3d	; 61
    7720:	de b7       	in	r29, 0x3e	; 62
    7722:	2d 97       	sbiw	r28, 0x0d	; 13
    7724:	cd bf       	out	0x3d, r28	; 61
    7726:	de bf       	out	0x3e, r29	; 62
    7728:	3c 01       	movw	r6, r24
    772a:	6c 87       	std	Y+12, r22	; 0x0c
    772c:	7d 87       	std	Y+13, r23	; 0x0d
    772e:	5a 01       	movw	r10, r20
    7730:	fc 01       	movw	r30, r24
    7732:	16 82       	std	Z+6, r1	; 0x06
    7734:	17 82       	std	Z+7, r1	; 0x07
    7736:	83 81       	ldd	r24, Z+3	; 0x03
    7738:	81 ff       	sbrs	r24, 1
    773a:	c8 c1       	rjmp	.+912    	; 0x7acc <vfprintf+0x3d2>
    773c:	2e 01       	movw	r4, r28
    773e:	08 94       	sec
    7740:	41 1c       	adc	r4, r1
    7742:	51 1c       	adc	r5, r1
    7744:	f3 01       	movw	r30, r6
    7746:	93 81       	ldd	r25, Z+3	; 0x03
    7748:	ec 85       	ldd	r30, Y+12	; 0x0c
    774a:	fd 85       	ldd	r31, Y+13	; 0x0d
    774c:	93 fd       	sbrc	r25, 3
    774e:	85 91       	lpm	r24, Z+
    7750:	93 ff       	sbrs	r25, 3
    7752:	81 91       	ld	r24, Z+
    7754:	ec 87       	std	Y+12, r30	; 0x0c
    7756:	fd 87       	std	Y+13, r31	; 0x0d
    7758:	88 23       	and	r24, r24
    775a:	09 f4       	brne	.+2      	; 0x775e <vfprintf+0x64>
    775c:	b3 c1       	rjmp	.+870    	; 0x7ac4 <vfprintf+0x3ca>
    775e:	85 32       	cpi	r24, 0x25	; 37
    7760:	41 f4       	brne	.+16     	; 0x7772 <vfprintf+0x78>
    7762:	93 fd       	sbrc	r25, 3
    7764:	85 91       	lpm	r24, Z+
    7766:	93 ff       	sbrs	r25, 3
    7768:	81 91       	ld	r24, Z+
    776a:	ec 87       	std	Y+12, r30	; 0x0c
    776c:	fd 87       	std	Y+13, r31	; 0x0d
    776e:	85 32       	cpi	r24, 0x25	; 37
    7770:	29 f4       	brne	.+10     	; 0x777c <vfprintf+0x82>
    7772:	90 e0       	ldi	r25, 0x00	; 0
    7774:	b3 01       	movw	r22, r6
    7776:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    777a:	e4 cf       	rjmp	.-56     	; 0x7744 <vfprintf+0x4a>
    777c:	ff 24       	eor	r15, r15
    777e:	ee 24       	eor	r14, r14
    7780:	10 e0       	ldi	r17, 0x00	; 0
    7782:	10 32       	cpi	r17, 0x20	; 32
    7784:	b0 f4       	brcc	.+44     	; 0x77b2 <vfprintf+0xb8>
    7786:	8b 32       	cpi	r24, 0x2B	; 43
    7788:	69 f0       	breq	.+26     	; 0x77a4 <vfprintf+0xaa>
    778a:	8c 32       	cpi	r24, 0x2C	; 44
    778c:	28 f4       	brcc	.+10     	; 0x7798 <vfprintf+0x9e>
    778e:	80 32       	cpi	r24, 0x20	; 32
    7790:	51 f0       	breq	.+20     	; 0x77a6 <vfprintf+0xac>
    7792:	83 32       	cpi	r24, 0x23	; 35
    7794:	71 f4       	brne	.+28     	; 0x77b2 <vfprintf+0xb8>
    7796:	0b c0       	rjmp	.+22     	; 0x77ae <vfprintf+0xb4>
    7798:	8d 32       	cpi	r24, 0x2D	; 45
    779a:	39 f0       	breq	.+14     	; 0x77aa <vfprintf+0xb0>
    779c:	80 33       	cpi	r24, 0x30	; 48
    779e:	49 f4       	brne	.+18     	; 0x77b2 <vfprintf+0xb8>
    77a0:	11 60       	ori	r17, 0x01	; 1
    77a2:	2c c0       	rjmp	.+88     	; 0x77fc <vfprintf+0x102>
    77a4:	12 60       	ori	r17, 0x02	; 2
    77a6:	14 60       	ori	r17, 0x04	; 4
    77a8:	29 c0       	rjmp	.+82     	; 0x77fc <vfprintf+0x102>
    77aa:	18 60       	ori	r17, 0x08	; 8
    77ac:	27 c0       	rjmp	.+78     	; 0x77fc <vfprintf+0x102>
    77ae:	10 61       	ori	r17, 0x10	; 16
    77b0:	25 c0       	rjmp	.+74     	; 0x77fc <vfprintf+0x102>
    77b2:	17 fd       	sbrc	r17, 7
    77b4:	2e c0       	rjmp	.+92     	; 0x7812 <vfprintf+0x118>
    77b6:	28 2f       	mov	r18, r24
    77b8:	20 53       	subi	r18, 0x30	; 48
    77ba:	2a 30       	cpi	r18, 0x0A	; 10
    77bc:	98 f4       	brcc	.+38     	; 0x77e4 <vfprintf+0xea>
    77be:	16 ff       	sbrs	r17, 6
    77c0:	08 c0       	rjmp	.+16     	; 0x77d2 <vfprintf+0xd8>
    77c2:	8f 2d       	mov	r24, r15
    77c4:	88 0f       	add	r24, r24
    77c6:	f8 2e       	mov	r15, r24
    77c8:	ff 0c       	add	r15, r15
    77ca:	ff 0c       	add	r15, r15
    77cc:	f8 0e       	add	r15, r24
    77ce:	f2 0e       	add	r15, r18
    77d0:	15 c0       	rjmp	.+42     	; 0x77fc <vfprintf+0x102>
    77d2:	8e 2d       	mov	r24, r14
    77d4:	88 0f       	add	r24, r24
    77d6:	e8 2e       	mov	r14, r24
    77d8:	ee 0c       	add	r14, r14
    77da:	ee 0c       	add	r14, r14
    77dc:	e8 0e       	add	r14, r24
    77de:	e2 0e       	add	r14, r18
    77e0:	10 62       	ori	r17, 0x20	; 32
    77e2:	0c c0       	rjmp	.+24     	; 0x77fc <vfprintf+0x102>
    77e4:	8e 32       	cpi	r24, 0x2E	; 46
    77e6:	21 f4       	brne	.+8      	; 0x77f0 <vfprintf+0xf6>
    77e8:	16 fd       	sbrc	r17, 6
    77ea:	6c c1       	rjmp	.+728    	; 0x7ac4 <vfprintf+0x3ca>
    77ec:	10 64       	ori	r17, 0x40	; 64
    77ee:	06 c0       	rjmp	.+12     	; 0x77fc <vfprintf+0x102>
    77f0:	8c 36       	cpi	r24, 0x6C	; 108
    77f2:	11 f4       	brne	.+4      	; 0x77f8 <vfprintf+0xfe>
    77f4:	10 68       	ori	r17, 0x80	; 128
    77f6:	02 c0       	rjmp	.+4      	; 0x77fc <vfprintf+0x102>
    77f8:	88 36       	cpi	r24, 0x68	; 104
    77fa:	59 f4       	brne	.+22     	; 0x7812 <vfprintf+0x118>
    77fc:	ec 85       	ldd	r30, Y+12	; 0x0c
    77fe:	fd 85       	ldd	r31, Y+13	; 0x0d
    7800:	93 fd       	sbrc	r25, 3
    7802:	85 91       	lpm	r24, Z+
    7804:	93 ff       	sbrs	r25, 3
    7806:	81 91       	ld	r24, Z+
    7808:	ec 87       	std	Y+12, r30	; 0x0c
    780a:	fd 87       	std	Y+13, r31	; 0x0d
    780c:	88 23       	and	r24, r24
    780e:	09 f0       	breq	.+2      	; 0x7812 <vfprintf+0x118>
    7810:	b8 cf       	rjmp	.-144    	; 0x7782 <vfprintf+0x88>
    7812:	98 2f       	mov	r25, r24
    7814:	95 54       	subi	r25, 0x45	; 69
    7816:	93 30       	cpi	r25, 0x03	; 3
    7818:	18 f0       	brcs	.+6      	; 0x7820 <vfprintf+0x126>
    781a:	90 52       	subi	r25, 0x20	; 32
    781c:	93 30       	cpi	r25, 0x03	; 3
    781e:	38 f4       	brcc	.+14     	; 0x782e <vfprintf+0x134>
    7820:	24 e0       	ldi	r18, 0x04	; 4
    7822:	30 e0       	ldi	r19, 0x00	; 0
    7824:	a2 0e       	add	r10, r18
    7826:	b3 1e       	adc	r11, r19
    7828:	3f e3       	ldi	r19, 0x3F	; 63
    782a:	39 83       	std	Y+1, r19	; 0x01
    782c:	0f c0       	rjmp	.+30     	; 0x784c <vfprintf+0x152>
    782e:	83 36       	cpi	r24, 0x63	; 99
    7830:	31 f0       	breq	.+12     	; 0x783e <vfprintf+0x144>
    7832:	83 37       	cpi	r24, 0x73	; 115
    7834:	81 f0       	breq	.+32     	; 0x7856 <vfprintf+0x15c>
    7836:	83 35       	cpi	r24, 0x53	; 83
    7838:	09 f0       	breq	.+2      	; 0x783c <vfprintf+0x142>
    783a:	5a c0       	rjmp	.+180    	; 0x78f0 <vfprintf+0x1f6>
    783c:	22 c0       	rjmp	.+68     	; 0x7882 <vfprintf+0x188>
    783e:	f5 01       	movw	r30, r10
    7840:	80 81       	ld	r24, Z
    7842:	89 83       	std	Y+1, r24	; 0x01
    7844:	22 e0       	ldi	r18, 0x02	; 2
    7846:	30 e0       	ldi	r19, 0x00	; 0
    7848:	a2 0e       	add	r10, r18
    784a:	b3 1e       	adc	r11, r19
    784c:	21 e0       	ldi	r18, 0x01	; 1
    784e:	c2 2e       	mov	r12, r18
    7850:	d1 2c       	mov	r13, r1
    7852:	42 01       	movw	r8, r4
    7854:	14 c0       	rjmp	.+40     	; 0x787e <vfprintf+0x184>
    7856:	92 e0       	ldi	r25, 0x02	; 2
    7858:	29 2e       	mov	r2, r25
    785a:	31 2c       	mov	r3, r1
    785c:	2a 0c       	add	r2, r10
    785e:	3b 1c       	adc	r3, r11
    7860:	f5 01       	movw	r30, r10
    7862:	80 80       	ld	r8, Z
    7864:	91 80       	ldd	r9, Z+1	; 0x01
    7866:	16 ff       	sbrs	r17, 6
    7868:	03 c0       	rjmp	.+6      	; 0x7870 <vfprintf+0x176>
    786a:	6f 2d       	mov	r22, r15
    786c:	70 e0       	ldi	r23, 0x00	; 0
    786e:	02 c0       	rjmp	.+4      	; 0x7874 <vfprintf+0x17a>
    7870:	6f ef       	ldi	r22, 0xFF	; 255
    7872:	7f ef       	ldi	r23, 0xFF	; 255
    7874:	c4 01       	movw	r24, r8
    7876:	0e 94 92 3d 	call	0x7b24	; 0x7b24 <strnlen>
    787a:	6c 01       	movw	r12, r24
    787c:	51 01       	movw	r10, r2
    787e:	1f 77       	andi	r17, 0x7F	; 127
    7880:	15 c0       	rjmp	.+42     	; 0x78ac <vfprintf+0x1b2>
    7882:	82 e0       	ldi	r24, 0x02	; 2
    7884:	28 2e       	mov	r2, r24
    7886:	31 2c       	mov	r3, r1
    7888:	2a 0c       	add	r2, r10
    788a:	3b 1c       	adc	r3, r11
    788c:	f5 01       	movw	r30, r10
    788e:	80 80       	ld	r8, Z
    7890:	91 80       	ldd	r9, Z+1	; 0x01
    7892:	16 ff       	sbrs	r17, 6
    7894:	03 c0       	rjmp	.+6      	; 0x789c <vfprintf+0x1a2>
    7896:	6f 2d       	mov	r22, r15
    7898:	70 e0       	ldi	r23, 0x00	; 0
    789a:	02 c0       	rjmp	.+4      	; 0x78a0 <vfprintf+0x1a6>
    789c:	6f ef       	ldi	r22, 0xFF	; 255
    789e:	7f ef       	ldi	r23, 0xFF	; 255
    78a0:	c4 01       	movw	r24, r8
    78a2:	0e 94 7e 3d 	call	0x7afc	; 0x7afc <strnlen_P>
    78a6:	6c 01       	movw	r12, r24
    78a8:	10 68       	ori	r17, 0x80	; 128
    78aa:	51 01       	movw	r10, r2
    78ac:	13 fd       	sbrc	r17, 3
    78ae:	1c c0       	rjmp	.+56     	; 0x78e8 <vfprintf+0x1ee>
    78b0:	06 c0       	rjmp	.+12     	; 0x78be <vfprintf+0x1c4>
    78b2:	80 e2       	ldi	r24, 0x20	; 32
    78b4:	90 e0       	ldi	r25, 0x00	; 0
    78b6:	b3 01       	movw	r22, r6
    78b8:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    78bc:	ea 94       	dec	r14
    78be:	8e 2d       	mov	r24, r14
    78c0:	90 e0       	ldi	r25, 0x00	; 0
    78c2:	c8 16       	cp	r12, r24
    78c4:	d9 06       	cpc	r13, r25
    78c6:	a8 f3       	brcs	.-22     	; 0x78b2 <vfprintf+0x1b8>
    78c8:	0f c0       	rjmp	.+30     	; 0x78e8 <vfprintf+0x1ee>
    78ca:	f4 01       	movw	r30, r8
    78cc:	17 fd       	sbrc	r17, 7
    78ce:	85 91       	lpm	r24, Z+
    78d0:	17 ff       	sbrs	r17, 7
    78d2:	81 91       	ld	r24, Z+
    78d4:	4f 01       	movw	r8, r30
    78d6:	90 e0       	ldi	r25, 0x00	; 0
    78d8:	b3 01       	movw	r22, r6
    78da:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    78de:	e1 10       	cpse	r14, r1
    78e0:	ea 94       	dec	r14
    78e2:	08 94       	sec
    78e4:	c1 08       	sbc	r12, r1
    78e6:	d1 08       	sbc	r13, r1
    78e8:	c1 14       	cp	r12, r1
    78ea:	d1 04       	cpc	r13, r1
    78ec:	71 f7       	brne	.-36     	; 0x78ca <vfprintf+0x1d0>
    78ee:	e7 c0       	rjmp	.+462    	; 0x7abe <vfprintf+0x3c4>
    78f0:	84 36       	cpi	r24, 0x64	; 100
    78f2:	11 f0       	breq	.+4      	; 0x78f8 <vfprintf+0x1fe>
    78f4:	89 36       	cpi	r24, 0x69	; 105
    78f6:	51 f5       	brne	.+84     	; 0x794c <vfprintf+0x252>
    78f8:	f5 01       	movw	r30, r10
    78fa:	17 ff       	sbrs	r17, 7
    78fc:	07 c0       	rjmp	.+14     	; 0x790c <vfprintf+0x212>
    78fe:	80 81       	ld	r24, Z
    7900:	91 81       	ldd	r25, Z+1	; 0x01
    7902:	a2 81       	ldd	r26, Z+2	; 0x02
    7904:	b3 81       	ldd	r27, Z+3	; 0x03
    7906:	24 e0       	ldi	r18, 0x04	; 4
    7908:	30 e0       	ldi	r19, 0x00	; 0
    790a:	08 c0       	rjmp	.+16     	; 0x791c <vfprintf+0x222>
    790c:	80 81       	ld	r24, Z
    790e:	91 81       	ldd	r25, Z+1	; 0x01
    7910:	aa 27       	eor	r26, r26
    7912:	97 fd       	sbrc	r25, 7
    7914:	a0 95       	com	r26
    7916:	ba 2f       	mov	r27, r26
    7918:	22 e0       	ldi	r18, 0x02	; 2
    791a:	30 e0       	ldi	r19, 0x00	; 0
    791c:	a2 0e       	add	r10, r18
    791e:	b3 1e       	adc	r11, r19
    7920:	01 2f       	mov	r16, r17
    7922:	0f 76       	andi	r16, 0x6F	; 111
    7924:	b7 ff       	sbrs	r27, 7
    7926:	08 c0       	rjmp	.+16     	; 0x7938 <vfprintf+0x23e>
    7928:	b0 95       	com	r27
    792a:	a0 95       	com	r26
    792c:	90 95       	com	r25
    792e:	81 95       	neg	r24
    7930:	9f 4f       	sbci	r25, 0xFF	; 255
    7932:	af 4f       	sbci	r26, 0xFF	; 255
    7934:	bf 4f       	sbci	r27, 0xFF	; 255
    7936:	00 68       	ori	r16, 0x80	; 128
    7938:	bc 01       	movw	r22, r24
    793a:	cd 01       	movw	r24, r26
    793c:	a2 01       	movw	r20, r4
    793e:	2a e0       	ldi	r18, 0x0A	; 10
    7940:	30 e0       	ldi	r19, 0x00	; 0
    7942:	0e 94 d9 3d 	call	0x7bb2	; 0x7bb2 <__ultoa_invert>
    7946:	d8 2e       	mov	r13, r24
    7948:	d4 18       	sub	r13, r4
    794a:	3f c0       	rjmp	.+126    	; 0x79ca <vfprintf+0x2d0>
    794c:	85 37       	cpi	r24, 0x75	; 117
    794e:	21 f4       	brne	.+8      	; 0x7958 <vfprintf+0x25e>
    7950:	1f 7e       	andi	r17, 0xEF	; 239
    7952:	2a e0       	ldi	r18, 0x0A	; 10
    7954:	30 e0       	ldi	r19, 0x00	; 0
    7956:	20 c0       	rjmp	.+64     	; 0x7998 <vfprintf+0x29e>
    7958:	19 7f       	andi	r17, 0xF9	; 249
    795a:	8f 36       	cpi	r24, 0x6F	; 111
    795c:	a9 f0       	breq	.+42     	; 0x7988 <vfprintf+0x28e>
    795e:	80 37       	cpi	r24, 0x70	; 112
    7960:	20 f4       	brcc	.+8      	; 0x796a <vfprintf+0x270>
    7962:	88 35       	cpi	r24, 0x58	; 88
    7964:	09 f0       	breq	.+2      	; 0x7968 <vfprintf+0x26e>
    7966:	ae c0       	rjmp	.+348    	; 0x7ac4 <vfprintf+0x3ca>
    7968:	0b c0       	rjmp	.+22     	; 0x7980 <vfprintf+0x286>
    796a:	80 37       	cpi	r24, 0x70	; 112
    796c:	21 f0       	breq	.+8      	; 0x7976 <vfprintf+0x27c>
    796e:	88 37       	cpi	r24, 0x78	; 120
    7970:	09 f0       	breq	.+2      	; 0x7974 <vfprintf+0x27a>
    7972:	a8 c0       	rjmp	.+336    	; 0x7ac4 <vfprintf+0x3ca>
    7974:	01 c0       	rjmp	.+2      	; 0x7978 <vfprintf+0x27e>
    7976:	10 61       	ori	r17, 0x10	; 16
    7978:	14 ff       	sbrs	r17, 4
    797a:	09 c0       	rjmp	.+18     	; 0x798e <vfprintf+0x294>
    797c:	14 60       	ori	r17, 0x04	; 4
    797e:	07 c0       	rjmp	.+14     	; 0x798e <vfprintf+0x294>
    7980:	14 ff       	sbrs	r17, 4
    7982:	08 c0       	rjmp	.+16     	; 0x7994 <vfprintf+0x29a>
    7984:	16 60       	ori	r17, 0x06	; 6
    7986:	06 c0       	rjmp	.+12     	; 0x7994 <vfprintf+0x29a>
    7988:	28 e0       	ldi	r18, 0x08	; 8
    798a:	30 e0       	ldi	r19, 0x00	; 0
    798c:	05 c0       	rjmp	.+10     	; 0x7998 <vfprintf+0x29e>
    798e:	20 e1       	ldi	r18, 0x10	; 16
    7990:	30 e0       	ldi	r19, 0x00	; 0
    7992:	02 c0       	rjmp	.+4      	; 0x7998 <vfprintf+0x29e>
    7994:	20 e1       	ldi	r18, 0x10	; 16
    7996:	32 e0       	ldi	r19, 0x02	; 2
    7998:	f5 01       	movw	r30, r10
    799a:	17 ff       	sbrs	r17, 7
    799c:	07 c0       	rjmp	.+14     	; 0x79ac <vfprintf+0x2b2>
    799e:	60 81       	ld	r22, Z
    79a0:	71 81       	ldd	r23, Z+1	; 0x01
    79a2:	82 81       	ldd	r24, Z+2	; 0x02
    79a4:	93 81       	ldd	r25, Z+3	; 0x03
    79a6:	44 e0       	ldi	r20, 0x04	; 4
    79a8:	50 e0       	ldi	r21, 0x00	; 0
    79aa:	06 c0       	rjmp	.+12     	; 0x79b8 <vfprintf+0x2be>
    79ac:	60 81       	ld	r22, Z
    79ae:	71 81       	ldd	r23, Z+1	; 0x01
    79b0:	80 e0       	ldi	r24, 0x00	; 0
    79b2:	90 e0       	ldi	r25, 0x00	; 0
    79b4:	42 e0       	ldi	r20, 0x02	; 2
    79b6:	50 e0       	ldi	r21, 0x00	; 0
    79b8:	a4 0e       	add	r10, r20
    79ba:	b5 1e       	adc	r11, r21
    79bc:	a2 01       	movw	r20, r4
    79be:	0e 94 d9 3d 	call	0x7bb2	; 0x7bb2 <__ultoa_invert>
    79c2:	d8 2e       	mov	r13, r24
    79c4:	d4 18       	sub	r13, r4
    79c6:	01 2f       	mov	r16, r17
    79c8:	0f 77       	andi	r16, 0x7F	; 127
    79ca:	06 ff       	sbrs	r16, 6
    79cc:	09 c0       	rjmp	.+18     	; 0x79e0 <vfprintf+0x2e6>
    79ce:	0e 7f       	andi	r16, 0xFE	; 254
    79d0:	df 14       	cp	r13, r15
    79d2:	30 f4       	brcc	.+12     	; 0x79e0 <vfprintf+0x2e6>
    79d4:	04 ff       	sbrs	r16, 4
    79d6:	06 c0       	rjmp	.+12     	; 0x79e4 <vfprintf+0x2ea>
    79d8:	02 fd       	sbrc	r16, 2
    79da:	04 c0       	rjmp	.+8      	; 0x79e4 <vfprintf+0x2ea>
    79dc:	0f 7e       	andi	r16, 0xEF	; 239
    79de:	02 c0       	rjmp	.+4      	; 0x79e4 <vfprintf+0x2ea>
    79e0:	1d 2d       	mov	r17, r13
    79e2:	01 c0       	rjmp	.+2      	; 0x79e6 <vfprintf+0x2ec>
    79e4:	1f 2d       	mov	r17, r15
    79e6:	80 2f       	mov	r24, r16
    79e8:	90 e0       	ldi	r25, 0x00	; 0
    79ea:	04 ff       	sbrs	r16, 4
    79ec:	0c c0       	rjmp	.+24     	; 0x7a06 <vfprintf+0x30c>
    79ee:	fe 01       	movw	r30, r28
    79f0:	ed 0d       	add	r30, r13
    79f2:	f1 1d       	adc	r31, r1
    79f4:	20 81       	ld	r18, Z
    79f6:	20 33       	cpi	r18, 0x30	; 48
    79f8:	11 f4       	brne	.+4      	; 0x79fe <vfprintf+0x304>
    79fa:	09 7e       	andi	r16, 0xE9	; 233
    79fc:	09 c0       	rjmp	.+18     	; 0x7a10 <vfprintf+0x316>
    79fe:	02 ff       	sbrs	r16, 2
    7a00:	06 c0       	rjmp	.+12     	; 0x7a0e <vfprintf+0x314>
    7a02:	1e 5f       	subi	r17, 0xFE	; 254
    7a04:	05 c0       	rjmp	.+10     	; 0x7a10 <vfprintf+0x316>
    7a06:	86 78       	andi	r24, 0x86	; 134
    7a08:	90 70       	andi	r25, 0x00	; 0
    7a0a:	00 97       	sbiw	r24, 0x00	; 0
    7a0c:	09 f0       	breq	.+2      	; 0x7a10 <vfprintf+0x316>
    7a0e:	1f 5f       	subi	r17, 0xFF	; 255
    7a10:	80 2e       	mov	r8, r16
    7a12:	99 24       	eor	r9, r9
    7a14:	03 fd       	sbrc	r16, 3
    7a16:	12 c0       	rjmp	.+36     	; 0x7a3c <vfprintf+0x342>
    7a18:	00 ff       	sbrs	r16, 0
    7a1a:	0d c0       	rjmp	.+26     	; 0x7a36 <vfprintf+0x33c>
    7a1c:	fd 2c       	mov	r15, r13
    7a1e:	1e 15       	cp	r17, r14
    7a20:	50 f4       	brcc	.+20     	; 0x7a36 <vfprintf+0x33c>
    7a22:	fe 0c       	add	r15, r14
    7a24:	f1 1a       	sub	r15, r17
    7a26:	1e 2d       	mov	r17, r14
    7a28:	06 c0       	rjmp	.+12     	; 0x7a36 <vfprintf+0x33c>
    7a2a:	80 e2       	ldi	r24, 0x20	; 32
    7a2c:	90 e0       	ldi	r25, 0x00	; 0
    7a2e:	b3 01       	movw	r22, r6
    7a30:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    7a34:	1f 5f       	subi	r17, 0xFF	; 255
    7a36:	1e 15       	cp	r17, r14
    7a38:	c0 f3       	brcs	.-16     	; 0x7a2a <vfprintf+0x330>
    7a3a:	04 c0       	rjmp	.+8      	; 0x7a44 <vfprintf+0x34a>
    7a3c:	1e 15       	cp	r17, r14
    7a3e:	10 f4       	brcc	.+4      	; 0x7a44 <vfprintf+0x34a>
    7a40:	e1 1a       	sub	r14, r17
    7a42:	01 c0       	rjmp	.+2      	; 0x7a46 <vfprintf+0x34c>
    7a44:	ee 24       	eor	r14, r14
    7a46:	84 fe       	sbrs	r8, 4
    7a48:	0f c0       	rjmp	.+30     	; 0x7a68 <vfprintf+0x36e>
    7a4a:	80 e3       	ldi	r24, 0x30	; 48
    7a4c:	90 e0       	ldi	r25, 0x00	; 0
    7a4e:	b3 01       	movw	r22, r6
    7a50:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    7a54:	82 fe       	sbrs	r8, 2
    7a56:	1f c0       	rjmp	.+62     	; 0x7a96 <vfprintf+0x39c>
    7a58:	81 fe       	sbrs	r8, 1
    7a5a:	03 c0       	rjmp	.+6      	; 0x7a62 <vfprintf+0x368>
    7a5c:	88 e5       	ldi	r24, 0x58	; 88
    7a5e:	90 e0       	ldi	r25, 0x00	; 0
    7a60:	10 c0       	rjmp	.+32     	; 0x7a82 <vfprintf+0x388>
    7a62:	88 e7       	ldi	r24, 0x78	; 120
    7a64:	90 e0       	ldi	r25, 0x00	; 0
    7a66:	0d c0       	rjmp	.+26     	; 0x7a82 <vfprintf+0x388>
    7a68:	c4 01       	movw	r24, r8
    7a6a:	86 78       	andi	r24, 0x86	; 134
    7a6c:	90 70       	andi	r25, 0x00	; 0
    7a6e:	00 97       	sbiw	r24, 0x00	; 0
    7a70:	91 f0       	breq	.+36     	; 0x7a96 <vfprintf+0x39c>
    7a72:	81 fc       	sbrc	r8, 1
    7a74:	02 c0       	rjmp	.+4      	; 0x7a7a <vfprintf+0x380>
    7a76:	80 e2       	ldi	r24, 0x20	; 32
    7a78:	01 c0       	rjmp	.+2      	; 0x7a7c <vfprintf+0x382>
    7a7a:	8b e2       	ldi	r24, 0x2B	; 43
    7a7c:	07 fd       	sbrc	r16, 7
    7a7e:	8d e2       	ldi	r24, 0x2D	; 45
    7a80:	90 e0       	ldi	r25, 0x00	; 0
    7a82:	b3 01       	movw	r22, r6
    7a84:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    7a88:	06 c0       	rjmp	.+12     	; 0x7a96 <vfprintf+0x39c>
    7a8a:	80 e3       	ldi	r24, 0x30	; 48
    7a8c:	90 e0       	ldi	r25, 0x00	; 0
    7a8e:	b3 01       	movw	r22, r6
    7a90:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    7a94:	fa 94       	dec	r15
    7a96:	df 14       	cp	r13, r15
    7a98:	c0 f3       	brcs	.-16     	; 0x7a8a <vfprintf+0x390>
    7a9a:	da 94       	dec	r13
    7a9c:	f2 01       	movw	r30, r4
    7a9e:	ed 0d       	add	r30, r13
    7aa0:	f1 1d       	adc	r31, r1
    7aa2:	80 81       	ld	r24, Z
    7aa4:	90 e0       	ldi	r25, 0x00	; 0
    7aa6:	b3 01       	movw	r22, r6
    7aa8:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    7aac:	dd 20       	and	r13, r13
    7aae:	a9 f7       	brne	.-22     	; 0x7a9a <vfprintf+0x3a0>
    7ab0:	06 c0       	rjmp	.+12     	; 0x7abe <vfprintf+0x3c4>
    7ab2:	80 e2       	ldi	r24, 0x20	; 32
    7ab4:	90 e0       	ldi	r25, 0x00	; 0
    7ab6:	b3 01       	movw	r22, r6
    7ab8:	0e 94 ad 3d 	call	0x7b5a	; 0x7b5a <fputc>
    7abc:	ea 94       	dec	r14
    7abe:	ee 20       	and	r14, r14
    7ac0:	c1 f7       	brne	.-16     	; 0x7ab2 <vfprintf+0x3b8>
    7ac2:	40 ce       	rjmp	.-896    	; 0x7744 <vfprintf+0x4a>
    7ac4:	f3 01       	movw	r30, r6
    7ac6:	86 81       	ldd	r24, Z+6	; 0x06
    7ac8:	97 81       	ldd	r25, Z+7	; 0x07
    7aca:	02 c0       	rjmp	.+4      	; 0x7ad0 <vfprintf+0x3d6>
    7acc:	8f ef       	ldi	r24, 0xFF	; 255
    7ace:	9f ef       	ldi	r25, 0xFF	; 255
    7ad0:	2d 96       	adiw	r28, 0x0d	; 13
    7ad2:	cd bf       	out	0x3d, r28	; 61
    7ad4:	de bf       	out	0x3e, r29	; 62
    7ad6:	df 91       	pop	r29
    7ad8:	cf 91       	pop	r28
    7ada:	1f 91       	pop	r17
    7adc:	0f 91       	pop	r16
    7ade:	ff 90       	pop	r15
    7ae0:	ef 90       	pop	r14
    7ae2:	df 90       	pop	r13
    7ae4:	cf 90       	pop	r12
    7ae6:	bf 90       	pop	r11
    7ae8:	af 90       	pop	r10
    7aea:	9f 90       	pop	r9
    7aec:	8f 90       	pop	r8
    7aee:	7f 90       	pop	r7
    7af0:	6f 90       	pop	r6
    7af2:	5f 90       	pop	r5
    7af4:	4f 90       	pop	r4
    7af6:	3f 90       	pop	r3
    7af8:	2f 90       	pop	r2
    7afa:	08 95       	ret

00007afc <strnlen_P>:
    7afc:	fc 01       	movw	r30, r24
    7afe:	05 90       	lpm	r0, Z+
    7b00:	61 50       	subi	r22, 0x01	; 1
    7b02:	70 40       	sbci	r23, 0x00	; 0
    7b04:	01 10       	cpse	r0, r1
    7b06:	d8 f7       	brcc	.-10     	; 0x7afe <strnlen_P+0x2>
    7b08:	80 95       	com	r24
    7b0a:	90 95       	com	r25
    7b0c:	8e 0f       	add	r24, r30
    7b0e:	9f 1f       	adc	r25, r31
    7b10:	08 95       	ret

00007b12 <memcpy>:
    7b12:	fb 01       	movw	r30, r22
    7b14:	dc 01       	movw	r26, r24
    7b16:	02 c0       	rjmp	.+4      	; 0x7b1c <memcpy+0xa>
    7b18:	01 90       	ld	r0, Z+
    7b1a:	0d 92       	st	X+, r0
    7b1c:	41 50       	subi	r20, 0x01	; 1
    7b1e:	50 40       	sbci	r21, 0x00	; 0
    7b20:	d8 f7       	brcc	.-10     	; 0x7b18 <memcpy+0x6>
    7b22:	08 95       	ret

00007b24 <strnlen>:
    7b24:	fc 01       	movw	r30, r24
    7b26:	61 50       	subi	r22, 0x01	; 1
    7b28:	70 40       	sbci	r23, 0x00	; 0
    7b2a:	01 90       	ld	r0, Z+
    7b2c:	01 10       	cpse	r0, r1
    7b2e:	d8 f7       	brcc	.-10     	; 0x7b26 <strnlen+0x2>
    7b30:	80 95       	com	r24
    7b32:	90 95       	com	r25
    7b34:	8e 0f       	add	r24, r30
    7b36:	9f 1f       	adc	r25, r31
    7b38:	08 95       	ret

00007b3a <strrev>:
    7b3a:	dc 01       	movw	r26, r24
    7b3c:	fc 01       	movw	r30, r24
    7b3e:	67 2f       	mov	r22, r23
    7b40:	71 91       	ld	r23, Z+
    7b42:	77 23       	and	r23, r23
    7b44:	e1 f7       	brne	.-8      	; 0x7b3e <strrev+0x4>
    7b46:	32 97       	sbiw	r30, 0x02	; 2
    7b48:	04 c0       	rjmp	.+8      	; 0x7b52 <strrev+0x18>
    7b4a:	7c 91       	ld	r23, X
    7b4c:	6d 93       	st	X+, r22
    7b4e:	70 83       	st	Z, r23
    7b50:	62 91       	ld	r22, -Z
    7b52:	ae 17       	cp	r26, r30
    7b54:	bf 07       	cpc	r27, r31
    7b56:	c8 f3       	brcs	.-14     	; 0x7b4a <strrev+0x10>
    7b58:	08 95       	ret

00007b5a <fputc>:
    7b5a:	0f 93       	push	r16
    7b5c:	1f 93       	push	r17
    7b5e:	cf 93       	push	r28
    7b60:	df 93       	push	r29
    7b62:	8c 01       	movw	r16, r24
    7b64:	eb 01       	movw	r28, r22
    7b66:	8b 81       	ldd	r24, Y+3	; 0x03
    7b68:	81 ff       	sbrs	r24, 1
    7b6a:	1b c0       	rjmp	.+54     	; 0x7ba2 <fputc+0x48>
    7b6c:	82 ff       	sbrs	r24, 2
    7b6e:	0d c0       	rjmp	.+26     	; 0x7b8a <fputc+0x30>
    7b70:	2e 81       	ldd	r18, Y+6	; 0x06
    7b72:	3f 81       	ldd	r19, Y+7	; 0x07
    7b74:	8c 81       	ldd	r24, Y+4	; 0x04
    7b76:	9d 81       	ldd	r25, Y+5	; 0x05
    7b78:	28 17       	cp	r18, r24
    7b7a:	39 07       	cpc	r19, r25
    7b7c:	64 f4       	brge	.+24     	; 0x7b96 <fputc+0x3c>
    7b7e:	e8 81       	ld	r30, Y
    7b80:	f9 81       	ldd	r31, Y+1	; 0x01
    7b82:	01 93       	st	Z+, r16
    7b84:	e8 83       	st	Y, r30
    7b86:	f9 83       	std	Y+1, r31	; 0x01
    7b88:	06 c0       	rjmp	.+12     	; 0x7b96 <fputc+0x3c>
    7b8a:	e8 85       	ldd	r30, Y+8	; 0x08
    7b8c:	f9 85       	ldd	r31, Y+9	; 0x09
    7b8e:	80 2f       	mov	r24, r16
    7b90:	19 95       	eicall
    7b92:	00 97       	sbiw	r24, 0x00	; 0
    7b94:	31 f4       	brne	.+12     	; 0x7ba2 <fputc+0x48>
    7b96:	8e 81       	ldd	r24, Y+6	; 0x06
    7b98:	9f 81       	ldd	r25, Y+7	; 0x07
    7b9a:	01 96       	adiw	r24, 0x01	; 1
    7b9c:	8e 83       	std	Y+6, r24	; 0x06
    7b9e:	9f 83       	std	Y+7, r25	; 0x07
    7ba0:	02 c0       	rjmp	.+4      	; 0x7ba6 <fputc+0x4c>
    7ba2:	0f ef       	ldi	r16, 0xFF	; 255
    7ba4:	1f ef       	ldi	r17, 0xFF	; 255
    7ba6:	c8 01       	movw	r24, r16
    7ba8:	df 91       	pop	r29
    7baa:	cf 91       	pop	r28
    7bac:	1f 91       	pop	r17
    7bae:	0f 91       	pop	r16
    7bb0:	08 95       	ret

00007bb2 <__ultoa_invert>:
    7bb2:	fa 01       	movw	r30, r20
    7bb4:	aa 27       	eor	r26, r26
    7bb6:	28 30       	cpi	r18, 0x08	; 8
    7bb8:	51 f1       	breq	.+84     	; 0x7c0e <__ultoa_invert+0x5c>
    7bba:	20 31       	cpi	r18, 0x10	; 16
    7bbc:	81 f1       	breq	.+96     	; 0x7c1e <__ultoa_invert+0x6c>
    7bbe:	e8 94       	clt
    7bc0:	6f 93       	push	r22
    7bc2:	6e 7f       	andi	r22, 0xFE	; 254
    7bc4:	6e 5f       	subi	r22, 0xFE	; 254
    7bc6:	7f 4f       	sbci	r23, 0xFF	; 255
    7bc8:	8f 4f       	sbci	r24, 0xFF	; 255
    7bca:	9f 4f       	sbci	r25, 0xFF	; 255
    7bcc:	af 4f       	sbci	r26, 0xFF	; 255
    7bce:	b1 e0       	ldi	r27, 0x01	; 1
    7bd0:	3e d0       	rcall	.+124    	; 0x7c4e <__ultoa_invert+0x9c>
    7bd2:	b4 e0       	ldi	r27, 0x04	; 4
    7bd4:	3c d0       	rcall	.+120    	; 0x7c4e <__ultoa_invert+0x9c>
    7bd6:	67 0f       	add	r22, r23
    7bd8:	78 1f       	adc	r23, r24
    7bda:	89 1f       	adc	r24, r25
    7bdc:	9a 1f       	adc	r25, r26
    7bde:	a1 1d       	adc	r26, r1
    7be0:	68 0f       	add	r22, r24
    7be2:	79 1f       	adc	r23, r25
    7be4:	8a 1f       	adc	r24, r26
    7be6:	91 1d       	adc	r25, r1
    7be8:	a1 1d       	adc	r26, r1
    7bea:	6a 0f       	add	r22, r26
    7bec:	71 1d       	adc	r23, r1
    7bee:	81 1d       	adc	r24, r1
    7bf0:	91 1d       	adc	r25, r1
    7bf2:	a1 1d       	adc	r26, r1
    7bf4:	20 d0       	rcall	.+64     	; 0x7c36 <__ultoa_invert+0x84>
    7bf6:	09 f4       	brne	.+2      	; 0x7bfa <__ultoa_invert+0x48>
    7bf8:	68 94       	set
    7bfa:	3f 91       	pop	r19
    7bfc:	2a e0       	ldi	r18, 0x0A	; 10
    7bfe:	26 9f       	mul	r18, r22
    7c00:	11 24       	eor	r1, r1
    7c02:	30 19       	sub	r19, r0
    7c04:	30 5d       	subi	r19, 0xD0	; 208
    7c06:	31 93       	st	Z+, r19
    7c08:	de f6       	brtc	.-74     	; 0x7bc0 <__ultoa_invert+0xe>
    7c0a:	cf 01       	movw	r24, r30
    7c0c:	08 95       	ret
    7c0e:	46 2f       	mov	r20, r22
    7c10:	47 70       	andi	r20, 0x07	; 7
    7c12:	40 5d       	subi	r20, 0xD0	; 208
    7c14:	41 93       	st	Z+, r20
    7c16:	b3 e0       	ldi	r27, 0x03	; 3
    7c18:	0f d0       	rcall	.+30     	; 0x7c38 <__ultoa_invert+0x86>
    7c1a:	c9 f7       	brne	.-14     	; 0x7c0e <__ultoa_invert+0x5c>
    7c1c:	f6 cf       	rjmp	.-20     	; 0x7c0a <__ultoa_invert+0x58>
    7c1e:	46 2f       	mov	r20, r22
    7c20:	4f 70       	andi	r20, 0x0F	; 15
    7c22:	40 5d       	subi	r20, 0xD0	; 208
    7c24:	4a 33       	cpi	r20, 0x3A	; 58
    7c26:	18 f0       	brcs	.+6      	; 0x7c2e <__ultoa_invert+0x7c>
    7c28:	49 5d       	subi	r20, 0xD9	; 217
    7c2a:	31 fd       	sbrc	r19, 1
    7c2c:	40 52       	subi	r20, 0x20	; 32
    7c2e:	41 93       	st	Z+, r20
    7c30:	02 d0       	rcall	.+4      	; 0x7c36 <__ultoa_invert+0x84>
    7c32:	a9 f7       	brne	.-22     	; 0x7c1e <__ultoa_invert+0x6c>
    7c34:	ea cf       	rjmp	.-44     	; 0x7c0a <__ultoa_invert+0x58>
    7c36:	b4 e0       	ldi	r27, 0x04	; 4
    7c38:	a6 95       	lsr	r26
    7c3a:	97 95       	ror	r25
    7c3c:	87 95       	ror	r24
    7c3e:	77 95       	ror	r23
    7c40:	67 95       	ror	r22
    7c42:	ba 95       	dec	r27
    7c44:	c9 f7       	brne	.-14     	; 0x7c38 <__ultoa_invert+0x86>
    7c46:	00 97       	sbiw	r24, 0x00	; 0
    7c48:	61 05       	cpc	r22, r1
    7c4a:	71 05       	cpc	r23, r1
    7c4c:	08 95       	ret
    7c4e:	9b 01       	movw	r18, r22
    7c50:	ac 01       	movw	r20, r24
    7c52:	0a 2e       	mov	r0, r26
    7c54:	06 94       	lsr	r0
    7c56:	57 95       	ror	r21
    7c58:	47 95       	ror	r20
    7c5a:	37 95       	ror	r19
    7c5c:	27 95       	ror	r18
    7c5e:	ba 95       	dec	r27
    7c60:	c9 f7       	brne	.-14     	; 0x7c54 <__ultoa_invert+0xa2>
    7c62:	62 0f       	add	r22, r18
    7c64:	73 1f       	adc	r23, r19
    7c66:	84 1f       	adc	r24, r20
    7c68:	95 1f       	adc	r25, r21
    7c6a:	a0 1d       	adc	r26, r0
    7c6c:	08 95       	ret

00007c6e <_exit>:
    7c6e:	f8 94       	cli

00007c70 <__stop_program>:
    7c70:	ff cf       	rjmp	.-2      	; 0x7c70 <__stop_program>
