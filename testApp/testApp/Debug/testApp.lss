
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c476  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000012e  00802000  0000c476  0000c50a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fbd  0080212e  0080212e  0000c638  2**0
                  ALLOC
  3 .stab         00002784  00000000  00000000  0000c638  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a8c  00000000  00000000  0000edbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  0000f848  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c614  00000000  00000000  0000fc08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000213d  00000000  00000000  0001c21c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003dda  00000000  00000000  0001e359  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c38  00000000  00000000  00022134  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004572  00000000  00000000  00023d6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000051af  00000000  00000000  000282de  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0002d48d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 5b 14 	jmp	0x28b6	; 0x28b6 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 6f 13 	jmp	0x26de	; 0x26de <__vector_16>
      44:	0c 94 9f 13 	jmp	0x273e	; 0x273e <__vector_17>
      48:	0c 94 cf 13 	jmp	0x279e	; 0x279e <__vector_18>
      4c:	0c 94 ff 13 	jmp	0x27fe	; 0x27fe <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 ab 40 	jmp	0x8156	; 0x8156 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 18 30 	jmp	0x6030	; 0x6030 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 60 16 	jmp	0x2cc0	; 0x2cc0 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 9e 15 	jmp	0x2b3c	; 0x2b3c <__vector_79>
     140:	0c 94 ce 15 	jmp	0x2b9c	; 0x2b9c <__vector_80>
     144:	0c 94 fe 15 	jmp	0x2bfc	; 0x2bfc <__vector_81>
     148:	0c 94 2e 16 	jmp	0x2c5c	; 0x2c5c <__vector_82>
     14c:	0c 94 ea 01 	jmp	0x3d4	; 0x3d4 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 7a 10 	jmp	0x20f4	; 0x20f4 <__vector_104>
     1a4:	0c 94 b8 0e 	jmp	0x1d70	; 0x1d70 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e6 e7       	ldi	r30, 0x76	; 118
     244:	f4 ec       	ldi	r31, 0xC4	; 196
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 32       	cpi	r26, 0x2E	; 46
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e2       	ldi	r26, 0x2E	; 46
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ab 3e       	cpi	r26, 0xEB	; 235
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 39 01 	call	0x272	; 0x272 <main>
     26a:	0c 94 39 62 	jmp	0xc472	; 0xc472 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <main>:
 * Created: 1/29/2013 2:50:50 PM
 *  Author: Vlad
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	00 d0       	rcall	.+0      	; 0x278 <main+0x6>
     278:	00 d0       	rcall	.+0      	; 0x27a <main+0x8>
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
	chb_init();
     27e:	0e 94 47 20 	call	0x408e	; 0x408e <chb_init>
	SD_init();
     282:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <SD_init>
	getBootSectorData();
     286:	0e 94 83 41 	call	0x8306	; 0x8306 <getBootSectorData>
	uint16_t MotesInSystem = 2;
     28a:	82 e0       	ldi	r24, 0x02	; 2
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	8d 83       	std	Y+5, r24	; 0x05
     290:	9e 83       	std	Y+6, r25	; 0x06
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     292:	46 c0       	rjmp	.+140    	; 0x320 <main+0xae>
			//store samples in SD card as they come in
			if(StartOfFreeSpace >= 512){
     294:	80 91 d0 50 	lds	r24, 0x50D0
     298:	90 91 d1 50 	lds	r25, 0x50D1
     29c:	a0 91 d2 50 	lds	r26, 0x50D2
     2a0:	b0 91 d3 50 	lds	r27, 0x50D3
     2a4:	80 30       	cpi	r24, 0x00	; 0
     2a6:	22 e0       	ldi	r18, 0x02	; 2
     2a8:	92 07       	cpc	r25, r18
     2aa:	20 e0       	ldi	r18, 0x00	; 0
     2ac:	a2 07       	cpc	r26, r18
     2ae:	20 e0       	ldi	r18, 0x00	; 0
     2b0:	b2 07       	cpc	r27, r18
     2b2:	b0 f1       	brcs	.+108    	; 0x320 <main+0xae>
				cli();
     2b4:	f8 94       	cli
				for(uint32_t i=0;i<StartOfFreeSpace;i+=512){	//atomically write the data that accumulated in the FRAM buffer to the SD card
     2b6:	19 82       	std	Y+1, r1	; 0x01
     2b8:	1a 82       	std	Y+2, r1	; 0x02
     2ba:	1b 82       	std	Y+3, r1	; 0x03
     2bc:	1c 82       	std	Y+4, r1	; 0x04
     2be:	16 c0       	rjmp	.+44     	; 0x2ec <main+0x7a>
					writeFile("DATA",i);						
     2c0:	80 e0       	ldi	r24, 0x00	; 0
     2c2:	90 e2       	ldi	r25, 0x20	; 32
     2c4:	29 81       	ldd	r18, Y+1	; 0x01
     2c6:	3a 81       	ldd	r19, Y+2	; 0x02
     2c8:	4b 81       	ldd	r20, Y+3	; 0x03
     2ca:	5c 81       	ldd	r21, Y+4	; 0x04
     2cc:	ba 01       	movw	r22, r20
     2ce:	a9 01       	movw	r20, r18
     2d0:	0e 94 18 48 	call	0x9030	; 0x9030 <writeFile>
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
			//store samples in SD card as they come in
			if(StartOfFreeSpace >= 512){
				cli();
				for(uint32_t i=0;i<StartOfFreeSpace;i+=512){	//atomically write the data that accumulated in the FRAM buffer to the SD card
     2d4:	89 81       	ldd	r24, Y+1	; 0x01
     2d6:	9a 81       	ldd	r25, Y+2	; 0x02
     2d8:	ab 81       	ldd	r26, Y+3	; 0x03
     2da:	bc 81       	ldd	r27, Y+4	; 0x04
     2dc:	80 50       	subi	r24, 0x00	; 0
     2de:	9e 4f       	sbci	r25, 0xFE	; 254
     2e0:	af 4f       	sbci	r26, 0xFF	; 255
     2e2:	bf 4f       	sbci	r27, 0xFF	; 255
     2e4:	89 83       	std	Y+1, r24	; 0x01
     2e6:	9a 83       	std	Y+2, r25	; 0x02
     2e8:	ab 83       	std	Y+3, r26	; 0x03
     2ea:	bc 83       	std	Y+4, r27	; 0x04
     2ec:	80 91 d0 50 	lds	r24, 0x50D0
     2f0:	90 91 d1 50 	lds	r25, 0x50D1
     2f4:	a0 91 d2 50 	lds	r26, 0x50D2
     2f8:	b0 91 d3 50 	lds	r27, 0x50D3
     2fc:	29 81       	ldd	r18, Y+1	; 0x01
     2fe:	3a 81       	ldd	r19, Y+2	; 0x02
     300:	4b 81       	ldd	r20, Y+3	; 0x03
     302:	5c 81       	ldd	r21, Y+4	; 0x04
     304:	28 17       	cp	r18, r24
     306:	39 07       	cpc	r19, r25
     308:	4a 07       	cpc	r20, r26
     30a:	5b 07       	cpc	r21, r27
     30c:	c8 f2       	brcs	.-78     	; 0x2c0 <main+0x4e>
					writeFile("DATA",i);						
				}
				StartOfFreeSpace = 0;					
     30e:	10 92 d0 50 	sts	0x50D0, r1
     312:	10 92 d1 50 	sts	0x50D1, r1
     316:	10 92 d2 50 	sts	0x50D2, r1
     31a:	10 92 d3 50 	sts	0x50D3, r1
				sei();
     31e:	78 94       	sei
	chb_init();
	SD_init();
	getBootSectorData();
	uint16_t MotesInSystem = 2;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     320:	20 91 69 50 	lds	r18, 0x5069
     324:	30 91 6a 50 	lds	r19, 0x506A
     328:	8d 81       	ldd	r24, Y+5	; 0x05
     32a:	9e 81       	ldd	r25, Y+6	; 0x06
     32c:	28 17       	cp	r18, r24
     32e:	39 07       	cpc	r19, r25
     330:	08 f4       	brcc	.+2      	; 0x334 <main+0xc2>
     332:	b0 cf       	rjmp	.-160    	; 0x294 <main+0x22>
				StartOfFreeSpace = 0;					
				sei();
			}				
		}
		//send synch message
		MotesReadyToSynch = 0;	//reset unsynched motes number
     334:	10 92 69 50 	sts	0x5069, r1
     338:	10 92 6a 50 	sts	0x506A, r1
	}	
     33c:	00 00       	nop
	chb_init();
	SD_init();
	getBootSectorData();
	uint16_t MotesInSystem = 2;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     33e:	f0 cf       	rjmp	.-32     	; 0x320 <main+0xae>

00000340 <synch>:
uint16_t* moteID;
//const char ResetCommand[6] = {'r','e','s','e','t','\n'};
uint8_t messageSize = 8;
char buff[8];

void synch(int SynchPer){
     340:	cf 93       	push	r28
     342:	df 93       	push	r29
     344:	0f 92       	push	r0
     346:	0f 92       	push	r0
     348:	cd b7       	in	r28, 0x3d	; 61
     34a:	de b7       	in	r29, 0x3e	; 62
     34c:	89 83       	std	Y+1, r24	; 0x01
     34e:	9a 83       	std	Y+2, r25	; 0x02
	*ResetCommand = "reset";
     350:	86 e0       	ldi	r24, 0x06	; 6
     352:	90 e2       	ldi	r25, 0x20	; 32
     354:	80 93 ac 50 	sts	0x50AC, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     358:	83 e0       	ldi	r24, 0x03	; 3
     35a:	80 93 53 40 	sts	0x4053, r24
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     35e:	80 e8       	ldi	r24, 0x80	; 128
     360:	91 e0       	ldi	r25, 0x01	; 1
     362:	28 ec       	ldi	r18, 0xC8	; 200
     364:	fc 01       	movw	r30, r24
     366:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     368:	80 e4       	ldi	r24, 0x40	; 64
     36a:	99 e0       	ldi	r25, 0x09	; 9
     36c:	29 e0       	ldi	r18, 0x09	; 9
     36e:	fc 01       	movw	r30, r24
     370:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x03;	//enable timer overflow interrupt as high priority interrupt
     372:	80 e4       	ldi	r24, 0x40	; 64
     374:	99 e0       	ldi	r25, 0x09	; 9
     376:	23 e0       	ldi	r18, 0x03	; 3
     378:	fc 01       	movw	r30, r24
     37a:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     37c:	80 e4       	ldi	r24, 0x40	; 64
     37e:	99 e0       	ldi	r25, 0x09	; 9
     380:	69 81       	ldd	r22, Y+1	; 0x01
     382:	7a 81       	ldd	r23, Y+2	; 0x02
     384:	44 ef       	ldi	r20, 0xF4	; 244
     386:	51 e0       	ldi	r21, 0x01	; 1
     388:	64 9f       	mul	r22, r20
     38a:	90 01       	movw	r18, r0
     38c:	65 9f       	mul	r22, r21
     38e:	30 0d       	add	r19, r0
     390:	74 9f       	mul	r23, r20
     392:	30 0d       	add	r19, r0
     394:	11 24       	eor	r1, r1
     396:	fc 01       	movw	r30, r24
     398:	26 a3       	lds	r18, 0x56
     39a:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     39c:	80 e4       	ldi	r24, 0x40	; 64
     39e:	98 e0       	ldi	r25, 0x08	; 8
     3a0:	20 e0       	ldi	r18, 0x00	; 0
     3a2:	3a ef       	ldi	r19, 0xFA	; 250
     3a4:	fc 01       	movw	r30, r24
     3a6:	26 a3       	lds	r18, 0x56
     3a8:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x02;  //enable timer overflow interrupt as medium priority interrupt
     3aa:	80 e4       	ldi	r24, 0x40	; 64
     3ac:	98 e0       	ldi	r25, 0x08	; 8
     3ae:	22 e0       	ldi	r18, 0x02	; 2
     3b0:	fc 01       	movw	r30, r24
     3b2:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     3b4:	80 e4       	ldi	r24, 0x40	; 64
     3b6:	98 e0       	ldi	r25, 0x08	; 8
     3b8:	21 e0       	ldi	r18, 0x01	; 1
     3ba:	fc 01       	movw	r30, r24
     3bc:	20 83       	st	Z, r18
	PMIC.CTRL = ENABLE_ALL_INTERRUPT_LEVELS;
     3be:	80 ea       	ldi	r24, 0xA0	; 160
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	27 e0       	ldi	r18, 0x07	; 7
     3c4:	fc 01       	movw	r30, r24
     3c6:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     3c8:	78 94       	sei
}
     3ca:	0f 90       	pop	r0
     3cc:	0f 90       	pop	r0
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	08 95       	ret

000003d4 <__vector_83>:

ISR(TCD1_OVF_vect) {
     3d4:	1f 92       	push	r1
     3d6:	0f 92       	push	r0
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	0f 92       	push	r0
     3dc:	00 90 3b 00 	lds	r0, 0x003B
     3e0:	0f 92       	push	r0
     3e2:	11 24       	eor	r1, r1
     3e4:	ef 92       	push	r14
     3e6:	ff 92       	push	r15
     3e8:	0f 93       	push	r16
     3ea:	1f 93       	push	r17
     3ec:	2f 93       	push	r18
     3ee:	3f 93       	push	r19
     3f0:	4f 93       	push	r20
     3f2:	5f 93       	push	r21
     3f4:	6f 93       	push	r22
     3f6:	7f 93       	push	r23
     3f8:	8f 93       	push	r24
     3fa:	9f 93       	push	r25
     3fc:	af 93       	push	r26
     3fe:	bf 93       	push	r27
     400:	ef 93       	push	r30
     402:	ff 93       	push	r31
     404:	cf 93       	push	r28
     406:	df 93       	push	r29
     408:	00 d0       	rcall	.+0      	; 0x40a <__vector_83+0x36>
     40a:	0f 92       	push	r0
     40c:	cd b7       	in	r28, 0x3d	; 61
     40e:	de b7       	in	r29, 0x3e	; 62
	//insert code here to send and wait for synch message
	//perhaps just disable ADC or ADC interrupts while waiting for reply instead of having the whole mote hang
	RadioMonitorMode = TIME_SYNCH;
	ADC_Pause_Sampling();	//pause the ADC while synching
	chb_write(0x0000,message,strlen(message));
}	
     410:	0d b7       	in	r16, 0x3d	; 61
     412:	1e b7       	in	r17, 0x3e	; 62
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
	PMIC.CTRL = ENABLE_ALL_INTERRUPT_LEVELS;
	sei(); //  Enable global interrupts
}

ISR(TCD1_OVF_vect) {
     414:	8d b7       	in	r24, 0x3d	; 61
     416:	9e b7       	in	r25, 0x3e	; 62
     418:	7c 01       	movw	r14, r24
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     41a:	80 e4       	ldi	r24, 0x40	; 64
     41c:	98 e0       	ldi	r25, 0x08	; 8
     41e:	fc 01       	movw	r30, r24
     420:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     422:	80 e4       	ldi	r24, 0x40	; 64
     424:	99 e0       	ldi	r25, 0x09	; 9
     426:	fc 01       	movw	r30, r24
     428:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
     42a:	80 e4       	ldi	r24, 0x40	; 64
     42c:	98 e0       	ldi	r25, 0x08	; 8
     42e:	2c e0       	ldi	r18, 0x0C	; 12
     430:	fc 01       	movw	r30, r24
     432:	21 87       	std	Z+9, r18	; 0x09
	TCD1.CTRLFSET = 0x0C;
     434:	80 e4       	ldi	r24, 0x40	; 64
     436:	99 e0       	ldi	r25, 0x09	; 9
     438:	2c e0       	ldi	r18, 0x0C	; 12
     43a:	fc 01       	movw	r30, r24
     43c:	21 87       	std	Z+9, r18	; 0x09
	chb_init();
     43e:	0e 94 47 20 	call	0x408e	; 0x408e <chb_init>
	chb_set_short_addr(*moteID);
     442:	80 91 e3 50 	lds	r24, 0x50E3
     446:	90 91 e4 50 	lds	r25, 0x50E4
     44a:	fc 01       	movw	r30, r24
     44c:	80 81       	ld	r24, Z
     44e:	91 81       	ldd	r25, Z+1	; 0x01
     450:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <chb_set_short_addr>
	char message[messageSize];
     454:	20 91 05 20 	lds	r18, 0x2005
     458:	82 2f       	mov	r24, r18
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	01 97       	sbiw	r24, 0x01	; 1
     45e:	89 83       	std	Y+1, r24	; 0x01
     460:	9a 83       	std	Y+2, r25	; 0x02
     462:	82 2f       	mov	r24, r18
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	2d b7       	in	r18, 0x3d	; 61
     468:	3e b7       	in	r19, 0x3e	; 62
     46a:	28 1b       	sub	r18, r24
     46c:	39 0b       	sbc	r19, r25
     46e:	2d bf       	out	0x3d, r18	; 61
     470:	3e bf       	out	0x3e, r19	; 62
     472:	8d b7       	in	r24, 0x3d	; 61
     474:	9e b7       	in	r25, 0x3e	; 62
     476:	01 96       	adiw	r24, 0x01	; 1
     478:	00 96       	adiw	r24, 0x00	; 0
     47a:	8b 83       	std	Y+3, r24	; 0x03
     47c:	9c 83       	std	Y+4, r25	; 0x04
	strcpy(message,ResetCommand);
     47e:	8b 81       	ldd	r24, Y+3	; 0x03
     480:	9c 81       	ldd	r25, Y+4	; 0x04
     482:	2c ea       	ldi	r18, 0xAC	; 172
     484:	30 e5       	ldi	r19, 0x50	; 80
     486:	b9 01       	movw	r22, r18
     488:	0e 94 37 5f 	call	0xbe6e	; 0xbe6e <strcpy>
	itoa((int)(*moteID),buff,10);
     48c:	80 91 e3 50 	lds	r24, 0x50E3
     490:	90 91 e4 50 	lds	r25, 0x50E4
     494:	fc 01       	movw	r30, r24
     496:	80 81       	ld	r24, Z
     498:	91 81       	ldd	r25, Z+1	; 0x01
     49a:	2b ed       	ldi	r18, 0xDB	; 219
     49c:	30 e5       	ldi	r19, 0x50	; 80
     49e:	b9 01       	movw	r22, r18
     4a0:	4a e0       	ldi	r20, 0x0A	; 10
     4a2:	50 e0       	ldi	r21, 0x00	; 0
     4a4:	0e 94 4c 5f 	call	0xbe98	; 0xbe98 <itoa>
	strcat(message,buff);
     4a8:	8b 81       	ldd	r24, Y+3	; 0x03
     4aa:	9c 81       	ldd	r25, Y+4	; 0x04
     4ac:	2b ed       	ldi	r18, 0xDB	; 219
     4ae:	30 e5       	ldi	r19, 0x50	; 80
     4b0:	b9 01       	movw	r22, r18
     4b2:	0e 94 2c 5f 	call	0xbe58	; 0xbe58 <strcat>
	//insert code here to send and wait for synch message
	//perhaps just disable ADC or ADC interrupts while waiting for reply instead of having the whole mote hang
	RadioMonitorMode = TIME_SYNCH;
     4b6:	82 e0       	ldi	r24, 0x02	; 2
     4b8:	80 93 53 40 	sts	0x4053, r24
	ADC_Pause_Sampling();	//pause the ADC while synching
     4bc:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     4c0:	6b 81       	ldd	r22, Y+3	; 0x03
     4c2:	7c 81       	ldd	r23, Y+4	; 0x04
     4c4:	8b 81       	ldd	r24, Y+3	; 0x03
     4c6:	9c 81       	ldd	r25, Y+4	; 0x04
     4c8:	9c 01       	movw	r18, r24
     4ca:	f9 01       	movw	r30, r18
     4cc:	01 90       	ld	r0, Z+
     4ce:	00 20       	and	r0, r0
     4d0:	e9 f7       	brne	.-6      	; 0x4cc <__vector_83+0xf8>
     4d2:	cf 01       	movw	r24, r30
     4d4:	01 97       	sbiw	r24, 0x01	; 1
     4d6:	82 1b       	sub	r24, r18
     4d8:	93 0b       	sbc	r25, r19
     4da:	9c 01       	movw	r18, r24
     4dc:	40 e0       	ldi	r20, 0x00	; 0
     4de:	50 e0       	ldi	r21, 0x00	; 0
     4e0:	80 e0       	ldi	r24, 0x00	; 0
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	0e 94 0e 21 	call	0x421c	; 0x421c <chb_write>
     4e8:	ed be       	out	0x3d, r14	; 61
     4ea:	fe be       	out	0x3e, r15	; 62
}	
     4ec:	0d bf       	out	0x3d, r16	; 61
     4ee:	1e bf       	out	0x3e, r17	; 62
     4f0:	24 96       	adiw	r28, 0x04	; 4
     4f2:	cd bf       	out	0x3d, r28	; 61
     4f4:	de bf       	out	0x3e, r29	; 62
     4f6:	df 91       	pop	r29
     4f8:	cf 91       	pop	r28
     4fa:	ff 91       	pop	r31
     4fc:	ef 91       	pop	r30
     4fe:	bf 91       	pop	r27
     500:	af 91       	pop	r26
     502:	9f 91       	pop	r25
     504:	8f 91       	pop	r24
     506:	7f 91       	pop	r23
     508:	6f 91       	pop	r22
     50a:	5f 91       	pop	r21
     50c:	4f 91       	pop	r20
     50e:	3f 91       	pop	r19
     510:	2f 91       	pop	r18
     512:	1f 91       	pop	r17
     514:	0f 91       	pop	r16
     516:	ff 90       	pop	r15
     518:	ef 90       	pop	r14
     51a:	0f 90       	pop	r0
     51c:	00 92 3b 00 	sts	0x003B, r0
     520:	0f 90       	pop	r0
     522:	0f be       	out	0x3f, r0	; 63
     524:	0f 90       	pop	r0
     526:	1f 90       	pop	r1
     528:	18 95       	reti

0000052a <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     52a:	cf 93       	push	r28
     52c:	df 93       	push	r29
     52e:	cd b7       	in	r28, 0x3d	; 61
     530:	de b7       	in	r29, 0x3e	; 62
     532:	6b 97       	sbiw	r28, 0x1b	; 27
     534:	cd bf       	out	0x3d, r28	; 61
     536:	de bf       	out	0x3e, r29	; 62
     538:	8e 8b       	std	Y+22, r24	; 0x16
     53a:	9f 8b       	std	Y+23, r25	; 0x17
     53c:	68 8f       	std	Y+24, r22	; 0x18
     53e:	79 8f       	std	Y+25, r23	; 0x19
     540:	4a 8f       	std	Y+26, r20	; 0x1a
     542:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     544:	19 82       	std	Y+1, r1	; 0x01
     546:	1a 82       	std	Y+2, r1	; 0x02
     548:	1b 82       	std	Y+3, r1	; 0x03
     54a:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	90 e1       	ldi	r25, 0x10	; 16
     550:	a0 e0       	ldi	r26, 0x00	; 0
     552:	b0 e0       	ldi	r27, 0x00	; 0
     554:	8d 83       	std	Y+5, r24	; 0x05
     556:	9e 83       	std	Y+6, r25	; 0x06
     558:	af 83       	std	Y+7, r26	; 0x07
     55a:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     55c:	19 86       	std	Y+9, r1	; 0x09
     55e:	1a 86       	std	Y+10, r1	; 0x0a
     560:	1b 86       	std	Y+11, r1	; 0x0b
     562:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	92 e0       	ldi	r25, 0x02	; 2
     56e:	0e 94 a4 1c 	call	0x3948	; 0x3948 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     572:	80 e0       	ldi	r24, 0x00	; 0
     574:	92 e0       	ldi	r25, 0x02	; 2
     576:	20 e0       	ldi	r18, 0x00	; 0
     578:	32 e0       	ldi	r19, 0x02	; 2
     57a:	f9 01       	movw	r30, r18
     57c:	21 81       	ldd	r18, Z+1	; 0x01
     57e:	29 7e       	andi	r18, 0xE9	; 233
     580:	fc 01       	movw	r30, r24
     582:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	92 e0       	ldi	r25, 0x02	; 2
     588:	20 e0       	ldi	r18, 0x00	; 0
     58a:	32 e0       	ldi	r19, 0x02	; 2
     58c:	f9 01       	movw	r30, r18
     58e:	24 81       	ldd	r18, Z+4	; 0x04
     590:	28 7f       	andi	r18, 0xF8	; 248
     592:	23 60       	ori	r18, 0x03	; 3
     594:	fc 01       	movw	r30, r24
     596:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     598:	80 e0       	ldi	r24, 0x00	; 0
     59a:	92 e0       	ldi	r25, 0x02	; 2
     59c:	20 e0       	ldi	r18, 0x00	; 0
     59e:	32 e0       	ldi	r19, 0x02	; 2
     5a0:	f9 01       	movw	r30, r18
     5a2:	22 81       	ldd	r18, Z+2	; 0x02
     5a4:	2f 7c       	andi	r18, 0xCF	; 207
     5a6:	fc 01       	movw	r30, r24
     5a8:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     5aa:	80 e2       	ldi	r24, 0x20	; 32
     5ac:	92 e0       	ldi	r25, 0x02	; 2
     5ae:	20 e2       	ldi	r18, 0x20	; 32
     5b0:	32 e0       	ldi	r19, 0x02	; 2
     5b2:	f9 01       	movw	r30, r18
     5b4:	20 81       	ld	r18, Z
     5b6:	20 7e       	andi	r18, 0xE0	; 224
     5b8:	21 60       	ori	r18, 0x01	; 1
     5ba:	fc 01       	movw	r30, r24
     5bc:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     5be:	80 e2       	ldi	r24, 0x20	; 32
     5c0:	92 e0       	ldi	r25, 0x02	; 2
     5c2:	29 e0       	ldi	r18, 0x09	; 9
     5c4:	fc 01       	movw	r30, r24
     5c6:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	92 e0       	ldi	r25, 0x02	; 2
     5cc:	20 e0       	ldi	r18, 0x00	; 0
     5ce:	32 e0       	ldi	r19, 0x02	; 2
     5d0:	f9 01       	movw	r30, r18
     5d2:	20 81       	ld	r18, Z
     5d4:	21 60       	ori	r18, 0x01	; 1
     5d6:	fc 01       	movw	r30, r24
     5d8:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     5da:	80 e0       	ldi	r24, 0x00	; 0
     5dc:	92 e0       	ldi	r25, 0x02	; 2
     5de:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     5e2:	80 e0       	ldi	r24, 0x00	; 0
     5e4:	92 e0       	ldi	r25, 0x02	; 2
     5e6:	60 e2       	ldi	r22, 0x20	; 32
     5e8:	72 e0       	ldi	r23, 0x02	; 2
     5ea:	40 e0       	ldi	r20, 0x00	; 0
     5ec:	0e 94 53 1f 	call	0x3ea6	; 0x3ea6 <ADC_Offset_Get_Unsigned>
     5f0:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     5f2:	80 e0       	ldi	r24, 0x00	; 0
     5f4:	92 e0       	ldi	r25, 0x02	; 2
     5f6:	20 e0       	ldi	r18, 0x00	; 0
     5f8:	32 e0       	ldi	r19, 0x02	; 2
     5fa:	f9 01       	movw	r30, r18
     5fc:	20 81       	ld	r18, Z
     5fe:	2e 7f       	andi	r18, 0xFE	; 254
     600:	fc 01       	movw	r30, r24
     602:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     604:	80 e2       	ldi	r24, 0x20	; 32
     606:	92 e0       	ldi	r25, 0x02	; 2
     608:	fc 01       	movw	r30, r24
     60a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     60c:	80 e0       	ldi	r24, 0x00	; 0
     60e:	92 e0       	ldi	r25, 0x02	; 2
     610:	20 e0       	ldi	r18, 0x00	; 0
     612:	32 e0       	ldi	r19, 0x02	; 2
     614:	f9 01       	movw	r30, r18
     616:	23 81       	ldd	r18, Z+3	; 0x03
     618:	2f 73       	andi	r18, 0x3F	; 63
     61a:	fc 01       	movw	r30, r24
     61c:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     61e:	80 e0       	ldi	r24, 0x00	; 0
     620:	92 e0       	ldi	r25, 0x02	; 2
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	32 e0       	ldi	r19, 0x02	; 2
     626:	f9 01       	movw	r30, r18
     628:	20 81       	ld	r18, Z
     62a:	21 60       	ori	r18, 0x01	; 1
     62c:	fc 01       	movw	r30, r24
     62e:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     630:	80 e0       	ldi	r24, 0x00	; 0
     632:	92 e0       	ldi	r25, 0x02	; 2
     634:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     638:	80 e0       	ldi	r24, 0x00	; 0
     63a:	92 e0       	ldi	r25, 0x02	; 2
     63c:	20 e0       	ldi	r18, 0x00	; 0
     63e:	32 e0       	ldi	r19, 0x02	; 2
     640:	f9 01       	movw	r30, r18
     642:	21 81       	ldd	r18, Z+1	; 0x01
     644:	28 60       	ori	r18, 0x08	; 8
     646:	fc 01       	movw	r30, r24
     648:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     64a:	1d 86       	std	Y+13, r1	; 0x0d
     64c:	1e 86       	std	Y+14, r1	; 0x0e
     64e:	56 c0       	rjmp	.+172    	; 0x6fc <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     650:	80 e2       	ldi	r24, 0x20	; 32
     652:	92 e0       	ldi	r25, 0x02	; 2
     654:	fc 01       	movw	r30, r24
     656:	83 81       	ldd	r24, Z+3	; 0x03
     658:	88 2f       	mov	r24, r24
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	81 70       	andi	r24, 0x01	; 1
     65e:	90 70       	andi	r25, 0x00	; 0
     660:	00 97       	sbiw	r24, 0x00	; 0
     662:	b1 f3       	breq	.-20     	; 0x650 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     664:	2d 89       	ldd	r18, Y+21	; 0x15
     666:	80 e2       	ldi	r24, 0x20	; 32
     668:	92 e0       	ldi	r25, 0x02	; 2
     66a:	62 2f       	mov	r22, r18
     66c:	0e 94 fd 1c 	call	0x39fa	; 0x39fa <ADC_ResultCh_GetWord_Signed>
     670:	8f 87       	std	Y+15, r24	; 0x0f
     672:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     674:	8f 85       	ldd	r24, Y+15	; 0x0f
     676:	98 89       	ldd	r25, Y+16	; 0x10
     678:	cc 01       	movw	r24, r24
     67a:	a0 e0       	ldi	r26, 0x00	; 0
     67c:	b0 e0       	ldi	r27, 0x00	; 0
     67e:	29 81       	ldd	r18, Y+1	; 0x01
     680:	3a 81       	ldd	r19, Y+2	; 0x02
     682:	4b 81       	ldd	r20, Y+3	; 0x03
     684:	5c 81       	ldd	r21, Y+4	; 0x04
     686:	82 0f       	add	r24, r18
     688:	93 1f       	adc	r25, r19
     68a:	a4 1f       	adc	r26, r20
     68c:	b5 1f       	adc	r27, r21
     68e:	89 83       	std	Y+1, r24	; 0x01
     690:	9a 83       	std	Y+2, r25	; 0x02
     692:	ab 83       	std	Y+3, r26	; 0x03
     694:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     696:	8f 85       	ldd	r24, Y+15	; 0x0f
     698:	98 89       	ldd	r25, Y+16	; 0x10
     69a:	9c 01       	movw	r18, r24
     69c:	40 e0       	ldi	r20, 0x00	; 0
     69e:	50 e0       	ldi	r21, 0x00	; 0
     6a0:	89 85       	ldd	r24, Y+9	; 0x09
     6a2:	9a 85       	ldd	r25, Y+10	; 0x0a
     6a4:	ab 85       	ldd	r26, Y+11	; 0x0b
     6a6:	bc 85       	ldd	r27, Y+12	; 0x0c
     6a8:	82 17       	cp	r24, r18
     6aa:	93 07       	cpc	r25, r19
     6ac:	a4 07       	cpc	r26, r20
     6ae:	b5 07       	cpc	r27, r21
     6b0:	48 f4       	brcc	.+18     	; 0x6c4 <CO_collectTemp+0x19a>
     6b2:	8f 85       	ldd	r24, Y+15	; 0x0f
     6b4:	98 89       	ldd	r25, Y+16	; 0x10
     6b6:	cc 01       	movw	r24, r24
     6b8:	a0 e0       	ldi	r26, 0x00	; 0
     6ba:	b0 e0       	ldi	r27, 0x00	; 0
     6bc:	89 87       	std	Y+9, r24	; 0x09
     6be:	9a 87       	std	Y+10, r25	; 0x0a
     6c0:	ab 87       	std	Y+11, r26	; 0x0b
     6c2:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     6c4:	8f 85       	ldd	r24, Y+15	; 0x0f
     6c6:	98 89       	ldd	r25, Y+16	; 0x10
     6c8:	9c 01       	movw	r18, r24
     6ca:	40 e0       	ldi	r20, 0x00	; 0
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	8d 81       	ldd	r24, Y+5	; 0x05
     6d0:	9e 81       	ldd	r25, Y+6	; 0x06
     6d2:	af 81       	ldd	r26, Y+7	; 0x07
     6d4:	b8 85       	ldd	r27, Y+8	; 0x08
     6d6:	28 17       	cp	r18, r24
     6d8:	39 07       	cpc	r19, r25
     6da:	4a 07       	cpc	r20, r26
     6dc:	5b 07       	cpc	r21, r27
     6de:	48 f4       	brcc	.+18     	; 0x6f2 <CO_collectTemp+0x1c8>
     6e0:	8f 85       	ldd	r24, Y+15	; 0x0f
     6e2:	98 89       	ldd	r25, Y+16	; 0x10
     6e4:	cc 01       	movw	r24, r24
     6e6:	a0 e0       	ldi	r26, 0x00	; 0
     6e8:	b0 e0       	ldi	r27, 0x00	; 0
     6ea:	8d 83       	std	Y+5, r24	; 0x05
     6ec:	9e 83       	std	Y+6, r25	; 0x06
     6ee:	af 83       	std	Y+7, r26	; 0x07
     6f0:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     6f2:	8d 85       	ldd	r24, Y+13	; 0x0d
     6f4:	9e 85       	ldd	r25, Y+14	; 0x0e
     6f6:	01 96       	adiw	r24, 0x01	; 1
     6f8:	8d 87       	std	Y+13, r24	; 0x0d
     6fa:	9e 87       	std	Y+14, r25	; 0x0e
     6fc:	8d 85       	ldd	r24, Y+13	; 0x0d
     6fe:	9e 85       	ldd	r25, Y+14	; 0x0e
     700:	f4 e0       	ldi	r31, 0x04	; 4
     702:	80 30       	cpi	r24, 0x00	; 0
     704:	9f 07       	cpc	r25, r31
     706:	08 f4       	brcc	.+2      	; 0x70a <CO_collectTemp+0x1e0>
     708:	a3 cf       	rjmp	.-186    	; 0x650 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     70a:	80 e0       	ldi	r24, 0x00	; 0
     70c:	92 e0       	ldi	r25, 0x02	; 2
     70e:	20 e0       	ldi	r18, 0x00	; 0
     710:	32 e0       	ldi	r19, 0x02	; 2
     712:	f9 01       	movw	r30, r18
     714:	21 81       	ldd	r18, Z+1	; 0x01
     716:	27 7f       	andi	r18, 0xF7	; 247
     718:	fc 01       	movw	r30, r24
     71a:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     71c:	80 e0       	ldi	r24, 0x00	; 0
     71e:	92 e0       	ldi	r25, 0x02	; 2
     720:	20 e0       	ldi	r18, 0x00	; 0
     722:	32 e0       	ldi	r19, 0x02	; 2
     724:	f9 01       	movw	r30, r18
     726:	20 81       	ld	r18, Z
     728:	22 60       	ori	r18, 0x02	; 2
     72a:	fc 01       	movw	r30, r24
     72c:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	92 e0       	ldi	r25, 0x02	; 2
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	32 e0       	ldi	r19, 0x02	; 2
     736:	f9 01       	movw	r30, r18
     738:	20 81       	ld	r18, Z
     73a:	2e 7f       	andi	r18, 0xFE	; 254
     73c:	fc 01       	movw	r30, r24
     73e:	20 83       	st	Z, r18

	ADCPower(FALSE);
     740:	80 e0       	ldi	r24, 0x00	; 0
     742:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>

	average = sum / NUM_SAMPLES;
     746:	89 81       	ldd	r24, Y+1	; 0x01
     748:	9a 81       	ldd	r25, Y+2	; 0x02
     74a:	ab 81       	ldd	r26, Y+3	; 0x03
     74c:	bc 81       	ldd	r27, Y+4	; 0x04
     74e:	07 2e       	mov	r0, r23
     750:	7a e0       	ldi	r23, 0x0A	; 10
     752:	b6 95       	lsr	r27
     754:	a7 95       	ror	r26
     756:	97 95       	ror	r25
     758:	87 95       	ror	r24
     75a:	7a 95       	dec	r23
     75c:	d1 f7       	brne	.-12     	; 0x752 <CO_collectTemp+0x228>
     75e:	70 2d       	mov	r23, r0
     760:	89 8b       	std	Y+17, r24	; 0x11
     762:	9a 8b       	std	Y+18, r25	; 0x12
     764:	ab 8b       	std	Y+19, r26	; 0x13
     766:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     768:	89 89       	ldd	r24, Y+17	; 0x11
     76a:	9a 89       	ldd	r25, Y+18	; 0x12
     76c:	ab 89       	ldd	r26, Y+19	; 0x13
     76e:	bc 89       	ldd	r27, Y+20	; 0x14
     770:	28 ee       	ldi	r18, 0xE8	; 232
     772:	33 e0       	ldi	r19, 0x03	; 3
     774:	40 e0       	ldi	r20, 0x00	; 0
     776:	50 e0       	ldi	r21, 0x00	; 0
     778:	bc 01       	movw	r22, r24
     77a:	cd 01       	movw	r24, r26
     77c:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
     780:	dc 01       	movw	r26, r24
     782:	cb 01       	movw	r24, r22
     784:	2f ef       	ldi	r18, 0xFF	; 255
     786:	3f e0       	ldi	r19, 0x0F	; 15
     788:	40 e0       	ldi	r20, 0x00	; 0
     78a:	50 e0       	ldi	r21, 0x00	; 0
     78c:	bc 01       	movw	r22, r24
     78e:	cd 01       	movw	r24, r26
     790:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
     794:	da 01       	movw	r26, r20
     796:	c9 01       	movw	r24, r18
     798:	9c 01       	movw	r18, r24
     79a:	22 53       	subi	r18, 0x32	; 50
     79c:	30 40       	sbci	r19, 0x00	; 0
     79e:	8e 89       	ldd	r24, Y+22	; 0x16
     7a0:	9f 89       	ldd	r25, Y+23	; 0x17
     7a2:	fc 01       	movw	r30, r24
     7a4:	20 83       	st	Z, r18
     7a6:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     7a8:	89 85       	ldd	r24, Y+9	; 0x09
     7aa:	9a 85       	ldd	r25, Y+10	; 0x0a
     7ac:	ab 85       	ldd	r26, Y+11	; 0x0b
     7ae:	bc 85       	ldd	r27, Y+12	; 0x0c
     7b0:	28 ee       	ldi	r18, 0xE8	; 232
     7b2:	33 e0       	ldi	r19, 0x03	; 3
     7b4:	40 e0       	ldi	r20, 0x00	; 0
     7b6:	50 e0       	ldi	r21, 0x00	; 0
     7b8:	bc 01       	movw	r22, r24
     7ba:	cd 01       	movw	r24, r26
     7bc:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
     7c0:	dc 01       	movw	r26, r24
     7c2:	cb 01       	movw	r24, r22
     7c4:	2f ef       	ldi	r18, 0xFF	; 255
     7c6:	3f e0       	ldi	r19, 0x0F	; 15
     7c8:	40 e0       	ldi	r20, 0x00	; 0
     7ca:	50 e0       	ldi	r21, 0x00	; 0
     7cc:	bc 01       	movw	r22, r24
     7ce:	cd 01       	movw	r24, r26
     7d0:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
     7d4:	da 01       	movw	r26, r20
     7d6:	c9 01       	movw	r24, r18
     7d8:	9c 01       	movw	r18, r24
     7da:	22 53       	subi	r18, 0x32	; 50
     7dc:	30 40       	sbci	r19, 0x00	; 0
     7de:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7e0:	9b 8d       	ldd	r25, Y+27	; 0x1b
     7e2:	fc 01       	movw	r30, r24
     7e4:	20 83       	st	Z, r18
     7e6:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     7e8:	8d 81       	ldd	r24, Y+5	; 0x05
     7ea:	9e 81       	ldd	r25, Y+6	; 0x06
     7ec:	af 81       	ldd	r26, Y+7	; 0x07
     7ee:	b8 85       	ldd	r27, Y+8	; 0x08
     7f0:	28 ee       	ldi	r18, 0xE8	; 232
     7f2:	33 e0       	ldi	r19, 0x03	; 3
     7f4:	40 e0       	ldi	r20, 0x00	; 0
     7f6:	50 e0       	ldi	r21, 0x00	; 0
     7f8:	bc 01       	movw	r22, r24
     7fa:	cd 01       	movw	r24, r26
     7fc:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
     800:	dc 01       	movw	r26, r24
     802:	cb 01       	movw	r24, r22
     804:	2f ef       	ldi	r18, 0xFF	; 255
     806:	3f e0       	ldi	r19, 0x0F	; 15
     808:	40 e0       	ldi	r20, 0x00	; 0
     80a:	50 e0       	ldi	r21, 0x00	; 0
     80c:	bc 01       	movw	r22, r24
     80e:	cd 01       	movw	r24, r26
     810:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
     814:	da 01       	movw	r26, r20
     816:	c9 01       	movw	r24, r18
     818:	9c 01       	movw	r18, r24
     81a:	22 53       	subi	r18, 0x32	; 50
     81c:	30 40       	sbci	r19, 0x00	; 0
     81e:	88 8d       	ldd	r24, Y+24	; 0x18
     820:	99 8d       	ldd	r25, Y+25	; 0x19
     822:	fc 01       	movw	r30, r24
     824:	20 83       	st	Z, r18
     826:	31 83       	std	Z+1, r19	; 0x01
}
     828:	6b 96       	adiw	r28, 0x1b	; 27
     82a:	cd bf       	out	0x3d, r28	; 61
     82c:	de bf       	out	0x3e, r29	; 62
     82e:	df 91       	pop	r29
     830:	cf 91       	pop	r28
     832:	08 95       	ret

00000834 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     834:	0f 93       	push	r16
     836:	1f 93       	push	r17
     838:	cf 93       	push	r28
     83a:	df 93       	push	r29
     83c:	cd b7       	in	r28, 0x3d	; 61
     83e:	de b7       	in	r29, 0x3e	; 62
     840:	a9 97       	sbiw	r28, 0x29	; 41
     842:	cd bf       	out	0x3d, r28	; 61
     844:	de bf       	out	0x3e, r29	; 62
     846:	8c a3       	lds	r24, 0x5c
     848:	9d a3       	lds	r25, 0x5d
     84a:	6e a3       	lds	r22, 0x5e
     84c:	7f a3       	lds	r23, 0x5f
     84e:	48 a7       	lds	r20, 0x78
     850:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     852:	19 82       	std	Y+1, r1	; 0x01
     854:	1a 82       	std	Y+2, r1	; 0x02
     856:	1b 82       	std	Y+3, r1	; 0x03
     858:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	90 e1       	ldi	r25, 0x10	; 16
     85e:	a0 e0       	ldi	r26, 0x00	; 0
     860:	b0 e0       	ldi	r27, 0x00	; 0
     862:	8d 83       	std	Y+5, r24	; 0x05
     864:	9e 83       	std	Y+6, r25	; 0x06
     866:	af 83       	std	Y+7, r26	; 0x07
     868:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     86a:	19 86       	std	Y+9, r1	; 0x09
     86c:	1a 86       	std	Y+10, r1	; 0x0a
     86e:	1b 86       	std	Y+11, r1	; 0x0b
     870:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     872:	81 e0       	ldi	r24, 0x01	; 1
     874:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     878:	84 e0       	ldi	r24, 0x04	; 4
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	0e 94 24 35 	call	0x6a48	; 0x6a48 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     880:	84 e0       	ldi	r24, 0x04	; 4
     882:	60 e0       	ldi	r22, 0x00	; 0
     884:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
     888:	80 e0       	ldi	r24, 0x00	; 0
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	a8 ec       	ldi	r26, 0xC8	; 200
     88e:	b2 e4       	ldi	r27, 0x42	; 66
     890:	8d 8b       	std	Y+21, r24	; 0x15
     892:	9e 8b       	std	Y+22, r25	; 0x16
     894:	af 8b       	std	Y+23, r26	; 0x17
     896:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     898:	6d 89       	ldd	r22, Y+21	; 0x15
     89a:	7e 89       	ldd	r23, Y+22	; 0x16
     89c:	8f 89       	ldd	r24, Y+23	; 0x17
     89e:	98 8d       	ldd	r25, Y+24	; 0x18
     8a0:	20 e0       	ldi	r18, 0x00	; 0
     8a2:	30 e0       	ldi	r19, 0x00	; 0
     8a4:	4a ef       	ldi	r20, 0xFA	; 250
     8a6:	55 e4       	ldi	r21, 0x45	; 69
     8a8:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
     8ac:	dc 01       	movw	r26, r24
     8ae:	cb 01       	movw	r24, r22
     8b0:	89 8f       	std	Y+25, r24	; 0x19
     8b2:	9a 8f       	std	Y+26, r25	; 0x1a
     8b4:	ab 8f       	std	Y+27, r26	; 0x1b
     8b6:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     8b8:	11 e0       	ldi	r17, 0x01	; 1
     8ba:	69 8d       	ldd	r22, Y+25	; 0x19
     8bc:	7a 8d       	ldd	r23, Y+26	; 0x1a
     8be:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8c0:	9c 8d       	ldd	r25, Y+28	; 0x1c
     8c2:	20 e0       	ldi	r18, 0x00	; 0
     8c4:	30 e0       	ldi	r19, 0x00	; 0
     8c6:	40 e8       	ldi	r20, 0x80	; 128
     8c8:	5f e3       	ldi	r21, 0x3F	; 63
     8ca:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
     8ce:	88 23       	and	r24, r24
     8d0:	0c f0       	brlt	.+2      	; 0x8d4 <CO_collectBatt+0xa0>
     8d2:	10 e0       	ldi	r17, 0x00	; 0
     8d4:	11 23       	and	r17, r17
     8d6:	29 f0       	breq	.+10     	; 0x8e2 <CO_collectBatt+0xae>
		__ticks = 1;
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	90 e0       	ldi	r25, 0x00	; 0
     8dc:	8d 8f       	std	Y+29, r24	; 0x1d
     8de:	9e 8f       	std	Y+30, r25	; 0x1e
     8e0:	46 c0       	rjmp	.+140    	; 0x96e <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     8e2:	11 e0       	ldi	r17, 0x01	; 1
     8e4:	69 8d       	ldd	r22, Y+25	; 0x19
     8e6:	7a 8d       	ldd	r23, Y+26	; 0x1a
     8e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
     8ec:	20 e0       	ldi	r18, 0x00	; 0
     8ee:	3f ef       	ldi	r19, 0xFF	; 255
     8f0:	4f e7       	ldi	r20, 0x7F	; 127
     8f2:	57 e4       	ldi	r21, 0x47	; 71
     8f4:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
     8f8:	18 16       	cp	r1, r24
     8fa:	0c f0       	brlt	.+2      	; 0x8fe <CO_collectBatt+0xca>
     8fc:	10 e0       	ldi	r17, 0x00	; 0
     8fe:	11 23       	and	r17, r17
     900:	61 f1       	breq	.+88     	; 0x95a <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     902:	6d 89       	ldd	r22, Y+21	; 0x15
     904:	7e 89       	ldd	r23, Y+22	; 0x16
     906:	8f 89       	ldd	r24, Y+23	; 0x17
     908:	98 8d       	ldd	r25, Y+24	; 0x18
     90a:	20 e0       	ldi	r18, 0x00	; 0
     90c:	30 e0       	ldi	r19, 0x00	; 0
     90e:	40 e2       	ldi	r20, 0x20	; 32
     910:	51 e4       	ldi	r21, 0x41	; 65
     912:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
     916:	dc 01       	movw	r26, r24
     918:	cb 01       	movw	r24, r22
     91a:	bc 01       	movw	r22, r24
     91c:	cd 01       	movw	r24, r26
     91e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
     922:	dc 01       	movw	r26, r24
     924:	cb 01       	movw	r24, r22
     926:	8d 8f       	std	Y+29, r24	; 0x1d
     928:	9e 8f       	std	Y+30, r25	; 0x1e
     92a:	12 c0       	rjmp	.+36     	; 0x950 <CO_collectBatt+0x11c>
     92c:	80 e2       	ldi	r24, 0x20	; 32
     92e:	93 e0       	ldi	r25, 0x03	; 3
     930:	8f 8f       	std	Y+31, r24	; 0x1f
     932:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     934:	8f 8d       	ldd	r24, Y+31	; 0x1f
     936:	98 a1       	lds	r25, 0x48
     938:	8c 01       	movw	r16, r24
     93a:	c8 01       	movw	r24, r16
     93c:	01 97       	sbiw	r24, 0x01	; 1
     93e:	f1 f7       	brne	.-4      	; 0x93c <CO_collectBatt+0x108>
     940:	8c 01       	movw	r16, r24
     942:	0f 8f       	std	Y+31, r16	; 0x1f
     944:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     946:	8d 8d       	ldd	r24, Y+29	; 0x1d
     948:	9e 8d       	ldd	r25, Y+30	; 0x1e
     94a:	01 97       	sbiw	r24, 0x01	; 1
     94c:	8d 8f       	std	Y+29, r24	; 0x1d
     94e:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     950:	8d 8d       	ldd	r24, Y+29	; 0x1d
     952:	9e 8d       	ldd	r25, Y+30	; 0x1e
     954:	00 97       	sbiw	r24, 0x00	; 0
     956:	51 f7       	brne	.-44     	; 0x92c <CO_collectBatt+0xf8>
     958:	17 c0       	rjmp	.+46     	; 0x988 <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     95a:	69 8d       	ldd	r22, Y+25	; 0x19
     95c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     95e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     960:	9c 8d       	ldd	r25, Y+28	; 0x1c
     962:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
     966:	dc 01       	movw	r26, r24
     968:	cb 01       	movw	r24, r22
     96a:	8d 8f       	std	Y+29, r24	; 0x1d
     96c:	9e 8f       	std	Y+30, r25	; 0x1e
     96e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     970:	9e 8d       	ldd	r25, Y+30	; 0x1e
     972:	89 a3       	lds	r24, 0x59
     974:	9a a3       	lds	r25, 0x5a
     976:	89 a1       	lds	r24, 0x49
     978:	9a a1       	lds	r25, 0x4a
     97a:	8c 01       	movw	r16, r24
     97c:	f8 01       	movw	r30, r16
     97e:	31 97       	sbiw	r30, 0x01	; 1
     980:	f1 f7       	brne	.-4      	; 0x97e <CO_collectBatt+0x14a>
     982:	8f 01       	movw	r16, r30
     984:	09 a3       	lds	r16, 0x59
     986:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     988:	80 e4       	ldi	r24, 0x40	; 64
     98a:	92 e0       	ldi	r25, 0x02	; 2
     98c:	0e 94 a4 1c 	call	0x3948	; 0x3948 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     990:	80 e4       	ldi	r24, 0x40	; 64
     992:	92 e0       	ldi	r25, 0x02	; 2
     994:	20 e4       	ldi	r18, 0x40	; 64
     996:	32 e0       	ldi	r19, 0x02	; 2
     998:	f9 01       	movw	r30, r18
     99a:	21 81       	ldd	r18, Z+1	; 0x01
     99c:	29 7e       	andi	r18, 0xE9	; 233
     99e:	fc 01       	movw	r30, r24
     9a0:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     9a2:	80 e4       	ldi	r24, 0x40	; 64
     9a4:	92 e0       	ldi	r25, 0x02	; 2
     9a6:	20 e4       	ldi	r18, 0x40	; 64
     9a8:	32 e0       	ldi	r19, 0x02	; 2
     9aa:	f9 01       	movw	r30, r18
     9ac:	24 81       	ldd	r18, Z+4	; 0x04
     9ae:	28 7f       	andi	r18, 0xF8	; 248
     9b0:	23 60       	ori	r18, 0x03	; 3
     9b2:	fc 01       	movw	r30, r24
     9b4:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     9b6:	80 e4       	ldi	r24, 0x40	; 64
     9b8:	92 e0       	ldi	r25, 0x02	; 2
     9ba:	20 e4       	ldi	r18, 0x40	; 64
     9bc:	32 e0       	ldi	r19, 0x02	; 2
     9be:	f9 01       	movw	r30, r18
     9c0:	22 81       	ldd	r18, Z+2	; 0x02
     9c2:	2f 7c       	andi	r18, 0xCF	; 207
     9c4:	fc 01       	movw	r30, r24
     9c6:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     9c8:	80 e6       	ldi	r24, 0x60	; 96
     9ca:	92 e0       	ldi	r25, 0x02	; 2
     9cc:	20 e6       	ldi	r18, 0x60	; 96
     9ce:	32 e0       	ldi	r19, 0x02	; 2
     9d0:	f9 01       	movw	r30, r18
     9d2:	20 81       	ld	r18, Z
     9d4:	20 7e       	andi	r18, 0xE0	; 224
     9d6:	21 60       	ori	r18, 0x01	; 1
     9d8:	fc 01       	movw	r30, r24
     9da:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     9dc:	80 e6       	ldi	r24, 0x60	; 96
     9de:	92 e0       	ldi	r25, 0x02	; 2
     9e0:	29 e0       	ldi	r18, 0x09	; 9
     9e2:	fc 01       	movw	r30, r24
     9e4:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     9e6:	80 e4       	ldi	r24, 0x40	; 64
     9e8:	92 e0       	ldi	r25, 0x02	; 2
     9ea:	20 e4       	ldi	r18, 0x40	; 64
     9ec:	32 e0       	ldi	r19, 0x02	; 2
     9ee:	f9 01       	movw	r30, r18
     9f0:	20 81       	ld	r18, Z
     9f2:	21 60       	ori	r18, 0x01	; 1
     9f4:	fc 01       	movw	r30, r24
     9f6:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     9f8:	80 e4       	ldi	r24, 0x40	; 64
     9fa:	92 e0       	ldi	r25, 0x02	; 2
     9fc:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     a00:	80 e4       	ldi	r24, 0x40	; 64
     a02:	92 e0       	ldi	r25, 0x02	; 2
     a04:	60 e6       	ldi	r22, 0x60	; 96
     a06:	72 e0       	ldi	r23, 0x02	; 2
     a08:	40 e0       	ldi	r20, 0x00	; 0
     a0a:	0e 94 53 1f 	call	0x3ea6	; 0x3ea6 <ADC_Offset_Get_Unsigned>
     a0e:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     a10:	80 e4       	ldi	r24, 0x40	; 64
     a12:	92 e0       	ldi	r25, 0x02	; 2
     a14:	20 e4       	ldi	r18, 0x40	; 64
     a16:	32 e0       	ldi	r19, 0x02	; 2
     a18:	f9 01       	movw	r30, r18
     a1a:	20 81       	ld	r18, Z
     a1c:	2e 7f       	andi	r18, 0xFE	; 254
     a1e:	fc 01       	movw	r30, r24
     a20:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     a22:	80 e6       	ldi	r24, 0x60	; 96
     a24:	92 e0       	ldi	r25, 0x02	; 2
     a26:	fc 01       	movw	r30, r24
     a28:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     a2a:	80 e4       	ldi	r24, 0x40	; 64
     a2c:	92 e0       	ldi	r25, 0x02	; 2
     a2e:	20 e4       	ldi	r18, 0x40	; 64
     a30:	32 e0       	ldi	r19, 0x02	; 2
     a32:	f9 01       	movw	r30, r18
     a34:	23 81       	ldd	r18, Z+3	; 0x03
     a36:	2f 73       	andi	r18, 0x3F	; 63
     a38:	fc 01       	movw	r30, r24
     a3a:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     a3c:	80 e4       	ldi	r24, 0x40	; 64
     a3e:	92 e0       	ldi	r25, 0x02	; 2
     a40:	20 e4       	ldi	r18, 0x40	; 64
     a42:	32 e0       	ldi	r19, 0x02	; 2
     a44:	f9 01       	movw	r30, r18
     a46:	20 81       	ld	r18, Z
     a48:	21 60       	ori	r18, 0x01	; 1
     a4a:	fc 01       	movw	r30, r24
     a4c:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     a4e:	80 e4       	ldi	r24, 0x40	; 64
     a50:	92 e0       	ldi	r25, 0x02	; 2
     a52:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     a56:	80 e4       	ldi	r24, 0x40	; 64
     a58:	92 e0       	ldi	r25, 0x02	; 2
     a5a:	20 e4       	ldi	r18, 0x40	; 64
     a5c:	32 e0       	ldi	r19, 0x02	; 2
     a5e:	f9 01       	movw	r30, r18
     a60:	21 81       	ldd	r18, Z+1	; 0x01
     a62:	28 60       	ori	r18, 0x08	; 8
     a64:	fc 01       	movw	r30, r24
     a66:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a68:	1d 86       	std	Y+13, r1	; 0x0d
     a6a:	1e 86       	std	Y+14, r1	; 0x0e
     a6c:	56 c0       	rjmp	.+172    	; 0xb1a <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     a6e:	80 e6       	ldi	r24, 0x60	; 96
     a70:	92 e0       	ldi	r25, 0x02	; 2
     a72:	fc 01       	movw	r30, r24
     a74:	83 81       	ldd	r24, Z+3	; 0x03
     a76:	88 2f       	mov	r24, r24
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	81 70       	andi	r24, 0x01	; 1
     a7c:	90 70       	andi	r25, 0x00	; 0
     a7e:	00 97       	sbiw	r24, 0x00	; 0
     a80:	b1 f3       	breq	.-20     	; 0xa6e <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a82:	2b a1       	lds	r18, 0x4b
     a84:	80 e6       	ldi	r24, 0x60	; 96
     a86:	92 e0       	ldi	r25, 0x02	; 2
     a88:	62 2f       	mov	r22, r18
     a8a:	0e 94 fd 1c 	call	0x39fa	; 0x39fa <ADC_ResultCh_GetWord_Signed>
     a8e:	8f 87       	std	Y+15, r24	; 0x0f
     a90:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     a92:	8f 85       	ldd	r24, Y+15	; 0x0f
     a94:	98 89       	ldd	r25, Y+16	; 0x10
     a96:	cc 01       	movw	r24, r24
     a98:	a0 e0       	ldi	r26, 0x00	; 0
     a9a:	b0 e0       	ldi	r27, 0x00	; 0
     a9c:	29 81       	ldd	r18, Y+1	; 0x01
     a9e:	3a 81       	ldd	r19, Y+2	; 0x02
     aa0:	4b 81       	ldd	r20, Y+3	; 0x03
     aa2:	5c 81       	ldd	r21, Y+4	; 0x04
     aa4:	82 0f       	add	r24, r18
     aa6:	93 1f       	adc	r25, r19
     aa8:	a4 1f       	adc	r26, r20
     aaa:	b5 1f       	adc	r27, r21
     aac:	89 83       	std	Y+1, r24	; 0x01
     aae:	9a 83       	std	Y+2, r25	; 0x02
     ab0:	ab 83       	std	Y+3, r26	; 0x03
     ab2:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     ab4:	8f 85       	ldd	r24, Y+15	; 0x0f
     ab6:	98 89       	ldd	r25, Y+16	; 0x10
     ab8:	9c 01       	movw	r18, r24
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	89 85       	ldd	r24, Y+9	; 0x09
     ac0:	9a 85       	ldd	r25, Y+10	; 0x0a
     ac2:	ab 85       	ldd	r26, Y+11	; 0x0b
     ac4:	bc 85       	ldd	r27, Y+12	; 0x0c
     ac6:	82 17       	cp	r24, r18
     ac8:	93 07       	cpc	r25, r19
     aca:	a4 07       	cpc	r26, r20
     acc:	b5 07       	cpc	r27, r21
     ace:	48 f4       	brcc	.+18     	; 0xae2 <CO_collectBatt+0x2ae>
     ad0:	8f 85       	ldd	r24, Y+15	; 0x0f
     ad2:	98 89       	ldd	r25, Y+16	; 0x10
     ad4:	cc 01       	movw	r24, r24
     ad6:	a0 e0       	ldi	r26, 0x00	; 0
     ad8:	b0 e0       	ldi	r27, 0x00	; 0
     ada:	89 87       	std	Y+9, r24	; 0x09
     adc:	9a 87       	std	Y+10, r25	; 0x0a
     ade:	ab 87       	std	Y+11, r26	; 0x0b
     ae0:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     ae2:	8f 85       	ldd	r24, Y+15	; 0x0f
     ae4:	98 89       	ldd	r25, Y+16	; 0x10
     ae6:	9c 01       	movw	r18, r24
     ae8:	40 e0       	ldi	r20, 0x00	; 0
     aea:	50 e0       	ldi	r21, 0x00	; 0
     aec:	8d 81       	ldd	r24, Y+5	; 0x05
     aee:	9e 81       	ldd	r25, Y+6	; 0x06
     af0:	af 81       	ldd	r26, Y+7	; 0x07
     af2:	b8 85       	ldd	r27, Y+8	; 0x08
     af4:	28 17       	cp	r18, r24
     af6:	39 07       	cpc	r19, r25
     af8:	4a 07       	cpc	r20, r26
     afa:	5b 07       	cpc	r21, r27
     afc:	48 f4       	brcc	.+18     	; 0xb10 <CO_collectBatt+0x2dc>
     afe:	8f 85       	ldd	r24, Y+15	; 0x0f
     b00:	98 89       	ldd	r25, Y+16	; 0x10
     b02:	cc 01       	movw	r24, r24
     b04:	a0 e0       	ldi	r26, 0x00	; 0
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	8d 83       	std	Y+5, r24	; 0x05
     b0a:	9e 83       	std	Y+6, r25	; 0x06
     b0c:	af 83       	std	Y+7, r26	; 0x07
     b0e:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     b10:	8d 85       	ldd	r24, Y+13	; 0x0d
     b12:	9e 85       	ldd	r25, Y+14	; 0x0e
     b14:	01 96       	adiw	r24, 0x01	; 1
     b16:	8d 87       	std	Y+13, r24	; 0x0d
     b18:	9e 87       	std	Y+14, r25	; 0x0e
     b1a:	8d 85       	ldd	r24, Y+13	; 0x0d
     b1c:	9e 85       	ldd	r25, Y+14	; 0x0e
     b1e:	f4 e0       	ldi	r31, 0x04	; 4
     b20:	80 30       	cpi	r24, 0x00	; 0
     b22:	9f 07       	cpc	r25, r31
     b24:	08 f4       	brcc	.+2      	; 0xb28 <CO_collectBatt+0x2f4>
     b26:	a3 cf       	rjmp	.-186    	; 0xa6e <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     b28:	80 e4       	ldi	r24, 0x40	; 64
     b2a:	92 e0       	ldi	r25, 0x02	; 2
     b2c:	20 e4       	ldi	r18, 0x40	; 64
     b2e:	32 e0       	ldi	r19, 0x02	; 2
     b30:	f9 01       	movw	r30, r18
     b32:	21 81       	ldd	r18, Z+1	; 0x01
     b34:	27 7f       	andi	r18, 0xF7	; 247
     b36:	fc 01       	movw	r30, r24
     b38:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     b3a:	80 e4       	ldi	r24, 0x40	; 64
     b3c:	92 e0       	ldi	r25, 0x02	; 2
     b3e:	20 e4       	ldi	r18, 0x40	; 64
     b40:	32 e0       	ldi	r19, 0x02	; 2
     b42:	f9 01       	movw	r30, r18
     b44:	20 81       	ld	r18, Z
     b46:	2e 7f       	andi	r18, 0xFE	; 254
     b48:	fc 01       	movw	r30, r24
     b4a:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     b4c:	89 81       	ldd	r24, Y+1	; 0x01
     b4e:	9a 81       	ldd	r25, Y+2	; 0x02
     b50:	ab 81       	ldd	r26, Y+3	; 0x03
     b52:	bc 81       	ldd	r27, Y+4	; 0x04
     b54:	07 2e       	mov	r0, r23
     b56:	7a e0       	ldi	r23, 0x0A	; 10
     b58:	b6 95       	lsr	r27
     b5a:	a7 95       	ror	r26
     b5c:	97 95       	ror	r25
     b5e:	87 95       	ror	r24
     b60:	7a 95       	dec	r23
     b62:	d1 f7       	brne	.-12     	; 0xb58 <CO_collectBatt+0x324>
     b64:	70 2d       	mov	r23, r0
     b66:	89 8b       	std	Y+17, r24	; 0x11
     b68:	9a 8b       	std	Y+18, r25	; 0x12
     b6a:	ab 8b       	std	Y+19, r26	; 0x13
     b6c:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     b6e:	84 e0       	ldi	r24, 0x04	; 4
     b70:	60 e0       	ldi	r22, 0x00	; 0
     b72:	0e 94 88 35 	call	0x6b10	; 0x6b10 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     b76:	80 e0       	ldi	r24, 0x00	; 0
     b78:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b7c:	89 89       	ldd	r24, Y+17	; 0x11
     b7e:	9a 89       	ldd	r25, Y+18	; 0x12
     b80:	ab 89       	ldd	r26, Y+19	; 0x13
     b82:	bc 89       	ldd	r27, Y+20	; 0x14
     b84:	28 ee       	ldi	r18, 0xE8	; 232
     b86:	33 e0       	ldi	r19, 0x03	; 3
     b88:	40 e0       	ldi	r20, 0x00	; 0
     b8a:	50 e0       	ldi	r21, 0x00	; 0
     b8c:	bc 01       	movw	r22, r24
     b8e:	cd 01       	movw	r24, r26
     b90:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
     b94:	dc 01       	movw	r26, r24
     b96:	cb 01       	movw	r24, r22
     b98:	2f ef       	ldi	r18, 0xFF	; 255
     b9a:	3f e0       	ldi	r19, 0x0F	; 15
     b9c:	40 e0       	ldi	r20, 0x00	; 0
     b9e:	50 e0       	ldi	r21, 0x00	; 0
     ba0:	bc 01       	movw	r22, r24
     ba2:	cd 01       	movw	r24, r26
     ba4:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
     ba8:	da 01       	movw	r26, r20
     baa:	c9 01       	movw	r24, r18
     bac:	9c 01       	movw	r18, r24
     bae:	22 53       	subi	r18, 0x32	; 50
     bb0:	30 40       	sbci	r19, 0x00	; 0
     bb2:	8c a1       	lds	r24, 0x4c
     bb4:	9d a1       	lds	r25, 0x4d
     bb6:	fc 01       	movw	r30, r24
     bb8:	20 83       	st	Z, r18
     bba:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     bbc:	89 85       	ldd	r24, Y+9	; 0x09
     bbe:	9a 85       	ldd	r25, Y+10	; 0x0a
     bc0:	ab 85       	ldd	r26, Y+11	; 0x0b
     bc2:	bc 85       	ldd	r27, Y+12	; 0x0c
     bc4:	28 ee       	ldi	r18, 0xE8	; 232
     bc6:	33 e0       	ldi	r19, 0x03	; 3
     bc8:	40 e0       	ldi	r20, 0x00	; 0
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	bc 01       	movw	r22, r24
     bce:	cd 01       	movw	r24, r26
     bd0:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
     bd4:	dc 01       	movw	r26, r24
     bd6:	cb 01       	movw	r24, r22
     bd8:	2f ef       	ldi	r18, 0xFF	; 255
     bda:	3f e0       	ldi	r19, 0x0F	; 15
     bdc:	40 e0       	ldi	r20, 0x00	; 0
     bde:	50 e0       	ldi	r21, 0x00	; 0
     be0:	bc 01       	movw	r22, r24
     be2:	cd 01       	movw	r24, r26
     be4:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
     be8:	da 01       	movw	r26, r20
     bea:	c9 01       	movw	r24, r18
     bec:	9c 01       	movw	r18, r24
     bee:	22 53       	subi	r18, 0x32	; 50
     bf0:	30 40       	sbci	r19, 0x00	; 0
     bf2:	88 a5       	lds	r24, 0x68
     bf4:	99 a5       	lds	r25, 0x69
     bf6:	fc 01       	movw	r30, r24
     bf8:	20 83       	st	Z, r18
     bfa:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     bfc:	8d 81       	ldd	r24, Y+5	; 0x05
     bfe:	9e 81       	ldd	r25, Y+6	; 0x06
     c00:	af 81       	ldd	r26, Y+7	; 0x07
     c02:	b8 85       	ldd	r27, Y+8	; 0x08
     c04:	28 ee       	ldi	r18, 0xE8	; 232
     c06:	33 e0       	ldi	r19, 0x03	; 3
     c08:	40 e0       	ldi	r20, 0x00	; 0
     c0a:	50 e0       	ldi	r21, 0x00	; 0
     c0c:	bc 01       	movw	r22, r24
     c0e:	cd 01       	movw	r24, r26
     c10:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
     c14:	dc 01       	movw	r26, r24
     c16:	cb 01       	movw	r24, r22
     c18:	2f ef       	ldi	r18, 0xFF	; 255
     c1a:	3f e0       	ldi	r19, 0x0F	; 15
     c1c:	40 e0       	ldi	r20, 0x00	; 0
     c1e:	50 e0       	ldi	r21, 0x00	; 0
     c20:	bc 01       	movw	r22, r24
     c22:	cd 01       	movw	r24, r26
     c24:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
     c28:	da 01       	movw	r26, r20
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 01       	movw	r18, r24
     c2e:	22 53       	subi	r18, 0x32	; 50
     c30:	30 40       	sbci	r19, 0x00	; 0
     c32:	8e a1       	lds	r24, 0x4e
     c34:	9f a1       	lds	r25, 0x4f
     c36:	fc 01       	movw	r30, r24
     c38:	20 83       	st	Z, r18
     c3a:	31 83       	std	Z+1, r19	; 0x01
}
     c3c:	a9 96       	adiw	r28, 0x29	; 41
     c3e:	cd bf       	out	0x3d, r28	; 61
     c40:	de bf       	out	0x3e, r29	; 62
     c42:	df 91       	pop	r29
     c44:	cf 91       	pop	r28
     c46:	1f 91       	pop	r17
     c48:	0f 91       	pop	r16
     c4a:	08 95       	ret

00000c4c <ADCPower>:

void ADCPower(uint8_t on) {
     c4c:	0f 93       	push	r16
     c4e:	1f 93       	push	r17
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	2f 97       	sbiw	r28, 0x0f	; 15
     c5a:	cd bf       	out	0x3d, r28	; 61
     c5c:	de bf       	out	0x3e, r29	; 62
     c5e:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     c60:	8f 85       	ldd	r24, Y+15	; 0x0f
     c62:	88 23       	and	r24, r24
     c64:	09 f4       	brne	.+2      	; 0xc68 <ADCPower+0x1c>
     c66:	ce c0       	rjmp	.+412    	; 0xe04 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	96 e0       	ldi	r25, 0x06	; 6
     c6c:	2e ed       	ldi	r18, 0xDE	; 222
     c6e:	fc 01       	movw	r30, r24
     c70:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c72:	80 e2       	ldi	r24, 0x20	; 32
     c74:	96 e0       	ldi	r25, 0x06	; 6
     c76:	2e e0       	ldi	r18, 0x0E	; 14
     c78:	fc 01       	movw	r30, r24
     c7a:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     c7c:	80 e4       	ldi	r24, 0x40	; 64
     c7e:	96 e0       	ldi	r25, 0x06	; 6
     c80:	23 e0       	ldi	r18, 0x03	; 3
     c82:	fc 01       	movw	r30, r24
     c84:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     c86:	80 e8       	ldi	r24, 0x80	; 128
     c88:	96 e0       	ldi	r25, 0x06	; 6
     c8a:	20 e1       	ldi	r18, 0x10	; 16
     c8c:	fc 01       	movw	r30, r24
     c8e:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     c90:	80 ea       	ldi	r24, 0xA0	; 160
     c92:	96 e0       	ldi	r25, 0x06	; 6
     c94:	2e e0       	ldi	r18, 0x0E	; 14
     c96:	fc 01       	movw	r30, r24
     c98:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     c9a:	80 e0       	ldi	r24, 0x00	; 0
     c9c:	96 e0       	ldi	r25, 0x06	; 6
     c9e:	2e e9       	ldi	r18, 0x9E	; 158
     ca0:	fc 01       	movw	r30, r24
     ca2:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     ca4:	80 e2       	ldi	r24, 0x20	; 32
     ca6:	96 e0       	ldi	r25, 0x06	; 6
     ca8:	28 e0       	ldi	r18, 0x08	; 8
     caa:	fc 01       	movw	r30, r24
     cac:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     cae:	80 e4       	ldi	r24, 0x40	; 64
     cb0:	96 e0       	ldi	r25, 0x06	; 6
     cb2:	23 e0       	ldi	r18, 0x03	; 3
     cb4:	fc 01       	movw	r30, r24
     cb6:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     cb8:	80 e8       	ldi	r24, 0x80	; 128
     cba:	96 e0       	ldi	r25, 0x06	; 6
     cbc:	20 e1       	ldi	r18, 0x10	; 16
     cbe:	fc 01       	movw	r30, r24
     cc0:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     cc2:	80 ea       	ldi	r24, 0xA0	; 160
     cc4:	96 e0       	ldi	r25, 0x06	; 6
     cc6:	2e e0       	ldi	r18, 0x0E	; 14
     cc8:	fc 01       	movw	r30, r24
     cca:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     ccc:	10 92 72 50 	sts	0x5072, r1
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	90 e0       	ldi	r25, 0x00	; 0
     cd4:	a8 ec       	ldi	r26, 0xC8	; 200
     cd6:	b2 e4       	ldi	r27, 0x42	; 66
     cd8:	89 83       	std	Y+1, r24	; 0x01
     cda:	9a 83       	std	Y+2, r25	; 0x02
     cdc:	ab 83       	std	Y+3, r26	; 0x03
     cde:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     ce0:	69 81       	ldd	r22, Y+1	; 0x01
     ce2:	7a 81       	ldd	r23, Y+2	; 0x02
     ce4:	8b 81       	ldd	r24, Y+3	; 0x03
     ce6:	9c 81       	ldd	r25, Y+4	; 0x04
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	4a ef       	ldi	r20, 0xFA	; 250
     cee:	55 e4       	ldi	r21, 0x45	; 69
     cf0:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
     cf4:	dc 01       	movw	r26, r24
     cf6:	cb 01       	movw	r24, r22
     cf8:	8d 83       	std	Y+5, r24	; 0x05
     cfa:	9e 83       	std	Y+6, r25	; 0x06
     cfc:	af 83       	std	Y+7, r26	; 0x07
     cfe:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     d00:	11 e0       	ldi	r17, 0x01	; 1
     d02:	6d 81       	ldd	r22, Y+5	; 0x05
     d04:	7e 81       	ldd	r23, Y+6	; 0x06
     d06:	8f 81       	ldd	r24, Y+7	; 0x07
     d08:	98 85       	ldd	r25, Y+8	; 0x08
     d0a:	20 e0       	ldi	r18, 0x00	; 0
     d0c:	30 e0       	ldi	r19, 0x00	; 0
     d0e:	40 e8       	ldi	r20, 0x80	; 128
     d10:	5f e3       	ldi	r21, 0x3F	; 63
     d12:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
     d16:	88 23       	and	r24, r24
     d18:	0c f0       	brlt	.+2      	; 0xd1c <ADCPower+0xd0>
     d1a:	10 e0       	ldi	r17, 0x00	; 0
     d1c:	11 23       	and	r17, r17
     d1e:	29 f0       	breq	.+10     	; 0xd2a <ADCPower+0xde>
		__ticks = 1;
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	89 87       	std	Y+9, r24	; 0x09
     d26:	9a 87       	std	Y+10, r25	; 0x0a
     d28:	46 c0       	rjmp	.+140    	; 0xdb6 <ADCPower+0x16a>
	else if (__tmp > 65535)
     d2a:	11 e0       	ldi	r17, 0x01	; 1
     d2c:	6d 81       	ldd	r22, Y+5	; 0x05
     d2e:	7e 81       	ldd	r23, Y+6	; 0x06
     d30:	8f 81       	ldd	r24, Y+7	; 0x07
     d32:	98 85       	ldd	r25, Y+8	; 0x08
     d34:	20 e0       	ldi	r18, 0x00	; 0
     d36:	3f ef       	ldi	r19, 0xFF	; 255
     d38:	4f e7       	ldi	r20, 0x7F	; 127
     d3a:	57 e4       	ldi	r21, 0x47	; 71
     d3c:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
     d40:	18 16       	cp	r1, r24
     d42:	0c f0       	brlt	.+2      	; 0xd46 <ADCPower+0xfa>
     d44:	10 e0       	ldi	r17, 0x00	; 0
     d46:	11 23       	and	r17, r17
     d48:	61 f1       	breq	.+88     	; 0xda2 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d4a:	69 81       	ldd	r22, Y+1	; 0x01
     d4c:	7a 81       	ldd	r23, Y+2	; 0x02
     d4e:	8b 81       	ldd	r24, Y+3	; 0x03
     d50:	9c 81       	ldd	r25, Y+4	; 0x04
     d52:	20 e0       	ldi	r18, 0x00	; 0
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	40 e2       	ldi	r20, 0x20	; 32
     d58:	51 e4       	ldi	r21, 0x41	; 65
     d5a:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
     d5e:	dc 01       	movw	r26, r24
     d60:	cb 01       	movw	r24, r22
     d62:	bc 01       	movw	r22, r24
     d64:	cd 01       	movw	r24, r26
     d66:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
     d6a:	dc 01       	movw	r26, r24
     d6c:	cb 01       	movw	r24, r22
     d6e:	89 87       	std	Y+9, r24	; 0x09
     d70:	9a 87       	std	Y+10, r25	; 0x0a
     d72:	12 c0       	rjmp	.+36     	; 0xd98 <ADCPower+0x14c>
     d74:	80 e2       	ldi	r24, 0x20	; 32
     d76:	93 e0       	ldi	r25, 0x03	; 3
     d78:	8b 87       	std	Y+11, r24	; 0x0b
     d7a:	9c 87       	std	Y+12, r25	; 0x0c
     d7c:	8b 85       	ldd	r24, Y+11	; 0x0b
     d7e:	9c 85       	ldd	r25, Y+12	; 0x0c
     d80:	8c 01       	movw	r16, r24
     d82:	c8 01       	movw	r24, r16
     d84:	01 97       	sbiw	r24, 0x01	; 1
     d86:	f1 f7       	brne	.-4      	; 0xd84 <ADCPower+0x138>
     d88:	8c 01       	movw	r16, r24
     d8a:	0b 87       	std	Y+11, r16	; 0x0b
     d8c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d8e:	89 85       	ldd	r24, Y+9	; 0x09
     d90:	9a 85       	ldd	r25, Y+10	; 0x0a
     d92:	01 97       	sbiw	r24, 0x01	; 1
     d94:	89 87       	std	Y+9, r24	; 0x09
     d96:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d98:	89 85       	ldd	r24, Y+9	; 0x09
     d9a:	9a 85       	ldd	r25, Y+10	; 0x0a
     d9c:	00 97       	sbiw	r24, 0x00	; 0
     d9e:	51 f7       	brne	.-44     	; 0xd74 <ADCPower+0x128>
     da0:	17 c0       	rjmp	.+46     	; 0xdd0 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     da2:	6d 81       	ldd	r22, Y+5	; 0x05
     da4:	7e 81       	ldd	r23, Y+6	; 0x06
     da6:	8f 81       	ldd	r24, Y+7	; 0x07
     da8:	98 85       	ldd	r25, Y+8	; 0x08
     daa:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
     dae:	dc 01       	movw	r26, r24
     db0:	cb 01       	movw	r24, r22
     db2:	89 87       	std	Y+9, r24	; 0x09
     db4:	9a 87       	std	Y+10, r25	; 0x0a
     db6:	89 85       	ldd	r24, Y+9	; 0x09
     db8:	9a 85       	ldd	r25, Y+10	; 0x0a
     dba:	8d 87       	std	Y+13, r24	; 0x0d
     dbc:	9e 87       	std	Y+14, r25	; 0x0e
     dbe:	8d 85       	ldd	r24, Y+13	; 0x0d
     dc0:	9e 85       	ldd	r25, Y+14	; 0x0e
     dc2:	8c 01       	movw	r16, r24
     dc4:	f8 01       	movw	r30, r16
     dc6:	31 97       	sbiw	r30, 0x01	; 1
     dc8:	f1 f7       	brne	.-4      	; 0xdc6 <ADCPower+0x17a>
     dca:	8f 01       	movw	r16, r30
     dcc:	0d 87       	std	Y+13, r16	; 0x0d
     dce:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     dd0:	80 e4       	ldi	r24, 0x40	; 64
     dd2:	96 e0       	ldi	r25, 0x06	; 6
     dd4:	20 e4       	ldi	r18, 0x40	; 64
     dd6:	fc 01       	movw	r30, r24
     dd8:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	80 93 73 50 	sts	0x5073, r24
     de0:	80 93 da 50 	sts	0x50DA, r24
     de4:	80 93 cb 23 	sts	0x23CB, r24
     de8:	80 93 6b 50 	sts	0x506B, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     dec:	8f ef       	ldi	r24, 0xFF	; 255
     dee:	61 e0       	ldi	r22, 0x01	; 1
     df0:	0e 94 24 35 	call	0x6a48	; 0x6a48 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     df4:	8f ef       	ldi	r24, 0xFF	; 255
     df6:	61 e0       	ldi	r22, 0x01	; 1
     df8:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     dfc:	8f ef       	ldi	r24, 0xFF	; 255
     dfe:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <set_filter>
     e02:	42 c0       	rjmp	.+132    	; 0xe88 <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     e04:	80 e0       	ldi	r24, 0x00	; 0
     e06:	96 e0       	ldi	r25, 0x06	; 6
     e08:	2e ed       	ldi	r18, 0xDE	; 222
     e0a:	fc 01       	movw	r30, r24
     e0c:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     e0e:	80 e2       	ldi	r24, 0x20	; 32
     e10:	96 e0       	ldi	r25, 0x06	; 6
     e12:	2e e0       	ldi	r18, 0x0E	; 14
     e14:	fc 01       	movw	r30, r24
     e16:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     e18:	80 e4       	ldi	r24, 0x40	; 64
     e1a:	96 e0       	ldi	r25, 0x06	; 6
     e1c:	23 e0       	ldi	r18, 0x03	; 3
     e1e:	fc 01       	movw	r30, r24
     e20:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     e22:	80 e8       	ldi	r24, 0x80	; 128
     e24:	96 e0       	ldi	r25, 0x06	; 6
     e26:	20 e1       	ldi	r18, 0x10	; 16
     e28:	fc 01       	movw	r30, r24
     e2a:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     e2c:	80 ea       	ldi	r24, 0xA0	; 160
     e2e:	96 e0       	ldi	r25, 0x06	; 6
     e30:	2e e0       	ldi	r18, 0x0E	; 14
     e32:	fc 01       	movw	r30, r24
     e34:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     e36:	80 e0       	ldi	r24, 0x00	; 0
     e38:	96 e0       	ldi	r25, 0x06	; 6
     e3a:	2e ed       	ldi	r18, 0xDE	; 222
     e3c:	fc 01       	movw	r30, r24
     e3e:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     e40:	80 e2       	ldi	r24, 0x20	; 32
     e42:	96 e0       	ldi	r25, 0x06	; 6
     e44:	2e e0       	ldi	r18, 0x0E	; 14
     e46:	fc 01       	movw	r30, r24
     e48:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     e4a:	80 e4       	ldi	r24, 0x40	; 64
     e4c:	96 e0       	ldi	r25, 0x06	; 6
     e4e:	23 e0       	ldi	r18, 0x03	; 3
     e50:	fc 01       	movw	r30, r24
     e52:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     e54:	80 e8       	ldi	r24, 0x80	; 128
     e56:	96 e0       	ldi	r25, 0x06	; 6
     e58:	20 e1       	ldi	r18, 0x10	; 16
     e5a:	fc 01       	movw	r30, r24
     e5c:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     e5e:	80 ea       	ldi	r24, 0xA0	; 160
     e60:	96 e0       	ldi	r25, 0x06	; 6
     e62:	2e e0       	ldi	r18, 0x0E	; 14
     e64:	fc 01       	movw	r30, r24
     e66:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     e68:	80 e4       	ldi	r24, 0x40	; 64
     e6a:	96 e0       	ldi	r25, 0x06	; 6
     e6c:	20 e4       	ldi	r18, 0x40	; 64
     e6e:	fc 01       	movw	r30, r24
     e70:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     e72:	80 e0       	ldi	r24, 0x00	; 0
     e74:	80 93 73 50 	sts	0x5073, r24
     e78:	80 93 da 50 	sts	0x50DA, r24
     e7c:	80 93 cb 23 	sts	0x23CB, r24
     e80:	80 93 6b 50 	sts	0x506B, r24
		channelStatus = 0x00;
     e84:	10 92 72 50 	sts	0x5072, r1
		
	}
}
     e88:	2f 96       	adiw	r28, 0x0f	; 15
     e8a:	cd bf       	out	0x3d, r28	; 61
     e8c:	de bf       	out	0x3e, r29	; 62
     e8e:	df 91       	pop	r29
     e90:	cf 91       	pop	r28
     e92:	1f 91       	pop	r17
     e94:	0f 91       	pop	r16
     e96:	08 95       	ret

00000e98 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     e98:	0f 93       	push	r16
     e9a:	1f 93       	push	r17
     e9c:	cf 93       	push	r28
     e9e:	df 93       	push	r29
     ea0:	cd b7       	in	r28, 0x3d	; 61
     ea2:	de b7       	in	r29, 0x3e	; 62
     ea4:	6a 97       	sbiw	r28, 0x1a	; 26
     ea6:	cd bf       	out	0x3d, r28	; 61
     ea8:	de bf       	out	0x3e, r29	; 62
     eaa:	89 8f       	std	Y+25, r24	; 0x19
     eac:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     eae:	89 8d       	ldd	r24, Y+25	; 0x19
     eb0:	28 2f       	mov	r18, r24
     eb2:	30 e0       	ldi	r19, 0x00	; 0
     eb4:	81 e0       	ldi	r24, 0x01	; 1
     eb6:	90 e0       	ldi	r25, 0x00	; 0
     eb8:	02 c0       	rjmp	.+4      	; 0xebe <set_ampGain+0x26>
     eba:	88 0f       	add	r24, r24
     ebc:	99 1f       	adc	r25, r25
     ebe:	2a 95       	dec	r18
     ec0:	e2 f7       	brpl	.-8      	; 0xeba <set_ampGain+0x22>
     ec2:	61 e0       	ldi	r22, 0x01	; 1
     ec4:	0e 94 53 36 	call	0x6ca6	; 0x6ca6 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     ec8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     eca:	88 2f       	mov	r24, r24
     ecc:	90 e0       	ldi	r25, 0x00	; 0
     ece:	81 70       	andi	r24, 0x01	; 1
     ed0:	90 70       	andi	r25, 0x00	; 0
     ed2:	88 23       	and	r24, r24
     ed4:	31 f0       	breq	.+12     	; 0xee2 <set_ampGain+0x4a>
     ed6:	80 e0       	ldi	r24, 0x00	; 0
     ed8:	96 e0       	ldi	r25, 0x06	; 6
     eda:	20 e4       	ldi	r18, 0x40	; 64
     edc:	fc 01       	movw	r30, r24
     ede:	25 83       	std	Z+5, r18	; 0x05
     ee0:	05 c0       	rjmp	.+10     	; 0xeec <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     ee2:	80 e0       	ldi	r24, 0x00	; 0
     ee4:	96 e0       	ldi	r25, 0x06	; 6
     ee6:	20 e4       	ldi	r18, 0x40	; 64
     ee8:	fc 01       	movw	r30, r24
     eea:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     eec:	8a 8d       	ldd	r24, Y+26	; 0x1a
     eee:	88 2f       	mov	r24, r24
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	82 70       	andi	r24, 0x02	; 2
     ef4:	90 70       	andi	r25, 0x00	; 0
     ef6:	00 97       	sbiw	r24, 0x00	; 0
     ef8:	31 f0       	breq	.+12     	; 0xf06 <set_ampGain+0x6e>
     efa:	80 e2       	ldi	r24, 0x20	; 32
     efc:	96 e0       	ldi	r25, 0x06	; 6
     efe:	22 e0       	ldi	r18, 0x02	; 2
     f00:	fc 01       	movw	r30, r24
     f02:	25 83       	std	Z+5, r18	; 0x05
     f04:	05 c0       	rjmp	.+10     	; 0xf10 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     f06:	80 e2       	ldi	r24, 0x20	; 32
     f08:	96 e0       	ldi	r25, 0x06	; 6
     f0a:	22 e0       	ldi	r18, 0x02	; 2
     f0c:	fc 01       	movw	r30, r24
     f0e:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     f10:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f12:	88 2f       	mov	r24, r24
     f14:	90 e0       	ldi	r25, 0x00	; 0
     f16:	84 70       	andi	r24, 0x04	; 4
     f18:	90 70       	andi	r25, 0x00	; 0
     f1a:	00 97       	sbiw	r24, 0x00	; 0
     f1c:	31 f0       	breq	.+12     	; 0xf2a <set_ampGain+0x92>
     f1e:	80 e2       	ldi	r24, 0x20	; 32
     f20:	96 e0       	ldi	r25, 0x06	; 6
     f22:	24 e0       	ldi	r18, 0x04	; 4
     f24:	fc 01       	movw	r30, r24
     f26:	25 83       	std	Z+5, r18	; 0x05
     f28:	05 c0       	rjmp	.+10     	; 0xf34 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     f2a:	80 e2       	ldi	r24, 0x20	; 32
     f2c:	96 e0       	ldi	r25, 0x06	; 6
     f2e:	24 e0       	ldi	r18, 0x04	; 4
     f30:	fc 01       	movw	r30, r24
     f32:	26 83       	std	Z+6, r18	; 0x06
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	a0 e8       	ldi	r26, 0x80	; 128
     f3a:	bf e3       	ldi	r27, 0x3F	; 63
     f3c:	89 83       	std	Y+1, r24	; 0x01
     f3e:	9a 83       	std	Y+2, r25	; 0x02
     f40:	ab 83       	std	Y+3, r26	; 0x03
     f42:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     f44:	69 81       	ldd	r22, Y+1	; 0x01
     f46:	7a 81       	ldd	r23, Y+2	; 0x02
     f48:	8b 81       	ldd	r24, Y+3	; 0x03
     f4a:	9c 81       	ldd	r25, Y+4	; 0x04
     f4c:	2b ea       	ldi	r18, 0xAB	; 171
     f4e:	3a ea       	ldi	r19, 0xAA	; 170
     f50:	4a e2       	ldi	r20, 0x2A	; 42
     f52:	51 e4       	ldi	r21, 0x41	; 65
     f54:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
     f58:	dc 01       	movw	r26, r24
     f5a:	cb 01       	movw	r24, r22
     f5c:	8d 83       	std	Y+5, r24	; 0x05
     f5e:	9e 83       	std	Y+6, r25	; 0x06
     f60:	af 83       	std	Y+7, r26	; 0x07
     f62:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     f64:	11 e0       	ldi	r17, 0x01	; 1
     f66:	6d 81       	ldd	r22, Y+5	; 0x05
     f68:	7e 81       	ldd	r23, Y+6	; 0x06
     f6a:	8f 81       	ldd	r24, Y+7	; 0x07
     f6c:	98 85       	ldd	r25, Y+8	; 0x08
     f6e:	20 e0       	ldi	r18, 0x00	; 0
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	40 e8       	ldi	r20, 0x80	; 128
     f74:	5f e3       	ldi	r21, 0x3F	; 63
     f76:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
     f7a:	88 23       	and	r24, r24
     f7c:	0c f0       	brlt	.+2      	; 0xf80 <set_ampGain+0xe8>
     f7e:	10 e0       	ldi	r17, 0x00	; 0
     f80:	11 23       	and	r17, r17
     f82:	19 f0       	breq	.+6      	; 0xf8a <set_ampGain+0xf2>
		__ticks = 1;
     f84:	81 e0       	ldi	r24, 0x01	; 1
     f86:	89 87       	std	Y+9, r24	; 0x09
     f88:	a3 c0       	rjmp	.+326    	; 0x10d0 <set_ampGain+0x238>
	else if (__tmp > 255)
     f8a:	11 e0       	ldi	r17, 0x01	; 1
     f8c:	6d 81       	ldd	r22, Y+5	; 0x05
     f8e:	7e 81       	ldd	r23, Y+6	; 0x06
     f90:	8f 81       	ldd	r24, Y+7	; 0x07
     f92:	98 85       	ldd	r25, Y+8	; 0x08
     f94:	20 e0       	ldi	r18, 0x00	; 0
     f96:	30 e0       	ldi	r19, 0x00	; 0
     f98:	4f e7       	ldi	r20, 0x7F	; 127
     f9a:	53 e4       	ldi	r21, 0x43	; 67
     f9c:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
     fa0:	18 16       	cp	r1, r24
     fa2:	0c f0       	brlt	.+2      	; 0xfa6 <set_ampGain+0x10e>
     fa4:	10 e0       	ldi	r17, 0x00	; 0
     fa6:	11 23       	and	r17, r17
     fa8:	09 f4       	brne	.+2      	; 0xfac <set_ampGain+0x114>
     faa:	89 c0       	rjmp	.+274    	; 0x10be <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     fac:	69 81       	ldd	r22, Y+1	; 0x01
     fae:	7a 81       	ldd	r23, Y+2	; 0x02
     fb0:	8b 81       	ldd	r24, Y+3	; 0x03
     fb2:	9c 81       	ldd	r25, Y+4	; 0x04
     fb4:	20 e0       	ldi	r18, 0x00	; 0
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	4a e7       	ldi	r20, 0x7A	; 122
     fba:	54 e4       	ldi	r21, 0x44	; 68
     fbc:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
     fc0:	dc 01       	movw	r26, r24
     fc2:	cb 01       	movw	r24, r22
     fc4:	8a 87       	std	Y+10, r24	; 0x0a
     fc6:	9b 87       	std	Y+11, r25	; 0x0b
     fc8:	ac 87       	std	Y+12, r26	; 0x0c
     fca:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     fcc:	6a 85       	ldd	r22, Y+10	; 0x0a
     fce:	7b 85       	ldd	r23, Y+11	; 0x0b
     fd0:	8c 85       	ldd	r24, Y+12	; 0x0c
     fd2:	9d 85       	ldd	r25, Y+13	; 0x0d
     fd4:	20 e0       	ldi	r18, 0x00	; 0
     fd6:	30 e0       	ldi	r19, 0x00	; 0
     fd8:	4a ef       	ldi	r20, 0xFA	; 250
     fda:	55 e4       	ldi	r21, 0x45	; 69
     fdc:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
     fe0:	dc 01       	movw	r26, r24
     fe2:	cb 01       	movw	r24, r22
     fe4:	8e 87       	std	Y+14, r24	; 0x0e
     fe6:	9f 87       	std	Y+15, r25	; 0x0f
     fe8:	a8 8b       	std	Y+16, r26	; 0x10
     fea:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     fec:	11 e0       	ldi	r17, 0x01	; 1
     fee:	6e 85       	ldd	r22, Y+14	; 0x0e
     ff0:	7f 85       	ldd	r23, Y+15	; 0x0f
     ff2:	88 89       	ldd	r24, Y+16	; 0x10
     ff4:	99 89       	ldd	r25, Y+17	; 0x11
     ff6:	20 e0       	ldi	r18, 0x00	; 0
     ff8:	30 e0       	ldi	r19, 0x00	; 0
     ffa:	40 e8       	ldi	r20, 0x80	; 128
     ffc:	5f e3       	ldi	r21, 0x3F	; 63
     ffe:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    1002:	88 23       	and	r24, r24
    1004:	0c f0       	brlt	.+2      	; 0x1008 <set_ampGain+0x170>
    1006:	10 e0       	ldi	r17, 0x00	; 0
    1008:	11 23       	and	r17, r17
    100a:	29 f0       	breq	.+10     	; 0x1016 <set_ampGain+0x17e>
		__ticks = 1;
    100c:	81 e0       	ldi	r24, 0x01	; 1
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	8a 8b       	std	Y+18, r24	; 0x12
    1012:	9b 8b       	std	Y+19, r25	; 0x13
    1014:	46 c0       	rjmp	.+140    	; 0x10a2 <set_ampGain+0x20a>
	else if (__tmp > 65535)
    1016:	11 e0       	ldi	r17, 0x01	; 1
    1018:	6e 85       	ldd	r22, Y+14	; 0x0e
    101a:	7f 85       	ldd	r23, Y+15	; 0x0f
    101c:	88 89       	ldd	r24, Y+16	; 0x10
    101e:	99 89       	ldd	r25, Y+17	; 0x11
    1020:	20 e0       	ldi	r18, 0x00	; 0
    1022:	3f ef       	ldi	r19, 0xFF	; 255
    1024:	4f e7       	ldi	r20, 0x7F	; 127
    1026:	57 e4       	ldi	r21, 0x47	; 71
    1028:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    102c:	18 16       	cp	r1, r24
    102e:	0c f0       	brlt	.+2      	; 0x1032 <set_ampGain+0x19a>
    1030:	10 e0       	ldi	r17, 0x00	; 0
    1032:	11 23       	and	r17, r17
    1034:	61 f1       	breq	.+88     	; 0x108e <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1036:	6a 85       	ldd	r22, Y+10	; 0x0a
    1038:	7b 85       	ldd	r23, Y+11	; 0x0b
    103a:	8c 85       	ldd	r24, Y+12	; 0x0c
    103c:	9d 85       	ldd	r25, Y+13	; 0x0d
    103e:	20 e0       	ldi	r18, 0x00	; 0
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	40 e2       	ldi	r20, 0x20	; 32
    1044:	51 e4       	ldi	r21, 0x41	; 65
    1046:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    104a:	dc 01       	movw	r26, r24
    104c:	cb 01       	movw	r24, r22
    104e:	bc 01       	movw	r22, r24
    1050:	cd 01       	movw	r24, r26
    1052:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    1056:	dc 01       	movw	r26, r24
    1058:	cb 01       	movw	r24, r22
    105a:	8a 8b       	std	Y+18, r24	; 0x12
    105c:	9b 8b       	std	Y+19, r25	; 0x13
    105e:	12 c0       	rjmp	.+36     	; 0x1084 <set_ampGain+0x1ec>
    1060:	80 e2       	ldi	r24, 0x20	; 32
    1062:	93 e0       	ldi	r25, 0x03	; 3
    1064:	8c 8b       	std	Y+20, r24	; 0x14
    1066:	9d 8b       	std	Y+21, r25	; 0x15
    1068:	8c 89       	ldd	r24, Y+20	; 0x14
    106a:	9d 89       	ldd	r25, Y+21	; 0x15
    106c:	8c 01       	movw	r16, r24
    106e:	c8 01       	movw	r24, r16
    1070:	01 97       	sbiw	r24, 0x01	; 1
    1072:	f1 f7       	brne	.-4      	; 0x1070 <set_ampGain+0x1d8>
    1074:	8c 01       	movw	r16, r24
    1076:	0c 8b       	std	Y+20, r16	; 0x14
    1078:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    107a:	8a 89       	ldd	r24, Y+18	; 0x12
    107c:	9b 89       	ldd	r25, Y+19	; 0x13
    107e:	01 97       	sbiw	r24, 0x01	; 1
    1080:	8a 8b       	std	Y+18, r24	; 0x12
    1082:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1084:	8a 89       	ldd	r24, Y+18	; 0x12
    1086:	9b 89       	ldd	r25, Y+19	; 0x13
    1088:	00 97       	sbiw	r24, 0x00	; 0
    108a:	51 f7       	brne	.-44     	; 0x1060 <set_ampGain+0x1c8>
    108c:	28 c0       	rjmp	.+80     	; 0x10de <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    108e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1090:	7f 85       	ldd	r23, Y+15	; 0x0f
    1092:	88 89       	ldd	r24, Y+16	; 0x10
    1094:	99 89       	ldd	r25, Y+17	; 0x11
    1096:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    109a:	dc 01       	movw	r26, r24
    109c:	cb 01       	movw	r24, r22
    109e:	8a 8b       	std	Y+18, r24	; 0x12
    10a0:	9b 8b       	std	Y+19, r25	; 0x13
    10a2:	8a 89       	ldd	r24, Y+18	; 0x12
    10a4:	9b 89       	ldd	r25, Y+19	; 0x13
    10a6:	8e 8b       	std	Y+22, r24	; 0x16
    10a8:	9f 8b       	std	Y+23, r25	; 0x17
    10aa:	8e 89       	ldd	r24, Y+22	; 0x16
    10ac:	9f 89       	ldd	r25, Y+23	; 0x17
    10ae:	8c 01       	movw	r16, r24
    10b0:	f8 01       	movw	r30, r16
    10b2:	31 97       	sbiw	r30, 0x01	; 1
    10b4:	f1 f7       	brne	.-4      	; 0x10b2 <set_ampGain+0x21a>
    10b6:	8f 01       	movw	r16, r30
    10b8:	0e 8b       	std	Y+22, r16	; 0x16
    10ba:	1f 8b       	std	Y+23, r17	; 0x17
    10bc:	10 c0       	rjmp	.+32     	; 0x10de <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    10be:	6d 81       	ldd	r22, Y+5	; 0x05
    10c0:	7e 81       	ldd	r23, Y+6	; 0x06
    10c2:	8f 81       	ldd	r24, Y+7	; 0x07
    10c4:	98 85       	ldd	r25, Y+8	; 0x08
    10c6:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    10ca:	dc 01       	movw	r26, r24
    10cc:	cb 01       	movw	r24, r22
    10ce:	89 87       	std	Y+9, r24	; 0x09
    10d0:	89 85       	ldd	r24, Y+9	; 0x09
    10d2:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    10d4:	88 8d       	ldd	r24, Y+24	; 0x18
    10d6:	18 2f       	mov	r17, r24
    10d8:	1a 95       	dec	r17
    10da:	f1 f7       	brne	.-4      	; 0x10d8 <set_ampGain+0x240>
    10dc:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    10de:	8f ef       	ldi	r24, 0xFF	; 255
    10e0:	61 e0       	ldi	r22, 0x01	; 1
    10e2:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    10e6:	6a 96       	adiw	r28, 0x1a	; 26
    10e8:	cd bf       	out	0x3d, r28	; 61
    10ea:	de bf       	out	0x3e, r29	; 62
    10ec:	df 91       	pop	r29
    10ee:	cf 91       	pop	r28
    10f0:	1f 91       	pop	r17
    10f2:	0f 91       	pop	r16
    10f4:	08 95       	ret

000010f6 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <set_filter+0x6>
    10fc:	cd b7       	in	r28, 0x3d	; 61
    10fe:	de b7       	in	r29, 0x3e	; 62
    1100:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    1102:	8b 81       	ldd	r24, Y+3	; 0x03
    1104:	83 70       	andi	r24, 0x03	; 3
    1106:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    1108:	8b 81       	ldd	r24, Y+3	; 0x03
    110a:	8c 70       	andi	r24, 0x0C	; 12
    110c:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    110e:	8b 81       	ldd	r24, Y+3	; 0x03
    1110:	88 2f       	mov	r24, r24
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	85 70       	andi	r24, 0x05	; 5
    1116:	90 70       	andi	r25, 0x00	; 0
    1118:	00 97       	sbiw	r24, 0x00	; 0
    111a:	51 f0       	breq	.+20     	; 0x1130 <set_filter+0x3a>
    111c:	80 91 72 50 	lds	r24, 0x5072
    1120:	98 2f       	mov	r25, r24
    1122:	90 7f       	andi	r25, 0xF0	; 240
    1124:	8b 81       	ldd	r24, Y+3	; 0x03
    1126:	82 95       	swap	r24
    1128:	8f 70       	andi	r24, 0x0F	; 15
    112a:	89 2b       	or	r24, r25
    112c:	80 93 72 50 	sts	0x5072, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    1130:	8b 81       	ldd	r24, Y+3	; 0x03
    1132:	88 2f       	mov	r24, r24
    1134:	90 e0       	ldi	r25, 0x00	; 0
    1136:	8a 70       	andi	r24, 0x0A	; 10
    1138:	90 70       	andi	r25, 0x00	; 0
    113a:	00 97       	sbiw	r24, 0x00	; 0
    113c:	49 f0       	breq	.+18     	; 0x1150 <set_filter+0x5a>
    113e:	8b 81       	ldd	r24, Y+3	; 0x03
    1140:	98 2f       	mov	r25, r24
    1142:	90 7f       	andi	r25, 0xF0	; 240
    1144:	80 91 72 50 	lds	r24, 0x5072
    1148:	8f 70       	andi	r24, 0x0F	; 15
    114a:	89 2b       	or	r24, r25
    114c:	80 93 72 50 	sts	0x5072, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    1150:	84 e0       	ldi	r24, 0x04	; 4
    1152:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    1156:	80 91 72 50 	lds	r24, 0x5072
    115a:	80 93 5a 50 	sts	0x505A, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    115e:	89 81       	ldd	r24, Y+1	; 0x01
    1160:	88 23       	and	r24, r24
    1162:	19 f0       	breq	.+6      	; 0x116a <set_filter+0x74>
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	0e 94 90 39 	call	0x7320	; 0x7320 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    116a:	8a 81       	ldd	r24, Y+2	; 0x02
    116c:	88 23       	and	r24, r24
    116e:	19 f0       	breq	.+6      	; 0x1176 <set_filter+0x80>
    1170:	81 e0       	ldi	r24, 0x01	; 1
    1172:	0e 94 a8 39 	call	0x7350	; 0x7350 <upperMuxCS>

	SPICS(TRUE);
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    117c:	80 ec       	ldi	r24, 0xC0	; 192
    117e:	98 e0       	ldi	r25, 0x08	; 8
    1180:	2f ef       	ldi	r18, 0xFF	; 255
    1182:	fc 01       	movw	r30, r24
    1184:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1186:	00 00       	nop
    1188:	80 ec       	ldi	r24, 0xC0	; 192
    118a:	98 e0       	ldi	r25, 0x08	; 8
    118c:	fc 01       	movw	r30, r24
    118e:	82 81       	ldd	r24, Z+2	; 0x02
    1190:	88 23       	and	r24, r24
    1192:	d4 f7       	brge	.-12     	; 0x1188 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    1194:	80 ec       	ldi	r24, 0xC0	; 192
    1196:	98 e0       	ldi	r25, 0x08	; 8
    1198:	fc 01       	movw	r30, r24
    119a:	83 81       	ldd	r24, Z+3	; 0x03
    119c:	80 93 66 50 	sts	0x5066, r24

	nop();
    11a0:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    11a2:	80 ec       	ldi	r24, 0xC0	; 192
    11a4:	98 e0       	ldi	r25, 0x08	; 8
    11a6:	20 91 5a 50 	lds	r18, 0x505A
    11aa:	fc 01       	movw	r30, r24
    11ac:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    11ae:	00 00       	nop
    11b0:	80 ec       	ldi	r24, 0xC0	; 192
    11b2:	98 e0       	ldi	r25, 0x08	; 8
    11b4:	fc 01       	movw	r30, r24
    11b6:	82 81       	ldd	r24, Z+2	; 0x02
    11b8:	88 23       	and	r24, r24
    11ba:	d4 f7       	brge	.-12     	; 0x11b0 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    11bc:	80 ec       	ldi	r24, 0xC0	; 192
    11be:	98 e0       	ldi	r25, 0x08	; 8
    11c0:	fc 01       	movw	r30, r24
    11c2:	83 81       	ldd	r24, Z+3	; 0x03
    11c4:	80 93 66 50 	sts	0x5066, r24
	SPICS(FALSE);
    11c8:	80 e0       	ldi	r24, 0x00	; 0
    11ca:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    11ce:	89 81       	ldd	r24, Y+1	; 0x01
    11d0:	88 23       	and	r24, r24
    11d2:	19 f0       	breq	.+6      	; 0x11da <set_filter+0xe4>
    11d4:	80 e0       	ldi	r24, 0x00	; 0
    11d6:	0e 94 90 39 	call	0x7320	; 0x7320 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    11da:	8a 81       	ldd	r24, Y+2	; 0x02
    11dc:	88 23       	and	r24, r24
    11de:	19 f0       	breq	.+6      	; 0x11e6 <set_filter+0xf0>
    11e0:	80 e0       	ldi	r24, 0x00	; 0
    11e2:	0e 94 a8 39 	call	0x7350	; 0x7350 <upperMuxCS>
	SPIDisable();
    11e6:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
}
    11ea:	23 96       	adiw	r28, 0x03	; 3
    11ec:	cd bf       	out	0x3d, r28	; 61
    11ee:	de bf       	out	0x3e, r29	; 62
    11f0:	df 91       	pop	r29
    11f2:	cf 91       	pop	r28
    11f4:	08 95       	ret

000011f6 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    11f6:	cf 93       	push	r28
    11f8:	df 93       	push	r29
    11fa:	0f 92       	push	r0
    11fc:	cd b7       	in	r28, 0x3d	; 61
    11fe:	de b7       	in	r29, 0x3e	; 62
    1200:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    1202:	89 81       	ldd	r24, Y+1	; 0x01
    1204:	88 23       	and	r24, r24
    1206:	59 f0       	breq	.+22     	; 0x121e <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    1208:	80 e0       	ldi	r24, 0x00	; 0
    120a:	96 e0       	ldi	r25, 0x06	; 6
    120c:	20 e2       	ldi	r18, 0x20	; 32
    120e:	fc 01       	movw	r30, r24
    1210:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	96 e0       	ldi	r25, 0x06	; 6
    1216:	20 e2       	ldi	r18, 0x20	; 32
    1218:	fc 01       	movw	r30, r24
    121a:	25 83       	std	Z+5, r18	; 0x05
    121c:	0a c0       	rjmp	.+20     	; 0x1232 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    121e:	80 e0       	ldi	r24, 0x00	; 0
    1220:	96 e0       	ldi	r25, 0x06	; 6
    1222:	20 e2       	ldi	r18, 0x20	; 32
    1224:	fc 01       	movw	r30, r24
    1226:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    1228:	80 e0       	ldi	r24, 0x00	; 0
    122a:	96 e0       	ldi	r25, 0x06	; 6
    122c:	20 e2       	ldi	r18, 0x20	; 32
    122e:	fc 01       	movw	r30, r24
    1230:	22 83       	std	Z+2, r18	; 0x02
	}
}
    1232:	0f 90       	pop	r0
    1234:	df 91       	pop	r29
    1236:	cf 91       	pop	r28
    1238:	08 95       	ret

0000123a <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {
    123a:	2f 92       	push	r2
    123c:	3f 92       	push	r3
    123e:	4f 92       	push	r4
    1240:	5f 92       	push	r5
    1242:	6f 92       	push	r6
    1244:	7f 92       	push	r7
    1246:	8f 92       	push	r8
    1248:	9f 92       	push	r9
    124a:	af 92       	push	r10
    124c:	bf 92       	push	r11
    124e:	cf 92       	push	r12
    1250:	df 92       	push	r13
    1252:	ef 92       	push	r14
    1254:	ff 92       	push	r15
    1256:	0f 93       	push	r16
    1258:	1f 93       	push	r17
    125a:	cf 93       	push	r28
    125c:	df 93       	push	r29
    125e:	cd b7       	in	r28, 0x3d	; 61
    1260:	de b7       	in	r29, 0x3e	; 62
    1262:	ec 97       	sbiw	r28, 0x3c	; 60
    1264:	cd bf       	out	0x3d, r28	; 61
    1266:	de bf       	out	0x3e, r29	; 62
    1268:	8b a3       	lds	r24, 0x5b
    126a:	6c a3       	lds	r22, 0x5c
    126c:	4d a3       	lds	r20, 0x5d
    126e:	5e a3       	lds	r21, 0x5e
    1270:	2f a3       	lds	r18, 0x5f
    1272:	38 a7       	lds	r19, 0x78
    1274:	09 a7       	lds	r16, 0x79
    1276:	1a a7       	lds	r17, 0x7a
    1278:	eb a6       	lds	r30, 0xbb
    127a:	cc a6       	lds	r28, 0xbc

	int64_t sum = 0;
    127c:	19 82       	std	Y+1, r1	; 0x01
    127e:	1a 82       	std	Y+2, r1	; 0x02
    1280:	1b 82       	std	Y+3, r1	; 0x03
    1282:	1c 82       	std	Y+4, r1	; 0x04
    1284:	1d 82       	std	Y+5, r1	; 0x05
    1286:	1e 82       	std	Y+6, r1	; 0x06
    1288:	1f 82       	std	Y+7, r1	; 0x07
    128a:	18 86       	std	Y+8, r1	; 0x08
	int64_t average;
	int64_t min = ADC_MAX;
    128c:	8f ef       	ldi	r24, 0xFF	; 255
    128e:	89 87       	std	Y+9, r24	; 0x09
    1290:	8f ef       	ldi	r24, 0xFF	; 255
    1292:	8a 87       	std	Y+10, r24	; 0x0a
    1294:	8f e7       	ldi	r24, 0x7F	; 127
    1296:	8b 87       	std	Y+11, r24	; 0x0b
    1298:	1c 86       	std	Y+12, r1	; 0x0c
    129a:	1d 86       	std	Y+13, r1	; 0x0d
    129c:	1e 86       	std	Y+14, r1	; 0x0e
    129e:	1f 86       	std	Y+15, r1	; 0x0f
    12a0:	18 8a       	std	Y+16, r1	; 0x10
	int64_t max = -ADC_MAX;
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	89 8b       	std	Y+17, r24	; 0x11
    12a6:	1a 8a       	std	Y+18, r1	; 0x12
    12a8:	80 e8       	ldi	r24, 0x80	; 128
    12aa:	8b 8b       	std	Y+19, r24	; 0x13
    12ac:	8f ef       	ldi	r24, 0xFF	; 255
    12ae:	8c 8b       	std	Y+20, r24	; 0x14
    12b0:	8f ef       	ldi	r24, 0xFF	; 255
    12b2:	8d 8b       	std	Y+21, r24	; 0x15
    12b4:	8f ef       	ldi	r24, 0xFF	; 255
    12b6:	8e 8b       	std	Y+22, r24	; 0x16
    12b8:	8f ef       	ldi	r24, 0xFF	; 255
    12ba:	8f 8b       	std	Y+23, r24	; 0x17
    12bc:	8f ef       	ldi	r24, 0xFF	; 255
    12be:	88 8f       	std	Y+24, r24	; 0x18
	uint16_t period;
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    12c0:	81 e0       	ldi	r24, 0x01	; 1
    12c2:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    12c6:	8b a1       	lds	r24, 0x4b
    12c8:	6b a5       	lds	r22, 0x6b
    12ca:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_filter(filterConfig);
    12ce:	8c a1       	lds	r24, 0x4c
    12d0:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    12d4:	8b a1       	lds	r24, 0x4b
    12d6:	85 30       	cpi	r24, 0x05	; 5
    12d8:	31 f0       	breq	.+12     	; 0x12e6 <CO_collectADC+0xac>
    12da:	8b a1       	lds	r24, 0x4b
    12dc:	86 30       	cpi	r24, 0x06	; 6
    12de:	19 f0       	breq	.+6      	; 0x12e6 <CO_collectADC+0xac>
    12e0:	8b a1       	lds	r24, 0x4b
    12e2:	87 30       	cpi	r24, 0x07	; 7
    12e4:	19 f4       	brne	.+6      	; 0x12ec <CO_collectADC+0xb2>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	0e 94 38 11 	call	0x2270	; 0x2270 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
	setADCInput(channel);
    12f2:	8b a1       	lds	r24, 0x4b
    12f4:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    12f8:	84 e0       	ldi	r24, 0x04	; 4
    12fa:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    12fe:	80 ec       	ldi	r24, 0xC0	; 192
    1300:	98 e0       	ldi	r25, 0x08	; 8
    1302:	24 e5       	ldi	r18, 0x54	; 84
    1304:	fc 01       	movw	r30, r24
    1306:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    1308:	80 ea       	ldi	r24, 0xA0	; 160
    130a:	96 e0       	ldi	r25, 0x06	; 6
    130c:	21 e0       	ldi	r18, 0x01	; 1
    130e:	fc 01       	movw	r30, r24
    1310:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1312:	80 ea       	ldi	r24, 0xA0	; 160
    1314:	96 e0       	ldi	r25, 0x06	; 6
    1316:	22 e0       	ldi	r18, 0x02	; 2
    1318:	fc 01       	movw	r30, r24
    131a:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    131c:	80 ea       	ldi	r24, 0xA0	; 160
    131e:	96 e0       	ldi	r25, 0x06	; 6
    1320:	21 e0       	ldi	r18, 0x01	; 1
    1322:	fc 01       	movw	r30, r24
    1324:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    1326:	80 ea       	ldi	r24, 0xA0	; 160
    1328:	96 e0       	ldi	r25, 0x06	; 6
    132a:	21 e0       	ldi	r18, 0x01	; 1
    132c:	fc 01       	movw	r30, r24
    132e:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    1330:	80 e8       	ldi	r24, 0x80	; 128
    1332:	96 e0       	ldi	r25, 0x06	; 6
    1334:	20 e2       	ldi	r18, 0x20	; 32
    1336:	fc 01       	movw	r30, r24
    1338:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    133a:	80 e4       	ldi	r24, 0x40	; 64
    133c:	9a e0       	ldi	r25, 0x0A	; 10
    133e:	23 e2       	ldi	r18, 0x23	; 35
    1340:	fc 01       	movw	r30, r24
    1342:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    1344:	8c a5       	lds	r24, 0x6c
    1346:	88 2f       	mov	r24, r24
    1348:	90 e0       	ldi	r25, 0x00	; 0
    134a:	25 e1       	ldi	r18, 0x15	; 21
    134c:	30 e0       	ldi	r19, 0x00	; 0
    134e:	28 1b       	sub	r18, r24
    1350:	39 0b       	sbc	r19, r25
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	02 c0       	rjmp	.+4      	; 0x135c <CO_collectADC+0x122>
    1358:	88 0f       	add	r24, r24
    135a:	99 1f       	adc	r25, r25
    135c:	2a 95       	dec	r18
    135e:	e2 f7       	brpl	.-8      	; 0x1358 <CO_collectADC+0x11e>
    1360:	01 97       	sbiw	r24, 0x01	; 1
    1362:	89 8f       	std	Y+25, r24	; 0x19
    1364:	9a 8f       	std	Y+26, r25	; 0x1a
	TCE1.PER = period;
    1366:	80 e4       	ldi	r24, 0x40	; 64
    1368:	9a e0       	ldi	r25, 0x0A	; 10
    136a:	29 8d       	ldd	r18, Y+25	; 0x19
    136c:	3a 8d       	ldd	r19, Y+26	; 0x1a
    136e:	fc 01       	movw	r30, r24
    1370:	26 a3       	lds	r18, 0x56
    1372:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    1374:	80 e4       	ldi	r24, 0x40	; 64
    1376:	9a e0       	ldi	r25, 0x0A	; 10
    1378:	29 8d       	ldd	r18, Y+25	; 0x19
    137a:	3a 8d       	ldd	r19, Y+26	; 0x1a
    137c:	36 95       	lsr	r19
    137e:	27 95       	ror	r18
    1380:	fc 01       	movw	r30, r24
    1382:	22 af       	sts	0x72, r18
    1384:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1386:	80 e4       	ldi	r24, 0x40	; 64
    1388:	9a e0       	ldi	r25, 0x0A	; 10
    138a:	20 e4       	ldi	r18, 0x40	; 64
    138c:	3a e0       	ldi	r19, 0x0A	; 10
    138e:	f9 01       	movw	r30, r18
    1390:	20 81       	ld	r18, Z
    1392:	20 7f       	andi	r18, 0xF0	; 240
    1394:	21 60       	ori	r18, 0x01	; 1
    1396:	fc 01       	movw	r30, r24
    1398:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    139a:	80 ea       	ldi	r24, 0xA0	; 160
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	20 ea       	ldi	r18, 0xA0	; 160
    13a0:	30 e0       	ldi	r19, 0x00	; 0
    13a2:	f9 01       	movw	r30, r18
    13a4:	22 81       	ldd	r18, Z+2	; 0x02
    13a6:	21 60       	ori	r18, 0x01	; 1
    13a8:	fc 01       	movw	r30, r24
    13aa:	22 83       	std	Z+2, r18	; 0x02
	sei();
    13ac:	78 94       	sei

	sampleCount = 0;
    13ae:	10 92 67 50 	sts	0x5067, r1
    13b2:	10 92 68 50 	sts	0x5068, r1
	discardCount = 0;
    13b6:	10 92 52 40 	sts	0x4052, r1
	
	// wait for ADC to collect samples
	while(sampleCount < NUM_SAMPLES);
    13ba:	00 00       	nop
    13bc:	80 91 67 50 	lds	r24, 0x5067
    13c0:	90 91 68 50 	lds	r25, 0x5068
    13c4:	f4 e0       	ldi	r31, 0x04	; 4
    13c6:	80 30       	cpi	r24, 0x00	; 0
    13c8:	9f 07       	cpc	r25, r31
    13ca:	c0 f3       	brcs	.-16     	; 0x13bc <CO_collectADC+0x182>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    13cc:	80 e4       	ldi	r24, 0x40	; 64
    13ce:	9a e0       	ldi	r25, 0x0A	; 10
    13d0:	20 e4       	ldi	r18, 0x40	; 64
    13d2:	3a e0       	ldi	r19, 0x0A	; 10
    13d4:	f9 01       	movw	r30, r18
    13d6:	20 81       	ld	r18, Z
    13d8:	20 7f       	andi	r18, 0xF0	; 240
    13da:	fc 01       	movw	r30, r24
    13dc:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    13de:	80 ea       	ldi	r24, 0xA0	; 160
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	20 ea       	ldi	r18, 0xA0	; 160
    13e4:	30 e0       	ldi	r19, 0x00	; 0
    13e6:	f9 01       	movw	r30, r18
    13e8:	22 81       	ldd	r18, Z+2	; 0x02
    13ea:	2e 7f       	andi	r18, 0xFE	; 254
    13ec:	fc 01       	movw	r30, r24
    13ee:	22 83       	std	Z+2, r18	; 0x02
	cli();
    13f0:	f8 94       	cli

	SPIDisable();	
    13f2:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	enableADCMUX(FALSE);
    13f6:	80 e0       	ldi	r24, 0x00	; 0
    13f8:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
	ADCPower(FALSE);
    13fc:	80 e0       	ldi	r24, 0x00	; 0
    13fe:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    1402:	10 92 67 50 	sts	0x5067, r1
    1406:	10 92 68 50 	sts	0x5068, r1
    140a:	69 c1       	rjmp	.+722    	; 0x16de <CO_collectADC+0x4a4>
		sum += data24Bit[sampleCount];
    140c:	80 91 67 50 	lds	r24, 0x5067
    1410:	90 91 68 50 	lds	r25, 0x5068
    1414:	88 0f       	add	r24, r24
    1416:	99 1f       	adc	r25, r25
    1418:	88 0f       	add	r24, r24
    141a:	99 1f       	adc	r25, r25
    141c:	88 5a       	subi	r24, 0xA8	; 168
    141e:	9f 4b       	sbci	r25, 0xBF	; 191
    1420:	fc 01       	movw	r30, r24
    1422:	80 81       	ld	r24, Z
    1424:	91 81       	ldd	r25, Z+1	; 0x01
    1426:	a2 81       	ldd	r26, Z+2	; 0x02
    1428:	b3 81       	ldd	r27, Z+3	; 0x03
    142a:	8d a7       	lds	r24, 0x7d
    142c:	9e a7       	lds	r25, 0x7e
    142e:	af a7       	lds	r26, 0x7f
    1430:	b8 ab       	sts	0x58, r27
    1432:	bb 0f       	add	r27, r27
    1434:	88 0b       	sbc	r24, r24
    1436:	98 2f       	mov	r25, r24
    1438:	dc 01       	movw	r26, r24
    143a:	89 ab       	sts	0x59, r24
    143c:	8a ab       	sts	0x5a, r24
    143e:	8b ab       	sts	0x5b, r24
    1440:	8c ab       	sts	0x5c, r24
    1442:	a9 80       	ldd	r10, Y+1	; 0x01
    1444:	ba 80       	ldd	r11, Y+2	; 0x02
    1446:	cb 80       	ldd	r12, Y+3	; 0x03
    1448:	dc 80       	ldd	r13, Y+4	; 0x04
    144a:	ed 80       	ldd	r14, Y+5	; 0x05
    144c:	fe 80       	ldd	r15, Y+6	; 0x06
    144e:	0f 81       	ldd	r16, Y+7	; 0x07
    1450:	18 85       	ldd	r17, Y+8	; 0x08
    1452:	2d a5       	lds	r18, 0x6d
    1454:	2a 0d       	add	r18, r10
    1456:	e1 e0       	ldi	r30, 0x01	; 1
    1458:	2a 15       	cp	r18, r10
    145a:	08 f0       	brcs	.+2      	; 0x145e <CO_collectADC+0x224>
    145c:	e0 e0       	ldi	r30, 0x00	; 0
    145e:	3e a5       	lds	r19, 0x6e
    1460:	3b 0d       	add	r19, r11
    1462:	a1 e0       	ldi	r26, 0x01	; 1
    1464:	3b 15       	cp	r19, r11
    1466:	08 f0       	brcs	.+2      	; 0x146a <CO_collectADC+0x230>
    1468:	a0 e0       	ldi	r26, 0x00	; 0
    146a:	fe 2f       	mov	r31, r30
    146c:	f3 0f       	add	r31, r19
    146e:	e1 e0       	ldi	r30, 0x01	; 1
    1470:	f3 17       	cp	r31, r19
    1472:	08 f0       	brcs	.+2      	; 0x1476 <CO_collectADC+0x23c>
    1474:	e0 e0       	ldi	r30, 0x00	; 0
    1476:	ae 2b       	or	r26, r30
    1478:	3f 2f       	mov	r19, r31
    147a:	4f a5       	lds	r20, 0x6f
    147c:	4c 0d       	add	r20, r12
    147e:	b1 e0       	ldi	r27, 0x01	; 1
    1480:	4c 15       	cp	r20, r12
    1482:	08 f0       	brcs	.+2      	; 0x1486 <CO_collectADC+0x24c>
    1484:	b0 e0       	ldi	r27, 0x00	; 0
    1486:	fa 2f       	mov	r31, r26
    1488:	f4 0f       	add	r31, r20
    148a:	e1 e0       	ldi	r30, 0x01	; 1
    148c:	f4 17       	cp	r31, r20
    148e:	08 f0       	brcs	.+2      	; 0x1492 <CO_collectADC+0x258>
    1490:	e0 e0       	ldi	r30, 0x00	; 0
    1492:	be 2b       	or	r27, r30
    1494:	4f 2f       	mov	r20, r31
    1496:	58 a9       	sts	0x48, r21
    1498:	5d 0d       	add	r21, r13
    149a:	a1 e0       	ldi	r26, 0x01	; 1
    149c:	5d 15       	cp	r21, r13
    149e:	08 f0       	brcs	.+2      	; 0x14a2 <CO_collectADC+0x268>
    14a0:	a0 e0       	ldi	r26, 0x00	; 0
    14a2:	fb 2f       	mov	r31, r27
    14a4:	f5 0f       	add	r31, r21
    14a6:	e1 e0       	ldi	r30, 0x01	; 1
    14a8:	f5 17       	cp	r31, r21
    14aa:	08 f0       	brcs	.+2      	; 0x14ae <CO_collectADC+0x274>
    14ac:	e0 e0       	ldi	r30, 0x00	; 0
    14ae:	ae 2b       	or	r26, r30
    14b0:	5f 2f       	mov	r21, r31
    14b2:	69 a9       	sts	0x49, r22
    14b4:	6e 0d       	add	r22, r14
    14b6:	b1 e0       	ldi	r27, 0x01	; 1
    14b8:	6e 15       	cp	r22, r14
    14ba:	08 f0       	brcs	.+2      	; 0x14be <CO_collectADC+0x284>
    14bc:	b0 e0       	ldi	r27, 0x00	; 0
    14be:	fa 2f       	mov	r31, r26
    14c0:	f6 0f       	add	r31, r22
    14c2:	e1 e0       	ldi	r30, 0x01	; 1
    14c4:	f6 17       	cp	r31, r22
    14c6:	08 f0       	brcs	.+2      	; 0x14ca <CO_collectADC+0x290>
    14c8:	e0 e0       	ldi	r30, 0x00	; 0
    14ca:	be 2b       	or	r27, r30
    14cc:	6f 2f       	mov	r22, r31
    14ce:	7a a9       	sts	0x4a, r23
    14d0:	7f 0d       	add	r23, r15
    14d2:	a1 e0       	ldi	r26, 0x01	; 1
    14d4:	7f 15       	cp	r23, r15
    14d6:	08 f0       	brcs	.+2      	; 0x14da <CO_collectADC+0x2a0>
    14d8:	a0 e0       	ldi	r26, 0x00	; 0
    14da:	fb 2f       	mov	r31, r27
    14dc:	f7 0f       	add	r31, r23
    14de:	e1 e0       	ldi	r30, 0x01	; 1
    14e0:	f7 17       	cp	r31, r23
    14e2:	08 f0       	brcs	.+2      	; 0x14e6 <CO_collectADC+0x2ac>
    14e4:	e0 e0       	ldi	r30, 0x00	; 0
    14e6:	ae 2b       	or	r26, r30
    14e8:	7f 2f       	mov	r23, r31
    14ea:	8b a9       	sts	0x4b, r24
    14ec:	80 0f       	add	r24, r16
    14ee:	f1 e0       	ldi	r31, 0x01	; 1
    14f0:	80 17       	cp	r24, r16
    14f2:	08 f0       	brcs	.+2      	; 0x14f6 <CO_collectADC+0x2bc>
    14f4:	f0 e0       	ldi	r31, 0x00	; 0
    14f6:	a8 0f       	add	r26, r24
    14f8:	e1 e0       	ldi	r30, 0x01	; 1
    14fa:	a8 17       	cp	r26, r24
    14fc:	08 f0       	brcs	.+2      	; 0x1500 <CO_collectADC+0x2c6>
    14fe:	e0 e0       	ldi	r30, 0x00	; 0
    1500:	fe 2b       	or	r31, r30
    1502:	8a 2f       	mov	r24, r26
    1504:	9c a9       	sts	0x4c, r25
    1506:	91 0f       	add	r25, r17
    1508:	ef 2f       	mov	r30, r31
    150a:	e9 0f       	add	r30, r25
    150c:	9e 2f       	mov	r25, r30
    150e:	29 83       	std	Y+1, r18	; 0x01
    1510:	3a 83       	std	Y+2, r19	; 0x02
    1512:	4b 83       	std	Y+3, r20	; 0x03
    1514:	5c 83       	std	Y+4, r21	; 0x04
    1516:	6d 83       	std	Y+5, r22	; 0x05
    1518:	7e 83       	std	Y+6, r23	; 0x06
    151a:	8f 83       	std	Y+7, r24	; 0x07
    151c:	98 87       	std	Y+8, r25	; 0x08
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
    151e:	80 91 67 50 	lds	r24, 0x5067
    1522:	90 91 68 50 	lds	r25, 0x5068
    1526:	88 0f       	add	r24, r24
    1528:	99 1f       	adc	r25, r25
    152a:	88 0f       	add	r24, r24
    152c:	99 1f       	adc	r25, r25
    152e:	88 5a       	subi	r24, 0xA8	; 168
    1530:	9f 4b       	sbci	r25, 0xBF	; 191
    1532:	fc 01       	movw	r30, r24
    1534:	80 81       	ld	r24, Z
    1536:	91 81       	ldd	r25, Z+1	; 0x01
    1538:	a2 81       	ldd	r26, Z+2	; 0x02
    153a:	b3 81       	ldd	r27, Z+3	; 0x03
    153c:	1c 01       	movw	r2, r24
    153e:	2d 01       	movw	r4, r26
    1540:	bb 0f       	add	r27, r27
    1542:	88 0b       	sbc	r24, r24
    1544:	98 2f       	mov	r25, r24
    1546:	dc 01       	movw	r26, r24
    1548:	68 2e       	mov	r6, r24
    154a:	78 2e       	mov	r7, r24
    154c:	88 2e       	mov	r8, r24
    154e:	98 2e       	mov	r9, r24
    1550:	88 8d       	ldd	r24, Y+24	; 0x18
    1552:	89 15       	cp	r24, r9
    1554:	5c f1       	brlt	.+86     	; 0x15ac <CO_collectADC+0x372>
    1556:	88 8d       	ldd	r24, Y+24	; 0x18
    1558:	89 15       	cp	r24, r9
    155a:	09 f0       	breq	.+2      	; 0x155e <CO_collectADC+0x324>
    155c:	42 c0       	rjmp	.+132    	; 0x15e2 <CO_collectADC+0x3a8>
    155e:	8f 89       	ldd	r24, Y+23	; 0x17
    1560:	88 15       	cp	r24, r8
    1562:	20 f1       	brcs	.+72     	; 0x15ac <CO_collectADC+0x372>
    1564:	8f 89       	ldd	r24, Y+23	; 0x17
    1566:	88 15       	cp	r24, r8
    1568:	e1 f5       	brne	.+120    	; 0x15e2 <CO_collectADC+0x3a8>
    156a:	8e 89       	ldd	r24, Y+22	; 0x16
    156c:	87 15       	cp	r24, r7
    156e:	f0 f0       	brcs	.+60     	; 0x15ac <CO_collectADC+0x372>
    1570:	8e 89       	ldd	r24, Y+22	; 0x16
    1572:	87 15       	cp	r24, r7
    1574:	b1 f5       	brne	.+108    	; 0x15e2 <CO_collectADC+0x3a8>
    1576:	8d 89       	ldd	r24, Y+21	; 0x15
    1578:	86 15       	cp	r24, r6
    157a:	c0 f0       	brcs	.+48     	; 0x15ac <CO_collectADC+0x372>
    157c:	8d 89       	ldd	r24, Y+21	; 0x15
    157e:	86 15       	cp	r24, r6
    1580:	81 f5       	brne	.+96     	; 0x15e2 <CO_collectADC+0x3a8>
    1582:	8c 89       	ldd	r24, Y+20	; 0x14
    1584:	85 15       	cp	r24, r5
    1586:	90 f0       	brcs	.+36     	; 0x15ac <CO_collectADC+0x372>
    1588:	8c 89       	ldd	r24, Y+20	; 0x14
    158a:	85 15       	cp	r24, r5
    158c:	51 f5       	brne	.+84     	; 0x15e2 <CO_collectADC+0x3a8>
    158e:	8b 89       	ldd	r24, Y+19	; 0x13
    1590:	84 15       	cp	r24, r4
    1592:	60 f0       	brcs	.+24     	; 0x15ac <CO_collectADC+0x372>
    1594:	8b 89       	ldd	r24, Y+19	; 0x13
    1596:	84 15       	cp	r24, r4
    1598:	21 f5       	brne	.+72     	; 0x15e2 <CO_collectADC+0x3a8>
    159a:	8a 89       	ldd	r24, Y+18	; 0x12
    159c:	83 15       	cp	r24, r3
    159e:	30 f0       	brcs	.+12     	; 0x15ac <CO_collectADC+0x372>
    15a0:	8a 89       	ldd	r24, Y+18	; 0x12
    15a2:	83 15       	cp	r24, r3
    15a4:	f1 f4       	brne	.+60     	; 0x15e2 <CO_collectADC+0x3a8>
    15a6:	89 89       	ldd	r24, Y+17	; 0x11
    15a8:	82 15       	cp	r24, r2
    15aa:	d8 f4       	brcc	.+54     	; 0x15e2 <CO_collectADC+0x3a8>
    15ac:	80 91 67 50 	lds	r24, 0x5067
    15b0:	90 91 68 50 	lds	r25, 0x5068
    15b4:	88 0f       	add	r24, r24
    15b6:	99 1f       	adc	r25, r25
    15b8:	88 0f       	add	r24, r24
    15ba:	99 1f       	adc	r25, r25
    15bc:	88 5a       	subi	r24, 0xA8	; 168
    15be:	9f 4b       	sbci	r25, 0xBF	; 191
    15c0:	fc 01       	movw	r30, r24
    15c2:	80 81       	ld	r24, Z
    15c4:	91 81       	ldd	r25, Z+1	; 0x01
    15c6:	a2 81       	ldd	r26, Z+2	; 0x02
    15c8:	b3 81       	ldd	r27, Z+3	; 0x03
    15ca:	89 8b       	std	Y+17, r24	; 0x11
    15cc:	9a 8b       	std	Y+18, r25	; 0x12
    15ce:	ab 8b       	std	Y+19, r26	; 0x13
    15d0:	bc 8b       	std	Y+20, r27	; 0x14
    15d2:	bb 0f       	add	r27, r27
    15d4:	88 0b       	sbc	r24, r24
    15d6:	98 2f       	mov	r25, r24
    15d8:	dc 01       	movw	r26, r24
    15da:	8d 8b       	std	Y+21, r24	; 0x15
    15dc:	8e 8b       	std	Y+22, r24	; 0x16
    15de:	8f 8b       	std	Y+23, r24	; 0x17
    15e0:	88 8f       	std	Y+24, r24	; 0x18
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
    15e2:	80 91 67 50 	lds	r24, 0x5067
    15e6:	90 91 68 50 	lds	r25, 0x5068
    15ea:	88 0f       	add	r24, r24
    15ec:	99 1f       	adc	r25, r25
    15ee:	88 0f       	add	r24, r24
    15f0:	99 1f       	adc	r25, r25
    15f2:	88 5a       	subi	r24, 0xA8	; 168
    15f4:	9f 4b       	sbci	r25, 0xBF	; 191
    15f6:	fc 01       	movw	r30, r24
    15f8:	80 81       	ld	r24, Z
    15fa:	91 81       	ldd	r25, Z+1	; 0x01
    15fc:	a2 81       	ldd	r26, Z+2	; 0x02
    15fe:	b3 81       	ldd	r27, Z+3	; 0x03
    1600:	8d ab       	sts	0x5d, r24
    1602:	9e ab       	sts	0x5e, r25
    1604:	af ab       	sts	0x5f, r26
    1606:	b8 af       	sts	0x78, r27
    1608:	bb 0f       	add	r27, r27
    160a:	88 0b       	sbc	r24, r24
    160c:	98 2f       	mov	r25, r24
    160e:	dc 01       	movw	r26, r24
    1610:	89 af       	sts	0x79, r24
    1612:	8a af       	sts	0x7a, r24
    1614:	8b af       	sts	0x7b, r24
    1616:	8c af       	sts	0x7c, r24
    1618:	88 89       	ldd	r24, Y+16	; 0x10
    161a:	fc ad       	sts	0x6c, r31
    161c:	f8 17       	cp	r31, r24
    161e:	dc f1       	brlt	.+118    	; 0x1696 <CO_collectADC+0x45c>
    1620:	88 89       	ldd	r24, Y+16	; 0x10
    1622:	2c ad       	sts	0x6c, r18
    1624:	82 17       	cp	r24, r18
    1626:	09 f0       	breq	.+2      	; 0x162a <CO_collectADC+0x3f0>
    1628:	51 c0       	rjmp	.+162    	; 0x16cc <CO_collectADC+0x492>
    162a:	8f 85       	ldd	r24, Y+15	; 0x0f
    162c:	9b ad       	sts	0x6b, r25
    162e:	98 17       	cp	r25, r24
    1630:	90 f1       	brcs	.+100    	; 0x1696 <CO_collectADC+0x45c>
    1632:	8f 85       	ldd	r24, Y+15	; 0x0f
    1634:	eb ad       	sts	0x6b, r30
    1636:	8e 17       	cp	r24, r30
    1638:	09 f0       	breq	.+2      	; 0x163c <CO_collectADC+0x402>
    163a:	48 c0       	rjmp	.+144    	; 0x16cc <CO_collectADC+0x492>
    163c:	8e 85       	ldd	r24, Y+14	; 0x0e
    163e:	fa ad       	sts	0x6a, r31
    1640:	f8 17       	cp	r31, r24
    1642:	48 f1       	brcs	.+82     	; 0x1696 <CO_collectADC+0x45c>
    1644:	8e 85       	ldd	r24, Y+14	; 0x0e
    1646:	2a ad       	sts	0x6a, r18
    1648:	82 17       	cp	r24, r18
    164a:	09 f0       	breq	.+2      	; 0x164e <CO_collectADC+0x414>
    164c:	3f c0       	rjmp	.+126    	; 0x16cc <CO_collectADC+0x492>
    164e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1650:	99 ad       	sts	0x69, r25
    1652:	98 17       	cp	r25, r24
    1654:	00 f1       	brcs	.+64     	; 0x1696 <CO_collectADC+0x45c>
    1656:	8d 85       	ldd	r24, Y+13	; 0x0d
    1658:	e9 ad       	sts	0x69, r30
    165a:	8e 17       	cp	r24, r30
    165c:	b9 f5       	brne	.+110    	; 0x16cc <CO_collectADC+0x492>
    165e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1660:	f8 ad       	sts	0x68, r31
    1662:	f8 17       	cp	r31, r24
    1664:	c0 f0       	brcs	.+48     	; 0x1696 <CO_collectADC+0x45c>
    1666:	8c 85       	ldd	r24, Y+12	; 0x0c
    1668:	28 ad       	sts	0x68, r18
    166a:	82 17       	cp	r24, r18
    166c:	79 f5       	brne	.+94     	; 0x16cc <CO_collectADC+0x492>
    166e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1670:	9f a9       	sts	0x4f, r25
    1672:	98 17       	cp	r25, r24
    1674:	80 f0       	brcs	.+32     	; 0x1696 <CO_collectADC+0x45c>
    1676:	8b 85       	ldd	r24, Y+11	; 0x0b
    1678:	ef a9       	sts	0x4f, r30
    167a:	8e 17       	cp	r24, r30
    167c:	39 f5       	brne	.+78     	; 0x16cc <CO_collectADC+0x492>
    167e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1680:	fe a9       	sts	0x4e, r31
    1682:	f8 17       	cp	r31, r24
    1684:	40 f0       	brcs	.+16     	; 0x1696 <CO_collectADC+0x45c>
    1686:	8a 85       	ldd	r24, Y+10	; 0x0a
    1688:	2e a9       	sts	0x4e, r18
    168a:	82 17       	cp	r24, r18
    168c:	f9 f4       	brne	.+62     	; 0x16cc <CO_collectADC+0x492>
    168e:	89 85       	ldd	r24, Y+9	; 0x09
    1690:	9d a9       	sts	0x4d, r25
    1692:	98 17       	cp	r25, r24
    1694:	d8 f4       	brcc	.+54     	; 0x16cc <CO_collectADC+0x492>
    1696:	80 91 67 50 	lds	r24, 0x5067
    169a:	90 91 68 50 	lds	r25, 0x5068
    169e:	88 0f       	add	r24, r24
    16a0:	99 1f       	adc	r25, r25
    16a2:	88 0f       	add	r24, r24
    16a4:	99 1f       	adc	r25, r25
    16a6:	88 5a       	subi	r24, 0xA8	; 168
    16a8:	9f 4b       	sbci	r25, 0xBF	; 191
    16aa:	fc 01       	movw	r30, r24
    16ac:	80 81       	ld	r24, Z
    16ae:	91 81       	ldd	r25, Z+1	; 0x01
    16b0:	a2 81       	ldd	r26, Z+2	; 0x02
    16b2:	b3 81       	ldd	r27, Z+3	; 0x03
    16b4:	89 87       	std	Y+9, r24	; 0x09
    16b6:	9a 87       	std	Y+10, r25	; 0x0a
    16b8:	ab 87       	std	Y+11, r26	; 0x0b
    16ba:	bc 87       	std	Y+12, r27	; 0x0c
    16bc:	bb 0f       	add	r27, r27
    16be:	88 0b       	sbc	r24, r24
    16c0:	98 2f       	mov	r25, r24
    16c2:	dc 01       	movw	r26, r24
    16c4:	8d 87       	std	Y+13, r24	; 0x0d
    16c6:	8e 87       	std	Y+14, r24	; 0x0e
    16c8:	8f 87       	std	Y+15, r24	; 0x0f
    16ca:	88 8b       	std	Y+16, r24	; 0x10
	SPIDisable();	
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    16cc:	80 91 67 50 	lds	r24, 0x5067
    16d0:	90 91 68 50 	lds	r25, 0x5068
    16d4:	01 96       	adiw	r24, 0x01	; 1
    16d6:	80 93 67 50 	sts	0x5067, r24
    16da:	90 93 68 50 	sts	0x5068, r25
    16de:	80 91 67 50 	lds	r24, 0x5067
    16e2:	90 91 68 50 	lds	r25, 0x5068
    16e6:	f4 e0       	ldi	r31, 0x04	; 4
    16e8:	80 30       	cpi	r24, 0x00	; 0
    16ea:	9f 07       	cpc	r25, r31
    16ec:	08 f4       	brcc	.+2      	; 0x16f0 <CO_collectADC+0x4b6>
    16ee:	8e ce       	rjmp	.-740    	; 0x140c <CO_collectADC+0x1d2>
		sum += data24Bit[sampleCount];
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
	}
	average = sum / NUM_SAMPLES;
    16f0:	29 81       	ldd	r18, Y+1	; 0x01
    16f2:	3a 81       	ldd	r19, Y+2	; 0x02
    16f4:	4b 81       	ldd	r20, Y+3	; 0x03
    16f6:	5c 81       	ldd	r21, Y+4	; 0x04
    16f8:	6d 81       	ldd	r22, Y+5	; 0x05
    16fa:	7e 81       	ldd	r23, Y+6	; 0x06
    16fc:	8f 81       	ldd	r24, Y+7	; 0x07
    16fe:	98 85       	ldd	r25, Y+8	; 0x08
    1700:	a2 2e       	mov	r10, r18
    1702:	b3 2e       	mov	r11, r19
    1704:	c4 2e       	mov	r12, r20
    1706:	d5 2e       	mov	r13, r21
    1708:	e6 2e       	mov	r14, r22
    170a:	f7 2e       	mov	r15, r23
    170c:	08 2f       	mov	r16, r24
    170e:	19 2f       	mov	r17, r25
    1710:	11 23       	and	r17, r17
    1712:	0c f0       	brlt	.+2      	; 0x1716 <CO_collectADC+0x4dc>
    1714:	6c c0       	rjmp	.+216    	; 0x17ee <CO_collectADC+0x5b4>
    1716:	22 24       	eor	r2, r2
    1718:	2a 94       	dec	r2
    171a:	0f 2e       	mov	r0, r31
    171c:	f3 e0       	ldi	r31, 0x03	; 3
    171e:	3f 2e       	mov	r3, r31
    1720:	f0 2d       	mov	r31, r0
    1722:	44 24       	eor	r4, r4
    1724:	55 24       	eor	r5, r5
    1726:	66 24       	eor	r6, r6
    1728:	77 24       	eor	r7, r7
    172a:	88 24       	eor	r8, r8
    172c:	99 24       	eor	r9, r9
    172e:	2a 2d       	mov	r18, r10
    1730:	22 0d       	add	r18, r2
    1732:	e1 e0       	ldi	r30, 0x01	; 1
    1734:	2a 15       	cp	r18, r10
    1736:	08 f0       	brcs	.+2      	; 0x173a <CO_collectADC+0x500>
    1738:	e0 e0       	ldi	r30, 0x00	; 0
    173a:	3b 2d       	mov	r19, r11
    173c:	33 0d       	add	r19, r3
    173e:	f1 e0       	ldi	r31, 0x01	; 1
    1740:	3b 15       	cp	r19, r11
    1742:	08 f0       	brcs	.+2      	; 0x1746 <CO_collectADC+0x50c>
    1744:	f0 e0       	ldi	r31, 0x00	; 0
    1746:	e3 0f       	add	r30, r19
    1748:	a1 e0       	ldi	r26, 0x01	; 1
    174a:	e3 17       	cp	r30, r19
    174c:	08 f0       	brcs	.+2      	; 0x1750 <CO_collectADC+0x516>
    174e:	a0 e0       	ldi	r26, 0x00	; 0
    1750:	fa 2b       	or	r31, r26
    1752:	3e 2f       	mov	r19, r30
    1754:	4c 2d       	mov	r20, r12
    1756:	44 0d       	add	r20, r4
    1758:	e1 e0       	ldi	r30, 0x01	; 1
    175a:	4c 15       	cp	r20, r12
    175c:	08 f0       	brcs	.+2      	; 0x1760 <CO_collectADC+0x526>
    175e:	e0 e0       	ldi	r30, 0x00	; 0
    1760:	f4 0f       	add	r31, r20
    1762:	a1 e0       	ldi	r26, 0x01	; 1
    1764:	f4 17       	cp	r31, r20
    1766:	08 f0       	brcs	.+2      	; 0x176a <CO_collectADC+0x530>
    1768:	a0 e0       	ldi	r26, 0x00	; 0
    176a:	ea 2b       	or	r30, r26
    176c:	4f 2f       	mov	r20, r31
    176e:	5d 2d       	mov	r21, r13
    1770:	55 0d       	add	r21, r5
    1772:	f1 e0       	ldi	r31, 0x01	; 1
    1774:	5d 15       	cp	r21, r13
    1776:	08 f0       	brcs	.+2      	; 0x177a <CO_collectADC+0x540>
    1778:	f0 e0       	ldi	r31, 0x00	; 0
    177a:	e5 0f       	add	r30, r21
    177c:	a1 e0       	ldi	r26, 0x01	; 1
    177e:	e5 17       	cp	r30, r21
    1780:	08 f0       	brcs	.+2      	; 0x1784 <CO_collectADC+0x54a>
    1782:	a0 e0       	ldi	r26, 0x00	; 0
    1784:	fa 2b       	or	r31, r26
    1786:	5e 2f       	mov	r21, r30
    1788:	6e 2d       	mov	r22, r14
    178a:	66 0d       	add	r22, r6
    178c:	e1 e0       	ldi	r30, 0x01	; 1
    178e:	6e 15       	cp	r22, r14
    1790:	08 f0       	brcs	.+2      	; 0x1794 <CO_collectADC+0x55a>
    1792:	e0 e0       	ldi	r30, 0x00	; 0
    1794:	f6 0f       	add	r31, r22
    1796:	a1 e0       	ldi	r26, 0x01	; 1
    1798:	f6 17       	cp	r31, r22
    179a:	08 f0       	brcs	.+2      	; 0x179e <CO_collectADC+0x564>
    179c:	a0 e0       	ldi	r26, 0x00	; 0
    179e:	ea 2b       	or	r30, r26
    17a0:	6f 2f       	mov	r22, r31
    17a2:	7f 2d       	mov	r23, r15
    17a4:	77 0d       	add	r23, r7
    17a6:	f1 e0       	ldi	r31, 0x01	; 1
    17a8:	7f 15       	cp	r23, r15
    17aa:	08 f0       	brcs	.+2      	; 0x17ae <CO_collectADC+0x574>
    17ac:	f0 e0       	ldi	r31, 0x00	; 0
    17ae:	e7 0f       	add	r30, r23
    17b0:	a1 e0       	ldi	r26, 0x01	; 1
    17b2:	e7 17       	cp	r30, r23
    17b4:	08 f0       	brcs	.+2      	; 0x17b8 <CO_collectADC+0x57e>
    17b6:	a0 e0       	ldi	r26, 0x00	; 0
    17b8:	fa 2b       	or	r31, r26
    17ba:	7e 2f       	mov	r23, r30
    17bc:	80 2f       	mov	r24, r16
    17be:	88 0d       	add	r24, r8
    17c0:	e1 e0       	ldi	r30, 0x01	; 1
    17c2:	80 17       	cp	r24, r16
    17c4:	08 f0       	brcs	.+2      	; 0x17c8 <CO_collectADC+0x58e>
    17c6:	e0 e0       	ldi	r30, 0x00	; 0
    17c8:	f8 0f       	add	r31, r24
    17ca:	a1 e0       	ldi	r26, 0x01	; 1
    17cc:	f8 17       	cp	r31, r24
    17ce:	08 f0       	brcs	.+2      	; 0x17d2 <CO_collectADC+0x598>
    17d0:	a0 e0       	ldi	r26, 0x00	; 0
    17d2:	ea 2b       	or	r30, r26
    17d4:	8f 2f       	mov	r24, r31
    17d6:	91 2f       	mov	r25, r17
    17d8:	99 0d       	add	r25, r9
    17da:	e9 0f       	add	r30, r25
    17dc:	9e 2f       	mov	r25, r30
    17de:	a2 2e       	mov	r10, r18
    17e0:	b3 2e       	mov	r11, r19
    17e2:	c4 2e       	mov	r12, r20
    17e4:	d5 2e       	mov	r13, r21
    17e6:	e6 2e       	mov	r14, r22
    17e8:	f7 2e       	mov	r15, r23
    17ea:	08 2f       	mov	r16, r24
    17ec:	19 2f       	mov	r17, r25
    17ee:	2a 2d       	mov	r18, r10
    17f0:	3b 2d       	mov	r19, r11
    17f2:	4c 2d       	mov	r20, r12
    17f4:	5d 2d       	mov	r21, r13
    17f6:	6e 2d       	mov	r22, r14
    17f8:	7f 2d       	mov	r23, r15
    17fa:	80 2f       	mov	r24, r16
    17fc:	91 2f       	mov	r25, r17
    17fe:	0a e0       	ldi	r16, 0x0A	; 10
    1800:	0e 94 c7 54 	call	0xa98e	; 0xa98e <__ashrdi3>
    1804:	a2 2e       	mov	r10, r18
    1806:	b3 2e       	mov	r11, r19
    1808:	c4 2e       	mov	r12, r20
    180a:	d5 2e       	mov	r13, r21
    180c:	e6 2e       	mov	r14, r22
    180e:	f7 2e       	mov	r15, r23
    1810:	08 2f       	mov	r16, r24
    1812:	19 2f       	mov	r17, r25
    1814:	ab 8e       	std	Y+27, r10	; 0x1b
    1816:	bc 8e       	std	Y+28, r11	; 0x1c
    1818:	cd 8e       	std	Y+29, r12	; 0x1d
    181a:	de 8e       	std	Y+30, r13	; 0x1e
    181c:	ef 8e       	std	Y+31, r14	; 0x1f
    181e:	f8 a2       	lds	r31, 0x98
    1820:	09 a3       	lds	r16, 0x59
    1822:	1a a3       	lds	r17, 0x5a

	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1824:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1826:	3c 8d       	ldd	r19, Y+28	; 0x1c
    1828:	4d 8d       	ldd	r20, Y+29	; 0x1d
    182a:	5e 8d       	ldd	r21, Y+30	; 0x1e
    182c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    182e:	78 a1       	lds	r23, 0x48
    1830:	89 a1       	lds	r24, 0x49
    1832:	9a a1       	lds	r25, 0x4a
    1834:	0f 2e       	mov	r0, r31
    1836:	f0 ea       	ldi	r31, 0xA0	; 160
    1838:	af 2e       	mov	r10, r31
    183a:	f0 2d       	mov	r31, r0
    183c:	0f 2e       	mov	r0, r31
    183e:	f5 e2       	ldi	r31, 0x25	; 37
    1840:	bf 2e       	mov	r11, r31
    1842:	f0 2d       	mov	r31, r0
    1844:	0f 2e       	mov	r0, r31
    1846:	f6 e2       	ldi	r31, 0x26	; 38
    1848:	cf 2e       	mov	r12, r31
    184a:	f0 2d       	mov	r31, r0
    184c:	dd 24       	eor	r13, r13
    184e:	ee 24       	eor	r14, r14
    1850:	ff 24       	eor	r15, r15
    1852:	00 e0       	ldi	r16, 0x00	; 0
    1854:	10 e0       	ldi	r17, 0x00	; 0
    1856:	0e 94 80 53 	call	0xa700	; 0xa700 <__muldi3>
    185a:	22 2e       	mov	r2, r18
    185c:	33 2e       	mov	r3, r19
    185e:	44 2e       	mov	r4, r20
    1860:	55 2e       	mov	r5, r21
    1862:	66 2e       	mov	r6, r22
    1864:	77 2e       	mov	r7, r23
    1866:	88 2e       	mov	r8, r24
    1868:	99 2e       	mov	r9, r25
    186a:	a2 2c       	mov	r10, r2
    186c:	b3 2c       	mov	r11, r3
    186e:	c4 2c       	mov	r12, r4
    1870:	d5 2c       	mov	r13, r5
    1872:	e6 2c       	mov	r14, r6
    1874:	f7 2c       	mov	r15, r7
    1876:	08 2d       	mov	r16, r8
    1878:	19 2d       	mov	r17, r9
    187a:	2a 2d       	mov	r18, r10
    187c:	3b 2d       	mov	r19, r11
    187e:	4c 2d       	mov	r20, r12
    1880:	5d 2d       	mov	r21, r13
    1882:	6e 2d       	mov	r22, r14
    1884:	7f 2d       	mov	r23, r15
    1886:	80 2f       	mov	r24, r16
    1888:	91 2f       	mov	r25, r17
    188a:	aa 24       	eor	r10, r10
    188c:	aa 94       	dec	r10
    188e:	bb 24       	eor	r11, r11
    1890:	ba 94       	dec	r11
    1892:	0f 2e       	mov	r0, r31
    1894:	ff e7       	ldi	r31, 0x7F	; 127
    1896:	cf 2e       	mov	r12, r31
    1898:	f0 2d       	mov	r31, r0
    189a:	dd 24       	eor	r13, r13
    189c:	ee 24       	eor	r14, r14
    189e:	ff 24       	eor	r15, r15
    18a0:	00 e0       	ldi	r16, 0x00	; 0
    18a2:	10 e0       	ldi	r17, 0x00	; 0
    18a4:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    18a8:	22 2e       	mov	r2, r18
    18aa:	33 2e       	mov	r3, r19
    18ac:	44 2e       	mov	r4, r20
    18ae:	55 2e       	mov	r5, r21
    18b0:	66 2e       	mov	r6, r22
    18b2:	77 2e       	mov	r7, r23
    18b4:	88 2e       	mov	r8, r24
    18b6:	99 2e       	mov	r9, r25
    18b8:	a2 2c       	mov	r10, r2
    18ba:	b3 2c       	mov	r11, r3
    18bc:	c4 2c       	mov	r12, r4
    18be:	d5 2c       	mov	r13, r5
    18c0:	e6 2c       	mov	r14, r6
    18c2:	f7 2c       	mov	r15, r7
    18c4:	08 2d       	mov	r16, r8
    18c6:	19 2d       	mov	r17, r9
    18c8:	2a 2d       	mov	r18, r10
    18ca:	3b 2d       	mov	r19, r11
    18cc:	4c 2d       	mov	r20, r12
    18ce:	5d 2d       	mov	r21, r13
    18d0:	6e 2d       	mov	r22, r14
    18d2:	7f 2d       	mov	r23, r15
    18d4:	80 2f       	mov	r24, r16
    18d6:	91 2f       	mov	r25, r17
    18d8:	01 e0       	ldi	r16, 0x01	; 1
    18da:	0e 94 53 54 	call	0xa8a6	; 0xa8a6 <__ashldi3>
    18de:	22 2e       	mov	r2, r18
    18e0:	33 2e       	mov	r3, r19
    18e2:	44 2e       	mov	r4, r20
    18e4:	55 2e       	mov	r5, r21
    18e6:	66 2e       	mov	r6, r22
    18e8:	77 2e       	mov	r7, r23
    18ea:	88 2e       	mov	r8, r24
    18ec:	99 2e       	mov	r9, r25
    18ee:	a2 2c       	mov	r10, r2
    18f0:	b3 2c       	mov	r11, r3
    18f2:	c4 2c       	mov	r12, r4
    18f4:	d5 2c       	mov	r13, r5
    18f6:	e6 2c       	mov	r14, r6
    18f8:	f7 2c       	mov	r15, r7
    18fa:	08 2d       	mov	r16, r8
    18fc:	19 2d       	mov	r17, r9
    18fe:	2a 2d       	mov	r18, r10
    1900:	3b 2d       	mov	r19, r11
    1902:	4c 2d       	mov	r20, r12
    1904:	5d 2d       	mov	r21, r13
    1906:	6e 2d       	mov	r22, r14
    1908:	7f 2d       	mov	r23, r15
    190a:	80 2f       	mov	r24, r16
    190c:	91 2f       	mov	r25, r17
    190e:	0f 2e       	mov	r0, r31
    1910:	f3 e0       	ldi	r31, 0x03	; 3
    1912:	af 2e       	mov	r10, r31
    1914:	f0 2d       	mov	r31, r0
    1916:	bb 24       	eor	r11, r11
    1918:	cc 24       	eor	r12, r12
    191a:	dd 24       	eor	r13, r13
    191c:	ee 24       	eor	r14, r14
    191e:	ff 24       	eor	r15, r15
    1920:	00 e0       	ldi	r16, 0x00	; 0
    1922:	10 e0       	ldi	r17, 0x00	; 0
    1924:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    1928:	a2 2e       	mov	r10, r18
    192a:	b3 2e       	mov	r11, r19
    192c:	c4 2e       	mov	r12, r20
    192e:	d5 2e       	mov	r13, r21
    1930:	e6 2e       	mov	r14, r22
    1932:	f7 2e       	mov	r15, r23
    1934:	08 2f       	mov	r16, r24
    1936:	19 2f       	mov	r17, r25
    1938:	2a 2d       	mov	r18, r10
    193a:	3b 2d       	mov	r19, r11
    193c:	4c 2d       	mov	r20, r12
    193e:	5d 2d       	mov	r21, r13
    1940:	6e 2d       	mov	r22, r14
    1942:	7f 2d       	mov	r23, r15
    1944:	80 2f       	mov	r24, r16
    1946:	91 2f       	mov	r25, r17
    1948:	da 01       	movw	r26, r20
    194a:	c9 01       	movw	r24, r18
    194c:	b0 95       	com	r27
    194e:	a0 95       	com	r26
    1950:	90 95       	com	r25
    1952:	81 95       	neg	r24
    1954:	9f 4f       	sbci	r25, 0xFF	; 255
    1956:	af 4f       	sbci	r26, 0xFF	; 255
    1958:	bf 4f       	sbci	r27, 0xFF	; 255
    195a:	2d a1       	lds	r18, 0x4d
    195c:	3e a1       	lds	r19, 0x4e
    195e:	f9 01       	movw	r30, r18
    1960:	80 83       	st	Z, r24
    1962:	91 83       	std	Z+1, r25	; 0x01
    1964:	a2 83       	std	Z+2, r26	; 0x02
    1966:	b3 83       	std	Z+3, r27	; 0x03
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1968:	29 89       	ldd	r18, Y+17	; 0x11
    196a:	3a 89       	ldd	r19, Y+18	; 0x12
    196c:	4b 89       	ldd	r20, Y+19	; 0x13
    196e:	5c 89       	ldd	r21, Y+20	; 0x14
    1970:	6d 89       	ldd	r22, Y+21	; 0x15
    1972:	7e 89       	ldd	r23, Y+22	; 0x16
    1974:	8f 89       	ldd	r24, Y+23	; 0x17
    1976:	98 8d       	ldd	r25, Y+24	; 0x18
    1978:	0f 2e       	mov	r0, r31
    197a:	f0 ea       	ldi	r31, 0xA0	; 160
    197c:	af 2e       	mov	r10, r31
    197e:	f0 2d       	mov	r31, r0
    1980:	0f 2e       	mov	r0, r31
    1982:	f5 e2       	ldi	r31, 0x25	; 37
    1984:	bf 2e       	mov	r11, r31
    1986:	f0 2d       	mov	r31, r0
    1988:	0f 2e       	mov	r0, r31
    198a:	f6 e2       	ldi	r31, 0x26	; 38
    198c:	cf 2e       	mov	r12, r31
    198e:	f0 2d       	mov	r31, r0
    1990:	dd 24       	eor	r13, r13
    1992:	ee 24       	eor	r14, r14
    1994:	ff 24       	eor	r15, r15
    1996:	00 e0       	ldi	r16, 0x00	; 0
    1998:	10 e0       	ldi	r17, 0x00	; 0
    199a:	0e 94 80 53 	call	0xa700	; 0xa700 <__muldi3>
    199e:	22 2e       	mov	r2, r18
    19a0:	33 2e       	mov	r3, r19
    19a2:	44 2e       	mov	r4, r20
    19a4:	55 2e       	mov	r5, r21
    19a6:	66 2e       	mov	r6, r22
    19a8:	77 2e       	mov	r7, r23
    19aa:	88 2e       	mov	r8, r24
    19ac:	99 2e       	mov	r9, r25
    19ae:	a2 2c       	mov	r10, r2
    19b0:	b3 2c       	mov	r11, r3
    19b2:	c4 2c       	mov	r12, r4
    19b4:	d5 2c       	mov	r13, r5
    19b6:	e6 2c       	mov	r14, r6
    19b8:	f7 2c       	mov	r15, r7
    19ba:	08 2d       	mov	r16, r8
    19bc:	19 2d       	mov	r17, r9
    19be:	2a 2d       	mov	r18, r10
    19c0:	3b 2d       	mov	r19, r11
    19c2:	4c 2d       	mov	r20, r12
    19c4:	5d 2d       	mov	r21, r13
    19c6:	6e 2d       	mov	r22, r14
    19c8:	7f 2d       	mov	r23, r15
    19ca:	80 2f       	mov	r24, r16
    19cc:	91 2f       	mov	r25, r17
    19ce:	aa 24       	eor	r10, r10
    19d0:	aa 94       	dec	r10
    19d2:	bb 24       	eor	r11, r11
    19d4:	ba 94       	dec	r11
    19d6:	0f 2e       	mov	r0, r31
    19d8:	ff e7       	ldi	r31, 0x7F	; 127
    19da:	cf 2e       	mov	r12, r31
    19dc:	f0 2d       	mov	r31, r0
    19de:	dd 24       	eor	r13, r13
    19e0:	ee 24       	eor	r14, r14
    19e2:	ff 24       	eor	r15, r15
    19e4:	00 e0       	ldi	r16, 0x00	; 0
    19e6:	10 e0       	ldi	r17, 0x00	; 0
    19e8:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    19ec:	22 2e       	mov	r2, r18
    19ee:	33 2e       	mov	r3, r19
    19f0:	44 2e       	mov	r4, r20
    19f2:	55 2e       	mov	r5, r21
    19f4:	66 2e       	mov	r6, r22
    19f6:	77 2e       	mov	r7, r23
    19f8:	88 2e       	mov	r8, r24
    19fa:	99 2e       	mov	r9, r25
    19fc:	a2 2c       	mov	r10, r2
    19fe:	b3 2c       	mov	r11, r3
    1a00:	c4 2c       	mov	r12, r4
    1a02:	d5 2c       	mov	r13, r5
    1a04:	e6 2c       	mov	r14, r6
    1a06:	f7 2c       	mov	r15, r7
    1a08:	08 2d       	mov	r16, r8
    1a0a:	19 2d       	mov	r17, r9
    1a0c:	2a 2d       	mov	r18, r10
    1a0e:	3b 2d       	mov	r19, r11
    1a10:	4c 2d       	mov	r20, r12
    1a12:	5d 2d       	mov	r21, r13
    1a14:	6e 2d       	mov	r22, r14
    1a16:	7f 2d       	mov	r23, r15
    1a18:	80 2f       	mov	r24, r16
    1a1a:	91 2f       	mov	r25, r17
    1a1c:	01 e0       	ldi	r16, 0x01	; 1
    1a1e:	0e 94 53 54 	call	0xa8a6	; 0xa8a6 <__ashldi3>
    1a22:	22 2e       	mov	r2, r18
    1a24:	33 2e       	mov	r3, r19
    1a26:	44 2e       	mov	r4, r20
    1a28:	55 2e       	mov	r5, r21
    1a2a:	66 2e       	mov	r6, r22
    1a2c:	77 2e       	mov	r7, r23
    1a2e:	88 2e       	mov	r8, r24
    1a30:	99 2e       	mov	r9, r25
    1a32:	a2 2c       	mov	r10, r2
    1a34:	b3 2c       	mov	r11, r3
    1a36:	c4 2c       	mov	r12, r4
    1a38:	d5 2c       	mov	r13, r5
    1a3a:	e6 2c       	mov	r14, r6
    1a3c:	f7 2c       	mov	r15, r7
    1a3e:	08 2d       	mov	r16, r8
    1a40:	19 2d       	mov	r17, r9
    1a42:	2a 2d       	mov	r18, r10
    1a44:	3b 2d       	mov	r19, r11
    1a46:	4c 2d       	mov	r20, r12
    1a48:	5d 2d       	mov	r21, r13
    1a4a:	6e 2d       	mov	r22, r14
    1a4c:	7f 2d       	mov	r23, r15
    1a4e:	80 2f       	mov	r24, r16
    1a50:	91 2f       	mov	r25, r17
    1a52:	0f 2e       	mov	r0, r31
    1a54:	f3 e0       	ldi	r31, 0x03	; 3
    1a56:	af 2e       	mov	r10, r31
    1a58:	f0 2d       	mov	r31, r0
    1a5a:	bb 24       	eor	r11, r11
    1a5c:	cc 24       	eor	r12, r12
    1a5e:	dd 24       	eor	r13, r13
    1a60:	ee 24       	eor	r14, r14
    1a62:	ff 24       	eor	r15, r15
    1a64:	00 e0       	ldi	r16, 0x00	; 0
    1a66:	10 e0       	ldi	r17, 0x00	; 0
    1a68:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    1a6c:	a2 2e       	mov	r10, r18
    1a6e:	b3 2e       	mov	r11, r19
    1a70:	c4 2e       	mov	r12, r20
    1a72:	d5 2e       	mov	r13, r21
    1a74:	e6 2e       	mov	r14, r22
    1a76:	f7 2e       	mov	r15, r23
    1a78:	08 2f       	mov	r16, r24
    1a7a:	19 2f       	mov	r17, r25
    1a7c:	2a 2d       	mov	r18, r10
    1a7e:	3b 2d       	mov	r19, r11
    1a80:	4c 2d       	mov	r20, r12
    1a82:	5d 2d       	mov	r21, r13
    1a84:	6e 2d       	mov	r22, r14
    1a86:	7f 2d       	mov	r23, r15
    1a88:	80 2f       	mov	r24, r16
    1a8a:	91 2f       	mov	r25, r17
    1a8c:	da 01       	movw	r26, r20
    1a8e:	c9 01       	movw	r24, r18
    1a90:	b0 95       	com	r27
    1a92:	a0 95       	com	r26
    1a94:	90 95       	com	r25
    1a96:	81 95       	neg	r24
    1a98:	9f 4f       	sbci	r25, 0xFF	; 255
    1a9a:	af 4f       	sbci	r26, 0xFF	; 255
    1a9c:	bf 4f       	sbci	r27, 0xFF	; 255
    1a9e:	29 a5       	lds	r18, 0x69
    1aa0:	3a a5       	lds	r19, 0x6a
    1aa2:	f9 01       	movw	r30, r18
    1aa4:	80 83       	st	Z, r24
    1aa6:	91 83       	std	Z+1, r25	; 0x01
    1aa8:	a2 83       	std	Z+2, r26	; 0x02
    1aaa:	b3 83       	std	Z+3, r27	; 0x03
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1aac:	29 85       	ldd	r18, Y+9	; 0x09
    1aae:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ab0:	4b 85       	ldd	r20, Y+11	; 0x0b
    1ab2:	5c 85       	ldd	r21, Y+12	; 0x0c
    1ab4:	6d 85       	ldd	r22, Y+13	; 0x0d
    1ab6:	7e 85       	ldd	r23, Y+14	; 0x0e
    1ab8:	8f 85       	ldd	r24, Y+15	; 0x0f
    1aba:	98 89       	ldd	r25, Y+16	; 0x10
    1abc:	0f 2e       	mov	r0, r31
    1abe:	f0 ea       	ldi	r31, 0xA0	; 160
    1ac0:	af 2e       	mov	r10, r31
    1ac2:	f0 2d       	mov	r31, r0
    1ac4:	0f 2e       	mov	r0, r31
    1ac6:	f5 e2       	ldi	r31, 0x25	; 37
    1ac8:	bf 2e       	mov	r11, r31
    1aca:	f0 2d       	mov	r31, r0
    1acc:	0f 2e       	mov	r0, r31
    1ace:	f6 e2       	ldi	r31, 0x26	; 38
    1ad0:	cf 2e       	mov	r12, r31
    1ad2:	f0 2d       	mov	r31, r0
    1ad4:	dd 24       	eor	r13, r13
    1ad6:	ee 24       	eor	r14, r14
    1ad8:	ff 24       	eor	r15, r15
    1ada:	00 e0       	ldi	r16, 0x00	; 0
    1adc:	10 e0       	ldi	r17, 0x00	; 0
    1ade:	0e 94 80 53 	call	0xa700	; 0xa700 <__muldi3>
    1ae2:	22 2e       	mov	r2, r18
    1ae4:	33 2e       	mov	r3, r19
    1ae6:	44 2e       	mov	r4, r20
    1ae8:	55 2e       	mov	r5, r21
    1aea:	66 2e       	mov	r6, r22
    1aec:	77 2e       	mov	r7, r23
    1aee:	88 2e       	mov	r8, r24
    1af0:	99 2e       	mov	r9, r25
    1af2:	a2 2c       	mov	r10, r2
    1af4:	b3 2c       	mov	r11, r3
    1af6:	c4 2c       	mov	r12, r4
    1af8:	d5 2c       	mov	r13, r5
    1afa:	e6 2c       	mov	r14, r6
    1afc:	f7 2c       	mov	r15, r7
    1afe:	08 2d       	mov	r16, r8
    1b00:	19 2d       	mov	r17, r9
    1b02:	2a 2d       	mov	r18, r10
    1b04:	3b 2d       	mov	r19, r11
    1b06:	4c 2d       	mov	r20, r12
    1b08:	5d 2d       	mov	r21, r13
    1b0a:	6e 2d       	mov	r22, r14
    1b0c:	7f 2d       	mov	r23, r15
    1b0e:	80 2f       	mov	r24, r16
    1b10:	91 2f       	mov	r25, r17
    1b12:	aa 24       	eor	r10, r10
    1b14:	aa 94       	dec	r10
    1b16:	bb 24       	eor	r11, r11
    1b18:	ba 94       	dec	r11
    1b1a:	0f 2e       	mov	r0, r31
    1b1c:	ff e7       	ldi	r31, 0x7F	; 127
    1b1e:	cf 2e       	mov	r12, r31
    1b20:	f0 2d       	mov	r31, r0
    1b22:	dd 24       	eor	r13, r13
    1b24:	ee 24       	eor	r14, r14
    1b26:	ff 24       	eor	r15, r15
    1b28:	00 e0       	ldi	r16, 0x00	; 0
    1b2a:	10 e0       	ldi	r17, 0x00	; 0
    1b2c:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    1b30:	22 2e       	mov	r2, r18
    1b32:	33 2e       	mov	r3, r19
    1b34:	44 2e       	mov	r4, r20
    1b36:	55 2e       	mov	r5, r21
    1b38:	66 2e       	mov	r6, r22
    1b3a:	77 2e       	mov	r7, r23
    1b3c:	88 2e       	mov	r8, r24
    1b3e:	99 2e       	mov	r9, r25
    1b40:	a2 2c       	mov	r10, r2
    1b42:	b3 2c       	mov	r11, r3
    1b44:	c4 2c       	mov	r12, r4
    1b46:	d5 2c       	mov	r13, r5
    1b48:	e6 2c       	mov	r14, r6
    1b4a:	f7 2c       	mov	r15, r7
    1b4c:	08 2d       	mov	r16, r8
    1b4e:	19 2d       	mov	r17, r9
    1b50:	2a 2d       	mov	r18, r10
    1b52:	3b 2d       	mov	r19, r11
    1b54:	4c 2d       	mov	r20, r12
    1b56:	5d 2d       	mov	r21, r13
    1b58:	6e 2d       	mov	r22, r14
    1b5a:	7f 2d       	mov	r23, r15
    1b5c:	80 2f       	mov	r24, r16
    1b5e:	91 2f       	mov	r25, r17
    1b60:	01 e0       	ldi	r16, 0x01	; 1
    1b62:	0e 94 53 54 	call	0xa8a6	; 0xa8a6 <__ashldi3>
    1b66:	22 2e       	mov	r2, r18
    1b68:	33 2e       	mov	r3, r19
    1b6a:	44 2e       	mov	r4, r20
    1b6c:	55 2e       	mov	r5, r21
    1b6e:	66 2e       	mov	r6, r22
    1b70:	77 2e       	mov	r7, r23
    1b72:	88 2e       	mov	r8, r24
    1b74:	99 2e       	mov	r9, r25
    1b76:	a2 2c       	mov	r10, r2
    1b78:	b3 2c       	mov	r11, r3
    1b7a:	c4 2c       	mov	r12, r4
    1b7c:	d5 2c       	mov	r13, r5
    1b7e:	e6 2c       	mov	r14, r6
    1b80:	f7 2c       	mov	r15, r7
    1b82:	08 2d       	mov	r16, r8
    1b84:	19 2d       	mov	r17, r9
    1b86:	2a 2d       	mov	r18, r10
    1b88:	3b 2d       	mov	r19, r11
    1b8a:	4c 2d       	mov	r20, r12
    1b8c:	5d 2d       	mov	r21, r13
    1b8e:	6e 2d       	mov	r22, r14
    1b90:	7f 2d       	mov	r23, r15
    1b92:	80 2f       	mov	r24, r16
    1b94:	91 2f       	mov	r25, r17
    1b96:	0f 2e       	mov	r0, r31
    1b98:	f3 e0       	ldi	r31, 0x03	; 3
    1b9a:	af 2e       	mov	r10, r31
    1b9c:	f0 2d       	mov	r31, r0
    1b9e:	bb 24       	eor	r11, r11
    1ba0:	cc 24       	eor	r12, r12
    1ba2:	dd 24       	eor	r13, r13
    1ba4:	ee 24       	eor	r14, r14
    1ba6:	ff 24       	eor	r15, r15
    1ba8:	00 e0       	ldi	r16, 0x00	; 0
    1baa:	10 e0       	ldi	r17, 0x00	; 0
    1bac:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    1bb0:	a2 2e       	mov	r10, r18
    1bb2:	b3 2e       	mov	r11, r19
    1bb4:	c4 2e       	mov	r12, r20
    1bb6:	d5 2e       	mov	r13, r21
    1bb8:	e6 2e       	mov	r14, r22
    1bba:	f7 2e       	mov	r15, r23
    1bbc:	08 2f       	mov	r16, r24
    1bbe:	19 2f       	mov	r17, r25
    1bc0:	2a 2d       	mov	r18, r10
    1bc2:	3b 2d       	mov	r19, r11
    1bc4:	4c 2d       	mov	r20, r12
    1bc6:	5d 2d       	mov	r21, r13
    1bc8:	6e 2d       	mov	r22, r14
    1bca:	7f 2d       	mov	r23, r15
    1bcc:	80 2f       	mov	r24, r16
    1bce:	91 2f       	mov	r25, r17
    1bd0:	da 01       	movw	r26, r20
    1bd2:	c9 01       	movw	r24, r18
    1bd4:	b0 95       	com	r27
    1bd6:	a0 95       	com	r26
    1bd8:	90 95       	com	r25
    1bda:	81 95       	neg	r24
    1bdc:	9f 4f       	sbci	r25, 0xFF	; 255
    1bde:	af 4f       	sbci	r26, 0xFF	; 255
    1be0:	bf 4f       	sbci	r27, 0xFF	; 255
    1be2:	2f a1       	lds	r18, 0x4f
    1be4:	38 a5       	lds	r19, 0x68
    1be6:	f9 01       	movw	r30, r18
    1be8:	80 83       	st	Z, r24
    1bea:	91 83       	std	Z+1, r25	; 0x01
    1bec:	a2 83       	std	Z+2, r26	; 0x02
    1bee:	b3 83       	std	Z+3, r27	; 0x03

}
    1bf0:	ec 96       	adiw	r28, 0x3c	; 60
    1bf2:	cd bf       	out	0x3d, r28	; 61
    1bf4:	de bf       	out	0x3e, r29	; 62
    1bf6:	df 91       	pop	r29
    1bf8:	cf 91       	pop	r28
    1bfa:	1f 91       	pop	r17
    1bfc:	0f 91       	pop	r16
    1bfe:	ff 90       	pop	r15
    1c00:	ef 90       	pop	r14
    1c02:	df 90       	pop	r13
    1c04:	cf 90       	pop	r12
    1c06:	bf 90       	pop	r11
    1c08:	af 90       	pop	r10
    1c0a:	9f 90       	pop	r9
    1c0c:	8f 90       	pop	r8
    1c0e:	7f 90       	pop	r7
    1c10:	6f 90       	pop	r6
    1c12:	5f 90       	pop	r5
    1c14:	4f 90       	pop	r4
    1c16:	3f 90       	pop	r3
    1c18:	2f 90       	pop	r2
    1c1a:	08 95       	ret

00001c1c <CO_collectADC_cont>:

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	00 d0       	rcall	.+0      	; 0x1c22 <CO_collectADC_cont+0x6>
    1c22:	00 d0       	rcall	.+0      	; 0x1c24 <CO_collectADC_cont+0x8>
    1c24:	cd b7       	in	r28, 0x3d	; 61
    1c26:	de b7       	in	r29, 0x3e	; 62
    1c28:	8b 83       	std	Y+3, r24	; 0x03
    1c2a:	6c 83       	std	Y+4, r22	; 0x04
    1c2c:	4d 83       	std	Y+5, r20	; 0x05
    1c2e:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1c30:	81 e0       	ldi	r24, 0x01	; 1
    1c32:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
//get data to write files to SD card
getBootSectorData();
    1c36:	0e 94 83 41 	call	0x8306	; 0x8306 <getBootSectorData>
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3c:	6d 81       	ldd	r22, Y+5	; 0x05
    1c3e:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
set_filter(filterConfig);
    1c42:	8c 81       	ldd	r24, Y+4	; 0x04
    1c44:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1c48:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4a:	85 30       	cpi	r24, 0x05	; 5
    1c4c:	31 f0       	breq	.+12     	; 0x1c5a <CO_collectADC_cont+0x3e>
    1c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c50:	86 30       	cpi	r24, 0x06	; 6
    1c52:	19 f0       	breq	.+6      	; 0x1c5a <CO_collectADC_cont+0x3e>
    1c54:	8b 81       	ldd	r24, Y+3	; 0x03
    1c56:	87 30       	cpi	r24, 0x07	; 7
    1c58:	19 f4       	brne	.+6      	; 0x1c60 <CO_collectADC_cont+0x44>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1c5a:	81 e0       	ldi	r24, 0x01	; 1
    1c5c:	0e 94 38 11 	call	0x2270	; 0x2270 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
setADCInput(channel);
    1c66:	8b 81       	ldd	r24, Y+3	; 0x03
    1c68:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1c6c:	84 e0       	ldi	r24, 0x04	; 4
    1c6e:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1c72:	80 ec       	ldi	r24, 0xC0	; 192
    1c74:	98 e0       	ldi	r25, 0x08	; 8
    1c76:	24 e5       	ldi	r18, 0x54	; 84
    1c78:	fc 01       	movw	r30, r24
    1c7a:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1c7c:	80 ea       	ldi	r24, 0xA0	; 160
    1c7e:	96 e0       	ldi	r25, 0x06	; 6
    1c80:	21 e0       	ldi	r18, 0x01	; 1
    1c82:	fc 01       	movw	r30, r24
    1c84:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1c86:	80 ea       	ldi	r24, 0xA0	; 160
    1c88:	96 e0       	ldi	r25, 0x06	; 6
    1c8a:	22 e0       	ldi	r18, 0x02	; 2
    1c8c:	fc 01       	movw	r30, r24
    1c8e:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    1c90:	80 ea       	ldi	r24, 0xA0	; 160
    1c92:	96 e0       	ldi	r25, 0x06	; 6
    1c94:	21 e0       	ldi	r18, 0x01	; 1
    1c96:	fc 01       	movw	r30, r24
    1c98:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_LO_gc;
    1c9a:	80 ea       	ldi	r24, 0xA0	; 160
    1c9c:	96 e0       	ldi	r25, 0x06	; 6
    1c9e:	24 e0       	ldi	r18, 0x04	; 4
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    1ca4:	80 e8       	ldi	r24, 0x80	; 128
    1ca6:	96 e0       	ldi	r25, 0x06	; 6
    1ca8:	20 e2       	ldi	r18, 0x20	; 32
    1caa:	fc 01       	movw	r30, r24
    1cac:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1cae:	80 e4       	ldi	r24, 0x40	; 64
    1cb0:	9a e0       	ldi	r25, 0x0A	; 10
    1cb2:	23 e2       	ldi	r18, 0x23	; 35
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1cb8:	8e 81       	ldd	r24, Y+6	; 0x06
    1cba:	88 2f       	mov	r24, r24
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	25 e1       	ldi	r18, 0x15	; 21
    1cc0:	30 e0       	ldi	r19, 0x00	; 0
    1cc2:	28 1b       	sub	r18, r24
    1cc4:	39 0b       	sbc	r19, r25
    1cc6:	81 e0       	ldi	r24, 0x01	; 1
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	02 c0       	rjmp	.+4      	; 0x1cd0 <CO_collectADC_cont+0xb4>
    1ccc:	88 0f       	add	r24, r24
    1cce:	99 1f       	adc	r25, r25
    1cd0:	2a 95       	dec	r18
    1cd2:	e2 f7       	brpl	.-8      	; 0x1ccc <CO_collectADC_cont+0xb0>
    1cd4:	01 97       	sbiw	r24, 0x01	; 1
    1cd6:	89 83       	std	Y+1, r24	; 0x01
    1cd8:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1cda:	80 e4       	ldi	r24, 0x40	; 64
    1cdc:	9a e0       	ldi	r25, 0x0A	; 10
    1cde:	29 81       	ldd	r18, Y+1	; 0x01
    1ce0:	3a 81       	ldd	r19, Y+2	; 0x02
    1ce2:	fc 01       	movw	r30, r24
    1ce4:	26 a3       	lds	r18, 0x56
    1ce6:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1ce8:	80 e4       	ldi	r24, 0x40	; 64
    1cea:	9a e0       	ldi	r25, 0x0A	; 10
    1cec:	29 81       	ldd	r18, Y+1	; 0x01
    1cee:	3a 81       	ldd	r19, Y+2	; 0x02
    1cf0:	36 95       	lsr	r19
    1cf2:	27 95       	ror	r18
    1cf4:	fc 01       	movw	r30, r24
    1cf6:	22 af       	sts	0x72, r18
    1cf8:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1cfa:	80 e4       	ldi	r24, 0x40	; 64
    1cfc:	9a e0       	ldi	r25, 0x0A	; 10
    1cfe:	20 e4       	ldi	r18, 0x40	; 64
    1d00:	3a e0       	ldi	r19, 0x0A	; 10
    1d02:	f9 01       	movw	r30, r18
    1d04:	20 81       	ld	r18, Z
    1d06:	20 7f       	andi	r18, 0xF0	; 240
    1d08:	21 60       	ori	r18, 0x01	; 1
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1d0e:	80 ea       	ldi	r24, 0xA0	; 160
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	20 ea       	ldi	r18, 0xA0	; 160
    1d14:	30 e0       	ldi	r19, 0x00	; 0
    1d16:	f9 01       	movw	r30, r18
    1d18:	22 81       	ldd	r18, Z+2	; 0x02
    1d1a:	21 60       	ori	r18, 0x01	; 1
    1d1c:	fc 01       	movw	r30, r24
    1d1e:	22 83       	std	Z+2, r18	; 0x02
sei();
    1d20:	78 94       	sei

sampleCount = 0;
    1d22:	10 92 67 50 	sts	0x5067, r1
    1d26:	10 92 68 50 	sts	0x5068, r1
TotalSampleCount = 0;
    1d2a:	10 92 95 50 	sts	0x5095, r1
    1d2e:	10 92 96 50 	sts	0x5096, r1
discardCount = 0;
    1d32:	10 92 52 40 	sts	0x4052, r1
}
    1d36:	26 96       	adiw	r28, 0x06	; 6
    1d38:	cd bf       	out	0x3d, r28	; 61
    1d3a:	de bf       	out	0x3e, r29	; 62
    1d3c:	df 91       	pop	r29
    1d3e:	cf 91       	pop	r28
    1d40:	08 95       	ret

00001d42 <ADC_Pause_Sampling>:


void ADC_Pause_Sampling(){
    1d42:	cf 93       	push	r28
    1d44:	df 93       	push	r29
    1d46:	cd b7       	in	r28, 0x3d	; 61
    1d48:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1d4a:	80 ea       	ldi	r24, 0xA0	; 160
    1d4c:	96 e0       	ldi	r25, 0x06	; 6
    1d4e:	fc 01       	movw	r30, r24
    1d50:	13 86       	std	Z+11, r1	; 0x0b
}
    1d52:	df 91       	pop	r29
    1d54:	cf 91       	pop	r28
    1d56:	08 95       	ret

00001d58 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    1d58:	cf 93       	push	r28
    1d5a:	df 93       	push	r29
    1d5c:	cd b7       	in	r28, 0x3d	; 61
    1d5e:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1d60:	80 ea       	ldi	r24, 0xA0	; 160
    1d62:	96 e0       	ldi	r25, 0x06	; 6
    1d64:	21 e0       	ldi	r18, 0x01	; 1
    1d66:	fc 01       	movw	r30, r24
    1d68:	23 87       	std	Z+11, r18	; 0x0b
}	
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	08 95       	ret

00001d70 <__vector_105>:
ISR(PORTF_INT1_vect) {
    1d70:	1f 92       	push	r1
    1d72:	0f 92       	push	r0
    1d74:	0f b6       	in	r0, 0x3f	; 63
    1d76:	0f 92       	push	r0
    1d78:	00 90 3b 00 	lds	r0, 0x003B
    1d7c:	0f 92       	push	r0
    1d7e:	11 24       	eor	r1, r1
    1d80:	2f 92       	push	r2
    1d82:	3f 92       	push	r3
    1d84:	4f 92       	push	r4
    1d86:	5f 92       	push	r5
    1d88:	6f 92       	push	r6
    1d8a:	7f 92       	push	r7
    1d8c:	8f 92       	push	r8
    1d8e:	9f 92       	push	r9
    1d90:	af 92       	push	r10
    1d92:	bf 92       	push	r11
    1d94:	cf 92       	push	r12
    1d96:	df 92       	push	r13
    1d98:	ef 92       	push	r14
    1d9a:	ff 92       	push	r15
    1d9c:	0f 93       	push	r16
    1d9e:	1f 93       	push	r17
    1da0:	2f 93       	push	r18
    1da2:	3f 93       	push	r19
    1da4:	4f 93       	push	r20
    1da6:	5f 93       	push	r21
    1da8:	6f 93       	push	r22
    1daa:	7f 93       	push	r23
    1dac:	8f 93       	push	r24
    1dae:	9f 93       	push	r25
    1db0:	af 93       	push	r26
    1db2:	bf 93       	push	r27
    1db4:	ef 93       	push	r30
    1db6:	ff 93       	push	r31
    1db8:	cf 93       	push	r28
    1dba:	df 93       	push	r29
    1dbc:	00 d0       	rcall	.+0      	; 0x1dbe <__vector_105+0x4e>
    1dbe:	cd b7       	in	r28, 0x3d	; 61
    1dc0:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if(TotalSampleCount>=10){
    1dc2:	80 91 95 50 	lds	r24, 0x5095
    1dc6:	90 91 96 50 	lds	r25, 0x5096
    1dca:	8a 30       	cpi	r24, 0x0A	; 10
    1dcc:	91 05       	cpc	r25, r1
    1dce:	20 f0       	brcs	.+8      	; 0x1dd8 <__vector_105+0x68>
		SD_disable();
    1dd0:	0e 94 10 53 	call	0xa620	; 0xa620 <SD_disable>
		while(1){
			nop();
    1dd4:	00 00       	nop
		}		
    1dd6:	fe cf       	rjmp	.-4      	; 0x1dd4 <__vector_105+0x64>
	}		
	if (discardCount < ADC_DISCARD) {
    1dd8:	80 91 52 40 	lds	r24, 0x4052
    1ddc:	88 23       	and	r24, r24
    1dde:	34 f0       	brlt	.+12     	; 0x1dec <__vector_105+0x7c>
		discardCount++;
    1de0:	80 91 52 40 	lds	r24, 0x4052
    1de4:	8f 5f       	subi	r24, 0xFF	; 255
    1de6:	80 93 52 40 	sts	0x4052, r24
    1dea:	5b c1       	rjmp	.+694    	; 0x20a2 <__vector_105+0x332>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1dec:	84 e0       	ldi	r24, 0x04	; 4
    1dee:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1df2:	80 ec       	ldi	r24, 0xC0	; 192
    1df4:	98 e0       	ldi	r25, 0x08	; 8
    1df6:	24 e5       	ldi	r18, 0x54	; 84
    1df8:	fc 01       	movw	r30, r24
    1dfa:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1dfc:	81 e0       	ldi	r24, 0x01	; 1
    1dfe:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1e02:	80 ea       	ldi	r24, 0xA0	; 160
    1e04:	96 e0       	ldi	r25, 0x06	; 6
    1e06:	22 e0       	ldi	r18, 0x02	; 2
    1e08:	fc 01       	movw	r30, r24
    1e0a:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1e0c:	19 82       	std	Y+1, r1	; 0x01
    1e0e:	1a c0       	rjmp	.+52     	; 0x1e44 <__vector_105+0xd4>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1e10:	80 ec       	ldi	r24, 0xC0	; 192
    1e12:	98 e0       	ldi	r25, 0x08	; 8
    1e14:	2a ea       	ldi	r18, 0xAA	; 170
    1e16:	fc 01       	movw	r30, r24
    1e18:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1e1a:	00 00       	nop
    1e1c:	80 ec       	ldi	r24, 0xC0	; 192
    1e1e:	98 e0       	ldi	r25, 0x08	; 8
    1e20:	fc 01       	movw	r30, r24
    1e22:	82 81       	ldd	r24, Z+2	; 0x02
    1e24:	88 23       	and	r24, r24
    1e26:	d4 f7       	brge	.-12     	; 0x1e1c <__vector_105+0xac>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1e28:	89 81       	ldd	r24, Y+1	; 0x01
    1e2a:	88 2f       	mov	r24, r24
    1e2c:	90 e0       	ldi	r25, 0x00	; 0
    1e2e:	20 ec       	ldi	r18, 0xC0	; 192
    1e30:	38 e0       	ldi	r19, 0x08	; 8
    1e32:	f9 01       	movw	r30, r18
    1e34:	23 81       	ldd	r18, Z+3	; 0x03
    1e36:	86 5a       	subi	r24, 0xA6	; 166
    1e38:	9f 4a       	sbci	r25, 0xAF	; 175
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1e3e:	89 81       	ldd	r24, Y+1	; 0x01
    1e40:	8f 5f       	subi	r24, 0xFF	; 255
    1e42:	89 83       	std	Y+1, r24	; 0x01
    1e44:	89 81       	ldd	r24, Y+1	; 0x01
    1e46:	83 30       	cpi	r24, 0x03	; 3
    1e48:	18 f3       	brcs	.-58     	; 0x1e10 <__vector_105+0xa0>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1e4a:	80 ea       	ldi	r24, 0xA0	; 160
    1e4c:	96 e0       	ldi	r25, 0x06	; 6
    1e4e:	22 e0       	ldi	r18, 0x02	; 2
    1e50:	fc 01       	movw	r30, r24
    1e52:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1e54:	80 e0       	ldi	r24, 0x00	; 0
    1e56:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1e5a:	80 91 5a 50 	lds	r24, 0x505A
    1e5e:	88 23       	and	r24, r24
    1e60:	34 f4       	brge	.+12     	; 0x1e6e <__vector_105+0xfe>
    1e62:	8b e5       	ldi	r24, 0x5B	; 91
    1e64:	90 e4       	ldi	r25, 0x40	; 64
    1e66:	2f ef       	ldi	r18, 0xFF	; 255
    1e68:	fc 01       	movw	r30, r24
    1e6a:	20 83       	st	Z, r18
    1e6c:	04 c0       	rjmp	.+8      	; 0x1e76 <__vector_105+0x106>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    1e6e:	8b e5       	ldi	r24, 0x5B	; 91
    1e70:	90 e4       	ldi	r25, 0x40	; 64
    1e72:	fc 01       	movw	r30, r24
    1e74:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1e76:	8a e5       	ldi	r24, 0x5A	; 90
    1e78:	90 e4       	ldi	r25, 0x40	; 64
    1e7a:	20 91 5a 50 	lds	r18, 0x505A
    1e7e:	fc 01       	movw	r30, r24
    1e80:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1e82:	89 e5       	ldi	r24, 0x59	; 89
    1e84:	90 e4       	ldi	r25, 0x40	; 64
    1e86:	20 91 5b 50 	lds	r18, 0x505B
    1e8a:	fc 01       	movw	r30, r24
    1e8c:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    1e8e:	88 e5       	ldi	r24, 0x58	; 88
    1e90:	90 e4       	ldi	r25, 0x40	; 64
    1e92:	20 91 5c 50 	lds	r18, 0x505C
    1e96:	fc 01       	movw	r30, r24
    1e98:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    1e9a:	80 91 58 40 	lds	r24, 0x4058
    1e9e:	90 91 59 40 	lds	r25, 0x4059
    1ea2:	a0 91 5a 40 	lds	r26, 0x405A
    1ea6:	b0 91 5b 40 	lds	r27, 0x405B
    1eaa:	5c 01       	movw	r10, r24
    1eac:	6d 01       	movw	r12, r26
    1eae:	bb 0f       	add	r27, r27
    1eb0:	88 0b       	sbc	r24, r24
    1eb2:	98 2f       	mov	r25, r24
    1eb4:	dc 01       	movw	r26, r24
    1eb6:	e8 2e       	mov	r14, r24
    1eb8:	f8 2e       	mov	r15, r24
    1eba:	08 2f       	mov	r16, r24
    1ebc:	18 2f       	mov	r17, r24
    1ebe:	a0 92 97 50 	sts	0x5097, r10
    1ec2:	b0 92 98 50 	sts	0x5098, r11
    1ec6:	c0 92 99 50 	sts	0x5099, r12
    1eca:	d0 92 9a 50 	sts	0x509A, r13
    1ece:	e0 92 9b 50 	sts	0x509B, r14
    1ed2:	f0 92 9c 50 	sts	0x509C, r15
    1ed6:	00 93 9d 50 	sts	0x509D, r16
    1eda:	10 93 9e 50 	sts	0x509E, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1ede:	80 91 67 50 	lds	r24, 0x5067
    1ee2:	90 91 68 50 	lds	r25, 0x5068
    1ee6:	88 0f       	add	r24, r24
    1ee8:	99 1f       	adc	r25, r25
    1eea:	88 0f       	add	r24, r24
    1eec:	99 1f       	adc	r25, r25
    1eee:	9c 01       	movw	r18, r24
    1ef0:	2c 52       	subi	r18, 0x2C	; 44
    1ef2:	3c 4d       	sbci	r19, 0xDC	; 220
    1ef4:	2a 83       	std	Y+2, r18	; 0x02
    1ef6:	3b 83       	std	Y+3, r19	; 0x03
    1ef8:	a0 90 97 50 	lds	r10, 0x5097
    1efc:	b0 90 98 50 	lds	r11, 0x5098
    1f00:	c0 90 99 50 	lds	r12, 0x5099
    1f04:	d0 90 9a 50 	lds	r13, 0x509A
    1f08:	e0 90 9b 50 	lds	r14, 0x509B
    1f0c:	f0 90 9c 50 	lds	r15, 0x509C
    1f10:	00 91 9d 50 	lds	r16, 0x509D
    1f14:	10 91 9e 50 	lds	r17, 0x509E
    1f18:	2a 2d       	mov	r18, r10
    1f1a:	3b 2d       	mov	r19, r11
    1f1c:	4c 2d       	mov	r20, r12
    1f1e:	5d 2d       	mov	r21, r13
    1f20:	6e 2d       	mov	r22, r14
    1f22:	7f 2d       	mov	r23, r15
    1f24:	80 2f       	mov	r24, r16
    1f26:	91 2f       	mov	r25, r17
    1f28:	0f 2e       	mov	r0, r31
    1f2a:	f0 ea       	ldi	r31, 0xA0	; 160
    1f2c:	af 2e       	mov	r10, r31
    1f2e:	f0 2d       	mov	r31, r0
    1f30:	0f 2e       	mov	r0, r31
    1f32:	f5 e2       	ldi	r31, 0x25	; 37
    1f34:	bf 2e       	mov	r11, r31
    1f36:	f0 2d       	mov	r31, r0
    1f38:	0f 2e       	mov	r0, r31
    1f3a:	f6 e2       	ldi	r31, 0x26	; 38
    1f3c:	cf 2e       	mov	r12, r31
    1f3e:	f0 2d       	mov	r31, r0
    1f40:	dd 24       	eor	r13, r13
    1f42:	ee 24       	eor	r14, r14
    1f44:	ff 24       	eor	r15, r15
    1f46:	00 e0       	ldi	r16, 0x00	; 0
    1f48:	10 e0       	ldi	r17, 0x00	; 0
    1f4a:	0e 94 80 53 	call	0xa700	; 0xa700 <__muldi3>
    1f4e:	22 2e       	mov	r2, r18
    1f50:	33 2e       	mov	r3, r19
    1f52:	44 2e       	mov	r4, r20
    1f54:	55 2e       	mov	r5, r21
    1f56:	66 2e       	mov	r6, r22
    1f58:	77 2e       	mov	r7, r23
    1f5a:	88 2e       	mov	r8, r24
    1f5c:	99 2e       	mov	r9, r25
    1f5e:	a2 2c       	mov	r10, r2
    1f60:	b3 2c       	mov	r11, r3
    1f62:	c4 2c       	mov	r12, r4
    1f64:	d5 2c       	mov	r13, r5
    1f66:	e6 2c       	mov	r14, r6
    1f68:	f7 2c       	mov	r15, r7
    1f6a:	08 2d       	mov	r16, r8
    1f6c:	19 2d       	mov	r17, r9
    1f6e:	2a 2d       	mov	r18, r10
    1f70:	3b 2d       	mov	r19, r11
    1f72:	4c 2d       	mov	r20, r12
    1f74:	5d 2d       	mov	r21, r13
    1f76:	6e 2d       	mov	r22, r14
    1f78:	7f 2d       	mov	r23, r15
    1f7a:	80 2f       	mov	r24, r16
    1f7c:	91 2f       	mov	r25, r17
    1f7e:	aa 24       	eor	r10, r10
    1f80:	aa 94       	dec	r10
    1f82:	bb 24       	eor	r11, r11
    1f84:	ba 94       	dec	r11
    1f86:	0f 2e       	mov	r0, r31
    1f88:	ff e7       	ldi	r31, 0x7F	; 127
    1f8a:	cf 2e       	mov	r12, r31
    1f8c:	f0 2d       	mov	r31, r0
    1f8e:	dd 24       	eor	r13, r13
    1f90:	ee 24       	eor	r14, r14
    1f92:	ff 24       	eor	r15, r15
    1f94:	00 e0       	ldi	r16, 0x00	; 0
    1f96:	10 e0       	ldi	r17, 0x00	; 0
    1f98:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    1f9c:	22 2e       	mov	r2, r18
    1f9e:	33 2e       	mov	r3, r19
    1fa0:	44 2e       	mov	r4, r20
    1fa2:	55 2e       	mov	r5, r21
    1fa4:	66 2e       	mov	r6, r22
    1fa6:	77 2e       	mov	r7, r23
    1fa8:	88 2e       	mov	r8, r24
    1faa:	99 2e       	mov	r9, r25
    1fac:	a2 2c       	mov	r10, r2
    1fae:	b3 2c       	mov	r11, r3
    1fb0:	c4 2c       	mov	r12, r4
    1fb2:	d5 2c       	mov	r13, r5
    1fb4:	e6 2c       	mov	r14, r6
    1fb6:	f7 2c       	mov	r15, r7
    1fb8:	08 2d       	mov	r16, r8
    1fba:	19 2d       	mov	r17, r9
    1fbc:	2a 2d       	mov	r18, r10
    1fbe:	3b 2d       	mov	r19, r11
    1fc0:	4c 2d       	mov	r20, r12
    1fc2:	5d 2d       	mov	r21, r13
    1fc4:	6e 2d       	mov	r22, r14
    1fc6:	7f 2d       	mov	r23, r15
    1fc8:	80 2f       	mov	r24, r16
    1fca:	91 2f       	mov	r25, r17
    1fcc:	01 e0       	ldi	r16, 0x01	; 1
    1fce:	0e 94 53 54 	call	0xa8a6	; 0xa8a6 <__ashldi3>
    1fd2:	22 2e       	mov	r2, r18
    1fd4:	33 2e       	mov	r3, r19
    1fd6:	44 2e       	mov	r4, r20
    1fd8:	55 2e       	mov	r5, r21
    1fda:	66 2e       	mov	r6, r22
    1fdc:	77 2e       	mov	r7, r23
    1fde:	88 2e       	mov	r8, r24
    1fe0:	99 2e       	mov	r9, r25
    1fe2:	a2 2c       	mov	r10, r2
    1fe4:	b3 2c       	mov	r11, r3
    1fe6:	c4 2c       	mov	r12, r4
    1fe8:	d5 2c       	mov	r13, r5
    1fea:	e6 2c       	mov	r14, r6
    1fec:	f7 2c       	mov	r15, r7
    1fee:	08 2d       	mov	r16, r8
    1ff0:	19 2d       	mov	r17, r9
    1ff2:	2a 2d       	mov	r18, r10
    1ff4:	3b 2d       	mov	r19, r11
    1ff6:	4c 2d       	mov	r20, r12
    1ff8:	5d 2d       	mov	r21, r13
    1ffa:	6e 2d       	mov	r22, r14
    1ffc:	7f 2d       	mov	r23, r15
    1ffe:	80 2f       	mov	r24, r16
    2000:	91 2f       	mov	r25, r17
    2002:	0f 2e       	mov	r0, r31
    2004:	f3 e0       	ldi	r31, 0x03	; 3
    2006:	af 2e       	mov	r10, r31
    2008:	f0 2d       	mov	r31, r0
    200a:	bb 24       	eor	r11, r11
    200c:	cc 24       	eor	r12, r12
    200e:	dd 24       	eor	r13, r13
    2010:	ee 24       	eor	r14, r14
    2012:	ff 24       	eor	r15, r15
    2014:	00 e0       	ldi	r16, 0x00	; 0
    2016:	10 e0       	ldi	r17, 0x00	; 0
    2018:	0e 94 2f 55 	call	0xaa5e	; 0xaa5e <__divdi3>
    201c:	a2 2e       	mov	r10, r18
    201e:	b3 2e       	mov	r11, r19
    2020:	c4 2e       	mov	r12, r20
    2022:	d5 2e       	mov	r13, r21
    2024:	e6 2e       	mov	r14, r22
    2026:	f7 2e       	mov	r15, r23
    2028:	08 2f       	mov	r16, r24
    202a:	19 2f       	mov	r17, r25
    202c:	2a 2d       	mov	r18, r10
    202e:	3b 2d       	mov	r19, r11
    2030:	4c 2d       	mov	r20, r12
    2032:	5d 2d       	mov	r21, r13
    2034:	6e 2d       	mov	r22, r14
    2036:	7f 2d       	mov	r23, r15
    2038:	80 2f       	mov	r24, r16
    203a:	91 2f       	mov	r25, r17
    203c:	da 01       	movw	r26, r20
    203e:	c9 01       	movw	r24, r18
    2040:	b0 95       	com	r27
    2042:	a0 95       	com	r26
    2044:	90 95       	com	r25
    2046:	81 95       	neg	r24
    2048:	9f 4f       	sbci	r25, 0xFF	; 255
    204a:	af 4f       	sbci	r26, 0xFF	; 255
    204c:	bf 4f       	sbci	r27, 0xFF	; 255
    204e:	ea 81       	ldd	r30, Y+2	; 0x02
    2050:	fb 81       	ldd	r31, Y+3	; 0x03
    2052:	80 83       	st	Z, r24
    2054:	91 83       	std	Z+1, r25	; 0x01
    2056:	a2 83       	std	Z+2, r26	; 0x02
    2058:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    205a:	80 91 67 50 	lds	r24, 0x5067
    205e:	90 91 68 50 	lds	r25, 0x5068
    2062:	01 96       	adiw	r24, 0x01	; 1
    2064:	80 93 67 50 	sts	0x5067, r24
    2068:	90 93 68 50 	sts	0x5068, r25
	//after 128 samples, store the data into sd card and reset sample buffer
	if (sampleCount >= 128) { 
    206c:	80 91 67 50 	lds	r24, 0x5067
    2070:	90 91 68 50 	lds	r25, 0x5068
    2074:	80 38       	cpi	r24, 0x80	; 128
    2076:	91 05       	cpc	r25, r1
    2078:	a0 f0       	brcs	.+40     	; 0x20a2 <__vector_105+0x332>
		//SPIInit(SPI_MODE_0_gc);
		//SPICS(TRUE);
		//PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS low
		//PortEx_OUTCLR(BIT3_bm, PS_BANKB);
		//writeFile("samples");
		writeFile("data",0); 
    207a:	8c e0       	ldi	r24, 0x0C	; 12
    207c:	90 e2       	ldi	r25, 0x20	; 32
    207e:	40 e0       	ldi	r20, 0x00	; 0
    2080:	50 e0       	ldi	r21, 0x00	; 0
    2082:	ba 01       	movw	r22, r20
    2084:	0e 94 18 48 	call	0x9030	; 0x9030 <writeFile>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    2088:	10 92 67 50 	sts	0x5067, r1
    208c:	10 92 68 50 	sts	0x5068, r1
		TotalSampleCount++;
    2090:	80 91 95 50 	lds	r24, 0x5095
    2094:	90 91 96 50 	lds	r25, 0x5096
    2098:	01 96       	adiw	r24, 0x01	; 1
    209a:	80 93 95 50 	sts	0x5095, r24
    209e:	90 93 96 50 	sts	0x5096, r25
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
	}	
	}	
}
    20a2:	23 96       	adiw	r28, 0x03	; 3
    20a4:	cd bf       	out	0x3d, r28	; 61
    20a6:	de bf       	out	0x3e, r29	; 62
    20a8:	df 91       	pop	r29
    20aa:	cf 91       	pop	r28
    20ac:	ff 91       	pop	r31
    20ae:	ef 91       	pop	r30
    20b0:	bf 91       	pop	r27
    20b2:	af 91       	pop	r26
    20b4:	9f 91       	pop	r25
    20b6:	8f 91       	pop	r24
    20b8:	7f 91       	pop	r23
    20ba:	6f 91       	pop	r22
    20bc:	5f 91       	pop	r21
    20be:	4f 91       	pop	r20
    20c0:	3f 91       	pop	r19
    20c2:	2f 91       	pop	r18
    20c4:	1f 91       	pop	r17
    20c6:	0f 91       	pop	r16
    20c8:	ff 90       	pop	r15
    20ca:	ef 90       	pop	r14
    20cc:	df 90       	pop	r13
    20ce:	cf 90       	pop	r12
    20d0:	bf 90       	pop	r11
    20d2:	af 90       	pop	r10
    20d4:	9f 90       	pop	r9
    20d6:	8f 90       	pop	r8
    20d8:	7f 90       	pop	r7
    20da:	6f 90       	pop	r6
    20dc:	5f 90       	pop	r5
    20de:	4f 90       	pop	r4
    20e0:	3f 90       	pop	r3
    20e2:	2f 90       	pop	r2
    20e4:	0f 90       	pop	r0
    20e6:	00 92 3b 00 	sts	0x003B, r0
    20ea:	0f 90       	pop	r0
    20ec:	0f be       	out	0x3f, r0	; 63
    20ee:	0f 90       	pop	r0
    20f0:	1f 90       	pop	r1
    20f2:	18 95       	reti

000020f4 <__vector_104>:

ISR(PORTF_INT0_vect) {
    20f4:	1f 92       	push	r1
    20f6:	0f 92       	push	r0
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	0f 92       	push	r0
    20fc:	00 90 3b 00 	lds	r0, 0x003B
    2100:	0f 92       	push	r0
    2102:	11 24       	eor	r1, r1
    2104:	2f 93       	push	r18
    2106:	3f 93       	push	r19
    2108:	4f 93       	push	r20
    210a:	5f 93       	push	r21
    210c:	6f 93       	push	r22
    210e:	7f 93       	push	r23
    2110:	8f 93       	push	r24
    2112:	9f 93       	push	r25
    2114:	af 93       	push	r26
    2116:	bf 93       	push	r27
    2118:	ef 93       	push	r30
    211a:	ff 93       	push	r31
    211c:	cf 93       	push	r28
    211e:	df 93       	push	r29
    2120:	0f 92       	push	r0
    2122:	cd b7       	in	r28, 0x3d	; 61
    2124:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    2126:	80 91 52 40 	lds	r24, 0x4052
    212a:	88 23       	and	r24, r24
    212c:	34 f0       	brlt	.+12     	; 0x213a <__vector_104+0x46>
		discardCount++;
    212e:	80 91 52 40 	lds	r24, 0x4052
    2132:	8f 5f       	subi	r24, 0xFF	; 255
    2134:	80 93 52 40 	sts	0x4052, r24
    2138:	84 c0       	rjmp	.+264    	; 0x2242 <__vector_104+0x14e>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    213a:	81 e0       	ldi	r24, 0x01	; 1
    213c:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2140:	80 ea       	ldi	r24, 0xA0	; 160
    2142:	96 e0       	ldi	r25, 0x06	; 6
    2144:	22 e0       	ldi	r18, 0x02	; 2
    2146:	fc 01       	movw	r30, r24
    2148:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    214a:	19 82       	std	Y+1, r1	; 0x01
    214c:	1a c0       	rjmp	.+52     	; 0x2182 <__vector_104+0x8e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    214e:	80 ec       	ldi	r24, 0xC0	; 192
    2150:	98 e0       	ldi	r25, 0x08	; 8
    2152:	2a ea       	ldi	r18, 0xAA	; 170
    2154:	fc 01       	movw	r30, r24
    2156:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    2158:	00 00       	nop
    215a:	80 ec       	ldi	r24, 0xC0	; 192
    215c:	98 e0       	ldi	r25, 0x08	; 8
    215e:	fc 01       	movw	r30, r24
    2160:	82 81       	ldd	r24, Z+2	; 0x02
    2162:	88 23       	and	r24, r24
    2164:	d4 f7       	brge	.-12     	; 0x215a <__vector_104+0x66>
			SPIBuffer[bufIndex] = SPIC.DATA;
    2166:	89 81       	ldd	r24, Y+1	; 0x01
    2168:	88 2f       	mov	r24, r24
    216a:	90 e0       	ldi	r25, 0x00	; 0
    216c:	20 ec       	ldi	r18, 0xC0	; 192
    216e:	38 e0       	ldi	r19, 0x08	; 8
    2170:	f9 01       	movw	r30, r18
    2172:	23 81       	ldd	r18, Z+3	; 0x03
    2174:	86 5a       	subi	r24, 0xA6	; 166
    2176:	9f 4a       	sbci	r25, 0xAF	; 175
    2178:	fc 01       	movw	r30, r24
    217a:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	8f 5f       	subi	r24, 0xFF	; 255
    2180:	89 83       	std	Y+1, r24	; 0x01
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	83 30       	cpi	r24, 0x03	; 3
    2186:	18 f3       	brcs	.-58     	; 0x214e <__vector_104+0x5a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2188:	80 ea       	ldi	r24, 0xA0	; 160
    218a:	96 e0       	ldi	r25, 0x06	; 6
    218c:	22 e0       	ldi	r18, 0x02	; 2
    218e:	fc 01       	movw	r30, r24
    2190:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    2192:	80 e0       	ldi	r24, 0x00	; 0
    2194:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    2198:	80 91 5a 50 	lds	r24, 0x505A
    219c:	88 23       	and	r24, r24
    219e:	7c f4       	brge	.+30     	; 0x21be <__vector_104+0xca>
    21a0:	80 91 67 50 	lds	r24, 0x5067
    21a4:	90 91 68 50 	lds	r25, 0x5068
    21a8:	88 0f       	add	r24, r24
    21aa:	99 1f       	adc	r25, r25
    21ac:	88 0f       	add	r24, r24
    21ae:	99 1f       	adc	r25, r25
    21b0:	03 96       	adiw	r24, 0x03	; 3
    21b2:	88 5a       	subi	r24, 0xA8	; 168
    21b4:	9f 4b       	sbci	r25, 0xBF	; 191
    21b6:	2f ef       	ldi	r18, 0xFF	; 255
    21b8:	fc 01       	movw	r30, r24
    21ba:	20 83       	st	Z, r18
    21bc:	0d c0       	rjmp	.+26     	; 0x21d8 <__vector_104+0xe4>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    21be:	80 91 67 50 	lds	r24, 0x5067
    21c2:	90 91 68 50 	lds	r25, 0x5068
    21c6:	88 0f       	add	r24, r24
    21c8:	99 1f       	adc	r25, r25
    21ca:	88 0f       	add	r24, r24
    21cc:	99 1f       	adc	r25, r25
    21ce:	03 96       	adiw	r24, 0x03	; 3
    21d0:	88 5a       	subi	r24, 0xA8	; 168
    21d2:	9f 4b       	sbci	r25, 0xBF	; 191
    21d4:	fc 01       	movw	r30, r24
    21d6:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    21d8:	80 91 67 50 	lds	r24, 0x5067
    21dc:	90 91 68 50 	lds	r25, 0x5068
    21e0:	88 0f       	add	r24, r24
    21e2:	99 1f       	adc	r25, r25
    21e4:	88 0f       	add	r24, r24
    21e6:	99 1f       	adc	r25, r25
    21e8:	02 96       	adiw	r24, 0x02	; 2
    21ea:	88 5a       	subi	r24, 0xA8	; 168
    21ec:	9f 4b       	sbci	r25, 0xBF	; 191
    21ee:	20 91 5a 50 	lds	r18, 0x505A
    21f2:	fc 01       	movw	r30, r24
    21f4:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    21f6:	80 91 67 50 	lds	r24, 0x5067
    21fa:	90 91 68 50 	lds	r25, 0x5068
    21fe:	88 0f       	add	r24, r24
    2200:	99 1f       	adc	r25, r25
    2202:	88 0f       	add	r24, r24
    2204:	99 1f       	adc	r25, r25
    2206:	01 96       	adiw	r24, 0x01	; 1
    2208:	88 5a       	subi	r24, 0xA8	; 168
    220a:	9f 4b       	sbci	r25, 0xBF	; 191
    220c:	20 91 5b 50 	lds	r18, 0x505B
    2210:	fc 01       	movw	r30, r24
    2212:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    2214:	80 91 67 50 	lds	r24, 0x5067
    2218:	90 91 68 50 	lds	r25, 0x5068
    221c:	88 0f       	add	r24, r24
    221e:	99 1f       	adc	r25, r25
    2220:	88 0f       	add	r24, r24
    2222:	99 1f       	adc	r25, r25
    2224:	88 5a       	subi	r24, 0xA8	; 168
    2226:	9f 4b       	sbci	r25, 0xBF	; 191
    2228:	20 91 5c 50 	lds	r18, 0x505C
    222c:	fc 01       	movw	r30, r24
    222e:	20 83       	st	Z, r18

		sampleCount++;
    2230:	80 91 67 50 	lds	r24, 0x5067
    2234:	90 91 68 50 	lds	r25, 0x5068
    2238:	01 96       	adiw	r24, 0x01	; 1
    223a:	80 93 67 50 	sts	0x5067, r24
    223e:	90 93 68 50 	sts	0x5068, r25
	}
}
    2242:	0f 90       	pop	r0
    2244:	df 91       	pop	r29
    2246:	cf 91       	pop	r28
    2248:	ff 91       	pop	r31
    224a:	ef 91       	pop	r30
    224c:	bf 91       	pop	r27
    224e:	af 91       	pop	r26
    2250:	9f 91       	pop	r25
    2252:	8f 91       	pop	r24
    2254:	7f 91       	pop	r23
    2256:	6f 91       	pop	r22
    2258:	5f 91       	pop	r21
    225a:	4f 91       	pop	r20
    225c:	3f 91       	pop	r19
    225e:	2f 91       	pop	r18
    2260:	0f 90       	pop	r0
    2262:	00 92 3b 00 	sts	0x003B, r0
    2266:	0f 90       	pop	r0
    2268:	0f be       	out	0x3f, r0	; 63
    226a:	0f 90       	pop	r0
    226c:	1f 90       	pop	r1
    226e:	18 95       	reti

00002270 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    2270:	cf 93       	push	r28
    2272:	df 93       	push	r29
    2274:	0f 92       	push	r0
    2276:	cd b7       	in	r28, 0x3d	; 61
    2278:	de b7       	in	r29, 0x3e	; 62
    227a:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    227c:	89 81       	ldd	r24, Y+1	; 0x01
    227e:	88 23       	and	r24, r24
    2280:	49 f0       	breq	.+18     	; 0x2294 <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    2282:	80 e2       	ldi	r24, 0x20	; 32
    2284:	60 e0       	ldi	r22, 0x00	; 0
    2286:	0e 94 24 35 	call	0x6a48	; 0x6a48 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    228a:	80 e2       	ldi	r24, 0x20	; 32
    228c:	60 e0       	ldi	r22, 0x00	; 0
    228e:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
    2292:	04 c0       	rjmp	.+8      	; 0x229c <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    2294:	80 e2       	ldi	r24, 0x20	; 32
    2296:	60 e0       	ldi	r22, 0x00	; 0
    2298:	0e 94 88 35 	call	0x6b10	; 0x6b10 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    229c:	0f 90       	pop	r0
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	08 95       	ret

000022a4 <CO_collectSeismic3Channel>:

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    22a4:	8f 92       	push	r8
    22a6:	9f 92       	push	r9
    22a8:	af 92       	push	r10
    22aa:	bf 92       	push	r11
    22ac:	cf 92       	push	r12
    22ae:	df 92       	push	r13
    22b0:	ef 92       	push	r14
    22b2:	ff 92       	push	r15
    22b4:	0f 93       	push	r16
    22b6:	cf 93       	push	r28
    22b8:	df 93       	push	r29
    22ba:	cd b7       	in	r28, 0x3d	; 61
    22bc:	de b7       	in	r29, 0x3e	; 62
    22be:	2e 97       	sbiw	r28, 0x0e	; 14
    22c0:	cd bf       	out	0x3d, r28	; 61
    22c2:	de bf       	out	0x3e, r29	; 62
    22c4:	89 83       	std	Y+1, r24	; 0x01
    22c6:	6a 83       	std	Y+2, r22	; 0x02
    22c8:	7b 83       	std	Y+3, r23	; 0x03
    22ca:	4c 83       	std	Y+4, r20	; 0x04
    22cc:	2d 83       	std	Y+5, r18	; 0x05
    22ce:	0e 83       	std	Y+6, r16	; 0x06
    22d0:	ef 82       	std	Y+7, r14	; 0x07
    22d2:	f8 86       	std	Y+8, r15	; 0x08
    22d4:	c9 86       	std	Y+9, r12	; 0x09
    22d6:	da 86       	std	Y+10, r13	; 0x0a
    22d8:	ab 86       	std	Y+11, r10	; 0x0b
    22da:	bc 86       	std	Y+12, r11	; 0x0c
    22dc:	8d 86       	std	Y+13, r8	; 0x0d
    22de:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    22e0:	81 e0       	ldi	r24, 0x01	; 1
    22e2:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    22e6:	8a 81       	ldd	r24, Y+2	; 0x02
    22e8:	9b 81       	ldd	r25, Y+3	; 0x03
    22ea:	fc 01       	movw	r30, r24
    22ec:	90 81       	ld	r25, Z
    22ee:	85 e0       	ldi	r24, 0x05	; 5
    22f0:	69 2f       	mov	r22, r25
    22f2:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    22f6:	8a 81       	ldd	r24, Y+2	; 0x02
    22f8:	9b 81       	ldd	r25, Y+3	; 0x03
    22fa:	01 96       	adiw	r24, 0x01	; 1
    22fc:	fc 01       	movw	r30, r24
    22fe:	90 81       	ld	r25, Z
    2300:	86 e0       	ldi	r24, 0x06	; 6
    2302:	69 2f       	mov	r22, r25
    2304:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2308:	8a 81       	ldd	r24, Y+2	; 0x02
    230a:	9b 81       	ldd	r25, Y+3	; 0x03
    230c:	02 96       	adiw	r24, 0x02	; 2
    230e:	fc 01       	movw	r30, r24
    2310:	90 81       	ld	r25, Z
    2312:	87 e0       	ldi	r24, 0x07	; 7
    2314:	69 2f       	mov	r22, r25
    2316:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_filter(filterConfig);
    231a:	89 81       	ldd	r24, Y+1	; 0x01
    231c:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2320:	8e 81       	ldd	r24, Y+6	; 0x06
    2322:	0e 94 38 11 	call	0x2270	; 0x2270 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2326:	84 e0       	ldi	r24, 0x04	; 4
    2328:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    232c:	80 ec       	ldi	r24, 0xC0	; 192
    232e:	98 e0       	ldi	r25, 0x08	; 8
    2330:	24 e5       	ldi	r18, 0x54	; 84
    2332:	fc 01       	movw	r30, r24
    2334:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2336:	81 e0       	ldi	r24, 0x01	; 1
    2338:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    233c:	85 e0       	ldi	r24, 0x05	; 5
    233e:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2342:	80 ea       	ldi	r24, 0xA0	; 160
    2344:	96 e0       	ldi	r25, 0x06	; 6
    2346:	22 e0       	ldi	r18, 0x02	; 2
    2348:	fc 01       	movw	r30, r24
    234a:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    234c:	80 ea       	ldi	r24, 0xA0	; 160
    234e:	96 e0       	ldi	r25, 0x06	; 6
    2350:	21 e0       	ldi	r18, 0x01	; 1
    2352:	fc 01       	movw	r30, r24
    2354:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2356:	80 e8       	ldi	r24, 0x80	; 128
    2358:	91 e0       	ldi	r25, 0x01	; 1
    235a:	28 e7       	ldi	r18, 0x78	; 120
    235c:	fc 01       	movw	r30, r24
    235e:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2360:	80 e0       	ldi	r24, 0x00	; 0
    2362:	98 e0       	ldi	r25, 0x08	; 8
    2364:	20 ef       	ldi	r18, 0xF0	; 240
    2366:	fc 01       	movw	r30, r24
    2368:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    236a:	80 e0       	ldi	r24, 0x00	; 0
    236c:	98 e0       	ldi	r25, 0x08	; 8
    236e:	2f 81       	ldd	r18, Y+7	; 0x07
    2370:	38 85       	ldd	r19, Y+8	; 0x08
    2372:	fc 01       	movw	r30, r24
    2374:	20 a7       	lds	r18, 0x70
    2376:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    2378:	80 e0       	ldi	r24, 0x00	; 0
    237a:	98 e0       	ldi	r25, 0x08	; 8
    237c:	29 85       	ldd	r18, Y+9	; 0x09
    237e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2380:	fc 01       	movw	r30, r24
    2382:	22 a7       	lds	r18, 0x72
    2384:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    2386:	80 e0       	ldi	r24, 0x00	; 0
    2388:	98 e0       	ldi	r25, 0x08	; 8
    238a:	2b 85       	ldd	r18, Y+11	; 0x0b
    238c:	3c 85       	ldd	r19, Y+12	; 0x0c
    238e:	fc 01       	movw	r30, r24
    2390:	24 a7       	lds	r18, 0x74
    2392:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    2394:	80 e0       	ldi	r24, 0x00	; 0
    2396:	98 e0       	ldi	r25, 0x08	; 8
    2398:	2d 85       	ldd	r18, Y+13	; 0x0d
    239a:	3e 85       	ldd	r19, Y+14	; 0x0e
    239c:	fc 01       	movw	r30, r24
    239e:	26 a7       	lds	r18, 0x76
    23a0:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    23a2:	80 e0       	ldi	r24, 0x00	; 0
    23a4:	98 e0       	ldi	r25, 0x08	; 8
    23a6:	2d 81       	ldd	r18, Y+5	; 0x05
    23a8:	22 2f       	mov	r18, r18
    23aa:	30 e0       	ldi	r19, 0x00	; 0
    23ac:	21 50       	subi	r18, 0x01	; 1
    23ae:	30 40       	sbci	r19, 0x00	; 0
    23b0:	fc 01       	movw	r30, r24
    23b2:	26 a3       	lds	r18, 0x56
    23b4:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    23b6:	80 e0       	ldi	r24, 0x00	; 0
    23b8:	98 e0       	ldi	r25, 0x08	; 8
    23ba:	22 e0       	ldi	r18, 0x02	; 2
    23bc:	fc 01       	movw	r30, r24
    23be:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    23c0:	80 e0       	ldi	r24, 0x00	; 0
    23c2:	98 e0       	ldi	r25, 0x08	; 8
    23c4:	2f ef       	ldi	r18, 0xFF	; 255
    23c6:	fc 01       	movw	r30, r24
    23c8:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    23ca:	80 e0       	ldi	r24, 0x00	; 0
    23cc:	98 e0       	ldi	r25, 0x08	; 8
    23ce:	20 e0       	ldi	r18, 0x00	; 0
    23d0:	38 e0       	ldi	r19, 0x08	; 8
    23d2:	f9 01       	movw	r30, r18
    23d4:	20 81       	ld	r18, Z
    23d6:	20 7f       	andi	r18, 0xF0	; 240
    23d8:	28 60       	ori	r18, 0x08	; 8
    23da:	fc 01       	movw	r30, r24
    23dc:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    23de:	10 92 4c 40 	sts	0x404C, r1
    23e2:	10 92 4d 40 	sts	0x404D, r1
	sampleCount = 0;
    23e6:	10 92 67 50 	sts	0x5067, r1
    23ea:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    23ee:	10 92 d4 50 	sts	0x50D4, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    23f2:	80 e0       	ldi	r24, 0x00	; 0
    23f4:	80 93 30 21 	sts	0x2130, r24
    23f8:	80 93 2f 21 	sts	0x212F, r24
    23fc:	80 93 2e 21 	sts	0x212E, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2400:	80 ea       	ldi	r24, 0xA0	; 160
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	20 ea       	ldi	r18, 0xA0	; 160
    2406:	30 e0       	ldi	r19, 0x00	; 0
    2408:	f9 01       	movw	r30, r18
    240a:	22 81       	ldd	r18, Z+2	; 0x02
    240c:	26 60       	ori	r18, 0x06	; 6
    240e:	fc 01       	movw	r30, r24
    2410:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2412:	78 94       	sei

	SPICS(TRUE);
    2414:	81 e0       	ldi	r24, 0x01	; 1
    2416:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    241a:	80 e8       	ldi	r24, 0x80	; 128
    241c:	96 e0       	ldi	r25, 0x06	; 6
    241e:	20 e2       	ldi	r18, 0x20	; 32
    2420:	fc 01       	movw	r30, r24
    2422:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2424:	80 e4       	ldi	r24, 0x40	; 64
    2426:	9a e0       	ldi	r25, 0x0A	; 10
    2428:	23 e2       	ldi	r18, 0x23	; 35
    242a:	fc 01       	movw	r30, r24
    242c:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    242e:	80 e4       	ldi	r24, 0x40	; 64
    2430:	9a e0       	ldi	r25, 0x0A	; 10
    2432:	2c 81       	ldd	r18, Y+4	; 0x04
    2434:	42 2f       	mov	r20, r18
    2436:	50 e0       	ldi	r21, 0x00	; 0
    2438:	20 e2       	ldi	r18, 0x20	; 32
    243a:	30 e0       	ldi	r19, 0x00	; 0
    243c:	02 c0       	rjmp	.+4      	; 0x2442 <CO_collectSeismic3Channel+0x19e>
    243e:	22 0f       	add	r18, r18
    2440:	33 1f       	adc	r19, r19
    2442:	4a 95       	dec	r20
    2444:	e2 f7       	brpl	.-8      	; 0x243e <CO_collectSeismic3Channel+0x19a>
    2446:	fc 01       	movw	r30, r24
    2448:	26 a3       	lds	r18, 0x56
    244a:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    244c:	80 e4       	ldi	r24, 0x40	; 64
    244e:	9a e0       	ldi	r25, 0x0A	; 10
    2450:	2c 81       	ldd	r18, Y+4	; 0x04
    2452:	42 2f       	mov	r20, r18
    2454:	50 e0       	ldi	r21, 0x00	; 0
    2456:	20 e1       	ldi	r18, 0x10	; 16
    2458:	30 e0       	ldi	r19, 0x00	; 0
    245a:	04 2e       	mov	r0, r20
    245c:	02 c0       	rjmp	.+4      	; 0x2462 <CO_collectSeismic3Channel+0x1be>
    245e:	22 0f       	add	r18, r18
    2460:	33 1f       	adc	r19, r19
    2462:	0a 94       	dec	r0
    2464:	e2 f7       	brpl	.-8      	; 0x245e <CO_collectSeismic3Channel+0x1ba>
    2466:	fc 01       	movw	r30, r24
    2468:	22 af       	sts	0x72, r18
    246a:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    246c:	80 e4       	ldi	r24, 0x40	; 64
    246e:	9a e0       	ldi	r25, 0x0A	; 10
    2470:	20 e4       	ldi	r18, 0x40	; 64
    2472:	3a e0       	ldi	r19, 0x0A	; 10
    2474:	f9 01       	movw	r30, r18
    2476:	20 81       	ld	r18, Z
    2478:	20 7f       	andi	r18, 0xF0	; 240
    247a:	21 60       	ori	r18, 0x01	; 1
    247c:	fc 01       	movw	r30, r24
    247e:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2480:	00 00       	nop
    2482:	80 91 67 50 	lds	r24, 0x5067
    2486:	90 91 68 50 	lds	r25, 0x5068
    248a:	f5 e5       	ldi	r31, 0x55	; 85
    248c:	83 35       	cpi	r24, 0x53	; 83
    248e:	9f 07       	cpc	r25, r31
    2490:	c0 f3       	brcs	.-16     	; 0x2482 <CO_collectSeismic3Channel+0x1de>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2492:	80 e0       	ldi	r24, 0x00	; 0
    2494:	98 e0       	ldi	r25, 0x08	; 8
    2496:	20 e0       	ldi	r18, 0x00	; 0
    2498:	38 e0       	ldi	r19, 0x08	; 8
    249a:	f9 01       	movw	r30, r18
    249c:	20 81       	ld	r18, Z
    249e:	20 7f       	andi	r18, 0xF0	; 240
    24a0:	fc 01       	movw	r30, r24
    24a2:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    24a4:	80 e4       	ldi	r24, 0x40	; 64
    24a6:	9a e0       	ldi	r25, 0x0A	; 10
    24a8:	20 e4       	ldi	r18, 0x40	; 64
    24aa:	3a e0       	ldi	r19, 0x0A	; 10
    24ac:	f9 01       	movw	r30, r18
    24ae:	20 81       	ld	r18, Z
    24b0:	20 7f       	andi	r18, 0xF0	; 240
    24b2:	fc 01       	movw	r30, r24
    24b4:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    24b6:	80 ea       	ldi	r24, 0xA0	; 160
    24b8:	90 e0       	ldi	r25, 0x00	; 0
    24ba:	20 ea       	ldi	r18, 0xA0	; 160
    24bc:	30 e0       	ldi	r19, 0x00	; 0
    24be:	f9 01       	movw	r30, r18
    24c0:	22 81       	ldd	r18, Z+2	; 0x02
    24c2:	29 7f       	andi	r18, 0xF9	; 249
    24c4:	fc 01       	movw	r30, r24
    24c6:	22 83       	std	Z+2, r18	; 0x02
	cli();
    24c8:	f8 94       	cli

	SPICS(FALSE);
    24ca:	80 e0       	ldi	r24, 0x00	; 0
    24cc:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    24d0:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	enableADCMUX(FALSE);
    24d4:	80 e0       	ldi	r24, 0x00	; 0
    24d6:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
	ADCPower(FALSE);
    24da:	80 e0       	ldi	r24, 0x00	; 0
    24dc:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	
}
    24e0:	2e 96       	adiw	r28, 0x0e	; 14
    24e2:	cd bf       	out	0x3d, r28	; 61
    24e4:	de bf       	out	0x3e, r29	; 62
    24e6:	df 91       	pop	r29
    24e8:	cf 91       	pop	r28
    24ea:	0f 91       	pop	r16
    24ec:	ff 90       	pop	r15
    24ee:	ef 90       	pop	r14
    24f0:	df 90       	pop	r13
    24f2:	cf 90       	pop	r12
    24f4:	bf 90       	pop	r11
    24f6:	af 90       	pop	r10
    24f8:	9f 90       	pop	r9
    24fa:	8f 90       	pop	r8
    24fc:	08 95       	ret

000024fe <CO_collectSeismic3Channel_continuous>:

void CO_collectSeismic3Channel_continuous(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    24fe:	8f 92       	push	r8
    2500:	9f 92       	push	r9
    2502:	af 92       	push	r10
    2504:	bf 92       	push	r11
    2506:	cf 92       	push	r12
    2508:	df 92       	push	r13
    250a:	ef 92       	push	r14
    250c:	ff 92       	push	r15
    250e:	0f 93       	push	r16
    2510:	cf 93       	push	r28
    2512:	df 93       	push	r29
    2514:	cd b7       	in	r28, 0x3d	; 61
    2516:	de b7       	in	r29, 0x3e	; 62
    2518:	2e 97       	sbiw	r28, 0x0e	; 14
    251a:	cd bf       	out	0x3d, r28	; 61
    251c:	de bf       	out	0x3e, r29	; 62
    251e:	89 83       	std	Y+1, r24	; 0x01
    2520:	6a 83       	std	Y+2, r22	; 0x02
    2522:	7b 83       	std	Y+3, r23	; 0x03
    2524:	4c 83       	std	Y+4, r20	; 0x04
    2526:	2d 83       	std	Y+5, r18	; 0x05
    2528:	0e 83       	std	Y+6, r16	; 0x06
    252a:	ef 82       	std	Y+7, r14	; 0x07
    252c:	f8 86       	std	Y+8, r15	; 0x08
    252e:	c9 86       	std	Y+9, r12	; 0x09
    2530:	da 86       	std	Y+10, r13	; 0x0a
    2532:	ab 86       	std	Y+11, r10	; 0x0b
    2534:	bc 86       	std	Y+12, r11	; 0x0c
    2536:	8d 86       	std	Y+13, r8	; 0x0d
    2538:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    253a:	81 e0       	ldi	r24, 0x01	; 1
    253c:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2540:	8a 81       	ldd	r24, Y+2	; 0x02
    2542:	9b 81       	ldd	r25, Y+3	; 0x03
    2544:	fc 01       	movw	r30, r24
    2546:	90 81       	ld	r25, Z
    2548:	85 e0       	ldi	r24, 0x05	; 5
    254a:	69 2f       	mov	r22, r25
    254c:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2550:	8a 81       	ldd	r24, Y+2	; 0x02
    2552:	9b 81       	ldd	r25, Y+3	; 0x03
    2554:	01 96       	adiw	r24, 0x01	; 1
    2556:	fc 01       	movw	r30, r24
    2558:	90 81       	ld	r25, Z
    255a:	86 e0       	ldi	r24, 0x06	; 6
    255c:	69 2f       	mov	r22, r25
    255e:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2562:	8a 81       	ldd	r24, Y+2	; 0x02
    2564:	9b 81       	ldd	r25, Y+3	; 0x03
    2566:	02 96       	adiw	r24, 0x02	; 2
    2568:	fc 01       	movw	r30, r24
    256a:	90 81       	ld	r25, Z
    256c:	87 e0       	ldi	r24, 0x07	; 7
    256e:	69 2f       	mov	r22, r25
    2570:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_filter(filterConfig);
    2574:	89 81       	ldd	r24, Y+1	; 0x01
    2576:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    257a:	8e 81       	ldd	r24, Y+6	; 0x06
    257c:	0e 94 38 11 	call	0x2270	; 0x2270 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2580:	84 e0       	ldi	r24, 0x04	; 4
    2582:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2586:	80 ec       	ldi	r24, 0xC0	; 192
    2588:	98 e0       	ldi	r25, 0x08	; 8
    258a:	24 e5       	ldi	r18, 0x54	; 84
    258c:	fc 01       	movw	r30, r24
    258e:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2590:	81 e0       	ldi	r24, 0x01	; 1
    2592:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2596:	85 e0       	ldi	r24, 0x05	; 5
    2598:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    259c:	80 ea       	ldi	r24, 0xA0	; 160
    259e:	96 e0       	ldi	r25, 0x06	; 6
    25a0:	22 e0       	ldi	r18, 0x02	; 2
    25a2:	fc 01       	movw	r30, r24
    25a4:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    25a6:	80 ea       	ldi	r24, 0xA0	; 160
    25a8:	96 e0       	ldi	r25, 0x06	; 6
    25aa:	21 e0       	ldi	r18, 0x01	; 1
    25ac:	fc 01       	movw	r30, r24
    25ae:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    25b0:	80 e8       	ldi	r24, 0x80	; 128
    25b2:	91 e0       	ldi	r25, 0x01	; 1
    25b4:	28 e7       	ldi	r18, 0x78	; 120
    25b6:	fc 01       	movw	r30, r24
    25b8:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    25ba:	80 e0       	ldi	r24, 0x00	; 0
    25bc:	98 e0       	ldi	r25, 0x08	; 8
    25be:	20 ef       	ldi	r18, 0xF0	; 240
    25c0:	fc 01       	movw	r30, r24
    25c2:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    25c4:	80 e0       	ldi	r24, 0x00	; 0
    25c6:	98 e0       	ldi	r25, 0x08	; 8
    25c8:	2f 81       	ldd	r18, Y+7	; 0x07
    25ca:	38 85       	ldd	r19, Y+8	; 0x08
    25cc:	fc 01       	movw	r30, r24
    25ce:	20 a7       	lds	r18, 0x70
    25d0:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    25d2:	80 e0       	ldi	r24, 0x00	; 0
    25d4:	98 e0       	ldi	r25, 0x08	; 8
    25d6:	29 85       	ldd	r18, Y+9	; 0x09
    25d8:	3a 85       	ldd	r19, Y+10	; 0x0a
    25da:	fc 01       	movw	r30, r24
    25dc:	22 a7       	lds	r18, 0x72
    25de:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    25e0:	80 e0       	ldi	r24, 0x00	; 0
    25e2:	98 e0       	ldi	r25, 0x08	; 8
    25e4:	2b 85       	ldd	r18, Y+11	; 0x0b
    25e6:	3c 85       	ldd	r19, Y+12	; 0x0c
    25e8:	fc 01       	movw	r30, r24
    25ea:	24 a7       	lds	r18, 0x74
    25ec:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    25ee:	80 e0       	ldi	r24, 0x00	; 0
    25f0:	98 e0       	ldi	r25, 0x08	; 8
    25f2:	2d 85       	ldd	r18, Y+13	; 0x0d
    25f4:	3e 85       	ldd	r19, Y+14	; 0x0e
    25f6:	fc 01       	movw	r30, r24
    25f8:	26 a7       	lds	r18, 0x76
    25fa:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    25fc:	80 e0       	ldi	r24, 0x00	; 0
    25fe:	98 e0       	ldi	r25, 0x08	; 8
    2600:	2d 81       	ldd	r18, Y+5	; 0x05
    2602:	22 2f       	mov	r18, r18
    2604:	30 e0       	ldi	r19, 0x00	; 0
    2606:	21 50       	subi	r18, 0x01	; 1
    2608:	30 40       	sbci	r19, 0x00	; 0
    260a:	fc 01       	movw	r30, r24
    260c:	26 a3       	lds	r18, 0x56
    260e:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2610:	80 e0       	ldi	r24, 0x00	; 0
    2612:	98 e0       	ldi	r25, 0x08	; 8
    2614:	22 e0       	ldi	r18, 0x02	; 2
    2616:	fc 01       	movw	r30, r24
    2618:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    261a:	80 e0       	ldi	r24, 0x00	; 0
    261c:	98 e0       	ldi	r25, 0x08	; 8
    261e:	2f ef       	ldi	r18, 0xFF	; 255
    2620:	fc 01       	movw	r30, r24
    2622:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2624:	80 e0       	ldi	r24, 0x00	; 0
    2626:	98 e0       	ldi	r25, 0x08	; 8
    2628:	20 e0       	ldi	r18, 0x00	; 0
    262a:	38 e0       	ldi	r19, 0x08	; 8
    262c:	f9 01       	movw	r30, r18
    262e:	20 81       	ld	r18, Z
    2630:	20 7f       	andi	r18, 0xF0	; 240
    2632:	28 60       	ori	r18, 0x08	; 8
    2634:	fc 01       	movw	r30, r24
    2636:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    2638:	10 92 4c 40 	sts	0x404C, r1
    263c:	10 92 4d 40 	sts	0x404D, r1
	sampleCount = 0;
    2640:	10 92 67 50 	sts	0x5067, r1
    2644:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2648:	10 92 d4 50 	sts	0x50D4, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    264c:	80 e0       	ldi	r24, 0x00	; 0
    264e:	80 93 30 21 	sts	0x2130, r24
    2652:	80 93 2f 21 	sts	0x212F, r24
    2656:	80 93 2e 21 	sts	0x212E, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    265a:	80 ea       	ldi	r24, 0xA0	; 160
    265c:	90 e0       	ldi	r25, 0x00	; 0
    265e:	20 ea       	ldi	r18, 0xA0	; 160
    2660:	30 e0       	ldi	r19, 0x00	; 0
    2662:	f9 01       	movw	r30, r18
    2664:	22 81       	ldd	r18, Z+2	; 0x02
    2666:	26 60       	ori	r18, 0x06	; 6
    2668:	fc 01       	movw	r30, r24
    266a:	22 83       	std	Z+2, r18	; 0x02
	sei();
    266c:	78 94       	sei

	SPICS(TRUE);
    266e:	81 e0       	ldi	r24, 0x01	; 1
    2670:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2674:	80 e8       	ldi	r24, 0x80	; 128
    2676:	96 e0       	ldi	r25, 0x06	; 6
    2678:	20 e2       	ldi	r18, 0x20	; 32
    267a:	fc 01       	movw	r30, r24
    267c:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    267e:	80 e4       	ldi	r24, 0x40	; 64
    2680:	9a e0       	ldi	r25, 0x0A	; 10
    2682:	23 e2       	ldi	r18, 0x23	; 35
    2684:	fc 01       	movw	r30, r24
    2686:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2688:	80 e4       	ldi	r24, 0x40	; 64
    268a:	9a e0       	ldi	r25, 0x0A	; 10
    268c:	2c 81       	ldd	r18, Y+4	; 0x04
    268e:	42 2f       	mov	r20, r18
    2690:	50 e0       	ldi	r21, 0x00	; 0
    2692:	20 e2       	ldi	r18, 0x20	; 32
    2694:	30 e0       	ldi	r19, 0x00	; 0
    2696:	02 c0       	rjmp	.+4      	; 0x269c <CO_collectSeismic3Channel_continuous+0x19e>
    2698:	22 0f       	add	r18, r18
    269a:	33 1f       	adc	r19, r19
    269c:	4a 95       	dec	r20
    269e:	e2 f7       	brpl	.-8      	; 0x2698 <CO_collectSeismic3Channel_continuous+0x19a>
    26a0:	fc 01       	movw	r30, r24
    26a2:	26 a3       	lds	r18, 0x56
    26a4:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    26a6:	80 e4       	ldi	r24, 0x40	; 64
    26a8:	9a e0       	ldi	r25, 0x0A	; 10
    26aa:	2c 81       	ldd	r18, Y+4	; 0x04
    26ac:	42 2f       	mov	r20, r18
    26ae:	50 e0       	ldi	r21, 0x00	; 0
    26b0:	20 e1       	ldi	r18, 0x10	; 16
    26b2:	30 e0       	ldi	r19, 0x00	; 0
    26b4:	04 2e       	mov	r0, r20
    26b6:	02 c0       	rjmp	.+4      	; 0x26bc <CO_collectSeismic3Channel_continuous+0x1be>
    26b8:	22 0f       	add	r18, r18
    26ba:	33 1f       	adc	r19, r19
    26bc:	0a 94       	dec	r0
    26be:	e2 f7       	brpl	.-8      	; 0x26b8 <CO_collectSeismic3Channel_continuous+0x1ba>
    26c0:	fc 01       	movw	r30, r24
    26c2:	22 af       	sts	0x72, r18
    26c4:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    26c6:	80 e4       	ldi	r24, 0x40	; 64
    26c8:	9a e0       	ldi	r25, 0x0A	; 10
    26ca:	20 e4       	ldi	r18, 0x40	; 64
    26cc:	3a e0       	ldi	r19, 0x0A	; 10
    26ce:	f9 01       	movw	r30, r18
    26d0:	20 81       	ld	r18, Z
    26d2:	20 7f       	andi	r18, 0xF0	; 240
    26d4:	21 60       	ori	r18, 0x01	; 1
    26d6:	fc 01       	movw	r30, r24
    26d8:	20 83       	st	Z, r18
	
	// collect samples from ADC continuously
	while(1){
		nop();
    26da:	00 00       	nop
	}
    26dc:	fe cf       	rjmp	.-4      	; 0x26da <CO_collectSeismic3Channel_continuous+0x1dc>

000026de <__vector_16>:
}


ISR(TCC0_CCA_vect) {
    26de:	1f 92       	push	r1
    26e0:	0f 92       	push	r0
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	0f 92       	push	r0
    26e6:	00 90 3b 00 	lds	r0, 0x003B
    26ea:	0f 92       	push	r0
    26ec:	11 24       	eor	r1, r1
    26ee:	2f 93       	push	r18
    26f0:	3f 93       	push	r19
    26f2:	4f 93       	push	r20
    26f4:	5f 93       	push	r21
    26f6:	6f 93       	push	r22
    26f8:	7f 93       	push	r23
    26fa:	8f 93       	push	r24
    26fc:	9f 93       	push	r25
    26fe:	af 93       	push	r26
    2700:	bf 93       	push	r27
    2702:	ef 93       	push	r30
    2704:	ff 93       	push	r31
    2706:	cf 93       	push	r28
    2708:	df 93       	push	r29
    270a:	cd b7       	in	r28, 0x3d	; 61
    270c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    270e:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
}
    2712:	df 91       	pop	r29
    2714:	cf 91       	pop	r28
    2716:	ff 91       	pop	r31
    2718:	ef 91       	pop	r30
    271a:	bf 91       	pop	r27
    271c:	af 91       	pop	r26
    271e:	9f 91       	pop	r25
    2720:	8f 91       	pop	r24
    2722:	7f 91       	pop	r23
    2724:	6f 91       	pop	r22
    2726:	5f 91       	pop	r21
    2728:	4f 91       	pop	r20
    272a:	3f 91       	pop	r19
    272c:	2f 91       	pop	r18
    272e:	0f 90       	pop	r0
    2730:	00 92 3b 00 	sts	0x003B, r0
    2734:	0f 90       	pop	r0
    2736:	0f be       	out	0x3f, r0	; 63
    2738:	0f 90       	pop	r0
    273a:	1f 90       	pop	r1
    273c:	18 95       	reti

0000273e <__vector_17>:

ISR(TCC0_CCB_vect) {
    273e:	1f 92       	push	r1
    2740:	0f 92       	push	r0
    2742:	0f b6       	in	r0, 0x3f	; 63
    2744:	0f 92       	push	r0
    2746:	00 90 3b 00 	lds	r0, 0x003B
    274a:	0f 92       	push	r0
    274c:	11 24       	eor	r1, r1
    274e:	2f 93       	push	r18
    2750:	3f 93       	push	r19
    2752:	4f 93       	push	r20
    2754:	5f 93       	push	r21
    2756:	6f 93       	push	r22
    2758:	7f 93       	push	r23
    275a:	8f 93       	push	r24
    275c:	9f 93       	push	r25
    275e:	af 93       	push	r26
    2760:	bf 93       	push	r27
    2762:	ef 93       	push	r30
    2764:	ff 93       	push	r31
    2766:	cf 93       	push	r28
    2768:	df 93       	push	r29
    276a:	cd b7       	in	r28, 0x3d	; 61
    276c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    276e:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
}
    2772:	df 91       	pop	r29
    2774:	cf 91       	pop	r28
    2776:	ff 91       	pop	r31
    2778:	ef 91       	pop	r30
    277a:	bf 91       	pop	r27
    277c:	af 91       	pop	r26
    277e:	9f 91       	pop	r25
    2780:	8f 91       	pop	r24
    2782:	7f 91       	pop	r23
    2784:	6f 91       	pop	r22
    2786:	5f 91       	pop	r21
    2788:	4f 91       	pop	r20
    278a:	3f 91       	pop	r19
    278c:	2f 91       	pop	r18
    278e:	0f 90       	pop	r0
    2790:	00 92 3b 00 	sts	0x003B, r0
    2794:	0f 90       	pop	r0
    2796:	0f be       	out	0x3f, r0	; 63
    2798:	0f 90       	pop	r0
    279a:	1f 90       	pop	r1
    279c:	18 95       	reti

0000279e <__vector_18>:

ISR(TCC0_CCC_vect) {
    279e:	1f 92       	push	r1
    27a0:	0f 92       	push	r0
    27a2:	0f b6       	in	r0, 0x3f	; 63
    27a4:	0f 92       	push	r0
    27a6:	00 90 3b 00 	lds	r0, 0x003B
    27aa:	0f 92       	push	r0
    27ac:	11 24       	eor	r1, r1
    27ae:	2f 93       	push	r18
    27b0:	3f 93       	push	r19
    27b2:	4f 93       	push	r20
    27b4:	5f 93       	push	r21
    27b6:	6f 93       	push	r22
    27b8:	7f 93       	push	r23
    27ba:	8f 93       	push	r24
    27bc:	9f 93       	push	r25
    27be:	af 93       	push	r26
    27c0:	bf 93       	push	r27
    27c2:	ef 93       	push	r30
    27c4:	ff 93       	push	r31
    27c6:	cf 93       	push	r28
    27c8:	df 93       	push	r29
    27ca:	cd b7       	in	r28, 0x3d	; 61
    27cc:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    27ce:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
}
    27d2:	df 91       	pop	r29
    27d4:	cf 91       	pop	r28
    27d6:	ff 91       	pop	r31
    27d8:	ef 91       	pop	r30
    27da:	bf 91       	pop	r27
    27dc:	af 91       	pop	r26
    27de:	9f 91       	pop	r25
    27e0:	8f 91       	pop	r24
    27e2:	7f 91       	pop	r23
    27e4:	6f 91       	pop	r22
    27e6:	5f 91       	pop	r21
    27e8:	4f 91       	pop	r20
    27ea:	3f 91       	pop	r19
    27ec:	2f 91       	pop	r18
    27ee:	0f 90       	pop	r0
    27f0:	00 92 3b 00 	sts	0x003B, r0
    27f4:	0f 90       	pop	r0
    27f6:	0f be       	out	0x3f, r0	; 63
    27f8:	0f 90       	pop	r0
    27fa:	1f 90       	pop	r1
    27fc:	18 95       	reti

000027fe <__vector_19>:

ISR(TCC0_CCD_vect) {
    27fe:	1f 92       	push	r1
    2800:	0f 92       	push	r0
    2802:	0f b6       	in	r0, 0x3f	; 63
    2804:	0f 92       	push	r0
    2806:	00 90 3b 00 	lds	r0, 0x003B
    280a:	0f 92       	push	r0
    280c:	11 24       	eor	r1, r1
    280e:	2f 93       	push	r18
    2810:	3f 93       	push	r19
    2812:	4f 93       	push	r20
    2814:	5f 93       	push	r21
    2816:	6f 93       	push	r22
    2818:	7f 93       	push	r23
    281a:	8f 93       	push	r24
    281c:	9f 93       	push	r25
    281e:	af 93       	push	r26
    2820:	bf 93       	push	r27
    2822:	ef 93       	push	r30
    2824:	ff 93       	push	r31
    2826:	cf 93       	push	r28
    2828:	df 93       	push	r29
    282a:	cd b7       	in	r28, 0x3d	; 61
    282c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    282e:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
	SPICount = 0;
    2832:	10 92 d4 50 	sts	0x50D4, r1
	if(PORTB.OUT & PIN1_bm) {
    2836:	80 e2       	ldi	r24, 0x20	; 32
    2838:	96 e0       	ldi	r25, 0x06	; 6
    283a:	fc 01       	movw	r30, r24
    283c:	84 81       	ldd	r24, Z+4	; 0x04
    283e:	88 2f       	mov	r24, r24
    2840:	90 e0       	ldi	r25, 0x00	; 0
    2842:	82 70       	andi	r24, 0x02	; 2
    2844:	90 70       	andi	r25, 0x00	; 0
    2846:	00 97       	sbiw	r24, 0x00	; 0
    2848:	b1 f0       	breq	.+44     	; 0x2876 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    284a:	80 e0       	ldi	r24, 0x00	; 0
    284c:	96 e0       	ldi	r25, 0x06	; 6
    284e:	fc 01       	movw	r30, r24
    2850:	84 81       	ldd	r24, Z+4	; 0x04
    2852:	88 2f       	mov	r24, r24
    2854:	90 e0       	ldi	r25, 0x00	; 0
    2856:	80 74       	andi	r24, 0x40	; 64
    2858:	90 70       	andi	r25, 0x00	; 0
    285a:	00 97       	sbiw	r24, 0x00	; 0
    285c:	31 f0       	breq	.+12     	; 0x286a <__vector_19+0x6c>
    285e:	80 e2       	ldi	r24, 0x20	; 32
    2860:	96 e0       	ldi	r25, 0x06	; 6
    2862:	22 e0       	ldi	r18, 0x02	; 2
    2864:	fc 01       	movw	r30, r24
    2866:	27 83       	std	Z+7, r18	; 0x07
    2868:	10 c0       	rjmp	.+32     	; 0x288a <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    286a:	80 e0       	ldi	r24, 0x00	; 0
    286c:	96 e0       	ldi	r25, 0x06	; 6
    286e:	20 e4       	ldi	r18, 0x40	; 64
    2870:	fc 01       	movw	r30, r24
    2872:	27 83       	std	Z+7, r18	; 0x07
    2874:	0a c0       	rjmp	.+20     	; 0x288a <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2876:	80 e0       	ldi	r24, 0x00	; 0
    2878:	96 e0       	ldi	r25, 0x06	; 6
    287a:	20 e4       	ldi	r18, 0x40	; 64
    287c:	fc 01       	movw	r30, r24
    287e:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2880:	80 e2       	ldi	r24, 0x20	; 32
    2882:	96 e0       	ldi	r25, 0x06	; 6
    2884:	22 e0       	ldi	r18, 0x02	; 2
    2886:	fc 01       	movw	r30, r24
    2888:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    288a:	df 91       	pop	r29
    288c:	cf 91       	pop	r28
    288e:	ff 91       	pop	r31
    2890:	ef 91       	pop	r30
    2892:	bf 91       	pop	r27
    2894:	af 91       	pop	r26
    2896:	9f 91       	pop	r25
    2898:	8f 91       	pop	r24
    289a:	7f 91       	pop	r23
    289c:	6f 91       	pop	r22
    289e:	5f 91       	pop	r21
    28a0:	4f 91       	pop	r20
    28a2:	3f 91       	pop	r19
    28a4:	2f 91       	pop	r18
    28a6:	0f 90       	pop	r0
    28a8:	00 92 3b 00 	sts	0x003B, r0
    28ac:	0f 90       	pop	r0
    28ae:	0f be       	out	0x3f, r0	; 63
    28b0:	0f 90       	pop	r0
    28b2:	1f 90       	pop	r1
    28b4:	18 95       	reti

000028b6 <__vector_14>:

ISR(TCC0_OVF_vect) {
    28b6:	1f 92       	push	r1
    28b8:	0f 92       	push	r0
    28ba:	0f b6       	in	r0, 0x3f	; 63
    28bc:	0f 92       	push	r0
    28be:	00 90 3b 00 	lds	r0, 0x003B
    28c2:	0f 92       	push	r0
    28c4:	11 24       	eor	r1, r1
    28c6:	2f 93       	push	r18
    28c8:	3f 93       	push	r19
    28ca:	4f 93       	push	r20
    28cc:	5f 93       	push	r21
    28ce:	6f 93       	push	r22
    28d0:	7f 93       	push	r23
    28d2:	8f 93       	push	r24
    28d4:	9f 93       	push	r25
    28d6:	af 93       	push	r26
    28d8:	bf 93       	push	r27
    28da:	ef 93       	push	r30
    28dc:	ff 93       	push	r31
    28de:	cf 93       	push	r28
    28e0:	df 93       	push	r29
    28e2:	cd b7       	in	r28, 0x3d	; 61
    28e4:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    28e6:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <writeSE2FRAM>
}
    28ea:	df 91       	pop	r29
    28ec:	cf 91       	pop	r28
    28ee:	ff 91       	pop	r31
    28f0:	ef 91       	pop	r30
    28f2:	bf 91       	pop	r27
    28f4:	af 91       	pop	r26
    28f6:	9f 91       	pop	r25
    28f8:	8f 91       	pop	r24
    28fa:	7f 91       	pop	r23
    28fc:	6f 91       	pop	r22
    28fe:	5f 91       	pop	r21
    2900:	4f 91       	pop	r20
    2902:	3f 91       	pop	r19
    2904:	2f 91       	pop	r18
    2906:	0f 90       	pop	r0
    2908:	00 92 3b 00 	sts	0x003B, r0
    290c:	0f 90       	pop	r0
    290e:	0f be       	out	0x3f, r0	; 63
    2910:	0f 90       	pop	r0
    2912:	1f 90       	pop	r1
    2914:	18 95       	reti

00002916 <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD) {
    2916:	8f 92       	push	r8
    2918:	9f 92       	push	r9
    291a:	af 92       	push	r10
    291c:	bf 92       	push	r11
    291e:	cf 92       	push	r12
    2920:	df 92       	push	r13
    2922:	ef 92       	push	r14
    2924:	0f 93       	push	r16
    2926:	cf 93       	push	r28
    2928:	df 93       	push	r29
    292a:	cd b7       	in	r28, 0x3d	; 61
    292c:	de b7       	in	r29, 0x3e	; 62
    292e:	2c 97       	sbiw	r28, 0x0c	; 12
    2930:	cd bf       	out	0x3d, r28	; 61
    2932:	de bf       	out	0x3e, r29	; 62
    2934:	89 83       	std	Y+1, r24	; 0x01
    2936:	6a 83       	std	Y+2, r22	; 0x02
    2938:	4b 83       	std	Y+3, r20	; 0x03
    293a:	2c 83       	std	Y+4, r18	; 0x04
    293c:	0d 83       	std	Y+5, r16	; 0x05
    293e:	ee 82       	std	Y+6, r14	; 0x06
    2940:	cf 82       	std	Y+7, r12	; 0x07
    2942:	d8 86       	std	Y+8, r13	; 0x08
    2944:	a9 86       	std	Y+9, r10	; 0x09
    2946:	ba 86       	std	Y+10, r11	; 0x0a
    2948:	8b 86       	std	Y+11, r8	; 0x0b
    294a:	9c 86       	std	Y+12, r9	; 0x0c
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    294c:	81 e0       	ldi	r24, 0x01	; 1
    294e:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2952:	89 81       	ldd	r24, Y+1	; 0x01
    2954:	6b 81       	ldd	r22, Y+3	; 0x03
    2956:	0e 94 4c 07 	call	0xe98	; 0xe98 <set_ampGain>
	set_filter(filterConfig);
    295a:	8a 81       	ldd	r24, Y+2	; 0x02
    295c:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2960:	8e 81       	ldd	r24, Y+6	; 0x06
    2962:	0e 94 38 11 	call	0x2270	; 0x2270 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2966:	84 e0       	ldi	r24, 0x04	; 4
    2968:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    296c:	80 ec       	ldi	r24, 0xC0	; 192
    296e:	98 e0       	ldi	r25, 0x08	; 8
    2970:	24 e5       	ldi	r18, 0x54	; 84
    2972:	fc 01       	movw	r30, r24
    2974:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2976:	81 e0       	ldi	r24, 0x01	; 1
    2978:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
	setADCInput(channel);
    297c:	89 81       	ldd	r24, Y+1	; 0x01
    297e:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2982:	80 ea       	ldi	r24, 0xA0	; 160
    2984:	96 e0       	ldi	r25, 0x06	; 6
    2986:	22 e0       	ldi	r18, 0x02	; 2
    2988:	fc 01       	movw	r30, r24
    298a:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    298c:	80 ea       	ldi	r24, 0xA0	; 160
    298e:	96 e0       	ldi	r25, 0x06	; 6
    2990:	21 e0       	ldi	r18, 0x01	; 1
    2992:	fc 01       	movw	r30, r24
    2994:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2996:	80 e8       	ldi	r24, 0x80	; 128
    2998:	91 e0       	ldi	r25, 0x01	; 1
    299a:	28 e7       	ldi	r18, 0x78	; 120
    299c:	fc 01       	movw	r30, r24
    299e:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    29a0:	80 e0       	ldi	r24, 0x00	; 0
    29a2:	99 e0       	ldi	r25, 0x09	; 9
    29a4:	20 ef       	ldi	r18, 0xF0	; 240
    29a6:	fc 01       	movw	r30, r24
    29a8:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    29aa:	80 e0       	ldi	r24, 0x00	; 0
    29ac:	99 e0       	ldi	r25, 0x09	; 9
    29ae:	2f 81       	ldd	r18, Y+7	; 0x07
    29b0:	38 85       	ldd	r19, Y+8	; 0x08
    29b2:	fc 01       	movw	r30, r24
    29b4:	20 a7       	lds	r18, 0x70
    29b6:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    29b8:	80 e0       	ldi	r24, 0x00	; 0
    29ba:	99 e0       	ldi	r25, 0x09	; 9
    29bc:	29 85       	ldd	r18, Y+9	; 0x09
    29be:	3a 85       	ldd	r19, Y+10	; 0x0a
    29c0:	fc 01       	movw	r30, r24
    29c2:	22 a7       	lds	r18, 0x72
    29c4:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    29c6:	80 e0       	ldi	r24, 0x00	; 0
    29c8:	99 e0       	ldi	r25, 0x09	; 9
    29ca:	2b 85       	ldd	r18, Y+11	; 0x0b
    29cc:	3c 85       	ldd	r19, Y+12	; 0x0c
    29ce:	fc 01       	movw	r30, r24
    29d0:	24 a7       	lds	r18, 0x74
    29d2:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    29d4:	80 e0       	ldi	r24, 0x00	; 0
    29d6:	99 e0       	ldi	r25, 0x09	; 9
    29d8:	2a 8d       	ldd	r18, Y+26	; 0x1a
    29da:	3b 8d       	ldd	r19, Y+27	; 0x1b
    29dc:	fc 01       	movw	r30, r24
    29de:	26 a7       	lds	r18, 0x76
    29e0:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    29e2:	80 e0       	ldi	r24, 0x00	; 0
    29e4:	99 e0       	ldi	r25, 0x09	; 9
    29e6:	2d 81       	ldd	r18, Y+5	; 0x05
    29e8:	22 2f       	mov	r18, r18
    29ea:	30 e0       	ldi	r19, 0x00	; 0
    29ec:	21 50       	subi	r18, 0x01	; 1
    29ee:	30 40       	sbci	r19, 0x00	; 0
    29f0:	fc 01       	movw	r30, r24
    29f2:	26 a3       	lds	r18, 0x56
    29f4:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    29f6:	80 e0       	ldi	r24, 0x00	; 0
    29f8:	99 e0       	ldi	r25, 0x09	; 9
    29fa:	22 e0       	ldi	r18, 0x02	; 2
    29fc:	fc 01       	movw	r30, r24
    29fe:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2a00:	80 e0       	ldi	r24, 0x00	; 0
    2a02:	99 e0       	ldi	r25, 0x09	; 9
    2a04:	2f ef       	ldi	r18, 0xFF	; 255
    2a06:	fc 01       	movw	r30, r24
    2a08:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2a0a:	80 e0       	ldi	r24, 0x00	; 0
    2a0c:	99 e0       	ldi	r25, 0x09	; 9
    2a0e:	20 e0       	ldi	r18, 0x00	; 0
    2a10:	39 e0       	ldi	r19, 0x09	; 9
    2a12:	f9 01       	movw	r30, r18
    2a14:	20 81       	ld	r18, Z
    2a16:	20 7f       	andi	r18, 0xF0	; 240
    2a18:	28 60       	ori	r18, 0x08	; 8
    2a1a:	fc 01       	movw	r30, r24
    2a1c:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    2a1e:	10 92 4c 40 	sts	0x404C, r1
    2a22:	10 92 4d 40 	sts	0x404D, r1
	sampleCount = 0;
    2a26:	10 92 67 50 	sts	0x5067, r1
    2a2a:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2a2e:	10 92 d4 50 	sts	0x50D4, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2a32:	80 e0       	ldi	r24, 0x00	; 0
    2a34:	80 93 30 21 	sts	0x2130, r24
    2a38:	80 93 2f 21 	sts	0x212F, r24
    2a3c:	80 93 2e 21 	sts	0x212E, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2a40:	80 ea       	ldi	r24, 0xA0	; 160
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	20 ea       	ldi	r18, 0xA0	; 160
    2a46:	30 e0       	ldi	r19, 0x00	; 0
    2a48:	f9 01       	movw	r30, r18
    2a4a:	22 81       	ldd	r18, Z+2	; 0x02
    2a4c:	26 60       	ori	r18, 0x06	; 6
    2a4e:	fc 01       	movw	r30, r24
    2a50:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2a52:	78 94       	sei

	SPICS(TRUE);
    2a54:	81 e0       	ldi	r24, 0x01	; 1
    2a56:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2a5a:	80 e8       	ldi	r24, 0x80	; 128
    2a5c:	96 e0       	ldi	r25, 0x06	; 6
    2a5e:	20 e2       	ldi	r18, 0x20	; 32
    2a60:	fc 01       	movw	r30, r24
    2a62:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a64:	80 e4       	ldi	r24, 0x40	; 64
    2a66:	9a e0       	ldi	r25, 0x0A	; 10
    2a68:	23 e2       	ldi	r18, 0x23	; 35
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2a6e:	80 e4       	ldi	r24, 0x40	; 64
    2a70:	9a e0       	ldi	r25, 0x0A	; 10
    2a72:	2c 81       	ldd	r18, Y+4	; 0x04
    2a74:	42 2f       	mov	r20, r18
    2a76:	50 e0       	ldi	r21, 0x00	; 0
    2a78:	20 e2       	ldi	r18, 0x20	; 32
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	02 c0       	rjmp	.+4      	; 0x2a82 <CO_collectSeismic1Channel+0x16c>
    2a7e:	22 0f       	add	r18, r18
    2a80:	33 1f       	adc	r19, r19
    2a82:	4a 95       	dec	r20
    2a84:	e2 f7       	brpl	.-8      	; 0x2a7e <CO_collectSeismic1Channel+0x168>
    2a86:	fc 01       	movw	r30, r24
    2a88:	26 a3       	lds	r18, 0x56
    2a8a:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2a8c:	80 e4       	ldi	r24, 0x40	; 64
    2a8e:	9a e0       	ldi	r25, 0x0A	; 10
    2a90:	2c 81       	ldd	r18, Y+4	; 0x04
    2a92:	42 2f       	mov	r20, r18
    2a94:	50 e0       	ldi	r21, 0x00	; 0
    2a96:	20 e1       	ldi	r18, 0x10	; 16
    2a98:	30 e0       	ldi	r19, 0x00	; 0
    2a9a:	04 2e       	mov	r0, r20
    2a9c:	02 c0       	rjmp	.+4      	; 0x2aa2 <CO_collectSeismic1Channel+0x18c>
    2a9e:	22 0f       	add	r18, r18
    2aa0:	33 1f       	adc	r19, r19
    2aa2:	0a 94       	dec	r0
    2aa4:	e2 f7       	brpl	.-8      	; 0x2a9e <CO_collectSeismic1Channel+0x188>
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	22 af       	sts	0x72, r18
    2aaa:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2aac:	80 e4       	ldi	r24, 0x40	; 64
    2aae:	9a e0       	ldi	r25, 0x0A	; 10
    2ab0:	20 e4       	ldi	r18, 0x40	; 64
    2ab2:	3a e0       	ldi	r19, 0x0A	; 10
    2ab4:	f9 01       	movw	r30, r18
    2ab6:	20 81       	ld	r18, Z
    2ab8:	20 7f       	andi	r18, 0xF0	; 240
    2aba:	21 60       	ori	r18, 0x01	; 1
    2abc:	fc 01       	movw	r30, r24
    2abe:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2ac0:	00 00       	nop
    2ac2:	80 91 67 50 	lds	r24, 0x5067
    2ac6:	90 91 68 50 	lds	r25, 0x5068
    2aca:	f5 e5       	ldi	r31, 0x55	; 85
    2acc:	83 35       	cpi	r24, 0x53	; 83
    2ace:	9f 07       	cpc	r25, r31
    2ad0:	c0 f3       	brcs	.-16     	; 0x2ac2 <CO_collectSeismic1Channel+0x1ac>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2ad2:	80 e0       	ldi	r24, 0x00	; 0
    2ad4:	99 e0       	ldi	r25, 0x09	; 9
    2ad6:	20 e0       	ldi	r18, 0x00	; 0
    2ad8:	39 e0       	ldi	r19, 0x09	; 9
    2ada:	f9 01       	movw	r30, r18
    2adc:	20 81       	ld	r18, Z
    2ade:	20 7f       	andi	r18, 0xF0	; 240
    2ae0:	fc 01       	movw	r30, r24
    2ae2:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2ae4:	80 e4       	ldi	r24, 0x40	; 64
    2ae6:	9a e0       	ldi	r25, 0x0A	; 10
    2ae8:	20 e4       	ldi	r18, 0x40	; 64
    2aea:	3a e0       	ldi	r19, 0x0A	; 10
    2aec:	f9 01       	movw	r30, r18
    2aee:	20 81       	ld	r18, Z
    2af0:	20 7f       	andi	r18, 0xF0	; 240
    2af2:	fc 01       	movw	r30, r24
    2af4:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2af6:	80 ea       	ldi	r24, 0xA0	; 160
    2af8:	90 e0       	ldi	r25, 0x00	; 0
    2afa:	20 ea       	ldi	r18, 0xA0	; 160
    2afc:	30 e0       	ldi	r19, 0x00	; 0
    2afe:	f9 01       	movw	r30, r18
    2b00:	22 81       	ldd	r18, Z+2	; 0x02
    2b02:	29 7f       	andi	r18, 0xF9	; 249
    2b04:	fc 01       	movw	r30, r24
    2b06:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2b08:	f8 94       	cli

	SPICS(FALSE);
    2b0a:	80 e0       	ldi	r24, 0x00	; 0
    2b0c:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    2b10:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	enableADCMUX(FALSE);
    2b14:	80 e0       	ldi	r24, 0x00	; 0
    2b16:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <enableADCMUX>
	ADCPower(FALSE);
    2b1a:	80 e0       	ldi	r24, 0x00	; 0
    2b1c:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	
}
    2b20:	2c 96       	adiw	r28, 0x0c	; 12
    2b22:	cd bf       	out	0x3d, r28	; 61
    2b24:	de bf       	out	0x3e, r29	; 62
    2b26:	df 91       	pop	r29
    2b28:	cf 91       	pop	r28
    2b2a:	0f 91       	pop	r16
    2b2c:	ef 90       	pop	r14
    2b2e:	df 90       	pop	r13
    2b30:	cf 90       	pop	r12
    2b32:	bf 90       	pop	r11
    2b34:	af 90       	pop	r10
    2b36:	9f 90       	pop	r9
    2b38:	8f 90       	pop	r8
    2b3a:	08 95       	ret

00002b3c <__vector_79>:

ISR(TCD0_CCA_vect) {
    2b3c:	1f 92       	push	r1
    2b3e:	0f 92       	push	r0
    2b40:	0f b6       	in	r0, 0x3f	; 63
    2b42:	0f 92       	push	r0
    2b44:	00 90 3b 00 	lds	r0, 0x003B
    2b48:	0f 92       	push	r0
    2b4a:	11 24       	eor	r1, r1
    2b4c:	2f 93       	push	r18
    2b4e:	3f 93       	push	r19
    2b50:	4f 93       	push	r20
    2b52:	5f 93       	push	r21
    2b54:	6f 93       	push	r22
    2b56:	7f 93       	push	r23
    2b58:	8f 93       	push	r24
    2b5a:	9f 93       	push	r25
    2b5c:	af 93       	push	r26
    2b5e:	bf 93       	push	r27
    2b60:	ef 93       	push	r30
    2b62:	ff 93       	push	r31
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	cd b7       	in	r28, 0x3d	; 61
    2b6a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2b6c:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
}
    2b70:	df 91       	pop	r29
    2b72:	cf 91       	pop	r28
    2b74:	ff 91       	pop	r31
    2b76:	ef 91       	pop	r30
    2b78:	bf 91       	pop	r27
    2b7a:	af 91       	pop	r26
    2b7c:	9f 91       	pop	r25
    2b7e:	8f 91       	pop	r24
    2b80:	7f 91       	pop	r23
    2b82:	6f 91       	pop	r22
    2b84:	5f 91       	pop	r21
    2b86:	4f 91       	pop	r20
    2b88:	3f 91       	pop	r19
    2b8a:	2f 91       	pop	r18
    2b8c:	0f 90       	pop	r0
    2b8e:	00 92 3b 00 	sts	0x003B, r0
    2b92:	0f 90       	pop	r0
    2b94:	0f be       	out	0x3f, r0	; 63
    2b96:	0f 90       	pop	r0
    2b98:	1f 90       	pop	r1
    2b9a:	18 95       	reti

00002b9c <__vector_80>:

ISR(TCD0_CCB_vect) {
    2b9c:	1f 92       	push	r1
    2b9e:	0f 92       	push	r0
    2ba0:	0f b6       	in	r0, 0x3f	; 63
    2ba2:	0f 92       	push	r0
    2ba4:	00 90 3b 00 	lds	r0, 0x003B
    2ba8:	0f 92       	push	r0
    2baa:	11 24       	eor	r1, r1
    2bac:	2f 93       	push	r18
    2bae:	3f 93       	push	r19
    2bb0:	4f 93       	push	r20
    2bb2:	5f 93       	push	r21
    2bb4:	6f 93       	push	r22
    2bb6:	7f 93       	push	r23
    2bb8:	8f 93       	push	r24
    2bba:	9f 93       	push	r25
    2bbc:	af 93       	push	r26
    2bbe:	bf 93       	push	r27
    2bc0:	ef 93       	push	r30
    2bc2:	ff 93       	push	r31
    2bc4:	cf 93       	push	r28
    2bc6:	df 93       	push	r29
    2bc8:	cd b7       	in	r28, 0x3d	; 61
    2bca:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2bcc:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
}
    2bd0:	df 91       	pop	r29
    2bd2:	cf 91       	pop	r28
    2bd4:	ff 91       	pop	r31
    2bd6:	ef 91       	pop	r30
    2bd8:	bf 91       	pop	r27
    2bda:	af 91       	pop	r26
    2bdc:	9f 91       	pop	r25
    2bde:	8f 91       	pop	r24
    2be0:	7f 91       	pop	r23
    2be2:	6f 91       	pop	r22
    2be4:	5f 91       	pop	r21
    2be6:	4f 91       	pop	r20
    2be8:	3f 91       	pop	r19
    2bea:	2f 91       	pop	r18
    2bec:	0f 90       	pop	r0
    2bee:	00 92 3b 00 	sts	0x003B, r0
    2bf2:	0f 90       	pop	r0
    2bf4:	0f be       	out	0x3f, r0	; 63
    2bf6:	0f 90       	pop	r0
    2bf8:	1f 90       	pop	r1
    2bfa:	18 95       	reti

00002bfc <__vector_81>:

ISR(TCD0_CCC_vect) {
    2bfc:	1f 92       	push	r1
    2bfe:	0f 92       	push	r0
    2c00:	0f b6       	in	r0, 0x3f	; 63
    2c02:	0f 92       	push	r0
    2c04:	00 90 3b 00 	lds	r0, 0x003B
    2c08:	0f 92       	push	r0
    2c0a:	11 24       	eor	r1, r1
    2c0c:	2f 93       	push	r18
    2c0e:	3f 93       	push	r19
    2c10:	4f 93       	push	r20
    2c12:	5f 93       	push	r21
    2c14:	6f 93       	push	r22
    2c16:	7f 93       	push	r23
    2c18:	8f 93       	push	r24
    2c1a:	9f 93       	push	r25
    2c1c:	af 93       	push	r26
    2c1e:	bf 93       	push	r27
    2c20:	ef 93       	push	r30
    2c22:	ff 93       	push	r31
    2c24:	cf 93       	push	r28
    2c26:	df 93       	push	r29
    2c28:	cd b7       	in	r28, 0x3d	; 61
    2c2a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2c2c:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
}
    2c30:	df 91       	pop	r29
    2c32:	cf 91       	pop	r28
    2c34:	ff 91       	pop	r31
    2c36:	ef 91       	pop	r30
    2c38:	bf 91       	pop	r27
    2c3a:	af 91       	pop	r26
    2c3c:	9f 91       	pop	r25
    2c3e:	8f 91       	pop	r24
    2c40:	7f 91       	pop	r23
    2c42:	6f 91       	pop	r22
    2c44:	5f 91       	pop	r21
    2c46:	4f 91       	pop	r20
    2c48:	3f 91       	pop	r19
    2c4a:	2f 91       	pop	r18
    2c4c:	0f 90       	pop	r0
    2c4e:	00 92 3b 00 	sts	0x003B, r0
    2c52:	0f 90       	pop	r0
    2c54:	0f be       	out	0x3f, r0	; 63
    2c56:	0f 90       	pop	r0
    2c58:	1f 90       	pop	r1
    2c5a:	18 95       	reti

00002c5c <__vector_82>:

ISR(TCD0_CCD_vect) {
    2c5c:	1f 92       	push	r1
    2c5e:	0f 92       	push	r0
    2c60:	0f b6       	in	r0, 0x3f	; 63
    2c62:	0f 92       	push	r0
    2c64:	00 90 3b 00 	lds	r0, 0x003B
    2c68:	0f 92       	push	r0
    2c6a:	11 24       	eor	r1, r1
    2c6c:	2f 93       	push	r18
    2c6e:	3f 93       	push	r19
    2c70:	4f 93       	push	r20
    2c72:	5f 93       	push	r21
    2c74:	6f 93       	push	r22
    2c76:	7f 93       	push	r23
    2c78:	8f 93       	push	r24
    2c7a:	9f 93       	push	r25
    2c7c:	af 93       	push	r26
    2c7e:	bf 93       	push	r27
    2c80:	ef 93       	push	r30
    2c82:	ff 93       	push	r31
    2c84:	cf 93       	push	r28
    2c86:	df 93       	push	r29
    2c88:	cd b7       	in	r28, 0x3d	; 61
    2c8a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2c8c:	0e 94 90 16 	call	0x2d20	; 0x2d20 <sampleCurrentChannel>
	SPICount = 0;
    2c90:	10 92 d4 50 	sts	0x50D4, r1
}
    2c94:	df 91       	pop	r29
    2c96:	cf 91       	pop	r28
    2c98:	ff 91       	pop	r31
    2c9a:	ef 91       	pop	r30
    2c9c:	bf 91       	pop	r27
    2c9e:	af 91       	pop	r26
    2ca0:	9f 91       	pop	r25
    2ca2:	8f 91       	pop	r24
    2ca4:	7f 91       	pop	r23
    2ca6:	6f 91       	pop	r22
    2ca8:	5f 91       	pop	r21
    2caa:	4f 91       	pop	r20
    2cac:	3f 91       	pop	r19
    2cae:	2f 91       	pop	r18
    2cb0:	0f 90       	pop	r0
    2cb2:	00 92 3b 00 	sts	0x003B, r0
    2cb6:	0f 90       	pop	r0
    2cb8:	0f be       	out	0x3f, r0	; 63
    2cba:	0f 90       	pop	r0
    2cbc:	1f 90       	pop	r1
    2cbe:	18 95       	reti

00002cc0 <__vector_77>:

ISR(TCD0_OVF_vect) {
    2cc0:	1f 92       	push	r1
    2cc2:	0f 92       	push	r0
    2cc4:	0f b6       	in	r0, 0x3f	; 63
    2cc6:	0f 92       	push	r0
    2cc8:	00 90 3b 00 	lds	r0, 0x003B
    2ccc:	0f 92       	push	r0
    2cce:	11 24       	eor	r1, r1
    2cd0:	2f 93       	push	r18
    2cd2:	3f 93       	push	r19
    2cd4:	4f 93       	push	r20
    2cd6:	5f 93       	push	r21
    2cd8:	6f 93       	push	r22
    2cda:	7f 93       	push	r23
    2cdc:	8f 93       	push	r24
    2cde:	9f 93       	push	r25
    2ce0:	af 93       	push	r26
    2ce2:	bf 93       	push	r27
    2ce4:	ef 93       	push	r30
    2ce6:	ff 93       	push	r31
    2ce8:	cf 93       	push	r28
    2cea:	df 93       	push	r29
    2cec:	cd b7       	in	r28, 0x3d	; 61
    2cee:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    2cf0:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <writeSE2FRAM>
}
    2cf4:	df 91       	pop	r29
    2cf6:	cf 91       	pop	r28
    2cf8:	ff 91       	pop	r31
    2cfa:	ef 91       	pop	r30
    2cfc:	bf 91       	pop	r27
    2cfe:	af 91       	pop	r26
    2d00:	9f 91       	pop	r25
    2d02:	8f 91       	pop	r24
    2d04:	7f 91       	pop	r23
    2d06:	6f 91       	pop	r22
    2d08:	5f 91       	pop	r21
    2d0a:	4f 91       	pop	r20
    2d0c:	3f 91       	pop	r19
    2d0e:	2f 91       	pop	r18
    2d10:	0f 90       	pop	r0
    2d12:	00 92 3b 00 	sts	0x003B, r0
    2d16:	0f 90       	pop	r0
    2d18:	0f be       	out	0x3f, r0	; 63
    2d1a:	0f 90       	pop	r0
    2d1c:	1f 90       	pop	r1
    2d1e:	18 95       	reti

00002d20 <sampleCurrentChannel>:

void sampleCurrentChannel() {
    2d20:	cf 93       	push	r28
    2d22:	df 93       	push	r29
    2d24:	cd b7       	in	r28, 0x3d	; 61
    2d26:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2d28:	80 ea       	ldi	r24, 0xA0	; 160
    2d2a:	96 e0       	ldi	r25, 0x06	; 6
    2d2c:	22 e0       	ldi	r18, 0x02	; 2
    2d2e:	fc 01       	movw	r30, r24
    2d30:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d32:	80 ec       	ldi	r24, 0xC0	; 192
    2d34:	98 e0       	ldi	r25, 0x08	; 8
    2d36:	2a ea       	ldi	r18, 0xAA	; 170
    2d38:	fc 01       	movw	r30, r24
    2d3a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d3c:	00 00       	nop
    2d3e:	80 ec       	ldi	r24, 0xC0	; 192
    2d40:	98 e0       	ldi	r25, 0x08	; 8
    2d42:	fc 01       	movw	r30, r24
    2d44:	82 81       	ldd	r24, Z+2	; 0x02
    2d46:	88 23       	and	r24, r24
    2d48:	d4 f7       	brge	.-12     	; 0x2d3e <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    2d4a:	80 91 d4 50 	lds	r24, 0x50D4
    2d4e:	88 2f       	mov	r24, r24
    2d50:	90 e0       	ldi	r25, 0x00	; 0
    2d52:	20 ec       	ldi	r18, 0xC0	; 192
    2d54:	38 e0       	ldi	r19, 0x08	; 8
    2d56:	f9 01       	movw	r30, r18
    2d58:	23 81       	ldd	r18, Z+3	; 0x03
    2d5a:	86 5a       	subi	r24, 0xA6	; 166
    2d5c:	9f 4a       	sbci	r25, 0xAF	; 175
    2d5e:	fc 01       	movw	r30, r24
    2d60:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d62:	80 ec       	ldi	r24, 0xC0	; 192
    2d64:	98 e0       	ldi	r25, 0x08	; 8
    2d66:	2a ea       	ldi	r18, 0xAA	; 170
    2d68:	fc 01       	movw	r30, r24
    2d6a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d6c:	00 00       	nop
    2d6e:	80 ec       	ldi	r24, 0xC0	; 192
    2d70:	98 e0       	ldi	r25, 0x08	; 8
    2d72:	fc 01       	movw	r30, r24
    2d74:	82 81       	ldd	r24, Z+2	; 0x02
    2d76:	88 23       	and	r24, r24
    2d78:	d4 f7       	brge	.-12     	; 0x2d6e <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2d7a:	80 91 d4 50 	lds	r24, 0x50D4
    2d7e:	88 2f       	mov	r24, r24
    2d80:	90 e0       	ldi	r25, 0x00	; 0
    2d82:	01 96       	adiw	r24, 0x01	; 1
    2d84:	20 ec       	ldi	r18, 0xC0	; 192
    2d86:	38 e0       	ldi	r19, 0x08	; 8
    2d88:	f9 01       	movw	r30, r18
    2d8a:	23 81       	ldd	r18, Z+3	; 0x03
    2d8c:	86 5a       	subi	r24, 0xA6	; 166
    2d8e:	9f 4a       	sbci	r25, 0xAF	; 175
    2d90:	fc 01       	movw	r30, r24
    2d92:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d94:	80 ec       	ldi	r24, 0xC0	; 192
    2d96:	98 e0       	ldi	r25, 0x08	; 8
    2d98:	2a ea       	ldi	r18, 0xAA	; 170
    2d9a:	fc 01       	movw	r30, r24
    2d9c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d9e:	00 00       	nop
    2da0:	80 ec       	ldi	r24, 0xC0	; 192
    2da2:	98 e0       	ldi	r25, 0x08	; 8
    2da4:	fc 01       	movw	r30, r24
    2da6:	82 81       	ldd	r24, Z+2	; 0x02
    2da8:	88 23       	and	r24, r24
    2daa:	d4 f7       	brge	.-12     	; 0x2da0 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2dac:	80 91 d4 50 	lds	r24, 0x50D4
    2db0:	88 2f       	mov	r24, r24
    2db2:	90 e0       	ldi	r25, 0x00	; 0
    2db4:	02 96       	adiw	r24, 0x02	; 2
    2db6:	20 ec       	ldi	r18, 0xC0	; 192
    2db8:	38 e0       	ldi	r19, 0x08	; 8
    2dba:	f9 01       	movw	r30, r18
    2dbc:	23 81       	ldd	r18, Z+3	; 0x03
    2dbe:	86 5a       	subi	r24, 0xA6	; 166
    2dc0:	9f 4a       	sbci	r25, 0xAF	; 175
    2dc2:	fc 01       	movw	r30, r24
    2dc4:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2dc6:	80 ea       	ldi	r24, 0xA0	; 160
    2dc8:	96 e0       	ldi	r25, 0x06	; 6
    2dca:	22 e0       	ldi	r18, 0x02	; 2
    2dcc:	fc 01       	movw	r30, r24
    2dce:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2dd0:	80 91 d4 50 	lds	r24, 0x50D4
    2dd4:	8d 5f       	subi	r24, 0xFD	; 253
    2dd6:	80 93 d4 50 	sts	0x50D4, r24
}
    2dda:	df 91       	pop	r29
    2ddc:	cf 91       	pop	r28
    2dde:	08 95       	ret

00002de0 <writeSE2FRAM>:

void writeSE2FRAM() {
    2de0:	cf 93       	push	r28
    2de2:	df 93       	push	r29
    2de4:	cd b7       	in	r28, 0x3d	; 61
    2de6:	de b7       	in	r29, 0x3e	; 62
    2de8:	29 97       	sbiw	r28, 0x09	; 9
    2dea:	cd bf       	out	0x3d, r28	; 61
    2dec:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2dee:	1a 82       	std	Y+2, r1	; 0x02
    2df0:	1b 82       	std	Y+3, r1	; 0x03
    2df2:	1c 82       	std	Y+4, r1	; 0x04
    2df4:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2df6:	80 91 67 50 	lds	r24, 0x5067
    2dfa:	90 91 68 50 	lds	r25, 0x5068
    2dfe:	01 96       	adiw	r24, 0x01	; 1
    2e00:	80 93 67 50 	sts	0x5067, r24
    2e04:	90 93 68 50 	sts	0x5068, r25
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2e08:	80 ec       	ldi	r24, 0xC0	; 192
    2e0a:	98 e0       	ldi	r25, 0x08	; 8
    2e0c:	20 ed       	ldi	r18, 0xD0	; 208
    2e0e:	fc 01       	movw	r30, r24
    2e10:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2e12:	19 82       	std	Y+1, r1	; 0x01
    2e14:	4f c0       	rjmp	.+158    	; 0x2eb4 <writeSE2FRAM+0xd4>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2e16:	89 81       	ldd	r24, Y+1	; 0x01
    2e18:	88 2f       	mov	r24, r24
    2e1a:	90 e0       	ldi	r25, 0x00	; 0
    2e1c:	86 5a       	subi	r24, 0xA6	; 166
    2e1e:	9f 4a       	sbci	r25, 0xAF	; 175
    2e20:	fc 01       	movw	r30, r24
    2e22:	80 81       	ld	r24, Z
    2e24:	88 23       	and	r24, r24
    2e26:	3c f4       	brge	.+14     	; 0x2e36 <writeSE2FRAM+0x56>
    2e28:	ce 01       	movw	r24, r28
    2e2a:	06 96       	adiw	r24, 0x06	; 6
    2e2c:	03 96       	adiw	r24, 0x03	; 3
    2e2e:	2f ef       	ldi	r18, 0xFF	; 255
    2e30:	fc 01       	movw	r30, r24
    2e32:	20 83       	st	Z, r18
    2e34:	05 c0       	rjmp	.+10     	; 0x2e40 <writeSE2FRAM+0x60>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2e36:	ce 01       	movw	r24, r28
    2e38:	06 96       	adiw	r24, 0x06	; 6
    2e3a:	03 96       	adiw	r24, 0x03	; 3
    2e3c:	fc 01       	movw	r30, r24
    2e3e:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2e40:	ce 01       	movw	r24, r28
    2e42:	06 96       	adiw	r24, 0x06	; 6
    2e44:	02 96       	adiw	r24, 0x02	; 2
    2e46:	29 81       	ldd	r18, Y+1	; 0x01
    2e48:	22 2f       	mov	r18, r18
    2e4a:	30 e0       	ldi	r19, 0x00	; 0
    2e4c:	26 5a       	subi	r18, 0xA6	; 166
    2e4e:	3f 4a       	sbci	r19, 0xAF	; 175
    2e50:	f9 01       	movw	r30, r18
    2e52:	20 81       	ld	r18, Z
    2e54:	fc 01       	movw	r30, r24
    2e56:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2e58:	ce 01       	movw	r24, r28
    2e5a:	06 96       	adiw	r24, 0x06	; 6
    2e5c:	01 96       	adiw	r24, 0x01	; 1
    2e5e:	29 81       	ldd	r18, Y+1	; 0x01
    2e60:	22 2f       	mov	r18, r18
    2e62:	30 e0       	ldi	r19, 0x00	; 0
    2e64:	2f 5f       	subi	r18, 0xFF	; 255
    2e66:	3f 4f       	sbci	r19, 0xFF	; 255
    2e68:	26 5a       	subi	r18, 0xA6	; 166
    2e6a:	3f 4a       	sbci	r19, 0xAF	; 175
    2e6c:	f9 01       	movw	r30, r18
    2e6e:	20 81       	ld	r18, Z
    2e70:	fc 01       	movw	r30, r24
    2e72:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2e74:	ce 01       	movw	r24, r28
    2e76:	06 96       	adiw	r24, 0x06	; 6
    2e78:	29 81       	ldd	r18, Y+1	; 0x01
    2e7a:	22 2f       	mov	r18, r18
    2e7c:	30 e0       	ldi	r19, 0x00	; 0
    2e7e:	2e 5f       	subi	r18, 0xFE	; 254
    2e80:	3f 4f       	sbci	r19, 0xFF	; 255
    2e82:	26 5a       	subi	r18, 0xA6	; 166
    2e84:	3f 4a       	sbci	r19, 0xAF	; 175
    2e86:	f9 01       	movw	r30, r18
    2e88:	20 81       	ld	r18, Z
    2e8a:	fc 01       	movw	r30, r24
    2e8c:	20 83       	st	Z, r18
		sum += currentSample;
    2e8e:	2a 81       	ldd	r18, Y+2	; 0x02
    2e90:	3b 81       	ldd	r19, Y+3	; 0x03
    2e92:	4c 81       	ldd	r20, Y+4	; 0x04
    2e94:	5d 81       	ldd	r21, Y+5	; 0x05
    2e96:	8e 81       	ldd	r24, Y+6	; 0x06
    2e98:	9f 81       	ldd	r25, Y+7	; 0x07
    2e9a:	a8 85       	ldd	r26, Y+8	; 0x08
    2e9c:	b9 85       	ldd	r27, Y+9	; 0x09
    2e9e:	82 0f       	add	r24, r18
    2ea0:	93 1f       	adc	r25, r19
    2ea2:	a4 1f       	adc	r26, r20
    2ea4:	b5 1f       	adc	r27, r21
    2ea6:	8a 83       	std	Y+2, r24	; 0x02
    2ea8:	9b 83       	std	Y+3, r25	; 0x03
    2eaa:	ac 83       	std	Y+4, r26	; 0x04
    2eac:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2eae:	89 81       	ldd	r24, Y+1	; 0x01
    2eb0:	8d 5f       	subi	r24, 0xFD	; 253
    2eb2:	89 83       	std	Y+1, r24	; 0x01
    2eb4:	89 81       	ldd	r24, Y+1	; 0x01
    2eb6:	8c 30       	cpi	r24, 0x0C	; 12
    2eb8:	08 f4       	brcc	.+2      	; 0x2ebc <writeSE2FRAM+0xdc>
    2eba:	ad cf       	rjmp	.-166    	; 0x2e16 <writeSE2FRAM+0x36>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2ebc:	8a 81       	ldd	r24, Y+2	; 0x02
    2ebe:	9b 81       	ldd	r25, Y+3	; 0x03
    2ec0:	ac 81       	ldd	r26, Y+4	; 0x04
    2ec2:	bd 81       	ldd	r27, Y+5	; 0x05
    2ec4:	24 e0       	ldi	r18, 0x04	; 4
    2ec6:	30 e0       	ldi	r19, 0x00	; 0
    2ec8:	40 e0       	ldi	r20, 0x00	; 0
    2eca:	50 e0       	ldi	r21, 0x00	; 0
    2ecc:	bc 01       	movw	r22, r24
    2ece:	cd 01       	movw	r24, r26
    2ed0:	0e 94 c7 5e 	call	0xbd8e	; 0xbd8e <__divmodsi4>
    2ed4:	da 01       	movw	r26, r20
    2ed6:	c9 01       	movw	r24, r18
    2ed8:	8a 83       	std	Y+2, r24	; 0x02
    2eda:	9b 83       	std	Y+3, r25	; 0x03
    2edc:	ac 83       	std	Y+4, r26	; 0x04
    2ede:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2ee0:	ce 01       	movw	r24, r28
    2ee2:	02 96       	adiw	r24, 0x02	; 2
    2ee4:	fc 01       	movw	r30, r24
    2ee6:	80 81       	ld	r24, Z
    2ee8:	80 93 5c 50 	sts	0x505C, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2eec:	ce 01       	movw	r24, r28
    2eee:	02 96       	adiw	r24, 0x02	; 2
    2ef0:	fc 01       	movw	r30, r24
    2ef2:	81 81       	ldd	r24, Z+1	; 0x01
    2ef4:	80 93 5b 50 	sts	0x505B, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2ef8:	ce 01       	movw	r24, r28
    2efa:	02 96       	adiw	r24, 0x02	; 2
    2efc:	fc 01       	movw	r30, r24
    2efe:	82 81       	ldd	r24, Z+2	; 0x02
    2f00:	80 93 5a 50 	sts	0x505A, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2f04:	80 e4       	ldi	r24, 0x40	; 64
    2f06:	96 e0       	ldi	r25, 0x06	; 6
    2f08:	20 e1       	ldi	r18, 0x10	; 16
    2f0a:	fc 01       	movw	r30, r24
    2f0c:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2f0e:	80 e2       	ldi	r24, 0x20	; 32
    2f10:	96 e0       	ldi	r25, 0x06	; 6
    2f12:	28 e0       	ldi	r18, 0x08	; 8
    2f14:	fc 01       	movw	r30, r24
    2f16:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2f18:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2f1a:	80 ec       	ldi	r24, 0xC0	; 192
    2f1c:	98 e0       	ldi	r25, 0x08	; 8
    2f1e:	26 e0       	ldi	r18, 0x06	; 6
    2f20:	fc 01       	movw	r30, r24
    2f22:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f24:	00 00       	nop
    2f26:	80 ec       	ldi	r24, 0xC0	; 192
    2f28:	98 e0       	ldi	r25, 0x08	; 8
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	82 81       	ldd	r24, Z+2	; 0x02
    2f2e:	88 23       	and	r24, r24
    2f30:	d4 f7       	brge	.-12     	; 0x2f26 <writeSE2FRAM+0x146>
	SPIBuffer[12] = SPIC.DATA;
    2f32:	80 ec       	ldi	r24, 0xC0	; 192
    2f34:	98 e0       	ldi	r25, 0x08	; 8
    2f36:	fc 01       	movw	r30, r24
    2f38:	83 81       	ldd	r24, Z+3	; 0x03
    2f3a:	80 93 66 50 	sts	0x5066, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2f3e:	80 e2       	ldi	r24, 0x20	; 32
    2f40:	96 e0       	ldi	r25, 0x06	; 6
    2f42:	28 e0       	ldi	r18, 0x08	; 8
    2f44:	fc 01       	movw	r30, r24
    2f46:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2f48:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2f4a:	80 e2       	ldi	r24, 0x20	; 32
    2f4c:	96 e0       	ldi	r25, 0x06	; 6
    2f4e:	28 e0       	ldi	r18, 0x08	; 8
    2f50:	fc 01       	movw	r30, r24
    2f52:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2f54:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2f56:	80 ec       	ldi	r24, 0xC0	; 192
    2f58:	98 e0       	ldi	r25, 0x08	; 8
    2f5a:	22 e0       	ldi	r18, 0x02	; 2
    2f5c:	fc 01       	movw	r30, r24
    2f5e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f60:	00 00       	nop
    2f62:	80 ec       	ldi	r24, 0xC0	; 192
    2f64:	98 e0       	ldi	r25, 0x08	; 8
    2f66:	fc 01       	movw	r30, r24
    2f68:	82 81       	ldd	r24, Z+2	; 0x02
    2f6a:	88 23       	and	r24, r24
    2f6c:	d4 f7       	brge	.-12     	; 0x2f62 <writeSE2FRAM+0x182>
	SPIBuffer[12] = SPIC.DATA;
    2f6e:	80 ec       	ldi	r24, 0xC0	; 192
    2f70:	98 e0       	ldi	r25, 0x08	; 8
    2f72:	fc 01       	movw	r30, r24
    2f74:	83 81       	ldd	r24, Z+3	; 0x03
    2f76:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2f7a:	80 ec       	ldi	r24, 0xC0	; 192
    2f7c:	98 e0       	ldi	r25, 0x08	; 8
    2f7e:	20 91 4d 40 	lds	r18, 0x404D
    2f82:	fc 01       	movw	r30, r24
    2f84:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f86:	00 00       	nop
    2f88:	80 ec       	ldi	r24, 0xC0	; 192
    2f8a:	98 e0       	ldi	r25, 0x08	; 8
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	82 81       	ldd	r24, Z+2	; 0x02
    2f90:	88 23       	and	r24, r24
    2f92:	d4 f7       	brge	.-12     	; 0x2f88 <writeSE2FRAM+0x1a8>
	SPIBuffer[12] = SPIC.DATA;
    2f94:	80 ec       	ldi	r24, 0xC0	; 192
    2f96:	98 e0       	ldi	r25, 0x08	; 8
    2f98:	fc 01       	movw	r30, r24
    2f9a:	83 81       	ldd	r24, Z+3	; 0x03
    2f9c:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2fa0:	80 ec       	ldi	r24, 0xC0	; 192
    2fa2:	98 e0       	ldi	r25, 0x08	; 8
    2fa4:	2c e4       	ldi	r18, 0x4C	; 76
    2fa6:	30 e4       	ldi	r19, 0x40	; 64
    2fa8:	f9 01       	movw	r30, r18
    2faa:	20 81       	ld	r18, Z
    2fac:	fc 01       	movw	r30, r24
    2fae:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fb0:	00 00       	nop
    2fb2:	80 ec       	ldi	r24, 0xC0	; 192
    2fb4:	98 e0       	ldi	r25, 0x08	; 8
    2fb6:	fc 01       	movw	r30, r24
    2fb8:	82 81       	ldd	r24, Z+2	; 0x02
    2fba:	88 23       	and	r24, r24
    2fbc:	d4 f7       	brge	.-12     	; 0x2fb2 <writeSE2FRAM+0x1d2>
	SPIBuffer[12] = SPIC.DATA;
    2fbe:	80 ec       	ldi	r24, 0xC0	; 192
    2fc0:	98 e0       	ldi	r25, 0x08	; 8
    2fc2:	fc 01       	movw	r30, r24
    2fc4:	83 81       	ldd	r24, Z+3	; 0x03
    2fc6:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[0];
    2fca:	80 ec       	ldi	r24, 0xC0	; 192
    2fcc:	98 e0       	ldi	r25, 0x08	; 8
    2fce:	20 91 5a 50 	lds	r18, 0x505A
    2fd2:	fc 01       	movw	r30, r24
    2fd4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fd6:	00 00       	nop
    2fd8:	80 ec       	ldi	r24, 0xC0	; 192
    2fda:	98 e0       	ldi	r25, 0x08	; 8
    2fdc:	fc 01       	movw	r30, r24
    2fde:	82 81       	ldd	r24, Z+2	; 0x02
    2fe0:	88 23       	and	r24, r24
    2fe2:	d4 f7       	brge	.-12     	; 0x2fd8 <writeSE2FRAM+0x1f8>
	SPIBuffer[12] = SPIC.DATA;
    2fe4:	80 ec       	ldi	r24, 0xC0	; 192
    2fe6:	98 e0       	ldi	r25, 0x08	; 8
    2fe8:	fc 01       	movw	r30, r24
    2fea:	83 81       	ldd	r24, Z+3	; 0x03
    2fec:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[1];
    2ff0:	80 ec       	ldi	r24, 0xC0	; 192
    2ff2:	98 e0       	ldi	r25, 0x08	; 8
    2ff4:	20 91 5b 50 	lds	r18, 0x505B
    2ff8:	fc 01       	movw	r30, r24
    2ffa:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ffc:	00 00       	nop
    2ffe:	80 ec       	ldi	r24, 0xC0	; 192
    3000:	98 e0       	ldi	r25, 0x08	; 8
    3002:	fc 01       	movw	r30, r24
    3004:	82 81       	ldd	r24, Z+2	; 0x02
    3006:	88 23       	and	r24, r24
    3008:	d4 f7       	brge	.-12     	; 0x2ffe <writeSE2FRAM+0x21e>
	SPIBuffer[12] = SPIC.DATA;
    300a:	80 ec       	ldi	r24, 0xC0	; 192
    300c:	98 e0       	ldi	r25, 0x08	; 8
    300e:	fc 01       	movw	r30, r24
    3010:	83 81       	ldd	r24, Z+3	; 0x03
    3012:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[2];
    3016:	80 ec       	ldi	r24, 0xC0	; 192
    3018:	98 e0       	ldi	r25, 0x08	; 8
    301a:	20 91 5c 50 	lds	r18, 0x505C
    301e:	fc 01       	movw	r30, r24
    3020:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3022:	00 00       	nop
    3024:	80 ec       	ldi	r24, 0xC0	; 192
    3026:	98 e0       	ldi	r25, 0x08	; 8
    3028:	fc 01       	movw	r30, r24
    302a:	82 81       	ldd	r24, Z+2	; 0x02
    302c:	88 23       	and	r24, r24
    302e:	d4 f7       	brge	.-12     	; 0x3024 <writeSE2FRAM+0x244>
	SPIBuffer[12] = SPIC.DATA;
    3030:	80 ec       	ldi	r24, 0xC0	; 192
    3032:	98 e0       	ldi	r25, 0x08	; 8
    3034:	fc 01       	movw	r30, r24
    3036:	83 81       	ldd	r24, Z+3	; 0x03
    3038:	80 93 66 50 	sts	0x5066, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    303c:	80 e2       	ldi	r24, 0x20	; 32
    303e:	96 e0       	ldi	r25, 0x06	; 6
    3040:	28 e0       	ldi	r18, 0x08	; 8
    3042:	fc 01       	movw	r30, r24
    3044:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3046:	80 e4       	ldi	r24, 0x40	; 64
    3048:	96 e0       	ldi	r25, 0x06	; 6
    304a:	20 e1       	ldi	r18, 0x10	; 16
    304c:	fc 01       	movw	r30, r24
    304e:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    3050:	80 ec       	ldi	r24, 0xC0	; 192
    3052:	98 e0       	ldi	r25, 0x08	; 8
    3054:	24 e5       	ldi	r18, 0x54	; 84
    3056:	fc 01       	movw	r30, r24
    3058:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    305a:	80 e4       	ldi	r24, 0x40	; 64
    305c:	96 e0       	ldi	r25, 0x06	; 6
    305e:	20 e1       	ldi	r18, 0x10	; 16
    3060:	fc 01       	movw	r30, r24
    3062:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    3064:	80 91 4c 40 	lds	r24, 0x404C
    3068:	90 91 4d 40 	lds	r25, 0x404D
    306c:	03 96       	adiw	r24, 0x03	; 3
    306e:	80 93 4c 40 	sts	0x404C, r24
    3072:	90 93 4d 40 	sts	0x404D, r25
	checksumADC[0] += SPIBuffer[0];
    3076:	90 91 2e 21 	lds	r25, 0x212E
    307a:	80 91 5a 50 	lds	r24, 0x505A
    307e:	89 0f       	add	r24, r25
    3080:	80 93 2e 21 	sts	0x212E, r24
	checksumADC[1] += SPIBuffer[1];
    3084:	90 91 2f 21 	lds	r25, 0x212F
    3088:	80 91 5b 50 	lds	r24, 0x505B
    308c:	89 0f       	add	r24, r25
    308e:	80 93 2f 21 	sts	0x212F, r24
	checksumADC[2] += SPIBuffer[2];
    3092:	90 91 30 21 	lds	r25, 0x2130
    3096:	80 91 5c 50 	lds	r24, 0x505C
    309a:	89 0f       	add	r24, r25
    309c:	80 93 30 21 	sts	0x2130, r24
}
    30a0:	29 96       	adiw	r28, 0x09	; 9
    30a2:	cd bf       	out	0x3d, r28	; 61
    30a4:	de bf       	out	0x3e, r29	; 62
    30a6:	df 91       	pop	r29
    30a8:	cf 91       	pop	r28
    30aa:	08 95       	ret

000030ac <calcChecksumFRAM>:


void calcChecksumFRAM() {
    30ac:	2f 92       	push	r2
    30ae:	3f 92       	push	r3
    30b0:	4f 92       	push	r4
    30b2:	5f 92       	push	r5
    30b4:	6f 92       	push	r6
    30b6:	7f 92       	push	r7
    30b8:	8f 92       	push	r8
    30ba:	9f 92       	push	r9
    30bc:	af 92       	push	r10
    30be:	bf 92       	push	r11
    30c0:	cf 92       	push	r12
    30c2:	df 92       	push	r13
    30c4:	ef 92       	push	r14
    30c6:	ff 92       	push	r15
    30c8:	0f 93       	push	r16
    30ca:	1f 93       	push	r17
    30cc:	cf 93       	push	r28
    30ce:	df 93       	push	r29
    30d0:	00 d0       	rcall	.+0      	; 0x30d2 <calcChecksumFRAM+0x26>
    30d2:	0f 92       	push	r0
    30d4:	cd b7       	in	r28, 0x3d	; 61
    30d6:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    30d8:	aa 24       	eor	r10, r10
    30da:	bb 24       	eor	r11, r11
    30dc:	cc 24       	eor	r12, r12
    30de:	dd 24       	eor	r13, r13
    30e0:	ee 24       	eor	r14, r14
    30e2:	ff 24       	eor	r15, r15
    30e4:	00 e0       	ldi	r16, 0x00	; 0
    30e6:	10 e0       	ldi	r17, 0x00	; 0
    30e8:	a0 92 8c 50 	sts	0x508C, r10
    30ec:	b0 92 8d 50 	sts	0x508D, r11
    30f0:	c0 92 8e 50 	sts	0x508E, r12
    30f4:	d0 92 8f 50 	sts	0x508F, r13
    30f8:	e0 92 90 50 	sts	0x5090, r14
    30fc:	f0 92 91 50 	sts	0x5091, r15
    3100:	00 93 92 50 	sts	0x5092, r16
    3104:	10 93 93 50 	sts	0x5093, r17
    3108:	2a 2d       	mov	r18, r10
    310a:	3b 2d       	mov	r19, r11
    310c:	4c 2d       	mov	r20, r12
    310e:	5d 2d       	mov	r21, r13
    3110:	6e 2d       	mov	r22, r14
    3112:	7f 2d       	mov	r23, r15
    3114:	80 2f       	mov	r24, r16
    3116:	91 2f       	mov	r25, r17
    3118:	20 93 84 50 	sts	0x5084, r18
    311c:	30 93 85 50 	sts	0x5085, r19
    3120:	40 93 86 50 	sts	0x5086, r20
    3124:	50 93 87 50 	sts	0x5087, r21
    3128:	60 93 88 50 	sts	0x5088, r22
    312c:	70 93 89 50 	sts	0x5089, r23
    3130:	80 93 8a 50 	sts	0x508A, r24
    3134:	90 93 8b 50 	sts	0x508B, r25
    3138:	20 93 7c 50 	sts	0x507C, r18
    313c:	30 93 7d 50 	sts	0x507D, r19
    3140:	40 93 7e 50 	sts	0x507E, r20
    3144:	50 93 7f 50 	sts	0x507F, r21
    3148:	60 93 80 50 	sts	0x5080, r22
    314c:	70 93 81 50 	sts	0x5081, r23
    3150:	80 93 82 50 	sts	0x5082, r24
    3154:	90 93 83 50 	sts	0x5083, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    3158:	80 e0       	ldi	r24, 0x00	; 0
    315a:	80 93 33 21 	sts	0x2133, r24
    315e:	80 93 32 21 	sts	0x2132, r24
    3162:	80 93 31 21 	sts	0x2131, r24
	FRAMAddress = FR_BASEADD;
    3166:	10 92 4c 40 	sts	0x404C, r1
    316a:	10 92 4d 40 	sts	0x404D, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    316e:	19 82       	std	Y+1, r1	; 0x01
    3170:	1a 82       	std	Y+2, r1	; 0x02
    3172:	88 c2       	rjmp	.+1296   	; 0x3684 <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    3174:	81 e7       	ldi	r24, 0x71	; 113
    3176:	9c e1       	ldi	r25, 0x1C	; 28
    3178:	0e 94 47 3a 	call	0x748e	; 0x748e <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    317c:	80 91 4c 40 	lds	r24, 0x404C
    3180:	90 91 4d 40 	lds	r25, 0x404D
    3184:	8f 58       	subi	r24, 0x8F	; 143
    3186:	93 4e       	sbci	r25, 0xE3	; 227
    3188:	80 93 4c 40 	sts	0x404C, r24
    318c:	90 93 4d 40 	sts	0x404D, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3190:	1b 82       	std	Y+3, r1	; 0x03
    3192:	1c 82       	std	Y+4, r1	; 0x04
    3194:	6b c2       	rjmp	.+1238   	; 0x366c <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    3196:	8b 81       	ldd	r24, Y+3	; 0x03
    3198:	9c 81       	ldd	r25, Y+4	; 0x04
    319a:	23 e0       	ldi	r18, 0x03	; 3
    319c:	30 e0       	ldi	r19, 0x00	; 0
    319e:	b9 01       	movw	r22, r18
    31a0:	0e 94 7e 5e 	call	0xbcfc	; 0xbcfc <__udivmodhi4>
    31a4:	9c 01       	movw	r18, r24
    31a6:	2f 5c       	subi	r18, 0xCF	; 207
    31a8:	3e 4d       	sbci	r19, 0xDE	; 222
    31aa:	f9 01       	movw	r30, r18
    31ac:	40 81       	ld	r20, Z
    31ae:	2b 81       	ldd	r18, Y+3	; 0x03
    31b0:	3c 81       	ldd	r19, Y+4	; 0x04
    31b2:	2c 52       	subi	r18, 0x2C	; 44
    31b4:	3c 4d       	sbci	r19, 0xDC	; 220
    31b6:	f9 01       	movw	r30, r18
    31b8:	20 81       	ld	r18, Z
    31ba:	24 0f       	add	r18, r20
    31bc:	8f 5c       	subi	r24, 0xCF	; 207
    31be:	9e 4d       	sbci	r25, 0xDE	; 222
    31c0:	fc 01       	movw	r30, r24
    31c2:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    31c4:	8b 81       	ldd	r24, Y+3	; 0x03
    31c6:	9c 81       	ldd	r25, Y+4	; 0x04
    31c8:	23 e0       	ldi	r18, 0x03	; 3
    31ca:	30 e0       	ldi	r19, 0x00	; 0
    31cc:	b9 01       	movw	r22, r18
    31ce:	0e 94 7e 5e 	call	0xbcfc	; 0xbcfc <__udivmodhi4>
    31d2:	00 97       	sbiw	r24, 0x00	; 0
    31d4:	09 f0       	breq	.+2      	; 0x31d8 <calcChecksumFRAM+0x12c>
    31d6:	44 c0       	rjmp	.+136    	; 0x3260 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    31d8:	8b 81       	ldd	r24, Y+3	; 0x03
    31da:	9c 81       	ldd	r25, Y+4	; 0x04
    31dc:	8c 52       	subi	r24, 0x2C	; 44
    31de:	9c 4d       	sbci	r25, 0xDC	; 220
    31e0:	fc 01       	movw	r30, r24
    31e2:	80 81       	ld	r24, Z
    31e4:	88 23       	and	r24, r24
    31e6:	d4 f4       	brge	.+52     	; 0x321c <calcChecksumFRAM+0x170>
    31e8:	80 91 58 50 	lds	r24, 0x5058
    31ec:	90 91 59 50 	lds	r25, 0x5059
    31f0:	fc 01       	movw	r30, r24
    31f2:	10 82       	st	Z, r1
    31f4:	fc 01       	movw	r30, r24
    31f6:	11 82       	std	Z+1, r1	; 0x01
    31f8:	fc 01       	movw	r30, r24
    31fa:	12 82       	std	Z+2, r1	; 0x02
    31fc:	2f ef       	ldi	r18, 0xFF	; 255
    31fe:	fc 01       	movw	r30, r24
    3200:	23 83       	std	Z+3, r18	; 0x03
    3202:	2f ef       	ldi	r18, 0xFF	; 255
    3204:	fc 01       	movw	r30, r24
    3206:	24 83       	std	Z+4, r18	; 0x04
    3208:	2f ef       	ldi	r18, 0xFF	; 255
    320a:	fc 01       	movw	r30, r24
    320c:	25 83       	std	Z+5, r18	; 0x05
    320e:	2f ef       	ldi	r18, 0xFF	; 255
    3210:	fc 01       	movw	r30, r24
    3212:	26 83       	std	Z+6, r18	; 0x06
    3214:	2f ef       	ldi	r18, 0xFF	; 255
    3216:	fc 01       	movw	r30, r24
    3218:	27 83       	std	Z+7, r18	; 0x07
    321a:	14 c0       	rjmp	.+40     	; 0x3244 <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    321c:	80 91 58 50 	lds	r24, 0x5058
    3220:	90 91 59 50 	lds	r25, 0x5059
    3224:	fc 01       	movw	r30, r24
    3226:	10 82       	st	Z, r1
    3228:	fc 01       	movw	r30, r24
    322a:	11 82       	std	Z+1, r1	; 0x01
    322c:	fc 01       	movw	r30, r24
    322e:	12 82       	std	Z+2, r1	; 0x02
    3230:	fc 01       	movw	r30, r24
    3232:	13 82       	std	Z+3, r1	; 0x03
    3234:	fc 01       	movw	r30, r24
    3236:	14 82       	std	Z+4, r1	; 0x04
    3238:	fc 01       	movw	r30, r24
    323a:	15 82       	std	Z+5, r1	; 0x05
    323c:	fc 01       	movw	r30, r24
    323e:	16 82       	std	Z+6, r1	; 0x06
    3240:	fc 01       	movw	r30, r24
    3242:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    3244:	80 91 58 50 	lds	r24, 0x5058
    3248:	90 91 59 50 	lds	r25, 0x5059
    324c:	02 96       	adiw	r24, 0x02	; 2
    324e:	2b 81       	ldd	r18, Y+3	; 0x03
    3250:	3c 81       	ldd	r19, Y+4	; 0x04
    3252:	2c 52       	subi	r18, 0x2C	; 44
    3254:	3c 4d       	sbci	r19, 0xDC	; 220
    3256:	f9 01       	movw	r30, r18
    3258:	20 81       	ld	r18, Z
    325a:	fc 01       	movw	r30, r24
    325c:	20 83       	st	Z, r18
    325e:	24 c0       	rjmp	.+72     	; 0x32a8 <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    3260:	8b 81       	ldd	r24, Y+3	; 0x03
    3262:	9c 81       	ldd	r25, Y+4	; 0x04
    3264:	23 e0       	ldi	r18, 0x03	; 3
    3266:	30 e0       	ldi	r19, 0x00	; 0
    3268:	b9 01       	movw	r22, r18
    326a:	0e 94 7e 5e 	call	0xbcfc	; 0xbcfc <__udivmodhi4>
    326e:	81 30       	cpi	r24, 0x01	; 1
    3270:	91 05       	cpc	r25, r1
    3272:	71 f4       	brne	.+28     	; 0x3290 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    3274:	80 91 58 50 	lds	r24, 0x5058
    3278:	90 91 59 50 	lds	r25, 0x5059
    327c:	01 96       	adiw	r24, 0x01	; 1
    327e:	2b 81       	ldd	r18, Y+3	; 0x03
    3280:	3c 81       	ldd	r19, Y+4	; 0x04
    3282:	2c 52       	subi	r18, 0x2C	; 44
    3284:	3c 4d       	sbci	r19, 0xDC	; 220
    3286:	f9 01       	movw	r30, r18
    3288:	20 81       	ld	r18, Z
    328a:	fc 01       	movw	r30, r24
    328c:	20 83       	st	Z, r18
    328e:	0c c0       	rjmp	.+24     	; 0x32a8 <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    3290:	80 91 58 50 	lds	r24, 0x5058
    3294:	90 91 59 50 	lds	r25, 0x5059
    3298:	2b 81       	ldd	r18, Y+3	; 0x03
    329a:	3c 81       	ldd	r19, Y+4	; 0x04
    329c:	2c 52       	subi	r18, 0x2C	; 44
    329e:	3c 4d       	sbci	r19, 0xDC	; 220
    32a0:	f9 01       	movw	r30, r18
    32a2:	20 81       	ld	r18, Z
    32a4:	fc 01       	movw	r30, r24
    32a6:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    32a8:	8b 81       	ldd	r24, Y+3	; 0x03
    32aa:	9c 81       	ldd	r25, Y+4	; 0x04
    32ac:	29 e0       	ldi	r18, 0x09	; 9
    32ae:	30 e0       	ldi	r19, 0x00	; 0
    32b0:	b9 01       	movw	r22, r18
    32b2:	0e 94 7e 5e 	call	0xbcfc	; 0xbcfc <__udivmodhi4>
    32b6:	82 30       	cpi	r24, 0x02	; 2
    32b8:	91 05       	cpc	r25, r1
    32ba:	09 f0       	breq	.+2      	; 0x32be <calcChecksumFRAM+0x212>
    32bc:	94 c0       	rjmp	.+296    	; 0x33e6 <calcChecksumFRAM+0x33a>
    32be:	a0 90 7c 50 	lds	r10, 0x507C
    32c2:	b0 90 7d 50 	lds	r11, 0x507D
    32c6:	c0 90 7e 50 	lds	r12, 0x507E
    32ca:	d0 90 7f 50 	lds	r13, 0x507F
    32ce:	e0 90 80 50 	lds	r14, 0x5080
    32d2:	f0 90 81 50 	lds	r15, 0x5081
    32d6:	00 91 82 50 	lds	r16, 0x5082
    32da:	10 91 83 50 	lds	r17, 0x5083
    32de:	80 91 58 50 	lds	r24, 0x5058
    32e2:	90 91 59 50 	lds	r25, 0x5059
    32e6:	fc 01       	movw	r30, r24
    32e8:	20 80       	ld	r2, Z
    32ea:	fc 01       	movw	r30, r24
    32ec:	31 80       	ldd	r3, Z+1	; 0x01
    32ee:	fc 01       	movw	r30, r24
    32f0:	42 80       	ldd	r4, Z+2	; 0x02
    32f2:	fc 01       	movw	r30, r24
    32f4:	53 80       	ldd	r5, Z+3	; 0x03
    32f6:	fc 01       	movw	r30, r24
    32f8:	64 80       	ldd	r6, Z+4	; 0x04
    32fa:	fc 01       	movw	r30, r24
    32fc:	75 80       	ldd	r7, Z+5	; 0x05
    32fe:	fc 01       	movw	r30, r24
    3300:	86 80       	ldd	r8, Z+6	; 0x06
    3302:	fc 01       	movw	r30, r24
    3304:	97 80       	ldd	r9, Z+7	; 0x07
    3306:	2a 2d       	mov	r18, r10
    3308:	22 0d       	add	r18, r2
    330a:	e1 e0       	ldi	r30, 0x01	; 1
    330c:	2a 15       	cp	r18, r10
    330e:	08 f0       	brcs	.+2      	; 0x3312 <calcChecksumFRAM+0x266>
    3310:	e0 e0       	ldi	r30, 0x00	; 0
    3312:	3b 2d       	mov	r19, r11
    3314:	33 0d       	add	r19, r3
    3316:	f1 e0       	ldi	r31, 0x01	; 1
    3318:	3b 15       	cp	r19, r11
    331a:	08 f0       	brcs	.+2      	; 0x331e <calcChecksumFRAM+0x272>
    331c:	f0 e0       	ldi	r31, 0x00	; 0
    331e:	e3 0f       	add	r30, r19
    3320:	a1 e0       	ldi	r26, 0x01	; 1
    3322:	e3 17       	cp	r30, r19
    3324:	08 f0       	brcs	.+2      	; 0x3328 <calcChecksumFRAM+0x27c>
    3326:	a0 e0       	ldi	r26, 0x00	; 0
    3328:	fa 2b       	or	r31, r26
    332a:	3e 2f       	mov	r19, r30
    332c:	4c 2d       	mov	r20, r12
    332e:	44 0d       	add	r20, r4
    3330:	e1 e0       	ldi	r30, 0x01	; 1
    3332:	4c 15       	cp	r20, r12
    3334:	08 f0       	brcs	.+2      	; 0x3338 <calcChecksumFRAM+0x28c>
    3336:	e0 e0       	ldi	r30, 0x00	; 0
    3338:	f4 0f       	add	r31, r20
    333a:	a1 e0       	ldi	r26, 0x01	; 1
    333c:	f4 17       	cp	r31, r20
    333e:	08 f0       	brcs	.+2      	; 0x3342 <calcChecksumFRAM+0x296>
    3340:	a0 e0       	ldi	r26, 0x00	; 0
    3342:	ea 2b       	or	r30, r26
    3344:	4f 2f       	mov	r20, r31
    3346:	5d 2d       	mov	r21, r13
    3348:	55 0d       	add	r21, r5
    334a:	f1 e0       	ldi	r31, 0x01	; 1
    334c:	5d 15       	cp	r21, r13
    334e:	08 f0       	brcs	.+2      	; 0x3352 <calcChecksumFRAM+0x2a6>
    3350:	f0 e0       	ldi	r31, 0x00	; 0
    3352:	e5 0f       	add	r30, r21
    3354:	a1 e0       	ldi	r26, 0x01	; 1
    3356:	e5 17       	cp	r30, r21
    3358:	08 f0       	brcs	.+2      	; 0x335c <calcChecksumFRAM+0x2b0>
    335a:	a0 e0       	ldi	r26, 0x00	; 0
    335c:	fa 2b       	or	r31, r26
    335e:	5e 2f       	mov	r21, r30
    3360:	6e 2d       	mov	r22, r14
    3362:	66 0d       	add	r22, r6
    3364:	e1 e0       	ldi	r30, 0x01	; 1
    3366:	6e 15       	cp	r22, r14
    3368:	08 f0       	brcs	.+2      	; 0x336c <calcChecksumFRAM+0x2c0>
    336a:	e0 e0       	ldi	r30, 0x00	; 0
    336c:	f6 0f       	add	r31, r22
    336e:	a1 e0       	ldi	r26, 0x01	; 1
    3370:	f6 17       	cp	r31, r22
    3372:	08 f0       	brcs	.+2      	; 0x3376 <calcChecksumFRAM+0x2ca>
    3374:	a0 e0       	ldi	r26, 0x00	; 0
    3376:	ea 2b       	or	r30, r26
    3378:	6f 2f       	mov	r22, r31
    337a:	7f 2d       	mov	r23, r15
    337c:	77 0d       	add	r23, r7
    337e:	f1 e0       	ldi	r31, 0x01	; 1
    3380:	7f 15       	cp	r23, r15
    3382:	08 f0       	brcs	.+2      	; 0x3386 <calcChecksumFRAM+0x2da>
    3384:	f0 e0       	ldi	r31, 0x00	; 0
    3386:	e7 0f       	add	r30, r23
    3388:	a1 e0       	ldi	r26, 0x01	; 1
    338a:	e7 17       	cp	r30, r23
    338c:	08 f0       	brcs	.+2      	; 0x3390 <calcChecksumFRAM+0x2e4>
    338e:	a0 e0       	ldi	r26, 0x00	; 0
    3390:	fa 2b       	or	r31, r26
    3392:	7e 2f       	mov	r23, r30
    3394:	80 2f       	mov	r24, r16
    3396:	88 0d       	add	r24, r8
    3398:	e1 e0       	ldi	r30, 0x01	; 1
    339a:	80 17       	cp	r24, r16
    339c:	08 f0       	brcs	.+2      	; 0x33a0 <calcChecksumFRAM+0x2f4>
    339e:	e0 e0       	ldi	r30, 0x00	; 0
    33a0:	f8 0f       	add	r31, r24
    33a2:	a1 e0       	ldi	r26, 0x01	; 1
    33a4:	f8 17       	cp	r31, r24
    33a6:	08 f0       	brcs	.+2      	; 0x33aa <calcChecksumFRAM+0x2fe>
    33a8:	a0 e0       	ldi	r26, 0x00	; 0
    33aa:	ea 2b       	or	r30, r26
    33ac:	8f 2f       	mov	r24, r31
    33ae:	91 2f       	mov	r25, r17
    33b0:	99 0d       	add	r25, r9
    33b2:	e9 0f       	add	r30, r25
    33b4:	9e 2f       	mov	r25, r30
    33b6:	a2 2e       	mov	r10, r18
    33b8:	b3 2e       	mov	r11, r19
    33ba:	c4 2e       	mov	r12, r20
    33bc:	d5 2e       	mov	r13, r21
    33be:	e6 2e       	mov	r14, r22
    33c0:	f7 2e       	mov	r15, r23
    33c2:	08 2f       	mov	r16, r24
    33c4:	19 2f       	mov	r17, r25
    33c6:	a0 92 7c 50 	sts	0x507C, r10
    33ca:	b0 92 7d 50 	sts	0x507D, r11
    33ce:	c0 92 7e 50 	sts	0x507E, r12
    33d2:	d0 92 7f 50 	sts	0x507F, r13
    33d6:	e0 92 80 50 	sts	0x5080, r14
    33da:	f0 92 81 50 	sts	0x5081, r15
    33de:	00 93 82 50 	sts	0x5082, r16
    33e2:	10 93 83 50 	sts	0x5083, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    33e6:	8b 81       	ldd	r24, Y+3	; 0x03
    33e8:	9c 81       	ldd	r25, Y+4	; 0x04
    33ea:	29 e0       	ldi	r18, 0x09	; 9
    33ec:	30 e0       	ldi	r19, 0x00	; 0
    33ee:	b9 01       	movw	r22, r18
    33f0:	0e 94 7e 5e 	call	0xbcfc	; 0xbcfc <__udivmodhi4>
    33f4:	85 30       	cpi	r24, 0x05	; 5
    33f6:	91 05       	cpc	r25, r1
    33f8:	09 f0       	breq	.+2      	; 0x33fc <calcChecksumFRAM+0x350>
    33fa:	94 c0       	rjmp	.+296    	; 0x3524 <calcChecksumFRAM+0x478>
    33fc:	a0 90 84 50 	lds	r10, 0x5084
    3400:	b0 90 85 50 	lds	r11, 0x5085
    3404:	c0 90 86 50 	lds	r12, 0x5086
    3408:	d0 90 87 50 	lds	r13, 0x5087
    340c:	e0 90 88 50 	lds	r14, 0x5088
    3410:	f0 90 89 50 	lds	r15, 0x5089
    3414:	00 91 8a 50 	lds	r16, 0x508A
    3418:	10 91 8b 50 	lds	r17, 0x508B
    341c:	80 91 58 50 	lds	r24, 0x5058
    3420:	90 91 59 50 	lds	r25, 0x5059
    3424:	fc 01       	movw	r30, r24
    3426:	20 80       	ld	r2, Z
    3428:	fc 01       	movw	r30, r24
    342a:	31 80       	ldd	r3, Z+1	; 0x01
    342c:	fc 01       	movw	r30, r24
    342e:	42 80       	ldd	r4, Z+2	; 0x02
    3430:	fc 01       	movw	r30, r24
    3432:	53 80       	ldd	r5, Z+3	; 0x03
    3434:	fc 01       	movw	r30, r24
    3436:	64 80       	ldd	r6, Z+4	; 0x04
    3438:	fc 01       	movw	r30, r24
    343a:	75 80       	ldd	r7, Z+5	; 0x05
    343c:	fc 01       	movw	r30, r24
    343e:	86 80       	ldd	r8, Z+6	; 0x06
    3440:	fc 01       	movw	r30, r24
    3442:	97 80       	ldd	r9, Z+7	; 0x07
    3444:	2a 2d       	mov	r18, r10
    3446:	22 0d       	add	r18, r2
    3448:	e1 e0       	ldi	r30, 0x01	; 1
    344a:	2a 15       	cp	r18, r10
    344c:	08 f0       	brcs	.+2      	; 0x3450 <calcChecksumFRAM+0x3a4>
    344e:	e0 e0       	ldi	r30, 0x00	; 0
    3450:	3b 2d       	mov	r19, r11
    3452:	33 0d       	add	r19, r3
    3454:	f1 e0       	ldi	r31, 0x01	; 1
    3456:	3b 15       	cp	r19, r11
    3458:	08 f0       	brcs	.+2      	; 0x345c <calcChecksumFRAM+0x3b0>
    345a:	f0 e0       	ldi	r31, 0x00	; 0
    345c:	e3 0f       	add	r30, r19
    345e:	a1 e0       	ldi	r26, 0x01	; 1
    3460:	e3 17       	cp	r30, r19
    3462:	08 f0       	brcs	.+2      	; 0x3466 <calcChecksumFRAM+0x3ba>
    3464:	a0 e0       	ldi	r26, 0x00	; 0
    3466:	fa 2b       	or	r31, r26
    3468:	3e 2f       	mov	r19, r30
    346a:	4c 2d       	mov	r20, r12
    346c:	44 0d       	add	r20, r4
    346e:	e1 e0       	ldi	r30, 0x01	; 1
    3470:	4c 15       	cp	r20, r12
    3472:	08 f0       	brcs	.+2      	; 0x3476 <calcChecksumFRAM+0x3ca>
    3474:	e0 e0       	ldi	r30, 0x00	; 0
    3476:	f4 0f       	add	r31, r20
    3478:	a1 e0       	ldi	r26, 0x01	; 1
    347a:	f4 17       	cp	r31, r20
    347c:	08 f0       	brcs	.+2      	; 0x3480 <calcChecksumFRAM+0x3d4>
    347e:	a0 e0       	ldi	r26, 0x00	; 0
    3480:	ea 2b       	or	r30, r26
    3482:	4f 2f       	mov	r20, r31
    3484:	5d 2d       	mov	r21, r13
    3486:	55 0d       	add	r21, r5
    3488:	f1 e0       	ldi	r31, 0x01	; 1
    348a:	5d 15       	cp	r21, r13
    348c:	08 f0       	brcs	.+2      	; 0x3490 <calcChecksumFRAM+0x3e4>
    348e:	f0 e0       	ldi	r31, 0x00	; 0
    3490:	e5 0f       	add	r30, r21
    3492:	a1 e0       	ldi	r26, 0x01	; 1
    3494:	e5 17       	cp	r30, r21
    3496:	08 f0       	brcs	.+2      	; 0x349a <calcChecksumFRAM+0x3ee>
    3498:	a0 e0       	ldi	r26, 0x00	; 0
    349a:	fa 2b       	or	r31, r26
    349c:	5e 2f       	mov	r21, r30
    349e:	6e 2d       	mov	r22, r14
    34a0:	66 0d       	add	r22, r6
    34a2:	e1 e0       	ldi	r30, 0x01	; 1
    34a4:	6e 15       	cp	r22, r14
    34a6:	08 f0       	brcs	.+2      	; 0x34aa <calcChecksumFRAM+0x3fe>
    34a8:	e0 e0       	ldi	r30, 0x00	; 0
    34aa:	f6 0f       	add	r31, r22
    34ac:	a1 e0       	ldi	r26, 0x01	; 1
    34ae:	f6 17       	cp	r31, r22
    34b0:	08 f0       	brcs	.+2      	; 0x34b4 <calcChecksumFRAM+0x408>
    34b2:	a0 e0       	ldi	r26, 0x00	; 0
    34b4:	ea 2b       	or	r30, r26
    34b6:	6f 2f       	mov	r22, r31
    34b8:	7f 2d       	mov	r23, r15
    34ba:	77 0d       	add	r23, r7
    34bc:	f1 e0       	ldi	r31, 0x01	; 1
    34be:	7f 15       	cp	r23, r15
    34c0:	08 f0       	brcs	.+2      	; 0x34c4 <calcChecksumFRAM+0x418>
    34c2:	f0 e0       	ldi	r31, 0x00	; 0
    34c4:	e7 0f       	add	r30, r23
    34c6:	a1 e0       	ldi	r26, 0x01	; 1
    34c8:	e7 17       	cp	r30, r23
    34ca:	08 f0       	brcs	.+2      	; 0x34ce <calcChecksumFRAM+0x422>
    34cc:	a0 e0       	ldi	r26, 0x00	; 0
    34ce:	fa 2b       	or	r31, r26
    34d0:	7e 2f       	mov	r23, r30
    34d2:	80 2f       	mov	r24, r16
    34d4:	88 0d       	add	r24, r8
    34d6:	e1 e0       	ldi	r30, 0x01	; 1
    34d8:	80 17       	cp	r24, r16
    34da:	08 f0       	brcs	.+2      	; 0x34de <calcChecksumFRAM+0x432>
    34dc:	e0 e0       	ldi	r30, 0x00	; 0
    34de:	f8 0f       	add	r31, r24
    34e0:	a1 e0       	ldi	r26, 0x01	; 1
    34e2:	f8 17       	cp	r31, r24
    34e4:	08 f0       	brcs	.+2      	; 0x34e8 <calcChecksumFRAM+0x43c>
    34e6:	a0 e0       	ldi	r26, 0x00	; 0
    34e8:	ea 2b       	or	r30, r26
    34ea:	8f 2f       	mov	r24, r31
    34ec:	91 2f       	mov	r25, r17
    34ee:	99 0d       	add	r25, r9
    34f0:	e9 0f       	add	r30, r25
    34f2:	9e 2f       	mov	r25, r30
    34f4:	a2 2e       	mov	r10, r18
    34f6:	b3 2e       	mov	r11, r19
    34f8:	c4 2e       	mov	r12, r20
    34fa:	d5 2e       	mov	r13, r21
    34fc:	e6 2e       	mov	r14, r22
    34fe:	f7 2e       	mov	r15, r23
    3500:	08 2f       	mov	r16, r24
    3502:	19 2f       	mov	r17, r25
    3504:	a0 92 84 50 	sts	0x5084, r10
    3508:	b0 92 85 50 	sts	0x5085, r11
    350c:	c0 92 86 50 	sts	0x5086, r12
    3510:	d0 92 87 50 	sts	0x5087, r13
    3514:	e0 92 88 50 	sts	0x5088, r14
    3518:	f0 92 89 50 	sts	0x5089, r15
    351c:	00 93 8a 50 	sts	0x508A, r16
    3520:	10 93 8b 50 	sts	0x508B, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    3524:	8b 81       	ldd	r24, Y+3	; 0x03
    3526:	9c 81       	ldd	r25, Y+4	; 0x04
    3528:	29 e0       	ldi	r18, 0x09	; 9
    352a:	30 e0       	ldi	r19, 0x00	; 0
    352c:	b9 01       	movw	r22, r18
    352e:	0e 94 7e 5e 	call	0xbcfc	; 0xbcfc <__udivmodhi4>
    3532:	88 30       	cpi	r24, 0x08	; 8
    3534:	91 05       	cpc	r25, r1
    3536:	09 f0       	breq	.+2      	; 0x353a <calcChecksumFRAM+0x48e>
    3538:	94 c0       	rjmp	.+296    	; 0x3662 <calcChecksumFRAM+0x5b6>
    353a:	a0 90 8c 50 	lds	r10, 0x508C
    353e:	b0 90 8d 50 	lds	r11, 0x508D
    3542:	c0 90 8e 50 	lds	r12, 0x508E
    3546:	d0 90 8f 50 	lds	r13, 0x508F
    354a:	e0 90 90 50 	lds	r14, 0x5090
    354e:	f0 90 91 50 	lds	r15, 0x5091
    3552:	00 91 92 50 	lds	r16, 0x5092
    3556:	10 91 93 50 	lds	r17, 0x5093
    355a:	80 91 58 50 	lds	r24, 0x5058
    355e:	90 91 59 50 	lds	r25, 0x5059
    3562:	fc 01       	movw	r30, r24
    3564:	20 80       	ld	r2, Z
    3566:	fc 01       	movw	r30, r24
    3568:	31 80       	ldd	r3, Z+1	; 0x01
    356a:	fc 01       	movw	r30, r24
    356c:	42 80       	ldd	r4, Z+2	; 0x02
    356e:	fc 01       	movw	r30, r24
    3570:	53 80       	ldd	r5, Z+3	; 0x03
    3572:	fc 01       	movw	r30, r24
    3574:	64 80       	ldd	r6, Z+4	; 0x04
    3576:	fc 01       	movw	r30, r24
    3578:	75 80       	ldd	r7, Z+5	; 0x05
    357a:	fc 01       	movw	r30, r24
    357c:	86 80       	ldd	r8, Z+6	; 0x06
    357e:	fc 01       	movw	r30, r24
    3580:	97 80       	ldd	r9, Z+7	; 0x07
    3582:	2a 2d       	mov	r18, r10
    3584:	22 0d       	add	r18, r2
    3586:	e1 e0       	ldi	r30, 0x01	; 1
    3588:	2a 15       	cp	r18, r10
    358a:	08 f0       	brcs	.+2      	; 0x358e <calcChecksumFRAM+0x4e2>
    358c:	e0 e0       	ldi	r30, 0x00	; 0
    358e:	3b 2d       	mov	r19, r11
    3590:	33 0d       	add	r19, r3
    3592:	f1 e0       	ldi	r31, 0x01	; 1
    3594:	3b 15       	cp	r19, r11
    3596:	08 f0       	brcs	.+2      	; 0x359a <calcChecksumFRAM+0x4ee>
    3598:	f0 e0       	ldi	r31, 0x00	; 0
    359a:	e3 0f       	add	r30, r19
    359c:	a1 e0       	ldi	r26, 0x01	; 1
    359e:	e3 17       	cp	r30, r19
    35a0:	08 f0       	brcs	.+2      	; 0x35a4 <calcChecksumFRAM+0x4f8>
    35a2:	a0 e0       	ldi	r26, 0x00	; 0
    35a4:	fa 2b       	or	r31, r26
    35a6:	3e 2f       	mov	r19, r30
    35a8:	4c 2d       	mov	r20, r12
    35aa:	44 0d       	add	r20, r4
    35ac:	e1 e0       	ldi	r30, 0x01	; 1
    35ae:	4c 15       	cp	r20, r12
    35b0:	08 f0       	brcs	.+2      	; 0x35b4 <calcChecksumFRAM+0x508>
    35b2:	e0 e0       	ldi	r30, 0x00	; 0
    35b4:	f4 0f       	add	r31, r20
    35b6:	a1 e0       	ldi	r26, 0x01	; 1
    35b8:	f4 17       	cp	r31, r20
    35ba:	08 f0       	brcs	.+2      	; 0x35be <calcChecksumFRAM+0x512>
    35bc:	a0 e0       	ldi	r26, 0x00	; 0
    35be:	ea 2b       	or	r30, r26
    35c0:	4f 2f       	mov	r20, r31
    35c2:	5d 2d       	mov	r21, r13
    35c4:	55 0d       	add	r21, r5
    35c6:	f1 e0       	ldi	r31, 0x01	; 1
    35c8:	5d 15       	cp	r21, r13
    35ca:	08 f0       	brcs	.+2      	; 0x35ce <calcChecksumFRAM+0x522>
    35cc:	f0 e0       	ldi	r31, 0x00	; 0
    35ce:	e5 0f       	add	r30, r21
    35d0:	a1 e0       	ldi	r26, 0x01	; 1
    35d2:	e5 17       	cp	r30, r21
    35d4:	08 f0       	brcs	.+2      	; 0x35d8 <calcChecksumFRAM+0x52c>
    35d6:	a0 e0       	ldi	r26, 0x00	; 0
    35d8:	fa 2b       	or	r31, r26
    35da:	5e 2f       	mov	r21, r30
    35dc:	6e 2d       	mov	r22, r14
    35de:	66 0d       	add	r22, r6
    35e0:	e1 e0       	ldi	r30, 0x01	; 1
    35e2:	6e 15       	cp	r22, r14
    35e4:	08 f0       	brcs	.+2      	; 0x35e8 <calcChecksumFRAM+0x53c>
    35e6:	e0 e0       	ldi	r30, 0x00	; 0
    35e8:	f6 0f       	add	r31, r22
    35ea:	a1 e0       	ldi	r26, 0x01	; 1
    35ec:	f6 17       	cp	r31, r22
    35ee:	08 f0       	brcs	.+2      	; 0x35f2 <calcChecksumFRAM+0x546>
    35f0:	a0 e0       	ldi	r26, 0x00	; 0
    35f2:	ea 2b       	or	r30, r26
    35f4:	6f 2f       	mov	r22, r31
    35f6:	7f 2d       	mov	r23, r15
    35f8:	77 0d       	add	r23, r7
    35fa:	f1 e0       	ldi	r31, 0x01	; 1
    35fc:	7f 15       	cp	r23, r15
    35fe:	08 f0       	brcs	.+2      	; 0x3602 <calcChecksumFRAM+0x556>
    3600:	f0 e0       	ldi	r31, 0x00	; 0
    3602:	e7 0f       	add	r30, r23
    3604:	a1 e0       	ldi	r26, 0x01	; 1
    3606:	e7 17       	cp	r30, r23
    3608:	08 f0       	brcs	.+2      	; 0x360c <calcChecksumFRAM+0x560>
    360a:	a0 e0       	ldi	r26, 0x00	; 0
    360c:	fa 2b       	or	r31, r26
    360e:	7e 2f       	mov	r23, r30
    3610:	80 2f       	mov	r24, r16
    3612:	88 0d       	add	r24, r8
    3614:	e1 e0       	ldi	r30, 0x01	; 1
    3616:	80 17       	cp	r24, r16
    3618:	08 f0       	brcs	.+2      	; 0x361c <calcChecksumFRAM+0x570>
    361a:	e0 e0       	ldi	r30, 0x00	; 0
    361c:	f8 0f       	add	r31, r24
    361e:	a1 e0       	ldi	r26, 0x01	; 1
    3620:	f8 17       	cp	r31, r24
    3622:	08 f0       	brcs	.+2      	; 0x3626 <calcChecksumFRAM+0x57a>
    3624:	a0 e0       	ldi	r26, 0x00	; 0
    3626:	ea 2b       	or	r30, r26
    3628:	8f 2f       	mov	r24, r31
    362a:	91 2f       	mov	r25, r17
    362c:	99 0d       	add	r25, r9
    362e:	e9 0f       	add	r30, r25
    3630:	9e 2f       	mov	r25, r30
    3632:	a2 2e       	mov	r10, r18
    3634:	b3 2e       	mov	r11, r19
    3636:	c4 2e       	mov	r12, r20
    3638:	d5 2e       	mov	r13, r21
    363a:	e6 2e       	mov	r14, r22
    363c:	f7 2e       	mov	r15, r23
    363e:	08 2f       	mov	r16, r24
    3640:	19 2f       	mov	r17, r25
    3642:	a0 92 8c 50 	sts	0x508C, r10
    3646:	b0 92 8d 50 	sts	0x508D, r11
    364a:	c0 92 8e 50 	sts	0x508E, r12
    364e:	d0 92 8f 50 	sts	0x508F, r13
    3652:	e0 92 90 50 	sts	0x5090, r14
    3656:	f0 92 91 50 	sts	0x5091, r15
    365a:	00 93 92 50 	sts	0x5092, r16
    365e:	10 93 93 50 	sts	0x5093, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3662:	8b 81       	ldd	r24, Y+3	; 0x03
    3664:	9c 81       	ldd	r25, Y+4	; 0x04
    3666:	01 96       	adiw	r24, 0x01	; 1
    3668:	8b 83       	std	Y+3, r24	; 0x03
    366a:	9c 83       	std	Y+4, r25	; 0x04
    366c:	8b 81       	ldd	r24, Y+3	; 0x03
    366e:	9c 81       	ldd	r25, Y+4	; 0x04
    3670:	fc e1       	ldi	r31, 0x1C	; 28
    3672:	81 37       	cpi	r24, 0x71	; 113
    3674:	9f 07       	cpc	r25, r31
    3676:	08 f4       	brcc	.+2      	; 0x367a <calcChecksumFRAM+0x5ce>
    3678:	8e cd       	rjmp	.-1252   	; 0x3196 <calcChecksumFRAM+0xea>

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    367a:	89 81       	ldd	r24, Y+1	; 0x01
    367c:	9a 81       	ldd	r25, Y+2	; 0x02
    367e:	01 96       	adiw	r24, 0x01	; 1
    3680:	89 83       	std	Y+1, r24	; 0x01
    3682:	9a 83       	std	Y+2, r25	; 0x02
    3684:	89 81       	ldd	r24, Y+1	; 0x01
    3686:	9a 81       	ldd	r25, Y+2	; 0x02
    3688:	89 30       	cpi	r24, 0x09	; 9
    368a:	91 05       	cpc	r25, r1
    368c:	08 f4       	brcc	.+2      	; 0x3690 <calcChecksumFRAM+0x5e4>
    368e:	72 cd       	rjmp	.-1308   	; 0x3174 <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3690:	24 96       	adiw	r28, 0x04	; 4
    3692:	cd bf       	out	0x3d, r28	; 61
    3694:	de bf       	out	0x3e, r29	; 62
    3696:	df 91       	pop	r29
    3698:	cf 91       	pop	r28
    369a:	1f 91       	pop	r17
    369c:	0f 91       	pop	r16
    369e:	ff 90       	pop	r15
    36a0:	ef 90       	pop	r14
    36a2:	df 90       	pop	r13
    36a4:	cf 90       	pop	r12
    36a6:	bf 90       	pop	r11
    36a8:	af 90       	pop	r10
    36aa:	9f 90       	pop	r9
    36ac:	8f 90       	pop	r8
    36ae:	7f 90       	pop	r7
    36b0:	6f 90       	pop	r6
    36b2:	5f 90       	pop	r5
    36b4:	4f 90       	pop	r4
    36b6:	3f 90       	pop	r3
    36b8:	2f 90       	pop	r2
    36ba:	08 95       	ret

000036bc <FRAMWriteKnowns>:


void FRAMWriteKnowns() {
    36bc:	cf 93       	push	r28
    36be:	df 93       	push	r29
    36c0:	cd b7       	in	r28, 0x3d	; 61
    36c2:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    36c4:	10 92 4c 40 	sts	0x404C, r1
    36c8:	10 92 4d 40 	sts	0x404D, r1
	sampleCount = 0;
    36cc:	10 92 67 50 	sts	0x5067, r1
    36d0:	10 92 68 50 	sts	0x5068, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    36d4:	80 e0       	ldi	r24, 0x00	; 0
    36d6:	80 93 30 21 	sts	0x2130, r24
    36da:	80 93 2f 21 	sts	0x212F, r24
    36de:	80 93 2e 21 	sts	0x212E, r24
	
	ADCPower(TRUE);
    36e2:	81 e0       	ldi	r24, 0x01	; 1
    36e4:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    36e8:	84 e0       	ldi	r24, 0x04	; 4
    36ea:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    36ee:	80 ec       	ldi	r24, 0xC0	; 192
    36f0:	98 e0       	ldi	r25, 0x08	; 8
    36f2:	20 ed       	ldi	r18, 0xD0	; 208
    36f4:	fc 01       	movw	r30, r24
    36f6:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    36f8:	8d e0       	ldi	r24, 0x0D	; 13
    36fa:	80 93 5a 50 	sts	0x505A, r24
	SPIBuffer[1] = 0xF3;
    36fe:	83 ef       	ldi	r24, 0xF3	; 243
    3700:	80 93 5b 50 	sts	0x505B, r24
	SPIBuffer[2] = 0x57;
    3704:	87 e5       	ldi	r24, 0x57	; 87
    3706:	80 93 5c 50 	sts	0x505C, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    370a:	cd c0       	rjmp	.+410    	; 0x38a6 <FRAMWriteKnowns+0x1ea>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    370c:	80 e4       	ldi	r24, 0x40	; 64
    370e:	96 e0       	ldi	r25, 0x06	; 6
    3710:	20 e1       	ldi	r18, 0x10	; 16
    3712:	fc 01       	movw	r30, r24
    3714:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3716:	80 e2       	ldi	r24, 0x20	; 32
    3718:	96 e0       	ldi	r25, 0x06	; 6
    371a:	28 e0       	ldi	r18, 0x08	; 8
    371c:	fc 01       	movw	r30, r24
    371e:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3720:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3722:	80 ec       	ldi	r24, 0xC0	; 192
    3724:	98 e0       	ldi	r25, 0x08	; 8
    3726:	26 e0       	ldi	r18, 0x06	; 6
    3728:	fc 01       	movw	r30, r24
    372a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    372c:	00 00       	nop
    372e:	80 ec       	ldi	r24, 0xC0	; 192
    3730:	98 e0       	ldi	r25, 0x08	; 8
    3732:	fc 01       	movw	r30, r24
    3734:	82 81       	ldd	r24, Z+2	; 0x02
    3736:	88 23       	and	r24, r24
    3738:	d4 f7       	brge	.-12     	; 0x372e <FRAMWriteKnowns+0x72>
		SPIBuffer[12] = SPIC.DATA;
    373a:	80 ec       	ldi	r24, 0xC0	; 192
    373c:	98 e0       	ldi	r25, 0x08	; 8
    373e:	fc 01       	movw	r30, r24
    3740:	83 81       	ldd	r24, Z+3	; 0x03
    3742:	80 93 66 50 	sts	0x5066, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3746:	80 e2       	ldi	r24, 0x20	; 32
    3748:	96 e0       	ldi	r25, 0x06	; 6
    374a:	28 e0       	ldi	r18, 0x08	; 8
    374c:	fc 01       	movw	r30, r24
    374e:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    3750:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3752:	80 e2       	ldi	r24, 0x20	; 32
    3754:	96 e0       	ldi	r25, 0x06	; 6
    3756:	28 e0       	ldi	r18, 0x08	; 8
    3758:	fc 01       	movw	r30, r24
    375a:	26 83       	std	Z+6, r18	; 0x06
		nop();
    375c:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    375e:	80 ec       	ldi	r24, 0xC0	; 192
    3760:	98 e0       	ldi	r25, 0x08	; 8
    3762:	22 e0       	ldi	r18, 0x02	; 2
    3764:	fc 01       	movw	r30, r24
    3766:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3768:	00 00       	nop
    376a:	80 ec       	ldi	r24, 0xC0	; 192
    376c:	98 e0       	ldi	r25, 0x08	; 8
    376e:	fc 01       	movw	r30, r24
    3770:	82 81       	ldd	r24, Z+2	; 0x02
    3772:	88 23       	and	r24, r24
    3774:	d4 f7       	brge	.-12     	; 0x376a <FRAMWriteKnowns+0xae>
		SPIBuffer[12] = SPIC.DATA;
    3776:	80 ec       	ldi	r24, 0xC0	; 192
    3778:	98 e0       	ldi	r25, 0x08	; 8
    377a:	fc 01       	movw	r30, r24
    377c:	83 81       	ldd	r24, Z+3	; 0x03
    377e:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    3782:	80 ec       	ldi	r24, 0xC0	; 192
    3784:	98 e0       	ldi	r25, 0x08	; 8
    3786:	20 91 4d 40 	lds	r18, 0x404D
    378a:	fc 01       	movw	r30, r24
    378c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    378e:	00 00       	nop
    3790:	80 ec       	ldi	r24, 0xC0	; 192
    3792:	98 e0       	ldi	r25, 0x08	; 8
    3794:	fc 01       	movw	r30, r24
    3796:	82 81       	ldd	r24, Z+2	; 0x02
    3798:	88 23       	and	r24, r24
    379a:	d4 f7       	brge	.-12     	; 0x3790 <FRAMWriteKnowns+0xd4>
		SPIBuffer[12] = SPIC.DATA;
    379c:	80 ec       	ldi	r24, 0xC0	; 192
    379e:	98 e0       	ldi	r25, 0x08	; 8
    37a0:	fc 01       	movw	r30, r24
    37a2:	83 81       	ldd	r24, Z+3	; 0x03
    37a4:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    37a8:	80 ec       	ldi	r24, 0xC0	; 192
    37aa:	98 e0       	ldi	r25, 0x08	; 8
    37ac:	2c e4       	ldi	r18, 0x4C	; 76
    37ae:	30 e4       	ldi	r19, 0x40	; 64
    37b0:	f9 01       	movw	r30, r18
    37b2:	20 81       	ld	r18, Z
    37b4:	fc 01       	movw	r30, r24
    37b6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37b8:	00 00       	nop
    37ba:	80 ec       	ldi	r24, 0xC0	; 192
    37bc:	98 e0       	ldi	r25, 0x08	; 8
    37be:	fc 01       	movw	r30, r24
    37c0:	82 81       	ldd	r24, Z+2	; 0x02
    37c2:	88 23       	and	r24, r24
    37c4:	d4 f7       	brge	.-12     	; 0x37ba <FRAMWriteKnowns+0xfe>
		SPIBuffer[12] = SPIC.DATA;
    37c6:	80 ec       	ldi	r24, 0xC0	; 192
    37c8:	98 e0       	ldi	r25, 0x08	; 8
    37ca:	fc 01       	movw	r30, r24
    37cc:	83 81       	ldd	r24, Z+3	; 0x03
    37ce:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[0];
    37d2:	80 ec       	ldi	r24, 0xC0	; 192
    37d4:	98 e0       	ldi	r25, 0x08	; 8
    37d6:	20 91 5a 50 	lds	r18, 0x505A
    37da:	fc 01       	movw	r30, r24
    37dc:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37de:	00 00       	nop
    37e0:	80 ec       	ldi	r24, 0xC0	; 192
    37e2:	98 e0       	ldi	r25, 0x08	; 8
    37e4:	fc 01       	movw	r30, r24
    37e6:	82 81       	ldd	r24, Z+2	; 0x02
    37e8:	88 23       	and	r24, r24
    37ea:	d4 f7       	brge	.-12     	; 0x37e0 <FRAMWriteKnowns+0x124>
		SPIBuffer[12] = SPIC.DATA;
    37ec:	80 ec       	ldi	r24, 0xC0	; 192
    37ee:	98 e0       	ldi	r25, 0x08	; 8
    37f0:	fc 01       	movw	r30, r24
    37f2:	83 81       	ldd	r24, Z+3	; 0x03
    37f4:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[1];
    37f8:	80 ec       	ldi	r24, 0xC0	; 192
    37fa:	98 e0       	ldi	r25, 0x08	; 8
    37fc:	20 91 5b 50 	lds	r18, 0x505B
    3800:	fc 01       	movw	r30, r24
    3802:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3804:	00 00       	nop
    3806:	80 ec       	ldi	r24, 0xC0	; 192
    3808:	98 e0       	ldi	r25, 0x08	; 8
    380a:	fc 01       	movw	r30, r24
    380c:	82 81       	ldd	r24, Z+2	; 0x02
    380e:	88 23       	and	r24, r24
    3810:	d4 f7       	brge	.-12     	; 0x3806 <FRAMWriteKnowns+0x14a>
		SPIBuffer[12] = SPIC.DATA;
    3812:	80 ec       	ldi	r24, 0xC0	; 192
    3814:	98 e0       	ldi	r25, 0x08	; 8
    3816:	fc 01       	movw	r30, r24
    3818:	83 81       	ldd	r24, Z+3	; 0x03
    381a:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[2];
    381e:	80 ec       	ldi	r24, 0xC0	; 192
    3820:	98 e0       	ldi	r25, 0x08	; 8
    3822:	20 91 5c 50 	lds	r18, 0x505C
    3826:	fc 01       	movw	r30, r24
    3828:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    382a:	00 00       	nop
    382c:	80 ec       	ldi	r24, 0xC0	; 192
    382e:	98 e0       	ldi	r25, 0x08	; 8
    3830:	fc 01       	movw	r30, r24
    3832:	82 81       	ldd	r24, Z+2	; 0x02
    3834:	88 23       	and	r24, r24
    3836:	d4 f7       	brge	.-12     	; 0x382c <FRAMWriteKnowns+0x170>
		SPIBuffer[12] = SPIC.DATA;
    3838:	80 ec       	ldi	r24, 0xC0	; 192
    383a:	98 e0       	ldi	r25, 0x08	; 8
    383c:	fc 01       	movw	r30, r24
    383e:	83 81       	ldd	r24, Z+3	; 0x03
    3840:	80 93 66 50 	sts	0x5066, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3844:	80 e2       	ldi	r24, 0x20	; 32
    3846:	96 e0       	ldi	r25, 0x06	; 6
    3848:	28 e0       	ldi	r18, 0x08	; 8
    384a:	fc 01       	movw	r30, r24
    384c:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    384e:	80 e4       	ldi	r24, 0x40	; 64
    3850:	96 e0       	ldi	r25, 0x06	; 6
    3852:	20 e1       	ldi	r18, 0x10	; 16
    3854:	fc 01       	movw	r30, r24
    3856:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    3858:	80 91 4c 40 	lds	r24, 0x404C
    385c:	90 91 4d 40 	lds	r25, 0x404D
    3860:	03 96       	adiw	r24, 0x03	; 3
    3862:	80 93 4c 40 	sts	0x404C, r24
    3866:	90 93 4d 40 	sts	0x404D, r25
		checksumADC[0] += SPIBuffer[0];
    386a:	90 91 2e 21 	lds	r25, 0x212E
    386e:	80 91 5a 50 	lds	r24, 0x505A
    3872:	89 0f       	add	r24, r25
    3874:	80 93 2e 21 	sts	0x212E, r24
		checksumADC[1] += SPIBuffer[1];
    3878:	90 91 2f 21 	lds	r25, 0x212F
    387c:	80 91 5b 50 	lds	r24, 0x505B
    3880:	89 0f       	add	r24, r25
    3882:	80 93 2f 21 	sts	0x212F, r24
		checksumADC[2] += SPIBuffer[2];
    3886:	90 91 30 21 	lds	r25, 0x2130
    388a:	80 91 5c 50 	lds	r24, 0x505C
    388e:	89 0f       	add	r24, r25
    3890:	80 93 30 21 	sts	0x2130, r24
		
		sampleCount++;
    3894:	80 91 67 50 	lds	r24, 0x5067
    3898:	90 91 68 50 	lds	r25, 0x5068
    389c:	01 96       	adiw	r24, 0x01	; 1
    389e:	80 93 67 50 	sts	0x5067, r24
    38a2:	90 93 68 50 	sts	0x5068, r25
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    38a6:	80 91 67 50 	lds	r24, 0x5067
    38aa:	90 91 68 50 	lds	r25, 0x5068
    38ae:	f5 e5       	ldi	r31, 0x55	; 85
    38b0:	83 35       	cpi	r24, 0x53	; 83
    38b2:	9f 07       	cpc	r25, r31
    38b4:	08 f4       	brcc	.+2      	; 0x38b8 <FRAMWriteKnowns+0x1fc>
    38b6:	2a cf       	rjmp	.-428    	; 0x370c <FRAMWriteKnowns+0x50>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    38b8:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	ADCPower(FALSE);
    38bc:	80 e0       	ldi	r24, 0x00	; 0
    38be:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
}
    38c2:	df 91       	pop	r29
    38c4:	cf 91       	pop	r28
    38c6:	08 95       	ret

000038c8 <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    38c8:	cf 93       	push	r28
    38ca:	df 93       	push	r29
    38cc:	0f 92       	push	r0
    38ce:	cd b7       	in	r28, 0x3d	; 61
    38d0:	de b7       	in	r29, 0x3e	; 62
    38d2:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    38d4:	89 81       	ldd	r24, Y+1	; 0x01
    38d6:	88 2f       	mov	r24, r24
    38d8:	90 e0       	ldi	r25, 0x00	; 0
    38da:	81 70       	andi	r24, 0x01	; 1
    38dc:	90 70       	andi	r25, 0x00	; 0
    38de:	88 23       	and	r24, r24
    38e0:	31 f0       	breq	.+12     	; 0x38ee <setADCInput+0x26>
    38e2:	80 e0       	ldi	r24, 0x00	; 0
    38e4:	96 e0       	ldi	r25, 0x06	; 6
    38e6:	20 e4       	ldi	r18, 0x40	; 64
    38e8:	fc 01       	movw	r30, r24
    38ea:	25 83       	std	Z+5, r18	; 0x05
    38ec:	05 c0       	rjmp	.+10     	; 0x38f8 <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    38ee:	80 e0       	ldi	r24, 0x00	; 0
    38f0:	96 e0       	ldi	r25, 0x06	; 6
    38f2:	20 e4       	ldi	r18, 0x40	; 64
    38f4:	fc 01       	movw	r30, r24
    38f6:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    38f8:	89 81       	ldd	r24, Y+1	; 0x01
    38fa:	88 2f       	mov	r24, r24
    38fc:	90 e0       	ldi	r25, 0x00	; 0
    38fe:	82 70       	andi	r24, 0x02	; 2
    3900:	90 70       	andi	r25, 0x00	; 0
    3902:	00 97       	sbiw	r24, 0x00	; 0
    3904:	31 f0       	breq	.+12     	; 0x3912 <setADCInput+0x4a>
    3906:	80 e2       	ldi	r24, 0x20	; 32
    3908:	96 e0       	ldi	r25, 0x06	; 6
    390a:	22 e0       	ldi	r18, 0x02	; 2
    390c:	fc 01       	movw	r30, r24
    390e:	25 83       	std	Z+5, r18	; 0x05
    3910:	05 c0       	rjmp	.+10     	; 0x391c <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3912:	80 e2       	ldi	r24, 0x20	; 32
    3914:	96 e0       	ldi	r25, 0x06	; 6
    3916:	22 e0       	ldi	r18, 0x02	; 2
    3918:	fc 01       	movw	r30, r24
    391a:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    391c:	89 81       	ldd	r24, Y+1	; 0x01
    391e:	88 2f       	mov	r24, r24
    3920:	90 e0       	ldi	r25, 0x00	; 0
    3922:	84 70       	andi	r24, 0x04	; 4
    3924:	90 70       	andi	r25, 0x00	; 0
    3926:	00 97       	sbiw	r24, 0x00	; 0
    3928:	31 f0       	breq	.+12     	; 0x3936 <setADCInput+0x6e>
    392a:	80 e2       	ldi	r24, 0x20	; 32
    392c:	96 e0       	ldi	r25, 0x06	; 6
    392e:	24 e0       	ldi	r18, 0x04	; 4
    3930:	fc 01       	movw	r30, r24
    3932:	25 83       	std	Z+5, r18	; 0x05
    3934:	05 c0       	rjmp	.+10     	; 0x3940 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    3936:	80 e2       	ldi	r24, 0x20	; 32
    3938:	96 e0       	ldi	r25, 0x06	; 6
    393a:	24 e0       	ldi	r18, 0x04	; 4
    393c:	fc 01       	movw	r30, r24
    393e:	26 83       	std	Z+6, r18	; 0x06

}
    3940:	0f 90       	pop	r0
    3942:	df 91       	pop	r29
    3944:	cf 91       	pop	r28
    3946:	08 95       	ret

00003948 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    3948:	cf 93       	push	r28
    394a:	df 93       	push	r29
    394c:	0f 92       	push	r0
    394e:	0f 92       	push	r0
    3950:	cd b7       	in	r28, 0x3d	; 61
    3952:	de b7       	in	r29, 0x3e	; 62
    3954:	89 83       	std	Y+1, r24	; 0x01
    3956:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    3958:	89 81       	ldd	r24, Y+1	; 0x01
    395a:	9a 81       	ldd	r25, Y+2	; 0x02
    395c:	22 e0       	ldi	r18, 0x02	; 2
    395e:	80 30       	cpi	r24, 0x00	; 0
    3960:	92 07       	cpc	r25, r18
    3962:	89 f4       	brne	.+34     	; 0x3986 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3964:	80 e2       	ldi	r24, 0x20	; 32
    3966:	0e 94 21 20 	call	0x4042	; 0x4042 <SP_ReadCalibrationByte>
    396a:	28 2f       	mov	r18, r24
    396c:	89 81       	ldd	r24, Y+1	; 0x01
    396e:	9a 81       	ldd	r25, Y+2	; 0x02
    3970:	fc 01       	movw	r30, r24
    3972:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3974:	81 e2       	ldi	r24, 0x21	; 33
    3976:	0e 94 21 20 	call	0x4042	; 0x4042 <SP_ReadCalibrationByte>
    397a:	28 2f       	mov	r18, r24
    397c:	89 81       	ldd	r24, Y+1	; 0x01
    397e:	9a 81       	ldd	r25, Y+2	; 0x02
    3980:	fc 01       	movw	r30, r24
    3982:	25 87       	std	Z+13, r18	; 0x0d
    3984:	10 c0       	rjmp	.+32     	; 0x39a6 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3986:	84 e2       	ldi	r24, 0x24	; 36
    3988:	0e 94 21 20 	call	0x4042	; 0x4042 <SP_ReadCalibrationByte>
    398c:	28 2f       	mov	r18, r24
    398e:	89 81       	ldd	r24, Y+1	; 0x01
    3990:	9a 81       	ldd	r25, Y+2	; 0x02
    3992:	fc 01       	movw	r30, r24
    3994:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3996:	85 e2       	ldi	r24, 0x25	; 37
    3998:	0e 94 21 20 	call	0x4042	; 0x4042 <SP_ReadCalibrationByte>
    399c:	28 2f       	mov	r18, r24
    399e:	89 81       	ldd	r24, Y+1	; 0x01
    39a0:	9a 81       	ldd	r25, Y+2	; 0x02
    39a2:	fc 01       	movw	r30, r24
    39a4:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    39a6:	0f 90       	pop	r0
    39a8:	0f 90       	pop	r0
    39aa:	df 91       	pop	r29
    39ac:	cf 91       	pop	r28
    39ae:	08 95       	ret

000039b0 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    39b0:	cf 93       	push	r28
    39b2:	df 93       	push	r29
    39b4:	cd b7       	in	r28, 0x3d	; 61
    39b6:	de b7       	in	r29, 0x3e	; 62
    39b8:	25 97       	sbiw	r28, 0x05	; 5
    39ba:	cd bf       	out	0x3d, r28	; 61
    39bc:	de bf       	out	0x3e, r29	; 62
    39be:	8b 83       	std	Y+3, r24	; 0x03
    39c0:	9c 83       	std	Y+4, r25	; 0x04
    39c2:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    39c4:	8b 81       	ldd	r24, Y+3	; 0x03
    39c6:	9c 81       	ldd	r25, Y+4	; 0x04
    39c8:	21 e0       	ldi	r18, 0x01	; 1
    39ca:	fc 01       	movw	r30, r24
    39cc:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    39ce:	8b 81       	ldd	r24, Y+3	; 0x03
    39d0:	9c 81       	ldd	r25, Y+4	; 0x04
    39d2:	fc 01       	movw	r30, r24
    39d4:	24 81       	ldd	r18, Z+4	; 0x04
    39d6:	35 81       	ldd	r19, Z+5	; 0x05
    39d8:	8d 81       	ldd	r24, Y+5	; 0x05
    39da:	88 2f       	mov	r24, r24
    39dc:	90 e0       	ldi	r25, 0x00	; 0
    39de:	a9 01       	movw	r20, r18
    39e0:	48 1b       	sub	r20, r24
    39e2:	59 0b       	sbc	r21, r25
    39e4:	ca 01       	movw	r24, r20
    39e6:	89 83       	std	Y+1, r24	; 0x01
    39e8:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    39ea:	89 81       	ldd	r24, Y+1	; 0x01
    39ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39ee:	25 96       	adiw	r28, 0x05	; 5
    39f0:	cd bf       	out	0x3d, r28	; 61
    39f2:	de bf       	out	0x3e, r29	; 62
    39f4:	df 91       	pop	r29
    39f6:	cf 91       	pop	r28
    39f8:	08 95       	ret

000039fa <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    39fa:	cf 93       	push	r28
    39fc:	df 93       	push	r29
    39fe:	cd b7       	in	r28, 0x3d	; 61
    3a00:	de b7       	in	r29, 0x3e	; 62
    3a02:	25 97       	sbiw	r28, 0x05	; 5
    3a04:	cd bf       	out	0x3d, r28	; 61
    3a06:	de bf       	out	0x3e, r29	; 62
    3a08:	8b 83       	std	Y+3, r24	; 0x03
    3a0a:	9c 83       	std	Y+4, r25	; 0x04
    3a0c:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a10:	9c 81       	ldd	r25, Y+4	; 0x04
    3a12:	21 e0       	ldi	r18, 0x01	; 1
    3a14:	fc 01       	movw	r30, r24
    3a16:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3a18:	8b 81       	ldd	r24, Y+3	; 0x03
    3a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1c:	fc 01       	movw	r30, r24
    3a1e:	24 81       	ldd	r18, Z+4	; 0x04
    3a20:	35 81       	ldd	r19, Z+5	; 0x05
    3a22:	8d 81       	ldd	r24, Y+5	; 0x05
    3a24:	99 27       	eor	r25, r25
    3a26:	87 fd       	sbrc	r24, 7
    3a28:	90 95       	com	r25
    3a2a:	a9 01       	movw	r20, r18
    3a2c:	48 1b       	sub	r20, r24
    3a2e:	59 0b       	sbc	r21, r25
    3a30:	ca 01       	movw	r24, r20
    3a32:	89 83       	std	Y+1, r24	; 0x01
    3a34:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3a36:	89 81       	ldd	r24, Y+1	; 0x01
    3a38:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a3a:	25 96       	adiw	r28, 0x05	; 5
    3a3c:	cd bf       	out	0x3d, r28	; 61
    3a3e:	de bf       	out	0x3e, r29	; 62
    3a40:	df 91       	pop	r29
    3a42:	cf 91       	pop	r28
    3a44:	08 95       	ret

00003a46 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3a46:	cf 93       	push	r28
    3a48:	df 93       	push	r29
    3a4a:	0f 92       	push	r0
    3a4c:	0f 92       	push	r0
    3a4e:	cd b7       	in	r28, 0x3d	; 61
    3a50:	de b7       	in	r29, 0x3e	; 62
    3a52:	89 83       	std	Y+1, r24	; 0x01
    3a54:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a56:	89 81       	ldd	r24, Y+1	; 0x01
    3a58:	9a 81       	ldd	r25, Y+2	; 0x02
    3a5a:	21 e0       	ldi	r18, 0x01	; 1
    3a5c:	fc 01       	movw	r30, r24
    3a5e:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	9a 81       	ldd	r25, Y+2	; 0x02
    3a64:	fc 01       	movw	r30, r24
    3a66:	84 81       	ldd	r24, Z+4	; 0x04
    3a68:	95 81       	ldd	r25, Z+5	; 0x05
}
    3a6a:	0f 90       	pop	r0
    3a6c:	0f 90       	pop	r0
    3a6e:	df 91       	pop	r29
    3a70:	cf 91       	pop	r28
    3a72:	08 95       	ret

00003a74 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3a74:	cf 93       	push	r28
    3a76:	df 93       	push	r29
    3a78:	0f 92       	push	r0
    3a7a:	0f 92       	push	r0
    3a7c:	cd b7       	in	r28, 0x3d	; 61
    3a7e:	de b7       	in	r29, 0x3e	; 62
    3a80:	89 83       	std	Y+1, r24	; 0x01
    3a82:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a84:	89 81       	ldd	r24, Y+1	; 0x01
    3a86:	9a 81       	ldd	r25, Y+2	; 0x02
    3a88:	21 e0       	ldi	r18, 0x01	; 1
    3a8a:	fc 01       	movw	r30, r24
    3a8c:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3a8e:	89 81       	ldd	r24, Y+1	; 0x01
    3a90:	9a 81       	ldd	r25, Y+2	; 0x02
    3a92:	fc 01       	movw	r30, r24
    3a94:	84 81       	ldd	r24, Z+4	; 0x04
}
    3a96:	0f 90       	pop	r0
    3a98:	0f 90       	pop	r0
    3a9a:	df 91       	pop	r29
    3a9c:	cf 91       	pop	r28
    3a9e:	08 95       	ret

00003aa0 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3aa0:	cf 93       	push	r28
    3aa2:	df 93       	push	r29
    3aa4:	0f 92       	push	r0
    3aa6:	0f 92       	push	r0
    3aa8:	cd b7       	in	r28, 0x3d	; 61
    3aaa:	de b7       	in	r29, 0x3e	; 62
    3aac:	89 83       	std	Y+1, r24	; 0x01
    3aae:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3ab0:	89 81       	ldd	r24, Y+1	; 0x01
    3ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ab4:	21 e0       	ldi	r18, 0x01	; 1
    3ab6:	fc 01       	movw	r30, r24
    3ab8:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    3aba:	89 81       	ldd	r24, Y+1	; 0x01
    3abc:	9a 81       	ldd	r25, Y+2	; 0x02
    3abe:	fc 01       	movw	r30, r24
    3ac0:	85 81       	ldd	r24, Z+5	; 0x05
}
    3ac2:	0f 90       	pop	r0
    3ac4:	0f 90       	pop	r0
    3ac6:	df 91       	pop	r29
    3ac8:	cf 91       	pop	r28
    3aca:	08 95       	ret

00003acc <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    3acc:	0f 93       	push	r16
    3ace:	1f 93       	push	r17
    3ad0:	cf 93       	push	r28
    3ad2:	df 93       	push	r29
    3ad4:	cd b7       	in	r28, 0x3d	; 61
    3ad6:	de b7       	in	r29, 0x3e	; 62
    3ad8:	6b 97       	sbiw	r28, 0x1b	; 27
    3ada:	cd bf       	out	0x3d, r28	; 61
    3adc:	de bf       	out	0x3e, r29	; 62
    3ade:	8a 8f       	std	Y+26, r24	; 0x1a
    3ae0:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3ae2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ae4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ae6:	fc 01       	movw	r30, r24
    3ae8:	84 81       	ldd	r24, Z+4	; 0x04
    3aea:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    3aec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3aee:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3af0:	fc 01       	movw	r30, r24
    3af2:	14 82       	std	Z+4, r1	; 0x04
    3af4:	80 e0       	ldi	r24, 0x00	; 0
    3af6:	90 e0       	ldi	r25, 0x00	; 0
    3af8:	a0 e8       	ldi	r26, 0x80	; 128
    3afa:	b2 e4       	ldi	r27, 0x42	; 66
    3afc:	8a 83       	std	Y+2, r24	; 0x02
    3afe:	9b 83       	std	Y+3, r25	; 0x03
    3b00:	ac 83       	std	Y+4, r26	; 0x04
    3b02:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3b04:	6a 81       	ldd	r22, Y+2	; 0x02
    3b06:	7b 81       	ldd	r23, Y+3	; 0x03
    3b08:	8c 81       	ldd	r24, Y+4	; 0x04
    3b0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3b0c:	2b ea       	ldi	r18, 0xAB	; 171
    3b0e:	3a ea       	ldi	r19, 0xAA	; 170
    3b10:	4a e2       	ldi	r20, 0x2A	; 42
    3b12:	5f e3       	ldi	r21, 0x3F	; 63
    3b14:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    3b18:	dc 01       	movw	r26, r24
    3b1a:	cb 01       	movw	r24, r22
    3b1c:	8e 83       	std	Y+6, r24	; 0x06
    3b1e:	9f 83       	std	Y+7, r25	; 0x07
    3b20:	a8 87       	std	Y+8, r26	; 0x08
    3b22:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3b24:	11 e0       	ldi	r17, 0x01	; 1
    3b26:	6e 81       	ldd	r22, Y+6	; 0x06
    3b28:	7f 81       	ldd	r23, Y+7	; 0x07
    3b2a:	88 85       	ldd	r24, Y+8	; 0x08
    3b2c:	99 85       	ldd	r25, Y+9	; 0x09
    3b2e:	20 e0       	ldi	r18, 0x00	; 0
    3b30:	30 e0       	ldi	r19, 0x00	; 0
    3b32:	40 e8       	ldi	r20, 0x80	; 128
    3b34:	5f e3       	ldi	r21, 0x3F	; 63
    3b36:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    3b3a:	88 23       	and	r24, r24
    3b3c:	0c f0       	brlt	.+2      	; 0x3b40 <ADC_Wait_8MHz+0x74>
    3b3e:	10 e0       	ldi	r17, 0x00	; 0
    3b40:	11 23       	and	r17, r17
    3b42:	19 f0       	breq	.+6      	; 0x3b4a <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3b44:	81 e0       	ldi	r24, 0x01	; 1
    3b46:	8a 87       	std	Y+10, r24	; 0x0a
    3b48:	a3 c0       	rjmp	.+326    	; 0x3c90 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    3b4a:	11 e0       	ldi	r17, 0x01	; 1
    3b4c:	6e 81       	ldd	r22, Y+6	; 0x06
    3b4e:	7f 81       	ldd	r23, Y+7	; 0x07
    3b50:	88 85       	ldd	r24, Y+8	; 0x08
    3b52:	99 85       	ldd	r25, Y+9	; 0x09
    3b54:	20 e0       	ldi	r18, 0x00	; 0
    3b56:	30 e0       	ldi	r19, 0x00	; 0
    3b58:	4f e7       	ldi	r20, 0x7F	; 127
    3b5a:	53 e4       	ldi	r21, 0x43	; 67
    3b5c:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    3b60:	18 16       	cp	r1, r24
    3b62:	0c f0       	brlt	.+2      	; 0x3b66 <ADC_Wait_8MHz+0x9a>
    3b64:	10 e0       	ldi	r17, 0x00	; 0
    3b66:	11 23       	and	r17, r17
    3b68:	09 f4       	brne	.+2      	; 0x3b6c <ADC_Wait_8MHz+0xa0>
    3b6a:	89 c0       	rjmp	.+274    	; 0x3c7e <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    3b6c:	6a 81       	ldd	r22, Y+2	; 0x02
    3b6e:	7b 81       	ldd	r23, Y+3	; 0x03
    3b70:	8c 81       	ldd	r24, Y+4	; 0x04
    3b72:	9d 81       	ldd	r25, Y+5	; 0x05
    3b74:	20 e0       	ldi	r18, 0x00	; 0
    3b76:	30 e0       	ldi	r19, 0x00	; 0
    3b78:	4a e7       	ldi	r20, 0x7A	; 122
    3b7a:	54 e4       	ldi	r21, 0x44	; 68
    3b7c:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    3b80:	dc 01       	movw	r26, r24
    3b82:	cb 01       	movw	r24, r22
    3b84:	8b 87       	std	Y+11, r24	; 0x0b
    3b86:	9c 87       	std	Y+12, r25	; 0x0c
    3b88:	ad 87       	std	Y+13, r26	; 0x0d
    3b8a:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3b8c:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b8e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b90:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b92:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b94:	20 e0       	ldi	r18, 0x00	; 0
    3b96:	30 e0       	ldi	r19, 0x00	; 0
    3b98:	4a ef       	ldi	r20, 0xFA	; 250
    3b9a:	53 e4       	ldi	r21, 0x43	; 67
    3b9c:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    3ba0:	dc 01       	movw	r26, r24
    3ba2:	cb 01       	movw	r24, r22
    3ba4:	8f 87       	std	Y+15, r24	; 0x0f
    3ba6:	98 8b       	std	Y+16, r25	; 0x10
    3ba8:	a9 8b       	std	Y+17, r26	; 0x11
    3baa:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3bac:	11 e0       	ldi	r17, 0x01	; 1
    3bae:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bb0:	78 89       	ldd	r23, Y+16	; 0x10
    3bb2:	89 89       	ldd	r24, Y+17	; 0x11
    3bb4:	9a 89       	ldd	r25, Y+18	; 0x12
    3bb6:	20 e0       	ldi	r18, 0x00	; 0
    3bb8:	30 e0       	ldi	r19, 0x00	; 0
    3bba:	40 e8       	ldi	r20, 0x80	; 128
    3bbc:	5f e3       	ldi	r21, 0x3F	; 63
    3bbe:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    3bc2:	88 23       	and	r24, r24
    3bc4:	0c f0       	brlt	.+2      	; 0x3bc8 <ADC_Wait_8MHz+0xfc>
    3bc6:	10 e0       	ldi	r17, 0x00	; 0
    3bc8:	11 23       	and	r17, r17
    3bca:	29 f0       	breq	.+10     	; 0x3bd6 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    3bcc:	81 e0       	ldi	r24, 0x01	; 1
    3bce:	90 e0       	ldi	r25, 0x00	; 0
    3bd0:	8b 8b       	std	Y+19, r24	; 0x13
    3bd2:	9c 8b       	std	Y+20, r25	; 0x14
    3bd4:	46 c0       	rjmp	.+140    	; 0x3c62 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3bd6:	11 e0       	ldi	r17, 0x01	; 1
    3bd8:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bda:	78 89       	ldd	r23, Y+16	; 0x10
    3bdc:	89 89       	ldd	r24, Y+17	; 0x11
    3bde:	9a 89       	ldd	r25, Y+18	; 0x12
    3be0:	20 e0       	ldi	r18, 0x00	; 0
    3be2:	3f ef       	ldi	r19, 0xFF	; 255
    3be4:	4f e7       	ldi	r20, 0x7F	; 127
    3be6:	57 e4       	ldi	r21, 0x47	; 71
    3be8:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    3bec:	18 16       	cp	r1, r24
    3bee:	0c f0       	brlt	.+2      	; 0x3bf2 <ADC_Wait_8MHz+0x126>
    3bf0:	10 e0       	ldi	r17, 0x00	; 0
    3bf2:	11 23       	and	r17, r17
    3bf4:	61 f1       	breq	.+88     	; 0x3c4e <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3bf6:	6b 85       	ldd	r22, Y+11	; 0x0b
    3bf8:	7c 85       	ldd	r23, Y+12	; 0x0c
    3bfa:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bfc:	9e 85       	ldd	r25, Y+14	; 0x0e
    3bfe:	20 e0       	ldi	r18, 0x00	; 0
    3c00:	30 e0       	ldi	r19, 0x00	; 0
    3c02:	40 e2       	ldi	r20, 0x20	; 32
    3c04:	51 e4       	ldi	r21, 0x41	; 65
    3c06:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    3c0a:	dc 01       	movw	r26, r24
    3c0c:	cb 01       	movw	r24, r22
    3c0e:	bc 01       	movw	r22, r24
    3c10:	cd 01       	movw	r24, r26
    3c12:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    3c16:	dc 01       	movw	r26, r24
    3c18:	cb 01       	movw	r24, r22
    3c1a:	8b 8b       	std	Y+19, r24	; 0x13
    3c1c:	9c 8b       	std	Y+20, r25	; 0x14
    3c1e:	12 c0       	rjmp	.+36     	; 0x3c44 <ADC_Wait_8MHz+0x178>
    3c20:	82 e3       	ldi	r24, 0x32	; 50
    3c22:	90 e0       	ldi	r25, 0x00	; 0
    3c24:	8d 8b       	std	Y+21, r24	; 0x15
    3c26:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3c28:	8d 89       	ldd	r24, Y+21	; 0x15
    3c2a:	9e 89       	ldd	r25, Y+22	; 0x16
    3c2c:	8c 01       	movw	r16, r24
    3c2e:	c8 01       	movw	r24, r16
    3c30:	01 97       	sbiw	r24, 0x01	; 1
    3c32:	f1 f7       	brne	.-4      	; 0x3c30 <ADC_Wait_8MHz+0x164>
    3c34:	8c 01       	movw	r16, r24
    3c36:	0d 8b       	std	Y+21, r16	; 0x15
    3c38:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3c3a:	8b 89       	ldd	r24, Y+19	; 0x13
    3c3c:	9c 89       	ldd	r25, Y+20	; 0x14
    3c3e:	01 97       	sbiw	r24, 0x01	; 1
    3c40:	8b 8b       	std	Y+19, r24	; 0x13
    3c42:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c44:	8b 89       	ldd	r24, Y+19	; 0x13
    3c46:	9c 89       	ldd	r25, Y+20	; 0x14
    3c48:	00 97       	sbiw	r24, 0x00	; 0
    3c4a:	51 f7       	brne	.-44     	; 0x3c20 <ADC_Wait_8MHz+0x154>
    3c4c:	28 c0       	rjmp	.+80     	; 0x3c9e <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c4e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3c50:	78 89       	ldd	r23, Y+16	; 0x10
    3c52:	89 89       	ldd	r24, Y+17	; 0x11
    3c54:	9a 89       	ldd	r25, Y+18	; 0x12
    3c56:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    3c5a:	dc 01       	movw	r26, r24
    3c5c:	cb 01       	movw	r24, r22
    3c5e:	8b 8b       	std	Y+19, r24	; 0x13
    3c60:	9c 8b       	std	Y+20, r25	; 0x14
    3c62:	8b 89       	ldd	r24, Y+19	; 0x13
    3c64:	9c 89       	ldd	r25, Y+20	; 0x14
    3c66:	8f 8b       	std	Y+23, r24	; 0x17
    3c68:	98 8f       	std	Y+24, r25	; 0x18
    3c6a:	8f 89       	ldd	r24, Y+23	; 0x17
    3c6c:	98 8d       	ldd	r25, Y+24	; 0x18
    3c6e:	8c 01       	movw	r16, r24
    3c70:	f8 01       	movw	r30, r16
    3c72:	31 97       	sbiw	r30, 0x01	; 1
    3c74:	f1 f7       	brne	.-4      	; 0x3c72 <ADC_Wait_8MHz+0x1a6>
    3c76:	8f 01       	movw	r16, r30
    3c78:	0f 8b       	std	Y+23, r16	; 0x17
    3c7a:	18 8f       	std	Y+24, r17	; 0x18
    3c7c:	10 c0       	rjmp	.+32     	; 0x3c9e <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3c7e:	6e 81       	ldd	r22, Y+6	; 0x06
    3c80:	7f 81       	ldd	r23, Y+7	; 0x07
    3c82:	88 85       	ldd	r24, Y+8	; 0x08
    3c84:	99 85       	ldd	r25, Y+9	; 0x09
    3c86:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    3c8a:	dc 01       	movw	r26, r24
    3c8c:	cb 01       	movw	r24, r22
    3c8e:	8a 87       	std	Y+10, r24	; 0x0a
    3c90:	8a 85       	ldd	r24, Y+10	; 0x0a
    3c92:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3c94:	89 8d       	ldd	r24, Y+25	; 0x19
    3c96:	18 2f       	mov	r17, r24
    3c98:	1a 95       	dec	r17
    3c9a:	f1 f7       	brne	.-4      	; 0x3c98 <ADC_Wait_8MHz+0x1cc>
    3c9c:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3c9e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ca0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ca2:	29 81       	ldd	r18, Y+1	; 0x01
    3ca4:	fc 01       	movw	r30, r24
    3ca6:	24 83       	std	Z+4, r18	; 0x04
}
    3ca8:	6b 96       	adiw	r28, 0x1b	; 27
    3caa:	cd bf       	out	0x3d, r28	; 61
    3cac:	de bf       	out	0x3e, r29	; 62
    3cae:	df 91       	pop	r29
    3cb0:	cf 91       	pop	r28
    3cb2:	1f 91       	pop	r17
    3cb4:	0f 91       	pop	r16
    3cb6:	08 95       	ret

00003cb8 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    3cb8:	0f 93       	push	r16
    3cba:	1f 93       	push	r17
    3cbc:	cf 93       	push	r28
    3cbe:	df 93       	push	r29
    3cc0:	cd b7       	in	r28, 0x3d	; 61
    3cc2:	de b7       	in	r29, 0x3e	; 62
    3cc4:	6b 97       	sbiw	r28, 0x1b	; 27
    3cc6:	cd bf       	out	0x3d, r28	; 61
    3cc8:	de bf       	out	0x3e, r29	; 62
    3cca:	8a 8f       	std	Y+26, r24	; 0x1a
    3ccc:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3cce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cd0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cd2:	fc 01       	movw	r30, r24
    3cd4:	84 81       	ldd	r24, Z+4	; 0x04
    3cd6:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3cd8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cda:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cdc:	21 e0       	ldi	r18, 0x01	; 1
    3cde:	fc 01       	movw	r30, r24
    3ce0:	24 83       	std	Z+4, r18	; 0x04
    3ce2:	80 e0       	ldi	r24, 0x00	; 0
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	a0 e0       	ldi	r26, 0x00	; 0
    3ce8:	b3 e4       	ldi	r27, 0x43	; 67
    3cea:	8a 83       	std	Y+2, r24	; 0x02
    3cec:	9b 83       	std	Y+3, r25	; 0x03
    3cee:	ac 83       	std	Y+4, r26	; 0x04
    3cf0:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3cf2:	6a 81       	ldd	r22, Y+2	; 0x02
    3cf4:	7b 81       	ldd	r23, Y+3	; 0x03
    3cf6:	8c 81       	ldd	r24, Y+4	; 0x04
    3cf8:	9d 81       	ldd	r25, Y+5	; 0x05
    3cfa:	2b ea       	ldi	r18, 0xAB	; 171
    3cfc:	3a ea       	ldi	r19, 0xAA	; 170
    3cfe:	4a e2       	ldi	r20, 0x2A	; 42
    3d00:	5f e3       	ldi	r21, 0x3F	; 63
    3d02:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    3d06:	dc 01       	movw	r26, r24
    3d08:	cb 01       	movw	r24, r22
    3d0a:	8e 83       	std	Y+6, r24	; 0x06
    3d0c:	9f 83       	std	Y+7, r25	; 0x07
    3d0e:	a8 87       	std	Y+8, r26	; 0x08
    3d10:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3d12:	11 e0       	ldi	r17, 0x01	; 1
    3d14:	6e 81       	ldd	r22, Y+6	; 0x06
    3d16:	7f 81       	ldd	r23, Y+7	; 0x07
    3d18:	88 85       	ldd	r24, Y+8	; 0x08
    3d1a:	99 85       	ldd	r25, Y+9	; 0x09
    3d1c:	20 e0       	ldi	r18, 0x00	; 0
    3d1e:	30 e0       	ldi	r19, 0x00	; 0
    3d20:	40 e8       	ldi	r20, 0x80	; 128
    3d22:	5f e3       	ldi	r21, 0x3F	; 63
    3d24:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    3d28:	88 23       	and	r24, r24
    3d2a:	0c f0       	brlt	.+2      	; 0x3d2e <ADC_Wait_32MHz+0x76>
    3d2c:	10 e0       	ldi	r17, 0x00	; 0
    3d2e:	11 23       	and	r17, r17
    3d30:	19 f0       	breq	.+6      	; 0x3d38 <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3d32:	81 e0       	ldi	r24, 0x01	; 1
    3d34:	8a 87       	std	Y+10, r24	; 0x0a
    3d36:	a3 c0       	rjmp	.+326    	; 0x3e7e <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3d38:	11 e0       	ldi	r17, 0x01	; 1
    3d3a:	6e 81       	ldd	r22, Y+6	; 0x06
    3d3c:	7f 81       	ldd	r23, Y+7	; 0x07
    3d3e:	88 85       	ldd	r24, Y+8	; 0x08
    3d40:	99 85       	ldd	r25, Y+9	; 0x09
    3d42:	20 e0       	ldi	r18, 0x00	; 0
    3d44:	30 e0       	ldi	r19, 0x00	; 0
    3d46:	4f e7       	ldi	r20, 0x7F	; 127
    3d48:	53 e4       	ldi	r21, 0x43	; 67
    3d4a:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    3d4e:	18 16       	cp	r1, r24
    3d50:	0c f0       	brlt	.+2      	; 0x3d54 <ADC_Wait_32MHz+0x9c>
    3d52:	10 e0       	ldi	r17, 0x00	; 0
    3d54:	11 23       	and	r17, r17
    3d56:	09 f4       	brne	.+2      	; 0x3d5a <ADC_Wait_32MHz+0xa2>
    3d58:	89 c0       	rjmp	.+274    	; 0x3e6c <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3d5a:	6a 81       	ldd	r22, Y+2	; 0x02
    3d5c:	7b 81       	ldd	r23, Y+3	; 0x03
    3d5e:	8c 81       	ldd	r24, Y+4	; 0x04
    3d60:	9d 81       	ldd	r25, Y+5	; 0x05
    3d62:	20 e0       	ldi	r18, 0x00	; 0
    3d64:	30 e0       	ldi	r19, 0x00	; 0
    3d66:	4a e7       	ldi	r20, 0x7A	; 122
    3d68:	54 e4       	ldi	r21, 0x44	; 68
    3d6a:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    3d6e:	dc 01       	movw	r26, r24
    3d70:	cb 01       	movw	r24, r22
    3d72:	8b 87       	std	Y+11, r24	; 0x0b
    3d74:	9c 87       	std	Y+12, r25	; 0x0c
    3d76:	ad 87       	std	Y+13, r26	; 0x0d
    3d78:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3d7a:	6b 85       	ldd	r22, Y+11	; 0x0b
    3d7c:	7c 85       	ldd	r23, Y+12	; 0x0c
    3d7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d80:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d82:	20 e0       	ldi	r18, 0x00	; 0
    3d84:	30 e0       	ldi	r19, 0x00	; 0
    3d86:	4a ef       	ldi	r20, 0xFA	; 250
    3d88:	53 e4       	ldi	r21, 0x43	; 67
    3d8a:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    3d8e:	dc 01       	movw	r26, r24
    3d90:	cb 01       	movw	r24, r22
    3d92:	8f 87       	std	Y+15, r24	; 0x0f
    3d94:	98 8b       	std	Y+16, r25	; 0x10
    3d96:	a9 8b       	std	Y+17, r26	; 0x11
    3d98:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3d9a:	11 e0       	ldi	r17, 0x01	; 1
    3d9c:	6f 85       	ldd	r22, Y+15	; 0x0f
    3d9e:	78 89       	ldd	r23, Y+16	; 0x10
    3da0:	89 89       	ldd	r24, Y+17	; 0x11
    3da2:	9a 89       	ldd	r25, Y+18	; 0x12
    3da4:	20 e0       	ldi	r18, 0x00	; 0
    3da6:	30 e0       	ldi	r19, 0x00	; 0
    3da8:	40 e8       	ldi	r20, 0x80	; 128
    3daa:	5f e3       	ldi	r21, 0x3F	; 63
    3dac:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    3db0:	88 23       	and	r24, r24
    3db2:	0c f0       	brlt	.+2      	; 0x3db6 <ADC_Wait_32MHz+0xfe>
    3db4:	10 e0       	ldi	r17, 0x00	; 0
    3db6:	11 23       	and	r17, r17
    3db8:	29 f0       	breq	.+10     	; 0x3dc4 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    3dba:	81 e0       	ldi	r24, 0x01	; 1
    3dbc:	90 e0       	ldi	r25, 0x00	; 0
    3dbe:	8b 8b       	std	Y+19, r24	; 0x13
    3dc0:	9c 8b       	std	Y+20, r25	; 0x14
    3dc2:	46 c0       	rjmp	.+140    	; 0x3e50 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3dc4:	11 e0       	ldi	r17, 0x01	; 1
    3dc6:	6f 85       	ldd	r22, Y+15	; 0x0f
    3dc8:	78 89       	ldd	r23, Y+16	; 0x10
    3dca:	89 89       	ldd	r24, Y+17	; 0x11
    3dcc:	9a 89       	ldd	r25, Y+18	; 0x12
    3dce:	20 e0       	ldi	r18, 0x00	; 0
    3dd0:	3f ef       	ldi	r19, 0xFF	; 255
    3dd2:	4f e7       	ldi	r20, 0x7F	; 127
    3dd4:	57 e4       	ldi	r21, 0x47	; 71
    3dd6:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    3dda:	18 16       	cp	r1, r24
    3ddc:	0c f0       	brlt	.+2      	; 0x3de0 <ADC_Wait_32MHz+0x128>
    3dde:	10 e0       	ldi	r17, 0x00	; 0
    3de0:	11 23       	and	r17, r17
    3de2:	61 f1       	breq	.+88     	; 0x3e3c <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3de4:	6b 85       	ldd	r22, Y+11	; 0x0b
    3de6:	7c 85       	ldd	r23, Y+12	; 0x0c
    3de8:	8d 85       	ldd	r24, Y+13	; 0x0d
    3dea:	9e 85       	ldd	r25, Y+14	; 0x0e
    3dec:	20 e0       	ldi	r18, 0x00	; 0
    3dee:	30 e0       	ldi	r19, 0x00	; 0
    3df0:	40 e2       	ldi	r20, 0x20	; 32
    3df2:	51 e4       	ldi	r21, 0x41	; 65
    3df4:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    3df8:	dc 01       	movw	r26, r24
    3dfa:	cb 01       	movw	r24, r22
    3dfc:	bc 01       	movw	r22, r24
    3dfe:	cd 01       	movw	r24, r26
    3e00:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    3e04:	dc 01       	movw	r26, r24
    3e06:	cb 01       	movw	r24, r22
    3e08:	8b 8b       	std	Y+19, r24	; 0x13
    3e0a:	9c 8b       	std	Y+20, r25	; 0x14
    3e0c:	12 c0       	rjmp	.+36     	; 0x3e32 <ADC_Wait_32MHz+0x17a>
    3e0e:	82 e3       	ldi	r24, 0x32	; 50
    3e10:	90 e0       	ldi	r25, 0x00	; 0
    3e12:	8d 8b       	std	Y+21, r24	; 0x15
    3e14:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3e16:	8d 89       	ldd	r24, Y+21	; 0x15
    3e18:	9e 89       	ldd	r25, Y+22	; 0x16
    3e1a:	8c 01       	movw	r16, r24
    3e1c:	c8 01       	movw	r24, r16
    3e1e:	01 97       	sbiw	r24, 0x01	; 1
    3e20:	f1 f7       	brne	.-4      	; 0x3e1e <ADC_Wait_32MHz+0x166>
    3e22:	8c 01       	movw	r16, r24
    3e24:	0d 8b       	std	Y+21, r16	; 0x15
    3e26:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e28:	8b 89       	ldd	r24, Y+19	; 0x13
    3e2a:	9c 89       	ldd	r25, Y+20	; 0x14
    3e2c:	01 97       	sbiw	r24, 0x01	; 1
    3e2e:	8b 8b       	std	Y+19, r24	; 0x13
    3e30:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e32:	8b 89       	ldd	r24, Y+19	; 0x13
    3e34:	9c 89       	ldd	r25, Y+20	; 0x14
    3e36:	00 97       	sbiw	r24, 0x00	; 0
    3e38:	51 f7       	brne	.-44     	; 0x3e0e <ADC_Wait_32MHz+0x156>
    3e3a:	28 c0       	rjmp	.+80     	; 0x3e8c <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e3c:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e3e:	78 89       	ldd	r23, Y+16	; 0x10
    3e40:	89 89       	ldd	r24, Y+17	; 0x11
    3e42:	9a 89       	ldd	r25, Y+18	; 0x12
    3e44:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    3e48:	dc 01       	movw	r26, r24
    3e4a:	cb 01       	movw	r24, r22
    3e4c:	8b 8b       	std	Y+19, r24	; 0x13
    3e4e:	9c 8b       	std	Y+20, r25	; 0x14
    3e50:	8b 89       	ldd	r24, Y+19	; 0x13
    3e52:	9c 89       	ldd	r25, Y+20	; 0x14
    3e54:	8f 8b       	std	Y+23, r24	; 0x17
    3e56:	98 8f       	std	Y+24, r25	; 0x18
    3e58:	8f 89       	ldd	r24, Y+23	; 0x17
    3e5a:	98 8d       	ldd	r25, Y+24	; 0x18
    3e5c:	8c 01       	movw	r16, r24
    3e5e:	f8 01       	movw	r30, r16
    3e60:	31 97       	sbiw	r30, 0x01	; 1
    3e62:	f1 f7       	brne	.-4      	; 0x3e60 <ADC_Wait_32MHz+0x1a8>
    3e64:	8f 01       	movw	r16, r30
    3e66:	0f 8b       	std	Y+23, r16	; 0x17
    3e68:	18 8f       	std	Y+24, r17	; 0x18
    3e6a:	10 c0       	rjmp	.+32     	; 0x3e8c <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3e6c:	6e 81       	ldd	r22, Y+6	; 0x06
    3e6e:	7f 81       	ldd	r23, Y+7	; 0x07
    3e70:	88 85       	ldd	r24, Y+8	; 0x08
    3e72:	99 85       	ldd	r25, Y+9	; 0x09
    3e74:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    3e78:	dc 01       	movw	r26, r24
    3e7a:	cb 01       	movw	r24, r22
    3e7c:	8a 87       	std	Y+10, r24	; 0x0a
    3e7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e80:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3e82:	89 8d       	ldd	r24, Y+25	; 0x19
    3e84:	18 2f       	mov	r17, r24
    3e86:	1a 95       	dec	r17
    3e88:	f1 f7       	brne	.-4      	; 0x3e86 <ADC_Wait_32MHz+0x1ce>
    3e8a:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3e8c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3e8e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3e90:	29 81       	ldd	r18, Y+1	; 0x01
    3e92:	fc 01       	movw	r30, r24
    3e94:	24 83       	std	Z+4, r18	; 0x04
}
    3e96:	6b 96       	adiw	r28, 0x1b	; 27
    3e98:	cd bf       	out	0x3d, r28	; 61
    3e9a:	de bf       	out	0x3e, r29	; 62
    3e9c:	df 91       	pop	r29
    3e9e:	cf 91       	pop	r28
    3ea0:	1f 91       	pop	r17
    3ea2:	0f 91       	pop	r16
    3ea4:	08 95       	ret

00003ea6 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3ea6:	cf 93       	push	r28
    3ea8:	df 93       	push	r29
    3eaa:	cd b7       	in	r28, 0x3d	; 61
    3eac:	de b7       	in	r29, 0x3e	; 62
    3eae:	2a 97       	sbiw	r28, 0x0a	; 10
    3eb0:	cd bf       	out	0x3d, r28	; 61
    3eb2:	de bf       	out	0x3e, r29	; 62
    3eb4:	8e 83       	std	Y+6, r24	; 0x06
    3eb6:	9f 83       	std	Y+7, r25	; 0x07
    3eb8:	68 87       	std	Y+8, r22	; 0x08
    3eba:	79 87       	std	Y+9, r23	; 0x09
    3ebc:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3ebe:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ec0:	88 23       	and	r24, r24
    3ec2:	a9 f1       	breq	.+106    	; 0x3f2e <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3ec4:	19 82       	std	Y+1, r1	; 0x01
    3ec6:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3ec8:	1b 82       	std	Y+3, r1	; 0x03
    3eca:	1c 82       	std	Y+4, r1	; 0x04
    3ecc:	24 c0       	rjmp	.+72     	; 0x3f16 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3ece:	88 85       	ldd	r24, Y+8	; 0x08
    3ed0:	99 85       	ldd	r25, Y+9	; 0x09
    3ed2:	fc 01       	movw	r30, r24
    3ed4:	80 81       	ld	r24, Z
    3ed6:	28 2f       	mov	r18, r24
    3ed8:	20 68       	ori	r18, 0x80	; 128
    3eda:	88 85       	ldd	r24, Y+8	; 0x08
    3edc:	99 85       	ldd	r25, Y+9	; 0x09
    3ede:	fc 01       	movw	r30, r24
    3ee0:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3ee2:	88 85       	ldd	r24, Y+8	; 0x08
    3ee4:	99 85       	ldd	r25, Y+9	; 0x09
    3ee6:	fc 01       	movw	r30, r24
    3ee8:	83 81       	ldd	r24, Z+3	; 0x03
    3eea:	88 2f       	mov	r24, r24
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	81 70       	andi	r24, 0x01	; 1
    3ef0:	90 70       	andi	r25, 0x00	; 0
    3ef2:	00 97       	sbiw	r24, 0x00	; 0
    3ef4:	b1 f3       	breq	.-20     	; 0x3ee2 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3ef6:	88 85       	ldd	r24, Y+8	; 0x08
    3ef8:	99 85       	ldd	r25, Y+9	; 0x09
    3efa:	60 e0       	ldi	r22, 0x00	; 0
    3efc:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <ADC_ResultCh_GetWord_Unsigned>
    3f00:	29 81       	ldd	r18, Y+1	; 0x01
    3f02:	3a 81       	ldd	r19, Y+2	; 0x02
    3f04:	82 0f       	add	r24, r18
    3f06:	93 1f       	adc	r25, r19
    3f08:	89 83       	std	Y+1, r24	; 0x01
    3f0a:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f10:	01 96       	adiw	r24, 0x01	; 1
    3f12:	8b 83       	std	Y+3, r24	; 0x03
    3f14:	9c 83       	std	Y+4, r25	; 0x04
    3f16:	8b 81       	ldd	r24, Y+3	; 0x03
    3f18:	9c 81       	ldd	r25, Y+4	; 0x04
    3f1a:	84 30       	cpi	r24, 0x04	; 4
    3f1c:	91 05       	cpc	r25, r1
    3f1e:	bc f2       	brlt	.-82     	; 0x3ece <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3f20:	89 81       	ldd	r24, Y+1	; 0x01
    3f22:	9a 81       	ldd	r25, Y+2	; 0x02
    3f24:	96 95       	lsr	r25
    3f26:	87 95       	ror	r24
    3f28:	96 95       	lsr	r25
    3f2a:	87 95       	ror	r24
    3f2c:	1b c0       	rjmp	.+54     	; 0x3f64 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3f2e:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3f30:	88 85       	ldd	r24, Y+8	; 0x08
    3f32:	99 85       	ldd	r25, Y+9	; 0x09
    3f34:	fc 01       	movw	r30, r24
    3f36:	80 81       	ld	r24, Z
    3f38:	28 2f       	mov	r18, r24
    3f3a:	20 68       	ori	r18, 0x80	; 128
    3f3c:	88 85       	ldd	r24, Y+8	; 0x08
    3f3e:	99 85       	ldd	r25, Y+9	; 0x09
    3f40:	fc 01       	movw	r30, r24
    3f42:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3f44:	88 85       	ldd	r24, Y+8	; 0x08
    3f46:	99 85       	ldd	r25, Y+9	; 0x09
    3f48:	fc 01       	movw	r30, r24
    3f4a:	83 81       	ldd	r24, Z+3	; 0x03
    3f4c:	88 2f       	mov	r24, r24
    3f4e:	90 e0       	ldi	r25, 0x00	; 0
    3f50:	81 70       	andi	r24, 0x01	; 1
    3f52:	90 70       	andi	r25, 0x00	; 0
    3f54:	00 97       	sbiw	r24, 0x00	; 0
    3f56:	b1 f3       	breq	.-20     	; 0x3f44 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3f58:	88 85       	ldd	r24, Y+8	; 0x08
    3f5a:	99 85       	ldd	r25, Y+9	; 0x09
    3f5c:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <ADC_ResultCh_GetWord>
    3f60:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3f62:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3f64:	2a 96       	adiw	r28, 0x0a	; 10
    3f66:	cd bf       	out	0x3d, r28	; 61
    3f68:	de bf       	out	0x3e, r29	; 62
    3f6a:	df 91       	pop	r29
    3f6c:	cf 91       	pop	r28
    3f6e:	08 95       	ret

00003f70 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3f70:	cf 93       	push	r28
    3f72:	df 93       	push	r29
    3f74:	cd b7       	in	r28, 0x3d	; 61
    3f76:	de b7       	in	r29, 0x3e	; 62
    3f78:	2a 97       	sbiw	r28, 0x0a	; 10
    3f7a:	cd bf       	out	0x3d, r28	; 61
    3f7c:	de bf       	out	0x3e, r29	; 62
    3f7e:	8e 83       	std	Y+6, r24	; 0x06
    3f80:	9f 83       	std	Y+7, r25	; 0x07
    3f82:	68 87       	std	Y+8, r22	; 0x08
    3f84:	79 87       	std	Y+9, r23	; 0x09
    3f86:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3f88:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f8a:	88 23       	and	r24, r24
    3f8c:	c1 f1       	breq	.+112    	; 0x3ffe <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3f8e:	19 82       	std	Y+1, r1	; 0x01
    3f90:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3f92:	1b 82       	std	Y+3, r1	; 0x03
    3f94:	1c 82       	std	Y+4, r1	; 0x04
    3f96:	24 c0       	rjmp	.+72     	; 0x3fe0 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3f98:	88 85       	ldd	r24, Y+8	; 0x08
    3f9a:	99 85       	ldd	r25, Y+9	; 0x09
    3f9c:	fc 01       	movw	r30, r24
    3f9e:	80 81       	ld	r24, Z
    3fa0:	28 2f       	mov	r18, r24
    3fa2:	20 68       	ori	r18, 0x80	; 128
    3fa4:	88 85       	ldd	r24, Y+8	; 0x08
    3fa6:	99 85       	ldd	r25, Y+9	; 0x09
    3fa8:	fc 01       	movw	r30, r24
    3faa:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3fac:	88 85       	ldd	r24, Y+8	; 0x08
    3fae:	99 85       	ldd	r25, Y+9	; 0x09
    3fb0:	fc 01       	movw	r30, r24
    3fb2:	83 81       	ldd	r24, Z+3	; 0x03
    3fb4:	88 2f       	mov	r24, r24
    3fb6:	90 e0       	ldi	r25, 0x00	; 0
    3fb8:	81 70       	andi	r24, 0x01	; 1
    3fba:	90 70       	andi	r25, 0x00	; 0
    3fbc:	00 97       	sbiw	r24, 0x00	; 0
    3fbe:	b1 f3       	breq	.-20     	; 0x3fac <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3fc0:	88 85       	ldd	r24, Y+8	; 0x08
    3fc2:	99 85       	ldd	r25, Y+9	; 0x09
    3fc4:	60 e0       	ldi	r22, 0x00	; 0
    3fc6:	0e 94 fd 1c 	call	0x39fa	; 0x39fa <ADC_ResultCh_GetWord_Signed>
    3fca:	29 81       	ldd	r18, Y+1	; 0x01
    3fcc:	3a 81       	ldd	r19, Y+2	; 0x02
    3fce:	82 0f       	add	r24, r18
    3fd0:	93 1f       	adc	r25, r19
    3fd2:	89 83       	std	Y+1, r24	; 0x01
    3fd4:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fda:	01 96       	adiw	r24, 0x01	; 1
    3fdc:	8b 83       	std	Y+3, r24	; 0x03
    3fde:	9c 83       	std	Y+4, r25	; 0x04
    3fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    3fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    3fe4:	84 30       	cpi	r24, 0x04	; 4
    3fe6:	91 05       	cpc	r25, r1
    3fe8:	bc f2       	brlt	.-82     	; 0x3f98 <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3fea:	89 81       	ldd	r24, Y+1	; 0x01
    3fec:	9a 81       	ldd	r25, Y+2	; 0x02
    3fee:	99 23       	and	r25, r25
    3ff0:	0c f4       	brge	.+2      	; 0x3ff4 <ADC_Offset_Get_Signed+0x84>
    3ff2:	03 96       	adiw	r24, 0x03	; 3
    3ff4:	95 95       	asr	r25
    3ff6:	87 95       	ror	r24
    3ff8:	95 95       	asr	r25
    3ffa:	87 95       	ror	r24
    3ffc:	1c c0       	rjmp	.+56     	; 0x4036 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3ffe:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    4000:	88 85       	ldd	r24, Y+8	; 0x08
    4002:	99 85       	ldd	r25, Y+9	; 0x09
    4004:	fc 01       	movw	r30, r24
    4006:	80 81       	ld	r24, Z
    4008:	28 2f       	mov	r18, r24
    400a:	20 68       	ori	r18, 0x80	; 128
    400c:	88 85       	ldd	r24, Y+8	; 0x08
    400e:	99 85       	ldd	r25, Y+9	; 0x09
    4010:	fc 01       	movw	r30, r24
    4012:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    4014:	88 85       	ldd	r24, Y+8	; 0x08
    4016:	99 85       	ldd	r25, Y+9	; 0x09
    4018:	fc 01       	movw	r30, r24
    401a:	83 81       	ldd	r24, Z+3	; 0x03
    401c:	88 2f       	mov	r24, r24
    401e:	90 e0       	ldi	r25, 0x00	; 0
    4020:	81 70       	andi	r24, 0x01	; 1
    4022:	90 70       	andi	r25, 0x00	; 0
    4024:	00 97       	sbiw	r24, 0x00	; 0
    4026:	b1 f3       	breq	.-20     	; 0x4014 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    4028:	88 85       	ldd	r24, Y+8	; 0x08
    402a:	99 85       	ldd	r25, Y+9	; 0x09
    402c:	60 e0       	ldi	r22, 0x00	; 0
    402e:	0e 94 fd 1c 	call	0x39fa	; 0x39fa <ADC_ResultCh_GetWord_Signed>
    4032:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    4034:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    4036:	2a 96       	adiw	r28, 0x0a	; 10
    4038:	cd bf       	out	0x3d, r28	; 61
    403a:	de bf       	out	0x3e, r29	; 62
    403c:	df 91       	pop	r29
    403e:	cf 91       	pop	r28
    4040:	08 95       	ret

00004042 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    4042:	1f 93       	push	r17
    4044:	cf 93       	push	r28
    4046:	df 93       	push	r29
    4048:	cd b7       	in	r28, 0x3d	; 61
    404a:	de b7       	in	r29, 0x3e	; 62
    404c:	25 97       	sbiw	r28, 0x05	; 5
    404e:	cd bf       	out	0x3d, r28	; 61
    4050:	de bf       	out	0x3e, r29	; 62
    4052:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    4054:	8a ec       	ldi	r24, 0xCA	; 202
    4056:	91 e0       	ldi	r25, 0x01	; 1
    4058:	22 e0       	ldi	r18, 0x02	; 2
    405a:	fc 01       	movw	r30, r24
    405c:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    405e:	8d 81       	ldd	r24, Y+5	; 0x05
    4060:	88 2f       	mov	r24, r24
    4062:	90 e0       	ldi	r25, 0x00	; 0
    4064:	89 83       	std	Y+1, r24	; 0x01
    4066:	9a 83       	std	Y+2, r25	; 0x02
    4068:	89 81       	ldd	r24, Y+1	; 0x01
    406a:	9a 81       	ldd	r25, Y+2	; 0x02
    406c:	fc 01       	movw	r30, r24
    406e:	14 91       	lpm	r17, Z
    4070:	1b 83       	std	Y+3, r17	; 0x03
    4072:	8b 81       	ldd	r24, Y+3	; 0x03
    4074:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    4076:	8a ec       	ldi	r24, 0xCA	; 202
    4078:	91 e0       	ldi	r25, 0x01	; 1
    407a:	fc 01       	movw	r30, r24
    407c:	10 82       	st	Z, r1

	return result;
    407e:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4080:	25 96       	adiw	r28, 0x05	; 5
    4082:	cd bf       	out	0x3d, r28	; 61
    4084:	de bf       	out	0x3e, r29	; 62
    4086:	df 91       	pop	r29
    4088:	cf 91       	pop	r28
    408a:	1f 91       	pop	r17
    408c:	08 95       	ret

0000408e <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    408e:	cf 93       	push	r28
    4090:	df 93       	push	r29
    4092:	cd b7       	in	r28, 0x3d	; 61
    4094:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    4096:	24 e1       	ldi	r18, 0x14	; 20
    4098:	84 e3       	ldi	r24, 0x34	; 52
    409a:	91 e2       	ldi	r25, 0x21	; 33
    409c:	fc 01       	movw	r30, r24
    409e:	32 2f       	mov	r19, r18
    40a0:	11 92       	st	Z+, r1
    40a2:	3a 95       	dec	r19
    40a4:	e9 f7       	brne	.-6      	; 0x40a0 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    40a6:	0e 94 07 2e 	call	0x5c0e	; 0x5c0e <chb_get_short_addr>
    40aa:	80 93 34 21 	sts	0x2134, r24
    40ae:	90 93 35 21 	sts	0x2135, r25
    chb_drvr_init();
    40b2:	0e 94 fb 2f 	call	0x5ff6	; 0x5ff6 <chb_drvr_init>
	radio_msg_received_int_enable();
    40b6:	0e 94 60 20 	call	0x40c0	; 0x40c0 <radio_msg_received_int_enable>
}
    40ba:	df 91       	pop	r29
    40bc:	cf 91       	pop	r28
    40be:	08 95       	ret

000040c0 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    40c0:	cf 93       	push	r28
    40c2:	df 93       	push	r29
    40c4:	cd b7       	in	r28, 0x3d	; 61
    40c6:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    40c8:	80 e8       	ldi	r24, 0x80	; 128
    40ca:	96 e0       	ldi	r25, 0x06	; 6
    40cc:	24 e0       	ldi	r18, 0x04	; 4
    40ce:	fc 01       	movw	r30, r24
    40d0:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    40d2:	80 e8       	ldi	r24, 0x80	; 128
    40d4:	96 e0       	ldi	r25, 0x06	; 6
    40d6:	24 e0       	ldi	r18, 0x04	; 4
    40d8:	fc 01       	movw	r30, r24
    40da:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    40dc:	80 e8       	ldi	r24, 0x80	; 128
    40de:	96 e0       	ldi	r25, 0x06	; 6
    40e0:	22 e0       	ldi	r18, 0x02	; 2
    40e2:	fc 01       	movw	r30, r24
    40e4:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    40e6:	80 e8       	ldi	r24, 0x80	; 128
    40e8:	96 e0       	ldi	r25, 0x06	; 6
    40ea:	24 e0       	ldi	r18, 0x04	; 4
    40ec:	fc 01       	movw	r30, r24
    40ee:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_LO_gc;
    40f0:	80 e8       	ldi	r24, 0x80	; 128
    40f2:	96 e0       	ldi	r25, 0x06	; 6
    40f4:	21 e0       	ldi	r18, 0x01	; 1
    40f6:	fc 01       	movw	r30, r24
    40f8:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    40fa:	80 ea       	ldi	r24, 0xA0	; 160
    40fc:	90 e0       	ldi	r25, 0x00	; 0
    40fe:	20 ea       	ldi	r18, 0xA0	; 160
    4100:	30 e0       	ldi	r19, 0x00	; 0
    4102:	f9 01       	movw	r30, r18
    4104:	22 81       	ldd	r18, Z+2	; 0x02
    4106:	21 60       	ori	r18, 0x01	; 1
    4108:	fc 01       	movw	r30, r24
    410a:	22 83       	std	Z+2, r18	; 0x02
	sei();
    410c:	78 94       	sei
}
    410e:	df 91       	pop	r29
    4110:	cf 91       	pop	r28
    4112:	08 95       	ret

00004114 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    4114:	cf 93       	push	r28
    4116:	df 93       	push	r29
    4118:	cd b7       	in	r28, 0x3d	; 61
    411a:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    411c:	84 e3       	ldi	r24, 0x34	; 52
    411e:	91 e2       	ldi	r25, 0x21	; 33
}
    4120:	df 91       	pop	r29
    4122:	cf 91       	pop	r28
    4124:	08 95       	ret

00004126 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    4126:	cf 93       	push	r28
    4128:	df 93       	push	r29
    412a:	cd b7       	in	r28, 0x3d	; 61
    412c:	de b7       	in	r29, 0x3e	; 62
    412e:	27 97       	sbiw	r28, 0x07	; 7
    4130:	cd bf       	out	0x3d, r28	; 61
    4132:	de bf       	out	0x3e, r29	; 62
    4134:	8b 83       	std	Y+3, r24	; 0x03
    4136:	9c 83       	std	Y+4, r25	; 0x04
    4138:	6d 83       	std	Y+5, r22	; 0x05
    413a:	7e 83       	std	Y+6, r23	; 0x06
    413c:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    413e:	8b 81       	ldd	r24, Y+3	; 0x03
    4140:	9c 81       	ldd	r25, Y+4	; 0x04
    4142:	89 83       	std	Y+1, r24	; 0x01
    4144:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    4146:	8f 81       	ldd	r24, Y+7	; 0x07
    4148:	28 2f       	mov	r18, r24
    414a:	25 5f       	subi	r18, 0xF5	; 245
    414c:	89 81       	ldd	r24, Y+1	; 0x01
    414e:	9a 81       	ldd	r25, Y+2	; 0x02
    4150:	fc 01       	movw	r30, r24
    4152:	20 83       	st	Z, r18
    4154:	89 81       	ldd	r24, Y+1	; 0x01
    4156:	9a 81       	ldd	r25, Y+2	; 0x02
    4158:	01 96       	adiw	r24, 0x01	; 1
    415a:	89 83       	std	Y+1, r24	; 0x01
    415c:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    415e:	8d 81       	ldd	r24, Y+5	; 0x05
    4160:	9e 81       	ldd	r25, Y+6	; 0x06
    4162:	ff ef       	ldi	r31, 0xFF	; 255
    4164:	8f 3f       	cpi	r24, 0xFF	; 255
    4166:	9f 07       	cpc	r25, r31
    4168:	11 f0       	breq	.+4      	; 0x416e <chb_gen_hdr+0x48>
    416a:	21 e6       	ldi	r18, 0x61	; 97
    416c:	01 c0       	rjmp	.+2      	; 0x4170 <chb_gen_hdr+0x4a>
    416e:	21 e4       	ldi	r18, 0x41	; 65
    4170:	89 81       	ldd	r24, Y+1	; 0x01
    4172:	9a 81       	ldd	r25, Y+2	; 0x02
    4174:	fc 01       	movw	r30, r24
    4176:	20 83       	st	Z, r18
    4178:	89 81       	ldd	r24, Y+1	; 0x01
    417a:	9a 81       	ldd	r25, Y+2	; 0x02
    417c:	01 96       	adiw	r24, 0x01	; 1
    417e:	89 83       	std	Y+1, r24	; 0x01
    4180:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    4182:	89 81       	ldd	r24, Y+1	; 0x01
    4184:	9a 81       	ldd	r25, Y+2	; 0x02
    4186:	28 e9       	ldi	r18, 0x98	; 152
    4188:	fc 01       	movw	r30, r24
    418a:	20 83       	st	Z, r18
    418c:	89 81       	ldd	r24, Y+1	; 0x01
    418e:	9a 81       	ldd	r25, Y+2	; 0x02
    4190:	01 96       	adiw	r24, 0x01	; 1
    4192:	89 83       	std	Y+1, r24	; 0x01
    4194:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    4196:	20 91 36 21 	lds	r18, 0x2136
    419a:	89 81       	ldd	r24, Y+1	; 0x01
    419c:	9a 81       	ldd	r25, Y+2	; 0x02
    419e:	fc 01       	movw	r30, r24
    41a0:	20 83       	st	Z, r18
    41a2:	89 81       	ldd	r24, Y+1	; 0x01
    41a4:	9a 81       	ldd	r25, Y+2	; 0x02
    41a6:	01 96       	adiw	r24, 0x01	; 1
    41a8:	89 83       	std	Y+1, r24	; 0x01
    41aa:	9a 83       	std	Y+2, r25	; 0x02
    41ac:	82 2f       	mov	r24, r18
    41ae:	8f 5f       	subi	r24, 0xFF	; 255
    41b0:	80 93 36 21 	sts	0x2136, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    41b4:	89 81       	ldd	r24, Y+1	; 0x01
    41b6:	9a 81       	ldd	r25, Y+2	; 0x02
    41b8:	24 e3       	ldi	r18, 0x34	; 52
    41ba:	32 e1       	ldi	r19, 0x12	; 18
    41bc:	fc 01       	movw	r30, r24
    41be:	20 83       	st	Z, r18
    41c0:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41c2:	89 81       	ldd	r24, Y+1	; 0x01
    41c4:	9a 81       	ldd	r25, Y+2	; 0x02
    41c6:	02 96       	adiw	r24, 0x02	; 2
    41c8:	89 83       	std	Y+1, r24	; 0x01
    41ca:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    41cc:	89 81       	ldd	r24, Y+1	; 0x01
    41ce:	9a 81       	ldd	r25, Y+2	; 0x02
    41d0:	2d 81       	ldd	r18, Y+5	; 0x05
    41d2:	3e 81       	ldd	r19, Y+6	; 0x06
    41d4:	fc 01       	movw	r30, r24
    41d6:	20 83       	st	Z, r18
    41d8:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41da:	89 81       	ldd	r24, Y+1	; 0x01
    41dc:	9a 81       	ldd	r25, Y+2	; 0x02
    41de:	02 96       	adiw	r24, 0x02	; 2
    41e0:	89 83       	std	Y+1, r24	; 0x01
    41e2:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    41e4:	20 91 34 21 	lds	r18, 0x2134
    41e8:	30 91 35 21 	lds	r19, 0x2135
    41ec:	89 81       	ldd	r24, Y+1	; 0x01
    41ee:	9a 81       	ldd	r25, Y+2	; 0x02
    41f0:	fc 01       	movw	r30, r24
    41f2:	20 83       	st	Z, r18
    41f4:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41f6:	89 81       	ldd	r24, Y+1	; 0x01
    41f8:	9a 81       	ldd	r25, Y+2	; 0x02
    41fa:	02 96       	adiw	r24, 0x02	; 2
    41fc:	89 83       	std	Y+1, r24	; 0x01
    41fe:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    4200:	29 81       	ldd	r18, Y+1	; 0x01
    4202:	3a 81       	ldd	r19, Y+2	; 0x02
    4204:	8b 81       	ldd	r24, Y+3	; 0x03
    4206:	9c 81       	ldd	r25, Y+4	; 0x04
    4208:	a9 01       	movw	r20, r18
    420a:	48 1b       	sub	r20, r24
    420c:	59 0b       	sbc	r21, r25
    420e:	ca 01       	movw	r24, r20
}
    4210:	27 96       	adiw	r28, 0x07	; 7
    4212:	cd bf       	out	0x3d, r28	; 61
    4214:	de bf       	out	0x3e, r29	; 62
    4216:	df 91       	pop	r29
    4218:	cf 91       	pop	r28
    421a:	08 95       	ret

0000421c <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    421c:	ef 92       	push	r14
    421e:	ff 92       	push	r15
    4220:	0f 93       	push	r16
    4222:	1f 93       	push	r17
    4224:	cf 93       	push	r28
    4226:	df 93       	push	r29
    4228:	cd b7       	in	r28, 0x3d	; 61
    422a:	de b7       	in	r29, 0x3e	; 62
    422c:	e0 97       	sbiw	r28, 0x30	; 48
    422e:	cd bf       	out	0x3d, r28	; 61
    4230:	de bf       	out	0x3e, r29	; 62
    4232:	89 a7       	lds	r24, 0x79
    4234:	9a a7       	lds	r25, 0x7a
    4236:	6b a7       	lds	r22, 0x7b
    4238:	7c a7       	lds	r23, 0x7c
    423a:	2d a7       	lds	r18, 0x7d
    423c:	3e a7       	lds	r19, 0x7e
    423e:	4f a7       	lds	r20, 0x7f
    4240:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    4242:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    4244:	5c c1       	rjmp	.+696    	; 0x44fe <chb_write+0x2e2>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    4246:	8d a5       	lds	r24, 0x6d
    4248:	9e a5       	lds	r25, 0x6e
    424a:	af a5       	lds	r26, 0x6f
    424c:	b8 a9       	sts	0x48, r27
    424e:	85 36       	cpi	r24, 0x65	; 101
    4250:	91 05       	cpc	r25, r1
    4252:	a1 05       	cpc	r26, r1
    4254:	b1 05       	cpc	r27, r1
    4256:	20 f0       	brcs	.+8      	; 0x4260 <chb_write+0x44>
    4258:	84 e6       	ldi	r24, 0x64	; 100
    425a:	90 e0       	ldi	r25, 0x00	; 0
    425c:	a0 e0       	ldi	r26, 0x00	; 0
    425e:	b0 e0       	ldi	r27, 0x00	; 0
    4260:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    4262:	ce 01       	movw	r24, r28
    4264:	4f 96       	adiw	r24, 0x1f	; 31
    4266:	29 a5       	lds	r18, 0x69
    4268:	3a a5       	lds	r19, 0x6a
    426a:	b9 01       	movw	r22, r18
    426c:	4c 81       	ldd	r20, Y+4	; 0x04
    426e:	0e 94 93 20 	call	0x4126	; 0x4126 <chb_gen_hdr>
    4272:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    4274:	1a 82       	std	Y+2, r1	; 0x02
    4276:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    4278:	89 81       	ldd	r24, Y+1	; 0x01
    427a:	88 2f       	mov	r24, r24
    427c:	90 e0       	ldi	r25, 0x00	; 0
    427e:	2b a5       	lds	r18, 0x6b
    4280:	3c a5       	lds	r19, 0x6c
    4282:	28 0f       	add	r18, r24
    4284:	39 1f       	adc	r19, r25
    4286:	ce 01       	movw	r24, r28
    4288:	4f 96       	adiw	r24, 0x1f	; 31
    428a:	b9 01       	movw	r22, r18
    428c:	4c 81       	ldd	r20, Y+4	; 0x04
    428e:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <chb_tx>
    4292:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    4294:	8e 81       	ldd	r24, Y+6	; 0x06
    4296:	88 2f       	mov	r24, r24
    4298:	90 e0       	ldi	r25, 0x00	; 0
    429a:	83 30       	cpi	r24, 0x03	; 3
    429c:	91 05       	cpc	r25, r1
    429e:	09 f1       	breq	.+66     	; 0x42e2 <chb_write+0xc6>
    42a0:	84 30       	cpi	r24, 0x04	; 4
    42a2:	91 05       	cpc	r25, r1
    42a4:	24 f4       	brge	.+8      	; 0x42ae <chb_write+0x92>
    42a6:	81 30       	cpi	r24, 0x01	; 1
    42a8:	91 05       	cpc	r25, r1
    42aa:	39 f0       	breq	.+14     	; 0x42ba <chb_write+0x9e>
    42ac:	24 c0       	rjmp	.+72     	; 0x42f6 <chb_write+0xda>
    42ae:	85 30       	cpi	r24, 0x05	; 5
    42b0:	91 05       	cpc	r25, r1
    42b2:	69 f0       	breq	.+26     	; 0x42ce <chb_write+0xb2>
    42b4:	80 34       	cpi	r24, 0x40	; 64
    42b6:	91 05       	cpc	r25, r1
    42b8:	f1 f4       	brne	.+60     	; 0x42f6 <chb_write+0xda>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    42ba:	80 91 3b 21 	lds	r24, 0x213B
    42be:	90 91 3c 21 	lds	r25, 0x213C
    42c2:	01 96       	adiw	r24, 0x01	; 1
    42c4:	80 93 3b 21 	sts	0x213B, r24
    42c8:	90 93 3c 21 	sts	0x213C, r25
                 break;
    42cc:	15 c0       	rjmp	.+42     	; 0x42f8 <chb_write+0xdc>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    42ce:	80 91 3d 21 	lds	r24, 0x213D
    42d2:	90 91 3e 21 	lds	r25, 0x213E
    42d6:	01 96       	adiw	r24, 0x01	; 1
    42d8:	80 93 3d 21 	sts	0x213D, r24
    42dc:	90 93 3e 21 	sts	0x213E, r25
                 break;
    42e0:	0b c0       	rjmp	.+22     	; 0x42f8 <chb_write+0xdc>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    42e2:	80 91 3f 21 	lds	r24, 0x213F
    42e6:	90 91 40 21 	lds	r25, 0x2140
    42ea:	01 96       	adiw	r24, 0x01	; 1
    42ec:	80 93 3f 21 	sts	0x213F, r24
    42f0:	90 93 40 21 	sts	0x2140, r25
                 break;
    42f4:	01 c0       	rjmp	.+2      	; 0x42f8 <chb_write+0xdc>
 
             default:
                 break;
    42f6:	00 00       	nop
             }
			if(rtry>=0) _delay_us(100);		//if not successfully sent the first time, wait some time and try again
    42f8:	8a 81       	ldd	r24, Y+2	; 0x02
    42fa:	9b 81       	ldd	r25, Y+3	; 0x03
    42fc:	99 23       	and	r25, r25
    42fe:	0c f4       	brge	.+2      	; 0x4302 <chb_write+0xe6>
    4300:	d5 c0       	rjmp	.+426    	; 0x44ac <chb_write+0x290>
    4302:	80 e0       	ldi	r24, 0x00	; 0
    4304:	90 e0       	ldi	r25, 0x00	; 0
    4306:	a8 ec       	ldi	r26, 0xC8	; 200
    4308:	b2 e4       	ldi	r27, 0x42	; 66
    430a:	8f 83       	std	Y+7, r24	; 0x07
    430c:	98 87       	std	Y+8, r25	; 0x08
    430e:	a9 87       	std	Y+9, r26	; 0x09
    4310:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4312:	6f 81       	ldd	r22, Y+7	; 0x07
    4314:	78 85       	ldd	r23, Y+8	; 0x08
    4316:	89 85       	ldd	r24, Y+9	; 0x09
    4318:	9a 85       	ldd	r25, Y+10	; 0x0a
    431a:	2b ea       	ldi	r18, 0xAB	; 171
    431c:	3a ea       	ldi	r19, 0xAA	; 170
    431e:	4a ea       	ldi	r20, 0xAA	; 170
    4320:	5e e3       	ldi	r21, 0x3E	; 62
    4322:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    4326:	dc 01       	movw	r26, r24
    4328:	cb 01       	movw	r24, r22
    432a:	8b 87       	std	Y+11, r24	; 0x0b
    432c:	9c 87       	std	Y+12, r25	; 0x0c
    432e:	ad 87       	std	Y+13, r26	; 0x0d
    4330:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    4332:	11 e0       	ldi	r17, 0x01	; 1
    4334:	6b 85       	ldd	r22, Y+11	; 0x0b
    4336:	7c 85       	ldd	r23, Y+12	; 0x0c
    4338:	8d 85       	ldd	r24, Y+13	; 0x0d
    433a:	9e 85       	ldd	r25, Y+14	; 0x0e
    433c:	20 e0       	ldi	r18, 0x00	; 0
    433e:	30 e0       	ldi	r19, 0x00	; 0
    4340:	40 e8       	ldi	r20, 0x80	; 128
    4342:	5f e3       	ldi	r21, 0x3F	; 63
    4344:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    4348:	88 23       	and	r24, r24
    434a:	0c f0       	brlt	.+2      	; 0x434e <chb_write+0x132>
    434c:	10 e0       	ldi	r17, 0x00	; 0
    434e:	11 23       	and	r17, r17
    4350:	19 f0       	breq	.+6      	; 0x4358 <chb_write+0x13c>
		__ticks = 1;
    4352:	81 e0       	ldi	r24, 0x01	; 1
    4354:	8f 87       	std	Y+15, r24	; 0x0f
    4356:	a3 c0       	rjmp	.+326    	; 0x449e <chb_write+0x282>
	else if (__tmp > 255)
    4358:	11 e0       	ldi	r17, 0x01	; 1
    435a:	6b 85       	ldd	r22, Y+11	; 0x0b
    435c:	7c 85       	ldd	r23, Y+12	; 0x0c
    435e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4360:	9e 85       	ldd	r25, Y+14	; 0x0e
    4362:	20 e0       	ldi	r18, 0x00	; 0
    4364:	30 e0       	ldi	r19, 0x00	; 0
    4366:	4f e7       	ldi	r20, 0x7F	; 127
    4368:	53 e4       	ldi	r21, 0x43	; 67
    436a:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    436e:	18 16       	cp	r1, r24
    4370:	0c f0       	brlt	.+2      	; 0x4374 <chb_write+0x158>
    4372:	10 e0       	ldi	r17, 0x00	; 0
    4374:	11 23       	and	r17, r17
    4376:	09 f4       	brne	.+2      	; 0x437a <chb_write+0x15e>
    4378:	89 c0       	rjmp	.+274    	; 0x448c <chb_write+0x270>
	{
		_delay_ms(__us / 1000.0);
    437a:	6f 81       	ldd	r22, Y+7	; 0x07
    437c:	78 85       	ldd	r23, Y+8	; 0x08
    437e:	89 85       	ldd	r24, Y+9	; 0x09
    4380:	9a 85       	ldd	r25, Y+10	; 0x0a
    4382:	20 e0       	ldi	r18, 0x00	; 0
    4384:	30 e0       	ldi	r19, 0x00	; 0
    4386:	4a e7       	ldi	r20, 0x7A	; 122
    4388:	54 e4       	ldi	r21, 0x44	; 68
    438a:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    438e:	dc 01       	movw	r26, r24
    4390:	cb 01       	movw	r24, r22
    4392:	88 8b       	std	Y+16, r24	; 0x10
    4394:	99 8b       	std	Y+17, r25	; 0x11
    4396:	aa 8b       	std	Y+18, r26	; 0x12
    4398:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    439a:	68 89       	ldd	r22, Y+16	; 0x10
    439c:	79 89       	ldd	r23, Y+17	; 0x11
    439e:	8a 89       	ldd	r24, Y+18	; 0x12
    43a0:	9b 89       	ldd	r25, Y+19	; 0x13
    43a2:	20 e0       	ldi	r18, 0x00	; 0
    43a4:	30 e0       	ldi	r19, 0x00	; 0
    43a6:	4a e7       	ldi	r20, 0x7A	; 122
    43a8:	53 e4       	ldi	r21, 0x43	; 67
    43aa:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    43ae:	dc 01       	movw	r26, r24
    43b0:	cb 01       	movw	r24, r22
    43b2:	8c 8b       	std	Y+20, r24	; 0x14
    43b4:	9d 8b       	std	Y+21, r25	; 0x15
    43b6:	ae 8b       	std	Y+22, r26	; 0x16
    43b8:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    43ba:	11 e0       	ldi	r17, 0x01	; 1
    43bc:	6c 89       	ldd	r22, Y+20	; 0x14
    43be:	7d 89       	ldd	r23, Y+21	; 0x15
    43c0:	8e 89       	ldd	r24, Y+22	; 0x16
    43c2:	9f 89       	ldd	r25, Y+23	; 0x17
    43c4:	20 e0       	ldi	r18, 0x00	; 0
    43c6:	30 e0       	ldi	r19, 0x00	; 0
    43c8:	40 e8       	ldi	r20, 0x80	; 128
    43ca:	5f e3       	ldi	r21, 0x3F	; 63
    43cc:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    43d0:	88 23       	and	r24, r24
    43d2:	0c f0       	brlt	.+2      	; 0x43d6 <chb_write+0x1ba>
    43d4:	10 e0       	ldi	r17, 0x00	; 0
    43d6:	11 23       	and	r17, r17
    43d8:	29 f0       	breq	.+10     	; 0x43e4 <chb_write+0x1c8>
		__ticks = 1;
    43da:	81 e0       	ldi	r24, 0x01	; 1
    43dc:	90 e0       	ldi	r25, 0x00	; 0
    43de:	88 8f       	std	Y+24, r24	; 0x18
    43e0:	99 8f       	std	Y+25, r25	; 0x19
    43e2:	46 c0       	rjmp	.+140    	; 0x4470 <chb_write+0x254>
	else if (__tmp > 65535)
    43e4:	11 e0       	ldi	r17, 0x01	; 1
    43e6:	6c 89       	ldd	r22, Y+20	; 0x14
    43e8:	7d 89       	ldd	r23, Y+21	; 0x15
    43ea:	8e 89       	ldd	r24, Y+22	; 0x16
    43ec:	9f 89       	ldd	r25, Y+23	; 0x17
    43ee:	20 e0       	ldi	r18, 0x00	; 0
    43f0:	3f ef       	ldi	r19, 0xFF	; 255
    43f2:	4f e7       	ldi	r20, 0x7F	; 127
    43f4:	57 e4       	ldi	r21, 0x47	; 71
    43f6:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    43fa:	18 16       	cp	r1, r24
    43fc:	0c f0       	brlt	.+2      	; 0x4400 <chb_write+0x1e4>
    43fe:	10 e0       	ldi	r17, 0x00	; 0
    4400:	11 23       	and	r17, r17
    4402:	61 f1       	breq	.+88     	; 0x445c <chb_write+0x240>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4404:	68 89       	ldd	r22, Y+16	; 0x10
    4406:	79 89       	ldd	r23, Y+17	; 0x11
    4408:	8a 89       	ldd	r24, Y+18	; 0x12
    440a:	9b 89       	ldd	r25, Y+19	; 0x13
    440c:	20 e0       	ldi	r18, 0x00	; 0
    440e:	30 e0       	ldi	r19, 0x00	; 0
    4410:	40 e2       	ldi	r20, 0x20	; 32
    4412:	51 e4       	ldi	r21, 0x41	; 65
    4414:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    4418:	dc 01       	movw	r26, r24
    441a:	cb 01       	movw	r24, r22
    441c:	bc 01       	movw	r22, r24
    441e:	cd 01       	movw	r24, r26
    4420:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    4424:	dc 01       	movw	r26, r24
    4426:	cb 01       	movw	r24, r22
    4428:	88 8f       	std	Y+24, r24	; 0x18
    442a:	99 8f       	std	Y+25, r25	; 0x19
    442c:	12 c0       	rjmp	.+36     	; 0x4452 <chb_write+0x236>
    442e:	89 e1       	ldi	r24, 0x19	; 25
    4430:	90 e0       	ldi	r25, 0x00	; 0
    4432:	8a 8f       	std	Y+26, r24	; 0x1a
    4434:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4436:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4438:	9b 8d       	ldd	r25, Y+27	; 0x1b
    443a:	8c 01       	movw	r16, r24
    443c:	c8 01       	movw	r24, r16
    443e:	01 97       	sbiw	r24, 0x01	; 1
    4440:	f1 f7       	brne	.-4      	; 0x443e <chb_write+0x222>
    4442:	8c 01       	movw	r16, r24
    4444:	0a 8f       	std	Y+26, r16	; 0x1a
    4446:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4448:	88 8d       	ldd	r24, Y+24	; 0x18
    444a:	99 8d       	ldd	r25, Y+25	; 0x19
    444c:	01 97       	sbiw	r24, 0x01	; 1
    444e:	88 8f       	std	Y+24, r24	; 0x18
    4450:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4452:	88 8d       	ldd	r24, Y+24	; 0x18
    4454:	99 8d       	ldd	r25, Y+25	; 0x19
    4456:	00 97       	sbiw	r24, 0x00	; 0
    4458:	51 f7       	brne	.-44     	; 0x442e <chb_write+0x212>
    445a:	28 c0       	rjmp	.+80     	; 0x44ac <chb_write+0x290>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    445c:	6c 89       	ldd	r22, Y+20	; 0x14
    445e:	7d 89       	ldd	r23, Y+21	; 0x15
    4460:	8e 89       	ldd	r24, Y+22	; 0x16
    4462:	9f 89       	ldd	r25, Y+23	; 0x17
    4464:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    4468:	dc 01       	movw	r26, r24
    446a:	cb 01       	movw	r24, r22
    446c:	88 8f       	std	Y+24, r24	; 0x18
    446e:	99 8f       	std	Y+25, r25	; 0x19
    4470:	88 8d       	ldd	r24, Y+24	; 0x18
    4472:	99 8d       	ldd	r25, Y+25	; 0x19
    4474:	8c 8f       	std	Y+28, r24	; 0x1c
    4476:	9d 8f       	std	Y+29, r25	; 0x1d
    4478:	8c 8d       	ldd	r24, Y+28	; 0x1c
    447a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    447c:	8c 01       	movw	r16, r24
    447e:	c8 01       	movw	r24, r16
    4480:	01 97       	sbiw	r24, 0x01	; 1
    4482:	f1 f7       	brne	.-4      	; 0x4480 <chb_write+0x264>
    4484:	8c 01       	movw	r16, r24
    4486:	0c 8f       	std	Y+28, r16	; 0x1c
    4488:	1d 8f       	std	Y+29, r17	; 0x1d
    448a:	10 c0       	rjmp	.+32     	; 0x44ac <chb_write+0x290>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    448c:	6b 85       	ldd	r22, Y+11	; 0x0b
    448e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4490:	8d 85       	ldd	r24, Y+13	; 0x0d
    4492:	9e 85       	ldd	r25, Y+14	; 0x0e
    4494:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    4498:	dc 01       	movw	r26, r24
    449a:	cb 01       	movw	r24, r22
    449c:	8f 87       	std	Y+15, r24	; 0x0f
    449e:	8f 85       	ldd	r24, Y+15	; 0x0f
    44a0:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    44a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    44a4:	18 2f       	mov	r17, r24
    44a6:	1a 95       	dec	r17
    44a8:	f1 f7       	brne	.-4      	; 0x44a6 <chb_write+0x28a>
    44aa:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message
    44ac:	8a 81       	ldd	r24, Y+2	; 0x02
    44ae:	9b 81       	ldd	r25, Y+3	; 0x03
    44b0:	84 31       	cpi	r24, 0x14	; 20
    44b2:	91 05       	cpc	r25, r1
    44b4:	11 f4       	brne	.+4      	; 0x44ba <chb_write+0x29e>
    44b6:	8e 81       	ldd	r24, Y+6	; 0x06
    44b8:	2c c0       	rjmp	.+88     	; 0x4512 <chb_write+0x2f6>
			rtry++;	
    44ba:	8a 81       	ldd	r24, Y+2	; 0x02
    44bc:	9b 81       	ldd	r25, Y+3	; 0x03
    44be:	01 96       	adiw	r24, 0x01	; 1
    44c0:	8a 83       	std	Y+2, r24	; 0x02
    44c2:	9b 83       	std	Y+3, r25	; 0x03
		} while(status != CHB_SUCCESS);			
    44c4:	8e 81       	ldd	r24, Y+6	; 0x06
    44c6:	88 23       	and	r24, r24
    44c8:	09 f0       	breq	.+2      	; 0x44cc <chb_write+0x2b0>
    44ca:	d6 ce       	rjmp	.-596    	; 0x4278 <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    44cc:	99 81       	ldd	r25, Y+1	; 0x01
    44ce:	8c 81       	ldd	r24, Y+4	; 0x04
    44d0:	89 0f       	add	r24, r25
    44d2:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    44d4:	8c 81       	ldd	r24, Y+4	; 0x04
    44d6:	88 2f       	mov	r24, r24
    44d8:	90 e0       	ldi	r25, 0x00	; 0
    44da:	a0 e0       	ldi	r26, 0x00	; 0
    44dc:	b0 e0       	ldi	r27, 0x00	; 0
    44de:	2d a5       	lds	r18, 0x6d
    44e0:	3e a5       	lds	r19, 0x6e
    44e2:	4f a5       	lds	r20, 0x6f
    44e4:	58 a9       	sts	0x48, r21
    44e6:	79 01       	movw	r14, r18
    44e8:	8a 01       	movw	r16, r20
    44ea:	e8 1a       	sub	r14, r24
    44ec:	f9 0a       	sbc	r15, r25
    44ee:	0a 0b       	sbc	r16, r26
    44f0:	1b 0b       	sbc	r17, r27
    44f2:	d8 01       	movw	r26, r16
    44f4:	c7 01       	movw	r24, r14
    44f6:	8d a7       	lds	r24, 0x7d
    44f8:	9e a7       	lds	r25, 0x7e
    44fa:	af a7       	lds	r26, 0x7f
    44fc:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    44fe:	8d a5       	lds	r24, 0x6d
    4500:	9e a5       	lds	r25, 0x6e
    4502:	af a5       	lds	r26, 0x6f
    4504:	b8 a9       	sts	0x48, r27
    4506:	00 97       	sbiw	r24, 0x00	; 0
    4508:	a1 05       	cpc	r26, r1
    450a:	b1 05       	cpc	r27, r1
    450c:	09 f0       	breq	.+2      	; 0x4510 <chb_write+0x2f4>
    450e:	9b ce       	rjmp	.-714    	; 0x4246 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    4510:	80 e0       	ldi	r24, 0x00	; 0
}
    4512:	e0 96       	adiw	r28, 0x30	; 48
    4514:	cd bf       	out	0x3d, r28	; 61
    4516:	de bf       	out	0x3e, r29	; 62
    4518:	df 91       	pop	r29
    451a:	cf 91       	pop	r28
    451c:	1f 91       	pop	r17
    451e:	0f 91       	pop	r16
    4520:	ff 90       	pop	r15
    4522:	ef 90       	pop	r14
    4524:	08 95       	ret

00004526 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4526:	cf 93       	push	r28
    4528:	df 93       	push	r29
    452a:	cd b7       	in	r28, 0x3d	; 61
    452c:	de b7       	in	r29, 0x3e	; 62
    452e:	27 97       	sbiw	r28, 0x07	; 7
    4530:	cd bf       	out	0x3d, r28	; 61
    4532:	de bf       	out	0x3e, r29	; 62
    4534:	8e 83       	std	Y+6, r24	; 0x06
    4536:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    4538:	8e 81       	ldd	r24, Y+6	; 0x06
    453a:	9f 81       	ldd	r25, Y+7	; 0x07
    453c:	05 96       	adiw	r24, 0x05	; 5
    453e:	8a 83       	std	Y+2, r24	; 0x02
    4540:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    4542:	0e 94 60 23 	call	0x46c0	; 0x46c0 <chb_buf_read>
    4546:	8c 83       	std	Y+4, r24	; 0x04
    4548:	8c 81       	ldd	r24, Y+4	; 0x04
    454a:	88 23       	and	r24, r24
    454c:	14 f4       	brge	.+4      	; 0x4552 <chb_read+0x2c>
    {
        return 0;
    454e:	80 e0       	ldi	r24, 0x00	; 0
    4550:	80 c0       	rjmp	.+256    	; 0x4652 <chb_read+0x12c>
    }
    *data_ptr++ = len;
    4552:	8a 81       	ldd	r24, Y+2	; 0x02
    4554:	9b 81       	ldd	r25, Y+3	; 0x03
    4556:	2c 81       	ldd	r18, Y+4	; 0x04
    4558:	fc 01       	movw	r30, r24
    455a:	20 83       	st	Z, r18
    455c:	8a 81       	ldd	r24, Y+2	; 0x02
    455e:	9b 81       	ldd	r25, Y+3	; 0x03
    4560:	01 96       	adiw	r24, 0x01	; 1
    4562:	8a 83       	std	Y+2, r24	; 0x02
    4564:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4566:	19 82       	std	Y+1, r1	; 0x01
    4568:	0f c0       	rjmp	.+30     	; 0x4588 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    456a:	0e 94 60 23 	call	0x46c0	; 0x46c0 <chb_buf_read>
    456e:	28 2f       	mov	r18, r24
    4570:	8a 81       	ldd	r24, Y+2	; 0x02
    4572:	9b 81       	ldd	r25, Y+3	; 0x03
    4574:	fc 01       	movw	r30, r24
    4576:	20 83       	st	Z, r18
    4578:	8a 81       	ldd	r24, Y+2	; 0x02
    457a:	9b 81       	ldd	r25, Y+3	; 0x03
    457c:	01 96       	adiw	r24, 0x01	; 1
    457e:	8a 83       	std	Y+2, r24	; 0x02
    4580:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4582:	89 81       	ldd	r24, Y+1	; 0x01
    4584:	8f 5f       	subi	r24, 0xFF	; 255
    4586:	89 83       	std	Y+1, r24	; 0x01
    4588:	99 81       	ldd	r25, Y+1	; 0x01
    458a:	8c 81       	ldd	r24, Y+4	; 0x04
    458c:	98 17       	cp	r25, r24
    458e:	68 f3       	brcs	.-38     	; 0x456a <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    4590:	8e 81       	ldd	r24, Y+6	; 0x06
    4592:	9f 81       	ldd	r25, Y+7	; 0x07
    4594:	08 96       	adiw	r24, 0x08	; 8
    4596:	8a 83       	std	Y+2, r24	; 0x02
    4598:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    459a:	8a 81       	ldd	r24, Y+2	; 0x02
    459c:	9b 81       	ldd	r25, Y+3	; 0x03
    459e:	fc 01       	movw	r30, r24
    45a0:	80 81       	ld	r24, Z
    45a2:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    45a4:	8e 81       	ldd	r24, Y+6	; 0x06
    45a6:	9f 81       	ldd	r25, Y+7	; 0x07
    45a8:	0b 96       	adiw	r24, 0x0b	; 11
    45aa:	8a 83       	std	Y+2, r24	; 0x02
    45ac:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    45ae:	8a 81       	ldd	r24, Y+2	; 0x02
    45b0:	9b 81       	ldd	r25, Y+3	; 0x03
    45b2:	fc 01       	movw	r30, r24
    45b4:	20 81       	ld	r18, Z
    45b6:	31 81       	ldd	r19, Z+1	; 0x01
    45b8:	8e 81       	ldd	r24, Y+6	; 0x06
    45ba:	9f 81       	ldd	r25, Y+7	; 0x07
    45bc:	fc 01       	movw	r30, r24
    45be:	23 83       	std	Z+3, r18	; 0x03
    45c0:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    45c2:	8a 81       	ldd	r24, Y+2	; 0x02
    45c4:	9b 81       	ldd	r25, Y+3	; 0x03
    45c6:	02 96       	adiw	r24, 0x02	; 2
    45c8:	8a 83       	std	Y+2, r24	; 0x02
    45ca:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    45cc:	8a 81       	ldd	r24, Y+2	; 0x02
    45ce:	9b 81       	ldd	r25, Y+3	; 0x03
    45d0:	fc 01       	movw	r30, r24
    45d2:	20 81       	ld	r18, Z
    45d4:	31 81       	ldd	r19, Z+1	; 0x01
    45d6:	8e 81       	ldd	r24, Y+6	; 0x06
    45d8:	9f 81       	ldd	r25, Y+7	; 0x07
    45da:	fc 01       	movw	r30, r24
    45dc:	21 83       	std	Z+1, r18	; 0x01
    45de:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    45e0:	8a 81       	ldd	r24, Y+2	; 0x02
    45e2:	9b 81       	ldd	r25, Y+3	; 0x03
    45e4:	02 96       	adiw	r24, 0x02	; 2
    45e6:	8a 83       	std	Y+2, r24	; 0x02
    45e8:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    45ea:	0e 94 84 23 	call	0x4708	; 0x4708 <chb_buf_get_len>
    45ee:	88 23       	and	r24, r24
    45f0:	11 f4       	brne	.+4      	; 0x45f6 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    45f2:	10 92 37 21 	sts	0x2137, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    45f6:	80 91 11 20 	lds	r24, 0x2011
    45fa:	9d 81       	ldd	r25, Y+5	; 0x05
    45fc:	98 17       	cp	r25, r24
    45fe:	71 f4       	brne	.+28     	; 0x461c <chb_read+0xf6>
    4600:	8e 81       	ldd	r24, Y+6	; 0x06
    4602:	9f 81       	ldd	r25, Y+7	; 0x07
    4604:	fc 01       	movw	r30, r24
    4606:	21 81       	ldd	r18, Z+1	; 0x01
    4608:	32 81       	ldd	r19, Z+2	; 0x02
    460a:	80 91 12 20 	lds	r24, 0x2012
    460e:	90 91 13 20 	lds	r25, 0x2013
    4612:	28 17       	cp	r18, r24
    4614:	39 07       	cpc	r19, r25
    4616:	11 f4       	brne	.+4      	; 0x461c <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    4618:	80 e0       	ldi	r24, 0x00	; 0
    461a:	1b c0       	rjmp	.+54     	; 0x4652 <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    461c:	8d 81       	ldd	r24, Y+5	; 0x05
    461e:	80 93 11 20 	sts	0x2011, r24
        prev_src_addr = rx->src_addr;
    4622:	8e 81       	ldd	r24, Y+6	; 0x06
    4624:	9f 81       	ldd	r25, Y+7	; 0x07
    4626:	fc 01       	movw	r30, r24
    4628:	81 81       	ldd	r24, Z+1	; 0x01
    462a:	92 81       	ldd	r25, Z+2	; 0x02
    462c:	80 93 12 20 	sts	0x2012, r24
    4630:	90 93 13 20 	sts	0x2013, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    4634:	8c 81       	ldd	r24, Y+4	; 0x04
    4636:	88 2f       	mov	r24, r24
    4638:	90 e0       	ldi	r25, 0x00	; 0
    463a:	09 97       	sbiw	r24, 0x09	; 9
    463c:	9c 01       	movw	r18, r24
    463e:	8e 81       	ldd	r24, Y+6	; 0x06
    4640:	9f 81       	ldd	r25, Y+7	; 0x07
    4642:	4a 81       	ldd	r20, Y+2	; 0x02
    4644:	5b 81       	ldd	r21, Y+3	; 0x03
    4646:	ba 01       	movw	r22, r20
    4648:	a9 01       	movw	r20, r18
    464a:	0e 94 1a 5f 	call	0xbe34	; 0xbe34 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    464e:	8c 81       	ldd	r24, Y+4	; 0x04
    4650:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    4652:	27 96       	adiw	r28, 0x07	; 7
    4654:	cd bf       	out	0x3d, r28	; 61
    4656:	de bf       	out	0x3e, r29	; 62
    4658:	df 91       	pop	r29
    465a:	cf 91       	pop	r28
    465c:	08 95       	ret

0000465e <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    465e:	cf 93       	push	r28
    4660:	df 93       	push	r29
    4662:	cd b7       	in	r28, 0x3d	; 61
    4664:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4666:	10 92 c8 21 	sts	0x21C8, r1
    wr_ptr = 0;
    466a:	10 92 c9 21 	sts	0x21C9, r1
    len = 0;
    466e:	10 92 ca 21 	sts	0x21CA, r1
}
    4672:	df 91       	pop	r29
    4674:	cf 91       	pop	r28
    4676:	08 95       	ret

00004678 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4678:	cf 93       	push	r28
    467a:	df 93       	push	r29
    467c:	0f 92       	push	r0
    467e:	cd b7       	in	r28, 0x3d	; 61
    4680:	de b7       	in	r29, 0x3e	; 62
    4682:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4684:	80 91 c9 21 	lds	r24, 0x21C9
    4688:	88 2f       	mov	r24, r24
    468a:	90 e0       	ldi	r25, 0x00	; 0
    468c:	88 5b       	subi	r24, 0xB8	; 184
    468e:	9e 4d       	sbci	r25, 0xDE	; 222
    4690:	29 81       	ldd	r18, Y+1	; 0x01
    4692:	fc 01       	movw	r30, r24
    4694:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4696:	80 91 c9 21 	lds	r24, 0x21C9
    469a:	88 2f       	mov	r24, r24
    469c:	90 e0       	ldi	r25, 0x00	; 0
    469e:	01 96       	adiw	r24, 0x01	; 1
    46a0:	20 e8       	ldi	r18, 0x80	; 128
    46a2:	30 e0       	ldi	r19, 0x00	; 0
    46a4:	b9 01       	movw	r22, r18
    46a6:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    46aa:	80 93 c9 21 	sts	0x21C9, r24
    len++;
    46ae:	80 91 ca 21 	lds	r24, 0x21CA
    46b2:	8f 5f       	subi	r24, 0xFF	; 255
    46b4:	80 93 ca 21 	sts	0x21CA, r24
}
    46b8:	0f 90       	pop	r0
    46ba:	df 91       	pop	r29
    46bc:	cf 91       	pop	r28
    46be:	08 95       	ret

000046c0 <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    46c0:	cf 93       	push	r28
    46c2:	df 93       	push	r29
    46c4:	0f 92       	push	r0
    46c6:	cd b7       	in	r28, 0x3d	; 61
    46c8:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    46ca:	80 91 c8 21 	lds	r24, 0x21C8
    46ce:	88 2f       	mov	r24, r24
    46d0:	90 e0       	ldi	r25, 0x00	; 0
    46d2:	88 5b       	subi	r24, 0xB8	; 184
    46d4:	9e 4d       	sbci	r25, 0xDE	; 222
    46d6:	fc 01       	movw	r30, r24
    46d8:	80 81       	ld	r24, Z
    46da:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    46dc:	80 91 c8 21 	lds	r24, 0x21C8
    46e0:	88 2f       	mov	r24, r24
    46e2:	90 e0       	ldi	r25, 0x00	; 0
    46e4:	01 96       	adiw	r24, 0x01	; 1
    46e6:	20 e8       	ldi	r18, 0x80	; 128
    46e8:	30 e0       	ldi	r19, 0x00	; 0
    46ea:	b9 01       	movw	r22, r18
    46ec:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    46f0:	80 93 c8 21 	sts	0x21C8, r24
    len--;
    46f4:	80 91 ca 21 	lds	r24, 0x21CA
    46f8:	81 50       	subi	r24, 0x01	; 1
    46fa:	80 93 ca 21 	sts	0x21CA, r24
    return data;
    46fe:	89 81       	ldd	r24, Y+1	; 0x01
}
    4700:	0f 90       	pop	r0
    4702:	df 91       	pop	r29
    4704:	cf 91       	pop	r28
    4706:	08 95       	ret

00004708 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    4708:	cf 93       	push	r28
    470a:	df 93       	push	r29
    470c:	cd b7       	in	r28, 0x3d	; 61
    470e:	de b7       	in	r29, 0x3e	; 62
    return len;
    4710:	80 91 ca 21 	lds	r24, 0x21CA
}
    4714:	df 91       	pop	r29
    4716:	cf 91       	pop	r28
    4718:	08 95       	ret

0000471a <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    471a:	cf 93       	push	r28
    471c:	df 93       	push	r29
    471e:	cd b7       	in	r28, 0x3d	; 61
    4720:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    4722:	81 e0       	ldi	r24, 0x01	; 1
    4724:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    4728:	8f 71       	andi	r24, 0x1F	; 31
}
    472a:	df 91       	pop	r29
    472c:	cf 91       	pop	r28
    472e:	08 95       	ret

00004730 <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    4730:	cf 93       	push	r28
    4732:	df 93       	push	r29
    4734:	cd b7       	in	r28, 0x3d	; 61
    4736:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    4738:	82 e0       	ldi	r24, 0x02	; 2
    473a:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    473e:	82 95       	swap	r24
    4740:	86 95       	lsr	r24
    4742:	87 70       	andi	r24, 0x07	; 7
}
    4744:	df 91       	pop	r29
    4746:	cf 91       	pop	r28
    4748:	08 95       	ret

0000474a <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    474a:	0f 93       	push	r16
    474c:	1f 93       	push	r17
    474e:	cf 93       	push	r28
    4750:	df 93       	push	r29
    4752:	cd b7       	in	r28, 0x3d	; 61
    4754:	de b7       	in	r29, 0x3e	; 62
    4756:	e0 97       	sbiw	r28, 0x30	; 48
    4758:	cd bf       	out	0x3d, r28	; 61
    475a:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    475c:	84 e6       	ldi	r24, 0x64	; 100
    475e:	96 e0       	ldi	r25, 0x06	; 6
    4760:	24 e6       	ldi	r18, 0x64	; 100
    4762:	36 e0       	ldi	r19, 0x06	; 6
    4764:	f9 01       	movw	r30, r18
    4766:	20 81       	ld	r18, Z
    4768:	21 60       	ori	r18, 0x01	; 1
    476a:	fc 01       	movw	r30, r24
    476c:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    476e:	84 e6       	ldi	r24, 0x64	; 100
    4770:	96 e0       	ldi	r25, 0x06	; 6
    4772:	24 e6       	ldi	r18, 0x64	; 100
    4774:	36 e0       	ldi	r19, 0x06	; 6
    4776:	f9 01       	movw	r30, r18
    4778:	20 81       	ld	r18, Z
    477a:	2d 7f       	andi	r18, 0xFD	; 253
    477c:	fc 01       	movw	r30, r24
    477e:	20 83       	st	Z, r18
    4780:	80 e0       	ldi	r24, 0x00	; 0
    4782:	90 e0       	ldi	r25, 0x00	; 0
    4784:	ae eb       	ldi	r26, 0xBE	; 190
    4786:	b3 e4       	ldi	r27, 0x43	; 67
    4788:	89 83       	std	Y+1, r24	; 0x01
    478a:	9a 83       	std	Y+2, r25	; 0x02
    478c:	ab 83       	std	Y+3, r26	; 0x03
    478e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4790:	69 81       	ldd	r22, Y+1	; 0x01
    4792:	7a 81       	ldd	r23, Y+2	; 0x02
    4794:	8b 81       	ldd	r24, Y+3	; 0x03
    4796:	9c 81       	ldd	r25, Y+4	; 0x04
    4798:	2b ea       	ldi	r18, 0xAB	; 171
    479a:	3a ea       	ldi	r19, 0xAA	; 170
    479c:	4a ea       	ldi	r20, 0xAA	; 170
    479e:	5e e3       	ldi	r21, 0x3E	; 62
    47a0:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    47a4:	dc 01       	movw	r26, r24
    47a6:	cb 01       	movw	r24, r22
    47a8:	8d 83       	std	Y+5, r24	; 0x05
    47aa:	9e 83       	std	Y+6, r25	; 0x06
    47ac:	af 83       	std	Y+7, r26	; 0x07
    47ae:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    47b0:	11 e0       	ldi	r17, 0x01	; 1
    47b2:	6d 81       	ldd	r22, Y+5	; 0x05
    47b4:	7e 81       	ldd	r23, Y+6	; 0x06
    47b6:	8f 81       	ldd	r24, Y+7	; 0x07
    47b8:	98 85       	ldd	r25, Y+8	; 0x08
    47ba:	20 e0       	ldi	r18, 0x00	; 0
    47bc:	30 e0       	ldi	r19, 0x00	; 0
    47be:	40 e8       	ldi	r20, 0x80	; 128
    47c0:	5f e3       	ldi	r21, 0x3F	; 63
    47c2:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    47c6:	88 23       	and	r24, r24
    47c8:	0c f0       	brlt	.+2      	; 0x47cc <chb_reset+0x82>
    47ca:	10 e0       	ldi	r17, 0x00	; 0
    47cc:	11 23       	and	r17, r17
    47ce:	19 f0       	breq	.+6      	; 0x47d6 <chb_reset+0x8c>
		__ticks = 1;
    47d0:	81 e0       	ldi	r24, 0x01	; 1
    47d2:	89 87       	std	Y+9, r24	; 0x09
    47d4:	a3 c0       	rjmp	.+326    	; 0x491c <chb_reset+0x1d2>
	else if (__tmp > 255)
    47d6:	11 e0       	ldi	r17, 0x01	; 1
    47d8:	6d 81       	ldd	r22, Y+5	; 0x05
    47da:	7e 81       	ldd	r23, Y+6	; 0x06
    47dc:	8f 81       	ldd	r24, Y+7	; 0x07
    47de:	98 85       	ldd	r25, Y+8	; 0x08
    47e0:	20 e0       	ldi	r18, 0x00	; 0
    47e2:	30 e0       	ldi	r19, 0x00	; 0
    47e4:	4f e7       	ldi	r20, 0x7F	; 127
    47e6:	53 e4       	ldi	r21, 0x43	; 67
    47e8:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    47ec:	18 16       	cp	r1, r24
    47ee:	0c f0       	brlt	.+2      	; 0x47f2 <chb_reset+0xa8>
    47f0:	10 e0       	ldi	r17, 0x00	; 0
    47f2:	11 23       	and	r17, r17
    47f4:	09 f4       	brne	.+2      	; 0x47f8 <chb_reset+0xae>
    47f6:	89 c0       	rjmp	.+274    	; 0x490a <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    47f8:	69 81       	ldd	r22, Y+1	; 0x01
    47fa:	7a 81       	ldd	r23, Y+2	; 0x02
    47fc:	8b 81       	ldd	r24, Y+3	; 0x03
    47fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4800:	20 e0       	ldi	r18, 0x00	; 0
    4802:	30 e0       	ldi	r19, 0x00	; 0
    4804:	4a e7       	ldi	r20, 0x7A	; 122
    4806:	54 e4       	ldi	r21, 0x44	; 68
    4808:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    480c:	dc 01       	movw	r26, r24
    480e:	cb 01       	movw	r24, r22
    4810:	8a 87       	std	Y+10, r24	; 0x0a
    4812:	9b 87       	std	Y+11, r25	; 0x0b
    4814:	ac 87       	std	Y+12, r26	; 0x0c
    4816:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4818:	6a 85       	ldd	r22, Y+10	; 0x0a
    481a:	7b 85       	ldd	r23, Y+11	; 0x0b
    481c:	8c 85       	ldd	r24, Y+12	; 0x0c
    481e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4820:	20 e0       	ldi	r18, 0x00	; 0
    4822:	30 e0       	ldi	r19, 0x00	; 0
    4824:	4a e7       	ldi	r20, 0x7A	; 122
    4826:	53 e4       	ldi	r21, 0x43	; 67
    4828:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    482c:	dc 01       	movw	r26, r24
    482e:	cb 01       	movw	r24, r22
    4830:	8e 87       	std	Y+14, r24	; 0x0e
    4832:	9f 87       	std	Y+15, r25	; 0x0f
    4834:	a8 8b       	std	Y+16, r26	; 0x10
    4836:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    4838:	11 e0       	ldi	r17, 0x01	; 1
    483a:	6e 85       	ldd	r22, Y+14	; 0x0e
    483c:	7f 85       	ldd	r23, Y+15	; 0x0f
    483e:	88 89       	ldd	r24, Y+16	; 0x10
    4840:	99 89       	ldd	r25, Y+17	; 0x11
    4842:	20 e0       	ldi	r18, 0x00	; 0
    4844:	30 e0       	ldi	r19, 0x00	; 0
    4846:	40 e8       	ldi	r20, 0x80	; 128
    4848:	5f e3       	ldi	r21, 0x3F	; 63
    484a:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    484e:	88 23       	and	r24, r24
    4850:	0c f0       	brlt	.+2      	; 0x4854 <chb_reset+0x10a>
    4852:	10 e0       	ldi	r17, 0x00	; 0
    4854:	11 23       	and	r17, r17
    4856:	29 f0       	breq	.+10     	; 0x4862 <chb_reset+0x118>
		__ticks = 1;
    4858:	81 e0       	ldi	r24, 0x01	; 1
    485a:	90 e0       	ldi	r25, 0x00	; 0
    485c:	8a 8b       	std	Y+18, r24	; 0x12
    485e:	9b 8b       	std	Y+19, r25	; 0x13
    4860:	46 c0       	rjmp	.+140    	; 0x48ee <chb_reset+0x1a4>
	else if (__tmp > 65535)
    4862:	11 e0       	ldi	r17, 0x01	; 1
    4864:	6e 85       	ldd	r22, Y+14	; 0x0e
    4866:	7f 85       	ldd	r23, Y+15	; 0x0f
    4868:	88 89       	ldd	r24, Y+16	; 0x10
    486a:	99 89       	ldd	r25, Y+17	; 0x11
    486c:	20 e0       	ldi	r18, 0x00	; 0
    486e:	3f ef       	ldi	r19, 0xFF	; 255
    4870:	4f e7       	ldi	r20, 0x7F	; 127
    4872:	57 e4       	ldi	r21, 0x47	; 71
    4874:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    4878:	18 16       	cp	r1, r24
    487a:	0c f0       	brlt	.+2      	; 0x487e <chb_reset+0x134>
    487c:	10 e0       	ldi	r17, 0x00	; 0
    487e:	11 23       	and	r17, r17
    4880:	61 f1       	breq	.+88     	; 0x48da <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4882:	6a 85       	ldd	r22, Y+10	; 0x0a
    4884:	7b 85       	ldd	r23, Y+11	; 0x0b
    4886:	8c 85       	ldd	r24, Y+12	; 0x0c
    4888:	9d 85       	ldd	r25, Y+13	; 0x0d
    488a:	20 e0       	ldi	r18, 0x00	; 0
    488c:	30 e0       	ldi	r19, 0x00	; 0
    488e:	40 e2       	ldi	r20, 0x20	; 32
    4890:	51 e4       	ldi	r21, 0x41	; 65
    4892:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    4896:	dc 01       	movw	r26, r24
    4898:	cb 01       	movw	r24, r22
    489a:	bc 01       	movw	r22, r24
    489c:	cd 01       	movw	r24, r26
    489e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    48a2:	dc 01       	movw	r26, r24
    48a4:	cb 01       	movw	r24, r22
    48a6:	8a 8b       	std	Y+18, r24	; 0x12
    48a8:	9b 8b       	std	Y+19, r25	; 0x13
    48aa:	12 c0       	rjmp	.+36     	; 0x48d0 <chb_reset+0x186>
    48ac:	89 e1       	ldi	r24, 0x19	; 25
    48ae:	90 e0       	ldi	r25, 0x00	; 0
    48b0:	8c 8b       	std	Y+20, r24	; 0x14
    48b2:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    48b4:	8c 89       	ldd	r24, Y+20	; 0x14
    48b6:	9d 89       	ldd	r25, Y+21	; 0x15
    48b8:	8c 01       	movw	r16, r24
    48ba:	c8 01       	movw	r24, r16
    48bc:	01 97       	sbiw	r24, 0x01	; 1
    48be:	f1 f7       	brne	.-4      	; 0x48bc <chb_reset+0x172>
    48c0:	8c 01       	movw	r16, r24
    48c2:	0c 8b       	std	Y+20, r16	; 0x14
    48c4:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    48c6:	8a 89       	ldd	r24, Y+18	; 0x12
    48c8:	9b 89       	ldd	r25, Y+19	; 0x13
    48ca:	01 97       	sbiw	r24, 0x01	; 1
    48cc:	8a 8b       	std	Y+18, r24	; 0x12
    48ce:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    48d0:	8a 89       	ldd	r24, Y+18	; 0x12
    48d2:	9b 89       	ldd	r25, Y+19	; 0x13
    48d4:	00 97       	sbiw	r24, 0x00	; 0
    48d6:	51 f7       	brne	.-44     	; 0x48ac <chb_reset+0x162>
    48d8:	28 c0       	rjmp	.+80     	; 0x492a <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    48da:	6e 85       	ldd	r22, Y+14	; 0x0e
    48dc:	7f 85       	ldd	r23, Y+15	; 0x0f
    48de:	88 89       	ldd	r24, Y+16	; 0x10
    48e0:	99 89       	ldd	r25, Y+17	; 0x11
    48e2:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    48e6:	dc 01       	movw	r26, r24
    48e8:	cb 01       	movw	r24, r22
    48ea:	8a 8b       	std	Y+18, r24	; 0x12
    48ec:	9b 8b       	std	Y+19, r25	; 0x13
    48ee:	8a 89       	ldd	r24, Y+18	; 0x12
    48f0:	9b 89       	ldd	r25, Y+19	; 0x13
    48f2:	8e 8b       	std	Y+22, r24	; 0x16
    48f4:	9f 8b       	std	Y+23, r25	; 0x17
    48f6:	8e 89       	ldd	r24, Y+22	; 0x16
    48f8:	9f 89       	ldd	r25, Y+23	; 0x17
    48fa:	8c 01       	movw	r16, r24
    48fc:	f8 01       	movw	r30, r16
    48fe:	31 97       	sbiw	r30, 0x01	; 1
    4900:	f1 f7       	brne	.-4      	; 0x48fe <chb_reset+0x1b4>
    4902:	8f 01       	movw	r16, r30
    4904:	0e 8b       	std	Y+22, r16	; 0x16
    4906:	1f 8b       	std	Y+23, r17	; 0x17
    4908:	10 c0       	rjmp	.+32     	; 0x492a <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    490a:	6d 81       	ldd	r22, Y+5	; 0x05
    490c:	7e 81       	ldd	r23, Y+6	; 0x06
    490e:	8f 81       	ldd	r24, Y+7	; 0x07
    4910:	98 85       	ldd	r25, Y+8	; 0x08
    4912:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    4916:	dc 01       	movw	r26, r24
    4918:	cb 01       	movw	r24, r22
    491a:	89 87       	std	Y+9, r24	; 0x09
    491c:	89 85       	ldd	r24, Y+9	; 0x09
    491e:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4920:	88 8d       	ldd	r24, Y+24	; 0x18
    4922:	18 2f       	mov	r17, r24
    4924:	1a 95       	dec	r17
    4926:	f1 f7       	brne	.-4      	; 0x4924 <chb_reset+0x1da>
    4928:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    492a:	84 e6       	ldi	r24, 0x64	; 100
    492c:	96 e0       	ldi	r25, 0x06	; 6
    492e:	24 e6       	ldi	r18, 0x64	; 100
    4930:	36 e0       	ldi	r19, 0x06	; 6
    4932:	f9 01       	movw	r30, r18
    4934:	20 81       	ld	r18, Z
    4936:	2e 7f       	andi	r18, 0xFE	; 254
    4938:	fc 01       	movw	r30, r24
    493a:	20 83       	st	Z, r18
    493c:	80 e0       	ldi	r24, 0x00	; 0
    493e:	90 e0       	ldi	r25, 0x00	; 0
    4940:	a0 e8       	ldi	r26, 0x80	; 128
    4942:	bf e3       	ldi	r27, 0x3F	; 63
    4944:	89 8f       	std	Y+25, r24	; 0x19
    4946:	9a 8f       	std	Y+26, r25	; 0x1a
    4948:	ab 8f       	std	Y+27, r26	; 0x1b
    494a:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    494c:	69 8d       	ldd	r22, Y+25	; 0x19
    494e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4950:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4952:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4954:	2b ea       	ldi	r18, 0xAB	; 171
    4956:	3a ea       	ldi	r19, 0xAA	; 170
    4958:	4a ea       	ldi	r20, 0xAA	; 170
    495a:	5e e3       	ldi	r21, 0x3E	; 62
    495c:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    4960:	dc 01       	movw	r26, r24
    4962:	cb 01       	movw	r24, r22
    4964:	8d 8f       	std	Y+29, r24	; 0x1d
    4966:	9e 8f       	std	Y+30, r25	; 0x1e
    4968:	af 8f       	std	Y+31, r26	; 0x1f
    496a:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    496c:	11 e0       	ldi	r17, 0x01	; 1
    496e:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4970:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4972:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4974:	98 a1       	lds	r25, 0x48
    4976:	20 e0       	ldi	r18, 0x00	; 0
    4978:	30 e0       	ldi	r19, 0x00	; 0
    497a:	40 e8       	ldi	r20, 0x80	; 128
    497c:	5f e3       	ldi	r21, 0x3F	; 63
    497e:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    4982:	88 23       	and	r24, r24
    4984:	0c f0       	brlt	.+2      	; 0x4988 <chb_reset+0x23e>
    4986:	10 e0       	ldi	r17, 0x00	; 0
    4988:	11 23       	and	r17, r17
    498a:	19 f0       	breq	.+6      	; 0x4992 <chb_reset+0x248>
		__ticks = 1;
    498c:	81 e0       	ldi	r24, 0x01	; 1
    498e:	89 a3       	lds	r24, 0x59
    4990:	a3 c0       	rjmp	.+326    	; 0x4ad8 <chb_reset+0x38e>
	else if (__tmp > 255)
    4992:	11 e0       	ldi	r17, 0x01	; 1
    4994:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4996:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4998:	8f 8d       	ldd	r24, Y+31	; 0x1f
    499a:	98 a1       	lds	r25, 0x48
    499c:	20 e0       	ldi	r18, 0x00	; 0
    499e:	30 e0       	ldi	r19, 0x00	; 0
    49a0:	4f e7       	ldi	r20, 0x7F	; 127
    49a2:	53 e4       	ldi	r21, 0x43	; 67
    49a4:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    49a8:	18 16       	cp	r1, r24
    49aa:	0c f0       	brlt	.+2      	; 0x49ae <chb_reset+0x264>
    49ac:	10 e0       	ldi	r17, 0x00	; 0
    49ae:	11 23       	and	r17, r17
    49b0:	09 f4       	brne	.+2      	; 0x49b4 <chb_reset+0x26a>
    49b2:	89 c0       	rjmp	.+274    	; 0x4ac6 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    49b4:	69 8d       	ldd	r22, Y+25	; 0x19
    49b6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    49b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    49ba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    49bc:	20 e0       	ldi	r18, 0x00	; 0
    49be:	30 e0       	ldi	r19, 0x00	; 0
    49c0:	4a e7       	ldi	r20, 0x7A	; 122
    49c2:	54 e4       	ldi	r21, 0x44	; 68
    49c4:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    49c8:	dc 01       	movw	r26, r24
    49ca:	cb 01       	movw	r24, r22
    49cc:	8a a3       	lds	r24, 0x5a
    49ce:	9b a3       	lds	r25, 0x5b
    49d0:	ac a3       	lds	r26, 0x5c
    49d2:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    49d4:	6a a1       	lds	r22, 0x4a
    49d6:	7b a1       	lds	r23, 0x4b
    49d8:	8c a1       	lds	r24, 0x4c
    49da:	9d a1       	lds	r25, 0x4d
    49dc:	20 e0       	ldi	r18, 0x00	; 0
    49de:	30 e0       	ldi	r19, 0x00	; 0
    49e0:	4a e7       	ldi	r20, 0x7A	; 122
    49e2:	53 e4       	ldi	r21, 0x43	; 67
    49e4:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    49e8:	dc 01       	movw	r26, r24
    49ea:	cb 01       	movw	r24, r22
    49ec:	8e a3       	lds	r24, 0x5e
    49ee:	9f a3       	lds	r25, 0x5f
    49f0:	a8 a7       	lds	r26, 0x78
    49f2:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    49f4:	11 e0       	ldi	r17, 0x01	; 1
    49f6:	6e a1       	lds	r22, 0x4e
    49f8:	7f a1       	lds	r23, 0x4f
    49fa:	88 a5       	lds	r24, 0x68
    49fc:	99 a5       	lds	r25, 0x69
    49fe:	20 e0       	ldi	r18, 0x00	; 0
    4a00:	30 e0       	ldi	r19, 0x00	; 0
    4a02:	40 e8       	ldi	r20, 0x80	; 128
    4a04:	5f e3       	ldi	r21, 0x3F	; 63
    4a06:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    4a0a:	88 23       	and	r24, r24
    4a0c:	0c f0       	brlt	.+2      	; 0x4a10 <chb_reset+0x2c6>
    4a0e:	10 e0       	ldi	r17, 0x00	; 0
    4a10:	11 23       	and	r17, r17
    4a12:	29 f0       	breq	.+10     	; 0x4a1e <chb_reset+0x2d4>
		__ticks = 1;
    4a14:	81 e0       	ldi	r24, 0x01	; 1
    4a16:	90 e0       	ldi	r25, 0x00	; 0
    4a18:	8a a7       	lds	r24, 0x7a
    4a1a:	9b a7       	lds	r25, 0x7b
    4a1c:	46 c0       	rjmp	.+140    	; 0x4aaa <chb_reset+0x360>
	else if (__tmp > 65535)
    4a1e:	11 e0       	ldi	r17, 0x01	; 1
    4a20:	6e a1       	lds	r22, 0x4e
    4a22:	7f a1       	lds	r23, 0x4f
    4a24:	88 a5       	lds	r24, 0x68
    4a26:	99 a5       	lds	r25, 0x69
    4a28:	20 e0       	ldi	r18, 0x00	; 0
    4a2a:	3f ef       	ldi	r19, 0xFF	; 255
    4a2c:	4f e7       	ldi	r20, 0x7F	; 127
    4a2e:	57 e4       	ldi	r21, 0x47	; 71
    4a30:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    4a34:	18 16       	cp	r1, r24
    4a36:	0c f0       	brlt	.+2      	; 0x4a3a <chb_reset+0x2f0>
    4a38:	10 e0       	ldi	r17, 0x00	; 0
    4a3a:	11 23       	and	r17, r17
    4a3c:	61 f1       	breq	.+88     	; 0x4a96 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a3e:	6a a1       	lds	r22, 0x4a
    4a40:	7b a1       	lds	r23, 0x4b
    4a42:	8c a1       	lds	r24, 0x4c
    4a44:	9d a1       	lds	r25, 0x4d
    4a46:	20 e0       	ldi	r18, 0x00	; 0
    4a48:	30 e0       	ldi	r19, 0x00	; 0
    4a4a:	40 e2       	ldi	r20, 0x20	; 32
    4a4c:	51 e4       	ldi	r21, 0x41	; 65
    4a4e:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    4a52:	dc 01       	movw	r26, r24
    4a54:	cb 01       	movw	r24, r22
    4a56:	bc 01       	movw	r22, r24
    4a58:	cd 01       	movw	r24, r26
    4a5a:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    4a5e:	dc 01       	movw	r26, r24
    4a60:	cb 01       	movw	r24, r22
    4a62:	8a a7       	lds	r24, 0x7a
    4a64:	9b a7       	lds	r25, 0x7b
    4a66:	12 c0       	rjmp	.+36     	; 0x4a8c <chb_reset+0x342>
    4a68:	89 e1       	ldi	r24, 0x19	; 25
    4a6a:	90 e0       	ldi	r25, 0x00	; 0
    4a6c:	8c a7       	lds	r24, 0x7c
    4a6e:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4a70:	8c a5       	lds	r24, 0x6c
    4a72:	9d a5       	lds	r25, 0x6d
    4a74:	8c 01       	movw	r16, r24
    4a76:	c8 01       	movw	r24, r16
    4a78:	01 97       	sbiw	r24, 0x01	; 1
    4a7a:	f1 f7       	brne	.-4      	; 0x4a78 <chb_reset+0x32e>
    4a7c:	8c 01       	movw	r16, r24
    4a7e:	0c a7       	lds	r16, 0x7c
    4a80:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a82:	8a a5       	lds	r24, 0x6a
    4a84:	9b a5       	lds	r25, 0x6b
    4a86:	01 97       	sbiw	r24, 0x01	; 1
    4a88:	8a a7       	lds	r24, 0x7a
    4a8a:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a8c:	8a a5       	lds	r24, 0x6a
    4a8e:	9b a5       	lds	r25, 0x6b
    4a90:	00 97       	sbiw	r24, 0x00	; 0
    4a92:	51 f7       	brne	.-44     	; 0x4a68 <chb_reset+0x31e>
    4a94:	28 c0       	rjmp	.+80     	; 0x4ae6 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a96:	6e a1       	lds	r22, 0x4e
    4a98:	7f a1       	lds	r23, 0x4f
    4a9a:	88 a5       	lds	r24, 0x68
    4a9c:	99 a5       	lds	r25, 0x69
    4a9e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    4aa2:	dc 01       	movw	r26, r24
    4aa4:	cb 01       	movw	r24, r22
    4aa6:	8a a7       	lds	r24, 0x7a
    4aa8:	9b a7       	lds	r25, 0x7b
    4aaa:	8a a5       	lds	r24, 0x6a
    4aac:	9b a5       	lds	r25, 0x6b
    4aae:	8e a7       	lds	r24, 0x7e
    4ab0:	9f a7       	lds	r25, 0x7f
    4ab2:	8e a5       	lds	r24, 0x6e
    4ab4:	9f a5       	lds	r25, 0x6f
    4ab6:	8c 01       	movw	r16, r24
    4ab8:	f8 01       	movw	r30, r16
    4aba:	31 97       	sbiw	r30, 0x01	; 1
    4abc:	f1 f7       	brne	.-4      	; 0x4aba <chb_reset+0x370>
    4abe:	8f 01       	movw	r16, r30
    4ac0:	0e a7       	lds	r16, 0x7e
    4ac2:	1f a7       	lds	r17, 0x7f
    4ac4:	10 c0       	rjmp	.+32     	; 0x4ae6 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4ac6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4ac8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4aca:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4acc:	98 a1       	lds	r25, 0x48
    4ace:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    4ad2:	dc 01       	movw	r26, r24
    4ad4:	cb 01       	movw	r24, r22
    4ad6:	89 a3       	lds	r24, 0x59
    4ad8:	89 a1       	lds	r24, 0x49
    4ada:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4adc:	88 a9       	sts	0x48, r24
    4ade:	18 2f       	mov	r17, r24
    4ae0:	1a 95       	dec	r17
    4ae2:	f1 f7       	brne	.-4      	; 0x4ae0 <chb_reset+0x396>
    4ae4:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4ae6:	84 e6       	ldi	r24, 0x64	; 100
    4ae8:	96 e0       	ldi	r25, 0x06	; 6
    4aea:	24 e6       	ldi	r18, 0x64	; 100
    4aec:	36 e0       	ldi	r19, 0x06	; 6
    4aee:	f9 01       	movw	r30, r18
    4af0:	20 81       	ld	r18, Z
    4af2:	21 60       	ori	r18, 0x01	; 1
    4af4:	fc 01       	movw	r30, r24
    4af6:	20 83       	st	Z, r18
    4af8:	01 c0       	rjmp	.+2      	; 0x4afc <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4afa:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    4afc:	8d e1       	ldi	r24, 0x1D	; 29
    4afe:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    4b02:	81 30       	cpi	r24, 0x01	; 1
    4b04:	d1 f7       	brne	.-12     	; 0x4afa <chb_reset+0x3b0>
    4b06:	8c e1       	ldi	r24, 0x1C	; 28
    4b08:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    4b0c:	87 30       	cpi	r24, 0x07	; 7
    4b0e:	a9 f7       	brne	.-22     	; 0x4afa <chb_reset+0x3b0>
        {
            break;
    4b10:	00 00       	nop
        }
    }
	

}
    4b12:	e0 96       	adiw	r28, 0x30	; 48
    4b14:	cd bf       	out	0x3d, r28	; 61
    4b16:	de bf       	out	0x3e, r29	; 62
    4b18:	df 91       	pop	r29
    4b1a:	cf 91       	pop	r28
    4b1c:	1f 91       	pop	r17
    4b1e:	0f 91       	pop	r16
    4b20:	08 95       	ret

00004b22 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    4b22:	cf 93       	push	r28
    4b24:	df 93       	push	r29
    4b26:	0f 92       	push	r0
    4b28:	0f 92       	push	r0
    4b2a:	cd b7       	in	r28, 0x3d	; 61
    4b2c:	de b7       	in	r29, 0x3e	; 62
    4b2e:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    4b30:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    4b32:	8a 81       	ldd	r24, Y+2	; 0x02
    4b34:	80 68       	ori	r24, 0x80	; 128
    4b36:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4b38:	8f e3       	ldi	r24, 0x3F	; 63
    4b3a:	90 e0       	ldi	r25, 0x00	; 0
    4b3c:	fc 01       	movw	r30, r24
    4b3e:	80 81       	ld	r24, Z
    4b40:	80 93 4b 40 	sts	0x404B, r24
    4b44:	f8 94       	cli
    RadioCS(TRUE);
    4b46:	81 e0       	ldi	r24, 0x01	; 1
    4b48:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b4e:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4b52:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4b54:	89 81       	ldd	r24, Y+1	; 0x01
    4b56:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4b5a:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4b5c:	80 e0       	ldi	r24, 0x00	; 0
    4b5e:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>
    CHB_LEAVE_CRIT();
    4b62:	8f e3       	ldi	r24, 0x3F	; 63
    4b64:	90 e0       	ldi	r25, 0x00	; 0
    4b66:	20 91 4b 40 	lds	r18, 0x404B
    4b6a:	fc 01       	movw	r30, r24
    4b6c:	20 83       	st	Z, r18
    4b6e:	78 94       	sei

    return val;
    4b70:	89 81       	ldd	r24, Y+1	; 0x01
}
    4b72:	0f 90       	pop	r0
    4b74:	0f 90       	pop	r0
    4b76:	df 91       	pop	r29
    4b78:	cf 91       	pop	r28
    4b7a:	08 95       	ret

00004b7c <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4b7c:	cf 93       	push	r28
    4b7e:	df 93       	push	r29
    4b80:	00 d0       	rcall	.+0      	; 0x4b82 <chb_reg_read16+0x6>
    4b82:	0f 92       	push	r0
    4b84:	cd b7       	in	r28, 0x3d	; 61
    4b86:	de b7       	in	r29, 0x3e	; 62
    4b88:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4b8a:	1a 82       	std	Y+2, r1	; 0x02
    4b8c:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    4b8e:	19 82       	std	Y+1, r1	; 0x01
    4b90:	1d c0       	rjmp	.+58     	; 0x4bcc <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4b92:	9c 81       	ldd	r25, Y+4	; 0x04
    4b94:	89 81       	ldd	r24, Y+1	; 0x01
    4b96:	89 0f       	add	r24, r25
    4b98:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    4b9c:	88 2f       	mov	r24, r24
    4b9e:	90 e0       	ldi	r25, 0x00	; 0
    4ba0:	29 81       	ldd	r18, Y+1	; 0x01
    4ba2:	22 2f       	mov	r18, r18
    4ba4:	30 e0       	ldi	r19, 0x00	; 0
    4ba6:	22 0f       	add	r18, r18
    4ba8:	33 1f       	adc	r19, r19
    4baa:	22 0f       	add	r18, r18
    4bac:	33 1f       	adc	r19, r19
    4bae:	22 0f       	add	r18, r18
    4bb0:	33 1f       	adc	r19, r19
    4bb2:	02 2e       	mov	r0, r18
    4bb4:	02 c0       	rjmp	.+4      	; 0x4bba <chb_reg_read16+0x3e>
    4bb6:	88 0f       	add	r24, r24
    4bb8:	99 1f       	adc	r25, r25
    4bba:	0a 94       	dec	r0
    4bbc:	e2 f7       	brpl	.-8      	; 0x4bb6 <chb_reg_read16+0x3a>
    4bbe:	98 2f       	mov	r25, r24
    4bc0:	8c 81       	ldd	r24, Y+4	; 0x04
    4bc2:	89 2b       	or	r24, r25
    4bc4:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4bc6:	89 81       	ldd	r24, Y+1	; 0x01
    4bc8:	8f 5f       	subi	r24, 0xFF	; 255
    4bca:	89 83       	std	Y+1, r24	; 0x01
    4bcc:	89 81       	ldd	r24, Y+1	; 0x01
    4bce:	82 30       	cpi	r24, 0x02	; 2
    4bd0:	00 f3       	brcs	.-64     	; 0x4b92 <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    4bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    4bd4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4bd6:	24 96       	adiw	r28, 0x04	; 4
    4bd8:	cd bf       	out	0x3d, r28	; 61
    4bda:	de bf       	out	0x3e, r29	; 62
    4bdc:	df 91       	pop	r29
    4bde:	cf 91       	pop	r28
    4be0:	08 95       	ret

00004be2 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    4be2:	cf 93       	push	r28
    4be4:	df 93       	push	r29
    4be6:	00 d0       	rcall	.+0      	; 0x4be8 <chb_reg_write+0x6>
    4be8:	cd b7       	in	r28, 0x3d	; 61
    4bea:	de b7       	in	r29, 0x3e	; 62
    4bec:	8a 83       	std	Y+2, r24	; 0x02
    4bee:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    4bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf2:	80 6c       	ori	r24, 0xC0	; 192
    4bf4:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4bf6:	8f e3       	ldi	r24, 0x3F	; 63
    4bf8:	90 e0       	ldi	r25, 0x00	; 0
    4bfa:	fc 01       	movw	r30, r24
    4bfc:	80 81       	ld	r24, Z
    4bfe:	80 93 4b 40 	sts	0x404B, r24
    4c02:	f8 94       	cli
    RadioCS(TRUE);
    4c04:	81 e0       	ldi	r24, 0x01	; 1
    4c06:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    4c0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c0c:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4c10:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    4c12:	8b 81       	ldd	r24, Y+3	; 0x03
    4c14:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4c18:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4c1a:	80 e0       	ldi	r24, 0x00	; 0
    4c1c:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>
    CHB_LEAVE_CRIT();
    4c20:	8f e3       	ldi	r24, 0x3F	; 63
    4c22:	90 e0       	ldi	r25, 0x00	; 0
    4c24:	20 91 4b 40 	lds	r18, 0x404B
    4c28:	fc 01       	movw	r30, r24
    4c2a:	20 83       	st	Z, r18
    4c2c:	78 94       	sei
}
    4c2e:	23 96       	adiw	r28, 0x03	; 3
    4c30:	cd bf       	out	0x3d, r28	; 61
    4c32:	de bf       	out	0x3e, r29	; 62
    4c34:	df 91       	pop	r29
    4c36:	cf 91       	pop	r28
    4c38:	08 95       	ret

00004c3a <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4c3a:	cf 93       	push	r28
    4c3c:	df 93       	push	r29
    4c3e:	00 d0       	rcall	.+0      	; 0x4c40 <chb_reg_write16+0x6>
    4c40:	0f 92       	push	r0
    4c42:	cd b7       	in	r28, 0x3d	; 61
    4c44:	de b7       	in	r29, 0x3e	; 62
    4c46:	8a 83       	std	Y+2, r24	; 0x02
    4c48:	6b 83       	std	Y+3, r22	; 0x03
    4c4a:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4c4c:	19 82       	std	Y+1, r1	; 0x01
    4c4e:	1d c0       	rjmp	.+58     	; 0x4c8a <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4c50:	9a 81       	ldd	r25, Y+2	; 0x02
    4c52:	89 81       	ldd	r24, Y+1	; 0x01
    4c54:	49 2f       	mov	r20, r25
    4c56:	48 0f       	add	r20, r24
    4c58:	89 81       	ldd	r24, Y+1	; 0x01
    4c5a:	88 2f       	mov	r24, r24
    4c5c:	90 e0       	ldi	r25, 0x00	; 0
    4c5e:	9c 01       	movw	r18, r24
    4c60:	22 0f       	add	r18, r18
    4c62:	33 1f       	adc	r19, r19
    4c64:	22 0f       	add	r18, r18
    4c66:	33 1f       	adc	r19, r19
    4c68:	22 0f       	add	r18, r18
    4c6a:	33 1f       	adc	r19, r19
    4c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c70:	02 c0       	rjmp	.+4      	; 0x4c76 <chb_reg_write16+0x3c>
    4c72:	96 95       	lsr	r25
    4c74:	87 95       	ror	r24
    4c76:	2a 95       	dec	r18
    4c78:	e2 f7       	brpl	.-8      	; 0x4c72 <chb_reg_write16+0x38>
    4c7a:	98 2f       	mov	r25, r24
    4c7c:	84 2f       	mov	r24, r20
    4c7e:	69 2f       	mov	r22, r25
    4c80:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4c84:	89 81       	ldd	r24, Y+1	; 0x01
    4c86:	8f 5f       	subi	r24, 0xFF	; 255
    4c88:	89 83       	std	Y+1, r24	; 0x01
    4c8a:	89 81       	ldd	r24, Y+1	; 0x01
    4c8c:	82 30       	cpi	r24, 0x02	; 2
    4c8e:	00 f3       	brcs	.-64     	; 0x4c50 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4c90:	24 96       	adiw	r28, 0x04	; 4
    4c92:	cd bf       	out	0x3d, r28	; 61
    4c94:	de bf       	out	0x3e, r29	; 62
    4c96:	df 91       	pop	r29
    4c98:	cf 91       	pop	r28
    4c9a:	08 95       	ret

00004c9c <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4c9c:	cf 93       	push	r28
    4c9e:	df 93       	push	r29
    4ca0:	00 d0       	rcall	.+0      	; 0x4ca2 <chb_reg_write64+0x6>
    4ca2:	0f 92       	push	r0
    4ca4:	cd b7       	in	r28, 0x3d	; 61
    4ca6:	de b7       	in	r29, 0x3e	; 62
    4ca8:	8a 83       	std	Y+2, r24	; 0x02
    4caa:	6b 83       	std	Y+3, r22	; 0x03
    4cac:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4cae:	19 82       	std	Y+1, r1	; 0x01
    4cb0:	14 c0       	rjmp	.+40     	; 0x4cda <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    4cb4:	89 81       	ldd	r24, Y+1	; 0x01
    4cb6:	49 2f       	mov	r20, r25
    4cb8:	48 0f       	add	r20, r24
    4cba:	89 81       	ldd	r24, Y+1	; 0x01
    4cbc:	88 2f       	mov	r24, r24
    4cbe:	90 e0       	ldi	r25, 0x00	; 0
    4cc0:	2b 81       	ldd	r18, Y+3	; 0x03
    4cc2:	3c 81       	ldd	r19, Y+4	; 0x04
    4cc4:	82 0f       	add	r24, r18
    4cc6:	93 1f       	adc	r25, r19
    4cc8:	fc 01       	movw	r30, r24
    4cca:	90 81       	ld	r25, Z
    4ccc:	84 2f       	mov	r24, r20
    4cce:	69 2f       	mov	r22, r25
    4cd0:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4cd4:	89 81       	ldd	r24, Y+1	; 0x01
    4cd6:	8f 5f       	subi	r24, 0xFF	; 255
    4cd8:	89 83       	std	Y+1, r24	; 0x01
    4cda:	89 81       	ldd	r24, Y+1	; 0x01
    4cdc:	88 30       	cpi	r24, 0x08	; 8
    4cde:	48 f3       	brcs	.-46     	; 0x4cb2 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    4ce0:	24 96       	adiw	r28, 0x04	; 4
    4ce2:	cd bf       	out	0x3d, r28	; 61
    4ce4:	de bf       	out	0x3e, r29	; 62
    4ce6:	df 91       	pop	r29
    4ce8:	cf 91       	pop	r28
    4cea:	08 95       	ret

00004cec <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    4cec:	cf 93       	push	r28
    4cee:	df 93       	push	r29
    4cf0:	00 d0       	rcall	.+0      	; 0x4cf2 <chb_reg_read_mod_write+0x6>
    4cf2:	0f 92       	push	r0
    4cf4:	cd b7       	in	r28, 0x3d	; 61
    4cf6:	de b7       	in	r29, 0x3e	; 62
    4cf8:	8a 83       	std	Y+2, r24	; 0x02
    4cfa:	6b 83       	std	Y+3, r22	; 0x03
    4cfc:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    4cfe:	8a 81       	ldd	r24, Y+2	; 0x02
    4d00:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    4d04:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4d06:	9b 81       	ldd	r25, Y+3	; 0x03
    4d08:	8c 81       	ldd	r24, Y+4	; 0x04
    4d0a:	89 23       	and	r24, r25
    4d0c:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4d0e:	8c 81       	ldd	r24, Y+4	; 0x04
    4d10:	98 2f       	mov	r25, r24
    4d12:	90 95       	com	r25
    4d14:	89 81       	ldd	r24, Y+1	; 0x01
    4d16:	89 23       	and	r24, r25
    4d18:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4d1a:	99 81       	ldd	r25, Y+1	; 0x01
    4d1c:	8b 81       	ldd	r24, Y+3	; 0x03
    4d1e:	89 2b       	or	r24, r25
    4d20:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4d22:	8a 81       	ldd	r24, Y+2	; 0x02
    4d24:	69 81       	ldd	r22, Y+1	; 0x01
    4d26:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <chb_reg_write>
}
    4d2a:	24 96       	adiw	r28, 0x04	; 4
    4d2c:	cd bf       	out	0x3d, r28	; 61
    4d2e:	de bf       	out	0x3e, r29	; 62
    4d30:	df 91       	pop	r29
    4d32:	cf 91       	pop	r28
    4d34:	08 95       	ret

00004d36 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4d36:	cf 93       	push	r28
    4d38:	df 93       	push	r29
    4d3a:	cd b7       	in	r28, 0x3d	; 61
    4d3c:	de b7       	in	r29, 0x3e	; 62
    4d3e:	28 97       	sbiw	r28, 0x08	; 8
    4d40:	cd bf       	out	0x3d, r28	; 61
    4d42:	de bf       	out	0x3e, r29	; 62
    4d44:	8b 83       	std	Y+3, r24	; 0x03
    4d46:	9c 83       	std	Y+4, r25	; 0x04
    4d48:	6d 83       	std	Y+5, r22	; 0x05
    4d4a:	4e 83       	std	Y+6, r20	; 0x06
    4d4c:	5f 83       	std	Y+7, r21	; 0x07
    4d4e:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4d50:	8d 81       	ldd	r24, Y+5	; 0x05
    4d52:	28 2f       	mov	r18, r24
    4d54:	30 e0       	ldi	r19, 0x00	; 0
    4d56:	88 85       	ldd	r24, Y+8	; 0x08
    4d58:	88 2f       	mov	r24, r24
    4d5a:	90 e0       	ldi	r25, 0x00	; 0
    4d5c:	82 0f       	add	r24, r18
    4d5e:	93 1f       	adc	r25, r19
    4d60:	80 38       	cpi	r24, 0x80	; 128
    4d62:	91 05       	cpc	r25, r1
    4d64:	0c f0       	brlt	.+2      	; 0x4d68 <chb_frame_write+0x32>
    4d66:	45 c0       	rjmp	.+138    	; 0x4df2 <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4d68:	8f e3       	ldi	r24, 0x3F	; 63
    4d6a:	90 e0       	ldi	r25, 0x00	; 0
    4d6c:	fc 01       	movw	r30, r24
    4d6e:	80 81       	ld	r24, Z
    4d70:	80 93 4b 40 	sts	0x404B, r24
    4d74:	f8 94       	cli
    RadioCS(TRUE); 
    4d76:	81 e0       	ldi	r24, 0x01	; 1
    4d78:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    4d7c:	80 e6       	ldi	r24, 0x60	; 96
    4d7e:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4d82:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4d84:	19 82       	std	Y+1, r1	; 0x01
    4d86:	10 c0       	rjmp	.+32     	; 0x4da8 <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4d88:	8b 81       	ldd	r24, Y+3	; 0x03
    4d8a:	9c 81       	ldd	r25, Y+4	; 0x04
    4d8c:	fc 01       	movw	r30, r24
    4d8e:	20 81       	ld	r18, Z
    4d90:	8b 81       	ldd	r24, Y+3	; 0x03
    4d92:	9c 81       	ldd	r25, Y+4	; 0x04
    4d94:	01 96       	adiw	r24, 0x01	; 1
    4d96:	8b 83       	std	Y+3, r24	; 0x03
    4d98:	9c 83       	std	Y+4, r25	; 0x04
    4d9a:	82 2f       	mov	r24, r18
    4d9c:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4da0:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4da2:	89 81       	ldd	r24, Y+1	; 0x01
    4da4:	8f 5f       	subi	r24, 0xFF	; 255
    4da6:	89 83       	std	Y+1, r24	; 0x01
    4da8:	99 81       	ldd	r25, Y+1	; 0x01
    4daa:	8d 81       	ldd	r24, Y+5	; 0x05
    4dac:	98 17       	cp	r25, r24
    4dae:	60 f3       	brcs	.-40     	; 0x4d88 <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4db0:	19 82       	std	Y+1, r1	; 0x01
    4db2:	10 c0       	rjmp	.+32     	; 0x4dd4 <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4db4:	8e 81       	ldd	r24, Y+6	; 0x06
    4db6:	9f 81       	ldd	r25, Y+7	; 0x07
    4db8:	fc 01       	movw	r30, r24
    4dba:	20 81       	ld	r18, Z
    4dbc:	8e 81       	ldd	r24, Y+6	; 0x06
    4dbe:	9f 81       	ldd	r25, Y+7	; 0x07
    4dc0:	01 96       	adiw	r24, 0x01	; 1
    4dc2:	8e 83       	std	Y+6, r24	; 0x06
    4dc4:	9f 83       	std	Y+7, r25	; 0x07
    4dc6:	82 2f       	mov	r24, r18
    4dc8:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4dcc:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4dce:	89 81       	ldd	r24, Y+1	; 0x01
    4dd0:	8f 5f       	subi	r24, 0xFF	; 255
    4dd2:	89 83       	std	Y+1, r24	; 0x01
    4dd4:	99 81       	ldd	r25, Y+1	; 0x01
    4dd6:	88 85       	ldd	r24, Y+8	; 0x08
    4dd8:	98 17       	cp	r25, r24
    4dda:	60 f3       	brcs	.-40     	; 0x4db4 <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    4ddc:	80 e0       	ldi	r24, 0x00	; 0
    4dde:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>
    CHB_LEAVE_CRIT();
    4de2:	8f e3       	ldi	r24, 0x3F	; 63
    4de4:	90 e0       	ldi	r25, 0x00	; 0
    4de6:	20 91 4b 40 	lds	r18, 0x404B
    4dea:	fc 01       	movw	r30, r24
    4dec:	20 83       	st	Z, r18
    4dee:	78 94       	sei
    4df0:	01 c0       	rjmp	.+2      	; 0x4df4 <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4df2:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4df4:	28 96       	adiw	r28, 0x08	; 8
    4df6:	cd bf       	out	0x3d, r28	; 61
    4df8:	de bf       	out	0x3e, r29	; 62
    4dfa:	df 91       	pop	r29
    4dfc:	cf 91       	pop	r28
    4dfe:	08 95       	ret

00004e00 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    4e00:	0f 93       	push	r16
    4e02:	1f 93       	push	r17
    4e04:	cf 93       	push	r28
    4e06:	df 93       	push	r29
    4e08:	cd b7       	in	r28, 0x3d	; 61
    4e0a:	de b7       	in	r29, 0x3e	; 62
    4e0c:	e7 97       	sbiw	r28, 0x37	; 55
    4e0e:	cd bf       	out	0x3d, r28	; 61
    4e10:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4e12:	8f e3       	ldi	r24, 0x3F	; 63
    4e14:	90 e0       	ldi	r25, 0x00	; 0
    4e16:	fc 01       	movw	r30, r24
    4e18:	80 81       	ld	r24, Z
    4e1a:	80 93 4b 40 	sts	0x404B, r24
    4e1e:	f8 94       	cli
    RadioCS(TRUE);
    4e20:	81 e0       	ldi	r24, 0x01	; 1
    4e22:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4e26:	80 e2       	ldi	r24, 0x20	; 32
    4e28:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    len = SPID_write(0);
    4e2c:	80 e0       	ldi	r24, 0x00	; 0
    4e2e:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4e32:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4e34:	8a 81       	ldd	r24, Y+2	; 0x02
    4e36:	83 30       	cpi	r24, 0x03	; 3
    4e38:	08 f4       	brcc	.+2      	; 0x4e3c <chb_frame_read+0x3c>
    4e3a:	66 c0       	rjmp	.+204    	; 0x4f08 <chb_frame_read+0x108>
    4e3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e3e:	88 23       	and	r24, r24
    4e40:	0c f4       	brge	.+2      	; 0x4e44 <chb_frame_read+0x44>
    4e42:	62 c0       	rjmp	.+196    	; 0x4f08 <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4e44:	8a 81       	ldd	r24, Y+2	; 0x02
    4e46:	08 2f       	mov	r16, r24
    4e48:	10 e0       	ldi	r17, 0x00	; 0
    4e4a:	0e 94 84 23 	call	0x4708	; 0x4708 <chb_buf_get_len>
    4e4e:	88 2f       	mov	r24, r24
    4e50:	90 e0       	ldi	r25, 0x00	; 0
    4e52:	20 e8       	ldi	r18, 0x80	; 128
    4e54:	30 e0       	ldi	r19, 0x00	; 0
    4e56:	a9 01       	movw	r20, r18
    4e58:	48 1b       	sub	r20, r24
    4e5a:	59 0b       	sbc	r21, r25
    4e5c:	ca 01       	movw	r24, r20
    4e5e:	08 17       	cp	r16, r24
    4e60:	19 07       	cpc	r17, r25
    4e62:	f4 f4       	brge	.+60     	; 0x4ea0 <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4e64:	8a 81       	ldd	r24, Y+2	; 0x02
    4e66:	0e 94 3c 23 	call	0x4678	; 0x4678 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4e6a:	19 82       	std	Y+1, r1	; 0x01
    4e6c:	0a c0       	rjmp	.+20     	; 0x4e82 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4e6e:	80 e0       	ldi	r24, 0x00	; 0
    4e70:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4e74:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4e76:	8b 81       	ldd	r24, Y+3	; 0x03
    4e78:	0e 94 3c 23 	call	0x4678	; 0x4678 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4e7c:	89 81       	ldd	r24, Y+1	; 0x01
    4e7e:	8f 5f       	subi	r24, 0xFF	; 255
    4e80:	89 83       	std	Y+1, r24	; 0x01
    4e82:	99 81       	ldd	r25, Y+1	; 0x01
    4e84:	8a 81       	ldd	r24, Y+2	; 0x02
    4e86:	98 17       	cp	r25, r24
    4e88:	90 f3       	brcs	.-28     	; 0x4e6e <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4e8a:	80 e8       	ldi	r24, 0x80	; 128
    4e8c:	96 e0       	ldi	r25, 0x06	; 6
    4e8e:	24 e0       	ldi	r18, 0x04	; 4
    4e90:	fc 01       	movw	r30, r24
    4e92:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4e94:	80 e8       	ldi	r24, 0x80	; 128
    4e96:	96 e0       	ldi	r25, 0x06	; 6
    4e98:	24 e0       	ldi	r18, 0x04	; 4
    4e9a:	fc 01       	movw	r30, r24
    4e9c:	26 83       	std	Z+6, r18	; 0x06
    4e9e:	34 c0       	rjmp	.+104    	; 0x4f08 <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4ea0:	0e 94 8a 20 	call	0x4114	; 0x4114 <chb_get_pcb>
    4ea4:	8c 83       	std	Y+4, r24	; 0x04
    4ea6:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4ea8:	19 82       	std	Y+1, r1	; 0x01
    4eaa:	07 c0       	rjmp	.+14     	; 0x4eba <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    4eac:	80 e0       	ldi	r24, 0x00	; 0
    4eae:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    4eb2:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4eb4:	89 81       	ldd	r24, Y+1	; 0x01
    4eb6:	8f 5f       	subi	r24, 0xFF	; 255
    4eb8:	89 83       	std	Y+1, r24	; 0x01
    4eba:	99 81       	ldd	r25, Y+1	; 0x01
    4ebc:	8a 81       	ldd	r24, Y+2	; 0x02
    4ebe:	98 17       	cp	r25, r24
    4ec0:	a8 f3       	brcs	.-22     	; 0x4eac <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4ec2:	8c 81       	ldd	r24, Y+4	; 0x04
    4ec4:	9d 81       	ldd	r25, Y+5	; 0x05
    4ec6:	fc 01       	movw	r30, r24
    4ec8:	85 85       	ldd	r24, Z+13	; 0x0d
    4eca:	96 85       	ldd	r25, Z+14	; 0x0e
    4ecc:	9c 01       	movw	r18, r24
    4ece:	2f 5f       	subi	r18, 0xFF	; 255
    4ed0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    4ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    4ed6:	fc 01       	movw	r30, r24
    4ed8:	25 87       	std	Z+13, r18	; 0x0d
    4eda:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4edc:	ce 01       	movw	r24, r28
    4ede:	06 96       	adiw	r24, 0x06	; 6
    4ee0:	28 ee       	ldi	r18, 0xE8	; 232
    4ee2:	31 e0       	ldi	r19, 0x01	; 1
    4ee4:	b9 01       	movw	r22, r18
    4ee6:	0e 94 13 5f 	call	0xbe26	; 0xbe26 <strcpy_P>
            printf(buf);
    4eea:	0f 92       	push	r0
    4eec:	0f 92       	push	r0
    4eee:	8d b7       	in	r24, 0x3d	; 61
    4ef0:	9e b7       	in	r25, 0x3e	; 62
    4ef2:	01 96       	adiw	r24, 0x01	; 1
    4ef4:	9e 01       	movw	r18, r28
    4ef6:	2a 5f       	subi	r18, 0xFA	; 250
    4ef8:	3f 4f       	sbci	r19, 0xFF	; 255
    4efa:	fc 01       	movw	r30, r24
    4efc:	20 83       	st	Z, r18
    4efe:	31 83       	std	Z+1, r19	; 0x01
    4f00:	0e 94 6d 5f 	call	0xbeda	; 0xbeda <printf>
    4f04:	0f 90       	pop	r0
    4f06:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4f08:	80 e0       	ldi	r24, 0x00	; 0
    4f0a:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>
    CHB_LEAVE_CRIT();
    4f0e:	8f e3       	ldi	r24, 0x3F	; 63
    4f10:	90 e0       	ldi	r25, 0x00	; 0
    4f12:	20 91 4b 40 	lds	r18, 0x404B
    4f16:	fc 01       	movw	r30, r24
    4f18:	20 83       	st	Z, r18
    4f1a:	78 94       	sei
}
    4f1c:	e7 96       	adiw	r28, 0x37	; 55
    4f1e:	cd bf       	out	0x3d, r28	; 61
    4f20:	de bf       	out	0x3e, r29	; 62
    4f22:	df 91       	pop	r29
    4f24:	cf 91       	pop	r28
    4f26:	1f 91       	pop	r17
    4f28:	0f 91       	pop	r16
    4f2a:	08 95       	ret

00004f2c <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4f2c:	cf 93       	push	r28
    4f2e:	df 93       	push	r29
    4f30:	0f 92       	push	r0
    4f32:	cd b7       	in	r28, 0x3d	; 61
    4f34:	de b7       	in	r29, 0x3e	; 62
    4f36:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4f38:	89 81       	ldd	r24, Y+1	; 0x01
    4f3a:	88 2f       	mov	r24, r24
    4f3c:	90 e0       	ldi	r25, 0x00	; 0
    4f3e:	81 30       	cpi	r24, 0x01	; 1
    4f40:	91 05       	cpc	r25, r1
    4f42:	c1 f0       	breq	.+48     	; 0x4f74 <chb_set_mode+0x48>
    4f44:	82 30       	cpi	r24, 0x02	; 2
    4f46:	91 05       	cpc	r25, r1
    4f48:	1c f4       	brge	.+6      	; 0x4f50 <chb_set_mode+0x24>
    4f4a:	00 97       	sbiw	r24, 0x00	; 0
    4f4c:	41 f0       	breq	.+16     	; 0x4f5e <chb_set_mode+0x32>
    4f4e:	33 c0       	rjmp	.+102    	; 0x4fb6 <chb_set_mode+0x8a>
    4f50:	82 30       	cpi	r24, 0x02	; 2
    4f52:	91 05       	cpc	r25, r1
    4f54:	d1 f0       	breq	.+52     	; 0x4f8a <chb_set_mode+0x5e>
    4f56:	83 30       	cpi	r24, 0x03	; 3
    4f58:	91 05       	cpc	r25, r1
    4f5a:	11 f1       	breq	.+68     	; 0x4fa0 <chb_set_mode+0x74>
    4f5c:	2c c0       	rjmp	.+88     	; 0x4fb6 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4f5e:	8c e0       	ldi	r24, 0x0C	; 12
    4f60:	68 e0       	ldi	r22, 0x08	; 8
    4f62:	4f e3       	ldi	r20, 0x3F	; 63
    4f64:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f68:	86 e1       	ldi	r24, 0x16	; 22
    4f6a:	62 e0       	ldi	r22, 0x02	; 2
    4f6c:	43 e0       	ldi	r20, 0x03	; 3
    4f6e:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        break;
    4f72:	21 c0       	rjmp	.+66     	; 0x4fb6 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4f74:	8c e0       	ldi	r24, 0x0C	; 12
    4f76:	6c e0       	ldi	r22, 0x0C	; 12
    4f78:	4f e3       	ldi	r20, 0x3F	; 63
    4f7a:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f7e:	86 e1       	ldi	r24, 0x16	; 22
    4f80:	62 e0       	ldi	r22, 0x02	; 2
    4f82:	43 e0       	ldi	r20, 0x03	; 3
    4f84:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        break;
    4f88:	16 c0       	rjmp	.+44     	; 0x4fb6 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4f8a:	8c e0       	ldi	r24, 0x0C	; 12
    4f8c:	6c e1       	ldi	r22, 0x1C	; 28
    4f8e:	4f e3       	ldi	r20, 0x3F	; 63
    4f90:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f94:	86 e1       	ldi	r24, 0x16	; 22
    4f96:	62 e0       	ldi	r22, 0x02	; 2
    4f98:	43 e0       	ldi	r20, 0x03	; 3
    4f9a:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        break;
    4f9e:	0b c0       	rjmp	.+22     	; 0x4fb6 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4fa0:	8c e0       	ldi	r24, 0x0C	; 12
    4fa2:	60 e0       	ldi	r22, 0x00	; 0
    4fa4:	4f e3       	ldi	r20, 0x3F	; 63
    4fa6:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4faa:	86 e1       	ldi	r24, 0x16	; 22
    4fac:	63 e0       	ldi	r22, 0x03	; 3
    4fae:	43 e0       	ldi	r20, 0x03	; 3
    4fb0:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
        break;
    4fb4:	00 00       	nop
    }
}
    4fb6:	0f 90       	pop	r0
    4fb8:	df 91       	pop	r29
    4fba:	cf 91       	pop	r28
    4fbc:	08 95       	ret

00004fbe <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4fbe:	0f 93       	push	r16
    4fc0:	1f 93       	push	r17
    4fc2:	cf 93       	push	r28
    4fc4:	df 93       	push	r29
    4fc6:	cd b7       	in	r28, 0x3d	; 61
    4fc8:	de b7       	in	r29, 0x3e	; 62
    4fca:	6a 97       	sbiw	r28, 0x1a	; 26
    4fcc:	cd bf       	out	0x3d, r28	; 61
    4fce:	de bf       	out	0x3e, r29	; 62
    4fd0:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4fd2:	88 e0       	ldi	r24, 0x08	; 8
    4fd4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4fd6:	4f e1       	ldi	r20, 0x1F	; 31
    4fd8:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4fdc:	0e 94 8d 23 	call	0x471a	; 0x471a <chb_get_state>
    4fe0:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4fe2:	89 81       	ldd	r24, Y+1	; 0x01
    4fe4:	86 30       	cpi	r24, 0x06	; 6
    4fe6:	21 f0       	breq	.+8      	; 0x4ff0 <chb_set_channel+0x32>
    4fe8:	89 81       	ldd	r24, Y+1	; 0x01
    4fea:	89 30       	cpi	r24, 0x09	; 9
    4fec:	09 f0       	breq	.+2      	; 0x4ff0 <chb_set_channel+0x32>
    4fee:	d5 c0       	rjmp	.+426    	; 0x519a <chb_set_channel+0x1dc>
    4ff0:	80 e0       	ldi	r24, 0x00	; 0
    4ff2:	90 e0       	ldi	r25, 0x00	; 0
    4ff4:	ac ed       	ldi	r26, 0xDC	; 220
    4ff6:	b2 e4       	ldi	r27, 0x42	; 66
    4ff8:	8a 83       	std	Y+2, r24	; 0x02
    4ffa:	9b 83       	std	Y+3, r25	; 0x03
    4ffc:	ac 83       	std	Y+4, r26	; 0x04
    4ffe:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5000:	6a 81       	ldd	r22, Y+2	; 0x02
    5002:	7b 81       	ldd	r23, Y+3	; 0x03
    5004:	8c 81       	ldd	r24, Y+4	; 0x04
    5006:	9d 81       	ldd	r25, Y+5	; 0x05
    5008:	2b ea       	ldi	r18, 0xAB	; 171
    500a:	3a ea       	ldi	r19, 0xAA	; 170
    500c:	4a ea       	ldi	r20, 0xAA	; 170
    500e:	5e e3       	ldi	r21, 0x3E	; 62
    5010:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5014:	dc 01       	movw	r26, r24
    5016:	cb 01       	movw	r24, r22
    5018:	8e 83       	std	Y+6, r24	; 0x06
    501a:	9f 83       	std	Y+7, r25	; 0x07
    501c:	a8 87       	std	Y+8, r26	; 0x08
    501e:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    5020:	11 e0       	ldi	r17, 0x01	; 1
    5022:	6e 81       	ldd	r22, Y+6	; 0x06
    5024:	7f 81       	ldd	r23, Y+7	; 0x07
    5026:	88 85       	ldd	r24, Y+8	; 0x08
    5028:	99 85       	ldd	r25, Y+9	; 0x09
    502a:	20 e0       	ldi	r18, 0x00	; 0
    502c:	30 e0       	ldi	r19, 0x00	; 0
    502e:	40 e8       	ldi	r20, 0x80	; 128
    5030:	5f e3       	ldi	r21, 0x3F	; 63
    5032:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    5036:	88 23       	and	r24, r24
    5038:	0c f0       	brlt	.+2      	; 0x503c <chb_set_channel+0x7e>
    503a:	10 e0       	ldi	r17, 0x00	; 0
    503c:	11 23       	and	r17, r17
    503e:	19 f0       	breq	.+6      	; 0x5046 <chb_set_channel+0x88>
		__ticks = 1;
    5040:	81 e0       	ldi	r24, 0x01	; 1
    5042:	8a 87       	std	Y+10, r24	; 0x0a
    5044:	a3 c0       	rjmp	.+326    	; 0x518c <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    5046:	11 e0       	ldi	r17, 0x01	; 1
    5048:	6e 81       	ldd	r22, Y+6	; 0x06
    504a:	7f 81       	ldd	r23, Y+7	; 0x07
    504c:	88 85       	ldd	r24, Y+8	; 0x08
    504e:	99 85       	ldd	r25, Y+9	; 0x09
    5050:	20 e0       	ldi	r18, 0x00	; 0
    5052:	30 e0       	ldi	r19, 0x00	; 0
    5054:	4f e7       	ldi	r20, 0x7F	; 127
    5056:	53 e4       	ldi	r21, 0x43	; 67
    5058:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    505c:	18 16       	cp	r1, r24
    505e:	0c f0       	brlt	.+2      	; 0x5062 <chb_set_channel+0xa4>
    5060:	10 e0       	ldi	r17, 0x00	; 0
    5062:	11 23       	and	r17, r17
    5064:	09 f4       	brne	.+2      	; 0x5068 <chb_set_channel+0xaa>
    5066:	89 c0       	rjmp	.+274    	; 0x517a <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    5068:	6a 81       	ldd	r22, Y+2	; 0x02
    506a:	7b 81       	ldd	r23, Y+3	; 0x03
    506c:	8c 81       	ldd	r24, Y+4	; 0x04
    506e:	9d 81       	ldd	r25, Y+5	; 0x05
    5070:	20 e0       	ldi	r18, 0x00	; 0
    5072:	30 e0       	ldi	r19, 0x00	; 0
    5074:	4a e7       	ldi	r20, 0x7A	; 122
    5076:	54 e4       	ldi	r21, 0x44	; 68
    5078:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    507c:	dc 01       	movw	r26, r24
    507e:	cb 01       	movw	r24, r22
    5080:	8b 87       	std	Y+11, r24	; 0x0b
    5082:	9c 87       	std	Y+12, r25	; 0x0c
    5084:	ad 87       	std	Y+13, r26	; 0x0d
    5086:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5088:	6b 85       	ldd	r22, Y+11	; 0x0b
    508a:	7c 85       	ldd	r23, Y+12	; 0x0c
    508c:	8d 85       	ldd	r24, Y+13	; 0x0d
    508e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5090:	20 e0       	ldi	r18, 0x00	; 0
    5092:	30 e0       	ldi	r19, 0x00	; 0
    5094:	4a e7       	ldi	r20, 0x7A	; 122
    5096:	53 e4       	ldi	r21, 0x43	; 67
    5098:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    509c:	dc 01       	movw	r26, r24
    509e:	cb 01       	movw	r24, r22
    50a0:	8f 87       	std	Y+15, r24	; 0x0f
    50a2:	98 8b       	std	Y+16, r25	; 0x10
    50a4:	a9 8b       	std	Y+17, r26	; 0x11
    50a6:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    50a8:	11 e0       	ldi	r17, 0x01	; 1
    50aa:	6f 85       	ldd	r22, Y+15	; 0x0f
    50ac:	78 89       	ldd	r23, Y+16	; 0x10
    50ae:	89 89       	ldd	r24, Y+17	; 0x11
    50b0:	9a 89       	ldd	r25, Y+18	; 0x12
    50b2:	20 e0       	ldi	r18, 0x00	; 0
    50b4:	30 e0       	ldi	r19, 0x00	; 0
    50b6:	40 e8       	ldi	r20, 0x80	; 128
    50b8:	5f e3       	ldi	r21, 0x3F	; 63
    50ba:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    50be:	88 23       	and	r24, r24
    50c0:	0c f0       	brlt	.+2      	; 0x50c4 <chb_set_channel+0x106>
    50c2:	10 e0       	ldi	r17, 0x00	; 0
    50c4:	11 23       	and	r17, r17
    50c6:	29 f0       	breq	.+10     	; 0x50d2 <chb_set_channel+0x114>
		__ticks = 1;
    50c8:	81 e0       	ldi	r24, 0x01	; 1
    50ca:	90 e0       	ldi	r25, 0x00	; 0
    50cc:	8b 8b       	std	Y+19, r24	; 0x13
    50ce:	9c 8b       	std	Y+20, r25	; 0x14
    50d0:	46 c0       	rjmp	.+140    	; 0x515e <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    50d2:	11 e0       	ldi	r17, 0x01	; 1
    50d4:	6f 85       	ldd	r22, Y+15	; 0x0f
    50d6:	78 89       	ldd	r23, Y+16	; 0x10
    50d8:	89 89       	ldd	r24, Y+17	; 0x11
    50da:	9a 89       	ldd	r25, Y+18	; 0x12
    50dc:	20 e0       	ldi	r18, 0x00	; 0
    50de:	3f ef       	ldi	r19, 0xFF	; 255
    50e0:	4f e7       	ldi	r20, 0x7F	; 127
    50e2:	57 e4       	ldi	r21, 0x47	; 71
    50e4:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    50e8:	18 16       	cp	r1, r24
    50ea:	0c f0       	brlt	.+2      	; 0x50ee <chb_set_channel+0x130>
    50ec:	10 e0       	ldi	r17, 0x00	; 0
    50ee:	11 23       	and	r17, r17
    50f0:	61 f1       	breq	.+88     	; 0x514a <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    50f2:	6b 85       	ldd	r22, Y+11	; 0x0b
    50f4:	7c 85       	ldd	r23, Y+12	; 0x0c
    50f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    50f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    50fa:	20 e0       	ldi	r18, 0x00	; 0
    50fc:	30 e0       	ldi	r19, 0x00	; 0
    50fe:	40 e2       	ldi	r20, 0x20	; 32
    5100:	51 e4       	ldi	r21, 0x41	; 65
    5102:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5106:	dc 01       	movw	r26, r24
    5108:	cb 01       	movw	r24, r22
    510a:	bc 01       	movw	r22, r24
    510c:	cd 01       	movw	r24, r26
    510e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5112:	dc 01       	movw	r26, r24
    5114:	cb 01       	movw	r24, r22
    5116:	8b 8b       	std	Y+19, r24	; 0x13
    5118:	9c 8b       	std	Y+20, r25	; 0x14
    511a:	12 c0       	rjmp	.+36     	; 0x5140 <chb_set_channel+0x182>
    511c:	89 e1       	ldi	r24, 0x19	; 25
    511e:	90 e0       	ldi	r25, 0x00	; 0
    5120:	8d 8b       	std	Y+21, r24	; 0x15
    5122:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5124:	8d 89       	ldd	r24, Y+21	; 0x15
    5126:	9e 89       	ldd	r25, Y+22	; 0x16
    5128:	8c 01       	movw	r16, r24
    512a:	c8 01       	movw	r24, r16
    512c:	01 97       	sbiw	r24, 0x01	; 1
    512e:	f1 f7       	brne	.-4      	; 0x512c <chb_set_channel+0x16e>
    5130:	8c 01       	movw	r16, r24
    5132:	0d 8b       	std	Y+21, r16	; 0x15
    5134:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5136:	8b 89       	ldd	r24, Y+19	; 0x13
    5138:	9c 89       	ldd	r25, Y+20	; 0x14
    513a:	01 97       	sbiw	r24, 0x01	; 1
    513c:	8b 8b       	std	Y+19, r24	; 0x13
    513e:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5140:	8b 89       	ldd	r24, Y+19	; 0x13
    5142:	9c 89       	ldd	r25, Y+20	; 0x14
    5144:	00 97       	sbiw	r24, 0x00	; 0
    5146:	51 f7       	brne	.-44     	; 0x511c <chb_set_channel+0x15e>
    5148:	28 c0       	rjmp	.+80     	; 0x519a <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    514a:	6f 85       	ldd	r22, Y+15	; 0x0f
    514c:	78 89       	ldd	r23, Y+16	; 0x10
    514e:	89 89       	ldd	r24, Y+17	; 0x11
    5150:	9a 89       	ldd	r25, Y+18	; 0x12
    5152:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5156:	dc 01       	movw	r26, r24
    5158:	cb 01       	movw	r24, r22
    515a:	8b 8b       	std	Y+19, r24	; 0x13
    515c:	9c 8b       	std	Y+20, r25	; 0x14
    515e:	8b 89       	ldd	r24, Y+19	; 0x13
    5160:	9c 89       	ldd	r25, Y+20	; 0x14
    5162:	8f 8b       	std	Y+23, r24	; 0x17
    5164:	98 8f       	std	Y+24, r25	; 0x18
    5166:	8f 89       	ldd	r24, Y+23	; 0x17
    5168:	98 8d       	ldd	r25, Y+24	; 0x18
    516a:	8c 01       	movw	r16, r24
    516c:	c8 01       	movw	r24, r16
    516e:	01 97       	sbiw	r24, 0x01	; 1
    5170:	f1 f7       	brne	.-4      	; 0x516e <chb_set_channel+0x1b0>
    5172:	8c 01       	movw	r16, r24
    5174:	0f 8b       	std	Y+23, r16	; 0x17
    5176:	18 8f       	std	Y+24, r17	; 0x18
    5178:	10 c0       	rjmp	.+32     	; 0x519a <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    517a:	6e 81       	ldd	r22, Y+6	; 0x06
    517c:	7f 81       	ldd	r23, Y+7	; 0x07
    517e:	88 85       	ldd	r24, Y+8	; 0x08
    5180:	99 85       	ldd	r25, Y+9	; 0x09
    5182:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5186:	dc 01       	movw	r26, r24
    5188:	cb 01       	movw	r24, r22
    518a:	8a 87       	std	Y+10, r24	; 0x0a
    518c:	8a 85       	ldd	r24, Y+10	; 0x0a
    518e:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5190:	89 8d       	ldd	r24, Y+25	; 0x19
    5192:	18 2f       	mov	r17, r24
    5194:	1a 95       	dec	r17
    5196:	f1 f7       	brne	.-4      	; 0x5194 <chb_set_channel+0x1d6>
    5198:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    519a:	88 e0       	ldi	r24, 0x08	; 8
    519c:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    51a0:	88 2f       	mov	r24, r24
    51a2:	90 e0       	ldi	r25, 0x00	; 0
    51a4:	9c 01       	movw	r18, r24
    51a6:	2f 71       	andi	r18, 0x1F	; 31
    51a8:	30 70       	andi	r19, 0x00	; 0
    51aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    51ac:	88 2f       	mov	r24, r24
    51ae:	90 e0       	ldi	r25, 0x00	; 0
    51b0:	28 17       	cp	r18, r24
    51b2:	39 07       	cpc	r19, r25
    51b4:	11 f4       	brne	.+4      	; 0x51ba <chb_set_channel+0x1fc>
    51b6:	80 e4       	ldi	r24, 0x40	; 64
    51b8:	01 c0       	rjmp	.+2      	; 0x51bc <chb_set_channel+0x1fe>
    51ba:	83 e4       	ldi	r24, 0x43	; 67
}
    51bc:	6a 96       	adiw	r28, 0x1a	; 26
    51be:	cd bf       	out	0x3d, r28	; 61
    51c0:	de bf       	out	0x3e, r29	; 62
    51c2:	df 91       	pop	r29
    51c4:	cf 91       	pop	r28
    51c6:	1f 91       	pop	r17
    51c8:	0f 91       	pop	r16
    51ca:	08 95       	ret

000051cc <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    51cc:	cf 93       	push	r28
    51ce:	df 93       	push	r29
    51d0:	0f 92       	push	r0
    51d2:	cd b7       	in	r28, 0x3d	; 61
    51d4:	de b7       	in	r29, 0x3e	; 62
    51d6:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    51d8:	85 e0       	ldi	r24, 0x05	; 5
    51da:	69 81       	ldd	r22, Y+1	; 0x01
    51dc:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <chb_reg_write>
}
    51e0:	0f 90       	pop	r0
    51e2:	df 91       	pop	r29
    51e4:	cf 91       	pop	r28
    51e6:	08 95       	ret

000051e8 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    51e8:	0f 93       	push	r16
    51ea:	1f 93       	push	r17
    51ec:	cf 93       	push	r28
    51ee:	df 93       	push	r29
    51f0:	cd b7       	in	r28, 0x3d	; 61
    51f2:	de b7       	in	r29, 0x3e	; 62
    51f4:	c2 56       	subi	r28, 0x62	; 98
    51f6:	d0 40       	sbci	r29, 0x00	; 0
    51f8:	cd bf       	out	0x3d, r28	; 61
    51fa:	de bf       	out	0x3e, r29	; 62
    51fc:	9e 01       	movw	r18, r28
    51fe:	2e 59       	subi	r18, 0x9E	; 158
    5200:	3f 4f       	sbci	r19, 0xFF	; 255
    5202:	f9 01       	movw	r30, r18
    5204:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    5206:	84 e6       	ldi	r24, 0x64	; 100
    5208:	96 e0       	ldi	r25, 0x06	; 6
    520a:	fc 01       	movw	r30, r24
    520c:	80 81       	ld	r24, Z
    520e:	88 2f       	mov	r24, r24
    5210:	90 e0       	ldi	r25, 0x00	; 0
    5212:	82 70       	andi	r24, 0x02	; 2
    5214:	90 70       	andi	r25, 0x00	; 0
    5216:	00 97       	sbiw	r24, 0x00	; 0
    5218:	11 f0       	breq	.+4      	; 0x521e <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    521a:	84 e4       	ldi	r24, 0x44	; 68
    521c:	91 c4       	rjmp	.+2338   	; 0x5b40 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    521e:	0e 94 8d 23 	call	0x471a	; 0x471a <chb_get_state>
    5222:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    5224:	89 81       	ldd	r24, Y+1	; 0x01
    5226:	82 31       	cpi	r24, 0x12	; 18
    5228:	49 f0       	breq	.+18     	; 0x523c <chb_set_state+0x54>
    522a:	89 81       	ldd	r24, Y+1	; 0x01
    522c:	81 31       	cpi	r24, 0x11	; 17
    522e:	31 f0       	breq	.+12     	; 0x523c <chb_set_state+0x54>
    5230:	89 81       	ldd	r24, Y+1	; 0x01
    5232:	81 30       	cpi	r24, 0x01	; 1
    5234:	19 f0       	breq	.+6      	; 0x523c <chb_set_state+0x54>
    5236:	89 81       	ldd	r24, Y+1	; 0x01
    5238:	82 30       	cpi	r24, 0x02	; 2
    523a:	39 f4       	brne	.+14     	; 0x524a <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    523c:	00 00       	nop
    523e:	0e 94 8d 23 	call	0x471a	; 0x471a <chb_get_state>
    5242:	98 2f       	mov	r25, r24
    5244:	89 81       	ldd	r24, Y+1	; 0x01
    5246:	98 17       	cp	r25, r24
    5248:	d1 f3       	breq	.-12     	; 0x523e <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    524a:	ce 01       	movw	r24, r28
    524c:	8e 59       	subi	r24, 0x9E	; 158
    524e:	9f 4f       	sbci	r25, 0xFF	; 255
    5250:	fc 01       	movw	r30, r24
    5252:	80 81       	ld	r24, Z
    5254:	88 2f       	mov	r24, r24
    5256:	90 e0       	ldi	r25, 0x00	; 0
    5258:	86 31       	cpi	r24, 0x16	; 22
    525a:	91 05       	cpc	r25, r1
    525c:	09 f4       	brne	.+2      	; 0x5260 <chb_set_state+0x78>
    525e:	cd c1       	rjmp	.+922    	; 0x55fa <chb_set_state+0x412>
    5260:	89 31       	cpi	r24, 0x19	; 25
    5262:	91 05       	cpc	r25, r1
    5264:	09 f4       	brne	.+2      	; 0x5268 <chb_set_state+0x80>
    5266:	e9 c0       	rjmp	.+466    	; 0x543a <chb_set_state+0x252>
    5268:	88 30       	cpi	r24, 0x08	; 8
    526a:	91 05       	cpc	r25, r1
    526c:	09 f0       	breq	.+2      	; 0x5270 <chb_set_state+0x88>
    526e:	f7 c2       	rjmp	.+1518   	; 0x585e <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    5270:	84 e6       	ldi	r24, 0x64	; 100
    5272:	96 e0       	ldi	r25, 0x06	; 6
    5274:	24 e6       	ldi	r18, 0x64	; 100
    5276:	36 e0       	ldi	r19, 0x06	; 6
    5278:	f9 01       	movw	r30, r18
    527a:	20 81       	ld	r18, Z
    527c:	2d 7f       	andi	r18, 0xFD	; 253
    527e:	fc 01       	movw	r30, r24
    5280:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    5282:	82 e0       	ldi	r24, 0x02	; 2
    5284:	63 e0       	ldi	r22, 0x03	; 3
    5286:	4f e1       	ldi	r20, 0x1F	; 31
    5288:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
    528c:	80 e0       	ldi	r24, 0x00	; 0
    528e:	90 e0       	ldi	r25, 0x00	; 0
    5290:	a0 e8       	ldi	r26, 0x80	; 128
    5292:	bf e3       	ldi	r27, 0x3F	; 63
    5294:	8a 83       	std	Y+2, r24	; 0x02
    5296:	9b 83       	std	Y+3, r25	; 0x03
    5298:	ac 83       	std	Y+4, r26	; 0x04
    529a:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    529c:	6a 81       	ldd	r22, Y+2	; 0x02
    529e:	7b 81       	ldd	r23, Y+3	; 0x03
    52a0:	8c 81       	ldd	r24, Y+4	; 0x04
    52a2:	9d 81       	ldd	r25, Y+5	; 0x05
    52a4:	2b ea       	ldi	r18, 0xAB	; 171
    52a6:	3a ea       	ldi	r19, 0xAA	; 170
    52a8:	4a ea       	ldi	r20, 0xAA	; 170
    52aa:	5e e3       	ldi	r21, 0x3E	; 62
    52ac:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    52b0:	dc 01       	movw	r26, r24
    52b2:	cb 01       	movw	r24, r22
    52b4:	8e 83       	std	Y+6, r24	; 0x06
    52b6:	9f 83       	std	Y+7, r25	; 0x07
    52b8:	a8 87       	std	Y+8, r26	; 0x08
    52ba:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    52bc:	11 e0       	ldi	r17, 0x01	; 1
    52be:	6e 81       	ldd	r22, Y+6	; 0x06
    52c0:	7f 81       	ldd	r23, Y+7	; 0x07
    52c2:	88 85       	ldd	r24, Y+8	; 0x08
    52c4:	99 85       	ldd	r25, Y+9	; 0x09
    52c6:	20 e0       	ldi	r18, 0x00	; 0
    52c8:	30 e0       	ldi	r19, 0x00	; 0
    52ca:	40 e8       	ldi	r20, 0x80	; 128
    52cc:	5f e3       	ldi	r21, 0x3F	; 63
    52ce:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    52d2:	88 23       	and	r24, r24
    52d4:	0c f0       	brlt	.+2      	; 0x52d8 <chb_set_state+0xf0>
    52d6:	10 e0       	ldi	r17, 0x00	; 0
    52d8:	11 23       	and	r17, r17
    52da:	19 f0       	breq	.+6      	; 0x52e2 <chb_set_state+0xfa>
		__ticks = 1;
    52dc:	81 e0       	ldi	r24, 0x01	; 1
    52de:	8a 87       	std	Y+10, r24	; 0x0a
    52e0:	a3 c0       	rjmp	.+326    	; 0x5428 <chb_set_state+0x240>
	else if (__tmp > 255)
    52e2:	11 e0       	ldi	r17, 0x01	; 1
    52e4:	6e 81       	ldd	r22, Y+6	; 0x06
    52e6:	7f 81       	ldd	r23, Y+7	; 0x07
    52e8:	88 85       	ldd	r24, Y+8	; 0x08
    52ea:	99 85       	ldd	r25, Y+9	; 0x09
    52ec:	20 e0       	ldi	r18, 0x00	; 0
    52ee:	30 e0       	ldi	r19, 0x00	; 0
    52f0:	4f e7       	ldi	r20, 0x7F	; 127
    52f2:	53 e4       	ldi	r21, 0x43	; 67
    52f4:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    52f8:	18 16       	cp	r1, r24
    52fa:	0c f0       	brlt	.+2      	; 0x52fe <chb_set_state+0x116>
    52fc:	10 e0       	ldi	r17, 0x00	; 0
    52fe:	11 23       	and	r17, r17
    5300:	09 f4       	brne	.+2      	; 0x5304 <chb_set_state+0x11c>
    5302:	89 c0       	rjmp	.+274    	; 0x5416 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    5304:	6a 81       	ldd	r22, Y+2	; 0x02
    5306:	7b 81       	ldd	r23, Y+3	; 0x03
    5308:	8c 81       	ldd	r24, Y+4	; 0x04
    530a:	9d 81       	ldd	r25, Y+5	; 0x05
    530c:	20 e0       	ldi	r18, 0x00	; 0
    530e:	30 e0       	ldi	r19, 0x00	; 0
    5310:	4a e7       	ldi	r20, 0x7A	; 122
    5312:	54 e4       	ldi	r21, 0x44	; 68
    5314:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    5318:	dc 01       	movw	r26, r24
    531a:	cb 01       	movw	r24, r22
    531c:	8b 87       	std	Y+11, r24	; 0x0b
    531e:	9c 87       	std	Y+12, r25	; 0x0c
    5320:	ad 87       	std	Y+13, r26	; 0x0d
    5322:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5324:	6b 85       	ldd	r22, Y+11	; 0x0b
    5326:	7c 85       	ldd	r23, Y+12	; 0x0c
    5328:	8d 85       	ldd	r24, Y+13	; 0x0d
    532a:	9e 85       	ldd	r25, Y+14	; 0x0e
    532c:	20 e0       	ldi	r18, 0x00	; 0
    532e:	30 e0       	ldi	r19, 0x00	; 0
    5330:	4a e7       	ldi	r20, 0x7A	; 122
    5332:	53 e4       	ldi	r21, 0x43	; 67
    5334:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5338:	dc 01       	movw	r26, r24
    533a:	cb 01       	movw	r24, r22
    533c:	8f 87       	std	Y+15, r24	; 0x0f
    533e:	98 8b       	std	Y+16, r25	; 0x10
    5340:	a9 8b       	std	Y+17, r26	; 0x11
    5342:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    5344:	11 e0       	ldi	r17, 0x01	; 1
    5346:	6f 85       	ldd	r22, Y+15	; 0x0f
    5348:	78 89       	ldd	r23, Y+16	; 0x10
    534a:	89 89       	ldd	r24, Y+17	; 0x11
    534c:	9a 89       	ldd	r25, Y+18	; 0x12
    534e:	20 e0       	ldi	r18, 0x00	; 0
    5350:	30 e0       	ldi	r19, 0x00	; 0
    5352:	40 e8       	ldi	r20, 0x80	; 128
    5354:	5f e3       	ldi	r21, 0x3F	; 63
    5356:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    535a:	88 23       	and	r24, r24
    535c:	0c f0       	brlt	.+2      	; 0x5360 <chb_set_state+0x178>
    535e:	10 e0       	ldi	r17, 0x00	; 0
    5360:	11 23       	and	r17, r17
    5362:	29 f0       	breq	.+10     	; 0x536e <chb_set_state+0x186>
		__ticks = 1;
    5364:	81 e0       	ldi	r24, 0x01	; 1
    5366:	90 e0       	ldi	r25, 0x00	; 0
    5368:	8b 8b       	std	Y+19, r24	; 0x13
    536a:	9c 8b       	std	Y+20, r25	; 0x14
    536c:	46 c0       	rjmp	.+140    	; 0x53fa <chb_set_state+0x212>
	else if (__tmp > 65535)
    536e:	11 e0       	ldi	r17, 0x01	; 1
    5370:	6f 85       	ldd	r22, Y+15	; 0x0f
    5372:	78 89       	ldd	r23, Y+16	; 0x10
    5374:	89 89       	ldd	r24, Y+17	; 0x11
    5376:	9a 89       	ldd	r25, Y+18	; 0x12
    5378:	20 e0       	ldi	r18, 0x00	; 0
    537a:	3f ef       	ldi	r19, 0xFF	; 255
    537c:	4f e7       	ldi	r20, 0x7F	; 127
    537e:	57 e4       	ldi	r21, 0x47	; 71
    5380:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    5384:	18 16       	cp	r1, r24
    5386:	0c f0       	brlt	.+2      	; 0x538a <chb_set_state+0x1a2>
    5388:	10 e0       	ldi	r17, 0x00	; 0
    538a:	11 23       	and	r17, r17
    538c:	61 f1       	breq	.+88     	; 0x53e6 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    538e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5390:	7c 85       	ldd	r23, Y+12	; 0x0c
    5392:	8d 85       	ldd	r24, Y+13	; 0x0d
    5394:	9e 85       	ldd	r25, Y+14	; 0x0e
    5396:	20 e0       	ldi	r18, 0x00	; 0
    5398:	30 e0       	ldi	r19, 0x00	; 0
    539a:	40 e2       	ldi	r20, 0x20	; 32
    539c:	51 e4       	ldi	r21, 0x41	; 65
    539e:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    53a2:	dc 01       	movw	r26, r24
    53a4:	cb 01       	movw	r24, r22
    53a6:	bc 01       	movw	r22, r24
    53a8:	cd 01       	movw	r24, r26
    53aa:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    53ae:	dc 01       	movw	r26, r24
    53b0:	cb 01       	movw	r24, r22
    53b2:	8b 8b       	std	Y+19, r24	; 0x13
    53b4:	9c 8b       	std	Y+20, r25	; 0x14
    53b6:	12 c0       	rjmp	.+36     	; 0x53dc <chb_set_state+0x1f4>
    53b8:	89 e1       	ldi	r24, 0x19	; 25
    53ba:	90 e0       	ldi	r25, 0x00	; 0
    53bc:	8d 8b       	std	Y+21, r24	; 0x15
    53be:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    53c0:	8d 89       	ldd	r24, Y+21	; 0x15
    53c2:	9e 89       	ldd	r25, Y+22	; 0x16
    53c4:	8c 01       	movw	r16, r24
    53c6:	c8 01       	movw	r24, r16
    53c8:	01 97       	sbiw	r24, 0x01	; 1
    53ca:	f1 f7       	brne	.-4      	; 0x53c8 <chb_set_state+0x1e0>
    53cc:	8c 01       	movw	r16, r24
    53ce:	0d 8b       	std	Y+21, r16	; 0x15
    53d0:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53d2:	8b 89       	ldd	r24, Y+19	; 0x13
    53d4:	9c 89       	ldd	r25, Y+20	; 0x14
    53d6:	01 97       	sbiw	r24, 0x01	; 1
    53d8:	8b 8b       	std	Y+19, r24	; 0x13
    53da:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53dc:	8b 89       	ldd	r24, Y+19	; 0x13
    53de:	9c 89       	ldd	r25, Y+20	; 0x14
    53e0:	00 97       	sbiw	r24, 0x00	; 0
    53e2:	51 f7       	brne	.-44     	; 0x53b8 <chb_set_state+0x1d0>
    53e4:	29 c0       	rjmp	.+82     	; 0x5438 <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53e6:	6f 85       	ldd	r22, Y+15	; 0x0f
    53e8:	78 89       	ldd	r23, Y+16	; 0x10
    53ea:	89 89       	ldd	r24, Y+17	; 0x11
    53ec:	9a 89       	ldd	r25, Y+18	; 0x12
    53ee:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    53f2:	dc 01       	movw	r26, r24
    53f4:	cb 01       	movw	r24, r22
    53f6:	8b 8b       	std	Y+19, r24	; 0x13
    53f8:	9c 8b       	std	Y+20, r25	; 0x14
    53fa:	8b 89       	ldd	r24, Y+19	; 0x13
    53fc:	9c 89       	ldd	r25, Y+20	; 0x14
    53fe:	8f 8b       	std	Y+23, r24	; 0x17
    5400:	98 8f       	std	Y+24, r25	; 0x18
    5402:	8f 89       	ldd	r24, Y+23	; 0x17
    5404:	98 8d       	ldd	r25, Y+24	; 0x18
    5406:	8c 01       	movw	r16, r24
    5408:	f8 01       	movw	r30, r16
    540a:	31 97       	sbiw	r30, 0x01	; 1
    540c:	f1 f7       	brne	.-4      	; 0x540a <chb_set_state+0x222>
    540e:	8f 01       	movw	r16, r30
    5410:	0f 8b       	std	Y+23, r16	; 0x17
    5412:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    5414:	24 c2       	rjmp	.+1096   	; 0x585e <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5416:	6e 81       	ldd	r22, Y+6	; 0x06
    5418:	7f 81       	ldd	r23, Y+7	; 0x07
    541a:	88 85       	ldd	r24, Y+8	; 0x08
    541c:	99 85       	ldd	r25, Y+9	; 0x09
    541e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5422:	dc 01       	movw	r26, r24
    5424:	cb 01       	movw	r24, r22
    5426:	8a 87       	std	Y+10, r24	; 0x0a
    5428:	8a 85       	ldd	r24, Y+10	; 0x0a
    542a:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    542c:	89 8d       	ldd	r24, Y+25	; 0x19
    542e:	18 2f       	mov	r17, r24
    5430:	1a 95       	dec	r17
    5432:	f1 f7       	brne	.-4      	; 0x5430 <chb_set_state+0x248>
    5434:	19 8f       	std	Y+25, r17	; 0x19
    5436:	13 c2       	rjmp	.+1062   	; 0x585e <chb_set_state+0x676>
    5438:	12 c2       	rjmp	.+1060   	; 0x585e <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    543a:	89 81       	ldd	r24, Y+1	; 0x01
    543c:	86 31       	cpi	r24, 0x16	; 22
    543e:	09 f0       	breq	.+2      	; 0x5442 <chb_set_state+0x25a>
    5440:	0b c2       	rjmp	.+1046   	; 0x5858 <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5442:	82 e0       	ldi	r24, 0x02	; 2
    5444:	69 e0       	ldi	r22, 0x09	; 9
    5446:	4f e1       	ldi	r20, 0x1F	; 31
    5448:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
    544c:	80 e0       	ldi	r24, 0x00	; 0
    544e:	90 e0       	ldi	r25, 0x00	; 0
    5450:	a0 e8       	ldi	r26, 0x80	; 128
    5452:	bf e3       	ldi	r27, 0x3F	; 63
    5454:	8a 8f       	std	Y+26, r24	; 0x1a
    5456:	9b 8f       	std	Y+27, r25	; 0x1b
    5458:	ac 8f       	std	Y+28, r26	; 0x1c
    545a:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    545c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    545e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5460:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5462:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5464:	2b ea       	ldi	r18, 0xAB	; 171
    5466:	3a ea       	ldi	r19, 0xAA	; 170
    5468:	4a ea       	ldi	r20, 0xAA	; 170
    546a:	5e e3       	ldi	r21, 0x3E	; 62
    546c:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5470:	dc 01       	movw	r26, r24
    5472:	cb 01       	movw	r24, r22
    5474:	8e 8f       	std	Y+30, r24	; 0x1e
    5476:	9f 8f       	std	Y+31, r25	; 0x1f
    5478:	a8 a3       	lds	r26, 0x58
    547a:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    547c:	11 e0       	ldi	r17, 0x01	; 1
    547e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5480:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5482:	88 a1       	lds	r24, 0x48
    5484:	99 a1       	lds	r25, 0x49
    5486:	20 e0       	ldi	r18, 0x00	; 0
    5488:	30 e0       	ldi	r19, 0x00	; 0
    548a:	40 e8       	ldi	r20, 0x80	; 128
    548c:	5f e3       	ldi	r21, 0x3F	; 63
    548e:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    5492:	88 23       	and	r24, r24
    5494:	0c f0       	brlt	.+2      	; 0x5498 <chb_set_state+0x2b0>
    5496:	10 e0       	ldi	r17, 0x00	; 0
    5498:	11 23       	and	r17, r17
    549a:	19 f0       	breq	.+6      	; 0x54a2 <chb_set_state+0x2ba>
		__ticks = 1;
    549c:	81 e0       	ldi	r24, 0x01	; 1
    549e:	8a a3       	lds	r24, 0x5a
    54a0:	a3 c0       	rjmp	.+326    	; 0x55e8 <chb_set_state+0x400>
	else if (__tmp > 255)
    54a2:	11 e0       	ldi	r17, 0x01	; 1
    54a4:	6e 8d       	ldd	r22, Y+30	; 0x1e
    54a6:	7f 8d       	ldd	r23, Y+31	; 0x1f
    54a8:	88 a1       	lds	r24, 0x48
    54aa:	99 a1       	lds	r25, 0x49
    54ac:	20 e0       	ldi	r18, 0x00	; 0
    54ae:	30 e0       	ldi	r19, 0x00	; 0
    54b0:	4f e7       	ldi	r20, 0x7F	; 127
    54b2:	53 e4       	ldi	r21, 0x43	; 67
    54b4:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    54b8:	18 16       	cp	r1, r24
    54ba:	0c f0       	brlt	.+2      	; 0x54be <chb_set_state+0x2d6>
    54bc:	10 e0       	ldi	r17, 0x00	; 0
    54be:	11 23       	and	r17, r17
    54c0:	09 f4       	brne	.+2      	; 0x54c4 <chb_set_state+0x2dc>
    54c2:	89 c0       	rjmp	.+274    	; 0x55d6 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    54c4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    54c6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    54c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    54ca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    54cc:	20 e0       	ldi	r18, 0x00	; 0
    54ce:	30 e0       	ldi	r19, 0x00	; 0
    54d0:	4a e7       	ldi	r20, 0x7A	; 122
    54d2:	54 e4       	ldi	r21, 0x44	; 68
    54d4:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    54d8:	dc 01       	movw	r26, r24
    54da:	cb 01       	movw	r24, r22
    54dc:	8b a3       	lds	r24, 0x5b
    54de:	9c a3       	lds	r25, 0x5c
    54e0:	ad a3       	lds	r26, 0x5d
    54e2:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    54e4:	6b a1       	lds	r22, 0x4b
    54e6:	7c a1       	lds	r23, 0x4c
    54e8:	8d a1       	lds	r24, 0x4d
    54ea:	9e a1       	lds	r25, 0x4e
    54ec:	20 e0       	ldi	r18, 0x00	; 0
    54ee:	30 e0       	ldi	r19, 0x00	; 0
    54f0:	4a e7       	ldi	r20, 0x7A	; 122
    54f2:	53 e4       	ldi	r21, 0x43	; 67
    54f4:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    54f8:	dc 01       	movw	r26, r24
    54fa:	cb 01       	movw	r24, r22
    54fc:	8f a3       	lds	r24, 0x5f
    54fe:	98 a7       	lds	r25, 0x78
    5500:	a9 a7       	lds	r26, 0x79
    5502:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    5504:	11 e0       	ldi	r17, 0x01	; 1
    5506:	6f a1       	lds	r22, 0x4f
    5508:	78 a5       	lds	r23, 0x68
    550a:	89 a5       	lds	r24, 0x69
    550c:	9a a5       	lds	r25, 0x6a
    550e:	20 e0       	ldi	r18, 0x00	; 0
    5510:	30 e0       	ldi	r19, 0x00	; 0
    5512:	40 e8       	ldi	r20, 0x80	; 128
    5514:	5f e3       	ldi	r21, 0x3F	; 63
    5516:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    551a:	88 23       	and	r24, r24
    551c:	0c f0       	brlt	.+2      	; 0x5520 <chb_set_state+0x338>
    551e:	10 e0       	ldi	r17, 0x00	; 0
    5520:	11 23       	and	r17, r17
    5522:	29 f0       	breq	.+10     	; 0x552e <chb_set_state+0x346>
		__ticks = 1;
    5524:	81 e0       	ldi	r24, 0x01	; 1
    5526:	90 e0       	ldi	r25, 0x00	; 0
    5528:	8b a7       	lds	r24, 0x7b
    552a:	9c a7       	lds	r25, 0x7c
    552c:	46 c0       	rjmp	.+140    	; 0x55ba <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    552e:	11 e0       	ldi	r17, 0x01	; 1
    5530:	6f a1       	lds	r22, 0x4f
    5532:	78 a5       	lds	r23, 0x68
    5534:	89 a5       	lds	r24, 0x69
    5536:	9a a5       	lds	r25, 0x6a
    5538:	20 e0       	ldi	r18, 0x00	; 0
    553a:	3f ef       	ldi	r19, 0xFF	; 255
    553c:	4f e7       	ldi	r20, 0x7F	; 127
    553e:	57 e4       	ldi	r21, 0x47	; 71
    5540:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    5544:	18 16       	cp	r1, r24
    5546:	0c f0       	brlt	.+2      	; 0x554a <chb_set_state+0x362>
    5548:	10 e0       	ldi	r17, 0x00	; 0
    554a:	11 23       	and	r17, r17
    554c:	61 f1       	breq	.+88     	; 0x55a6 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    554e:	6b a1       	lds	r22, 0x4b
    5550:	7c a1       	lds	r23, 0x4c
    5552:	8d a1       	lds	r24, 0x4d
    5554:	9e a1       	lds	r25, 0x4e
    5556:	20 e0       	ldi	r18, 0x00	; 0
    5558:	30 e0       	ldi	r19, 0x00	; 0
    555a:	40 e2       	ldi	r20, 0x20	; 32
    555c:	51 e4       	ldi	r21, 0x41	; 65
    555e:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5562:	dc 01       	movw	r26, r24
    5564:	cb 01       	movw	r24, r22
    5566:	bc 01       	movw	r22, r24
    5568:	cd 01       	movw	r24, r26
    556a:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    556e:	dc 01       	movw	r26, r24
    5570:	cb 01       	movw	r24, r22
    5572:	8b a7       	lds	r24, 0x7b
    5574:	9c a7       	lds	r25, 0x7c
    5576:	12 c0       	rjmp	.+36     	; 0x559c <chb_set_state+0x3b4>
    5578:	89 e1       	ldi	r24, 0x19	; 25
    557a:	90 e0       	ldi	r25, 0x00	; 0
    557c:	8d a7       	lds	r24, 0x7d
    557e:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5580:	8d a5       	lds	r24, 0x6d
    5582:	9e a5       	lds	r25, 0x6e
    5584:	8c 01       	movw	r16, r24
    5586:	c8 01       	movw	r24, r16
    5588:	01 97       	sbiw	r24, 0x01	; 1
    558a:	f1 f7       	brne	.-4      	; 0x5588 <chb_set_state+0x3a0>
    558c:	8c 01       	movw	r16, r24
    558e:	0d a7       	lds	r16, 0x7d
    5590:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5592:	8b a5       	lds	r24, 0x6b
    5594:	9c a5       	lds	r25, 0x6c
    5596:	01 97       	sbiw	r24, 0x01	; 1
    5598:	8b a7       	lds	r24, 0x7b
    559a:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    559c:	8b a5       	lds	r24, 0x6b
    559e:	9c a5       	lds	r25, 0x6c
    55a0:	00 97       	sbiw	r24, 0x00	; 0
    55a2:	51 f7       	brne	.-44     	; 0x5578 <chb_set_state+0x390>
    55a4:	29 c0       	rjmp	.+82     	; 0x55f8 <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    55a6:	6f a1       	lds	r22, 0x4f
    55a8:	78 a5       	lds	r23, 0x68
    55aa:	89 a5       	lds	r24, 0x69
    55ac:	9a a5       	lds	r25, 0x6a
    55ae:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    55b2:	dc 01       	movw	r26, r24
    55b4:	cb 01       	movw	r24, r22
    55b6:	8b a7       	lds	r24, 0x7b
    55b8:	9c a7       	lds	r25, 0x7c
    55ba:	8b a5       	lds	r24, 0x6b
    55bc:	9c a5       	lds	r25, 0x6c
    55be:	8f a7       	lds	r24, 0x7f
    55c0:	98 ab       	sts	0x58, r25
    55c2:	8f a5       	lds	r24, 0x6f
    55c4:	98 a9       	sts	0x48, r25
    55c6:	8c 01       	movw	r16, r24
    55c8:	f8 01       	movw	r30, r16
    55ca:	31 97       	sbiw	r30, 0x01	; 1
    55cc:	f1 f7       	brne	.-4      	; 0x55ca <chb_set_state+0x3e2>
    55ce:	8f 01       	movw	r16, r30
    55d0:	0f a7       	lds	r16, 0x7f
    55d2:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    55d4:	41 c1       	rjmp	.+642    	; 0x5858 <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    55d6:	6e 8d       	ldd	r22, Y+30	; 0x1e
    55d8:	7f 8d       	ldd	r23, Y+31	; 0x1f
    55da:	88 a1       	lds	r24, 0x48
    55dc:	99 a1       	lds	r25, 0x49
    55de:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    55e2:	dc 01       	movw	r26, r24
    55e4:	cb 01       	movw	r24, r22
    55e6:	8a a3       	lds	r24, 0x5a
    55e8:	8a a1       	lds	r24, 0x4a
    55ea:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55ec:	89 a9       	sts	0x49, r24
    55ee:	18 2f       	mov	r17, r24
    55f0:	1a 95       	dec	r17
    55f2:	f1 f7       	brne	.-4      	; 0x55f0 <chb_set_state+0x408>
    55f4:	19 ab       	sts	0x59, r17
    55f6:	30 c1       	rjmp	.+608    	; 0x5858 <chb_set_state+0x670>
    55f8:	2f c1       	rjmp	.+606    	; 0x5858 <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    55fa:	89 81       	ldd	r24, Y+1	; 0x01
    55fc:	89 31       	cpi	r24, 0x19	; 25
    55fe:	09 f0       	breq	.+2      	; 0x5602 <chb_set_state+0x41a>
    5600:	2d c1       	rjmp	.+602    	; 0x585c <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5602:	82 e0       	ldi	r24, 0x02	; 2
    5604:	69 e0       	ldi	r22, 0x09	; 9
    5606:	4f e1       	ldi	r20, 0x1F	; 31
    5608:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
    560c:	80 e0       	ldi	r24, 0x00	; 0
    560e:	90 e0       	ldi	r25, 0x00	; 0
    5610:	a0 e8       	ldi	r26, 0x80	; 128
    5612:	bf e3       	ldi	r27, 0x3F	; 63
    5614:	8a ab       	sts	0x5a, r24
    5616:	9b ab       	sts	0x5b, r25
    5618:	ac ab       	sts	0x5c, r26
    561a:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    561c:	6a a9       	sts	0x4a, r22
    561e:	7b a9       	sts	0x4b, r23
    5620:	8c a9       	sts	0x4c, r24
    5622:	9d a9       	sts	0x4d, r25
    5624:	2b ea       	ldi	r18, 0xAB	; 171
    5626:	3a ea       	ldi	r19, 0xAA	; 170
    5628:	4a ea       	ldi	r20, 0xAA	; 170
    562a:	5e e3       	ldi	r21, 0x3E	; 62
    562c:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5630:	dc 01       	movw	r26, r24
    5632:	cb 01       	movw	r24, r22
    5634:	8e ab       	sts	0x5e, r24
    5636:	9f ab       	sts	0x5f, r25
    5638:	a8 af       	sts	0x78, r26
    563a:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    563c:	11 e0       	ldi	r17, 0x01	; 1
    563e:	6e a9       	sts	0x4e, r22
    5640:	7f a9       	sts	0x4f, r23
    5642:	88 ad       	sts	0x68, r24
    5644:	99 ad       	sts	0x69, r25
    5646:	20 e0       	ldi	r18, 0x00	; 0
    5648:	30 e0       	ldi	r19, 0x00	; 0
    564a:	40 e8       	ldi	r20, 0x80	; 128
    564c:	5f e3       	ldi	r21, 0x3F	; 63
    564e:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    5652:	88 23       	and	r24, r24
    5654:	0c f0       	brlt	.+2      	; 0x5658 <chb_set_state+0x470>
    5656:	10 e0       	ldi	r17, 0x00	; 0
    5658:	11 23       	and	r17, r17
    565a:	19 f0       	breq	.+6      	; 0x5662 <chb_set_state+0x47a>
		__ticks = 1;
    565c:	81 e0       	ldi	r24, 0x01	; 1
    565e:	8a af       	sts	0x7a, r24
    5660:	e6 c0       	rjmp	.+460    	; 0x582e <chb_set_state+0x646>
	else if (__tmp > 255)
    5662:	11 e0       	ldi	r17, 0x01	; 1
    5664:	6e a9       	sts	0x4e, r22
    5666:	7f a9       	sts	0x4f, r23
    5668:	88 ad       	sts	0x68, r24
    566a:	99 ad       	sts	0x69, r25
    566c:	20 e0       	ldi	r18, 0x00	; 0
    566e:	30 e0       	ldi	r19, 0x00	; 0
    5670:	4f e7       	ldi	r20, 0x7F	; 127
    5672:	53 e4       	ldi	r21, 0x43	; 67
    5674:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    5678:	18 16       	cp	r1, r24
    567a:	0c f0       	brlt	.+2      	; 0x567e <chb_set_state+0x496>
    567c:	10 e0       	ldi	r17, 0x00	; 0
    567e:	11 23       	and	r17, r17
    5680:	09 f4       	brne	.+2      	; 0x5684 <chb_set_state+0x49c>
    5682:	cc c0       	rjmp	.+408    	; 0x581c <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5684:	6a a9       	sts	0x4a, r22
    5686:	7b a9       	sts	0x4b, r23
    5688:	8c a9       	sts	0x4c, r24
    568a:	9d a9       	sts	0x4d, r25
    568c:	20 e0       	ldi	r18, 0x00	; 0
    568e:	30 e0       	ldi	r19, 0x00	; 0
    5690:	4a e7       	ldi	r20, 0x7A	; 122
    5692:	54 e4       	ldi	r21, 0x44	; 68
    5694:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    5698:	dc 01       	movw	r26, r24
    569a:	cb 01       	movw	r24, r22
    569c:	8b af       	sts	0x7b, r24
    569e:	9c af       	sts	0x7c, r25
    56a0:	ad af       	sts	0x7d, r26
    56a2:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    56a4:	8e 01       	movw	r16, r28
    56a6:	01 5c       	subi	r16, 0xC1	; 193
    56a8:	1f 4f       	sbci	r17, 0xFF	; 255
    56aa:	6b ad       	sts	0x6b, r22
    56ac:	7c ad       	sts	0x6c, r23
    56ae:	8d ad       	sts	0x6d, r24
    56b0:	9e ad       	sts	0x6e, r25
    56b2:	20 e0       	ldi	r18, 0x00	; 0
    56b4:	30 e0       	ldi	r19, 0x00	; 0
    56b6:	4a e7       	ldi	r20, 0x7A	; 122
    56b8:	53 e4       	ldi	r21, 0x43	; 67
    56ba:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    56be:	dc 01       	movw	r26, r24
    56c0:	cb 01       	movw	r24, r22
    56c2:	f8 01       	movw	r30, r16
    56c4:	80 83       	st	Z, r24
    56c6:	91 83       	std	Z+1, r25	; 0x01
    56c8:	a2 83       	std	Z+2, r26	; 0x02
    56ca:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    56cc:	ce 01       	movw	r24, r28
    56ce:	cf 96       	adiw	r24, 0x3f	; 63
    56d0:	11 e0       	ldi	r17, 0x01	; 1
    56d2:	fc 01       	movw	r30, r24
    56d4:	60 81       	ld	r22, Z
    56d6:	71 81       	ldd	r23, Z+1	; 0x01
    56d8:	82 81       	ldd	r24, Z+2	; 0x02
    56da:	93 81       	ldd	r25, Z+3	; 0x03
    56dc:	20 e0       	ldi	r18, 0x00	; 0
    56de:	30 e0       	ldi	r19, 0x00	; 0
    56e0:	40 e8       	ldi	r20, 0x80	; 128
    56e2:	5f e3       	ldi	r21, 0x3F	; 63
    56e4:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    56e8:	88 23       	and	r24, r24
    56ea:	0c f0       	brlt	.+2      	; 0x56ee <chb_set_state+0x506>
    56ec:	10 e0       	ldi	r17, 0x00	; 0
    56ee:	11 23       	and	r17, r17
    56f0:	49 f0       	breq	.+18     	; 0x5704 <chb_set_state+0x51c>
		__ticks = 1;
    56f2:	ce 01       	movw	r24, r28
    56f4:	8d 5b       	subi	r24, 0xBD	; 189
    56f6:	9f 4f       	sbci	r25, 0xFF	; 255
    56f8:	21 e0       	ldi	r18, 0x01	; 1
    56fa:	30 e0       	ldi	r19, 0x00	; 0
    56fc:	fc 01       	movw	r30, r24
    56fe:	20 83       	st	Z, r18
    5700:	31 83       	std	Z+1, r19	; 0x01
    5702:	6e c0       	rjmp	.+220    	; 0x57e0 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    5704:	ce 01       	movw	r24, r28
    5706:	cf 96       	adiw	r24, 0x3f	; 63
    5708:	11 e0       	ldi	r17, 0x01	; 1
    570a:	fc 01       	movw	r30, r24
    570c:	60 81       	ld	r22, Z
    570e:	71 81       	ldd	r23, Z+1	; 0x01
    5710:	82 81       	ldd	r24, Z+2	; 0x02
    5712:	93 81       	ldd	r25, Z+3	; 0x03
    5714:	20 e0       	ldi	r18, 0x00	; 0
    5716:	3f ef       	ldi	r19, 0xFF	; 255
    5718:	4f e7       	ldi	r20, 0x7F	; 127
    571a:	57 e4       	ldi	r21, 0x47	; 71
    571c:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    5720:	18 16       	cp	r1, r24
    5722:	0c f0       	brlt	.+2      	; 0x5726 <chb_set_state+0x53e>
    5724:	10 e0       	ldi	r17, 0x00	; 0
    5726:	11 23       	and	r17, r17
    5728:	09 f4       	brne	.+2      	; 0x572c <chb_set_state+0x544>
    572a:	49 c0       	rjmp	.+146    	; 0x57be <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    572c:	6b ad       	sts	0x6b, r22
    572e:	7c ad       	sts	0x6c, r23
    5730:	8d ad       	sts	0x6d, r24
    5732:	9e ad       	sts	0x6e, r25
    5734:	20 e0       	ldi	r18, 0x00	; 0
    5736:	30 e0       	ldi	r19, 0x00	; 0
    5738:	40 e2       	ldi	r20, 0x20	; 32
    573a:	51 e4       	ldi	r21, 0x41	; 65
    573c:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5740:	dc 01       	movw	r26, r24
    5742:	cb 01       	movw	r24, r22
    5744:	8e 01       	movw	r16, r28
    5746:	0d 5b       	subi	r16, 0xBD	; 189
    5748:	1f 4f       	sbci	r17, 0xFF	; 255
    574a:	bc 01       	movw	r22, r24
    574c:	cd 01       	movw	r24, r26
    574e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5752:	dc 01       	movw	r26, r24
    5754:	cb 01       	movw	r24, r22
    5756:	f8 01       	movw	r30, r16
    5758:	80 83       	st	Z, r24
    575a:	91 83       	std	Z+1, r25	; 0x01
    575c:	27 c0       	rjmp	.+78     	; 0x57ac <chb_set_state+0x5c4>
    575e:	ce 01       	movw	r24, r28
    5760:	8b 5b       	subi	r24, 0xBB	; 187
    5762:	9f 4f       	sbci	r25, 0xFF	; 255
    5764:	29 e1       	ldi	r18, 0x19	; 25
    5766:	30 e0       	ldi	r19, 0x00	; 0
    5768:	fc 01       	movw	r30, r24
    576a:	20 83       	st	Z, r18
    576c:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    576e:	ce 01       	movw	r24, r28
    5770:	8b 5b       	subi	r24, 0xBB	; 187
    5772:	9f 4f       	sbci	r25, 0xFF	; 255
    5774:	fc 01       	movw	r30, r24
    5776:	80 81       	ld	r24, Z
    5778:	91 81       	ldd	r25, Z+1	; 0x01
    577a:	8c 01       	movw	r16, r24
    577c:	c8 01       	movw	r24, r16
    577e:	01 97       	sbiw	r24, 0x01	; 1
    5780:	f1 f7       	brne	.-4      	; 0x577e <chb_set_state+0x596>
    5782:	8c 01       	movw	r16, r24
    5784:	ce 01       	movw	r24, r28
    5786:	8b 5b       	subi	r24, 0xBB	; 187
    5788:	9f 4f       	sbci	r25, 0xFF	; 255
    578a:	fc 01       	movw	r30, r24
    578c:	00 83       	st	Z, r16
    578e:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5790:	ce 01       	movw	r24, r28
    5792:	8d 5b       	subi	r24, 0xBD	; 189
    5794:	9f 4f       	sbci	r25, 0xFF	; 255
    5796:	9e 01       	movw	r18, r28
    5798:	2d 5b       	subi	r18, 0xBD	; 189
    579a:	3f 4f       	sbci	r19, 0xFF	; 255
    579c:	f9 01       	movw	r30, r18
    579e:	20 81       	ld	r18, Z
    57a0:	31 81       	ldd	r19, Z+1	; 0x01
    57a2:	21 50       	subi	r18, 0x01	; 1
    57a4:	30 40       	sbci	r19, 0x00	; 0
    57a6:	fc 01       	movw	r30, r24
    57a8:	20 83       	st	Z, r18
    57aa:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57ac:	ce 01       	movw	r24, r28
    57ae:	8d 5b       	subi	r24, 0xBD	; 189
    57b0:	9f 4f       	sbci	r25, 0xFF	; 255
    57b2:	fc 01       	movw	r30, r24
    57b4:	80 81       	ld	r24, Z
    57b6:	91 81       	ldd	r25, Z+1	; 0x01
    57b8:	00 97       	sbiw	r24, 0x00	; 0
    57ba:	89 f6       	brne	.-94     	; 0x575e <chb_set_state+0x576>
    57bc:	4c c0       	rjmp	.+152    	; 0x5856 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57be:	8e 01       	movw	r16, r28
    57c0:	0d 5b       	subi	r16, 0xBD	; 189
    57c2:	1f 4f       	sbci	r17, 0xFF	; 255
    57c4:	ce 01       	movw	r24, r28
    57c6:	cf 96       	adiw	r24, 0x3f	; 63
    57c8:	fc 01       	movw	r30, r24
    57ca:	60 81       	ld	r22, Z
    57cc:	71 81       	ldd	r23, Z+1	; 0x01
    57ce:	82 81       	ldd	r24, Z+2	; 0x02
    57d0:	93 81       	ldd	r25, Z+3	; 0x03
    57d2:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    57d6:	dc 01       	movw	r26, r24
    57d8:	cb 01       	movw	r24, r22
    57da:	f8 01       	movw	r30, r16
    57dc:	80 83       	st	Z, r24
    57de:	91 83       	std	Z+1, r25	; 0x01
    57e0:	ce 01       	movw	r24, r28
    57e2:	89 5b       	subi	r24, 0xB9	; 185
    57e4:	9f 4f       	sbci	r25, 0xFF	; 255
    57e6:	9e 01       	movw	r18, r28
    57e8:	2d 5b       	subi	r18, 0xBD	; 189
    57ea:	3f 4f       	sbci	r19, 0xFF	; 255
    57ec:	f9 01       	movw	r30, r18
    57ee:	20 81       	ld	r18, Z
    57f0:	31 81       	ldd	r19, Z+1	; 0x01
    57f2:	fc 01       	movw	r30, r24
    57f4:	20 83       	st	Z, r18
    57f6:	31 83       	std	Z+1, r19	; 0x01
    57f8:	ce 01       	movw	r24, r28
    57fa:	89 5b       	subi	r24, 0xB9	; 185
    57fc:	9f 4f       	sbci	r25, 0xFF	; 255
    57fe:	fc 01       	movw	r30, r24
    5800:	80 81       	ld	r24, Z
    5802:	91 81       	ldd	r25, Z+1	; 0x01
    5804:	8c 01       	movw	r16, r24
    5806:	c8 01       	movw	r24, r16
    5808:	01 97       	sbiw	r24, 0x01	; 1
    580a:	f1 f7       	brne	.-4      	; 0x5808 <chb_set_state+0x620>
    580c:	8c 01       	movw	r16, r24
    580e:	ce 01       	movw	r24, r28
    5810:	89 5b       	subi	r24, 0xB9	; 185
    5812:	9f 4f       	sbci	r25, 0xFF	; 255
    5814:	fc 01       	movw	r30, r24
    5816:	00 83       	st	Z, r16
    5818:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    581a:	20 c0       	rjmp	.+64     	; 0x585c <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    581c:	6e a9       	sts	0x4e, r22
    581e:	7f a9       	sts	0x4f, r23
    5820:	88 ad       	sts	0x68, r24
    5822:	99 ad       	sts	0x69, r25
    5824:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5828:	dc 01       	movw	r26, r24
    582a:	cb 01       	movw	r24, r22
    582c:	8a af       	sts	0x7a, r24
    582e:	ce 01       	movw	r24, r28
    5830:	87 5b       	subi	r24, 0xB7	; 183
    5832:	9f 4f       	sbci	r25, 0xFF	; 255
    5834:	2a ad       	sts	0x6a, r18
    5836:	fc 01       	movw	r30, r24
    5838:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    583a:	ce 01       	movw	r24, r28
    583c:	87 5b       	subi	r24, 0xB7	; 183
    583e:	9f 4f       	sbci	r25, 0xFF	; 255
    5840:	fc 01       	movw	r30, r24
    5842:	80 81       	ld	r24, Z
    5844:	18 2f       	mov	r17, r24
    5846:	1a 95       	dec	r17
    5848:	f1 f7       	brne	.-4      	; 0x5846 <chb_set_state+0x65e>
    584a:	ce 01       	movw	r24, r28
    584c:	87 5b       	subi	r24, 0xB7	; 183
    584e:	9f 4f       	sbci	r25, 0xFF	; 255
    5850:	fc 01       	movw	r30, r24
    5852:	10 83       	st	Z, r17
    5854:	03 c0       	rjmp	.+6      	; 0x585c <chb_set_state+0x674>
    5856:	02 c0       	rjmp	.+4      	; 0x585c <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5858:	00 00       	nop
    585a:	01 c0       	rjmp	.+2      	; 0x585e <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    585c:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    585e:	9e 01       	movw	r18, r28
    5860:	2e 59       	subi	r18, 0x9E	; 158
    5862:	3f 4f       	sbci	r19, 0xFF	; 255
    5864:	82 e0       	ldi	r24, 0x02	; 2
    5866:	f9 01       	movw	r30, r18
    5868:	60 81       	ld	r22, Z
    586a:	4f e1       	ldi	r20, 0x1F	; 31
    586c:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
    5870:	9e 01       	movw	r18, r28
    5872:	26 5b       	subi	r18, 0xB6	; 182
    5874:	3f 4f       	sbci	r19, 0xFF	; 255
    5876:	80 e0       	ldi	r24, 0x00	; 0
    5878:	90 e0       	ldi	r25, 0x00	; 0
    587a:	ac ed       	ldi	r26, 0xDC	; 220
    587c:	b2 e4       	ldi	r27, 0x42	; 66
    587e:	f9 01       	movw	r30, r18
    5880:	80 83       	st	Z, r24
    5882:	91 83       	std	Z+1, r25	; 0x01
    5884:	a2 83       	std	Z+2, r26	; 0x02
    5886:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5888:	8e 01       	movw	r16, r28
    588a:	02 5b       	subi	r16, 0xB2	; 178
    588c:	1f 4f       	sbci	r17, 0xFF	; 255
    588e:	ce 01       	movw	r24, r28
    5890:	86 5b       	subi	r24, 0xB6	; 182
    5892:	9f 4f       	sbci	r25, 0xFF	; 255
    5894:	fc 01       	movw	r30, r24
    5896:	60 81       	ld	r22, Z
    5898:	71 81       	ldd	r23, Z+1	; 0x01
    589a:	82 81       	ldd	r24, Z+2	; 0x02
    589c:	93 81       	ldd	r25, Z+3	; 0x03
    589e:	2b ea       	ldi	r18, 0xAB	; 171
    58a0:	3a ea       	ldi	r19, 0xAA	; 170
    58a2:	4a ea       	ldi	r20, 0xAA	; 170
    58a4:	5e e3       	ldi	r21, 0x3E	; 62
    58a6:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    58aa:	dc 01       	movw	r26, r24
    58ac:	cb 01       	movw	r24, r22
    58ae:	f8 01       	movw	r30, r16
    58b0:	80 83       	st	Z, r24
    58b2:	91 83       	std	Z+1, r25	; 0x01
    58b4:	a2 83       	std	Z+2, r26	; 0x02
    58b6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    58b8:	ce 01       	movw	r24, r28
    58ba:	82 5b       	subi	r24, 0xB2	; 178
    58bc:	9f 4f       	sbci	r25, 0xFF	; 255
    58be:	11 e0       	ldi	r17, 0x01	; 1
    58c0:	fc 01       	movw	r30, r24
    58c2:	60 81       	ld	r22, Z
    58c4:	71 81       	ldd	r23, Z+1	; 0x01
    58c6:	82 81       	ldd	r24, Z+2	; 0x02
    58c8:	93 81       	ldd	r25, Z+3	; 0x03
    58ca:	20 e0       	ldi	r18, 0x00	; 0
    58cc:	30 e0       	ldi	r19, 0x00	; 0
    58ce:	40 e8       	ldi	r20, 0x80	; 128
    58d0:	5f e3       	ldi	r21, 0x3F	; 63
    58d2:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    58d6:	88 23       	and	r24, r24
    58d8:	0c f0       	brlt	.+2      	; 0x58dc <chb_set_state+0x6f4>
    58da:	10 e0       	ldi	r17, 0x00	; 0
    58dc:	11 23       	and	r17, r17
    58de:	39 f0       	breq	.+14     	; 0x58ee <chb_set_state+0x706>
		__ticks = 1;
    58e0:	ce 01       	movw	r24, r28
    58e2:	8e 5a       	subi	r24, 0xAE	; 174
    58e4:	9f 4f       	sbci	r25, 0xFF	; 255
    58e6:	21 e0       	ldi	r18, 0x01	; 1
    58e8:	fc 01       	movw	r30, r24
    58ea:	20 83       	st	Z, r18
    58ec:	05 c1       	rjmp	.+522    	; 0x5af8 <chb_set_state+0x910>
	else if (__tmp > 255)
    58ee:	ce 01       	movw	r24, r28
    58f0:	82 5b       	subi	r24, 0xB2	; 178
    58f2:	9f 4f       	sbci	r25, 0xFF	; 255
    58f4:	11 e0       	ldi	r17, 0x01	; 1
    58f6:	fc 01       	movw	r30, r24
    58f8:	60 81       	ld	r22, Z
    58fa:	71 81       	ldd	r23, Z+1	; 0x01
    58fc:	82 81       	ldd	r24, Z+2	; 0x02
    58fe:	93 81       	ldd	r25, Z+3	; 0x03
    5900:	20 e0       	ldi	r18, 0x00	; 0
    5902:	30 e0       	ldi	r19, 0x00	; 0
    5904:	4f e7       	ldi	r20, 0x7F	; 127
    5906:	53 e4       	ldi	r21, 0x43	; 67
    5908:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    590c:	18 16       	cp	r1, r24
    590e:	0c f0       	brlt	.+2      	; 0x5912 <chb_set_state+0x72a>
    5910:	10 e0       	ldi	r17, 0x00	; 0
    5912:	11 23       	and	r17, r17
    5914:	09 f4       	brne	.+2      	; 0x5918 <chb_set_state+0x730>
    5916:	df c0       	rjmp	.+446    	; 0x5ad6 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    5918:	ce 01       	movw	r24, r28
    591a:	86 5b       	subi	r24, 0xB6	; 182
    591c:	9f 4f       	sbci	r25, 0xFF	; 255
    591e:	fc 01       	movw	r30, r24
    5920:	60 81       	ld	r22, Z
    5922:	71 81       	ldd	r23, Z+1	; 0x01
    5924:	82 81       	ldd	r24, Z+2	; 0x02
    5926:	93 81       	ldd	r25, Z+3	; 0x03
    5928:	20 e0       	ldi	r18, 0x00	; 0
    592a:	30 e0       	ldi	r19, 0x00	; 0
    592c:	4a e7       	ldi	r20, 0x7A	; 122
    592e:	54 e4       	ldi	r21, 0x44	; 68
    5930:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    5934:	dc 01       	movw	r26, r24
    5936:	cb 01       	movw	r24, r22
    5938:	9e 01       	movw	r18, r28
    593a:	2d 5a       	subi	r18, 0xAD	; 173
    593c:	3f 4f       	sbci	r19, 0xFF	; 255
    593e:	f9 01       	movw	r30, r18
    5940:	80 83       	st	Z, r24
    5942:	91 83       	std	Z+1, r25	; 0x01
    5944:	a2 83       	std	Z+2, r26	; 0x02
    5946:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5948:	8e 01       	movw	r16, r28
    594a:	09 5a       	subi	r16, 0xA9	; 169
    594c:	1f 4f       	sbci	r17, 0xFF	; 255
    594e:	ce 01       	movw	r24, r28
    5950:	8d 5a       	subi	r24, 0xAD	; 173
    5952:	9f 4f       	sbci	r25, 0xFF	; 255
    5954:	fc 01       	movw	r30, r24
    5956:	60 81       	ld	r22, Z
    5958:	71 81       	ldd	r23, Z+1	; 0x01
    595a:	82 81       	ldd	r24, Z+2	; 0x02
    595c:	93 81       	ldd	r25, Z+3	; 0x03
    595e:	20 e0       	ldi	r18, 0x00	; 0
    5960:	30 e0       	ldi	r19, 0x00	; 0
    5962:	4a e7       	ldi	r20, 0x7A	; 122
    5964:	53 e4       	ldi	r21, 0x43	; 67
    5966:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    596a:	dc 01       	movw	r26, r24
    596c:	cb 01       	movw	r24, r22
    596e:	f8 01       	movw	r30, r16
    5970:	80 83       	st	Z, r24
    5972:	91 83       	std	Z+1, r25	; 0x01
    5974:	a2 83       	std	Z+2, r26	; 0x02
    5976:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5978:	ce 01       	movw	r24, r28
    597a:	89 5a       	subi	r24, 0xA9	; 169
    597c:	9f 4f       	sbci	r25, 0xFF	; 255
    597e:	11 e0       	ldi	r17, 0x01	; 1
    5980:	fc 01       	movw	r30, r24
    5982:	60 81       	ld	r22, Z
    5984:	71 81       	ldd	r23, Z+1	; 0x01
    5986:	82 81       	ldd	r24, Z+2	; 0x02
    5988:	93 81       	ldd	r25, Z+3	; 0x03
    598a:	20 e0       	ldi	r18, 0x00	; 0
    598c:	30 e0       	ldi	r19, 0x00	; 0
    598e:	40 e8       	ldi	r20, 0x80	; 128
    5990:	5f e3       	ldi	r21, 0x3F	; 63
    5992:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    5996:	88 23       	and	r24, r24
    5998:	0c f0       	brlt	.+2      	; 0x599c <chb_set_state+0x7b4>
    599a:	10 e0       	ldi	r17, 0x00	; 0
    599c:	11 23       	and	r17, r17
    599e:	49 f0       	breq	.+18     	; 0x59b2 <chb_set_state+0x7ca>
		__ticks = 1;
    59a0:	ce 01       	movw	r24, r28
    59a2:	85 5a       	subi	r24, 0xA5	; 165
    59a4:	9f 4f       	sbci	r25, 0xFF	; 255
    59a6:	21 e0       	ldi	r18, 0x01	; 1
    59a8:	30 e0       	ldi	r19, 0x00	; 0
    59aa:	fc 01       	movw	r30, r24
    59ac:	20 83       	st	Z, r18
    59ae:	31 83       	std	Z+1, r19	; 0x01
    59b0:	74 c0       	rjmp	.+232    	; 0x5a9a <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    59b2:	ce 01       	movw	r24, r28
    59b4:	89 5a       	subi	r24, 0xA9	; 169
    59b6:	9f 4f       	sbci	r25, 0xFF	; 255
    59b8:	11 e0       	ldi	r17, 0x01	; 1
    59ba:	fc 01       	movw	r30, r24
    59bc:	60 81       	ld	r22, Z
    59be:	71 81       	ldd	r23, Z+1	; 0x01
    59c0:	82 81       	ldd	r24, Z+2	; 0x02
    59c2:	93 81       	ldd	r25, Z+3	; 0x03
    59c4:	20 e0       	ldi	r18, 0x00	; 0
    59c6:	3f ef       	ldi	r19, 0xFF	; 255
    59c8:	4f e7       	ldi	r20, 0x7F	; 127
    59ca:	57 e4       	ldi	r21, 0x47	; 71
    59cc:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    59d0:	18 16       	cp	r1, r24
    59d2:	0c f0       	brlt	.+2      	; 0x59d6 <chb_set_state+0x7ee>
    59d4:	10 e0       	ldi	r17, 0x00	; 0
    59d6:	11 23       	and	r17, r17
    59d8:	09 f4       	brne	.+2      	; 0x59dc <chb_set_state+0x7f4>
    59da:	4d c0       	rjmp	.+154    	; 0x5a76 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    59dc:	ce 01       	movw	r24, r28
    59de:	8d 5a       	subi	r24, 0xAD	; 173
    59e0:	9f 4f       	sbci	r25, 0xFF	; 255
    59e2:	fc 01       	movw	r30, r24
    59e4:	60 81       	ld	r22, Z
    59e6:	71 81       	ldd	r23, Z+1	; 0x01
    59e8:	82 81       	ldd	r24, Z+2	; 0x02
    59ea:	93 81       	ldd	r25, Z+3	; 0x03
    59ec:	20 e0       	ldi	r18, 0x00	; 0
    59ee:	30 e0       	ldi	r19, 0x00	; 0
    59f0:	40 e2       	ldi	r20, 0x20	; 32
    59f2:	51 e4       	ldi	r21, 0x41	; 65
    59f4:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    59f8:	dc 01       	movw	r26, r24
    59fa:	cb 01       	movw	r24, r22
    59fc:	8e 01       	movw	r16, r28
    59fe:	05 5a       	subi	r16, 0xA5	; 165
    5a00:	1f 4f       	sbci	r17, 0xFF	; 255
    5a02:	bc 01       	movw	r22, r24
    5a04:	cd 01       	movw	r24, r26
    5a06:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5a0a:	dc 01       	movw	r26, r24
    5a0c:	cb 01       	movw	r24, r22
    5a0e:	f8 01       	movw	r30, r16
    5a10:	80 83       	st	Z, r24
    5a12:	91 83       	std	Z+1, r25	; 0x01
    5a14:	27 c0       	rjmp	.+78     	; 0x5a64 <chb_set_state+0x87c>
    5a16:	ce 01       	movw	r24, r28
    5a18:	83 5a       	subi	r24, 0xA3	; 163
    5a1a:	9f 4f       	sbci	r25, 0xFF	; 255
    5a1c:	29 e1       	ldi	r18, 0x19	; 25
    5a1e:	30 e0       	ldi	r19, 0x00	; 0
    5a20:	fc 01       	movw	r30, r24
    5a22:	20 83       	st	Z, r18
    5a24:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5a26:	ce 01       	movw	r24, r28
    5a28:	83 5a       	subi	r24, 0xA3	; 163
    5a2a:	9f 4f       	sbci	r25, 0xFF	; 255
    5a2c:	fc 01       	movw	r30, r24
    5a2e:	80 81       	ld	r24, Z
    5a30:	91 81       	ldd	r25, Z+1	; 0x01
    5a32:	8c 01       	movw	r16, r24
    5a34:	c8 01       	movw	r24, r16
    5a36:	01 97       	sbiw	r24, 0x01	; 1
    5a38:	f1 f7       	brne	.-4      	; 0x5a36 <chb_set_state+0x84e>
    5a3a:	8c 01       	movw	r16, r24
    5a3c:	ce 01       	movw	r24, r28
    5a3e:	83 5a       	subi	r24, 0xA3	; 163
    5a40:	9f 4f       	sbci	r25, 0xFF	; 255
    5a42:	fc 01       	movw	r30, r24
    5a44:	00 83       	st	Z, r16
    5a46:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a48:	ce 01       	movw	r24, r28
    5a4a:	85 5a       	subi	r24, 0xA5	; 165
    5a4c:	9f 4f       	sbci	r25, 0xFF	; 255
    5a4e:	9e 01       	movw	r18, r28
    5a50:	25 5a       	subi	r18, 0xA5	; 165
    5a52:	3f 4f       	sbci	r19, 0xFF	; 255
    5a54:	f9 01       	movw	r30, r18
    5a56:	20 81       	ld	r18, Z
    5a58:	31 81       	ldd	r19, Z+1	; 0x01
    5a5a:	21 50       	subi	r18, 0x01	; 1
    5a5c:	30 40       	sbci	r19, 0x00	; 0
    5a5e:	fc 01       	movw	r30, r24
    5a60:	20 83       	st	Z, r18
    5a62:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a64:	ce 01       	movw	r24, r28
    5a66:	85 5a       	subi	r24, 0xA5	; 165
    5a68:	9f 4f       	sbci	r25, 0xFF	; 255
    5a6a:	fc 01       	movw	r30, r24
    5a6c:	80 81       	ld	r24, Z
    5a6e:	91 81       	ldd	r25, Z+1	; 0x01
    5a70:	00 97       	sbiw	r24, 0x00	; 0
    5a72:	89 f6       	brne	.-94     	; 0x5a16 <chb_set_state+0x82e>
    5a74:	58 c0       	rjmp	.+176    	; 0x5b26 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a76:	8e 01       	movw	r16, r28
    5a78:	05 5a       	subi	r16, 0xA5	; 165
    5a7a:	1f 4f       	sbci	r17, 0xFF	; 255
    5a7c:	ce 01       	movw	r24, r28
    5a7e:	89 5a       	subi	r24, 0xA9	; 169
    5a80:	9f 4f       	sbci	r25, 0xFF	; 255
    5a82:	fc 01       	movw	r30, r24
    5a84:	60 81       	ld	r22, Z
    5a86:	71 81       	ldd	r23, Z+1	; 0x01
    5a88:	82 81       	ldd	r24, Z+2	; 0x02
    5a8a:	93 81       	ldd	r25, Z+3	; 0x03
    5a8c:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5a90:	dc 01       	movw	r26, r24
    5a92:	cb 01       	movw	r24, r22
    5a94:	f8 01       	movw	r30, r16
    5a96:	80 83       	st	Z, r24
    5a98:	91 83       	std	Z+1, r25	; 0x01
    5a9a:	ce 01       	movw	r24, r28
    5a9c:	81 5a       	subi	r24, 0xA1	; 161
    5a9e:	9f 4f       	sbci	r25, 0xFF	; 255
    5aa0:	9e 01       	movw	r18, r28
    5aa2:	25 5a       	subi	r18, 0xA5	; 165
    5aa4:	3f 4f       	sbci	r19, 0xFF	; 255
    5aa6:	f9 01       	movw	r30, r18
    5aa8:	20 81       	ld	r18, Z
    5aaa:	31 81       	ldd	r19, Z+1	; 0x01
    5aac:	fc 01       	movw	r30, r24
    5aae:	20 83       	st	Z, r18
    5ab0:	31 83       	std	Z+1, r19	; 0x01
    5ab2:	ce 01       	movw	r24, r28
    5ab4:	81 5a       	subi	r24, 0xA1	; 161
    5ab6:	9f 4f       	sbci	r25, 0xFF	; 255
    5ab8:	fc 01       	movw	r30, r24
    5aba:	80 81       	ld	r24, Z
    5abc:	91 81       	ldd	r25, Z+1	; 0x01
    5abe:	8c 01       	movw	r16, r24
    5ac0:	c8 01       	movw	r24, r16
    5ac2:	01 97       	sbiw	r24, 0x01	; 1
    5ac4:	f1 f7       	brne	.-4      	; 0x5ac2 <chb_set_state+0x8da>
    5ac6:	8c 01       	movw	r16, r24
    5ac8:	ce 01       	movw	r24, r28
    5aca:	81 5a       	subi	r24, 0xA1	; 161
    5acc:	9f 4f       	sbci	r25, 0xFF	; 255
    5ace:	fc 01       	movw	r30, r24
    5ad0:	00 83       	st	Z, r16
    5ad2:	11 83       	std	Z+1, r17	; 0x01
    5ad4:	28 c0       	rjmp	.+80     	; 0x5b26 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5ad6:	8e 01       	movw	r16, r28
    5ad8:	0e 5a       	subi	r16, 0xAE	; 174
    5ada:	1f 4f       	sbci	r17, 0xFF	; 255
    5adc:	ce 01       	movw	r24, r28
    5ade:	82 5b       	subi	r24, 0xB2	; 178
    5ae0:	9f 4f       	sbci	r25, 0xFF	; 255
    5ae2:	fc 01       	movw	r30, r24
    5ae4:	60 81       	ld	r22, Z
    5ae6:	71 81       	ldd	r23, Z+1	; 0x01
    5ae8:	82 81       	ldd	r24, Z+2	; 0x02
    5aea:	93 81       	ldd	r25, Z+3	; 0x03
    5aec:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5af0:	dc 01       	movw	r26, r24
    5af2:	cb 01       	movw	r24, r22
    5af4:	f8 01       	movw	r30, r16
    5af6:	80 83       	st	Z, r24
    5af8:	ce 01       	movw	r24, r28
    5afa:	8f 59       	subi	r24, 0x9F	; 159
    5afc:	9f 4f       	sbci	r25, 0xFF	; 255
    5afe:	9e 01       	movw	r18, r28
    5b00:	2e 5a       	subi	r18, 0xAE	; 174
    5b02:	3f 4f       	sbci	r19, 0xFF	; 255
    5b04:	f9 01       	movw	r30, r18
    5b06:	20 81       	ld	r18, Z
    5b08:	fc 01       	movw	r30, r24
    5b0a:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5b0c:	ce 01       	movw	r24, r28
    5b0e:	8f 59       	subi	r24, 0x9F	; 159
    5b10:	9f 4f       	sbci	r25, 0xFF	; 255
    5b12:	fc 01       	movw	r30, r24
    5b14:	80 81       	ld	r24, Z
    5b16:	18 2f       	mov	r17, r24
    5b18:	1a 95       	dec	r17
    5b1a:	f1 f7       	brne	.-4      	; 0x5b18 <chb_set_state+0x930>
    5b1c:	ce 01       	movw	r24, r28
    5b1e:	8f 59       	subi	r24, 0x9F	; 159
    5b20:	9f 4f       	sbci	r25, 0xFF	; 255
    5b22:	fc 01       	movw	r30, r24
    5b24:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5b26:	0e 94 8d 23 	call	0x471a	; 0x471a <chb_get_state>
    5b2a:	28 2f       	mov	r18, r24
    5b2c:	ce 01       	movw	r24, r28
    5b2e:	8e 59       	subi	r24, 0x9E	; 158
    5b30:	9f 4f       	sbci	r25, 0xFF	; 255
    5b32:	fc 01       	movw	r30, r24
    5b34:	80 81       	ld	r24, Z
    5b36:	28 17       	cp	r18, r24
    5b38:	11 f4       	brne	.+4      	; 0x5b3e <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5b3a:	80 e4       	ldi	r24, 0x40	; 64
    5b3c:	01 c0       	rjmp	.+2      	; 0x5b40 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    5b3e:	83 e4       	ldi	r24, 0x43	; 67
}
    5b40:	ce 59       	subi	r28, 0x9E	; 158
    5b42:	df 4f       	sbci	r29, 0xFF	; 255
    5b44:	cd bf       	out	0x3d, r28	; 61
    5b46:	de bf       	out	0x3e, r29	; 62
    5b48:	df 91       	pop	r29
    5b4a:	cf 91       	pop	r28
    5b4c:	1f 91       	pop	r17
    5b4e:	0f 91       	pop	r16
    5b50:	08 95       	ret

00005b52 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5b52:	cf 93       	push	r28
    5b54:	df 93       	push	r29
    5b56:	0f 92       	push	r0
    5b58:	0f 92       	push	r0
    5b5a:	cd b7       	in	r28, 0x3d	; 61
    5b5c:	de b7       	in	r29, 0x3e	; 62
    5b5e:	89 83       	std	Y+1, r24	; 0x01
    5b60:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5b62:	29 81       	ldd	r18, Y+1	; 0x01
    5b64:	3a 81       	ldd	r19, Y+2	; 0x02
    5b66:	80 e0       	ldi	r24, 0x00	; 0
    5b68:	90 e0       	ldi	r25, 0x00	; 0
    5b6a:	b9 01       	movw	r22, r18
    5b6c:	48 e0       	ldi	r20, 0x08	; 8
    5b6e:	50 e0       	ldi	r21, 0x00	; 0
    5b70:	0e 94 c8 31 	call	0x6390	; 0x6390 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5b74:	29 81       	ldd	r18, Y+1	; 0x01
    5b76:	3a 81       	ldd	r19, Y+2	; 0x02
    5b78:	84 e2       	ldi	r24, 0x24	; 36
    5b7a:	b9 01       	movw	r22, r18
    5b7c:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <chb_reg_write64>
}
    5b80:	0f 90       	pop	r0
    5b82:	0f 90       	pop	r0
    5b84:	df 91       	pop	r29
    5b86:	cf 91       	pop	r28
    5b88:	08 95       	ret

00005b8a <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5b8a:	cf 93       	push	r28
    5b8c:	df 93       	push	r29
    5b8e:	0f 92       	push	r0
    5b90:	0f 92       	push	r0
    5b92:	cd b7       	in	r28, 0x3d	; 61
    5b94:	de b7       	in	r29, 0x3e	; 62
    5b96:	89 83       	std	Y+1, r24	; 0x01
    5b98:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5b9a:	29 81       	ldd	r18, Y+1	; 0x01
    5b9c:	3a 81       	ldd	r19, Y+2	; 0x02
    5b9e:	80 e0       	ldi	r24, 0x00	; 0
    5ba0:	90 e0       	ldi	r25, 0x00	; 0
    5ba2:	b9 01       	movw	r22, r18
    5ba4:	48 e0       	ldi	r20, 0x08	; 8
    5ba6:	50 e0       	ldi	r21, 0x00	; 0
    5ba8:	0e 94 04 32 	call	0x6408	; 0x6408 <chb_eeprom_read>
}
    5bac:	0f 90       	pop	r0
    5bae:	0f 90       	pop	r0
    5bb0:	df 91       	pop	r29
    5bb2:	cf 91       	pop	r28
    5bb4:	08 95       	ret

00005bb6 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5bb6:	cf 93       	push	r28
    5bb8:	df 93       	push	r29
    5bba:	00 d0       	rcall	.+0      	; 0x5bbc <chb_set_short_addr+0x6>
    5bbc:	00 d0       	rcall	.+0      	; 0x5bbe <chb_set_short_addr+0x8>
    5bbe:	cd b7       	in	r28, 0x3d	; 61
    5bc0:	de b7       	in	r29, 0x3e	; 62
    5bc2:	8d 83       	std	Y+5, r24	; 0x05
    5bc4:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5bc6:	ce 01       	movw	r24, r28
    5bc8:	05 96       	adiw	r24, 0x05	; 5
    5bca:	89 83       	std	Y+1, r24	; 0x01
    5bcc:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    5bce:	0e 94 8a 20 	call	0x4114	; 0x4114 <chb_get_pcb>
    5bd2:	8b 83       	std	Y+3, r24	; 0x03
    5bd4:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5bd6:	29 81       	ldd	r18, Y+1	; 0x01
    5bd8:	3a 81       	ldd	r19, Y+2	; 0x02
    5bda:	89 e0       	ldi	r24, 0x09	; 9
    5bdc:	90 e0       	ldi	r25, 0x00	; 0
    5bde:	b9 01       	movw	r22, r18
    5be0:	42 e0       	ldi	r20, 0x02	; 2
    5be2:	50 e0       	ldi	r21, 0x00	; 0
    5be4:	0e 94 c8 31 	call	0x6390	; 0x6390 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    5be8:	2d 81       	ldd	r18, Y+5	; 0x05
    5bea:	3e 81       	ldd	r19, Y+6	; 0x06
    5bec:	80 e2       	ldi	r24, 0x20	; 32
    5bee:	b9 01       	movw	r22, r18
    5bf0:	0e 94 1d 26 	call	0x4c3a	; 0x4c3a <chb_reg_write16>
    pcb->src_addr = addr;
    5bf4:	2d 81       	ldd	r18, Y+5	; 0x05
    5bf6:	3e 81       	ldd	r19, Y+6	; 0x06
    5bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    5bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    5bfc:	fc 01       	movw	r30, r24
    5bfe:	20 83       	st	Z, r18
    5c00:	31 83       	std	Z+1, r19	; 0x01
}
    5c02:	26 96       	adiw	r28, 0x06	; 6
    5c04:	cd bf       	out	0x3d, r28	; 61
    5c06:	de bf       	out	0x3e, r29	; 62
    5c08:	df 91       	pop	r29
    5c0a:	cf 91       	pop	r28
    5c0c:	08 95       	ret

00005c0e <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    5c0e:	cf 93       	push	r28
    5c10:	df 93       	push	r29
    5c12:	0f 92       	push	r0
    5c14:	0f 92       	push	r0
    5c16:	cd b7       	in	r28, 0x3d	; 61
    5c18:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    5c1a:	89 e0       	ldi	r24, 0x09	; 9
    5c1c:	90 e0       	ldi	r25, 0x00	; 0
    5c1e:	9e 01       	movw	r18, r28
    5c20:	2f 5f       	subi	r18, 0xFF	; 255
    5c22:	3f 4f       	sbci	r19, 0xFF	; 255
    5c24:	b9 01       	movw	r22, r18
    5c26:	42 e0       	ldi	r20, 0x02	; 2
    5c28:	50 e0       	ldi	r21, 0x00	; 0
    5c2a:	0e 94 04 32 	call	0x6408	; 0x6408 <chb_eeprom_read>
    return *(U16 *)addr;
    5c2e:	ce 01       	movw	r24, r28
    5c30:	01 96       	adiw	r24, 0x01	; 1
    5c32:	fc 01       	movw	r30, r24
    5c34:	80 81       	ld	r24, Z
    5c36:	91 81       	ldd	r25, Z+1	; 0x01
}
    5c38:	0f 90       	pop	r0
    5c3a:	0f 90       	pop	r0
    5c3c:	df 91       	pop	r29
    5c3e:	cf 91       	pop	r28
    5c40:	08 95       	ret

00005c42 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5c42:	cf 93       	push	r28
    5c44:	df 93       	push	r29
    5c46:	cd b7       	in	r28, 0x3d	; 61
    5c48:	de b7       	in	r29, 0x3e	; 62
    5c4a:	28 97       	sbiw	r28, 0x08	; 8
    5c4c:	cd bf       	out	0x3d, r28	; 61
    5c4e:	de bf       	out	0x3e, r29	; 62
    5c50:	8c 83       	std	Y+4, r24	; 0x04
    5c52:	9d 83       	std	Y+5, r25	; 0x05
    5c54:	6e 83       	std	Y+6, r22	; 0x06
    5c56:	7f 83       	std	Y+7, r23	; 0x07
    5c58:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5c5a:	0e 94 8d 23 	call	0x471a	; 0x471a <chb_get_state>
    5c5e:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5c60:	0e 94 8a 20 	call	0x4114	; 0x4114 <chb_get_pcb>
    5c64:	8a 83       	std	Y+2, r24	; 0x02
    5c66:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5c68:	89 81       	ldd	r24, Y+1	; 0x01
    5c6a:	82 30       	cpi	r24, 0x02	; 2
    5c6c:	19 f0       	breq	.+6      	; 0x5c74 <chb_tx+0x32>
    5c6e:	89 81       	ldd	r24, Y+1	; 0x01
    5c70:	82 31       	cpi	r24, 0x12	; 18
    5c72:	11 f4       	brne	.+4      	; 0x5c78 <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5c74:	84 e4       	ldi	r24, 0x44	; 68
    5c76:	23 c0       	rjmp	.+70     	; 0x5cbe <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5c78:	88 e0       	ldi	r24, 0x08	; 8
    5c7a:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    5c7e:	89 e1       	ldi	r24, 0x19	; 25
    5c80:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5c84:	8c 81       	ldd	r24, Y+4	; 0x04
    5c86:	9d 81       	ldd	r25, Y+5	; 0x05
    5c88:	2e 81       	ldd	r18, Y+6	; 0x06
    5c8a:	3f 81       	ldd	r19, Y+7	; 0x07
    5c8c:	6a e0       	ldi	r22, 0x0A	; 10
    5c8e:	a9 01       	movw	r20, r18
    5c90:	28 85       	ldd	r18, Y+8	; 0x08
    5c92:	0e 94 9b 26 	call	0x4d36	; 0x4d36 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5c96:	82 e0       	ldi	r24, 0x02	; 2
    5c98:	62 e0       	ldi	r22, 0x02	; 2
    5c9a:	4f e1       	ldi	r20, 0x1F	; 31
    5c9c:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>

    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
    5ca0:	00 00       	nop
    5ca2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ca4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ca6:	fc 01       	movw	r30, r24
    5ca8:	94 81       	ldd	r25, Z+4	; 0x04
    5caa:	81 e0       	ldi	r24, 0x01	; 1
    5cac:	89 27       	eor	r24, r25
    5cae:	88 23       	and	r24, r24
    5cb0:	c1 f7       	brne	.-16     	; 0x5ca2 <chb_tx+0x60>
    pcb->tx_end = false;
    5cb2:	8a 81       	ldd	r24, Y+2	; 0x02
    5cb4:	9b 81       	ldd	r25, Y+3	; 0x03
    5cb6:	fc 01       	movw	r30, r24
    5cb8:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5cba:	0e 94 98 23 	call	0x4730	; 0x4730 <chb_get_status>
}
    5cbe:	28 96       	adiw	r28, 0x08	; 8
    5cc0:	cd bf       	out	0x3d, r28	; 61
    5cc2:	de bf       	out	0x3e, r29	; 62
    5cc4:	df 91       	pop	r29
    5cc6:	cf 91       	pop	r28
    5cc8:	08 95       	ret

00005cca <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5cca:	0f 93       	push	r16
    5ccc:	1f 93       	push	r17
    5cce:	cf 93       	push	r28
    5cd0:	df 93       	push	r29
    5cd2:	cd b7       	in	r28, 0x3d	; 61
    5cd4:	de b7       	in	r29, 0x3e	; 62
    5cd6:	69 97       	sbiw	r28, 0x19	; 25
    5cd8:	cd bf       	out	0x3d, r28	; 61
    5cda:	de bf       	out	0x3e, r29	; 62
    5cdc:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    5cde:	89 8d       	ldd	r24, Y+25	; 0x19
    5ce0:	88 23       	and	r24, r24
    5ce2:	69 f0       	breq	.+26     	; 0x5cfe <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5ce4:	88 e0       	ldi	r24, 0x08	; 8
    5ce6:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5cea:	84 e6       	ldi	r24, 0x64	; 100
    5cec:	96 e0       	ldi	r25, 0x06	; 6
    5cee:	24 e6       	ldi	r18, 0x64	; 100
    5cf0:	36 e0       	ldi	r19, 0x06	; 6
    5cf2:	f9 01       	movw	r30, r18
    5cf4:	20 81       	ld	r18, Z
    5cf6:	22 60       	ori	r18, 0x02	; 2
    5cf8:	fc 01       	movw	r30, r24
    5cfa:	20 83       	st	Z, r18
    5cfc:	e1 c0       	rjmp	.+450    	; 0x5ec0 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    5cfe:	84 e6       	ldi	r24, 0x64	; 100
    5d00:	96 e0       	ldi	r25, 0x06	; 6
    5d02:	24 e6       	ldi	r18, 0x64	; 100
    5d04:	36 e0       	ldi	r19, 0x06	; 6
    5d06:	f9 01       	movw	r30, r18
    5d08:	20 81       	ld	r18, Z
    5d0a:	2d 7f       	andi	r18, 0xFD	; 253
    5d0c:	fc 01       	movw	r30, r24
    5d0e:	20 83       	st	Z, r18
    5d10:	80 e0       	ldi	r24, 0x00	; 0
    5d12:	90 e0       	ldi	r25, 0x00	; 0
    5d14:	a0 e7       	ldi	r26, 0x70	; 112
    5d16:	b3 e4       	ldi	r27, 0x43	; 67
    5d18:	89 83       	std	Y+1, r24	; 0x01
    5d1a:	9a 83       	std	Y+2, r25	; 0x02
    5d1c:	ab 83       	std	Y+3, r26	; 0x03
    5d1e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5d20:	69 81       	ldd	r22, Y+1	; 0x01
    5d22:	7a 81       	ldd	r23, Y+2	; 0x02
    5d24:	8b 81       	ldd	r24, Y+3	; 0x03
    5d26:	9c 81       	ldd	r25, Y+4	; 0x04
    5d28:	2b ea       	ldi	r18, 0xAB	; 171
    5d2a:	3a ea       	ldi	r19, 0xAA	; 170
    5d2c:	4a ea       	ldi	r20, 0xAA	; 170
    5d2e:	5e e3       	ldi	r21, 0x3E	; 62
    5d30:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5d34:	dc 01       	movw	r26, r24
    5d36:	cb 01       	movw	r24, r22
    5d38:	8d 83       	std	Y+5, r24	; 0x05
    5d3a:	9e 83       	std	Y+6, r25	; 0x06
    5d3c:	af 83       	std	Y+7, r26	; 0x07
    5d3e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5d40:	11 e0       	ldi	r17, 0x01	; 1
    5d42:	6d 81       	ldd	r22, Y+5	; 0x05
    5d44:	7e 81       	ldd	r23, Y+6	; 0x06
    5d46:	8f 81       	ldd	r24, Y+7	; 0x07
    5d48:	98 85       	ldd	r25, Y+8	; 0x08
    5d4a:	20 e0       	ldi	r18, 0x00	; 0
    5d4c:	30 e0       	ldi	r19, 0x00	; 0
    5d4e:	40 e8       	ldi	r20, 0x80	; 128
    5d50:	5f e3       	ldi	r21, 0x3F	; 63
    5d52:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    5d56:	88 23       	and	r24, r24
    5d58:	0c f0       	brlt	.+2      	; 0x5d5c <chb_sleep+0x92>
    5d5a:	10 e0       	ldi	r17, 0x00	; 0
    5d5c:	11 23       	and	r17, r17
    5d5e:	19 f0       	breq	.+6      	; 0x5d66 <chb_sleep+0x9c>
		__ticks = 1;
    5d60:	81 e0       	ldi	r24, 0x01	; 1
    5d62:	89 87       	std	Y+9, r24	; 0x09
    5d64:	a3 c0       	rjmp	.+326    	; 0x5eac <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5d66:	11 e0       	ldi	r17, 0x01	; 1
    5d68:	6d 81       	ldd	r22, Y+5	; 0x05
    5d6a:	7e 81       	ldd	r23, Y+6	; 0x06
    5d6c:	8f 81       	ldd	r24, Y+7	; 0x07
    5d6e:	98 85       	ldd	r25, Y+8	; 0x08
    5d70:	20 e0       	ldi	r18, 0x00	; 0
    5d72:	30 e0       	ldi	r19, 0x00	; 0
    5d74:	4f e7       	ldi	r20, 0x7F	; 127
    5d76:	53 e4       	ldi	r21, 0x43	; 67
    5d78:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    5d7c:	18 16       	cp	r1, r24
    5d7e:	0c f0       	brlt	.+2      	; 0x5d82 <chb_sleep+0xb8>
    5d80:	10 e0       	ldi	r17, 0x00	; 0
    5d82:	11 23       	and	r17, r17
    5d84:	09 f4       	brne	.+2      	; 0x5d88 <chb_sleep+0xbe>
    5d86:	89 c0       	rjmp	.+274    	; 0x5e9a <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5d88:	69 81       	ldd	r22, Y+1	; 0x01
    5d8a:	7a 81       	ldd	r23, Y+2	; 0x02
    5d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    5d8e:	9c 81       	ldd	r25, Y+4	; 0x04
    5d90:	20 e0       	ldi	r18, 0x00	; 0
    5d92:	30 e0       	ldi	r19, 0x00	; 0
    5d94:	4a e7       	ldi	r20, 0x7A	; 122
    5d96:	54 e4       	ldi	r21, 0x44	; 68
    5d98:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    5d9c:	dc 01       	movw	r26, r24
    5d9e:	cb 01       	movw	r24, r22
    5da0:	8a 87       	std	Y+10, r24	; 0x0a
    5da2:	9b 87       	std	Y+11, r25	; 0x0b
    5da4:	ac 87       	std	Y+12, r26	; 0x0c
    5da6:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5da8:	6a 85       	ldd	r22, Y+10	; 0x0a
    5daa:	7b 85       	ldd	r23, Y+11	; 0x0b
    5dac:	8c 85       	ldd	r24, Y+12	; 0x0c
    5dae:	9d 85       	ldd	r25, Y+13	; 0x0d
    5db0:	20 e0       	ldi	r18, 0x00	; 0
    5db2:	30 e0       	ldi	r19, 0x00	; 0
    5db4:	4a e7       	ldi	r20, 0x7A	; 122
    5db6:	53 e4       	ldi	r21, 0x43	; 67
    5db8:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5dbc:	dc 01       	movw	r26, r24
    5dbe:	cb 01       	movw	r24, r22
    5dc0:	8e 87       	std	Y+14, r24	; 0x0e
    5dc2:	9f 87       	std	Y+15, r25	; 0x0f
    5dc4:	a8 8b       	std	Y+16, r26	; 0x10
    5dc6:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5dc8:	11 e0       	ldi	r17, 0x01	; 1
    5dca:	6e 85       	ldd	r22, Y+14	; 0x0e
    5dcc:	7f 85       	ldd	r23, Y+15	; 0x0f
    5dce:	88 89       	ldd	r24, Y+16	; 0x10
    5dd0:	99 89       	ldd	r25, Y+17	; 0x11
    5dd2:	20 e0       	ldi	r18, 0x00	; 0
    5dd4:	30 e0       	ldi	r19, 0x00	; 0
    5dd6:	40 e8       	ldi	r20, 0x80	; 128
    5dd8:	5f e3       	ldi	r21, 0x3F	; 63
    5dda:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    5dde:	88 23       	and	r24, r24
    5de0:	0c f0       	brlt	.+2      	; 0x5de4 <chb_sleep+0x11a>
    5de2:	10 e0       	ldi	r17, 0x00	; 0
    5de4:	11 23       	and	r17, r17
    5de6:	29 f0       	breq	.+10     	; 0x5df2 <chb_sleep+0x128>
		__ticks = 1;
    5de8:	81 e0       	ldi	r24, 0x01	; 1
    5dea:	90 e0       	ldi	r25, 0x00	; 0
    5dec:	8a 8b       	std	Y+18, r24	; 0x12
    5dee:	9b 8b       	std	Y+19, r25	; 0x13
    5df0:	46 c0       	rjmp	.+140    	; 0x5e7e <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5df2:	11 e0       	ldi	r17, 0x01	; 1
    5df4:	6e 85       	ldd	r22, Y+14	; 0x0e
    5df6:	7f 85       	ldd	r23, Y+15	; 0x0f
    5df8:	88 89       	ldd	r24, Y+16	; 0x10
    5dfa:	99 89       	ldd	r25, Y+17	; 0x11
    5dfc:	20 e0       	ldi	r18, 0x00	; 0
    5dfe:	3f ef       	ldi	r19, 0xFF	; 255
    5e00:	4f e7       	ldi	r20, 0x7F	; 127
    5e02:	57 e4       	ldi	r21, 0x47	; 71
    5e04:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    5e08:	18 16       	cp	r1, r24
    5e0a:	0c f0       	brlt	.+2      	; 0x5e0e <chb_sleep+0x144>
    5e0c:	10 e0       	ldi	r17, 0x00	; 0
    5e0e:	11 23       	and	r17, r17
    5e10:	61 f1       	breq	.+88     	; 0x5e6a <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5e12:	6a 85       	ldd	r22, Y+10	; 0x0a
    5e14:	7b 85       	ldd	r23, Y+11	; 0x0b
    5e16:	8c 85       	ldd	r24, Y+12	; 0x0c
    5e18:	9d 85       	ldd	r25, Y+13	; 0x0d
    5e1a:	20 e0       	ldi	r18, 0x00	; 0
    5e1c:	30 e0       	ldi	r19, 0x00	; 0
    5e1e:	40 e2       	ldi	r20, 0x20	; 32
    5e20:	51 e4       	ldi	r21, 0x41	; 65
    5e22:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    5e26:	dc 01       	movw	r26, r24
    5e28:	cb 01       	movw	r24, r22
    5e2a:	bc 01       	movw	r22, r24
    5e2c:	cd 01       	movw	r24, r26
    5e2e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5e32:	dc 01       	movw	r26, r24
    5e34:	cb 01       	movw	r24, r22
    5e36:	8a 8b       	std	Y+18, r24	; 0x12
    5e38:	9b 8b       	std	Y+19, r25	; 0x13
    5e3a:	12 c0       	rjmp	.+36     	; 0x5e60 <chb_sleep+0x196>
    5e3c:	89 e1       	ldi	r24, 0x19	; 25
    5e3e:	90 e0       	ldi	r25, 0x00	; 0
    5e40:	8c 8b       	std	Y+20, r24	; 0x14
    5e42:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5e44:	8c 89       	ldd	r24, Y+20	; 0x14
    5e46:	9d 89       	ldd	r25, Y+21	; 0x15
    5e48:	8c 01       	movw	r16, r24
    5e4a:	c8 01       	movw	r24, r16
    5e4c:	01 97       	sbiw	r24, 0x01	; 1
    5e4e:	f1 f7       	brne	.-4      	; 0x5e4c <chb_sleep+0x182>
    5e50:	8c 01       	movw	r16, r24
    5e52:	0c 8b       	std	Y+20, r16	; 0x14
    5e54:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5e56:	8a 89       	ldd	r24, Y+18	; 0x12
    5e58:	9b 89       	ldd	r25, Y+19	; 0x13
    5e5a:	01 97       	sbiw	r24, 0x01	; 1
    5e5c:	8a 8b       	std	Y+18, r24	; 0x12
    5e5e:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5e60:	8a 89       	ldd	r24, Y+18	; 0x12
    5e62:	9b 89       	ldd	r25, Y+19	; 0x13
    5e64:	00 97       	sbiw	r24, 0x00	; 0
    5e66:	51 f7       	brne	.-44     	; 0x5e3c <chb_sleep+0x172>
    5e68:	28 c0       	rjmp	.+80     	; 0x5eba <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5e6a:	6e 85       	ldd	r22, Y+14	; 0x0e
    5e6c:	7f 85       	ldd	r23, Y+15	; 0x0f
    5e6e:	88 89       	ldd	r24, Y+16	; 0x10
    5e70:	99 89       	ldd	r25, Y+17	; 0x11
    5e72:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5e76:	dc 01       	movw	r26, r24
    5e78:	cb 01       	movw	r24, r22
    5e7a:	8a 8b       	std	Y+18, r24	; 0x12
    5e7c:	9b 8b       	std	Y+19, r25	; 0x13
    5e7e:	8a 89       	ldd	r24, Y+18	; 0x12
    5e80:	9b 89       	ldd	r25, Y+19	; 0x13
    5e82:	8e 8b       	std	Y+22, r24	; 0x16
    5e84:	9f 8b       	std	Y+23, r25	; 0x17
    5e86:	8e 89       	ldd	r24, Y+22	; 0x16
    5e88:	9f 89       	ldd	r25, Y+23	; 0x17
    5e8a:	8c 01       	movw	r16, r24
    5e8c:	f8 01       	movw	r30, r16
    5e8e:	31 97       	sbiw	r30, 0x01	; 1
    5e90:	f1 f7       	brne	.-4      	; 0x5e8e <chb_sleep+0x1c4>
    5e92:	8f 01       	movw	r16, r30
    5e94:	0e 8b       	std	Y+22, r16	; 0x16
    5e96:	1f 8b       	std	Y+23, r17	; 0x17
    5e98:	10 c0       	rjmp	.+32     	; 0x5eba <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5e9a:	6d 81       	ldd	r22, Y+5	; 0x05
    5e9c:	7e 81       	ldd	r23, Y+6	; 0x06
    5e9e:	8f 81       	ldd	r24, Y+7	; 0x07
    5ea0:	98 85       	ldd	r25, Y+8	; 0x08
    5ea2:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    5ea6:	dc 01       	movw	r26, r24
    5ea8:	cb 01       	movw	r24, r22
    5eaa:	89 87       	std	Y+9, r24	; 0x09
    5eac:	89 85       	ldd	r24, Y+9	; 0x09
    5eae:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5eb0:	88 8d       	ldd	r24, Y+24	; 0x18
    5eb2:	18 2f       	mov	r17, r24
    5eb4:	1a 95       	dec	r17
    5eb6:	f1 f7       	brne	.-4      	; 0x5eb4 <chb_sleep+0x1ea>
    5eb8:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5eba:	86 e1       	ldi	r24, 0x16	; 22
    5ebc:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <chb_set_state>
    }
}
    5ec0:	69 96       	adiw	r28, 0x19	; 25
    5ec2:	cd bf       	out	0x3d, r28	; 61
    5ec4:	de bf       	out	0x3e, r29	; 62
    5ec6:	df 91       	pop	r29
    5ec8:	cf 91       	pop	r28
    5eca:	1f 91       	pop	r17
    5ecc:	0f 91       	pop	r16
    5ece:	08 95       	ret

00005ed0 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5ed0:	cf 93       	push	r28
    5ed2:	df 93       	push	r29
    5ed4:	cd b7       	in	r28, 0x3d	; 61
    5ed6:	de b7       	in	r29, 0x3e	; 62
    5ed8:	ea 97       	sbiw	r28, 0x3a	; 58
    5eda:	cd bf       	out	0x3d, r28	; 61
    5edc:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5ede:	0e 94 a5 23 	call	0x474a	; 0x474a <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5ee2:	8e e0       	ldi	r24, 0x0E	; 14
    5ee4:	60 e0       	ldi	r22, 0x00	; 0
    5ee6:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5eea:	82 e0       	ldi	r24, 0x02	; 2
    5eec:	63 e0       	ldi	r22, 0x03	; 3
    5eee:	4f e1       	ldi	r20, 0x1F	; 31
    5ef0:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5ef4:	00 00       	nop
    5ef6:	81 e0       	ldi	r24, 0x01	; 1
    5ef8:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    5efc:	88 2f       	mov	r24, r24
    5efe:	90 e0       	ldi	r25, 0x00	; 0
    5f00:	8f 71       	andi	r24, 0x1F	; 31
    5f02:	90 70       	andi	r25, 0x00	; 0
    5f04:	88 30       	cpi	r24, 0x08	; 8
    5f06:	91 05       	cpc	r25, r1
    5f08:	b1 f7       	brne	.-20     	; 0x5ef6 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5f0a:	8e e2       	ldi	r24, 0x2E	; 46
    5f0c:	60 e4       	ldi	r22, 0x40	; 64
    5f0e:	40 ec       	ldi	r20, 0xC0	; 192
    5f10:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5f14:	8e e0       	ldi	r24, 0x0E	; 14
    5f16:	6c e0       	ldi	r22, 0x0C	; 12
    5f18:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5f1c:	84 e0       	ldi	r24, 0x04	; 4
    5f1e:	60 e2       	ldi	r22, 0x20	; 32
    5f20:	40 e2       	ldi	r20, 0x20	; 32
    5f22:	0e 94 76 26 	call	0x4cec	; 0x4cec <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5f26:	81 e0       	ldi	r24, 0x01	; 1
    5f28:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5f2c:	81 e0       	ldi	r24, 0x01	; 1
    5f2e:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5f32:	86 e1       	ldi	r24, 0x16	; 22
    5f34:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5f38:	82 e2       	ldi	r24, 0x22	; 34
    5f3a:	64 e3       	ldi	r22, 0x34	; 52
    5f3c:	72 e1       	ldi	r23, 0x12	; 18
    5f3e:	0e 94 1d 26 	call	0x4c3a	; 0x4c3a <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5f42:	0e 94 07 2e 	call	0x5c0e	; 0x5c0e <chb_get_short_addr>
    5f46:	9c 01       	movw	r18, r24
    5f48:	80 e2       	ldi	r24, 0x20	; 32
    5f4a:	b9 01       	movw	r22, r18
    5f4c:	0e 94 1d 26 	call	0x4c3a	; 0x4c3a <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5f50:	ce 01       	movw	r24, r28
    5f52:	01 96       	adiw	r24, 0x01	; 1
    5f54:	0e 94 c5 2d 	call	0x5b8a	; 0x5b8a <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5f58:	84 e2       	ldi	r24, 0x24	; 36
    5f5a:	9e 01       	movw	r18, r28
    5f5c:	2f 5f       	subi	r18, 0xFF	; 255
    5f5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5f60:	b9 01       	movw	r22, r18
    5f62:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5f66:	82 e7       	ldi	r24, 0x72	; 114
    5f68:	96 e0       	ldi	r25, 0x06	; 6
    5f6a:	22 e7       	ldi	r18, 0x72	; 114
    5f6c:	36 e0       	ldi	r19, 0x06	; 6
    5f6e:	f9 01       	movw	r30, r18
    5f70:	20 81       	ld	r18, Z
    5f72:	21 60       	ori	r18, 0x01	; 1
    5f74:	fc 01       	movw	r30, r24
    5f76:	20 83       	st	Z, r18
    5f78:	89 e6       	ldi	r24, 0x69	; 105
    5f7a:	96 e0       	ldi	r25, 0x06	; 6
    5f7c:	29 e6       	ldi	r18, 0x69	; 105
    5f7e:	36 e0       	ldi	r19, 0x06	; 6
    5f80:	f9 01       	movw	r30, r18
    5f82:	20 81       	ld	r18, Z
    5f84:	22 60       	ori	r18, 0x02	; 2
    5f86:	fc 01       	movw	r30, r24
    5f88:	20 83       	st	Z, r18
    5f8a:	8a e6       	ldi	r24, 0x6A	; 106
    5f8c:	96 e0       	ldi	r25, 0x06	; 6
    5f8e:	2a e6       	ldi	r18, 0x6A	; 106
    5f90:	36 e0       	ldi	r19, 0x06	; 6
    5f92:	f9 01       	movw	r30, r18
    5f94:	20 81       	ld	r18, Z
    5f96:	24 60       	ori	r18, 0x04	; 4
    5f98:	fc 01       	movw	r30, r24
    5f9a:	20 83       	st	Z, r18
	PMIC.CTRL = 0x07;	//enable interrupts on MCU
    5f9c:	80 ea       	ldi	r24, 0xA0	; 160
    5f9e:	90 e0       	ldi	r25, 0x00	; 0
    5fa0:	27 e0       	ldi	r18, 0x07	; 7
    5fa2:	fc 01       	movw	r30, r24
    5fa4:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5fa6:	0e 94 8d 23 	call	0x471a	; 0x471a <chb_get_state>
    5faa:	86 31       	cpi	r24, 0x16	; 22
    5fac:	b1 f0       	breq	.+44     	; 0x5fda <chb_radio_init+0x10a>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5fae:	ce 01       	movw	r24, r28
    5fb0:	09 96       	adiw	r24, 0x09	; 9
    5fb2:	2c e0       	ldi	r18, 0x0C	; 12
    5fb4:	32 e0       	ldi	r19, 0x02	; 2
    5fb6:	b9 01       	movw	r22, r18
    5fb8:	0e 94 13 5f 	call	0xbe26	; 0xbe26 <strcpy_P>
        printf(buf);
    5fbc:	0f 92       	push	r0
    5fbe:	0f 92       	push	r0
    5fc0:	8d b7       	in	r24, 0x3d	; 61
    5fc2:	9e b7       	in	r25, 0x3e	; 62
    5fc4:	01 96       	adiw	r24, 0x01	; 1
    5fc6:	9e 01       	movw	r18, r28
    5fc8:	27 5f       	subi	r18, 0xF7	; 247
    5fca:	3f 4f       	sbci	r19, 0xFF	; 255
    5fcc:	fc 01       	movw	r30, r24
    5fce:	20 83       	st	Z, r18
    5fd0:	31 83       	std	Z+1, r19	; 0x01
    5fd2:	0e 94 6d 5f 	call	0xbeda	; 0xbeda <printf>
    5fd6:	0f 90       	pop	r0
    5fd8:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5fda:	10 92 d0 50 	sts	0x50D0, r1
    5fde:	10 92 d1 50 	sts	0x50D1, r1
    5fe2:	10 92 d2 50 	sts	0x50D2, r1
    5fe6:	10 92 d3 50 	sts	0x50D3, r1
}
    5fea:	ea 96       	adiw	r28, 0x3a	; 58
    5fec:	cd bf       	out	0x3d, r28	; 61
    5fee:	de bf       	out	0x3e, r29	; 62
    5ff0:	df 91       	pop	r29
    5ff2:	cf 91       	pop	r28
    5ff4:	08 95       	ret

00005ff6 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5ff6:	cf 93       	push	r28
    5ff8:	df 93       	push	r29
    5ffa:	cd b7       	in	r28, 0x3d	; 61
    5ffc:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5ffe:	0e 94 44 32 	call	0x6488	; 0x6488 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    6002:	80 e6       	ldi	r24, 0x60	; 96
    6004:	96 e0       	ldi	r25, 0x06	; 6
    6006:	20 e6       	ldi	r18, 0x60	; 96
    6008:	36 e0       	ldi	r19, 0x06	; 6
    600a:	f9 01       	movw	r30, r18
    600c:	20 81       	ld	r18, Z
    600e:	22 60       	ori	r18, 0x02	; 2
    6010:	fc 01       	movw	r30, r24
    6012:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    6014:	80 e6       	ldi	r24, 0x60	; 96
    6016:	96 e0       	ldi	r25, 0x06	; 6
    6018:	20 e6       	ldi	r18, 0x60	; 96
    601a:	36 e0       	ldi	r19, 0x06	; 6
    601c:	f9 01       	movw	r30, r18
    601e:	20 81       	ld	r18, Z
    6020:	21 60       	ori	r18, 0x01	; 1
    6022:	fc 01       	movw	r30, r24
    6024:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    6026:	0e 94 68 2f 	call	0x5ed0	; 0x5ed0 <chb_radio_init>
}
    602a:	df 91       	pop	r29
    602c:	cf 91       	pop	r28
    602e:	08 95       	ret

00006030 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    6030:	1f 92       	push	r1
    6032:	0f 92       	push	r0
    6034:	0f b6       	in	r0, 0x3f	; 63
    6036:	0f 92       	push	r0
    6038:	00 90 3b 00 	lds	r0, 0x003B
    603c:	0f 92       	push	r0
    603e:	11 24       	eor	r1, r1
    6040:	2f 93       	push	r18
    6042:	3f 93       	push	r19
    6044:	4f 93       	push	r20
    6046:	5f 93       	push	r21
    6048:	6f 93       	push	r22
    604a:	7f 93       	push	r23
    604c:	8f 93       	push	r24
    604e:	9f 93       	push	r25
    6050:	af 93       	push	r26
    6052:	bf 93       	push	r27
    6054:	ef 93       	push	r30
    6056:	ff 93       	push	r31
    6058:	cf 93       	push	r28
    605a:	df 93       	push	r29
    605c:	cd b7       	in	r28, 0x3d	; 61
    605e:	de b7       	in	r29, 0x3e	; 62
    6060:	25 97       	sbiw	r28, 0x05	; 5
    6062:	cd bf       	out	0x3d, r28	; 61
    6064:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    6066:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    6068:	0e 94 8a 20 	call	0x4114	; 0x4114 <chb_get_pcb>
    606c:	8a 83       	std	Y+2, r24	; 0x02
    606e:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    6070:	8f e3       	ldi	r24, 0x3F	; 63
    6072:	90 e0       	ldi	r25, 0x00	; 0
    6074:	fc 01       	movw	r30, r24
    6076:	80 81       	ld	r24, Z
    6078:	80 93 4b 40 	sts	0x404B, r24
    607c:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    607e:	81 e0       	ldi	r24, 0x01	; 1
    6080:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    6084:	8f e8       	ldi	r24, 0x8F	; 143
    6086:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    608a:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    608c:	80 e0       	ldi	r24, 0x00	; 0
    608e:	0e 94 6f 32 	call	0x64de	; 0x64de <SPID_write>
    6092:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    6094:	80 e0       	ldi	r24, 0x00	; 0
    6096:	0e 94 12 31 	call	0x6224	; 0x6224 <RadioCS>

    while (intp_src)
    609a:	9d c0       	rjmp	.+314    	; 0x61d6 <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    609c:	89 81       	ldd	r24, Y+1	; 0x01
    609e:	88 2f       	mov	r24, r24
    60a0:	90 e0       	ldi	r25, 0x00	; 0
    60a2:	84 70       	andi	r24, 0x04	; 4
    60a4:	90 70       	andi	r25, 0x00	; 0
    60a6:	00 97       	sbiw	r24, 0x00	; 0
    60a8:	21 f0       	breq	.+8      	; 0x60b2 <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    60aa:	89 81       	ldd	r24, Y+1	; 0x01
    60ac:	8b 7f       	andi	r24, 0xFB	; 251
    60ae:	89 83       	std	Y+1, r24	; 0x01
    60b0:	92 c0       	rjmp	.+292    	; 0x61d6 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    60b2:	89 81       	ldd	r24, Y+1	; 0x01
    60b4:	88 2f       	mov	r24, r24
    60b6:	90 e0       	ldi	r25, 0x00	; 0
    60b8:	88 70       	andi	r24, 0x08	; 8
    60ba:	90 70       	andi	r25, 0x00	; 0
    60bc:	00 97       	sbiw	r24, 0x00	; 0
    60be:	09 f4       	brne	.+2      	; 0x60c2 <__vector_64+0x92>
    60c0:	4c c0       	rjmp	.+152    	; 0x615a <__vector_64+0x12a>
        {
            state = chb_get_state();
    60c2:	0e 94 8d 23 	call	0x471a	; 0x471a <chb_get_state>
    60c6:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    60c8:	8d 81       	ldd	r24, Y+5	; 0x05
    60ca:	86 30       	cpi	r24, 0x06	; 6
    60cc:	31 f0       	breq	.+12     	; 0x60da <__vector_64+0xaa>
    60ce:	8d 81       	ldd	r24, Y+5	; 0x05
    60d0:	86 31       	cpi	r24, 0x16	; 22
    60d2:	19 f0       	breq	.+6      	; 0x60da <__vector_64+0xaa>
    60d4:	8d 81       	ldd	r24, Y+5	; 0x05
    60d6:	81 31       	cpi	r24, 0x11	; 17
    60d8:	89 f5       	brne	.+98     	; 0x613c <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    60da:	88 e0       	ldi	r24, 0x08	; 8
    60dc:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    60e0:	87 e0       	ldi	r24, 0x07	; 7
    60e2:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    60e6:	28 2f       	mov	r18, r24
    60e8:	8a 81       	ldd	r24, Y+2	; 0x02
    60ea:	9b 81       	ldd	r25, Y+3	; 0x03
    60ec:	fc 01       	movw	r30, r24
    60ee:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    60f0:	86 e0       	ldi	r24, 0x06	; 6
    60f2:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
    60f6:	28 2f       	mov	r18, r24
    60f8:	22 1f       	adc	r18, r18
    60fa:	22 27       	eor	r18, r18
    60fc:	22 1f       	adc	r18, r18
    60fe:	8a 81       	ldd	r24, Y+2	; 0x02
    6100:	9b 81       	ldd	r25, Y+3	; 0x03
    6102:	fc 01       	movw	r30, r24
    6104:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    6106:	8a 81       	ldd	r24, Y+2	; 0x02
    6108:	9b 81       	ldd	r25, Y+3	; 0x03
    610a:	fc 01       	movw	r30, r24
    610c:	83 89       	ldd	r24, Z+19	; 0x13
    610e:	88 23       	and	r24, r24
    6110:	d1 f0       	breq	.+52     	; 0x6146 <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    6112:	0e 94 00 27 	call	0x4e00	; 0x4e00 <chb_frame_read>
                    pcb->rcvd_xfers++;
    6116:	8a 81       	ldd	r24, Y+2	; 0x02
    6118:	9b 81       	ldd	r25, Y+3	; 0x03
    611a:	fc 01       	movw	r30, r24
    611c:	85 81       	ldd	r24, Z+5	; 0x05
    611e:	96 81       	ldd	r25, Z+6	; 0x06
    6120:	9c 01       	movw	r18, r24
    6122:	2f 5f       	subi	r18, 0xFF	; 255
    6124:	3f 4f       	sbci	r19, 0xFF	; 255
    6126:	8a 81       	ldd	r24, Y+2	; 0x02
    6128:	9b 81       	ldd	r25, Y+3	; 0x03
    612a:	fc 01       	movw	r30, r24
    612c:	25 83       	std	Z+5, r18	; 0x05
    612e:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    6130:	8a 81       	ldd	r24, Y+2	; 0x02
    6132:	9b 81       	ldd	r25, Y+3	; 0x03
    6134:	21 e0       	ldi	r18, 0x01	; 1
    6136:	fc 01       	movw	r30, r24
    6138:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    613a:	05 c0       	rjmp	.+10     	; 0x6146 <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    613c:	8a 81       	ldd	r24, Y+2	; 0x02
    613e:	9b 81       	ldd	r25, Y+3	; 0x03
    6140:	21 e0       	ldi	r18, 0x01	; 1
    6142:	fc 01       	movw	r30, r24
    6144:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    6146:	89 81       	ldd	r24, Y+1	; 0x01
    6148:	87 7f       	andi	r24, 0xF7	; 247
    614a:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    614c:	00 00       	nop
    614e:	86 e1       	ldi	r24, 0x16	; 22
    6150:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <chb_set_state>
    6154:	80 34       	cpi	r24, 0x40	; 64
    6156:	d9 f7       	brne	.-10     	; 0x614e <__vector_64+0x11e>
    6158:	3e c0       	rjmp	.+124    	; 0x61d6 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    615a:	89 81       	ldd	r24, Y+1	; 0x01
    615c:	88 2f       	mov	r24, r24
    615e:	90 e0       	ldi	r25, 0x00	; 0
    6160:	80 74       	andi	r24, 0x40	; 64
    6162:	90 70       	andi	r25, 0x00	; 0
    6164:	00 97       	sbiw	r24, 0x00	; 0
    6166:	89 f0       	breq	.+34     	; 0x618a <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    6168:	89 81       	ldd	r24, Y+1	; 0x01
    616a:	8f 7b       	andi	r24, 0xBF	; 191
    616c:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    616e:	8a 81       	ldd	r24, Y+2	; 0x02
    6170:	9b 81       	ldd	r25, Y+3	; 0x03
    6172:	fc 01       	movw	r30, r24
    6174:	87 85       	ldd	r24, Z+15	; 0x0f
    6176:	90 89       	ldd	r25, Z+16	; 0x10
    6178:	9c 01       	movw	r18, r24
    617a:	2f 5f       	subi	r18, 0xFF	; 255
    617c:	3f 4f       	sbci	r19, 0xFF	; 255
    617e:	8a 81       	ldd	r24, Y+2	; 0x02
    6180:	9b 81       	ldd	r25, Y+3	; 0x03
    6182:	fc 01       	movw	r30, r24
    6184:	27 87       	std	Z+15, r18	; 0x0f
    6186:	30 8b       	std	Z+16, r19	; 0x10
    6188:	26 c0       	rjmp	.+76     	; 0x61d6 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    618a:	89 81       	ldd	r24, Y+1	; 0x01
    618c:	88 2f       	mov	r24, r24
    618e:	90 e0       	ldi	r25, 0x00	; 0
    6190:	82 70       	andi	r24, 0x02	; 2
    6192:	90 70       	andi	r25, 0x00	; 0
    6194:	00 97       	sbiw	r24, 0x00	; 0
    6196:	21 f0       	breq	.+8      	; 0x61a0 <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    6198:	89 81       	ldd	r24, Y+1	; 0x01
    619a:	8d 7f       	andi	r24, 0xFD	; 253
    619c:	89 83       	std	Y+1, r24	; 0x01
    619e:	1b c0       	rjmp	.+54     	; 0x61d6 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    61a0:	89 81       	ldd	r24, Y+1	; 0x01
    61a2:	88 2f       	mov	r24, r24
    61a4:	90 e0       	ldi	r25, 0x00	; 0
    61a6:	81 70       	andi	r24, 0x01	; 1
    61a8:	90 70       	andi	r25, 0x00	; 0
    61aa:	88 23       	and	r24, r24
    61ac:	21 f0       	breq	.+8      	; 0x61b6 <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    61ae:	89 81       	ldd	r24, Y+1	; 0x01
    61b0:	8e 7f       	andi	r24, 0xFE	; 254
    61b2:	89 83       	std	Y+1, r24	; 0x01
    61b4:	10 c0       	rjmp	.+32     	; 0x61d6 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    61b6:	89 81       	ldd	r24, Y+1	; 0x01
    61b8:	88 23       	and	r24, r24
    61ba:	6c f4       	brge	.+26     	; 0x61d6 <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    61bc:	89 81       	ldd	r24, Y+1	; 0x01
    61be:	8f 77       	andi	r24, 0x7F	; 127
    61c0:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    61c2:	8a 81       	ldd	r24, Y+2	; 0x02
    61c4:	9b 81       	ldd	r25, Y+3	; 0x03
    61c6:	fc 01       	movw	r30, r24
    61c8:	81 89       	ldd	r24, Z+17	; 0x11
    61ca:	28 2f       	mov	r18, r24
    61cc:	2f 5f       	subi	r18, 0xFF	; 255
    61ce:	8a 81       	ldd	r24, Y+2	; 0x02
    61d0:	9b 81       	ldd	r25, Y+3	; 0x03
    61d2:	fc 01       	movw	r30, r24
    61d4:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    61d6:	89 81       	ldd	r24, Y+1	; 0x01
    61d8:	88 23       	and	r24, r24
    61da:	09 f0       	breq	.+2      	; 0x61de <__vector_64+0x1ae>
    61dc:	5f cf       	rjmp	.-322    	; 0x609c <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    61de:	8f e3       	ldi	r24, 0x3F	; 63
    61e0:	90 e0       	ldi	r25, 0x00	; 0
    61e2:	20 91 4b 40 	lds	r18, 0x404B
    61e6:	fc 01       	movw	r30, r24
    61e8:	20 83       	st	Z, r18
    61ea:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    61ec:	8f e0       	ldi	r24, 0x0F	; 15
    61ee:	0e 94 91 25 	call	0x4b22	; 0x4b22 <chb_reg_read>
}
    61f2:	25 96       	adiw	r28, 0x05	; 5
    61f4:	cd bf       	out	0x3d, r28	; 61
    61f6:	de bf       	out	0x3e, r29	; 62
    61f8:	df 91       	pop	r29
    61fa:	cf 91       	pop	r28
    61fc:	ff 91       	pop	r31
    61fe:	ef 91       	pop	r30
    6200:	bf 91       	pop	r27
    6202:	af 91       	pop	r26
    6204:	9f 91       	pop	r25
    6206:	8f 91       	pop	r24
    6208:	7f 91       	pop	r23
    620a:	6f 91       	pop	r22
    620c:	5f 91       	pop	r21
    620e:	4f 91       	pop	r20
    6210:	3f 91       	pop	r19
    6212:	2f 91       	pop	r18
    6214:	0f 90       	pop	r0
    6216:	00 92 3b 00 	sts	0x003B, r0
    621a:	0f 90       	pop	r0
    621c:	0f be       	out	0x3f, r0	; 63
    621e:	0f 90       	pop	r0
    6220:	1f 90       	pop	r1
    6222:	18 95       	reti

00006224 <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    6224:	cf 93       	push	r28
    6226:	df 93       	push	r29
    6228:	0f 92       	push	r0
    622a:	cd b7       	in	r28, 0x3d	; 61
    622c:	de b7       	in	r29, 0x3e	; 62
    622e:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    6230:	89 81       	ldd	r24, Y+1	; 0x01
    6232:	88 23       	and	r24, r24
    6234:	31 f0       	breq	.+12     	; 0x6242 <RadioCS+0x1e>
    6236:	80 e6       	ldi	r24, 0x60	; 96
    6238:	96 e0       	ldi	r25, 0x06	; 6
    623a:	20 e1       	ldi	r18, 0x10	; 16
    623c:	fc 01       	movw	r30, r24
    623e:	26 83       	std	Z+6, r18	; 0x06
    6240:	05 c0       	rjmp	.+10     	; 0x624c <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    6242:	80 e6       	ldi	r24, 0x60	; 96
    6244:	96 e0       	ldi	r25, 0x06	; 6
    6246:	20 e1       	ldi	r18, 0x10	; 16
    6248:	fc 01       	movw	r30, r24
    624a:	25 83       	std	Z+5, r18	; 0x05
	}
    624c:	0f 90       	pop	r0
    624e:	df 91       	pop	r29
    6250:	cf 91       	pop	r28
    6252:	08 95       	ret

00006254 <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    6254:	cf 93       	push	r28
    6256:	df 93       	push	r29
    6258:	00 d0       	rcall	.+0      	; 0x625a <chb_eep_write_byte+0x6>
    625a:	cd b7       	in	r28, 0x3d	; 61
    625c:	de b7       	in	r29, 0x3e	; 62
    625e:	89 83       	std	Y+1, r24	; 0x01
    6260:	9a 83       	std	Y+2, r25	; 0x02
    6262:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    6264:	00 00       	nop
    6266:	80 ec       	ldi	r24, 0xC0	; 192
    6268:	91 e0       	ldi	r25, 0x01	; 1
    626a:	fc 01       	movw	r30, r24
    626c:	87 85       	ldd	r24, Z+15	; 0x0f
    626e:	88 23       	and	r24, r24
    6270:	d4 f3       	brlt	.-12     	; 0x6266 <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    6272:	80 ec       	ldi	r24, 0xC0	; 192
    6274:	91 e0       	ldi	r25, 0x01	; 1
    6276:	fc 01       	movw	r30, r24
    6278:	87 85       	ldd	r24, Z+15	; 0x0f
    627a:	88 2f       	mov	r24, r24
    627c:	90 e0       	ldi	r25, 0x00	; 0
    627e:	82 70       	andi	r24, 0x02	; 2
    6280:	90 70       	andi	r25, 0x00	; 0
    6282:	00 97       	sbiw	r24, 0x00	; 0
    6284:	99 f0       	breq	.+38     	; 0x62ac <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    6286:	80 ec       	ldi	r24, 0xC0	; 192
    6288:	91 e0       	ldi	r25, 0x01	; 1
    628a:	26 e3       	ldi	r18, 0x36	; 54
    628c:	fc 01       	movw	r30, r24
    628e:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    6290:	ef 93       	push	r30
    6292:	ff 93       	push	r31
    6294:	0f 93       	push	r16
    6296:	2f 93       	push	r18
    6298:	eb ec       	ldi	r30, 0xCB	; 203
    629a:	f1 e0       	ldi	r31, 0x01	; 1
    629c:	08 ed       	ldi	r16, 0xD8	; 216
    629e:	21 e0       	ldi	r18, 0x01	; 1
    62a0:	04 bf       	out	0x34, r16	; 52
    62a2:	20 83       	st	Z, r18
    62a4:	2f 91       	pop	r18
    62a6:	0f 91       	pop	r16
    62a8:	ff 91       	pop	r31
    62aa:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    62ac:	80 ec       	ldi	r24, 0xC0	; 192
    62ae:	91 e0       	ldi	r25, 0x01	; 1
    62b0:	23 e3       	ldi	r18, 0x33	; 51
    62b2:	fc 01       	movw	r30, r24
    62b4:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    62b6:	80 ec       	ldi	r24, 0xC0	; 192
    62b8:	91 e0       	ldi	r25, 0x01	; 1
    62ba:	29 81       	ldd	r18, Y+1	; 0x01
    62bc:	fc 01       	movw	r30, r24
    62be:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    62c0:	80 ec       	ldi	r24, 0xC0	; 192
    62c2:	91 e0       	ldi	r25, 0x01	; 1
    62c4:	29 81       	ldd	r18, Y+1	; 0x01
    62c6:	3a 81       	ldd	r19, Y+2	; 0x02
    62c8:	23 2f       	mov	r18, r19
    62ca:	33 27       	eor	r19, r19
    62cc:	2f 71       	andi	r18, 0x1F	; 31
    62ce:	fc 01       	movw	r30, r24
    62d0:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    62d2:	80 ec       	ldi	r24, 0xC0	; 192
    62d4:	91 e0       	ldi	r25, 0x01	; 1
    62d6:	fc 01       	movw	r30, r24
    62d8:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    62da:	80 ec       	ldi	r24, 0xC0	; 192
    62dc:	91 e0       	ldi	r25, 0x01	; 1
    62de:	2b 81       	ldd	r18, Y+3	; 0x03
    62e0:	fc 01       	movw	r30, r24
    62e2:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    62e4:	80 ec       	ldi	r24, 0xC0	; 192
    62e6:	91 e0       	ldi	r25, 0x01	; 1
    62e8:	25 e3       	ldi	r18, 0x35	; 53
    62ea:	fc 01       	movw	r30, r24
    62ec:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    62ee:	ef 93       	push	r30
    62f0:	ff 93       	push	r31
    62f2:	0f 93       	push	r16
    62f4:	2f 93       	push	r18
    62f6:	eb ec       	ldi	r30, 0xCB	; 203
    62f8:	f1 e0       	ldi	r31, 0x01	; 1
    62fa:	08 ed       	ldi	r16, 0xD8	; 216
    62fc:	21 e0       	ldi	r18, 0x01	; 1
    62fe:	04 bf       	out	0x34, r16	; 52
    6300:	20 83       	st	Z, r18
    6302:	2f 91       	pop	r18
    6304:	0f 91       	pop	r16
    6306:	ff 91       	pop	r31
    6308:	ef 91       	pop	r30
}
    630a:	23 96       	adiw	r28, 0x03	; 3
    630c:	cd bf       	out	0x3d, r28	; 61
    630e:	de bf       	out	0x3e, r29	; 62
    6310:	df 91       	pop	r29
    6312:	cf 91       	pop	r28
    6314:	08 95       	ret

00006316 <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    6316:	cf 93       	push	r28
    6318:	df 93       	push	r29
    631a:	0f 92       	push	r0
    631c:	0f 92       	push	r0
    631e:	cd b7       	in	r28, 0x3d	; 61
    6320:	de b7       	in	r29, 0x3e	; 62
    6322:	89 83       	std	Y+1, r24	; 0x01
    6324:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    6326:	00 00       	nop
    6328:	80 ec       	ldi	r24, 0xC0	; 192
    632a:	91 e0       	ldi	r25, 0x01	; 1
    632c:	fc 01       	movw	r30, r24
    632e:	87 85       	ldd	r24, Z+15	; 0x0f
    6330:	88 23       	and	r24, r24
    6332:	d4 f3       	brlt	.-12     	; 0x6328 <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    6334:	80 ec       	ldi	r24, 0xC0	; 192
    6336:	91 e0       	ldi	r25, 0x01	; 1
    6338:	29 81       	ldd	r18, Y+1	; 0x01
    633a:	fc 01       	movw	r30, r24
    633c:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    633e:	80 ec       	ldi	r24, 0xC0	; 192
    6340:	91 e0       	ldi	r25, 0x01	; 1
    6342:	29 81       	ldd	r18, Y+1	; 0x01
    6344:	3a 81       	ldd	r19, Y+2	; 0x02
    6346:	23 2f       	mov	r18, r19
    6348:	33 27       	eor	r19, r19
    634a:	2f 71       	andi	r18, 0x1F	; 31
    634c:	fc 01       	movw	r30, r24
    634e:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    6350:	80 ec       	ldi	r24, 0xC0	; 192
    6352:	91 e0       	ldi	r25, 0x01	; 1
    6354:	fc 01       	movw	r30, r24
    6356:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    6358:	80 ec       	ldi	r24, 0xC0	; 192
    635a:	91 e0       	ldi	r25, 0x01	; 1
    635c:	26 e0       	ldi	r18, 0x06	; 6
    635e:	fc 01       	movw	r30, r24
    6360:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    6362:	ef 93       	push	r30
    6364:	ff 93       	push	r31
    6366:	0f 93       	push	r16
    6368:	2f 93       	push	r18
    636a:	eb ec       	ldi	r30, 0xCB	; 203
    636c:	f1 e0       	ldi	r31, 0x01	; 1
    636e:	08 ed       	ldi	r16, 0xD8	; 216
    6370:	21 e0       	ldi	r18, 0x01	; 1
    6372:	04 bf       	out	0x34, r16	; 52
    6374:	20 83       	st	Z, r18
    6376:	2f 91       	pop	r18
    6378:	0f 91       	pop	r16
    637a:	ff 91       	pop	r31
    637c:	ef 91       	pop	r30

    return NVM.DATA0;
    637e:	80 ec       	ldi	r24, 0xC0	; 192
    6380:	91 e0       	ldi	r25, 0x01	; 1
    6382:	fc 01       	movw	r30, r24
    6384:	84 81       	ldd	r24, Z+4	; 0x04
}
    6386:	0f 90       	pop	r0
    6388:	0f 90       	pop	r0
    638a:	df 91       	pop	r29
    638c:	cf 91       	pop	r28
    638e:	08 95       	ret

00006390 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    6390:	cf 93       	push	r28
    6392:	df 93       	push	r29
    6394:	cd b7       	in	r28, 0x3d	; 61
    6396:	de b7       	in	r29, 0x3e	; 62
    6398:	27 97       	sbiw	r28, 0x07	; 7
    639a:	cd bf       	out	0x3d, r28	; 61
    639c:	de bf       	out	0x3e, r29	; 62
    639e:	8a 83       	std	Y+2, r24	; 0x02
    63a0:	9b 83       	std	Y+3, r25	; 0x03
    63a2:	6c 83       	std	Y+4, r22	; 0x04
    63a4:	7d 83       	std	Y+5, r23	; 0x05
    63a6:	4e 83       	std	Y+6, r20	; 0x06
    63a8:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    63aa:	80 ec       	ldi	r24, 0xC0	; 192
    63ac:	91 e0       	ldi	r25, 0x01	; 1
    63ae:	20 ec       	ldi	r18, 0xC0	; 192
    63b0:	31 e0       	ldi	r19, 0x01	; 1
    63b2:	f9 01       	movw	r30, r18
    63b4:	24 85       	ldd	r18, Z+12	; 0x0c
    63b6:	27 7f       	andi	r18, 0xF7	; 247
    63b8:	fc 01       	movw	r30, r24
    63ba:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    63bc:	19 82       	std	Y+1, r1	; 0x01
    63be:	16 c0       	rjmp	.+44     	; 0x63ec <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    63c0:	89 81       	ldd	r24, Y+1	; 0x01
    63c2:	28 2f       	mov	r18, r24
    63c4:	30 e0       	ldi	r19, 0x00	; 0
    63c6:	8a 81       	ldd	r24, Y+2	; 0x02
    63c8:	9b 81       	ldd	r25, Y+3	; 0x03
    63ca:	82 0f       	add	r24, r18
    63cc:	93 1f       	adc	r25, r19
    63ce:	29 81       	ldd	r18, Y+1	; 0x01
    63d0:	22 2f       	mov	r18, r18
    63d2:	30 e0       	ldi	r19, 0x00	; 0
    63d4:	4c 81       	ldd	r20, Y+4	; 0x04
    63d6:	5d 81       	ldd	r21, Y+5	; 0x05
    63d8:	24 0f       	add	r18, r20
    63da:	35 1f       	adc	r19, r21
    63dc:	f9 01       	movw	r30, r18
    63de:	20 81       	ld	r18, Z
    63e0:	62 2f       	mov	r22, r18
    63e2:	0e 94 2a 31 	call	0x6254	; 0x6254 <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    63e6:	89 81       	ldd	r24, Y+1	; 0x01
    63e8:	8f 5f       	subi	r24, 0xFF	; 255
    63ea:	89 83       	std	Y+1, r24	; 0x01
    63ec:	89 81       	ldd	r24, Y+1	; 0x01
    63ee:	28 2f       	mov	r18, r24
    63f0:	30 e0       	ldi	r19, 0x00	; 0
    63f2:	8e 81       	ldd	r24, Y+6	; 0x06
    63f4:	9f 81       	ldd	r25, Y+7	; 0x07
    63f6:	28 17       	cp	r18, r24
    63f8:	39 07       	cpc	r19, r25
    63fa:	10 f3       	brcs	.-60     	; 0x63c0 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    63fc:	27 96       	adiw	r28, 0x07	; 7
    63fe:	cd bf       	out	0x3d, r28	; 61
    6400:	de bf       	out	0x3e, r29	; 62
    6402:	df 91       	pop	r29
    6404:	cf 91       	pop	r28
    6406:	08 95       	ret

00006408 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    6408:	0f 93       	push	r16
    640a:	1f 93       	push	r17
    640c:	cf 93       	push	r28
    640e:	df 93       	push	r29
    6410:	cd b7       	in	r28, 0x3d	; 61
    6412:	de b7       	in	r29, 0x3e	; 62
    6414:	27 97       	sbiw	r28, 0x07	; 7
    6416:	cd bf       	out	0x3d, r28	; 61
    6418:	de bf       	out	0x3e, r29	; 62
    641a:	8a 83       	std	Y+2, r24	; 0x02
    641c:	9b 83       	std	Y+3, r25	; 0x03
    641e:	6c 83       	std	Y+4, r22	; 0x04
    6420:	7d 83       	std	Y+5, r23	; 0x05
    6422:	4e 83       	std	Y+6, r20	; 0x06
    6424:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    6426:	80 ec       	ldi	r24, 0xC0	; 192
    6428:	91 e0       	ldi	r25, 0x01	; 1
    642a:	20 ec       	ldi	r18, 0xC0	; 192
    642c:	31 e0       	ldi	r19, 0x01	; 1
    642e:	f9 01       	movw	r30, r18
    6430:	24 85       	ldd	r18, Z+12	; 0x0c
    6432:	27 7f       	andi	r18, 0xF7	; 247
    6434:	fc 01       	movw	r30, r24
    6436:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6438:	19 82       	std	Y+1, r1	; 0x01
    643a:	16 c0       	rjmp	.+44     	; 0x6468 <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    643c:	89 81       	ldd	r24, Y+1	; 0x01
    643e:	88 2f       	mov	r24, r24
    6440:	90 e0       	ldi	r25, 0x00	; 0
    6442:	2c 81       	ldd	r18, Y+4	; 0x04
    6444:	3d 81       	ldd	r19, Y+5	; 0x05
    6446:	89 01       	movw	r16, r18
    6448:	08 0f       	add	r16, r24
    644a:	19 1f       	adc	r17, r25
    644c:	89 81       	ldd	r24, Y+1	; 0x01
    644e:	28 2f       	mov	r18, r24
    6450:	30 e0       	ldi	r19, 0x00	; 0
    6452:	8a 81       	ldd	r24, Y+2	; 0x02
    6454:	9b 81       	ldd	r25, Y+3	; 0x03
    6456:	82 0f       	add	r24, r18
    6458:	93 1f       	adc	r25, r19
    645a:	0e 94 8b 31 	call	0x6316	; 0x6316 <chb_eep_read_byte>
    645e:	f8 01       	movw	r30, r16
    6460:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6462:	89 81       	ldd	r24, Y+1	; 0x01
    6464:	8f 5f       	subi	r24, 0xFF	; 255
    6466:	89 83       	std	Y+1, r24	; 0x01
    6468:	89 81       	ldd	r24, Y+1	; 0x01
    646a:	28 2f       	mov	r18, r24
    646c:	30 e0       	ldi	r19, 0x00	; 0
    646e:	8e 81       	ldd	r24, Y+6	; 0x06
    6470:	9f 81       	ldd	r25, Y+7	; 0x07
    6472:	28 17       	cp	r18, r24
    6474:	39 07       	cpc	r19, r25
    6476:	10 f3       	brcs	.-60     	; 0x643c <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    6478:	27 96       	adiw	r28, 0x07	; 7
    647a:	cd bf       	out	0x3d, r28	; 61
    647c:	de bf       	out	0x3e, r29	; 62
    647e:	df 91       	pop	r29
    6480:	cf 91       	pop	r28
    6482:	1f 91       	pop	r17
    6484:	0f 91       	pop	r16
    6486:	08 95       	ret

00006488 <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    6488:	cf 93       	push	r28
    648a:	df 93       	push	r29
    648c:	cd b7       	in	r28, 0x3d	; 61
    648e:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    6490:	80 e6       	ldi	r24, 0x60	; 96
    6492:	96 e0       	ldi	r25, 0x06	; 6
    6494:	20 e6       	ldi	r18, 0x60	; 96
    6496:	36 e0       	ldi	r19, 0x06	; 6
    6498:	f9 01       	movw	r30, r18
    649a:	20 81       	ld	r18, Z
    649c:	20 6b       	ori	r18, 0xB0	; 176
    649e:	fc 01       	movw	r30, r24
    64a0:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    64a2:	84 e6       	ldi	r24, 0x64	; 100
    64a4:	96 e0       	ldi	r25, 0x06	; 6
    64a6:	24 e6       	ldi	r18, 0x64	; 100
    64a8:	36 e0       	ldi	r19, 0x06	; 6
    64aa:	f9 01       	movw	r30, r18
    64ac:	20 81       	ld	r18, Z
    64ae:	20 61       	ori	r18, 0x10	; 16
    64b0:	fc 01       	movw	r30, r24
    64b2:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    64b4:	80 ec       	ldi	r24, 0xC0	; 192
    64b6:	99 e0       	ldi	r25, 0x09	; 9
    64b8:	20 ec       	ldi	r18, 0xC0	; 192
    64ba:	39 e0       	ldi	r19, 0x09	; 9
    64bc:	f9 01       	movw	r30, r18
    64be:	20 81       	ld	r18, Z
    64c0:	21 65       	ori	r18, 0x51	; 81
    64c2:	fc 01       	movw	r30, r24
    64c4:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    64c6:	84 e6       	ldi	r24, 0x64	; 100
    64c8:	96 e0       	ldi	r25, 0x06	; 6
    64ca:	24 e6       	ldi	r18, 0x64	; 100
    64cc:	36 e0       	ldi	r19, 0x06	; 6
    64ce:	f9 01       	movw	r30, r18
    64d0:	20 81       	ld	r18, Z
    64d2:	20 61       	ori	r18, 0x10	; 16
    64d4:	fc 01       	movw	r30, r24
    64d6:	20 83       	st	Z, r18
}
    64d8:	df 91       	pop	r29
    64da:	cf 91       	pop	r28
    64dc:	08 95       	ret

000064de <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    64de:	cf 93       	push	r28
    64e0:	df 93       	push	r29
    64e2:	0f 92       	push	r0
    64e4:	0f 92       	push	r0
    64e6:	cd b7       	in	r28, 0x3d	; 61
    64e8:	de b7       	in	r29, 0x3e	; 62
    64ea:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    64ec:	80 ec       	ldi	r24, 0xC0	; 192
    64ee:	99 e0       	ldi	r25, 0x09	; 9
    64f0:	2a 81       	ldd	r18, Y+2	; 0x02
    64f2:	fc 01       	movw	r30, r24
    64f4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    64f6:	00 00       	nop
    64f8:	80 ec       	ldi	r24, 0xC0	; 192
    64fa:	99 e0       	ldi	r25, 0x09	; 9
    64fc:	fc 01       	movw	r30, r24
    64fe:	82 81       	ldd	r24, Z+2	; 0x02
    6500:	88 23       	and	r24, r24
    6502:	d4 f7       	brge	.-12     	; 0x64f8 <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    6504:	80 ec       	ldi	r24, 0xC0	; 192
    6506:	99 e0       	ldi	r25, 0x09	; 9
    6508:	fc 01       	movw	r30, r24
    650a:	83 81       	ldd	r24, Z+3	; 0x03
    650c:	89 83       	std	Y+1, r24	; 0x01
	return data;
    650e:	89 81       	ldd	r24, Y+1	; 0x01
    6510:	0f 90       	pop	r0
    6512:	0f 90       	pop	r0
    6514:	df 91       	pop	r29
    6516:	cf 91       	pop	r28
    6518:	08 95       	ret

0000651a <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    651a:	0f 93       	push	r16
    651c:	cf 93       	push	r28
    651e:	df 93       	push	r29
    6520:	00 d0       	rcall	.+0      	; 0x6522 <CCPWrite+0x8>
    6522:	00 d0       	rcall	.+0      	; 0x6524 <CCPWrite+0xa>
    6524:	cd b7       	in	r28, 0x3d	; 61
    6526:	de b7       	in	r29, 0x3e	; 62
    6528:	8c 83       	std	Y+4, r24	; 0x04
    652a:	9d 83       	std	Y+5, r25	; 0x05
    652c:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    652e:	8f e3       	ldi	r24, 0x3F	; 63
    6530:	90 e0       	ldi	r25, 0x00	; 0
    6532:	fc 01       	movw	r30, r24
    6534:	80 81       	ld	r24, Z
    6536:	8b 83       	std	Y+3, r24	; 0x03
    6538:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    653a:	8c 81       	ldd	r24, Y+4	; 0x04
    653c:	9d 81       	ldd	r25, Y+5	; 0x05
    653e:	89 83       	std	Y+1, r24	; 0x01
    6540:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    6542:	8b e3       	ldi	r24, 0x3B	; 59
    6544:	90 e0       	ldi	r25, 0x00	; 0
    6546:	fc 01       	movw	r30, r24
    6548:	10 82       	st	Z, r1
#endif
	asm volatile(
    654a:	89 81       	ldd	r24, Y+1	; 0x01
    654c:	9a 81       	ldd	r25, Y+2	; 0x02
    654e:	2e 81       	ldd	r18, Y+6	; 0x06
    6550:	fc 01       	movw	r30, r24
    6552:	08 ed       	ldi	r16, 0xD8	; 216
    6554:	04 bf       	out	0x34, r16	; 52
    6556:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    6558:	8f e3       	ldi	r24, 0x3F	; 63
    655a:	90 e0       	ldi	r25, 0x00	; 0
    655c:	2b 81       	ldd	r18, Y+3	; 0x03
    655e:	fc 01       	movw	r30, r24
    6560:	20 83       	st	Z, r18
#endif
}
    6562:	26 96       	adiw	r28, 0x06	; 6
    6564:	cd bf       	out	0x3d, r28	; 61
    6566:	de bf       	out	0x3e, r29	; 62
    6568:	df 91       	pop	r29
    656a:	cf 91       	pop	r28
    656c:	0f 91       	pop	r16
    656e:	08 95       	ret

00006570 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6570:	cf 93       	push	r28
    6572:	df 93       	push	r29
    6574:	00 d0       	rcall	.+0      	; 0x6576 <CLKSYS_XOSC_Config+0x6>
    6576:	cd b7       	in	r28, 0x3d	; 61
    6578:	de b7       	in	r29, 0x3e	; 62
    657a:	89 83       	std	Y+1, r24	; 0x01
    657c:	6a 83       	std	Y+2, r22	; 0x02
    657e:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6580:	80 e5       	ldi	r24, 0x50	; 80
    6582:	90 e0       	ldi	r25, 0x00	; 0
    6584:	2a 81       	ldd	r18, Y+2	; 0x02
    6586:	22 23       	and	r18, r18
    6588:	11 f0       	breq	.+4      	; 0x658e <CLKSYS_XOSC_Config+0x1e>
    658a:	20 e2       	ldi	r18, 0x20	; 32
    658c:	01 c0       	rjmp	.+2      	; 0x6590 <CLKSYS_XOSC_Config+0x20>
    658e:	20 e0       	ldi	r18, 0x00	; 0
    6590:	39 81       	ldd	r19, Y+1	; 0x01
    6592:	32 2b       	or	r19, r18
    6594:	2b 81       	ldd	r18, Y+3	; 0x03
    6596:	23 2b       	or	r18, r19
    6598:	fc 01       	movw	r30, r24
    659a:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    659c:	23 96       	adiw	r28, 0x03	; 3
    659e:	cd bf       	out	0x3d, r28	; 61
    65a0:	de bf       	out	0x3e, r29	; 62
    65a2:	df 91       	pop	r29
    65a4:	cf 91       	pop	r28
    65a6:	08 95       	ret

000065a8 <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    65a8:	cf 93       	push	r28
    65aa:	df 93       	push	r29
    65ac:	0f 92       	push	r0
    65ae:	0f 92       	push	r0
    65b0:	cd b7       	in	r28, 0x3d	; 61
    65b2:	de b7       	in	r29, 0x3e	; 62
    65b4:	89 83       	std	Y+1, r24	; 0x01
    65b6:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    65b8:	8a 81       	ldd	r24, Y+2	; 0x02
    65ba:	8f 71       	andi	r24, 0x1F	; 31
    65bc:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    65be:	80 e5       	ldi	r24, 0x50	; 80
    65c0:	90 e0       	ldi	r25, 0x00	; 0
    65c2:	39 81       	ldd	r19, Y+1	; 0x01
    65c4:	2a 81       	ldd	r18, Y+2	; 0x02
    65c6:	23 2b       	or	r18, r19
    65c8:	fc 01       	movw	r30, r24
    65ca:	25 83       	std	Z+5, r18	; 0x05
}
    65cc:	0f 90       	pop	r0
    65ce:	0f 90       	pop	r0
    65d0:	df 91       	pop	r29
    65d2:	cf 91       	pop	r28
    65d4:	08 95       	ret

000065d6 <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    65d6:	cf 93       	push	r28
    65d8:	df 93       	push	r29
    65da:	0f 92       	push	r0
    65dc:	0f 92       	push	r0
    65de:	cd b7       	in	r28, 0x3d	; 61
    65e0:	de b7       	in	r29, 0x3e	; 62
    65e2:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    65e4:	80 e5       	ldi	r24, 0x50	; 80
    65e6:	90 e0       	ldi	r25, 0x00	; 0
    65e8:	20 e5       	ldi	r18, 0x50	; 80
    65ea:	30 e0       	ldi	r19, 0x00	; 0
    65ec:	f9 01       	movw	r30, r18
    65ee:	20 81       	ld	r18, Z
    65f0:	32 2f       	mov	r19, r18
    65f2:	2a 81       	ldd	r18, Y+2	; 0x02
    65f4:	20 95       	com	r18
    65f6:	23 23       	and	r18, r19
    65f8:	fc 01       	movw	r30, r24
    65fa:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    65fc:	80 e5       	ldi	r24, 0x50	; 80
    65fe:	90 e0       	ldi	r25, 0x00	; 0
    6600:	fc 01       	movw	r30, r24
    6602:	90 81       	ld	r25, Z
    6604:	8a 81       	ldd	r24, Y+2	; 0x02
    6606:	89 23       	and	r24, r25
    6608:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    660a:	89 81       	ldd	r24, Y+1	; 0x01
}
    660c:	0f 90       	pop	r0
    660e:	0f 90       	pop	r0
    6610:	df 91       	pop	r29
    6612:	cf 91       	pop	r28
    6614:	08 95       	ret

00006616 <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    6616:	cf 93       	push	r28
    6618:	df 93       	push	r29
    661a:	00 d0       	rcall	.+0      	; 0x661c <CLKSYS_Prescalers_Config+0x6>
    661c:	cd b7       	in	r28, 0x3d	; 61
    661e:	de b7       	in	r29, 0x3e	; 62
    6620:	8a 83       	std	Y+2, r24	; 0x02
    6622:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    6624:	9a 81       	ldd	r25, Y+2	; 0x02
    6626:	8b 81       	ldd	r24, Y+3	; 0x03
    6628:	89 2b       	or	r24, r25
    662a:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    662c:	81 e4       	ldi	r24, 0x41	; 65
    662e:	90 e0       	ldi	r25, 0x00	; 0
    6630:	69 81       	ldd	r22, Y+1	; 0x01
    6632:	0e 94 8d 32 	call	0x651a	; 0x651a <CCPWrite>
}
    6636:	23 96       	adiw	r28, 0x03	; 3
    6638:	cd bf       	out	0x3d, r28	; 61
    663a:	de bf       	out	0x3e, r29	; 62
    663c:	df 91       	pop	r29
    663e:	cf 91       	pop	r28
    6640:	08 95       	ret

00006642 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6642:	cf 93       	push	r28
    6644:	df 93       	push	r29
    6646:	0f 92       	push	r0
    6648:	0f 92       	push	r0
    664a:	cd b7       	in	r28, 0x3d	; 61
    664c:	de b7       	in	r29, 0x3e	; 62
    664e:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    6650:	80 e4       	ldi	r24, 0x40	; 64
    6652:	90 e0       	ldi	r25, 0x00	; 0
    6654:	fc 01       	movw	r30, r24
    6656:	80 81       	ld	r24, Z
    6658:	98 2f       	mov	r25, r24
    665a:	98 7f       	andi	r25, 0xF8	; 248
    665c:	8a 81       	ldd	r24, Y+2	; 0x02
    665e:	89 2b       	or	r24, r25
    6660:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    6662:	80 e4       	ldi	r24, 0x40	; 64
    6664:	90 e0       	ldi	r25, 0x00	; 0
    6666:	69 81       	ldd	r22, Y+1	; 0x01
    6668:	0e 94 8d 32 	call	0x651a	; 0x651a <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    666c:	80 e4       	ldi	r24, 0x40	; 64
    666e:	90 e0       	ldi	r25, 0x00	; 0
    6670:	fc 01       	movw	r30, r24
    6672:	90 81       	ld	r25, Z
    6674:	8a 81       	ldd	r24, Y+2	; 0x02
    6676:	89 23       	and	r24, r25
    6678:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    667a:	89 81       	ldd	r24, Y+1	; 0x01
}
    667c:	0f 90       	pop	r0
    667e:	0f 90       	pop	r0
    6680:	df 91       	pop	r29
    6682:	cf 91       	pop	r28
    6684:	08 95       	ret

00006686 <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    6686:	cf 93       	push	r28
    6688:	df 93       	push	r29
    668a:	0f 92       	push	r0
    668c:	cd b7       	in	r28, 0x3d	; 61
    668e:	de b7       	in	r29, 0x3e	; 62
    6690:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6692:	80 e4       	ldi	r24, 0x40	; 64
    6694:	90 e0       	ldi	r25, 0x00	; 0
    6696:	20 e4       	ldi	r18, 0x40	; 64
    6698:	30 e0       	ldi	r19, 0x00	; 0
    669a:	f9 01       	movw	r30, r18
    669c:	23 81       	ldd	r18, Z+3	; 0x03
    669e:	32 2f       	mov	r19, r18
    66a0:	31 7f       	andi	r19, 0xF1	; 241
    66a2:	29 81       	ldd	r18, Y+1	; 0x01
    66a4:	23 2b       	or	r18, r19
    66a6:	21 60       	ori	r18, 0x01	; 1
    66a8:	fc 01       	movw	r30, r24
    66aa:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    66ac:	0f 90       	pop	r0
    66ae:	df 91       	pop	r29
    66b0:	cf 91       	pop	r28
    66b2:	08 95       	ret

000066b4 <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    66b4:	cf 93       	push	r28
    66b6:	df 93       	push	r29
    66b8:	0f 92       	push	r0
    66ba:	0f 92       	push	r0
    66bc:	cd b7       	in	r28, 0x3d	; 61
    66be:	de b7       	in	r29, 0x3e	; 62
    66c0:	89 83       	std	Y+1, r24	; 0x01
    66c2:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    66c4:	80 e5       	ldi	r24, 0x50	; 80
    66c6:	90 e0       	ldi	r25, 0x00	; 0
    66c8:	20 e5       	ldi	r18, 0x50	; 80
    66ca:	30 e0       	ldi	r19, 0x00	; 0
    66cc:	f9 01       	movw	r30, r18
    66ce:	26 81       	ldd	r18, Z+6	; 0x06
    66d0:	32 2f       	mov	r19, r18
    66d2:	29 81       	ldd	r18, Y+1	; 0x01
    66d4:	20 95       	com	r18
    66d6:	32 23       	and	r19, r18
    66d8:	2a 81       	ldd	r18, Y+2	; 0x02
    66da:	22 23       	and	r18, r18
    66dc:	11 f0       	breq	.+4      	; 0x66e2 <CLKSYS_AutoCalibration_Enable+0x2e>
    66de:	29 81       	ldd	r18, Y+1	; 0x01
    66e0:	01 c0       	rjmp	.+2      	; 0x66e4 <CLKSYS_AutoCalibration_Enable+0x30>
    66e2:	20 e0       	ldi	r18, 0x00	; 0
    66e4:	23 2b       	or	r18, r19
    66e6:	fc 01       	movw	r30, r24
    66e8:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    66ea:	89 81       	ldd	r24, Y+1	; 0x01
    66ec:	81 30       	cpi	r24, 0x01	; 1
    66ee:	51 f4       	brne	.+20     	; 0x6704 <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    66f0:	88 e6       	ldi	r24, 0x68	; 104
    66f2:	90 e0       	ldi	r25, 0x00	; 0
    66f4:	28 e6       	ldi	r18, 0x68	; 104
    66f6:	30 e0       	ldi	r19, 0x00	; 0
    66f8:	f9 01       	movw	r30, r18
    66fa:	20 81       	ld	r18, Z
    66fc:	21 60       	ori	r18, 0x01	; 1
    66fe:	fc 01       	movw	r30, r24
    6700:	20 83       	st	Z, r18
    6702:	0c c0       	rjmp	.+24     	; 0x671c <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    6704:	89 81       	ldd	r24, Y+1	; 0x01
    6706:	82 30       	cpi	r24, 0x02	; 2
    6708:	49 f4       	brne	.+18     	; 0x671c <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    670a:	80 e6       	ldi	r24, 0x60	; 96
    670c:	90 e0       	ldi	r25, 0x00	; 0
    670e:	20 e6       	ldi	r18, 0x60	; 96
    6710:	30 e0       	ldi	r19, 0x00	; 0
    6712:	f9 01       	movw	r30, r18
    6714:	20 81       	ld	r18, Z
    6716:	21 60       	ori	r18, 0x01	; 1
    6718:	fc 01       	movw	r30, r24
    671a:	20 83       	st	Z, r18
	}
}
    671c:	0f 90       	pop	r0
    671e:	0f 90       	pop	r0
    6720:	df 91       	pop	r29
    6722:	cf 91       	pop	r28
    6724:	08 95       	ret

00006726 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    6726:	cf 93       	push	r28
    6728:	df 93       	push	r29
    672a:	cd b7       	in	r28, 0x3d	; 61
    672c:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    672e:	83 e5       	ldi	r24, 0x53	; 83
    6730:	90 e0       	ldi	r25, 0x00	; 0
    6732:	63 e0       	ldi	r22, 0x03	; 3
    6734:	0e 94 8d 32 	call	0x651a	; 0x651a <CCPWrite>
}
    6738:	df 91       	pop	r29
    673a:	cf 91       	pop	r28
    673c:	08 95       	ret

0000673e <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    673e:	cf 93       	push	r28
    6740:	df 93       	push	r29
    6742:	cd b7       	in	r28, 0x3d	; 61
    6744:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    6746:	82 e4       	ldi	r24, 0x42	; 66
    6748:	90 e0       	ldi	r25, 0x00	; 0
    674a:	61 e0       	ldi	r22, 0x01	; 1
    674c:	0e 94 8d 32 	call	0x651a	; 0x651a <CCPWrite>
}
    6750:	df 91       	pop	r29
    6752:	cf 91       	pop	r28
    6754:	08 95       	ret

00006756 <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    6756:	cf 93       	push	r28
    6758:	df 93       	push	r29
    675a:	cd b7       	in	r28, 0x3d	; 61
    675c:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    675e:	80 ec       	ldi	r24, 0xC0	; 192
    6760:	60 e0       	ldi	r22, 0x00	; 0
    6762:	4b e0       	ldi	r20, 0x0B	; 11
    6764:	0e 94 b8 32 	call	0x6570	; 0x6570 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    6768:	80 e5       	ldi	r24, 0x50	; 80
    676a:	90 e0       	ldi	r25, 0x00	; 0
    676c:	20 e5       	ldi	r18, 0x50	; 80
    676e:	30 e0       	ldi	r19, 0x00	; 0
    6770:	f9 01       	movw	r30, r18
    6772:	20 81       	ld	r18, Z
    6774:	28 60       	ori	r18, 0x08	; 8
    6776:	fc 01       	movw	r30, r24
    6778:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    677a:	80 e5       	ldi	r24, 0x50	; 80
    677c:	90 e0       	ldi	r25, 0x00	; 0
    677e:	fc 01       	movw	r30, r24
    6780:	81 81       	ldd	r24, Z+1	; 0x01
    6782:	88 2f       	mov	r24, r24
    6784:	90 e0       	ldi	r25, 0x00	; 0
    6786:	88 70       	andi	r24, 0x08	; 8
    6788:	90 70       	andi	r25, 0x00	; 0
    678a:	00 97       	sbiw	r24, 0x00	; 0
    678c:	b1 f3       	breq	.-20     	; 0x677a <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    678e:	80 ec       	ldi	r24, 0xC0	; 192
    6790:	62 e0       	ldi	r22, 0x02	; 2
    6792:	0e 94 d4 32 	call	0x65a8	; 0x65a8 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    6796:	80 e5       	ldi	r24, 0x50	; 80
    6798:	90 e0       	ldi	r25, 0x00	; 0
    679a:	20 e5       	ldi	r18, 0x50	; 80
    679c:	30 e0       	ldi	r19, 0x00	; 0
    679e:	f9 01       	movw	r30, r18
    67a0:	20 81       	ld	r18, Z
    67a2:	20 61       	ori	r18, 0x10	; 16
    67a4:	fc 01       	movw	r30, r24
    67a6:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    67a8:	80 e5       	ldi	r24, 0x50	; 80
    67aa:	90 e0       	ldi	r25, 0x00	; 0
    67ac:	fc 01       	movw	r30, r24
    67ae:	81 81       	ldd	r24, Z+1	; 0x01
    67b0:	88 2f       	mov	r24, r24
    67b2:	90 e0       	ldi	r25, 0x00	; 0
    67b4:	80 71       	andi	r24, 0x10	; 16
    67b6:	90 70       	andi	r25, 0x00	; 0
    67b8:	00 97       	sbiw	r24, 0x00	; 0
    67ba:	b1 f3       	breq	.-20     	; 0x67a8 <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    67bc:	84 e0       	ldi	r24, 0x04	; 4
    67be:	0e 94 21 33 	call	0x6642	; 0x6642 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    67c2:	81 e0       	ldi	r24, 0x01	; 1
    67c4:	0e 94 eb 32 	call	0x65d6	; 0x65d6 <CLKSYS_Disable>
}
    67c8:	df 91       	pop	r29
    67ca:	cf 91       	pop	r28
    67cc:	08 95       	ret

000067ce <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    67ce:	cf 93       	push	r28
    67d0:	df 93       	push	r29
    67d2:	cd b7       	in	r28, 0x3d	; 61
    67d4:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    67d6:	80 e5       	ldi	r24, 0x50	; 80
    67d8:	90 e0       	ldi	r25, 0x00	; 0
    67da:	20 e5       	ldi	r18, 0x50	; 80
    67dc:	30 e0       	ldi	r19, 0x00	; 0
    67de:	f9 01       	movw	r30, r18
    67e0:	20 81       	ld	r18, Z
    67e2:	22 60       	ori	r18, 0x02	; 2
    67e4:	fc 01       	movw	r30, r24
    67e6:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    67e8:	80 e0       	ldi	r24, 0x00	; 0
    67ea:	61 e0       	ldi	r22, 0x01	; 1
    67ec:	0e 94 0b 33 	call	0x6616	; 0x6616 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    67f0:	80 e5       	ldi	r24, 0x50	; 80
    67f2:	90 e0       	ldi	r25, 0x00	; 0
    67f4:	fc 01       	movw	r30, r24
    67f6:	81 81       	ldd	r24, Z+1	; 0x01
    67f8:	88 2f       	mov	r24, r24
    67fa:	90 e0       	ldi	r25, 0x00	; 0
    67fc:	82 70       	andi	r24, 0x02	; 2
    67fe:	90 70       	andi	r25, 0x00	; 0
    6800:	00 97       	sbiw	r24, 0x00	; 0
    6802:	b1 f3       	breq	.-20     	; 0x67f0 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6804:	81 e0       	ldi	r24, 0x01	; 1
    6806:	0e 94 21 33 	call	0x6642	; 0x6642 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    680a:	81 e0       	ldi	r24, 0x01	; 1
    680c:	0e 94 eb 32 	call	0x65d6	; 0x65d6 <CLKSYS_Disable>
	
}
    6810:	df 91       	pop	r29
    6812:	cf 91       	pop	r28
    6814:	08 95       	ret

00006816 <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    6816:	cf 93       	push	r28
    6818:	df 93       	push	r29
    681a:	cd b7       	in	r28, 0x3d	; 61
    681c:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    681e:	80 e5       	ldi	r24, 0x50	; 80
    6820:	90 e0       	ldi	r25, 0x00	; 0
    6822:	20 e5       	ldi	r18, 0x50	; 80
    6824:	30 e0       	ldi	r19, 0x00	; 0
    6826:	f9 01       	movw	r30, r18
    6828:	20 81       	ld	r18, Z
    682a:	22 60       	ori	r18, 0x02	; 2
    682c:	fc 01       	movw	r30, r24
    682e:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6830:	80 e0       	ldi	r24, 0x00	; 0
    6832:	60 e0       	ldi	r22, 0x00	; 0
    6834:	0e 94 0b 33 	call	0x6616	; 0x6616 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6838:	80 e5       	ldi	r24, 0x50	; 80
    683a:	90 e0       	ldi	r25, 0x00	; 0
    683c:	fc 01       	movw	r30, r24
    683e:	81 81       	ldd	r24, Z+1	; 0x01
    6840:	88 2f       	mov	r24, r24
    6842:	90 e0       	ldi	r25, 0x00	; 0
    6844:	82 70       	andi	r24, 0x02	; 2
    6846:	90 70       	andi	r25, 0x00	; 0
    6848:	00 97       	sbiw	r24, 0x00	; 0
    684a:	b1 f3       	breq	.-20     	; 0x6838 <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    684c:	81 e0       	ldi	r24, 0x01	; 1
    684e:	0e 94 21 33 	call	0x6642	; 0x6642 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6852:	81 e0       	ldi	r24, 0x01	; 1
    6854:	0e 94 eb 32 	call	0x65d6	; 0x65d6 <CLKSYS_Disable>
	
}
    6858:	df 91       	pop	r29
    685a:	cf 91       	pop	r28
    685c:	08 95       	ret

0000685e <portExCS>:


void portExCS(uint8_t write) {
    685e:	0f 93       	push	r16
    6860:	1f 93       	push	r17
    6862:	cf 93       	push	r28
    6864:	df 93       	push	r29
    6866:	cd b7       	in	r28, 0x3d	; 61
    6868:	de b7       	in	r29, 0x3e	; 62
    686a:	69 97       	sbiw	r28, 0x19	; 25
    686c:	cd bf       	out	0x3d, r28	; 61
    686e:	de bf       	out	0x3e, r29	; 62
    6870:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6872:	89 8d       	ldd	r24, Y+25	; 0x19
    6874:	88 23       	and	r24, r24
    6876:	31 f0       	breq	.+12     	; 0x6884 <portExCS+0x26>
    6878:	80 e0       	ldi	r24, 0x00	; 0
    687a:	96 e0       	ldi	r25, 0x06	; 6
    687c:	28 e0       	ldi	r18, 0x08	; 8
    687e:	fc 01       	movw	r30, r24
    6880:	26 83       	std	Z+6, r18	; 0x06
    6882:	05 c0       	rjmp	.+10     	; 0x688e <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    6884:	80 e0       	ldi	r24, 0x00	; 0
    6886:	96 e0       	ldi	r25, 0x06	; 6
    6888:	28 e0       	ldi	r18, 0x08	; 8
    688a:	fc 01       	movw	r30, r24
    688c:	25 83       	std	Z+5, r18	; 0x05
    688e:	80 e0       	ldi	r24, 0x00	; 0
    6890:	90 e0       	ldi	r25, 0x00	; 0
    6892:	a0 e2       	ldi	r26, 0x20	; 32
    6894:	b1 e4       	ldi	r27, 0x41	; 65
    6896:	89 83       	std	Y+1, r24	; 0x01
    6898:	9a 83       	std	Y+2, r25	; 0x02
    689a:	ab 83       	std	Y+3, r26	; 0x03
    689c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    689e:	69 81       	ldd	r22, Y+1	; 0x01
    68a0:	7a 81       	ldd	r23, Y+2	; 0x02
    68a2:	8b 81       	ldd	r24, Y+3	; 0x03
    68a4:	9c 81       	ldd	r25, Y+4	; 0x04
    68a6:	2b ea       	ldi	r18, 0xAB	; 171
    68a8:	3a ea       	ldi	r19, 0xAA	; 170
    68aa:	4a e2       	ldi	r20, 0x2A	; 42
    68ac:	51 e4       	ldi	r21, 0x41	; 65
    68ae:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    68b2:	dc 01       	movw	r26, r24
    68b4:	cb 01       	movw	r24, r22
    68b6:	8d 83       	std	Y+5, r24	; 0x05
    68b8:	9e 83       	std	Y+6, r25	; 0x06
    68ba:	af 83       	std	Y+7, r26	; 0x07
    68bc:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    68be:	11 e0       	ldi	r17, 0x01	; 1
    68c0:	6d 81       	ldd	r22, Y+5	; 0x05
    68c2:	7e 81       	ldd	r23, Y+6	; 0x06
    68c4:	8f 81       	ldd	r24, Y+7	; 0x07
    68c6:	98 85       	ldd	r25, Y+8	; 0x08
    68c8:	20 e0       	ldi	r18, 0x00	; 0
    68ca:	30 e0       	ldi	r19, 0x00	; 0
    68cc:	40 e8       	ldi	r20, 0x80	; 128
    68ce:	5f e3       	ldi	r21, 0x3F	; 63
    68d0:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    68d4:	88 23       	and	r24, r24
    68d6:	0c f0       	brlt	.+2      	; 0x68da <portExCS+0x7c>
    68d8:	10 e0       	ldi	r17, 0x00	; 0
    68da:	11 23       	and	r17, r17
    68dc:	19 f0       	breq	.+6      	; 0x68e4 <portExCS+0x86>
		__ticks = 1;
    68de:	81 e0       	ldi	r24, 0x01	; 1
    68e0:	89 87       	std	Y+9, r24	; 0x09
    68e2:	a3 c0       	rjmp	.+326    	; 0x6a2a <portExCS+0x1cc>
	else if (__tmp > 255)
    68e4:	11 e0       	ldi	r17, 0x01	; 1
    68e6:	6d 81       	ldd	r22, Y+5	; 0x05
    68e8:	7e 81       	ldd	r23, Y+6	; 0x06
    68ea:	8f 81       	ldd	r24, Y+7	; 0x07
    68ec:	98 85       	ldd	r25, Y+8	; 0x08
    68ee:	20 e0       	ldi	r18, 0x00	; 0
    68f0:	30 e0       	ldi	r19, 0x00	; 0
    68f2:	4f e7       	ldi	r20, 0x7F	; 127
    68f4:	53 e4       	ldi	r21, 0x43	; 67
    68f6:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    68fa:	18 16       	cp	r1, r24
    68fc:	0c f0       	brlt	.+2      	; 0x6900 <portExCS+0xa2>
    68fe:	10 e0       	ldi	r17, 0x00	; 0
    6900:	11 23       	and	r17, r17
    6902:	09 f4       	brne	.+2      	; 0x6906 <portExCS+0xa8>
    6904:	89 c0       	rjmp	.+274    	; 0x6a18 <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    6906:	69 81       	ldd	r22, Y+1	; 0x01
    6908:	7a 81       	ldd	r23, Y+2	; 0x02
    690a:	8b 81       	ldd	r24, Y+3	; 0x03
    690c:	9c 81       	ldd	r25, Y+4	; 0x04
    690e:	20 e0       	ldi	r18, 0x00	; 0
    6910:	30 e0       	ldi	r19, 0x00	; 0
    6912:	4a e7       	ldi	r20, 0x7A	; 122
    6914:	54 e4       	ldi	r21, 0x44	; 68
    6916:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    691a:	dc 01       	movw	r26, r24
    691c:	cb 01       	movw	r24, r22
    691e:	8a 87       	std	Y+10, r24	; 0x0a
    6920:	9b 87       	std	Y+11, r25	; 0x0b
    6922:	ac 87       	std	Y+12, r26	; 0x0c
    6924:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6926:	6a 85       	ldd	r22, Y+10	; 0x0a
    6928:	7b 85       	ldd	r23, Y+11	; 0x0b
    692a:	8c 85       	ldd	r24, Y+12	; 0x0c
    692c:	9d 85       	ldd	r25, Y+13	; 0x0d
    692e:	20 e0       	ldi	r18, 0x00	; 0
    6930:	30 e0       	ldi	r19, 0x00	; 0
    6932:	4a ef       	ldi	r20, 0xFA	; 250
    6934:	55 e4       	ldi	r21, 0x45	; 69
    6936:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    693a:	dc 01       	movw	r26, r24
    693c:	cb 01       	movw	r24, r22
    693e:	8e 87       	std	Y+14, r24	; 0x0e
    6940:	9f 87       	std	Y+15, r25	; 0x0f
    6942:	a8 8b       	std	Y+16, r26	; 0x10
    6944:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    6946:	11 e0       	ldi	r17, 0x01	; 1
    6948:	6e 85       	ldd	r22, Y+14	; 0x0e
    694a:	7f 85       	ldd	r23, Y+15	; 0x0f
    694c:	88 89       	ldd	r24, Y+16	; 0x10
    694e:	99 89       	ldd	r25, Y+17	; 0x11
    6950:	20 e0       	ldi	r18, 0x00	; 0
    6952:	30 e0       	ldi	r19, 0x00	; 0
    6954:	40 e8       	ldi	r20, 0x80	; 128
    6956:	5f e3       	ldi	r21, 0x3F	; 63
    6958:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    695c:	88 23       	and	r24, r24
    695e:	0c f0       	brlt	.+2      	; 0x6962 <portExCS+0x104>
    6960:	10 e0       	ldi	r17, 0x00	; 0
    6962:	11 23       	and	r17, r17
    6964:	29 f0       	breq	.+10     	; 0x6970 <portExCS+0x112>
		__ticks = 1;
    6966:	81 e0       	ldi	r24, 0x01	; 1
    6968:	90 e0       	ldi	r25, 0x00	; 0
    696a:	8a 8b       	std	Y+18, r24	; 0x12
    696c:	9b 8b       	std	Y+19, r25	; 0x13
    696e:	46 c0       	rjmp	.+140    	; 0x69fc <portExCS+0x19e>
	else if (__tmp > 65535)
    6970:	11 e0       	ldi	r17, 0x01	; 1
    6972:	6e 85       	ldd	r22, Y+14	; 0x0e
    6974:	7f 85       	ldd	r23, Y+15	; 0x0f
    6976:	88 89       	ldd	r24, Y+16	; 0x10
    6978:	99 89       	ldd	r25, Y+17	; 0x11
    697a:	20 e0       	ldi	r18, 0x00	; 0
    697c:	3f ef       	ldi	r19, 0xFF	; 255
    697e:	4f e7       	ldi	r20, 0x7F	; 127
    6980:	57 e4       	ldi	r21, 0x47	; 71
    6982:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    6986:	18 16       	cp	r1, r24
    6988:	0c f0       	brlt	.+2      	; 0x698c <portExCS+0x12e>
    698a:	10 e0       	ldi	r17, 0x00	; 0
    698c:	11 23       	and	r17, r17
    698e:	61 f1       	breq	.+88     	; 0x69e8 <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6990:	6a 85       	ldd	r22, Y+10	; 0x0a
    6992:	7b 85       	ldd	r23, Y+11	; 0x0b
    6994:	8c 85       	ldd	r24, Y+12	; 0x0c
    6996:	9d 85       	ldd	r25, Y+13	; 0x0d
    6998:	20 e0       	ldi	r18, 0x00	; 0
    699a:	30 e0       	ldi	r19, 0x00	; 0
    699c:	40 e2       	ldi	r20, 0x20	; 32
    699e:	51 e4       	ldi	r21, 0x41	; 65
    69a0:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    69a4:	dc 01       	movw	r26, r24
    69a6:	cb 01       	movw	r24, r22
    69a8:	bc 01       	movw	r22, r24
    69aa:	cd 01       	movw	r24, r26
    69ac:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    69b0:	dc 01       	movw	r26, r24
    69b2:	cb 01       	movw	r24, r22
    69b4:	8a 8b       	std	Y+18, r24	; 0x12
    69b6:	9b 8b       	std	Y+19, r25	; 0x13
    69b8:	12 c0       	rjmp	.+36     	; 0x69de <portExCS+0x180>
    69ba:	80 e2       	ldi	r24, 0x20	; 32
    69bc:	93 e0       	ldi	r25, 0x03	; 3
    69be:	8c 8b       	std	Y+20, r24	; 0x14
    69c0:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    69c2:	8c 89       	ldd	r24, Y+20	; 0x14
    69c4:	9d 89       	ldd	r25, Y+21	; 0x15
    69c6:	8c 01       	movw	r16, r24
    69c8:	c8 01       	movw	r24, r16
    69ca:	01 97       	sbiw	r24, 0x01	; 1
    69cc:	f1 f7       	brne	.-4      	; 0x69ca <portExCS+0x16c>
    69ce:	8c 01       	movw	r16, r24
    69d0:	0c 8b       	std	Y+20, r16	; 0x14
    69d2:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    69d4:	8a 89       	ldd	r24, Y+18	; 0x12
    69d6:	9b 89       	ldd	r25, Y+19	; 0x13
    69d8:	01 97       	sbiw	r24, 0x01	; 1
    69da:	8a 8b       	std	Y+18, r24	; 0x12
    69dc:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    69de:	8a 89       	ldd	r24, Y+18	; 0x12
    69e0:	9b 89       	ldd	r25, Y+19	; 0x13
    69e2:	00 97       	sbiw	r24, 0x00	; 0
    69e4:	51 f7       	brne	.-44     	; 0x69ba <portExCS+0x15c>
    69e6:	28 c0       	rjmp	.+80     	; 0x6a38 <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    69e8:	6e 85       	ldd	r22, Y+14	; 0x0e
    69ea:	7f 85       	ldd	r23, Y+15	; 0x0f
    69ec:	88 89       	ldd	r24, Y+16	; 0x10
    69ee:	99 89       	ldd	r25, Y+17	; 0x11
    69f0:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    69f4:	dc 01       	movw	r26, r24
    69f6:	cb 01       	movw	r24, r22
    69f8:	8a 8b       	std	Y+18, r24	; 0x12
    69fa:	9b 8b       	std	Y+19, r25	; 0x13
    69fc:	8a 89       	ldd	r24, Y+18	; 0x12
    69fe:	9b 89       	ldd	r25, Y+19	; 0x13
    6a00:	8e 8b       	std	Y+22, r24	; 0x16
    6a02:	9f 8b       	std	Y+23, r25	; 0x17
    6a04:	8e 89       	ldd	r24, Y+22	; 0x16
    6a06:	9f 89       	ldd	r25, Y+23	; 0x17
    6a08:	8c 01       	movw	r16, r24
    6a0a:	f8 01       	movw	r30, r16
    6a0c:	31 97       	sbiw	r30, 0x01	; 1
    6a0e:	f1 f7       	brne	.-4      	; 0x6a0c <portExCS+0x1ae>
    6a10:	8f 01       	movw	r16, r30
    6a12:	0e 8b       	std	Y+22, r16	; 0x16
    6a14:	1f 8b       	std	Y+23, r17	; 0x17
    6a16:	10 c0       	rjmp	.+32     	; 0x6a38 <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6a18:	6d 81       	ldd	r22, Y+5	; 0x05
    6a1a:	7e 81       	ldd	r23, Y+6	; 0x06
    6a1c:	8f 81       	ldd	r24, Y+7	; 0x07
    6a1e:	98 85       	ldd	r25, Y+8	; 0x08
    6a20:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    6a24:	dc 01       	movw	r26, r24
    6a26:	cb 01       	movw	r24, r22
    6a28:	89 87       	std	Y+9, r24	; 0x09
    6a2a:	89 85       	ldd	r24, Y+9	; 0x09
    6a2c:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6a2e:	88 8d       	ldd	r24, Y+24	; 0x18
    6a30:	18 2f       	mov	r17, r24
    6a32:	1a 95       	dec	r17
    6a34:	f1 f7       	brne	.-4      	; 0x6a32 <portExCS+0x1d4>
    6a36:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    6a38:	69 96       	adiw	r28, 0x19	; 25
    6a3a:	cd bf       	out	0x3d, r28	; 61
    6a3c:	de bf       	out	0x3e, r29	; 62
    6a3e:	df 91       	pop	r29
    6a40:	cf 91       	pop	r28
    6a42:	1f 91       	pop	r17
    6a44:	0f 91       	pop	r16
    6a46:	08 95       	ret

00006a48 <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    6a48:	cf 93       	push	r28
    6a4a:	df 93       	push	r29
    6a4c:	00 d0       	rcall	.+0      	; 0x6a4e <PortEx_DIRSET+0x6>
    6a4e:	cd b7       	in	r28, 0x3d	; 61
    6a50:	de b7       	in	r29, 0x3e	; 62
    6a52:	8a 83       	std	Y+2, r24	; 0x02
    6a54:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6a56:	80 e0       	ldi	r24, 0x00	; 0
    6a58:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    6a5c:	81 e0       	ldi	r24, 0x01	; 1
    6a5e:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	portExCS(TRUE);
    6a62:	81 e0       	ldi	r24, 0x01	; 1
    6a64:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    6a68:	8b 81       	ldd	r24, Y+3	; 0x03
    6a6a:	88 23       	and	r24, r24
    6a6c:	39 f0       	breq	.+14     	; 0x6a7c <PortEx_DIRSET+0x34>
    6a6e:	90 91 6b 50 	lds	r25, 0x506B
    6a72:	8a 81       	ldd	r24, Y+2	; 0x02
    6a74:	89 2b       	or	r24, r25
    6a76:	80 93 6b 50 	sts	0x506B, r24
    6a7a:	06 c0       	rjmp	.+12     	; 0x6a88 <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6a7c:	90 91 da 50 	lds	r25, 0x50DA
    6a80:	8a 81       	ldd	r24, Y+2	; 0x02
    6a82:	89 2b       	or	r24, r25
    6a84:	80 93 da 50 	sts	0x50DA, r24
	
	SPIBuffer[0] = PS_WRITE;
    6a88:	80 e4       	ldi	r24, 0x40	; 64
    6a8a:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    6a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a90:	88 23       	and	r24, r24
    6a92:	41 f0       	breq	.+16     	; 0x6aa4 <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    6a94:	10 92 5b 50 	sts	0x505B, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6a98:	80 91 6b 50 	lds	r24, 0x506B
    6a9c:	80 95       	com	r24
    6a9e:	80 93 5c 50 	sts	0x505C, r24
    6aa2:	08 c0       	rjmp	.+16     	; 0x6ab4 <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6aa4:	81 e0       	ldi	r24, 0x01	; 1
    6aa6:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = ~bankB_DIR;
    6aaa:	80 91 da 50 	lds	r24, 0x50DA
    6aae:	80 95       	com	r24
    6ab0:	80 93 5c 50 	sts	0x505C, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6ab4:	19 82       	std	Y+1, r1	; 0x01
    6ab6:	1b c0       	rjmp	.+54     	; 0x6aee <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    6ab8:	80 ec       	ldi	r24, 0xC0	; 192
    6aba:	98 e0       	ldi	r25, 0x08	; 8
    6abc:	29 81       	ldd	r18, Y+1	; 0x01
    6abe:	22 2f       	mov	r18, r18
    6ac0:	30 e0       	ldi	r19, 0x00	; 0
    6ac2:	26 5a       	subi	r18, 0xA6	; 166
    6ac4:	3f 4a       	sbci	r19, 0xAF	; 175
    6ac6:	f9 01       	movw	r30, r18
    6ac8:	20 81       	ld	r18, Z
    6aca:	fc 01       	movw	r30, r24
    6acc:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6ace:	00 00       	nop
    6ad0:	80 ec       	ldi	r24, 0xC0	; 192
    6ad2:	98 e0       	ldi	r25, 0x08	; 8
    6ad4:	fc 01       	movw	r30, r24
    6ad6:	82 81       	ldd	r24, Z+2	; 0x02
    6ad8:	88 23       	and	r24, r24
    6ada:	d4 f7       	brge	.-12     	; 0x6ad0 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6adc:	80 ec       	ldi	r24, 0xC0	; 192
    6ade:	98 e0       	ldi	r25, 0x08	; 8
    6ae0:	fc 01       	movw	r30, r24
    6ae2:	83 81       	ldd	r24, Z+3	; 0x03
    6ae4:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6ae8:	89 81       	ldd	r24, Y+1	; 0x01
    6aea:	8f 5f       	subi	r24, 0xFF	; 255
    6aec:	89 83       	std	Y+1, r24	; 0x01
    6aee:	89 81       	ldd	r24, Y+1	; 0x01
    6af0:	83 30       	cpi	r24, 0x03	; 3
    6af2:	10 f3       	brcs	.-60     	; 0x6ab8 <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    6af4:	80 e0       	ldi	r24, 0x00	; 0
    6af6:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>
	SPICS(FALSE);
    6afa:	80 e0       	ldi	r24, 0x00	; 0
    6afc:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    6b00:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>


}
    6b04:	23 96       	adiw	r28, 0x03	; 3
    6b06:	cd bf       	out	0x3d, r28	; 61
    6b08:	de bf       	out	0x3e, r29	; 62
    6b0a:	df 91       	pop	r29
    6b0c:	cf 91       	pop	r28
    6b0e:	08 95       	ret

00006b10 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6b10:	cf 93       	push	r28
    6b12:	df 93       	push	r29
    6b14:	00 d0       	rcall	.+0      	; 0x6b16 <PortEx_DIRCLR+0x6>
    6b16:	cd b7       	in	r28, 0x3d	; 61
    6b18:	de b7       	in	r29, 0x3e	; 62
    6b1a:	8a 83       	std	Y+2, r24	; 0x02
    6b1c:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6b1e:	80 e0       	ldi	r24, 0x00	; 0
    6b20:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    6b24:	81 e0       	ldi	r24, 0x01	; 1
    6b26:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	portExCS(TRUE);
    6b2a:	81 e0       	ldi	r24, 0x01	; 1
    6b2c:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6b30:	8b 81       	ldd	r24, Y+3	; 0x03
    6b32:	88 23       	and	r24, r24
    6b34:	49 f0       	breq	.+18     	; 0x6b48 <PortEx_DIRCLR+0x38>
    6b36:	80 91 6b 50 	lds	r24, 0x506B
    6b3a:	98 2f       	mov	r25, r24
    6b3c:	90 95       	com	r25
    6b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    6b40:	89 23       	and	r24, r25
    6b42:	80 93 6b 50 	sts	0x506B, r24
    6b46:	08 c0       	rjmp	.+16     	; 0x6b58 <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    6b48:	80 91 da 50 	lds	r24, 0x50DA
    6b4c:	98 2f       	mov	r25, r24
    6b4e:	90 95       	com	r25
    6b50:	8a 81       	ldd	r24, Y+2	; 0x02
    6b52:	89 23       	and	r24, r25
    6b54:	80 93 da 50 	sts	0x50DA, r24
	
	SPIBuffer[0] = PS_WRITE;
    6b58:	80 e4       	ldi	r24, 0x40	; 64
    6b5a:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    6b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    6b60:	88 23       	and	r24, r24
    6b62:	41 f0       	breq	.+16     	; 0x6b74 <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    6b64:	10 92 5b 50 	sts	0x505B, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6b68:	80 91 6b 50 	lds	r24, 0x506B
    6b6c:	80 95       	com	r24
    6b6e:	80 93 5c 50 	sts	0x505C, r24
    6b72:	08 c0       	rjmp	.+16     	; 0x6b84 <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6b74:	81 e0       	ldi	r24, 0x01	; 1
    6b76:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = ~bankB_DIR;
    6b7a:	80 91 da 50 	lds	r24, 0x50DA
    6b7e:	80 95       	com	r24
    6b80:	80 93 5c 50 	sts	0x505C, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6b84:	19 82       	std	Y+1, r1	; 0x01
    6b86:	1b c0       	rjmp	.+54     	; 0x6bbe <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    6b88:	80 ec       	ldi	r24, 0xC0	; 192
    6b8a:	98 e0       	ldi	r25, 0x08	; 8
    6b8c:	29 81       	ldd	r18, Y+1	; 0x01
    6b8e:	22 2f       	mov	r18, r18
    6b90:	30 e0       	ldi	r19, 0x00	; 0
    6b92:	26 5a       	subi	r18, 0xA6	; 166
    6b94:	3f 4a       	sbci	r19, 0xAF	; 175
    6b96:	f9 01       	movw	r30, r18
    6b98:	20 81       	ld	r18, Z
    6b9a:	fc 01       	movw	r30, r24
    6b9c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6b9e:	00 00       	nop
    6ba0:	80 ec       	ldi	r24, 0xC0	; 192
    6ba2:	98 e0       	ldi	r25, 0x08	; 8
    6ba4:	fc 01       	movw	r30, r24
    6ba6:	82 81       	ldd	r24, Z+2	; 0x02
    6ba8:	88 23       	and	r24, r24
    6baa:	d4 f7       	brge	.-12     	; 0x6ba0 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6bac:	80 ec       	ldi	r24, 0xC0	; 192
    6bae:	98 e0       	ldi	r25, 0x08	; 8
    6bb0:	fc 01       	movw	r30, r24
    6bb2:	83 81       	ldd	r24, Z+3	; 0x03
    6bb4:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6bb8:	89 81       	ldd	r24, Y+1	; 0x01
    6bba:	8f 5f       	subi	r24, 0xFF	; 255
    6bbc:	89 83       	std	Y+1, r24	; 0x01
    6bbe:	89 81       	ldd	r24, Y+1	; 0x01
    6bc0:	83 30       	cpi	r24, 0x03	; 3
    6bc2:	10 f3       	brcs	.-60     	; 0x6b88 <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6bc4:	80 e0       	ldi	r24, 0x00	; 0
    6bc6:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	portExCS(FALSE);
    6bca:	80 e0       	ldi	r24, 0x00	; 0
    6bcc:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>
	SPIDisable();
    6bd0:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
}
    6bd4:	23 96       	adiw	r28, 0x03	; 3
    6bd6:	cd bf       	out	0x3d, r28	; 61
    6bd8:	de bf       	out	0x3e, r29	; 62
    6bda:	df 91       	pop	r29
    6bdc:	cf 91       	pop	r28
    6bde:	08 95       	ret

00006be0 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6be0:	cf 93       	push	r28
    6be2:	df 93       	push	r29
    6be4:	00 d0       	rcall	.+0      	; 0x6be6 <PortEx_OUTSET+0x6>
    6be6:	cd b7       	in	r28, 0x3d	; 61
    6be8:	de b7       	in	r29, 0x3e	; 62
    6bea:	8a 83       	std	Y+2, r24	; 0x02
    6bec:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6bee:	80 e0       	ldi	r24, 0x00	; 0
    6bf0:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    6bf4:	81 e0       	ldi	r24, 0x01	; 1
    6bf6:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	portExCS(TRUE);
    6bfa:	81 e0       	ldi	r24, 0x01	; 1
    6bfc:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6c00:	8b 81       	ldd	r24, Y+3	; 0x03
    6c02:	88 23       	and	r24, r24
    6c04:	39 f0       	breq	.+14     	; 0x6c14 <PortEx_OUTSET+0x34>
    6c06:	90 91 cb 23 	lds	r25, 0x23CB
    6c0a:	8a 81       	ldd	r24, Y+2	; 0x02
    6c0c:	89 2b       	or	r24, r25
    6c0e:	80 93 cb 23 	sts	0x23CB, r24
    6c12:	06 c0       	rjmp	.+12     	; 0x6c20 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6c14:	90 91 73 50 	lds	r25, 0x5073
    6c18:	8a 81       	ldd	r24, Y+2	; 0x02
    6c1a:	89 2b       	or	r24, r25
    6c1c:	80 93 73 50 	sts	0x5073, r24
	
	SPIBuffer[0] = PS_WRITE;
    6c20:	80 e4       	ldi	r24, 0x40	; 64
    6c22:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    6c26:	8b 81       	ldd	r24, Y+3	; 0x03
    6c28:	88 23       	and	r24, r24
    6c2a:	41 f0       	breq	.+16     	; 0x6c3c <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6c2c:	84 e1       	ldi	r24, 0x14	; 20
    6c2e:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankA_OUT;
    6c32:	80 91 cb 23 	lds	r24, 0x23CB
    6c36:	80 93 5c 50 	sts	0x505C, r24
    6c3a:	07 c0       	rjmp	.+14     	; 0x6c4a <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6c3c:	85 e1       	ldi	r24, 0x15	; 21
    6c3e:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankB_OUT; 
    6c42:	80 91 73 50 	lds	r24, 0x5073
    6c46:	80 93 5c 50 	sts	0x505C, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6c4a:	19 82       	std	Y+1, r1	; 0x01
    6c4c:	1b c0       	rjmp	.+54     	; 0x6c84 <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6c4e:	80 ec       	ldi	r24, 0xC0	; 192
    6c50:	98 e0       	ldi	r25, 0x08	; 8
    6c52:	29 81       	ldd	r18, Y+1	; 0x01
    6c54:	22 2f       	mov	r18, r18
    6c56:	30 e0       	ldi	r19, 0x00	; 0
    6c58:	26 5a       	subi	r18, 0xA6	; 166
    6c5a:	3f 4a       	sbci	r19, 0xAF	; 175
    6c5c:	f9 01       	movw	r30, r18
    6c5e:	20 81       	ld	r18, Z
    6c60:	fc 01       	movw	r30, r24
    6c62:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6c64:	00 00       	nop
    6c66:	80 ec       	ldi	r24, 0xC0	; 192
    6c68:	98 e0       	ldi	r25, 0x08	; 8
    6c6a:	fc 01       	movw	r30, r24
    6c6c:	82 81       	ldd	r24, Z+2	; 0x02
    6c6e:	88 23       	and	r24, r24
    6c70:	d4 f7       	brge	.-12     	; 0x6c66 <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6c72:	80 ec       	ldi	r24, 0xC0	; 192
    6c74:	98 e0       	ldi	r25, 0x08	; 8
    6c76:	fc 01       	movw	r30, r24
    6c78:	83 81       	ldd	r24, Z+3	; 0x03
    6c7a:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6c7e:	89 81       	ldd	r24, Y+1	; 0x01
    6c80:	8f 5f       	subi	r24, 0xFF	; 255
    6c82:	89 83       	std	Y+1, r24	; 0x01
    6c84:	89 81       	ldd	r24, Y+1	; 0x01
    6c86:	83 30       	cpi	r24, 0x03	; 3
    6c88:	10 f3       	brcs	.-60     	; 0x6c4e <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6c8a:	80 e0       	ldi	r24, 0x00	; 0
    6c8c:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	portExCS(FALSE);
    6c90:	80 e0       	ldi	r24, 0x00	; 0
    6c92:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>
	SPIDisable();
    6c96:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
}
    6c9a:	23 96       	adiw	r28, 0x03	; 3
    6c9c:	cd bf       	out	0x3d, r28	; 61
    6c9e:	de bf       	out	0x3e, r29	; 62
    6ca0:	df 91       	pop	r29
    6ca2:	cf 91       	pop	r28
    6ca4:	08 95       	ret

00006ca6 <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    6ca6:	cf 93       	push	r28
    6ca8:	df 93       	push	r29
    6caa:	00 d0       	rcall	.+0      	; 0x6cac <PortEx_OUTCLR+0x6>
    6cac:	cd b7       	in	r28, 0x3d	; 61
    6cae:	de b7       	in	r29, 0x3e	; 62
    6cb0:	8a 83       	std	Y+2, r24	; 0x02
    6cb2:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6cb4:	80 e0       	ldi	r24, 0x00	; 0
    6cb6:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    6cba:	81 e0       	ldi	r24, 0x01	; 1
    6cbc:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	portExCS(TRUE);
    6cc0:	81 e0       	ldi	r24, 0x01	; 1
    6cc2:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    6cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    6cc8:	88 23       	and	r24, r24
    6cca:	49 f0       	breq	.+18     	; 0x6cde <PortEx_OUTCLR+0x38>
    6ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    6cce:	98 2f       	mov	r25, r24
    6cd0:	90 95       	com	r25
    6cd2:	80 91 cb 23 	lds	r24, 0x23CB
    6cd6:	89 23       	and	r24, r25
    6cd8:	80 93 cb 23 	sts	0x23CB, r24
    6cdc:	08 c0       	rjmp	.+16     	; 0x6cee <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6cde:	8a 81       	ldd	r24, Y+2	; 0x02
    6ce0:	98 2f       	mov	r25, r24
    6ce2:	90 95       	com	r25
    6ce4:	80 91 73 50 	lds	r24, 0x5073
    6ce8:	89 23       	and	r24, r25
    6cea:	80 93 73 50 	sts	0x5073, r24
	
	SPIBuffer[0] = PS_WRITE;
    6cee:	80 e4       	ldi	r24, 0x40	; 64
    6cf0:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    6cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    6cf6:	88 23       	and	r24, r24
    6cf8:	41 f0       	breq	.+16     	; 0x6d0a <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6cfa:	84 e1       	ldi	r24, 0x14	; 20
    6cfc:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankA_OUT;
    6d00:	80 91 cb 23 	lds	r24, 0x23CB
    6d04:	80 93 5c 50 	sts	0x505C, r24
    6d08:	07 c0       	rjmp	.+14     	; 0x6d18 <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6d0a:	85 e1       	ldi	r24, 0x15	; 21
    6d0c:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankB_OUT; 
    6d10:	80 91 73 50 	lds	r24, 0x5073
    6d14:	80 93 5c 50 	sts	0x505C, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d18:	19 82       	std	Y+1, r1	; 0x01
    6d1a:	1b c0       	rjmp	.+54     	; 0x6d52 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6d1c:	80 ec       	ldi	r24, 0xC0	; 192
    6d1e:	98 e0       	ldi	r25, 0x08	; 8
    6d20:	29 81       	ldd	r18, Y+1	; 0x01
    6d22:	22 2f       	mov	r18, r18
    6d24:	30 e0       	ldi	r19, 0x00	; 0
    6d26:	26 5a       	subi	r18, 0xA6	; 166
    6d28:	3f 4a       	sbci	r19, 0xAF	; 175
    6d2a:	f9 01       	movw	r30, r18
    6d2c:	20 81       	ld	r18, Z
    6d2e:	fc 01       	movw	r30, r24
    6d30:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6d32:	00 00       	nop
    6d34:	80 ec       	ldi	r24, 0xC0	; 192
    6d36:	98 e0       	ldi	r25, 0x08	; 8
    6d38:	fc 01       	movw	r30, r24
    6d3a:	82 81       	ldd	r24, Z+2	; 0x02
    6d3c:	88 23       	and	r24, r24
    6d3e:	d4 f7       	brge	.-12     	; 0x6d34 <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6d40:	80 ec       	ldi	r24, 0xC0	; 192
    6d42:	98 e0       	ldi	r25, 0x08	; 8
    6d44:	fc 01       	movw	r30, r24
    6d46:	83 81       	ldd	r24, Z+3	; 0x03
    6d48:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d4c:	89 81       	ldd	r24, Y+1	; 0x01
    6d4e:	8f 5f       	subi	r24, 0xFF	; 255
    6d50:	89 83       	std	Y+1, r24	; 0x01
    6d52:	89 81       	ldd	r24, Y+1	; 0x01
    6d54:	83 30       	cpi	r24, 0x03	; 3
    6d56:	10 f3       	brcs	.-60     	; 0x6d1c <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6d58:	80 e0       	ldi	r24, 0x00	; 0
    6d5a:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	portExCS(FALSE);
    6d5e:	80 e0       	ldi	r24, 0x00	; 0
    6d60:	0e 94 2f 34 	call	0x685e	; 0x685e <portExCS>
	SPIDisable();
    6d64:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
}
    6d68:	23 96       	adiw	r28, 0x03	; 3
    6d6a:	cd bf       	out	0x3d, r28	; 61
    6d6c:	de bf       	out	0x3e, r29	; 62
    6d6e:	df 91       	pop	r29
    6d70:	cf 91       	pop	r28
    6d72:	08 95       	ret

00006d74 <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6d74:	0f 93       	push	r16
    6d76:	1f 93       	push	r17
    6d78:	cf 93       	push	r28
    6d7a:	df 93       	push	r29
    6d7c:	cd b7       	in	r28, 0x3d	; 61
    6d7e:	de b7       	in	r29, 0x3e	; 62
    6d80:	2f 97       	sbiw	r28, 0x0f	; 15
    6d82:	cd bf       	out	0x3d, r28	; 61
    6d84:	de bf       	out	0x3e, r29	; 62
    6d86:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6d88:	8f 85       	ldd	r24, Y+15	; 0x0f
    6d8a:	88 23       	and	r24, r24
    6d8c:	09 f4       	brne	.+2      	; 0x6d90 <Ext1Power+0x1c>
    6d8e:	8b c0       	rjmp	.+278    	; 0x6ea6 <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6d90:	80 ea       	ldi	r24, 0xA0	; 160
    6d92:	96 e0       	ldi	r25, 0x06	; 6
    6d94:	20 e2       	ldi	r18, 0x20	; 32
    6d96:	fc 01       	movw	r30, r24
    6d98:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6d9a:	80 ea       	ldi	r24, 0xA0	; 160
    6d9c:	96 e0       	ldi	r25, 0x06	; 6
    6d9e:	20 e2       	ldi	r18, 0x20	; 32
    6da0:	fc 01       	movw	r30, r24
    6da2:	25 83       	std	Z+5, r18	; 0x05
    6da4:	80 e0       	ldi	r24, 0x00	; 0
    6da6:	90 e0       	ldi	r25, 0x00	; 0
    6da8:	a8 ec       	ldi	r26, 0xC8	; 200
    6daa:	b2 e4       	ldi	r27, 0x42	; 66
    6dac:	89 83       	std	Y+1, r24	; 0x01
    6dae:	9a 83       	std	Y+2, r25	; 0x02
    6db0:	ab 83       	std	Y+3, r26	; 0x03
    6db2:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6db4:	69 81       	ldd	r22, Y+1	; 0x01
    6db6:	7a 81       	ldd	r23, Y+2	; 0x02
    6db8:	8b 81       	ldd	r24, Y+3	; 0x03
    6dba:	9c 81       	ldd	r25, Y+4	; 0x04
    6dbc:	20 e0       	ldi	r18, 0x00	; 0
    6dbe:	30 e0       	ldi	r19, 0x00	; 0
    6dc0:	4a ef       	ldi	r20, 0xFA	; 250
    6dc2:	55 e4       	ldi	r21, 0x45	; 69
    6dc4:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    6dc8:	dc 01       	movw	r26, r24
    6dca:	cb 01       	movw	r24, r22
    6dcc:	8d 83       	std	Y+5, r24	; 0x05
    6dce:	9e 83       	std	Y+6, r25	; 0x06
    6dd0:	af 83       	std	Y+7, r26	; 0x07
    6dd2:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6dd4:	11 e0       	ldi	r17, 0x01	; 1
    6dd6:	6d 81       	ldd	r22, Y+5	; 0x05
    6dd8:	7e 81       	ldd	r23, Y+6	; 0x06
    6dda:	8f 81       	ldd	r24, Y+7	; 0x07
    6ddc:	98 85       	ldd	r25, Y+8	; 0x08
    6dde:	20 e0       	ldi	r18, 0x00	; 0
    6de0:	30 e0       	ldi	r19, 0x00	; 0
    6de2:	40 e8       	ldi	r20, 0x80	; 128
    6de4:	5f e3       	ldi	r21, 0x3F	; 63
    6de6:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    6dea:	88 23       	and	r24, r24
    6dec:	0c f0       	brlt	.+2      	; 0x6df0 <Ext1Power+0x7c>
    6dee:	10 e0       	ldi	r17, 0x00	; 0
    6df0:	11 23       	and	r17, r17
    6df2:	29 f0       	breq	.+10     	; 0x6dfe <Ext1Power+0x8a>
		__ticks = 1;
    6df4:	81 e0       	ldi	r24, 0x01	; 1
    6df6:	90 e0       	ldi	r25, 0x00	; 0
    6df8:	89 87       	std	Y+9, r24	; 0x09
    6dfa:	9a 87       	std	Y+10, r25	; 0x0a
    6dfc:	46 c0       	rjmp	.+140    	; 0x6e8a <Ext1Power+0x116>
	else if (__tmp > 65535)
    6dfe:	11 e0       	ldi	r17, 0x01	; 1
    6e00:	6d 81       	ldd	r22, Y+5	; 0x05
    6e02:	7e 81       	ldd	r23, Y+6	; 0x06
    6e04:	8f 81       	ldd	r24, Y+7	; 0x07
    6e06:	98 85       	ldd	r25, Y+8	; 0x08
    6e08:	20 e0       	ldi	r18, 0x00	; 0
    6e0a:	3f ef       	ldi	r19, 0xFF	; 255
    6e0c:	4f e7       	ldi	r20, 0x7F	; 127
    6e0e:	57 e4       	ldi	r21, 0x47	; 71
    6e10:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    6e14:	18 16       	cp	r1, r24
    6e16:	0c f0       	brlt	.+2      	; 0x6e1a <Ext1Power+0xa6>
    6e18:	10 e0       	ldi	r17, 0x00	; 0
    6e1a:	11 23       	and	r17, r17
    6e1c:	61 f1       	breq	.+88     	; 0x6e76 <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e1e:	69 81       	ldd	r22, Y+1	; 0x01
    6e20:	7a 81       	ldd	r23, Y+2	; 0x02
    6e22:	8b 81       	ldd	r24, Y+3	; 0x03
    6e24:	9c 81       	ldd	r25, Y+4	; 0x04
    6e26:	20 e0       	ldi	r18, 0x00	; 0
    6e28:	30 e0       	ldi	r19, 0x00	; 0
    6e2a:	40 e2       	ldi	r20, 0x20	; 32
    6e2c:	51 e4       	ldi	r21, 0x41	; 65
    6e2e:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    6e32:	dc 01       	movw	r26, r24
    6e34:	cb 01       	movw	r24, r22
    6e36:	bc 01       	movw	r22, r24
    6e38:	cd 01       	movw	r24, r26
    6e3a:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    6e3e:	dc 01       	movw	r26, r24
    6e40:	cb 01       	movw	r24, r22
    6e42:	89 87       	std	Y+9, r24	; 0x09
    6e44:	9a 87       	std	Y+10, r25	; 0x0a
    6e46:	12 c0       	rjmp	.+36     	; 0x6e6c <Ext1Power+0xf8>
    6e48:	80 e2       	ldi	r24, 0x20	; 32
    6e4a:	93 e0       	ldi	r25, 0x03	; 3
    6e4c:	8b 87       	std	Y+11, r24	; 0x0b
    6e4e:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6e50:	8b 85       	ldd	r24, Y+11	; 0x0b
    6e52:	9c 85       	ldd	r25, Y+12	; 0x0c
    6e54:	8c 01       	movw	r16, r24
    6e56:	c8 01       	movw	r24, r16
    6e58:	01 97       	sbiw	r24, 0x01	; 1
    6e5a:	f1 f7       	brne	.-4      	; 0x6e58 <Ext1Power+0xe4>
    6e5c:	8c 01       	movw	r16, r24
    6e5e:	0b 87       	std	Y+11, r16	; 0x0b
    6e60:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e62:	89 85       	ldd	r24, Y+9	; 0x09
    6e64:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e66:	01 97       	sbiw	r24, 0x01	; 1
    6e68:	89 87       	std	Y+9, r24	; 0x09
    6e6a:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e6c:	89 85       	ldd	r24, Y+9	; 0x09
    6e6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e70:	00 97       	sbiw	r24, 0x00	; 0
    6e72:	51 f7       	brne	.-44     	; 0x6e48 <Ext1Power+0xd4>
    6e74:	22 c0       	rjmp	.+68     	; 0x6eba <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e76:	6d 81       	ldd	r22, Y+5	; 0x05
    6e78:	7e 81       	ldd	r23, Y+6	; 0x06
    6e7a:	8f 81       	ldd	r24, Y+7	; 0x07
    6e7c:	98 85       	ldd	r25, Y+8	; 0x08
    6e7e:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    6e82:	dc 01       	movw	r26, r24
    6e84:	cb 01       	movw	r24, r22
    6e86:	89 87       	std	Y+9, r24	; 0x09
    6e88:	9a 87       	std	Y+10, r25	; 0x0a
    6e8a:	89 85       	ldd	r24, Y+9	; 0x09
    6e8c:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e8e:	8d 87       	std	Y+13, r24	; 0x0d
    6e90:	9e 87       	std	Y+14, r25	; 0x0e
    6e92:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e94:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e96:	8c 01       	movw	r16, r24
    6e98:	f8 01       	movw	r30, r16
    6e9a:	31 97       	sbiw	r30, 0x01	; 1
    6e9c:	f1 f7       	brne	.-4      	; 0x6e9a <Ext1Power+0x126>
    6e9e:	8f 01       	movw	r16, r30
    6ea0:	0d 87       	std	Y+13, r16	; 0x0d
    6ea2:	1e 87       	std	Y+14, r17	; 0x0e
    6ea4:	0a c0       	rjmp	.+20     	; 0x6eba <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6ea6:	80 ea       	ldi	r24, 0xA0	; 160
    6ea8:	96 e0       	ldi	r25, 0x06	; 6
    6eaa:	20 e2       	ldi	r18, 0x20	; 32
    6eac:	fc 01       	movw	r30, r24
    6eae:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6eb0:	80 ea       	ldi	r24, 0xA0	; 160
    6eb2:	96 e0       	ldi	r25, 0x06	; 6
    6eb4:	20 e2       	ldi	r18, 0x20	; 32
    6eb6:	fc 01       	movw	r30, r24
    6eb8:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6eba:	2f 96       	adiw	r28, 0x0f	; 15
    6ebc:	cd bf       	out	0x3d, r28	; 61
    6ebe:	de bf       	out	0x3e, r29	; 62
    6ec0:	df 91       	pop	r29
    6ec2:	cf 91       	pop	r28
    6ec4:	1f 91       	pop	r17
    6ec6:	0f 91       	pop	r16
    6ec8:	08 95       	ret

00006eca <Ext2Power>:

void Ext2Power(uint8_t on) {
    6eca:	0f 93       	push	r16
    6ecc:	1f 93       	push	r17
    6ece:	cf 93       	push	r28
    6ed0:	df 93       	push	r29
    6ed2:	cd b7       	in	r28, 0x3d	; 61
    6ed4:	de b7       	in	r29, 0x3e	; 62
    6ed6:	2f 97       	sbiw	r28, 0x0f	; 15
    6ed8:	cd bf       	out	0x3d, r28	; 61
    6eda:	de bf       	out	0x3e, r29	; 62
    6edc:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6ede:	8f 85       	ldd	r24, Y+15	; 0x0f
    6ee0:	88 23       	and	r24, r24
    6ee2:	09 f4       	brne	.+2      	; 0x6ee6 <Ext2Power+0x1c>
    6ee4:	8b c0       	rjmp	.+278    	; 0x6ffc <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6ee6:	80 ea       	ldi	r24, 0xA0	; 160
    6ee8:	96 e0       	ldi	r25, 0x06	; 6
    6eea:	20 e4       	ldi	r18, 0x40	; 64
    6eec:	fc 01       	movw	r30, r24
    6eee:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6ef0:	80 ea       	ldi	r24, 0xA0	; 160
    6ef2:	96 e0       	ldi	r25, 0x06	; 6
    6ef4:	20 e4       	ldi	r18, 0x40	; 64
    6ef6:	fc 01       	movw	r30, r24
    6ef8:	25 83       	std	Z+5, r18	; 0x05
    6efa:	80 e0       	ldi	r24, 0x00	; 0
    6efc:	90 e0       	ldi	r25, 0x00	; 0
    6efe:	a8 ec       	ldi	r26, 0xC8	; 200
    6f00:	b2 e4       	ldi	r27, 0x42	; 66
    6f02:	89 83       	std	Y+1, r24	; 0x01
    6f04:	9a 83       	std	Y+2, r25	; 0x02
    6f06:	ab 83       	std	Y+3, r26	; 0x03
    6f08:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6f0a:	69 81       	ldd	r22, Y+1	; 0x01
    6f0c:	7a 81       	ldd	r23, Y+2	; 0x02
    6f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    6f10:	9c 81       	ldd	r25, Y+4	; 0x04
    6f12:	20 e0       	ldi	r18, 0x00	; 0
    6f14:	30 e0       	ldi	r19, 0x00	; 0
    6f16:	4a ef       	ldi	r20, 0xFA	; 250
    6f18:	55 e4       	ldi	r21, 0x45	; 69
    6f1a:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    6f1e:	dc 01       	movw	r26, r24
    6f20:	cb 01       	movw	r24, r22
    6f22:	8d 83       	std	Y+5, r24	; 0x05
    6f24:	9e 83       	std	Y+6, r25	; 0x06
    6f26:	af 83       	std	Y+7, r26	; 0x07
    6f28:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6f2a:	11 e0       	ldi	r17, 0x01	; 1
    6f2c:	6d 81       	ldd	r22, Y+5	; 0x05
    6f2e:	7e 81       	ldd	r23, Y+6	; 0x06
    6f30:	8f 81       	ldd	r24, Y+7	; 0x07
    6f32:	98 85       	ldd	r25, Y+8	; 0x08
    6f34:	20 e0       	ldi	r18, 0x00	; 0
    6f36:	30 e0       	ldi	r19, 0x00	; 0
    6f38:	40 e8       	ldi	r20, 0x80	; 128
    6f3a:	5f e3       	ldi	r21, 0x3F	; 63
    6f3c:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    6f40:	88 23       	and	r24, r24
    6f42:	0c f0       	brlt	.+2      	; 0x6f46 <Ext2Power+0x7c>
    6f44:	10 e0       	ldi	r17, 0x00	; 0
    6f46:	11 23       	and	r17, r17
    6f48:	29 f0       	breq	.+10     	; 0x6f54 <Ext2Power+0x8a>
		__ticks = 1;
    6f4a:	81 e0       	ldi	r24, 0x01	; 1
    6f4c:	90 e0       	ldi	r25, 0x00	; 0
    6f4e:	89 87       	std	Y+9, r24	; 0x09
    6f50:	9a 87       	std	Y+10, r25	; 0x0a
    6f52:	46 c0       	rjmp	.+140    	; 0x6fe0 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6f54:	11 e0       	ldi	r17, 0x01	; 1
    6f56:	6d 81       	ldd	r22, Y+5	; 0x05
    6f58:	7e 81       	ldd	r23, Y+6	; 0x06
    6f5a:	8f 81       	ldd	r24, Y+7	; 0x07
    6f5c:	98 85       	ldd	r25, Y+8	; 0x08
    6f5e:	20 e0       	ldi	r18, 0x00	; 0
    6f60:	3f ef       	ldi	r19, 0xFF	; 255
    6f62:	4f e7       	ldi	r20, 0x7F	; 127
    6f64:	57 e4       	ldi	r21, 0x47	; 71
    6f66:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    6f6a:	18 16       	cp	r1, r24
    6f6c:	0c f0       	brlt	.+2      	; 0x6f70 <Ext2Power+0xa6>
    6f6e:	10 e0       	ldi	r17, 0x00	; 0
    6f70:	11 23       	and	r17, r17
    6f72:	61 f1       	breq	.+88     	; 0x6fcc <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6f74:	69 81       	ldd	r22, Y+1	; 0x01
    6f76:	7a 81       	ldd	r23, Y+2	; 0x02
    6f78:	8b 81       	ldd	r24, Y+3	; 0x03
    6f7a:	9c 81       	ldd	r25, Y+4	; 0x04
    6f7c:	20 e0       	ldi	r18, 0x00	; 0
    6f7e:	30 e0       	ldi	r19, 0x00	; 0
    6f80:	40 e2       	ldi	r20, 0x20	; 32
    6f82:	51 e4       	ldi	r21, 0x41	; 65
    6f84:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    6f88:	dc 01       	movw	r26, r24
    6f8a:	cb 01       	movw	r24, r22
    6f8c:	bc 01       	movw	r22, r24
    6f8e:	cd 01       	movw	r24, r26
    6f90:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    6f94:	dc 01       	movw	r26, r24
    6f96:	cb 01       	movw	r24, r22
    6f98:	89 87       	std	Y+9, r24	; 0x09
    6f9a:	9a 87       	std	Y+10, r25	; 0x0a
    6f9c:	12 c0       	rjmp	.+36     	; 0x6fc2 <Ext2Power+0xf8>
    6f9e:	80 e2       	ldi	r24, 0x20	; 32
    6fa0:	93 e0       	ldi	r25, 0x03	; 3
    6fa2:	8b 87       	std	Y+11, r24	; 0x0b
    6fa4:	9c 87       	std	Y+12, r25	; 0x0c
    6fa6:	8b 85       	ldd	r24, Y+11	; 0x0b
    6fa8:	9c 85       	ldd	r25, Y+12	; 0x0c
    6faa:	8c 01       	movw	r16, r24
    6fac:	c8 01       	movw	r24, r16
    6fae:	01 97       	sbiw	r24, 0x01	; 1
    6fb0:	f1 f7       	brne	.-4      	; 0x6fae <Ext2Power+0xe4>
    6fb2:	8c 01       	movw	r16, r24
    6fb4:	0b 87       	std	Y+11, r16	; 0x0b
    6fb6:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6fb8:	89 85       	ldd	r24, Y+9	; 0x09
    6fba:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fbc:	01 97       	sbiw	r24, 0x01	; 1
    6fbe:	89 87       	std	Y+9, r24	; 0x09
    6fc0:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6fc2:	89 85       	ldd	r24, Y+9	; 0x09
    6fc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fc6:	00 97       	sbiw	r24, 0x00	; 0
    6fc8:	51 f7       	brne	.-44     	; 0x6f9e <Ext2Power+0xd4>
    6fca:	22 c0       	rjmp	.+68     	; 0x7010 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6fcc:	6d 81       	ldd	r22, Y+5	; 0x05
    6fce:	7e 81       	ldd	r23, Y+6	; 0x06
    6fd0:	8f 81       	ldd	r24, Y+7	; 0x07
    6fd2:	98 85       	ldd	r25, Y+8	; 0x08
    6fd4:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    6fd8:	dc 01       	movw	r26, r24
    6fda:	cb 01       	movw	r24, r22
    6fdc:	89 87       	std	Y+9, r24	; 0x09
    6fde:	9a 87       	std	Y+10, r25	; 0x0a
    6fe0:	89 85       	ldd	r24, Y+9	; 0x09
    6fe2:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fe4:	8d 87       	std	Y+13, r24	; 0x0d
    6fe6:	9e 87       	std	Y+14, r25	; 0x0e
    6fe8:	8d 85       	ldd	r24, Y+13	; 0x0d
    6fea:	9e 85       	ldd	r25, Y+14	; 0x0e
    6fec:	8c 01       	movw	r16, r24
    6fee:	f8 01       	movw	r30, r16
    6ff0:	31 97       	sbiw	r30, 0x01	; 1
    6ff2:	f1 f7       	brne	.-4      	; 0x6ff0 <Ext2Power+0x126>
    6ff4:	8f 01       	movw	r16, r30
    6ff6:	0d 87       	std	Y+13, r16	; 0x0d
    6ff8:	1e 87       	std	Y+14, r17	; 0x0e
    6ffa:	0a c0       	rjmp	.+20     	; 0x7010 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6ffc:	80 ea       	ldi	r24, 0xA0	; 160
    6ffe:	96 e0       	ldi	r25, 0x06	; 6
    7000:	20 e4       	ldi	r18, 0x40	; 64
    7002:	fc 01       	movw	r30, r24
    7004:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    7006:	80 ea       	ldi	r24, 0xA0	; 160
    7008:	96 e0       	ldi	r25, 0x06	; 6
    700a:	20 e4       	ldi	r18, 0x40	; 64
    700c:	fc 01       	movw	r30, r24
    700e:	22 83       	std	Z+2, r18	; 0x02
	}
}
    7010:	2f 96       	adiw	r28, 0x0f	; 15
    7012:	cd bf       	out	0x3d, r28	; 61
    7014:	de bf       	out	0x3e, r29	; 62
    7016:	df 91       	pop	r29
    7018:	cf 91       	pop	r28
    701a:	1f 91       	pop	r17
    701c:	0f 91       	pop	r16
    701e:	08 95       	ret

00007020 <HVPower>:

void HVPower(uint8_t on) {
    7020:	0f 93       	push	r16
    7022:	1f 93       	push	r17
    7024:	cf 93       	push	r28
    7026:	df 93       	push	r29
    7028:	cd b7       	in	r28, 0x3d	; 61
    702a:	de b7       	in	r29, 0x3e	; 62
    702c:	a7 97       	sbiw	r28, 0x27	; 39
    702e:	cd bf       	out	0x3d, r28	; 61
    7030:	de bf       	out	0x3e, r29	; 62
    7032:	8f a3       	lds	r24, 0x5f
	if (on) {
    7034:	8f a1       	lds	r24, 0x4f
    7036:	88 23       	and	r24, r24
    7038:	09 f4       	brne	.+2      	; 0x703c <HVPower+0x1c>
    703a:	8b c0       	rjmp	.+278    	; 0x7152 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    703c:	80 ea       	ldi	r24, 0xA0	; 160
    703e:	96 e0       	ldi	r25, 0x06	; 6
    7040:	20 e8       	ldi	r18, 0x80	; 128
    7042:	fc 01       	movw	r30, r24
    7044:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    7046:	80 ea       	ldi	r24, 0xA0	; 160
    7048:	96 e0       	ldi	r25, 0x06	; 6
    704a:	20 e8       	ldi	r18, 0x80	; 128
    704c:	fc 01       	movw	r30, r24
    704e:	25 83       	std	Z+5, r18	; 0x05
    7050:	80 e0       	ldi	r24, 0x00	; 0
    7052:	90 e0       	ldi	r25, 0x00	; 0
    7054:	a8 ec       	ldi	r26, 0xC8	; 200
    7056:	b2 e4       	ldi	r27, 0x42	; 66
    7058:	89 83       	std	Y+1, r24	; 0x01
    705a:	9a 83       	std	Y+2, r25	; 0x02
    705c:	ab 83       	std	Y+3, r26	; 0x03
    705e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7060:	69 81       	ldd	r22, Y+1	; 0x01
    7062:	7a 81       	ldd	r23, Y+2	; 0x02
    7064:	8b 81       	ldd	r24, Y+3	; 0x03
    7066:	9c 81       	ldd	r25, Y+4	; 0x04
    7068:	20 e0       	ldi	r18, 0x00	; 0
    706a:	30 e0       	ldi	r19, 0x00	; 0
    706c:	4a ef       	ldi	r20, 0xFA	; 250
    706e:	55 e4       	ldi	r21, 0x45	; 69
    7070:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7074:	dc 01       	movw	r26, r24
    7076:	cb 01       	movw	r24, r22
    7078:	8d 83       	std	Y+5, r24	; 0x05
    707a:	9e 83       	std	Y+6, r25	; 0x06
    707c:	af 83       	std	Y+7, r26	; 0x07
    707e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7080:	11 e0       	ldi	r17, 0x01	; 1
    7082:	6d 81       	ldd	r22, Y+5	; 0x05
    7084:	7e 81       	ldd	r23, Y+6	; 0x06
    7086:	8f 81       	ldd	r24, Y+7	; 0x07
    7088:	98 85       	ldd	r25, Y+8	; 0x08
    708a:	20 e0       	ldi	r18, 0x00	; 0
    708c:	30 e0       	ldi	r19, 0x00	; 0
    708e:	40 e8       	ldi	r20, 0x80	; 128
    7090:	5f e3       	ldi	r21, 0x3F	; 63
    7092:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7096:	88 23       	and	r24, r24
    7098:	0c f0       	brlt	.+2      	; 0x709c <HVPower+0x7c>
    709a:	10 e0       	ldi	r17, 0x00	; 0
    709c:	11 23       	and	r17, r17
    709e:	29 f0       	breq	.+10     	; 0x70aa <HVPower+0x8a>
		__ticks = 1;
    70a0:	81 e0       	ldi	r24, 0x01	; 1
    70a2:	90 e0       	ldi	r25, 0x00	; 0
    70a4:	89 87       	std	Y+9, r24	; 0x09
    70a6:	9a 87       	std	Y+10, r25	; 0x0a
    70a8:	46 c0       	rjmp	.+140    	; 0x7136 <HVPower+0x116>
	else if (__tmp > 65535)
    70aa:	11 e0       	ldi	r17, 0x01	; 1
    70ac:	6d 81       	ldd	r22, Y+5	; 0x05
    70ae:	7e 81       	ldd	r23, Y+6	; 0x06
    70b0:	8f 81       	ldd	r24, Y+7	; 0x07
    70b2:	98 85       	ldd	r25, Y+8	; 0x08
    70b4:	20 e0       	ldi	r18, 0x00	; 0
    70b6:	3f ef       	ldi	r19, 0xFF	; 255
    70b8:	4f e7       	ldi	r20, 0x7F	; 127
    70ba:	57 e4       	ldi	r21, 0x47	; 71
    70bc:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    70c0:	18 16       	cp	r1, r24
    70c2:	0c f0       	brlt	.+2      	; 0x70c6 <HVPower+0xa6>
    70c4:	10 e0       	ldi	r17, 0x00	; 0
    70c6:	11 23       	and	r17, r17
    70c8:	61 f1       	breq	.+88     	; 0x7122 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    70ca:	69 81       	ldd	r22, Y+1	; 0x01
    70cc:	7a 81       	ldd	r23, Y+2	; 0x02
    70ce:	8b 81       	ldd	r24, Y+3	; 0x03
    70d0:	9c 81       	ldd	r25, Y+4	; 0x04
    70d2:	20 e0       	ldi	r18, 0x00	; 0
    70d4:	30 e0       	ldi	r19, 0x00	; 0
    70d6:	40 e2       	ldi	r20, 0x20	; 32
    70d8:	51 e4       	ldi	r21, 0x41	; 65
    70da:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    70de:	dc 01       	movw	r26, r24
    70e0:	cb 01       	movw	r24, r22
    70e2:	bc 01       	movw	r22, r24
    70e4:	cd 01       	movw	r24, r26
    70e6:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    70ea:	dc 01       	movw	r26, r24
    70ec:	cb 01       	movw	r24, r22
    70ee:	89 87       	std	Y+9, r24	; 0x09
    70f0:	9a 87       	std	Y+10, r25	; 0x0a
    70f2:	12 c0       	rjmp	.+36     	; 0x7118 <HVPower+0xf8>
    70f4:	80 e2       	ldi	r24, 0x20	; 32
    70f6:	93 e0       	ldi	r25, 0x03	; 3
    70f8:	8b 87       	std	Y+11, r24	; 0x0b
    70fa:	9c 87       	std	Y+12, r25	; 0x0c
    70fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    70fe:	9c 85       	ldd	r25, Y+12	; 0x0c
    7100:	8c 01       	movw	r16, r24
    7102:	c8 01       	movw	r24, r16
    7104:	01 97       	sbiw	r24, 0x01	; 1
    7106:	f1 f7       	brne	.-4      	; 0x7104 <HVPower+0xe4>
    7108:	8c 01       	movw	r16, r24
    710a:	0b 87       	std	Y+11, r16	; 0x0b
    710c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    710e:	89 85       	ldd	r24, Y+9	; 0x09
    7110:	9a 85       	ldd	r25, Y+10	; 0x0a
    7112:	01 97       	sbiw	r24, 0x01	; 1
    7114:	89 87       	std	Y+9, r24	; 0x09
    7116:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7118:	89 85       	ldd	r24, Y+9	; 0x09
    711a:	9a 85       	ldd	r25, Y+10	; 0x0a
    711c:	00 97       	sbiw	r24, 0x00	; 0
    711e:	51 f7       	brne	.-44     	; 0x70f4 <HVPower+0xd4>
    7120:	22 c0       	rjmp	.+68     	; 0x7166 <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7122:	6d 81       	ldd	r22, Y+5	; 0x05
    7124:	7e 81       	ldd	r23, Y+6	; 0x06
    7126:	8f 81       	ldd	r24, Y+7	; 0x07
    7128:	98 85       	ldd	r25, Y+8	; 0x08
    712a:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    712e:	dc 01       	movw	r26, r24
    7130:	cb 01       	movw	r24, r22
    7132:	89 87       	std	Y+9, r24	; 0x09
    7134:	9a 87       	std	Y+10, r25	; 0x0a
    7136:	89 85       	ldd	r24, Y+9	; 0x09
    7138:	9a 85       	ldd	r25, Y+10	; 0x0a
    713a:	8d 87       	std	Y+13, r24	; 0x0d
    713c:	9e 87       	std	Y+14, r25	; 0x0e
    713e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7140:	9e 85       	ldd	r25, Y+14	; 0x0e
    7142:	8c 01       	movw	r16, r24
    7144:	f8 01       	movw	r30, r16
    7146:	31 97       	sbiw	r30, 0x01	; 1
    7148:	f1 f7       	brne	.-4      	; 0x7146 <HVPower+0x126>
    714a:	8f 01       	movw	r16, r30
    714c:	0d 87       	std	Y+13, r16	; 0x0d
    714e:	1e 87       	std	Y+14, r17	; 0x0e
    7150:	0a c0       	rjmp	.+20     	; 0x7166 <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    7152:	80 ea       	ldi	r24, 0xA0	; 160
    7154:	96 e0       	ldi	r25, 0x06	; 6
    7156:	20 e8       	ldi	r18, 0x80	; 128
    7158:	fc 01       	movw	r30, r24
    715a:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    715c:	80 ea       	ldi	r24, 0xA0	; 160
    715e:	96 e0       	ldi	r25, 0x06	; 6
    7160:	20 e8       	ldi	r18, 0x80	; 128
    7162:	fc 01       	movw	r30, r24
    7164:	22 83       	std	Z+2, r18	; 0x02
    7166:	80 e0       	ldi	r24, 0x00	; 0
    7168:	90 e0       	ldi	r25, 0x00	; 0
    716a:	aa e7       	ldi	r26, 0x7A	; 122
    716c:	b4 e4       	ldi	r27, 0x44	; 68
    716e:	8f 87       	std	Y+15, r24	; 0x0f
    7170:	98 8b       	std	Y+16, r25	; 0x10
    7172:	a9 8b       	std	Y+17, r26	; 0x11
    7174:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7176:	6f 85       	ldd	r22, Y+15	; 0x0f
    7178:	78 89       	ldd	r23, Y+16	; 0x10
    717a:	89 89       	ldd	r24, Y+17	; 0x11
    717c:	9a 89       	ldd	r25, Y+18	; 0x12
    717e:	2b ea       	ldi	r18, 0xAB	; 171
    7180:	3a ea       	ldi	r19, 0xAA	; 170
    7182:	4a e2       	ldi	r20, 0x2A	; 42
    7184:	51 e4       	ldi	r21, 0x41	; 65
    7186:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    718a:	dc 01       	movw	r26, r24
    718c:	cb 01       	movw	r24, r22
    718e:	8b 8b       	std	Y+19, r24	; 0x13
    7190:	9c 8b       	std	Y+20, r25	; 0x14
    7192:	ad 8b       	std	Y+21, r26	; 0x15
    7194:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7196:	11 e0       	ldi	r17, 0x01	; 1
    7198:	6b 89       	ldd	r22, Y+19	; 0x13
    719a:	7c 89       	ldd	r23, Y+20	; 0x14
    719c:	8d 89       	ldd	r24, Y+21	; 0x15
    719e:	9e 89       	ldd	r25, Y+22	; 0x16
    71a0:	20 e0       	ldi	r18, 0x00	; 0
    71a2:	30 e0       	ldi	r19, 0x00	; 0
    71a4:	40 e8       	ldi	r20, 0x80	; 128
    71a6:	5f e3       	ldi	r21, 0x3F	; 63
    71a8:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    71ac:	88 23       	and	r24, r24
    71ae:	0c f0       	brlt	.+2      	; 0x71b2 <HVPower+0x192>
    71b0:	10 e0       	ldi	r17, 0x00	; 0
    71b2:	11 23       	and	r17, r17
    71b4:	19 f0       	breq	.+6      	; 0x71bc <HVPower+0x19c>
		__ticks = 1;
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	8f 8b       	std	Y+23, r24	; 0x17
    71ba:	a3 c0       	rjmp	.+326    	; 0x7302 <HVPower+0x2e2>
	else if (__tmp > 255)
    71bc:	11 e0       	ldi	r17, 0x01	; 1
    71be:	6b 89       	ldd	r22, Y+19	; 0x13
    71c0:	7c 89       	ldd	r23, Y+20	; 0x14
    71c2:	8d 89       	ldd	r24, Y+21	; 0x15
    71c4:	9e 89       	ldd	r25, Y+22	; 0x16
    71c6:	20 e0       	ldi	r18, 0x00	; 0
    71c8:	30 e0       	ldi	r19, 0x00	; 0
    71ca:	4f e7       	ldi	r20, 0x7F	; 127
    71cc:	53 e4       	ldi	r21, 0x43	; 67
    71ce:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    71d2:	18 16       	cp	r1, r24
    71d4:	0c f0       	brlt	.+2      	; 0x71d8 <HVPower+0x1b8>
    71d6:	10 e0       	ldi	r17, 0x00	; 0
    71d8:	11 23       	and	r17, r17
    71da:	09 f4       	brne	.+2      	; 0x71de <HVPower+0x1be>
    71dc:	89 c0       	rjmp	.+274    	; 0x72f0 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    71de:	6f 85       	ldd	r22, Y+15	; 0x0f
    71e0:	78 89       	ldd	r23, Y+16	; 0x10
    71e2:	89 89       	ldd	r24, Y+17	; 0x11
    71e4:	9a 89       	ldd	r25, Y+18	; 0x12
    71e6:	20 e0       	ldi	r18, 0x00	; 0
    71e8:	30 e0       	ldi	r19, 0x00	; 0
    71ea:	4a e7       	ldi	r20, 0x7A	; 122
    71ec:	54 e4       	ldi	r21, 0x44	; 68
    71ee:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    71f2:	dc 01       	movw	r26, r24
    71f4:	cb 01       	movw	r24, r22
    71f6:	88 8f       	std	Y+24, r24	; 0x18
    71f8:	99 8f       	std	Y+25, r25	; 0x19
    71fa:	aa 8f       	std	Y+26, r26	; 0x1a
    71fc:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    71fe:	68 8d       	ldd	r22, Y+24	; 0x18
    7200:	79 8d       	ldd	r23, Y+25	; 0x19
    7202:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7204:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7206:	20 e0       	ldi	r18, 0x00	; 0
    7208:	30 e0       	ldi	r19, 0x00	; 0
    720a:	4a ef       	ldi	r20, 0xFA	; 250
    720c:	55 e4       	ldi	r21, 0x45	; 69
    720e:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7212:	dc 01       	movw	r26, r24
    7214:	cb 01       	movw	r24, r22
    7216:	8c 8f       	std	Y+28, r24	; 0x1c
    7218:	9d 8f       	std	Y+29, r25	; 0x1d
    721a:	ae 8f       	std	Y+30, r26	; 0x1e
    721c:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    721e:	11 e0       	ldi	r17, 0x01	; 1
    7220:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7222:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7224:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7226:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7228:	20 e0       	ldi	r18, 0x00	; 0
    722a:	30 e0       	ldi	r19, 0x00	; 0
    722c:	40 e8       	ldi	r20, 0x80	; 128
    722e:	5f e3       	ldi	r21, 0x3F	; 63
    7230:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7234:	88 23       	and	r24, r24
    7236:	0c f0       	brlt	.+2      	; 0x723a <HVPower+0x21a>
    7238:	10 e0       	ldi	r17, 0x00	; 0
    723a:	11 23       	and	r17, r17
    723c:	29 f0       	breq	.+10     	; 0x7248 <HVPower+0x228>
		__ticks = 1;
    723e:	81 e0       	ldi	r24, 0x01	; 1
    7240:	90 e0       	ldi	r25, 0x00	; 0
    7242:	88 a3       	lds	r24, 0x58
    7244:	99 a3       	lds	r25, 0x59
    7246:	46 c0       	rjmp	.+140    	; 0x72d4 <HVPower+0x2b4>
	else if (__tmp > 65535)
    7248:	11 e0       	ldi	r17, 0x01	; 1
    724a:	6c 8d       	ldd	r22, Y+28	; 0x1c
    724c:	7d 8d       	ldd	r23, Y+29	; 0x1d
    724e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7250:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7252:	20 e0       	ldi	r18, 0x00	; 0
    7254:	3f ef       	ldi	r19, 0xFF	; 255
    7256:	4f e7       	ldi	r20, 0x7F	; 127
    7258:	57 e4       	ldi	r21, 0x47	; 71
    725a:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    725e:	18 16       	cp	r1, r24
    7260:	0c f0       	brlt	.+2      	; 0x7264 <HVPower+0x244>
    7262:	10 e0       	ldi	r17, 0x00	; 0
    7264:	11 23       	and	r17, r17
    7266:	61 f1       	breq	.+88     	; 0x72c0 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7268:	68 8d       	ldd	r22, Y+24	; 0x18
    726a:	79 8d       	ldd	r23, Y+25	; 0x19
    726c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    726e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7270:	20 e0       	ldi	r18, 0x00	; 0
    7272:	30 e0       	ldi	r19, 0x00	; 0
    7274:	40 e2       	ldi	r20, 0x20	; 32
    7276:	51 e4       	ldi	r21, 0x41	; 65
    7278:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    727c:	dc 01       	movw	r26, r24
    727e:	cb 01       	movw	r24, r22
    7280:	bc 01       	movw	r22, r24
    7282:	cd 01       	movw	r24, r26
    7284:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7288:	dc 01       	movw	r26, r24
    728a:	cb 01       	movw	r24, r22
    728c:	88 a3       	lds	r24, 0x58
    728e:	99 a3       	lds	r25, 0x59
    7290:	12 c0       	rjmp	.+36     	; 0x72b6 <HVPower+0x296>
    7292:	80 e2       	ldi	r24, 0x20	; 32
    7294:	93 e0       	ldi	r25, 0x03	; 3
    7296:	8a a3       	lds	r24, 0x5a
    7298:	9b a3       	lds	r25, 0x5b
    729a:	8a a1       	lds	r24, 0x4a
    729c:	9b a1       	lds	r25, 0x4b
    729e:	8c 01       	movw	r16, r24
    72a0:	c8 01       	movw	r24, r16
    72a2:	01 97       	sbiw	r24, 0x01	; 1
    72a4:	f1 f7       	brne	.-4      	; 0x72a2 <HVPower+0x282>
    72a6:	8c 01       	movw	r16, r24
    72a8:	0a a3       	lds	r16, 0x5a
    72aa:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    72ac:	88 a1       	lds	r24, 0x48
    72ae:	99 a1       	lds	r25, 0x49
    72b0:	01 97       	sbiw	r24, 0x01	; 1
    72b2:	88 a3       	lds	r24, 0x58
    72b4:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    72b6:	88 a1       	lds	r24, 0x48
    72b8:	99 a1       	lds	r25, 0x49
    72ba:	00 97       	sbiw	r24, 0x00	; 0
    72bc:	51 f7       	brne	.-44     	; 0x7292 <HVPower+0x272>
    72be:	28 c0       	rjmp	.+80     	; 0x7310 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    72c0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    72c2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    72c4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    72c6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    72c8:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    72cc:	dc 01       	movw	r26, r24
    72ce:	cb 01       	movw	r24, r22
    72d0:	88 a3       	lds	r24, 0x58
    72d2:	99 a3       	lds	r25, 0x59
    72d4:	88 a1       	lds	r24, 0x48
    72d6:	99 a1       	lds	r25, 0x49
    72d8:	8c a3       	lds	r24, 0x5c
    72da:	9d a3       	lds	r25, 0x5d
    72dc:	8c a1       	lds	r24, 0x4c
    72de:	9d a1       	lds	r25, 0x4d
    72e0:	8c 01       	movw	r16, r24
    72e2:	f8 01       	movw	r30, r16
    72e4:	31 97       	sbiw	r30, 0x01	; 1
    72e6:	f1 f7       	brne	.-4      	; 0x72e4 <HVPower+0x2c4>
    72e8:	8f 01       	movw	r16, r30
    72ea:	0c a3       	lds	r16, 0x5c
    72ec:	1d a3       	lds	r17, 0x5d
    72ee:	10 c0       	rjmp	.+32     	; 0x7310 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    72f0:	6b 89       	ldd	r22, Y+19	; 0x13
    72f2:	7c 89       	ldd	r23, Y+20	; 0x14
    72f4:	8d 89       	ldd	r24, Y+21	; 0x15
    72f6:	9e 89       	ldd	r25, Y+22	; 0x16
    72f8:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    72fc:	dc 01       	movw	r26, r24
    72fe:	cb 01       	movw	r24, r22
    7300:	8f 8b       	std	Y+23, r24	; 0x17
    7302:	8f 89       	ldd	r24, Y+23	; 0x17
    7304:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7306:	8e a1       	lds	r24, 0x4e
    7308:	18 2f       	mov	r17, r24
    730a:	1a 95       	dec	r17
    730c:	f1 f7       	brne	.-4      	; 0x730a <HVPower+0x2ea>
    730e:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    7310:	a7 96       	adiw	r28, 0x27	; 39
    7312:	cd bf       	out	0x3d, r28	; 61
    7314:	de bf       	out	0x3e, r29	; 62
    7316:	df 91       	pop	r29
    7318:	cf 91       	pop	r28
    731a:	1f 91       	pop	r17
    731c:	0f 91       	pop	r16
    731e:	08 95       	ret

00007320 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    7320:	cf 93       	push	r28
    7322:	df 93       	push	r29
    7324:	0f 92       	push	r0
    7326:	cd b7       	in	r28, 0x3d	; 61
    7328:	de b7       	in	r29, 0x3e	; 62
    732a:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    732c:	89 81       	ldd	r24, Y+1	; 0x01
    732e:	88 23       	and	r24, r24
    7330:	31 f0       	breq	.+12     	; 0x733e <lowerMuxCS+0x1e>
    7332:	80 e8       	ldi	r24, 0x80	; 128
    7334:	96 e0       	ldi	r25, 0x06	; 6
    7336:	20 e1       	ldi	r18, 0x10	; 16
    7338:	fc 01       	movw	r30, r24
    733a:	26 83       	std	Z+6, r18	; 0x06
    733c:	05 c0       	rjmp	.+10     	; 0x7348 <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    733e:	80 e8       	ldi	r24, 0x80	; 128
    7340:	96 e0       	ldi	r25, 0x06	; 6
    7342:	20 e1       	ldi	r18, 0x10	; 16
    7344:	fc 01       	movw	r30, r24
    7346:	25 83       	std	Z+5, r18	; 0x05
}
    7348:	0f 90       	pop	r0
    734a:	df 91       	pop	r29
    734c:	cf 91       	pop	r28
    734e:	08 95       	ret

00007350 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    7350:	cf 93       	push	r28
    7352:	df 93       	push	r29
    7354:	0f 92       	push	r0
    7356:	cd b7       	in	r28, 0x3d	; 61
    7358:	de b7       	in	r29, 0x3e	; 62
    735a:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    735c:	89 81       	ldd	r24, Y+1	; 0x01
    735e:	88 23       	and	r24, r24
    7360:	31 f0       	breq	.+12     	; 0x736e <upperMuxCS+0x1e>
    7362:	80 e4       	ldi	r24, 0x40	; 64
    7364:	96 e0       	ldi	r25, 0x06	; 6
    7366:	22 e0       	ldi	r18, 0x02	; 2
    7368:	fc 01       	movw	r30, r24
    736a:	26 83       	std	Z+6, r18	; 0x06
    736c:	05 c0       	rjmp	.+10     	; 0x7378 <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    736e:	80 e4       	ldi	r24, 0x40	; 64
    7370:	96 e0       	ldi	r25, 0x06	; 6
    7372:	22 e0       	ldi	r18, 0x02	; 2
    7374:	fc 01       	movw	r30, r24
    7376:	25 83       	std	Z+5, r18	; 0x05
}
    7378:	0f 90       	pop	r0
    737a:	df 91       	pop	r29
    737c:	cf 91       	pop	r28
    737e:	08 95       	ret

00007380 <SPIInit>:

void SPIInit(uint8_t mode) {
    7380:	cf 93       	push	r28
    7382:	df 93       	push	r29
    7384:	0f 92       	push	r0
    7386:	cd b7       	in	r28, 0x3d	; 61
    7388:	de b7       	in	r29, 0x3e	; 62
    738a:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    738c:	80 e4       	ldi	r24, 0x40	; 64
    738e:	96 e0       	ldi	r25, 0x06	; 6
    7390:	20 e1       	ldi	r18, 0x10	; 16
    7392:	fc 01       	movw	r30, r24
    7394:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    7396:	80 e4       	ldi	r24, 0x40	; 64
    7398:	96 e0       	ldi	r25, 0x06	; 6
    739a:	28 e3       	ldi	r18, 0x38	; 56
    739c:	fc 01       	movw	r30, r24
    739e:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    73a0:	80 e4       	ldi	r24, 0x40	; 64
    73a2:	96 e0       	ldi	r25, 0x06	; 6
    73a4:	20 e1       	ldi	r18, 0x10	; 16
    73a6:	fc 01       	movw	r30, r24
    73a8:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    73aa:	80 ec       	ldi	r24, 0xC0	; 192
    73ac:	98 e0       	ldi	r25, 0x08	; 8
    73ae:	29 81       	ldd	r18, Y+1	; 0x01
    73b0:	21 65       	ori	r18, 0x51	; 81
    73b2:	fc 01       	movw	r30, r24
    73b4:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    73b6:	80 ec       	ldi	r24, 0xC0	; 192
    73b8:	98 e0       	ldi	r25, 0x08	; 8
    73ba:	fc 01       	movw	r30, r24
    73bc:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    73be:	80 e4       	ldi	r24, 0x40	; 64
    73c0:	96 e0       	ldi	r25, 0x06	; 6
    73c2:	20 ea       	ldi	r18, 0xA0	; 160
    73c4:	fc 01       	movw	r30, r24
    73c6:	21 83       	std	Z+1, r18	; 0x01

	
}
    73c8:	0f 90       	pop	r0
    73ca:	df 91       	pop	r29
    73cc:	cf 91       	pop	r28
    73ce:	08 95       	ret

000073d0 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    73d0:	cf 93       	push	r28
    73d2:	df 93       	push	r29
    73d4:	0f 92       	push	r0
    73d6:	0f 92       	push	r0
    73d8:	cd b7       	in	r28, 0x3d	; 61
    73da:	de b7       	in	r29, 0x3e	; 62
    73dc:	89 83       	std	Y+1, r24	; 0x01
    73de:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    73e0:	80 e4       	ldi	r24, 0x40	; 64
    73e2:	96 e0       	ldi	r25, 0x06	; 6
    73e4:	20 e1       	ldi	r18, 0x10	; 16
    73e6:	fc 01       	movw	r30, r24
    73e8:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    73ea:	80 e4       	ldi	r24, 0x40	; 64
    73ec:	96 e0       	ldi	r25, 0x06	; 6
    73ee:	28 e3       	ldi	r18, 0x38	; 56
    73f0:	fc 01       	movw	r30, r24
    73f2:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    73f4:	80 e4       	ldi	r24, 0x40	; 64
    73f6:	96 e0       	ldi	r25, 0x06	; 6
    73f8:	20 e1       	ldi	r18, 0x10	; 16
    73fa:	fc 01       	movw	r30, r24
    73fc:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    73fe:	80 ec       	ldi	r24, 0xC0	; 192
    7400:	98 e0       	ldi	r25, 0x08	; 8
    7402:	3a 81       	ldd	r19, Y+2	; 0x02
    7404:	29 81       	ldd	r18, Y+1	; 0x01
    7406:	23 2b       	or	r18, r19
    7408:	20 65       	ori	r18, 0x50	; 80
    740a:	fc 01       	movw	r30, r24
    740c:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    740e:	80 ec       	ldi	r24, 0xC0	; 192
    7410:	98 e0       	ldi	r25, 0x08	; 8
    7412:	fc 01       	movw	r30, r24
    7414:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    7416:	80 e4       	ldi	r24, 0x40	; 64
    7418:	96 e0       	ldi	r25, 0x06	; 6
    741a:	20 ea       	ldi	r18, 0xA0	; 160
    741c:	fc 01       	movw	r30, r24
    741e:	21 83       	std	Z+1, r18	; 0x01
}
    7420:	0f 90       	pop	r0
    7422:	0f 90       	pop	r0
    7424:	df 91       	pop	r29
    7426:	cf 91       	pop	r28
    7428:	08 95       	ret

0000742a <SPICS>:

void SPICS(uint8_t enable) {
    742a:	cf 93       	push	r28
    742c:	df 93       	push	r29
    742e:	0f 92       	push	r0
    7430:	cd b7       	in	r28, 0x3d	; 61
    7432:	de b7       	in	r29, 0x3e	; 62
    7434:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    7436:	89 81       	ldd	r24, Y+1	; 0x01
    7438:	88 23       	and	r24, r24
    743a:	31 f0       	breq	.+12     	; 0x7448 <SPICS+0x1e>
    743c:	80 e4       	ldi	r24, 0x40	; 64
    743e:	96 e0       	ldi	r25, 0x06	; 6
    7440:	20 e1       	ldi	r18, 0x10	; 16
    7442:	fc 01       	movw	r30, r24
    7444:	26 83       	std	Z+6, r18	; 0x06
    7446:	05 c0       	rjmp	.+10     	; 0x7452 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    7448:	80 e4       	ldi	r24, 0x40	; 64
    744a:	96 e0       	ldi	r25, 0x06	; 6
    744c:	20 e1       	ldi	r18, 0x10	; 16
    744e:	fc 01       	movw	r30, r24
    7450:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    7452:	0f 90       	pop	r0
    7454:	df 91       	pop	r29
    7456:	cf 91       	pop	r28
    7458:	08 95       	ret

0000745a <SPIDisable>:

void SPIDisable() {
    745a:	cf 93       	push	r28
    745c:	df 93       	push	r29
    745e:	cd b7       	in	r28, 0x3d	; 61
    7460:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    7462:	80 e4       	ldi	r24, 0x40	; 64
    7464:	96 e0       	ldi	r25, 0x06	; 6
    7466:	20 e1       	ldi	r18, 0x10	; 16
    7468:	fc 01       	movw	r30, r24
    746a:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    746c:	80 ec       	ldi	r24, 0xC0	; 192
    746e:	98 e0       	ldi	r25, 0x08	; 8
    7470:	fc 01       	movw	r30, r24
    7472:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    7474:	80 e4       	ldi	r24, 0x40	; 64
    7476:	96 e0       	ldi	r25, 0x06	; 6
    7478:	20 e1       	ldi	r18, 0x10	; 16
    747a:	fc 01       	movw	r30, r24
    747c:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    747e:	80 e4       	ldi	r24, 0x40	; 64
    7480:	96 e0       	ldi	r25, 0x06	; 6
    7482:	20 eb       	ldi	r18, 0xB0	; 176
    7484:	fc 01       	movw	r30, r24
    7486:	22 83       	std	Z+2, r18	; 0x02

}
    7488:	df 91       	pop	r29
    748a:	cf 91       	pop	r28
    748c:	08 95       	ret

0000748e <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    748e:	cf 93       	push	r28
    7490:	df 93       	push	r29
    7492:	00 d0       	rcall	.+0      	; 0x7494 <readFRAM+0x6>
    7494:	0f 92       	push	r0
    7496:	cd b7       	in	r28, 0x3d	; 61
    7498:	de b7       	in	r29, 0x3e	; 62
    749a:	8b 83       	std	Y+3, r24	; 0x03
    749c:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    749e:	80 e0       	ldi	r24, 0x00	; 0
    74a0:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    74a4:	80 ec       	ldi	r24, 0xC0	; 192
    74a6:	98 e0       	ldi	r25, 0x08	; 8
    74a8:	20 ed       	ldi	r18, 0xD0	; 208
    74aa:	fc 01       	movw	r30, r24
    74ac:	20 83       	st	Z, r18
	SPICS(TRUE);
    74ae:	81 e0       	ldi	r24, 0x01	; 1
    74b0:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    74b4:	80 e2       	ldi	r24, 0x20	; 32
    74b6:	96 e0       	ldi	r25, 0x06	; 6
    74b8:	28 e0       	ldi	r18, 0x08	; 8
    74ba:	fc 01       	movw	r30, r24
    74bc:	26 83       	std	Z+6, r18	; 0x06
	nop();
    74be:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    74c0:	80 ec       	ldi	r24, 0xC0	; 192
    74c2:	98 e0       	ldi	r25, 0x08	; 8
    74c4:	23 e0       	ldi	r18, 0x03	; 3
    74c6:	fc 01       	movw	r30, r24
    74c8:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74ca:	00 00       	nop
    74cc:	80 ec       	ldi	r24, 0xC0	; 192
    74ce:	98 e0       	ldi	r25, 0x08	; 8
    74d0:	fc 01       	movw	r30, r24
    74d2:	82 81       	ldd	r24, Z+2	; 0x02
    74d4:	88 23       	and	r24, r24
    74d6:	d4 f7       	brge	.-12     	; 0x74cc <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    74d8:	80 ec       	ldi	r24, 0xC0	; 192
    74da:	98 e0       	ldi	r25, 0x08	; 8
    74dc:	fc 01       	movw	r30, r24
    74de:	83 81       	ldd	r24, Z+3	; 0x03
    74e0:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    74e4:	80 ec       	ldi	r24, 0xC0	; 192
    74e6:	98 e0       	ldi	r25, 0x08	; 8
    74e8:	20 91 4d 40 	lds	r18, 0x404D
    74ec:	fc 01       	movw	r30, r24
    74ee:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74f0:	00 00       	nop
    74f2:	80 ec       	ldi	r24, 0xC0	; 192
    74f4:	98 e0       	ldi	r25, 0x08	; 8
    74f6:	fc 01       	movw	r30, r24
    74f8:	82 81       	ldd	r24, Z+2	; 0x02
    74fa:	88 23       	and	r24, r24
    74fc:	d4 f7       	brge	.-12     	; 0x74f2 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    74fe:	80 ec       	ldi	r24, 0xC0	; 192
    7500:	98 e0       	ldi	r25, 0x08	; 8
    7502:	fc 01       	movw	r30, r24
    7504:	83 81       	ldd	r24, Z+3	; 0x03
    7506:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    750a:	80 ec       	ldi	r24, 0xC0	; 192
    750c:	98 e0       	ldi	r25, 0x08	; 8
    750e:	2c e4       	ldi	r18, 0x4C	; 76
    7510:	30 e4       	ldi	r19, 0x40	; 64
    7512:	f9 01       	movw	r30, r18
    7514:	20 81       	ld	r18, Z
    7516:	fc 01       	movw	r30, r24
    7518:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    751a:	00 00       	nop
    751c:	80 ec       	ldi	r24, 0xC0	; 192
    751e:	98 e0       	ldi	r25, 0x08	; 8
    7520:	fc 01       	movw	r30, r24
    7522:	82 81       	ldd	r24, Z+2	; 0x02
    7524:	88 23       	and	r24, r24
    7526:	d4 f7       	brge	.-12     	; 0x751c <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    7528:	80 ec       	ldi	r24, 0xC0	; 192
    752a:	98 e0       	ldi	r25, 0x08	; 8
    752c:	fc 01       	movw	r30, r24
    752e:	83 81       	ldd	r24, Z+3	; 0x03
    7530:	80 93 66 50 	sts	0x5066, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7534:	19 82       	std	Y+1, r1	; 0x01
    7536:	1a 82       	std	Y+2, r1	; 0x02
    7538:	1b c0       	rjmp	.+54     	; 0x7570 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    753a:	80 ec       	ldi	r24, 0xC0	; 192
    753c:	98 e0       	ldi	r25, 0x08	; 8
    753e:	2a ea       	ldi	r18, 0xAA	; 170
    7540:	fc 01       	movw	r30, r24
    7542:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    7544:	00 00       	nop
    7546:	80 ec       	ldi	r24, 0xC0	; 192
    7548:	98 e0       	ldi	r25, 0x08	; 8
    754a:	fc 01       	movw	r30, r24
    754c:	82 81       	ldd	r24, Z+2	; 0x02
    754e:	88 23       	and	r24, r24
    7550:	d4 f7       	brge	.-12     	; 0x7546 <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    7552:	80 ec       	ldi	r24, 0xC0	; 192
    7554:	98 e0       	ldi	r25, 0x08	; 8
    7556:	fc 01       	movw	r30, r24
    7558:	23 81       	ldd	r18, Z+3	; 0x03
    755a:	89 81       	ldd	r24, Y+1	; 0x01
    755c:	9a 81       	ldd	r25, Y+2	; 0x02
    755e:	8c 52       	subi	r24, 0x2C	; 44
    7560:	9c 4d       	sbci	r25, 0xDC	; 220
    7562:	fc 01       	movw	r30, r24
    7564:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7566:	89 81       	ldd	r24, Y+1	; 0x01
    7568:	9a 81       	ldd	r25, Y+2	; 0x02
    756a:	01 96       	adiw	r24, 0x01	; 1
    756c:	89 83       	std	Y+1, r24	; 0x01
    756e:	9a 83       	std	Y+2, r25	; 0x02
    7570:	29 81       	ldd	r18, Y+1	; 0x01
    7572:	3a 81       	ldd	r19, Y+2	; 0x02
    7574:	8b 81       	ldd	r24, Y+3	; 0x03
    7576:	9c 81       	ldd	r25, Y+4	; 0x04
    7578:	28 17       	cp	r18, r24
    757a:	39 07       	cpc	r19, r25
    757c:	f0 f2       	brcs	.-68     	; 0x753a <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    757e:	80 e2       	ldi	r24, 0x20	; 32
    7580:	96 e0       	ldi	r25, 0x06	; 6
    7582:	28 e0       	ldi	r18, 0x08	; 8
    7584:	fc 01       	movw	r30, r24
    7586:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    7588:	80 e0       	ldi	r24, 0x00	; 0
    758a:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    758e:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>

}
    7592:	24 96       	adiw	r28, 0x04	; 4
    7594:	cd bf       	out	0x3d, r28	; 61
    7596:	de bf       	out	0x3e, r29	; 62
    7598:	df 91       	pop	r29
    759a:	cf 91       	pop	r28
    759c:	08 95       	ret

0000759e <FRAMTest3Channel>:

void FRAMTest3Channel(void) {
    759e:	8f 92       	push	r8
    75a0:	9f 92       	push	r9
    75a2:	af 92       	push	r10
    75a4:	bf 92       	push	r11
    75a6:	cf 92       	push	r12
    75a8:	df 92       	push	r13
    75aa:	ef 92       	push	r14
    75ac:	ff 92       	push	r15
    75ae:	0f 93       	push	r16
    75b0:	1f 93       	push	r17
    75b2:	cf 93       	push	r28
    75b4:	df 93       	push	r29
    75b6:	cd b7       	in	r28, 0x3d	; 61
    75b8:	de b7       	in	r29, 0x3e	; 62
    75ba:	6b 97       	sbiw	r28, 0x1b	; 27
    75bc:	cd bf       	out	0x3d, r28	; 61
    75be:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    75c0:	19 8e       	std	Y+25, r1	; 0x19
    75c2:	1a 8e       	std	Y+26, r1	; 0x1a
    75c4:	1b 8e       	std	Y+27, r1	; 0x1b
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
    75c6:	9e 01       	movw	r18, r28
    75c8:	27 5e       	subi	r18, 0xE7	; 231
    75ca:	3f 4f       	sbci	r19, 0xFF	; 255
}

void FRAMTest3Channel(void) {
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    75cc:	8e ec       	ldi	r24, 0xCE	; 206
    75ce:	b9 01       	movw	r22, r18
    75d0:	40 e0       	ldi	r20, 0x00	; 0
    75d2:	25 e1       	ldi	r18, 0x15	; 21
    75d4:	01 e0       	ldi	r16, 0x01	; 1
    75d6:	0f 2e       	mov	r0, r31
    75d8:	fd e0       	ldi	r31, 0x0D	; 13
    75da:	ef 2e       	mov	r14, r31
    75dc:	ff 24       	eor	r15, r15
    75de:	f0 2d       	mov	r31, r0
    75e0:	0f 2e       	mov	r0, r31
    75e2:	fe e0       	ldi	r31, 0x0E	; 14
    75e4:	cf 2e       	mov	r12, r31
    75e6:	dd 24       	eor	r13, r13
    75e8:	f0 2d       	mov	r31, r0
    75ea:	0f 2e       	mov	r0, r31
    75ec:	ff e0       	ldi	r31, 0x0F	; 15
    75ee:	af 2e       	mov	r10, r31
    75f0:	bb 24       	eor	r11, r11
    75f2:	f0 2d       	mov	r31, r0
    75f4:	88 24       	eor	r8, r8
    75f6:	99 24       	eor	r9, r9
    75f8:	68 94       	set
    75fa:	84 f8       	bld	r8, 4
    75fc:	0e 94 52 11 	call	0x22a4	; 0x22a4 <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7600:	81 e0       	ldi	r24, 0x01	; 1
    7602:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
    7606:	80 e0       	ldi	r24, 0x00	; 0
    7608:	90 e0       	ldi	r25, 0x00	; 0
    760a:	aa e7       	ldi	r26, 0x7A	; 122
    760c:	b3 e4       	ldi	r27, 0x43	; 67
    760e:	89 83       	std	Y+1, r24	; 0x01
    7610:	9a 83       	std	Y+2, r25	; 0x02
    7612:	ab 83       	std	Y+3, r26	; 0x03
    7614:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7616:	69 81       	ldd	r22, Y+1	; 0x01
    7618:	7a 81       	ldd	r23, Y+2	; 0x02
    761a:	8b 81       	ldd	r24, Y+3	; 0x03
    761c:	9c 81       	ldd	r25, Y+4	; 0x04
    761e:	2b ea       	ldi	r18, 0xAB	; 171
    7620:	3a ea       	ldi	r19, 0xAA	; 170
    7622:	4a e2       	ldi	r20, 0x2A	; 42
    7624:	51 e4       	ldi	r21, 0x41	; 65
    7626:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    762a:	dc 01       	movw	r26, r24
    762c:	cb 01       	movw	r24, r22
    762e:	8d 83       	std	Y+5, r24	; 0x05
    7630:	9e 83       	std	Y+6, r25	; 0x06
    7632:	af 83       	std	Y+7, r26	; 0x07
    7634:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7636:	11 e0       	ldi	r17, 0x01	; 1
    7638:	6d 81       	ldd	r22, Y+5	; 0x05
    763a:	7e 81       	ldd	r23, Y+6	; 0x06
    763c:	8f 81       	ldd	r24, Y+7	; 0x07
    763e:	98 85       	ldd	r25, Y+8	; 0x08
    7640:	20 e0       	ldi	r18, 0x00	; 0
    7642:	30 e0       	ldi	r19, 0x00	; 0
    7644:	40 e8       	ldi	r20, 0x80	; 128
    7646:	5f e3       	ldi	r21, 0x3F	; 63
    7648:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    764c:	88 23       	and	r24, r24
    764e:	0c f0       	brlt	.+2      	; 0x7652 <FRAMTest3Channel+0xb4>
    7650:	10 e0       	ldi	r17, 0x00	; 0
    7652:	11 23       	and	r17, r17
    7654:	19 f0       	breq	.+6      	; 0x765c <FRAMTest3Channel+0xbe>
		__ticks = 1;
    7656:	81 e0       	ldi	r24, 0x01	; 1
    7658:	89 87       	std	Y+9, r24	; 0x09
    765a:	a3 c0       	rjmp	.+326    	; 0x77a2 <FRAMTest3Channel+0x204>
	else if (__tmp > 255)
    765c:	11 e0       	ldi	r17, 0x01	; 1
    765e:	6d 81       	ldd	r22, Y+5	; 0x05
    7660:	7e 81       	ldd	r23, Y+6	; 0x06
    7662:	8f 81       	ldd	r24, Y+7	; 0x07
    7664:	98 85       	ldd	r25, Y+8	; 0x08
    7666:	20 e0       	ldi	r18, 0x00	; 0
    7668:	30 e0       	ldi	r19, 0x00	; 0
    766a:	4f e7       	ldi	r20, 0x7F	; 127
    766c:	53 e4       	ldi	r21, 0x43	; 67
    766e:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    7672:	18 16       	cp	r1, r24
    7674:	0c f0       	brlt	.+2      	; 0x7678 <FRAMTest3Channel+0xda>
    7676:	10 e0       	ldi	r17, 0x00	; 0
    7678:	11 23       	and	r17, r17
    767a:	09 f4       	brne	.+2      	; 0x767e <FRAMTest3Channel+0xe0>
    767c:	89 c0       	rjmp	.+274    	; 0x7790 <FRAMTest3Channel+0x1f2>
	{
		_delay_ms(__us / 1000.0);
    767e:	69 81       	ldd	r22, Y+1	; 0x01
    7680:	7a 81       	ldd	r23, Y+2	; 0x02
    7682:	8b 81       	ldd	r24, Y+3	; 0x03
    7684:	9c 81       	ldd	r25, Y+4	; 0x04
    7686:	20 e0       	ldi	r18, 0x00	; 0
    7688:	30 e0       	ldi	r19, 0x00	; 0
    768a:	4a e7       	ldi	r20, 0x7A	; 122
    768c:	54 e4       	ldi	r21, 0x44	; 68
    768e:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    7692:	dc 01       	movw	r26, r24
    7694:	cb 01       	movw	r24, r22
    7696:	8a 87       	std	Y+10, r24	; 0x0a
    7698:	9b 87       	std	Y+11, r25	; 0x0b
    769a:	ac 87       	std	Y+12, r26	; 0x0c
    769c:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    769e:	6a 85       	ldd	r22, Y+10	; 0x0a
    76a0:	7b 85       	ldd	r23, Y+11	; 0x0b
    76a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    76a4:	9d 85       	ldd	r25, Y+13	; 0x0d
    76a6:	20 e0       	ldi	r18, 0x00	; 0
    76a8:	30 e0       	ldi	r19, 0x00	; 0
    76aa:	4a ef       	ldi	r20, 0xFA	; 250
    76ac:	55 e4       	ldi	r21, 0x45	; 69
    76ae:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    76b2:	dc 01       	movw	r26, r24
    76b4:	cb 01       	movw	r24, r22
    76b6:	8e 87       	std	Y+14, r24	; 0x0e
    76b8:	9f 87       	std	Y+15, r25	; 0x0f
    76ba:	a8 8b       	std	Y+16, r26	; 0x10
    76bc:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    76be:	11 e0       	ldi	r17, 0x01	; 1
    76c0:	6e 85       	ldd	r22, Y+14	; 0x0e
    76c2:	7f 85       	ldd	r23, Y+15	; 0x0f
    76c4:	88 89       	ldd	r24, Y+16	; 0x10
    76c6:	99 89       	ldd	r25, Y+17	; 0x11
    76c8:	20 e0       	ldi	r18, 0x00	; 0
    76ca:	30 e0       	ldi	r19, 0x00	; 0
    76cc:	40 e8       	ldi	r20, 0x80	; 128
    76ce:	5f e3       	ldi	r21, 0x3F	; 63
    76d0:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    76d4:	88 23       	and	r24, r24
    76d6:	0c f0       	brlt	.+2      	; 0x76da <FRAMTest3Channel+0x13c>
    76d8:	10 e0       	ldi	r17, 0x00	; 0
    76da:	11 23       	and	r17, r17
    76dc:	29 f0       	breq	.+10     	; 0x76e8 <FRAMTest3Channel+0x14a>
		__ticks = 1;
    76de:	81 e0       	ldi	r24, 0x01	; 1
    76e0:	90 e0       	ldi	r25, 0x00	; 0
    76e2:	8a 8b       	std	Y+18, r24	; 0x12
    76e4:	9b 8b       	std	Y+19, r25	; 0x13
    76e6:	46 c0       	rjmp	.+140    	; 0x7774 <FRAMTest3Channel+0x1d6>
	else if (__tmp > 65535)
    76e8:	11 e0       	ldi	r17, 0x01	; 1
    76ea:	6e 85       	ldd	r22, Y+14	; 0x0e
    76ec:	7f 85       	ldd	r23, Y+15	; 0x0f
    76ee:	88 89       	ldd	r24, Y+16	; 0x10
    76f0:	99 89       	ldd	r25, Y+17	; 0x11
    76f2:	20 e0       	ldi	r18, 0x00	; 0
    76f4:	3f ef       	ldi	r19, 0xFF	; 255
    76f6:	4f e7       	ldi	r20, 0x7F	; 127
    76f8:	57 e4       	ldi	r21, 0x47	; 71
    76fa:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    76fe:	18 16       	cp	r1, r24
    7700:	0c f0       	brlt	.+2      	; 0x7704 <FRAMTest3Channel+0x166>
    7702:	10 e0       	ldi	r17, 0x00	; 0
    7704:	11 23       	and	r17, r17
    7706:	61 f1       	breq	.+88     	; 0x7760 <FRAMTest3Channel+0x1c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7708:	6a 85       	ldd	r22, Y+10	; 0x0a
    770a:	7b 85       	ldd	r23, Y+11	; 0x0b
    770c:	8c 85       	ldd	r24, Y+12	; 0x0c
    770e:	9d 85       	ldd	r25, Y+13	; 0x0d
    7710:	20 e0       	ldi	r18, 0x00	; 0
    7712:	30 e0       	ldi	r19, 0x00	; 0
    7714:	40 e2       	ldi	r20, 0x20	; 32
    7716:	51 e4       	ldi	r21, 0x41	; 65
    7718:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    771c:	dc 01       	movw	r26, r24
    771e:	cb 01       	movw	r24, r22
    7720:	bc 01       	movw	r22, r24
    7722:	cd 01       	movw	r24, r26
    7724:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7728:	dc 01       	movw	r26, r24
    772a:	cb 01       	movw	r24, r22
    772c:	8a 8b       	std	Y+18, r24	; 0x12
    772e:	9b 8b       	std	Y+19, r25	; 0x13
    7730:	12 c0       	rjmp	.+36     	; 0x7756 <FRAMTest3Channel+0x1b8>
    7732:	80 e2       	ldi	r24, 0x20	; 32
    7734:	93 e0       	ldi	r25, 0x03	; 3
    7736:	8c 8b       	std	Y+20, r24	; 0x14
    7738:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    773a:	8c 89       	ldd	r24, Y+20	; 0x14
    773c:	9d 89       	ldd	r25, Y+21	; 0x15
    773e:	8c 01       	movw	r16, r24
    7740:	c8 01       	movw	r24, r16
    7742:	01 97       	sbiw	r24, 0x01	; 1
    7744:	f1 f7       	brne	.-4      	; 0x7742 <FRAMTest3Channel+0x1a4>
    7746:	8c 01       	movw	r16, r24
    7748:	0c 8b       	std	Y+20, r16	; 0x14
    774a:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    774c:	8a 89       	ldd	r24, Y+18	; 0x12
    774e:	9b 89       	ldd	r25, Y+19	; 0x13
    7750:	01 97       	sbiw	r24, 0x01	; 1
    7752:	8a 8b       	std	Y+18, r24	; 0x12
    7754:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7756:	8a 89       	ldd	r24, Y+18	; 0x12
    7758:	9b 89       	ldd	r25, Y+19	; 0x13
    775a:	00 97       	sbiw	r24, 0x00	; 0
    775c:	51 f7       	brne	.-44     	; 0x7732 <FRAMTest3Channel+0x194>
    775e:	28 c0       	rjmp	.+80     	; 0x77b0 <FRAMTest3Channel+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7760:	6e 85       	ldd	r22, Y+14	; 0x0e
    7762:	7f 85       	ldd	r23, Y+15	; 0x0f
    7764:	88 89       	ldd	r24, Y+16	; 0x10
    7766:	99 89       	ldd	r25, Y+17	; 0x11
    7768:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    776c:	dc 01       	movw	r26, r24
    776e:	cb 01       	movw	r24, r22
    7770:	8a 8b       	std	Y+18, r24	; 0x12
    7772:	9b 8b       	std	Y+19, r25	; 0x13
    7774:	8a 89       	ldd	r24, Y+18	; 0x12
    7776:	9b 89       	ldd	r25, Y+19	; 0x13
    7778:	8e 8b       	std	Y+22, r24	; 0x16
    777a:	9f 8b       	std	Y+23, r25	; 0x17
    777c:	8e 89       	ldd	r24, Y+22	; 0x16
    777e:	9f 89       	ldd	r25, Y+23	; 0x17
    7780:	8c 01       	movw	r16, r24
    7782:	c8 01       	movw	r24, r16
    7784:	01 97       	sbiw	r24, 0x01	; 1
    7786:	f1 f7       	brne	.-4      	; 0x7784 <FRAMTest3Channel+0x1e6>
    7788:	8c 01       	movw	r16, r24
    778a:	0e 8b       	std	Y+22, r16	; 0x16
    778c:	1f 8b       	std	Y+23, r17	; 0x17
    778e:	10 c0       	rjmp	.+32     	; 0x77b0 <FRAMTest3Channel+0x212>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7790:	6d 81       	ldd	r22, Y+5	; 0x05
    7792:	7e 81       	ldd	r23, Y+6	; 0x06
    7794:	8f 81       	ldd	r24, Y+7	; 0x07
    7796:	98 85       	ldd	r25, Y+8	; 0x08
    7798:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    779c:	dc 01       	movw	r26, r24
    779e:	cb 01       	movw	r24, r22
    77a0:	89 87       	std	Y+9, r24	; 0x09
    77a2:	89 85       	ldd	r24, Y+9	; 0x09
    77a4:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    77a6:	88 8d       	ldd	r24, Y+24	; 0x18
    77a8:	18 2f       	mov	r17, r24
    77aa:	1a 95       	dec	r17
    77ac:	f1 f7       	brne	.-4      	; 0x77aa <FRAMTest3Channel+0x20c>
    77ae:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    77b0:	0e 94 56 18 	call	0x30ac	; 0x30ac <calcChecksumFRAM>

	ADCPower(FALSE);
    77b4:	80 e0       	ldi	r24, 0x00	; 0
    77b6:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	
}
    77ba:	6b 96       	adiw	r28, 0x1b	; 27
    77bc:	cd bf       	out	0x3d, r28	; 61
    77be:	de bf       	out	0x3e, r29	; 62
    77c0:	df 91       	pop	r29
    77c2:	cf 91       	pop	r28
    77c4:	1f 91       	pop	r17
    77c6:	0f 91       	pop	r16
    77c8:	ff 90       	pop	r15
    77ca:	ef 90       	pop	r14
    77cc:	df 90       	pop	r13
    77ce:	cf 90       	pop	r12
    77d0:	bf 90       	pop	r11
    77d2:	af 90       	pop	r10
    77d4:	9f 90       	pop	r9
    77d6:	8f 90       	pop	r8
    77d8:	08 95       	ret

000077da <FRAMTest1Channel>:

void FRAMTest1Channel(void) {
    77da:	8f 92       	push	r8
    77dc:	9f 92       	push	r9
    77de:	af 92       	push	r10
    77e0:	bf 92       	push	r11
    77e2:	cf 92       	push	r12
    77e4:	df 92       	push	r13
    77e6:	ef 92       	push	r14
    77e8:	0f 93       	push	r16
    77ea:	1f 93       	push	r17
    77ec:	cf 93       	push	r28
    77ee:	df 93       	push	r29
    77f0:	cd b7       	in	r28, 0x3d	; 61
    77f2:	de b7       	in	r29, 0x3e	; 62
    77f4:	68 97       	sbiw	r28, 0x18	; 24
    77f6:	cd bf       	out	0x3d, r28	; 61
    77f8:	de bf       	out	0x3e, r29	; 62

	CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
    77fa:	0f 92       	push	r0
    77fc:	0f 92       	push	r0
    77fe:	8d b7       	in	r24, 0x3d	; 61
    7800:	9e b7       	in	r25, 0x3e	; 62
    7802:	01 96       	adiw	r24, 0x01	; 1
    7804:	20 e1       	ldi	r18, 0x10	; 16
    7806:	30 e0       	ldi	r19, 0x00	; 0
    7808:	fc 01       	movw	r30, r24
    780a:	20 83       	st	Z, r18
    780c:	31 83       	std	Z+1, r19	; 0x01
    780e:	87 e0       	ldi	r24, 0x07	; 7
    7810:	68 ec       	ldi	r22, 0xC8	; 200
    7812:	40 e0       	ldi	r20, 0x00	; 0
    7814:	20 e0       	ldi	r18, 0x00	; 0
    7816:	05 e1       	ldi	r16, 0x15	; 21
    7818:	ee 24       	eor	r14, r14
    781a:	e3 94       	inc	r14
    781c:	0f 2e       	mov	r0, r31
    781e:	fd e0       	ldi	r31, 0x0D	; 13
    7820:	cf 2e       	mov	r12, r31
    7822:	dd 24       	eor	r13, r13
    7824:	f0 2d       	mov	r31, r0
    7826:	0f 2e       	mov	r0, r31
    7828:	fe e0       	ldi	r31, 0x0E	; 14
    782a:	af 2e       	mov	r10, r31
    782c:	bb 24       	eor	r11, r11
    782e:	f0 2d       	mov	r31, r0
    7830:	0f 2e       	mov	r0, r31
    7832:	ff e0       	ldi	r31, 0x0F	; 15
    7834:	8f 2e       	mov	r8, r31
    7836:	99 24       	eor	r9, r9
    7838:	f0 2d       	mov	r31, r0
    783a:	0e 94 8b 14 	call	0x2916	; 0x2916 <CO_collectSeismic1Channel>
    783e:	0f 90       	pop	r0
    7840:	0f 90       	pop	r0
	GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7842:	81 e0       	ldi	r24, 0x01	; 1
    7844:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
    7848:	80 e0       	ldi	r24, 0x00	; 0
    784a:	90 e0       	ldi	r25, 0x00	; 0
    784c:	aa e7       	ldi	r26, 0x7A	; 122
    784e:	b3 e4       	ldi	r27, 0x43	; 67
    7850:	89 83       	std	Y+1, r24	; 0x01
    7852:	9a 83       	std	Y+2, r25	; 0x02
    7854:	ab 83       	std	Y+3, r26	; 0x03
    7856:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7858:	69 81       	ldd	r22, Y+1	; 0x01
    785a:	7a 81       	ldd	r23, Y+2	; 0x02
    785c:	8b 81       	ldd	r24, Y+3	; 0x03
    785e:	9c 81       	ldd	r25, Y+4	; 0x04
    7860:	2b ea       	ldi	r18, 0xAB	; 171
    7862:	3a ea       	ldi	r19, 0xAA	; 170
    7864:	4a e2       	ldi	r20, 0x2A	; 42
    7866:	51 e4       	ldi	r21, 0x41	; 65
    7868:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    786c:	dc 01       	movw	r26, r24
    786e:	cb 01       	movw	r24, r22
    7870:	8d 83       	std	Y+5, r24	; 0x05
    7872:	9e 83       	std	Y+6, r25	; 0x06
    7874:	af 83       	std	Y+7, r26	; 0x07
    7876:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7878:	11 e0       	ldi	r17, 0x01	; 1
    787a:	6d 81       	ldd	r22, Y+5	; 0x05
    787c:	7e 81       	ldd	r23, Y+6	; 0x06
    787e:	8f 81       	ldd	r24, Y+7	; 0x07
    7880:	98 85       	ldd	r25, Y+8	; 0x08
    7882:	20 e0       	ldi	r18, 0x00	; 0
    7884:	30 e0       	ldi	r19, 0x00	; 0
    7886:	40 e8       	ldi	r20, 0x80	; 128
    7888:	5f e3       	ldi	r21, 0x3F	; 63
    788a:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    788e:	88 23       	and	r24, r24
    7890:	0c f0       	brlt	.+2      	; 0x7894 <FRAMTest1Channel+0xba>
    7892:	10 e0       	ldi	r17, 0x00	; 0
    7894:	11 23       	and	r17, r17
    7896:	19 f0       	breq	.+6      	; 0x789e <FRAMTest1Channel+0xc4>
		__ticks = 1;
    7898:	81 e0       	ldi	r24, 0x01	; 1
    789a:	89 87       	std	Y+9, r24	; 0x09
    789c:	a3 c0       	rjmp	.+326    	; 0x79e4 <FRAMTest1Channel+0x20a>
	else if (__tmp > 255)
    789e:	11 e0       	ldi	r17, 0x01	; 1
    78a0:	6d 81       	ldd	r22, Y+5	; 0x05
    78a2:	7e 81       	ldd	r23, Y+6	; 0x06
    78a4:	8f 81       	ldd	r24, Y+7	; 0x07
    78a6:	98 85       	ldd	r25, Y+8	; 0x08
    78a8:	20 e0       	ldi	r18, 0x00	; 0
    78aa:	30 e0       	ldi	r19, 0x00	; 0
    78ac:	4f e7       	ldi	r20, 0x7F	; 127
    78ae:	53 e4       	ldi	r21, 0x43	; 67
    78b0:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    78b4:	18 16       	cp	r1, r24
    78b6:	0c f0       	brlt	.+2      	; 0x78ba <FRAMTest1Channel+0xe0>
    78b8:	10 e0       	ldi	r17, 0x00	; 0
    78ba:	11 23       	and	r17, r17
    78bc:	09 f4       	brne	.+2      	; 0x78c0 <FRAMTest1Channel+0xe6>
    78be:	89 c0       	rjmp	.+274    	; 0x79d2 <FRAMTest1Channel+0x1f8>
	{
		_delay_ms(__us / 1000.0);
    78c0:	69 81       	ldd	r22, Y+1	; 0x01
    78c2:	7a 81       	ldd	r23, Y+2	; 0x02
    78c4:	8b 81       	ldd	r24, Y+3	; 0x03
    78c6:	9c 81       	ldd	r25, Y+4	; 0x04
    78c8:	20 e0       	ldi	r18, 0x00	; 0
    78ca:	30 e0       	ldi	r19, 0x00	; 0
    78cc:	4a e7       	ldi	r20, 0x7A	; 122
    78ce:	54 e4       	ldi	r21, 0x44	; 68
    78d0:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    78d4:	dc 01       	movw	r26, r24
    78d6:	cb 01       	movw	r24, r22
    78d8:	8a 87       	std	Y+10, r24	; 0x0a
    78da:	9b 87       	std	Y+11, r25	; 0x0b
    78dc:	ac 87       	std	Y+12, r26	; 0x0c
    78de:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    78e0:	6a 85       	ldd	r22, Y+10	; 0x0a
    78e2:	7b 85       	ldd	r23, Y+11	; 0x0b
    78e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    78e6:	9d 85       	ldd	r25, Y+13	; 0x0d
    78e8:	20 e0       	ldi	r18, 0x00	; 0
    78ea:	30 e0       	ldi	r19, 0x00	; 0
    78ec:	4a ef       	ldi	r20, 0xFA	; 250
    78ee:	55 e4       	ldi	r21, 0x45	; 69
    78f0:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    78f4:	dc 01       	movw	r26, r24
    78f6:	cb 01       	movw	r24, r22
    78f8:	8e 87       	std	Y+14, r24	; 0x0e
    78fa:	9f 87       	std	Y+15, r25	; 0x0f
    78fc:	a8 8b       	std	Y+16, r26	; 0x10
    78fe:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7900:	11 e0       	ldi	r17, 0x01	; 1
    7902:	6e 85       	ldd	r22, Y+14	; 0x0e
    7904:	7f 85       	ldd	r23, Y+15	; 0x0f
    7906:	88 89       	ldd	r24, Y+16	; 0x10
    7908:	99 89       	ldd	r25, Y+17	; 0x11
    790a:	20 e0       	ldi	r18, 0x00	; 0
    790c:	30 e0       	ldi	r19, 0x00	; 0
    790e:	40 e8       	ldi	r20, 0x80	; 128
    7910:	5f e3       	ldi	r21, 0x3F	; 63
    7912:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7916:	88 23       	and	r24, r24
    7918:	0c f0       	brlt	.+2      	; 0x791c <FRAMTest1Channel+0x142>
    791a:	10 e0       	ldi	r17, 0x00	; 0
    791c:	11 23       	and	r17, r17
    791e:	29 f0       	breq	.+10     	; 0x792a <FRAMTest1Channel+0x150>
		__ticks = 1;
    7920:	81 e0       	ldi	r24, 0x01	; 1
    7922:	90 e0       	ldi	r25, 0x00	; 0
    7924:	8a 8b       	std	Y+18, r24	; 0x12
    7926:	9b 8b       	std	Y+19, r25	; 0x13
    7928:	46 c0       	rjmp	.+140    	; 0x79b6 <FRAMTest1Channel+0x1dc>
	else if (__tmp > 65535)
    792a:	11 e0       	ldi	r17, 0x01	; 1
    792c:	6e 85       	ldd	r22, Y+14	; 0x0e
    792e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7930:	88 89       	ldd	r24, Y+16	; 0x10
    7932:	99 89       	ldd	r25, Y+17	; 0x11
    7934:	20 e0       	ldi	r18, 0x00	; 0
    7936:	3f ef       	ldi	r19, 0xFF	; 255
    7938:	4f e7       	ldi	r20, 0x7F	; 127
    793a:	57 e4       	ldi	r21, 0x47	; 71
    793c:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    7940:	18 16       	cp	r1, r24
    7942:	0c f0       	brlt	.+2      	; 0x7946 <FRAMTest1Channel+0x16c>
    7944:	10 e0       	ldi	r17, 0x00	; 0
    7946:	11 23       	and	r17, r17
    7948:	61 f1       	breq	.+88     	; 0x79a2 <FRAMTest1Channel+0x1c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    794a:	6a 85       	ldd	r22, Y+10	; 0x0a
    794c:	7b 85       	ldd	r23, Y+11	; 0x0b
    794e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7950:	9d 85       	ldd	r25, Y+13	; 0x0d
    7952:	20 e0       	ldi	r18, 0x00	; 0
    7954:	30 e0       	ldi	r19, 0x00	; 0
    7956:	40 e2       	ldi	r20, 0x20	; 32
    7958:	51 e4       	ldi	r21, 0x41	; 65
    795a:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    795e:	dc 01       	movw	r26, r24
    7960:	cb 01       	movw	r24, r22
    7962:	bc 01       	movw	r22, r24
    7964:	cd 01       	movw	r24, r26
    7966:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    796a:	dc 01       	movw	r26, r24
    796c:	cb 01       	movw	r24, r22
    796e:	8a 8b       	std	Y+18, r24	; 0x12
    7970:	9b 8b       	std	Y+19, r25	; 0x13
    7972:	12 c0       	rjmp	.+36     	; 0x7998 <FRAMTest1Channel+0x1be>
    7974:	80 e2       	ldi	r24, 0x20	; 32
    7976:	93 e0       	ldi	r25, 0x03	; 3
    7978:	8c 8b       	std	Y+20, r24	; 0x14
    797a:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    797c:	8c 89       	ldd	r24, Y+20	; 0x14
    797e:	9d 89       	ldd	r25, Y+21	; 0x15
    7980:	8c 01       	movw	r16, r24
    7982:	c8 01       	movw	r24, r16
    7984:	01 97       	sbiw	r24, 0x01	; 1
    7986:	f1 f7       	brne	.-4      	; 0x7984 <FRAMTest1Channel+0x1aa>
    7988:	8c 01       	movw	r16, r24
    798a:	0c 8b       	std	Y+20, r16	; 0x14
    798c:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    798e:	8a 89       	ldd	r24, Y+18	; 0x12
    7990:	9b 89       	ldd	r25, Y+19	; 0x13
    7992:	01 97       	sbiw	r24, 0x01	; 1
    7994:	8a 8b       	std	Y+18, r24	; 0x12
    7996:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7998:	8a 89       	ldd	r24, Y+18	; 0x12
    799a:	9b 89       	ldd	r25, Y+19	; 0x13
    799c:	00 97       	sbiw	r24, 0x00	; 0
    799e:	51 f7       	brne	.-44     	; 0x7974 <FRAMTest1Channel+0x19a>
    79a0:	28 c0       	rjmp	.+80     	; 0x79f2 <FRAMTest1Channel+0x218>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    79a2:	6e 85       	ldd	r22, Y+14	; 0x0e
    79a4:	7f 85       	ldd	r23, Y+15	; 0x0f
    79a6:	88 89       	ldd	r24, Y+16	; 0x10
    79a8:	99 89       	ldd	r25, Y+17	; 0x11
    79aa:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    79ae:	dc 01       	movw	r26, r24
    79b0:	cb 01       	movw	r24, r22
    79b2:	8a 8b       	std	Y+18, r24	; 0x12
    79b4:	9b 8b       	std	Y+19, r25	; 0x13
    79b6:	8a 89       	ldd	r24, Y+18	; 0x12
    79b8:	9b 89       	ldd	r25, Y+19	; 0x13
    79ba:	8e 8b       	std	Y+22, r24	; 0x16
    79bc:	9f 8b       	std	Y+23, r25	; 0x17
    79be:	8e 89       	ldd	r24, Y+22	; 0x16
    79c0:	9f 89       	ldd	r25, Y+23	; 0x17
    79c2:	8c 01       	movw	r16, r24
    79c4:	f8 01       	movw	r30, r16
    79c6:	31 97       	sbiw	r30, 0x01	; 1
    79c8:	f1 f7       	brne	.-4      	; 0x79c6 <FRAMTest1Channel+0x1ec>
    79ca:	8f 01       	movw	r16, r30
    79cc:	0e 8b       	std	Y+22, r16	; 0x16
    79ce:	1f 8b       	std	Y+23, r17	; 0x17
    79d0:	10 c0       	rjmp	.+32     	; 0x79f2 <FRAMTest1Channel+0x218>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    79d2:	6d 81       	ldd	r22, Y+5	; 0x05
    79d4:	7e 81       	ldd	r23, Y+6	; 0x06
    79d6:	8f 81       	ldd	r24, Y+7	; 0x07
    79d8:	98 85       	ldd	r25, Y+8	; 0x08
    79da:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    79de:	dc 01       	movw	r26, r24
    79e0:	cb 01       	movw	r24, r22
    79e2:	89 87       	std	Y+9, r24	; 0x09
    79e4:	89 85       	ldd	r24, Y+9	; 0x09
    79e6:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    79e8:	88 8d       	ldd	r24, Y+24	; 0x18
    79ea:	18 2f       	mov	r17, r24
    79ec:	1a 95       	dec	r17
    79ee:	f1 f7       	brne	.-4      	; 0x79ec <FRAMTest1Channel+0x212>
    79f0:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    79f2:	0e 94 56 18 	call	0x30ac	; 0x30ac <calcChecksumFRAM>

	ADCPower(FALSE);
    79f6:	80 e0       	ldi	r24, 0x00	; 0
    79f8:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>

}
    79fc:	68 96       	adiw	r28, 0x18	; 24
    79fe:	cd bf       	out	0x3d, r28	; 61
    7a00:	de bf       	out	0x3e, r29	; 62
    7a02:	df 91       	pop	r29
    7a04:	cf 91       	pop	r28
    7a06:	1f 91       	pop	r17
    7a08:	0f 91       	pop	r16
    7a0a:	ef 90       	pop	r14
    7a0c:	df 90       	pop	r13
    7a0e:	cf 90       	pop	r12
    7a10:	bf 90       	pop	r11
    7a12:	af 90       	pop	r10
    7a14:	9f 90       	pop	r9
    7a16:	8f 90       	pop	r8
    7a18:	08 95       	ret

00007a1a <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7a1a:	0f 93       	push	r16
    7a1c:	1f 93       	push	r17
    7a1e:	cf 93       	push	r28
    7a20:	df 93       	push	r29
    7a22:	cd b7       	in	r28, 0x3d	; 61
    7a24:	de b7       	in	r29, 0x3e	; 62
    7a26:	68 97       	sbiw	r28, 0x18	; 24
    7a28:	cd bf       	out	0x3d, r28	; 61
    7a2a:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    7a2c:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <FRAMWriteKnowns>
	ADCPower(TRUE);
    7a30:	81 e0       	ldi	r24, 0x01	; 1
    7a32:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
    7a36:	80 e0       	ldi	r24, 0x00	; 0
    7a38:	90 e0       	ldi	r25, 0x00	; 0
    7a3a:	aa e7       	ldi	r26, 0x7A	; 122
    7a3c:	b3 e4       	ldi	r27, 0x43	; 67
    7a3e:	89 83       	std	Y+1, r24	; 0x01
    7a40:	9a 83       	std	Y+2, r25	; 0x02
    7a42:	ab 83       	std	Y+3, r26	; 0x03
    7a44:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7a46:	69 81       	ldd	r22, Y+1	; 0x01
    7a48:	7a 81       	ldd	r23, Y+2	; 0x02
    7a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    7a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    7a4e:	2b ea       	ldi	r18, 0xAB	; 171
    7a50:	3a ea       	ldi	r19, 0xAA	; 170
    7a52:	4a e2       	ldi	r20, 0x2A	; 42
    7a54:	51 e4       	ldi	r21, 0x41	; 65
    7a56:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7a5a:	dc 01       	movw	r26, r24
    7a5c:	cb 01       	movw	r24, r22
    7a5e:	8d 83       	std	Y+5, r24	; 0x05
    7a60:	9e 83       	std	Y+6, r25	; 0x06
    7a62:	af 83       	std	Y+7, r26	; 0x07
    7a64:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7a66:	11 e0       	ldi	r17, 0x01	; 1
    7a68:	6d 81       	ldd	r22, Y+5	; 0x05
    7a6a:	7e 81       	ldd	r23, Y+6	; 0x06
    7a6c:	8f 81       	ldd	r24, Y+7	; 0x07
    7a6e:	98 85       	ldd	r25, Y+8	; 0x08
    7a70:	20 e0       	ldi	r18, 0x00	; 0
    7a72:	30 e0       	ldi	r19, 0x00	; 0
    7a74:	40 e8       	ldi	r20, 0x80	; 128
    7a76:	5f e3       	ldi	r21, 0x3F	; 63
    7a78:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7a7c:	88 23       	and	r24, r24
    7a7e:	0c f0       	brlt	.+2      	; 0x7a82 <FRAMWriteKnownsCheck+0x68>
    7a80:	10 e0       	ldi	r17, 0x00	; 0
    7a82:	11 23       	and	r17, r17
    7a84:	19 f0       	breq	.+6      	; 0x7a8c <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    7a86:	81 e0       	ldi	r24, 0x01	; 1
    7a88:	89 87       	std	Y+9, r24	; 0x09
    7a8a:	a3 c0       	rjmp	.+326    	; 0x7bd2 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7a8c:	11 e0       	ldi	r17, 0x01	; 1
    7a8e:	6d 81       	ldd	r22, Y+5	; 0x05
    7a90:	7e 81       	ldd	r23, Y+6	; 0x06
    7a92:	8f 81       	ldd	r24, Y+7	; 0x07
    7a94:	98 85       	ldd	r25, Y+8	; 0x08
    7a96:	20 e0       	ldi	r18, 0x00	; 0
    7a98:	30 e0       	ldi	r19, 0x00	; 0
    7a9a:	4f e7       	ldi	r20, 0x7F	; 127
    7a9c:	53 e4       	ldi	r21, 0x43	; 67
    7a9e:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    7aa2:	18 16       	cp	r1, r24
    7aa4:	0c f0       	brlt	.+2      	; 0x7aa8 <FRAMWriteKnownsCheck+0x8e>
    7aa6:	10 e0       	ldi	r17, 0x00	; 0
    7aa8:	11 23       	and	r17, r17
    7aaa:	09 f4       	brne	.+2      	; 0x7aae <FRAMWriteKnownsCheck+0x94>
    7aac:	89 c0       	rjmp	.+274    	; 0x7bc0 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7aae:	69 81       	ldd	r22, Y+1	; 0x01
    7ab0:	7a 81       	ldd	r23, Y+2	; 0x02
    7ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    7ab4:	9c 81       	ldd	r25, Y+4	; 0x04
    7ab6:	20 e0       	ldi	r18, 0x00	; 0
    7ab8:	30 e0       	ldi	r19, 0x00	; 0
    7aba:	4a e7       	ldi	r20, 0x7A	; 122
    7abc:	54 e4       	ldi	r21, 0x44	; 68
    7abe:	0e 94 ef 5c 	call	0xb9de	; 0xb9de <__divsf3>
    7ac2:	dc 01       	movw	r26, r24
    7ac4:	cb 01       	movw	r24, r22
    7ac6:	8a 87       	std	Y+10, r24	; 0x0a
    7ac8:	9b 87       	std	Y+11, r25	; 0x0b
    7aca:	ac 87       	std	Y+12, r26	; 0x0c
    7acc:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7ace:	6a 85       	ldd	r22, Y+10	; 0x0a
    7ad0:	7b 85       	ldd	r23, Y+11	; 0x0b
    7ad2:	8c 85       	ldd	r24, Y+12	; 0x0c
    7ad4:	9d 85       	ldd	r25, Y+13	; 0x0d
    7ad6:	20 e0       	ldi	r18, 0x00	; 0
    7ad8:	30 e0       	ldi	r19, 0x00	; 0
    7ada:	4a ef       	ldi	r20, 0xFA	; 250
    7adc:	55 e4       	ldi	r21, 0x45	; 69
    7ade:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7ae2:	dc 01       	movw	r26, r24
    7ae4:	cb 01       	movw	r24, r22
    7ae6:	8e 87       	std	Y+14, r24	; 0x0e
    7ae8:	9f 87       	std	Y+15, r25	; 0x0f
    7aea:	a8 8b       	std	Y+16, r26	; 0x10
    7aec:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7aee:	11 e0       	ldi	r17, 0x01	; 1
    7af0:	6e 85       	ldd	r22, Y+14	; 0x0e
    7af2:	7f 85       	ldd	r23, Y+15	; 0x0f
    7af4:	88 89       	ldd	r24, Y+16	; 0x10
    7af6:	99 89       	ldd	r25, Y+17	; 0x11
    7af8:	20 e0       	ldi	r18, 0x00	; 0
    7afa:	30 e0       	ldi	r19, 0x00	; 0
    7afc:	40 e8       	ldi	r20, 0x80	; 128
    7afe:	5f e3       	ldi	r21, 0x3F	; 63
    7b00:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7b04:	88 23       	and	r24, r24
    7b06:	0c f0       	brlt	.+2      	; 0x7b0a <FRAMWriteKnownsCheck+0xf0>
    7b08:	10 e0       	ldi	r17, 0x00	; 0
    7b0a:	11 23       	and	r17, r17
    7b0c:	29 f0       	breq	.+10     	; 0x7b18 <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    7b0e:	81 e0       	ldi	r24, 0x01	; 1
    7b10:	90 e0       	ldi	r25, 0x00	; 0
    7b12:	8a 8b       	std	Y+18, r24	; 0x12
    7b14:	9b 8b       	std	Y+19, r25	; 0x13
    7b16:	46 c0       	rjmp	.+140    	; 0x7ba4 <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7b18:	11 e0       	ldi	r17, 0x01	; 1
    7b1a:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b1c:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b1e:	88 89       	ldd	r24, Y+16	; 0x10
    7b20:	99 89       	ldd	r25, Y+17	; 0x11
    7b22:	20 e0       	ldi	r18, 0x00	; 0
    7b24:	3f ef       	ldi	r19, 0xFF	; 255
    7b26:	4f e7       	ldi	r20, 0x7F	; 127
    7b28:	57 e4       	ldi	r21, 0x47	; 71
    7b2a:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    7b2e:	18 16       	cp	r1, r24
    7b30:	0c f0       	brlt	.+2      	; 0x7b34 <FRAMWriteKnownsCheck+0x11a>
    7b32:	10 e0       	ldi	r17, 0x00	; 0
    7b34:	11 23       	and	r17, r17
    7b36:	61 f1       	breq	.+88     	; 0x7b90 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7b38:	6a 85       	ldd	r22, Y+10	; 0x0a
    7b3a:	7b 85       	ldd	r23, Y+11	; 0x0b
    7b3c:	8c 85       	ldd	r24, Y+12	; 0x0c
    7b3e:	9d 85       	ldd	r25, Y+13	; 0x0d
    7b40:	20 e0       	ldi	r18, 0x00	; 0
    7b42:	30 e0       	ldi	r19, 0x00	; 0
    7b44:	40 e2       	ldi	r20, 0x20	; 32
    7b46:	51 e4       	ldi	r21, 0x41	; 65
    7b48:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7b4c:	dc 01       	movw	r26, r24
    7b4e:	cb 01       	movw	r24, r22
    7b50:	bc 01       	movw	r22, r24
    7b52:	cd 01       	movw	r24, r26
    7b54:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7b58:	dc 01       	movw	r26, r24
    7b5a:	cb 01       	movw	r24, r22
    7b5c:	8a 8b       	std	Y+18, r24	; 0x12
    7b5e:	9b 8b       	std	Y+19, r25	; 0x13
    7b60:	12 c0       	rjmp	.+36     	; 0x7b86 <FRAMWriteKnownsCheck+0x16c>
    7b62:	80 e2       	ldi	r24, 0x20	; 32
    7b64:	93 e0       	ldi	r25, 0x03	; 3
    7b66:	8c 8b       	std	Y+20, r24	; 0x14
    7b68:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b6a:	8c 89       	ldd	r24, Y+20	; 0x14
    7b6c:	9d 89       	ldd	r25, Y+21	; 0x15
    7b6e:	8c 01       	movw	r16, r24
    7b70:	c8 01       	movw	r24, r16
    7b72:	01 97       	sbiw	r24, 0x01	; 1
    7b74:	f1 f7       	brne	.-4      	; 0x7b72 <FRAMWriteKnownsCheck+0x158>
    7b76:	8c 01       	movw	r16, r24
    7b78:	0c 8b       	std	Y+20, r16	; 0x14
    7b7a:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b7c:	8a 89       	ldd	r24, Y+18	; 0x12
    7b7e:	9b 89       	ldd	r25, Y+19	; 0x13
    7b80:	01 97       	sbiw	r24, 0x01	; 1
    7b82:	8a 8b       	std	Y+18, r24	; 0x12
    7b84:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b86:	8a 89       	ldd	r24, Y+18	; 0x12
    7b88:	9b 89       	ldd	r25, Y+19	; 0x13
    7b8a:	00 97       	sbiw	r24, 0x00	; 0
    7b8c:	51 f7       	brne	.-44     	; 0x7b62 <FRAMWriteKnownsCheck+0x148>
    7b8e:	28 c0       	rjmp	.+80     	; 0x7be0 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b90:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b92:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b94:	88 89       	ldd	r24, Y+16	; 0x10
    7b96:	99 89       	ldd	r25, Y+17	; 0x11
    7b98:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7b9c:	dc 01       	movw	r26, r24
    7b9e:	cb 01       	movw	r24, r22
    7ba0:	8a 8b       	std	Y+18, r24	; 0x12
    7ba2:	9b 8b       	std	Y+19, r25	; 0x13
    7ba4:	8a 89       	ldd	r24, Y+18	; 0x12
    7ba6:	9b 89       	ldd	r25, Y+19	; 0x13
    7ba8:	8e 8b       	std	Y+22, r24	; 0x16
    7baa:	9f 8b       	std	Y+23, r25	; 0x17
    7bac:	8e 89       	ldd	r24, Y+22	; 0x16
    7bae:	9f 89       	ldd	r25, Y+23	; 0x17
    7bb0:	8c 01       	movw	r16, r24
    7bb2:	c8 01       	movw	r24, r16
    7bb4:	01 97       	sbiw	r24, 0x01	; 1
    7bb6:	f1 f7       	brne	.-4      	; 0x7bb4 <FRAMWriteKnownsCheck+0x19a>
    7bb8:	8c 01       	movw	r16, r24
    7bba:	0e 8b       	std	Y+22, r16	; 0x16
    7bbc:	1f 8b       	std	Y+23, r17	; 0x17
    7bbe:	10 c0       	rjmp	.+32     	; 0x7be0 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7bc0:	6d 81       	ldd	r22, Y+5	; 0x05
    7bc2:	7e 81       	ldd	r23, Y+6	; 0x06
    7bc4:	8f 81       	ldd	r24, Y+7	; 0x07
    7bc6:	98 85       	ldd	r25, Y+8	; 0x08
    7bc8:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7bcc:	dc 01       	movw	r26, r24
    7bce:	cb 01       	movw	r24, r22
    7bd0:	89 87       	std	Y+9, r24	; 0x09
    7bd2:	89 85       	ldd	r24, Y+9	; 0x09
    7bd4:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7bd6:	88 8d       	ldd	r24, Y+24	; 0x18
    7bd8:	18 2f       	mov	r17, r24
    7bda:	1a 95       	dec	r17
    7bdc:	f1 f7       	brne	.-4      	; 0x7bda <FRAMWriteKnownsCheck+0x1c0>
    7bde:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7be0:	0e 94 56 18 	call	0x30ac	; 0x30ac <calcChecksumFRAM>

	ADCPower(FALSE);
    7be4:	80 e0       	ldi	r24, 0x00	; 0
    7be6:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>

}
    7bea:	68 96       	adiw	r28, 0x18	; 24
    7bec:	cd bf       	out	0x3d, r28	; 61
    7bee:	de bf       	out	0x3e, r29	; 62
    7bf0:	df 91       	pop	r29
    7bf2:	cf 91       	pop	r28
    7bf4:	1f 91       	pop	r17
    7bf6:	0f 91       	pop	r16
    7bf8:	08 95       	ret

00007bfa <checkMote>:

//random function for testing stuff	
void checkMote(){
    7bfa:	0f 93       	push	r16
    7bfc:	1f 93       	push	r17
    7bfe:	cf 93       	push	r28
    7c00:	df 93       	push	r29
    7c02:	cd b7       	in	r28, 0x3d	; 61
    7c04:	de b7       	in	r29, 0x3e	; 62
    7c06:	aa 97       	sbiw	r28, 0x2a	; 42
    7c08:	cd bf       	out	0x3d, r28	; 61
    7c0a:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    7c0c:	81 e0       	ldi	r24, 0x01	; 1
    7c0e:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	Ext1Power(TRUE);
    7c12:	81 e0       	ldi	r24, 0x01	; 1
    7c14:	0e 94 ba 36 	call	0x6d74	; 0x6d74 <Ext1Power>
    7c18:	80 e0       	ldi	r24, 0x00	; 0
    7c1a:	90 e0       	ldi	r25, 0x00	; 0
    7c1c:	a8 ec       	ldi	r26, 0xC8	; 200
    7c1e:	b2 e4       	ldi	r27, 0x42	; 66
    7c20:	89 83       	std	Y+1, r24	; 0x01
    7c22:	9a 83       	std	Y+2, r25	; 0x02
    7c24:	ab 83       	std	Y+3, r26	; 0x03
    7c26:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7c28:	69 81       	ldd	r22, Y+1	; 0x01
    7c2a:	7a 81       	ldd	r23, Y+2	; 0x02
    7c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    7c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    7c30:	20 e0       	ldi	r18, 0x00	; 0
    7c32:	30 e0       	ldi	r19, 0x00	; 0
    7c34:	4a ef       	ldi	r20, 0xFA	; 250
    7c36:	55 e4       	ldi	r21, 0x45	; 69
    7c38:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7c3c:	dc 01       	movw	r26, r24
    7c3e:	cb 01       	movw	r24, r22
    7c40:	8d 83       	std	Y+5, r24	; 0x05
    7c42:	9e 83       	std	Y+6, r25	; 0x06
    7c44:	af 83       	std	Y+7, r26	; 0x07
    7c46:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7c48:	11 e0       	ldi	r17, 0x01	; 1
    7c4a:	6d 81       	ldd	r22, Y+5	; 0x05
    7c4c:	7e 81       	ldd	r23, Y+6	; 0x06
    7c4e:	8f 81       	ldd	r24, Y+7	; 0x07
    7c50:	98 85       	ldd	r25, Y+8	; 0x08
    7c52:	20 e0       	ldi	r18, 0x00	; 0
    7c54:	30 e0       	ldi	r19, 0x00	; 0
    7c56:	40 e8       	ldi	r20, 0x80	; 128
    7c58:	5f e3       	ldi	r21, 0x3F	; 63
    7c5a:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7c5e:	88 23       	and	r24, r24
    7c60:	0c f0       	brlt	.+2      	; 0x7c64 <checkMote+0x6a>
    7c62:	10 e0       	ldi	r17, 0x00	; 0
    7c64:	11 23       	and	r17, r17
    7c66:	29 f0       	breq	.+10     	; 0x7c72 <checkMote+0x78>
		__ticks = 1;
    7c68:	81 e0       	ldi	r24, 0x01	; 1
    7c6a:	90 e0       	ldi	r25, 0x00	; 0
    7c6c:	89 87       	std	Y+9, r24	; 0x09
    7c6e:	9a 87       	std	Y+10, r25	; 0x0a
    7c70:	46 c0       	rjmp	.+140    	; 0x7cfe <checkMote+0x104>
	else if (__tmp > 65535)
    7c72:	11 e0       	ldi	r17, 0x01	; 1
    7c74:	6d 81       	ldd	r22, Y+5	; 0x05
    7c76:	7e 81       	ldd	r23, Y+6	; 0x06
    7c78:	8f 81       	ldd	r24, Y+7	; 0x07
    7c7a:	98 85       	ldd	r25, Y+8	; 0x08
    7c7c:	20 e0       	ldi	r18, 0x00	; 0
    7c7e:	3f ef       	ldi	r19, 0xFF	; 255
    7c80:	4f e7       	ldi	r20, 0x7F	; 127
    7c82:	57 e4       	ldi	r21, 0x47	; 71
    7c84:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    7c88:	18 16       	cp	r1, r24
    7c8a:	0c f0       	brlt	.+2      	; 0x7c8e <checkMote+0x94>
    7c8c:	10 e0       	ldi	r17, 0x00	; 0
    7c8e:	11 23       	and	r17, r17
    7c90:	61 f1       	breq	.+88     	; 0x7cea <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7c92:	69 81       	ldd	r22, Y+1	; 0x01
    7c94:	7a 81       	ldd	r23, Y+2	; 0x02
    7c96:	8b 81       	ldd	r24, Y+3	; 0x03
    7c98:	9c 81       	ldd	r25, Y+4	; 0x04
    7c9a:	20 e0       	ldi	r18, 0x00	; 0
    7c9c:	30 e0       	ldi	r19, 0x00	; 0
    7c9e:	40 e2       	ldi	r20, 0x20	; 32
    7ca0:	51 e4       	ldi	r21, 0x41	; 65
    7ca2:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7ca6:	dc 01       	movw	r26, r24
    7ca8:	cb 01       	movw	r24, r22
    7caa:	bc 01       	movw	r22, r24
    7cac:	cd 01       	movw	r24, r26
    7cae:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7cb2:	dc 01       	movw	r26, r24
    7cb4:	cb 01       	movw	r24, r22
    7cb6:	89 87       	std	Y+9, r24	; 0x09
    7cb8:	9a 87       	std	Y+10, r25	; 0x0a
    7cba:	12 c0       	rjmp	.+36     	; 0x7ce0 <checkMote+0xe6>
    7cbc:	80 e2       	ldi	r24, 0x20	; 32
    7cbe:	93 e0       	ldi	r25, 0x03	; 3
    7cc0:	8b 87       	std	Y+11, r24	; 0x0b
    7cc2:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7cc4:	8b 85       	ldd	r24, Y+11	; 0x0b
    7cc6:	9c 85       	ldd	r25, Y+12	; 0x0c
    7cc8:	8c 01       	movw	r16, r24
    7cca:	c8 01       	movw	r24, r16
    7ccc:	01 97       	sbiw	r24, 0x01	; 1
    7cce:	f1 f7       	brne	.-4      	; 0x7ccc <checkMote+0xd2>
    7cd0:	8c 01       	movw	r16, r24
    7cd2:	0b 87       	std	Y+11, r16	; 0x0b
    7cd4:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7cd6:	89 85       	ldd	r24, Y+9	; 0x09
    7cd8:	9a 85       	ldd	r25, Y+10	; 0x0a
    7cda:	01 97       	sbiw	r24, 0x01	; 1
    7cdc:	89 87       	std	Y+9, r24	; 0x09
    7cde:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7ce0:	89 85       	ldd	r24, Y+9	; 0x09
    7ce2:	9a 85       	ldd	r25, Y+10	; 0x0a
    7ce4:	00 97       	sbiw	r24, 0x00	; 0
    7ce6:	51 f7       	brne	.-44     	; 0x7cbc <checkMote+0xc2>
    7ce8:	17 c0       	rjmp	.+46     	; 0x7d18 <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7cea:	6d 81       	ldd	r22, Y+5	; 0x05
    7cec:	7e 81       	ldd	r23, Y+6	; 0x06
    7cee:	8f 81       	ldd	r24, Y+7	; 0x07
    7cf0:	98 85       	ldd	r25, Y+8	; 0x08
    7cf2:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7cf6:	dc 01       	movw	r26, r24
    7cf8:	cb 01       	movw	r24, r22
    7cfa:	89 87       	std	Y+9, r24	; 0x09
    7cfc:	9a 87       	std	Y+10, r25	; 0x0a
    7cfe:	89 85       	ldd	r24, Y+9	; 0x09
    7d00:	9a 85       	ldd	r25, Y+10	; 0x0a
    7d02:	8d 87       	std	Y+13, r24	; 0x0d
    7d04:	9e 87       	std	Y+14, r25	; 0x0e
    7d06:	8d 85       	ldd	r24, Y+13	; 0x0d
    7d08:	9e 85       	ldd	r25, Y+14	; 0x0e
    7d0a:	8c 01       	movw	r16, r24
    7d0c:	c8 01       	movw	r24, r16
    7d0e:	01 97       	sbiw	r24, 0x01	; 1
    7d10:	f1 f7       	brne	.-4      	; 0x7d0e <checkMote+0x114>
    7d12:	8c 01       	movw	r16, r24
    7d14:	0d 87       	std	Y+13, r16	; 0x0d
    7d16:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7d18:	88 e0       	ldi	r24, 0x08	; 8
    7d1a:	60 e0       	ldi	r22, 0x00	; 0
    7d1c:	0e 94 24 35 	call	0x6a48	; 0x6a48 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7d20:	88 e0       	ldi	r24, 0x08	; 8
    7d22:	60 e0       	ldi	r22, 0x00	; 0
    7d24:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
    7d28:	80 e0       	ldi	r24, 0x00	; 0
    7d2a:	90 e4       	ldi	r25, 0x40	; 64
    7d2c:	ac e9       	ldi	r26, 0x9C	; 156
    7d2e:	b5 e4       	ldi	r27, 0x45	; 69
    7d30:	8f 87       	std	Y+15, r24	; 0x0f
    7d32:	98 8b       	std	Y+16, r25	; 0x10
    7d34:	a9 8b       	std	Y+17, r26	; 0x11
    7d36:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7d38:	6f 85       	ldd	r22, Y+15	; 0x0f
    7d3a:	78 89       	ldd	r23, Y+16	; 0x10
    7d3c:	89 89       	ldd	r24, Y+17	; 0x11
    7d3e:	9a 89       	ldd	r25, Y+18	; 0x12
    7d40:	20 e0       	ldi	r18, 0x00	; 0
    7d42:	30 e0       	ldi	r19, 0x00	; 0
    7d44:	4a ef       	ldi	r20, 0xFA	; 250
    7d46:	55 e4       	ldi	r21, 0x45	; 69
    7d48:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7d4c:	dc 01       	movw	r26, r24
    7d4e:	cb 01       	movw	r24, r22
    7d50:	8b 8b       	std	Y+19, r24	; 0x13
    7d52:	9c 8b       	std	Y+20, r25	; 0x14
    7d54:	ad 8b       	std	Y+21, r26	; 0x15
    7d56:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7d58:	11 e0       	ldi	r17, 0x01	; 1
    7d5a:	6b 89       	ldd	r22, Y+19	; 0x13
    7d5c:	7c 89       	ldd	r23, Y+20	; 0x14
    7d5e:	8d 89       	ldd	r24, Y+21	; 0x15
    7d60:	9e 89       	ldd	r25, Y+22	; 0x16
    7d62:	20 e0       	ldi	r18, 0x00	; 0
    7d64:	30 e0       	ldi	r19, 0x00	; 0
    7d66:	40 e8       	ldi	r20, 0x80	; 128
    7d68:	5f e3       	ldi	r21, 0x3F	; 63
    7d6a:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7d6e:	88 23       	and	r24, r24
    7d70:	0c f0       	brlt	.+2      	; 0x7d74 <checkMote+0x17a>
    7d72:	10 e0       	ldi	r17, 0x00	; 0
    7d74:	11 23       	and	r17, r17
    7d76:	29 f0       	breq	.+10     	; 0x7d82 <checkMote+0x188>
		__ticks = 1;
    7d78:	81 e0       	ldi	r24, 0x01	; 1
    7d7a:	90 e0       	ldi	r25, 0x00	; 0
    7d7c:	8f 8b       	std	Y+23, r24	; 0x17
    7d7e:	98 8f       	std	Y+24, r25	; 0x18
    7d80:	46 c0       	rjmp	.+140    	; 0x7e0e <checkMote+0x214>
	else if (__tmp > 65535)
    7d82:	11 e0       	ldi	r17, 0x01	; 1
    7d84:	6b 89       	ldd	r22, Y+19	; 0x13
    7d86:	7c 89       	ldd	r23, Y+20	; 0x14
    7d88:	8d 89       	ldd	r24, Y+21	; 0x15
    7d8a:	9e 89       	ldd	r25, Y+22	; 0x16
    7d8c:	20 e0       	ldi	r18, 0x00	; 0
    7d8e:	3f ef       	ldi	r19, 0xFF	; 255
    7d90:	4f e7       	ldi	r20, 0x7F	; 127
    7d92:	57 e4       	ldi	r21, 0x47	; 71
    7d94:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    7d98:	18 16       	cp	r1, r24
    7d9a:	0c f0       	brlt	.+2      	; 0x7d9e <checkMote+0x1a4>
    7d9c:	10 e0       	ldi	r17, 0x00	; 0
    7d9e:	11 23       	and	r17, r17
    7da0:	61 f1       	breq	.+88     	; 0x7dfa <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7da2:	6f 85       	ldd	r22, Y+15	; 0x0f
    7da4:	78 89       	ldd	r23, Y+16	; 0x10
    7da6:	89 89       	ldd	r24, Y+17	; 0x11
    7da8:	9a 89       	ldd	r25, Y+18	; 0x12
    7daa:	20 e0       	ldi	r18, 0x00	; 0
    7dac:	30 e0       	ldi	r19, 0x00	; 0
    7dae:	40 e2       	ldi	r20, 0x20	; 32
    7db0:	51 e4       	ldi	r21, 0x41	; 65
    7db2:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7db6:	dc 01       	movw	r26, r24
    7db8:	cb 01       	movw	r24, r22
    7dba:	bc 01       	movw	r22, r24
    7dbc:	cd 01       	movw	r24, r26
    7dbe:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7dc2:	dc 01       	movw	r26, r24
    7dc4:	cb 01       	movw	r24, r22
    7dc6:	8f 8b       	std	Y+23, r24	; 0x17
    7dc8:	98 8f       	std	Y+24, r25	; 0x18
    7dca:	12 c0       	rjmp	.+36     	; 0x7df0 <checkMote+0x1f6>
    7dcc:	80 e2       	ldi	r24, 0x20	; 32
    7dce:	93 e0       	ldi	r25, 0x03	; 3
    7dd0:	89 8f       	std	Y+25, r24	; 0x19
    7dd2:	9a 8f       	std	Y+26, r25	; 0x1a
    7dd4:	89 8d       	ldd	r24, Y+25	; 0x19
    7dd6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7dd8:	8c 01       	movw	r16, r24
    7dda:	c8 01       	movw	r24, r16
    7ddc:	01 97       	sbiw	r24, 0x01	; 1
    7dde:	f1 f7       	brne	.-4      	; 0x7ddc <checkMote+0x1e2>
    7de0:	8c 01       	movw	r16, r24
    7de2:	09 8f       	std	Y+25, r16	; 0x19
    7de4:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7de6:	8f 89       	ldd	r24, Y+23	; 0x17
    7de8:	98 8d       	ldd	r25, Y+24	; 0x18
    7dea:	01 97       	sbiw	r24, 0x01	; 1
    7dec:	8f 8b       	std	Y+23, r24	; 0x17
    7dee:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7df0:	8f 89       	ldd	r24, Y+23	; 0x17
    7df2:	98 8d       	ldd	r25, Y+24	; 0x18
    7df4:	00 97       	sbiw	r24, 0x00	; 0
    7df6:	51 f7       	brne	.-44     	; 0x7dcc <checkMote+0x1d2>
    7df8:	17 c0       	rjmp	.+46     	; 0x7e28 <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7dfa:	6b 89       	ldd	r22, Y+19	; 0x13
    7dfc:	7c 89       	ldd	r23, Y+20	; 0x14
    7dfe:	8d 89       	ldd	r24, Y+21	; 0x15
    7e00:	9e 89       	ldd	r25, Y+22	; 0x16
    7e02:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7e06:	dc 01       	movw	r26, r24
    7e08:	cb 01       	movw	r24, r22
    7e0a:	8f 8b       	std	Y+23, r24	; 0x17
    7e0c:	98 8f       	std	Y+24, r25	; 0x18
    7e0e:	8f 89       	ldd	r24, Y+23	; 0x17
    7e10:	98 8d       	ldd	r25, Y+24	; 0x18
    7e12:	8b 8f       	std	Y+27, r24	; 0x1b
    7e14:	9c 8f       	std	Y+28, r25	; 0x1c
    7e16:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7e18:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7e1a:	8c 01       	movw	r16, r24
    7e1c:	c8 01       	movw	r24, r16
    7e1e:	01 97       	sbiw	r24, 0x01	; 1
    7e20:	f1 f7       	brne	.-4      	; 0x7e1e <checkMote+0x224>
    7e22:	8c 01       	movw	r16, r24
    7e24:	0b 8f       	std	Y+27, r16	; 0x1b
    7e26:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7e28:	88 e0       	ldi	r24, 0x08	; 8
    7e2a:	60 e0       	ldi	r22, 0x00	; 0
    7e2c:	0e 94 53 36 	call	0x6ca6	; 0x6ca6 <PortEx_OUTCLR>
    7e30:	80 e0       	ldi	r24, 0x00	; 0
    7e32:	90 e4       	ldi	r25, 0x40	; 64
    7e34:	ac e9       	ldi	r26, 0x9C	; 156
    7e36:	b5 e4       	ldi	r27, 0x45	; 69
    7e38:	8d 8f       	std	Y+29, r24	; 0x1d
    7e3a:	9e 8f       	std	Y+30, r25	; 0x1e
    7e3c:	af 8f       	std	Y+31, r26	; 0x1f
    7e3e:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7e40:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7e42:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7e44:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7e46:	98 a1       	lds	r25, 0x48
    7e48:	20 e0       	ldi	r18, 0x00	; 0
    7e4a:	30 e0       	ldi	r19, 0x00	; 0
    7e4c:	4a ef       	ldi	r20, 0xFA	; 250
    7e4e:	55 e4       	ldi	r21, 0x45	; 69
    7e50:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7e54:	dc 01       	movw	r26, r24
    7e56:	cb 01       	movw	r24, r22
    7e58:	89 a3       	lds	r24, 0x59
    7e5a:	9a a3       	lds	r25, 0x5a
    7e5c:	ab a3       	lds	r26, 0x5b
    7e5e:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7e60:	11 e0       	ldi	r17, 0x01	; 1
    7e62:	69 a1       	lds	r22, 0x49
    7e64:	7a a1       	lds	r23, 0x4a
    7e66:	8b a1       	lds	r24, 0x4b
    7e68:	9c a1       	lds	r25, 0x4c
    7e6a:	20 e0       	ldi	r18, 0x00	; 0
    7e6c:	30 e0       	ldi	r19, 0x00	; 0
    7e6e:	40 e8       	ldi	r20, 0x80	; 128
    7e70:	5f e3       	ldi	r21, 0x3F	; 63
    7e72:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    7e76:	88 23       	and	r24, r24
    7e78:	0c f0       	brlt	.+2      	; 0x7e7c <checkMote+0x282>
    7e7a:	10 e0       	ldi	r17, 0x00	; 0
    7e7c:	11 23       	and	r17, r17
    7e7e:	29 f0       	breq	.+10     	; 0x7e8a <checkMote+0x290>
		__ticks = 1;
    7e80:	81 e0       	ldi	r24, 0x01	; 1
    7e82:	90 e0       	ldi	r25, 0x00	; 0
    7e84:	8d a3       	lds	r24, 0x5d
    7e86:	9e a3       	lds	r25, 0x5e
    7e88:	46 c0       	rjmp	.+140    	; 0x7f16 <checkMote+0x31c>
	else if (__tmp > 65535)
    7e8a:	11 e0       	ldi	r17, 0x01	; 1
    7e8c:	69 a1       	lds	r22, 0x49
    7e8e:	7a a1       	lds	r23, 0x4a
    7e90:	8b a1       	lds	r24, 0x4b
    7e92:	9c a1       	lds	r25, 0x4c
    7e94:	20 e0       	ldi	r18, 0x00	; 0
    7e96:	3f ef       	ldi	r19, 0xFF	; 255
    7e98:	4f e7       	ldi	r20, 0x7F	; 127
    7e9a:	57 e4       	ldi	r21, 0x47	; 71
    7e9c:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    7ea0:	18 16       	cp	r1, r24
    7ea2:	0c f0       	brlt	.+2      	; 0x7ea6 <checkMote+0x2ac>
    7ea4:	10 e0       	ldi	r17, 0x00	; 0
    7ea6:	11 23       	and	r17, r17
    7ea8:	61 f1       	breq	.+88     	; 0x7f02 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7eaa:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7eac:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7eae:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7eb0:	98 a1       	lds	r25, 0x48
    7eb2:	20 e0       	ldi	r18, 0x00	; 0
    7eb4:	30 e0       	ldi	r19, 0x00	; 0
    7eb6:	40 e2       	ldi	r20, 0x20	; 32
    7eb8:	51 e4       	ldi	r21, 0x41	; 65
    7eba:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    7ebe:	dc 01       	movw	r26, r24
    7ec0:	cb 01       	movw	r24, r22
    7ec2:	bc 01       	movw	r22, r24
    7ec4:	cd 01       	movw	r24, r26
    7ec6:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7eca:	dc 01       	movw	r26, r24
    7ecc:	cb 01       	movw	r24, r22
    7ece:	8d a3       	lds	r24, 0x5d
    7ed0:	9e a3       	lds	r25, 0x5e
    7ed2:	12 c0       	rjmp	.+36     	; 0x7ef8 <checkMote+0x2fe>
    7ed4:	80 e2       	ldi	r24, 0x20	; 32
    7ed6:	93 e0       	ldi	r25, 0x03	; 3
    7ed8:	8f a3       	lds	r24, 0x5f
    7eda:	98 a7       	lds	r25, 0x78
    7edc:	8f a1       	lds	r24, 0x4f
    7ede:	98 a5       	lds	r25, 0x68
    7ee0:	8c 01       	movw	r16, r24
    7ee2:	c8 01       	movw	r24, r16
    7ee4:	01 97       	sbiw	r24, 0x01	; 1
    7ee6:	f1 f7       	brne	.-4      	; 0x7ee4 <checkMote+0x2ea>
    7ee8:	8c 01       	movw	r16, r24
    7eea:	0f a3       	lds	r16, 0x5f
    7eec:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7eee:	8d a1       	lds	r24, 0x4d
    7ef0:	9e a1       	lds	r25, 0x4e
    7ef2:	01 97       	sbiw	r24, 0x01	; 1
    7ef4:	8d a3       	lds	r24, 0x5d
    7ef6:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7ef8:	8d a1       	lds	r24, 0x4d
    7efa:	9e a1       	lds	r25, 0x4e
    7efc:	00 97       	sbiw	r24, 0x00	; 0
    7efe:	51 f7       	brne	.-44     	; 0x7ed4 <checkMote+0x2da>
    7f00:	18 c0       	rjmp	.+48     	; 0x7f32 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7f02:	69 a1       	lds	r22, 0x49
    7f04:	7a a1       	lds	r23, 0x4a
    7f06:	8b a1       	lds	r24, 0x4b
    7f08:	9c a1       	lds	r25, 0x4c
    7f0a:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    7f0e:	dc 01       	movw	r26, r24
    7f10:	cb 01       	movw	r24, r22
    7f12:	8d a3       	lds	r24, 0x5d
    7f14:	9e a3       	lds	r25, 0x5e
    7f16:	8d a1       	lds	r24, 0x4d
    7f18:	9e a1       	lds	r25, 0x4e
    7f1a:	89 a7       	lds	r24, 0x79
    7f1c:	9a a7       	lds	r25, 0x7a
    7f1e:	89 a5       	lds	r24, 0x69
    7f20:	9a a5       	lds	r25, 0x6a
    7f22:	8c 01       	movw	r16, r24
    7f24:	c8 01       	movw	r24, r16
    7f26:	01 97       	sbiw	r24, 0x01	; 1
    7f28:	f1 f7       	brne	.-4      	; 0x7f26 <checkMote+0x32c>
    7f2a:	8c 01       	movw	r16, r24
    7f2c:	09 a7       	lds	r16, 0x79
    7f2e:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7f30:	f7 ce       	rjmp	.-530    	; 0x7d20 <checkMote+0x126>
    7f32:	f6 ce       	rjmp	.-532    	; 0x7d20 <checkMote+0x126>

00007f34 <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7f34:	cf 93       	push	r28
    7f36:	df 93       	push	r29
    7f38:	cd b7       	in	r28, 0x3d	; 61
    7f3a:	de b7       	in	r29, 0x3e	; 62
    7f3c:	28 97       	sbiw	r28, 0x08	; 8
    7f3e:	cd bf       	out	0x3d, r28	; 61
    7f40:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7f42:	19 82       	std	Y+1, r1	; 0x01
    7f44:	1a 82       	std	Y+2, r1	; 0x02
    7f46:	0c c0       	rjmp	.+24     	; 0x7f60 <SD_write_and_read_knowns+0x2c>
    7f48:	29 81       	ldd	r18, Y+1	; 0x01
    7f4a:	89 81       	ldd	r24, Y+1	; 0x01
    7f4c:	9a 81       	ldd	r25, Y+2	; 0x02
    7f4e:	8c 52       	subi	r24, 0x2C	; 44
    7f50:	9c 4d       	sbci	r25, 0xDC	; 220
    7f52:	fc 01       	movw	r30, r24
    7f54:	20 83       	st	Z, r18
    7f56:	89 81       	ldd	r24, Y+1	; 0x01
    7f58:	9a 81       	ldd	r25, Y+2	; 0x02
    7f5a:	01 96       	adiw	r24, 0x01	; 1
    7f5c:	89 83       	std	Y+1, r24	; 0x01
    7f5e:	9a 83       	std	Y+2, r25	; 0x02
    7f60:	89 81       	ldd	r24, Y+1	; 0x01
    7f62:	9a 81       	ldd	r25, Y+2	; 0x02
    7f64:	88 31       	cpi	r24, 0x18	; 24
    7f66:	91 05       	cpc	r25, r1
    7f68:	7c f3       	brlt	.-34     	; 0x7f48 <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7f6a:	24 ed       	ldi	r18, 0xD4	; 212
    7f6c:	33 e2       	ldi	r19, 0x23	; 35
    7f6e:	64 e1       	ldi	r22, 0x14	; 20
    7f70:	70 e0       	ldi	r23, 0x00	; 0
    7f72:	80 e0       	ldi	r24, 0x00	; 0
    7f74:	90 e0       	ldi	r25, 0x00	; 0
    7f76:	a9 01       	movw	r20, r18
    7f78:	28 e1       	ldi	r18, 0x18	; 24
    7f7a:	30 e0       	ldi	r19, 0x00	; 0
    7f7c:	0e 94 c3 4f 	call	0x9f86	; 0x9f86 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7f80:	1b 82       	std	Y+3, r1	; 0x03
    7f82:	1c 82       	std	Y+4, r1	; 0x04
    7f84:	0b c0       	rjmp	.+22     	; 0x7f9c <SD_write_and_read_knowns+0x68>
    7f86:	8b 81       	ldd	r24, Y+3	; 0x03
    7f88:	9c 81       	ldd	r25, Y+4	; 0x04
    7f8a:	8c 52       	subi	r24, 0x2C	; 44
    7f8c:	9c 4d       	sbci	r25, 0xDC	; 220
    7f8e:	fc 01       	movw	r30, r24
    7f90:	10 82       	st	Z, r1
    7f92:	8b 81       	ldd	r24, Y+3	; 0x03
    7f94:	9c 81       	ldd	r25, Y+4	; 0x04
    7f96:	01 96       	adiw	r24, 0x01	; 1
    7f98:	8b 83       	std	Y+3, r24	; 0x03
    7f9a:	9c 83       	std	Y+4, r25	; 0x04
    7f9c:	8b 81       	ldd	r24, Y+3	; 0x03
    7f9e:	9c 81       	ldd	r25, Y+4	; 0x04
    7fa0:	88 31       	cpi	r24, 0x18	; 24
    7fa2:	91 05       	cpc	r25, r1
    7fa4:	84 f3       	brlt	.-32     	; 0x7f86 <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7fa6:	24 ed       	ldi	r18, 0xD4	; 212
    7fa8:	33 e2       	ldi	r19, 0x23	; 35
    7faa:	64 e1       	ldi	r22, 0x14	; 20
    7fac:	70 e0       	ldi	r23, 0x00	; 0
    7fae:	80 e0       	ldi	r24, 0x00	; 0
    7fb0:	90 e0       	ldi	r25, 0x00	; 0
    7fb2:	a9 01       	movw	r20, r18
    7fb4:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7fb8:	1d 82       	std	Y+5, r1	; 0x05
    7fba:	1e 82       	std	Y+6, r1	; 0x06
    7fbc:	13 c0       	rjmp	.+38     	; 0x7fe4 <SD_write_and_read_knowns+0xb0>
    7fbe:	8d 81       	ldd	r24, Y+5	; 0x05
    7fc0:	9e 81       	ldd	r25, Y+6	; 0x06
    7fc2:	24 e6       	ldi	r18, 0x64	; 100
    7fc4:	30 e0       	ldi	r19, 0x00	; 0
    7fc6:	b9 01       	movw	r22, r18
    7fc8:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    7fcc:	28 2f       	mov	r18, r24
    7fce:	8d 81       	ldd	r24, Y+5	; 0x05
    7fd0:	9e 81       	ldd	r25, Y+6	; 0x06
    7fd2:	8c 52       	subi	r24, 0x2C	; 44
    7fd4:	9c 4d       	sbci	r25, 0xDC	; 220
    7fd6:	fc 01       	movw	r30, r24
    7fd8:	20 83       	st	Z, r18
    7fda:	8d 81       	ldd	r24, Y+5	; 0x05
    7fdc:	9e 81       	ldd	r25, Y+6	; 0x06
    7fde:	01 96       	adiw	r24, 0x01	; 1
    7fe0:	8d 83       	std	Y+5, r24	; 0x05
    7fe2:	9e 83       	std	Y+6, r25	; 0x06
    7fe4:	8d 81       	ldd	r24, Y+5	; 0x05
    7fe6:	9e 81       	ldd	r25, Y+6	; 0x06
    7fe8:	f4 e0       	ldi	r31, 0x04	; 4
    7fea:	82 3e       	cpi	r24, 0xE2	; 226
    7fec:	9f 07       	cpc	r25, r31
    7fee:	3c f3       	brlt	.-50     	; 0x7fbe <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7ff0:	24 ed       	ldi	r18, 0xD4	; 212
    7ff2:	33 e2       	ldi	r19, 0x23	; 35
    7ff4:	60 e5       	ldi	r22, 0x50	; 80
    7ff6:	70 e0       	ldi	r23, 0x00	; 0
    7ff8:	80 e0       	ldi	r24, 0x00	; 0
    7ffa:	90 e0       	ldi	r25, 0x00	; 0
    7ffc:	a9 01       	movw	r20, r18
    7ffe:	22 ee       	ldi	r18, 0xE2	; 226
    8000:	34 e0       	ldi	r19, 0x04	; 4
    8002:	0e 94 07 51 	call	0xa20e	; 0xa20e <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    8006:	1f 82       	std	Y+7, r1	; 0x07
    8008:	18 86       	std	Y+8, r1	; 0x08
    800a:	0b c0       	rjmp	.+22     	; 0x8022 <SD_write_and_read_knowns+0xee>
    800c:	8f 81       	ldd	r24, Y+7	; 0x07
    800e:	98 85       	ldd	r25, Y+8	; 0x08
    8010:	8c 52       	subi	r24, 0x2C	; 44
    8012:	9c 4d       	sbci	r25, 0xDC	; 220
    8014:	fc 01       	movw	r30, r24
    8016:	10 82       	st	Z, r1
    8018:	8f 81       	ldd	r24, Y+7	; 0x07
    801a:	98 85       	ldd	r25, Y+8	; 0x08
    801c:	01 96       	adiw	r24, 0x01	; 1
    801e:	8f 83       	std	Y+7, r24	; 0x07
    8020:	98 87       	std	Y+8, r25	; 0x08
    8022:	8f 81       	ldd	r24, Y+7	; 0x07
    8024:	98 85       	ldd	r25, Y+8	; 0x08
    8026:	f4 e0       	ldi	r31, 0x04	; 4
    8028:	82 3e       	cpi	r24, 0xE2	; 226
    802a:	9f 07       	cpc	r25, r31
    802c:	7c f3       	brlt	.-34     	; 0x800c <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    802e:	24 ed       	ldi	r18, 0xD4	; 212
    8030:	33 e2       	ldi	r19, 0x23	; 35
    8032:	60 e5       	ldi	r22, 0x50	; 80
    8034:	70 e0       	ldi	r23, 0x00	; 0
    8036:	80 e0       	ldi	r24, 0x00	; 0
    8038:	90 e0       	ldi	r25, 0x00	; 0
    803a:	a9 01       	movw	r20, r18
    803c:	23 e0       	ldi	r18, 0x03	; 3
    803e:	30 e0       	ldi	r19, 0x00	; 0
    8040:	0e 94 65 52 	call	0xa4ca	; 0xa4ca <SD_read_multiple_blocks>
}
    8044:	28 96       	adiw	r28, 0x08	; 8
    8046:	cd bf       	out	0x3d, r28	; 61
    8048:	de bf       	out	0x3e, r29	; 62
    804a:	df 91       	pop	r29
    804c:	cf 91       	pop	r28
    804e:	08 95       	ret

00008050 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    8050:	cf 93       	push	r28
    8052:	df 93       	push	r29
    8054:	00 d0       	rcall	.+0      	; 0x8056 <SD_write_and_read_knowns_FAT+0x6>
    8056:	0f 92       	push	r0
    8058:	cd b7       	in	r28, 0x3d	; 61
    805a:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    805c:	19 82       	std	Y+1, r1	; 0x01
    805e:	1a 82       	std	Y+2, r1	; 0x02
    8060:	0c c0       	rjmp	.+24     	; 0x807a <SD_write_and_read_knowns_FAT+0x2a>
    8062:	29 81       	ldd	r18, Y+1	; 0x01
    8064:	89 81       	ldd	r24, Y+1	; 0x01
    8066:	9a 81       	ldd	r25, Y+2	; 0x02
    8068:	8c 52       	subi	r24, 0x2C	; 44
    806a:	9c 4d       	sbci	r25, 0xDC	; 220
    806c:	fc 01       	movw	r30, r24
    806e:	20 83       	st	Z, r18
    8070:	89 81       	ldd	r24, Y+1	; 0x01
    8072:	9a 81       	ldd	r25, Y+2	; 0x02
    8074:	01 96       	adiw	r24, 0x01	; 1
    8076:	89 83       	std	Y+1, r24	; 0x01
    8078:	9a 83       	std	Y+2, r25	; 0x02
    807a:	89 81       	ldd	r24, Y+1	; 0x01
    807c:	9a 81       	ldd	r25, Y+2	; 0x02
    807e:	88 31       	cpi	r24, 0x18	; 24
    8080:	91 05       	cpc	r25, r1
    8082:	7c f3       	brlt	.-34     	; 0x8062 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",0);
    8084:	83 e2       	ldi	r24, 0x23	; 35
    8086:	90 e2       	ldi	r25, 0x20	; 32
    8088:	40 e0       	ldi	r20, 0x00	; 0
    808a:	50 e0       	ldi	r21, 0x00	; 0
    808c:	ba 01       	movw	r22, r20
    808e:	0e 94 18 48 	call	0x9030	; 0x9030 <writeFile>
    8092:	80 93 94 50 	sts	0x5094, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    8096:	1b 82       	std	Y+3, r1	; 0x03
    8098:	1c 82       	std	Y+4, r1	; 0x04
    809a:	0b c0       	rjmp	.+22     	; 0x80b2 <SD_write_and_read_knowns_FAT+0x62>
    809c:	8b 81       	ldd	r24, Y+3	; 0x03
    809e:	9c 81       	ldd	r25, Y+4	; 0x04
    80a0:	8c 52       	subi	r24, 0x2C	; 44
    80a2:	9c 4d       	sbci	r25, 0xDC	; 220
    80a4:	fc 01       	movw	r30, r24
    80a6:	10 82       	st	Z, r1
    80a8:	8b 81       	ldd	r24, Y+3	; 0x03
    80aa:	9c 81       	ldd	r25, Y+4	; 0x04
    80ac:	01 96       	adiw	r24, 0x01	; 1
    80ae:	8b 83       	std	Y+3, r24	; 0x03
    80b0:	9c 83       	std	Y+4, r25	; 0x04
    80b2:	8b 81       	ldd	r24, Y+3	; 0x03
    80b4:	9c 81       	ldd	r25, Y+4	; 0x04
    80b6:	88 31       	cpi	r24, 0x18	; 24
    80b8:	91 05       	cpc	r25, r1
    80ba:	84 f3       	brlt	.-32     	; 0x809c <SD_write_and_read_knowns_FAT+0x4c>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    80bc:	23 e2       	ldi	r18, 0x23	; 35
    80be:	30 e2       	ldi	r19, 0x20	; 32
    80c0:	80 e0       	ldi	r24, 0x00	; 0
    80c2:	b9 01       	movw	r22, r18
    80c4:	0e 94 33 46 	call	0x8c66	; 0x8c66 <readFile>
    80c8:	80 93 94 50 	sts	0x5094, r24
}
    80cc:	24 96       	adiw	r28, 0x04	; 4
    80ce:	cd bf       	out	0x3d, r28	; 61
    80d0:	de bf       	out	0x3e, r29	; 62
    80d2:	df 91       	pop	r29
    80d4:	cf 91       	pop	r28
    80d6:	08 95       	ret

000080d8 <chibi_test_radio>:
	//WriteRadioRegister(RADIOCTRLRGSTR, RX_ON);
	//sei();
}
*/
//function for testing radio transmission
void chibi_test_radio(){
    80d8:	cf 93       	push	r28
    80da:	df 93       	push	r29
    80dc:	cd b7       	in	r28, 0x3d	; 61
    80de:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    80e0:	0e 94 47 20 	call	0x408e	; 0x408e <chb_init>
	chb_set_short_addr(0x0002);
    80e4:	82 e0       	ldi	r24, 0x02	; 2
    80e6:	90 e0       	ldi	r25, 0x00	; 0
    80e8:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    80ec:	00 00       	nop
    80ee:	fe cf       	rjmp	.-4      	; 0x80ec <chibi_test_radio+0x14>

000080f0 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    80f0:	cf 93       	push	r28
    80f2:	df 93       	push	r29
    80f4:	0f 92       	push	r0
    80f6:	0f 92       	push	r0
    80f8:	cd b7       	in	r28, 0x3d	; 61
    80fa:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    80fc:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <SD_init>
	getBootSectorData();
    8100:	0e 94 83 41 	call	0x8306	; 0x8306 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    8104:	19 82       	std	Y+1, r1	; 0x01
    8106:	1a 82       	std	Y+2, r1	; 0x02
    8108:	13 c0       	rjmp	.+38     	; 0x8130 <TestCard+0x40>
    810a:	89 81       	ldd	r24, Y+1	; 0x01
    810c:	9a 81       	ldd	r25, Y+2	; 0x02
    810e:	29 e7       	ldi	r18, 0x79	; 121
    8110:	30 e0       	ldi	r19, 0x00	; 0
    8112:	b9 01       	movw	r22, r18
    8114:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    8118:	28 2f       	mov	r18, r24
    811a:	89 81       	ldd	r24, Y+1	; 0x01
    811c:	9a 81       	ldd	r25, Y+2	; 0x02
    811e:	8c 52       	subi	r24, 0x2C	; 44
    8120:	9c 4d       	sbci	r25, 0xDC	; 220
    8122:	fc 01       	movw	r30, r24
    8124:	20 83       	st	Z, r18
    8126:	89 81       	ldd	r24, Y+1	; 0x01
    8128:	9a 81       	ldd	r25, Y+2	; 0x02
    812a:	01 96       	adiw	r24, 0x01	; 1
    812c:	89 83       	std	Y+1, r24	; 0x01
    812e:	9a 83       	std	Y+2, r25	; 0x02
    8130:	89 81       	ldd	r24, Y+1	; 0x01
    8132:	9a 81       	ldd	r25, Y+2	; 0x02
    8134:	f2 e0       	ldi	r31, 0x02	; 2
    8136:	80 30       	cpi	r24, 0x00	; 0
    8138:	9f 07       	cpc	r25, r31
    813a:	3c f3       	brlt	.-50     	; 0x810a <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",0);//}
    813c:	83 e2       	ldi	r24, 0x23	; 35
    813e:	90 e2       	ldi	r25, 0x20	; 32
    8140:	40 e0       	ldi	r20, 0x00	; 0
    8142:	50 e0       	ldi	r21, 0x00	; 0
    8144:	ba 01       	movw	r22, r20
    8146:	0e 94 18 48 	call	0x9030	; 0x9030 <writeFile>
	nop();
    814a:	00 00       	nop
}
    814c:	0f 90       	pop	r0
    814e:	0f 90       	pop	r0
    8150:	df 91       	pop	r29
    8152:	cf 91       	pop	r28
    8154:	08 95       	ret

00008156 <__vector_43>:

//interrupt service routine for handling received data over radio
ISR(PORTE_INT0_vect){
    8156:	1f 92       	push	r1
    8158:	0f 92       	push	r0
    815a:	0f b6       	in	r0, 0x3f	; 63
    815c:	0f 92       	push	r0
    815e:	00 90 3b 00 	lds	r0, 0x003B
    8162:	0f 92       	push	r0
    8164:	11 24       	eor	r1, r1
    8166:	2f 93       	push	r18
    8168:	3f 93       	push	r19
    816a:	4f 93       	push	r20
    816c:	5f 93       	push	r21
    816e:	6f 93       	push	r22
    8170:	7f 93       	push	r23
    8172:	8f 93       	push	r24
    8174:	9f 93       	push	r25
    8176:	af 93       	push	r26
    8178:	bf 93       	push	r27
    817a:	ef 93       	push	r30
    817c:	ff 93       	push	r31
    817e:	cf 93       	push	r28
    8180:	df 93       	push	r29
    8182:	cd b7       	in	r28, 0x3d	; 61
    8184:	de b7       	in	r29, 0x3e	; 62
    8186:	c4 58       	subi	r28, 0x84	; 132
    8188:	d0 40       	sbci	r29, 0x00	; 0
    818a:	cd bf       	out	0x3d, r28	; 61
    818c:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    818e:	80 91 53 40 	lds	r24, 0x4053
    8192:	88 2f       	mov	r24, r24
    8194:	90 e0       	ldi	r25, 0x00	; 0
    8196:	81 30       	cpi	r24, 0x01	; 1
    8198:	91 05       	cpc	r25, r1
    819a:	29 f0       	breq	.+10     	; 0x81a6 <__vector_43+0x50>
    819c:	82 30       	cpi	r24, 0x02	; 2
    819e:	91 05       	cpc	r25, r1
    81a0:	09 f4       	brne	.+2      	; 0x81a4 <__vector_43+0x4e>
    81a2:	73 c0       	rjmp	.+230    	; 0x828a <__vector_43+0x134>
    81a4:	91 c0       	rjmp	.+290    	; 0x82c8 <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    81a6:	ce 01       	movw	r24, r28
    81a8:	05 96       	adiw	r24, 0x05	; 5
    81aa:	0e 94 93 22 	call	0x4526	; 0x4526 <chb_read>
			if(!strncmp(msg,ResetCommand,5)){
    81ae:	ce 01       	movw	r24, r28
    81b0:	05 96       	adiw	r24, 0x05	; 5
    81b2:	2c ea       	ldi	r18, 0xAC	; 172
    81b4:	30 e5       	ldi	r19, 0x50	; 80
    81b6:	b9 01       	movw	r22, r18
    81b8:	45 e0       	ldi	r20, 0x05	; 5
    81ba:	50 e0       	ldi	r21, 0x00	; 0
    81bc:	0e 94 3e 5f 	call	0xbe7c	; 0xbe7c <strncmp>
    81c0:	00 97       	sbiw	r24, 0x00	; 0
    81c2:	51 f4       	brne	.+20     	; 0x81d8 <__vector_43+0x82>
				MotesReadyToSynch++;
    81c4:	80 91 69 50 	lds	r24, 0x5069
    81c8:	90 91 6a 50 	lds	r25, 0x506A
    81cc:	01 96       	adiw	r24, 0x01	; 1
    81ce:	80 93 69 50 	sts	0x5069, r24
    81d2:	90 93 6a 50 	sts	0x506A, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    81d6:	7a c0       	rjmp	.+244    	; 0x82cc <__vector_43+0x176>
			if(!strncmp(msg,ResetCommand,5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    81d8:	19 82       	std	Y+1, r1	; 0x01
    81da:	1a 82       	std	Y+2, r1	; 0x02
    81dc:	1b 82       	std	Y+3, r1	; 0x03
    81de:	1c 82       	std	Y+4, r1	; 0x04
    81e0:	1a c0       	rjmp	.+52     	; 0x8216 <__vector_43+0xc0>
    81e2:	9e 01       	movw	r18, r28
    81e4:	2b 5f       	subi	r18, 0xFB	; 251
    81e6:	3f 4f       	sbci	r19, 0xFF	; 255
    81e8:	89 81       	ldd	r24, Y+1	; 0x01
    81ea:	9a 81       	ldd	r25, Y+2	; 0x02
    81ec:	82 0f       	add	r24, r18
    81ee:	93 1f       	adc	r25, r19
    81f0:	fc 01       	movw	r30, r24
    81f2:	20 81       	ld	r18, Z
    81f4:	89 81       	ldd	r24, Y+1	; 0x01
    81f6:	9a 81       	ldd	r25, Y+2	; 0x02
    81f8:	8c 52       	subi	r24, 0x2C	; 44
    81fa:	9c 4d       	sbci	r25, 0xDC	; 220
    81fc:	fc 01       	movw	r30, r24
    81fe:	20 83       	st	Z, r18
    8200:	89 81       	ldd	r24, Y+1	; 0x01
    8202:	9a 81       	ldd	r25, Y+2	; 0x02
    8204:	ab 81       	ldd	r26, Y+3	; 0x03
    8206:	bc 81       	ldd	r27, Y+4	; 0x04
    8208:	01 96       	adiw	r24, 0x01	; 1
    820a:	a1 1d       	adc	r26, r1
    820c:	b1 1d       	adc	r27, r1
    820e:	89 83       	std	Y+1, r24	; 0x01
    8210:	9a 83       	std	Y+2, r25	; 0x02
    8212:	ab 83       	std	Y+3, r26	; 0x03
    8214:	bc 83       	std	Y+4, r27	; 0x04
    8216:	89 81       	ldd	r24, Y+1	; 0x01
    8218:	9a 81       	ldd	r25, Y+2	; 0x02
    821a:	ab 81       	ldd	r26, Y+3	; 0x03
    821c:	bc 81       	ldd	r27, Y+4	; 0x04
    821e:	80 38       	cpi	r24, 0x80	; 128
    8220:	91 05       	cpc	r25, r1
    8222:	a1 05       	cpc	r26, r1
    8224:	b1 05       	cpc	r27, r1
    8226:	e8 f2       	brcs	.-70     	; 0x81e2 <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    8228:	80 91 d0 50 	lds	r24, 0x50D0
    822c:	90 91 d1 50 	lds	r25, 0x50D1
    8230:	a0 91 d2 50 	lds	r26, 0x50D2
    8234:	b0 91 d3 50 	lds	r27, 0x50D3
    8238:	80 58       	subi	r24, 0x80	; 128
    823a:	9f 4f       	sbci	r25, 0xFF	; 255
    823c:	af 4f       	sbci	r26, 0xFF	; 255
    823e:	bf 4f       	sbci	r27, 0xFF	; 255
    8240:	80 93 d0 50 	sts	0x50D0, r24
    8244:	90 93 d1 50 	sts	0x50D1, r25
    8248:	a0 93 d2 50 	sts	0x50D2, r26
    824c:	b0 93 d3 50 	sts	0x50D3, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    8250:	80 91 d0 50 	lds	r24, 0x50D0
    8254:	90 91 d1 50 	lds	r25, 0x50D1
    8258:	a0 91 d2 50 	lds	r26, 0x50D2
    825c:	b0 91 d3 50 	lds	r27, 0x50D3
    8260:	80 58       	subi	r24, 0x80	; 128
    8262:	9f 4f       	sbci	r25, 0xFF	; 255
    8264:	af 4f       	sbci	r26, 0xFF	; 255
    8266:	bf 4f       	sbci	r27, 0xFF	; 255
    8268:	81 37       	cpi	r24, 0x71	; 113
    826a:	fc e1       	ldi	r31, 0x1C	; 28
    826c:	9f 07       	cpc	r25, r31
    826e:	f0 e0       	ldi	r31, 0x00	; 0
    8270:	af 07       	cpc	r26, r31
    8272:	f0 e0       	ldi	r31, 0x00	; 0
    8274:	bf 07       	cpc	r27, r31
    8276:	50 f1       	brcs	.+84     	; 0x82cc <__vector_43+0x176>
    8278:	10 92 d0 50 	sts	0x50D0, r1
    827c:	10 92 d1 50 	sts	0x50D1, r1
    8280:	10 92 d2 50 	sts	0x50D2, r1
    8284:	10 92 d3 50 	sts	0x50D3, r1
			}			
			break;
    8288:	21 c0       	rjmp	.+66     	; 0x82cc <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    828a:	ce 01       	movw	r24, r28
    828c:	05 96       	adiw	r24, 0x05	; 5
    828e:	0e 94 93 22 	call	0x4526	; 0x4526 <chb_read>
			if(!strncmp(msg,BasestationSynchResponse,15)){	//if basestation synch response message received, do the following
    8292:	ce 01       	movw	r24, r28
    8294:	05 96       	adiw	r24, 0x05	; 5
    8296:	24 e1       	ldi	r18, 0x14	; 20
    8298:	30 e2       	ldi	r19, 0x20	; 32
    829a:	b9 01       	movw	r22, r18
    829c:	4f e0       	ldi	r20, 0x0F	; 15
    829e:	50 e0       	ldi	r21, 0x00	; 0
    82a0:	0e 94 3e 5f 	call	0xbe7c	; 0xbe7c <strncmp>
    82a4:	00 97       	sbiw	r24, 0x00	; 0
    82a6:	a1 f4       	brne	.+40     	; 0x82d0 <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    82a8:	83 e0       	ldi	r24, 0x03	; 3
    82aa:	80 93 53 40 	sts	0x4053, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    82ae:	80 e4       	ldi	r24, 0x40	; 64
    82b0:	99 e0       	ldi	r25, 0x09	; 9
    82b2:	29 e0       	ldi	r18, 0x09	; 9
    82b4:	fc 01       	movw	r30, r24
    82b6:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    82b8:	80 e4       	ldi	r24, 0x40	; 64
    82ba:	98 e0       	ldi	r25, 0x08	; 8
    82bc:	21 e0       	ldi	r18, 0x01	; 1
    82be:	fc 01       	movw	r30, r24
    82c0:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    82c2:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <ADC_Resume_Sampling>
			}
			break;
    82c6:	04 c0       	rjmp	.+8      	; 0x82d0 <__vector_43+0x17a>
		default:
			break;
    82c8:	00 00       	nop
    82ca:	03 c0       	rjmp	.+6      	; 0x82d2 <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    82cc:	00 00       	nop
    82ce:	01 c0       	rjmp	.+2      	; 0x82d2 <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    82d0:	00 00       	nop
		default:
			break;
	}
    82d2:	cc 57       	subi	r28, 0x7C	; 124
    82d4:	df 4f       	sbci	r29, 0xFF	; 255
    82d6:	cd bf       	out	0x3d, r28	; 61
    82d8:	de bf       	out	0x3e, r29	; 62
    82da:	df 91       	pop	r29
    82dc:	cf 91       	pop	r28
    82de:	ff 91       	pop	r31
    82e0:	ef 91       	pop	r30
    82e2:	bf 91       	pop	r27
    82e4:	af 91       	pop	r26
    82e6:	9f 91       	pop	r25
    82e8:	8f 91       	pop	r24
    82ea:	7f 91       	pop	r23
    82ec:	6f 91       	pop	r22
    82ee:	5f 91       	pop	r21
    82f0:	4f 91       	pop	r20
    82f2:	3f 91       	pop	r19
    82f4:	2f 91       	pop	r18
    82f6:	0f 90       	pop	r0
    82f8:	00 92 3b 00 	sts	0x003B, r0
    82fc:	0f 90       	pop	r0
    82fe:	0f be       	out	0x3f, r0	; 63
    8300:	0f 90       	pop	r0
    8302:	1f 90       	pop	r1
    8304:	18 95       	reti

00008306 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    8306:	ef 92       	push	r14
    8308:	ff 92       	push	r15
    830a:	0f 93       	push	r16
    830c:	1f 93       	push	r17
    830e:	cf 93       	push	r28
    8310:	df 93       	push	r29
    8312:	cd b7       	in	r28, 0x3d	; 61
    8314:	de b7       	in	r29, 0x3e	; 62
    8316:	2a 97       	sbiw	r28, 0x0a	; 10
    8318:	cd bf       	out	0x3d, r28	; 61
    831a:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    831c:	10 92 6e 50 	sts	0x506E, r1
    8320:	10 92 6f 50 	sts	0x506F, r1
    8324:	10 92 70 50 	sts	0x5070, r1
    8328:	10 92 71 50 	sts	0x5071, r1

SD_read_block(0,SDBuffer);
    832c:	2b ec       	ldi	r18, 0xCB	; 203
    832e:	31 e2       	ldi	r19, 0x21	; 33
    8330:	60 e0       	ldi	r22, 0x00	; 0
    8332:	70 e0       	ldi	r23, 0x00	; 0
    8334:	cb 01       	movw	r24, r22
    8336:	a9 01       	movw	r20, r18
    8338:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    833c:	8b ec       	ldi	r24, 0xCB	; 203
    833e:	91 e2       	ldi	r25, 0x21	; 33
    8340:	89 83       	std	Y+1, r24	; 0x01
    8342:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    8344:	89 81       	ldd	r24, Y+1	; 0x01
    8346:	9a 81       	ldd	r25, Y+2	; 0x02
    8348:	fc 01       	movw	r30, r24
    834a:	80 81       	ld	r24, Z
    834c:	89 3e       	cpi	r24, 0xE9	; 233
    834e:	09 f4       	brne	.+2      	; 0x8352 <getBootSectorData+0x4c>
    8350:	4d c0       	rjmp	.+154    	; 0x83ec <getBootSectorData+0xe6>
    8352:	89 81       	ldd	r24, Y+1	; 0x01
    8354:	9a 81       	ldd	r25, Y+2	; 0x02
    8356:	fc 01       	movw	r30, r24
    8358:	80 81       	ld	r24, Z
    835a:	8b 3e       	cpi	r24, 0xEB	; 235
    835c:	09 f4       	brne	.+2      	; 0x8360 <getBootSectorData+0x5a>
    835e:	46 c0       	rjmp	.+140    	; 0x83ec <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    8360:	8b ec       	ldi	r24, 0xCB	; 203
    8362:	91 e2       	ldi	r25, 0x21	; 33
    8364:	8b 83       	std	Y+3, r24	; 0x03
    8366:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    8368:	8b 81       	ldd	r24, Y+3	; 0x03
    836a:	9c 81       	ldd	r25, Y+4	; 0x04
    836c:	82 50       	subi	r24, 0x02	; 2
    836e:	9e 4f       	sbci	r25, 0xFE	; 254
    8370:	fc 01       	movw	r30, r24
    8372:	80 81       	ld	r24, Z
    8374:	91 81       	ldd	r25, Z+1	; 0x01
    8376:	fa ea       	ldi	r31, 0xAA	; 170
    8378:	85 35       	cpi	r24, 0x55	; 85
    837a:	9f 07       	cpc	r25, r31
    837c:	11 f0       	breq	.+4      	; 0x8382 <getBootSectorData+0x7c>
    837e:	81 e0       	ldi	r24, 0x01	; 1
    8380:	01 c1       	rjmp	.+514    	; 0x8584 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    8382:	8b 81       	ldd	r24, Y+3	; 0x03
    8384:	9c 81       	ldd	r25, Y+4	; 0x04
    8386:	82 54       	subi	r24, 0x42	; 66
    8388:	9e 4f       	sbci	r25, 0xFE	; 254
    838a:	8d 83       	std	Y+5, r24	; 0x05
    838c:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    838e:	8d 81       	ldd	r24, Y+5	; 0x05
    8390:	9e 81       	ldd	r25, Y+6	; 0x06
    8392:	fc 01       	movw	r30, r24
    8394:	80 85       	ldd	r24, Z+8	; 0x08
    8396:	91 85       	ldd	r25, Z+9	; 0x09
    8398:	a2 85       	ldd	r26, Z+10	; 0x0a
    839a:	b3 85       	ldd	r27, Z+11	; 0x0b
    839c:	80 93 6e 50 	sts	0x506E, r24
    83a0:	90 93 6f 50 	sts	0x506F, r25
    83a4:	a0 93 70 50 	sts	0x5070, r26
    83a8:	b0 93 71 50 	sts	0x5071, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    83ac:	8d 81       	ldd	r24, Y+5	; 0x05
    83ae:	9e 81       	ldd	r25, Y+6	; 0x06
    83b0:	fc 01       	movw	r30, r24
    83b2:	80 85       	ldd	r24, Z+8	; 0x08
    83b4:	91 85       	ldd	r25, Z+9	; 0x09
    83b6:	a2 85       	ldd	r26, Z+10	; 0x0a
    83b8:	b3 85       	ldd	r27, Z+11	; 0x0b
    83ba:	2b ec       	ldi	r18, 0xCB	; 203
    83bc:	31 e2       	ldi	r19, 0x21	; 33
    83be:	bc 01       	movw	r22, r24
    83c0:	cd 01       	movw	r24, r26
    83c2:	a9 01       	movw	r20, r18
    83c4:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    83c8:	8b ec       	ldi	r24, 0xCB	; 203
    83ca:	91 e2       	ldi	r25, 0x21	; 33
    83cc:	89 83       	std	Y+1, r24	; 0x01
    83ce:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    83d0:	89 81       	ldd	r24, Y+1	; 0x01
    83d2:	9a 81       	ldd	r25, Y+2	; 0x02
    83d4:	fc 01       	movw	r30, r24
    83d6:	80 81       	ld	r24, Z
    83d8:	89 3e       	cpi	r24, 0xE9	; 233
    83da:	41 f0       	breq	.+16     	; 0x83ec <getBootSectorData+0xe6>
    83dc:	89 81       	ldd	r24, Y+1	; 0x01
    83de:	9a 81       	ldd	r25, Y+2	; 0x02
    83e0:	fc 01       	movw	r30, r24
    83e2:	80 81       	ld	r24, Z
    83e4:	8b 3e       	cpi	r24, 0xEB	; 235
    83e6:	11 f0       	breq	.+4      	; 0x83ec <getBootSectorData+0xe6>
    83e8:	81 e0       	ldi	r24, 0x01	; 1
    83ea:	cc c0       	rjmp	.+408    	; 0x8584 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    83ec:	89 81       	ldd	r24, Y+1	; 0x01
    83ee:	9a 81       	ldd	r25, Y+2	; 0x02
    83f0:	fc 01       	movw	r30, r24
    83f2:	83 85       	ldd	r24, Z+11	; 0x0b
    83f4:	94 85       	ldd	r25, Z+12	; 0x0c
    83f6:	80 93 49 40 	sts	0x4049, r24
    83fa:	90 93 4a 40 	sts	0x404A, r25
sectorPerCluster = bpb->sectorPerCluster;
    83fe:	89 81       	ldd	r24, Y+1	; 0x01
    8400:	9a 81       	ldd	r25, Y+2	; 0x02
    8402:	fc 01       	movw	r30, r24
    8404:	85 85       	ldd	r24, Z+13	; 0x0d
    8406:	88 2f       	mov	r24, r24
    8408:	90 e0       	ldi	r25, 0x00	; 0
    840a:	80 93 6c 50 	sts	0x506C, r24
    840e:	90 93 6d 50 	sts	0x506D, r25
reservedSectorCount = bpb->reservedSectorCount;
    8412:	89 81       	ldd	r24, Y+1	; 0x01
    8414:	9a 81       	ldd	r25, Y+2	; 0x02
    8416:	fc 01       	movw	r30, r24
    8418:	86 85       	ldd	r24, Z+14	; 0x0e
    841a:	97 85       	ldd	r25, Z+15	; 0x0f
    841c:	80 93 74 50 	sts	0x5074, r24
    8420:	90 93 75 50 	sts	0x5075, r25
rootCluster = bpb->rootCluster;
    8424:	89 81       	ldd	r24, Y+1	; 0x01
    8426:	9a 81       	ldd	r25, Y+2	; 0x02
    8428:	fc 01       	movw	r30, r24
    842a:	84 a5       	lds	r24, 0x64
    842c:	95 a5       	lds	r25, 0x65
    842e:	a6 a5       	lds	r26, 0x66
    8430:	b7 a5       	lds	r27, 0x67
    8432:	80 93 54 40 	sts	0x4054, r24
    8436:	90 93 55 40 	sts	0x4055, r25
    843a:	a0 93 56 40 	sts	0x4056, r26
    843e:	b0 93 57 40 	sts	0x4057, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    8442:	89 81       	ldd	r24, Y+1	; 0x01
    8444:	9a 81       	ldd	r25, Y+2	; 0x02
    8446:	fc 01       	movw	r30, r24
    8448:	24 8d       	ldd	r18, Z+28	; 0x1c
    844a:	35 8d       	ldd	r19, Z+29	; 0x1d
    844c:	46 8d       	ldd	r20, Z+30	; 0x1e
    844e:	57 8d       	ldd	r21, Z+31	; 0x1f
    8450:	80 91 74 50 	lds	r24, 0x5074
    8454:	90 91 75 50 	lds	r25, 0x5075
    8458:	cc 01       	movw	r24, r24
    845a:	a0 e0       	ldi	r26, 0x00	; 0
    845c:	b0 e0       	ldi	r27, 0x00	; 0
    845e:	79 01       	movw	r14, r18
    8460:	8a 01       	movw	r16, r20
    8462:	e8 0e       	add	r14, r24
    8464:	f9 1e       	adc	r15, r25
    8466:	0a 1f       	adc	r16, r26
    8468:	1b 1f       	adc	r17, r27
    846a:	89 81       	ldd	r24, Y+1	; 0x01
    846c:	9a 81       	ldd	r25, Y+2	; 0x02
    846e:	fc 01       	movw	r30, r24
    8470:	80 89       	ldd	r24, Z+16	; 0x10
    8472:	88 2f       	mov	r24, r24
    8474:	90 e0       	ldi	r25, 0x00	; 0
    8476:	a0 e0       	ldi	r26, 0x00	; 0
    8478:	b0 e0       	ldi	r27, 0x00	; 0
    847a:	29 81       	ldd	r18, Y+1	; 0x01
    847c:	3a 81       	ldd	r19, Y+2	; 0x02
    847e:	f9 01       	movw	r30, r18
    8480:	24 a1       	lds	r18, 0x44
    8482:	35 a1       	lds	r19, 0x45
    8484:	46 a1       	lds	r20, 0x46
    8486:	57 a1       	lds	r21, 0x47
    8488:	bc 01       	movw	r22, r24
    848a:	cd 01       	movw	r24, r26
    848c:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    8490:	dc 01       	movw	r26, r24
    8492:	cb 01       	movw	r24, r22
    8494:	8e 0d       	add	r24, r14
    8496:	9f 1d       	adc	r25, r15
    8498:	a0 1f       	adc	r26, r16
    849a:	b1 1f       	adc	r27, r17
    849c:	80 93 d0 23 	sts	0x23D0, r24
    84a0:	90 93 d1 23 	sts	0x23D1, r25
    84a4:	a0 93 d2 23 	sts	0x23D2, r26
    84a8:	b0 93 d3 23 	sts	0x23D3, r27

dataSectors = bpb->totalSectors_F32
    84ac:	89 81       	ldd	r24, Y+1	; 0x01
    84ae:	9a 81       	ldd	r25, Y+2	; 0x02
    84b0:	fc 01       	movw	r30, r24
    84b2:	20 a1       	lds	r18, 0x40
    84b4:	31 a1       	lds	r19, 0x41
    84b6:	42 a1       	lds	r20, 0x42
    84b8:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    84ba:	89 81       	ldd	r24, Y+1	; 0x01
    84bc:	9a 81       	ldd	r25, Y+2	; 0x02
    84be:	fc 01       	movw	r30, r24
    84c0:	86 85       	ldd	r24, Z+14	; 0x0e
    84c2:	97 85       	ldd	r25, Z+15	; 0x0f
    84c4:	cc 01       	movw	r24, r24
    84c6:	a0 e0       	ldi	r26, 0x00	; 0
    84c8:	b0 e0       	ldi	r27, 0x00	; 0
    84ca:	79 01       	movw	r14, r18
    84cc:	8a 01       	movw	r16, r20
    84ce:	e8 1a       	sub	r14, r24
    84d0:	f9 0a       	sbc	r15, r25
    84d2:	0a 0b       	sbc	r16, r26
    84d4:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    84d6:	89 81       	ldd	r24, Y+1	; 0x01
    84d8:	9a 81       	ldd	r25, Y+2	; 0x02
    84da:	fc 01       	movw	r30, r24
    84dc:	80 89       	ldd	r24, Z+16	; 0x10
    84de:	88 2f       	mov	r24, r24
    84e0:	90 e0       	ldi	r25, 0x00	; 0
    84e2:	a0 e0       	ldi	r26, 0x00	; 0
    84e4:	b0 e0       	ldi	r27, 0x00	; 0
    84e6:	29 81       	ldd	r18, Y+1	; 0x01
    84e8:	3a 81       	ldd	r19, Y+2	; 0x02
    84ea:	f9 01       	movw	r30, r18
    84ec:	24 a1       	lds	r18, 0x44
    84ee:	35 a1       	lds	r19, 0x45
    84f0:	46 a1       	lds	r20, 0x46
    84f2:	57 a1       	lds	r21, 0x47
    84f4:	bc 01       	movw	r22, r24
    84f6:	cd 01       	movw	r24, r26
    84f8:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    84fc:	dc 01       	movw	r26, r24
    84fe:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    8500:	a8 01       	movw	r20, r16
    8502:	97 01       	movw	r18, r14
    8504:	28 1b       	sub	r18, r24
    8506:	39 0b       	sbc	r19, r25
    8508:	4a 0b       	sbc	r20, r26
    850a:	5b 0b       	sbc	r21, r27
    850c:	da 01       	movw	r26, r20
    850e:	c9 01       	movw	r24, r18
    8510:	8f 83       	std	Y+7, r24	; 0x07
    8512:	98 87       	std	Y+8, r25	; 0x08
    8514:	a9 87       	std	Y+9, r26	; 0x09
    8516:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    8518:	80 91 6c 50 	lds	r24, 0x506C
    851c:	90 91 6d 50 	lds	r25, 0x506D
    8520:	9c 01       	movw	r18, r24
    8522:	40 e0       	ldi	r20, 0x00	; 0
    8524:	50 e0       	ldi	r21, 0x00	; 0
    8526:	8f 81       	ldd	r24, Y+7	; 0x07
    8528:	98 85       	ldd	r25, Y+8	; 0x08
    852a:	a9 85       	ldd	r26, Y+9	; 0x09
    852c:	ba 85       	ldd	r27, Y+10	; 0x0a
    852e:	bc 01       	movw	r22, r24
    8530:	cd 01       	movw	r24, r26
    8532:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    8536:	da 01       	movw	r26, r20
    8538:	c9 01       	movw	r24, r18
    853a:	80 93 4e 40 	sts	0x404E, r24
    853e:	90 93 4f 40 	sts	0x404F, r25
    8542:	a0 93 50 40 	sts	0x4050, r26
    8546:	b0 93 51 40 	sts	0x4051, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    854a:	81 e0       	ldi	r24, 0x01	; 1
    854c:	60 e0       	ldi	r22, 0x00	; 0
    854e:	20 e0       	ldi	r18, 0x00	; 0
    8550:	30 e0       	ldi	r19, 0x00	; 0
    8552:	a9 01       	movw	r20, r18
    8554:	0e 94 a8 43 	call	0x8750	; 0x8750 <getSetFreeCluster>
    8558:	9b 01       	movw	r18, r22
    855a:	ac 01       	movw	r20, r24
    855c:	80 91 4e 40 	lds	r24, 0x404E
    8560:	90 91 4f 40 	lds	r25, 0x404F
    8564:	a0 91 50 40 	lds	r26, 0x4050
    8568:	b0 91 51 40 	lds	r27, 0x4051
    856c:	82 17       	cp	r24, r18
    856e:	93 07       	cpc	r25, r19
    8570:	a4 07       	cpc	r26, r20
    8572:	b5 07       	cpc	r27, r21
    8574:	18 f4       	brcc	.+6      	; 0x857c <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    8576:	10 92 d5 50 	sts	0x50D5, r1
    857a:	03 c0       	rjmp	.+6      	; 0x8582 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    857c:	81 e0       	ldi	r24, 0x01	; 1
    857e:	80 93 d5 50 	sts	0x50D5, r24
return 0;
    8582:	80 e0       	ldi	r24, 0x00	; 0
}
    8584:	2a 96       	adiw	r28, 0x0a	; 10
    8586:	cd bf       	out	0x3d, r28	; 61
    8588:	de bf       	out	0x3e, r29	; 62
    858a:	df 91       	pop	r29
    858c:	cf 91       	pop	r28
    858e:	1f 91       	pop	r17
    8590:	0f 91       	pop	r16
    8592:	ff 90       	pop	r15
    8594:	ef 90       	pop	r14
    8596:	08 95       	ret

00008598 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    8598:	cf 93       	push	r28
    859a:	df 93       	push	r29
    859c:	00 d0       	rcall	.+0      	; 0x859e <getFirstSector+0x6>
    859e:	0f 92       	push	r0
    85a0:	cd b7       	in	r28, 0x3d	; 61
    85a2:	de b7       	in	r29, 0x3e	; 62
    85a4:	69 83       	std	Y+1, r22	; 0x01
    85a6:	7a 83       	std	Y+2, r23	; 0x02
    85a8:	8b 83       	std	Y+3, r24	; 0x03
    85aa:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    85ac:	89 81       	ldd	r24, Y+1	; 0x01
    85ae:	9a 81       	ldd	r25, Y+2	; 0x02
    85b0:	ab 81       	ldd	r26, Y+3	; 0x03
    85b2:	bc 81       	ldd	r27, Y+4	; 0x04
    85b4:	02 97       	sbiw	r24, 0x02	; 2
    85b6:	a1 09       	sbc	r26, r1
    85b8:	b1 09       	sbc	r27, r1
    85ba:	20 91 6c 50 	lds	r18, 0x506C
    85be:	30 91 6d 50 	lds	r19, 0x506D
    85c2:	99 01       	movw	r18, r18
    85c4:	40 e0       	ldi	r20, 0x00	; 0
    85c6:	50 e0       	ldi	r21, 0x00	; 0
    85c8:	bc 01       	movw	r22, r24
    85ca:	cd 01       	movw	r24, r26
    85cc:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    85d0:	9b 01       	movw	r18, r22
    85d2:	ac 01       	movw	r20, r24
    85d4:	80 91 d0 23 	lds	r24, 0x23D0
    85d8:	90 91 d1 23 	lds	r25, 0x23D1
    85dc:	a0 91 d2 23 	lds	r26, 0x23D2
    85e0:	b0 91 d3 23 	lds	r27, 0x23D3
    85e4:	82 0f       	add	r24, r18
    85e6:	93 1f       	adc	r25, r19
    85e8:	a4 1f       	adc	r26, r20
    85ea:	b5 1f       	adc	r27, r21
}
    85ec:	bc 01       	movw	r22, r24
    85ee:	cd 01       	movw	r24, r26
    85f0:	24 96       	adiw	r28, 0x04	; 4
    85f2:	cd bf       	out	0x3d, r28	; 61
    85f4:	de bf       	out	0x3e, r29	; 62
    85f6:	df 91       	pop	r29
    85f8:	cf 91       	pop	r28
    85fa:	08 95       	ret

000085fc <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    85fc:	ef 92       	push	r14
    85fe:	ff 92       	push	r15
    8600:	0f 93       	push	r16
    8602:	1f 93       	push	r17
    8604:	cf 93       	push	r28
    8606:	df 93       	push	r29
    8608:	cd b7       	in	r28, 0x3d	; 61
    860a:	de b7       	in	r29, 0x3e	; 62
    860c:	62 97       	sbiw	r28, 0x12	; 18
    860e:	cd bf       	out	0x3d, r28	; 61
    8610:	de bf       	out	0x3e, r29	; 62
    8612:	6a 87       	std	Y+10, r22	; 0x0a
    8614:	7b 87       	std	Y+11, r23	; 0x0b
    8616:	8c 87       	std	Y+12, r24	; 0x0c
    8618:	9d 87       	std	Y+13, r25	; 0x0d
    861a:	4e 87       	std	Y+14, r20	; 0x0e
    861c:	0f 87       	std	Y+15, r16	; 0x0f
    861e:	18 8b       	std	Y+16, r17	; 0x10
    8620:	29 8b       	std	Y+17, r18	; 0x11
    8622:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    8624:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    8626:	80 91 74 50 	lds	r24, 0x5074
    862a:	90 91 75 50 	lds	r25, 0x5075
    862e:	9c 01       	movw	r18, r24
    8630:	40 e0       	ldi	r20, 0x00	; 0
    8632:	50 e0       	ldi	r21, 0x00	; 0
    8634:	80 91 6e 50 	lds	r24, 0x506E
    8638:	90 91 6f 50 	lds	r25, 0x506F
    863c:	a0 91 70 50 	lds	r26, 0x5070
    8640:	b0 91 71 50 	lds	r27, 0x5071
    8644:	79 01       	movw	r14, r18
    8646:	8a 01       	movw	r16, r20
    8648:	e8 0e       	add	r14, r24
    864a:	f9 1e       	adc	r15, r25
    864c:	0a 1f       	adc	r16, r26
    864e:	1b 1f       	adc	r17, r27
    8650:	8a 85       	ldd	r24, Y+10	; 0x0a
    8652:	9b 85       	ldd	r25, Y+11	; 0x0b
    8654:	ac 85       	ldd	r26, Y+12	; 0x0c
    8656:	bd 85       	ldd	r27, Y+13	; 0x0d
    8658:	88 0f       	add	r24, r24
    865a:	99 1f       	adc	r25, r25
    865c:	aa 1f       	adc	r26, r26
    865e:	bb 1f       	adc	r27, r27
    8660:	88 0f       	add	r24, r24
    8662:	99 1f       	adc	r25, r25
    8664:	aa 1f       	adc	r26, r26
    8666:	bb 1f       	adc	r27, r27
    8668:	20 91 49 40 	lds	r18, 0x4049
    866c:	30 91 4a 40 	lds	r19, 0x404A
    8670:	99 01       	movw	r18, r18
    8672:	40 e0       	ldi	r20, 0x00	; 0
    8674:	50 e0       	ldi	r21, 0x00	; 0
    8676:	bc 01       	movw	r22, r24
    8678:	cd 01       	movw	r24, r26
    867a:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    867e:	da 01       	movw	r26, r20
    8680:	c9 01       	movw	r24, r18
    8682:	8e 0d       	add	r24, r14
    8684:	9f 1d       	adc	r25, r15
    8686:	a0 1f       	adc	r26, r16
    8688:	b1 1f       	adc	r27, r17
    868a:	8a 83       	std	Y+2, r24	; 0x02
    868c:	9b 83       	std	Y+3, r25	; 0x03
    868e:	ac 83       	std	Y+4, r26	; 0x04
    8690:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    8692:	8a 85       	ldd	r24, Y+10	; 0x0a
    8694:	9b 85       	ldd	r25, Y+11	; 0x0b
    8696:	ac 85       	ldd	r26, Y+12	; 0x0c
    8698:	bd 85       	ldd	r27, Y+13	; 0x0d
    869a:	88 0f       	add	r24, r24
    869c:	99 1f       	adc	r25, r25
    869e:	aa 1f       	adc	r26, r26
    86a0:	bb 1f       	adc	r27, r27
    86a2:	88 0f       	add	r24, r24
    86a4:	99 1f       	adc	r25, r25
    86a6:	aa 1f       	adc	r26, r26
    86a8:	bb 1f       	adc	r27, r27
    86aa:	20 91 49 40 	lds	r18, 0x4049
    86ae:	30 91 4a 40 	lds	r19, 0x404A
    86b2:	99 01       	movw	r18, r18
    86b4:	40 e0       	ldi	r20, 0x00	; 0
    86b6:	50 e0       	ldi	r21, 0x00	; 0
    86b8:	bc 01       	movw	r22, r24
    86ba:	cd 01       	movw	r24, r26
    86bc:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    86c0:	dc 01       	movw	r26, r24
    86c2:	cb 01       	movw	r24, r22
    86c4:	8e 83       	std	Y+6, r24	; 0x06
    86c6:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    86c8:	8a 81       	ldd	r24, Y+2	; 0x02
    86ca:	9b 81       	ldd	r25, Y+3	; 0x03
    86cc:	ac 81       	ldd	r26, Y+4	; 0x04
    86ce:	bd 81       	ldd	r27, Y+5	; 0x05
    86d0:	2b ec       	ldi	r18, 0xCB	; 203
    86d2:	31 e2       	ldi	r19, 0x21	; 33
    86d4:	bc 01       	movw	r22, r24
    86d6:	cd 01       	movw	r24, r26
    86d8:	a9 01       	movw	r20, r18
    86da:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    86de:	8e 81       	ldd	r24, Y+6	; 0x06
    86e0:	9f 81       	ldd	r25, Y+7	; 0x07
    86e2:	85 53       	subi	r24, 0x35	; 53
    86e4:	9e 4d       	sbci	r25, 0xDE	; 222
    86e6:	88 87       	std	Y+8, r24	; 0x08
    86e8:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    86ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    86ec:	88 23       	and	r24, r24
    86ee:	49 f4       	brne	.+18     	; 0x8702 <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    86f0:	88 85       	ldd	r24, Y+8	; 0x08
    86f2:	99 85       	ldd	r25, Y+9	; 0x09
    86f4:	fc 01       	movw	r30, r24
    86f6:	80 81       	ld	r24, Z
    86f8:	91 81       	ldd	r25, Z+1	; 0x01
    86fa:	a2 81       	ldd	r26, Z+2	; 0x02
    86fc:	b3 81       	ldd	r27, Z+3	; 0x03
    86fe:	bf 70       	andi	r27, 0x0F	; 15
    8700:	1b c0       	rjmp	.+54     	; 0x8738 <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    8702:	28 85       	ldd	r18, Y+8	; 0x08
    8704:	39 85       	ldd	r19, Y+9	; 0x09
    8706:	8f 85       	ldd	r24, Y+15	; 0x0f
    8708:	98 89       	ldd	r25, Y+16	; 0x10
    870a:	a9 89       	ldd	r26, Y+17	; 0x11
    870c:	ba 89       	ldd	r27, Y+18	; 0x12
    870e:	f9 01       	movw	r30, r18
    8710:	80 83       	st	Z, r24
    8712:	91 83       	std	Z+1, r25	; 0x01
    8714:	a2 83       	std	Z+2, r26	; 0x02
    8716:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    8718:	8a 81       	ldd	r24, Y+2	; 0x02
    871a:	9b 81       	ldd	r25, Y+3	; 0x03
    871c:	ac 81       	ldd	r26, Y+4	; 0x04
    871e:	bd 81       	ldd	r27, Y+5	; 0x05
    8720:	2b ec       	ldi	r18, 0xCB	; 203
    8722:	31 e2       	ldi	r19, 0x21	; 33
    8724:	bc 01       	movw	r22, r24
    8726:	cd 01       	movw	r24, r26
    8728:	a9 01       	movw	r20, r18
    872a:	20 e0       	ldi	r18, 0x00	; 0
    872c:	32 e0       	ldi	r19, 0x02	; 2
    872e:	0e 94 c3 4f 	call	0x9f86	; 0x9f86 <SD_write_block>

return (0);
    8732:	80 e0       	ldi	r24, 0x00	; 0
    8734:	90 e0       	ldi	r25, 0x00	; 0
    8736:	dc 01       	movw	r26, r24
}
    8738:	bc 01       	movw	r22, r24
    873a:	cd 01       	movw	r24, r26
    873c:	62 96       	adiw	r28, 0x12	; 18
    873e:	cd bf       	out	0x3d, r28	; 61
    8740:	de bf       	out	0x3e, r29	; 62
    8742:	df 91       	pop	r29
    8744:	cf 91       	pop	r28
    8746:	1f 91       	pop	r17
    8748:	0f 91       	pop	r16
    874a:	ff 90       	pop	r15
    874c:	ef 90       	pop	r14
    874e:	08 95       	ret

00008750 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    8750:	cf 93       	push	r28
    8752:	df 93       	push	r29
    8754:	cd b7       	in	r28, 0x3d	; 61
    8756:	de b7       	in	r29, 0x3e	; 62
    8758:	28 97       	sbiw	r28, 0x08	; 8
    875a:	cd bf       	out	0x3d, r28	; 61
    875c:	de bf       	out	0x3e, r29	; 62
    875e:	8b 83       	std	Y+3, r24	; 0x03
    8760:	6c 83       	std	Y+4, r22	; 0x04
    8762:	2d 83       	std	Y+5, r18	; 0x05
    8764:	3e 83       	std	Y+6, r19	; 0x06
    8766:	4f 83       	std	Y+7, r20	; 0x07
    8768:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    876a:	8b ec       	ldi	r24, 0xCB	; 203
    876c:	91 e2       	ldi	r25, 0x21	; 33
    876e:	89 83       	std	Y+1, r24	; 0x01
    8770:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    8772:	80 91 6e 50 	lds	r24, 0x506E
    8776:	90 91 6f 50 	lds	r25, 0x506F
    877a:	a0 91 70 50 	lds	r26, 0x5070
    877e:	b0 91 71 50 	lds	r27, 0x5071
    8782:	01 96       	adiw	r24, 0x01	; 1
    8784:	a1 1d       	adc	r26, r1
    8786:	b1 1d       	adc	r27, r1
    8788:	2b ec       	ldi	r18, 0xCB	; 203
    878a:	31 e2       	ldi	r19, 0x21	; 33
    878c:	bc 01       	movw	r22, r24
    878e:	cd 01       	movw	r24, r26
    8790:	a9 01       	movw	r20, r18
    8792:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    8796:	89 81       	ldd	r24, Y+1	; 0x01
    8798:	9a 81       	ldd	r25, Y+2	; 0x02
    879a:	fc 01       	movw	r30, r24
    879c:	80 81       	ld	r24, Z
    879e:	91 81       	ldd	r25, Z+1	; 0x01
    87a0:	a2 81       	ldd	r26, Z+2	; 0x02
    87a2:	b3 81       	ldd	r27, Z+3	; 0x03
    87a4:	82 35       	cpi	r24, 0x52	; 82
    87a6:	f2 e5       	ldi	r31, 0x52	; 82
    87a8:	9f 07       	cpc	r25, r31
    87aa:	f1 e6       	ldi	r31, 0x61	; 97
    87ac:	af 07       	cpc	r26, r31
    87ae:	f1 e4       	ldi	r31, 0x41	; 65
    87b0:	bf 07       	cpc	r27, r31
    87b2:	11 f5       	brne	.+68     	; 0x87f8 <getSetFreeCluster+0xa8>
    87b4:	89 81       	ldd	r24, Y+1	; 0x01
    87b6:	9a 81       	ldd	r25, Y+2	; 0x02
    87b8:	8c 51       	subi	r24, 0x1C	; 28
    87ba:	9e 4f       	sbci	r25, 0xFE	; 254
    87bc:	fc 01       	movw	r30, r24
    87be:	80 81       	ld	r24, Z
    87c0:	91 81       	ldd	r25, Z+1	; 0x01
    87c2:	a2 81       	ldd	r26, Z+2	; 0x02
    87c4:	b3 81       	ldd	r27, Z+3	; 0x03
    87c6:	82 37       	cpi	r24, 0x72	; 114
    87c8:	f2 e7       	ldi	r31, 0x72	; 114
    87ca:	9f 07       	cpc	r25, r31
    87cc:	f1 e4       	ldi	r31, 0x41	; 65
    87ce:	af 07       	cpc	r26, r31
    87d0:	f1 e6       	ldi	r31, 0x61	; 97
    87d2:	bf 07       	cpc	r27, r31
    87d4:	89 f4       	brne	.+34     	; 0x87f8 <getSetFreeCluster+0xa8>
    87d6:	89 81       	ldd	r24, Y+1	; 0x01
    87d8:	9a 81       	ldd	r25, Y+2	; 0x02
    87da:	84 50       	subi	r24, 0x04	; 4
    87dc:	9e 4f       	sbci	r25, 0xFE	; 254
    87de:	fc 01       	movw	r30, r24
    87e0:	80 81       	ld	r24, Z
    87e2:	91 81       	ldd	r25, Z+1	; 0x01
    87e4:	a2 81       	ldd	r26, Z+2	; 0x02
    87e6:	b3 81       	ldd	r27, Z+3	; 0x03
    87e8:	80 30       	cpi	r24, 0x00	; 0
    87ea:	f0 e0       	ldi	r31, 0x00	; 0
    87ec:	9f 07       	cpc	r25, r31
    87ee:	f5 e5       	ldi	r31, 0x55	; 85
    87f0:	af 07       	cpc	r26, r31
    87f2:	fa ea       	ldi	r31, 0xAA	; 170
    87f4:	bf 07       	cpc	r27, r31
    87f6:	21 f0       	breq	.+8      	; 0x8800 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    87f8:	8f ef       	ldi	r24, 0xFF	; 255
    87fa:	9f ef       	ldi	r25, 0xFF	; 255
    87fc:	dc 01       	movw	r26, r24
    87fe:	51 c0       	rjmp	.+162    	; 0x88a2 <getSetFreeCluster+0x152>

 if(get_set == GET)
    8800:	8c 81       	ldd	r24, Y+4	; 0x04
    8802:	88 23       	and	r24, r24
    8804:	b9 f4       	brne	.+46     	; 0x8834 <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    8806:	8b 81       	ldd	r24, Y+3	; 0x03
    8808:	81 30       	cpi	r24, 0x01	; 1
    880a:	51 f4       	brne	.+20     	; 0x8820 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    880c:	89 81       	ldd	r24, Y+1	; 0x01
    880e:	9a 81       	ldd	r25, Y+2	; 0x02
    8810:	88 51       	subi	r24, 0x18	; 24
    8812:	9e 4f       	sbci	r25, 0xFE	; 254
    8814:	fc 01       	movw	r30, r24
    8816:	80 81       	ld	r24, Z
    8818:	91 81       	ldd	r25, Z+1	; 0x01
    881a:	a2 81       	ldd	r26, Z+2	; 0x02
    881c:	b3 81       	ldd	r27, Z+3	; 0x03
    881e:	41 c0       	rjmp	.+130    	; 0x88a2 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    8820:	89 81       	ldd	r24, Y+1	; 0x01
    8822:	9a 81       	ldd	r25, Y+2	; 0x02
    8824:	84 51       	subi	r24, 0x14	; 20
    8826:	9e 4f       	sbci	r25, 0xFE	; 254
    8828:	fc 01       	movw	r30, r24
    882a:	80 81       	ld	r24, Z
    882c:	91 81       	ldd	r25, Z+1	; 0x01
    882e:	a2 81       	ldd	r26, Z+2	; 0x02
    8830:	b3 81       	ldd	r27, Z+3	; 0x03
    8832:	37 c0       	rjmp	.+110    	; 0x88a2 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    8834:	8b 81       	ldd	r24, Y+3	; 0x03
    8836:	81 30       	cpi	r24, 0x01	; 1
    8838:	79 f4       	brne	.+30     	; 0x8858 <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    883a:	89 81       	ldd	r24, Y+1	; 0x01
    883c:	9a 81       	ldd	r25, Y+2	; 0x02
    883e:	9c 01       	movw	r18, r24
    8840:	28 51       	subi	r18, 0x18	; 24
    8842:	3e 4f       	sbci	r19, 0xFE	; 254
    8844:	8d 81       	ldd	r24, Y+5	; 0x05
    8846:	9e 81       	ldd	r25, Y+6	; 0x06
    8848:	af 81       	ldd	r26, Y+7	; 0x07
    884a:	b8 85       	ldd	r27, Y+8	; 0x08
    884c:	f9 01       	movw	r30, r18
    884e:	80 83       	st	Z, r24
    8850:	91 83       	std	Z+1, r25	; 0x01
    8852:	a2 83       	std	Z+2, r26	; 0x02
    8854:	b3 83       	std	Z+3, r27	; 0x03
    8856:	0e c0       	rjmp	.+28     	; 0x8874 <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    8858:	89 81       	ldd	r24, Y+1	; 0x01
    885a:	9a 81       	ldd	r25, Y+2	; 0x02
    885c:	9c 01       	movw	r18, r24
    885e:	24 51       	subi	r18, 0x14	; 20
    8860:	3e 4f       	sbci	r19, 0xFE	; 254
    8862:	8d 81       	ldd	r24, Y+5	; 0x05
    8864:	9e 81       	ldd	r25, Y+6	; 0x06
    8866:	af 81       	ldd	r26, Y+7	; 0x07
    8868:	b8 85       	ldd	r27, Y+8	; 0x08
    886a:	f9 01       	movw	r30, r18
    886c:	80 83       	st	Z, r24
    886e:	91 83       	std	Z+1, r25	; 0x01
    8870:	a2 83       	std	Z+2, r26	; 0x02
    8872:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    8874:	80 91 6e 50 	lds	r24, 0x506E
    8878:	90 91 6f 50 	lds	r25, 0x506F
    887c:	a0 91 70 50 	lds	r26, 0x5070
    8880:	b0 91 71 50 	lds	r27, 0x5071
    8884:	01 96       	adiw	r24, 0x01	; 1
    8886:	a1 1d       	adc	r26, r1
    8888:	b1 1d       	adc	r27, r1
    888a:	2b ec       	ldi	r18, 0xCB	; 203
    888c:	31 e2       	ldi	r19, 0x21	; 33
    888e:	bc 01       	movw	r22, r24
    8890:	cd 01       	movw	r24, r26
    8892:	a9 01       	movw	r20, r18
    8894:	20 e0       	ldi	r18, 0x00	; 0
    8896:	32 e0       	ldi	r19, 0x02	; 2
    8898:	0e 94 c3 4f 	call	0x9f86	; 0x9f86 <SD_write_block>
 }
 return 0xffffffff;
    889c:	8f ef       	ldi	r24, 0xFF	; 255
    889e:	9f ef       	ldi	r25, 0xFF	; 255
    88a0:	dc 01       	movw	r26, r24
}
    88a2:	bc 01       	movw	r22, r24
    88a4:	cd 01       	movw	r24, r26
    88a6:	28 96       	adiw	r28, 0x08	; 8
    88a8:	cd bf       	out	0x3d, r28	; 61
    88aa:	de bf       	out	0x3e, r29	; 62
    88ac:	df 91       	pop	r29
    88ae:	cf 91       	pop	r28
    88b0:	08 95       	ret

000088b2 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    88b2:	0f 93       	push	r16
    88b4:	1f 93       	push	r17
    88b6:	cf 93       	push	r28
    88b8:	df 93       	push	r29
    88ba:	cd b7       	in	r28, 0x3d	; 61
    88bc:	de b7       	in	r29, 0x3e	; 62
    88be:	6c 97       	sbiw	r28, 0x1c	; 28
    88c0:	cd bf       	out	0x3d, r28	; 61
    88c2:	de bf       	out	0x3e, r29	; 62
    88c4:	8a 8f       	std	Y+26, r24	; 0x1a
    88c6:	6b 8f       	std	Y+27, r22	; 0x1b
    88c8:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    88ca:	80 91 54 40 	lds	r24, 0x4054
    88ce:	90 91 55 40 	lds	r25, 0x4055
    88d2:	a0 91 56 40 	lds	r26, 0x4056
    88d6:	b0 91 57 40 	lds	r27, 0x4057
    88da:	89 83       	std	Y+1, r24	; 0x01
    88dc:	9a 83       	std	Y+2, r25	; 0x02
    88de:	ab 83       	std	Y+3, r26	; 0x03
    88e0:	bc 83       	std	Y+4, r27	; 0x04
    88e2:	01 c0       	rjmp	.+2      	; 0x88e6 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    88e4:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    88e6:	89 81       	ldd	r24, Y+1	; 0x01
    88e8:	9a 81       	ldd	r25, Y+2	; 0x02
    88ea:	ab 81       	ldd	r26, Y+3	; 0x03
    88ec:	bc 81       	ldd	r27, Y+4	; 0x04
    88ee:	bc 01       	movw	r22, r24
    88f0:	cd 01       	movw	r24, r26
    88f2:	0e 94 cc 42 	call	0x8598	; 0x8598 <getFirstSector>
    88f6:	dc 01       	movw	r26, r24
    88f8:	cb 01       	movw	r24, r22
    88fa:	88 8b       	std	Y+16, r24	; 0x10
    88fc:	99 8b       	std	Y+17, r25	; 0x11
    88fe:	aa 8b       	std	Y+18, r26	; 0x12
    8900:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    8902:	1d 82       	std	Y+5, r1	; 0x05
    8904:	1e 82       	std	Y+6, r1	; 0x06
    8906:	1f 82       	std	Y+7, r1	; 0x07
    8908:	18 86       	std	Y+8, r1	; 0x08
    890a:	68 c1       	rjmp	.+720    	; 0x8bdc <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    890c:	28 89       	ldd	r18, Y+16	; 0x10
    890e:	39 89       	ldd	r19, Y+17	; 0x11
    8910:	4a 89       	ldd	r20, Y+18	; 0x12
    8912:	5b 89       	ldd	r21, Y+19	; 0x13
    8914:	8d 81       	ldd	r24, Y+5	; 0x05
    8916:	9e 81       	ldd	r25, Y+6	; 0x06
    8918:	af 81       	ldd	r26, Y+7	; 0x07
    891a:	b8 85       	ldd	r27, Y+8	; 0x08
    891c:	82 0f       	add	r24, r18
    891e:	93 1f       	adc	r25, r19
    8920:	a4 1f       	adc	r26, r20
    8922:	b5 1f       	adc	r27, r21
    8924:	2b ec       	ldi	r18, 0xCB	; 203
    8926:	31 e2       	ldi	r19, 0x21	; 33
    8928:	bc 01       	movw	r22, r24
    892a:	cd 01       	movw	r24, r26
    892c:	a9 01       	movw	r20, r18
    892e:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    8932:	1d 86       	std	Y+13, r1	; 0x0d
    8934:	1e 86       	std	Y+14, r1	; 0x0e
    8936:	3d c1       	rjmp	.+634    	; 0x8bb2 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    8938:	8d 85       	ldd	r24, Y+13	; 0x0d
    893a:	9e 85       	ldd	r25, Y+14	; 0x0e
    893c:	85 53       	subi	r24, 0x35	; 53
    893e:	9e 4d       	sbci	r25, 0xDE	; 222
    8940:	8c 8b       	std	Y+20, r24	; 0x14
    8942:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    8944:	8c 89       	ldd	r24, Y+20	; 0x14
    8946:	9d 89       	ldd	r25, Y+21	; 0x15
    8948:	fc 01       	movw	r30, r24
    894a:	80 81       	ld	r24, Z
    894c:	88 23       	and	r24, r24
    894e:	19 f4       	brne	.+6      	; 0x8956 <findFiles+0xa4>
		{
		  return 0;   
    8950:	80 e0       	ldi	r24, 0x00	; 0
    8952:	90 e0       	ldi	r25, 0x00	; 0
    8954:	80 c1       	rjmp	.+768    	; 0x8c56 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    8956:	8c 89       	ldd	r24, Y+20	; 0x14
    8958:	9d 89       	ldd	r25, Y+21	; 0x15
    895a:	fc 01       	movw	r30, r24
    895c:	80 81       	ld	r24, Z
    895e:	85 3e       	cpi	r24, 0xE5	; 229
    8960:	09 f4       	brne	.+2      	; 0x8964 <findFiles+0xb2>
    8962:	22 c1       	rjmp	.+580    	; 0x8ba8 <findFiles+0x2f6>
    8964:	8c 89       	ldd	r24, Y+20	; 0x14
    8966:	9d 89       	ldd	r25, Y+21	; 0x15
    8968:	fc 01       	movw	r30, r24
    896a:	83 85       	ldd	r24, Z+11	; 0x0b
    896c:	8f 30       	cpi	r24, 0x0F	; 15
    896e:	09 f4       	brne	.+2      	; 0x8972 <findFiles+0xc0>
    8970:	1b c1       	rjmp	.+566    	; 0x8ba8 <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    8972:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8974:	81 30       	cpi	r24, 0x01	; 1
    8976:	21 f0       	breq	.+8      	; 0x8980 <findFiles+0xce>
    8978:	8a 8d       	ldd	r24, Y+26	; 0x1a
    897a:	82 30       	cpi	r24, 0x02	; 2
    897c:	09 f0       	breq	.+2      	; 0x8980 <findFiles+0xce>
    897e:	11 c1       	rjmp	.+546    	; 0x8ba2 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8980:	1f 86       	std	Y+15, r1	; 0x0f
    8982:	17 c0       	rjmp	.+46     	; 0x89b2 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    8984:	8f 85       	ldd	r24, Y+15	; 0x0f
    8986:	88 2f       	mov	r24, r24
    8988:	90 e0       	ldi	r25, 0x00	; 0
    898a:	2c 89       	ldd	r18, Y+20	; 0x14
    898c:	3d 89       	ldd	r19, Y+21	; 0x15
    898e:	82 0f       	add	r24, r18
    8990:	93 1f       	adc	r25, r19
    8992:	fc 01       	movw	r30, r24
    8994:	40 81       	ld	r20, Z
    8996:	8f 85       	ldd	r24, Y+15	; 0x0f
    8998:	88 2f       	mov	r24, r24
    899a:	90 e0       	ldi	r25, 0x00	; 0
    899c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    899e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    89a0:	82 0f       	add	r24, r18
    89a2:	93 1f       	adc	r25, r19
    89a4:	fc 01       	movw	r30, r24
    89a6:	80 81       	ld	r24, Z
    89a8:	48 17       	cp	r20, r24
    89aa:	39 f4       	brne	.+14     	; 0x89ba <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    89ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    89ae:	8f 5f       	subi	r24, 0xFF	; 255
    89b0:	8f 87       	std	Y+15, r24	; 0x0f
    89b2:	8f 85       	ldd	r24, Y+15	; 0x0f
    89b4:	8b 30       	cpi	r24, 0x0B	; 11
    89b6:	30 f3       	brcs	.-52     	; 0x8984 <findFiles+0xd2>
    89b8:	01 c0       	rjmp	.+2      	; 0x89bc <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    89ba:	00 00       	nop
            if(j == 11)
    89bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    89be:	8b 30       	cpi	r24, 0x0B	; 11
    89c0:	09 f0       	breq	.+2      	; 0x89c4 <findFiles+0x112>
    89c2:	f2 c0       	rjmp	.+484    	; 0x8ba8 <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    89c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    89c6:	81 30       	cpi	r24, 0x01	; 1
    89c8:	09 f0       	breq	.+2      	; 0x89cc <findFiles+0x11a>
    89ca:	52 c0       	rjmp	.+164    	; 0x8a70 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    89cc:	28 89       	ldd	r18, Y+16	; 0x10
    89ce:	39 89       	ldd	r19, Y+17	; 0x11
    89d0:	4a 89       	ldd	r20, Y+18	; 0x12
    89d2:	5b 89       	ldd	r21, Y+19	; 0x13
    89d4:	8d 81       	ldd	r24, Y+5	; 0x05
    89d6:	9e 81       	ldd	r25, Y+6	; 0x06
    89d8:	af 81       	ldd	r26, Y+7	; 0x07
    89da:	b8 85       	ldd	r27, Y+8	; 0x08
    89dc:	82 0f       	add	r24, r18
    89de:	93 1f       	adc	r25, r19
    89e0:	a4 1f       	adc	r26, r20
    89e2:	b5 1f       	adc	r27, r21
    89e4:	80 93 d6 50 	sts	0x50D6, r24
    89e8:	90 93 d7 50 	sts	0x50D7, r25
    89ec:	a0 93 d8 50 	sts	0x50D8, r26
    89f0:	b0 93 d9 50 	sts	0x50D9, r27
				appendFileLocation = i;
    89f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    89f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    89f8:	cc 01       	movw	r24, r24
    89fa:	a0 e0       	ldi	r26, 0x00	; 0
    89fc:	b0 e0       	ldi	r27, 0x00	; 0
    89fe:	80 93 cc 23 	sts	0x23CC, r24
    8a02:	90 93 cd 23 	sts	0x23CD, r25
    8a06:	a0 93 ce 23 	sts	0x23CE, r26
    8a0a:	b0 93 cf 23 	sts	0x23CF, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a0e:	8c 89       	ldd	r24, Y+20	; 0x14
    8a10:	9d 89       	ldd	r25, Y+21	; 0x15
    8a12:	fc 01       	movw	r30, r24
    8a14:	84 89       	ldd	r24, Z+20	; 0x14
    8a16:	95 89       	ldd	r25, Z+21	; 0x15
    8a18:	cc 01       	movw	r24, r24
    8a1a:	a0 e0       	ldi	r26, 0x00	; 0
    8a1c:	b0 e0       	ldi	r27, 0x00	; 0
    8a1e:	ac 01       	movw	r20, r24
    8a20:	33 27       	eor	r19, r19
    8a22:	22 27       	eor	r18, r18
    8a24:	8c 89       	ldd	r24, Y+20	; 0x14
    8a26:	9d 89       	ldd	r25, Y+21	; 0x15
    8a28:	fc 01       	movw	r30, r24
    8a2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a2c:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a2e:	cc 01       	movw	r24, r24
    8a30:	a0 e0       	ldi	r26, 0x00	; 0
    8a32:	b0 e0       	ldi	r27, 0x00	; 0
    8a34:	82 2b       	or	r24, r18
    8a36:	93 2b       	or	r25, r19
    8a38:	a4 2b       	or	r26, r20
    8a3a:	b5 2b       	or	r27, r21
    8a3c:	80 93 78 50 	sts	0x5078, r24
    8a40:	90 93 79 50 	sts	0x5079, r25
    8a44:	a0 93 7a 50 	sts	0x507A, r26
    8a48:	b0 93 7b 50 	sts	0x507B, r27
				fileSize = dir->fileSize;
    8a4c:	8c 89       	ldd	r24, Y+20	; 0x14
    8a4e:	9d 89       	ldd	r25, Y+21	; 0x15
    8a50:	fc 01       	movw	r30, r24
    8a52:	84 8d       	ldd	r24, Z+28	; 0x1c
    8a54:	95 8d       	ldd	r25, Z+29	; 0x1d
    8a56:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8a58:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8a5a:	80 93 45 40 	sts	0x4045, r24
    8a5e:	90 93 46 40 	sts	0x4046, r25
    8a62:	a0 93 47 40 	sts	0x4047, r26
    8a66:	b0 93 48 40 	sts	0x4048, r27
			    return (dir);
    8a6a:	8c 89       	ldd	r24, Y+20	; 0x14
    8a6c:	9d 89       	ldd	r25, Y+21	; 0x15
    8a6e:	f3 c0       	rjmp	.+486    	; 0x8c56 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a70:	8c 89       	ldd	r24, Y+20	; 0x14
    8a72:	9d 89       	ldd	r25, Y+21	; 0x15
    8a74:	fc 01       	movw	r30, r24
    8a76:	84 89       	ldd	r24, Z+20	; 0x14
    8a78:	95 89       	ldd	r25, Z+21	; 0x15
    8a7a:	cc 01       	movw	r24, r24
    8a7c:	a0 e0       	ldi	r26, 0x00	; 0
    8a7e:	b0 e0       	ldi	r27, 0x00	; 0
    8a80:	ac 01       	movw	r20, r24
    8a82:	33 27       	eor	r19, r19
    8a84:	22 27       	eor	r18, r18
    8a86:	8c 89       	ldd	r24, Y+20	; 0x14
    8a88:	9d 89       	ldd	r25, Y+21	; 0x15
    8a8a:	fc 01       	movw	r30, r24
    8a8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a8e:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a90:	cc 01       	movw	r24, r24
    8a92:	a0 e0       	ldi	r26, 0x00	; 0
    8a94:	b0 e0       	ldi	r27, 0x00	; 0
    8a96:	82 2b       	or	r24, r18
    8a98:	93 2b       	or	r25, r19
    8a9a:	a4 2b       	or	r26, r20
    8a9c:	b5 2b       	or	r27, r21
    8a9e:	89 87       	std	Y+9, r24	; 0x09
    8aa0:	9a 87       	std	Y+10, r25	; 0x0a
    8aa2:	ab 87       	std	Y+11, r26	; 0x0b
    8aa4:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8aa6:	8c 89       	ldd	r24, Y+20	; 0x14
    8aa8:	9d 89       	ldd	r25, Y+21	; 0x15
    8aaa:	25 ee       	ldi	r18, 0xE5	; 229
    8aac:	fc 01       	movw	r30, r24
    8aae:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8ab0:	28 89       	ldd	r18, Y+16	; 0x10
    8ab2:	39 89       	ldd	r19, Y+17	; 0x11
    8ab4:	4a 89       	ldd	r20, Y+18	; 0x12
    8ab6:	5b 89       	ldd	r21, Y+19	; 0x13
    8ab8:	8d 81       	ldd	r24, Y+5	; 0x05
    8aba:	9e 81       	ldd	r25, Y+6	; 0x06
    8abc:	af 81       	ldd	r26, Y+7	; 0x07
    8abe:	b8 85       	ldd	r27, Y+8	; 0x08
    8ac0:	82 0f       	add	r24, r18
    8ac2:	93 1f       	adc	r25, r19
    8ac4:	a4 1f       	adc	r26, r20
    8ac6:	b5 1f       	adc	r27, r21
    8ac8:	2b ec       	ldi	r18, 0xCB	; 203
    8aca:	31 e2       	ldi	r19, 0x21	; 33
    8acc:	bc 01       	movw	r22, r24
    8ace:	cd 01       	movw	r24, r26
    8ad0:	a9 01       	movw	r20, r18
    8ad2:	20 e0       	ldi	r18, 0x00	; 0
    8ad4:	32 e0       	ldi	r19, 0x02	; 2
    8ad6:	0e 94 c3 4f 	call	0x9f86	; 0x9f86 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8ada:	8c 89       	ldd	r24, Y+20	; 0x14
    8adc:	9d 89       	ldd	r25, Y+21	; 0x15
    8ade:	fc 01       	movw	r30, r24
    8ae0:	24 8d       	ldd	r18, Z+28	; 0x1c
    8ae2:	35 8d       	ldd	r19, Z+29	; 0x1d
    8ae4:	46 8d       	ldd	r20, Z+30	; 0x1e
    8ae6:	57 8d       	ldd	r21, Z+31	; 0x1f
    8ae8:	80 e0       	ldi	r24, 0x00	; 0
    8aea:	ba 01       	movw	r22, r20
    8aec:	a9 01       	movw	r20, r18
    8aee:	0e 94 60 4c 	call	0x98c0	; 0x98c0 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8af2:	82 e0       	ldi	r24, 0x02	; 2
    8af4:	60 e0       	ldi	r22, 0x00	; 0
    8af6:	20 e0       	ldi	r18, 0x00	; 0
    8af8:	30 e0       	ldi	r19, 0x00	; 0
    8afa:	a9 01       	movw	r20, r18
    8afc:	0e 94 a8 43 	call	0x8750	; 0x8750 <getSetFreeCluster>
    8b00:	dc 01       	movw	r26, r24
    8b02:	cb 01       	movw	r24, r22
    8b04:	89 83       	std	Y+1, r24	; 0x01
    8b06:	9a 83       	std	Y+2, r25	; 0x02
    8b08:	ab 83       	std	Y+3, r26	; 0x03
    8b0a:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8b0c:	29 85       	ldd	r18, Y+9	; 0x09
    8b0e:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b10:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b12:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b14:	89 81       	ldd	r24, Y+1	; 0x01
    8b16:	9a 81       	ldd	r25, Y+2	; 0x02
    8b18:	ab 81       	ldd	r26, Y+3	; 0x03
    8b1a:	bc 81       	ldd	r27, Y+4	; 0x04
    8b1c:	28 17       	cp	r18, r24
    8b1e:	39 07       	cpc	r19, r25
    8b20:	4a 07       	cpc	r20, r26
    8b22:	5b 07       	cpc	r21, r27
    8b24:	40 f4       	brcc	.+16     	; 0x8b36 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    8b26:	29 85       	ldd	r18, Y+9	; 0x09
    8b28:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b2a:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b2c:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b2e:	82 e0       	ldi	r24, 0x02	; 2
    8b30:	61 e0       	ldi	r22, 0x01	; 1
    8b32:	0e 94 a8 43 	call	0x8750	; 0x8750 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    8b36:	89 85       	ldd	r24, Y+9	; 0x09
    8b38:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b3a:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b3c:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b3e:	bc 01       	movw	r22, r24
    8b40:	cd 01       	movw	r24, r26
    8b42:	40 e0       	ldi	r20, 0x00	; 0
    8b44:	00 e0       	ldi	r16, 0x00	; 0
    8b46:	10 e0       	ldi	r17, 0x00	; 0
    8b48:	98 01       	movw	r18, r16
    8b4a:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
    8b4e:	dc 01       	movw	r26, r24
    8b50:	cb 01       	movw	r24, r22
    8b52:	8e 8b       	std	Y+22, r24	; 0x16
    8b54:	9f 8b       	std	Y+23, r25	; 0x17
    8b56:	a8 8f       	std	Y+24, r26	; 0x18
    8b58:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8b5a:	89 85       	ldd	r24, Y+9	; 0x09
    8b5c:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b5e:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b60:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b62:	bc 01       	movw	r22, r24
    8b64:	cd 01       	movw	r24, r26
    8b66:	41 e0       	ldi	r20, 0x01	; 1
    8b68:	00 e0       	ldi	r16, 0x00	; 0
    8b6a:	10 e0       	ldi	r17, 0x00	; 0
    8b6c:	98 01       	movw	r18, r16
    8b6e:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8b72:	8e 89       	ldd	r24, Y+22	; 0x16
    8b74:	9f 89       	ldd	r25, Y+23	; 0x17
    8b76:	a8 8d       	ldd	r26, Y+24	; 0x18
    8b78:	b9 8d       	ldd	r27, Y+25	; 0x19
    8b7a:	87 3f       	cpi	r24, 0xF7	; 247
    8b7c:	ff ef       	ldi	r31, 0xFF	; 255
    8b7e:	9f 07       	cpc	r25, r31
    8b80:	ff ef       	ldi	r31, 0xFF	; 255
    8b82:	af 07       	cpc	r26, r31
    8b84:	ff e0       	ldi	r31, 0x0F	; 15
    8b86:	bf 07       	cpc	r27, r31
    8b88:	18 f0       	brcs	.+6      	; 0x8b90 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    8b8a:	80 e0       	ldi	r24, 0x00	; 0
    8b8c:	90 e0       	ldi	r25, 0x00	; 0
    8b8e:	63 c0       	rjmp	.+198    	; 0x8c56 <findFiles+0x3a4>
					firstCluster = nextCluster;
    8b90:	8e 89       	ldd	r24, Y+22	; 0x16
    8b92:	9f 89       	ldd	r25, Y+23	; 0x17
    8b94:	a8 8d       	ldd	r26, Y+24	; 0x18
    8b96:	b9 8d       	ldd	r27, Y+25	; 0x19
    8b98:	89 87       	std	Y+9, r24	; 0x09
    8b9a:	9a 87       	std	Y+10, r25	; 0x0a
    8b9c:	ab 87       	std	Y+11, r26	; 0x0b
    8b9e:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8ba0:	ca cf       	rjmp	.-108    	; 0x8b36 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8ba2:	80 e0       	ldi	r24, 0x00	; 0
    8ba4:	90 e0       	ldi	r25, 0x00	; 0
    8ba6:	57 c0       	rjmp	.+174    	; 0x8c56 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8ba8:	8d 85       	ldd	r24, Y+13	; 0x0d
    8baa:	9e 85       	ldd	r25, Y+14	; 0x0e
    8bac:	80 96       	adiw	r24, 0x20	; 32
    8bae:	8d 87       	std	Y+13, r24	; 0x0d
    8bb0:	9e 87       	std	Y+14, r25	; 0x0e
    8bb2:	80 91 49 40 	lds	r24, 0x4049
    8bb6:	90 91 4a 40 	lds	r25, 0x404A
    8bba:	2d 85       	ldd	r18, Y+13	; 0x0d
    8bbc:	3e 85       	ldd	r19, Y+14	; 0x0e
    8bbe:	28 17       	cp	r18, r24
    8bc0:	39 07       	cpc	r19, r25
    8bc2:	08 f4       	brcc	.+2      	; 0x8bc6 <findFiles+0x314>
    8bc4:	b9 ce       	rjmp	.-654    	; 0x8938 <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    8bc8:	9e 81       	ldd	r25, Y+6	; 0x06
    8bca:	af 81       	ldd	r26, Y+7	; 0x07
    8bcc:	b8 85       	ldd	r27, Y+8	; 0x08
    8bce:	01 96       	adiw	r24, 0x01	; 1
    8bd0:	a1 1d       	adc	r26, r1
    8bd2:	b1 1d       	adc	r27, r1
    8bd4:	8d 83       	std	Y+5, r24	; 0x05
    8bd6:	9e 83       	std	Y+6, r25	; 0x06
    8bd8:	af 83       	std	Y+7, r26	; 0x07
    8bda:	b8 87       	std	Y+8, r27	; 0x08
    8bdc:	80 91 6c 50 	lds	r24, 0x506C
    8be0:	90 91 6d 50 	lds	r25, 0x506D
    8be4:	9c 01       	movw	r18, r24
    8be6:	40 e0       	ldi	r20, 0x00	; 0
    8be8:	50 e0       	ldi	r21, 0x00	; 0
    8bea:	8d 81       	ldd	r24, Y+5	; 0x05
    8bec:	9e 81       	ldd	r25, Y+6	; 0x06
    8bee:	af 81       	ldd	r26, Y+7	; 0x07
    8bf0:	b8 85       	ldd	r27, Y+8	; 0x08
    8bf2:	82 17       	cp	r24, r18
    8bf4:	93 07       	cpc	r25, r19
    8bf6:	a4 07       	cpc	r26, r20
    8bf8:	b5 07       	cpc	r27, r21
    8bfa:	08 f4       	brcc	.+2      	; 0x8bfe <findFiles+0x34c>
    8bfc:	87 ce       	rjmp	.-754    	; 0x890c <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8bfe:	89 81       	ldd	r24, Y+1	; 0x01
    8c00:	9a 81       	ldd	r25, Y+2	; 0x02
    8c02:	ab 81       	ldd	r26, Y+3	; 0x03
    8c04:	bc 81       	ldd	r27, Y+4	; 0x04
    8c06:	bc 01       	movw	r22, r24
    8c08:	cd 01       	movw	r24, r26
    8c0a:	40 e0       	ldi	r20, 0x00	; 0
    8c0c:	00 e0       	ldi	r16, 0x00	; 0
    8c0e:	10 e0       	ldi	r17, 0x00	; 0
    8c10:	98 01       	movw	r18, r16
    8c12:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
    8c16:	dc 01       	movw	r26, r24
    8c18:	cb 01       	movw	r24, r22
    8c1a:	89 83       	std	Y+1, r24	; 0x01
    8c1c:	9a 83       	std	Y+2, r25	; 0x02
    8c1e:	ab 83       	std	Y+3, r26	; 0x03
    8c20:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8c22:	89 81       	ldd	r24, Y+1	; 0x01
    8c24:	9a 81       	ldd	r25, Y+2	; 0x02
    8c26:	ab 81       	ldd	r26, Y+3	; 0x03
    8c28:	bc 81       	ldd	r27, Y+4	; 0x04
    8c2a:	87 3f       	cpi	r24, 0xF7	; 247
    8c2c:	2f ef       	ldi	r18, 0xFF	; 255
    8c2e:	92 07       	cpc	r25, r18
    8c30:	2f ef       	ldi	r18, 0xFF	; 255
    8c32:	a2 07       	cpc	r26, r18
    8c34:	2f e0       	ldi	r18, 0x0F	; 15
    8c36:	b2 07       	cpc	r27, r18
    8c38:	18 f0       	brcs	.+6      	; 0x8c40 <findFiles+0x38e>
   	 return 0;
    8c3a:	80 e0       	ldi	r24, 0x00	; 0
    8c3c:	90 e0       	ldi	r25, 0x00	; 0
    8c3e:	0b c0       	rjmp	.+22     	; 0x8c56 <findFiles+0x3a4>
   if(cluster == 0) 
    8c40:	89 81       	ldd	r24, Y+1	; 0x01
    8c42:	9a 81       	ldd	r25, Y+2	; 0x02
    8c44:	ab 81       	ldd	r26, Y+3	; 0x03
    8c46:	bc 81       	ldd	r27, Y+4	; 0x04
    8c48:	00 97       	sbiw	r24, 0x00	; 0
    8c4a:	a1 05       	cpc	r26, r1
    8c4c:	b1 05       	cpc	r27, r1
    8c4e:	09 f0       	breq	.+2      	; 0x8c52 <findFiles+0x3a0>
    8c50:	49 ce       	rjmp	.-878    	; 0x88e4 <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8c52:	80 e0       	ldi	r24, 0x00	; 0
    8c54:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    8c56:	6c 96       	adiw	r28, 0x1c	; 28
    8c58:	cd bf       	out	0x3d, r28	; 61
    8c5a:	de bf       	out	0x3e, r29	; 62
    8c5c:	df 91       	pop	r29
    8c5e:	cf 91       	pop	r28
    8c60:	1f 91       	pop	r17
    8c62:	0f 91       	pop	r16
    8c64:	08 95       	ret

00008c66 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    8c66:	0f 93       	push	r16
    8c68:	1f 93       	push	r17
    8c6a:	cf 93       	push	r28
    8c6c:	df 93       	push	r29
    8c6e:	cd b7       	in	r28, 0x3d	; 61
    8c70:	de b7       	in	r29, 0x3e	; 62
    8c72:	67 97       	sbiw	r28, 0x17	; 23
    8c74:	cd bf       	out	0x3d, r28	; 61
    8c76:	de bf       	out	0x3e, r29	; 62
    8c78:	8d 8b       	std	Y+21, r24	; 0x15
    8c7a:	6e 8b       	std	Y+22, r22	; 0x16
    8c7c:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8c7e:	1e 82       	std	Y+6, r1	; 0x06
    8c80:	1f 82       	std	Y+7, r1	; 0x07
    8c82:	18 86       	std	Y+8, r1	; 0x08
    8c84:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8c86:	8e 89       	ldd	r24, Y+22	; 0x16
    8c88:	9f 89       	ldd	r25, Y+23	; 0x17
    8c8a:	0e 94 e2 46 	call	0x8dc4	; 0x8dc4 <convertFileName>
    8c8e:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8c90:	8a 85       	ldd	r24, Y+10	; 0x0a
    8c92:	88 23       	and	r24, r24
    8c94:	11 f0       	breq	.+4      	; 0x8c9a <readFile+0x34>
    8c96:	82 e0       	ldi	r24, 0x02	; 2
    8c98:	8d c0       	rjmp	.+282    	; 0x8db4 <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    8c9a:	22 eb       	ldi	r18, 0xB2	; 178
    8c9c:	30 e5       	ldi	r19, 0x50	; 80
    8c9e:	81 e0       	ldi	r24, 0x01	; 1
    8ca0:	b9 01       	movw	r22, r18
    8ca2:	0e 94 59 44 	call	0x88b2	; 0x88b2 <findFiles>
    8ca6:	8b 87       	std	Y+11, r24	; 0x0b
    8ca8:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    8caa:	8b 85       	ldd	r24, Y+11	; 0x0b
    8cac:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cae:	00 97       	sbiw	r24, 0x00	; 0
    8cb0:	39 f4       	brne	.+14     	; 0x8cc0 <readFile+0x5a>
{
  if(flag == READ) return (1);
    8cb2:	8d 89       	ldd	r24, Y+21	; 0x15
    8cb4:	88 23       	and	r24, r24
    8cb6:	11 f4       	brne	.+4      	; 0x8cbc <readFile+0x56>
    8cb8:	81 e0       	ldi	r24, 0x01	; 1
    8cba:	7c c0       	rjmp	.+248    	; 0x8db4 <readFile+0x14e>
  else return (0);
    8cbc:	80 e0       	ldi	r24, 0x00	; 0
    8cbe:	7a c0       	rjmp	.+244    	; 0x8db4 <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8cc0:	8d 89       	ldd	r24, Y+21	; 0x15
    8cc2:	81 30       	cpi	r24, 0x01	; 1
    8cc4:	11 f4       	brne	.+4      	; 0x8cca <readFile+0x64>
    8cc6:	81 e0       	ldi	r24, 0x01	; 1
    8cc8:	75 c0       	rjmp	.+234    	; 0x8db4 <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8cca:	8b 85       	ldd	r24, Y+11	; 0x0b
    8ccc:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cce:	fc 01       	movw	r30, r24
    8cd0:	84 89       	ldd	r24, Z+20	; 0x14
    8cd2:	95 89       	ldd	r25, Z+21	; 0x15
    8cd4:	cc 01       	movw	r24, r24
    8cd6:	a0 e0       	ldi	r26, 0x00	; 0
    8cd8:	b0 e0       	ldi	r27, 0x00	; 0
    8cda:	ac 01       	movw	r20, r24
    8cdc:	33 27       	eor	r19, r19
    8cde:	22 27       	eor	r18, r18
    8ce0:	8b 85       	ldd	r24, Y+11	; 0x0b
    8ce2:	9c 85       	ldd	r25, Y+12	; 0x0c
    8ce4:	fc 01       	movw	r30, r24
    8ce6:	82 8d       	ldd	r24, Z+26	; 0x1a
    8ce8:	93 8d       	ldd	r25, Z+27	; 0x1b
    8cea:	cc 01       	movw	r24, r24
    8cec:	a0 e0       	ldi	r26, 0x00	; 0
    8cee:	b0 e0       	ldi	r27, 0x00	; 0
    8cf0:	82 2b       	or	r24, r18
    8cf2:	93 2b       	or	r25, r19
    8cf4:	a4 2b       	or	r26, r20
    8cf6:	b5 2b       	or	r27, r21
    8cf8:	89 83       	std	Y+1, r24	; 0x01
    8cfa:	9a 83       	std	Y+2, r25	; 0x02
    8cfc:	ab 83       	std	Y+3, r26	; 0x03
    8cfe:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    8d00:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d02:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d04:	fc 01       	movw	r30, r24
    8d06:	84 8d       	ldd	r24, Z+28	; 0x1c
    8d08:	95 8d       	ldd	r25, Z+29	; 0x1d
    8d0a:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8d0c:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8d0e:	8d 87       	std	Y+13, r24	; 0x0d
    8d10:	9e 87       	std	Y+14, r25	; 0x0e
    8d12:	af 87       	std	Y+15, r26	; 0x0f
    8d14:	b8 8b       	std	Y+16, r27	; 0x10
    8d16:	01 c0       	rjmp	.+2      	; 0x8d1a <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8d18:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8d1a:	89 81       	ldd	r24, Y+1	; 0x01
    8d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    8d1e:	ab 81       	ldd	r26, Y+3	; 0x03
    8d20:	bc 81       	ldd	r27, Y+4	; 0x04
    8d22:	bc 01       	movw	r22, r24
    8d24:	cd 01       	movw	r24, r26
    8d26:	0e 94 cc 42 	call	0x8598	; 0x8598 <getFirstSector>
    8d2a:	dc 01       	movw	r26, r24
    8d2c:	cb 01       	movw	r24, r22
    8d2e:	89 8b       	std	Y+17, r24	; 0x11
    8d30:	9a 8b       	std	Y+18, r25	; 0x12
    8d32:	ab 8b       	std	Y+19, r26	; 0x13
    8d34:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    8d36:	1d 82       	std	Y+5, r1	; 0x05
    8d38:	17 c0       	rjmp	.+46     	; 0x8d68 <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    8d3c:	28 2f       	mov	r18, r24
    8d3e:	30 e0       	ldi	r19, 0x00	; 0
    8d40:	40 e0       	ldi	r20, 0x00	; 0
    8d42:	50 e0       	ldi	r21, 0x00	; 0
    8d44:	89 89       	ldd	r24, Y+17	; 0x11
    8d46:	9a 89       	ldd	r25, Y+18	; 0x12
    8d48:	ab 89       	ldd	r26, Y+19	; 0x13
    8d4a:	bc 89       	ldd	r27, Y+20	; 0x14
    8d4c:	82 0f       	add	r24, r18
    8d4e:	93 1f       	adc	r25, r19
    8d50:	a4 1f       	adc	r26, r20
    8d52:	b5 1f       	adc	r27, r21
    8d54:	24 ed       	ldi	r18, 0xD4	; 212
    8d56:	33 e2       	ldi	r19, 0x23	; 35
    8d58:	bc 01       	movw	r22, r24
    8d5a:	cd 01       	movw	r24, r26
    8d5c:	a9 01       	movw	r20, r18
    8d5e:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8d62:	8d 81       	ldd	r24, Y+5	; 0x05
    8d64:	8f 5f       	subi	r24, 0xFF	; 255
    8d66:	8d 83       	std	Y+5, r24	; 0x05
    8d68:	8d 81       	ldd	r24, Y+5	; 0x05
    8d6a:	28 2f       	mov	r18, r24
    8d6c:	30 e0       	ldi	r19, 0x00	; 0
    8d6e:	80 91 6c 50 	lds	r24, 0x506C
    8d72:	90 91 6d 50 	lds	r25, 0x506D
    8d76:	28 17       	cp	r18, r24
    8d78:	39 07       	cpc	r19, r25
    8d7a:	f8 f2       	brcs	.-66     	; 0x8d3a <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8d7c:	89 81       	ldd	r24, Y+1	; 0x01
    8d7e:	9a 81       	ldd	r25, Y+2	; 0x02
    8d80:	ab 81       	ldd	r26, Y+3	; 0x03
    8d82:	bc 81       	ldd	r27, Y+4	; 0x04
    8d84:	bc 01       	movw	r22, r24
    8d86:	cd 01       	movw	r24, r26
    8d88:	40 e0       	ldi	r20, 0x00	; 0
    8d8a:	00 e0       	ldi	r16, 0x00	; 0
    8d8c:	10 e0       	ldi	r17, 0x00	; 0
    8d8e:	98 01       	movw	r18, r16
    8d90:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
    8d94:	dc 01       	movw	r26, r24
    8d96:	cb 01       	movw	r24, r22
    8d98:	89 83       	std	Y+1, r24	; 0x01
    8d9a:	9a 83       	std	Y+2, r25	; 0x02
    8d9c:	ab 83       	std	Y+3, r26	; 0x03
    8d9e:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8da0:	89 81       	ldd	r24, Y+1	; 0x01
    8da2:	9a 81       	ldd	r25, Y+2	; 0x02
    8da4:	ab 81       	ldd	r26, Y+3	; 0x03
    8da6:	bc 81       	ldd	r27, Y+4	; 0x04
    8da8:	00 97       	sbiw	r24, 0x00	; 0
    8daa:	a1 05       	cpc	r26, r1
    8dac:	b1 05       	cpc	r27, r1
    8dae:	09 f0       	breq	.+2      	; 0x8db2 <readFile+0x14c>
    8db0:	b3 cf       	rjmp	.-154    	; 0x8d18 <readFile+0xb2>
	  return 0;}
    8db2:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8db4:	67 96       	adiw	r28, 0x17	; 23
    8db6:	cd bf       	out	0x3d, r28	; 61
    8db8:	de bf       	out	0x3e, r29	; 62
    8dba:	df 91       	pop	r29
    8dbc:	cf 91       	pop	r28
    8dbe:	1f 91       	pop	r17
    8dc0:	0f 91       	pop	r16
    8dc2:	08 95       	ret

00008dc4 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8dc4:	cf 93       	push	r28
    8dc6:	df 93       	push	r29
    8dc8:	cd b7       	in	r28, 0x3d	; 61
    8dca:	de b7       	in	r29, 0x3e	; 62
    8dcc:	62 97       	sbiw	r28, 0x12	; 18
    8dce:	cd bf       	out	0x3d, r28	; 61
    8dd0:	de bf       	out	0x3e, r29	; 62
    8dd2:	89 8b       	std	Y+17, r24	; 0x11
    8dd4:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8dd6:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    8dd8:	89 89       	ldd	r24, Y+17	; 0x11
    8dda:	9a 89       	ldd	r25, Y+18	; 0x12
    8ddc:	9c 01       	movw	r18, r24
    8dde:	f9 01       	movw	r30, r18
    8de0:	01 90       	ld	r0, Z+
    8de2:	00 20       	and	r0, r0
    8de4:	e9 f7       	brne	.-6      	; 0x8de0 <convertFileName+0x1c>
    8de6:	cf 01       	movw	r24, r30
    8de8:	01 97       	sbiw	r24, 0x01	; 1
    8dea:	82 1b       	sub	r24, r18
    8dec:	93 0b       	sbc	r25, r19
    8dee:	80 31       	cpi	r24, 0x10	; 16
    8df0:	91 05       	cpc	r25, r1
    8df2:	10 f0       	brcs	.+4      	; 0x8df8 <convertFileName+0x34>
    8df4:	81 e0       	ldi	r24, 0x01	; 1
    8df6:	16 c1       	rjmp	.+556    	; 0x9024 <convertFileName+0x260>
int i=0;
    8df8:	1c 82       	std	Y+4, r1	; 0x04
    8dfa:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    8dfc:	13 c0       	rjmp	.+38     	; 0x8e24 <convertFileName+0x60>
	Filename[i] = fileName[i];
    8dfe:	8c 81       	ldd	r24, Y+4	; 0x04
    8e00:	9d 81       	ldd	r25, Y+5	; 0x05
    8e02:	29 89       	ldd	r18, Y+17	; 0x11
    8e04:	3a 89       	ldd	r19, Y+18	; 0x12
    8e06:	82 0f       	add	r24, r18
    8e08:	93 1f       	adc	r25, r19
    8e0a:	fc 01       	movw	r30, r24
    8e0c:	20 81       	ld	r18, Z
    8e0e:	8c 81       	ldd	r24, Y+4	; 0x04
    8e10:	9d 81       	ldd	r25, Y+5	; 0x05
    8e12:	8e 54       	subi	r24, 0x4E	; 78
    8e14:	9f 4a       	sbci	r25, 0xAF	; 175
    8e16:	fc 01       	movw	r30, r24
    8e18:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    8e1a:	8c 81       	ldd	r24, Y+4	; 0x04
    8e1c:	9d 81       	ldd	r25, Y+5	; 0x05
    8e1e:	01 96       	adiw	r24, 0x01	; 1
    8e20:	8c 83       	std	Y+4, r24	; 0x04
    8e22:	9d 83       	std	Y+5, r25	; 0x05
    8e24:	4c 81       	ldd	r20, Y+4	; 0x04
    8e26:	5d 81       	ldd	r21, Y+5	; 0x05
    8e28:	89 89       	ldd	r24, Y+17	; 0x11
    8e2a:	9a 89       	ldd	r25, Y+18	; 0x12
    8e2c:	9c 01       	movw	r18, r24
    8e2e:	f9 01       	movw	r30, r18
    8e30:	01 90       	ld	r0, Z+
    8e32:	00 20       	and	r0, r0
    8e34:	e9 f7       	brne	.-6      	; 0x8e30 <convertFileName+0x6c>
    8e36:	cf 01       	movw	r24, r30
    8e38:	01 97       	sbiw	r24, 0x01	; 1
    8e3a:	82 1b       	sub	r24, r18
    8e3c:	93 0b       	sbc	r25, r19
    8e3e:	48 17       	cp	r20, r24
    8e40:	59 07       	cpc	r21, r25
    8e42:	e8 f2       	brcs	.-70     	; 0x8dfe <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8e44:	0c c0       	rjmp	.+24     	; 0x8e5e <convertFileName+0x9a>
    8e46:	8c 81       	ldd	r24, Y+4	; 0x04
    8e48:	9d 81       	ldd	r25, Y+5	; 0x05
    8e4a:	8e 54       	subi	r24, 0x4E	; 78
    8e4c:	9f 4a       	sbci	r25, 0xAF	; 175
    8e4e:	20 e2       	ldi	r18, 0x20	; 32
    8e50:	fc 01       	movw	r30, r24
    8e52:	20 83       	st	Z, r18
    8e54:	8c 81       	ldd	r24, Y+4	; 0x04
    8e56:	9d 81       	ldd	r25, Y+5	; 0x05
    8e58:	01 96       	adiw	r24, 0x01	; 1
    8e5a:	8c 83       	std	Y+4, r24	; 0x04
    8e5c:	9d 83       	std	Y+5, r25	; 0x05
    8e5e:	8c 81       	ldd	r24, Y+4	; 0x04
    8e60:	9d 81       	ldd	r25, Y+5	; 0x05
    8e62:	8f 30       	cpi	r24, 0x0F	; 15
    8e64:	91 05       	cpc	r25, r1
    8e66:	7c f3       	brlt	.-34     	; 0x8e46 <convertFileName+0x82>


for(j=0; j<12; j++)
    8e68:	1a 82       	std	Y+2, r1	; 0x02
    8e6a:	0c c0       	rjmp	.+24     	; 0x8e84 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    8e6e:	88 2f       	mov	r24, r24
    8e70:	90 e0       	ldi	r25, 0x00	; 0
    8e72:	8e 54       	subi	r24, 0x4E	; 78
    8e74:	9f 4a       	sbci	r25, 0xAF	; 175
    8e76:	fc 01       	movw	r30, r24
    8e78:	80 81       	ld	r24, Z
    8e7a:	8e 32       	cpi	r24, 0x2E	; 46
    8e7c:	39 f0       	breq	.+14     	; 0x8e8c <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    8e80:	8f 5f       	subi	r24, 0xFF	; 255
    8e82:	8a 83       	std	Y+2, r24	; 0x02
    8e84:	8a 81       	ldd	r24, Y+2	; 0x02
    8e86:	8c 30       	cpi	r24, 0x0C	; 12
    8e88:	88 f3       	brcs	.-30     	; 0x8e6c <convertFileName+0xa8>
    8e8a:	01 c0       	rjmp	.+2      	; 0x8e8e <convertFileName+0xca>
if(Filename[j] == '.') break;
    8e8c:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    8e90:	89 30       	cpi	r24, 0x09	; 9
    8e92:	28 f0       	brcs	.+10     	; 0x8e9e <convertFileName+0xda>
    8e94:	8a 81       	ldd	r24, Y+2	; 0x02
    8e96:	8c 30       	cpi	r24, 0x0C	; 12
    8e98:	10 f4       	brcc	.+4      	; 0x8e9e <convertFileName+0xda>
	return 1;}
    8e9a:	81 e0       	ldi	r24, 0x01	; 1
    8e9c:	c3 c0       	rjmp	.+390    	; 0x9024 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    8ea0:	8c 30       	cpi	r24, 0x0C	; 12
    8ea2:	11 f4       	brne	.+4      	; 0x8ea8 <convertFileName+0xe4>
    8ea4:	81 e0       	ldi	r24, 0x01	; 1
    8ea6:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8ea8:	1b 82       	std	Y+3, r1	; 0x03
    8eaa:	14 c0       	rjmp	.+40     	; 0x8ed4 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8eac:	8b 81       	ldd	r24, Y+3	; 0x03
    8eae:	88 2f       	mov	r24, r24
    8eb0:	90 e0       	ldi	r25, 0x00	; 0
    8eb2:	2b 81       	ldd	r18, Y+3	; 0x03
    8eb4:	22 2f       	mov	r18, r18
    8eb6:	30 e0       	ldi	r19, 0x00	; 0
    8eb8:	2e 54       	subi	r18, 0x4E	; 78
    8eba:	3f 4a       	sbci	r19, 0xAF	; 175
    8ebc:	f9 01       	movw	r30, r18
    8ebe:	40 81       	ld	r20, Z
    8ec0:	9e 01       	movw	r18, r28
    8ec2:	2a 5f       	subi	r18, 0xFA	; 250
    8ec4:	3f 4f       	sbci	r19, 0xFF	; 255
    8ec6:	82 0f       	add	r24, r18
    8ec8:	93 1f       	adc	r25, r19
    8eca:	fc 01       	movw	r30, r24
    8ecc:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8ece:	8b 81       	ldd	r24, Y+3	; 0x03
    8ed0:	8f 5f       	subi	r24, 0xFF	; 255
    8ed2:	8b 83       	std	Y+3, r24	; 0x03
    8ed4:	9b 81       	ldd	r25, Y+3	; 0x03
    8ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    8ed8:	98 17       	cp	r25, r24
    8eda:	40 f3       	brcs	.-48     	; 0x8eac <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8edc:	8a 81       	ldd	r24, Y+2	; 0x02
    8ede:	8b 83       	std	Y+3, r24	; 0x03
    8ee0:	0e c0       	rjmp	.+28     	; 0x8efe <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    8ee4:	88 2f       	mov	r24, r24
    8ee6:	90 e0       	ldi	r25, 0x00	; 0
    8ee8:	9e 01       	movw	r18, r28
    8eea:	2a 5f       	subi	r18, 0xFA	; 250
    8eec:	3f 4f       	sbci	r19, 0xFF	; 255
    8eee:	82 0f       	add	r24, r18
    8ef0:	93 1f       	adc	r25, r19
    8ef2:	20 e2       	ldi	r18, 0x20	; 32
    8ef4:	fc 01       	movw	r30, r24
    8ef6:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    8efa:	8f 5f       	subi	r24, 0xFF	; 255
    8efc:	8b 83       	std	Y+3, r24	; 0x03
    8efe:	8b 81       	ldd	r24, Y+3	; 0x03
    8f00:	88 30       	cpi	r24, 0x08	; 8
    8f02:	78 f3       	brcs	.-34     	; 0x8ee2 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8f04:	99 81       	ldd	r25, Y+1	; 0x01
    8f06:	81 e0       	ldi	r24, 0x01	; 1
    8f08:	89 27       	eor	r24, r25
    8f0a:	88 23       	and	r24, r24
    8f0c:	19 f0       	breq	.+6      	; 0x8f14 <convertFileName+0x150>
    8f0e:	8a 81       	ldd	r24, Y+2	; 0x02
    8f10:	8f 5f       	subi	r24, 0xFF	; 255
    8f12:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8f14:	88 e0       	ldi	r24, 0x08	; 8
    8f16:	8b 83       	std	Y+3, r24	; 0x03
    8f18:	32 c0       	rjmp	.+100    	; 0x8f7e <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    8f1c:	88 2f       	mov	r24, r24
    8f1e:	90 e0       	ldi	r25, 0x00	; 0
    8f20:	8e 54       	subi	r24, 0x4E	; 78
    8f22:	9f 4a       	sbci	r25, 0xAF	; 175
    8f24:	fc 01       	movw	r30, r24
    8f26:	80 81       	ld	r24, Z
    8f28:	88 23       	and	r24, r24
    8f2a:	19 f1       	breq	.+70     	; 0x8f72 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    8f2e:	88 2f       	mov	r24, r24
    8f30:	90 e0       	ldi	r25, 0x00	; 0
    8f32:	2a 81       	ldd	r18, Y+2	; 0x02
    8f34:	22 2f       	mov	r18, r18
    8f36:	30 e0       	ldi	r19, 0x00	; 0
    8f38:	2e 54       	subi	r18, 0x4E	; 78
    8f3a:	3f 4a       	sbci	r19, 0xAF	; 175
    8f3c:	f9 01       	movw	r30, r18
    8f3e:	40 81       	ld	r20, Z
    8f40:	9e 01       	movw	r18, r28
    8f42:	2a 5f       	subi	r18, 0xFA	; 250
    8f44:	3f 4f       	sbci	r19, 0xFF	; 255
    8f46:	82 0f       	add	r24, r18
    8f48:	93 1f       	adc	r25, r19
    8f4a:	fc 01       	movw	r30, r24
    8f4c:	40 83       	st	Z, r20
    8f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    8f50:	8f 5f       	subi	r24, 0xFF	; 255
    8f52:	8a 83       	std	Y+2, r24	; 0x02
    8f54:	11 c0       	rjmp	.+34     	; 0x8f78 <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8f56:	8b 81       	ldd	r24, Y+3	; 0x03
    8f58:	88 2f       	mov	r24, r24
    8f5a:	90 e0       	ldi	r25, 0x00	; 0
    8f5c:	9e 01       	movw	r18, r28
    8f5e:	2a 5f       	subi	r18, 0xFA	; 250
    8f60:	3f 4f       	sbci	r19, 0xFF	; 255
    8f62:	82 0f       	add	r24, r18
    8f64:	93 1f       	adc	r25, r19
    8f66:	20 e2       	ldi	r18, 0x20	; 32
    8f68:	fc 01       	movw	r30, r24
    8f6a:	20 83       	st	Z, r18
    8f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    8f6e:	8f 5f       	subi	r24, 0xFF	; 255
    8f70:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8f72:	8b 81       	ldd	r24, Y+3	; 0x03
    8f74:	8b 30       	cpi	r24, 0x0B	; 11
    8f76:	78 f3       	brcs	.-34     	; 0x8f56 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8f78:	8b 81       	ldd	r24, Y+3	; 0x03
    8f7a:	8f 5f       	subi	r24, 0xFF	; 255
    8f7c:	8b 83       	std	Y+3, r24	; 0x03
    8f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    8f80:	8b 30       	cpi	r24, 0x0B	; 11
    8f82:	58 f2       	brcs	.-106    	; 0x8f1a <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8f84:	1a 82       	std	Y+2, r1	; 0x02
    8f86:	31 c0       	rjmp	.+98     	; 0x8fea <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8f88:	8a 81       	ldd	r24, Y+2	; 0x02
    8f8a:	88 2f       	mov	r24, r24
    8f8c:	90 e0       	ldi	r25, 0x00	; 0
    8f8e:	9e 01       	movw	r18, r28
    8f90:	2a 5f       	subi	r18, 0xFA	; 250
    8f92:	3f 4f       	sbci	r19, 0xFF	; 255
    8f94:	82 0f       	add	r24, r18
    8f96:	93 1f       	adc	r25, r19
    8f98:	fc 01       	movw	r30, r24
    8f9a:	80 81       	ld	r24, Z
    8f9c:	81 36       	cpi	r24, 0x61	; 97
    8f9e:	10 f1       	brcs	.+68     	; 0x8fe4 <convertFileName+0x220>
    8fa0:	8a 81       	ldd	r24, Y+2	; 0x02
    8fa2:	88 2f       	mov	r24, r24
    8fa4:	90 e0       	ldi	r25, 0x00	; 0
    8fa6:	9e 01       	movw	r18, r28
    8fa8:	2a 5f       	subi	r18, 0xFA	; 250
    8faa:	3f 4f       	sbci	r19, 0xFF	; 255
    8fac:	82 0f       	add	r24, r18
    8fae:	93 1f       	adc	r25, r19
    8fb0:	fc 01       	movw	r30, r24
    8fb2:	80 81       	ld	r24, Z
    8fb4:	8b 37       	cpi	r24, 0x7B	; 123
    8fb6:	b0 f4       	brcc	.+44     	; 0x8fe4 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    8fba:	88 2f       	mov	r24, r24
    8fbc:	90 e0       	ldi	r25, 0x00	; 0
    8fbe:	2a 81       	ldd	r18, Y+2	; 0x02
    8fc0:	22 2f       	mov	r18, r18
    8fc2:	30 e0       	ldi	r19, 0x00	; 0
    8fc4:	ae 01       	movw	r20, r28
    8fc6:	4a 5f       	subi	r20, 0xFA	; 250
    8fc8:	5f 4f       	sbci	r21, 0xFF	; 255
    8fca:	24 0f       	add	r18, r20
    8fcc:	35 1f       	adc	r19, r21
    8fce:	f9 01       	movw	r30, r18
    8fd0:	20 81       	ld	r18, Z
    8fd2:	42 2f       	mov	r20, r18
    8fd4:	40 52       	subi	r20, 0x20	; 32
    8fd6:	9e 01       	movw	r18, r28
    8fd8:	2a 5f       	subi	r18, 0xFA	; 250
    8fda:	3f 4f       	sbci	r19, 0xFF	; 255
    8fdc:	82 0f       	add	r24, r18
    8fde:	93 1f       	adc	r25, r19
    8fe0:	fc 01       	movw	r30, r24
    8fe2:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8fe4:	8a 81       	ldd	r24, Y+2	; 0x02
    8fe6:	8f 5f       	subi	r24, 0xFF	; 255
    8fe8:	8a 83       	std	Y+2, r24	; 0x02
    8fea:	8a 81       	ldd	r24, Y+2	; 0x02
    8fec:	8b 30       	cpi	r24, 0x0B	; 11
    8fee:	60 f2       	brcs	.-104    	; 0x8f88 <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8ff0:	1a 82       	std	Y+2, r1	; 0x02
    8ff2:	14 c0       	rjmp	.+40     	; 0x901c <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8ff4:	8a 81       	ldd	r24, Y+2	; 0x02
    8ff6:	88 2f       	mov	r24, r24
    8ff8:	90 e0       	ldi	r25, 0x00	; 0
    8ffa:	2a 81       	ldd	r18, Y+2	; 0x02
    8ffc:	22 2f       	mov	r18, r18
    8ffe:	30 e0       	ldi	r19, 0x00	; 0
    9000:	ae 01       	movw	r20, r28
    9002:	4a 5f       	subi	r20, 0xFA	; 250
    9004:	5f 4f       	sbci	r21, 0xFF	; 255
    9006:	24 0f       	add	r18, r20
    9008:	35 1f       	adc	r19, r21
    900a:	f9 01       	movw	r30, r18
    900c:	20 81       	ld	r18, Z
    900e:	8e 54       	subi	r24, 0x4E	; 78
    9010:	9f 4a       	sbci	r25, 0xAF	; 175
    9012:	fc 01       	movw	r30, r24
    9014:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    9016:	8a 81       	ldd	r24, Y+2	; 0x02
    9018:	8f 5f       	subi	r24, 0xFF	; 255
    901a:	8a 83       	std	Y+2, r24	; 0x02
    901c:	8a 81       	ldd	r24, Y+2	; 0x02
    901e:	8b 30       	cpi	r24, 0x0B	; 11
    9020:	48 f3       	brcs	.-46     	; 0x8ff4 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    9022:	80 e0       	ldi	r24, 0x00	; 0
}
    9024:	62 96       	adiw	r28, 0x12	; 18
    9026:	cd bf       	out	0x3d, r28	; 61
    9028:	de bf       	out	0x3e, r29	; 62
    902a:	df 91       	pop	r29
    902c:	cf 91       	pop	r28
    902e:	08 95       	ret

00009030 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint32_t index_offset){
    9030:	ef 92       	push	r14
    9032:	ff 92       	push	r15
    9034:	0f 93       	push	r16
    9036:	1f 93       	push	r17
    9038:	cf 93       	push	r28
    903a:	df 93       	push	r29
    903c:	cd b7       	in	r28, 0x3d	; 61
    903e:	de b7       	in	r29, 0x3e	; 62
    9040:	ad 97       	sbiw	r28, 0x2d	; 45
    9042:	cd bf       	out	0x3d, r28	; 61
    9044:	de bf       	out	0x3e, r29	; 62
    9046:	88 a7       	lds	r24, 0x78
    9048:	99 a7       	lds	r25, 0x79
    904a:	4a a7       	lds	r20, 0x7a
    904c:	5b a7       	lds	r21, 0x7b
    904e:	6c a7       	lds	r22, 0x7c
    9050:	7d a7       	lds	r23, 0x7d
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    9052:	1a 82       	std	Y+2, r1	; 0x02
    9054:	1b 82       	std	Y+3, r1	; 0x03
    9056:	1c 82       	std	Y+4, r1	; 0x04
    9058:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    905a:	1e 82       	std	Y+6, r1	; 0x06
    905c:	1f 82       	std	Y+7, r1	; 0x07
    905e:	18 86       	std	Y+8, r1	; 0x08
    9060:	19 86       	std	Y+9, r1	; 0x09
    9062:	1a 86       	std	Y+10, r1	; 0x0a
    9064:	1b 86       	std	Y+11, r1	; 0x0b
if(strlen(fileName) > 15) return 1;
for(int i=0; i < strlen(fileName); i++){
	Filename[i] = fileName[i];
}
*/
j = readFile (VERIFY, fileName);
    9066:	28 a5       	lds	r18, 0x68
    9068:	39 a5       	lds	r19, 0x69
    906a:	81 e0       	ldi	r24, 0x01	; 1
    906c:	b9 01       	movw	r22, r18
    906e:	0e 94 33 46 	call	0x8c66	; 0x8c66 <readFile>
    9072:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    9074:	89 81       	ldd	r24, Y+1	; 0x01
    9076:	81 30       	cpi	r24, 0x01	; 1
    9078:	09 f0       	breq	.+2      	; 0x907c <writeFile+0x4c>
    907a:	84 c0       	rjmp	.+264    	; 0x9184 <writeFile+0x154>
{
  //File already exists, appending data
  appendFile = 1;
    907c:	81 e0       	ldi	r24, 0x01	; 1
    907e:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    9080:	80 91 78 50 	lds	r24, 0x5078
    9084:	90 91 79 50 	lds	r25, 0x5079
    9088:	a0 91 7a 50 	lds	r26, 0x507A
    908c:	b0 91 7b 50 	lds	r27, 0x507B
    9090:	8c 87       	std	Y+12, r24	; 0x0c
    9092:	9d 87       	std	Y+13, r25	; 0x0d
    9094:	ae 87       	std	Y+14, r26	; 0x0e
    9096:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    9098:	1c 8a       	std	Y+20, r1	; 0x14
    909a:	1d 8a       	std	Y+21, r1	; 0x15
    909c:	1e 8a       	std	Y+22, r1	; 0x16
    909e:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    90a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    90a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    90a4:	ae 85       	ldd	r26, Y+14	; 0x0e
    90a6:	bf 85       	ldd	r27, Y+15	; 0x0f
    90a8:	bc 01       	movw	r22, r24
    90aa:	cd 01       	movw	r24, r26
    90ac:	40 e0       	ldi	r20, 0x00	; 0
    90ae:	00 e0       	ldi	r16, 0x00	; 0
    90b0:	10 e0       	ldi	r17, 0x00	; 0
    90b2:	98 01       	movw	r18, r16
    90b4:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
    90b8:	dc 01       	movw	r26, r24
    90ba:	cb 01       	movw	r24, r22
    90bc:	8a 8f       	std	Y+26, r24	; 0x1a
    90be:	9b 8f       	std	Y+27, r25	; 0x1b
    90c0:	ac 8f       	std	Y+28, r26	; 0x1c
    90c2:	bd 8f       	std	Y+29, r27	; 0x1d
    if(nextCluster == EOF) break;
    90c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    90c6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    90c8:	ac 8d       	ldd	r26, Y+28	; 0x1c
    90ca:	bd 8d       	ldd	r27, Y+29	; 0x1d
    90cc:	8f 3f       	cpi	r24, 0xFF	; 255
    90ce:	0f ef       	ldi	r16, 0xFF	; 255
    90d0:	90 07       	cpc	r25, r16
    90d2:	0f ef       	ldi	r16, 0xFF	; 255
    90d4:	a0 07       	cpc	r26, r16
    90d6:	0f e0       	ldi	r16, 0x0F	; 15
    90d8:	b0 07       	cpc	r27, r16
    90da:	a1 f0       	breq	.+40     	; 0x9104 <writeFile+0xd4>
	cluster = nextCluster;
    90dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    90de:	9b 8d       	ldd	r25, Y+27	; 0x1b
    90e0:	ac 8d       	ldd	r26, Y+28	; 0x1c
    90e2:	bd 8d       	ldd	r27, Y+29	; 0x1d
    90e4:	8c 87       	std	Y+12, r24	; 0x0c
    90e6:	9d 87       	std	Y+13, r25	; 0x0d
    90e8:	ae 87       	std	Y+14, r26	; 0x0e
    90ea:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    90ec:	8c 89       	ldd	r24, Y+20	; 0x14
    90ee:	9d 89       	ldd	r25, Y+21	; 0x15
    90f0:	ae 89       	ldd	r26, Y+22	; 0x16
    90f2:	bf 89       	ldd	r27, Y+23	; 0x17
    90f4:	01 96       	adiw	r24, 0x01	; 1
    90f6:	a1 1d       	adc	r26, r1
    90f8:	b1 1d       	adc	r27, r1
    90fa:	8c 8b       	std	Y+20, r24	; 0x14
    90fc:	9d 8b       	std	Y+21, r25	; 0x15
    90fe:	ae 8b       	std	Y+22, r26	; 0x16
    9100:	bf 8b       	std	Y+23, r27	; 0x17
  }
    9102:	ce cf       	rjmp	.-100    	; 0x90a0 <writeFile+0x70>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    9104:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    9106:	e0 90 45 40 	lds	r14, 0x4045
    910a:	f0 90 46 40 	lds	r15, 0x4046
    910e:	00 91 47 40 	lds	r16, 0x4047
    9112:	10 91 48 40 	lds	r17, 0x4048
    9116:	80 91 6c 50 	lds	r24, 0x506C
    911a:	90 91 6d 50 	lds	r25, 0x506D
    911e:	cc 01       	movw	r24, r24
    9120:	a0 e0       	ldi	r26, 0x00	; 0
    9122:	b0 e0       	ldi	r27, 0x00	; 0
    9124:	2c 89       	ldd	r18, Y+20	; 0x14
    9126:	3d 89       	ldd	r19, Y+21	; 0x15
    9128:	4e 89       	ldd	r20, Y+22	; 0x16
    912a:	5f 89       	ldd	r21, Y+23	; 0x17
    912c:	bc 01       	movw	r22, r24
    912e:	cd 01       	movw	r24, r26
    9130:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    9134:	dc 01       	movw	r26, r24
    9136:	cb 01       	movw	r24, r22
    9138:	20 91 49 40 	lds	r18, 0x4049
    913c:	30 91 4a 40 	lds	r19, 0x404A
    9140:	99 01       	movw	r18, r18
    9142:	40 e0       	ldi	r20, 0x00	; 0
    9144:	50 e0       	ldi	r21, 0x00	; 0
    9146:	bc 01       	movw	r22, r24
    9148:	cd 01       	movw	r24, r26
    914a:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    914e:	dc 01       	movw	r26, r24
    9150:	cb 01       	movw	r24, r22
    9152:	a8 01       	movw	r20, r16
    9154:	97 01       	movw	r18, r14
    9156:	28 1b       	sub	r18, r24
    9158:	39 0b       	sbc	r19, r25
    915a:	4a 0b       	sbc	r20, r26
    915c:	5b 0b       	sbc	r21, r27
    915e:	da 01       	movw	r26, r20
    9160:	c9 01       	movw	r24, r18
    9162:	20 91 49 40 	lds	r18, 0x4049
    9166:	30 91 4a 40 	lds	r19, 0x404A
    916a:	99 01       	movw	r18, r18
    916c:	40 e0       	ldi	r20, 0x00	; 0
    916e:	50 e0       	ldi	r21, 0x00	; 0
    9170:	bc 01       	movw	r22, r24
    9172:	cd 01       	movw	r24, r26
    9174:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    9178:	da 01       	movw	r26, r20
    917a:	c9 01       	movw	r24, r18
    917c:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    917e:	81 e0       	ldi	r24, 0x01	; 1
    9180:	8b 83       	std	Y+3, r24	; 0x03
    9182:	69 c0       	rjmp	.+210    	; 0x9256 <writeFile+0x226>
}
else if(j == 2) 
    9184:	89 81       	ldd	r24, Y+1	; 0x01
    9186:	82 30       	cpi	r24, 0x02	; 2
    9188:	11 f4       	brne	.+4      	; 0x918e <writeFile+0x15e>
   return 1; //invalid file name
    918a:	81 e0       	ldi	r24, 0x01	; 1
    918c:	b6 c2       	rjmp	.+1388   	; 0x96fa <writeFile+0x6ca>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    918e:	82 e0       	ldi	r24, 0x02	; 2
    9190:	60 e0       	ldi	r22, 0x00	; 0
    9192:	20 e0       	ldi	r18, 0x00	; 0
    9194:	30 e0       	ldi	r19, 0x00	; 0
    9196:	a9 01       	movw	r20, r18
    9198:	0e 94 a8 43 	call	0x8750	; 0x8750 <getSetFreeCluster>
    919c:	dc 01       	movw	r26, r24
    919e:	cb 01       	movw	r24, r22
    91a0:	8c 87       	std	Y+12, r24	; 0x0c
    91a2:	9d 87       	std	Y+13, r25	; 0x0d
    91a4:	ae 87       	std	Y+14, r26	; 0x0e
    91a6:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    91a8:	80 91 4e 40 	lds	r24, 0x404E
    91ac:	90 91 4f 40 	lds	r25, 0x404F
    91b0:	a0 91 50 40 	lds	r26, 0x4050
    91b4:	b0 91 51 40 	lds	r27, 0x4051
    91b8:	2c 85       	ldd	r18, Y+12	; 0x0c
    91ba:	3d 85       	ldd	r19, Y+13	; 0x0d
    91bc:	4e 85       	ldd	r20, Y+14	; 0x0e
    91be:	5f 85       	ldd	r21, Y+15	; 0x0f
    91c0:	82 17       	cp	r24, r18
    91c2:	93 07       	cpc	r25, r19
    91c4:	a4 07       	cpc	r26, r20
    91c6:	b5 07       	cpc	r27, r21
    91c8:	60 f4       	brcc	.+24     	; 0x91e2 <writeFile+0x1b2>
     cluster = rootCluster;
    91ca:	80 91 54 40 	lds	r24, 0x4054
    91ce:	90 91 55 40 	lds	r25, 0x4055
    91d2:	a0 91 56 40 	lds	r26, 0x4056
    91d6:	b0 91 57 40 	lds	r27, 0x4057
    91da:	8c 87       	std	Y+12, r24	; 0x0c
    91dc:	9d 87       	std	Y+13, r25	; 0x0d
    91de:	ae 87       	std	Y+14, r26	; 0x0e
    91e0:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    91e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    91e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    91e6:	ae 85       	ldd	r26, Y+14	; 0x0e
    91e8:	bf 85       	ldd	r27, Y+15	; 0x0f
    91ea:	bc 01       	movw	r22, r24
    91ec:	cd 01       	movw	r24, r26
    91ee:	0e 94 87 4b 	call	0x970e	; 0x970e <searchNextFreeCluster>
    91f2:	dc 01       	movw	r26, r24
    91f4:	cb 01       	movw	r24, r22
    91f6:	8c 87       	std	Y+12, r24	; 0x0c
    91f8:	9d 87       	std	Y+13, r25	; 0x0d
    91fa:	ae 87       	std	Y+14, r26	; 0x0e
    91fc:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    91fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    9200:	9d 85       	ldd	r25, Y+13	; 0x0d
    9202:	ae 85       	ldd	r26, Y+14	; 0x0e
    9204:	bf 85       	ldd	r27, Y+15	; 0x0f
    9206:	00 97       	sbiw	r24, 0x00	; 0
    9208:	a1 05       	cpc	r26, r1
    920a:	b1 05       	cpc	r27, r1
    920c:	11 f4       	brne	.+4      	; 0x9212 <writeFile+0x1e2>
   {
	   // No free cluster!
	  return 2;
    920e:	82 e0       	ldi	r24, 0x02	; 2
    9210:	74 c2       	rjmp	.+1256   	; 0x96fa <writeFile+0x6ca>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    9212:	8c 85       	ldd	r24, Y+12	; 0x0c
    9214:	9d 85       	ldd	r25, Y+13	; 0x0d
    9216:	ae 85       	ldd	r26, Y+14	; 0x0e
    9218:	bf 85       	ldd	r27, Y+15	; 0x0f
    921a:	bc 01       	movw	r22, r24
    921c:	cd 01       	movw	r24, r26
    921e:	41 e0       	ldi	r20, 0x01	; 1
    9220:	0f ef       	ldi	r16, 0xFF	; 255
    9222:	1f ef       	ldi	r17, 0xFF	; 255
    9224:	2f ef       	ldi	r18, 0xFF	; 255
    9226:	3f e0       	ldi	r19, 0x0F	; 15
    9228:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    922c:	8c 85       	ldd	r24, Y+12	; 0x0c
    922e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9230:	ae 85       	ldd	r26, Y+14	; 0x0e
    9232:	bf 85       	ldd	r27, Y+15	; 0x0f
    9234:	cd 01       	movw	r24, r26
    9236:	aa 27       	eor	r26, r26
    9238:	bb 27       	eor	r27, r27
    923a:	8e 83       	std	Y+6, r24	; 0x06
    923c:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    923e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9240:	9d 85       	ldd	r25, Y+13	; 0x0d
    9242:	88 87       	std	Y+8, r24	; 0x08
    9244:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    9246:	10 92 45 40 	sts	0x4045, r1
    924a:	10 92 46 40 	sts	0x4046, r1
    924e:	10 92 47 40 	sts	0x4047, r1
    9252:	10 92 48 40 	sts	0x4048, r1
}

//start writing data here
if(start){
    9256:	8b 81       	ldd	r24, Y+3	; 0x03
    9258:	88 23       	and	r24, r24
    925a:	11 f1       	breq	.+68     	; 0x92a0 <writeFile+0x270>
      start = 0;
    925c:	1b 82       	std	Y+3, r1	; 0x03
	  startBlock = getFirstSector (cluster) + sector;
    925e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9260:	9d 85       	ldd	r25, Y+13	; 0x0d
    9262:	ae 85       	ldd	r26, Y+14	; 0x0e
    9264:	bf 85       	ldd	r27, Y+15	; 0x0f
    9266:	bc 01       	movw	r22, r24
    9268:	cd 01       	movw	r24, r26
    926a:	0e 94 cc 42 	call	0x8598	; 0x8598 <getFirstSector>
    926e:	dc 01       	movw	r26, r24
    9270:	cb 01       	movw	r24, r22
    9272:	9c 01       	movw	r18, r24
    9274:	8d 81       	ldd	r24, Y+5	; 0x05
    9276:	88 2f       	mov	r24, r24
    9278:	90 e0       	ldi	r25, 0x00	; 0
    927a:	82 0f       	add	r24, r18
    927c:	93 1f       	adc	r25, r19
    927e:	8a 87       	std	Y+10, r24	; 0x0a
    9280:	9b 87       	std	Y+11, r25	; 0x0b
	  SD_read_block (startBlock,SDBuffer);
    9282:	8a 85       	ldd	r24, Y+10	; 0x0a
    9284:	9b 85       	ldd	r25, Y+11	; 0x0b
    9286:	cc 01       	movw	r24, r24
    9288:	a0 e0       	ldi	r26, 0x00	; 0
    928a:	b0 e0       	ldi	r27, 0x00	; 0
    928c:	2b ec       	ldi	r18, 0xCB	; 203
    928e:	31 e2       	ldi	r19, 0x21	; 33
    9290:	bc 01       	movw	r22, r24
    9292:	cd 01       	movw	r24, r26
    9294:	a9 01       	movw	r20, r18
    9296:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
	  j = sector;
    929a:	8d 81       	ldd	r24, Y+5	; 0x05
    929c:	89 83       	std	Y+1, r24	; 0x01
    929e:	0d c0       	rjmp	.+26     	; 0x92ba <writeFile+0x28a>
   }
   else{
      startBlock = getFirstSector (cluster);
    92a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    92a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    92a4:	ae 85       	ldd	r26, Y+14	; 0x0e
    92a6:	bf 85       	ldd	r27, Y+15	; 0x0f
    92a8:	bc 01       	movw	r22, r24
    92aa:	cd 01       	movw	r24, r26
    92ac:	0e 94 cc 42 	call	0x8598	; 0x8598 <getFirstSector>
    92b0:	dc 01       	movw	r26, r24
    92b2:	cb 01       	movw	r24, r22
    92b4:	8a 87       	std	Y+10, r24	; 0x0a
    92b6:	9b 87       	std	Y+11, r25	; 0x0b
	  j=0;
    92b8:	19 82       	std	Y+1, r1	; 0x01
   }
//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes   
fileSize += 512;
    92ba:	80 91 45 40 	lds	r24, 0x4045
    92be:	90 91 46 40 	lds	r25, 0x4046
    92c2:	a0 91 47 40 	lds	r26, 0x4047
    92c6:	b0 91 48 40 	lds	r27, 0x4048
    92ca:	80 50       	subi	r24, 0x00	; 0
    92cc:	9e 4f       	sbci	r25, 0xFE	; 254
    92ce:	af 4f       	sbci	r26, 0xFF	; 255
    92d0:	bf 4f       	sbci	r27, 0xFF	; 255
    92d2:	80 93 45 40 	sts	0x4045, r24
    92d6:	90 93 46 40 	sts	0x4046, r25
    92da:	a0 93 47 40 	sts	0x4047, r26
    92de:	b0 93 48 40 	sts	0x4048, r27
SD_write_block (startBlock,FRAMReadBuffer+index_offset,512);
    92e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    92e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    92e6:	cc 01       	movw	r24, r24
    92e8:	a0 e0       	ldi	r26, 0x00	; 0
    92ea:	b0 e0       	ldi	r27, 0x00	; 0
    92ec:	2a a5       	lds	r18, 0x6a
    92ee:	3b a5       	lds	r19, 0x6b
    92f0:	2c 52       	subi	r18, 0x2C	; 44
    92f2:	3c 4d       	sbci	r19, 0xDC	; 220
    92f4:	bc 01       	movw	r22, r24
    92f6:	cd 01       	movw	r24, r26
    92f8:	a9 01       	movw	r20, r18
    92fa:	20 e0       	ldi	r18, 0x00	; 0
    92fc:	32 e0       	ldi	r19, 0x02	; 2
    92fe:	0e 94 c3 4f 	call	0x9f86	; 0x9f86 <SD_write_block>
j++;
    9302:	89 81       	ldd	r24, Y+1	; 0x01
    9304:	8f 5f       	subi	r24, 0xFF	; 255
    9306:	89 83       	std	Y+1, r24	; 0x01
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
    9308:	89 81       	ldd	r24, Y+1	; 0x01
    930a:	28 2f       	mov	r18, r24
    930c:	30 e0       	ldi	r19, 0x00	; 0
    930e:	80 91 6c 50 	lds	r24, 0x506C
    9312:	90 91 6d 50 	lds	r25, 0x506D
    9316:	28 17       	cp	r18, r24
    9318:	39 07       	cpc	r19, r25
    931a:	e1 f5       	brne	.+120    	; 0x9394 <writeFile+0x364>
	j = 0; 
    931c:	19 82       	std	Y+1, r1	; 0x01
 
	prevCluster = cluster;
    931e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9320:	9d 85       	ldd	r25, Y+13	; 0x0d
    9322:	ae 85       	ldd	r26, Y+14	; 0x0e
    9324:	bf 85       	ldd	r27, Y+15	; 0x0f
    9326:	88 8b       	std	Y+16, r24	; 0x10
    9328:	99 8b       	std	Y+17, r25	; 0x11
    932a:	aa 8b       	std	Y+18, r26	; 0x12
    932c:	bb 8b       	std	Y+19, r27	; 0x13
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    932e:	88 89       	ldd	r24, Y+16	; 0x10
    9330:	99 89       	ldd	r25, Y+17	; 0x11
    9332:	aa 89       	ldd	r26, Y+18	; 0x12
    9334:	bb 89       	ldd	r27, Y+19	; 0x13
    9336:	bc 01       	movw	r22, r24
    9338:	cd 01       	movw	r24, r26
    933a:	0e 94 87 4b 	call	0x970e	; 0x970e <searchNextFreeCluster>
    933e:	dc 01       	movw	r26, r24
    9340:	cb 01       	movw	r24, r22
    9342:	8c 87       	std	Y+12, r24	; 0x0c
    9344:	9d 87       	std	Y+13, r25	; 0x0d
    9346:	ae 87       	std	Y+14, r26	; 0x0e
    9348:	bf 87       	std	Y+15, r27	; 0x0f
	if(cluster == 0){
    934a:	8c 85       	ldd	r24, Y+12	; 0x0c
    934c:	9d 85       	ldd	r25, Y+13	; 0x0d
    934e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9350:	bf 85       	ldd	r27, Y+15	; 0x0f
    9352:	00 97       	sbiw	r24, 0x00	; 0
    9354:	a1 05       	cpc	r26, r1
    9356:	b1 05       	cpc	r27, r1
    9358:	11 f4       	brne	.+4      	; 0x935e <writeFile+0x32e>
      //No free cluster!
	  return 2;
    935a:	82 e0       	ldi	r24, 0x02	; 2
    935c:	ce c1       	rjmp	.+924    	; 0x96fa <writeFile+0x6ca>
   }
	getSetNextCluster(prevCluster, SET, cluster);
    935e:	88 89       	ldd	r24, Y+16	; 0x10
    9360:	99 89       	ldd	r25, Y+17	; 0x11
    9362:	aa 89       	ldd	r26, Y+18	; 0x12
    9364:	bb 89       	ldd	r27, Y+19	; 0x13
    9366:	0c 85       	ldd	r16, Y+12	; 0x0c
    9368:	1d 85       	ldd	r17, Y+13	; 0x0d
    936a:	2e 85       	ldd	r18, Y+14	; 0x0e
    936c:	3f 85       	ldd	r19, Y+15	; 0x0f
    936e:	bc 01       	movw	r22, r24
    9370:	cd 01       	movw	r24, r26
    9372:	41 e0       	ldi	r20, 0x01	; 1
    9374:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
	getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    9378:	8c 85       	ldd	r24, Y+12	; 0x0c
    937a:	9d 85       	ldd	r25, Y+13	; 0x0d
    937c:	ae 85       	ldd	r26, Y+14	; 0x0e
    937e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9380:	bc 01       	movw	r22, r24
    9382:	cd 01       	movw	r24, r26
    9384:	41 e0       	ldi	r20, 0x01	; 1
    9386:	0f ef       	ldi	r16, 0xFF	; 255
    9388:	1f ef       	ldi	r17, 0xFF	; 255
    938a:	2f ef       	ldi	r18, 0xFF	; 255
    938c:	3f e0       	ldi	r19, 0x0F	; 15
    938e:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
    9392:	05 c0       	rjmp	.+10     	; 0x939e <writeFile+0x36e>
}
//otherwise increment the sector offset 
else startBlock++;       
    9394:	8a 85       	ldd	r24, Y+10	; 0x0a
    9396:	9b 85       	ldd	r25, Y+11	; 0x0b
    9398:	01 96       	adiw	r24, 0x01	; 1
    939a:	8a 87       	std	Y+10, r24	; 0x0a
    939c:	9b 87       	std	Y+11, r25	; 0x0b

getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    939e:	2c 85       	ldd	r18, Y+12	; 0x0c
    93a0:	3d 85       	ldd	r19, Y+13	; 0x0d
    93a2:	4e 85       	ldd	r20, Y+14	; 0x0e
    93a4:	5f 85       	ldd	r21, Y+15	; 0x0f
    93a6:	82 e0       	ldi	r24, 0x02	; 2
    93a8:	61 e0       	ldi	r22, 0x01	; 1
    93aa:	0e 94 a8 43 	call	0x8750	; 0x8750 <getSetFreeCluster>

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    93ae:	8c 81       	ldd	r24, Y+4	; 0x04
    93b0:	88 23       	and	r24, r24
    93b2:	09 f4       	brne	.+2      	; 0x93b6 <writeFile+0x386>
    93b4:	66 c0       	rjmp	.+204    	; 0x9482 <writeFile+0x452>
{
  SD_read_block (appendFileSector,SDBuffer);    
    93b6:	80 91 d6 50 	lds	r24, 0x50D6
    93ba:	90 91 d7 50 	lds	r25, 0x50D7
    93be:	a0 91 d8 50 	lds	r26, 0x50D8
    93c2:	b0 91 d9 50 	lds	r27, 0x50D9
    93c6:	2b ec       	ldi	r18, 0xCB	; 203
    93c8:	31 e2       	ldi	r19, 0x21	; 33
    93ca:	bc 01       	movw	r22, r24
    93cc:	cd 01       	movw	r24, r26
    93ce:	a9 01       	movw	r20, r18
    93d0:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    93d4:	80 91 cc 23 	lds	r24, 0x23CC
    93d8:	90 91 cd 23 	lds	r25, 0x23CD
    93dc:	a0 91 ce 23 	lds	r26, 0x23CE
    93e0:	b0 91 cf 23 	lds	r27, 0x23CF
    93e4:	85 53       	subi	r24, 0x35	; 53
    93e6:	9e 4d       	sbci	r25, 0xDE	; 222
    93e8:	8e 8f       	std	Y+30, r24	; 0x1e
    93ea:	9f 8f       	std	Y+31, r25	; 0x1f

  dir->lastAccessDate = 0;   //date of last access ignored
    93ec:	8e 8d       	ldd	r24, Y+30	; 0x1e
    93ee:	9f 8d       	ldd	r25, Y+31	; 0x1f
    93f0:	fc 01       	movw	r30, r24
    93f2:	12 8a       	std	Z+18, r1	; 0x12
    93f4:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    93f6:	20 91 45 40 	lds	r18, 0x4045
    93fa:	30 91 46 40 	lds	r19, 0x4046
    93fe:	40 91 47 40 	lds	r20, 0x4047
    9402:	50 91 48 40 	lds	r21, 0x4048
    9406:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9408:	9f 8d       	ldd	r25, Y+31	; 0x1f
    940a:	fc 01       	movw	r30, r24
    940c:	84 8d       	ldd	r24, Z+28	; 0x1c
    940e:	95 8d       	ldd	r25, Z+29	; 0x1d
    9410:	a6 8d       	ldd	r26, Z+30	; 0x1e
    9412:	b7 8d       	ldd	r27, Z+31	; 0x1f
    9414:	79 01       	movw	r14, r18
    9416:	8a 01       	movw	r16, r20
    9418:	e8 1a       	sub	r14, r24
    941a:	f9 0a       	sbc	r15, r25
    941c:	0a 0b       	sbc	r16, r26
    941e:	1b 0b       	sbc	r17, r27
    9420:	d8 01       	movw	r26, r16
    9422:	c7 01       	movw	r24, r14
    9424:	88 a3       	lds	r24, 0x58
    9426:	99 a3       	lds	r25, 0x59
    9428:	aa a3       	lds	r26, 0x5a
    942a:	bb a3       	lds	r27, 0x5b
  dir->fileSize = fileSize;
    942c:	80 91 45 40 	lds	r24, 0x4045
    9430:	90 91 46 40 	lds	r25, 0x4046
    9434:	a0 91 47 40 	lds	r26, 0x4047
    9438:	b0 91 48 40 	lds	r27, 0x4048
    943c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    943e:	3f 8d       	ldd	r19, Y+31	; 0x1f
    9440:	f9 01       	movw	r30, r18
    9442:	84 8f       	std	Z+28, r24	; 0x1c
    9444:	95 8f       	std	Z+29, r25	; 0x1d
    9446:	a6 8f       	std	Z+30, r26	; 0x1e
    9448:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    944a:	80 91 d6 50 	lds	r24, 0x50D6
    944e:	90 91 d7 50 	lds	r25, 0x50D7
    9452:	a0 91 d8 50 	lds	r26, 0x50D8
    9456:	b0 91 d9 50 	lds	r27, 0x50D9
    945a:	2b ec       	ldi	r18, 0xCB	; 203
    945c:	31 e2       	ldi	r19, 0x21	; 33
    945e:	bc 01       	movw	r22, r24
    9460:	cd 01       	movw	r24, r26
    9462:	a9 01       	movw	r20, r18
    9464:	20 e0       	ldi	r18, 0x00	; 0
    9466:	32 e0       	ldi	r19, 0x02	; 2
    9468:	0e 94 c3 4f 	call	0x9f86	; 0x9f86 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    946c:	28 a1       	lds	r18, 0x48
    946e:	39 a1       	lds	r19, 0x49
    9470:	4a a1       	lds	r20, 0x4a
    9472:	5b a1       	lds	r21, 0x4b
    9474:	81 e0       	ldi	r24, 0x01	; 1
    9476:	ba 01       	movw	r22, r20
    9478:	a9 01       	movw	r20, r18
    947a:	0e 94 60 4c 	call	0x98c0	; 0x98c0 <freeMemoryUpdate>

 //File appended!
  return 0;
    947e:	80 e0       	ldi	r24, 0x00	; 0
    9480:	3c c1       	rjmp	.+632    	; 0x96fa <writeFile+0x6ca>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9482:	80 91 54 40 	lds	r24, 0x4054
    9486:	90 91 55 40 	lds	r25, 0x4055
    948a:	a0 91 56 40 	lds	r26, 0x4056
    948e:	b0 91 57 40 	lds	r27, 0x4057
    9492:	88 8b       	std	Y+16, r24	; 0x10
    9494:	99 8b       	std	Y+17, r25	; 0x11
    9496:	aa 8b       	std	Y+18, r26	; 0x12
    9498:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    949a:	88 89       	ldd	r24, Y+16	; 0x10
    949c:	99 89       	ldd	r25, Y+17	; 0x11
    949e:	aa 89       	ldd	r26, Y+18	; 0x12
    94a0:	bb 89       	ldd	r27, Y+19	; 0x13
    94a2:	bc 01       	movw	r22, r24
    94a4:	cd 01       	movw	r24, r26
    94a6:	0e 94 cc 42 	call	0x8598	; 0x8598 <getFirstSector>
    94aa:	dc 01       	movw	r26, r24
    94ac:	cb 01       	movw	r24, r22
    94ae:	8c a3       	lds	r24, 0x5c
    94b0:	9d a3       	lds	r25, 0x5d
    94b2:	ae a3       	lds	r26, 0x5e
    94b4:	bf a3       	lds	r27, 0x5f

   for(sector = 0; sector < sectorPerCluster; sector++)
    94b6:	1d 82       	std	Y+5, r1	; 0x05
    94b8:	ad c0       	rjmp	.+346    	; 0x9614 <writeFile+0x5e4>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    94ba:	8d 81       	ldd	r24, Y+5	; 0x05
    94bc:	28 2f       	mov	r18, r24
    94be:	30 e0       	ldi	r19, 0x00	; 0
    94c0:	40 e0       	ldi	r20, 0x00	; 0
    94c2:	50 e0       	ldi	r21, 0x00	; 0
    94c4:	8c a1       	lds	r24, 0x4c
    94c6:	9d a1       	lds	r25, 0x4d
    94c8:	ae a1       	lds	r26, 0x4e
    94ca:	bf a1       	lds	r27, 0x4f
    94cc:	82 0f       	add	r24, r18
    94ce:	93 1f       	adc	r25, r19
    94d0:	a4 1f       	adc	r26, r20
    94d2:	b5 1f       	adc	r27, r21
    94d4:	2b ec       	ldi	r18, 0xCB	; 203
    94d6:	31 e2       	ldi	r19, 0x21	; 33
    94d8:	bc 01       	movw	r22, r24
    94da:	cd 01       	movw	r24, r26
    94dc:	a9 01       	movw	r20, r18
    94de:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    94e2:	18 8e       	std	Y+24, r1	; 0x18
    94e4:	19 8e       	std	Y+25, r1	; 0x19
    94e6:	89 c0       	rjmp	.+274    	; 0x95fa <writeFile+0x5ca>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    94e8:	88 8d       	ldd	r24, Y+24	; 0x18
    94ea:	99 8d       	ldd	r25, Y+25	; 0x19
    94ec:	85 53       	subi	r24, 0x35	; 53
    94ee:	9e 4d       	sbci	r25, 0xDE	; 222
    94f0:	8e 8f       	std	Y+30, r24	; 0x1e
    94f2:	9f 8f       	std	Y+31, r25	; 0x1f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    94f4:	8a 81       	ldd	r24, Y+2	; 0x02
    94f6:	88 23       	and	r24, r24
    94f8:	11 f0       	breq	.+4      	; 0x94fe <writeFile+0x4ce>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    94fa:	80 e0       	ldi	r24, 0x00	; 0
    94fc:	fe c0       	rjmp	.+508    	; 0x96fa <writeFile+0x6ca>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    94fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9500:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9502:	fc 01       	movw	r30, r24
    9504:	80 81       	ld	r24, Z
    9506:	88 23       	and	r24, r24
    9508:	39 f0       	breq	.+14     	; 0x9518 <writeFile+0x4e8>
    950a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    950c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    950e:	fc 01       	movw	r30, r24
    9510:	80 81       	ld	r24, Z
    9512:	85 3e       	cpi	r24, 0xE5	; 229
    9514:	09 f0       	breq	.+2      	; 0x9518 <writeFile+0x4e8>
    9516:	6c c0       	rjmp	.+216    	; 0x95f0 <writeFile+0x5c0>
		{
		  for(j=0; j<11; j++)
    9518:	19 82       	std	Y+1, r1	; 0x01
    951a:	13 c0       	rjmp	.+38     	; 0x9542 <writeFile+0x512>
  			dir->name[j] = Filename[j];
    951c:	89 81       	ldd	r24, Y+1	; 0x01
    951e:	88 2f       	mov	r24, r24
    9520:	90 e0       	ldi	r25, 0x00	; 0
    9522:	29 81       	ldd	r18, Y+1	; 0x01
    9524:	22 2f       	mov	r18, r18
    9526:	30 e0       	ldi	r19, 0x00	; 0
    9528:	2e 54       	subi	r18, 0x4E	; 78
    952a:	3f 4a       	sbci	r19, 0xAF	; 175
    952c:	f9 01       	movw	r30, r18
    952e:	40 81       	ld	r20, Z
    9530:	2e 8d       	ldd	r18, Y+30	; 0x1e
    9532:	3f 8d       	ldd	r19, Y+31	; 0x1f
    9534:	82 0f       	add	r24, r18
    9536:	93 1f       	adc	r25, r19
    9538:	fc 01       	movw	r30, r24
    953a:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    953c:	89 81       	ldd	r24, Y+1	; 0x01
    953e:	8f 5f       	subi	r24, 0xFF	; 255
    9540:	89 83       	std	Y+1, r24	; 0x01
    9542:	89 81       	ldd	r24, Y+1	; 0x01
    9544:	8b 30       	cpi	r24, 0x0B	; 11
    9546:	50 f3       	brcs	.-44     	; 0x951c <writeFile+0x4ec>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    9548:	8e 8d       	ldd	r24, Y+30	; 0x1e
    954a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    954c:	20 e2       	ldi	r18, 0x20	; 32
    954e:	fc 01       	movw	r30, r24
    9550:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    9552:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9554:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9556:	fc 01       	movw	r30, r24
    9558:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    955a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    955c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    955e:	fc 01       	movw	r30, r24
    9560:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    9562:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9564:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9566:	fc 01       	movw	r30, r24
    9568:	12 8a       	std	Z+18, r1	; 0x12
    956a:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    956c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    956e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9570:	2e 81       	ldd	r18, Y+6	; 0x06
    9572:	3f 81       	ldd	r19, Y+7	; 0x07
    9574:	fc 01       	movw	r30, r24
    9576:	24 8b       	std	Z+20, r18	; 0x14
    9578:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    957a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    957c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    957e:	28 85       	ldd	r18, Y+8	; 0x08
    9580:	39 85       	ldd	r19, Y+9	; 0x09
    9582:	fc 01       	movw	r30, r24
    9584:	22 8f       	std	Z+26, r18	; 0x1a
    9586:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    9588:	80 91 45 40 	lds	r24, 0x4045
    958c:	90 91 46 40 	lds	r25, 0x4046
    9590:	a0 91 47 40 	lds	r26, 0x4047
    9594:	b0 91 48 40 	lds	r27, 0x4048
    9598:	2e 8d       	ldd	r18, Y+30	; 0x1e
    959a:	3f 8d       	ldd	r19, Y+31	; 0x1f
    959c:	f9 01       	movw	r30, r18
    959e:	84 8f       	std	Z+28, r24	; 0x1c
    95a0:	95 8f       	std	Z+29, r25	; 0x1d
    95a2:	a6 8f       	std	Z+30, r26	; 0x1e
    95a4:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    95a6:	8d 81       	ldd	r24, Y+5	; 0x05
    95a8:	28 2f       	mov	r18, r24
    95aa:	30 e0       	ldi	r19, 0x00	; 0
    95ac:	40 e0       	ldi	r20, 0x00	; 0
    95ae:	50 e0       	ldi	r21, 0x00	; 0
    95b0:	8c a1       	lds	r24, 0x4c
    95b2:	9d a1       	lds	r25, 0x4d
    95b4:	ae a1       	lds	r26, 0x4e
    95b6:	bf a1       	lds	r27, 0x4f
    95b8:	82 0f       	add	r24, r18
    95ba:	93 1f       	adc	r25, r19
    95bc:	a4 1f       	adc	r26, r20
    95be:	b5 1f       	adc	r27, r21
    95c0:	2b ec       	ldi	r18, 0xCB	; 203
    95c2:	31 e2       	ldi	r19, 0x21	; 33
    95c4:	bc 01       	movw	r22, r24
    95c6:	cd 01       	movw	r24, r26
    95c8:	a9 01       	movw	r20, r18
    95ca:	20 e0       	ldi	r18, 0x00	; 0
    95cc:	32 e0       	ldi	r19, 0x02	; 2
    95ce:	0e 94 c3 4f 	call	0x9f86	; 0x9f86 <SD_write_block>
		  fileCreatedFlag = 1;
    95d2:	81 e0       	ldi	r24, 0x01	; 1
    95d4:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    95d6:	20 91 45 40 	lds	r18, 0x4045
    95da:	30 91 46 40 	lds	r19, 0x4046
    95de:	40 91 47 40 	lds	r20, 0x4047
    95e2:	50 91 48 40 	lds	r21, 0x4048
    95e6:	81 e0       	ldi	r24, 0x01	; 1
    95e8:	ba 01       	movw	r22, r20
    95ea:	a9 01       	movw	r20, r18
    95ec:	0e 94 60 4c 	call	0x98c0	; 0x98c0 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    95f0:	88 8d       	ldd	r24, Y+24	; 0x18
    95f2:	99 8d       	ldd	r25, Y+25	; 0x19
    95f4:	80 96       	adiw	r24, 0x20	; 32
    95f6:	88 8f       	std	Y+24, r24	; 0x18
    95f8:	99 8f       	std	Y+25, r25	; 0x19
    95fa:	28 8d       	ldd	r18, Y+24	; 0x18
    95fc:	39 8d       	ldd	r19, Y+25	; 0x19
    95fe:	80 91 49 40 	lds	r24, 0x4049
    9602:	90 91 4a 40 	lds	r25, 0x404A
    9606:	28 17       	cp	r18, r24
    9608:	39 07       	cpc	r19, r25
    960a:	08 f4       	brcc	.+2      	; 0x960e <writeFile+0x5de>
    960c:	6d cf       	rjmp	.-294    	; 0x94e8 <writeFile+0x4b8>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    960e:	8d 81       	ldd	r24, Y+5	; 0x05
    9610:	8f 5f       	subi	r24, 0xFF	; 255
    9612:	8d 83       	std	Y+5, r24	; 0x05
    9614:	8d 81       	ldd	r24, Y+5	; 0x05
    9616:	28 2f       	mov	r18, r24
    9618:	30 e0       	ldi	r19, 0x00	; 0
    961a:	80 91 6c 50 	lds	r24, 0x506C
    961e:	90 91 6d 50 	lds	r25, 0x506D
    9622:	28 17       	cp	r18, r24
    9624:	39 07       	cpc	r19, r25
    9626:	08 f4       	brcc	.+2      	; 0x962a <writeFile+0x5fa>
    9628:	48 cf       	rjmp	.-368    	; 0x94ba <writeFile+0x48a>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    962a:	88 89       	ldd	r24, Y+16	; 0x10
    962c:	99 89       	ldd	r25, Y+17	; 0x11
    962e:	aa 89       	ldd	r26, Y+18	; 0x12
    9630:	bb 89       	ldd	r27, Y+19	; 0x13
    9632:	bc 01       	movw	r22, r24
    9634:	cd 01       	movw	r24, r26
    9636:	40 e0       	ldi	r20, 0x00	; 0
    9638:	00 e0       	ldi	r16, 0x00	; 0
    963a:	10 e0       	ldi	r17, 0x00	; 0
    963c:	98 01       	movw	r18, r16
    963e:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
    9642:	dc 01       	movw	r26, r24
    9644:	cb 01       	movw	r24, r22
    9646:	8c 87       	std	Y+12, r24	; 0x0c
    9648:	9d 87       	std	Y+13, r25	; 0x0d
    964a:	ae 87       	std	Y+14, r26	; 0x0e
    964c:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    964e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9650:	9d 85       	ldd	r25, Y+13	; 0x0d
    9652:	ae 85       	ldd	r26, Y+14	; 0x0e
    9654:	bf 85       	ldd	r27, Y+15	; 0x0f
    9656:	87 3f       	cpi	r24, 0xF7	; 247
    9658:	ff ef       	ldi	r31, 0xFF	; 255
    965a:	9f 07       	cpc	r25, r31
    965c:	ff ef       	ldi	r31, 0xFF	; 255
    965e:	af 07       	cpc	r26, r31
    9660:	ff e0       	ldi	r31, 0x0F	; 15
    9662:	bf 07       	cpc	r27, r31
    9664:	b8 f1       	brcs	.+110    	; 0x96d4 <writeFile+0x6a4>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    9666:	8c 85       	ldd	r24, Y+12	; 0x0c
    9668:	9d 85       	ldd	r25, Y+13	; 0x0d
    966a:	ae 85       	ldd	r26, Y+14	; 0x0e
    966c:	bf 85       	ldd	r27, Y+15	; 0x0f
    966e:	8f 3f       	cpi	r24, 0xFF	; 255
    9670:	0f ef       	ldi	r16, 0xFF	; 255
    9672:	90 07       	cpc	r25, r16
    9674:	0f ef       	ldi	r16, 0xFF	; 255
    9676:	a0 07       	cpc	r26, r16
    9678:	0f e0       	ldi	r16, 0x0F	; 15
    967a:	b0 07       	cpc	r27, r16
    967c:	49 f5       	brne	.+82     	; 0x96d0 <writeFile+0x6a0>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    967e:	88 89       	ldd	r24, Y+16	; 0x10
    9680:	99 89       	ldd	r25, Y+17	; 0x11
    9682:	aa 89       	ldd	r26, Y+18	; 0x12
    9684:	bb 89       	ldd	r27, Y+19	; 0x13
    9686:	bc 01       	movw	r22, r24
    9688:	cd 01       	movw	r24, r26
    968a:	0e 94 87 4b 	call	0x970e	; 0x970e <searchNextFreeCluster>
    968e:	dc 01       	movw	r26, r24
    9690:	cb 01       	movw	r24, r22
    9692:	8c 87       	std	Y+12, r24	; 0x0c
    9694:	9d 87       	std	Y+13, r25	; 0x0d
    9696:	ae 87       	std	Y+14, r26	; 0x0e
    9698:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    969a:	88 89       	ldd	r24, Y+16	; 0x10
    969c:	99 89       	ldd	r25, Y+17	; 0x11
    969e:	aa 89       	ldd	r26, Y+18	; 0x12
    96a0:	bb 89       	ldd	r27, Y+19	; 0x13
    96a2:	0c 85       	ldd	r16, Y+12	; 0x0c
    96a4:	1d 85       	ldd	r17, Y+13	; 0x0d
    96a6:	2e 85       	ldd	r18, Y+14	; 0x0e
    96a8:	3f 85       	ldd	r19, Y+15	; 0x0f
    96aa:	bc 01       	movw	r22, r24
    96ac:	cd 01       	movw	r24, r26
    96ae:	41 e0       	ldi	r20, 0x01	; 1
    96b0:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    96b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    96b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    96b8:	ae 85       	ldd	r26, Y+14	; 0x0e
    96ba:	bf 85       	ldd	r27, Y+15	; 0x0f
    96bc:	bc 01       	movw	r22, r24
    96be:	cd 01       	movw	r24, r26
    96c0:	41 e0       	ldi	r20, 0x01	; 1
    96c2:	0f ef       	ldi	r16, 0xFF	; 255
    96c4:	1f ef       	ldi	r17, 0xFF	; 255
    96c6:	2f ef       	ldi	r18, 0xFF	; 255
    96c8:	3f e0       	ldi	r19, 0x0F	; 15
    96ca:	0e 94 fe 42 	call	0x85fc	; 0x85fc <getSetNextCluster>
    96ce:	02 c0       	rjmp	.+4      	; 0x96d4 <writeFile+0x6a4>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    96d0:	83 e0       	ldi	r24, 0x03	; 3
    96d2:	13 c0       	rjmp	.+38     	; 0x96fa <writeFile+0x6ca>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    96d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    96d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    96d8:	ae 85       	ldd	r26, Y+14	; 0x0e
    96da:	bf 85       	ldd	r27, Y+15	; 0x0f
    96dc:	00 97       	sbiw	r24, 0x00	; 0
    96de:	a1 05       	cpc	r26, r1
    96e0:	b1 05       	cpc	r27, r1
    96e2:	11 f4       	brne	.+4      	; 0x96e8 <writeFile+0x6b8>
	   return 4;
    96e4:	84 e0       	ldi	r24, 0x04	; 4
    96e6:	09 c0       	rjmp	.+18     	; 0x96fa <writeFile+0x6ca>
	}
   
   prevCluster = cluster;
    96e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    96ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    96ec:	ae 85       	ldd	r26, Y+14	; 0x0e
    96ee:	bf 85       	ldd	r27, Y+15	; 0x0f
    96f0:	88 8b       	std	Y+16, r24	; 0x10
    96f2:	99 8b       	std	Y+17, r25	; 0x11
    96f4:	aa 8b       	std	Y+18, r26	; 0x12
    96f6:	bb 8b       	std	Y+19, r27	; 0x13
 }
    96f8:	d0 ce       	rjmp	.-608    	; 0x949a <writeFile+0x46a>
 
 return 0;
}
    96fa:	ad 96       	adiw	r28, 0x2d	; 45
    96fc:	cd bf       	out	0x3d, r28	; 61
    96fe:	de bf       	out	0x3e, r29	; 62
    9700:	df 91       	pop	r29
    9702:	cf 91       	pop	r28
    9704:	1f 91       	pop	r17
    9706:	0f 91       	pop	r16
    9708:	ff 90       	pop	r15
    970a:	ef 90       	pop	r14
    970c:	08 95       	ret

0000970e <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    970e:	ef 92       	push	r14
    9710:	ff 92       	push	r15
    9712:	0f 93       	push	r16
    9714:	1f 93       	push	r17
    9716:	cf 93       	push	r28
    9718:	df 93       	push	r29
    971a:	cd b7       	in	r28, 0x3d	; 61
    971c:	de b7       	in	r29, 0x3e	; 62
    971e:	2f 97       	sbiw	r28, 0x0f	; 15
    9720:	cd bf       	out	0x3d, r28	; 61
    9722:	de bf       	out	0x3e, r29	; 62
    9724:	6c 87       	std	Y+12, r22	; 0x0c
    9726:	7d 87       	std	Y+13, r23	; 0x0d
    9728:	8e 87       	std	Y+14, r24	; 0x0e
    972a:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    972c:	8c 85       	ldd	r24, Y+12	; 0x0c
    972e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9730:	ae 85       	ldd	r26, Y+14	; 0x0e
    9732:	bf 85       	ldd	r27, Y+15	; 0x0f
    9734:	80 78       	andi	r24, 0x80	; 128
    9736:	8c 87       	std	Y+12, r24	; 0x0c
    9738:	9d 87       	std	Y+13, r25	; 0x0d
    973a:	ae 87       	std	Y+14, r26	; 0x0e
    973c:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    973e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9740:	9d 85       	ldd	r25, Y+13	; 0x0d
    9742:	ae 85       	ldd	r26, Y+14	; 0x0e
    9744:	bf 85       	ldd	r27, Y+15	; 0x0f
    9746:	89 83       	std	Y+1, r24	; 0x01
    9748:	9a 83       	std	Y+2, r25	; 0x02
    974a:	ab 83       	std	Y+3, r26	; 0x03
    974c:	bc 83       	std	Y+4, r27	; 0x04
    974e:	7a c0       	rjmp	.+244    	; 0x9844 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9750:	80 91 74 50 	lds	r24, 0x5074
    9754:	90 91 75 50 	lds	r25, 0x5075
    9758:	9c 01       	movw	r18, r24
    975a:	40 e0       	ldi	r20, 0x00	; 0
    975c:	50 e0       	ldi	r21, 0x00	; 0
    975e:	80 91 6e 50 	lds	r24, 0x506E
    9762:	90 91 6f 50 	lds	r25, 0x506F
    9766:	a0 91 70 50 	lds	r26, 0x5070
    976a:	b0 91 71 50 	lds	r27, 0x5071
    976e:	79 01       	movw	r14, r18
    9770:	8a 01       	movw	r16, r20
    9772:	e8 0e       	add	r14, r24
    9774:	f9 1e       	adc	r15, r25
    9776:	0a 1f       	adc	r16, r26
    9778:	1b 1f       	adc	r17, r27
    977a:	89 81       	ldd	r24, Y+1	; 0x01
    977c:	9a 81       	ldd	r25, Y+2	; 0x02
    977e:	ab 81       	ldd	r26, Y+3	; 0x03
    9780:	bc 81       	ldd	r27, Y+4	; 0x04
    9782:	88 0f       	add	r24, r24
    9784:	99 1f       	adc	r25, r25
    9786:	aa 1f       	adc	r26, r26
    9788:	bb 1f       	adc	r27, r27
    978a:	88 0f       	add	r24, r24
    978c:	99 1f       	adc	r25, r25
    978e:	aa 1f       	adc	r26, r26
    9790:	bb 1f       	adc	r27, r27
    9792:	20 91 49 40 	lds	r18, 0x4049
    9796:	30 91 4a 40 	lds	r19, 0x404A
    979a:	99 01       	movw	r18, r18
    979c:	40 e0       	ldi	r20, 0x00	; 0
    979e:	50 e0       	ldi	r21, 0x00	; 0
    97a0:	bc 01       	movw	r22, r24
    97a2:	cd 01       	movw	r24, r26
    97a4:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    97a8:	da 01       	movw	r26, r20
    97aa:	c9 01       	movw	r24, r18
    97ac:	8e 0d       	add	r24, r14
    97ae:	9f 1d       	adc	r25, r15
    97b0:	a0 1f       	adc	r26, r16
    97b2:	b1 1f       	adc	r27, r17
    97b4:	8e 83       	std	Y+6, r24	; 0x06
    97b6:	9f 83       	std	Y+7, r25	; 0x07
    97b8:	a8 87       	std	Y+8, r26	; 0x08
    97ba:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    97bc:	8e 81       	ldd	r24, Y+6	; 0x06
    97be:	9f 81       	ldd	r25, Y+7	; 0x07
    97c0:	a8 85       	ldd	r26, Y+8	; 0x08
    97c2:	b9 85       	ldd	r27, Y+9	; 0x09
    97c4:	2b ec       	ldi	r18, 0xCB	; 203
    97c6:	31 e2       	ldi	r19, 0x21	; 33
    97c8:	bc 01       	movw	r22, r24
    97ca:	cd 01       	movw	r24, r26
    97cc:	a9 01       	movw	r20, r18
    97ce:	0e 94 91 50 	call	0xa122	; 0xa122 <SD_read_block>
      for(i=0; i<128; i++)
    97d2:	1d 82       	std	Y+5, r1	; 0x05
    97d4:	28 c0       	rjmp	.+80     	; 0x9826 <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    97d6:	8d 81       	ldd	r24, Y+5	; 0x05
    97d8:	88 2f       	mov	r24, r24
    97da:	90 e0       	ldi	r25, 0x00	; 0
    97dc:	88 0f       	add	r24, r24
    97de:	99 1f       	adc	r25, r25
    97e0:	88 0f       	add	r24, r24
    97e2:	99 1f       	adc	r25, r25
    97e4:	85 53       	subi	r24, 0x35	; 53
    97e6:	9e 4d       	sbci	r25, 0xDE	; 222
    97e8:	8a 87       	std	Y+10, r24	; 0x0a
    97ea:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    97ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    97ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    97f0:	fc 01       	movw	r30, r24
    97f2:	80 81       	ld	r24, Z
    97f4:	91 81       	ldd	r25, Z+1	; 0x01
    97f6:	a2 81       	ldd	r26, Z+2	; 0x02
    97f8:	b3 81       	ldd	r27, Z+3	; 0x03
    97fa:	bf 70       	andi	r27, 0x0F	; 15
    97fc:	00 97       	sbiw	r24, 0x00	; 0
    97fe:	a1 05       	cpc	r26, r1
    9800:	b1 05       	cpc	r27, r1
    9802:	71 f4       	brne	.+28     	; 0x9820 <searchNextFreeCluster+0x112>
            return(cluster+i);
    9804:	8d 81       	ldd	r24, Y+5	; 0x05
    9806:	28 2f       	mov	r18, r24
    9808:	30 e0       	ldi	r19, 0x00	; 0
    980a:	40 e0       	ldi	r20, 0x00	; 0
    980c:	50 e0       	ldi	r21, 0x00	; 0
    980e:	89 81       	ldd	r24, Y+1	; 0x01
    9810:	9a 81       	ldd	r25, Y+2	; 0x02
    9812:	ab 81       	ldd	r26, Y+3	; 0x03
    9814:	bc 81       	ldd	r27, Y+4	; 0x04
    9816:	82 0f       	add	r24, r18
    9818:	93 1f       	adc	r25, r19
    981a:	a4 1f       	adc	r26, r20
    981c:	b5 1f       	adc	r27, r21
    981e:	27 c0       	rjmp	.+78     	; 0x986e <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    9820:	8d 81       	ldd	r24, Y+5	; 0x05
    9822:	8f 5f       	subi	r24, 0xFF	; 255
    9824:	8d 83       	std	Y+5, r24	; 0x05
    9826:	8d 81       	ldd	r24, Y+5	; 0x05
    9828:	88 23       	and	r24, r24
    982a:	ac f6       	brge	.-86     	; 0x97d6 <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    982c:	89 81       	ldd	r24, Y+1	; 0x01
    982e:	9a 81       	ldd	r25, Y+2	; 0x02
    9830:	ab 81       	ldd	r26, Y+3	; 0x03
    9832:	bc 81       	ldd	r27, Y+4	; 0x04
    9834:	80 58       	subi	r24, 0x80	; 128
    9836:	9f 4f       	sbci	r25, 0xFF	; 255
    9838:	af 4f       	sbci	r26, 0xFF	; 255
    983a:	bf 4f       	sbci	r27, 0xFF	; 255
    983c:	89 83       	std	Y+1, r24	; 0x01
    983e:	9a 83       	std	Y+2, r25	; 0x02
    9840:	ab 83       	std	Y+3, r26	; 0x03
    9842:	bc 83       	std	Y+4, r27	; 0x04
    9844:	80 91 4e 40 	lds	r24, 0x404E
    9848:	90 91 4f 40 	lds	r25, 0x404F
    984c:	a0 91 50 40 	lds	r26, 0x4050
    9850:	b0 91 51 40 	lds	r27, 0x4051
    9854:	29 81       	ldd	r18, Y+1	; 0x01
    9856:	3a 81       	ldd	r19, Y+2	; 0x02
    9858:	4b 81       	ldd	r20, Y+3	; 0x03
    985a:	5c 81       	ldd	r21, Y+4	; 0x04
    985c:	28 17       	cp	r18, r24
    985e:	39 07       	cpc	r19, r25
    9860:	4a 07       	cpc	r20, r26
    9862:	5b 07       	cpc	r21, r27
    9864:	08 f4       	brcc	.+2      	; 0x9868 <searchNextFreeCluster+0x15a>
    9866:	74 cf       	rjmp	.-280    	; 0x9750 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    9868:	80 e0       	ldi	r24, 0x00	; 0
    986a:	90 e0       	ldi	r25, 0x00	; 0
    986c:	dc 01       	movw	r26, r24
}
    986e:	bc 01       	movw	r22, r24
    9870:	cd 01       	movw	r24, r26
    9872:	2f 96       	adiw	r28, 0x0f	; 15
    9874:	cd bf       	out	0x3d, r28	; 61
    9876:	de bf       	out	0x3e, r29	; 62
    9878:	df 91       	pop	r29
    987a:	cf 91       	pop	r28
    987c:	1f 91       	pop	r17
    987e:	0f 91       	pop	r16
    9880:	ff 90       	pop	r15
    9882:	ef 90       	pop	r14
    9884:	08 95       	ret

00009886 <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    9886:	cf 93       	push	r28
    9888:	df 93       	push	r29
    988a:	00 d0       	rcall	.+0      	; 0x988c <deleteFile+0x6>
    988c:	cd b7       	in	r28, 0x3d	; 61
    988e:	de b7       	in	r29, 0x3e	; 62
    9890:	8a 83       	std	Y+2, r24	; 0x02
    9892:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9894:	8a 81       	ldd	r24, Y+2	; 0x02
    9896:	9b 81       	ldd	r25, Y+3	; 0x03
    9898:	0e 94 e2 46 	call	0x8dc4	; 0x8dc4 <convertFileName>
    989c:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    989e:	89 81       	ldd	r24, Y+1	; 0x01
    98a0:	88 23       	and	r24, r24
    98a2:	39 f4       	brne	.+14     	; 0x98b2 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    98a4:	22 eb       	ldi	r18, 0xB2	; 178
    98a6:	30 e5       	ldi	r19, 0x50	; 80
    98a8:	82 e0       	ldi	r24, 0x02	; 2
    98aa:	b9 01       	movw	r22, r18
    98ac:	0e 94 59 44 	call	0x88b2	; 0x88b2 <findFiles>
    98b0:	01 c0       	rjmp	.+2      	; 0x98b4 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    98b2:	00 00       	nop

  findFiles (DELETE, Filename);
}
    98b4:	23 96       	adiw	r28, 0x03	; 3
    98b6:	cd bf       	out	0x3d, r28	; 61
    98b8:	de bf       	out	0x3e, r29	; 62
    98ba:	df 91       	pop	r29
    98bc:	cf 91       	pop	r28
    98be:	08 95       	ret

000098c0 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    98c0:	ef 92       	push	r14
    98c2:	ff 92       	push	r15
    98c4:	0f 93       	push	r16
    98c6:	1f 93       	push	r17
    98c8:	cf 93       	push	r28
    98ca:	df 93       	push	r29
    98cc:	cd b7       	in	r28, 0x3d	; 61
    98ce:	de b7       	in	r29, 0x3e	; 62
    98d0:	29 97       	sbiw	r28, 0x09	; 9
    98d2:	cd bf       	out	0x3d, r28	; 61
    98d4:	de bf       	out	0x3e, r29	; 62
    98d6:	8d 83       	std	Y+5, r24	; 0x05
    98d8:	4e 83       	std	Y+6, r20	; 0x06
    98da:	5f 83       	std	Y+7, r21	; 0x07
    98dc:	68 87       	std	Y+8, r22	; 0x08
    98de:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    98e0:	8e 81       	ldd	r24, Y+6	; 0x06
    98e2:	9f 81       	ldd	r25, Y+7	; 0x07
    98e4:	a8 85       	ldd	r26, Y+8	; 0x08
    98e6:	b9 85       	ldd	r27, Y+9	; 0x09
    98e8:	91 70       	andi	r25, 0x01	; 1
    98ea:	a0 70       	andi	r26, 0x00	; 0
    98ec:	b0 70       	andi	r27, 0x00	; 0
    98ee:	00 97       	sbiw	r24, 0x00	; 0
    98f0:	a1 05       	cpc	r26, r1
    98f2:	b1 05       	cpc	r27, r1
    98f4:	91 f4       	brne	.+36     	; 0x991a <freeMemoryUpdate+0x5a>
    98f6:	8e 81       	ldd	r24, Y+6	; 0x06
    98f8:	9f 81       	ldd	r25, Y+7	; 0x07
    98fa:	a8 85       	ldd	r26, Y+8	; 0x08
    98fc:	b9 85       	ldd	r27, Y+9	; 0x09
    98fe:	07 2e       	mov	r0, r23
    9900:	79 e0       	ldi	r23, 0x09	; 9
    9902:	b6 95       	lsr	r27
    9904:	a7 95       	ror	r26
    9906:	97 95       	ror	r25
    9908:	87 95       	ror	r24
    990a:	7a 95       	dec	r23
    990c:	d1 f7       	brne	.-12     	; 0x9902 <freeMemoryUpdate+0x42>
    990e:	70 2d       	mov	r23, r0
    9910:	8e 83       	std	Y+6, r24	; 0x06
    9912:	9f 83       	std	Y+7, r25	; 0x07
    9914:	a8 87       	std	Y+8, r26	; 0x08
    9916:	b9 87       	std	Y+9, r27	; 0x09
    9918:	14 c0       	rjmp	.+40     	; 0x9942 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    991a:	8e 81       	ldd	r24, Y+6	; 0x06
    991c:	9f 81       	ldd	r25, Y+7	; 0x07
    991e:	a8 85       	ldd	r26, Y+8	; 0x08
    9920:	b9 85       	ldd	r27, Y+9	; 0x09
    9922:	07 2e       	mov	r0, r23
    9924:	79 e0       	ldi	r23, 0x09	; 9
    9926:	b6 95       	lsr	r27
    9928:	a7 95       	ror	r26
    992a:	97 95       	ror	r25
    992c:	87 95       	ror	r24
    992e:	7a 95       	dec	r23
    9930:	d1 f7       	brne	.-12     	; 0x9926 <freeMemoryUpdate+0x66>
    9932:	70 2d       	mov	r23, r0
    9934:	01 96       	adiw	r24, 0x01	; 1
    9936:	a1 1d       	adc	r26, r1
    9938:	b1 1d       	adc	r27, r1
    993a:	8e 83       	std	Y+6, r24	; 0x06
    993c:	9f 83       	std	Y+7, r25	; 0x07
    993e:	a8 87       	std	Y+8, r26	; 0x08
    9940:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9942:	8e 81       	ldd	r24, Y+6	; 0x06
    9944:	9f 81       	ldd	r25, Y+7	; 0x07
    9946:	a8 85       	ldd	r26, Y+8	; 0x08
    9948:	b9 85       	ldd	r27, Y+9	; 0x09
    994a:	87 70       	andi	r24, 0x07	; 7
    994c:	90 70       	andi	r25, 0x00	; 0
    994e:	a0 70       	andi	r26, 0x00	; 0
    9950:	b0 70       	andi	r27, 0x00	; 0
    9952:	00 97       	sbiw	r24, 0x00	; 0
    9954:	a1 05       	cpc	r26, r1
    9956:	b1 05       	cpc	r27, r1
    9958:	89 f4       	brne	.+34     	; 0x997c <freeMemoryUpdate+0xbc>
    995a:	8e 81       	ldd	r24, Y+6	; 0x06
    995c:	9f 81       	ldd	r25, Y+7	; 0x07
    995e:	a8 85       	ldd	r26, Y+8	; 0x08
    9960:	b9 85       	ldd	r27, Y+9	; 0x09
    9962:	68 94       	set
    9964:	12 f8       	bld	r1, 2
    9966:	b6 95       	lsr	r27
    9968:	a7 95       	ror	r26
    996a:	97 95       	ror	r25
    996c:	87 95       	ror	r24
    996e:	16 94       	lsr	r1
    9970:	d1 f7       	brne	.-12     	; 0x9966 <freeMemoryUpdate+0xa6>
    9972:	8e 83       	std	Y+6, r24	; 0x06
    9974:	9f 83       	std	Y+7, r25	; 0x07
    9976:	a8 87       	std	Y+8, r26	; 0x08
    9978:	b9 87       	std	Y+9, r27	; 0x09
    997a:	13 c0       	rjmp	.+38     	; 0x99a2 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    997c:	8e 81       	ldd	r24, Y+6	; 0x06
    997e:	9f 81       	ldd	r25, Y+7	; 0x07
    9980:	a8 85       	ldd	r26, Y+8	; 0x08
    9982:	b9 85       	ldd	r27, Y+9	; 0x09
    9984:	68 94       	set
    9986:	12 f8       	bld	r1, 2
    9988:	b6 95       	lsr	r27
    998a:	a7 95       	ror	r26
    998c:	97 95       	ror	r25
    998e:	87 95       	ror	r24
    9990:	16 94       	lsr	r1
    9992:	d1 f7       	brne	.-12     	; 0x9988 <freeMemoryUpdate+0xc8>
    9994:	01 96       	adiw	r24, 0x01	; 1
    9996:	a1 1d       	adc	r26, r1
    9998:	b1 1d       	adc	r27, r1
    999a:	8e 83       	std	Y+6, r24	; 0x06
    999c:	9f 83       	std	Y+7, r25	; 0x07
    999e:	a8 87       	std	Y+8, r26	; 0x08
    99a0:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    99a2:	80 91 d5 50 	lds	r24, 0x50D5
    99a6:	88 23       	and	r24, r24
    99a8:	e9 f1       	breq	.+122    	; 0x9a24 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    99aa:	81 e0       	ldi	r24, 0x01	; 1
    99ac:	60 e0       	ldi	r22, 0x00	; 0
    99ae:	20 e0       	ldi	r18, 0x00	; 0
    99b0:	30 e0       	ldi	r19, 0x00	; 0
    99b2:	a9 01       	movw	r20, r18
    99b4:	0e 94 a8 43 	call	0x8750	; 0x8750 <getSetFreeCluster>
    99b8:	dc 01       	movw	r26, r24
    99ba:	cb 01       	movw	r24, r22
    99bc:	89 83       	std	Y+1, r24	; 0x01
    99be:	9a 83       	std	Y+2, r25	; 0x02
    99c0:	ab 83       	std	Y+3, r26	; 0x03
    99c2:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    99c4:	8d 81       	ldd	r24, Y+5	; 0x05
    99c6:	88 23       	and	r24, r24
    99c8:	89 f4       	brne	.+34     	; 0x99ec <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    99ca:	29 81       	ldd	r18, Y+1	; 0x01
    99cc:	3a 81       	ldd	r19, Y+2	; 0x02
    99ce:	4b 81       	ldd	r20, Y+3	; 0x03
    99d0:	5c 81       	ldd	r21, Y+4	; 0x04
    99d2:	8e 81       	ldd	r24, Y+6	; 0x06
    99d4:	9f 81       	ldd	r25, Y+7	; 0x07
    99d6:	a8 85       	ldd	r26, Y+8	; 0x08
    99d8:	b9 85       	ldd	r27, Y+9	; 0x09
    99da:	82 0f       	add	r24, r18
    99dc:	93 1f       	adc	r25, r19
    99de:	a4 1f       	adc	r26, r20
    99e0:	b5 1f       	adc	r27, r21
    99e2:	89 83       	std	Y+1, r24	; 0x01
    99e4:	9a 83       	std	Y+2, r25	; 0x02
    99e6:	ab 83       	std	Y+3, r26	; 0x03
    99e8:	bc 83       	std	Y+4, r27	; 0x04
    99ea:	14 c0       	rjmp	.+40     	; 0x9a14 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    99ec:	29 81       	ldd	r18, Y+1	; 0x01
    99ee:	3a 81       	ldd	r19, Y+2	; 0x02
    99f0:	4b 81       	ldd	r20, Y+3	; 0x03
    99f2:	5c 81       	ldd	r21, Y+4	; 0x04
    99f4:	8e 81       	ldd	r24, Y+6	; 0x06
    99f6:	9f 81       	ldd	r25, Y+7	; 0x07
    99f8:	a8 85       	ldd	r26, Y+8	; 0x08
    99fa:	b9 85       	ldd	r27, Y+9	; 0x09
    99fc:	79 01       	movw	r14, r18
    99fe:	8a 01       	movw	r16, r20
    9a00:	e8 1a       	sub	r14, r24
    9a02:	f9 0a       	sbc	r15, r25
    9a04:	0a 0b       	sbc	r16, r26
    9a06:	1b 0b       	sbc	r17, r27
    9a08:	d8 01       	movw	r26, r16
    9a0a:	c7 01       	movw	r24, r14
    9a0c:	89 83       	std	Y+1, r24	; 0x01
    9a0e:	9a 83       	std	Y+2, r25	; 0x02
    9a10:	ab 83       	std	Y+3, r26	; 0x03
    9a12:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9a14:	29 81       	ldd	r18, Y+1	; 0x01
    9a16:	3a 81       	ldd	r19, Y+2	; 0x02
    9a18:	4b 81       	ldd	r20, Y+3	; 0x03
    9a1a:	5c 81       	ldd	r21, Y+4	; 0x04
    9a1c:	81 e0       	ldi	r24, 0x01	; 1
    9a1e:	61 e0       	ldi	r22, 0x01	; 1
    9a20:	0e 94 a8 43 	call	0x8750	; 0x8750 <getSetFreeCluster>
  }
}
    9a24:	29 96       	adiw	r28, 0x09	; 9
    9a26:	cd bf       	out	0x3d, r28	; 61
    9a28:	de bf       	out	0x3e, r29	; 62
    9a2a:	df 91       	pop	r29
    9a2c:	cf 91       	pop	r28
    9a2e:	1f 91       	pop	r17
    9a30:	0f 91       	pop	r16
    9a32:	ff 90       	pop	r15
    9a34:	ef 90       	pop	r14
    9a36:	08 95       	ret

00009a38 <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    9a38:	0f 93       	push	r16
    9a3a:	1f 93       	push	r17
    9a3c:	cf 93       	push	r28
    9a3e:	df 93       	push	r29
    9a40:	cd b7       	in	r28, 0x3d	; 61
    9a42:	de b7       	in	r29, 0x3e	; 62
    9a44:	a9 97       	sbiw	r28, 0x29	; 41
    9a46:	cd bf       	out	0x3d, r28	; 61
    9a48:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    9a4a:	81 e0       	ldi	r24, 0x01	; 1
    9a4c:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9a50:	81 e0       	ldi	r24, 0x01	; 1
    9a52:	0e 94 ba 36 	call	0x6d74	; 0x6d74 <Ext1Power>
    9a56:	80 e0       	ldi	r24, 0x00	; 0
    9a58:	90 e0       	ldi	r25, 0x00	; 0
    9a5a:	a8 ec       	ldi	r26, 0xC8	; 200
    9a5c:	b2 e4       	ldi	r27, 0x42	; 66
    9a5e:	8e 87       	std	Y+14, r24	; 0x0e
    9a60:	9f 87       	std	Y+15, r25	; 0x0f
    9a62:	a8 8b       	std	Y+16, r26	; 0x10
    9a64:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9a66:	6e 85       	ldd	r22, Y+14	; 0x0e
    9a68:	7f 85       	ldd	r23, Y+15	; 0x0f
    9a6a:	88 89       	ldd	r24, Y+16	; 0x10
    9a6c:	99 89       	ldd	r25, Y+17	; 0x11
    9a6e:	20 e0       	ldi	r18, 0x00	; 0
    9a70:	30 e0       	ldi	r19, 0x00	; 0
    9a72:	4a ef       	ldi	r20, 0xFA	; 250
    9a74:	55 e4       	ldi	r21, 0x45	; 69
    9a76:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    9a7a:	dc 01       	movw	r26, r24
    9a7c:	cb 01       	movw	r24, r22
    9a7e:	8a 8b       	std	Y+18, r24	; 0x12
    9a80:	9b 8b       	std	Y+19, r25	; 0x13
    9a82:	ac 8b       	std	Y+20, r26	; 0x14
    9a84:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9a86:	11 e0       	ldi	r17, 0x01	; 1
    9a88:	6a 89       	ldd	r22, Y+18	; 0x12
    9a8a:	7b 89       	ldd	r23, Y+19	; 0x13
    9a8c:	8c 89       	ldd	r24, Y+20	; 0x14
    9a8e:	9d 89       	ldd	r25, Y+21	; 0x15
    9a90:	20 e0       	ldi	r18, 0x00	; 0
    9a92:	30 e0       	ldi	r19, 0x00	; 0
    9a94:	40 e8       	ldi	r20, 0x80	; 128
    9a96:	5f e3       	ldi	r21, 0x3F	; 63
    9a98:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    9a9c:	88 23       	and	r24, r24
    9a9e:	0c f0       	brlt	.+2      	; 0x9aa2 <SD_init+0x6a>
    9aa0:	10 e0       	ldi	r17, 0x00	; 0
    9aa2:	11 23       	and	r17, r17
    9aa4:	29 f0       	breq	.+10     	; 0x9ab0 <SD_init+0x78>
		__ticks = 1;
    9aa6:	81 e0       	ldi	r24, 0x01	; 1
    9aa8:	90 e0       	ldi	r25, 0x00	; 0
    9aaa:	8e 8b       	std	Y+22, r24	; 0x16
    9aac:	9f 8b       	std	Y+23, r25	; 0x17
    9aae:	46 c0       	rjmp	.+140    	; 0x9b3c <SD_init+0x104>
	else if (__tmp > 65535)
    9ab0:	11 e0       	ldi	r17, 0x01	; 1
    9ab2:	6a 89       	ldd	r22, Y+18	; 0x12
    9ab4:	7b 89       	ldd	r23, Y+19	; 0x13
    9ab6:	8c 89       	ldd	r24, Y+20	; 0x14
    9ab8:	9d 89       	ldd	r25, Y+21	; 0x15
    9aba:	20 e0       	ldi	r18, 0x00	; 0
    9abc:	3f ef       	ldi	r19, 0xFF	; 255
    9abe:	4f e7       	ldi	r20, 0x7F	; 127
    9ac0:	57 e4       	ldi	r21, 0x47	; 71
    9ac2:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    9ac6:	18 16       	cp	r1, r24
    9ac8:	0c f0       	brlt	.+2      	; 0x9acc <SD_init+0x94>
    9aca:	10 e0       	ldi	r17, 0x00	; 0
    9acc:	11 23       	and	r17, r17
    9ace:	61 f1       	breq	.+88     	; 0x9b28 <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9ad0:	6e 85       	ldd	r22, Y+14	; 0x0e
    9ad2:	7f 85       	ldd	r23, Y+15	; 0x0f
    9ad4:	88 89       	ldd	r24, Y+16	; 0x10
    9ad6:	99 89       	ldd	r25, Y+17	; 0x11
    9ad8:	20 e0       	ldi	r18, 0x00	; 0
    9ada:	30 e0       	ldi	r19, 0x00	; 0
    9adc:	40 e2       	ldi	r20, 0x20	; 32
    9ade:	51 e4       	ldi	r21, 0x41	; 65
    9ae0:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    9ae4:	dc 01       	movw	r26, r24
    9ae6:	cb 01       	movw	r24, r22
    9ae8:	bc 01       	movw	r22, r24
    9aea:	cd 01       	movw	r24, r26
    9aec:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    9af0:	dc 01       	movw	r26, r24
    9af2:	cb 01       	movw	r24, r22
    9af4:	8e 8b       	std	Y+22, r24	; 0x16
    9af6:	9f 8b       	std	Y+23, r25	; 0x17
    9af8:	12 c0       	rjmp	.+36     	; 0x9b1e <SD_init+0xe6>
    9afa:	80 e2       	ldi	r24, 0x20	; 32
    9afc:	93 e0       	ldi	r25, 0x03	; 3
    9afe:	88 8f       	std	Y+24, r24	; 0x18
    9b00:	99 8f       	std	Y+25, r25	; 0x19
    9b02:	88 8d       	ldd	r24, Y+24	; 0x18
    9b04:	99 8d       	ldd	r25, Y+25	; 0x19
    9b06:	8c 01       	movw	r16, r24
    9b08:	c8 01       	movw	r24, r16
    9b0a:	01 97       	sbiw	r24, 0x01	; 1
    9b0c:	f1 f7       	brne	.-4      	; 0x9b0a <SD_init+0xd2>
    9b0e:	8c 01       	movw	r16, r24
    9b10:	08 8f       	std	Y+24, r16	; 0x18
    9b12:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9b14:	8e 89       	ldd	r24, Y+22	; 0x16
    9b16:	9f 89       	ldd	r25, Y+23	; 0x17
    9b18:	01 97       	sbiw	r24, 0x01	; 1
    9b1a:	8e 8b       	std	Y+22, r24	; 0x16
    9b1c:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9b1e:	8e 89       	ldd	r24, Y+22	; 0x16
    9b20:	9f 89       	ldd	r25, Y+23	; 0x17
    9b22:	00 97       	sbiw	r24, 0x00	; 0
    9b24:	51 f7       	brne	.-44     	; 0x9afa <SD_init+0xc2>
    9b26:	17 c0       	rjmp	.+46     	; 0x9b56 <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9b28:	6a 89       	ldd	r22, Y+18	; 0x12
    9b2a:	7b 89       	ldd	r23, Y+19	; 0x13
    9b2c:	8c 89       	ldd	r24, Y+20	; 0x14
    9b2e:	9d 89       	ldd	r25, Y+21	; 0x15
    9b30:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    9b34:	dc 01       	movw	r26, r24
    9b36:	cb 01       	movw	r24, r22
    9b38:	8e 8b       	std	Y+22, r24	; 0x16
    9b3a:	9f 8b       	std	Y+23, r25	; 0x17
    9b3c:	8e 89       	ldd	r24, Y+22	; 0x16
    9b3e:	9f 89       	ldd	r25, Y+23	; 0x17
    9b40:	8a 8f       	std	Y+26, r24	; 0x1a
    9b42:	9b 8f       	std	Y+27, r25	; 0x1b
    9b44:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9b46:	9b 8d       	ldd	r25, Y+27	; 0x1b
    9b48:	8c 01       	movw	r16, r24
    9b4a:	f8 01       	movw	r30, r16
    9b4c:	31 97       	sbiw	r30, 0x01	; 1
    9b4e:	f1 f7       	brne	.-4      	; 0x9b4c <SD_init+0x114>
    9b50:	8f 01       	movw	r16, r30
    9b52:	0a 8f       	std	Y+26, r16	; 0x1a
    9b54:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9b56:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    9b58:	88 e0       	ldi	r24, 0x08	; 8
    9b5a:	60 e0       	ldi	r22, 0x00	; 0
    9b5c:	0e 94 24 35 	call	0x6a48	; 0x6a48 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9b60:	88 e0       	ldi	r24, 0x08	; 8
    9b62:	60 e0       	ldi	r22, 0x00	; 0
    9b64:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9b68:	80 e0       	ldi	r24, 0x00	; 0
    9b6a:	90 e0       	ldi	r25, 0x00	; 0
    9b6c:	63 e0       	ldi	r22, 0x03	; 3
    9b6e:	70 e0       	ldi	r23, 0x00	; 0
    9b70:	0e 94 e8 39 	call	0x73d0	; 0x73d0 <SPIInit2>
	SPICS(TRUE);
    9b74:	81 e0       	ldi	r24, 0x01	; 1
    9b76:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9b7a:	1a 82       	std	Y+2, r1	; 0x02
    9b7c:	1b 82       	std	Y+3, r1	; 0x03
    9b7e:	17 c0       	rjmp	.+46     	; 0x9bae <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9b80:	80 ec       	ldi	r24, 0xC0	; 192
    9b82:	98 e0       	ldi	r25, 0x08	; 8
    9b84:	2f ef       	ldi	r18, 0xFF	; 255
    9b86:	fc 01       	movw	r30, r24
    9b88:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9b8a:	00 00       	nop
    9b8c:	80 ec       	ldi	r24, 0xC0	; 192
    9b8e:	98 e0       	ldi	r25, 0x08	; 8
    9b90:	fc 01       	movw	r30, r24
    9b92:	82 81       	ldd	r24, Z+2	; 0x02
    9b94:	88 23       	and	r24, r24
    9b96:	d4 f7       	brge	.-12     	; 0x9b8c <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    9b98:	80 ec       	ldi	r24, 0xC0	; 192
    9b9a:	98 e0       	ldi	r25, 0x08	; 8
    9b9c:	fc 01       	movw	r30, r24
    9b9e:	83 81       	ldd	r24, Z+3	; 0x03
    9ba0:	80 93 ab 50 	sts	0x50AB, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    9ba6:	9b 81       	ldd	r25, Y+3	; 0x03
    9ba8:	01 96       	adiw	r24, 0x01	; 1
    9baa:	8a 83       	std	Y+2, r24	; 0x02
    9bac:	9b 83       	std	Y+3, r25	; 0x03
    9bae:	8a 81       	ldd	r24, Y+2	; 0x02
    9bb0:	9b 81       	ldd	r25, Y+3	; 0x03
    9bb2:	8a 30       	cpi	r24, 0x0A	; 10
    9bb4:	91 05       	cpc	r25, r1
    9bb6:	24 f3       	brlt	.-56     	; 0x9b80 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    9bb8:	80 e0       	ldi	r24, 0x00	; 0
    9bba:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    9bbe:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9bc2:	88 e0       	ldi	r24, 0x08	; 8
    9bc4:	60 e0       	ldi	r22, 0x00	; 0
    9bc6:	0e 94 53 36 	call	0x6ca6	; 0x6ca6 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9bca:	80 e0       	ldi	r24, 0x00	; 0
    9bcc:	90 e0       	ldi	r25, 0x00	; 0
    9bce:	63 e0       	ldi	r22, 0x03	; 3
    9bd0:	70 e0       	ldi	r23, 0x00	; 0
    9bd2:	0e 94 e8 39 	call	0x73d0	; 0x73d0 <SPIInit2>
	SPICS(TRUE);
    9bd6:	81 e0       	ldi	r24, 0x01	; 1
    9bd8:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9bdc:	1c 82       	std	Y+4, r1	; 0x04
    9bde:	1d 82       	std	Y+5, r1	; 0x05
    9be0:	0d c0       	rjmp	.+26     	; 0x9bfc <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    9be2:	8c 81       	ldd	r24, Y+4	; 0x04
    9be4:	9d 81       	ldd	r25, Y+5	; 0x05
    9be6:	8a 30       	cpi	r24, 0x0A	; 10
    9be8:	91 05       	cpc	r25, r1
    9bea:	1c f0       	brlt	.+6      	; 0x9bf2 <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    9bec:	81 e0       	ldi	r24, 0x01	; 1
    9bee:	89 83       	std	Y+1, r24	; 0x01
			break;
    9bf0:	10 c0       	rjmp	.+32     	; 0x9c12 <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9bf2:	8c 81       	ldd	r24, Y+4	; 0x04
    9bf4:	9d 81       	ldd	r25, Y+5	; 0x05
    9bf6:	01 96       	adiw	r24, 0x01	; 1
    9bf8:	8c 83       	std	Y+4, r24	; 0x04
    9bfa:	9d 83       	std	Y+5, r25	; 0x05
    9bfc:	80 e0       	ldi	r24, 0x00	; 0
    9bfe:	40 e0       	ldi	r20, 0x00	; 0
    9c00:	50 e0       	ldi	r21, 0x00	; 0
    9c02:	ba 01       	movw	r22, r20
    9c04:	25 e9       	ldi	r18, 0x95	; 149
    9c06:	08 e0       	ldi	r16, 0x08	; 8
    9c08:	10 e0       	ldi	r17, 0x00	; 0
    9c0a:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
    9c0e:	81 30       	cpi	r24, 0x01	; 1
    9c10:	41 f7       	brne	.-48     	; 0x9be2 <SD_init+0x1aa>
    9c12:	80 e0       	ldi	r24, 0x00	; 0
    9c14:	90 e0       	ldi	r25, 0x00	; 0
    9c16:	a8 ec       	ldi	r26, 0xC8	; 200
    9c18:	b2 e4       	ldi	r27, 0x42	; 66
    9c1a:	8c 8f       	std	Y+28, r24	; 0x1c
    9c1c:	9d 8f       	std	Y+29, r25	; 0x1d
    9c1e:	ae 8f       	std	Y+30, r26	; 0x1e
    9c20:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9c22:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9c24:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9c26:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9c28:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9c2a:	20 e0       	ldi	r18, 0x00	; 0
    9c2c:	30 e0       	ldi	r19, 0x00	; 0
    9c2e:	4a ef       	ldi	r20, 0xFA	; 250
    9c30:	55 e4       	ldi	r21, 0x45	; 69
    9c32:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    9c36:	dc 01       	movw	r26, r24
    9c38:	cb 01       	movw	r24, r22
    9c3a:	88 a3       	lds	r24, 0x58
    9c3c:	99 a3       	lds	r25, 0x59
    9c3e:	aa a3       	lds	r26, 0x5a
    9c40:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    9c42:	11 e0       	ldi	r17, 0x01	; 1
    9c44:	68 a1       	lds	r22, 0x48
    9c46:	79 a1       	lds	r23, 0x49
    9c48:	8a a1       	lds	r24, 0x4a
    9c4a:	9b a1       	lds	r25, 0x4b
    9c4c:	20 e0       	ldi	r18, 0x00	; 0
    9c4e:	30 e0       	ldi	r19, 0x00	; 0
    9c50:	40 e8       	ldi	r20, 0x80	; 128
    9c52:	5f e3       	ldi	r21, 0x3F	; 63
    9c54:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__cmpsf2>
    9c58:	88 23       	and	r24, r24
    9c5a:	0c f0       	brlt	.+2      	; 0x9c5e <SD_init+0x226>
    9c5c:	10 e0       	ldi	r17, 0x00	; 0
    9c5e:	11 23       	and	r17, r17
    9c60:	29 f0       	breq	.+10     	; 0x9c6c <SD_init+0x234>
		__ticks = 1;
    9c62:	81 e0       	ldi	r24, 0x01	; 1
    9c64:	90 e0       	ldi	r25, 0x00	; 0
    9c66:	8c a3       	lds	r24, 0x5c
    9c68:	9d a3       	lds	r25, 0x5d
    9c6a:	46 c0       	rjmp	.+140    	; 0x9cf8 <SD_init+0x2c0>
	else if (__tmp > 65535)
    9c6c:	11 e0       	ldi	r17, 0x01	; 1
    9c6e:	68 a1       	lds	r22, 0x48
    9c70:	79 a1       	lds	r23, 0x49
    9c72:	8a a1       	lds	r24, 0x4a
    9c74:	9b a1       	lds	r25, 0x4b
    9c76:	20 e0       	ldi	r18, 0x00	; 0
    9c78:	3f ef       	ldi	r19, 0xFF	; 255
    9c7a:	4f e7       	ldi	r20, 0x7F	; 127
    9c7c:	57 e4       	ldi	r21, 0x47	; 71
    9c7e:	0e 94 f8 5d 	call	0xbbf0	; 0xbbf0 <__gesf2>
    9c82:	18 16       	cp	r1, r24
    9c84:	0c f0       	brlt	.+2      	; 0x9c88 <SD_init+0x250>
    9c86:	10 e0       	ldi	r17, 0x00	; 0
    9c88:	11 23       	and	r17, r17
    9c8a:	61 f1       	breq	.+88     	; 0x9ce4 <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9c8c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9c8e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9c90:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9c92:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9c94:	20 e0       	ldi	r18, 0x00	; 0
    9c96:	30 e0       	ldi	r19, 0x00	; 0
    9c98:	40 e2       	ldi	r20, 0x20	; 32
    9c9a:	51 e4       	ldi	r21, 0x41	; 65
    9c9c:	0e 94 fc 5d 	call	0xbbf8	; 0xbbf8 <__mulsf3>
    9ca0:	dc 01       	movw	r26, r24
    9ca2:	cb 01       	movw	r24, r22
    9ca4:	bc 01       	movw	r22, r24
    9ca6:	cd 01       	movw	r24, r26
    9ca8:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    9cac:	dc 01       	movw	r26, r24
    9cae:	cb 01       	movw	r24, r22
    9cb0:	8c a3       	lds	r24, 0x5c
    9cb2:	9d a3       	lds	r25, 0x5d
    9cb4:	12 c0       	rjmp	.+36     	; 0x9cda <SD_init+0x2a2>
    9cb6:	80 e2       	ldi	r24, 0x20	; 32
    9cb8:	93 e0       	ldi	r25, 0x03	; 3
    9cba:	8e a3       	lds	r24, 0x5e
    9cbc:	9f a3       	lds	r25, 0x5f
    9cbe:	8e a1       	lds	r24, 0x4e
    9cc0:	9f a1       	lds	r25, 0x4f
    9cc2:	8c 01       	movw	r16, r24
    9cc4:	c8 01       	movw	r24, r16
    9cc6:	01 97       	sbiw	r24, 0x01	; 1
    9cc8:	f1 f7       	brne	.-4      	; 0x9cc6 <SD_init+0x28e>
    9cca:	8c 01       	movw	r16, r24
    9ccc:	0e a3       	lds	r16, 0x5e
    9cce:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9cd0:	8c a1       	lds	r24, 0x4c
    9cd2:	9d a1       	lds	r25, 0x4d
    9cd4:	01 97       	sbiw	r24, 0x01	; 1
    9cd6:	8c a3       	lds	r24, 0x5c
    9cd8:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9cda:	8c a1       	lds	r24, 0x4c
    9cdc:	9d a1       	lds	r25, 0x4d
    9cde:	00 97       	sbiw	r24, 0x00	; 0
    9ce0:	51 f7       	brne	.-44     	; 0x9cb6 <SD_init+0x27e>
    9ce2:	17 c0       	rjmp	.+46     	; 0x9d12 <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9ce4:	68 a1       	lds	r22, 0x48
    9ce6:	79 a1       	lds	r23, 0x49
    9ce8:	8a a1       	lds	r24, 0x4a
    9cea:	9b a1       	lds	r25, 0x4b
    9cec:	0e 94 57 5d 	call	0xbaae	; 0xbaae <__fixunssfsi>
    9cf0:	dc 01       	movw	r26, r24
    9cf2:	cb 01       	movw	r24, r22
    9cf4:	8c a3       	lds	r24, 0x5c
    9cf6:	9d a3       	lds	r25, 0x5d
    9cf8:	8c a1       	lds	r24, 0x4c
    9cfa:	9d a1       	lds	r25, 0x4d
    9cfc:	88 a7       	lds	r24, 0x78
    9cfe:	99 a7       	lds	r25, 0x79
    9d00:	88 a5       	lds	r24, 0x68
    9d02:	99 a5       	lds	r25, 0x69
    9d04:	8c 01       	movw	r16, r24
    9d06:	f8 01       	movw	r30, r16
    9d08:	31 97       	sbiw	r30, 0x01	; 1
    9d0a:	f1 f7       	brne	.-4      	; 0x9d08 <SD_init+0x2d0>
    9d0c:	8f 01       	movw	r16, r30
    9d0e:	08 a7       	lds	r16, 0x78
    9d10:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9d12:	1e 82       	std	Y+6, r1	; 0x06
    9d14:	1f 82       	std	Y+7, r1	; 0x07
    9d16:	0d c0       	rjmp	.+26     	; 0x9d32 <SD_init+0x2fa>
		if (i >= 10) {
    9d18:	8e 81       	ldd	r24, Y+6	; 0x06
    9d1a:	9f 81       	ldd	r25, Y+7	; 0x07
    9d1c:	8a 30       	cpi	r24, 0x0A	; 10
    9d1e:	91 05       	cpc	r25, r1
    9d20:	1c f0       	brlt	.+6      	; 0x9d28 <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    9d22:	81 e0       	ldi	r24, 0x01	; 1
    9d24:	89 83       	std	Y+1, r24	; 0x01
			break;
    9d26:	11 c0       	rjmp	.+34     	; 0x9d4a <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9d28:	8e 81       	ldd	r24, Y+6	; 0x06
    9d2a:	9f 81       	ldd	r25, Y+7	; 0x07
    9d2c:	01 96       	adiw	r24, 0x01	; 1
    9d2e:	8e 83       	std	Y+6, r24	; 0x06
    9d30:	9f 83       	std	Y+7, r25	; 0x07
    9d32:	88 e0       	ldi	r24, 0x08	; 8
    9d34:	4a ea       	ldi	r20, 0xAA	; 170
    9d36:	51 e0       	ldi	r21, 0x01	; 1
    9d38:	60 e0       	ldi	r22, 0x00	; 0
    9d3a:	70 e0       	ldi	r23, 0x00	; 0
    9d3c:	27 e8       	ldi	r18, 0x87	; 135
    9d3e:	08 e0       	ldi	r16, 0x08	; 8
    9d40:	10 e0       	ldi	r17, 0x00	; 0
    9d42:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
    9d46:	81 30       	cpi	r24, 0x01	; 1
    9d48:	39 f7       	brne	.-50     	; 0x9d18 <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9d4a:	18 86       	std	Y+8, r1	; 0x08
    9d4c:	19 86       	std	Y+9, r1	; 0x09
    9d4e:	13 c0       	rjmp	.+38     	; 0x9d76 <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9d50:	88 85       	ldd	r24, Y+8	; 0x08
    9d52:	99 85       	ldd	r25, Y+9	; 0x09
    9d54:	8c 01       	movw	r16, r24
    9d56:	0e 5f       	subi	r16, 0xFE	; 254
    9d58:	1f 4f       	sbci	r17, 0xFF	; 255
    9d5a:	8f ef       	ldi	r24, 0xFF	; 255
    9d5c:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    9d60:	28 2f       	mov	r18, r24
    9d62:	c8 01       	movw	r24, r16
    9d64:	81 56       	subi	r24, 0x61	; 97
    9d66:	9f 4a       	sbci	r25, 0xAF	; 175
    9d68:	fc 01       	movw	r30, r24
    9d6a:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9d6c:	88 85       	ldd	r24, Y+8	; 0x08
    9d6e:	99 85       	ldd	r25, Y+9	; 0x09
    9d70:	01 96       	adiw	r24, 0x01	; 1
    9d72:	88 87       	std	Y+8, r24	; 0x08
    9d74:	99 87       	std	Y+9, r25	; 0x09
    9d76:	88 85       	ldd	r24, Y+8	; 0x08
    9d78:	99 85       	ldd	r25, Y+9	; 0x09
    9d7a:	84 30       	cpi	r24, 0x04	; 4
    9d7c:	91 05       	cpc	r25, r1
    9d7e:	44 f3       	brlt	.-48     	; 0x9d50 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9d80:	80 91 a3 50 	lds	r24, 0x50A3
    9d84:	81 30       	cpi	r24, 0x01	; 1
    9d86:	21 f4       	brne	.+8      	; 0x9d90 <SD_init+0x358>
    9d88:	80 91 a4 50 	lds	r24, 0x50A4
    9d8c:	8a 3a       	cpi	r24, 0xAA	; 170
    9d8e:	11 f0       	breq	.+4      	; 0x9d94 <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9d90:	81 e0       	ldi	r24, 0x01	; 1
    9d92:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9d94:	87 e3       	ldi	r24, 0x37	; 55
    9d96:	40 e0       	ldi	r20, 0x00	; 0
    9d98:	50 e0       	ldi	r21, 0x00	; 0
    9d9a:	ba 01       	movw	r22, r20
    9d9c:	2f ef       	ldi	r18, 0xFF	; 255
    9d9e:	08 e0       	ldi	r16, 0x08	; 8
    9da0:	10 e0       	ldi	r17, 0x00	; 0
    9da2:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9da6:	81 e0       	ldi	r24, 0x01	; 1
    9da8:	40 e0       	ldi	r20, 0x00	; 0
    9daa:	50 e0       	ldi	r21, 0x00	; 0
    9dac:	60 e0       	ldi	r22, 0x00	; 0
    9dae:	70 e4       	ldi	r23, 0x40	; 64
    9db0:	2f ef       	ldi	r18, 0xFF	; 255
    9db2:	08 e0       	ldi	r16, 0x08	; 8
    9db4:	10 e0       	ldi	r17, 0x00	; 0
    9db6:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
	} while(Buffer[1]!= 0x00);
    9dba:	80 91 a0 50 	lds	r24, 0x50A0
    9dbe:	88 23       	and	r24, r24
    9dc0:	49 f7       	brne	.-46     	; 0x9d94 <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9dc2:	1a 86       	std	Y+10, r1	; 0x0a
    9dc4:	1b 86       	std	Y+11, r1	; 0x0b
    9dc6:	0d c0       	rjmp	.+26     	; 0x9de2 <SD_init+0x3aa>
		if (i >= 10) {
    9dc8:	8a 85       	ldd	r24, Y+10	; 0x0a
    9dca:	9b 85       	ldd	r25, Y+11	; 0x0b
    9dcc:	8a 30       	cpi	r24, 0x0A	; 10
    9dce:	91 05       	cpc	r25, r1
    9dd0:	1c f0       	brlt	.+6      	; 0x9dd8 <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    9dd2:	81 e0       	ldi	r24, 0x01	; 1
    9dd4:	89 83       	std	Y+1, r24	; 0x01
			break;
    9dd6:	10 c0       	rjmp	.+32     	; 0x9df8 <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9dd8:	8a 85       	ldd	r24, Y+10	; 0x0a
    9dda:	9b 85       	ldd	r25, Y+11	; 0x0b
    9ddc:	01 96       	adiw	r24, 0x01	; 1
    9dde:	8a 87       	std	Y+10, r24	; 0x0a
    9de0:	9b 87       	std	Y+11, r25	; 0x0b
    9de2:	8a e3       	ldi	r24, 0x3A	; 58
    9de4:	40 e0       	ldi	r20, 0x00	; 0
    9de6:	50 e0       	ldi	r21, 0x00	; 0
    9de8:	ba 01       	movw	r22, r20
    9dea:	2f ef       	ldi	r18, 0xFF	; 255
    9dec:	08 e0       	ldi	r16, 0x08	; 8
    9dee:	10 e0       	ldi	r17, 0x00	; 0
    9df0:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
    9df4:	88 23       	and	r24, r24
    9df6:	41 f7       	brne	.-48     	; 0x9dc8 <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9df8:	1c 86       	std	Y+12, r1	; 0x0c
    9dfa:	1d 86       	std	Y+13, r1	; 0x0d
    9dfc:	0f c0       	rjmp	.+30     	; 0x9e1c <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9dfe:	8f ef       	ldi	r24, 0xFF	; 255
    9e00:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    9e04:	28 2f       	mov	r18, r24
    9e06:	8c 85       	ldd	r24, Y+12	; 0x0c
    9e08:	9d 85       	ldd	r25, Y+13	; 0x0d
    9e0a:	81 56       	subi	r24, 0x61	; 97
    9e0c:	9f 4a       	sbci	r25, 0xAF	; 175
    9e0e:	fc 01       	movw	r30, r24
    9e10:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9e12:	8c 85       	ldd	r24, Y+12	; 0x0c
    9e14:	9d 85       	ldd	r25, Y+13	; 0x0d
    9e16:	01 96       	adiw	r24, 0x01	; 1
    9e18:	8c 87       	std	Y+12, r24	; 0x0c
    9e1a:	9d 87       	std	Y+13, r25	; 0x0d
    9e1c:	8c 85       	ldd	r24, Y+12	; 0x0c
    9e1e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9e20:	84 30       	cpi	r24, 0x04	; 4
    9e22:	91 05       	cpc	r25, r1
    9e24:	64 f3       	brlt	.-40     	; 0x9dfe <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9e26:	80 91 9f 50 	lds	r24, 0x509F
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9e2a:	80 e0       	ldi	r24, 0x00	; 0
    9e2c:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    9e30:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9e34:	88 e0       	ldi	r24, 0x08	; 8
    9e36:	60 e0       	ldi	r22, 0x00	; 0
    9e38:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
	return errorCode;	
    9e3c:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9e3e:	a9 96       	adiw	r28, 0x29	; 41
    9e40:	cd bf       	out	0x3d, r28	; 61
    9e42:	de bf       	out	0x3e, r29	; 62
    9e44:	df 91       	pop	r29
    9e46:	cf 91       	pop	r28
    9e48:	1f 91       	pop	r17
    9e4a:	0f 91       	pop	r16
    9e4c:	08 95       	ret

00009e4e <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9e4e:	cf 93       	push	r28
    9e50:	df 93       	push	r29
    9e52:	0f 92       	push	r0
    9e54:	0f 92       	push	r0
    9e56:	cd b7       	in	r28, 0x3d	; 61
    9e58:	de b7       	in	r29, 0x3e	; 62
    9e5a:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9e5c:	80 ec       	ldi	r24, 0xC0	; 192
    9e5e:	98 e0       	ldi	r25, 0x08	; 8
    9e60:	2a 81       	ldd	r18, Y+2	; 0x02
    9e62:	fc 01       	movw	r30, r24
    9e64:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9e66:	00 00       	nop
    9e68:	80 ec       	ldi	r24, 0xC0	; 192
    9e6a:	98 e0       	ldi	r25, 0x08	; 8
    9e6c:	fc 01       	movw	r30, r24
    9e6e:	82 81       	ldd	r24, Z+2	; 0x02
    9e70:	88 23       	and	r24, r24
    9e72:	d4 f7       	brge	.-12     	; 0x9e68 <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9e74:	80 ec       	ldi	r24, 0xC0	; 192
    9e76:	98 e0       	ldi	r25, 0x08	; 8
    9e78:	fc 01       	movw	r30, r24
    9e7a:	83 81       	ldd	r24, Z+3	; 0x03
    9e7c:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9e7e:	89 81       	ldd	r24, Y+1	; 0x01
}
    9e80:	0f 90       	pop	r0
    9e82:	0f 90       	pop	r0
    9e84:	df 91       	pop	r29
    9e86:	cf 91       	pop	r28
    9e88:	08 95       	ret

00009e8a <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9e8a:	0f 93       	push	r16
    9e8c:	1f 93       	push	r17
    9e8e:	cf 93       	push	r28
    9e90:	df 93       	push	r29
    9e92:	cd b7       	in	r28, 0x3d	; 61
    9e94:	de b7       	in	r29, 0x3e	; 62
    9e96:	2a 97       	sbiw	r28, 0x0a	; 10
    9e98:	cd bf       	out	0x3d, r28	; 61
    9e9a:	de bf       	out	0x3e, r29	; 62
    9e9c:	8b 83       	std	Y+3, r24	; 0x03
    9e9e:	4c 83       	std	Y+4, r20	; 0x04
    9ea0:	5d 83       	std	Y+5, r21	; 0x05
    9ea2:	6e 83       	std	Y+6, r22	; 0x06
    9ea4:	7f 83       	std	Y+7, r23	; 0x07
    9ea6:	28 87       	std	Y+8, r18	; 0x08
    9ea8:	09 87       	std	Y+9, r16	; 0x09
    9eaa:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9eac:	8b 81       	ldd	r24, Y+3	; 0x03
    9eae:	80 64       	ori	r24, 0x40	; 64
    9eb0:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9eb4:	8c 81       	ldd	r24, Y+4	; 0x04
    9eb6:	9d 81       	ldd	r25, Y+5	; 0x05
    9eb8:	ae 81       	ldd	r26, Y+6	; 0x06
    9eba:	bf 81       	ldd	r27, Y+7	; 0x07
    9ebc:	8b 2f       	mov	r24, r27
    9ebe:	99 27       	eor	r25, r25
    9ec0:	aa 27       	eor	r26, r26
    9ec2:	bb 27       	eor	r27, r27
    9ec4:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9ec8:	8c 81       	ldd	r24, Y+4	; 0x04
    9eca:	9d 81       	ldd	r25, Y+5	; 0x05
    9ecc:	ae 81       	ldd	r26, Y+6	; 0x06
    9ece:	bf 81       	ldd	r27, Y+7	; 0x07
    9ed0:	cd 01       	movw	r24, r26
    9ed2:	aa 27       	eor	r26, r26
    9ed4:	bb 27       	eor	r27, r27
    9ed6:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9eda:	8c 81       	ldd	r24, Y+4	; 0x04
    9edc:	9d 81       	ldd	r25, Y+5	; 0x05
    9ede:	ae 81       	ldd	r26, Y+6	; 0x06
    9ee0:	bf 81       	ldd	r27, Y+7	; 0x07
    9ee2:	89 2f       	mov	r24, r25
    9ee4:	9a 2f       	mov	r25, r26
    9ee6:	ab 2f       	mov	r26, r27
    9ee8:	bb 27       	eor	r27, r27
    9eea:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9eee:	8c 81       	ldd	r24, Y+4	; 0x04
    9ef0:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
	SPI_write(crc);
    9ef4:	88 85       	ldd	r24, Y+8	; 0x08
    9ef6:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
	
	for(int i=0; i<read; i++){
    9efa:	19 82       	std	Y+1, r1	; 0x01
    9efc:	1a 82       	std	Y+2, r1	; 0x02
    9efe:	33 c0       	rjmp	.+102    	; 0x9f66 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9f00:	89 81       	ldd	r24, Y+1	; 0x01
    9f02:	9a 81       	ldd	r25, Y+2	; 0x02
    9f04:	2d e0       	ldi	r18, 0x0D	; 13
    9f06:	30 e0       	ldi	r19, 0x00	; 0
    9f08:	b9 01       	movw	r22, r18
    9f0a:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    9f0e:	8c 01       	movw	r16, r24
    9f10:	8f ef       	ldi	r24, 0xFF	; 255
    9f12:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    9f16:	28 2f       	mov	r18, r24
    9f18:	c8 01       	movw	r24, r16
    9f1a:	81 56       	subi	r24, 0x61	; 97
    9f1c:	9f 4a       	sbci	r25, 0xAF	; 175
    9f1e:	fc 01       	movw	r30, r24
    9f20:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9f22:	89 81       	ldd	r24, Y+1	; 0x01
    9f24:	9a 81       	ldd	r25, Y+2	; 0x02
    9f26:	2d e0       	ldi	r18, 0x0D	; 13
    9f28:	30 e0       	ldi	r19, 0x00	; 0
    9f2a:	b9 01       	movw	r22, r18
    9f2c:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    9f30:	81 56       	subi	r24, 0x61	; 97
    9f32:	9f 4a       	sbci	r25, 0xAF	; 175
    9f34:	fc 01       	movw	r30, r24
    9f36:	80 81       	ld	r24, Z
    9f38:	8f 3f       	cpi	r24, 0xFF	; 255
    9f3a:	81 f0       	breq	.+32     	; 0x9f5c <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9f3c:	89 81       	ldd	r24, Y+1	; 0x01
    9f3e:	9a 81       	ldd	r25, Y+2	; 0x02
    9f40:	2d e0       	ldi	r18, 0x0D	; 13
    9f42:	30 e0       	ldi	r19, 0x00	; 0
    9f44:	b9 01       	movw	r22, r18
    9f46:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    9f4a:	81 56       	subi	r24, 0x61	; 97
    9f4c:	9f 4a       	sbci	r25, 0xAF	; 175
    9f4e:	fc 01       	movw	r30, r24
    9f50:	80 81       	ld	r24, Z
    9f52:	80 93 a0 50 	sts	0x50A0, r24
			return Buffer[1];
    9f56:	80 91 a0 50 	lds	r24, 0x50A0
    9f5a:	0d c0       	rjmp	.+26     	; 0x9f76 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9f5c:	89 81       	ldd	r24, Y+1	; 0x01
    9f5e:	9a 81       	ldd	r25, Y+2	; 0x02
    9f60:	01 96       	adiw	r24, 0x01	; 1
    9f62:	89 83       	std	Y+1, r24	; 0x01
    9f64:	9a 83       	std	Y+2, r25	; 0x02
    9f66:	29 81       	ldd	r18, Y+1	; 0x01
    9f68:	3a 81       	ldd	r19, Y+2	; 0x02
    9f6a:	89 85       	ldd	r24, Y+9	; 0x09
    9f6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f6e:	28 17       	cp	r18, r24
    9f70:	39 07       	cpc	r19, r25
    9f72:	34 f2       	brlt	.-116    	; 0x9f00 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9f74:	8f ef       	ldi	r24, 0xFF	; 255
}
    9f76:	2a 96       	adiw	r28, 0x0a	; 10
    9f78:	cd bf       	out	0x3d, r28	; 61
    9f7a:	de bf       	out	0x3e, r29	; 62
    9f7c:	df 91       	pop	r29
    9f7e:	cf 91       	pop	r28
    9f80:	1f 91       	pop	r17
    9f82:	0f 91       	pop	r16
    9f84:	08 95       	ret

00009f86 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9f86:	0f 93       	push	r16
    9f88:	1f 93       	push	r17
    9f8a:	cf 93       	push	r28
    9f8c:	df 93       	push	r29
    9f8e:	cd b7       	in	r28, 0x3d	; 61
    9f90:	de b7       	in	r29, 0x3e	; 62
    9f92:	62 97       	sbiw	r28, 0x12	; 18
    9f94:	cd bf       	out	0x3d, r28	; 61
    9f96:	de bf       	out	0x3e, r29	; 62
    9f98:	6b 87       	std	Y+11, r22	; 0x0b
    9f9a:	7c 87       	std	Y+12, r23	; 0x0c
    9f9c:	8d 87       	std	Y+13, r24	; 0x0d
    9f9e:	9e 87       	std	Y+14, r25	; 0x0e
    9fa0:	4f 87       	std	Y+15, r20	; 0x0f
    9fa2:	58 8b       	std	Y+16, r21	; 0x10
    9fa4:	29 8b       	std	Y+17, r18	; 0x11
    9fa6:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9fa8:	88 e0       	ldi	r24, 0x08	; 8
    9faa:	60 e0       	ldi	r22, 0x00	; 0
    9fac:	0e 94 53 36 	call	0x6ca6	; 0x6ca6 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9fb0:	80 e0       	ldi	r24, 0x00	; 0
    9fb2:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    9fb6:	81 e0       	ldi	r24, 0x01	; 1
    9fb8:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9fbc:	20 e0       	ldi	r18, 0x00	; 0
    9fbe:	32 e0       	ldi	r19, 0x02	; 2
    9fc0:	89 89       	ldd	r24, Y+17	; 0x11
    9fc2:	9a 89       	ldd	r25, Y+18	; 0x12
    9fc4:	a9 01       	movw	r20, r18
    9fc6:	48 1b       	sub	r20, r24
    9fc8:	59 0b       	sbc	r21, r25
    9fca:	ca 01       	movw	r24, r20
    9fcc:	89 83       	std	Y+1, r24	; 0x01
    9fce:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9fd0:	89 81       	ldd	r24, Y+1	; 0x01
    9fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    9fd4:	52 e0       	ldi	r21, 0x02	; 2
    9fd6:	80 30       	cpi	r24, 0x00	; 0
    9fd8:	95 07       	cpc	r25, r21
    9fda:	11 f4       	brne	.+4      	; 0x9fe0 <SD_write_block+0x5a>
    9fdc:	19 82       	std	Y+1, r1	; 0x01
    9fde:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9fe0:	1b 82       	std	Y+3, r1	; 0x03
    9fe2:	1c 82       	std	Y+4, r1	; 0x04
    9fe4:	0b c0       	rjmp	.+22     	; 0x9ffc <SD_write_block+0x76>
	if (i >= 10) {
    9fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    9fe8:	9c 81       	ldd	r25, Y+4	; 0x04
    9fea:	8a 30       	cpi	r24, 0x0A	; 10
    9fec:	91 05       	cpc	r25, r1
    9fee:	0c f0       	brlt	.+2      	; 0x9ff2 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9ff0:	ff cf       	rjmp	.-2      	; 0x9ff0 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    9ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    9ff6:	01 96       	adiw	r24, 0x01	; 1
    9ff8:	8b 83       	std	Y+3, r24	; 0x03
    9ffa:	9c 83       	std	Y+4, r25	; 0x04
    9ffc:	2b 85       	ldd	r18, Y+11	; 0x0b
    9ffe:	3c 85       	ldd	r19, Y+12	; 0x0c
    a000:	4d 85       	ldd	r20, Y+13	; 0x0d
    a002:	5e 85       	ldd	r21, Y+14	; 0x0e
    a004:	88 e1       	ldi	r24, 0x18	; 24
    a006:	ba 01       	movw	r22, r20
    a008:	a9 01       	movw	r20, r18
    a00a:	2f ef       	ldi	r18, 0xFF	; 255
    a00c:	08 e0       	ldi	r16, 0x08	; 8
    a00e:	10 e0       	ldi	r17, 0x00	; 0
    a010:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
    a014:	88 23       	and	r24, r24
    a016:	39 f7       	brne	.-50     	; 0x9fe6 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    a018:	8f ef       	ldi	r24, 0xFF	; 255
    a01a:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a01e:	80 93 9f 50 	sts	0x509F, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    a022:	8e ef       	ldi	r24, 0xFE	; 254
    a024:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a028:	1d 82       	std	Y+5, r1	; 0x05
    a02a:	1e 82       	std	Y+6, r1	; 0x06
    a02c:	1d c0       	rjmp	.+58     	; 0xa068 <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    a02e:	8d 81       	ldd	r24, Y+5	; 0x05
    a030:	9e 81       	ldd	r25, Y+6	; 0x06
    a032:	2d e0       	ldi	r18, 0x0D	; 13
    a034:	30 e0       	ldi	r19, 0x00	; 0
    a036:	b9 01       	movw	r22, r18
    a038:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    a03c:	8c 01       	movw	r16, r24
    a03e:	8d 81       	ldd	r24, Y+5	; 0x05
    a040:	9e 81       	ldd	r25, Y+6	; 0x06
    a042:	2f 85       	ldd	r18, Y+15	; 0x0f
    a044:	38 89       	ldd	r19, Y+16	; 0x10
    a046:	82 0f       	add	r24, r18
    a048:	93 1f       	adc	r25, r19
    a04a:	fc 01       	movw	r30, r24
    a04c:	80 81       	ld	r24, Z
    a04e:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a052:	28 2f       	mov	r18, r24
    a054:	c8 01       	movw	r24, r16
    a056:	81 56       	subi	r24, 0x61	; 97
    a058:	9f 4a       	sbci	r25, 0xAF	; 175
    a05a:	fc 01       	movw	r30, r24
    a05c:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a05e:	8d 81       	ldd	r24, Y+5	; 0x05
    a060:	9e 81       	ldd	r25, Y+6	; 0x06
    a062:	01 96       	adiw	r24, 0x01	; 1
    a064:	8d 83       	std	Y+5, r24	; 0x05
    a066:	9e 83       	std	Y+6, r25	; 0x06
    a068:	2d 81       	ldd	r18, Y+5	; 0x05
    a06a:	3e 81       	ldd	r19, Y+6	; 0x06
    a06c:	89 89       	ldd	r24, Y+17	; 0x11
    a06e:	9a 89       	ldd	r25, Y+18	; 0x12
    a070:	28 17       	cp	r18, r24
    a072:	39 07       	cpc	r19, r25
    a074:	e4 f2       	brlt	.-72     	; 0xa02e <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a076:	1f 82       	std	Y+7, r1	; 0x07
    a078:	18 86       	std	Y+8, r1	; 0x08
    a07a:	16 c0       	rjmp	.+44     	; 0xa0a8 <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    a07c:	8f 81       	ldd	r24, Y+7	; 0x07
    a07e:	98 85       	ldd	r25, Y+8	; 0x08
    a080:	2d e0       	ldi	r18, 0x0D	; 13
    a082:	30 e0       	ldi	r19, 0x00	; 0
    a084:	b9 01       	movw	r22, r18
    a086:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    a08a:	8c 01       	movw	r16, r24
    a08c:	80 e0       	ldi	r24, 0x00	; 0
    a08e:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a092:	28 2f       	mov	r18, r24
    a094:	c8 01       	movw	r24, r16
    a096:	81 56       	subi	r24, 0x61	; 97
    a098:	9f 4a       	sbci	r25, 0xAF	; 175
    a09a:	fc 01       	movw	r30, r24
    a09c:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a09e:	8f 81       	ldd	r24, Y+7	; 0x07
    a0a0:	98 85       	ldd	r25, Y+8	; 0x08
    a0a2:	01 96       	adiw	r24, 0x01	; 1
    a0a4:	8f 83       	std	Y+7, r24	; 0x07
    a0a6:	98 87       	std	Y+8, r25	; 0x08
    a0a8:	2f 81       	ldd	r18, Y+7	; 0x07
    a0aa:	38 85       	ldd	r19, Y+8	; 0x08
    a0ac:	89 81       	ldd	r24, Y+1	; 0x01
    a0ae:	9a 81       	ldd	r25, Y+2	; 0x02
    a0b0:	28 17       	cp	r18, r24
    a0b2:	39 07       	cpc	r19, r25
    a0b4:	1c f3       	brlt	.-58     	; 0xa07c <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    a0b6:	8f ef       	ldi	r24, 0xFF	; 255
    a0b8:	80 93 9f 50 	sts	0x509F, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a0bc:	19 86       	std	Y+9, r1	; 0x09
    a0be:	1a 86       	std	Y+10, r1	; 0x0a
    a0c0:	0a c0       	rjmp	.+20     	; 0xa0d6 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    a0c2:	8f ef       	ldi	r24, 0xFF	; 255
    a0c4:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a0c8:	80 93 9f 50 	sts	0x509F, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a0cc:	89 85       	ldd	r24, Y+9	; 0x09
    a0ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    a0d0:	01 96       	adiw	r24, 0x01	; 1
    a0d2:	89 87       	std	Y+9, r24	; 0x09
    a0d4:	9a 87       	std	Y+10, r25	; 0x0a
    a0d6:	89 85       	ldd	r24, Y+9	; 0x09
    a0d8:	9a 85       	ldd	r25, Y+10	; 0x0a
    a0da:	82 30       	cpi	r24, 0x02	; 2
    a0dc:	91 05       	cpc	r25, r1
    a0de:	8c f3       	brlt	.-30     	; 0xa0c2 <SD_write_block+0x13c>
    a0e0:	80 91 9f 50 	lds	r24, 0x509F
    a0e4:	8f 3f       	cpi	r24, 0xFF	; 255
    a0e6:	69 f3       	breq	.-38     	; 0xa0c2 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    a0e8:	80 91 9f 50 	lds	r24, 0x509F
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    a0ec:	05 c0       	rjmp	.+10     	; 0xa0f8 <SD_write_block+0x172>
    a0ee:	8f ef       	ldi	r24, 0xFF	; 255
    a0f0:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a0f4:	80 93 9f 50 	sts	0x509F, r24
    a0f8:	80 91 9f 50 	lds	r24, 0x509F
    a0fc:	8f 3f       	cpi	r24, 0xFF	; 255
    a0fe:	b9 f7       	brne	.-18     	; 0xa0ee <SD_write_block+0x168>
	SPICS(FALSE);
    a100:	80 e0       	ldi	r24, 0x00	; 0
    a102:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    a106:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    a10a:	88 e0       	ldi	r24, 0x08	; 8
    a10c:	60 e0       	ldi	r22, 0x00	; 0
    a10e:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
}
    a112:	62 96       	adiw	r28, 0x12	; 18
    a114:	cd bf       	out	0x3d, r28	; 61
    a116:	de bf       	out	0x3e, r29	; 62
    a118:	df 91       	pop	r29
    a11a:	cf 91       	pop	r28
    a11c:	1f 91       	pop	r17
    a11e:	0f 91       	pop	r16
    a120:	08 95       	ret

0000a122 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    a122:	0f 93       	push	r16
    a124:	1f 93       	push	r17
    a126:	cf 93       	push	r28
    a128:	df 93       	push	r29
    a12a:	cd b7       	in	r28, 0x3d	; 61
    a12c:	de b7       	in	r29, 0x3e	; 62
    a12e:	2a 97       	sbiw	r28, 0x0a	; 10
    a130:	cd bf       	out	0x3d, r28	; 61
    a132:	de bf       	out	0x3e, r29	; 62
    a134:	6d 83       	std	Y+5, r22	; 0x05
    a136:	7e 83       	std	Y+6, r23	; 0x06
    a138:	8f 83       	std	Y+7, r24	; 0x07
    a13a:	98 87       	std	Y+8, r25	; 0x08
    a13c:	49 87       	std	Y+9, r20	; 0x09
    a13e:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a140:	88 e0       	ldi	r24, 0x08	; 8
    a142:	60 e0       	ldi	r22, 0x00	; 0
    a144:	0e 94 53 36 	call	0x6ca6	; 0x6ca6 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a148:	80 e0       	ldi	r24, 0x00	; 0
    a14a:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    a14e:	81 e0       	ldi	r24, 0x01	; 1
    a150:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a154:	19 82       	std	Y+1, r1	; 0x01
    a156:	1a 82       	std	Y+2, r1	; 0x02
    a158:	0b c0       	rjmp	.+22     	; 0xa170 <SD_read_block+0x4e>
		if (i >= 10) {
    a15a:	89 81       	ldd	r24, Y+1	; 0x01
    a15c:	9a 81       	ldd	r25, Y+2	; 0x02
    a15e:	8a 30       	cpi	r24, 0x0A	; 10
    a160:	91 05       	cpc	r25, r1
    a162:	0c f0       	brlt	.+2      	; 0xa166 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    a164:	ff cf       	rjmp	.-2      	; 0xa164 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a166:	89 81       	ldd	r24, Y+1	; 0x01
    a168:	9a 81       	ldd	r25, Y+2	; 0x02
    a16a:	01 96       	adiw	r24, 0x01	; 1
    a16c:	89 83       	std	Y+1, r24	; 0x01
    a16e:	9a 83       	std	Y+2, r25	; 0x02
    a170:	2d 81       	ldd	r18, Y+5	; 0x05
    a172:	3e 81       	ldd	r19, Y+6	; 0x06
    a174:	4f 81       	ldd	r20, Y+7	; 0x07
    a176:	58 85       	ldd	r21, Y+8	; 0x08
    a178:	81 e1       	ldi	r24, 0x11	; 17
    a17a:	ba 01       	movw	r22, r20
    a17c:	a9 01       	movw	r20, r18
    a17e:	2f ef       	ldi	r18, 0xFF	; 255
    a180:	08 e0       	ldi	r16, 0x08	; 8
    a182:	10 e0       	ldi	r17, 0x00	; 0
    a184:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
    a188:	88 23       	and	r24, r24
    a18a:	39 f7       	brne	.-50     	; 0xa15a <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a18c:	05 c0       	rjmp	.+10     	; 0xa198 <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    a18e:	8f ef       	ldi	r24, 0xFF	; 255
    a190:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a194:	80 93 9f 50 	sts	0x509F, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a198:	80 91 9f 50 	lds	r24, 0x509F
    a19c:	8e 3f       	cpi	r24, 0xFE	; 254
    a19e:	b9 f7       	brne	.-18     	; 0xa18e <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a1a0:	1b 82       	std	Y+3, r1	; 0x03
    a1a2:	1c 82       	std	Y+4, r1	; 0x04
    a1a4:	11 c0       	rjmp	.+34     	; 0xa1c8 <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a1a6:	8b 81       	ldd	r24, Y+3	; 0x03
    a1a8:	9c 81       	ldd	r25, Y+4	; 0x04
    a1aa:	29 85       	ldd	r18, Y+9	; 0x09
    a1ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    a1ae:	89 01       	movw	r16, r18
    a1b0:	08 0f       	add	r16, r24
    a1b2:	19 1f       	adc	r17, r25
    a1b4:	8f ef       	ldi	r24, 0xFF	; 255
    a1b6:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a1ba:	f8 01       	movw	r30, r16
    a1bc:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a1be:	8b 81       	ldd	r24, Y+3	; 0x03
    a1c0:	9c 81       	ldd	r25, Y+4	; 0x04
    a1c2:	01 96       	adiw	r24, 0x01	; 1
    a1c4:	8b 83       	std	Y+3, r24	; 0x03
    a1c6:	9c 83       	std	Y+4, r25	; 0x04
    a1c8:	8b 81       	ldd	r24, Y+3	; 0x03
    a1ca:	9c 81       	ldd	r25, Y+4	; 0x04
    a1cc:	f2 e0       	ldi	r31, 0x02	; 2
    a1ce:	80 30       	cpi	r24, 0x00	; 0
    a1d0:	9f 07       	cpc	r25, r31
    a1d2:	4c f3       	brlt	.-46     	; 0xa1a6 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    a1d4:	10 92 ab 50 	sts	0x50AB, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a1d8:	05 c0       	rjmp	.+10     	; 0xa1e4 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    a1da:	8f ef       	ldi	r24, 0xFF	; 255
    a1dc:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a1e0:	80 93 ab 50 	sts	0x50AB, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a1e4:	80 91 ab 50 	lds	r24, 0x50AB
    a1e8:	8f 3f       	cpi	r24, 0xFF	; 255
    a1ea:	b9 f7       	brne	.-18     	; 0xa1da <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    a1ec:	80 e0       	ldi	r24, 0x00	; 0
    a1ee:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    a1f2:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a1f6:	88 e0       	ldi	r24, 0x08	; 8
    a1f8:	60 e0       	ldi	r22, 0x00	; 0
    a1fa:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
}
    a1fe:	2a 96       	adiw	r28, 0x0a	; 10
    a200:	cd bf       	out	0x3d, r28	; 61
    a202:	de bf       	out	0x3e, r29	; 62
    a204:	df 91       	pop	r29
    a206:	cf 91       	pop	r28
    a208:	1f 91       	pop	r17
    a20a:	0f 91       	pop	r16
    a20c:	08 95       	ret

0000a20e <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    a20e:	0f 93       	push	r16
    a210:	1f 93       	push	r17
    a212:	cf 93       	push	r28
    a214:	df 93       	push	r29
    a216:	cd b7       	in	r28, 0x3d	; 61
    a218:	de b7       	in	r29, 0x3e	; 62
    a21a:	6a 97       	sbiw	r28, 0x1a	; 26
    a21c:	cd bf       	out	0x3d, r28	; 61
    a21e:	de bf       	out	0x3e, r29	; 62
    a220:	6b 8b       	std	Y+19, r22	; 0x13
    a222:	7c 8b       	std	Y+20, r23	; 0x14
    a224:	8d 8b       	std	Y+21, r24	; 0x15
    a226:	9e 8b       	std	Y+22, r25	; 0x16
    a228:	4f 8b       	std	Y+23, r20	; 0x17
    a22a:	58 8f       	std	Y+24, r21	; 0x18
    a22c:	29 8f       	std	Y+25, r18	; 0x19
    a22e:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a230:	88 e0       	ldi	r24, 0x08	; 8
    a232:	60 e0       	ldi	r22, 0x00	; 0
    a234:	0e 94 53 36 	call	0x6ca6	; 0x6ca6 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a238:	80 e0       	ldi	r24, 0x00	; 0
    a23a:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    a23e:	81 e0       	ldi	r24, 0x01	; 1
    a240:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    a244:	89 8d       	ldd	r24, Y+25	; 0x19
    a246:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a248:	99 23       	and	r25, r25
    a24a:	14 f4       	brge	.+4      	; 0xa250 <SD_write_multiple_blocks+0x42>
    a24c:	81 50       	subi	r24, 0x01	; 1
    a24e:	9e 4f       	sbci	r25, 0xFE	; 254
    a250:	89 2f       	mov	r24, r25
    a252:	99 0f       	add	r25, r25
    a254:	99 0b       	sbc	r25, r25
    a256:	85 95       	asr	r24
    a258:	89 83       	std	Y+1, r24	; 0x01
    a25a:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    a25c:	89 8d       	ldd	r24, Y+25	; 0x19
    a25e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a260:	20 e0       	ldi	r18, 0x00	; 0
    a262:	32 e0       	ldi	r19, 0x02	; 2
    a264:	b9 01       	movw	r22, r18
    a266:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    a26a:	20 e0       	ldi	r18, 0x00	; 0
    a26c:	32 e0       	ldi	r19, 0x02	; 2
    a26e:	a9 01       	movw	r20, r18
    a270:	48 1b       	sub	r20, r24
    a272:	59 0b       	sbc	r21, r25
    a274:	ca 01       	movw	r24, r20
    a276:	8b 83       	std	Y+3, r24	; 0x03
    a278:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a27a:	8b 81       	ldd	r24, Y+3	; 0x03
    a27c:	9c 81       	ldd	r25, Y+4	; 0x04
    a27e:	52 e0       	ldi	r21, 0x02	; 2
    a280:	80 30       	cpi	r24, 0x00	; 0
    a282:	95 07       	cpc	r25, r21
    a284:	19 f4       	brne	.+6      	; 0xa28c <SD_write_multiple_blocks+0x7e>
    a286:	1b 82       	std	Y+3, r1	; 0x03
    a288:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a28a:	05 c0       	rjmp	.+10     	; 0xa296 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    a28c:	89 81       	ldd	r24, Y+1	; 0x01
    a28e:	9a 81       	ldd	r25, Y+2	; 0x02
    a290:	01 96       	adiw	r24, 0x01	; 1
    a292:	89 83       	std	Y+1, r24	; 0x01
    a294:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a296:	00 00       	nop
    a298:	2b 89       	ldd	r18, Y+19	; 0x13
    a29a:	3c 89       	ldd	r19, Y+20	; 0x14
    a29c:	4d 89       	ldd	r20, Y+21	; 0x15
    a29e:	5e 89       	ldd	r21, Y+22	; 0x16
    a2a0:	89 e1       	ldi	r24, 0x19	; 25
    a2a2:	ba 01       	movw	r22, r20
    a2a4:	a9 01       	movw	r20, r18
    a2a6:	2f ef       	ldi	r18, 0xFF	; 255
    a2a8:	08 e0       	ldi	r16, 0x08	; 8
    a2aa:	10 e0       	ldi	r17, 0x00	; 0
    a2ac:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
    a2b0:	88 23       	and	r24, r24
    a2b2:	91 f7       	brne	.-28     	; 0xa298 <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    a2b4:	1d 82       	std	Y+5, r1	; 0x05
    a2b6:	1e 82       	std	Y+6, r1	; 0x06
    a2b8:	ba c0       	rjmp	.+372    	; 0xa42e <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    a2ba:	8f ef       	ldi	r24, 0xFF	; 255
    a2bc:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a2c0:	80 93 a0 50 	sts	0x50A0, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    a2c4:	8c ef       	ldi	r24, 0xFC	; 252
    a2c6:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a2ca:	80 93 a0 50 	sts	0x50A0, r24
		if(j == (numSectors-1)){
    a2ce:	89 81       	ldd	r24, Y+1	; 0x01
    a2d0:	9a 81       	ldd	r25, Y+2	; 0x02
    a2d2:	9c 01       	movw	r18, r24
    a2d4:	21 50       	subi	r18, 0x01	; 1
    a2d6:	30 40       	sbci	r19, 0x00	; 0
    a2d8:	8d 81       	ldd	r24, Y+5	; 0x05
    a2da:	9e 81       	ldd	r25, Y+6	; 0x06
    a2dc:	28 17       	cp	r18, r24
    a2de:	39 07       	cpc	r19, r25
    a2e0:	09 f0       	breq	.+2      	; 0xa2e4 <SD_write_multiple_blocks+0xd6>
    a2e2:	54 c0       	rjmp	.+168    	; 0xa38c <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a2e4:	1f 82       	std	Y+7, r1	; 0x07
    a2e6:	18 86       	std	Y+8, r1	; 0x08
    a2e8:	25 c0       	rjmp	.+74     	; 0xa334 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a2ea:	8f 81       	ldd	r24, Y+7	; 0x07
    a2ec:	98 85       	ldd	r25, Y+8	; 0x08
    a2ee:	2c e0       	ldi	r18, 0x0C	; 12
    a2f0:	30 e0       	ldi	r19, 0x00	; 0
    a2f2:	b9 01       	movw	r22, r18
    a2f4:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    a2f8:	8c 01       	movw	r16, r24
    a2fa:	8d 81       	ldd	r24, Y+5	; 0x05
    a2fc:	9e 81       	ldd	r25, Y+6	; 0x06
    a2fe:	9c 01       	movw	r18, r24
    a300:	32 2f       	mov	r19, r18
    a302:	22 27       	eor	r18, r18
    a304:	33 0f       	add	r19, r19
    a306:	8f 81       	ldd	r24, Y+7	; 0x07
    a308:	98 85       	ldd	r25, Y+8	; 0x08
    a30a:	82 0f       	add	r24, r18
    a30c:	93 1f       	adc	r25, r19
    a30e:	2f 89       	ldd	r18, Y+23	; 0x17
    a310:	38 8d       	ldd	r19, Y+24	; 0x18
    a312:	82 0f       	add	r24, r18
    a314:	93 1f       	adc	r25, r19
    a316:	fc 01       	movw	r30, r24
    a318:	80 81       	ld	r24, Z
    a31a:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a31e:	28 2f       	mov	r18, r24
    a320:	c8 01       	movw	r24, r16
    a322:	81 56       	subi	r24, 0x61	; 97
    a324:	9f 4a       	sbci	r25, 0xAF	; 175
    a326:	fc 01       	movw	r30, r24
    a328:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a32a:	8f 81       	ldd	r24, Y+7	; 0x07
    a32c:	98 85       	ldd	r25, Y+8	; 0x08
    a32e:	01 96       	adiw	r24, 0x01	; 1
    a330:	8f 83       	std	Y+7, r24	; 0x07
    a332:	98 87       	std	Y+8, r25	; 0x08
    a334:	20 e0       	ldi	r18, 0x00	; 0
    a336:	32 e0       	ldi	r19, 0x02	; 2
    a338:	8b 81       	ldd	r24, Y+3	; 0x03
    a33a:	9c 81       	ldd	r25, Y+4	; 0x04
    a33c:	28 1b       	sub	r18, r24
    a33e:	39 0b       	sbc	r19, r25
    a340:	8f 81       	ldd	r24, Y+7	; 0x07
    a342:	98 85       	ldd	r25, Y+8	; 0x08
    a344:	82 17       	cp	r24, r18
    a346:	93 07       	cpc	r25, r19
    a348:	84 f2       	brlt	.-96     	; 0xa2ea <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a34a:	19 86       	std	Y+9, r1	; 0x09
    a34c:	1a 86       	std	Y+10, r1	; 0x0a
    a34e:	16 c0       	rjmp	.+44     	; 0xa37c <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a350:	89 85       	ldd	r24, Y+9	; 0x09
    a352:	9a 85       	ldd	r25, Y+10	; 0x0a
    a354:	2c e0       	ldi	r18, 0x0C	; 12
    a356:	30 e0       	ldi	r19, 0x00	; 0
    a358:	b9 01       	movw	r22, r18
    a35a:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    a35e:	8c 01       	movw	r16, r24
    a360:	80 e0       	ldi	r24, 0x00	; 0
    a362:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a366:	28 2f       	mov	r18, r24
    a368:	c8 01       	movw	r24, r16
    a36a:	81 56       	subi	r24, 0x61	; 97
    a36c:	9f 4a       	sbci	r25, 0xAF	; 175
    a36e:	fc 01       	movw	r30, r24
    a370:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a372:	89 85       	ldd	r24, Y+9	; 0x09
    a374:	9a 85       	ldd	r25, Y+10	; 0x0a
    a376:	01 96       	adiw	r24, 0x01	; 1
    a378:	89 87       	std	Y+9, r24	; 0x09
    a37a:	9a 87       	std	Y+10, r25	; 0x0a
    a37c:	29 85       	ldd	r18, Y+9	; 0x09
    a37e:	3a 85       	ldd	r19, Y+10	; 0x0a
    a380:	8b 81       	ldd	r24, Y+3	; 0x03
    a382:	9c 81       	ldd	r25, Y+4	; 0x04
    a384:	28 17       	cp	r18, r24
    a386:	39 07       	cpc	r19, r25
    a388:	1c f3       	brlt	.-58     	; 0xa350 <SD_write_multiple_blocks+0x142>
    a38a:	2e c0       	rjmp	.+92     	; 0xa3e8 <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a38c:	1b 86       	std	Y+11, r1	; 0x0b
    a38e:	1c 86       	std	Y+12, r1	; 0x0c
    a390:	25 c0       	rjmp	.+74     	; 0xa3dc <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a392:	8b 85       	ldd	r24, Y+11	; 0x0b
    a394:	9c 85       	ldd	r25, Y+12	; 0x0c
    a396:	2c e0       	ldi	r18, 0x0C	; 12
    a398:	30 e0       	ldi	r19, 0x00	; 0
    a39a:	b9 01       	movw	r22, r18
    a39c:	0e 94 92 5e 	call	0xbd24	; 0xbd24 <__divmodhi4>
    a3a0:	8c 01       	movw	r16, r24
    a3a2:	8d 81       	ldd	r24, Y+5	; 0x05
    a3a4:	9e 81       	ldd	r25, Y+6	; 0x06
    a3a6:	9c 01       	movw	r18, r24
    a3a8:	32 2f       	mov	r19, r18
    a3aa:	22 27       	eor	r18, r18
    a3ac:	33 0f       	add	r19, r19
    a3ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    a3b0:	9c 85       	ldd	r25, Y+12	; 0x0c
    a3b2:	82 0f       	add	r24, r18
    a3b4:	93 1f       	adc	r25, r19
    a3b6:	2f 89       	ldd	r18, Y+23	; 0x17
    a3b8:	38 8d       	ldd	r19, Y+24	; 0x18
    a3ba:	82 0f       	add	r24, r18
    a3bc:	93 1f       	adc	r25, r19
    a3be:	fc 01       	movw	r30, r24
    a3c0:	80 81       	ld	r24, Z
    a3c2:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a3c6:	28 2f       	mov	r18, r24
    a3c8:	c8 01       	movw	r24, r16
    a3ca:	81 56       	subi	r24, 0x61	; 97
    a3cc:	9f 4a       	sbci	r25, 0xAF	; 175
    a3ce:	fc 01       	movw	r30, r24
    a3d0:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a3d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    a3d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    a3d6:	01 96       	adiw	r24, 0x01	; 1
    a3d8:	8b 87       	std	Y+11, r24	; 0x0b
    a3da:	9c 87       	std	Y+12, r25	; 0x0c
    a3dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    a3de:	9c 85       	ldd	r25, Y+12	; 0x0c
    a3e0:	f2 e0       	ldi	r31, 0x02	; 2
    a3e2:	80 30       	cpi	r24, 0x00	; 0
    a3e4:	9f 07       	cpc	r25, r31
    a3e6:	ac f2       	brlt	.-86     	; 0xa392 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a3e8:	1d 86       	std	Y+13, r1	; 0x0d
    a3ea:	1e 86       	std	Y+14, r1	; 0x0e
    a3ec:	0a c0       	rjmp	.+20     	; 0xa402 <SD_write_multiple_blocks+0x1f4>
    a3ee:	8f ef       	ldi	r24, 0xFF	; 255
    a3f0:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a3f4:	80 93 a0 50 	sts	0x50A0, r24
    a3f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    a3fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    a3fc:	01 96       	adiw	r24, 0x01	; 1
    a3fe:	8d 87       	std	Y+13, r24	; 0x0d
    a400:	9e 87       	std	Y+14, r25	; 0x0e
    a402:	8d 85       	ldd	r24, Y+13	; 0x0d
    a404:	9e 85       	ldd	r25, Y+14	; 0x0e
    a406:	82 30       	cpi	r24, 0x02	; 2
    a408:	91 05       	cpc	r25, r1
    a40a:	8c f3       	brlt	.-30     	; 0xa3ee <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a40c:	10 92 a0 50 	sts	0x50A0, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a410:	05 c0       	rjmp	.+10     	; 0xa41c <SD_write_multiple_blocks+0x20e>
    a412:	8f ef       	ldi	r24, 0xFF	; 255
    a414:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a418:	80 93 a0 50 	sts	0x50A0, r24
    a41c:	80 91 a0 50 	lds	r24, 0x50A0
    a420:	8f 3f       	cpi	r24, 0xFF	; 255
    a422:	b9 f7       	brne	.-18     	; 0xa412 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a424:	8d 81       	ldd	r24, Y+5	; 0x05
    a426:	9e 81       	ldd	r25, Y+6	; 0x06
    a428:	01 96       	adiw	r24, 0x01	; 1
    a42a:	8d 83       	std	Y+5, r24	; 0x05
    a42c:	9e 83       	std	Y+6, r25	; 0x06
    a42e:	2d 81       	ldd	r18, Y+5	; 0x05
    a430:	3e 81       	ldd	r19, Y+6	; 0x06
    a432:	89 81       	ldd	r24, Y+1	; 0x01
    a434:	9a 81       	ldd	r25, Y+2	; 0x02
    a436:	28 17       	cp	r18, r24
    a438:	39 07       	cpc	r19, r25
    a43a:	0c f4       	brge	.+2      	; 0xa43e <SD_write_multiple_blocks+0x230>
    a43c:	3e cf       	rjmp	.-388    	; 0xa2ba <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a43e:	1f 86       	std	Y+15, r1	; 0x0f
    a440:	18 8a       	std	Y+16, r1	; 0x10
    a442:	0a c0       	rjmp	.+20     	; 0xa458 <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a444:	8f ef       	ldi	r24, 0xFF	; 255
    a446:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a44a:	80 93 a0 50 	sts	0x50A0, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a44e:	8f 85       	ldd	r24, Y+15	; 0x0f
    a450:	98 89       	ldd	r25, Y+16	; 0x10
    a452:	01 96       	adiw	r24, 0x01	; 1
    a454:	8f 87       	std	Y+15, r24	; 0x0f
    a456:	98 8b       	std	Y+16, r25	; 0x10
    a458:	8f 85       	ldd	r24, Y+15	; 0x0f
    a45a:	98 89       	ldd	r25, Y+16	; 0x10
    a45c:	84 30       	cpi	r24, 0x04	; 4
    a45e:	91 05       	cpc	r25, r1
    a460:	8c f3       	brlt	.-30     	; 0xa444 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a462:	8d ef       	ldi	r24, 0xFD	; 253
    a464:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a468:	80 93 a0 50 	sts	0x50A0, r24
	for(int i=0;i<4;i++){
    a46c:	19 8a       	std	Y+17, r1	; 0x11
    a46e:	1a 8a       	std	Y+18, r1	; 0x12
    a470:	0a c0       	rjmp	.+20     	; 0xa486 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a472:	8f ef       	ldi	r24, 0xFF	; 255
    a474:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a478:	80 93 a0 50 	sts	0x50A0, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a47c:	89 89       	ldd	r24, Y+17	; 0x11
    a47e:	9a 89       	ldd	r25, Y+18	; 0x12
    a480:	01 96       	adiw	r24, 0x01	; 1
    a482:	89 8b       	std	Y+17, r24	; 0x11
    a484:	9a 8b       	std	Y+18, r25	; 0x12
    a486:	89 89       	ldd	r24, Y+17	; 0x11
    a488:	9a 89       	ldd	r25, Y+18	; 0x12
    a48a:	84 30       	cpi	r24, 0x04	; 4
    a48c:	91 05       	cpc	r25, r1
    a48e:	8c f3       	brlt	.-30     	; 0xa472 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a490:	10 92 a0 50 	sts	0x50A0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a494:	05 c0       	rjmp	.+10     	; 0xa4a0 <SD_write_multiple_blocks+0x292>
    a496:	8f ef       	ldi	r24, 0xFF	; 255
    a498:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a49c:	80 93 a0 50 	sts	0x50A0, r24
    a4a0:	80 91 a0 50 	lds	r24, 0x50A0
    a4a4:	8f 3f       	cpi	r24, 0xFF	; 255
    a4a6:	b9 f7       	brne	.-18     	; 0xa496 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a4a8:	80 e0       	ldi	r24, 0x00	; 0
    a4aa:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    a4ae:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a4b2:	88 e0       	ldi	r24, 0x08	; 8
    a4b4:	60 e0       	ldi	r22, 0x00	; 0
    a4b6:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
}
    a4ba:	6a 96       	adiw	r28, 0x1a	; 26
    a4bc:	cd bf       	out	0x3d, r28	; 61
    a4be:	de bf       	out	0x3e, r29	; 62
    a4c0:	df 91       	pop	r29
    a4c2:	cf 91       	pop	r28
    a4c4:	1f 91       	pop	r17
    a4c6:	0f 91       	pop	r16
    a4c8:	08 95       	ret

0000a4ca <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a4ca:	0f 93       	push	r16
    a4cc:	1f 93       	push	r17
    a4ce:	cf 93       	push	r28
    a4d0:	df 93       	push	r29
    a4d2:	cd b7       	in	r28, 0x3d	; 61
    a4d4:	de b7       	in	r29, 0x3e	; 62
    a4d6:	2e 97       	sbiw	r28, 0x0e	; 14
    a4d8:	cd bf       	out	0x3d, r28	; 61
    a4da:	de bf       	out	0x3e, r29	; 62
    a4dc:	6f 83       	std	Y+7, r22	; 0x07
    a4de:	78 87       	std	Y+8, r23	; 0x08
    a4e0:	89 87       	std	Y+9, r24	; 0x09
    a4e2:	9a 87       	std	Y+10, r25	; 0x0a
    a4e4:	4b 87       	std	Y+11, r20	; 0x0b
    a4e6:	5c 87       	std	Y+12, r21	; 0x0c
    a4e8:	2d 87       	std	Y+13, r18	; 0x0d
    a4ea:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a4ec:	88 e0       	ldi	r24, 0x08	; 8
    a4ee:	60 e0       	ldi	r22, 0x00	; 0
    a4f0:	0e 94 53 36 	call	0x6ca6	; 0x6ca6 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a4f4:	80 e0       	ldi	r24, 0x00	; 0
    a4f6:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    a4fa:	81 e0       	ldi	r24, 0x01	; 1
    a4fc:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a500:	00 00       	nop
    a502:	2f 81       	ldd	r18, Y+7	; 0x07
    a504:	38 85       	ldd	r19, Y+8	; 0x08
    a506:	49 85       	ldd	r20, Y+9	; 0x09
    a508:	5a 85       	ldd	r21, Y+10	; 0x0a
    a50a:	82 e1       	ldi	r24, 0x12	; 18
    a50c:	ba 01       	movw	r22, r20
    a50e:	a9 01       	movw	r20, r18
    a510:	2f ef       	ldi	r18, 0xFF	; 255
    a512:	08 e0       	ldi	r16, 0x08	; 8
    a514:	10 e0       	ldi	r17, 0x00	; 0
    a516:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
    a51a:	88 23       	and	r24, r24
    a51c:	91 f7       	brne	.-28     	; 0xa502 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a51e:	19 82       	std	Y+1, r1	; 0x01
    a520:	1a 82       	std	Y+2, r1	; 0x02
    a522:	4b c0       	rjmp	.+150    	; 0xa5ba <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a524:	8f ef       	ldi	r24, 0xFF	; 255
    a526:	80 93 a0 50 	sts	0x50A0, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a52a:	05 c0       	rjmp	.+10     	; 0xa536 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a52c:	8f ef       	ldi	r24, 0xFF	; 255
    a52e:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a532:	80 93 a0 50 	sts	0x50A0, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a536:	80 91 a0 50 	lds	r24, 0x50A0
    a53a:	8e 3f       	cpi	r24, 0xFE	; 254
    a53c:	b9 f7       	brne	.-18     	; 0xa52c <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a53e:	1b 82       	std	Y+3, r1	; 0x03
    a540:	1c 82       	std	Y+4, r1	; 0x04
    a542:	19 c0       	rjmp	.+50     	; 0xa576 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a544:	89 81       	ldd	r24, Y+1	; 0x01
    a546:	9a 81       	ldd	r25, Y+2	; 0x02
    a548:	9c 01       	movw	r18, r24
    a54a:	32 2f       	mov	r19, r18
    a54c:	22 27       	eor	r18, r18
    a54e:	33 0f       	add	r19, r19
    a550:	8b 81       	ldd	r24, Y+3	; 0x03
    a552:	9c 81       	ldd	r25, Y+4	; 0x04
    a554:	82 0f       	add	r24, r18
    a556:	93 1f       	adc	r25, r19
    a558:	2b 85       	ldd	r18, Y+11	; 0x0b
    a55a:	3c 85       	ldd	r19, Y+12	; 0x0c
    a55c:	89 01       	movw	r16, r18
    a55e:	08 0f       	add	r16, r24
    a560:	19 1f       	adc	r17, r25
    a562:	8f ef       	ldi	r24, 0xFF	; 255
    a564:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a568:	f8 01       	movw	r30, r16
    a56a:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a56c:	8b 81       	ldd	r24, Y+3	; 0x03
    a56e:	9c 81       	ldd	r25, Y+4	; 0x04
    a570:	01 96       	adiw	r24, 0x01	; 1
    a572:	8b 83       	std	Y+3, r24	; 0x03
    a574:	9c 83       	std	Y+4, r25	; 0x04
    a576:	8b 81       	ldd	r24, Y+3	; 0x03
    a578:	9c 81       	ldd	r25, Y+4	; 0x04
    a57a:	f2 e0       	ldi	r31, 0x02	; 2
    a57c:	80 30       	cpi	r24, 0x00	; 0
    a57e:	9f 07       	cpc	r25, r31
    a580:	0c f3       	brlt	.-62     	; 0xa544 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a582:	1d 82       	std	Y+5, r1	; 0x05
    a584:	1e 82       	std	Y+6, r1	; 0x06
    a586:	0f c0       	rjmp	.+30     	; 0xa5a6 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a588:	8f ef       	ldi	r24, 0xFF	; 255
    a58a:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a58e:	28 2f       	mov	r18, r24
    a590:	8d 81       	ldd	r24, Y+5	; 0x05
    a592:	9e 81       	ldd	r25, Y+6	; 0x06
    a594:	81 56       	subi	r24, 0x61	; 97
    a596:	9f 4a       	sbci	r25, 0xAF	; 175
    a598:	fc 01       	movw	r30, r24
    a59a:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a59c:	8d 81       	ldd	r24, Y+5	; 0x05
    a59e:	9e 81       	ldd	r25, Y+6	; 0x06
    a5a0:	01 96       	adiw	r24, 0x01	; 1
    a5a2:	8d 83       	std	Y+5, r24	; 0x05
    a5a4:	9e 83       	std	Y+6, r25	; 0x06
    a5a6:	8d 81       	ldd	r24, Y+5	; 0x05
    a5a8:	9e 81       	ldd	r25, Y+6	; 0x06
    a5aa:	82 30       	cpi	r24, 0x02	; 2
    a5ac:	91 05       	cpc	r25, r1
    a5ae:	64 f3       	brlt	.-40     	; 0xa588 <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a5b0:	89 81       	ldd	r24, Y+1	; 0x01
    a5b2:	9a 81       	ldd	r25, Y+2	; 0x02
    a5b4:	01 96       	adiw	r24, 0x01	; 1
    a5b6:	89 83       	std	Y+1, r24	; 0x01
    a5b8:	9a 83       	std	Y+2, r25	; 0x02
    a5ba:	29 81       	ldd	r18, Y+1	; 0x01
    a5bc:	3a 81       	ldd	r19, Y+2	; 0x02
    a5be:	8d 85       	ldd	r24, Y+13	; 0x0d
    a5c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    a5c2:	28 17       	cp	r18, r24
    a5c4:	39 07       	cpc	r19, r25
    a5c6:	0c f4       	brge	.+2      	; 0xa5ca <SD_read_multiple_blocks+0x100>
    a5c8:	ad cf       	rjmp	.-166    	; 0xa524 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a5ca:	8c e0       	ldi	r24, 0x0C	; 12
    a5cc:	40 e0       	ldi	r20, 0x00	; 0
    a5ce:	50 e0       	ldi	r21, 0x00	; 0
    a5d0:	ba 01       	movw	r22, r20
    a5d2:	2f ef       	ldi	r18, 0xFF	; 255
    a5d4:	08 e0       	ldi	r16, 0x08	; 8
    a5d6:	10 e0       	ldi	r17, 0x00	; 0
    a5d8:	0e 94 45 4f 	call	0x9e8a	; 0x9e8a <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a5dc:	8f ef       	ldi	r24, 0xFF	; 255
    a5de:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a5e2:	80 93 9f 50 	sts	0x509F, r24
	Buffer[1] = FILLER_BYTE;
    a5e6:	10 92 a0 50 	sts	0x50A0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a5ea:	05 c0       	rjmp	.+10     	; 0xa5f6 <SD_read_multiple_blocks+0x12c>
    a5ec:	8f ef       	ldi	r24, 0xFF	; 255
    a5ee:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
    a5f2:	80 93 a0 50 	sts	0x50A0, r24
    a5f6:	80 91 a0 50 	lds	r24, 0x50A0
    a5fa:	8f 3f       	cpi	r24, 0xFF	; 255
    a5fc:	b9 f7       	brne	.-18     	; 0xa5ec <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a5fe:	80 e0       	ldi	r24, 0x00	; 0
    a600:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    a604:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a608:	88 e0       	ldi	r24, 0x08	; 8
    a60a:	60 e0       	ldi	r22, 0x00	; 0
    a60c:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
}
    a610:	2e 96       	adiw	r28, 0x0e	; 14
    a612:	cd bf       	out	0x3d, r28	; 61
    a614:	de bf       	out	0x3e, r29	; 62
    a616:	df 91       	pop	r29
    a618:	cf 91       	pop	r28
    a61a:	1f 91       	pop	r17
    a61c:	0f 91       	pop	r16
    a61e:	08 95       	ret

0000a620 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a620:	cf 93       	push	r28
    a622:	df 93       	push	r29
    a624:	cd b7       	in	r28, 0x3d	; 61
    a626:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a628:	88 e0       	ldi	r24, 0x08	; 8
    a62a:	60 e0       	ldi	r22, 0x00	; 0
    a62c:	0e 94 24 35 	call	0x6a48	; 0x6a48 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a630:	88 e0       	ldi	r24, 0x08	; 8
    a632:	60 e0       	ldi	r22, 0x00	; 0
    a634:	0e 94 f0 35 	call	0x6be0	; 0x6be0 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a638:	80 e0       	ldi	r24, 0x00	; 0
    a63a:	0e 94 c0 39 	call	0x7380	; 0x7380 <SPIInit>
	SPICS(TRUE);
    a63e:	81 e0       	ldi	r24, 0x01	; 1
    a640:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a644:	8f ef       	ldi	r24, 0xFF	; 255
    a646:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <SPI_write>
	SPICS(FALSE);	//stop spi
    a64a:	80 e0       	ldi	r24, 0x00	; 0
    a64c:	0e 94 15 3a 	call	0x742a	; 0x742a <SPICS>
	SPIDisable();
    a650:	0e 94 2d 3a 	call	0x745a	; 0x745a <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a654:	80 e0       	ldi	r24, 0x00	; 0
    a656:	0e 94 26 06 	call	0xc4c	; 0xc4c <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a65a:	80 e0       	ldi	r24, 0x00	; 0
    a65c:	0e 94 ba 36 	call	0x6d74	; 0x6d74 <Ext1Power>
}
    a660:	df 91       	pop	r29
    a662:	cf 91       	pop	r28
    a664:	08 95       	ret

0000a666 <storeFilename>:

void storeFilename(char* str){
    a666:	cf 93       	push	r28
    a668:	df 93       	push	r29
    a66a:	00 d0       	rcall	.+0      	; 0xa66c <storeFilename+0x6>
    a66c:	0f 92       	push	r0
    a66e:	cd b7       	in	r28, 0x3d	; 61
    a670:	de b7       	in	r29, 0x3e	; 62
    a672:	8b 83       	std	Y+3, r24	; 0x03
    a674:	9c 83       	std	Y+4, r25	; 0x04
	int i=0;
    a676:	19 82       	std	Y+1, r1	; 0x01
    a678:	1a 82       	std	Y+2, r1	; 0x02
	for (;i<strlen(str) && i<15 ;i++) FileName[i] = str[i];
    a67a:	13 c0       	rjmp	.+38     	; 0xa6a2 <storeFilename+0x3c>
    a67c:	89 81       	ldd	r24, Y+1	; 0x01
    a67e:	9a 81       	ldd	r25, Y+2	; 0x02
    a680:	2b 81       	ldd	r18, Y+3	; 0x03
    a682:	3c 81       	ldd	r19, Y+4	; 0x04
    a684:	82 0f       	add	r24, r18
    a686:	93 1f       	adc	r25, r19
    a688:	fc 01       	movw	r30, r24
    a68a:	20 81       	ld	r18, Z
    a68c:	89 81       	ldd	r24, Y+1	; 0x01
    a68e:	9a 81       	ldd	r25, Y+2	; 0x02
    a690:	8f 53       	subi	r24, 0x3F	; 63
    a692:	9f 4a       	sbci	r25, 0xAF	; 175
    a694:	fc 01       	movw	r30, r24
    a696:	20 83       	st	Z, r18
    a698:	89 81       	ldd	r24, Y+1	; 0x01
    a69a:	9a 81       	ldd	r25, Y+2	; 0x02
    a69c:	01 96       	adiw	r24, 0x01	; 1
    a69e:	89 83       	std	Y+1, r24	; 0x01
    a6a0:	9a 83       	std	Y+2, r25	; 0x02
    a6a2:	49 81       	ldd	r20, Y+1	; 0x01
    a6a4:	5a 81       	ldd	r21, Y+2	; 0x02
    a6a6:	8b 81       	ldd	r24, Y+3	; 0x03
    a6a8:	9c 81       	ldd	r25, Y+4	; 0x04
    a6aa:	9c 01       	movw	r18, r24
    a6ac:	f9 01       	movw	r30, r18
    a6ae:	01 90       	ld	r0, Z+
    a6b0:	00 20       	and	r0, r0
    a6b2:	e9 f7       	brne	.-6      	; 0xa6ae <storeFilename+0x48>
    a6b4:	cf 01       	movw	r24, r30
    a6b6:	01 97       	sbiw	r24, 0x01	; 1
    a6b8:	82 1b       	sub	r24, r18
    a6ba:	93 0b       	sbc	r25, r19
    a6bc:	48 17       	cp	r20, r24
    a6be:	59 07       	cpc	r21, r25
    a6c0:	a0 f4       	brcc	.+40     	; 0xa6ea <storeFilename+0x84>
    a6c2:	89 81       	ldd	r24, Y+1	; 0x01
    a6c4:	9a 81       	ldd	r25, Y+2	; 0x02
    a6c6:	8f 30       	cpi	r24, 0x0F	; 15
    a6c8:	91 05       	cpc	r25, r1
    a6ca:	c4 f2       	brlt	.-80     	; 0xa67c <storeFilename+0x16>
	for (;i<15;i++)	FileName[i] = " ";
    a6cc:	0e c0       	rjmp	.+28     	; 0xa6ea <storeFilename+0x84>
    a6ce:	8b e2       	ldi	r24, 0x2B	; 43
    a6d0:	90 e2       	ldi	r25, 0x20	; 32
    a6d2:	28 2f       	mov	r18, r24
    a6d4:	89 81       	ldd	r24, Y+1	; 0x01
    a6d6:	9a 81       	ldd	r25, Y+2	; 0x02
    a6d8:	8f 53       	subi	r24, 0x3F	; 63
    a6da:	9f 4a       	sbci	r25, 0xAF	; 175
    a6dc:	fc 01       	movw	r30, r24
    a6de:	20 83       	st	Z, r18
    a6e0:	89 81       	ldd	r24, Y+1	; 0x01
    a6e2:	9a 81       	ldd	r25, Y+2	; 0x02
    a6e4:	01 96       	adiw	r24, 0x01	; 1
    a6e6:	89 83       	std	Y+1, r24	; 0x01
    a6e8:	9a 83       	std	Y+2, r25	; 0x02
    a6ea:	89 81       	ldd	r24, Y+1	; 0x01
    a6ec:	9a 81       	ldd	r25, Y+2	; 0x02
    a6ee:	8f 30       	cpi	r24, 0x0F	; 15
    a6f0:	91 05       	cpc	r25, r1
    a6f2:	6c f3       	brlt	.-38     	; 0xa6ce <storeFilename+0x68>
    a6f4:	24 96       	adiw	r28, 0x04	; 4
    a6f6:	cd bf       	out	0x3d, r28	; 61
    a6f8:	de bf       	out	0x3e, r29	; 62
    a6fa:	df 91       	pop	r29
    a6fc:	cf 91       	pop	r28
    a6fe:	08 95       	ret

0000a700 <__muldi3>:
    a700:	a0 e3       	ldi	r26, 0x30	; 48
    a702:	b0 e0       	ldi	r27, 0x00	; 0
    a704:	e6 e8       	ldi	r30, 0x86	; 134
    a706:	f3 e5       	ldi	r31, 0x53	; 83
    a708:	0c 94 e4 5e 	jmp	0xbdc8	; 0xbdc8 <__prologue_saves__+0x4>
    a70c:	29 8f       	std	Y+25, r18	; 0x19
    a70e:	3a 8f       	std	Y+26, r19	; 0x1a
    a710:	4b 8f       	std	Y+27, r20	; 0x1b
    a712:	5c 8f       	std	Y+28, r21	; 0x1c
    a714:	6d 8f       	std	Y+29, r22	; 0x1d
    a716:	7e 8f       	std	Y+30, r23	; 0x1e
    a718:	8f 8f       	std	Y+31, r24	; 0x1f
    a71a:	98 a3       	lds	r25, 0x58
    a71c:	a9 8a       	std	Y+17, r10	; 0x11
    a71e:	ba 8a       	std	Y+18, r11	; 0x12
    a720:	cb 8a       	std	Y+19, r12	; 0x13
    a722:	dc 8a       	std	Y+20, r13	; 0x14
    a724:	ed 8a       	std	Y+21, r14	; 0x15
    a726:	fe 8a       	std	Y+22, r15	; 0x16
    a728:	0f 8b       	std	Y+23, r16	; 0x17
    a72a:	18 8f       	std	Y+24, r17	; 0x18
    a72c:	09 8d       	ldd	r16, Y+25	; 0x19
    a72e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a730:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a732:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a734:	09 a3       	lds	r16, 0x59
    a736:	1a a3       	lds	r17, 0x5a
    a738:	2b a3       	lds	r18, 0x5b
    a73a:	3c a3       	lds	r19, 0x5c
    a73c:	68 01       	movw	r12, r16
    a73e:	79 01       	movw	r14, r18
    a740:	8f ef       	ldi	r24, 0xFF	; 255
    a742:	9f ef       	ldi	r25, 0xFF	; 255
    a744:	a0 e0       	ldi	r26, 0x00	; 0
    a746:	b0 e0       	ldi	r27, 0x00	; 0
    a748:	c8 22       	and	r12, r24
    a74a:	d9 22       	and	r13, r25
    a74c:	ea 22       	and	r14, r26
    a74e:	fb 22       	and	r15, r27
    a750:	89 01       	movw	r16, r18
    a752:	22 27       	eor	r18, r18
    a754:	33 27       	eor	r19, r19
    a756:	09 a7       	lds	r16, 0x79
    a758:	1a a7       	lds	r17, 0x7a
    a75a:	2b a7       	lds	r18, 0x7b
    a75c:	3c a7       	lds	r19, 0x7c
    a75e:	09 89       	ldd	r16, Y+17	; 0x11
    a760:	1a 89       	ldd	r17, Y+18	; 0x12
    a762:	2b 89       	ldd	r18, Y+19	; 0x13
    a764:	3c 89       	ldd	r19, Y+20	; 0x14
    a766:	0d a3       	lds	r16, 0x5d
    a768:	1e a3       	lds	r17, 0x5e
    a76a:	2f a3       	lds	r18, 0x5f
    a76c:	38 a7       	lds	r19, 0x78
    a76e:	48 01       	movw	r8, r16
    a770:	59 01       	movw	r10, r18
    a772:	88 22       	and	r8, r24
    a774:	99 22       	and	r9, r25
    a776:	aa 22       	and	r10, r26
    a778:	bb 22       	and	r11, r27
    a77a:	29 01       	movw	r4, r18
    a77c:	66 24       	eor	r6, r6
    a77e:	77 24       	eor	r7, r7
    a780:	c5 01       	movw	r24, r10
    a782:	b4 01       	movw	r22, r8
    a784:	a7 01       	movw	r20, r14
    a786:	96 01       	movw	r18, r12
    a788:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    a78c:	6d a7       	lds	r22, 0x7d
    a78e:	7e a7       	lds	r23, 0x7e
    a790:	8f a7       	lds	r24, 0x7f
    a792:	98 ab       	sts	0x58, r25
    a794:	c3 01       	movw	r24, r6
    a796:	b2 01       	movw	r22, r4
    a798:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    a79c:	6b 01       	movw	r12, r22
    a79e:	7c 01       	movw	r14, r24
    a7a0:	c5 01       	movw	r24, r10
    a7a2:	b4 01       	movw	r22, r8
    a7a4:	29 a5       	lds	r18, 0x69
    a7a6:	3a a5       	lds	r19, 0x6a
    a7a8:	4b a5       	lds	r20, 0x6b
    a7aa:	5c a5       	lds	r21, 0x6c
    a7ac:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    a7b0:	4b 01       	movw	r8, r22
    a7b2:	5c 01       	movw	r10, r24
    a7b4:	c3 01       	movw	r24, r6
    a7b6:	b2 01       	movw	r22, r4
    a7b8:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    a7bc:	ab 01       	movw	r20, r22
    a7be:	bc 01       	movw	r22, r24
    a7c0:	c8 0c       	add	r12, r8
    a7c2:	d9 1c       	adc	r13, r9
    a7c4:	ea 1c       	adc	r14, r10
    a7c6:	fb 1c       	adc	r15, r11
    a7c8:	0d a5       	lds	r16, 0x6d
    a7ca:	1e a5       	lds	r17, 0x6e
    a7cc:	2f a5       	lds	r18, 0x6f
    a7ce:	38 a9       	sts	0x48, r19
    a7d0:	c9 01       	movw	r24, r18
    a7d2:	aa 27       	eor	r26, r26
    a7d4:	bb 27       	eor	r27, r27
    a7d6:	c8 0e       	add	r12, r24
    a7d8:	d9 1e       	adc	r13, r25
    a7da:	ea 1e       	adc	r14, r26
    a7dc:	fb 1e       	adc	r15, r27
    a7de:	c8 14       	cp	r12, r8
    a7e0:	d9 04       	cpc	r13, r9
    a7e2:	ea 04       	cpc	r14, r10
    a7e4:	fb 04       	cpc	r15, r11
    a7e6:	20 f4       	brcc	.+8      	; 0xa7f0 <__muldi3+0xf0>
    a7e8:	40 50       	subi	r20, 0x00	; 0
    a7ea:	50 40       	sbci	r21, 0x00	; 0
    a7ec:	6f 4f       	sbci	r22, 0xFF	; 255
    a7ee:	7f 4f       	sbci	r23, 0xFF	; 255
    a7f0:	c7 01       	movw	r24, r14
    a7f2:	aa 27       	eor	r26, r26
    a7f4:	bb 27       	eor	r27, r27
    a7f6:	84 0f       	add	r24, r20
    a7f8:	95 1f       	adc	r25, r21
    a7fa:	a6 1f       	adc	r26, r22
    a7fc:	b7 1f       	adc	r27, r23
    a7fe:	8d 83       	std	Y+5, r24	; 0x05
    a800:	9e 83       	std	Y+6, r25	; 0x06
    a802:	af 83       	std	Y+7, r26	; 0x07
    a804:	b8 87       	std	Y+8, r27	; 0x08
    a806:	76 01       	movw	r14, r12
    a808:	dd 24       	eor	r13, r13
    a80a:	cc 24       	eor	r12, r12
    a80c:	4d a5       	lds	r20, 0x6d
    a80e:	5e a5       	lds	r21, 0x6e
    a810:	6f a5       	lds	r22, 0x6f
    a812:	78 a9       	sts	0x48, r23
    a814:	60 70       	andi	r22, 0x00	; 0
    a816:	70 70       	andi	r23, 0x00	; 0
    a818:	c4 0e       	add	r12, r20
    a81a:	d5 1e       	adc	r13, r21
    a81c:	e6 1e       	adc	r14, r22
    a81e:	f7 1e       	adc	r15, r23
    a820:	c9 82       	std	Y+1, r12	; 0x01
    a822:	da 82       	std	Y+2, r13	; 0x02
    a824:	eb 82       	std	Y+3, r14	; 0x03
    a826:	fc 82       	std	Y+4, r15	; 0x04
    a828:	1c 2d       	mov	r17, r12
    a82a:	0a 81       	ldd	r16, Y+2	; 0x02
    a82c:	8b 80       	ldd	r8, Y+3	; 0x03
    a82e:	4c 80       	ldd	r4, Y+4	; 0x04
    a830:	8d 87       	std	Y+13, r24	; 0x0d
    a832:	8e 81       	ldd	r24, Y+6	; 0x06
    a834:	8e 87       	std	Y+14, r24	; 0x0e
    a836:	8f 81       	ldd	r24, Y+7	; 0x07
    a838:	8f 87       	std	Y+15, r24	; 0x0f
    a83a:	88 85       	ldd	r24, Y+8	; 0x08
    a83c:	88 8b       	std	Y+16, r24	; 0x10
    a83e:	2d 89       	ldd	r18, Y+21	; 0x15
    a840:	3e 89       	ldd	r19, Y+22	; 0x16
    a842:	4f 89       	ldd	r20, Y+23	; 0x17
    a844:	58 8d       	ldd	r21, Y+24	; 0x18
    a846:	69 a1       	lds	r22, 0x49
    a848:	7a a1       	lds	r23, 0x4a
    a84a:	8b a1       	lds	r24, 0x4b
    a84c:	9c a1       	lds	r25, 0x4c
    a84e:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    a852:	6b 01       	movw	r12, r22
    a854:	7c 01       	movw	r14, r24
    a856:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a858:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a85a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a85c:	58 a1       	lds	r21, 0x48
    a85e:	6d a1       	lds	r22, 0x4d
    a860:	7e a1       	lds	r23, 0x4e
    a862:	8f a1       	lds	r24, 0x4f
    a864:	98 a5       	lds	r25, 0x68
    a866:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    a86a:	dc 01       	movw	r26, r24
    a86c:	cb 01       	movw	r24, r22
    a86e:	c8 0e       	add	r12, r24
    a870:	d9 1e       	adc	r13, r25
    a872:	ea 1e       	adc	r14, r26
    a874:	fb 1e       	adc	r15, r27
    a876:	8d 85       	ldd	r24, Y+13	; 0x0d
    a878:	9e 85       	ldd	r25, Y+14	; 0x0e
    a87a:	af 85       	ldd	r26, Y+15	; 0x0f
    a87c:	b8 89       	ldd	r27, Y+16	; 0x10
    a87e:	8c 0d       	add	r24, r12
    a880:	9d 1d       	adc	r25, r13
    a882:	ae 1d       	adc	r26, r14
    a884:	bf 1d       	adc	r27, r15
    a886:	8d 87       	std	Y+13, r24	; 0x0d
    a888:	9e 87       	std	Y+14, r25	; 0x0e
    a88a:	af 87       	std	Y+15, r26	; 0x0f
    a88c:	b8 8b       	std	Y+16, r27	; 0x10
    a88e:	68 2f       	mov	r22, r24
    a890:	7e 85       	ldd	r23, Y+14	; 0x0e
    a892:	21 2f       	mov	r18, r17
    a894:	30 2f       	mov	r19, r16
    a896:	48 2d       	mov	r20, r8
    a898:	54 2d       	mov	r21, r4
    a89a:	8f 85       	ldd	r24, Y+15	; 0x0f
    a89c:	98 89       	ldd	r25, Y+16	; 0x10
    a89e:	e0 96       	adiw	r28, 0x30	; 48
    a8a0:	e0 e1       	ldi	r30, 0x10	; 16
    a8a2:	0c 94 fd 5e 	jmp	0xbdfa	; 0xbdfa <__epilogue_restores__+0x4>

0000a8a6 <__ashldi3>:
    a8a6:	cf 92       	push	r12
    a8a8:	df 92       	push	r13
    a8aa:	ef 92       	push	r14
    a8ac:	ff 92       	push	r15
    a8ae:	0f 93       	push	r16
    a8b0:	cf 93       	push	r28
    a8b2:	df 93       	push	r29
    a8b4:	cd b7       	in	r28, 0x3d	; 61
    a8b6:	de b7       	in	r29, 0x3e	; 62
    a8b8:	60 97       	sbiw	r28, 0x10	; 16
    a8ba:	cd bf       	out	0x3d, r28	; 61
    a8bc:	de bf       	out	0x3e, r29	; 62
    a8be:	00 23       	and	r16, r16
    a8c0:	09 f4       	brne	.+2      	; 0xa8c4 <__ashldi3+0x1e>
    a8c2:	5a c0       	rjmp	.+180    	; 0xa978 <__ashldi3+0xd2>
    a8c4:	29 87       	std	Y+9, r18	; 0x09
    a8c6:	3a 87       	std	Y+10, r19	; 0x0a
    a8c8:	4b 87       	std	Y+11, r20	; 0x0b
    a8ca:	5c 87       	std	Y+12, r21	; 0x0c
    a8cc:	6d 87       	std	Y+13, r22	; 0x0d
    a8ce:	7e 87       	std	Y+14, r23	; 0x0e
    a8d0:	8f 87       	std	Y+15, r24	; 0x0f
    a8d2:	98 8b       	std	Y+16, r25	; 0x10
    a8d4:	80 e2       	ldi	r24, 0x20	; 32
    a8d6:	80 1b       	sub	r24, r16
    a8d8:	49 85       	ldd	r20, Y+9	; 0x09
    a8da:	5a 85       	ldd	r21, Y+10	; 0x0a
    a8dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    a8de:	7c 85       	ldd	r23, Y+12	; 0x0c
    a8e0:	18 16       	cp	r1, r24
    a8e2:	b4 f0       	brlt	.+44     	; 0xa910 <__ashldi3+0x6a>
    a8e4:	19 82       	std	Y+1, r1	; 0x01
    a8e6:	1a 82       	std	Y+2, r1	; 0x02
    a8e8:	1b 82       	std	Y+3, r1	; 0x03
    a8ea:	1c 82       	std	Y+4, r1	; 0x04
    a8ec:	99 27       	eor	r25, r25
    a8ee:	87 fd       	sbrc	r24, 7
    a8f0:	90 95       	com	r25
    a8f2:	90 95       	com	r25
    a8f4:	81 95       	neg	r24
    a8f6:	9f 4f       	sbci	r25, 0xFF	; 255
    a8f8:	04 c0       	rjmp	.+8      	; 0xa902 <__ashldi3+0x5c>
    a8fa:	44 0f       	add	r20, r20
    a8fc:	55 1f       	adc	r21, r21
    a8fe:	66 1f       	adc	r22, r22
    a900:	77 1f       	adc	r23, r23
    a902:	8a 95       	dec	r24
    a904:	d2 f7       	brpl	.-12     	; 0xa8fa <__ashldi3+0x54>
    a906:	4d 83       	std	Y+5, r20	; 0x05
    a908:	5e 83       	std	Y+6, r21	; 0x06
    a90a:	6f 83       	std	Y+7, r22	; 0x07
    a90c:	78 87       	std	Y+8, r23	; 0x08
    a90e:	2c c0       	rjmp	.+88     	; 0xa968 <__ashldi3+0xc2>
    a910:	6a 01       	movw	r12, r20
    a912:	7b 01       	movw	r14, r22
    a914:	00 2e       	mov	r0, r16
    a916:	04 c0       	rjmp	.+8      	; 0xa920 <__ashldi3+0x7a>
    a918:	cc 0c       	add	r12, r12
    a91a:	dd 1c       	adc	r13, r13
    a91c:	ee 1c       	adc	r14, r14
    a91e:	ff 1c       	adc	r15, r15
    a920:	0a 94       	dec	r0
    a922:	d2 f7       	brpl	.-12     	; 0xa918 <__ashldi3+0x72>
    a924:	c9 82       	std	Y+1, r12	; 0x01
    a926:	da 82       	std	Y+2, r13	; 0x02
    a928:	eb 82       	std	Y+3, r14	; 0x03
    a92a:	fc 82       	std	Y+4, r15	; 0x04
    a92c:	6a 01       	movw	r12, r20
    a92e:	7b 01       	movw	r14, r22
    a930:	04 c0       	rjmp	.+8      	; 0xa93a <__ashldi3+0x94>
    a932:	f6 94       	lsr	r15
    a934:	e7 94       	ror	r14
    a936:	d7 94       	ror	r13
    a938:	c7 94       	ror	r12
    a93a:	8a 95       	dec	r24
    a93c:	d2 f7       	brpl	.-12     	; 0xa932 <__ashldi3+0x8c>
    a93e:	d7 01       	movw	r26, r14
    a940:	c6 01       	movw	r24, r12
    a942:	4d 85       	ldd	r20, Y+13	; 0x0d
    a944:	5e 85       	ldd	r21, Y+14	; 0x0e
    a946:	6f 85       	ldd	r22, Y+15	; 0x0f
    a948:	78 89       	ldd	r23, Y+16	; 0x10
    a94a:	04 c0       	rjmp	.+8      	; 0xa954 <__ashldi3+0xae>
    a94c:	44 0f       	add	r20, r20
    a94e:	55 1f       	adc	r21, r21
    a950:	66 1f       	adc	r22, r22
    a952:	77 1f       	adc	r23, r23
    a954:	0a 95       	dec	r16
    a956:	d2 f7       	brpl	.-12     	; 0xa94c <__ashldi3+0xa6>
    a958:	84 2b       	or	r24, r20
    a95a:	95 2b       	or	r25, r21
    a95c:	a6 2b       	or	r26, r22
    a95e:	b7 2b       	or	r27, r23
    a960:	8d 83       	std	Y+5, r24	; 0x05
    a962:	9e 83       	std	Y+6, r25	; 0x06
    a964:	af 83       	std	Y+7, r26	; 0x07
    a966:	b8 87       	std	Y+8, r27	; 0x08
    a968:	29 81       	ldd	r18, Y+1	; 0x01
    a96a:	3a 81       	ldd	r19, Y+2	; 0x02
    a96c:	4b 81       	ldd	r20, Y+3	; 0x03
    a96e:	5c 81       	ldd	r21, Y+4	; 0x04
    a970:	6d 81       	ldd	r22, Y+5	; 0x05
    a972:	7e 81       	ldd	r23, Y+6	; 0x06
    a974:	8f 81       	ldd	r24, Y+7	; 0x07
    a976:	98 85       	ldd	r25, Y+8	; 0x08
    a978:	60 96       	adiw	r28, 0x10	; 16
    a97a:	cd bf       	out	0x3d, r28	; 61
    a97c:	de bf       	out	0x3e, r29	; 62
    a97e:	df 91       	pop	r29
    a980:	cf 91       	pop	r28
    a982:	0f 91       	pop	r16
    a984:	ff 90       	pop	r15
    a986:	ef 90       	pop	r14
    a988:	df 90       	pop	r13
    a98a:	cf 90       	pop	r12
    a98c:	08 95       	ret

0000a98e <__ashrdi3>:
    a98e:	0f 93       	push	r16
    a990:	cf 93       	push	r28
    a992:	df 93       	push	r29
    a994:	cd b7       	in	r28, 0x3d	; 61
    a996:	de b7       	in	r29, 0x3e	; 62
    a998:	60 97       	sbiw	r28, 0x10	; 16
    a99a:	cd bf       	out	0x3d, r28	; 61
    a99c:	de bf       	out	0x3e, r29	; 62
    a99e:	00 23       	and	r16, r16
    a9a0:	09 f4       	brne	.+2      	; 0xa9a4 <__ashrdi3+0x16>
    a9a2:	56 c0       	rjmp	.+172    	; 0xaa50 <__ashrdi3+0xc2>
    a9a4:	29 87       	std	Y+9, r18	; 0x09
    a9a6:	3a 87       	std	Y+10, r19	; 0x0a
    a9a8:	4b 87       	std	Y+11, r20	; 0x0b
    a9aa:	5c 87       	std	Y+12, r21	; 0x0c
    a9ac:	6d 87       	std	Y+13, r22	; 0x0d
    a9ae:	7e 87       	std	Y+14, r23	; 0x0e
    a9b0:	8f 87       	std	Y+15, r24	; 0x0f
    a9b2:	98 8b       	std	Y+16, r25	; 0x10
    a9b4:	20 e2       	ldi	r18, 0x20	; 32
    a9b6:	20 1b       	sub	r18, r16
    a9b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    a9ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    a9bc:	af 85       	ldd	r26, Y+15	; 0x0f
    a9be:	b8 89       	ldd	r27, Y+16	; 0x10
    a9c0:	ac 01       	movw	r20, r24
    a9c2:	bd 01       	movw	r22, r26
    a9c4:	12 16       	cp	r1, r18
    a9c6:	b4 f0       	brlt	.+44     	; 0xa9f4 <__ashrdi3+0x66>
    a9c8:	77 0f       	add	r23, r23
    a9ca:	44 0b       	sbc	r20, r20
    a9cc:	54 2f       	mov	r21, r20
    a9ce:	ba 01       	movw	r22, r20
    a9d0:	4d 83       	std	Y+5, r20	; 0x05
    a9d2:	5e 83       	std	Y+6, r21	; 0x06
    a9d4:	6f 83       	std	Y+7, r22	; 0x07
    a9d6:	78 87       	std	Y+8, r23	; 0x08
    a9d8:	33 27       	eor	r19, r19
    a9da:	27 fd       	sbrc	r18, 7
    a9dc:	30 95       	com	r19
    a9de:	30 95       	com	r19
    a9e0:	21 95       	neg	r18
    a9e2:	3f 4f       	sbci	r19, 0xFF	; 255
    a9e4:	04 c0       	rjmp	.+8      	; 0xa9ee <__ashrdi3+0x60>
    a9e6:	b5 95       	asr	r27
    a9e8:	a7 95       	ror	r26
    a9ea:	97 95       	ror	r25
    a9ec:	87 95       	ror	r24
    a9ee:	2a 95       	dec	r18
    a9f0:	d2 f7       	brpl	.-12     	; 0xa9e6 <__ashrdi3+0x58>
    a9f2:	22 c0       	rjmp	.+68     	; 0xaa38 <__ashrdi3+0xaa>
    a9f4:	00 2e       	mov	r0, r16
    a9f6:	04 c0       	rjmp	.+8      	; 0xaa00 <__ashrdi3+0x72>
    a9f8:	75 95       	asr	r23
    a9fa:	67 95       	ror	r22
    a9fc:	57 95       	ror	r21
    a9fe:	47 95       	ror	r20
    aa00:	0a 94       	dec	r0
    aa02:	d2 f7       	brpl	.-12     	; 0xa9f8 <__ashrdi3+0x6a>
    aa04:	4d 83       	std	Y+5, r20	; 0x05
    aa06:	5e 83       	std	Y+6, r21	; 0x06
    aa08:	6f 83       	std	Y+7, r22	; 0x07
    aa0a:	78 87       	std	Y+8, r23	; 0x08
    aa0c:	04 c0       	rjmp	.+8      	; 0xaa16 <__ashrdi3+0x88>
    aa0e:	88 0f       	add	r24, r24
    aa10:	99 1f       	adc	r25, r25
    aa12:	aa 1f       	adc	r26, r26
    aa14:	bb 1f       	adc	r27, r27
    aa16:	2a 95       	dec	r18
    aa18:	d2 f7       	brpl	.-12     	; 0xaa0e <__ashrdi3+0x80>
    aa1a:	49 85       	ldd	r20, Y+9	; 0x09
    aa1c:	5a 85       	ldd	r21, Y+10	; 0x0a
    aa1e:	6b 85       	ldd	r22, Y+11	; 0x0b
    aa20:	7c 85       	ldd	r23, Y+12	; 0x0c
    aa22:	04 c0       	rjmp	.+8      	; 0xaa2c <__ashrdi3+0x9e>
    aa24:	76 95       	lsr	r23
    aa26:	67 95       	ror	r22
    aa28:	57 95       	ror	r21
    aa2a:	47 95       	ror	r20
    aa2c:	0a 95       	dec	r16
    aa2e:	d2 f7       	brpl	.-12     	; 0xaa24 <__ashrdi3+0x96>
    aa30:	84 2b       	or	r24, r20
    aa32:	95 2b       	or	r25, r21
    aa34:	a6 2b       	or	r26, r22
    aa36:	b7 2b       	or	r27, r23
    aa38:	89 83       	std	Y+1, r24	; 0x01
    aa3a:	9a 83       	std	Y+2, r25	; 0x02
    aa3c:	ab 83       	std	Y+3, r26	; 0x03
    aa3e:	bc 83       	std	Y+4, r27	; 0x04
    aa40:	29 81       	ldd	r18, Y+1	; 0x01
    aa42:	3a 81       	ldd	r19, Y+2	; 0x02
    aa44:	4b 81       	ldd	r20, Y+3	; 0x03
    aa46:	5c 81       	ldd	r21, Y+4	; 0x04
    aa48:	6d 81       	ldd	r22, Y+5	; 0x05
    aa4a:	7e 81       	ldd	r23, Y+6	; 0x06
    aa4c:	8f 81       	ldd	r24, Y+7	; 0x07
    aa4e:	98 85       	ldd	r25, Y+8	; 0x08
    aa50:	60 96       	adiw	r28, 0x10	; 16
    aa52:	cd bf       	out	0x3d, r28	; 61
    aa54:	de bf       	out	0x3e, r29	; 62
    aa56:	df 91       	pop	r29
    aa58:	cf 91       	pop	r28
    aa5a:	0f 91       	pop	r16
    aa5c:	08 95       	ret

0000aa5e <__divdi3>:
    aa5e:	a8 e4       	ldi	r26, 0x48	; 72
    aa60:	b0 e0       	ldi	r27, 0x00	; 0
    aa62:	e5 e3       	ldi	r30, 0x35	; 53
    aa64:	f5 e5       	ldi	r31, 0x55	; 85
    aa66:	0c 94 e3 5e 	jmp	0xbdc6	; 0xbdc6 <__prologue_saves__+0x2>
    aa6a:	f5 01       	movw	r30, r10
    aa6c:	29 a3       	lds	r18, 0x59
    aa6e:	3a a3       	lds	r19, 0x5a
    aa70:	4b a3       	lds	r20, 0x5b
    aa72:	5c a3       	lds	r21, 0x5c
    aa74:	6d a3       	lds	r22, 0x5d
    aa76:	7e a3       	lds	r23, 0x5e
    aa78:	8f a3       	lds	r24, 0x5f
    aa7a:	98 a7       	lds	r25, 0x78
    aa7c:	a9 8e       	std	Y+25, r10	; 0x19
    aa7e:	fa 8f       	std	Y+26, r31	; 0x1a
    aa80:	cb 8e       	std	Y+27, r12	; 0x1b
    aa82:	dc 8e       	std	Y+28, r13	; 0x1c
    aa84:	ed 8e       	std	Y+29, r14	; 0x1d
    aa86:	fe 8e       	std	Y+30, r15	; 0x1e
    aa88:	0f 8f       	std	Y+31, r16	; 0x1f
    aa8a:	18 a3       	lds	r17, 0x58
    aa8c:	8d a0       	lds	r24, 0x8d
    aa8e:	9e a0       	lds	r25, 0x8e
    aa90:	af a0       	lds	r26, 0x8f
    aa92:	b8 a4       	lds	r27, 0xa8
    aa94:	b7 fe       	sbrs	r11, 7
    aa96:	67 c0       	rjmp	.+206    	; 0xab66 <__divdi3+0x108>
    aa98:	21 95       	neg	r18
    aa9a:	b1 e0       	ldi	r27, 0x01	; 1
    aa9c:	12 16       	cp	r1, r18
    aa9e:	08 f0       	brcs	.+2      	; 0xaaa2 <__divdi3+0x44>
    aaa0:	b0 e0       	ldi	r27, 0x00	; 0
    aaa2:	31 95       	neg	r19
    aaa4:	a1 e0       	ldi	r26, 0x01	; 1
    aaa6:	13 16       	cp	r1, r19
    aaa8:	08 f0       	brcs	.+2      	; 0xaaac <__divdi3+0x4e>
    aaaa:	a0 e0       	ldi	r26, 0x00	; 0
    aaac:	b3 2e       	mov	r11, r19
    aaae:	bb 1a       	sub	r11, r27
    aab0:	bb 2d       	mov	r27, r11
    aab2:	88 24       	eor	r8, r8
    aab4:	83 94       	inc	r8
    aab6:	3b 15       	cp	r19, r11
    aab8:	08 f0       	brcs	.+2      	; 0xaabc <__divdi3+0x5e>
    aaba:	88 24       	eor	r8, r8
    aabc:	a8 29       	or	r26, r8
    aabe:	41 95       	neg	r20
    aac0:	31 e0       	ldi	r19, 0x01	; 1
    aac2:	14 16       	cp	r1, r20
    aac4:	08 f0       	brcs	.+2      	; 0xaac8 <__divdi3+0x6a>
    aac6:	30 e0       	ldi	r19, 0x00	; 0
    aac8:	b4 2e       	mov	r11, r20
    aaca:	ba 1a       	sub	r11, r26
    aacc:	ab 2d       	mov	r26, r11
    aace:	88 24       	eor	r8, r8
    aad0:	83 94       	inc	r8
    aad2:	4b 15       	cp	r20, r11
    aad4:	08 f0       	brcs	.+2      	; 0xaad8 <__divdi3+0x7a>
    aad6:	88 24       	eor	r8, r8
    aad8:	38 29       	or	r19, r8
    aada:	51 95       	neg	r21
    aadc:	41 e0       	ldi	r20, 0x01	; 1
    aade:	15 16       	cp	r1, r21
    aae0:	08 f0       	brcs	.+2      	; 0xaae4 <__divdi3+0x86>
    aae2:	40 e0       	ldi	r20, 0x00	; 0
    aae4:	45 2e       	mov	r4, r21
    aae6:	43 1a       	sub	r4, r19
    aae8:	31 e0       	ldi	r19, 0x01	; 1
    aaea:	54 15       	cp	r21, r4
    aaec:	08 f0       	brcs	.+2      	; 0xaaf0 <__divdi3+0x92>
    aaee:	30 e0       	ldi	r19, 0x00	; 0
    aaf0:	43 2b       	or	r20, r19
    aaf2:	61 95       	neg	r22
    aaf4:	31 e0       	ldi	r19, 0x01	; 1
    aaf6:	16 16       	cp	r1, r22
    aaf8:	08 f0       	brcs	.+2      	; 0xaafc <__divdi3+0x9e>
    aafa:	30 e0       	ldi	r19, 0x00	; 0
    aafc:	86 2e       	mov	r8, r22
    aafe:	84 1a       	sub	r8, r20
    ab00:	41 e0       	ldi	r20, 0x01	; 1
    ab02:	68 15       	cp	r22, r8
    ab04:	08 f0       	brcs	.+2      	; 0xab08 <__divdi3+0xaa>
    ab06:	40 e0       	ldi	r20, 0x00	; 0
    ab08:	34 2b       	or	r19, r20
    ab0a:	71 95       	neg	r23
    ab0c:	41 e0       	ldi	r20, 0x01	; 1
    ab0e:	17 16       	cp	r1, r23
    ab10:	08 f0       	brcs	.+2      	; 0xab14 <__divdi3+0xb6>
    ab12:	40 e0       	ldi	r20, 0x00	; 0
    ab14:	57 2f       	mov	r21, r23
    ab16:	53 1b       	sub	r21, r19
    ab18:	31 e0       	ldi	r19, 0x01	; 1
    ab1a:	75 17       	cp	r23, r21
    ab1c:	08 f0       	brcs	.+2      	; 0xab20 <__divdi3+0xc2>
    ab1e:	30 e0       	ldi	r19, 0x00	; 0
    ab20:	43 2b       	or	r20, r19
    ab22:	81 95       	neg	r24
    ab24:	31 e0       	ldi	r19, 0x01	; 1
    ab26:	18 16       	cp	r1, r24
    ab28:	08 f0       	brcs	.+2      	; 0xab2c <__divdi3+0xce>
    ab2a:	30 e0       	ldi	r19, 0x00	; 0
    ab2c:	68 2f       	mov	r22, r24
    ab2e:	64 1b       	sub	r22, r20
    ab30:	46 2f       	mov	r20, r22
    ab32:	61 e0       	ldi	r22, 0x01	; 1
    ab34:	84 17       	cp	r24, r20
    ab36:	08 f0       	brcs	.+2      	; 0xab3a <__divdi3+0xdc>
    ab38:	60 e0       	ldi	r22, 0x00	; 0
    ab3a:	36 2b       	or	r19, r22
    ab3c:	91 95       	neg	r25
    ab3e:	93 1b       	sub	r25, r19
    ab40:	29 a3       	lds	r18, 0x59
    ab42:	ba a3       	lds	r27, 0x5a
    ab44:	ab a3       	lds	r26, 0x5b
    ab46:	4c a2       	lds	r20, 0x9c
    ab48:	8d a2       	lds	r24, 0x9d
    ab4a:	5e a3       	lds	r21, 0x5e
    ab4c:	4f a3       	lds	r20, 0x5f
    ab4e:	98 a7       	lds	r25, 0x78
    ab50:	8f ef       	ldi	r24, 0xFF	; 255
    ab52:	9f ef       	ldi	r25, 0xFF	; 255
    ab54:	af ef       	ldi	r26, 0xFF	; 255
    ab56:	bf ef       	ldi	r27, 0xFF	; 255
    ab58:	25 96       	adiw	r28, 0x05	; 5
    ab5a:	8c af       	sts	0x7c, r24
    ab5c:	9d af       	sts	0x7d, r25
    ab5e:	ae af       	sts	0x7e, r26
    ab60:	bf af       	sts	0x7f, r27
    ab62:	25 97       	sbiw	r28, 0x05	; 5
    ab64:	06 c0       	rjmp	.+12     	; 0xab72 <__divdi3+0x114>
    ab66:	25 96       	adiw	r28, 0x05	; 5
    ab68:	1c ae       	sts	0xbc, r17
    ab6a:	1d ae       	sts	0xbd, r17
    ab6c:	1e ae       	sts	0xbe, r17
    ab6e:	1f ae       	sts	0xbf, r17
    ab70:	25 97       	sbiw	r28, 0x05	; 5
    ab72:	8d 8d       	ldd	r24, Y+29	; 0x1d
    ab74:	9e 8d       	ldd	r25, Y+30	; 0x1e
    ab76:	af 8d       	ldd	r26, Y+31	; 0x1f
    ab78:	b8 a1       	lds	r27, 0x48
    ab7a:	b7 ff       	sbrs	r27, 7
    ab7c:	68 c0       	rjmp	.+208    	; 0xac4e <__divdi3+0x1f0>
    ab7e:	25 96       	adiw	r28, 0x05	; 5
    ab80:	2c ad       	sts	0x6c, r18
    ab82:	3d ad       	sts	0x6d, r19
    ab84:	4e ad       	sts	0x6e, r20
    ab86:	5f ad       	sts	0x6f, r21
    ab88:	25 97       	sbiw	r28, 0x05	; 5
    ab8a:	20 95       	com	r18
    ab8c:	30 95       	com	r19
    ab8e:	40 95       	com	r20
    ab90:	50 95       	com	r21
    ab92:	25 96       	adiw	r28, 0x05	; 5
    ab94:	2c af       	sts	0x7c, r18
    ab96:	3d af       	sts	0x7d, r19
    ab98:	4e af       	sts	0x7e, r20
    ab9a:	5f af       	sts	0x7f, r21
    ab9c:	25 97       	sbiw	r28, 0x05	; 5
    ab9e:	e1 95       	neg	r30
    aba0:	81 e0       	ldi	r24, 0x01	; 1
    aba2:	1e 16       	cp	r1, r30
    aba4:	08 f0       	brcs	.+2      	; 0xaba8 <__divdi3+0x14a>
    aba6:	80 e0       	ldi	r24, 0x00	; 0
    aba8:	f1 95       	neg	r31
    abaa:	91 e0       	ldi	r25, 0x01	; 1
    abac:	1f 16       	cp	r1, r31
    abae:	08 f0       	brcs	.+2      	; 0xabb2 <__divdi3+0x154>
    abb0:	90 e0       	ldi	r25, 0x00	; 0
    abb2:	4f 2f       	mov	r20, r31
    abb4:	48 1b       	sub	r20, r24
    abb6:	81 e0       	ldi	r24, 0x01	; 1
    abb8:	f4 17       	cp	r31, r20
    abba:	08 f0       	brcs	.+2      	; 0xabbe <__divdi3+0x160>
    abbc:	80 e0       	ldi	r24, 0x00	; 0
    abbe:	98 2b       	or	r25, r24
    abc0:	c1 94       	neg	r12
    abc2:	81 e0       	ldi	r24, 0x01	; 1
    abc4:	1c 14       	cp	r1, r12
    abc6:	08 f0       	brcs	.+2      	; 0xabca <__divdi3+0x16c>
    abc8:	80 e0       	ldi	r24, 0x00	; 0
    abca:	6c 2d       	mov	r22, r12
    abcc:	69 1b       	sub	r22, r25
    abce:	91 e0       	ldi	r25, 0x01	; 1
    abd0:	c6 16       	cp	r12, r22
    abd2:	08 f0       	brcs	.+2      	; 0xabd6 <__divdi3+0x178>
    abd4:	90 e0       	ldi	r25, 0x00	; 0
    abd6:	89 2b       	or	r24, r25
    abd8:	d1 94       	neg	r13
    abda:	91 e0       	ldi	r25, 0x01	; 1
    abdc:	1d 14       	cp	r1, r13
    abde:	08 f0       	brcs	.+2      	; 0xabe2 <__divdi3+0x184>
    abe0:	90 e0       	ldi	r25, 0x00	; 0
    abe2:	5d 2d       	mov	r21, r13
    abe4:	58 1b       	sub	r21, r24
    abe6:	81 e0       	ldi	r24, 0x01	; 1
    abe8:	d5 16       	cp	r13, r21
    abea:	08 f0       	brcs	.+2      	; 0xabee <__divdi3+0x190>
    abec:	80 e0       	ldi	r24, 0x00	; 0
    abee:	98 2b       	or	r25, r24
    abf0:	e1 94       	neg	r14
    abf2:	81 e0       	ldi	r24, 0x01	; 1
    abf4:	1e 14       	cp	r1, r14
    abf6:	08 f0       	brcs	.+2      	; 0xabfa <__divdi3+0x19c>
    abf8:	80 e0       	ldi	r24, 0x00	; 0
    abfa:	3e 2d       	mov	r19, r14
    abfc:	39 1b       	sub	r19, r25
    abfe:	91 e0       	ldi	r25, 0x01	; 1
    ac00:	e3 16       	cp	r14, r19
    ac02:	08 f0       	brcs	.+2      	; 0xac06 <__divdi3+0x1a8>
    ac04:	90 e0       	ldi	r25, 0x00	; 0
    ac06:	89 2b       	or	r24, r25
    ac08:	f1 94       	neg	r15
    ac0a:	91 e0       	ldi	r25, 0x01	; 1
    ac0c:	1f 14       	cp	r1, r15
    ac0e:	08 f0       	brcs	.+2      	; 0xac12 <__divdi3+0x1b4>
    ac10:	90 e0       	ldi	r25, 0x00	; 0
    ac12:	2f 2d       	mov	r18, r15
    ac14:	28 1b       	sub	r18, r24
    ac16:	81 e0       	ldi	r24, 0x01	; 1
    ac18:	f2 16       	cp	r15, r18
    ac1a:	08 f0       	brcs	.+2      	; 0xac1e <__divdi3+0x1c0>
    ac1c:	80 e0       	ldi	r24, 0x00	; 0
    ac1e:	98 2b       	or	r25, r24
    ac20:	01 95       	neg	r16
    ac22:	81 e0       	ldi	r24, 0x01	; 1
    ac24:	10 16       	cp	r1, r16
    ac26:	08 f0       	brcs	.+2      	; 0xac2a <__divdi3+0x1cc>
    ac28:	80 e0       	ldi	r24, 0x00	; 0
    ac2a:	70 2f       	mov	r23, r16
    ac2c:	79 1b       	sub	r23, r25
    ac2e:	97 2f       	mov	r25, r23
    ac30:	71 e0       	ldi	r23, 0x01	; 1
    ac32:	09 17       	cp	r16, r25
    ac34:	08 f0       	brcs	.+2      	; 0xac38 <__divdi3+0x1da>
    ac36:	70 e0       	ldi	r23, 0x00	; 0
    ac38:	87 2b       	or	r24, r23
    ac3a:	11 95       	neg	r17
    ac3c:	18 1b       	sub	r17, r24
    ac3e:	e9 8f       	std	Y+25, r30	; 0x19
    ac40:	4a 8f       	std	Y+26, r20	; 0x1a
    ac42:	6b 8f       	std	Y+27, r22	; 0x1b
    ac44:	5c 8f       	std	Y+28, r21	; 0x1c
    ac46:	3d 8f       	std	Y+29, r19	; 0x1d
    ac48:	2e 8f       	std	Y+30, r18	; 0x1e
    ac4a:	9f 8f       	std	Y+31, r25	; 0x1f
    ac4c:	18 a3       	lds	r17, 0x58
    ac4e:	79 8d       	ldd	r23, Y+25	; 0x19
    ac50:	6a 8d       	ldd	r22, Y+26	; 0x1a
    ac52:	5b 8d       	ldd	r21, Y+27	; 0x1b
    ac54:	4c 8d       	ldd	r20, Y+28	; 0x1c
    ac56:	3d 8d       	ldd	r19, Y+29	; 0x1d
    ac58:	2e 8d       	ldd	r18, Y+30	; 0x1e
    ac5a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    ac5c:	88 a1       	lds	r24, 0x48
    ac5e:	e9 a1       	lds	r30, 0x49
    ac60:	e9 8b       	std	Y+17, r30	; 0x11
    ac62:	ea a1       	lds	r30, 0x4a
    ac64:	ea 8b       	std	Y+18, r30	; 0x12
    ac66:	eb a1       	lds	r30, 0x4b
    ac68:	eb 8b       	std	Y+19, r30	; 0x13
    ac6a:	ec a1       	lds	r30, 0x4c
    ac6c:	ec 8b       	std	Y+20, r30	; 0x14
    ac6e:	ed a1       	lds	r30, 0x4d
    ac70:	ed 8b       	std	Y+21, r30	; 0x15
    ac72:	ee a1       	lds	r30, 0x4e
    ac74:	ee 8b       	std	Y+22, r30	; 0x16
    ac76:	ef a1       	lds	r30, 0x4f
    ac78:	ef 8b       	std	Y+23, r30	; 0x17
    ac7a:	e8 a5       	lds	r30, 0x68
    ac7c:	e8 8f       	std	Y+24, r30	; 0x18
    ac7e:	79 87       	std	Y+9, r23	; 0x09
    ac80:	6a 87       	std	Y+10, r22	; 0x0a
    ac82:	5b 87       	std	Y+11, r21	; 0x0b
    ac84:	4c 87       	std	Y+12, r20	; 0x0c
    ac86:	3d 87       	std	Y+13, r19	; 0x0d
    ac88:	2e 87       	std	Y+14, r18	; 0x0e
    ac8a:	9f 87       	std	Y+15, r25	; 0x0f
    ac8c:	88 8b       	std	Y+16, r24	; 0x10
    ac8e:	89 84       	ldd	r8, Y+9	; 0x09
    ac90:	9a 84       	ldd	r9, Y+10	; 0x0a
    ac92:	ab 84       	ldd	r10, Y+11	; 0x0b
    ac94:	bc 84       	ldd	r11, Y+12	; 0x0c
    ac96:	8d 85       	ldd	r24, Y+13	; 0x0d
    ac98:	9e 85       	ldd	r25, Y+14	; 0x0e
    ac9a:	af 85       	ldd	r26, Y+15	; 0x0f
    ac9c:	b8 89       	ldd	r27, Y+16	; 0x10
    ac9e:	e9 88       	ldd	r14, Y+17	; 0x11
    aca0:	fa 88       	ldd	r15, Y+18	; 0x12
    aca2:	0b 89       	ldd	r16, Y+19	; 0x13
    aca4:	1c 89       	ldd	r17, Y+20	; 0x14
    aca6:	ed aa       	sts	0x9d, r30
    aca8:	fe aa       	sts	0x9e, r31
    acaa:	0f ab       	sts	0x5f, r16
    acac:	18 af       	sts	0x78, r17
    acae:	cd 88       	ldd	r12, Y+21	; 0x15
    acb0:	de 88       	ldd	r13, Y+22	; 0x16
    acb2:	ef 88       	ldd	r14, Y+23	; 0x17
    acb4:	f8 8c       	ldd	r15, Y+24	; 0x18
    acb6:	00 97       	sbiw	r24, 0x00	; 0
    acb8:	a1 05       	cpc	r26, r1
    acba:	b1 05       	cpc	r27, r1
    acbc:	09 f0       	breq	.+2      	; 0xacc0 <__divdi3+0x262>
    acbe:	bd c3       	rjmp	.+1914   	; 0xb43a <__divdi3+0x9dc>
    acc0:	c8 14       	cp	r12, r8
    acc2:	d9 04       	cpc	r13, r9
    acc4:	ea 04       	cpc	r14, r10
    acc6:	fb 04       	cpc	r15, r11
    acc8:	08 f0       	brcs	.+2      	; 0xaccc <__divdi3+0x26e>
    acca:	4d c1       	rjmp	.+666    	; 0xaf66 <__divdi3+0x508>
    accc:	00 e0       	ldi	r16, 0x00	; 0
    acce:	80 16       	cp	r8, r16
    acd0:	00 e0       	ldi	r16, 0x00	; 0
    acd2:	90 06       	cpc	r9, r16
    acd4:	01 e0       	ldi	r16, 0x01	; 1
    acd6:	a0 06       	cpc	r10, r16
    acd8:	00 e0       	ldi	r16, 0x00	; 0
    acda:	b0 06       	cpc	r11, r16
    acdc:	58 f4       	brcc	.+22     	; 0xacf4 <__divdi3+0x296>
    acde:	1f ef       	ldi	r17, 0xFF	; 255
    ace0:	81 16       	cp	r8, r17
    ace2:	91 04       	cpc	r9, r1
    ace4:	a1 04       	cpc	r10, r1
    ace6:	b1 04       	cpc	r11, r1
    ace8:	09 f0       	breq	.+2      	; 0xacec <__divdi3+0x28e>
    acea:	90 f4       	brcc	.+36     	; 0xad10 <__divdi3+0x2b2>
    acec:	80 e0       	ldi	r24, 0x00	; 0
    acee:	90 e0       	ldi	r25, 0x00	; 0
    acf0:	dc 01       	movw	r26, r24
    acf2:	17 c0       	rjmp	.+46     	; 0xad22 <__divdi3+0x2c4>
    acf4:	20 e0       	ldi	r18, 0x00	; 0
    acf6:	82 16       	cp	r8, r18
    acf8:	20 e0       	ldi	r18, 0x00	; 0
    acfa:	92 06       	cpc	r9, r18
    acfc:	20 e0       	ldi	r18, 0x00	; 0
    acfe:	a2 06       	cpc	r10, r18
    ad00:	21 e0       	ldi	r18, 0x01	; 1
    ad02:	b2 06       	cpc	r11, r18
    ad04:	50 f4       	brcc	.+20     	; 0xad1a <__divdi3+0x2bc>
    ad06:	80 e1       	ldi	r24, 0x10	; 16
    ad08:	90 e0       	ldi	r25, 0x00	; 0
    ad0a:	a0 e0       	ldi	r26, 0x00	; 0
    ad0c:	b0 e0       	ldi	r27, 0x00	; 0
    ad0e:	09 c0       	rjmp	.+18     	; 0xad22 <__divdi3+0x2c4>
    ad10:	88 e0       	ldi	r24, 0x08	; 8
    ad12:	90 e0       	ldi	r25, 0x00	; 0
    ad14:	a0 e0       	ldi	r26, 0x00	; 0
    ad16:	b0 e0       	ldi	r27, 0x00	; 0
    ad18:	04 c0       	rjmp	.+8      	; 0xad22 <__divdi3+0x2c4>
    ad1a:	88 e1       	ldi	r24, 0x18	; 24
    ad1c:	90 e0       	ldi	r25, 0x00	; 0
    ad1e:	a0 e0       	ldi	r26, 0x00	; 0
    ad20:	b0 e0       	ldi	r27, 0x00	; 0
    ad22:	b5 01       	movw	r22, r10
    ad24:	a4 01       	movw	r20, r8
    ad26:	08 2e       	mov	r0, r24
    ad28:	04 c0       	rjmp	.+8      	; 0xad32 <__divdi3+0x2d4>
    ad2a:	76 95       	lsr	r23
    ad2c:	67 95       	ror	r22
    ad2e:	57 95       	ror	r21
    ad30:	47 95       	ror	r20
    ad32:	0a 94       	dec	r0
    ad34:	d2 f7       	brpl	.-12     	; 0xad2a <__divdi3+0x2cc>
    ad36:	fa 01       	movw	r30, r20
    ad38:	e3 5d       	subi	r30, 0xD3	; 211
    ad3a:	ff 4d       	sbci	r31, 0xDF	; 223
    ad3c:	20 81       	ld	r18, Z
    ad3e:	40 e2       	ldi	r20, 0x20	; 32
    ad40:	50 e0       	ldi	r21, 0x00	; 0
    ad42:	60 e0       	ldi	r22, 0x00	; 0
    ad44:	70 e0       	ldi	r23, 0x00	; 0
    ad46:	48 1b       	sub	r20, r24
    ad48:	59 0b       	sbc	r21, r25
    ad4a:	6a 0b       	sbc	r22, r26
    ad4c:	7b 0b       	sbc	r23, r27
    ad4e:	42 1b       	sub	r20, r18
    ad50:	51 09       	sbc	r21, r1
    ad52:	61 09       	sbc	r22, r1
    ad54:	71 09       	sbc	r23, r1
    ad56:	41 15       	cp	r20, r1
    ad58:	51 05       	cpc	r21, r1
    ad5a:	61 05       	cpc	r22, r1
    ad5c:	71 05       	cpc	r23, r1
    ad5e:	a1 f1       	breq	.+104    	; 0xadc8 <__divdi3+0x36a>
    ad60:	04 2e       	mov	r0, r20
    ad62:	04 c0       	rjmp	.+8      	; 0xad6c <__divdi3+0x30e>
    ad64:	88 0c       	add	r8, r8
    ad66:	99 1c       	adc	r9, r9
    ad68:	aa 1c       	adc	r10, r10
    ad6a:	bb 1c       	adc	r11, r11
    ad6c:	0a 94       	dec	r0
    ad6e:	d2 f7       	brpl	.-12     	; 0xad64 <__divdi3+0x306>
    ad70:	97 01       	movw	r18, r14
    ad72:	86 01       	movw	r16, r12
    ad74:	04 2e       	mov	r0, r20
    ad76:	04 c0       	rjmp	.+8      	; 0xad80 <__divdi3+0x322>
    ad78:	00 0f       	add	r16, r16
    ad7a:	11 1f       	adc	r17, r17
    ad7c:	22 1f       	adc	r18, r18
    ad7e:	33 1f       	adc	r19, r19
    ad80:	0a 94       	dec	r0
    ad82:	d2 f7       	brpl	.-12     	; 0xad78 <__divdi3+0x31a>
    ad84:	80 e2       	ldi	r24, 0x20	; 32
    ad86:	90 e0       	ldi	r25, 0x00	; 0
    ad88:	84 1b       	sub	r24, r20
    ad8a:	95 0b       	sbc	r25, r21
    ad8c:	cd a8       	sts	0x8d, r28
    ad8e:	de a8       	sts	0x8e, r29
    ad90:	ef a8       	sts	0x8f, r30
    ad92:	f8 ac       	sts	0xa8, r31
    ad94:	04 c0       	rjmp	.+8      	; 0xad9e <__divdi3+0x340>
    ad96:	f6 94       	lsr	r15
    ad98:	e7 94       	ror	r14
    ad9a:	d7 94       	ror	r13
    ad9c:	c7 94       	ror	r12
    ad9e:	8a 95       	dec	r24
    ada0:	d2 f7       	brpl	.-12     	; 0xad96 <__divdi3+0x338>
    ada2:	c0 2a       	or	r12, r16
    ada4:	d1 2a       	or	r13, r17
    ada6:	e2 2a       	or	r14, r18
    ada8:	f3 2a       	or	r15, r19
    adaa:	0d a9       	sts	0x4d, r16
    adac:	1e a9       	sts	0x4e, r17
    adae:	2f a9       	sts	0x4f, r18
    adb0:	38 ad       	sts	0x68, r19
    adb2:	04 c0       	rjmp	.+8      	; 0xadbc <__divdi3+0x35e>
    adb4:	00 0f       	add	r16, r16
    adb6:	11 1f       	adc	r17, r17
    adb8:	22 1f       	adc	r18, r18
    adba:	33 1f       	adc	r19, r19
    adbc:	4a 95       	dec	r20
    adbe:	d2 f7       	brpl	.-12     	; 0xadb4 <__divdi3+0x356>
    adc0:	0d ab       	sts	0x5d, r16
    adc2:	1e ab       	sts	0x5e, r17
    adc4:	2f ab       	sts	0x5f, r18
    adc6:	38 af       	sts	0x78, r19
    adc8:	25 01       	movw	r4, r10
    adca:	66 24       	eor	r6, r6
    adcc:	77 24       	eor	r7, r7
    adce:	95 01       	movw	r18, r10
    add0:	84 01       	movw	r16, r8
    add2:	20 70       	andi	r18, 0x00	; 0
    add4:	30 70       	andi	r19, 0x00	; 0
    add6:	09 ab       	sts	0x59, r16
    add8:	1a ab       	sts	0x5a, r17
    adda:	2b ab       	sts	0x5b, r18
    addc:	3c ab       	sts	0x5c, r19
    adde:	c7 01       	movw	r24, r14
    ade0:	b6 01       	movw	r22, r12
    ade2:	a3 01       	movw	r20, r6
    ade4:	92 01       	movw	r18, r4
    ade6:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    adea:	2d a7       	lds	r18, 0x7d
    adec:	3e a7       	lds	r19, 0x7e
    adee:	4f a7       	lds	r20, 0x7f
    adf0:	58 ab       	sts	0x58, r21
    adf2:	69 a7       	lds	r22, 0x79
    adf4:	7a a7       	lds	r23, 0x7a
    adf6:	8b a7       	lds	r24, 0x7b
    adf8:	9c a7       	lds	r25, 0x7c
    adfa:	c7 01       	movw	r24, r14
    adfc:	b6 01       	movw	r22, r12
    adfe:	a3 01       	movw	r20, r6
    ae00:	92 01       	movw	r18, r4
    ae02:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    ae06:	ca 01       	movw	r24, r20
    ae08:	b9 01       	movw	r22, r18
    ae0a:	29 a9       	sts	0x49, r18
    ae0c:	3a a9       	sts	0x4a, r19
    ae0e:	4b a9       	sts	0x4b, r20
    ae10:	5c a9       	sts	0x4c, r21
    ae12:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    ae16:	ab 01       	movw	r20, r22
    ae18:	bc 01       	movw	r22, r24
    ae1a:	09 a5       	lds	r16, 0x69
    ae1c:	1a a5       	lds	r17, 0x6a
    ae1e:	2b a5       	lds	r18, 0x6b
    ae20:	3c a5       	lds	r19, 0x6c
    ae22:	78 01       	movw	r14, r16
    ae24:	dd 24       	eor	r13, r13
    ae26:	cc 24       	eor	r12, r12
    ae28:	0d a9       	sts	0x4d, r16
    ae2a:	1e a9       	sts	0x4e, r17
    ae2c:	2f a9       	sts	0x4f, r18
    ae2e:	38 ad       	sts	0x68, r19
    ae30:	c9 01       	movw	r24, r18
    ae32:	aa 27       	eor	r26, r26
    ae34:	bb 27       	eor	r27, r27
    ae36:	c8 2a       	or	r12, r24
    ae38:	d9 2a       	or	r13, r25
    ae3a:	ea 2a       	or	r14, r26
    ae3c:	fb 2a       	or	r15, r27
    ae3e:	0d a5       	lds	r16, 0x6d
    ae40:	1e a5       	lds	r17, 0x6e
    ae42:	2f a5       	lds	r18, 0x6f
    ae44:	38 a9       	sts	0x48, r19
    ae46:	c4 16       	cp	r12, r20
    ae48:	d5 06       	cpc	r13, r21
    ae4a:	e6 06       	cpc	r14, r22
    ae4c:	f7 06       	cpc	r15, r23
    ae4e:	38 f5       	brcc	.+78     	; 0xae9e <__divdi3+0x440>
    ae50:	01 50       	subi	r16, 0x01	; 1
    ae52:	10 40       	sbci	r17, 0x00	; 0
    ae54:	20 40       	sbci	r18, 0x00	; 0
    ae56:	30 40       	sbci	r19, 0x00	; 0
    ae58:	09 a7       	lds	r16, 0x79
    ae5a:	1a a7       	lds	r17, 0x7a
    ae5c:	2b a7       	lds	r18, 0x7b
    ae5e:	3c a7       	lds	r19, 0x7c
    ae60:	c8 0c       	add	r12, r8
    ae62:	d9 1c       	adc	r13, r9
    ae64:	ea 1c       	adc	r14, r10
    ae66:	fb 1c       	adc	r15, r11
    ae68:	c8 14       	cp	r12, r8
    ae6a:	d9 04       	cpc	r13, r9
    ae6c:	ea 04       	cpc	r14, r10
    ae6e:	fb 04       	cpc	r15, r11
    ae70:	d0 f0       	brcs	.+52     	; 0xaea6 <__divdi3+0x448>
    ae72:	c4 16       	cp	r12, r20
    ae74:	d5 06       	cpc	r13, r21
    ae76:	e6 06       	cpc	r14, r22
    ae78:	f7 06       	cpc	r15, r23
    ae7a:	a8 f4       	brcc	.+42     	; 0xaea6 <__divdi3+0x448>
    ae7c:	0d a5       	lds	r16, 0x6d
    ae7e:	1e a5       	lds	r17, 0x6e
    ae80:	2f a5       	lds	r18, 0x6f
    ae82:	38 a9       	sts	0x48, r19
    ae84:	02 50       	subi	r16, 0x02	; 2
    ae86:	10 40       	sbci	r17, 0x00	; 0
    ae88:	20 40       	sbci	r18, 0x00	; 0
    ae8a:	30 40       	sbci	r19, 0x00	; 0
    ae8c:	09 a7       	lds	r16, 0x79
    ae8e:	1a a7       	lds	r17, 0x7a
    ae90:	2b a7       	lds	r18, 0x7b
    ae92:	3c a7       	lds	r19, 0x7c
    ae94:	c8 0c       	add	r12, r8
    ae96:	d9 1c       	adc	r13, r9
    ae98:	ea 1c       	adc	r14, r10
    ae9a:	fb 1c       	adc	r15, r11
    ae9c:	04 c0       	rjmp	.+8      	; 0xaea6 <__divdi3+0x448>
    ae9e:	09 a7       	lds	r16, 0x79
    aea0:	1a a7       	lds	r17, 0x7a
    aea2:	2b a7       	lds	r18, 0x7b
    aea4:	3c a7       	lds	r19, 0x7c
    aea6:	c4 1a       	sub	r12, r20
    aea8:	d5 0a       	sbc	r13, r21
    aeaa:	e6 0a       	sbc	r14, r22
    aeac:	f7 0a       	sbc	r15, r23
    aeae:	c7 01       	movw	r24, r14
    aeb0:	b6 01       	movw	r22, r12
    aeb2:	a3 01       	movw	r20, r6
    aeb4:	92 01       	movw	r18, r4
    aeb6:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    aeba:	2d a7       	lds	r18, 0x7d
    aebc:	3e a7       	lds	r19, 0x7e
    aebe:	4f a7       	lds	r20, 0x7f
    aec0:	58 ab       	sts	0x58, r21
    aec2:	69 af       	sts	0x79, r22
    aec4:	7a af       	sts	0x7a, r23
    aec6:	8b af       	sts	0x7b, r24
    aec8:	9c af       	sts	0x7c, r25
    aeca:	c7 01       	movw	r24, r14
    aecc:	b6 01       	movw	r22, r12
    aece:	a3 01       	movw	r20, r6
    aed0:	92 01       	movw	r18, r4
    aed2:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    aed6:	ca 01       	movw	r24, r20
    aed8:	b9 01       	movw	r22, r18
    aeda:	29 a9       	sts	0x49, r18
    aedc:	3a a9       	sts	0x4a, r19
    aede:	4b a9       	sts	0x4b, r20
    aee0:	5c a9       	sts	0x4c, r21
    aee2:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    aee6:	6b 01       	movw	r12, r22
    aee8:	7c 01       	movw	r14, r24
    aeea:	49 ad       	sts	0x69, r20
    aeec:	5a ad       	sts	0x6a, r21
    aeee:	6b ad       	sts	0x6b, r22
    aef0:	7c ad       	sts	0x6c, r23
    aef2:	9a 01       	movw	r18, r20
    aef4:	11 27       	eor	r17, r17
    aef6:	00 27       	eor	r16, r16
    aef8:	4d a9       	sts	0x4d, r20
    aefa:	5e a9       	sts	0x4e, r21
    aefc:	6f a9       	sts	0x4f, r22
    aefe:	78 ad       	sts	0x68, r23
    af00:	60 70       	andi	r22, 0x00	; 0
    af02:	70 70       	andi	r23, 0x00	; 0
    af04:	04 2b       	or	r16, r20
    af06:	15 2b       	or	r17, r21
    af08:	26 2b       	or	r18, r22
    af0a:	37 2b       	or	r19, r23
    af0c:	8d a5       	lds	r24, 0x6d
    af0e:	9e a5       	lds	r25, 0x6e
    af10:	af a5       	lds	r26, 0x6f
    af12:	b8 a9       	sts	0x48, r27
    af14:	0c 15       	cp	r16, r12
    af16:	1d 05       	cpc	r17, r13
    af18:	2e 05       	cpc	r18, r14
    af1a:	3f 05       	cpc	r19, r15
    af1c:	c0 f4       	brcc	.+48     	; 0xaf4e <__divdi3+0x4f0>
    af1e:	01 97       	sbiw	r24, 0x01	; 1
    af20:	a1 09       	sbc	r26, r1
    af22:	b1 09       	sbc	r27, r1
    af24:	08 0d       	add	r16, r8
    af26:	19 1d       	adc	r17, r9
    af28:	2a 1d       	adc	r18, r10
    af2a:	3b 1d       	adc	r19, r11
    af2c:	08 15       	cp	r16, r8
    af2e:	19 05       	cpc	r17, r9
    af30:	2a 05       	cpc	r18, r10
    af32:	3b 05       	cpc	r19, r11
    af34:	60 f0       	brcs	.+24     	; 0xaf4e <__divdi3+0x4f0>
    af36:	0c 15       	cp	r16, r12
    af38:	1d 05       	cpc	r17, r13
    af3a:	2e 05       	cpc	r18, r14
    af3c:	3f 05       	cpc	r19, r15
    af3e:	38 f4       	brcc	.+14     	; 0xaf4e <__divdi3+0x4f0>
    af40:	8d a5       	lds	r24, 0x6d
    af42:	9e a5       	lds	r25, 0x6e
    af44:	af a5       	lds	r26, 0x6f
    af46:	b8 a9       	sts	0x48, r27
    af48:	02 97       	sbiw	r24, 0x02	; 2
    af4a:	a1 09       	sbc	r26, r1
    af4c:	b1 09       	sbc	r27, r1
    af4e:	09 a5       	lds	r16, 0x69
    af50:	1a a5       	lds	r17, 0x6a
    af52:	2b a5       	lds	r18, 0x6b
    af54:	3c a5       	lds	r19, 0x6c
    af56:	78 01       	movw	r14, r16
    af58:	dd 24       	eor	r13, r13
    af5a:	cc 24       	eor	r12, r12
    af5c:	c8 2a       	or	r12, r24
    af5e:	d9 2a       	or	r13, r25
    af60:	ea 2a       	or	r14, r26
    af62:	fb 2a       	or	r15, r27
    af64:	b7 c4       	rjmp	.+2414   	; 0xb8d4 <__divdi3+0xe76>
    af66:	81 14       	cp	r8, r1
    af68:	91 04       	cpc	r9, r1
    af6a:	a1 04       	cpc	r10, r1
    af6c:	b1 04       	cpc	r11, r1
    af6e:	51 f4       	brne	.+20     	; 0xaf84 <__divdi3+0x526>
    af70:	61 e0       	ldi	r22, 0x01	; 1
    af72:	70 e0       	ldi	r23, 0x00	; 0
    af74:	80 e0       	ldi	r24, 0x00	; 0
    af76:	90 e0       	ldi	r25, 0x00	; 0
    af78:	a5 01       	movw	r20, r10
    af7a:	94 01       	movw	r18, r8
    af7c:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    af80:	49 01       	movw	r8, r18
    af82:	5a 01       	movw	r10, r20
    af84:	10 e0       	ldi	r17, 0x00	; 0
    af86:	81 16       	cp	r8, r17
    af88:	10 e0       	ldi	r17, 0x00	; 0
    af8a:	91 06       	cpc	r9, r17
    af8c:	11 e0       	ldi	r17, 0x01	; 1
    af8e:	a1 06       	cpc	r10, r17
    af90:	10 e0       	ldi	r17, 0x00	; 0
    af92:	b1 06       	cpc	r11, r17
    af94:	58 f4       	brcc	.+22     	; 0xafac <__divdi3+0x54e>
    af96:	2f ef       	ldi	r18, 0xFF	; 255
    af98:	82 16       	cp	r8, r18
    af9a:	91 04       	cpc	r9, r1
    af9c:	a1 04       	cpc	r10, r1
    af9e:	b1 04       	cpc	r11, r1
    afa0:	09 f0       	breq	.+2      	; 0xafa4 <__divdi3+0x546>
    afa2:	90 f4       	brcc	.+36     	; 0xafc8 <__divdi3+0x56a>
    afa4:	80 e0       	ldi	r24, 0x00	; 0
    afa6:	90 e0       	ldi	r25, 0x00	; 0
    afa8:	dc 01       	movw	r26, r24
    afaa:	17 c0       	rjmp	.+46     	; 0xafda <__divdi3+0x57c>
    afac:	30 e0       	ldi	r19, 0x00	; 0
    afae:	83 16       	cp	r8, r19
    afb0:	30 e0       	ldi	r19, 0x00	; 0
    afb2:	93 06       	cpc	r9, r19
    afb4:	30 e0       	ldi	r19, 0x00	; 0
    afb6:	a3 06       	cpc	r10, r19
    afb8:	31 e0       	ldi	r19, 0x01	; 1
    afba:	b3 06       	cpc	r11, r19
    afbc:	50 f4       	brcc	.+20     	; 0xafd2 <__divdi3+0x574>
    afbe:	80 e1       	ldi	r24, 0x10	; 16
    afc0:	90 e0       	ldi	r25, 0x00	; 0
    afc2:	a0 e0       	ldi	r26, 0x00	; 0
    afc4:	b0 e0       	ldi	r27, 0x00	; 0
    afc6:	09 c0       	rjmp	.+18     	; 0xafda <__divdi3+0x57c>
    afc8:	88 e0       	ldi	r24, 0x08	; 8
    afca:	90 e0       	ldi	r25, 0x00	; 0
    afcc:	a0 e0       	ldi	r26, 0x00	; 0
    afce:	b0 e0       	ldi	r27, 0x00	; 0
    afd0:	04 c0       	rjmp	.+8      	; 0xafda <__divdi3+0x57c>
    afd2:	88 e1       	ldi	r24, 0x18	; 24
    afd4:	90 e0       	ldi	r25, 0x00	; 0
    afd6:	a0 e0       	ldi	r26, 0x00	; 0
    afd8:	b0 e0       	ldi	r27, 0x00	; 0
    afda:	b5 01       	movw	r22, r10
    afdc:	a4 01       	movw	r20, r8
    afde:	08 2e       	mov	r0, r24
    afe0:	04 c0       	rjmp	.+8      	; 0xafea <__divdi3+0x58c>
    afe2:	76 95       	lsr	r23
    afe4:	67 95       	ror	r22
    afe6:	57 95       	ror	r21
    afe8:	47 95       	ror	r20
    afea:	0a 94       	dec	r0
    afec:	d2 f7       	brpl	.-12     	; 0xafe2 <__divdi3+0x584>
    afee:	fa 01       	movw	r30, r20
    aff0:	e3 5d       	subi	r30, 0xD3	; 211
    aff2:	ff 4d       	sbci	r31, 0xDF	; 223
    aff4:	20 81       	ld	r18, Z
    aff6:	ac 01       	movw	r20, r24
    aff8:	bd 01       	movw	r22, r26
    affa:	42 0f       	add	r20, r18
    affc:	51 1d       	adc	r21, r1
    affe:	61 1d       	adc	r22, r1
    b000:	71 1d       	adc	r23, r1
    b002:	80 e2       	ldi	r24, 0x20	; 32
    b004:	90 e0       	ldi	r25, 0x00	; 0
    b006:	a0 e0       	ldi	r26, 0x00	; 0
    b008:	b0 e0       	ldi	r27, 0x00	; 0
    b00a:	84 1b       	sub	r24, r20
    b00c:	95 0b       	sbc	r25, r21
    b00e:	a6 0b       	sbc	r26, r22
    b010:	b7 0b       	sbc	r27, r23
    b012:	51 f4       	brne	.+20     	; 0xb028 <__divdi3+0x5ca>
    b014:	c8 18       	sub	r12, r8
    b016:	d9 08       	sbc	r13, r9
    b018:	ea 08       	sbc	r14, r10
    b01a:	fb 08       	sbc	r15, r11
    b01c:	f1 e0       	ldi	r31, 0x01	; 1
    b01e:	4f 2e       	mov	r4, r31
    b020:	51 2c       	mov	r5, r1
    b022:	61 2c       	mov	r6, r1
    b024:	71 2c       	mov	r7, r1
    b026:	28 c1       	rjmp	.+592    	; 0xb278 <__divdi3+0x81a>
    b028:	08 2e       	mov	r0, r24
    b02a:	04 c0       	rjmp	.+8      	; 0xb034 <__divdi3+0x5d6>
    b02c:	88 0c       	add	r8, r8
    b02e:	99 1c       	adc	r9, r9
    b030:	aa 1c       	adc	r10, r10
    b032:	bb 1c       	adc	r11, r11
    b034:	0a 94       	dec	r0
    b036:	d2 f7       	brpl	.-12     	; 0xb02c <__divdi3+0x5ce>
    b038:	97 01       	movw	r18, r14
    b03a:	86 01       	movw	r16, r12
    b03c:	04 2e       	mov	r0, r20
    b03e:	04 c0       	rjmp	.+8      	; 0xb048 <__divdi3+0x5ea>
    b040:	36 95       	lsr	r19
    b042:	27 95       	ror	r18
    b044:	17 95       	ror	r17
    b046:	07 95       	ror	r16
    b048:	0a 94       	dec	r0
    b04a:	d2 f7       	brpl	.-12     	; 0xb040 <__divdi3+0x5e2>
    b04c:	09 ab       	sts	0x59, r16
    b04e:	1a ab       	sts	0x5a, r17
    b050:	2b ab       	sts	0x5b, r18
    b052:	3c ab       	sts	0x5c, r19
    b054:	97 01       	movw	r18, r14
    b056:	86 01       	movw	r16, r12
    b058:	08 2e       	mov	r0, r24
    b05a:	04 c0       	rjmp	.+8      	; 0xb064 <__divdi3+0x606>
    b05c:	00 0f       	add	r16, r16
    b05e:	11 1f       	adc	r17, r17
    b060:	22 1f       	adc	r18, r18
    b062:	33 1f       	adc	r19, r19
    b064:	0a 94       	dec	r0
    b066:	d2 f7       	brpl	.-12     	; 0xb05c <__divdi3+0x5fe>
    b068:	0d a7       	lds	r16, 0x7d
    b06a:	1e a7       	lds	r17, 0x7e
    b06c:	2f a7       	lds	r18, 0x7f
    b06e:	38 ab       	sts	0x58, r19
    b070:	ed a8       	sts	0x8d, r30
    b072:	fe a8       	sts	0x8e, r31
    b074:	0f a9       	sts	0x4f, r16
    b076:	18 ad       	sts	0x68, r17
    b078:	04 c0       	rjmp	.+8      	; 0xb082 <__divdi3+0x624>
    b07a:	16 95       	lsr	r17
    b07c:	07 95       	ror	r16
    b07e:	f7 94       	ror	r15
    b080:	e7 94       	ror	r14
    b082:	4a 95       	dec	r20
    b084:	d2 f7       	brpl	.-12     	; 0xb07a <__divdi3+0x61c>
    b086:	b8 01       	movw	r22, r16
    b088:	a7 01       	movw	r20, r14
    b08a:	0d a5       	lds	r16, 0x6d
    b08c:	1e a5       	lds	r17, 0x6e
    b08e:	2f a5       	lds	r18, 0x6f
    b090:	38 a9       	sts	0x48, r19
    b092:	04 2b       	or	r16, r20
    b094:	15 2b       	or	r17, r21
    b096:	26 2b       	or	r18, r22
    b098:	37 2b       	or	r19, r23
    b09a:	0d a7       	lds	r16, 0x7d
    b09c:	1e a7       	lds	r17, 0x7e
    b09e:	2f a7       	lds	r18, 0x7f
    b0a0:	38 ab       	sts	0x58, r19
    b0a2:	ed a8       	sts	0x8d, r30
    b0a4:	fe a8       	sts	0x8e, r31
    b0a6:	0f a9       	sts	0x4f, r16
    b0a8:	18 ad       	sts	0x68, r17
    b0aa:	04 c0       	rjmp	.+8      	; 0xb0b4 <__divdi3+0x656>
    b0ac:	ee 0c       	add	r14, r14
    b0ae:	ff 1c       	adc	r15, r15
    b0b0:	00 1f       	adc	r16, r16
    b0b2:	11 1f       	adc	r17, r17
    b0b4:	8a 95       	dec	r24
    b0b6:	d2 f7       	brpl	.-12     	; 0xb0ac <__divdi3+0x64e>
    b0b8:	ed aa       	sts	0x9d, r30
    b0ba:	fe aa       	sts	0x9e, r31
    b0bc:	0f ab       	sts	0x5f, r16
    b0be:	18 af       	sts	0x78, r17
    b0c0:	25 01       	movw	r4, r10
    b0c2:	66 24       	eor	r6, r6
    b0c4:	77 24       	eor	r7, r7
    b0c6:	95 01       	movw	r18, r10
    b0c8:	84 01       	movw	r16, r8
    b0ca:	20 70       	andi	r18, 0x00	; 0
    b0cc:	30 70       	andi	r19, 0x00	; 0
    b0ce:	09 af       	sts	0x79, r16
    b0d0:	1a af       	sts	0x7a, r17
    b0d2:	2b af       	sts	0x7b, r18
    b0d4:	3c af       	sts	0x7c, r19
    b0d6:	69 a9       	sts	0x49, r22
    b0d8:	7a a9       	sts	0x4a, r23
    b0da:	8b a9       	sts	0x4b, r24
    b0dc:	9c a9       	sts	0x4c, r25
    b0de:	a3 01       	movw	r20, r6
    b0e0:	92 01       	movw	r18, r4
    b0e2:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b0e6:	29 a7       	lds	r18, 0x79
    b0e8:	3a a7       	lds	r19, 0x7a
    b0ea:	4b a7       	lds	r20, 0x7b
    b0ec:	5c a7       	lds	r21, 0x7c
    b0ee:	6b 01       	movw	r12, r22
    b0f0:	7c 01       	movw	r14, r24
    b0f2:	69 a9       	sts	0x49, r22
    b0f4:	7a a9       	sts	0x4a, r23
    b0f6:	8b a9       	sts	0x4b, r24
    b0f8:	9c a9       	sts	0x4c, r25
    b0fa:	a3 01       	movw	r20, r6
    b0fc:	92 01       	movw	r18, r4
    b0fe:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b102:	ca 01       	movw	r24, r20
    b104:	b9 01       	movw	r22, r18
    b106:	29 ad       	sts	0x69, r18
    b108:	3a ad       	sts	0x6a, r19
    b10a:	4b ad       	sts	0x6b, r20
    b10c:	5c ad       	sts	0x6c, r21
    b10e:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b112:	ab 01       	movw	r20, r22
    b114:	bc 01       	movw	r22, r24
    b116:	76 01       	movw	r14, r12
    b118:	dd 24       	eor	r13, r13
    b11a:	cc 24       	eor	r12, r12
    b11c:	0d a5       	lds	r16, 0x6d
    b11e:	1e a5       	lds	r17, 0x6e
    b120:	2f a5       	lds	r18, 0x6f
    b122:	38 a9       	sts	0x48, r19
    b124:	c9 01       	movw	r24, r18
    b126:	aa 27       	eor	r26, r26
    b128:	bb 27       	eor	r27, r27
    b12a:	c8 2a       	or	r12, r24
    b12c:	d9 2a       	or	r13, r25
    b12e:	ea 2a       	or	r14, r26
    b130:	fb 2a       	or	r15, r27
    b132:	09 a5       	lds	r16, 0x69
    b134:	1a a5       	lds	r17, 0x6a
    b136:	2b a5       	lds	r18, 0x6b
    b138:	3c a5       	lds	r19, 0x6c
    b13a:	c4 16       	cp	r12, r20
    b13c:	d5 06       	cpc	r13, r21
    b13e:	e6 06       	cpc	r14, r22
    b140:	f7 06       	cpc	r15, r23
    b142:	38 f5       	brcc	.+78     	; 0xb192 <__divdi3+0x734>
    b144:	01 50       	subi	r16, 0x01	; 1
    b146:	10 40       	sbci	r17, 0x00	; 0
    b148:	20 40       	sbci	r18, 0x00	; 0
    b14a:	30 40       	sbci	r19, 0x00	; 0
    b14c:	09 ab       	sts	0x59, r16
    b14e:	1a ab       	sts	0x5a, r17
    b150:	2b ab       	sts	0x5b, r18
    b152:	3c ab       	sts	0x5c, r19
    b154:	c8 0c       	add	r12, r8
    b156:	d9 1c       	adc	r13, r9
    b158:	ea 1c       	adc	r14, r10
    b15a:	fb 1c       	adc	r15, r11
    b15c:	c8 14       	cp	r12, r8
    b15e:	d9 04       	cpc	r13, r9
    b160:	ea 04       	cpc	r14, r10
    b162:	fb 04       	cpc	r15, r11
    b164:	d0 f0       	brcs	.+52     	; 0xb19a <__divdi3+0x73c>
    b166:	c4 16       	cp	r12, r20
    b168:	d5 06       	cpc	r13, r21
    b16a:	e6 06       	cpc	r14, r22
    b16c:	f7 06       	cpc	r15, r23
    b16e:	a8 f4       	brcc	.+42     	; 0xb19a <__divdi3+0x73c>
    b170:	09 a5       	lds	r16, 0x69
    b172:	1a a5       	lds	r17, 0x6a
    b174:	2b a5       	lds	r18, 0x6b
    b176:	3c a5       	lds	r19, 0x6c
    b178:	02 50       	subi	r16, 0x02	; 2
    b17a:	10 40       	sbci	r17, 0x00	; 0
    b17c:	20 40       	sbci	r18, 0x00	; 0
    b17e:	30 40       	sbci	r19, 0x00	; 0
    b180:	09 ab       	sts	0x59, r16
    b182:	1a ab       	sts	0x5a, r17
    b184:	2b ab       	sts	0x5b, r18
    b186:	3c ab       	sts	0x5c, r19
    b188:	c8 0c       	add	r12, r8
    b18a:	d9 1c       	adc	r13, r9
    b18c:	ea 1c       	adc	r14, r10
    b18e:	fb 1c       	adc	r15, r11
    b190:	04 c0       	rjmp	.+8      	; 0xb19a <__divdi3+0x73c>
    b192:	09 ab       	sts	0x59, r16
    b194:	1a ab       	sts	0x5a, r17
    b196:	2b ab       	sts	0x5b, r18
    b198:	3c ab       	sts	0x5c, r19
    b19a:	c4 1a       	sub	r12, r20
    b19c:	d5 0a       	sbc	r13, r21
    b19e:	e6 0a       	sbc	r14, r22
    b1a0:	f7 0a       	sbc	r15, r23
    b1a2:	c7 01       	movw	r24, r14
    b1a4:	b6 01       	movw	r22, r12
    b1a6:	a3 01       	movw	r20, r6
    b1a8:	92 01       	movw	r18, r4
    b1aa:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b1ae:	29 a7       	lds	r18, 0x79
    b1b0:	3a a7       	lds	r19, 0x7a
    b1b2:	4b a7       	lds	r20, 0x7b
    b1b4:	5c a7       	lds	r21, 0x7c
    b1b6:	21 96       	adiw	r28, 0x01	; 1
    b1b8:	6c af       	sts	0x7c, r22
    b1ba:	7d af       	sts	0x7d, r23
    b1bc:	8e af       	sts	0x7e, r24
    b1be:	9f af       	sts	0x7f, r25
    b1c0:	21 97       	sbiw	r28, 0x01	; 1
    b1c2:	c7 01       	movw	r24, r14
    b1c4:	b6 01       	movw	r22, r12
    b1c6:	a3 01       	movw	r20, r6
    b1c8:	92 01       	movw	r18, r4
    b1ca:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b1ce:	ca 01       	movw	r24, r20
    b1d0:	b9 01       	movw	r22, r18
    b1d2:	29 ad       	sts	0x69, r18
    b1d4:	3a ad       	sts	0x6a, r19
    b1d6:	4b ad       	sts	0x6b, r20
    b1d8:	5c ad       	sts	0x6c, r21
    b1da:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b1de:	8b 01       	movw	r16, r22
    b1e0:	9c 01       	movw	r18, r24
    b1e2:	21 96       	adiw	r28, 0x01	; 1
    b1e4:	4c ad       	sts	0x6c, r20
    b1e6:	5d ad       	sts	0x6d, r21
    b1e8:	6e ad       	sts	0x6e, r22
    b1ea:	7f ad       	sts	0x6f, r23
    b1ec:	21 97       	sbiw	r28, 0x01	; 1
    b1ee:	da 01       	movw	r26, r20
    b1f0:	99 27       	eor	r25, r25
    b1f2:	88 27       	eor	r24, r24
    b1f4:	4d a5       	lds	r20, 0x6d
    b1f6:	5e a5       	lds	r21, 0x6e
    b1f8:	6f a5       	lds	r22, 0x6f
    b1fa:	78 a9       	sts	0x48, r23
    b1fc:	60 70       	andi	r22, 0x00	; 0
    b1fe:	70 70       	andi	r23, 0x00	; 0
    b200:	84 2b       	or	r24, r20
    b202:	95 2b       	or	r25, r21
    b204:	a6 2b       	or	r26, r22
    b206:	b7 2b       	or	r27, r23
    b208:	49 a5       	lds	r20, 0x69
    b20a:	5a a5       	lds	r21, 0x6a
    b20c:	6b a5       	lds	r22, 0x6b
    b20e:	7c a5       	lds	r23, 0x6c
    b210:	80 17       	cp	r24, r16
    b212:	91 07       	cpc	r25, r17
    b214:	a2 07       	cpc	r26, r18
    b216:	b3 07       	cpc	r27, r19
    b218:	f0 f4       	brcc	.+60     	; 0xb256 <__divdi3+0x7f8>
    b21a:	41 50       	subi	r20, 0x01	; 1
    b21c:	50 40       	sbci	r21, 0x00	; 0
    b21e:	60 40       	sbci	r22, 0x00	; 0
    b220:	70 40       	sbci	r23, 0x00	; 0
    b222:	88 0d       	add	r24, r8
    b224:	99 1d       	adc	r25, r9
    b226:	aa 1d       	adc	r26, r10
    b228:	bb 1d       	adc	r27, r11
    b22a:	88 15       	cp	r24, r8
    b22c:	99 05       	cpc	r25, r9
    b22e:	aa 05       	cpc	r26, r10
    b230:	bb 05       	cpc	r27, r11
    b232:	88 f0       	brcs	.+34     	; 0xb256 <__divdi3+0x7f8>
    b234:	80 17       	cp	r24, r16
    b236:	91 07       	cpc	r25, r17
    b238:	a2 07       	cpc	r26, r18
    b23a:	b3 07       	cpc	r27, r19
    b23c:	60 f4       	brcc	.+24     	; 0xb256 <__divdi3+0x7f8>
    b23e:	49 a5       	lds	r20, 0x69
    b240:	5a a5       	lds	r21, 0x6a
    b242:	6b a5       	lds	r22, 0x6b
    b244:	7c a5       	lds	r23, 0x6c
    b246:	42 50       	subi	r20, 0x02	; 2
    b248:	50 40       	sbci	r21, 0x00	; 0
    b24a:	60 40       	sbci	r22, 0x00	; 0
    b24c:	70 40       	sbci	r23, 0x00	; 0
    b24e:	88 0d       	add	r24, r8
    b250:	99 1d       	adc	r25, r9
    b252:	aa 1d       	adc	r26, r10
    b254:	bb 1d       	adc	r27, r11
    b256:	6c 01       	movw	r12, r24
    b258:	7d 01       	movw	r14, r26
    b25a:	c0 1a       	sub	r12, r16
    b25c:	d1 0a       	sbc	r13, r17
    b25e:	e2 0a       	sbc	r14, r18
    b260:	f3 0a       	sbc	r15, r19
    b262:	09 a9       	sts	0x49, r16
    b264:	1a a9       	sts	0x4a, r17
    b266:	2b a9       	sts	0x4b, r18
    b268:	3c a9       	sts	0x4c, r19
    b26a:	38 01       	movw	r6, r16
    b26c:	55 24       	eor	r5, r5
    b26e:	44 24       	eor	r4, r4
    b270:	44 2a       	or	r4, r20
    b272:	55 2a       	or	r5, r21
    b274:	66 2a       	or	r6, r22
    b276:	77 2a       	or	r7, r23
    b278:	85 01       	movw	r16, r10
    b27a:	22 27       	eor	r18, r18
    b27c:	33 27       	eor	r19, r19
    b27e:	0d a7       	lds	r16, 0x7d
    b280:	1e a7       	lds	r17, 0x7e
    b282:	2f a7       	lds	r18, 0x7f
    b284:	38 ab       	sts	0x58, r19
    b286:	95 01       	movw	r18, r10
    b288:	84 01       	movw	r16, r8
    b28a:	20 70       	andi	r18, 0x00	; 0
    b28c:	30 70       	andi	r19, 0x00	; 0
    b28e:	09 af       	sts	0x79, r16
    b290:	1a af       	sts	0x7a, r17
    b292:	2b af       	sts	0x7b, r18
    b294:	3c af       	sts	0x7c, r19
    b296:	c7 01       	movw	r24, r14
    b298:	b6 01       	movw	r22, r12
    b29a:	2d a5       	lds	r18, 0x6d
    b29c:	3e a5       	lds	r19, 0x6e
    b29e:	4f a5       	lds	r20, 0x6f
    b2a0:	58 a9       	sts	0x48, r21
    b2a2:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b2a6:	29 a7       	lds	r18, 0x79
    b2a8:	3a a7       	lds	r19, 0x7a
    b2aa:	4b a7       	lds	r20, 0x7b
    b2ac:	5c a7       	lds	r21, 0x7c
    b2ae:	69 ab       	sts	0x59, r22
    b2b0:	7a ab       	sts	0x5a, r23
    b2b2:	8b ab       	sts	0x5b, r24
    b2b4:	9c ab       	sts	0x5c, r25
    b2b6:	c7 01       	movw	r24, r14
    b2b8:	b6 01       	movw	r22, r12
    b2ba:	2d a5       	lds	r18, 0x6d
    b2bc:	3e a5       	lds	r19, 0x6e
    b2be:	4f a5       	lds	r20, 0x6f
    b2c0:	58 a9       	sts	0x48, r21
    b2c2:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b2c6:	ca 01       	movw	r24, r20
    b2c8:	b9 01       	movw	r22, r18
    b2ca:	29 ad       	sts	0x69, r18
    b2cc:	3a ad       	sts	0x6a, r19
    b2ce:	4b ad       	sts	0x6b, r20
    b2d0:	5c ad       	sts	0x6c, r21
    b2d2:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b2d6:	ab 01       	movw	r20, r22
    b2d8:	bc 01       	movw	r22, r24
    b2da:	09 a9       	sts	0x49, r16
    b2dc:	1a a9       	sts	0x4a, r17
    b2de:	2b a9       	sts	0x4b, r18
    b2e0:	3c a9       	sts	0x4c, r19
    b2e2:	78 01       	movw	r14, r16
    b2e4:	dd 24       	eor	r13, r13
    b2e6:	cc 24       	eor	r12, r12
    b2e8:	0d a9       	sts	0x4d, r16
    b2ea:	1e a9       	sts	0x4e, r17
    b2ec:	2f a9       	sts	0x4f, r18
    b2ee:	38 ad       	sts	0x68, r19
    b2f0:	c9 01       	movw	r24, r18
    b2f2:	aa 27       	eor	r26, r26
    b2f4:	bb 27       	eor	r27, r27
    b2f6:	c8 2a       	or	r12, r24
    b2f8:	d9 2a       	or	r13, r25
    b2fa:	ea 2a       	or	r14, r26
    b2fc:	fb 2a       	or	r15, r27
    b2fe:	09 a5       	lds	r16, 0x69
    b300:	1a a5       	lds	r17, 0x6a
    b302:	2b a5       	lds	r18, 0x6b
    b304:	3c a5       	lds	r19, 0x6c
    b306:	c4 16       	cp	r12, r20
    b308:	d5 06       	cpc	r13, r21
    b30a:	e6 06       	cpc	r14, r22
    b30c:	f7 06       	cpc	r15, r23
    b30e:	38 f5       	brcc	.+78     	; 0xb35e <__divdi3+0x900>
    b310:	01 50       	subi	r16, 0x01	; 1
    b312:	10 40       	sbci	r17, 0x00	; 0
    b314:	20 40       	sbci	r18, 0x00	; 0
    b316:	30 40       	sbci	r19, 0x00	; 0
    b318:	09 ab       	sts	0x59, r16
    b31a:	1a ab       	sts	0x5a, r17
    b31c:	2b ab       	sts	0x5b, r18
    b31e:	3c ab       	sts	0x5c, r19
    b320:	c8 0c       	add	r12, r8
    b322:	d9 1c       	adc	r13, r9
    b324:	ea 1c       	adc	r14, r10
    b326:	fb 1c       	adc	r15, r11
    b328:	c8 14       	cp	r12, r8
    b32a:	d9 04       	cpc	r13, r9
    b32c:	ea 04       	cpc	r14, r10
    b32e:	fb 04       	cpc	r15, r11
    b330:	d0 f0       	brcs	.+52     	; 0xb366 <__divdi3+0x908>
    b332:	c4 16       	cp	r12, r20
    b334:	d5 06       	cpc	r13, r21
    b336:	e6 06       	cpc	r14, r22
    b338:	f7 06       	cpc	r15, r23
    b33a:	a8 f4       	brcc	.+42     	; 0xb366 <__divdi3+0x908>
    b33c:	09 a5       	lds	r16, 0x69
    b33e:	1a a5       	lds	r17, 0x6a
    b340:	2b a5       	lds	r18, 0x6b
    b342:	3c a5       	lds	r19, 0x6c
    b344:	02 50       	subi	r16, 0x02	; 2
    b346:	10 40       	sbci	r17, 0x00	; 0
    b348:	20 40       	sbci	r18, 0x00	; 0
    b34a:	30 40       	sbci	r19, 0x00	; 0
    b34c:	09 ab       	sts	0x59, r16
    b34e:	1a ab       	sts	0x5a, r17
    b350:	2b ab       	sts	0x5b, r18
    b352:	3c ab       	sts	0x5c, r19
    b354:	c8 0c       	add	r12, r8
    b356:	d9 1c       	adc	r13, r9
    b358:	ea 1c       	adc	r14, r10
    b35a:	fb 1c       	adc	r15, r11
    b35c:	04 c0       	rjmp	.+8      	; 0xb366 <__divdi3+0x908>
    b35e:	09 ab       	sts	0x59, r16
    b360:	1a ab       	sts	0x5a, r17
    b362:	2b ab       	sts	0x5b, r18
    b364:	3c ab       	sts	0x5c, r19
    b366:	c4 1a       	sub	r12, r20
    b368:	d5 0a       	sbc	r13, r21
    b36a:	e6 0a       	sbc	r14, r22
    b36c:	f7 0a       	sbc	r15, r23
    b36e:	c7 01       	movw	r24, r14
    b370:	b6 01       	movw	r22, r12
    b372:	2d a5       	lds	r18, 0x6d
    b374:	3e a5       	lds	r19, 0x6e
    b376:	4f a5       	lds	r20, 0x6f
    b378:	58 a9       	sts	0x48, r21
    b37a:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b37e:	29 a7       	lds	r18, 0x79
    b380:	3a a7       	lds	r19, 0x7a
    b382:	4b a7       	lds	r20, 0x7b
    b384:	5c a7       	lds	r21, 0x7c
    b386:	21 96       	adiw	r28, 0x01	; 1
    b388:	6c af       	sts	0x7c, r22
    b38a:	7d af       	sts	0x7d, r23
    b38c:	8e af       	sts	0x7e, r24
    b38e:	9f af       	sts	0x7f, r25
    b390:	21 97       	sbiw	r28, 0x01	; 1
    b392:	c7 01       	movw	r24, r14
    b394:	b6 01       	movw	r22, r12
    b396:	2d a5       	lds	r18, 0x6d
    b398:	3e a5       	lds	r19, 0x6e
    b39a:	4f a5       	lds	r20, 0x6f
    b39c:	58 a9       	sts	0x48, r21
    b39e:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b3a2:	ca 01       	movw	r24, r20
    b3a4:	b9 01       	movw	r22, r18
    b3a6:	29 ad       	sts	0x69, r18
    b3a8:	3a ad       	sts	0x6a, r19
    b3aa:	4b ad       	sts	0x6b, r20
    b3ac:	5c ad       	sts	0x6c, r21
    b3ae:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b3b2:	8b 01       	movw	r16, r22
    b3b4:	9c 01       	movw	r18, r24
    b3b6:	21 96       	adiw	r28, 0x01	; 1
    b3b8:	4c ad       	sts	0x6c, r20
    b3ba:	5d ad       	sts	0x6d, r21
    b3bc:	6e ad       	sts	0x6e, r22
    b3be:	7f ad       	sts	0x6f, r23
    b3c0:	21 97       	sbiw	r28, 0x01	; 1
    b3c2:	da 01       	movw	r26, r20
    b3c4:	99 27       	eor	r25, r25
    b3c6:	88 27       	eor	r24, r24
    b3c8:	4d a9       	sts	0x4d, r20
    b3ca:	5e a9       	sts	0x4e, r21
    b3cc:	6f a9       	sts	0x4f, r22
    b3ce:	78 ad       	sts	0x68, r23
    b3d0:	60 70       	andi	r22, 0x00	; 0
    b3d2:	70 70       	andi	r23, 0x00	; 0
    b3d4:	84 2b       	or	r24, r20
    b3d6:	95 2b       	or	r25, r21
    b3d8:	a6 2b       	or	r26, r22
    b3da:	b7 2b       	or	r27, r23
    b3dc:	49 a5       	lds	r20, 0x69
    b3de:	5a a5       	lds	r21, 0x6a
    b3e0:	6b a5       	lds	r22, 0x6b
    b3e2:	7c a5       	lds	r23, 0x6c
    b3e4:	80 17       	cp	r24, r16
    b3e6:	91 07       	cpc	r25, r17
    b3e8:	a2 07       	cpc	r26, r18
    b3ea:	b3 07       	cpc	r27, r19
    b3ec:	d0 f4       	brcc	.+52     	; 0xb422 <__divdi3+0x9c4>
    b3ee:	41 50       	subi	r20, 0x01	; 1
    b3f0:	50 40       	sbci	r21, 0x00	; 0
    b3f2:	60 40       	sbci	r22, 0x00	; 0
    b3f4:	70 40       	sbci	r23, 0x00	; 0
    b3f6:	88 0d       	add	r24, r8
    b3f8:	99 1d       	adc	r25, r9
    b3fa:	aa 1d       	adc	r26, r10
    b3fc:	bb 1d       	adc	r27, r11
    b3fe:	88 15       	cp	r24, r8
    b400:	99 05       	cpc	r25, r9
    b402:	aa 05       	cpc	r26, r10
    b404:	bb 05       	cpc	r27, r11
    b406:	68 f0       	brcs	.+26     	; 0xb422 <__divdi3+0x9c4>
    b408:	80 17       	cp	r24, r16
    b40a:	91 07       	cpc	r25, r17
    b40c:	a2 07       	cpc	r26, r18
    b40e:	b3 07       	cpc	r27, r19
    b410:	40 f4       	brcc	.+16     	; 0xb422 <__divdi3+0x9c4>
    b412:	49 a5       	lds	r20, 0x69
    b414:	5a a5       	lds	r21, 0x6a
    b416:	6b a5       	lds	r22, 0x6b
    b418:	7c a5       	lds	r23, 0x6c
    b41a:	42 50       	subi	r20, 0x02	; 2
    b41c:	50 40       	sbci	r21, 0x00	; 0
    b41e:	60 40       	sbci	r22, 0x00	; 0
    b420:	70 40       	sbci	r23, 0x00	; 0
    b422:	09 a9       	sts	0x49, r16
    b424:	1a a9       	sts	0x4a, r17
    b426:	2b a9       	sts	0x4b, r18
    b428:	3c a9       	sts	0x4c, r19
    b42a:	78 01       	movw	r14, r16
    b42c:	dd 24       	eor	r13, r13
    b42e:	cc 24       	eor	r12, r12
    b430:	c4 2a       	or	r12, r20
    b432:	d5 2a       	or	r13, r21
    b434:	e6 2a       	or	r14, r22
    b436:	f7 2a       	or	r15, r23
    b438:	50 c2       	rjmp	.+1184   	; 0xb8da <__divdi3+0xe7c>
    b43a:	c8 16       	cp	r12, r24
    b43c:	d9 06       	cpc	r13, r25
    b43e:	ea 06       	cpc	r14, r26
    b440:	fb 06       	cpc	r15, r27
    b442:	08 f4       	brcc	.+2      	; 0xb446 <__divdi3+0x9e8>
    b444:	37 c2       	rjmp	.+1134   	; 0xb8b4 <__divdi3+0xe56>
    b446:	80 30       	cpi	r24, 0x00	; 0
    b448:	10 e0       	ldi	r17, 0x00	; 0
    b44a:	91 07       	cpc	r25, r17
    b44c:	11 e0       	ldi	r17, 0x01	; 1
    b44e:	a1 07       	cpc	r26, r17
    b450:	10 e0       	ldi	r17, 0x00	; 0
    b452:	b1 07       	cpc	r27, r17
    b454:	50 f4       	brcc	.+20     	; 0xb46a <__divdi3+0xa0c>
    b456:	8f 3f       	cpi	r24, 0xFF	; 255
    b458:	91 05       	cpc	r25, r1
    b45a:	a1 05       	cpc	r26, r1
    b45c:	b1 05       	cpc	r27, r1
    b45e:	09 f0       	breq	.+2      	; 0xb462 <__divdi3+0xa04>
    b460:	88 f4       	brcc	.+34     	; 0xb484 <__divdi3+0xa26>
    b462:	00 e0       	ldi	r16, 0x00	; 0
    b464:	10 e0       	ldi	r17, 0x00	; 0
    b466:	98 01       	movw	r18, r16
    b468:	16 c0       	rjmp	.+44     	; 0xb496 <__divdi3+0xa38>
    b46a:	80 30       	cpi	r24, 0x00	; 0
    b46c:	20 e0       	ldi	r18, 0x00	; 0
    b46e:	92 07       	cpc	r25, r18
    b470:	20 e0       	ldi	r18, 0x00	; 0
    b472:	a2 07       	cpc	r26, r18
    b474:	21 e0       	ldi	r18, 0x01	; 1
    b476:	b2 07       	cpc	r27, r18
    b478:	50 f4       	brcc	.+20     	; 0xb48e <__divdi3+0xa30>
    b47a:	00 e1       	ldi	r16, 0x10	; 16
    b47c:	10 e0       	ldi	r17, 0x00	; 0
    b47e:	20 e0       	ldi	r18, 0x00	; 0
    b480:	30 e0       	ldi	r19, 0x00	; 0
    b482:	09 c0       	rjmp	.+18     	; 0xb496 <__divdi3+0xa38>
    b484:	08 e0       	ldi	r16, 0x08	; 8
    b486:	10 e0       	ldi	r17, 0x00	; 0
    b488:	20 e0       	ldi	r18, 0x00	; 0
    b48a:	30 e0       	ldi	r19, 0x00	; 0
    b48c:	04 c0       	rjmp	.+8      	; 0xb496 <__divdi3+0xa38>
    b48e:	08 e1       	ldi	r16, 0x18	; 24
    b490:	10 e0       	ldi	r17, 0x00	; 0
    b492:	20 e0       	ldi	r18, 0x00	; 0
    b494:	30 e0       	ldi	r19, 0x00	; 0
    b496:	ac 01       	movw	r20, r24
    b498:	bd 01       	movw	r22, r26
    b49a:	00 2e       	mov	r0, r16
    b49c:	04 c0       	rjmp	.+8      	; 0xb4a6 <__divdi3+0xa48>
    b49e:	76 95       	lsr	r23
    b4a0:	67 95       	ror	r22
    b4a2:	57 95       	ror	r21
    b4a4:	47 95       	ror	r20
    b4a6:	0a 94       	dec	r0
    b4a8:	d2 f7       	brpl	.-12     	; 0xb49e <__divdi3+0xa40>
    b4aa:	fa 01       	movw	r30, r20
    b4ac:	e3 5d       	subi	r30, 0xD3	; 211
    b4ae:	ff 4d       	sbci	r31, 0xDF	; 223
    b4b0:	40 81       	ld	r20, Z
    b4b2:	04 0f       	add	r16, r20
    b4b4:	11 1d       	adc	r17, r1
    b4b6:	21 1d       	adc	r18, r1
    b4b8:	31 1d       	adc	r19, r1
    b4ba:	40 e2       	ldi	r20, 0x20	; 32
    b4bc:	50 e0       	ldi	r21, 0x00	; 0
    b4be:	60 e0       	ldi	r22, 0x00	; 0
    b4c0:	70 e0       	ldi	r23, 0x00	; 0
    b4c2:	40 1b       	sub	r20, r16
    b4c4:	51 0b       	sbc	r21, r17
    b4c6:	62 0b       	sbc	r22, r18
    b4c8:	73 0b       	sbc	r23, r19
    b4ca:	a1 f4       	brne	.+40     	; 0xb4f4 <__divdi3+0xa96>
    b4cc:	8c 15       	cp	r24, r12
    b4ce:	9d 05       	cpc	r25, r13
    b4d0:	ae 05       	cpc	r26, r14
    b4d2:	bf 05       	cpc	r27, r15
    b4d4:	08 f4       	brcc	.+2      	; 0xb4d8 <__divdi3+0xa7a>
    b4d6:	f5 c1       	rjmp	.+1002   	; 0xb8c2 <__divdi3+0xe64>
    b4d8:	ed a8       	sts	0x8d, r30
    b4da:	fe a8       	sts	0x8e, r31
    b4dc:	0f a9       	sts	0x4f, r16
    b4de:	18 ad       	sts	0x68, r17
    b4e0:	44 24       	eor	r4, r4
    b4e2:	55 24       	eor	r5, r5
    b4e4:	32 01       	movw	r6, r4
    b4e6:	e8 14       	cp	r14, r8
    b4e8:	f9 04       	cpc	r15, r9
    b4ea:	0a 05       	cpc	r16, r10
    b4ec:	1b 05       	cpc	r17, r11
    b4ee:	08 f0       	brcs	.+2      	; 0xb4f2 <__divdi3+0xa94>
    b4f0:	eb c1       	rjmp	.+982    	; 0xb8c8 <__divdi3+0xe6a>
    b4f2:	e3 c1       	rjmp	.+966    	; 0xb8ba <__divdi3+0xe5c>
    b4f4:	34 2e       	mov	r3, r20
    b4f6:	2c 01       	movw	r4, r24
    b4f8:	3d 01       	movw	r6, r26
    b4fa:	04 c0       	rjmp	.+8      	; 0xb504 <__divdi3+0xaa6>
    b4fc:	44 0c       	add	r4, r4
    b4fe:	55 1c       	adc	r5, r5
    b500:	66 1c       	adc	r6, r6
    b502:	77 1c       	adc	r7, r7
    b504:	4a 95       	dec	r20
    b506:	d2 f7       	brpl	.-12     	; 0xb4fc <__divdi3+0xa9e>
    b508:	d5 01       	movw	r26, r10
    b50a:	c4 01       	movw	r24, r8
    b50c:	00 2e       	mov	r0, r16
    b50e:	04 c0       	rjmp	.+8      	; 0xb518 <__divdi3+0xaba>
    b510:	b6 95       	lsr	r27
    b512:	a7 95       	ror	r26
    b514:	97 95       	ror	r25
    b516:	87 95       	ror	r24
    b518:	0a 94       	dec	r0
    b51a:	d2 f7       	brpl	.-12     	; 0xb510 <__divdi3+0xab2>
    b51c:	48 2a       	or	r4, r24
    b51e:	59 2a       	or	r5, r25
    b520:	6a 2a       	or	r6, r26
    b522:	7b 2a       	or	r7, r27
    b524:	a5 01       	movw	r20, r10
    b526:	94 01       	movw	r18, r8
    b528:	03 2c       	mov	r0, r3
    b52a:	04 c0       	rjmp	.+8      	; 0xb534 <__divdi3+0xad6>
    b52c:	22 0f       	add	r18, r18
    b52e:	33 1f       	adc	r19, r19
    b530:	44 1f       	adc	r20, r20
    b532:	55 1f       	adc	r21, r21
    b534:	0a 94       	dec	r0
    b536:	d2 f7       	brpl	.-12     	; 0xb52c <__divdi3+0xace>
    b538:	29 af       	sts	0x79, r18
    b53a:	3a af       	sts	0x7a, r19
    b53c:	4b af       	sts	0x7b, r20
    b53e:	5c af       	sts	0x7c, r21
    b540:	b7 01       	movw	r22, r14
    b542:	a6 01       	movw	r20, r12
    b544:	00 2e       	mov	r0, r16
    b546:	04 c0       	rjmp	.+8      	; 0xb550 <__divdi3+0xaf2>
    b548:	76 95       	lsr	r23
    b54a:	67 95       	ror	r22
    b54c:	57 95       	ror	r21
    b54e:	47 95       	ror	r20
    b550:	0a 94       	dec	r0
    b552:	d2 f7       	brpl	.-12     	; 0xb548 <__divdi3+0xaea>
    b554:	49 ab       	sts	0x59, r20
    b556:	5a ab       	sts	0x5a, r21
    b558:	6b ab       	sts	0x5b, r22
    b55a:	7c ab       	sts	0x5c, r23
    b55c:	c7 01       	movw	r24, r14
    b55e:	b6 01       	movw	r22, r12
    b560:	03 2c       	mov	r0, r3
    b562:	04 c0       	rjmp	.+8      	; 0xb56c <__divdi3+0xb0e>
    b564:	66 0f       	add	r22, r22
    b566:	77 1f       	adc	r23, r23
    b568:	88 1f       	adc	r24, r24
    b56a:	99 1f       	adc	r25, r25
    b56c:	0a 94       	dec	r0
    b56e:	d2 f7       	brpl	.-12     	; 0xb564 <__divdi3+0xb06>
    b570:	6d a7       	lds	r22, 0x7d
    b572:	7e a7       	lds	r23, 0x7e
    b574:	8f a7       	lds	r24, 0x7f
    b576:	98 ab       	sts	0x58, r25
    b578:	8d a9       	sts	0x4d, r24
    b57a:	9e a9       	sts	0x4e, r25
    b57c:	af a9       	sts	0x4f, r26
    b57e:	b8 ad       	sts	0x68, r27
    b580:	04 c0       	rjmp	.+8      	; 0xb58a <__divdi3+0xb2c>
    b582:	b6 95       	lsr	r27
    b584:	a7 95       	ror	r26
    b586:	97 95       	ror	r25
    b588:	87 95       	ror	r24
    b58a:	0a 95       	dec	r16
    b58c:	d2 f7       	brpl	.-12     	; 0xb582 <__divdi3+0xb24>
    b58e:	4d a5       	lds	r20, 0x6d
    b590:	5e a5       	lds	r21, 0x6e
    b592:	6f a5       	lds	r22, 0x6f
    b594:	78 a9       	sts	0x48, r23
    b596:	48 2b       	or	r20, r24
    b598:	59 2b       	or	r21, r25
    b59a:	6a 2b       	or	r22, r26
    b59c:	7b 2b       	or	r23, r27
    b59e:	4d a7       	lds	r20, 0x7d
    b5a0:	5e a7       	lds	r21, 0x7e
    b5a2:	6f a7       	lds	r22, 0x7f
    b5a4:	78 ab       	sts	0x58, r23
    b5a6:	43 01       	movw	r8, r6
    b5a8:	aa 24       	eor	r10, r10
    b5aa:	bb 24       	eor	r11, r11
    b5ac:	93 01       	movw	r18, r6
    b5ae:	82 01       	movw	r16, r4
    b5b0:	20 70       	andi	r18, 0x00	; 0
    b5b2:	30 70       	andi	r19, 0x00	; 0
    b5b4:	21 96       	adiw	r28, 0x01	; 1
    b5b6:	0c af       	sts	0x7c, r16
    b5b8:	1d af       	sts	0x7d, r17
    b5ba:	2e af       	sts	0x7e, r18
    b5bc:	3f af       	sts	0x7f, r19
    b5be:	21 97       	sbiw	r28, 0x01	; 1
    b5c0:	69 a9       	sts	0x49, r22
    b5c2:	7a a9       	sts	0x4a, r23
    b5c4:	8b a9       	sts	0x4b, r24
    b5c6:	9c a9       	sts	0x4c, r25
    b5c8:	a5 01       	movw	r20, r10
    b5ca:	94 01       	movw	r18, r8
    b5cc:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b5d0:	29 a7       	lds	r18, 0x79
    b5d2:	3a a7       	lds	r19, 0x7a
    b5d4:	4b a7       	lds	r20, 0x7b
    b5d6:	5c a7       	lds	r21, 0x7c
    b5d8:	6b 01       	movw	r12, r22
    b5da:	7c 01       	movw	r14, r24
    b5dc:	69 a9       	sts	0x49, r22
    b5de:	7a a9       	sts	0x4a, r23
    b5e0:	8b a9       	sts	0x4b, r24
    b5e2:	9c a9       	sts	0x4c, r25
    b5e4:	a5 01       	movw	r20, r10
    b5e6:	94 01       	movw	r18, r8
    b5e8:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b5ec:	ca 01       	movw	r24, r20
    b5ee:	b9 01       	movw	r22, r18
    b5f0:	21 96       	adiw	r28, 0x01	; 1
    b5f2:	2c ad       	sts	0x6c, r18
    b5f4:	3d ad       	sts	0x6d, r19
    b5f6:	4e ad       	sts	0x6e, r20
    b5f8:	5f ad       	sts	0x6f, r21
    b5fa:	21 97       	sbiw	r28, 0x01	; 1
    b5fc:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b600:	dc 01       	movw	r26, r24
    b602:	cb 01       	movw	r24, r22
    b604:	76 01       	movw	r14, r12
    b606:	dd 24       	eor	r13, r13
    b608:	cc 24       	eor	r12, r12
    b60a:	0d a5       	lds	r16, 0x6d
    b60c:	1e a5       	lds	r17, 0x6e
    b60e:	2f a5       	lds	r18, 0x6f
    b610:	38 a9       	sts	0x48, r19
    b612:	a9 01       	movw	r20, r18
    b614:	66 27       	eor	r22, r22
    b616:	77 27       	eor	r23, r23
    b618:	c4 2a       	or	r12, r20
    b61a:	d5 2a       	or	r13, r21
    b61c:	e6 2a       	or	r14, r22
    b61e:	f7 2a       	or	r15, r23
    b620:	09 a5       	lds	r16, 0x69
    b622:	1a a5       	lds	r17, 0x6a
    b624:	2b a5       	lds	r18, 0x6b
    b626:	3c a5       	lds	r19, 0x6c
    b628:	c8 16       	cp	r12, r24
    b62a:	d9 06       	cpc	r13, r25
    b62c:	ea 06       	cpc	r14, r26
    b62e:	fb 06       	cpc	r15, r27
    b630:	38 f5       	brcc	.+78     	; 0xb680 <__divdi3+0xc22>
    b632:	01 50       	subi	r16, 0x01	; 1
    b634:	10 40       	sbci	r17, 0x00	; 0
    b636:	20 40       	sbci	r18, 0x00	; 0
    b638:	30 40       	sbci	r19, 0x00	; 0
    b63a:	09 ab       	sts	0x59, r16
    b63c:	1a ab       	sts	0x5a, r17
    b63e:	2b ab       	sts	0x5b, r18
    b640:	3c ab       	sts	0x5c, r19
    b642:	c4 0c       	add	r12, r4
    b644:	d5 1c       	adc	r13, r5
    b646:	e6 1c       	adc	r14, r6
    b648:	f7 1c       	adc	r15, r7
    b64a:	c4 14       	cp	r12, r4
    b64c:	d5 04       	cpc	r13, r5
    b64e:	e6 04       	cpc	r14, r6
    b650:	f7 04       	cpc	r15, r7
    b652:	d0 f0       	brcs	.+52     	; 0xb688 <__divdi3+0xc2a>
    b654:	c8 16       	cp	r12, r24
    b656:	d9 06       	cpc	r13, r25
    b658:	ea 06       	cpc	r14, r26
    b65a:	fb 06       	cpc	r15, r27
    b65c:	a8 f4       	brcc	.+42     	; 0xb688 <__divdi3+0xc2a>
    b65e:	09 a5       	lds	r16, 0x69
    b660:	1a a5       	lds	r17, 0x6a
    b662:	2b a5       	lds	r18, 0x6b
    b664:	3c a5       	lds	r19, 0x6c
    b666:	02 50       	subi	r16, 0x02	; 2
    b668:	10 40       	sbci	r17, 0x00	; 0
    b66a:	20 40       	sbci	r18, 0x00	; 0
    b66c:	30 40       	sbci	r19, 0x00	; 0
    b66e:	09 ab       	sts	0x59, r16
    b670:	1a ab       	sts	0x5a, r17
    b672:	2b ab       	sts	0x5b, r18
    b674:	3c ab       	sts	0x5c, r19
    b676:	c4 0c       	add	r12, r4
    b678:	d5 1c       	adc	r13, r5
    b67a:	e6 1c       	adc	r14, r6
    b67c:	f7 1c       	adc	r15, r7
    b67e:	04 c0       	rjmp	.+8      	; 0xb688 <__divdi3+0xc2a>
    b680:	09 ab       	sts	0x59, r16
    b682:	1a ab       	sts	0x5a, r17
    b684:	2b ab       	sts	0x5b, r18
    b686:	3c ab       	sts	0x5c, r19
    b688:	c8 1a       	sub	r12, r24
    b68a:	d9 0a       	sbc	r13, r25
    b68c:	ea 0a       	sbc	r14, r26
    b68e:	fb 0a       	sbc	r15, r27
    b690:	c7 01       	movw	r24, r14
    b692:	b6 01       	movw	r22, r12
    b694:	a5 01       	movw	r20, r10
    b696:	94 01       	movw	r18, r8
    b698:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b69c:	29 a7       	lds	r18, 0x79
    b69e:	3a a7       	lds	r19, 0x7a
    b6a0:	4b a7       	lds	r20, 0x7b
    b6a2:	5c a7       	lds	r21, 0x7c
    b6a4:	29 96       	adiw	r28, 0x09	; 9
    b6a6:	6c af       	sts	0x7c, r22
    b6a8:	7d af       	sts	0x7d, r23
    b6aa:	8e af       	sts	0x7e, r24
    b6ac:	9f af       	sts	0x7f, r25
    b6ae:	29 97       	sbiw	r28, 0x09	; 9
    b6b0:	c7 01       	movw	r24, r14
    b6b2:	b6 01       	movw	r22, r12
    b6b4:	a5 01       	movw	r20, r10
    b6b6:	94 01       	movw	r18, r8
    b6b8:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__udivmodsi4>
    b6bc:	ca 01       	movw	r24, r20
    b6be:	b9 01       	movw	r22, r18
    b6c0:	21 96       	adiw	r28, 0x01	; 1
    b6c2:	2c ad       	sts	0x6c, r18
    b6c4:	3d ad       	sts	0x6d, r19
    b6c6:	4e ad       	sts	0x6e, r20
    b6c8:	5f ad       	sts	0x6f, r21
    b6ca:	21 97       	sbiw	r28, 0x01	; 1
    b6cc:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b6d0:	4b 01       	movw	r8, r22
    b6d2:	5c 01       	movw	r10, r24
    b6d4:	29 96       	adiw	r28, 0x09	; 9
    b6d6:	4c ad       	sts	0x6c, r20
    b6d8:	5d ad       	sts	0x6d, r21
    b6da:	6e ad       	sts	0x6e, r22
    b6dc:	7f ad       	sts	0x6f, r23
    b6de:	29 97       	sbiw	r28, 0x09	; 9
    b6e0:	9a 01       	movw	r18, r20
    b6e2:	11 27       	eor	r17, r17
    b6e4:	00 27       	eor	r16, r16
    b6e6:	8d a5       	lds	r24, 0x6d
    b6e8:	9e a5       	lds	r25, 0x6e
    b6ea:	af a5       	lds	r26, 0x6f
    b6ec:	b8 a9       	sts	0x48, r27
    b6ee:	a0 70       	andi	r26, 0x00	; 0
    b6f0:	b0 70       	andi	r27, 0x00	; 0
    b6f2:	08 2b       	or	r16, r24
    b6f4:	19 2b       	or	r17, r25
    b6f6:	2a 2b       	or	r18, r26
    b6f8:	3b 2b       	or	r19, r27
    b6fa:	89 a5       	lds	r24, 0x69
    b6fc:	9a a5       	lds	r25, 0x6a
    b6fe:	ab a5       	lds	r26, 0x6b
    b700:	bc a5       	lds	r27, 0x6c
    b702:	08 15       	cp	r16, r8
    b704:	19 05       	cpc	r17, r9
    b706:	2a 05       	cpc	r18, r10
    b708:	3b 05       	cpc	r19, r11
    b70a:	e0 f4       	brcc	.+56     	; 0xb744 <__divdi3+0xce6>
    b70c:	01 97       	sbiw	r24, 0x01	; 1
    b70e:	a1 09       	sbc	r26, r1
    b710:	b1 09       	sbc	r27, r1
    b712:	04 0d       	add	r16, r4
    b714:	15 1d       	adc	r17, r5
    b716:	26 1d       	adc	r18, r6
    b718:	37 1d       	adc	r19, r7
    b71a:	04 15       	cp	r16, r4
    b71c:	15 05       	cpc	r17, r5
    b71e:	26 05       	cpc	r18, r6
    b720:	37 05       	cpc	r19, r7
    b722:	80 f0       	brcs	.+32     	; 0xb744 <__divdi3+0xce6>
    b724:	08 15       	cp	r16, r8
    b726:	19 05       	cpc	r17, r9
    b728:	2a 05       	cpc	r18, r10
    b72a:	3b 05       	cpc	r19, r11
    b72c:	58 f4       	brcc	.+22     	; 0xb744 <__divdi3+0xce6>
    b72e:	89 a5       	lds	r24, 0x69
    b730:	9a a5       	lds	r25, 0x6a
    b732:	ab a5       	lds	r26, 0x6b
    b734:	bc a5       	lds	r27, 0x6c
    b736:	02 97       	sbiw	r24, 0x02	; 2
    b738:	a1 09       	sbc	r26, r1
    b73a:	b1 09       	sbc	r27, r1
    b73c:	04 0d       	add	r16, r4
    b73e:	15 1d       	adc	r17, r5
    b740:	26 1d       	adc	r18, r6
    b742:	37 1d       	adc	r19, r7
    b744:	b9 01       	movw	r22, r18
    b746:	a8 01       	movw	r20, r16
    b748:	48 19       	sub	r20, r8
    b74a:	59 09       	sbc	r21, r9
    b74c:	6a 09       	sbc	r22, r10
    b74e:	7b 09       	sbc	r23, r11
    b750:	4d a7       	lds	r20, 0x7d
    b752:	5e a7       	lds	r21, 0x7e
    b754:	6f a7       	lds	r22, 0x7f
    b756:	78 ab       	sts	0x58, r23
    b758:	09 a9       	sts	0x49, r16
    b75a:	1a a9       	sts	0x4a, r17
    b75c:	2b a9       	sts	0x4b, r18
    b75e:	3c a9       	sts	0x4c, r19
    b760:	78 01       	movw	r14, r16
    b762:	dd 24       	eor	r13, r13
    b764:	cc 24       	eor	r12, r12
    b766:	c8 2a       	or	r12, r24
    b768:	d9 2a       	or	r13, r25
    b76a:	ea 2a       	or	r14, r26
    b76c:	fb 2a       	or	r15, r27
    b76e:	ff ef       	ldi	r31, 0xFF	; 255
    b770:	8f 2e       	mov	r8, r31
    b772:	ff ef       	ldi	r31, 0xFF	; 255
    b774:	9f 2e       	mov	r9, r31
    b776:	a1 2c       	mov	r10, r1
    b778:	b1 2c       	mov	r11, r1
    b77a:	8c 20       	and	r8, r12
    b77c:	9d 20       	and	r9, r13
    b77e:	ae 20       	and	r10, r14
    b780:	bf 20       	and	r11, r15
    b782:	87 01       	movw	r16, r14
    b784:	22 27       	eor	r18, r18
    b786:	33 27       	eor	r19, r19
    b788:	09 a7       	lds	r16, 0x79
    b78a:	1a a7       	lds	r17, 0x7a
    b78c:	2b a7       	lds	r18, 0x7b
    b78e:	3c a7       	lds	r19, 0x7c
    b790:	49 ac       	sts	0xa9, r20
    b792:	5a ac       	sts	0xaa, r21
    b794:	6b ac       	sts	0xab, r22
    b796:	7c ac       	sts	0xac, r23
    b798:	2f ef       	ldi	r18, 0xFF	; 255
    b79a:	3f ef       	ldi	r19, 0xFF	; 255
    b79c:	40 e0       	ldi	r20, 0x00	; 0
    b79e:	50 e0       	ldi	r21, 0x00	; 0
    b7a0:	42 22       	and	r4, r18
    b7a2:	53 22       	and	r5, r19
    b7a4:	64 22       	and	r6, r20
    b7a6:	75 22       	and	r7, r21
    b7a8:	29 ad       	sts	0x69, r18
    b7aa:	3a ad       	sts	0x6a, r19
    b7ac:	4b ad       	sts	0x6b, r20
    b7ae:	5c ad       	sts	0x6c, r21
    b7b0:	8a 01       	movw	r16, r20
    b7b2:	22 27       	eor	r18, r18
    b7b4:	33 27       	eor	r19, r19
    b7b6:	09 ab       	sts	0x59, r16
    b7b8:	1a ab       	sts	0x5a, r17
    b7ba:	2b ab       	sts	0x5b, r18
    b7bc:	3c ab       	sts	0x5c, r19
    b7be:	c5 01       	movw	r24, r10
    b7c0:	b4 01       	movw	r22, r8
    b7c2:	a3 01       	movw	r20, r6
    b7c4:	92 01       	movw	r18, r4
    b7c6:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b7ca:	69 af       	sts	0x79, r22
    b7cc:	7a af       	sts	0x7a, r23
    b7ce:	8b af       	sts	0x7b, r24
    b7d0:	9c af       	sts	0x7c, r25
    b7d2:	c5 01       	movw	r24, r10
    b7d4:	b4 01       	movw	r22, r8
    b7d6:	29 a9       	sts	0x49, r18
    b7d8:	3a a9       	sts	0x4a, r19
    b7da:	4b a9       	sts	0x4b, r20
    b7dc:	5c a9       	sts	0x4c, r21
    b7de:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b7e2:	4b 01       	movw	r8, r22
    b7e4:	5c 01       	movw	r10, r24
    b7e6:	69 a5       	lds	r22, 0x69
    b7e8:	7a a5       	lds	r23, 0x6a
    b7ea:	8b a5       	lds	r24, 0x6b
    b7ec:	9c a5       	lds	r25, 0x6c
    b7ee:	a3 01       	movw	r20, r6
    b7f0:	92 01       	movw	r18, r4
    b7f2:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b7f6:	2b 01       	movw	r4, r22
    b7f8:	3c 01       	movw	r6, r24
    b7fa:	69 a5       	lds	r22, 0x69
    b7fc:	7a a5       	lds	r23, 0x6a
    b7fe:	8b a5       	lds	r24, 0x6b
    b800:	9c a5       	lds	r25, 0x6c
    b802:	29 a9       	sts	0x49, r18
    b804:	3a a9       	sts	0x4a, r19
    b806:	4b a9       	sts	0x4b, r20
    b808:	5c a9       	sts	0x4c, r21
    b80a:	0e 94 5f 5e 	call	0xbcbe	; 0xbcbe <__mulsi3>
    b80e:	ab 01       	movw	r20, r22
    b810:	bc 01       	movw	r22, r24
    b812:	84 0c       	add	r8, r4
    b814:	95 1c       	adc	r9, r5
    b816:	a6 1c       	adc	r10, r6
    b818:	b7 1c       	adc	r11, r7
    b81a:	09 ad       	sts	0x69, r16
    b81c:	1a ad       	sts	0x6a, r17
    b81e:	2b ad       	sts	0x6b, r18
    b820:	3c ad       	sts	0x6c, r19
    b822:	c9 01       	movw	r24, r18
    b824:	aa 27       	eor	r26, r26
    b826:	bb 27       	eor	r27, r27
    b828:	88 0e       	add	r8, r24
    b82a:	99 1e       	adc	r9, r25
    b82c:	aa 1e       	adc	r10, r26
    b82e:	bb 1e       	adc	r11, r27
    b830:	84 14       	cp	r8, r4
    b832:	95 04       	cpc	r9, r5
    b834:	a6 04       	cpc	r10, r6
    b836:	b7 04       	cpc	r11, r7
    b838:	20 f4       	brcc	.+8      	; 0xb842 <__divdi3+0xde4>
    b83a:	40 50       	subi	r20, 0x00	; 0
    b83c:	50 40       	sbci	r21, 0x00	; 0
    b83e:	6f 4f       	sbci	r22, 0xFF	; 255
    b840:	7f 4f       	sbci	r23, 0xFF	; 255
    b842:	c5 01       	movw	r24, r10
    b844:	aa 27       	eor	r26, r26
    b846:	bb 27       	eor	r27, r27
    b848:	84 0f       	add	r24, r20
    b84a:	95 1f       	adc	r25, r21
    b84c:	a6 1f       	adc	r26, r22
    b84e:	b7 1f       	adc	r27, r23
    b850:	0d a5       	lds	r16, 0x6d
    b852:	1e a5       	lds	r17, 0x6e
    b854:	2f a5       	lds	r18, 0x6f
    b856:	38 a9       	sts	0x48, r19
    b858:	08 17       	cp	r16, r24
    b85a:	19 07       	cpc	r17, r25
    b85c:	2a 07       	cpc	r18, r26
    b85e:	3b 07       	cpc	r19, r27
    b860:	18 f1       	brcs	.+70     	; 0xb8a8 <__divdi3+0xe4a>
    b862:	80 17       	cp	r24, r16
    b864:	91 07       	cpc	r25, r17
    b866:	a2 07       	cpc	r26, r18
    b868:	b3 07       	cpc	r27, r19
    b86a:	a1 f5       	brne	.+104    	; 0xb8d4 <__divdi3+0xe76>
    b86c:	54 01       	movw	r10, r8
    b86e:	99 24       	eor	r9, r9
    b870:	88 24       	eor	r8, r8
    b872:	89 ad       	sts	0x69, r24
    b874:	9a ad       	sts	0x6a, r25
    b876:	ab ad       	sts	0x6b, r26
    b878:	bc ad       	sts	0x6c, r27
    b87a:	a0 70       	andi	r26, 0x00	; 0
    b87c:	b0 70       	andi	r27, 0x00	; 0
    b87e:	88 0e       	add	r8, r24
    b880:	99 1e       	adc	r9, r25
    b882:	aa 1e       	adc	r10, r26
    b884:	bb 1e       	adc	r11, r27
    b886:	4d a9       	sts	0x4d, r20
    b888:	5e a9       	sts	0x4e, r21
    b88a:	6f a9       	sts	0x4f, r22
    b88c:	78 ad       	sts	0x68, r23
    b88e:	03 2c       	mov	r0, r3
    b890:	04 c0       	rjmp	.+8      	; 0xb89a <__divdi3+0xe3c>
    b892:	44 0f       	add	r20, r20
    b894:	55 1f       	adc	r21, r21
    b896:	66 1f       	adc	r22, r22
    b898:	77 1f       	adc	r23, r23
    b89a:	0a 94       	dec	r0
    b89c:	d2 f7       	brpl	.-12     	; 0xb892 <__divdi3+0xe34>
    b89e:	48 15       	cp	r20, r8
    b8a0:	59 05       	cpc	r21, r9
    b8a2:	6a 05       	cpc	r22, r10
    b8a4:	7b 05       	cpc	r23, r11
    b8a6:	b0 f4       	brcc	.+44     	; 0xb8d4 <__divdi3+0xe76>
    b8a8:	08 94       	sec
    b8aa:	c1 08       	sbc	r12, r1
    b8ac:	d1 08       	sbc	r13, r1
    b8ae:	e1 08       	sbc	r14, r1
    b8b0:	f1 08       	sbc	r15, r1
    b8b2:	10 c0       	rjmp	.+32     	; 0xb8d4 <__divdi3+0xe76>
    b8b4:	44 24       	eor	r4, r4
    b8b6:	55 24       	eor	r5, r5
    b8b8:	32 01       	movw	r6, r4
    b8ba:	cc 24       	eor	r12, r12
    b8bc:	dd 24       	eor	r13, r13
    b8be:	76 01       	movw	r14, r12
    b8c0:	0c c0       	rjmp	.+24     	; 0xb8da <__divdi3+0xe7c>
    b8c2:	44 24       	eor	r4, r4
    b8c4:	55 24       	eor	r5, r5
    b8c6:	32 01       	movw	r6, r4
    b8c8:	81 e0       	ldi	r24, 0x01	; 1
    b8ca:	c8 2e       	mov	r12, r24
    b8cc:	d1 2c       	mov	r13, r1
    b8ce:	e1 2c       	mov	r14, r1
    b8d0:	f1 2c       	mov	r15, r1
    b8d2:	03 c0       	rjmp	.+6      	; 0xb8da <__divdi3+0xe7c>
    b8d4:	44 24       	eor	r4, r4
    b8d6:	55 24       	eor	r5, r5
    b8d8:	32 01       	movw	r6, r4
    b8da:	fe 01       	movw	r30, r28
    b8dc:	31 96       	adiw	r30, 0x01	; 1
    b8de:	88 e0       	ldi	r24, 0x08	; 8
    b8e0:	df 01       	movw	r26, r30
    b8e2:	1d 92       	st	X+, r1
    b8e4:	8a 95       	dec	r24
    b8e6:	e9 f7       	brne	.-6      	; 0xb8e2 <__divdi3+0xe84>
    b8e8:	c9 82       	std	Y+1, r12	; 0x01
    b8ea:	da 82       	std	Y+2, r13	; 0x02
    b8ec:	eb 82       	std	Y+3, r14	; 0x03
    b8ee:	fc 82       	std	Y+4, r15	; 0x04
    b8f0:	4d 82       	std	Y+5, r4	; 0x05
    b8f2:	5e 82       	std	Y+6, r5	; 0x06
    b8f4:	6f 82       	std	Y+7, r6	; 0x07
    b8f6:	78 86       	std	Y+8, r7	; 0x08
    b8f8:	2c 2d       	mov	r18, r12
    b8fa:	3a 81       	ldd	r19, Y+2	; 0x02
    b8fc:	4b 81       	ldd	r20, Y+3	; 0x03
    b8fe:	5c 81       	ldd	r21, Y+4	; 0x04
    b900:	64 2d       	mov	r22, r4
    b902:	7e 81       	ldd	r23, Y+6	; 0x06
    b904:	8f 81       	ldd	r24, Y+7	; 0x07
    b906:	98 85       	ldd	r25, Y+8	; 0x08
    b908:	25 96       	adiw	r28, 0x05	; 5
    b90a:	ec ac       	sts	0xac, r30
    b90c:	fd ac       	sts	0xad, r31
    b90e:	0e ad       	sts	0x6e, r16
    b910:	1f ad       	sts	0x6f, r17
    b912:	25 97       	sbiw	r28, 0x05	; 5
    b914:	e1 14       	cp	r14, r1
    b916:	f1 04       	cpc	r15, r1
    b918:	01 05       	cpc	r16, r1
    b91a:	11 05       	cpc	r17, r1
    b91c:	09 f4       	brne	.+2      	; 0xb920 <__divdi3+0xec2>
    b91e:	56 c0       	rjmp	.+172    	; 0xb9cc <__divdi3+0xf6e>
    b920:	21 95       	neg	r18
    b922:	e1 e0       	ldi	r30, 0x01	; 1
    b924:	12 16       	cp	r1, r18
    b926:	08 f0       	brcs	.+2      	; 0xb92a <__divdi3+0xecc>
    b928:	e0 e0       	ldi	r30, 0x00	; 0
    b92a:	31 95       	neg	r19
    b92c:	f1 e0       	ldi	r31, 0x01	; 1
    b92e:	13 16       	cp	r1, r19
    b930:	08 f0       	brcs	.+2      	; 0xb934 <__divdi3+0xed6>
    b932:	f0 e0       	ldi	r31, 0x00	; 0
    b934:	03 2f       	mov	r16, r19
    b936:	0e 1b       	sub	r16, r30
    b938:	e1 e0       	ldi	r30, 0x01	; 1
    b93a:	30 17       	cp	r19, r16
    b93c:	08 f0       	brcs	.+2      	; 0xb940 <__divdi3+0xee2>
    b93e:	e0 e0       	ldi	r30, 0x00	; 0
    b940:	fe 2b       	or	r31, r30
    b942:	41 95       	neg	r20
    b944:	e1 e0       	ldi	r30, 0x01	; 1
    b946:	14 16       	cp	r1, r20
    b948:	08 f0       	brcs	.+2      	; 0xb94c <__divdi3+0xeee>
    b94a:	e0 e0       	ldi	r30, 0x00	; 0
    b94c:	14 2f       	mov	r17, r20
    b94e:	1f 1b       	sub	r17, r31
    b950:	31 e0       	ldi	r19, 0x01	; 1
    b952:	41 17       	cp	r20, r17
    b954:	08 f0       	brcs	.+2      	; 0xb958 <__divdi3+0xefa>
    b956:	30 e0       	ldi	r19, 0x00	; 0
    b958:	e3 2b       	or	r30, r19
    b95a:	51 95       	neg	r21
    b95c:	f1 e0       	ldi	r31, 0x01	; 1
    b95e:	15 16       	cp	r1, r21
    b960:	08 f0       	brcs	.+2      	; 0xb964 <__divdi3+0xf06>
    b962:	f0 e0       	ldi	r31, 0x00	; 0
    b964:	b5 2f       	mov	r27, r21
    b966:	be 1b       	sub	r27, r30
    b968:	31 e0       	ldi	r19, 0x01	; 1
    b96a:	5b 17       	cp	r21, r27
    b96c:	08 f0       	brcs	.+2      	; 0xb970 <__divdi3+0xf12>
    b96e:	30 e0       	ldi	r19, 0x00	; 0
    b970:	f3 2b       	or	r31, r19
    b972:	61 95       	neg	r22
    b974:	e1 e0       	ldi	r30, 0x01	; 1
    b976:	16 16       	cp	r1, r22
    b978:	08 f0       	brcs	.+2      	; 0xb97c <__divdi3+0xf1e>
    b97a:	e0 e0       	ldi	r30, 0x00	; 0
    b97c:	46 2e       	mov	r4, r22
    b97e:	4f 1a       	sub	r4, r31
    b980:	31 e0       	ldi	r19, 0x01	; 1
    b982:	64 15       	cp	r22, r4
    b984:	08 f0       	brcs	.+2      	; 0xb988 <__divdi3+0xf2a>
    b986:	30 e0       	ldi	r19, 0x00	; 0
    b988:	e3 2b       	or	r30, r19
    b98a:	71 95       	neg	r23
    b98c:	f1 e0       	ldi	r31, 0x01	; 1
    b98e:	17 16       	cp	r1, r23
    b990:	08 f0       	brcs	.+2      	; 0xb994 <__divdi3+0xf36>
    b992:	f0 e0       	ldi	r31, 0x00	; 0
    b994:	a7 2f       	mov	r26, r23
    b996:	ae 1b       	sub	r26, r30
    b998:	31 e0       	ldi	r19, 0x01	; 1
    b99a:	7a 17       	cp	r23, r26
    b99c:	08 f0       	brcs	.+2      	; 0xb9a0 <__divdi3+0xf42>
    b99e:	30 e0       	ldi	r19, 0x00	; 0
    b9a0:	f3 2b       	or	r31, r19
    b9a2:	81 95       	neg	r24
    b9a4:	e1 e0       	ldi	r30, 0x01	; 1
    b9a6:	18 16       	cp	r1, r24
    b9a8:	08 f0       	brcs	.+2      	; 0xb9ac <__divdi3+0xf4e>
    b9aa:	e0 e0       	ldi	r30, 0x00	; 0
    b9ac:	f8 2e       	mov	r15, r24
    b9ae:	ff 1a       	sub	r15, r31
    b9b0:	ff 2d       	mov	r31, r15
    b9b2:	31 e0       	ldi	r19, 0x01	; 1
    b9b4:	8f 15       	cp	r24, r15
    b9b6:	08 f0       	brcs	.+2      	; 0xb9ba <__divdi3+0xf5c>
    b9b8:	30 e0       	ldi	r19, 0x00	; 0
    b9ba:	e3 2b       	or	r30, r19
    b9bc:	91 95       	neg	r25
    b9be:	30 2f       	mov	r19, r16
    b9c0:	41 2f       	mov	r20, r17
    b9c2:	5b 2f       	mov	r21, r27
    b9c4:	64 2d       	mov	r22, r4
    b9c6:	7a 2f       	mov	r23, r26
    b9c8:	8f 2f       	mov	r24, r31
    b9ca:	9e 1b       	sub	r25, r30
    b9cc:	c8 5b       	subi	r28, 0xB8	; 184
    b9ce:	df 4f       	sbci	r29, 0xFF	; 255
    b9d0:	e1 e1       	ldi	r30, 0x11	; 17
    b9d2:	0c 94 fc 5e 	jmp	0xbdf8	; 0xbdf8 <__epilogue_restores__+0x2>

0000b9d6 <__cmpsf2>:
    b9d6:	97 d0       	rcall	.+302    	; 0xbb06 <__fp_cmp>
    b9d8:	08 f4       	brcc	.+2      	; 0xb9dc <__cmpsf2+0x6>
    b9da:	81 e0       	ldi	r24, 0x01	; 1
    b9dc:	08 95       	ret

0000b9de <__divsf3>:
    b9de:	0c d0       	rcall	.+24     	; 0xb9f8 <__divsf3x>
    b9e0:	cd c0       	rjmp	.+410    	; 0xbb7c <__fp_round>
    b9e2:	c5 d0       	rcall	.+394    	; 0xbb6e <__fp_pscB>
    b9e4:	40 f0       	brcs	.+16     	; 0xb9f6 <__divsf3+0x18>
    b9e6:	bc d0       	rcall	.+376    	; 0xbb60 <__fp_pscA>
    b9e8:	30 f0       	brcs	.+12     	; 0xb9f6 <__divsf3+0x18>
    b9ea:	21 f4       	brne	.+8      	; 0xb9f4 <__divsf3+0x16>
    b9ec:	5f 3f       	cpi	r21, 0xFF	; 255
    b9ee:	19 f0       	breq	.+6      	; 0xb9f6 <__divsf3+0x18>
    b9f0:	ae c0       	rjmp	.+348    	; 0xbb4e <__fp_inf>
    b9f2:	51 11       	cpse	r21, r1
    b9f4:	f7 c0       	rjmp	.+494    	; 0xbbe4 <__fp_szero>
    b9f6:	b1 c0       	rjmp	.+354    	; 0xbb5a <__fp_nan>

0000b9f8 <__divsf3x>:
    b9f8:	d2 d0       	rcall	.+420    	; 0xbb9e <__fp_split3>
    b9fa:	98 f3       	brcs	.-26     	; 0xb9e2 <__divsf3+0x4>

0000b9fc <__divsf3_pse>:
    b9fc:	99 23       	and	r25, r25
    b9fe:	c9 f3       	breq	.-14     	; 0xb9f2 <__divsf3+0x14>
    ba00:	55 23       	and	r21, r21
    ba02:	b1 f3       	breq	.-20     	; 0xb9f0 <__divsf3+0x12>
    ba04:	95 1b       	sub	r25, r21
    ba06:	55 0b       	sbc	r21, r21
    ba08:	bb 27       	eor	r27, r27
    ba0a:	aa 27       	eor	r26, r26
    ba0c:	62 17       	cp	r22, r18
    ba0e:	73 07       	cpc	r23, r19
    ba10:	84 07       	cpc	r24, r20
    ba12:	38 f0       	brcs	.+14     	; 0xba22 <__divsf3_pse+0x26>
    ba14:	9f 5f       	subi	r25, 0xFF	; 255
    ba16:	5f 4f       	sbci	r21, 0xFF	; 255
    ba18:	22 0f       	add	r18, r18
    ba1a:	33 1f       	adc	r19, r19
    ba1c:	44 1f       	adc	r20, r20
    ba1e:	aa 1f       	adc	r26, r26
    ba20:	a9 f3       	breq	.-22     	; 0xba0c <__divsf3_pse+0x10>
    ba22:	33 d0       	rcall	.+102    	; 0xba8a <__divsf3_pse+0x8e>
    ba24:	0e 2e       	mov	r0, r30
    ba26:	3a f0       	brmi	.+14     	; 0xba36 <__divsf3_pse+0x3a>
    ba28:	e0 e8       	ldi	r30, 0x80	; 128
    ba2a:	30 d0       	rcall	.+96     	; 0xba8c <__divsf3_pse+0x90>
    ba2c:	91 50       	subi	r25, 0x01	; 1
    ba2e:	50 40       	sbci	r21, 0x00	; 0
    ba30:	e6 95       	lsr	r30
    ba32:	00 1c       	adc	r0, r0
    ba34:	ca f7       	brpl	.-14     	; 0xba28 <__divsf3_pse+0x2c>
    ba36:	29 d0       	rcall	.+82     	; 0xba8a <__divsf3_pse+0x8e>
    ba38:	fe 2f       	mov	r31, r30
    ba3a:	27 d0       	rcall	.+78     	; 0xba8a <__divsf3_pse+0x8e>
    ba3c:	66 0f       	add	r22, r22
    ba3e:	77 1f       	adc	r23, r23
    ba40:	88 1f       	adc	r24, r24
    ba42:	bb 1f       	adc	r27, r27
    ba44:	26 17       	cp	r18, r22
    ba46:	37 07       	cpc	r19, r23
    ba48:	48 07       	cpc	r20, r24
    ba4a:	ab 07       	cpc	r26, r27
    ba4c:	b0 e8       	ldi	r27, 0x80	; 128
    ba4e:	09 f0       	breq	.+2      	; 0xba52 <__divsf3_pse+0x56>
    ba50:	bb 0b       	sbc	r27, r27
    ba52:	80 2d       	mov	r24, r0
    ba54:	bf 01       	movw	r22, r30
    ba56:	ff 27       	eor	r31, r31
    ba58:	93 58       	subi	r25, 0x83	; 131
    ba5a:	5f 4f       	sbci	r21, 0xFF	; 255
    ba5c:	2a f0       	brmi	.+10     	; 0xba68 <__divsf3_pse+0x6c>
    ba5e:	9e 3f       	cpi	r25, 0xFE	; 254
    ba60:	51 05       	cpc	r21, r1
    ba62:	68 f0       	brcs	.+26     	; 0xba7e <__divsf3_pse+0x82>
    ba64:	74 c0       	rjmp	.+232    	; 0xbb4e <__fp_inf>
    ba66:	be c0       	rjmp	.+380    	; 0xbbe4 <__fp_szero>
    ba68:	5f 3f       	cpi	r21, 0xFF	; 255
    ba6a:	ec f3       	brlt	.-6      	; 0xba66 <__divsf3_pse+0x6a>
    ba6c:	98 3e       	cpi	r25, 0xE8	; 232
    ba6e:	dc f3       	brlt	.-10     	; 0xba66 <__divsf3_pse+0x6a>
    ba70:	86 95       	lsr	r24
    ba72:	77 95       	ror	r23
    ba74:	67 95       	ror	r22
    ba76:	b7 95       	ror	r27
    ba78:	f7 95       	ror	r31
    ba7a:	9f 5f       	subi	r25, 0xFF	; 255
    ba7c:	c9 f7       	brne	.-14     	; 0xba70 <__divsf3_pse+0x74>
    ba7e:	88 0f       	add	r24, r24
    ba80:	91 1d       	adc	r25, r1
    ba82:	96 95       	lsr	r25
    ba84:	87 95       	ror	r24
    ba86:	97 f9       	bld	r25, 7
    ba88:	08 95       	ret
    ba8a:	e1 e0       	ldi	r30, 0x01	; 1
    ba8c:	66 0f       	add	r22, r22
    ba8e:	77 1f       	adc	r23, r23
    ba90:	88 1f       	adc	r24, r24
    ba92:	bb 1f       	adc	r27, r27
    ba94:	62 17       	cp	r22, r18
    ba96:	73 07       	cpc	r23, r19
    ba98:	84 07       	cpc	r24, r20
    ba9a:	ba 07       	cpc	r27, r26
    ba9c:	20 f0       	brcs	.+8      	; 0xbaa6 <__divsf3_pse+0xaa>
    ba9e:	62 1b       	sub	r22, r18
    baa0:	73 0b       	sbc	r23, r19
    baa2:	84 0b       	sbc	r24, r20
    baa4:	ba 0b       	sbc	r27, r26
    baa6:	ee 1f       	adc	r30, r30
    baa8:	88 f7       	brcc	.-30     	; 0xba8c <__divsf3_pse+0x90>
    baaa:	e0 95       	com	r30
    baac:	08 95       	ret

0000baae <__fixunssfsi>:
    baae:	7f d0       	rcall	.+254    	; 0xbbae <__fp_splitA>
    bab0:	88 f0       	brcs	.+34     	; 0xbad4 <__fixunssfsi+0x26>
    bab2:	9f 57       	subi	r25, 0x7F	; 127
    bab4:	90 f0       	brcs	.+36     	; 0xbada <__fixunssfsi+0x2c>
    bab6:	b9 2f       	mov	r27, r25
    bab8:	99 27       	eor	r25, r25
    baba:	b7 51       	subi	r27, 0x17	; 23
    babc:	a0 f0       	brcs	.+40     	; 0xbae6 <__fixunssfsi+0x38>
    babe:	d1 f0       	breq	.+52     	; 0xbaf4 <__fixunssfsi+0x46>
    bac0:	66 0f       	add	r22, r22
    bac2:	77 1f       	adc	r23, r23
    bac4:	88 1f       	adc	r24, r24
    bac6:	99 1f       	adc	r25, r25
    bac8:	1a f0       	brmi	.+6      	; 0xbad0 <__fixunssfsi+0x22>
    baca:	ba 95       	dec	r27
    bacc:	c9 f7       	brne	.-14     	; 0xbac0 <__fixunssfsi+0x12>
    bace:	12 c0       	rjmp	.+36     	; 0xbaf4 <__fixunssfsi+0x46>
    bad0:	b1 30       	cpi	r27, 0x01	; 1
    bad2:	81 f0       	breq	.+32     	; 0xbaf4 <__fixunssfsi+0x46>
    bad4:	86 d0       	rcall	.+268    	; 0xbbe2 <__fp_zero>
    bad6:	b1 e0       	ldi	r27, 0x01	; 1
    bad8:	08 95       	ret
    bada:	83 c0       	rjmp	.+262    	; 0xbbe2 <__fp_zero>
    badc:	67 2f       	mov	r22, r23
    bade:	78 2f       	mov	r23, r24
    bae0:	88 27       	eor	r24, r24
    bae2:	b8 5f       	subi	r27, 0xF8	; 248
    bae4:	39 f0       	breq	.+14     	; 0xbaf4 <__fixunssfsi+0x46>
    bae6:	b9 3f       	cpi	r27, 0xF9	; 249
    bae8:	cc f3       	brlt	.-14     	; 0xbadc <__fixunssfsi+0x2e>
    baea:	86 95       	lsr	r24
    baec:	77 95       	ror	r23
    baee:	67 95       	ror	r22
    baf0:	b3 95       	inc	r27
    baf2:	d9 f7       	brne	.-10     	; 0xbaea <__fixunssfsi+0x3c>
    baf4:	3e f4       	brtc	.+14     	; 0xbb04 <__fixunssfsi+0x56>
    baf6:	90 95       	com	r25
    baf8:	80 95       	com	r24
    bafa:	70 95       	com	r23
    bafc:	61 95       	neg	r22
    bafe:	7f 4f       	sbci	r23, 0xFF	; 255
    bb00:	8f 4f       	sbci	r24, 0xFF	; 255
    bb02:	9f 4f       	sbci	r25, 0xFF	; 255
    bb04:	08 95       	ret

0000bb06 <__fp_cmp>:
    bb06:	99 0f       	add	r25, r25
    bb08:	00 08       	sbc	r0, r0
    bb0a:	55 0f       	add	r21, r21
    bb0c:	aa 0b       	sbc	r26, r26
    bb0e:	e0 e8       	ldi	r30, 0x80	; 128
    bb10:	fe ef       	ldi	r31, 0xFE	; 254
    bb12:	16 16       	cp	r1, r22
    bb14:	17 06       	cpc	r1, r23
    bb16:	e8 07       	cpc	r30, r24
    bb18:	f9 07       	cpc	r31, r25
    bb1a:	c0 f0       	brcs	.+48     	; 0xbb4c <__fp_cmp+0x46>
    bb1c:	12 16       	cp	r1, r18
    bb1e:	13 06       	cpc	r1, r19
    bb20:	e4 07       	cpc	r30, r20
    bb22:	f5 07       	cpc	r31, r21
    bb24:	98 f0       	brcs	.+38     	; 0xbb4c <__fp_cmp+0x46>
    bb26:	62 1b       	sub	r22, r18
    bb28:	73 0b       	sbc	r23, r19
    bb2a:	84 0b       	sbc	r24, r20
    bb2c:	95 0b       	sbc	r25, r21
    bb2e:	39 f4       	brne	.+14     	; 0xbb3e <__fp_cmp+0x38>
    bb30:	0a 26       	eor	r0, r26
    bb32:	61 f0       	breq	.+24     	; 0xbb4c <__fp_cmp+0x46>
    bb34:	23 2b       	or	r18, r19
    bb36:	24 2b       	or	r18, r20
    bb38:	25 2b       	or	r18, r21
    bb3a:	21 f4       	brne	.+8      	; 0xbb44 <__fp_cmp+0x3e>
    bb3c:	08 95       	ret
    bb3e:	0a 26       	eor	r0, r26
    bb40:	09 f4       	brne	.+2      	; 0xbb44 <__fp_cmp+0x3e>
    bb42:	a1 40       	sbci	r26, 0x01	; 1
    bb44:	a6 95       	lsr	r26
    bb46:	8f ef       	ldi	r24, 0xFF	; 255
    bb48:	81 1d       	adc	r24, r1
    bb4a:	81 1d       	adc	r24, r1
    bb4c:	08 95       	ret

0000bb4e <__fp_inf>:
    bb4e:	97 f9       	bld	r25, 7
    bb50:	9f 67       	ori	r25, 0x7F	; 127
    bb52:	80 e8       	ldi	r24, 0x80	; 128
    bb54:	70 e0       	ldi	r23, 0x00	; 0
    bb56:	60 e0       	ldi	r22, 0x00	; 0
    bb58:	08 95       	ret

0000bb5a <__fp_nan>:
    bb5a:	9f ef       	ldi	r25, 0xFF	; 255
    bb5c:	80 ec       	ldi	r24, 0xC0	; 192
    bb5e:	08 95       	ret

0000bb60 <__fp_pscA>:
    bb60:	00 24       	eor	r0, r0
    bb62:	0a 94       	dec	r0
    bb64:	16 16       	cp	r1, r22
    bb66:	17 06       	cpc	r1, r23
    bb68:	18 06       	cpc	r1, r24
    bb6a:	09 06       	cpc	r0, r25
    bb6c:	08 95       	ret

0000bb6e <__fp_pscB>:
    bb6e:	00 24       	eor	r0, r0
    bb70:	0a 94       	dec	r0
    bb72:	12 16       	cp	r1, r18
    bb74:	13 06       	cpc	r1, r19
    bb76:	14 06       	cpc	r1, r20
    bb78:	05 06       	cpc	r0, r21
    bb7a:	08 95       	ret

0000bb7c <__fp_round>:
    bb7c:	09 2e       	mov	r0, r25
    bb7e:	03 94       	inc	r0
    bb80:	00 0c       	add	r0, r0
    bb82:	11 f4       	brne	.+4      	; 0xbb88 <__fp_round+0xc>
    bb84:	88 23       	and	r24, r24
    bb86:	52 f0       	brmi	.+20     	; 0xbb9c <__fp_round+0x20>
    bb88:	bb 0f       	add	r27, r27
    bb8a:	40 f4       	brcc	.+16     	; 0xbb9c <__fp_round+0x20>
    bb8c:	bf 2b       	or	r27, r31
    bb8e:	11 f4       	brne	.+4      	; 0xbb94 <__fp_round+0x18>
    bb90:	60 ff       	sbrs	r22, 0
    bb92:	04 c0       	rjmp	.+8      	; 0xbb9c <__fp_round+0x20>
    bb94:	6f 5f       	subi	r22, 0xFF	; 255
    bb96:	7f 4f       	sbci	r23, 0xFF	; 255
    bb98:	8f 4f       	sbci	r24, 0xFF	; 255
    bb9a:	9f 4f       	sbci	r25, 0xFF	; 255
    bb9c:	08 95       	ret

0000bb9e <__fp_split3>:
    bb9e:	57 fd       	sbrc	r21, 7
    bba0:	90 58       	subi	r25, 0x80	; 128
    bba2:	44 0f       	add	r20, r20
    bba4:	55 1f       	adc	r21, r21
    bba6:	59 f0       	breq	.+22     	; 0xbbbe <__fp_splitA+0x10>
    bba8:	5f 3f       	cpi	r21, 0xFF	; 255
    bbaa:	71 f0       	breq	.+28     	; 0xbbc8 <__fp_splitA+0x1a>
    bbac:	47 95       	ror	r20

0000bbae <__fp_splitA>:
    bbae:	88 0f       	add	r24, r24
    bbb0:	97 fb       	bst	r25, 7
    bbb2:	99 1f       	adc	r25, r25
    bbb4:	61 f0       	breq	.+24     	; 0xbbce <__fp_splitA+0x20>
    bbb6:	9f 3f       	cpi	r25, 0xFF	; 255
    bbb8:	79 f0       	breq	.+30     	; 0xbbd8 <__fp_splitA+0x2a>
    bbba:	87 95       	ror	r24
    bbbc:	08 95       	ret
    bbbe:	12 16       	cp	r1, r18
    bbc0:	13 06       	cpc	r1, r19
    bbc2:	14 06       	cpc	r1, r20
    bbc4:	55 1f       	adc	r21, r21
    bbc6:	f2 cf       	rjmp	.-28     	; 0xbbac <__fp_split3+0xe>
    bbc8:	46 95       	lsr	r20
    bbca:	f1 df       	rcall	.-30     	; 0xbbae <__fp_splitA>
    bbcc:	08 c0       	rjmp	.+16     	; 0xbbde <__fp_splitA+0x30>
    bbce:	16 16       	cp	r1, r22
    bbd0:	17 06       	cpc	r1, r23
    bbd2:	18 06       	cpc	r1, r24
    bbd4:	99 1f       	adc	r25, r25
    bbd6:	f1 cf       	rjmp	.-30     	; 0xbbba <__fp_splitA+0xc>
    bbd8:	86 95       	lsr	r24
    bbda:	71 05       	cpc	r23, r1
    bbdc:	61 05       	cpc	r22, r1
    bbde:	08 94       	sec
    bbe0:	08 95       	ret

0000bbe2 <__fp_zero>:
    bbe2:	e8 94       	clt

0000bbe4 <__fp_szero>:
    bbe4:	bb 27       	eor	r27, r27
    bbe6:	66 27       	eor	r22, r22
    bbe8:	77 27       	eor	r23, r23
    bbea:	cb 01       	movw	r24, r22
    bbec:	97 f9       	bld	r25, 7
    bbee:	08 95       	ret

0000bbf0 <__gesf2>:
    bbf0:	8a df       	rcall	.-236    	; 0xbb06 <__fp_cmp>
    bbf2:	08 f4       	brcc	.+2      	; 0xbbf6 <__gesf2+0x6>
    bbf4:	8f ef       	ldi	r24, 0xFF	; 255
    bbf6:	08 95       	ret

0000bbf8 <__mulsf3>:
    bbf8:	0b d0       	rcall	.+22     	; 0xbc10 <__mulsf3x>
    bbfa:	c0 cf       	rjmp	.-128    	; 0xbb7c <__fp_round>
    bbfc:	b1 df       	rcall	.-158    	; 0xbb60 <__fp_pscA>
    bbfe:	28 f0       	brcs	.+10     	; 0xbc0a <__mulsf3+0x12>
    bc00:	b6 df       	rcall	.-148    	; 0xbb6e <__fp_pscB>
    bc02:	18 f0       	brcs	.+6      	; 0xbc0a <__mulsf3+0x12>
    bc04:	95 23       	and	r25, r21
    bc06:	09 f0       	breq	.+2      	; 0xbc0a <__mulsf3+0x12>
    bc08:	a2 cf       	rjmp	.-188    	; 0xbb4e <__fp_inf>
    bc0a:	a7 cf       	rjmp	.-178    	; 0xbb5a <__fp_nan>
    bc0c:	11 24       	eor	r1, r1
    bc0e:	ea cf       	rjmp	.-44     	; 0xbbe4 <__fp_szero>

0000bc10 <__mulsf3x>:
    bc10:	c6 df       	rcall	.-116    	; 0xbb9e <__fp_split3>
    bc12:	a0 f3       	brcs	.-24     	; 0xbbfc <__mulsf3+0x4>

0000bc14 <__mulsf3_pse>:
    bc14:	95 9f       	mul	r25, r21
    bc16:	d1 f3       	breq	.-12     	; 0xbc0c <__mulsf3+0x14>
    bc18:	95 0f       	add	r25, r21
    bc1a:	50 e0       	ldi	r21, 0x00	; 0
    bc1c:	55 1f       	adc	r21, r21
    bc1e:	62 9f       	mul	r22, r18
    bc20:	f0 01       	movw	r30, r0
    bc22:	72 9f       	mul	r23, r18
    bc24:	bb 27       	eor	r27, r27
    bc26:	f0 0d       	add	r31, r0
    bc28:	b1 1d       	adc	r27, r1
    bc2a:	63 9f       	mul	r22, r19
    bc2c:	aa 27       	eor	r26, r26
    bc2e:	f0 0d       	add	r31, r0
    bc30:	b1 1d       	adc	r27, r1
    bc32:	aa 1f       	adc	r26, r26
    bc34:	64 9f       	mul	r22, r20
    bc36:	66 27       	eor	r22, r22
    bc38:	b0 0d       	add	r27, r0
    bc3a:	a1 1d       	adc	r26, r1
    bc3c:	66 1f       	adc	r22, r22
    bc3e:	82 9f       	mul	r24, r18
    bc40:	22 27       	eor	r18, r18
    bc42:	b0 0d       	add	r27, r0
    bc44:	a1 1d       	adc	r26, r1
    bc46:	62 1f       	adc	r22, r18
    bc48:	73 9f       	mul	r23, r19
    bc4a:	b0 0d       	add	r27, r0
    bc4c:	a1 1d       	adc	r26, r1
    bc4e:	62 1f       	adc	r22, r18
    bc50:	83 9f       	mul	r24, r19
    bc52:	a0 0d       	add	r26, r0
    bc54:	61 1d       	adc	r22, r1
    bc56:	22 1f       	adc	r18, r18
    bc58:	74 9f       	mul	r23, r20
    bc5a:	33 27       	eor	r19, r19
    bc5c:	a0 0d       	add	r26, r0
    bc5e:	61 1d       	adc	r22, r1
    bc60:	23 1f       	adc	r18, r19
    bc62:	84 9f       	mul	r24, r20
    bc64:	60 0d       	add	r22, r0
    bc66:	21 1d       	adc	r18, r1
    bc68:	82 2f       	mov	r24, r18
    bc6a:	76 2f       	mov	r23, r22
    bc6c:	6a 2f       	mov	r22, r26
    bc6e:	11 24       	eor	r1, r1
    bc70:	9f 57       	subi	r25, 0x7F	; 127
    bc72:	50 40       	sbci	r21, 0x00	; 0
    bc74:	8a f0       	brmi	.+34     	; 0xbc98 <__mulsf3_pse+0x84>
    bc76:	e1 f0       	breq	.+56     	; 0xbcb0 <__mulsf3_pse+0x9c>
    bc78:	88 23       	and	r24, r24
    bc7a:	4a f0       	brmi	.+18     	; 0xbc8e <__mulsf3_pse+0x7a>
    bc7c:	ee 0f       	add	r30, r30
    bc7e:	ff 1f       	adc	r31, r31
    bc80:	bb 1f       	adc	r27, r27
    bc82:	66 1f       	adc	r22, r22
    bc84:	77 1f       	adc	r23, r23
    bc86:	88 1f       	adc	r24, r24
    bc88:	91 50       	subi	r25, 0x01	; 1
    bc8a:	50 40       	sbci	r21, 0x00	; 0
    bc8c:	a9 f7       	brne	.-22     	; 0xbc78 <__mulsf3_pse+0x64>
    bc8e:	9e 3f       	cpi	r25, 0xFE	; 254
    bc90:	51 05       	cpc	r21, r1
    bc92:	70 f0       	brcs	.+28     	; 0xbcb0 <__mulsf3_pse+0x9c>
    bc94:	5c cf       	rjmp	.-328    	; 0xbb4e <__fp_inf>
    bc96:	a6 cf       	rjmp	.-180    	; 0xbbe4 <__fp_szero>
    bc98:	5f 3f       	cpi	r21, 0xFF	; 255
    bc9a:	ec f3       	brlt	.-6      	; 0xbc96 <__mulsf3_pse+0x82>
    bc9c:	98 3e       	cpi	r25, 0xE8	; 232
    bc9e:	dc f3       	brlt	.-10     	; 0xbc96 <__mulsf3_pse+0x82>
    bca0:	86 95       	lsr	r24
    bca2:	77 95       	ror	r23
    bca4:	67 95       	ror	r22
    bca6:	b7 95       	ror	r27
    bca8:	f7 95       	ror	r31
    bcaa:	e7 95       	ror	r30
    bcac:	9f 5f       	subi	r25, 0xFF	; 255
    bcae:	c1 f7       	brne	.-16     	; 0xbca0 <__mulsf3_pse+0x8c>
    bcb0:	fe 2b       	or	r31, r30
    bcb2:	88 0f       	add	r24, r24
    bcb4:	91 1d       	adc	r25, r1
    bcb6:	96 95       	lsr	r25
    bcb8:	87 95       	ror	r24
    bcba:	97 f9       	bld	r25, 7
    bcbc:	08 95       	ret

0000bcbe <__mulsi3>:
    bcbe:	62 9f       	mul	r22, r18
    bcc0:	d0 01       	movw	r26, r0
    bcc2:	73 9f       	mul	r23, r19
    bcc4:	f0 01       	movw	r30, r0
    bcc6:	82 9f       	mul	r24, r18
    bcc8:	e0 0d       	add	r30, r0
    bcca:	f1 1d       	adc	r31, r1
    bccc:	64 9f       	mul	r22, r20
    bcce:	e0 0d       	add	r30, r0
    bcd0:	f1 1d       	adc	r31, r1
    bcd2:	92 9f       	mul	r25, r18
    bcd4:	f0 0d       	add	r31, r0
    bcd6:	83 9f       	mul	r24, r19
    bcd8:	f0 0d       	add	r31, r0
    bcda:	74 9f       	mul	r23, r20
    bcdc:	f0 0d       	add	r31, r0
    bcde:	65 9f       	mul	r22, r21
    bce0:	f0 0d       	add	r31, r0
    bce2:	99 27       	eor	r25, r25
    bce4:	72 9f       	mul	r23, r18
    bce6:	b0 0d       	add	r27, r0
    bce8:	e1 1d       	adc	r30, r1
    bcea:	f9 1f       	adc	r31, r25
    bcec:	63 9f       	mul	r22, r19
    bcee:	b0 0d       	add	r27, r0
    bcf0:	e1 1d       	adc	r30, r1
    bcf2:	f9 1f       	adc	r31, r25
    bcf4:	bd 01       	movw	r22, r26
    bcf6:	cf 01       	movw	r24, r30
    bcf8:	11 24       	eor	r1, r1
    bcfa:	08 95       	ret

0000bcfc <__udivmodhi4>:
    bcfc:	aa 1b       	sub	r26, r26
    bcfe:	bb 1b       	sub	r27, r27
    bd00:	51 e1       	ldi	r21, 0x11	; 17
    bd02:	07 c0       	rjmp	.+14     	; 0xbd12 <__udivmodhi4_ep>

0000bd04 <__udivmodhi4_loop>:
    bd04:	aa 1f       	adc	r26, r26
    bd06:	bb 1f       	adc	r27, r27
    bd08:	a6 17       	cp	r26, r22
    bd0a:	b7 07       	cpc	r27, r23
    bd0c:	10 f0       	brcs	.+4      	; 0xbd12 <__udivmodhi4_ep>
    bd0e:	a6 1b       	sub	r26, r22
    bd10:	b7 0b       	sbc	r27, r23

0000bd12 <__udivmodhi4_ep>:
    bd12:	88 1f       	adc	r24, r24
    bd14:	99 1f       	adc	r25, r25
    bd16:	5a 95       	dec	r21
    bd18:	a9 f7       	brne	.-22     	; 0xbd04 <__udivmodhi4_loop>
    bd1a:	80 95       	com	r24
    bd1c:	90 95       	com	r25
    bd1e:	bc 01       	movw	r22, r24
    bd20:	cd 01       	movw	r24, r26
    bd22:	08 95       	ret

0000bd24 <__divmodhi4>:
    bd24:	97 fb       	bst	r25, 7
    bd26:	09 2e       	mov	r0, r25
    bd28:	07 26       	eor	r0, r23
    bd2a:	0a d0       	rcall	.+20     	; 0xbd40 <__divmodhi4_neg1>
    bd2c:	77 fd       	sbrc	r23, 7
    bd2e:	04 d0       	rcall	.+8      	; 0xbd38 <__divmodhi4_neg2>
    bd30:	e5 df       	rcall	.-54     	; 0xbcfc <__udivmodhi4>
    bd32:	06 d0       	rcall	.+12     	; 0xbd40 <__divmodhi4_neg1>
    bd34:	00 20       	and	r0, r0
    bd36:	1a f4       	brpl	.+6      	; 0xbd3e <__divmodhi4_exit>

0000bd38 <__divmodhi4_neg2>:
    bd38:	70 95       	com	r23
    bd3a:	61 95       	neg	r22
    bd3c:	7f 4f       	sbci	r23, 0xFF	; 255

0000bd3e <__divmodhi4_exit>:
    bd3e:	08 95       	ret

0000bd40 <__divmodhi4_neg1>:
    bd40:	f6 f7       	brtc	.-4      	; 0xbd3e <__divmodhi4_exit>
    bd42:	90 95       	com	r25
    bd44:	81 95       	neg	r24
    bd46:	9f 4f       	sbci	r25, 0xFF	; 255
    bd48:	08 95       	ret

0000bd4a <__udivmodsi4>:
    bd4a:	a1 e2       	ldi	r26, 0x21	; 33
    bd4c:	1a 2e       	mov	r1, r26
    bd4e:	aa 1b       	sub	r26, r26
    bd50:	bb 1b       	sub	r27, r27
    bd52:	fd 01       	movw	r30, r26
    bd54:	0d c0       	rjmp	.+26     	; 0xbd70 <__udivmodsi4_ep>

0000bd56 <__udivmodsi4_loop>:
    bd56:	aa 1f       	adc	r26, r26
    bd58:	bb 1f       	adc	r27, r27
    bd5a:	ee 1f       	adc	r30, r30
    bd5c:	ff 1f       	adc	r31, r31
    bd5e:	a2 17       	cp	r26, r18
    bd60:	b3 07       	cpc	r27, r19
    bd62:	e4 07       	cpc	r30, r20
    bd64:	f5 07       	cpc	r31, r21
    bd66:	20 f0       	brcs	.+8      	; 0xbd70 <__udivmodsi4_ep>
    bd68:	a2 1b       	sub	r26, r18
    bd6a:	b3 0b       	sbc	r27, r19
    bd6c:	e4 0b       	sbc	r30, r20
    bd6e:	f5 0b       	sbc	r31, r21

0000bd70 <__udivmodsi4_ep>:
    bd70:	66 1f       	adc	r22, r22
    bd72:	77 1f       	adc	r23, r23
    bd74:	88 1f       	adc	r24, r24
    bd76:	99 1f       	adc	r25, r25
    bd78:	1a 94       	dec	r1
    bd7a:	69 f7       	brne	.-38     	; 0xbd56 <__udivmodsi4_loop>
    bd7c:	60 95       	com	r22
    bd7e:	70 95       	com	r23
    bd80:	80 95       	com	r24
    bd82:	90 95       	com	r25
    bd84:	9b 01       	movw	r18, r22
    bd86:	ac 01       	movw	r20, r24
    bd88:	bd 01       	movw	r22, r26
    bd8a:	cf 01       	movw	r24, r30
    bd8c:	08 95       	ret

0000bd8e <__divmodsi4>:
    bd8e:	97 fb       	bst	r25, 7
    bd90:	09 2e       	mov	r0, r25
    bd92:	05 26       	eor	r0, r21
    bd94:	0e d0       	rcall	.+28     	; 0xbdb2 <__divmodsi4_neg1>
    bd96:	57 fd       	sbrc	r21, 7
    bd98:	04 d0       	rcall	.+8      	; 0xbda2 <__divmodsi4_neg2>
    bd9a:	d7 df       	rcall	.-82     	; 0xbd4a <__udivmodsi4>
    bd9c:	0a d0       	rcall	.+20     	; 0xbdb2 <__divmodsi4_neg1>
    bd9e:	00 1c       	adc	r0, r0
    bda0:	38 f4       	brcc	.+14     	; 0xbdb0 <__divmodsi4_exit>

0000bda2 <__divmodsi4_neg2>:
    bda2:	50 95       	com	r21
    bda4:	40 95       	com	r20
    bda6:	30 95       	com	r19
    bda8:	21 95       	neg	r18
    bdaa:	3f 4f       	sbci	r19, 0xFF	; 255
    bdac:	4f 4f       	sbci	r20, 0xFF	; 255
    bdae:	5f 4f       	sbci	r21, 0xFF	; 255

0000bdb0 <__divmodsi4_exit>:
    bdb0:	08 95       	ret

0000bdb2 <__divmodsi4_neg1>:
    bdb2:	f6 f7       	brtc	.-4      	; 0xbdb0 <__divmodsi4_exit>
    bdb4:	90 95       	com	r25
    bdb6:	80 95       	com	r24
    bdb8:	70 95       	com	r23
    bdba:	61 95       	neg	r22
    bdbc:	7f 4f       	sbci	r23, 0xFF	; 255
    bdbe:	8f 4f       	sbci	r24, 0xFF	; 255
    bdc0:	9f 4f       	sbci	r25, 0xFF	; 255
    bdc2:	08 95       	ret

0000bdc4 <__prologue_saves__>:
    bdc4:	2f 92       	push	r2
    bdc6:	3f 92       	push	r3
    bdc8:	4f 92       	push	r4
    bdca:	5f 92       	push	r5
    bdcc:	6f 92       	push	r6
    bdce:	7f 92       	push	r7
    bdd0:	8f 92       	push	r8
    bdd2:	9f 92       	push	r9
    bdd4:	af 92       	push	r10
    bdd6:	bf 92       	push	r11
    bdd8:	cf 92       	push	r12
    bdda:	df 92       	push	r13
    bddc:	ef 92       	push	r14
    bdde:	ff 92       	push	r15
    bde0:	0f 93       	push	r16
    bde2:	1f 93       	push	r17
    bde4:	cf 93       	push	r28
    bde6:	df 93       	push	r29
    bde8:	cd b7       	in	r28, 0x3d	; 61
    bdea:	de b7       	in	r29, 0x3e	; 62
    bdec:	ca 1b       	sub	r28, r26
    bdee:	db 0b       	sbc	r29, r27
    bdf0:	cd bf       	out	0x3d, r28	; 61
    bdf2:	de bf       	out	0x3e, r29	; 62
    bdf4:	19 94       	eijmp

0000bdf6 <__epilogue_restores__>:
    bdf6:	2a 88       	ldd	r2, Y+18	; 0x12
    bdf8:	39 88       	ldd	r3, Y+17	; 0x11
    bdfa:	48 88       	ldd	r4, Y+16	; 0x10
    bdfc:	5f 84       	ldd	r5, Y+15	; 0x0f
    bdfe:	6e 84       	ldd	r6, Y+14	; 0x0e
    be00:	7d 84       	ldd	r7, Y+13	; 0x0d
    be02:	8c 84       	ldd	r8, Y+12	; 0x0c
    be04:	9b 84       	ldd	r9, Y+11	; 0x0b
    be06:	aa 84       	ldd	r10, Y+10	; 0x0a
    be08:	b9 84       	ldd	r11, Y+9	; 0x09
    be0a:	c8 84       	ldd	r12, Y+8	; 0x08
    be0c:	df 80       	ldd	r13, Y+7	; 0x07
    be0e:	ee 80       	ldd	r14, Y+6	; 0x06
    be10:	fd 80       	ldd	r15, Y+5	; 0x05
    be12:	0c 81       	ldd	r16, Y+4	; 0x04
    be14:	1b 81       	ldd	r17, Y+3	; 0x03
    be16:	aa 81       	ldd	r26, Y+2	; 0x02
    be18:	b9 81       	ldd	r27, Y+1	; 0x01
    be1a:	ce 0f       	add	r28, r30
    be1c:	d1 1d       	adc	r29, r1
    be1e:	cd bf       	out	0x3d, r28	; 61
    be20:	de bf       	out	0x3e, r29	; 62
    be22:	ed 01       	movw	r28, r26
    be24:	08 95       	ret

0000be26 <strcpy_P>:
    be26:	fb 01       	movw	r30, r22
    be28:	dc 01       	movw	r26, r24
    be2a:	05 90       	lpm	r0, Z+
    be2c:	0d 92       	st	X+, r0
    be2e:	00 20       	and	r0, r0
    be30:	e1 f7       	brne	.-8      	; 0xbe2a <strcpy_P+0x4>
    be32:	08 95       	ret

0000be34 <memmove>:
    be34:	68 17       	cp	r22, r24
    be36:	79 07       	cpc	r23, r25
    be38:	68 f4       	brcc	.+26     	; 0xbe54 <memmove+0x20>
    be3a:	fb 01       	movw	r30, r22
    be3c:	dc 01       	movw	r26, r24
    be3e:	e4 0f       	add	r30, r20
    be40:	f5 1f       	adc	r31, r21
    be42:	a4 0f       	add	r26, r20
    be44:	b5 1f       	adc	r27, r21
    be46:	02 c0       	rjmp	.+4      	; 0xbe4c <memmove+0x18>
    be48:	02 90       	ld	r0, -Z
    be4a:	0e 92       	st	-X, r0
    be4c:	41 50       	subi	r20, 0x01	; 1
    be4e:	50 40       	sbci	r21, 0x00	; 0
    be50:	d8 f7       	brcc	.-10     	; 0xbe48 <memmove+0x14>
    be52:	08 95       	ret
    be54:	0c 94 8b 61 	jmp	0xc316	; 0xc316 <memcpy>

0000be58 <strcat>:
    be58:	fb 01       	movw	r30, r22
    be5a:	dc 01       	movw	r26, r24
    be5c:	0d 90       	ld	r0, X+
    be5e:	00 20       	and	r0, r0
    be60:	e9 f7       	brne	.-6      	; 0xbe5c <strcat+0x4>
    be62:	11 97       	sbiw	r26, 0x01	; 1
    be64:	01 90       	ld	r0, Z+
    be66:	0d 92       	st	X+, r0
    be68:	00 20       	and	r0, r0
    be6a:	e1 f7       	brne	.-8      	; 0xbe64 <strcat+0xc>
    be6c:	08 95       	ret

0000be6e <strcpy>:
    be6e:	fb 01       	movw	r30, r22
    be70:	dc 01       	movw	r26, r24
    be72:	01 90       	ld	r0, Z+
    be74:	0d 92       	st	X+, r0
    be76:	00 20       	and	r0, r0
    be78:	e1 f7       	brne	.-8      	; 0xbe72 <strcpy+0x4>
    be7a:	08 95       	ret

0000be7c <strncmp>:
    be7c:	fb 01       	movw	r30, r22
    be7e:	dc 01       	movw	r26, r24
    be80:	41 50       	subi	r20, 0x01	; 1
    be82:	50 40       	sbci	r21, 0x00	; 0
    be84:	30 f0       	brcs	.+12     	; 0xbe92 <strncmp+0x16>
    be86:	8d 91       	ld	r24, X+
    be88:	01 90       	ld	r0, Z+
    be8a:	80 19       	sub	r24, r0
    be8c:	19 f4       	brne	.+6      	; 0xbe94 <strncmp+0x18>
    be8e:	00 20       	and	r0, r0
    be90:	b9 f7       	brne	.-18     	; 0xbe80 <strncmp+0x4>
    be92:	88 1b       	sub	r24, r24
    be94:	99 0b       	sbc	r25, r25
    be96:	08 95       	ret

0000be98 <itoa>:
    be98:	fb 01       	movw	r30, r22
    be9a:	9f 01       	movw	r18, r30
    be9c:	e8 94       	clt
    be9e:	42 30       	cpi	r20, 0x02	; 2
    bea0:	c4 f0       	brlt	.+48     	; 0xbed2 <itoa+0x3a>
    bea2:	45 32       	cpi	r20, 0x25	; 37
    bea4:	b4 f4       	brge	.+44     	; 0xbed2 <itoa+0x3a>
    bea6:	4a 30       	cpi	r20, 0x0A	; 10
    bea8:	29 f4       	brne	.+10     	; 0xbeb4 <itoa+0x1c>
    beaa:	97 fb       	bst	r25, 7
    beac:	1e f4       	brtc	.+6      	; 0xbeb4 <itoa+0x1c>
    beae:	90 95       	com	r25
    beb0:	81 95       	neg	r24
    beb2:	9f 4f       	sbci	r25, 0xFF	; 255
    beb4:	64 2f       	mov	r22, r20
    beb6:	77 27       	eor	r23, r23
    beb8:	0e 94 7e 5e 	call	0xbcfc	; 0xbcfc <__udivmodhi4>
    bebc:	80 5d       	subi	r24, 0xD0	; 208
    bebe:	8a 33       	cpi	r24, 0x3A	; 58
    bec0:	0c f0       	brlt	.+2      	; 0xbec4 <itoa+0x2c>
    bec2:	89 5d       	subi	r24, 0xD9	; 217
    bec4:	81 93       	st	Z+, r24
    bec6:	cb 01       	movw	r24, r22
    bec8:	00 97       	sbiw	r24, 0x00	; 0
    beca:	a1 f7       	brne	.-24     	; 0xbeb4 <itoa+0x1c>
    becc:	16 f4       	brtc	.+4      	; 0xbed2 <itoa+0x3a>
    bece:	5d e2       	ldi	r21, 0x2D	; 45
    bed0:	51 93       	st	Z+, r21
    bed2:	10 82       	st	Z, r1
    bed4:	c9 01       	movw	r24, r18
    bed6:	0c 94 9f 61 	jmp	0xc33e	; 0xc33e <strrev>

0000beda <printf>:
    beda:	cf 93       	push	r28
    bedc:	df 93       	push	r29
    bede:	cd b7       	in	r28, 0x3d	; 61
    bee0:	de b7       	in	r29, 0x3e	; 62
    bee2:	fe 01       	movw	r30, r28
    bee4:	36 96       	adiw	r30, 0x06	; 6
    bee6:	61 91       	ld	r22, Z+
    bee8:	71 91       	ld	r23, Z+
    beea:	80 91 e7 50 	lds	r24, 0x50E7
    beee:	90 91 e8 50 	lds	r25, 0x50E8
    bef2:	af 01       	movw	r20, r30
    bef4:	0e 94 7f 5f 	call	0xbefe	; 0xbefe <vfprintf>
    bef8:	df 91       	pop	r29
    befa:	cf 91       	pop	r28
    befc:	08 95       	ret

0000befe <vfprintf>:
    befe:	2f 92       	push	r2
    bf00:	3f 92       	push	r3
    bf02:	4f 92       	push	r4
    bf04:	5f 92       	push	r5
    bf06:	6f 92       	push	r6
    bf08:	7f 92       	push	r7
    bf0a:	8f 92       	push	r8
    bf0c:	9f 92       	push	r9
    bf0e:	af 92       	push	r10
    bf10:	bf 92       	push	r11
    bf12:	cf 92       	push	r12
    bf14:	df 92       	push	r13
    bf16:	ef 92       	push	r14
    bf18:	ff 92       	push	r15
    bf1a:	0f 93       	push	r16
    bf1c:	1f 93       	push	r17
    bf1e:	cf 93       	push	r28
    bf20:	df 93       	push	r29
    bf22:	cd b7       	in	r28, 0x3d	; 61
    bf24:	de b7       	in	r29, 0x3e	; 62
    bf26:	2d 97       	sbiw	r28, 0x0d	; 13
    bf28:	cd bf       	out	0x3d, r28	; 61
    bf2a:	de bf       	out	0x3e, r29	; 62
    bf2c:	3c 01       	movw	r6, r24
    bf2e:	6c 87       	std	Y+12, r22	; 0x0c
    bf30:	7d 87       	std	Y+13, r23	; 0x0d
    bf32:	5a 01       	movw	r10, r20
    bf34:	fc 01       	movw	r30, r24
    bf36:	16 82       	std	Z+6, r1	; 0x06
    bf38:	17 82       	std	Z+7, r1	; 0x07
    bf3a:	83 81       	ldd	r24, Z+3	; 0x03
    bf3c:	81 ff       	sbrs	r24, 1
    bf3e:	c8 c1       	rjmp	.+912    	; 0xc2d0 <vfprintf+0x3d2>
    bf40:	2e 01       	movw	r4, r28
    bf42:	08 94       	sec
    bf44:	41 1c       	adc	r4, r1
    bf46:	51 1c       	adc	r5, r1
    bf48:	f3 01       	movw	r30, r6
    bf4a:	93 81       	ldd	r25, Z+3	; 0x03
    bf4c:	ec 85       	ldd	r30, Y+12	; 0x0c
    bf4e:	fd 85       	ldd	r31, Y+13	; 0x0d
    bf50:	93 fd       	sbrc	r25, 3
    bf52:	85 91       	lpm	r24, Z+
    bf54:	93 ff       	sbrs	r25, 3
    bf56:	81 91       	ld	r24, Z+
    bf58:	ec 87       	std	Y+12, r30	; 0x0c
    bf5a:	fd 87       	std	Y+13, r31	; 0x0d
    bf5c:	88 23       	and	r24, r24
    bf5e:	09 f4       	brne	.+2      	; 0xbf62 <vfprintf+0x64>
    bf60:	b3 c1       	rjmp	.+870    	; 0xc2c8 <vfprintf+0x3ca>
    bf62:	85 32       	cpi	r24, 0x25	; 37
    bf64:	41 f4       	brne	.+16     	; 0xbf76 <vfprintf+0x78>
    bf66:	93 fd       	sbrc	r25, 3
    bf68:	85 91       	lpm	r24, Z+
    bf6a:	93 ff       	sbrs	r25, 3
    bf6c:	81 91       	ld	r24, Z+
    bf6e:	ec 87       	std	Y+12, r30	; 0x0c
    bf70:	fd 87       	std	Y+13, r31	; 0x0d
    bf72:	85 32       	cpi	r24, 0x25	; 37
    bf74:	29 f4       	brne	.+10     	; 0xbf80 <vfprintf+0x82>
    bf76:	90 e0       	ldi	r25, 0x00	; 0
    bf78:	b3 01       	movw	r22, r6
    bf7a:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    bf7e:	e4 cf       	rjmp	.-56     	; 0xbf48 <vfprintf+0x4a>
    bf80:	ff 24       	eor	r15, r15
    bf82:	ee 24       	eor	r14, r14
    bf84:	10 e0       	ldi	r17, 0x00	; 0
    bf86:	10 32       	cpi	r17, 0x20	; 32
    bf88:	b0 f4       	brcc	.+44     	; 0xbfb6 <vfprintf+0xb8>
    bf8a:	8b 32       	cpi	r24, 0x2B	; 43
    bf8c:	69 f0       	breq	.+26     	; 0xbfa8 <vfprintf+0xaa>
    bf8e:	8c 32       	cpi	r24, 0x2C	; 44
    bf90:	28 f4       	brcc	.+10     	; 0xbf9c <vfprintf+0x9e>
    bf92:	80 32       	cpi	r24, 0x20	; 32
    bf94:	51 f0       	breq	.+20     	; 0xbfaa <vfprintf+0xac>
    bf96:	83 32       	cpi	r24, 0x23	; 35
    bf98:	71 f4       	brne	.+28     	; 0xbfb6 <vfprintf+0xb8>
    bf9a:	0b c0       	rjmp	.+22     	; 0xbfb2 <vfprintf+0xb4>
    bf9c:	8d 32       	cpi	r24, 0x2D	; 45
    bf9e:	39 f0       	breq	.+14     	; 0xbfae <vfprintf+0xb0>
    bfa0:	80 33       	cpi	r24, 0x30	; 48
    bfa2:	49 f4       	brne	.+18     	; 0xbfb6 <vfprintf+0xb8>
    bfa4:	11 60       	ori	r17, 0x01	; 1
    bfa6:	2c c0       	rjmp	.+88     	; 0xc000 <vfprintf+0x102>
    bfa8:	12 60       	ori	r17, 0x02	; 2
    bfaa:	14 60       	ori	r17, 0x04	; 4
    bfac:	29 c0       	rjmp	.+82     	; 0xc000 <vfprintf+0x102>
    bfae:	18 60       	ori	r17, 0x08	; 8
    bfb0:	27 c0       	rjmp	.+78     	; 0xc000 <vfprintf+0x102>
    bfb2:	10 61       	ori	r17, 0x10	; 16
    bfb4:	25 c0       	rjmp	.+74     	; 0xc000 <vfprintf+0x102>
    bfb6:	17 fd       	sbrc	r17, 7
    bfb8:	2e c0       	rjmp	.+92     	; 0xc016 <vfprintf+0x118>
    bfba:	28 2f       	mov	r18, r24
    bfbc:	20 53       	subi	r18, 0x30	; 48
    bfbe:	2a 30       	cpi	r18, 0x0A	; 10
    bfc0:	98 f4       	brcc	.+38     	; 0xbfe8 <vfprintf+0xea>
    bfc2:	16 ff       	sbrs	r17, 6
    bfc4:	08 c0       	rjmp	.+16     	; 0xbfd6 <vfprintf+0xd8>
    bfc6:	8f 2d       	mov	r24, r15
    bfc8:	88 0f       	add	r24, r24
    bfca:	f8 2e       	mov	r15, r24
    bfcc:	ff 0c       	add	r15, r15
    bfce:	ff 0c       	add	r15, r15
    bfd0:	f8 0e       	add	r15, r24
    bfd2:	f2 0e       	add	r15, r18
    bfd4:	15 c0       	rjmp	.+42     	; 0xc000 <vfprintf+0x102>
    bfd6:	8e 2d       	mov	r24, r14
    bfd8:	88 0f       	add	r24, r24
    bfda:	e8 2e       	mov	r14, r24
    bfdc:	ee 0c       	add	r14, r14
    bfde:	ee 0c       	add	r14, r14
    bfe0:	e8 0e       	add	r14, r24
    bfe2:	e2 0e       	add	r14, r18
    bfe4:	10 62       	ori	r17, 0x20	; 32
    bfe6:	0c c0       	rjmp	.+24     	; 0xc000 <vfprintf+0x102>
    bfe8:	8e 32       	cpi	r24, 0x2E	; 46
    bfea:	21 f4       	brne	.+8      	; 0xbff4 <vfprintf+0xf6>
    bfec:	16 fd       	sbrc	r17, 6
    bfee:	6c c1       	rjmp	.+728    	; 0xc2c8 <vfprintf+0x3ca>
    bff0:	10 64       	ori	r17, 0x40	; 64
    bff2:	06 c0       	rjmp	.+12     	; 0xc000 <vfprintf+0x102>
    bff4:	8c 36       	cpi	r24, 0x6C	; 108
    bff6:	11 f4       	brne	.+4      	; 0xbffc <vfprintf+0xfe>
    bff8:	10 68       	ori	r17, 0x80	; 128
    bffa:	02 c0       	rjmp	.+4      	; 0xc000 <vfprintf+0x102>
    bffc:	88 36       	cpi	r24, 0x68	; 104
    bffe:	59 f4       	brne	.+22     	; 0xc016 <vfprintf+0x118>
    c000:	ec 85       	ldd	r30, Y+12	; 0x0c
    c002:	fd 85       	ldd	r31, Y+13	; 0x0d
    c004:	93 fd       	sbrc	r25, 3
    c006:	85 91       	lpm	r24, Z+
    c008:	93 ff       	sbrs	r25, 3
    c00a:	81 91       	ld	r24, Z+
    c00c:	ec 87       	std	Y+12, r30	; 0x0c
    c00e:	fd 87       	std	Y+13, r31	; 0x0d
    c010:	88 23       	and	r24, r24
    c012:	09 f0       	breq	.+2      	; 0xc016 <vfprintf+0x118>
    c014:	b8 cf       	rjmp	.-144    	; 0xbf86 <vfprintf+0x88>
    c016:	98 2f       	mov	r25, r24
    c018:	95 54       	subi	r25, 0x45	; 69
    c01a:	93 30       	cpi	r25, 0x03	; 3
    c01c:	18 f0       	brcs	.+6      	; 0xc024 <vfprintf+0x126>
    c01e:	90 52       	subi	r25, 0x20	; 32
    c020:	93 30       	cpi	r25, 0x03	; 3
    c022:	38 f4       	brcc	.+14     	; 0xc032 <vfprintf+0x134>
    c024:	24 e0       	ldi	r18, 0x04	; 4
    c026:	30 e0       	ldi	r19, 0x00	; 0
    c028:	a2 0e       	add	r10, r18
    c02a:	b3 1e       	adc	r11, r19
    c02c:	3f e3       	ldi	r19, 0x3F	; 63
    c02e:	39 83       	std	Y+1, r19	; 0x01
    c030:	0f c0       	rjmp	.+30     	; 0xc050 <vfprintf+0x152>
    c032:	83 36       	cpi	r24, 0x63	; 99
    c034:	31 f0       	breq	.+12     	; 0xc042 <vfprintf+0x144>
    c036:	83 37       	cpi	r24, 0x73	; 115
    c038:	81 f0       	breq	.+32     	; 0xc05a <vfprintf+0x15c>
    c03a:	83 35       	cpi	r24, 0x53	; 83
    c03c:	09 f0       	breq	.+2      	; 0xc040 <vfprintf+0x142>
    c03e:	5a c0       	rjmp	.+180    	; 0xc0f4 <vfprintf+0x1f6>
    c040:	22 c0       	rjmp	.+68     	; 0xc086 <vfprintf+0x188>
    c042:	f5 01       	movw	r30, r10
    c044:	80 81       	ld	r24, Z
    c046:	89 83       	std	Y+1, r24	; 0x01
    c048:	22 e0       	ldi	r18, 0x02	; 2
    c04a:	30 e0       	ldi	r19, 0x00	; 0
    c04c:	a2 0e       	add	r10, r18
    c04e:	b3 1e       	adc	r11, r19
    c050:	21 e0       	ldi	r18, 0x01	; 1
    c052:	c2 2e       	mov	r12, r18
    c054:	d1 2c       	mov	r13, r1
    c056:	42 01       	movw	r8, r4
    c058:	14 c0       	rjmp	.+40     	; 0xc082 <vfprintf+0x184>
    c05a:	92 e0       	ldi	r25, 0x02	; 2
    c05c:	29 2e       	mov	r2, r25
    c05e:	31 2c       	mov	r3, r1
    c060:	2a 0c       	add	r2, r10
    c062:	3b 1c       	adc	r3, r11
    c064:	f5 01       	movw	r30, r10
    c066:	80 80       	ld	r8, Z
    c068:	91 80       	ldd	r9, Z+1	; 0x01
    c06a:	16 ff       	sbrs	r17, 6
    c06c:	03 c0       	rjmp	.+6      	; 0xc074 <vfprintf+0x176>
    c06e:	6f 2d       	mov	r22, r15
    c070:	70 e0       	ldi	r23, 0x00	; 0
    c072:	02 c0       	rjmp	.+4      	; 0xc078 <vfprintf+0x17a>
    c074:	6f ef       	ldi	r22, 0xFF	; 255
    c076:	7f ef       	ldi	r23, 0xFF	; 255
    c078:	c4 01       	movw	r24, r8
    c07a:	0e 94 94 61 	call	0xc328	; 0xc328 <strnlen>
    c07e:	6c 01       	movw	r12, r24
    c080:	51 01       	movw	r10, r2
    c082:	1f 77       	andi	r17, 0x7F	; 127
    c084:	15 c0       	rjmp	.+42     	; 0xc0b0 <vfprintf+0x1b2>
    c086:	82 e0       	ldi	r24, 0x02	; 2
    c088:	28 2e       	mov	r2, r24
    c08a:	31 2c       	mov	r3, r1
    c08c:	2a 0c       	add	r2, r10
    c08e:	3b 1c       	adc	r3, r11
    c090:	f5 01       	movw	r30, r10
    c092:	80 80       	ld	r8, Z
    c094:	91 80       	ldd	r9, Z+1	; 0x01
    c096:	16 ff       	sbrs	r17, 6
    c098:	03 c0       	rjmp	.+6      	; 0xc0a0 <vfprintf+0x1a2>
    c09a:	6f 2d       	mov	r22, r15
    c09c:	70 e0       	ldi	r23, 0x00	; 0
    c09e:	02 c0       	rjmp	.+4      	; 0xc0a4 <vfprintf+0x1a6>
    c0a0:	6f ef       	ldi	r22, 0xFF	; 255
    c0a2:	7f ef       	ldi	r23, 0xFF	; 255
    c0a4:	c4 01       	movw	r24, r8
    c0a6:	0e 94 80 61 	call	0xc300	; 0xc300 <strnlen_P>
    c0aa:	6c 01       	movw	r12, r24
    c0ac:	10 68       	ori	r17, 0x80	; 128
    c0ae:	51 01       	movw	r10, r2
    c0b0:	13 fd       	sbrc	r17, 3
    c0b2:	1c c0       	rjmp	.+56     	; 0xc0ec <vfprintf+0x1ee>
    c0b4:	06 c0       	rjmp	.+12     	; 0xc0c2 <vfprintf+0x1c4>
    c0b6:	80 e2       	ldi	r24, 0x20	; 32
    c0b8:	90 e0       	ldi	r25, 0x00	; 0
    c0ba:	b3 01       	movw	r22, r6
    c0bc:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c0c0:	ea 94       	dec	r14
    c0c2:	8e 2d       	mov	r24, r14
    c0c4:	90 e0       	ldi	r25, 0x00	; 0
    c0c6:	c8 16       	cp	r12, r24
    c0c8:	d9 06       	cpc	r13, r25
    c0ca:	a8 f3       	brcs	.-22     	; 0xc0b6 <vfprintf+0x1b8>
    c0cc:	0f c0       	rjmp	.+30     	; 0xc0ec <vfprintf+0x1ee>
    c0ce:	f4 01       	movw	r30, r8
    c0d0:	17 fd       	sbrc	r17, 7
    c0d2:	85 91       	lpm	r24, Z+
    c0d4:	17 ff       	sbrs	r17, 7
    c0d6:	81 91       	ld	r24, Z+
    c0d8:	4f 01       	movw	r8, r30
    c0da:	90 e0       	ldi	r25, 0x00	; 0
    c0dc:	b3 01       	movw	r22, r6
    c0de:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c0e2:	e1 10       	cpse	r14, r1
    c0e4:	ea 94       	dec	r14
    c0e6:	08 94       	sec
    c0e8:	c1 08       	sbc	r12, r1
    c0ea:	d1 08       	sbc	r13, r1
    c0ec:	c1 14       	cp	r12, r1
    c0ee:	d1 04       	cpc	r13, r1
    c0f0:	71 f7       	brne	.-36     	; 0xc0ce <vfprintf+0x1d0>
    c0f2:	e7 c0       	rjmp	.+462    	; 0xc2c2 <vfprintf+0x3c4>
    c0f4:	84 36       	cpi	r24, 0x64	; 100
    c0f6:	11 f0       	breq	.+4      	; 0xc0fc <vfprintf+0x1fe>
    c0f8:	89 36       	cpi	r24, 0x69	; 105
    c0fa:	51 f5       	brne	.+84     	; 0xc150 <vfprintf+0x252>
    c0fc:	f5 01       	movw	r30, r10
    c0fe:	17 ff       	sbrs	r17, 7
    c100:	07 c0       	rjmp	.+14     	; 0xc110 <vfprintf+0x212>
    c102:	80 81       	ld	r24, Z
    c104:	91 81       	ldd	r25, Z+1	; 0x01
    c106:	a2 81       	ldd	r26, Z+2	; 0x02
    c108:	b3 81       	ldd	r27, Z+3	; 0x03
    c10a:	24 e0       	ldi	r18, 0x04	; 4
    c10c:	30 e0       	ldi	r19, 0x00	; 0
    c10e:	08 c0       	rjmp	.+16     	; 0xc120 <vfprintf+0x222>
    c110:	80 81       	ld	r24, Z
    c112:	91 81       	ldd	r25, Z+1	; 0x01
    c114:	aa 27       	eor	r26, r26
    c116:	97 fd       	sbrc	r25, 7
    c118:	a0 95       	com	r26
    c11a:	ba 2f       	mov	r27, r26
    c11c:	22 e0       	ldi	r18, 0x02	; 2
    c11e:	30 e0       	ldi	r19, 0x00	; 0
    c120:	a2 0e       	add	r10, r18
    c122:	b3 1e       	adc	r11, r19
    c124:	01 2f       	mov	r16, r17
    c126:	0f 76       	andi	r16, 0x6F	; 111
    c128:	b7 ff       	sbrs	r27, 7
    c12a:	08 c0       	rjmp	.+16     	; 0xc13c <vfprintf+0x23e>
    c12c:	b0 95       	com	r27
    c12e:	a0 95       	com	r26
    c130:	90 95       	com	r25
    c132:	81 95       	neg	r24
    c134:	9f 4f       	sbci	r25, 0xFF	; 255
    c136:	af 4f       	sbci	r26, 0xFF	; 255
    c138:	bf 4f       	sbci	r27, 0xFF	; 255
    c13a:	00 68       	ori	r16, 0x80	; 128
    c13c:	bc 01       	movw	r22, r24
    c13e:	cd 01       	movw	r24, r26
    c140:	a2 01       	movw	r20, r4
    c142:	2a e0       	ldi	r18, 0x0A	; 10
    c144:	30 e0       	ldi	r19, 0x00	; 0
    c146:	0e 94 db 61 	call	0xc3b6	; 0xc3b6 <__ultoa_invert>
    c14a:	d8 2e       	mov	r13, r24
    c14c:	d4 18       	sub	r13, r4
    c14e:	3f c0       	rjmp	.+126    	; 0xc1ce <vfprintf+0x2d0>
    c150:	85 37       	cpi	r24, 0x75	; 117
    c152:	21 f4       	brne	.+8      	; 0xc15c <vfprintf+0x25e>
    c154:	1f 7e       	andi	r17, 0xEF	; 239
    c156:	2a e0       	ldi	r18, 0x0A	; 10
    c158:	30 e0       	ldi	r19, 0x00	; 0
    c15a:	20 c0       	rjmp	.+64     	; 0xc19c <vfprintf+0x29e>
    c15c:	19 7f       	andi	r17, 0xF9	; 249
    c15e:	8f 36       	cpi	r24, 0x6F	; 111
    c160:	a9 f0       	breq	.+42     	; 0xc18c <vfprintf+0x28e>
    c162:	80 37       	cpi	r24, 0x70	; 112
    c164:	20 f4       	brcc	.+8      	; 0xc16e <vfprintf+0x270>
    c166:	88 35       	cpi	r24, 0x58	; 88
    c168:	09 f0       	breq	.+2      	; 0xc16c <vfprintf+0x26e>
    c16a:	ae c0       	rjmp	.+348    	; 0xc2c8 <vfprintf+0x3ca>
    c16c:	0b c0       	rjmp	.+22     	; 0xc184 <vfprintf+0x286>
    c16e:	80 37       	cpi	r24, 0x70	; 112
    c170:	21 f0       	breq	.+8      	; 0xc17a <vfprintf+0x27c>
    c172:	88 37       	cpi	r24, 0x78	; 120
    c174:	09 f0       	breq	.+2      	; 0xc178 <vfprintf+0x27a>
    c176:	a8 c0       	rjmp	.+336    	; 0xc2c8 <vfprintf+0x3ca>
    c178:	01 c0       	rjmp	.+2      	; 0xc17c <vfprintf+0x27e>
    c17a:	10 61       	ori	r17, 0x10	; 16
    c17c:	14 ff       	sbrs	r17, 4
    c17e:	09 c0       	rjmp	.+18     	; 0xc192 <vfprintf+0x294>
    c180:	14 60       	ori	r17, 0x04	; 4
    c182:	07 c0       	rjmp	.+14     	; 0xc192 <vfprintf+0x294>
    c184:	14 ff       	sbrs	r17, 4
    c186:	08 c0       	rjmp	.+16     	; 0xc198 <vfprintf+0x29a>
    c188:	16 60       	ori	r17, 0x06	; 6
    c18a:	06 c0       	rjmp	.+12     	; 0xc198 <vfprintf+0x29a>
    c18c:	28 e0       	ldi	r18, 0x08	; 8
    c18e:	30 e0       	ldi	r19, 0x00	; 0
    c190:	05 c0       	rjmp	.+10     	; 0xc19c <vfprintf+0x29e>
    c192:	20 e1       	ldi	r18, 0x10	; 16
    c194:	30 e0       	ldi	r19, 0x00	; 0
    c196:	02 c0       	rjmp	.+4      	; 0xc19c <vfprintf+0x29e>
    c198:	20 e1       	ldi	r18, 0x10	; 16
    c19a:	32 e0       	ldi	r19, 0x02	; 2
    c19c:	f5 01       	movw	r30, r10
    c19e:	17 ff       	sbrs	r17, 7
    c1a0:	07 c0       	rjmp	.+14     	; 0xc1b0 <vfprintf+0x2b2>
    c1a2:	60 81       	ld	r22, Z
    c1a4:	71 81       	ldd	r23, Z+1	; 0x01
    c1a6:	82 81       	ldd	r24, Z+2	; 0x02
    c1a8:	93 81       	ldd	r25, Z+3	; 0x03
    c1aa:	44 e0       	ldi	r20, 0x04	; 4
    c1ac:	50 e0       	ldi	r21, 0x00	; 0
    c1ae:	06 c0       	rjmp	.+12     	; 0xc1bc <vfprintf+0x2be>
    c1b0:	60 81       	ld	r22, Z
    c1b2:	71 81       	ldd	r23, Z+1	; 0x01
    c1b4:	80 e0       	ldi	r24, 0x00	; 0
    c1b6:	90 e0       	ldi	r25, 0x00	; 0
    c1b8:	42 e0       	ldi	r20, 0x02	; 2
    c1ba:	50 e0       	ldi	r21, 0x00	; 0
    c1bc:	a4 0e       	add	r10, r20
    c1be:	b5 1e       	adc	r11, r21
    c1c0:	a2 01       	movw	r20, r4
    c1c2:	0e 94 db 61 	call	0xc3b6	; 0xc3b6 <__ultoa_invert>
    c1c6:	d8 2e       	mov	r13, r24
    c1c8:	d4 18       	sub	r13, r4
    c1ca:	01 2f       	mov	r16, r17
    c1cc:	0f 77       	andi	r16, 0x7F	; 127
    c1ce:	06 ff       	sbrs	r16, 6
    c1d0:	09 c0       	rjmp	.+18     	; 0xc1e4 <vfprintf+0x2e6>
    c1d2:	0e 7f       	andi	r16, 0xFE	; 254
    c1d4:	df 14       	cp	r13, r15
    c1d6:	30 f4       	brcc	.+12     	; 0xc1e4 <vfprintf+0x2e6>
    c1d8:	04 ff       	sbrs	r16, 4
    c1da:	06 c0       	rjmp	.+12     	; 0xc1e8 <vfprintf+0x2ea>
    c1dc:	02 fd       	sbrc	r16, 2
    c1de:	04 c0       	rjmp	.+8      	; 0xc1e8 <vfprintf+0x2ea>
    c1e0:	0f 7e       	andi	r16, 0xEF	; 239
    c1e2:	02 c0       	rjmp	.+4      	; 0xc1e8 <vfprintf+0x2ea>
    c1e4:	1d 2d       	mov	r17, r13
    c1e6:	01 c0       	rjmp	.+2      	; 0xc1ea <vfprintf+0x2ec>
    c1e8:	1f 2d       	mov	r17, r15
    c1ea:	80 2f       	mov	r24, r16
    c1ec:	90 e0       	ldi	r25, 0x00	; 0
    c1ee:	04 ff       	sbrs	r16, 4
    c1f0:	0c c0       	rjmp	.+24     	; 0xc20a <vfprintf+0x30c>
    c1f2:	fe 01       	movw	r30, r28
    c1f4:	ed 0d       	add	r30, r13
    c1f6:	f1 1d       	adc	r31, r1
    c1f8:	20 81       	ld	r18, Z
    c1fa:	20 33       	cpi	r18, 0x30	; 48
    c1fc:	11 f4       	brne	.+4      	; 0xc202 <vfprintf+0x304>
    c1fe:	09 7e       	andi	r16, 0xE9	; 233
    c200:	09 c0       	rjmp	.+18     	; 0xc214 <vfprintf+0x316>
    c202:	02 ff       	sbrs	r16, 2
    c204:	06 c0       	rjmp	.+12     	; 0xc212 <vfprintf+0x314>
    c206:	1e 5f       	subi	r17, 0xFE	; 254
    c208:	05 c0       	rjmp	.+10     	; 0xc214 <vfprintf+0x316>
    c20a:	86 78       	andi	r24, 0x86	; 134
    c20c:	90 70       	andi	r25, 0x00	; 0
    c20e:	00 97       	sbiw	r24, 0x00	; 0
    c210:	09 f0       	breq	.+2      	; 0xc214 <vfprintf+0x316>
    c212:	1f 5f       	subi	r17, 0xFF	; 255
    c214:	80 2e       	mov	r8, r16
    c216:	99 24       	eor	r9, r9
    c218:	03 fd       	sbrc	r16, 3
    c21a:	12 c0       	rjmp	.+36     	; 0xc240 <vfprintf+0x342>
    c21c:	00 ff       	sbrs	r16, 0
    c21e:	0d c0       	rjmp	.+26     	; 0xc23a <vfprintf+0x33c>
    c220:	fd 2c       	mov	r15, r13
    c222:	1e 15       	cp	r17, r14
    c224:	50 f4       	brcc	.+20     	; 0xc23a <vfprintf+0x33c>
    c226:	fe 0c       	add	r15, r14
    c228:	f1 1a       	sub	r15, r17
    c22a:	1e 2d       	mov	r17, r14
    c22c:	06 c0       	rjmp	.+12     	; 0xc23a <vfprintf+0x33c>
    c22e:	80 e2       	ldi	r24, 0x20	; 32
    c230:	90 e0       	ldi	r25, 0x00	; 0
    c232:	b3 01       	movw	r22, r6
    c234:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c238:	1f 5f       	subi	r17, 0xFF	; 255
    c23a:	1e 15       	cp	r17, r14
    c23c:	c0 f3       	brcs	.-16     	; 0xc22e <vfprintf+0x330>
    c23e:	04 c0       	rjmp	.+8      	; 0xc248 <vfprintf+0x34a>
    c240:	1e 15       	cp	r17, r14
    c242:	10 f4       	brcc	.+4      	; 0xc248 <vfprintf+0x34a>
    c244:	e1 1a       	sub	r14, r17
    c246:	01 c0       	rjmp	.+2      	; 0xc24a <vfprintf+0x34c>
    c248:	ee 24       	eor	r14, r14
    c24a:	84 fe       	sbrs	r8, 4
    c24c:	0f c0       	rjmp	.+30     	; 0xc26c <vfprintf+0x36e>
    c24e:	80 e3       	ldi	r24, 0x30	; 48
    c250:	90 e0       	ldi	r25, 0x00	; 0
    c252:	b3 01       	movw	r22, r6
    c254:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c258:	82 fe       	sbrs	r8, 2
    c25a:	1f c0       	rjmp	.+62     	; 0xc29a <vfprintf+0x39c>
    c25c:	81 fe       	sbrs	r8, 1
    c25e:	03 c0       	rjmp	.+6      	; 0xc266 <vfprintf+0x368>
    c260:	88 e5       	ldi	r24, 0x58	; 88
    c262:	90 e0       	ldi	r25, 0x00	; 0
    c264:	10 c0       	rjmp	.+32     	; 0xc286 <vfprintf+0x388>
    c266:	88 e7       	ldi	r24, 0x78	; 120
    c268:	90 e0       	ldi	r25, 0x00	; 0
    c26a:	0d c0       	rjmp	.+26     	; 0xc286 <vfprintf+0x388>
    c26c:	c4 01       	movw	r24, r8
    c26e:	86 78       	andi	r24, 0x86	; 134
    c270:	90 70       	andi	r25, 0x00	; 0
    c272:	00 97       	sbiw	r24, 0x00	; 0
    c274:	91 f0       	breq	.+36     	; 0xc29a <vfprintf+0x39c>
    c276:	81 fc       	sbrc	r8, 1
    c278:	02 c0       	rjmp	.+4      	; 0xc27e <vfprintf+0x380>
    c27a:	80 e2       	ldi	r24, 0x20	; 32
    c27c:	01 c0       	rjmp	.+2      	; 0xc280 <vfprintf+0x382>
    c27e:	8b e2       	ldi	r24, 0x2B	; 43
    c280:	07 fd       	sbrc	r16, 7
    c282:	8d e2       	ldi	r24, 0x2D	; 45
    c284:	90 e0       	ldi	r25, 0x00	; 0
    c286:	b3 01       	movw	r22, r6
    c288:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c28c:	06 c0       	rjmp	.+12     	; 0xc29a <vfprintf+0x39c>
    c28e:	80 e3       	ldi	r24, 0x30	; 48
    c290:	90 e0       	ldi	r25, 0x00	; 0
    c292:	b3 01       	movw	r22, r6
    c294:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c298:	fa 94       	dec	r15
    c29a:	df 14       	cp	r13, r15
    c29c:	c0 f3       	brcs	.-16     	; 0xc28e <vfprintf+0x390>
    c29e:	da 94       	dec	r13
    c2a0:	f2 01       	movw	r30, r4
    c2a2:	ed 0d       	add	r30, r13
    c2a4:	f1 1d       	adc	r31, r1
    c2a6:	80 81       	ld	r24, Z
    c2a8:	90 e0       	ldi	r25, 0x00	; 0
    c2aa:	b3 01       	movw	r22, r6
    c2ac:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c2b0:	dd 20       	and	r13, r13
    c2b2:	a9 f7       	brne	.-22     	; 0xc29e <vfprintf+0x3a0>
    c2b4:	06 c0       	rjmp	.+12     	; 0xc2c2 <vfprintf+0x3c4>
    c2b6:	80 e2       	ldi	r24, 0x20	; 32
    c2b8:	90 e0       	ldi	r25, 0x00	; 0
    c2ba:	b3 01       	movw	r22, r6
    c2bc:	0e 94 af 61 	call	0xc35e	; 0xc35e <fputc>
    c2c0:	ea 94       	dec	r14
    c2c2:	ee 20       	and	r14, r14
    c2c4:	c1 f7       	brne	.-16     	; 0xc2b6 <vfprintf+0x3b8>
    c2c6:	40 ce       	rjmp	.-896    	; 0xbf48 <vfprintf+0x4a>
    c2c8:	f3 01       	movw	r30, r6
    c2ca:	86 81       	ldd	r24, Z+6	; 0x06
    c2cc:	97 81       	ldd	r25, Z+7	; 0x07
    c2ce:	02 c0       	rjmp	.+4      	; 0xc2d4 <vfprintf+0x3d6>
    c2d0:	8f ef       	ldi	r24, 0xFF	; 255
    c2d2:	9f ef       	ldi	r25, 0xFF	; 255
    c2d4:	2d 96       	adiw	r28, 0x0d	; 13
    c2d6:	cd bf       	out	0x3d, r28	; 61
    c2d8:	de bf       	out	0x3e, r29	; 62
    c2da:	df 91       	pop	r29
    c2dc:	cf 91       	pop	r28
    c2de:	1f 91       	pop	r17
    c2e0:	0f 91       	pop	r16
    c2e2:	ff 90       	pop	r15
    c2e4:	ef 90       	pop	r14
    c2e6:	df 90       	pop	r13
    c2e8:	cf 90       	pop	r12
    c2ea:	bf 90       	pop	r11
    c2ec:	af 90       	pop	r10
    c2ee:	9f 90       	pop	r9
    c2f0:	8f 90       	pop	r8
    c2f2:	7f 90       	pop	r7
    c2f4:	6f 90       	pop	r6
    c2f6:	5f 90       	pop	r5
    c2f8:	4f 90       	pop	r4
    c2fa:	3f 90       	pop	r3
    c2fc:	2f 90       	pop	r2
    c2fe:	08 95       	ret

0000c300 <strnlen_P>:
    c300:	fc 01       	movw	r30, r24
    c302:	05 90       	lpm	r0, Z+
    c304:	61 50       	subi	r22, 0x01	; 1
    c306:	70 40       	sbci	r23, 0x00	; 0
    c308:	01 10       	cpse	r0, r1
    c30a:	d8 f7       	brcc	.-10     	; 0xc302 <strnlen_P+0x2>
    c30c:	80 95       	com	r24
    c30e:	90 95       	com	r25
    c310:	8e 0f       	add	r24, r30
    c312:	9f 1f       	adc	r25, r31
    c314:	08 95       	ret

0000c316 <memcpy>:
    c316:	fb 01       	movw	r30, r22
    c318:	dc 01       	movw	r26, r24
    c31a:	02 c0       	rjmp	.+4      	; 0xc320 <memcpy+0xa>
    c31c:	01 90       	ld	r0, Z+
    c31e:	0d 92       	st	X+, r0
    c320:	41 50       	subi	r20, 0x01	; 1
    c322:	50 40       	sbci	r21, 0x00	; 0
    c324:	d8 f7       	brcc	.-10     	; 0xc31c <memcpy+0x6>
    c326:	08 95       	ret

0000c328 <strnlen>:
    c328:	fc 01       	movw	r30, r24
    c32a:	61 50       	subi	r22, 0x01	; 1
    c32c:	70 40       	sbci	r23, 0x00	; 0
    c32e:	01 90       	ld	r0, Z+
    c330:	01 10       	cpse	r0, r1
    c332:	d8 f7       	brcc	.-10     	; 0xc32a <strnlen+0x2>
    c334:	80 95       	com	r24
    c336:	90 95       	com	r25
    c338:	8e 0f       	add	r24, r30
    c33a:	9f 1f       	adc	r25, r31
    c33c:	08 95       	ret

0000c33e <strrev>:
    c33e:	dc 01       	movw	r26, r24
    c340:	fc 01       	movw	r30, r24
    c342:	67 2f       	mov	r22, r23
    c344:	71 91       	ld	r23, Z+
    c346:	77 23       	and	r23, r23
    c348:	e1 f7       	brne	.-8      	; 0xc342 <strrev+0x4>
    c34a:	32 97       	sbiw	r30, 0x02	; 2
    c34c:	04 c0       	rjmp	.+8      	; 0xc356 <strrev+0x18>
    c34e:	7c 91       	ld	r23, X
    c350:	6d 93       	st	X+, r22
    c352:	70 83       	st	Z, r23
    c354:	62 91       	ld	r22, -Z
    c356:	ae 17       	cp	r26, r30
    c358:	bf 07       	cpc	r27, r31
    c35a:	c8 f3       	brcs	.-14     	; 0xc34e <strrev+0x10>
    c35c:	08 95       	ret

0000c35e <fputc>:
    c35e:	0f 93       	push	r16
    c360:	1f 93       	push	r17
    c362:	cf 93       	push	r28
    c364:	df 93       	push	r29
    c366:	8c 01       	movw	r16, r24
    c368:	eb 01       	movw	r28, r22
    c36a:	8b 81       	ldd	r24, Y+3	; 0x03
    c36c:	81 ff       	sbrs	r24, 1
    c36e:	1b c0       	rjmp	.+54     	; 0xc3a6 <fputc+0x48>
    c370:	82 ff       	sbrs	r24, 2
    c372:	0d c0       	rjmp	.+26     	; 0xc38e <fputc+0x30>
    c374:	2e 81       	ldd	r18, Y+6	; 0x06
    c376:	3f 81       	ldd	r19, Y+7	; 0x07
    c378:	8c 81       	ldd	r24, Y+4	; 0x04
    c37a:	9d 81       	ldd	r25, Y+5	; 0x05
    c37c:	28 17       	cp	r18, r24
    c37e:	39 07       	cpc	r19, r25
    c380:	64 f4       	brge	.+24     	; 0xc39a <fputc+0x3c>
    c382:	e8 81       	ld	r30, Y
    c384:	f9 81       	ldd	r31, Y+1	; 0x01
    c386:	01 93       	st	Z+, r16
    c388:	e8 83       	st	Y, r30
    c38a:	f9 83       	std	Y+1, r31	; 0x01
    c38c:	06 c0       	rjmp	.+12     	; 0xc39a <fputc+0x3c>
    c38e:	e8 85       	ldd	r30, Y+8	; 0x08
    c390:	f9 85       	ldd	r31, Y+9	; 0x09
    c392:	80 2f       	mov	r24, r16
    c394:	19 95       	eicall
    c396:	00 97       	sbiw	r24, 0x00	; 0
    c398:	31 f4       	brne	.+12     	; 0xc3a6 <fputc+0x48>
    c39a:	8e 81       	ldd	r24, Y+6	; 0x06
    c39c:	9f 81       	ldd	r25, Y+7	; 0x07
    c39e:	01 96       	adiw	r24, 0x01	; 1
    c3a0:	8e 83       	std	Y+6, r24	; 0x06
    c3a2:	9f 83       	std	Y+7, r25	; 0x07
    c3a4:	02 c0       	rjmp	.+4      	; 0xc3aa <fputc+0x4c>
    c3a6:	0f ef       	ldi	r16, 0xFF	; 255
    c3a8:	1f ef       	ldi	r17, 0xFF	; 255
    c3aa:	c8 01       	movw	r24, r16
    c3ac:	df 91       	pop	r29
    c3ae:	cf 91       	pop	r28
    c3b0:	1f 91       	pop	r17
    c3b2:	0f 91       	pop	r16
    c3b4:	08 95       	ret

0000c3b6 <__ultoa_invert>:
    c3b6:	fa 01       	movw	r30, r20
    c3b8:	aa 27       	eor	r26, r26
    c3ba:	28 30       	cpi	r18, 0x08	; 8
    c3bc:	51 f1       	breq	.+84     	; 0xc412 <__ultoa_invert+0x5c>
    c3be:	20 31       	cpi	r18, 0x10	; 16
    c3c0:	81 f1       	breq	.+96     	; 0xc422 <__ultoa_invert+0x6c>
    c3c2:	e8 94       	clt
    c3c4:	6f 93       	push	r22
    c3c6:	6e 7f       	andi	r22, 0xFE	; 254
    c3c8:	6e 5f       	subi	r22, 0xFE	; 254
    c3ca:	7f 4f       	sbci	r23, 0xFF	; 255
    c3cc:	8f 4f       	sbci	r24, 0xFF	; 255
    c3ce:	9f 4f       	sbci	r25, 0xFF	; 255
    c3d0:	af 4f       	sbci	r26, 0xFF	; 255
    c3d2:	b1 e0       	ldi	r27, 0x01	; 1
    c3d4:	3e d0       	rcall	.+124    	; 0xc452 <__ultoa_invert+0x9c>
    c3d6:	b4 e0       	ldi	r27, 0x04	; 4
    c3d8:	3c d0       	rcall	.+120    	; 0xc452 <__ultoa_invert+0x9c>
    c3da:	67 0f       	add	r22, r23
    c3dc:	78 1f       	adc	r23, r24
    c3de:	89 1f       	adc	r24, r25
    c3e0:	9a 1f       	adc	r25, r26
    c3e2:	a1 1d       	adc	r26, r1
    c3e4:	68 0f       	add	r22, r24
    c3e6:	79 1f       	adc	r23, r25
    c3e8:	8a 1f       	adc	r24, r26
    c3ea:	91 1d       	adc	r25, r1
    c3ec:	a1 1d       	adc	r26, r1
    c3ee:	6a 0f       	add	r22, r26
    c3f0:	71 1d       	adc	r23, r1
    c3f2:	81 1d       	adc	r24, r1
    c3f4:	91 1d       	adc	r25, r1
    c3f6:	a1 1d       	adc	r26, r1
    c3f8:	20 d0       	rcall	.+64     	; 0xc43a <__ultoa_invert+0x84>
    c3fa:	09 f4       	brne	.+2      	; 0xc3fe <__ultoa_invert+0x48>
    c3fc:	68 94       	set
    c3fe:	3f 91       	pop	r19
    c400:	2a e0       	ldi	r18, 0x0A	; 10
    c402:	26 9f       	mul	r18, r22
    c404:	11 24       	eor	r1, r1
    c406:	30 19       	sub	r19, r0
    c408:	30 5d       	subi	r19, 0xD0	; 208
    c40a:	31 93       	st	Z+, r19
    c40c:	de f6       	brtc	.-74     	; 0xc3c4 <__ultoa_invert+0xe>
    c40e:	cf 01       	movw	r24, r30
    c410:	08 95       	ret
    c412:	46 2f       	mov	r20, r22
    c414:	47 70       	andi	r20, 0x07	; 7
    c416:	40 5d       	subi	r20, 0xD0	; 208
    c418:	41 93       	st	Z+, r20
    c41a:	b3 e0       	ldi	r27, 0x03	; 3
    c41c:	0f d0       	rcall	.+30     	; 0xc43c <__ultoa_invert+0x86>
    c41e:	c9 f7       	brne	.-14     	; 0xc412 <__ultoa_invert+0x5c>
    c420:	f6 cf       	rjmp	.-20     	; 0xc40e <__ultoa_invert+0x58>
    c422:	46 2f       	mov	r20, r22
    c424:	4f 70       	andi	r20, 0x0F	; 15
    c426:	40 5d       	subi	r20, 0xD0	; 208
    c428:	4a 33       	cpi	r20, 0x3A	; 58
    c42a:	18 f0       	brcs	.+6      	; 0xc432 <__ultoa_invert+0x7c>
    c42c:	49 5d       	subi	r20, 0xD9	; 217
    c42e:	31 fd       	sbrc	r19, 1
    c430:	40 52       	subi	r20, 0x20	; 32
    c432:	41 93       	st	Z+, r20
    c434:	02 d0       	rcall	.+4      	; 0xc43a <__ultoa_invert+0x84>
    c436:	a9 f7       	brne	.-22     	; 0xc422 <__ultoa_invert+0x6c>
    c438:	ea cf       	rjmp	.-44     	; 0xc40e <__ultoa_invert+0x58>
    c43a:	b4 e0       	ldi	r27, 0x04	; 4
    c43c:	a6 95       	lsr	r26
    c43e:	97 95       	ror	r25
    c440:	87 95       	ror	r24
    c442:	77 95       	ror	r23
    c444:	67 95       	ror	r22
    c446:	ba 95       	dec	r27
    c448:	c9 f7       	brne	.-14     	; 0xc43c <__ultoa_invert+0x86>
    c44a:	00 97       	sbiw	r24, 0x00	; 0
    c44c:	61 05       	cpc	r22, r1
    c44e:	71 05       	cpc	r23, r1
    c450:	08 95       	ret
    c452:	9b 01       	movw	r18, r22
    c454:	ac 01       	movw	r20, r24
    c456:	0a 2e       	mov	r0, r26
    c458:	06 94       	lsr	r0
    c45a:	57 95       	ror	r21
    c45c:	47 95       	ror	r20
    c45e:	37 95       	ror	r19
    c460:	27 95       	ror	r18
    c462:	ba 95       	dec	r27
    c464:	c9 f7       	brne	.-14     	; 0xc458 <__ultoa_invert+0xa2>
    c466:	62 0f       	add	r22, r18
    c468:	73 1f       	adc	r23, r19
    c46a:	84 1f       	adc	r24, r20
    c46c:	95 1f       	adc	r25, r21
    c46e:	a0 1d       	adc	r26, r0
    c470:	08 95       	ret

0000c472 <_exit>:
    c472:	f8 94       	cli

0000c474 <__stop_program>:
    c474:	ff cf       	rjmp	.-2      	; 0xc474 <__stop_program>
